<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adam-p.ca/blog/2022/03/x-forwarded-for/">Original</a>
    <h1>The perils of the “real” client IP</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<h2 id="summary">
<a href="#summary">
##
</a>
Summary
</h2><p>This post ended up being incredibly <del>long</del> comprehensive. I’m afraid that many people won’t read enough to get everything that’s important, so here are the key points:</p><ul>
<li>
<p>When deriving the “real client IP address” from the <code>X-Forwarded-For</code> header, use the rightmost IP in the list.</p></li><li>
<p>The leftmost IP in the XFF header is commonly considered to be “closest to the client” and “most real”, but it’s trivially spoofable. Don’t use it for anything even close to security-related.</p></li><li>
<p>When choosing the rightmost XFF IP, make sure to use the <em>last</em> instance of that header.</p></li><li>
<p>Using special “true client IPs” set by reverse proxies (like <code>X-Real-IP</code>, <code>True-Client-IP</code>, etc.) <em>can</em> be good, but it depends on the a) how the reverse proxy actually sets it, b) whether the reverse proxy sets it if it’s already present/spoofed, and c) how you’ve configured the reverse proxy (sometimes).</p></li><li>
<p>Any header not specifically set by your reverse proxy cannot be trusted. For example, you <em>must not</em> check the <code>X-Real-IP</code> header if you’re not behind Nginx or something else that always sets it, because you’ll be reading a spoofed value.</p></li><li>
<p>A lot of rate limiter implementations are using spoofable IPs and are vulnerable to rate limiter escape and memory exhaustion attacks.</p></li></ul><p><em>If you use the “real client IP” anywhere in your code or infrastructure, you need to go check right now how you’re deriving it.</em></p><p>This is all explained in detail below, so keep reading. It’s a weird, scary, bumpy ride.</p><h2 id="introduction">
<a href="#introduction">
##
</a>
Introduction
</h2><p>The state of getting the “real client IP” using <code>X-Forwarded-For</code> and other HTTP headers is terrible. It’s done incorrectly, inconsistently, and the result is used inappropriately. This leads to security vulnerabilities in a variety of projects, and will certainly lead to more in the future.</p><p>After thinking about rate limiters for a while, I started worrying about their IPv6 handling. I <a href="https://adam-p.ca/blog/2022/02/ipv6-rate-limiting/">wrote a post</a> detailing how bad IPv6 rate limiting can and does lead to rate limiter escape and memory exhaustion. Then I moved on to worrying about how rate limiters determine what IP to rate-limit when they’re behind a load balancer (or any reverse proxy). As you’ll see, the situation is bad.</p><p>But this isn’t just about rate limiters. If you ever touch code that looks at the <code>X-Forwarded-For</code> header, or if you use someone else’s code that uses or gives you the “real client IP”, then you absolutely need to be savvy and wary. This post will help you get there.</p><p><strong>NOTE:</strong> Portions of this are redacted as I’m trying to disclose responsibly to the affected projects. Those portions will be added in as that projects choose to make the issues public. (So check back later!)</p><h2 id="it-cant-be-that-hard-to-get-the-real-client-ip-right">
<a href="#it-cant-be-that-hard-to-get-the-real-client-ip-right">
##
</a>
It can’t be that hard to get the real client IP, right?
</h2><p>There are many reasons why web services are interested in the IP address of their clients: geographical stats, geo-targeting, auditing, rate-limiting, abuse-blocking, session history, etc.</p><p>When a client directly connects to a server, the server can see the IP address of the client. If the client connects through one or more proxies (of any kind: forward, reverse, load balancer, API gateway, TLS offloading, IP access control, etc.), then the server only directly sees the IP address of the final proxy used by the client connection.</p><p>In order to pass the original IP address on to the server, there are several headers in common use:</p><ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"><code>X-Forwarded-For</code></a> is a list of comma-separated IPs that gets appended to by each traversed proxy<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. The idea is that the first IP (added by the first proxy) is the true client IP. Each subsequent IP is another proxy along the path. The last proxy’s IP is <em>not</em> present (because proxies don’t add their own IPs, and because it connects directly to the server so its IP will be directly available anyway). We’re going to talk about this a lot, so it’ll be abbreviated to “XFF”.</p></li><li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded"><code>Forwarded</code></a> is the most official but seemingly least-used header. We look at it in more detail <a href="#rfc-7239-forwarded-http-extension-june-2014">below</a>, but it’s really just a fancier version of XFF that has the same problems that we’re about to discuss.</p></li><li>
<p>There are also special single-IP headers like <code>X-Real-IP</code> (Nginx), <code>CF-Connecting-IP</code> (Cloudflare), or <code>True-Client-IP</code> (Cloudflare and Akamai). We’ll talk more about these below, but they’re not the main focus of this post.</p></li></ul><h2 id="pitfalls">
<a href="#pitfalls">
##
</a>
Pitfalls
</h2><p>Before talking about how to use XFF properly, we’ll talk about the many ways that using <code>X-Forwarded-For</code> can go wrong.</p><p>First of all, and most importantly, you must always be aware that <em>any XFF IPs that were added (or appear to have been added) by any proxy not controlled by you are completely unreliable</em>. Any proxy could have added, removed, or modified the header any way it wants. The client as well could have initially set the header to anything it wants to get the spoof-ball rolling. For example, if you make this request to an AWS load balancer<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>…</p><pre tabindex="0"><code>curl -X POST https://my.load.balanced.domain/login -H &#34;X-Forwarded-For: 1.2.3.4, 11.22.33.44&#34;
</code></pre><p>…your server behind the load balancer will get this:</p><pre tabindex="0"><code>X-Forwarded-For: 1.2.3.4, 11.22.33.44, &lt;actual client IP&gt;
</code></pre><p>And this:</p><pre tabindex="0"><code>curl -X POST https://my.load.balanced.domain/login -H &#34;X-Forwarded-For: oh, hi,,127.0.0.1,,,,&#34;
</code></pre><p>…will give you this:</p><pre tabindex="0"><code>X-Forwarded-For: oh, hi,,127.0.0.1,,,,, &lt;actual client IP&gt;
</code></pre><p>As you can see, everything already present is just passed through, unchanged and unvalidated. The final, actual IP is just appended to whatever is already there.</p><p>(In addition to curl’ing and custom clients, there is also at least one <a href="https://chrome.google.com/webstore/detail/x-forwarded-for-header/hkghghbnihliadkabmlcmcgmffllglin">Chrome extension</a> that lets you set the XFF header in browser requests. But <em>how</em> you can set the header doesn’t really matter to us here, only that an attacker can do it.)</p><p>According to the <a href="https://datatracker.ietf.org/doc/html/rfc2616#section-4.2">HTTP/1.1 RFC (2616)</a><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>:</p><blockquote>
<p>Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.</p></blockquote><p>That applies to XFF, as it is a comma-separated list. This can make getting the rightmost (or even leftmost) IP error-prone.</p><p>For example, Go has three ways to get a header value:</p><ul>
<li><a href="https://pkg.go.dev/net/http#Header.Get"><code>http.Header.Get(headerName)</code></a> returns the first header value as a string.</li><li><a href="https://pkg.go.dev/net/http#Header.Values"><code>http.Header.Values(headerName)</code></a> returns a slice (array) of strings with the values of all instances of the header <code>headerName</code>. (<code>headerName</code> is canonicalized before lookup.)</li><li><code>http.Header</code> is a <code>map[string][]string</code> and can be accessed directly. (The map keys are canonicalized header names.) This is similar to using <code>Values</code>.</li></ul><p>So here’s the attack:</p><ol>
<li>Eve makes a request with <em>two</em> spoofed XFF headers.</li><li>Your reverse proxy adds Eve’s true IP to the end of the <em>second</em> XFF header, per the RFC requirements.</li><li>You call <code>req.Header.Get(&#34;X-Forwarded-For&#34;)</code> and get the first header. You split it up and take the rightmost.</li><li>You have chosen a spoofed IP. You treat it as trustworthy. Bad things result.</li></ol><p>Unlike Go, Twisted’s method for getting a single header value <a href="https://github.com/twisted/twisted/blob/ebb2d360070e468981377b917e3a728ff4e6c7f6/src/twisted/web/http.py#L1068">returns the <em>last</em> value</a>. (Why is there no standard, common, accepted behaviour for this?) This avoids the above attack, but it can cause a different (less likely) problem: If you’re using the rightmost-ish algorithm (described <a href="#algorithms">below</a>), you need to go backwards from the right looking for the first untrusted IP. But what if one of your reverse proxies has added a new header instead of appending (a valid thing to do, per the RFC)? Now the IP that you want is nowhere to be found in the last header – it’s full of trusted reverse proxy IPs and the real IP is in a previous instance of the XFF header.</p><p>There might be a subtle, hypothetical attack possible here:</p><ol>
<li>You have (at least) two reverse proxies that you trust.</li><li>The second of those reverse proxies doesn’t like super long headers, so it creates a new one rather than appending if the XFF header is too long.</li><li>Eve knows this. And she wants to hide her IP from you.</li><li>Eve spoofs a long XFF in her request to you.</li><li>Your first reverse proxy adds her true IP to the XFF header.</li><li>Your second reverse proxy doesn’t like how long that header is, so it creates a new one. The header value is the IP of the first reverse proxy.</li><li>Your server software gets the last header and it has only a single IP, belonging to your first reverse proxy.</li><li>What does your logic do? Use that IP? Treat it as special because it’s private/trusted? Panic because it’s impossible that this IP should be trusted?</li></ol><p>Note that when I tested with a server behind AWS ALB I found that ALB had already concatenated the XFF headers. So that’s good. I have no idea if other reverse proxies do the same, but I bet there’s no real consistency.</p><p>The best thing to do is merge all of the XFF headers yourself.</p><p>(It is worthwhile asking – and checking – to make sure reverse proxies append to the correct header, because appending to the wrong header would wreck the trustworthiness of taking the rightmost. I have only checked AWS ALB and Cloudflare, and they’re doing it right. If anyone discovers something doing it wrong, please let me know.)</p><p>[2022-03-04: I created a <a href="https://github.com/golang/go/issues/51493">Go issue</a> arguing for a change to the behaviour of <code>http.Header.Get</code>. Not with any real expectation of a change, but we’ll see.]</p><h3 id="private-ips">
<a href="#private-ips">
###
</a>
Private IPs
</h3><p>Even in completely non-malicious scenarios, any of the XFF IPs – but especially the leftmost – may be a <a href="https://en.wikipedia.org/wiki/Private_network">private/internal IP address</a>. If the client first connects to an internal proxy, it may add the private IP of the client to the XFF header. This address is never going to be useful to you.</p><h3 id="splitting-the-ips">
<a href="#splitting-the-ips">
###
</a>
Splitting the IPs
</h3><p>Because <code>X-Forwarded-For</code> isn’t an official standard, there’s no formal spec for it. Most examples show the IP addresses comma-space (<code>&#34;, &#34;</code>) separated, but the space isn’t strictly required. (For example, the <a href="https://datatracker.ietf.org/doc/html/rfc2616#section-4.2">HTTP/1.1 RFC</a> says that headers <em>like</em> XFF are simply “comma separated”.) <em>Most</em> of the code I looked at splits by just comma and then trims the value, but at least <a href="https://github.com/go-chi/httprate/blob/463924d478ea0c19de7265b97371a59a7ebf5fdd/httprate.go#L33">one I found</a> looks for comma-space.</p><p>When testing, it looks to me like AWS ALB uses comma-space when adding an IP, but Cloudflare uses only a comma.</p><h3 id="unencrypted-data-is-always-untrustworthy">
<a href="#unencrypted-data-is-always-untrustworthy">
###
</a>
Unencrypted data is always untrustworthy
</h3><p>This should go without saying, but if you’re receiving HTTP-not-S requests, then anyone could have modified the headers before they got to you. This is worth mentioning because an interloper can’t mess with the “rightmost-ish” approach (described below) because they can’t mess with the IP of the final connection from the internet to your reverse proxy or server.</p><p>So just encrypt your traffic, okay?</p><h3 id="other-headers-x-client-ip-true-client-ip-might-be-present-and-spoofed">
<a href="#other-headers-x-client-ip-true-client-ip-might-be-present-and-spoofed">
###
</a>
Other headers (<code>X-Client-IP</code>, <code>True-Client-IP</code>) might be present and spoofed
</h3><p>Some reverse proxies remove any unexpected or unwanted headers, but some (like AWS ALB) don’t. So an attacker can set headers like <code>X-Client-IP</code> and <code>True-Client-IP</code> straight through to your server. You need to not get fooled into using them if your reverse proxy didn’t specifically set them for you.</p><h3 id="trying-to-learn-about-x-forwarded-for">
<a href="#trying-to-learn-about-x-forwarded-for">
###
</a>
Trying to learn about <code>X-Forwarded-For</code>
</h3><p>Trying to educate yourself about XFF is, unfortunately, also difficult.</p><p>MDN Web Docs are usually the gold standard for stuff like this, but <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For">the page about XFF</a> doesn’t mention these risks at all; it says “the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client” with no caveat. The <a href="https://en.wikipedia.org/wiki/X-Forwarded-For">Wikipedia entry</a> is much better: “Since it is easy to forge an X-Forwarded-For field the given information should be used with care. The right-most IP address is always the IP address that connects to the last proxy, which means it is the most reliable source of information.”</p><p>Other sources are similarly variable. Some say nothing whatsoever about the possibility of the header being spoofed or the presence of private addresses (<a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html">1</a>, <a href="https://techcommunity.microsoft.com/t5/iis-support-blog/how-to-use-x-forwarded-for-header-to-log-actual-client-ip/ba-p/873115">2</a>, <a href="https://www.geeksforgeeks.org/http-headers-x-forwarded-for/">3</a>, <a href="https://developers.cloudflare.com/fundamentals/get-started/http-request-headers/">4</a>, <a href="https://www.keycdn.com/blog/x-forwarded-for-cdn">5</a>). Others do a pretty good job of mentioning the risks (<a href="https://totaluptime.com/kb/prevent-x-forwarded-for-spoofing-or-manipulation/">6</a>, <a href="https://docs.fastly.com/signalsciences/faq/real-client-ip-addresses/#x-forwarded-for-header-configuration">7</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7239#section-8.1">8</a>), but sometimes you have to read pretty deeply to get to the warnings.</p><h2 id="avoiding-those-pits">
<a href="#avoiding-those-pits">
##
</a>
Avoiding those pits
</h2><p>Let’s make a few baseline statements:</p><ol>
<li>Using an IP in the private address space as the “real” client IP is never the right choice<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</li><li>Using a value that’s not actually an IP address is never the right choice.</li><li>In the absence of chicanery, the leftmost non-private, non-invalid IP is the closest we can come to the “real” client IP. (Henceforth, “leftmost-ish”.)</li><li>The only client IP that we can <em>trust</em> is the first one added by a (reverse) proxy that we control. (Henceforth, “rightmost-ish”.)</li></ol><p>The leftmost-ish is usually going to be the most “real”, while the rightmost-ish is going to be the most trustworthy. So which IP should you use? It depends on what you’re going to do with it.</p><p>If you’re going to do something security-related, you need to use the IP you trust – the rightmost-ish. The obvious example here is rate-limiting. If you use the leftmost-ish IP for this, an attacker can just spoof a different XFF prefix value with each request and <em>completely avoid being limited</em>.</p><p>Additionally, they might be able to exhaust your server memory by forcing you to store too many individual entries – one for each fake IP. It may seem hard to believe that storing IP addresses in memory could lead to exhaustion – especially if they’re stored in a cache with finite time-to-live, but keep in mind:</p><ul>
<li>The attacker won’t be limited to the 4 billion IPv4 addresses. They can use all the bazillion IPv6 addresses, if the limiter isn’t <a href="https://adam-p.ca/blog/2022/02/ipv6-rate-limiting/">smart about prefixes</a>.</li><li>Since many limiters don’t check for valid IPs, an attacker can use any random string it wants.</li><li>Also note that these strings can be <em>big</em>; for example, Go’s <a href="https://pkg.go.dev/net/http#pkg-constants">default header block size limit</a> is 1MB. That means a single random-string “IP” can be almost 1MB. That means adding 1MB of memory usage <em>per request</em>.</li></ul><p>It still won’t be feasible for all attackers and configurations, but it shouldn’t be dismissed without consideration.</p><p>Or an attacker can force you to rate-limit/block the IP addresses of other users. They can supply a real – but not their – IP address, and you’ll eventually be fooled into rate-limiting it. (And if you’re using the “real” IP for abuse reports, you might end up complaining about the wrong person.)</p><p>The downside to using the rightmost-ish IP for rate-limiting is that you might block a proxy IP that’s not actually a source of abuse but is just used by a bunch of different clients and you would have realized that if you’d just used the leftmost-ish instead. Yeah, well. That doesn’t seem super likely, and it’s still infinitely more acceptable than allowing attackers to trivially bypass your rate limiter and crash your server.</p><p>If you’re doing something not obviously security-related… Think hard about your use case. Let’s say you just want to do an <a href="https://en.wikipedia.org/wiki/Internet_geolocation">IP-geolocation</a> lookup for your stats. <em>Probably</em> the leftmost-ish IP is what you want. The vast majority of your users won’t be doing any header spoofing, and the geolocation of random internet proxies are no good to you, so you’ll <em>probably</em> get the best results with the IP closest to the user.</p><p>On the other hand, you might want to consider how many internet-proxy-using users you expect to have. Probably few enough that it won’t hurt your stats if you geolocate the wrong thing. And is there a way an attacker could hurt you by purposely skewing your geo stats? Probably not, but take a moment to really think about it.</p><p>So <em>be careful</em> when writing your “GetRealClientIP(request)” function. Make sure it has a big warning comment about how it should be used. Or maybe write two functions: “GetUntrustworthyRealClientIP(request)” and “GetTrustworthyButLessRealClientIP(request)”. Which are horrible names. Maybe just pass a flag instead. Anyway, the point is to prevent the callers of your functions from having any confusion about the nature of the result.</p><p>Also be careful when using the results of that function. It’s easy to write code that gets the leftmost-ish IP to do some geo lookup and then later decide you also need to do rate limiting… so you might as well use the same “realClientIP” variable! Oops. This might be a good time <a href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/">to make wrong code look wrong</a>.</p><p>And remember that the final proxy IP – or the address of the client if it’s connecting directly – is <em>not</em> in the XFF header. You need to look at your request connection information for that. (<code>http.Request.RemoteAddr</code> in Go, the <code>REMOTE_ADDR</code> environment variable for many CGI servers, etc.)</p><h3 id="algorithms">
<a href="#algorithms">
###
</a>
Algorithms
</h3><p>When reading this, remember that the final proxy IP is not in the XFF list – it’s the <code>RemoteAddr</code>. Also note that <code>RemoteAddr</code> might have the form <code>ip:port</code>, depending on your platform (like it does in Go) – sure sure to only use the IP part.</p><h4 id="first-collect-all-of-the-ips">
<a href="#first-collect-all-of-the-ips">
####
</a>
First: collect all of the IPs
</h4><p>Make a single list of all the IPs in all of the <code>X-Forwarded-For</code> headers.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> Also have the <code>RemoteAddr</code> available.</p><h4 id="second-decide-what-your-security-needs-are">
<a href="#second-decide-what-your-security-needs-are">
####
</a>
Second: decide what your security needs are
</h4><p>Default to using the rightmost-ish approach. Only use the leftmost-ish if you have to, and make sure you do so carefully.</p><h4 id="leftmost-ish-the-closest-to-the-real-ip-but-utterly-untrustworthy">
<a href="#leftmost-ish-the-closest-to-the-real-ip-but-utterly-untrustworthy">
####
</a>
Leftmost-ish: the closest to the “real IP”, but utterly untrustworthy
</h4><p>If your server is directly connected to the internet, there might be an XFF header or there might not be (depending on whether the client used a proxy). If there <em>is</em> an XFF header, pick the leftmost IP address that is a <em>valid, non-private</em> IPv4 or IPv6 address. If there is no XFF header, use the <code>RemoteAddr</code>.</p><p>If your server is behind one or more reverse proxies, pick the leftmost XFF IP address that is a <em>valid, non-private</em> IPv4 or IPv6 address. (If there’s no XFF header, you need to fix your network configuration problem <em>right now</em>.)</p><p>And never forget the security implications!</p><h4 id="rightmost-ish-the-only-useful-ip-you-can-trust">
<a href="#rightmost-ish-the-only-useful-ip-you-can-trust">
####
</a>
Rightmost-ish: the only useful IP you can trust
</h4><p>If your server is directly connected to the internet, the XFF header cannot be trusted, period. Use the <code>RemoteAddr</code>.</p><p>If your server is behind one or more reverse proxies and not directly accessible from the internet, you need to know either the IP addresses of those reverse proxies or the number of them that the request will pass through. We’ll call these the “trusted proxy IPs” and “trusted proxy count”. (Using “trusted proxy IPs” is preferable, for reasons described in the <a href="#network-architecture-changes">“network architecture changes” section</a>.)</p><p>The trusted proxy IPs or trusted proxy count will tell you how far from the right of the XFF header you need to check before you find the first IP that doesn’t belong to one of your reverse proxies. This IP was added by your first trusted proxy and is therefore the only IP you can trust. Use it.</p><p>(Notice that I’m not saying “valid, non-private IP” here. It is tempting to do so, just to be extra safe, and I won’t blame you if you do, but if you can’t trust your own reverse proxy to add the proper IP, then you have a bigger problem.)</p><p>Again, if you’re behind one or more reverse proxies and there’s no XFF header, you need to immediately figure out how people are connecting to your server directly.</p><h5 id="tentative-variation-rightmost-non-private-ip">
<a href="#tentative-variation-rightmost-non-private-ip">
#####
</a>
Tentative variation: rightmost non-private IP
</h5><p>If all of your reverse proxies are in the same private IP space as your server, I <em>think</em> it’s okay to use the rightmost non-private IP rather than using “trusted proxy IPs” or “trusted proxy count”. This is equivalent to adding all private IP ranges to your “trusted proxy IPs” list.</p><p>An example where this <em>doesn’t</em> work is if you’re behind an external reverse proxy service, like Cloudflare – it’s not in your private address space.</p><h2 id="falling-into-those-pits">
<a href="#falling-into-those-pits">
##
</a>
Falling into those pits
</h2><p>Let’s look at real-world examples!</p><p>Warning: I got a little carried away here. I was only intending to look at a couple of projects that I was familiar with, but the hit-rate of dangerous-use-of-leftmost was so high that I just kept searching. (And there were some interesting and educational aspects even when it was done right.)</p><p>(If a tool or service isn’t mentioned here, it’s because I either didn’t look at it or couldn’t find enough information about it. I included all successes as well as failures.)</p><h3 id="cloudflare-nginx-apache">
<a href="#cloudflare-nginx-apache">
###
</a>
Cloudflare, Nginx, Apache
</h3><p>Let’s start with some good news.</p><p><a href="https://support.cloudflare.com/hc/en-us/articles/206776727-Understanding-the-True-Client-IP-Header">Cloudflare adds</a> the <code>CF-Connecting-IP</code> header to all requests that pass through it; it adds <code>True-Client-IP</code> as a synonym for Enterprise users who require backwards compatibility. The value for these headers is a single IP address. The <a href="https://developers.cloudflare.com/fundamentals/get-started/http-request-headers/">fullest description</a> of these headers that I could find makes it <em>sound</em> like they are just using the leftmost XFF IP, but the example was sufficiently incomplete that I tried it out myself. Happily, it looks like they’re actually using the rightmost-ish.</p><p>Nginx offers a not-enabled-by-default module that <a href="https://nginx.org/en/docs/http/ngx_http_realip_module.html">adds the <code>X-Real-IP</code> header</a>. This is also a single IP. When properly and fully configured<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>, it also uses the rightmost IP that isn’t on the “trusted” list. So, the rightmost-ish IP. Also good.</p><p>Similarly, when configured to look at <code>X-Forwarded-For</code>, Apache’s <a href="https://httpd.apache.org/docs/trunk/mod/mod_remoteip.html">mod_remoteip</a> picks the rightmost untrusted IP to set into <code>REMOTE_ADDR</code>.</p><h3 id="akamai">
<a href="#akamai">
###
</a>
Akamai
</h3><p>Akamai does very wrong things, but at least warns about it. Here is <a href="https://community.akamai.com/customers/s/article/Difference-Between-Akamai-True-Client-IP-header-and-Default-X-Forwarded-For">the documentation</a> about how it handles <code>X-Forwarded-For</code> and <code>True-Client-IP</code> (original emphasis):</p><blockquote>
<p><code>X-Forwarded-For</code> header is the default header proxies use to report the end user IP that is requesting the content. However, this header is often overwritten by other proxies and is also overwritten by Akamai parent servers and thus are not very reliable.</p><p>The <code>True-Client-IP</code> header sent by Akamai does not get overwritten by proxy or Akamai servers and will contain the IP of the client when sending the request to the origin.</p><p><code>True-Client-IP</code> is a self provisioned feature enabled in the Property Manager.</p><p><em>Note that if the <code>True-Client-IP</code> header is already present in the request from the client it will not be overwritten or sent twice. It is not a security feature.</em></p><p>The connecting IP is appended to <code>X-Forwarded-For</code> header by proxy server and thus it can contain multiple IPs in the list with comma as separator. <code>True-Client-IP</code> contains only one IP. If the the end user uses proxy server to connect to Akamai edge server, <code>True-Client-IP</code> is the first IP from in <code>X-Forwarded-For</code> header. If the end user connects to Akamai edge server directly, <code>True-Client-IP</code> is the connecting public IP seen by Akamai.</p></blockquote><p>The relevant bits are “<code>True-Client-IP</code> is the first IP from in <code>X-Forwarded-For</code> header” and “if the True-Client-IP header is already present in the request from the client it will not be overwritten”. So <code>True-Client-IP</code> is either the leftmost XFF IP or keeps the original value spoofed by the client. Just the worst possible thing.</p><p>However, there is also the sentence “It is not a security feature.” Well, that’s certainly true. Does that warning make it okay? What’s the chance that there aren’t a ton of Akamai users out using <code>True-Client-IP</code> for security-related purposes?</p><p>(I’m not sure how to interpret the above when it says that the XFF header is “overwritten by Akamai parent servers”. Does it mean “appended to” when it says “overwritten”? Or is Akamai actually blowing away the existing header value? That would be against the spirit of XFF.)</p><h3 id="fastly">
<a href="#fastly">
###
</a>
Fastly
</h3><p>Fastly adds the <a href="https://developer.fastly.com/reference/http/http-headers/Fastly-Client-IP/"><code>Fastly-Client-IP</code></a> header with a single IP value. I <em>think</em> it’s using the rightmost-ish XFF IP:</p><blockquote>
<p>Essentially, <code>Fastly-Client-IP</code> is the non-Fastly thing that is making the request to Fastly.</p></blockquote><p><em>However</em>:</p><blockquote>
<p>The value is not protected from modification at the edge of the Fastly network, so if a client sets this header themselves, we will use it. If you want to prevent this [you need to do some additional configuration].</p></blockquote><p>So, by default <code>Fastly-Client-IP</code> is trivially spoofable. Again, it seems highly likely that there are a lot of people using its default behaviour for security-related purposes and making themselves vulnerable to attack.</p><h3 id="azure">
<a href="#azure">
###
</a>
Azure
</h3><p>Azure Front Door adds the <code>X-Azure-ClientIP</code> and <code>X-Azure-SocketIP</code> headers. They are <a href="https://docs.microsoft.com/en-us/azure/frontdoor/front-door-http-headers-protocol">described like so</a>:</p><blockquote>
<p><code>X-Azure-ClientIP</code>: Represents the client IP address associated with the request being processed. For example, a request coming from a proxy might add the <code>X-Forwarded-For</code> header to indicate the IP address of the original caller.</p><p><code>X-Azure-SocketIP</code>: Represents the socket IP address associated with the TCP connection that the current request originated from. A request’s client IP address might not be equal to its socket IP address because the client IP can be arbitrarily overwritten by a user.</p></blockquote><p>So, <code>X-Azure-ClientIP</code> is the leftmost-ish XFF IP and <code>X-Azure-SocketIP</code> is the rightmost-ish.</p><p>That’s reasonably good, but I think it could be a lot clearer. The only warning about <code>X-Azure-ClientIP</code> is a subtle hint in the description of the <em>other</em> header. I also hand-wavingly feel that the name of the less-secure header is more appealing than the more-secure one, and is probably leading many people into the wrong choice.</p><h3 id="go-chichi">
<a href="#go-chichi">
###
</a>
go-chi/chi
</h3><p>Chi is a Go HTTP router and provides a <a href="https://github.com/go-chi/chi/blob/c97bc988430d623a14f50b7019fb40529036a35a/middleware/realip.go#L42-L55">RealIP middleware</a> and a <a href="https://github.com/go-chi/httprate/blob/463924d478ea0c19de7265b97371a59a7ebf5fdd/httprate.go#L28-L37">rate limiter</a>. The RealIP middleware has this comment:</p><blockquote>
<p>You should only use this middleware if you can trust the headers passed to you (in particular, the two [three, actually] headers this middleware uses), for example because you have placed a reverse proxy like HAProxy or nginx in front of Chi. If your reverse proxies are configured to pass along arbitrary header values from the client, or if you use this middleware without a reverse proxy, malicious clients will be able to make you very sad (or, depending on how you’re using RemoteAddr, vulnerable to an attack of some sort).</p></blockquote><p>Which is a pretty good warning, right? Almost.</p><p>Let’s take this opportunity to talk about abusing <code>X-Real-IP</code>, <code>True-Client-IP</code>, etc. For example, AWS ALB “[passes] along arbitrary header values from the client” and, indeed, if you don’t realize that you will end up “very sad”. Because a request like this…</p><pre tabindex="0"><code>curl -X POST https://my.load.balanced.domain/login -H &#34;X-Forwarded-For:1.1.1.1&#34; -H &#34;X-Real-IP:2.2.2.2&#34; -H &#34;True-Client-IP:3.3.3.3&#34;
</code></pre><p>…results in your server getting these headers:</p><pre tabindex="0"><code>X-Forwarded-For: 1.1.1.1, &lt;actual client IP&gt;
X-Real-IP: 2.2.2.2
True-Client-IP: 3.3.3.3
</code></pre><p><code>chi.middleware.RealIP</code>’s logic goes like: “use the <code>True-Client-IP</code>; if that doesn’t exist, use the <code>X-Real-IP</code>; if that doesn’t exist, use <code>X-Forwarded-For</code>”. So it falls victim to header spoofing.</p><p>But, as we’ve learned, the <code>chi.middleware.RealIP</code> warning also isn’t good enough when it comes to <code>X-Forwarded-For</code> <em>because you can never, ever trust all of it</em><sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>. In the <code>RealIP</code> code, the logic I just paraphrased actually ends with “use the leftmost XFF IP address”. And we’re now suitably scared of using the leftmost XFF IP. (It also does not check that the leftmost “IP” is valid and non-private.)</p><p>So <code>chi.middleware.RealIP</code> falls firmly into the “only safe for non-security use” category. And you <em>must</em> be aware of its header preference order and what your reverse proxy does or doesn’t set and let through. In short, it’s hard to recommend it.</p><p>Chi’s rate limiter has identical logic for obtaining the IP address and doesn’t have the same warning. So that’s bad, for the reasons we’ve discussed – the non-XFF headers could be spoofed, the XFF header could be spoofed, the IP can be garbage, the rate limiter could be bypassed, your memory could be exploded. The best way to use it is to not use its “real IP” logic and instead write your own “GetTrustworthyClientIP(request)” and pass that to its <a href="https://github.com/go-chi/httprate/blob/463924d478ea0c19de7265b97371a59a7ebf5fdd/README.md?plain=1#L61">“rate limit by arbitrary keys”</a> feature.</p><p>Both RealIP and httprate are both using Go’s <code>http.Header.Get</code> to get the XFF header. As <a href="#multiple-headers">discussed above</a>, this means that switching to taking the rightmost-ish IP wouldn’t be sufficient, as an attacker could force the wrong header to be used.</p><p>Chi’s rate limiter is also the one instance I found of the XFF list being split by comma-space instead of just comma. I think that’s wrong.</p><p>[2022-03-03: Disclosed to maintainer via email. 2022-03-04: Maintainer requested that I <a href="https://github.com/go-chi/chi/issues/711">make an issue</a>.]</p><h3 id="didiptollbooth">
<a href="#didiptollbooth">
###
</a>
didip/tollbooth
</h3><p>The <a href="https://github.com/didip/tollbooth">Tollbooth HTTP rate limiter</a> is better, but you still need to be aware of what it’s doing in order to use it properly.</p><p>Its <a href="https://github.com/didip/tollbooth/blob/d2340101f440011dd593e8b6787f5b1a437c2516/README.md#L68-L70">README</a> says the order in which it looks for the “real” client IP address is…</p><blockquote>
<p>By default it’s: “RemoteAddr”, “X-Forwarded-For”, “X-Real-IP”</p></blockquote><p>Strangely, that default order isn’t actually the default everywhere. If you call <a href="https://github.com/didip/tollbooth/blob/e1a6b41b35e95810a7dce638996b15f136424ed2/limiter/limiter.go#L21"><code>limiter.New()</code></a> that <em>is</em> the default. But if you call <a href="https://github.com/didip/tollbooth/blob/2e5b779d07015e6a4386c6cc1a36612c17d54eb5/tollbooth.go#L33"><code>tollbooth.NewLimiter()</code></a> – “a convenience function to limiter.New” – the order is <code>&#34;X-Forwarded-For&#34;, &#34;X-Real-IP&#34;, &#34;RemoteAddr&#34;</code>. Which is an important difference!</p><p>It doesn’t make clear that it doesn’t support <code>CF-Connecting-IP</code>, <code>True-Client-IP</code>, or any other arbitrary header – <a href="https://github.com/didip/tollbooth/blob/2e5b779d07015e6a4386c6cc1a36612c17d54eb5/libstring/libstring.go#L20-L56">it just silently skips them</a> if you add them (returning empty string, leading to over-limiting).</p><p>This is a general problem with Tollbooth – it “fails open”: if it can’t find an IP to use <a href="https://github.com/didip/tollbooth/blob/2e5b779d07015e6a4386c6cc1a36612c17d54eb5/tollbooth.go#L51-L55">it doesn’t rate limit</a>. So if the user of the library misconfigures it (by trying to use an unsupported header, or even making a letter-case mistake in a supported on), it won’t rate limit at all and will give no indication of this. In a <a href="https://github.com/didip/tollbooth/pull/99#issuecomment-1059328777">comment on the PR to fix this</a> I give my opinion on how it should be have, but this is a pretty tricky problem.</p><p>Tollbooth also suffers from the <a href="#multiple-headers">“multiple headers”</a> problem – <a href="https://github.com/didip/tollbooth/blob/2e5b779d07015e6a4386c6cc1a36612c17d54eb5/libstring/libstring.go#L23">it uses</a> Go’s <code>r.Header.Get</code>. So, even though it’s counting from the rightmost, which is good, it’s doing so with the first header, which is bad.</p><p>Speaking of counting from the rightmost… If Tollbooth is configured to count very far from the right (like, <code>lmt.SetForwardedForIndexFromBehind(1000)</code>), then it will effectively take the leftmost IP (it <a href="https://github.com/didip/tollbooth/blob/2e5b779d07015e6a4386c6cc1a36612c17d54eb5/libstring/libstring.go#L42-L45">uses a minimum index of zero</a>). In that case, it should be doing <a href="#leftmost-ish-the-closest-to-the-real-ip-but-utterly-untrustworthy">“leftmost-ish”</a> IP validation.</p><p>There are two more things that bug me about tollbooth’s design. The first is that the ostensible default order has Go’s <code>http.Request.RemoteAddr</code> first. My understanding is that that field should never be empty (for an HTTP server, rather than client), so the rest of the list is guaranteed to be ignored. So why have a list? Also, if your server is behind a reverse proxy, <code>RemoteAddr</code> will be your proxy’s IP, which is useless.</p><p>The second thing that bugs me is going to get its very own section…</p><p>[2022-03-03: Disclosed to maintainer via email. 2022-03-04: Maintainer <a href="https://github.com/didip/tollbooth/pull/99">created a PR</a> to fix it. Ongoing discussion there.]</p><h3 id="a-default-list-of-places-to-look-for-the-client-ip-makes-no-sense">
<a href="#a-default-list-of-places-to-look-for-the-client-ip-makes-no-sense">
###
</a>
A default list of places to look for the client IP makes no sense
</h3><p>Where you should be looking for the “real” client IP is very specific to your network architecture and use case. A default configuration encourages blind, naïve use and will result in incorrect and potentially dangerous behaviour more often than not.</p><p>If you’re using Cloudflare you want <code>CF-Connecting-IP</code>. If you’re using <code>ngx_http_realip_module</code>, you want <code>X-Real-IP</code>. If you’re behind AWS ALB you want the rightmost-ish <code>X-Forwarded-For</code> IP. If you’re directly connected to the internet, you want <code>RemoteAddr</code> (or equivalent). And so on.</p><p>There’s <em>never</em> a time when you’re okay with just falling back across a big list of header values that have nothing to do with your network architecture. That’s going to bite you.</p><p>Even Tollbooth defaulting to using the rightmost XFF IP can be problematic. If your server is behind two layers of reverse proxies, then you’ll be looking at the IP of your first proxy instead of the client’s IP.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup> (What will probably happen is that you will rate-limit your proxy almost immediately, nothing gets through, and then you fix your config. But it still would have been better to be forced to think about the correct configuration in the first place.)</p><p>So, even though I know it’s not very user friendly, I don’t think that rate-limiting libraries should have any default at all, and instead should <em>require</em> explicit configuration.</p><h3 id="ululelimiter">
<a href="#ululelimiter">
###
</a>
ulule/limiter
</h3><p>Another Go rate limiter middleware. By default it doesn’t look at the XFF header, but if enabled it <a href="https://github.com/ulule/limiter/blob/9ba030af6009ca2bc9a285dbd815bc7a76de724a/network.go#L31-L56">uses the leftmost XFF IP</a>. The option is called “TrustForwardHeader”, but <em>you can never trust the XFF header</em>. So it falls victim to rate limit escape, etc.</p><p>It also uses Go’s <code>http.Header.Get</code>, so if it switches to rightmost-ish it will need to change how it gets the XFF header.</p><p>When <code>TrustForwardHeader</code> is true it first looks for XFF and then falls through to <code>X-Real-IP</code> and finally uses <code>RemoteAddr</code>. But as we just saw, “a default list of places to look for the client IP makes no sense”.</p><p>It returns <code>net.ParseIP(ip)</code> rather than just the raw string. This seems good at first, but <code>net.ParseIP</code> <a href="https://pkg.go.dev/net#ParseIP">returns nil</a> if the parse fails. So in the case of a garbage string, ulule/limiter doesn’t check for the failure, returns nil, and then, <a href="https://go.dev/play/p/8bgVfOy4Lkw">as far as I can tell</a>, uses <code>&#34;&lt;nil&gt;&#34;</code> as the “IP” key. (I’m surprised that it doesn’t panic, but I don’t think it does.) The way this logic works makes memory exhaustion more difficult, but it might be achievable using valid IPv6 addresses.</p><p>[2022-03-04: Disclosed to maintainer via email. 2022-03-05: <a href="https://github.com/ulule/limiter/pull/181">PR</a> has been created with fixes (mostly documentation warnings). It’s public, so I’m un-redacting this.]</p><h3 id="sethvargogo-limiter">
<a href="#sethvargogo-limiter">
###
</a>
sethvargo/go-limiter
</h3><p>This is yet another Go rate limiter middleware. If its <code>httplimit.IPKeyFunc</code> is configured to look at the <code>X-Forwarded-For</code> header (which is given as an example in its comment), it will <a href="https://github.com/sethvargo/go-limiter/blob/d0c1f4df450eb46623c6f3afe9f675d40da52cf9/httplimit/middleware.go#L40-L59"><em>use the whole header</em></a> as the rate limit key. That’s almost worse than taking the leftmost IP.</p><p>The way to work around this would be to avoid its “real IP” logic and create your own <a href="https://github.com/sethvargo/go-limiter/blob/67fff5ee8978ea6218af4d1354bb842096a5b543/httplimit/middleware.go#L38"><code>KeyFunc</code></a> that extracts the correct IP for your network architecture.</p><p>If the library can’t find the configured header(s), it falls through to <code>RemoteAddr</code>. But, again, I don’t think default fallbacks are good.</p><p>The library also uses Go’s <code>http.Header.Get()</code>.</p><p>[2022-03-04: Disclosed to maintainer via email. 2022-03-05: Maintainer indicated by email that I could un-redact this.]</p><h3 id="redacted">
<a href="#redacted">
###
</a>
[REDACTED]
</h3><p>Pending disclosure</p><h3 id="lets-encrypt">
<a href="#lets-encrypt">
###
</a>
Let’s Encrypt
</h3><p>It <a href="https://github.com/letsencrypt/boulder/blob/ab79f96d7bfc94be7d009e2aa2007c51ddf16f31/web/context.go#L95">looks like</a> Let’s Encrypt is using Nginx with <code>X-Real-IP</code>. If it’s configuration is good (I don’t think the config files are in GitHub), then it should be using rightmost-ish.</p><h3 id="redacted-1">
<a href="#redacted-1">
###
</a>
[REDACTED]
</h3><p>Pending disclosure</p><h3 id="jetty">
<a href="#jetty">
###
</a>
Jetty
</h3><p>It looks like the Jetty web server <a href="https://github.com/eclipse/jetty.project/blob/cb127793e5d8b5c5730b964392a9a905ba49191d/jetty-server/src/main/java/org/eclipse/jetty/server/ForwardedRequestCustomizer.java#L814-L821">uses the leftmost</a> XFF IP address. I haven’t dug far enough in to see what it’s used for (or how it’s exposed), but that’s a dangerous start.</p><h3 id="express">
<a href="#express">
###
</a>
Express
</h3><p>Express is a NodeJS web framework. The default configuration ignores the XFF header, but it’s possible to <a href="https://expressjs.com/en/guide/behind-proxies.html">configure it</a> to use the leftmost or a rightmost-ish XFF IP. The setting that uses the leftmost has this warning:</p><blockquote>
<p>When setting to true, it is important to ensure that the last reverse proxy trusted is removing/overwriting all of the following HTTP headers: X-Forwarded-For, X-Forwarded-Host, and X-Forwarded-Proto otherwise it may be possible for the client to provide any value.</p></blockquote><p>So that’s pretty good. (But still a footgun that I’m sure someone will fall victim to.)</p><h3 id="traefik">
<a href="#traefik">
###
</a>
Traefik
</h3><p>Traefik is a “cloud native network stack”. Its <a href="https://doc.traefik.io/traefik/middlewares/http/ratelimit/#ipstrategydepth">rate limiter</a> is configured to use the “trusted proxy count” version of rightmost-ish. So that’s good.</p><h3 id="phplist">
<a href="#phplist">
###
</a>
phpList
</h3><p>phpList is an “open source newsletter and email marketing software”. It <a href="https://github.com/phpList/phplist3/blob/927ce341068d16f35566eaaddf2b9ace639885a4/public_html/lists/admin/lib.php#L2423-L2445">uses the leftmost XFF IP</a>. I can’t quite tell what it’s used for, but it’s <a href="https://github.com/phpList/phplist3/blob/927ce341068d16f35566eaaddf2b9ace639885a4/public_html/lists/admin/index.php#L296">something surrounding login</a>.</p><h3 id="iis">
<a href="#iis">
###
</a>
IIS
</h3><p>I could find anything to suggest that Microsoft IIS processes the XFF header, but an official support blog post entitled <a href="https://techcommunity.microsoft.com/t5/iis-support-blog/how-to-use-x-forwarded-for-header-to-log-actual-client-ip/ba-p/873115">“How to use X-Forwarded-For header to log actual client IP address?”</a> says:</p><blockquote>
<p>If you see multiple IP addresses in X-Forwarded-For column, it means the client went through more than one network device. Each network device adds their own IP to the end of the value. The left-most IP address is the actual client IP address. Others belong to network devices the client go through.</p></blockquote><p>Which is a <em>woefully incomplete</em> statement. I fear for the 97,641 people who read that post.</p><h3 id="tor">
<a href="#tor">
###
</a>
Tor
</h3><p>Tor is an anonymity network. They have <a href="https://gitlab.torproject.org/tpo/anti-censorship/rdsys/-/issues/80">recently realized</a> that they have a control server that is both directly connected to the internet <em>and</em> behind a reverse proxy and are using XFF to give them trustworthy IPs, so they’re vulnerable to spoofing. It looks like they’re working towards limiting the public-ness of the interface, or doing better verification of CDN connections, or both.</p><p>(Because I looked into it, I’ll mention that it looks like they’re <em>not</em> falling victim to the <a href="#multiple-headers">“multiple headers”</a> pitfall. It looks like they use Twisted and call <code>request.getHeader</code> to get the XFF value. The <a href="https://github.com/twisted/twisted/blob/ebb2d360070e468981377b917e3a728ff4e6c7f6/src/twisted/web/http.py#L1068">Twisted source</a> for that method indicates that it returns the <em>last</em> matching header. That could cause problems if you need the Nth-from-the-right header, but I think it’s fine in this case.)</p><h2 id="advanced-and-theoretical-pitfalls-and-attacks">
<a href="#advanced-and-theoretical-pitfalls-and-attacks">
##
</a>
Advanced and theoretical pitfalls and attacks
</h2><p>I’ve talked a lot about two attacks on rate limiters: avoiding being limited and exhausting server memory. I’ve done this because rate limiters are what led me to this topic and because causing a map of IPs to fill memory was an obvious danger in many implementations.</p><p>But rate limiters are only one “security-related” use of <code>X-Forwarded-For</code>, and there are more, cooler possibilities for badness! They’re harder to find or reproduce, but they should be fun to speculate on…</p><h3 id="server-behind-reverse-proxy-_and_-directly-connectable">
<a href="#server-behind-reverse-proxy-_and_-directly-connectable">
###
</a>
Server behind reverse proxy <em>and</em> directly connectable
</h3><p>This was briefly mentioned in the “algorithms” section, but is worth repeating.</p><p>Generally speaking, if your server is behind one or more reverse proxies, there are one or more rightmost IPs in the XFF header that you can trust. The “rightmost-ish” algorithm is predicated on that. But if your server can <em>also</em> be connected to directly from the internet, that is no longer true.</p><p>With some experimentation, an attacker can craft an XFF header to look exactly like the one you expect from your reverse proxy:</p><ol>
<li>Attacker gets her IP limited/blocked by your server.</li><li>Attacker crafts XFF header so that the rightmost of it has different IPs in the private space, and different counts of those IPs.</li><li>Continue until the limit/block unexpectedly disappears.</li></ol><p>Now you’re using an untrusted XFF IP and don’t realize it. Rate limiter escape, memory exhaustion, etc.</p><p>One way to mitigate this is to check the <code>RemoteAddr</code> to make sure it belongs to your reverse proxy <em>before</em> you try to parse the XFF header.</p><h3 id="many-trusted-reverse-proxy-ips">
<a href="#many-trusted-reverse-proxy-ips">
###
</a>
Many trusted reverse proxy IPs
</h3><p>This is more of a “difficulty” than a pitfall or attack, but this is as good a place as any to fit it in.</p><p>In the rightmost-ish algorithm, the “trusted proxy IPs” list might be very large and might involve ranges rather than specific IPs. For example:</p><ul>
<li>There might be a pool of reverse proxies that feed into your server.</li><li>That pool might scale out with load. So your trusted IPs will have to include whatever range that pool uses.</li><li>You might use a large external service, like Cloudflare. So you’ll need to “trust” all of their <a href="https://www.cloudflare.com/ips">very large set of IPs</a>.</li></ul><p>Especially in that last case – and <em>especially</em> if you’re accepting IPv6 connections – you can’t just have a big list of single IPs that you check. You’ll need to check a list of ranges.</p><h3 id="network-architecture-changes">
<a href="#network-architecture-changes">
###
</a>
Network architecture changes
</h3><p>So, you’ve set everything up perfectly. Your configuration is exactly right and you’re picking the correct “client IP” every time. Great. It runs quietly and flawlessly for so long that you forget all about it.</p><p>And then you change your network architecture.</p><p>The scenarios with the less-bad result are when you’re using the rightmost-ish approach and you add a new level of reverse proxy.</p><ul>
<li>You were accepting connections directly from the internet, so you were using <code>RemoteAddr</code> for rate-limiting. Then you added a load balancer. Now you’re rate-limiting your load balancer.</li><li>You were using a single reverse proxy. You were using the rightmost XFF IP – the one that gets added by that proxy – for rate-limiting. Then you added another level of reverse proxy. Now you’re rate-limiting one of your reverse proxies (whichever is first in the chain).</li><li>You had a complex setup of internal reverse proxies. You were rate-limiting by rightmost-ish XFF IP, with your whole internal IP range on the “trusted proxy” list. Then you added Cloudflare in front of it all. Now you’re rate-limiting Cloudflare.</li></ul><p>Those are “less bad” because they don’t introduce security flaws, but they’re still going to result in a near-complete inability to process requests.</p><p>The “much more bad” scenarios tend to occur when removing reverse proxy levels, and introduce vulnerabilities that you won’t notice.</p><ul>
<li>You were using a single reverse proxy. You were using the rightmost XFF IP – the one that gets added by that proxy – for rate-limiting. Then you decide that you don’t need that extra proxy level and instead you connect your server directly to the internet. But now no part of the XFF is trustworthy and you’re vulnerable to spoofing.</li><li>You were using Cloudflare in front of AWS ALB and relying on its <code>CF-Connecting-IP</code> header. Then you decide to save some money, drop Cloudflare, and now have requests go directly to ALB. So now you’re vulnerable to <code>CF-Connecting-IP</code> spoofing.</li><li>You were using two levels of reverse proxy in front of your server. You were using the rightmost-ish XFF IP with a “trusted proxy count” of 2 for rate-limiting – so you were always taking the second-from-the-right IP. You decide to remove a level of reverse proxy. Now you’re vulnerable to spoofing because the second-from-the-right XFF IP is no longer trustable.</li></ul><p>Depending on your logic, it might take an attack before you notice that you’re vulnerable.</p><p>The takeaway here is pretty obvious – “when network architecture changes, configuration that depends on that architecture also needs to change” – but it can be very difficult to remember to update every dependent config file when you tweak something that “should” work and does appear to work. (Maybe there are fancy network-management tools that automatically push config changes in response to architecture changes? Would be cool.)</p><p>The “trusted proxy count” variation of the rightmost-ish algorithm is especially brittle to adding or removing reverse proxies. The “trusted proxy count” (especially with a big internal range) or “rightmost non-private IP” variations can better cope with changing the number of internal proxies (as long as you’re not going to zero).</p><h4 id="even-worse-_third-party_-network-architecture-changes">
<a href="#even-worse-_third-party_-network-architecture-changes">
####
</a>
Even worse: <em>Third-party</em> network architecture changes
</h4><p>Take a look at the <a href="https://www.cloudflare.com/ips">Cloudflare IP list</a>. Notice down at the bottom that there have been two times where Cloudflare removed IPs from the list.</p><p>Imagine you had those IPs on your trusted list. Imagine you didn’t realize they were removed. <em>Now who owns those IPs?</em> Whoever it is can put whatever they want in the XFF, pass it on to your trusted proxy chain, and you’ll use it as the “real” IP. Rate limit escape and memory exhaustion.</p><p>…The answer to that question is that Cloudflare still owns the IPs (I <a href="https://search.arin.net/rdap/?query=104.30.0.1">checked</a> <a href="https://search.arin.net/rdap/?query=199.27.128.1">ARIN</a>). But the point isn’t about Cloudflare and those particular IP ranges. <em>Any</em> CDN or reverse proxy service with a trusted IP list could change their list and cause problems.</p><p>(Edit: A reader shared <a href="https://adam-p.ca/img/blog/cloudflare-ip-range-removal-email.png">the email Cloudflare sent</a> when they most recently changed their IP set. He pointed out that even though Cloudflare still owns the IPs, they should be considered untrusted. The email mentions that there’s <a href="https://api.cloudflare.com/#cloudflare-ips-properties">an API</a> to get Cloudflare’s IPs, which is good. Anyway, my original point wasn’t just about Cloudflare, so it remains unchanged.)</p><h3 id="x-forwarded-for-parser-mismatch">
<a href="#x-forwarded-for-parser-mismatch">
###
</a>
<code>X-Forwarded-For</code> parser mismatch
</h3><p>This is inspired by <a href="https://bishopfox.com/blog/json-interoperability-vulnerabilities">JSON interoperability vulnerabilities</a>. These occur when different levels of code or architecture interpret JSON in different ways. So if the JSON parser at one level deals with, say, duplicate object keys by taking the first key and another level deals with it by taking the last key, you can have a problem. (E.g., an attacker passes a <code>&#34;username&#34;</code> value along with a matching password, but then also passes another <code>&#34;username&#34;</code> value. If your auth check uses the first username and the business logic uses the second, you’re going to access the wrong user data.)</p><p>If there’s one thing that’s certainly true of the XFF header it’s that there’s an abundance of ways of “interpreting” it. Let’s recap some of them and add a fun new one:</p><ul>
<li>Which position? Leftmost? Rightmost? Nth-from-rightmost? And so on.</li><li>What value is acceptable? Don’t validate at all? Only IPs? Only non-private IPs?</li><li>How to split up the list of IPs? Comma? Comma-space?</li><li>How to handle multiple XFF headers?</li><li>New: How to handle weird characters? What if there’s a null byte? Or some other control character? What if there’s a UTF-8 sequence?</li></ul><p><em>Any</em> difference in the answers to any of those question marks can result in a mismatch between parsers.</p><p>I wish I had a slam-dunk example scenario for this, but I don’t. Here are some hand-wavy ones:</p><ul>
<li>You block access to your service to requests from, say, Antarctica. You have a reverse proxy at one level that grabs an XFF IP and checks that. At another level, you have a reverse proxy that grabs a different XFF IP and collects geolocation statistics. You get confused about why you seem to have users connected from Antarctica. (One of them is doing it wrong, but this isn’t enough to tell you which.)</li><li>At one reverse proxy level, you check a user’s incoming IP address against your DB to make sure it’s acceptable for that user. At another reverse proxy level, you update that DB. If there’s a mismatch, you’ll end up too permissive, too restrictive, or both.</li><li>More generally… At one reverse proxy level you use the XFF header to determine the client’s IP. Allowing the request to proceed is an attestation that the client IP is acceptable for further processing. At a later reverse proxy level, the client IP is again derived from the XFF header and treated as trusted data because it is implicitly attested to by the previous level.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> A difference between the two levels in XFF parsing introduces a vulnerability.</li></ul><h2 id="rfc-7239-forwarded-http-extension-june-2014">
<a href="#rfc-7239-forwarded-http-extension-june-2014">
##
</a>
RFC 7239: Forwarded HTTP Extension, June 2014
</h2><p>After considering comma-vs-comma-space and other parser mismatches, you’re probably thinking, “There should be an RFC to concretely specify this.” And there is, kind of.</p><p><a href="https://datatracker.ietf.org/doc/html/rfc7239">RFC 7239</a> specifies the <code>Forwarded</code> header. Its purpose is to replace and improve <code>X-Forwarded-For</code>. The big thing it addresses is that <code>X-Forwarded-For</code> (the client IP address), <code>X-Forwarded-Host</code> (the client hostname), <code>X-Forwarded-Proto</code> (the protocol the client used; e.g., “https”), and <code>X-Forwarded-By</code> (the proxy IP address) are all separate-but-parallel headers. And if any proxy along the way adds an IP to XFF but doesn’t add a value to the others, then they’re no longer parallel and become impossible to map to one another. The <code>Forwarded</code> header includes all that information in a single list.</p><p>Does the <code>Forwarded</code> header fix the security issues that <code>X-Forwarded-For</code> has? Not even a little. It can be misused in exactly the same ways that XFF can.</p><p>Does it have wide adoption? Not that I can see. It gets mentioned in documentation occasionally, but I don’t remember it actually being checked in any of the code I read.</p><p>Okay, does the RFC at least make clear how it should be used and not be used? Well, there is <a href="https://datatracker.ietf.org/doc/html/rfc7239#section-8.1">this section</a>:</p><blockquote>
<h5 id="81--header-validity-and-integrity">
<a href="#81--header-validity-and-integrity">
#####
</a>
8.1. Header Validity and Integrity
</h5><p>The “Forwarded” HTTP header field cannot be relied upon to be correct, as it may be modified, whether mistakenly or for malicious reasons, by every node on the way to the server, including the client making the request.</p><p>One approach to ensure that the “Forwarded” HTTP header field is correct is to verify the correctness of proxies and to whitelist them as trusted. This approach has at least two weaknesses. First, the chain of IP addresses listed before the request came to the proxy cannot be trusted. Second, unless the communication between proxies and the endpoint is secured, the data can be modified by an attacker with access to the network.</p></blockquote><p>And that’s it.<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></p><p>That warning is strictly true, but it’s not very helpful and could be clearer. Would you read those five sentences and then think, “Now I thoroughly understand the danger! It’s perfectly clear to me how to use this header in a secure manner.”? I wouldn’t.</p><p>I feel like it should be the responsibility of this RFC not only to specify how to <em>create</em> the header but also how to correctly <em>consume</em> it.</p><p>(Bonus: The RFC adds a variation on IPv6 parsing – quotation marks: “Note that as “:” and “[]” are not valid characters in “token”, IPv6 addresses are written as “quoted-string”.” E.g., <code>&#34;[2001:db8:cafe::17]:4711&#34;</code>.)</p><h2 id="conclusions">
<a href="#conclusions">
##
</a>
Conclusions
</h2><p>Well, that was exhausting. I didn’t start out with the intention of writing a dissertation on this godforsaken header.</p><p>I have avoided giving <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#syntax">this definition</a> until now, just in case anyone skims the article and sees it, but I think we’re ready for it:</p><pre tabindex="0"><code>X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;
</code></pre><p>That’s what you’ll see on basically every page that describes the header. Is it any wonder that misuse of <code>X-Forwarded-For</code> is so prevalent?</p><p>Let’s summarize some of the things we’ve learned, the wisdom we’ve gained, and the opinions we’ve formed:</p><ol>
<li>
<p>Danger on the left, trust on the right. There are, maybe, some situations where the leftmost-ish XFF IP can be used, but only very carefully. If there’s any doubt, use the rightmost-ish.</p></li><li>
<p>Any header – or any part of any header – that wasn’t set by your own reverse proxy is fundamentally untrustworthy.</p></li><li>
<p>Setting a special header to a helpful value but also just letting it through if it’s already set is a terrible idea. (See: Akamai, Fastly.)</p></li><li>
<p>If there’s no universally sane default, there should be no default. And “get the real IP” is a case where there’s no sane default. (See: Chi, Tollbooth.)</p></li><li>
<p>Defaults should <em>not</em> be insecure. There shouldn’t need to be extra configuration to avoid shooting yourself in the foot. (See: Fastly.)</p></li><li>
<p>If you know a function or value is dangerous (spoofable, etc.), put that in your documentation for it in big red letters. Don’t just coyly hint at it. (See: Azure, etc.)</p></li><li>
<p>Good specifications (i.e., RFCs) should tell you how to consume a value, not just how to produce it. And if there are different ways to consume that value that make sense in different situations, it should give you the necessary information – with sufficient clarity – to help you make that choice. A reference implementation would also help.</p></li><li>
<p>Inconsistency in security implementations is bad. Pick a tool or cloud service that I didn’t cover here to check for XFF behaviour. Can you guess beforehand what you’ll find with any certainty? You can’t, and that’s bad.</p></li><li>
<p>If you’re creating a security tool, product, or feature, you need to have as thorough an understanding of the problem space as possible. Even if you start with solid off-the-shelf components (like a token bucket library and expirable cache for a rate limiter), you still need to be fully aware of, for example, the nature and meaning of a header that’s being used as input. Otherwise you run the risk of introducing a new vulnerability (or two, etc.).</p></li><li>
<p>If you’re taking untrusted input – like a header value – and putting it into an ever-growing, pretty-long-lived, in-memory structure (like a rate limiter map), you need to be incredibly careful. (Especially if that structure isn’t <em>behind</em> a rate limiter and instead <em>is</em> the rate limiter.)</p></li><li>
<p>Whenever possible, read the code for your dependencies. It’s hard and a ton of work, but bad security surprises can be worse.</p></li></ol><p>I have avoided saying that you should only use the rightmost-ish XFF IP and never, ever the leftmost. But, seriously, just don’t use it.</p><h2 id="discussion">
<a href="#discussion">
##
</a>
Discussion
</h2><p>Comment and discuss at <a href="https://news.ycombinator.com/item?id=30570053">Hacker News</a>.</p><p>There have been some interesting comments on HN and Reddit. I’ll share some tidbits here.</p><p>HN commenter scottlamb <a href="https://news.ycombinator.com/item?id=30571412">pointed out</a> that <a href="https://docs.rs/http/0.2.6/http/header/struct.HeaderMap.html#method.get">Rust’s method to return a single header</a> value also returns the value of the first such header. The commenter checked and discovered that they were using it wrong.</p><h3 id="aws-elbalb-has-an-option-to-make-xff-even-worse">
<a href="#aws-elbalb-has-an-option-to-make-xff-even-worse">
###
</a>
AWS ELB/ALB has an option to make XFF even worse
</h3><p>HN commenter nickjj brought the AWS ELB/ALB <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/x-forwarded-headers.html#x-forwarded-for">“client port preservation”</a> option to my attention. If enabled, the client port number is appended to the IP added to XFF. Turning that option on will a) violate the de facto standard form of the header, and b) mess up a lot of IP parsing code.</p><p>(And if the IP suddenly starts failing, then what? Does the rate limiter logic keep moving to the right until it finds a good IP? If done wrong, that could lead to using untrusted values. Does the rate limiter instead give up? And do what? Fail open? Fail closed? Panic? In a comment on the didip/tollbooth PR for this <a href="https://github.com/didip/tollbooth/pull/99#issuecomment-1059328777">I talk more about this</a>.)</p><p>HN commenter terom <a href="https://news.ycombinator.com/item?id=30571542">said</a>:</p><blockquote>
<p>highly recommended to just override the entire XFF header with a single value at the appropriate point in your stack, if at all possible</p></blockquote><p>Which is good advice and I didn’t really say in the post. If you have the ability to use one of the “good” single-IP headers, or add your own at your first proxy, that’s much better than messing around with XFF.</p><p>(The reason I didn’t really talk about the custom header is like: I was mostly writing for people who are trying to use what’s available rather than doing a lot of proxy tinkering. Or something.)</p><h3 id="envoys-xff-documentation-is-really-something">
<a href="#envoys-xff-documentation-is-really-something">
###
</a>
Envoy’s XFF documentation is really something
</h3><p>HN commenter jrockway <a href="https://news.ycombinator.com/item?id=30571219">pointed me</a> at the Envoy Proxy <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#x-forwarded-for">documentation for XFF use</a>. It’s not exactly generally educational, but I think it’s a really good effort at making sure that Envoy users don’t shoot themselves in the foot.</p><h2 id="acknowledgements">
<a href="#acknowledgements">
##
</a>
Acknowledgements
</h2><p>Thanks to <a href="https://github.com/rod-hynes">Rod Hynes</a> for proofreading and providing feedback. All mistakes are mine, of course.</p><p>Thanks to <a href="https://psiphon.ca">Psiphon Inc.</a> for giving me the time to work on this. And employing me.</p><h2 id="todo">
<a href="#todo">
##
</a>
TODO
</h2><ul>
<li>add note about single-value header Get being combined list</li><li>all projects: if deciding to use leftmost, check for valid/non-private</li><li>finish reference implementation</li><li>probably add some diagrams</li><li>rethink hyphenating rate-limit* (right now I’m not doing it for nouns but am doing it for verbs, and I can’t decide what’s right)</li></ul></article></div></div>
  </body>
</html>
