<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Jcparkyn/herd">Original</a>
    <h1>Show HN: A small programming language where everything is pass-by-value</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Herd is a simple interpreted programming language where everything is a value.</p>
<p dir="auto"><strong>Disclaimer: This is a hobby language, and you probably shouldn&#39;t use it for anything important.</strong></p>

<p dir="auto">In Herd, everything is pass-by-value, including lists and dicts.
This means that when you pass a list or dict to a function, <strong>you can guarantee that the function won&#39;t modify your copy</strong>.</p>
<p dir="auto">You can modify variables locally just like you would in an imperative language, but there will never be any side-effects on other copies of the value.</p>
<div dir="auto" data-snippet-clipboard-copy-content="var foo = { a: 1 };
var bar = foo; // make a copy of foo
set bar.a = 2; // modify bar (makes a copy)
println foo.a bar.a; // prints 1 2"><pre><span>var</span> foo <span>=</span> { a<span>:</span> <span>1</span> };
<span>var</span> bar <span>=</span> foo; <span>// make a copy of foo</span>
<span>set</span> bar.a <span>=</span> <span>2</span>; <span>// modify bar (makes a copy)</span>
println foo.a bar.a; <span>// prints 1 2</span></pre></div>

<p dir="auto">All reference types in Herd (e.g. strings, lists, dicts) use reference counting. Whenever you make a copy of a reference type, the reference count is incremented. Whenever you <em>modify</em> a reference type, one of two things happen:</p>
<ul dir="auto">
<li>If there&#39;s only one reference to the value, it can be modified in-place without making any copies. This is because the code doing the modification must be the only reference, so no other code will be able to observe the modification.</li>
<li>If there&#39;s more than one reference to the value, the language makes a shallow copy of it with the modification applied. The copy now has a reference count of one, so subsequent modifications usually don&#39;t need to allocate.</li>
</ul>
<p dir="auto">There&#39;s one very convenient consequence of everything being a value: <em>Reference cycles are impossible!</em> This means the reference counting system doesn&#39;t need cycle detection, and can also be used as a garbage collector.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Comparison to other languages</h2><a id="user-content-comparison-to-other-languages" aria-label="Permalink: Comparison to other languages" href="#comparison-to-other-languages"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Swift: Uses a lot of similar ideas (under the name &#34;Mutable Value Semantics&#34;), but is statically typed and overall a much more complex language, including many types that aren&#39;t values.</li>
<li>Matlab / R: These languages also use copy-on-write semantics for arrays, but as far as I&#39;m aware they can&#39;t reliably track when reference counts decrease back to one, so they have to make copies more often than herd does. (I also dislike these languages for other reasons).</li>
<li>PHP: Uses value semantics for arrays but not objects.</li>
<li>Perl: Uses value semantics for array and hashes, but exposes many ways to break the guarantees of value semantics.</li>
</ul>


<p dir="auto">Use the <code>println</code> function to print to the console. Strings are defined using single quotes.</p>


<div dir="auto" data-snippet-clipboard-copy-content="x = 1; // define an immutable variable
var y = 2; // define a mutable variable
set y = 3; // modify a mutable variable"><pre>x <span>=</span> <span>1</span>; <span>// define an immutable variable</span>
<span>var</span> y <span>=</span> <span>2</span>; <span>// define a mutable variable</span>
<span>set</span> y <span>=</span> <span>3</span>; <span>// modify a mutable variable</span></pre></div>

<p dir="auto">Values in herd have the following types:</p>
<ul dir="auto">
<li><code>()</code> the unit type, representing no value.</li>
<li><code>bool</code> boolean values: <code>true</code> and <code>false</code>.</li>
<li><code>number</code> 64-bit floating point number, e.g. <code>42</code>, <code>-7</code>, <code>2.6</code>.</li>
<li><code>string</code> a text string, e.g. <code>&#39;hello&#39;</code>.</li>
<li><code>list</code> an ordered collection of values, e.g. <code>[1, 2, 3]</code>.</li>
<li><code>dict</code> a collection of key-value pairs, e.g. <code>{ x: 1, y: 2 }</code>.</li>
<li><code>function</code> a function value, e.g. <code>\x y\ x + y</code>.</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="var list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
set list.[1] = &#39;z&#39;;
println list; // prints [&#39;a&#39;, &#39;z&#39;, &#39;c&#39;]"><pre><span>var</span> list <span>=</span> [<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>];
<span>set</span> list.[<span>1</span>] <span>=</span> <span>&#39;z&#39;</span>;
println list; <span>// prints [&#39;a&#39;, &#39;z&#39;, &#39;c&#39;]</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="var dict = { x: 1, y: 2 };
set dict.x = 3;
println dict; // prints { x: 3, y: 2 }"><pre><span>var</span> dict <span>=</span> { x<span>:</span> <span>1</span>, y<span>:</span> <span>2</span> };
<span>set</span> dict.x <span>=</span> <span>3</span>;
println dict; <span>// prints { x: 3, y: 2 }</span></pre></div>
<p dir="auto">You can use shorthand when creating dicts if the key name matches the variable name:</p>
<div dir="auto" data-snippet-clipboard-copy-content="x = 10;
y = 20;
dict = { x, y }; // equivalent to { x: x, y: y }"><pre>x <span>=</span> <span>10</span>;
y <span>=</span> <span>20</span>;
dict <span>=</span> { x, y }; <span>// equivalent to { x: x, y: y }</span></pre></div>

<p dir="auto">In herd, blocks are defined using parentheses. If the last expression in the block is not terminated with a semicolon, its value becomes the value of the block.</p>
<div dir="auto" data-snippet-clipboard-copy-content="x = (
  a = 2;
  b = 3;
  a + b
);
println x; // prints 5"><pre>x <span>=</span> (
  a <span>=</span> <span>2</span>;
  b <span>=</span> <span>3</span>;
  a <span>+</span> b
);
println x; <span>// prints 5</span></pre></div>

<p dir="auto">All functions in herd are defined using the anonymous function syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// define function taking two parameters
multiply1 = \a b\ (
  return a * b;
);
// call the function
x = multiply1 3 4;
println x; // prints 12"><pre><span>// define function taking two parameters</span>
multiply1 <span>=</span> \a b\ (
  <span>return</span> a <span>*</span> b;
);
<span>// call the function</span>
x <span>=</span> multiply1 <span>3</span> <span>4</span>;
println x; <span>// prints 12</span></pre></div>
<p dir="auto">The body of the function is just a block expression, so you can omit the <code>return</code> statement if you want:</p>
<div dir="auto" data-snippet-clipboard-copy-content="multiply2 = \a b\ (a * b);"><pre>multiply2 <span>=</span> \a b\ (a <span>*</span> b);</pre></div>
<p dir="auto">You can also omit the parentheses for simple expressions:</p>

<p dir="auto">And there&#39;s an even shorter syntax for single-parameter functions:</p>

<p dir="auto">Functions with no parameters can be defined using <code>\\</code>, and called by passing a unit value <code>()</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="getRandomNumber = \\ Math.randomInt 0 100;
println (getRandomNumber ()); // prints a random number"><pre>getRandomNumber <span>=</span> \\ <span>Math</span>.randomInt <span>0</span> <span>100</span>;
println (getRandomNumber ()); <span>// prints a random number</span></pre></div>
<p dir="auto">Functions with a variable number of arguments can be defined using <code>..</code> for the last parameter:</p>
<div dir="auto" data-snippet-clipboard-copy-content="min = \first ..rest\ (
  var minVal = first;
  for x in rest do (
    if x &lt; minVal then (
      set minVal = x;
    )
  )
  minVal
);

println (min 5 3 8); // prints 3"><pre>min <span>=</span> \first ..rest\ (
  <span>var</span> minVal <span>=</span> first;
  <span>for</span> x <span>in</span> rest <span>do</span> (
    <span>if</span> x <span>&lt;</span> minVal then (
      <span>set</span> minVal <span>=</span> x;
    )
  )
  minVal
);

println (min <span>5</span> <span>3</span> <span>8</span>); <span>// prints 3</span></pre></div>

<p dir="auto">In herd, <em>everything</em> is immutable unless declared with <code>var</code>. This includes lists and complex objects that would be mutable in other languages.</p>
<div dir="auto" data-snippet-clipboard-copy-content="list = [&#39;a&#39;, &#39;b&#39;]; // list is immutable, because it wasn&#39;t defined with var.
set list.[0] = &#39;A&#39;; // Not allowed"><pre>list <span>=</span> [<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>]; <span>// list is immutable, because it wasn&#39;t defined with var.</span>
<span>set</span> list.[<span>0</span>] <span>=</span> <span>&#39;A&#39;</span>; <span>// Not allowed</span></pre></div>
<p dir="auto">Each copy of a value is a <em>distinct copy</em>, and modifications to one variable won&#39;t modify other variables - even for lists and dicts!</p>
<div dir="auto" data-snippet-clipboard-copy-content="var list1 = [&#39;a&#39;, &#39;b&#39;];
var list2 = list1; // make a copy
set list2.[0] = &#39;c&#39;; // modify list2
println list1; // prints [&#39;a&#39;, &#39;b&#39;]
println list2; // prints [&#39;c&#39;, &#39;b&#39;]"><pre><span>var</span> list1 <span>=</span> [<span>&#39;a&#39;</span>, <span>&#39;b&#39;</span>];
<span>var</span> list2 <span>=</span> list1; <span>// make a copy</span>
<span>set</span> list2.[<span>0</span>] <span>=</span> <span>&#39;c&#39;</span>; <span>// modify list2</span>
println list1; <span>// prints [&#39;a&#39;, &#39;b&#39;]</span>
println list2; <span>// prints [&#39;c&#39;, &#39;b&#39;]</span></pre></div>
<p dir="auto">This also applies when passing values to functions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="doubleEveryItem = \var list\ (
  for [i, x] in List.enumerate list do (
    set list.[i] = x * 2;
  )
  list
);
list1 = [3, 4];
list2 = doubleEveryItem list1;
println list1; // prints [3, 4]
println list2; // prints [6, 8]"><pre>doubleEveryItem <span>=</span> \<span>var</span> list\ (
  <span>for</span> [i, x] <span>in</span> <span>List</span>.enumerate list <span>do</span> (
    <span>set</span> list.[i] <span>=</span> x <span>*</span> <span>2</span>;
  )
  list
);
list1 <span>=</span> [<span>3</span>, <span>4</span>];
list2 <span>=</span> doubleEveryItem list1;
println list1; <span>// prints [3, 4]</span>
println list2; <span>// prints [6, 8]</span></pre></div>

<p dir="auto">Use <code>!</code> to destructure lists and dicts:</p>
<div dir="auto" data-snippet-clipboard-copy-content="list = [1, 2];
![a, b] = list; // destructure list
println a; // prints 1
println b; // prints 2

dict = { x: 10, y: 20 };
!{ x, y } = dict; // destructure dict
println x; // prints 10
println y; // prints 20"><pre>list <span>=</span> [<span>1</span>, <span>2</span>];
<span>!</span>[a, b] <span>=</span> list; <span>// destructure list</span>
println a; <span>// prints 1</span>
println b; <span>// prints 2</span>

dict <span>=</span> { x<span>:</span> <span>10</span>, y<span>:</span> <span>20</span> };
<span>!</span>{ x, y } <span>=</span> dict; <span>// destructure dict</span>
println x; <span>// prints 10</span>
println y; <span>// prints 20</span></pre></div>
<p dir="auto">You can also use pattern matching in <code>switch</code> expressions to handle multiple cases:</p>
<div dir="auto" data-snippet-clipboard-copy-content="x = [1, 2, 3];
y = switch x on {
  [] =&gt; &#39;Empty list&#39;,
  [1, ...rest] =&gt; &#39;Begins with 1, then &#39; ++ (toString rest),
  [a] =&gt; &#39;Single item: &#39; ++ (toString a),
  _ =&gt; &#39;Something else&#39;,
};
println y; // prints &#39;Begins with 1, then [2, 3]&#39;"><pre>x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>];
y <span>=</span> <span>switch</span> x <span>on</span> {
  [] <span>=&gt;</span> <span>&#39;Empty list&#39;</span>,
  [<span>1</span>, ...rest] <span>=&gt;</span> <span>&#39;Begins with 1, then &#39;</span> <span>++</span> (toString rest),
  [a] <span>=&gt;</span> <span>&#39;Single item: &#39;</span> <span>++</span> (toString a),
  _ <span>=&gt;</span> <span>&#39;Something else&#39;</span>,
};
println y; <span>// prints &#39;Begins with 1, then [2, 3]&#39;</span></pre></div>
<p dir="auto">You can use <code>var</code> to destructure to a mutable variable, or <code>set</code> to modify an existing variable:</p>
<div dir="auto" data-snippet-clipboard-copy-content="list = [1, 2];
[a, var b] = list; // a is immutable, b is mutable
set b = b + 10;
println [list, a, b]; // prints [[1, 2], 1, 12]"><pre>list <span>=</span> [<span>1</span>, <span>2</span>];
[a, <span>var</span> b] <span>=</span> list; <span>// a is immutable, b is mutable</span>
<span>set</span> b <span>=</span> b <span>+</span> <span>10</span>;
println [list, a, b]; <span>// prints [[1, 2], 1, 12]</span></pre></div>

<p dir="auto">The pipe operator <code>|</code> can be used to chain function calls in a more readable way:</p>
<div dir="auto" data-snippet-clipboard-copy-content="x = [1, 2, 3]
  | List.map \(_ * 2) // double each item
  | List.filter \(_ &gt; 3); // keep only items greater than 3
println x; // prints [4, 6]"><pre>x <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>]
  <span>|</span> <span>List</span>.map \(_ <span>*</span> <span>2</span>) <span>// double each item</span>
  <span>|</span> <span>List</span>.filter \(_ <span>&gt;</span> <span>3</span>); <span>// keep only items greater than 3</span>
println x; <span>// prints [4, 6]</span></pre></div>
<p dir="auto">You can combine the pipe operator with <code>set</code> to modify variables in-place using <code>|=</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="var x = [1, 2];
set x |= List.push 3; // equivalent to set x = x | List.push 3;
println x; // prints [1, 2, 3]"><pre><span>var</span> x <span>=</span> [<span>1</span>, <span>2</span>];
<span>set</span> x <span>|</span><span>=</span> <span>List</span>.push <span>3</span>; <span>// equivalent to set x = x | List.push 3;</span>
println x; <span>// prints [1, 2, 3]</span></pre></div>

<p dir="auto">Export code from a file by returning it at the end of the file:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// in file1.herd
x = 42;
double = \n\ n * 2;
return { x, double };"><pre><span>// in file1.herd</span>
x <span>=</span> <span>42</span>;
<span>double</span> <span>=</span> \n\ n <span>*</span> <span>2</span>;
<span>return</span> { x, <span>double</span> };</pre></div>
<p dir="auto">Import code from other files using the <code>import</code> function:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// in file2.herd
!{ x, double } = import &#39;file1.herd&#39;;
println (double x); // prints 84"><pre><span>// in file2.herd</span>
<span>!</span>{ x, <span>double</span> } <span>=</span> import <span>&#39;file1.herd&#39;</span>;
println (<span>double</span> x); <span>// prints 84</span></pre></div>
<p dir="auto">You can also import all code from a file:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// in file2.herd
File1 = import &#39;file1.herd&#39;;
println (File1.double File1.x); // prints 84"><pre><span>// in file2.herd</span>
<span>File1</span> <span>=</span> import <span>&#39;file1.herd&#39;</span>;
println (<span>File1</span>.<span>double</span> <span>File1</span>.x); <span>// prints 84</span></pre></div>

<p dir="auto">Standard library modules are already imported for you, and can be accessed from the imported modules:</p>
<ul dir="auto">
<li><code>System</code> - system functions for getting current time, program args, etc.</li>
<li><code>IO</code> - file input/output functions.</li>
<li><code>List</code> - list utility functions.</li>
<li><code>Dict</code> - dict utility functions.</li>
<li><code>Math</code> - mathematical functions and constants.</li>
<li><code>Bitwise</code> - bitwise operations on integers.</li>
<li><code>Random</code> - random number generation.</li>
<li><code>String</code> - string utility functions.</li>
<li><code>File</code> - file system utility functions.</li>
<li><code>Parallel</code> - multithreading utilities.</li>
</ul>
<p dir="auto">Some very commonly used functions are also available globally:</p>
<ul dir="auto">
<li><code>not</code></li>
<li><code>range</code></li>
<li><code>assert</code></li>
<li><code>toString</code></li>
<li><code>print</code></li>
<li><code>println</code></li>
<li><code>len</code></li>
</ul>

<p dir="auto">Herd has built-in support for multithreading using the <code>Parallel</code> standard library module.</p>
<p dir="auto">Use <code>Parallel.parallelMap</code> to map a function over a list in parallel:</p>
<div dir="auto" data-snippet-clipboard-copy-content="list = [1, 2, 3];
// square each item in parallel
squared = Parallel.parallelMap list \(_ * _);
println squared; // prints [1, 4, 9]"><pre>list <span>=</span> [<span>1</span>, <span>2</span>, <span>3</span>];
<span>// square each item in parallel</span>
squared <span>=</span> <span>Parallel</span>.parallelMap list \(_ <span>*</span> _);
println squared; <span>// prints [1, 4, 9]</span></pre></div>
<p dir="auto">Use <code>Parallel.parallelRun</code> to run multiple functions in parallel and wait for all of them to complete:</p>
<div dir="auto" data-snippet-clipboard-copy-content="getOrder = \id\ (...); // TODO
getCatalog = \\ (...); // TODO
orderId = 123;
// Run both functions in parallel
![order, catalog] = Parallel.parallelRun [
  \\ getOrder orderId,
  \\ getCatalog (),
];"><pre>getOrder <span>=</span> \id\ (...); <span>// TODO</span>
getCatalog <span>=</span> \\ (...); <span>// TODO</span>
orderId <span>=</span> <span>123</span>;
<span>// Run both functions in parallel</span>
<span>!</span>[order, catalog] <span>=</span> <span>Parallel</span>.parallelRun [
  \\ getOrder orderId,
  \\ getCatalog (),
];</pre></div>
<p dir="auto">In herd, it is <em>impossible</em> to create a data race, because any mutations only affect the current thread.
You can safely pass complex data structures between threads without worrying about synchronization.
However (as with the rest of herd), each function will have its own copy of the data, so the only way to communicate between threads is via the return value.</p>

<p dir="auto"><strong>Dynamic typing</strong>
I&#39;m not generally a fan of dynamic typing, but:</p>
<ul dir="auto">
<li>I wanted to learn how to build an interpreter.</li>
<li>I wanted the language to be as simple as possible.</li>
<li>I don&#39;t think this concept has ever been explored in a dynamic language before (excluding Matlab and R, which have large caveats). Swift is the closest equivalent, but it&#39;s statically typed and much more complex.</li>
</ul>
<p dir="auto"><strong>User-defined types</strong>
Herd currently has a very simple type system, with no user-defined types.
If I wanted to turn this into a production-ready language, I&#39;d probably add Julia-esque structs and multiple dispatch (following the same immutability guarantees as the rest of the language).</p>
<p dir="auto"><strong>Semicolons</strong>
This is mostly just because I&#39;m too lazy to write a whitespace-sensitive parser.</p>
<p dir="auto"><strong>var, set, and =</strong>
I took a different approach with the syntax here than most other languages I&#39;ve seen, in particular that the default for <code>=</code> is to define immutable variables, and mutating them requires a dedicated <code>set</code> keyword.</p>
<ol dir="auto">
<li>In most programs, the majority of variables can be immutable.</li>
<li>Programs define immutable variables more often than they mutate variables.</li>
</ol>
<p dir="auto">So I made immutable variable definition the &#34;default&#34;, and gave keywords to the other two operations.</p>
<p dir="auto"><strong>Function syntax</strong>
Just trying out something different which is a bit more concise than most other languages.
This is sort of a hybrid between Rust&#39;s closure syntax (but with <code>\</code> instead of <code>|</code>) and ML-style function calls (<code>f x y</code>) which require a bit less punctuation.</p>
<p dir="auto"><strong>Currying (or lack thereof)</strong>
Currying has a lot of nice properties for language implementation and reasoning, but personally I don&#39;t think it&#39;s a good fit for herd and would make the language less approachable.</p>
<ul dir="auto">
<li>With currying, we can&#39;t produce a good error message when the user calls a function with the wrong number of arguments.</li>
<li>Currying is incompatible with varargs functions (which I admittedly haven&#39;t implemented yet).</li>
<li>It&#39;s still possible to explicitly partially apply a function using the <code>\(func x _)</code> syntax.</li>
</ul>

<p dir="auto">Herd uses a very naive single-pass JIT compiler to convert code to machine code at runtime, with cranelift for generating the final optimized machine code. This results in surprisingly good performance - not in the same league as modern JS runtimes, but competitive or faster than many interpreted languages (e.g. CPython).</p>
<p dir="auto">Values in Herd are represented using NaN-boxing, so primitive types (number, bool, unit) can be stored without any heap allocation. I chose this over tagged pointers, because it makes it much easier to get good numerical performance (at least for 64-bit floats) without complex inlining logic.</p>
<p dir="auto">The current biggest performance gaps in herd are:</p>
<ol dir="auto">
<li>Atomic reference counting overhead, particurly for array/list mutations in hot loops. A lot of this could be removed by lifting the atomic operations out of loops, so the hot code can safely mutate its owned copy.</li>
<li>The single-pass JIT compiler adds some startup overhead by compiling all imported code, especially as the standard library and user codebase get larger. Cranelift is still pretty fast though, so this isn&#39;t a major problem.</li>
<li>The single-pass JIT also limits the optimizations that we can do, particularly around type specialization. A more advanced tracing JIT could get a bit of extra performance, but with a big complexity cost.</li>
</ol>
<p dir="auto">Here are some benchmark numbers on an i5-13600KF, comparing herd to CPython 3.11 and JavaScript (Node.js 18.6) on a selection of scripts (see <code>./benchmarks</code> for the full code):</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Benchmark</th>
<th>herd</th>
<th>js</th>
<th>python</th>
</tr>
</thead>
<tbody>
<tr>
<td>binarytrees</td>
<td>1285.1ms</td>
<td>789.1ms (-38.6%)</td>
<td>1992.4ms (55.0%)</td>
</tr>
<tr>
<td>binarytrees-m</td>
<td>211.1ms</td>
<td></td>
<td></td>
</tr>
<tr>
<td>helloworld</td>
<td>25.9ms</td>
<td>53.4ms (106.1%)</td>
<td>26.8ms (3.6%)</td>
</tr>
<tr>
<td>iterables</td>
<td>630.6ms</td>
<td></td>
<td>1360.9ms (115.8%)</td>
</tr>
<tr>
<td>mandelbrot</td>
<td>485.6ms</td>
<td>146.1ms (-69.9%)</td>
<td>3109.8ms (540.3%)</td>
</tr>
<tr>
<td>nbody</td>
<td>2998.1ms</td>
<td>86.0ms (-97.1%)</td>
<td>1898.2ms (-36.7%)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</article></div></div>
  </body>
</html>
