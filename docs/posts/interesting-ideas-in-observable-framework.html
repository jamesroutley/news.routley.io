<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/">Original</a>
    <h1>Interesting ideas in Observable Framework</h1>
    
    <div id="readability-page-1" class="page"><div>


<h2>Interesting ideas in Observable Framework</h2>
<p>3rd March 2024</p>

<p>Mike Bostock, <a href="https://observablehq.com/blog/observable-2-0">Announcing: Observable Framework</a>:</p>
<blockquote>
<p>Today we’re launching <a href="https://observablehq.com/product">Observable 2.0</a> with a bold new vision: an open-source static site generator for building fast, beautiful data apps, dashboards, and reports.</p>
<p>Our mission is to help teams communicate more effectively with data. Effective presentation of data is critical for deep insight, nuanced understanding, and informed decisions. Observable notebooks are great for ephemeral, <em>ad hoc</em> data exploration. But notebooks aren’t well-suited for polished dashboards and apps.</p>
<p>Enter <a href="https://observablehq.com/framework/">Observable Framework</a>.</p>
</blockquote>
<p>There are a lot of <em>really</em> interesting ideas in Observable Framework.</p>

<ul>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#static-site-dashboards">A static site generator for data projects and dashboards</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#javascript-in-markdown">JavaScript in Markdown</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#everything-reactive">Everything is still reactive</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#only-code-you-use">Only include the code that you use</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#cache-data-at-build">Cache your data at build time</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#comparison-to-observable-notebooks">Comparison to Observable Notebooks</a></li>
  <li><a href="https://simonwillison.net/2024/Mar/3/interesting-ideas-in-observable-framework/#change-in-strategy">A change in strategy</a></li>
</ul>

<h4 id="static-site-dashboards">A static site generator for data projects and dashboards</h4>
<p>At its heart, Observable Framework is a static site generator. You give it a mixture of Markdown and JavaScript (and potentially other languages too) and it compiles them all together into fast loading interactive pages.</p>
<p>It ships with a full featured hot-reloading server, so you can edit those files in your editor, hit save and see the changes reflected instantly in your browser.</p>
<p>Once you’re happy with your work you can run a build command to turn it into a set of static files ready to deploy to a server—or you can use the <code>npm run deploy</code> command to deploy it directly to Observable’s own authenticated sharing platform.</p>
<h4 id="javascript-in-markdown">JavaScript in Markdown</h4>
<p>The key to the design of Observable Framework is the way it uses JavaScript in Markdown to create interactive documents.</p>
<p>Here’s what that looks like:</p>
<div><pre><span># <span>This is a document</span></span>

Markdown content goes here.

This will output 1870:

<span>```</span><span>js</span>
<span>34</span> <span>*</span> <span>55</span>
<span>```</span>

And here&#39;s the current date and time, updating constantly:

<span>```</span><span>js</span>
<span>new</span> <span>Date</span>(now)
<span>```</span>

The same thing as an inline string: ${new Date(now)}</pre></div>
<p>Any Markdown code block tagged <code>js</code> will be executed as JavaScript in the user’s browser. This is an <em>incredibly</em> powerful abstraction—anything you can do in JavaScript (which these days is effectively anything at all) can now be seamlessly integrated into your document.</p>
<p>In the above example the <code>now</code> value is interesting—it’s a special variable that provides the current time in milliseconds since the epoch, updating constantly. Because <code>now</code> updates constantly, the display value of the cell and that inline expression will update constantly as well.</p>
<p>If you’ve used Observable Notebooks before this will feel familiar—but notebooks involve code and markdown authored in separate cells. With Framework they are all now part of a single text document.</p>
<p>Aside: when I tried the above example I found that the <code>${new Date(now)}</code> inline expression displayed as <code>Mon Feb 19 2024 20:46:02 GMT-0800 (Pacific Standard Time)</code> while the <code>js</code> block displayed as <code>2024-02-20T04:46:02.641Z</code>. That’s because inline expressions use the JavaScript default string representation of the object, while the <code>js</code> block uses the Observable <code>display()</code> function which has its own rules for how to display different types of objects, <a href="https://github.com/observablehq/inspector/blob/main/src/inspect.js">visible in inspect/src/inspect.js</a>.</p>
<h4 id="everything-reactive">Everything is still reactive</h4>
<p>The best feature of Observable Notebooks is their <em>reactivity</em>—the way cells automatically refresh when other cells they depend on change. This is a big difference to Python’s popular Jupyter notebooks, and is the signature feature of <a href="https://marimo.io/">marimo</a>, a new Python notebook tool.</p>
<p>Observable Framework retains this feature in its new JavaScript Markdown documents.</p>
<p>This is particularly useful when working with form inputs. You can drop an input onto a page and refer its value throughout the rest of the document, adding realtime interactivity to documents incredibly easily.</p>
<p>Here’s an example. I ported one of my <a href="https://observablehq.com/@simonw/datasette-downloads-per-day-with-observable-plot">favourite notebooks</a> to Framework, which provides a tool for viewing download statistics for my various Python packages.</p>
<p>The Observable Framework version can be found at <a href="https://simonw.github.io/observable-framework-experiments/package-downloads">https://simonw.github.io/observable-framework-experiments/package-downloads</a>—source code <a href="https://github.com/simonw/observable-framework-experiments/blob/main/docs/package-downloads.md">here on GitHub</a>.</p>
<p><img src="https://static.simonwillison.net/static/2024/pypi-dashboard.gif" alt="Animated demo showing PyPI download stats for Datasette projects - as I switch a select menu between sqlite-utils and csv-diff and shot-scraper the displayed chart updates to match."/></p>
<p>This entire thing is just 57 lines of Markdown. Here’s the code with additional comments (and presented in a slightly different order—the order of code blocks doesn’t matter in Observable thanks to reactivity).</p>
<div><pre><span># <span>PyPI download stats for Datasette projects</span></span>

Showing downloads for <span>**</span>${packageName}<span>**</span></pre></div>
<p>It starts with a Markdown <code>&lt;h1&gt;</code> heading and text that shows the name of the selected package.</p>
<div><pre><span>```</span><span>js</span> echo
<span>const</span> <span>packageName</span> <span>=</span> <span>view</span>(<span>Inputs</span>.<span>select</span>(packages, {
  value<span>:</span> <span><span>&#34;</span>sqlite-utils<span>&#34;</span></span>,
  label<span>:</span> <span><span>&#34;</span>Package<span>&#34;</span></span>
}));
<span>```</span></pre></div>
<p>This block displays the select widget allowing the user to pick one of the items from the <code>packages</code> array (defined later on).</p>
<p><code>Inputs.select()</code> is a built-in method provided by Framework, described in the <a href="https://observablehq.com/framework/lib/inputs">Observable Inputs</a> documentation.</p>
<p>The <code>view()</code> function is new in Observable Framework—it’s the thing that enables the reactivity, ensuring that updates to the input selection are acted on by other code blocks in the document.</p>
<p>Because <code>packageName</code> is defined with <code>const</code> it becomes a variable that is visible to other <code>js</code> blocks on the page. It’s used by this next block:</p>
<div><pre><span>```</span><span>js</span> echo
<span>const</span> <span>data</span> <span>=</span> <span>d3</span>.<span>json</span>(
  <span><span>`</span>https://datasette.io/content/stats.json?_size=max&amp;package=<span><span>${</span>packageName<span>}</span></span>&amp;_sort_desc=date&amp;_shape=array<span>`</span></span>
);</pre></div>
<p>Here we are fetching the data that we need for the chart. I’m using <code>d3.json()</code> (all of D3 is available in Framework) to fetch the data from a URL that includes the selected package name.</p>
<p>The data is coming from <a href="https://datasette.io/">Datasette</a>, using the Datasette JSON API. I have a SQLite table at <a href="https://datasette.io/content/stats">datasette.io/content/stats</a> that’s updated once a day with the latest PyPI package statistics via a convoluted series of GitHub Actions workflows, <a href="https://simonwillison.net/2021/Jul/28/baked-data/#baked-data-datasette-io">described previously</a>.</p>
<p>Adding <code>.json</code> to that URL returns the JSON, then I ask for rows for that particular package, sorted descending by date and returning the maximum number of rows (1,000) as a JSON array of objects.</p>
<p>Now that we have <code>data</code> as a variable we can manipulate it slightly for use with Observable Plot—parsing the SQLite string dates into JavaScript <code>Date</code> objects:</p>
<div><pre><span>```</span><span>js</span> echo
<span>const</span> <span>data_with_dates</span> <span>=</span> <span>data</span>.<span>map</span>(<span>function</span>(<span>d</span>) {
  d.date = d3.<span>timeParse</span>(<span><span>&#34;</span>%Y-%m-%d<span>&#34;</span></span>)(d.date);
  return d;
})
```</pre></div>
<p>This code is ready to render as a chart. I’m using <a href="https://observablehq.com/plot">Observable Plot</a>—also packaged with Framework:</p>
<pre><code>```js echo
Plot.plot({
  y: {
    grid: true,
    label: `${packageName} PyPI downloads per day`
  },
  width: width,
  marginLeft: 60,
  marks: [
    Plot.line(data_with_dates, {
      x: &#34;date&#34;,
      y: &#34;downloads&#34;,
      title: &#34;downloads&#34;,
      tip: true
    })
  ]
})
```
</code></pre>
<p>So we have one cell that lets the user pick the package they want, a cell that fetches that data, a cell that processes it and a cell that renders it as a chart.</p>
<p>There’s one more piece of the puzzle: where does that list of packages come from? I fetch that with another API call to Datasette. Here I’m using a SQL query executed against the <a href="https://datasette.io/content">/content</a> database directly:</p>
<div><pre><span>```</span><span>js</span> echo
<span>const</span> <span>packages_sql</span> <span>=</span> <span><span>&#34;</span>select package from stats group by package order by max(downloads) desc<span>&#34;</span></span>
<span>```</span>
<span>```</span><span>js</span> echo
<span>const</span> <span>packages</span> <span>=</span> <span>fetch</span>(
  <span><span>`</span>https://datasette.io/content.json?sql=<span><span>${</span><span>encodeURIComponent</span>(</span></span>
<span><span>    packages_sql</span></span>
<span><span>  )<span>}</span></span>&amp;_size=max&amp;_shape=arrayfirst<span>`</span></span>
).<span>then</span>((<span>r</span>) <span>=&gt;</span> <span>r</span>.<span>json</span>());
<span>```</span></pre></div>
<p><code>_shape=arrayfirst</code> is a shortcut for getting back a JSON array of the first column of the resulting rows.</p>
<p>That’s all there is to it! It’s a pretty tiny amount of code for a full interactive dashboard.</p>
<h4 id="only-code-you-use">Only include the code that you use</h4>
<p>You may have noticed that my dashboard example uses several additional libraries—<code>Inputs</code> for the form element, <code>d3</code> for the data fetching and <code>Plot</code> for the chart rendering.</p>
<p>Observable Framework is smart about these. It implements lazy loading in development mode, so code is only loaded the first time you attempt to use it in a cell.</p>
<p>When you build and deploy your application, Framework automatically loads just the referenced library code from the <a href="https://www.jsdelivr.com/">jsdelivr CDN</a>.</p>
<h4 id="cache-data-at-build">Cache your data at build time</h4>
<p>One of the most interesting features of Framework is its <a href="https://observablehq.com/framework/loaders">Data loader</a> mechanism.</p>
<p>Dashboards built using Framework can load data at runtime from anywhere using <code>fetch()</code> requests (or wrappers around them). This is how Observable Notebooks work too, but it leaves the performance of your dashboard at the mercy of whatever backends you are talking to.</p>
<p>Dashboards benefit from fast loading times. Framework encourages a pattern where you build the data for the dashboard at deploy time, bundling it together into static files containing just the subset of the data needed for the dashboard. These can be served lightning fast from the same static hosting as the dashboard code itself.</p>
<p>The design of the data loaders is beautifully simple and powerful. A data loader is a script that can be written in <em>any</em> programming language. At build time, Framework executes that script and saves whatever is outputs to a file.</p>
<p>A data loader can be as simple as the following, saved as <code>quakes.json.sh</code>:</p>
<div><pre>curl https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson</pre></div>
<p>When the application is built, that filename tells Framework the destination file (<code>quakes.json</code>) and the loader to execute (<code>.sh</code>).</p>
<p>This means you can load data from any source using any technology you like, provided it has the ability to output JSON or CSV or some other useful format to standard output.</p>
<h4 id="comparison-to-observable-notebooks">Comparison to Observable Notebooks</h4>
<p>Mike introduced Observable Framework as <em>Observable 2.0</em>. It’s worth reviewing how the this system compares to the original Observable Notebook platform.</p>
<p>I’ve been a huge fan of Observable Notebooks for years—<a href="https://simonwillison.net/tags/observable/">38 blog posts and counting</a>! The most obvious comparison is to Jupyter Notebooks, where they have some key differences:</p>
<ul>
<li>Observable notebooks use JavaScript, not Python.</li>
<li>The notebook editor itself isn’t open source—it’s a hosted product provided on <a href="https://observablehq.com/">observablehq.com</a>. You can export the notebooks as static files and run them anywhere you like, but the editor itself is a proprietary product.</li>
<li>Observable cells are <em>reactive</em>. This is the key difference with Jupyter: any time you change a cell all other cells that depend on that cell are automatically re-evaluated, similar to Excel.</li>
<li>The JavaScript syntax they use isn’t quite standard JavaScript—they had to invent a new <code>viewof</code> keyword to support their reactivity model.</li>
<li>Editable notebooks are a pretty complex proprietary file format. They don’t play well with tools like Git, to the point that Observable ended up implementing their own custom version control and collaboration systems.</li>
</ul>
<p>Observable Framework reuses many of the ideas (and code) from Observable Notebooks, but with some crucial differences:</p>
<ul>
<li>Notebooks (really documents) are now <strong>single text files</strong>—Markdown files with embedded JavaScript blocks. It’s all still reactive, but the file format is much simpler and can be edited using any text editor, and checked into Git.</li>
<li>It’s <strong>all open source</strong>. Everything is under an ISC license (OSI approved) and you can run the full editing stack on your own machine.</li>
<li>It’s all just standard JavaScript now—<strong>no custom syntax</strong>.</li>
</ul>
<h4 id="change-in-strategy">A change in strategy</h4>
<p>Reading the tea leaves a bit, this also looks to me like a strategic change of direction for Observable as a company. Their previous focus was on building great collaboration tools for data science and analytics teams, based around the proprietary Observable Notebook editor.</p>
<p>With Framework they appear to be leaning more into the developer tools space.</p>
<p>On Twitter <a href="https://twitter.com/observablehq">@observablehq</a> describes itself as “The end-to-end solution for developers who want to build and host dashboards that don’t suck”—the Internet Archive copy <a href="https://web.archive.org/web/20231003212202/https://twitter.com/observablehq">from October 3rd 2023</a> showed “Build data visualizations, dashboards, and data apps that impact your business — faster.”</p>
<p>I’m excited to see where this goes. I’ve limited my usage of Observable Notebooks a little in the past purely due to the proprietary nature of their platform and the limitations placed on free accounts (mainly the lack of free private notebooks), while still having enormous respect for the technology and enthusiastically adopting their open source libraries such as <a href="https://observablehq.com/plot/">Observable Plot</a>.</p>
<p>Observable Framework addresses basically all of my reservations. It’s a fantastic new expression of the ideas that made Observable Notebooks so compelling, and I expect to use it for all sorts of interesting projects in the future.</p>




</div></div>
  </body>
</html>
