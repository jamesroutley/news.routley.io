<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://two-wrongs.com/unreasonable-effectiveness-of-conditional-probabilities.html">Original</a>
    <h1>The Unreasonable Effectiveness of Conditional Probabilities</h1>
    
    <div id="readability-page-1" class="page"><div>
                

<p>
I have been steeping myself in probabilistic exercises recently, because it’s an
area where I feel like I could benefit from building better intuition. I have
found a recurring key to solving many of them: conditioning on an intermediary
state, and then computing the value of that intermediary state separately. This
turns very difficult problems into ones where the solution is almost
obvious.<span><sup>1</sup> Although sometimes we are trading efficiency for simplicity, here.</span>
</p>

<p>
That was useful in the <a href="https://two-wrongs.com/birthday-line-puzzle.html">Birthday Line Puzzle</a>, but here are three more examples
where it shows up. If you find the a problem uninteresting, scroll on down
to the next – they’re all different.
</p>


<section id="outline-container-orgb935fe8">

<div id="text-orgb935fe8">
<blockquote>
<p>
A fast food franchise includes a toy in their child-size meals. There
are four different toys. Each meal costs $8. How much do you expect to pay
before you have all four toys?
</p>
</blockquote>

<p>
As always with these types of problems, start by gut feeling your way toward a
rough approximation.<span><sup>2</sup> The minimum number of meals would be four, and I would
be very surprised if it took anyone more than 25 meals, so maybe a reasonable
guess for the expected cost is in the range of $50–120 ? It’s a very rough
estimation, but better than none at all!</span> Sometimes you need to get a solution
to a problem out quickly while you’re working on a more accurate one, and then
it’s useful to have practised your gut feeling.
</p>
</div>

<div id="outline-container-org1a0e1d0">
<h2 id="org1a0e1d0">Analysis</h2>
<div id="text-org1a0e1d0">
<p>
The cost is a simple function of the number of meals you buy, so let’s focus on
the number of meals. There are many ways to work out that expectation, but I
favour methods that build on fundamentals<span><sup>3</sup> The reason for this is that my
memory is terrible but my intelligence usually serves me well, so by focusing on
fundamentals I can memorise fewer things but apply them in a wide variety of
ways.</span>,<span><sup>4</sup> Another reason to work with fundamentals is that they are robust
against variations in problem specification. In this example, all toys have the
same probability of appearing. if they did not, that would invalidate some other
types of analysis. This one would be relatively easy to adapt to account for
that.</span>. From a fundamentals perspective, the expected number of meals is a
function of the probability of finding the fourth toy in any specific meal. To
make the solution simpler<span><sup>5</sup> More steps, but each step is simpler.</span>, we’ll
start by looking at the probability of <i>having</i> four toys (not finding the fourth
toy) after having bought any number of meals.
</p>

<p>
We are going to write the probability of having \(k\) toys after \(i\) meals as
\(P(n_i=k)\). Some examples are trivial:
</p>

<ul>
<li>\(P(n_1=1) = 1\), because after the first meal we are guaranteed to have one toy.</li>

<li>\(P(n_1=4) = 0\), because after the first meal we are guaranteed not to have four
toys.</li>

<li>Similarly, \(P(n_2=3) = 0\), because after the second meal we have, at best, two
toys, not three.</li>

<li>We can probably also guess that \(P(n_{99}=1)\) is very small, because after 99
meals we would be extremely unlucky to still have only one toy.</li>

<li>Similarly, we may think that \(P(n_{99}=4)\) is very close to 1, because after 99
meals, we can be very sure that we have found all four toys.</li>
</ul>

<p>
Computing this probability for any combination of \(i\) and \(k\) is formidable, but
we can break it up into multiple, easier, parts. If we have three toys after we
have eaten the sixth meal, there are only two ways that can happen. Either
</p>

<ul>
<li>we had three toys also after the fifth meal, and we didn’t find the fourth toy
this meal; or</li>

<li>we had only two toys after the fifth meal, and we did find the third toy this
meal.</li>
</ul>

<p>
In more general mathematical notation, we would write that as
</p>

<p>
\[P(n_i=k) = P(n_i=k, n_{i-1}=k) + P(n_i=k, n_{i-1}=k-1).\]
</p>

<p>
We are one step closer, but not quite there yet. What is the probability of e.g.
\(P(n_i = k, n_{i-1}=k)\)? I.e. what’s the probability that we had \(k\) toys after the
previous meal, and still have \(k\) now? We can split that up further, and this
is where the power of conditional probabilities come in. Probability laws tell
us that
</p>

<p>
\[P(a, b) = P(a \mid b) \times P(b),\]
</p>

<p>
i.e. the probaiblity that \(a\) and \(b\) happens is equal to the probability that
\(a\) happens given that \(b\) has already happened, times the probability that \(b\)
happens in the first place. Applied to our example, we have
</p>

<p>
\[P(n_i=k, n_{i-1}=k) = P(n_i=k \mid n_{i-1} = k) \times P(n_{i-1} = k).\]
</p>

<p>
The first of these factors, \(P(n_i=k \mid n_{i-1} = k)\) is the probability of
not finding the next toy in meal \(i\). This depends only on how many toys we
have: if we have one toy, the probability of getting that same toy again is 1/4.
If we have three toys, the probability of getting any of them again is 3/4.
</p>

<p>
The second factor, \(P(n_{i-1} = k)\) can be computed recursively.
</p>

<p>
Similar reasoning applies to the other case where we do find toy \(k\) in meal
\(i\). In the end, the probability of
having \(k\) toys after \(i\) meals is
</p>

<p>
\[\begin{array}{l}
P(n_i=k) &amp;= &amp;P(n_i=k &amp;\mid &amp;n_{i-1}&amp;=&amp;k) &amp;\times &amp;P(n_{i-1}&amp;=&amp;k) \\
&amp;+ &amp;P(n_i=k &amp;\mid &amp;n_{i-1}&amp;=&amp;k-1) &amp;\times &amp;P(n_{i-1}&amp;=&amp;k-1).
\end{array}\]
</p>

<p>
If you read it carefully, you should be able to figure out the intuitive meaning
of each factor. Given what we know about the conditional probabilities, we can
also simplify the calculation a bit more.<span><sup>6</sup> If you are confused about the 5-k
numerator: Given that we have \(k-1\) toys after meal \(i-1\), the probability of
finidng toy \(k\) in this meal depends only on how many toys we are missing. if we
are looking for the last toy, the probability of finding it is 1/4. One place
it’s easy to slip here is that if we are looking for toy \(k\), that means we are
missing not just 4-k toys, but 4-(k-1) = 5-k toys.</span>
</p>

<p>
\[P(n_i=k) = \frac{k}{4} \times P(n_{i-1}=k) + \frac{5-k}{4} \times P(n_{i-1}=k-1)\]
</p>
</div>
</div>

<div id="outline-container-orgec7c305">
<h2 id="orgec7c305">Spreadsheet Sketch</h2>
<div id="text-orgec7c305">
<p>
We can, in principle, calculate this in a spreadseheet. For the first meal, we
hard-code (1,0,0,0) because we will find the first toy in that first meal, and
it gives the recursion a base case to rest on. Similarly, the probaiblity of
having 0 toys is 0 after every meal – also a base case for the recursion. Then
for each cell, we set it to be k/4 times the cell to the left, and (5-k)/4 times
the cell above and to the left.<span><sup>7</sup> It surprised me that, after eating four
meals, there’s a much larger probaility that we have all four toys (9 %) than
that we still have just one (2 %). To my intuition, those two cases both seem
like equally unlikely flukes – either we get the same toy in every meal, or we
get a different one in every meal. The reason four toys is more likely is that
it offers more choices for the order in which second, third, and fourth toy are
received.</span>
</p>

<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Toy\Meal</th>
<th scope="col">1</th>
<th scope="col">2</th>
<th scope="col">3</th>
<th scope="col">4</th>
<th scope="col">5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>

<tr>
<td>1</td>
<td>1.00</td>
<td>0.25</td>
<td>0.06</td>
<td>0.02</td>
<td>0</td>
</tr>

<tr>
<td>2</td>
<td>0</td>
<td>0.75</td>
<td>0.56</td>
<td>0.33</td>
<td>0.18</td>
</tr>

<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0.38</td>
<td>0.56</td>
<td>0.59</td>
</tr>

<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.09</td>
<td>0.23</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc1517bf">
<h2 id="orgc1517bf">Naïve Python</h2>
<div id="text-orgc1517bf">
<p>
When we get tired of autofilling cells in spreadsheets, we can also
write the recursion in something like Python, and ask for the probability of
having four toys after eating five meals, for example. According to our
spreadsheet sketch, this should be 23 %.
</p>

<p><label>In[1]:</label></p><div>
<pre><span>import</span> functools

<span>@functools.cache</span>
<span>def</span> <span>P</span>(i, k):
    <span>if</span> i == 1:
        <span>return</span> 1 <span>if</span> k == 1 <span>else</span> 0

    <span>p_found</span> = (5-k)/4 * P(i-1, k-1)
    <span>p_notfound</span> = k/4 * P(i-1, k)

    <span>return</span> p_found + p_notfound

<span>print</span>(P(i=5, k=4))
</pre>
</div>

<p><label>Out[1]:</label></p><pre>0.234375
</pre>


<p>
And it is!
</p>
</div>
</div>


<div id="outline-container-orgb7150d1">
<h2 id="orgb7150d1">Dynamic Programming</h2>
<div id="text-orgb7150d1">
<p>
However, if we try to use this to find the probability of having four
toys after every meal, we may run into a problem that the recursion is
inefficient. Since every meal depends only on the meal before, and the number of
toys we find cannot decrease, we can use dynamic programming instead of
recursion.
</p>

<p>
This function will return a generator for the probability of having four toys
after every meal. If we slice out the first five probabilities, they should
mirror what we had in our spreadsheet.
</p>

<p><label>In[2]:</label></p><div>
<pre><span>from</span> itertools <span>import</span> islice

<span>def</span> <span>P_k4</span>():
    <span># </span><span>&#34;First-meal&#34; base case of the recursion.</span>
    <span>p_n</span> = [0, 1, 0, 0, 0]
    <span>while</span> <span>True</span>:
        <span>yield</span> p_n[4]
        <span># </span><span>Update &#34;backwards&#34; because data dependencies.</span>
        <span>for</span> n <span>in</span> (4, 3, 2, 1):
            <span># </span><span>Other base case embedded here.</span>
            <span>p_found</span> = 0 <span>if</span> n == 1 <span>else</span> (5-n)/4 * p_n[n-1]
            <span>p_notfound</span> = n/4 * p_n[n]
            <span>p_n</span>[n] = p_found + p_notfound

<span>print</span>(<span>list</span>(islice(P_k4(), 5)))
</pre>
</div>

<p><label>Out[2]:</label></p><pre>[0, 0.0, 0.0, 0.09375, 0.234375]
</pre>


<p>
They do!
</p>
</div>
</div>


<div id="outline-container-orgc76f00e">
<h2 id="orgc76f00e">Expected Meal Count</h2>
<div id="text-orgc76f00e">
<p>
What we have now is a way to figure out what the probability is of <i>having</i> four
toys after a given number of meals. The original question we wanted to answer
was about the probability of <i>finding</i> the fourth toy. However, if we take the
probability of having the fourth toy after meal 9, and subtract the probability
of having the fourth toy after meal 8, then we get the probability of having
found the fourth toy in meal 9.
</p>

<p>
We create a new generator based on the one we have which computes these
successive differences.
</p>

<p><label>In[3]:</label></p><div>
<pre><span>def</span> <span>P_finding4</span>():
    <span># </span><span>First meal has a 0 probability of containing fourth toy.</span>
    <span>yield</span> 0
    <span># </span><span>Create two generators, offset one of them.</span>
    <span>distr</span>, <span>offset</span> = P_k4(), P_k4()
    <span>next</span>(offset)
    <span># </span><span>Compute the successive differences.</span>
    <span>for</span> a, b <span>in</span> <span>zip</span>(distr, offset):
        <span>yield</span> b - a
</pre>
</div>

<p>
Then we can use this to compute the expected number of meals we’ll go through,
by multiplying the probability of finding the fourth toy in each meal with its
meal number. Since we have an infinite number of such probabilities, we’ll have
to limit this computation to, say, the first 150, which seems to contain most of
the information of the entire series.<span><sup>8</sup> How did I arrive at 150? I just tried
a bunch of numbers until the result stabilised.</span>
</p>

<p><label>In[4]:</label></p><div>
<pre><span>find_probabilities</span> = islice(P_finding4(), 150)
<span>expectation</span> = <span>sum</span>(
    p*(i+1) <span>for</span> i, p <span>in</span> <span>enumerate</span>(find_probabilities)
)
<span>print</span>(expectation)
</pre>
</div>

<p><label>Out[3]:</label></p><pre>8.33333333333334
</pre>


<p>
This is the number of meals we should expect to buy! At $8 apiece, we should
expect to spend about $67. Depending on the quality of toys and their
collectible value, that might be a tad much.
</p>
</div>
</div>

<div id="outline-container-org43dfbd9">
<h2 id="org43dfbd9">Validation</h2>
<div id="text-org43dfbd9">
<p>
We want to validate our calculations. Fortunately, this scenario is small enough
that we can just simulate it outright. We write one function that simulates
buying meals until it has got all four toys<span><sup>9</sup> What about the iteration limit?
Doesn’t matter for the simulation because in practise it will always find all
four toys well before it has bought a thousand meals. It’s just that having
anything that can potentially turn into an infinite loop is a bad idea for
production code, so I have the habit of always encoding iteration limits on
these things if I can’t prove they will terminate on their own.</span>, and another
that runs this simulation a large number of times to get the average number of
meals purchased.
</p>

<p><label>In[5]:</label></p><div>
<pre><span>import</span> random

<span>def</span> <span>buy_meals_until_all_toys</span>(iterlimit=1000):
    <span>owned_toys</span> = [<span>False</span>] * 4

    <span>for</span> i <span>in</span> <span>range</span>(iterlimit):
        <span>owned_toys</span>[random.randrange(0, 4)] = <span>True</span>
        <span>if</span> <span>all</span>(owned_toys):
            <span>return</span> i+1

    <span>raise</span> <span>Exception</span>(f<span>&#39;Expected simulation to finish in {iterlimit} iterations.&#39;</span>)

<span>def</span> <span>estimate_expectation</span>(n=5000):
    <span>total</span> = 0
    <span>for</span> i <span>in</span> <span>range</span>(n):
        <span>total</span> += buy_meals_until_all_toys()
    <span>return</span> total/n

<span>print</span>(estimate_expectation())
</pre>
</div>

<p><label>Out[4]:</label></p><pre>8.3564
</pre>


<p>
It is indeed close to the theoretical 8.33 value we found before. Good!
</p>
</div>
</div>
</section>


<section id="outline-container-org9e7d20f">

<div id="text-org9e7d20f">
<blockquote>
<p>
The game master rolls a die once. You win a dollar amount equal to the number of
pips on the side that is up, but you can exchange your winnings (whatever they
were) for a new roll. You can do this two times – in other words, on the third
roll you have to accept whatever winnings you get. It costs $4 to enter this
game. Would you play?
</p>
</blockquote>

<p>
The question is whether the expected value, or <abbr>ev</abbr>, of the first throw exceeds
the $4 cost of entering the game. That sounds tough to figure out. However, we
can quickly rattle off the <abbr>ev</abbr> of the third throw: $3.5.<span><sup>10</sup> This is the
average number of pips a die will show.</span> We can go backwards from there. If we
assume we’ve chosen to do the second roll, then our choice is between keeping
our current winnings (a known number in the 1–6 range) or we take our chances on
the last roll, <abbr>ev</abbr> 3.5.
</p>

<p>
Clearly, if our second roll ended up being 1–3, we should take our chances on
the third roll. If our second roll ended up being 4–6, we will on average earn
more by keeping those winnings and not rolling again. What, then, is the <abbr>ev</abbr> of
the second roll? There are two possibilities:
</p>

<ul>
<li>It ends up showing 1–3, in which case the <abbr>ev</abbr> is that of the third roll we go
on to: 3.5; or</li>

<li>It ends up showing 4–6, we keep whatever it shows and in this case the <abbr>ev</abbr> is
the average of those numbers: 5.</li>
</ul>

<p>
Both of these outcomes are equally likely, meaning the <abbr>ev</abbr> is
(3.5+5)/2 = 4.25.
</p>

<p>
We use the same reasoning to go back to the first throw. Given the <abbr>ev</abbr> of the
second throw, we would keep our winnings on the first throw only if they are 5
or 6. This means the first throw has an <abbr>ev</abbr> of 2/6 × 5.5 + 4/6 × 4.25 = 4.67.
</p>

<p>
If someone charges us just $4 for this, we should play as much as we can, for an
average profit of $0.67 per game! But the reason we can work this out is that
we’re able to condition on the outcome of the previous throw, and we know the
probabilities of that.
</p>
</div>
</section>


<section id="outline-container-orge2cd943">

<div id="text-orge2cd943">
<blockquote>
<p>
Team Alpha plays a series of games against team Bravo, with the winner of the
series being the first to win two games. Your friend wants to wager on team
Alpha taking the entire series (i.e. being the first to two wins), but the
bookies will only allow wagers on individual games, with odds 2:1, meaning you
pay $1 to enter the wager, and if you have picked the winning team you get $2
back, otherwise nothing.
</p>

<p>
You tell your friend that you will be counterparty to their bet, and pay out
twice what they pay you if Alpha wins, otherwise nothing. Are you making a
mistake?
</p>
</blockquote>

<p>
Assuming you don’t want to hold the risk of that bet, the question is really
“for each $1 your friend gives you, <i>can you place it on the individual games</i>
with the bookies such that at the end, you get $2 if Alpha takes the entire
series, and nothing otherwise?”
</p>

<p>
The series structure can be drawn like this.<span><sup>11</sup> The white nodes represent
games, and the score in the node is the record of wins to each team before the
game starts. The black nodes indicate that a winner is determined and no more
games are played, and the series result is indicated in the node.</span>
</p>


<p><img src="https://two-wrongs.com/image/eff-cond-prob-01.png" alt="eff-cond-prob-01.png"/>
</p>

<p>
In the outcomes represented by the two top black nodes, we need to be in
possession of $2, and in the bottom two nodes, nothing. For clarity, let’s add
this information to the graph.
</p>


<p><img src="https://two-wrongs.com/image/eff-cond-prob-02.png" alt="eff-cond-prob-02.png"/>
</p>


<p>
This puts a constraint on the 1–1 game: we need to place a bet such that if
Alpha wins, we get $2, and if Alpha loses, we have nothing. Some thinking will
lead to the answer: before that game, we must be in possession of $1, and place
it all on Alpha winning the game. We’ll add that to the graph too.
</p>



<p><img src="https://two-wrongs.com/image/eff-cond-prob-03.png" alt="eff-cond-prob-03.png"/>
</p>

<p>
Now the process repeats. This has put a constraint on the 1–0 game. We have to
possess and wager money such that if Alpha wins, we have $2, and if Alpha loses,
we still have $1. This can only happen if we have $1.5, and wager $0.5. This
continues all the way to the first game:
</p>


<p><img src="https://two-wrongs.com/image/eff-cond-prob-04.png" alt="eff-cond-prob-04.png"/>
</p>

<p>
In other words, as long as the odds for all games are set in advance, we can
replicate the 2:1 series bet by cleverly betting on the individual games. We
figured out how by conditioning on the outcome of earlier games.
</p>
</div>


<div id="outline-container-orgae73759">
<h2 id="orgae73759">Spreadsheet Sketch</h2>
<div id="text-orgae73759">
<p>
In this small number of games, we could do the calculations manually. If the
teams play more games, we might want to make a spreadsheet. If we tilt our head,
the nodes in the graphs above actually sort of make up a coordinate system,
where each axis counts the number of wins by the corresponding team.
</p>

<p>
So we can start our spreadsheet by filling in the boundary conditions, here for
a first-to-three-wins series, again, with 2:1 odds on both individual games and
the series. In each cell is the amount of money we have in the outcome in
question.
</p>

<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td> </td>
<td><b>0 wins A</b></td>
<td><b>1 win A</b></td>
<td><b>2 wins A</b></td>
<td><b>3 wins A</b></td>
</tr>

<tr>
<td><b>0 wins B</b></td>
<td> </td>
<td> </td>
<td> </td>
<td>2</td>
</tr>

<tr>
<td><b>1 win B</b></td>
<td> </td>
<td> </td>
<td> </td>
<td>2</td>
</tr>

<tr>
<td><b>2 wins B</b></td>
<td> </td>
<td> </td>
<td> </td>
<td>2</td>
</tr>

<tr>
<td><b>3 wins B</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>–</td>
</tr>
</tbody>
</table>

<p>
Now, for each game, we have the following equations:
</p>

<p>
\[w + x = R\]
</p>

<p>
\[w - x = D\]
</p>

<p>
where \(w\) is wealth before the game, \(x\) is bet size, \(R\) is the cell to the
right and \(D\) is the cell below. We can add those together to cancel out the bet
size, and then we learn that
</p>

<p>
\[2w = R + D\]
</p>

<p>
or simply that the wealth in each cell should be the average of the win and the
loss on that bet. (Due to the 2:1 odds.)
</p>

<p>
We plug this in and autofill from the bottom right to the top left.
</p>

<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td> </td>
<td><b>0 wins A</b></td>
<td><b>1 win A</b></td>
<td><b>2 wins A</b></td>
<td><b>3 wins A</b></td>
</tr>

<tr>
<td><b>0 wins B</b></td>
<td>1.00</td>
<td>1.38</td>
<td>1.75</td>
<td>2</td>
</tr>

<tr>
<td><b>1 win B</b></td>
<td>0.63</td>
<td>1.00</td>
<td>1.50</td>
<td>2</td>
</tr>

<tr>
<td><b>2 wins B</b></td>
<td>0.25</td>
<td>0.5</td>
<td>1.00</td>
<td>2</td>
</tr>

<tr>
<td><b>3 wins B</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>–</td>
</tr>
</tbody>
</table>

<p>
This doesn’t tell us directly how to bet, only how much money to have in various
situations. But we can derive how much to bet from this, using the same
equations as above.
</p>

<p>
If the odds are something other than 2:1, e.g. 1.63, we would end up with only a
tiny bit more complicated equations:
</p>

<p>
\[w + 0.63x = R\]
</p>

<p>
\[w - x = D\]
</p>

<p>
which combined give us \(w = (1.59R + W)/2.59\). If we plug that formula into our
spreadsheet instead, we’ll see that to end up with $1 if A wins, we have to
start with $0.71.
</p>

<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>

<col/>
</colgroup>
<tbody>
<tr>
<td> </td>
<td><b>0 wins A</b></td>
<td><b>1 win A</b></td>
<td><b>2 wins A</b></td>
<td><b>3 wins A</b></td>
</tr>

<tr>
<td><b>0 wins B</b></td>
<td>0.71</td>
<td>0.83</td>
<td>0.94</td>
<td>1</td>
</tr>

<tr>
<td><b>1 win B</b></td>
<td>0.50</td>
<td>0.67</td>
<td>0.85</td>
<td>1</td>
</tr>

<tr>
<td><b>2 wins B</b></td>
<td>0.23</td>
<td>0.38</td>
<td>0.61</td>
<td>1</td>
</tr>

<tr>
<td><b>3 wins B</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>–</td>
</tr>
</tbody>
</table>

<p>
From this, we learn that the appropriate odds for the entire series, based on
the odds for the individual games, is 0.71:1, or 1.41 decimal.
</p>
</div>
</div>
</section>

            </div></div>
  </body>
</html>
