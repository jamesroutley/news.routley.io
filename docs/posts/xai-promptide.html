<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://x.ai/prompt-ide/">Original</a>
    <h1>XAI PromptIDE</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><p>Integrated development environment for prompt engineering and interpretability research</p></div></div></section><section class="page"><div><div><p><small>November 6, 2023</small></p><p><strong>The xAI PromptIDE is an integrated development environment for prompt engineering and interpretability research. It accelerates prompt engineering through an SDK that allows implementing complex prompting techniques and rich analytics that visualize the network&#39;s outputs. We use it heavily in our continuous development of <a href="https://x.ai/">Grok</a>.</strong></p><p>We developed the PromptIDE to give transparent access to Grok-1, the model that powers <a href="https://x.ai/">Grok</a>, to engineers and researchers in the community. The IDE is designed to empower users and help them explore the capabilities of our large language models (LLMs) at pace. At the heart of the IDE is a Python code editor that - combined with a new <a href="https://x.ai/ide/docs.html">SDK</a> - allows implementing complex prompting techniques. While executing prompts in the IDE, users see helpful analytics such as the precise tokenization, sampling probabilities, alternative tokens, and aggregated attention masks.</p><p>The IDE also offers quality of life features. It automatically saves all prompts and has built-in versioning. The analytics generated by running a prompt can be stored permanently allowing users to compare the outputs of different prompting techniques. Finally, users can upload small files such as CSV files and read them using a single Python function from the SDK. When combined with the SDK&#39;s concurrency features, even somewhat large files can be processed quickly.</p><p>We also hope to build a community around the PromptIDE. Any prompt can be shared publicly at the click of a button. Users can decide if they only want to share a single version of the prompt or the entire tree. It&#39;s also possible to include any stored analytics when sharing a prompt.</p><p>The PromptIDE is available to members of our early <a href="https://ide.x.ai">access program</a>. Below, you find a walkthrough of the main features of the IDE.</p><p>Thank you,</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_42.png"/></p><p>At the heart of the PromptIDE is a code editor and a <a href="https://x.ai/ide/docs.html">Python SDK</a>. The SDK provides a new programming paradigm that allows implementing complex prompting techniques elegantly. All Python functions are executed in an implicit context, which is a sequence of tokens. You can manually add tokens to the context using the <code>prompt()</code> function or you can use our models to generate tokens based on the context using the <code>sample()</code> function. When sampling from the model, you have various configuration options that are passed as argument to the function:</p><pre data-lang="python"><code data-lang="python"><span>async def </span><span>sample</span><span>(
</span><span>    </span><span>self</span><span>,
</span><span>    </span><span>max_len</span><span>: int = </span><span>256</span><span>,
</span><span>    </span><span>temperature</span><span>: float = </span><span>1.0</span><span>,
</span><span>    </span><span>nucleus_p</span><span>: float = </span><span>0.7</span><span>,
</span><span>    </span><span>stop_tokens</span><span>: Optional[list[str]] = </span><span>None</span><span>,
</span><span>    </span><span>stop_strings</span><span>: Optional[list[str]] = </span><span>None</span><span>,
</span><span>    </span><span>rng_seed</span><span>: Optional[int] = </span><span>None</span><span>,
</span><span>    </span><span>add_to_context</span><span>: bool = </span><span>True</span><span>,
</span><span>    </span><span>return_attention</span><span>: bool = </span><span>False</span><span>,
</span><span>    </span><span>allowed_tokens</span><span>: Optional[Sequence[Union[int, str]]] = </span><span>None</span><span>,
</span><span>    </span><span>disallowed_tokens</span><span>: Optional[Sequence[Union[int, str]]] = </span><span>None</span><span>,
</span><span>    </span><span>augment_tokens</span><span>: bool = </span><span>True</span><span>,
</span><span>) -&gt; SampleResult:
</span><span>    </span><span>&#34;&#34;&#34;Generates a model response based on the current prompt.
</span><span>
</span><span>    The current prompt consists of all text that has been added to the prompt either since the
</span><span>    beginning of the program or since the last call to `clear_prompt`.
</span><span>
</span><span>    Args:
</span><span>        max_len: Maximum number of tokens to generate.
</span><span>        temperature: Temperature of the final softmax operation. The lower the temperature, the
</span><span>            lower the variance of the token distribution. In the limit, the distribution collapses
</span><span>            onto the single token with the highest probability.
</span><span>        nucleus_p: Threshold of the Top-P sampling technique: We rank all tokens by their
</span><span>            probability and then only actually sample from the set of tokens that ranks in the
</span><span>            Top-P percentile of the distribution.
</span><span>        stop_tokens: A list of strings, each of which will be mapped independently to a single
</span><span>            token. If a string does not map cleanly to one token, it will be silently ignored.
</span><span>            If the network samples one of these tokens, sampling is stopped and the stop token
</span><span>            *is not* included in the response.
</span><span>        stop_strings: A list of strings. If any of these strings occurs in the network output,
</span><span>            sampling is stopped but the string that triggered the stop *will be* included in the
</span><span>            response. Note that the response may be longer than the stop string. For example, if
</span><span>            the stop string is &#34;Hel&#34; and the network predicts the single-token response &#34;Hello&#34;,
</span><span>            sampling will be stopped but the response will still read &#34;Hello&#34;.
</span><span>        rng_seed: See of the random number generator used to sample from the model outputs.
</span><span>        add_to_context: If true, the generated tokens will be added to the context.
</span><span>        return_attention: If true, returns the attention mask. Note that this can significantly
</span><span>            increase the response size for long sequences.
</span><span>        allowed_tokens: If set, only these tokens can be sampled. Invalid input tokens are
</span><span>            ignored. Only one of `allowed_tokens` and `disallowed_tokens` must be set.
</span><span>        disallowed_tokens: If set, these tokens cannot be sampled. Invalid input tokens are
</span><span>            ignored. Only one of `allowed_tokens` and `disallowed_tokens` must be set.
</span><span>        augment_tokens: If true, strings passed to `stop_tokens`, `allowed_tokens` and
</span><span>            `disallowed_tokens` will be augmented to include both the passed token and the
</span><span>            version with leading whitespace. This is useful because most words have two
</span><span>            corresponding vocabulary entries: one with leading whitespace and one without.
</span><span>
</span><span>    Returns:
</span><span>        The generated text.
</span><span>    &#34;&#34;&#34;
</span></code></pre><p>The code is executed locally using an in-browser Python interpreter that runs in a separate web worker. Multiple web workers can run at the same time, which means you can execute many prompts in parallel.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_42_completion.png"/></p><p>Complex prompting techniques can be implemented using multiple contexts within the same program. If a function is annotated with the <code>@prompt_fn</code> decorator, it is executed in its own, fresh context. The function can perform some operations independently of its parent context and pass the results back to the caller using the <code>return</code> statement. This programming paradigm enables recursive and iterative prompts with arbitrarily nested sub-contexts.</p><h2 id="concurrency">Concurrency</h2><p>The SDK uses Python coroutines that enable processing multiple <code>@prompt_fn</code>-annotated Python functions concurrently. This can significantly speed up the time to completion - especially when working with CSV files.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_concurrency.png"/></p><h2 id="user-inputs">User inputs</h2><p>Prompts can be made interactive through the <code>user_input()</code> function, which blocks execution until the user has entered a string into a textbox in the UI. The <code>user_input()</code> function returns the string entered by the user, which cen then, for example, be added to the context via the <code>prompt()</code> function. Using these APIs, a chatbot can be implemented in just four lines of code:</p><pre data-lang="python"><code data-lang="python"><span>await </span><span>prompt</span><span>(</span><span>PREAMBLE</span><span>)
</span><span>while </span><span>text := </span><span>await </span><span>user_input</span><span>(&#34;</span><span>Write a message</span><span>&#34;):
</span><span>    </span><span>await </span><span>prompt</span><span>(</span><span>f</span><span>&#34;</span><span>&lt;|separator|&gt;</span><span>\n\n</span><span>Human: </span><span>{text}</span><span>&lt;|separator|&gt;</span><span>\n\n</span><span>Assistant:</span><span>&#34;)
</span><span>    </span><span>await </span><span>sample</span><span>(</span><span>max_len</span><span>=</span><span>1024</span><span>, </span><span>stop_tokens</span><span>=[&#34;</span><span>&lt;|separator|&gt;</span><span>&#34;], </span><span>return_attention</span><span>=</span><span>True</span><span>)
</span></code></pre><h2 id="files">Files</h2><p>Developers can upload small files to the PromptIDE (up to 5 MiB per file. At most 50 MiB total) and use their uploaded files in the prompt. The <code>read_file()</code> function returns any uploaded file as a byte array. When combined with the concurrency feature mentioned above, this can be used to implement batch processing prompts to evaluate a prompting technique on a variety of problems. The screenshot below shows a prompt that calculates the MMLU evaluation score.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_mmlu2.png"/></p><p>While executing a prompt, users see detailed per-token analytics to help them better understand the model&#39;s output. The completion window shows the precise tokenization of the context alongside the numeric identifiers of each token. When clicking on a token, users also see the top-K tokens after applying top-P thresholding and the aggregated attention mask at the token.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_42_completion.png"/></p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_42_token.png"/></p><p>When using the <code>user_input()</code> function, a textbox shows up in the window while the prompt is running that users can enter their response into. The below screenshot shows the result of executing the chatbot code snippet listed above.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_chat_completion.png"/></p><p>Finally, the context can also be rendered in markdown to improve legibility when the token visualization features are not required.</p><p><img alt="Sampling probabilities in the PromptIDE" src="https://x.ai/screenshot_completion_markdown.png"/></p></div></div></section></div>
  </body>
</html>
