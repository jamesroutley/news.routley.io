<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mofi.loud.red/blog/wasm-and-workers">Original</a>
    <h1>Snappy UIs with WebAssembly and Web Workers</h1>
    
    <div id="readability-page-1" class="page"><article><h2>Snappy UIs With WebAssembly and Web Workers</h2>
	<p>Published: 2023-08-07</p>
	<p>Our web app allows users can change the length of a song or find loops present in it for infinite listening, remixing, or for their next next video edit or performance. After uploading a song, there is an initial server-side analysis step after which the audio can be manipulated completely in the browser. Users can alter the desired length or mark sections of audio to prefer or avoid which will regenerate results. To make these manipulations responsive and snappy, computations happen client-side and do not need another network call (which would introduce additional latency). To make this possible, we rely on using a <a href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener" target="_blank">WebAssembly</a> binary executed inside of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener" target="_blank">Web Worker</a> (several of them actually, running in parallel). In this post, we will go over some more details of how this works.</p>
<h3>Running Fast(er) With WebAssembly</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener" target="_blank">WebAssembly</a> allows web developers to use low-level code delivered in a binary format that runs at speeds you would not be able to achieve with just JavaScript. WebAssembly (or Wasm for short) describes a low-level assembly-like language that can be targeted from a higher-level language like C, C++, or Rust. The nice thing is that you get to choose which language you want to use, as long as you can find a way to compile it down to a Wasm binary!</p>
<p>We use <a href="https://www.assemblyscript.org/" rel="noopener" target="_blank">AssemblyScript</a> which allows us to write our high-level code in TypeScript (strongly typed JavaScript). Since the rest of our client-side code is also written in TypeScript (which in turn gets compiled to “regular” JavaScript), this allows us to share code between the code delivered as part of our UI (using JS) and the binary (using Wasm). We get to share type definitions of the data being passed in and out of the compiled binary and some interop that makes it easier to pass data back and forth. While code written with AssemblyScript looks very similar to TypeScript, it needs some modifications before being able to be compiled with AssemblyScript (by defining more granular types for example).</p>
<p>AssemblyScript code might look something like the following:</p>
<pre><!-- HTML_TAG_START --><code><span>export</span> <span>function</span> <span>compute</span><span>(</span>array<span>:</span> StaticArray<span>&lt;</span>f64<span>&gt;</span><span>,</span> target<span>:</span> i32<span>)</span><span>:</span> Result <span>{</span>
	<span>const</span> total <span>=</span> <span>10</span><span>;</span>
	<span>const</span> sum <span>=</span> <span>0</span><span>;</span>

	<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> total<span>;</span> i<span>++</span><span>)</span> <span>{</span>
		sum <span>+=</span> array<span>[</span>i<span>]</span><span>;</span>
	<span>}</span>

	<span>return</span> <span>{</span> sum <span>}</span><span>;</span>
<span>}</span></code><!-- HTML_TAG_END --></pre>
<p>Here, we are writing a function that sums up the first 10 items from <code>array</code> and returns it wrapped in an object. In our code, we return more than just one item inside of this object. The nice thing with AssemblyScript is that it will take care of properly passing this structured data across the JS/Wasm boundary.</p>
<h3>Keeping Things Responsive With Web Workers</h3>
<p>While the Wasm binary is faster than a JavaScript implementation would be, it still takes a non-neglible time to run. If we were to just call the <code>compute</code> function inside of our Svelte front-end, we would run it in the main thread and lock up the UI, causing a bad user experience as the webpage would appear frozen. To fix this, we run that code inside of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener" target="_blank">Web Worker</a>. Doing this will allow us to run the search algorithm in a separate thread so the main thread is available to respond to the user.</p>
<p>In our case, to perform a search, a worker needs some context on the structure of the song. We first initialize a worker with the song analysis results from the server (this requires us to send data from the main thread into the worker thread), then ask it to execute a search with the target length. Since this context only changes when the user changes the song they are working on, we can reuse a worker given we are editing the same song and just need to vary the target duration or the preferences.</p>
<p>Since that code runs in separate execution context in a separate thread, how can we implement cross-thread communication? Using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API" rel="noopener" target="_blank">Channel Messaging API</a>’s <code>postMessage</code> method! This method allows us to send a message across the thread boundary.</p>
<p>Our code that manages the worker looks something like the following:</p>
<pre><!-- HTML_TAG_START --><code><span>import</span> Worker <span>from</span> <span>&#34;./worker?worker&#34;</span><span>;</span>

<span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>)</span><span>;</span>


worker<span>.</span><span>postMessage</span><span>(</span><span>{</span>
	type<span>:</span> <span>&#34;populate&#34;</span><span>,</span>
	data<span>:</span> <span>new</span> <span>Float64Array</span><span>(</span>searchContext<span>)</span><span>,</span>
<span>}</span><span>)</span><span>;</span>


<span>function</span> <span>search</span><span>(</span>
	<span>callback</span><span>:</span> <span>(</span>ratio<span>:</span> Result<span>)</span> <span>=&gt;</span> <span>void</span><span>,</span>
	target<span>:</span> <span>number</span><span>,</span>
	onProgress<span>?</span><span>:</span> <span>(</span>ratio<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> <span>void</span><span>,</span>
<span>)</span> <span>{</span>
	worker<span>.</span><span>onmessage</span> <span>=</span> <span>(</span><span>{</span> data<span>:</span> <span>{</span> type<span>,</span> data <span>}</span> <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
		<span>if</span> <span>(</span>type <span>===</span> <span>&#34;finish&#34;</span><span>)</span> <span>{</span>
			<span>callback</span><span>(</span>data <span>as</span> Result<span>)</span><span>;</span>
			
		<span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>===</span> <span>&#34;progress&#34;</span><span>)</span> <span>{</span>
			onProgress<span>?.</span><span>(</span>data<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span><span>;</span>

	
	worker<span>.</span><span>postMessage</span><span>(</span><span>{</span>
		type<span>:</span> <span>&#34;process&#34;</span><span>,</span>
		data<span>:</span> <span>{</span> target <span>}</span><span>,</span>
	<span>}</span><span>)</span><span>;</span>
<span>}</span></code><!-- HTML_TAG_END --></pre>
<p>The <code>worker.ts</code> referenced above (the <code>?worker</code> suffix is a <a href="https://vitejs.dev/guide/features.html#web-workers" rel="noopener" target="_blank">Vite feature</a>) has some code to handle the messages from the main thread and copy the search context into its local memory and then run our WebAssembly code when needed:</p>
<pre><!-- HTML_TAG_START --><code><span>let</span> cachedData<span>:</span> Float64Array<span>;</span>

<span>onmessage</span> <span>=</span> <span>async</span> <span>(</span><span>{</span> data<span>:</span> <span>{</span> type<span>,</span> data <span>}</span> <span>}</span><span>:</span> <span>{</span> data<span>:</span> <span>{</span> type<span>:</span> <span>string</span><span>;</span> data<span>:</span> <span>any</span> <span>}</span> <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>const</span> <span>{</span> compute <span>}</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#34;./wasm/assembly&#34;</span><span>)</span><span>;</span>

	<span>if</span> <span>(</span>type <span>===</span> <span>&#34;populate&#34;</span><span>)</span> <span>{</span>
		cachedData <span>=</span> data<span>;</span>

		<span>postMessage</span><span>(</span><span>{</span>
			type<span>:</span> <span>&#34;loaded&#34;</span><span>,</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span> <span>else</span> <span>if</span> <span>(</span>type <span>===</span> <span>&#34;process&#34;</span><span>)</span> <span>{</span>
		<span>const</span> <span>{</span> target <span>}</span> <span>=</span> data<span>;</span>

		<span>postMessage</span><span>(</span><span>{</span>
			type<span>:</span> <span>&#34;finish&#34;</span><span>,</span>
			data<span>:</span> <span>compute</span><span>(</span>cachedData<span>,</span> target<span>)</span><span>,</span>
		<span>}</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span><span>;</span></code><!-- HTML_TAG_END --></pre>
<p>Note: as <a href="https://news.ycombinator.com/item?id=36489267" rel="noopener" target="_blank">pointed out on Hacker News</a>, if you are running Firefox, the dynamic import above <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1540913" rel="noopener" target="_blank">requires Firefox 113 or newer</a>.</p>
<p>As mentioned before, keeping a copy of the search result is possible since the analysis context required is shared across searches. This avoids some overhead when the user initializes a new search (by altering the target length or region preferences) by avoiding having to copy it in for every search.</p>
<h3>Reusing Workers</h3>
<p>In Mofi, users get to choose from multiple results of generated songs. Since these searches can run in parallel and we want to get results shown to the user as quickly as possible, we run multiple instances of Web Workers at the same time. This allows us to have results “trickle in” as each worker finishes processing.</p>
<p><img src="https://mofi.loud.red/_app/immutable/assets/results.72e94103.png" alt="Screenshot of multiple search results"/></p>
<p>We don’t want to run too many workers at once, however: after we reach the number of physical cores, the cost of switching between threads starts to outweight the benefits of parallelization and computation incurs a performance hit. To manage this, we use a pool of workers. When a new request comes in to look for a result, we try to find a worker that will handle the request:</p>
<ul><li>If we haven’t filled the pool of workers yet, we have space to create one, so we initialize a new instance of the worker and populate it with data. Once it has finished initialization, we can send over the request.</li>
<li>If there is an idle worker in our pool, we take one and let it perform the search. The advantage of this is that reusing the worker allows us to skip initialization since it already has the context needed to perform the search.</li>
<li>If there is no idle worker, we add the request along with a callback to a list of waiting tasks. Once a worker finishes a task, the scheduler takes the next task off of the queue and processes it.</li></ul>
<p>Having a pool of workers also let’s us stop all searches by terminating all workers:</p>
<pre><!-- HTML_TAG_START --><code><span>export</span> <span>function</span> <span>terminate</span><span>(</span><span>)</span> <span>{</span>
	waitingTasks <span>=</span> <span>[</span><span>]</span><span>;</span>
	busyWorkers<span>.</span><span>forEach</span><span>(</span><span>(</span>worker<span>)</span> <span>=&gt;</span> worker<span>.</span><span>terminate</span><span>(</span><span>)</span><span>)</span><span>;</span>
	busyWorkers <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>}</span></code><!-- HTML_TAG_END --></pre>
<p>This happens when the user issues a new search. At this point, all running workers are looking for outdated results so we don’t need them anymore.</p>
<h3>Tip: Progress Updates</h3>
<p>A worker can only return data once completed, but we also want to show a progress indicator even when its task has not finished. To do this, inside of the worker code, we create a global <code>onProgress</code> helper function that allows us to send a message to the main thread like this:</p>
<pre><!-- HTML_TAG_START --><code><span>(</span>globalThis <span>as</span> <span>any</span><span>)</span><span>.</span><span>onProgress</span> <span>=</span> <span>(</span>ratio<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>postMessage</span><span>(</span><span>{</span>
		type<span>:</span> <span>&#34;progress&#34;</span><span>,</span>
		data<span>:</span> ratio<span>,</span>
	<span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code><!-- HTML_TAG_END --></pre>
<p>Then, inside the AssemblyScript code, we can add this:</p>
<pre><!-- HTML_TAG_START --><code><span><span>@</span><span>external</span></span><span>(</span><span>&#34;env&#34;</span><span>,</span> <span>&#34;onProgress&#34;</span><span>)</span>
<span>export</span> <span>declare</span> <span>function</span> <span>onProgress</span><span>(</span>ratio<span>:</span> <span>number</span><span>)</span><span>:</span> <span>void</span><span>;</span></code><!-- HTML_TAG_END --></pre>
<p>which allows us to “import” the function and call it inside of the Wasm binary and send incremental updates before returning the final result:</p>
<pre><!-- HTML_TAG_START --><code><span><span>+</span><span> import { onProgress } from &#34;./glue&#34;;
</span></span>
export function compute(array: StaticArray&lt;f64&gt;, target: i32): Result {
	const total = 10;
	const sum = 0;

	for (let i = 0; i &lt; total; i++) {
		sum += array[i];
<span><span>+</span><span>		onProgress(i / total);
</span></span>	}

	return { sum };
}</code><!-- HTML_TAG_END --></pre>
<p>This is a simplified example and this loop would finish fast, but in the case of long-running loop iterations the progress updates will be more beneficial.</p>
<h3>Wrapping Up</h3>
<p>Using WebAssembly and Web Workers, we are able to shift the iterative aspect of Mofi’s audio manipulation to the client to make the experience more responsive and snappy. This project was exciting for me to build because it got me using novel web technologies to build a performant application that mostly runs in the browser. In the future, I hope to be able to analyze the audio in the browser too, but it looks difficult to do at this stage.</p>
<p>Thank you for reading, and if you haven’t already, please give Mofi a try!</p></article></div>
  </body>
</html>
