<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://whynothugo.nl/journal/2022/10/21/how-the-clipboard-works/">Original</a>
    <h1>How the clipboard works</h1>
    
    <div id="readability-page-1" class="page"><article><p>Reading how copy-paste works from the Wayland specification is non-trivial
unless you understand a lot of how desktop computing works and Wayland
internal. It took me quite a while to figure it all out, though once you get
there, it seems quite obvious.</p><p>Here’s my attempt at explaining how it works for mere mortals.</p><a href="#terminology"></a><h2 id="terminology"><a href="#terminology">Terminology <span>¶</span></a></h2><p>Let me clarify that what we usually call “clipboard” is actually called a
“selection”. I’ll use the term “clipboard” here anyway to keep this friendly,
but keep in mind that it’s not the actual technical term.</p><a href="#copying"></a><h2 id="copying"><a href="#copying">Copying <span>¶</span></a></h2><p>When you select some text and press ctrl+c, you’d normally say that the program
“copies” data into the clipboard. In reality, no copying happens at this point.
What the program actually does is announce <em>“I have the clipboard now, and have
data of type <code>text/plain</code>”</em>. At this point, the previous application that owned
the clipboard (if any) is informed that they no longer own the clipboard.
From this point on, whenever another application gains focus, it’ll be informed
that someone owns the clipboard and is offering data of type <code>text/plain</code>. This
happens when an application gains focus because only a foreground application
can access the clipboard.</p><p>However, we don’t just copy text, we can copy anything. Let’s copy a png image
on Firefox (e.g.: right click, copy image). At this point, Firefox announces
<em>“I have the clipboard; I have data of type <code>image/png</code>, <code>text/x-moz-url</code><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
or <code>text/plain</code>”</em>. This means that the data can either be pasted as a png image
(e.g.: raw image bytes) or as a URL (the URL to the image we’ve copied) or as
text (again, the URL. This is the fallback for programs that don’t support any
of the above two).</p><p>This all oversimplified one tiny bit; the copying process is not one step, but
a few (but the above introduction should help this make sense). In full detail:</p><ul><li>The application creates a <code>wl_data_source</code> object, indicating that it’s going
to offer data to other applications.</li><li>The application adds the mime types that it can handle to the data source
(with <code>wl_data_source::offer</code>)</li><li>The application finally calls <code>wl_data_device::set_selection</code>, to indicate
<em>“I’m taking ownership of the clipboard, and the above created
<code>wl_data_source</code> is what I’m offering”</em>.</li></ul><a href="#pasting"></a><h2 id="pasting"><a href="#pasting">Pasting <span>¶</span></a></h2><p>Copying wasn’t hard, now let’s see how the other side works.</p><p>As mentioned above, applications are informed when another application owns the
clipboard.</p><p>So let’s imagine an you’ve copied an image in Firefox, and now switch to a
terminal. The compositor will inform the terminal <em>“Somebody owns the clipboard
and is offering data of types <code>image/png</code>, <code>text/x-moz-url</code> or <code>text/plain</code>”</em>.
If you try to paste, the terminal will ignore the types it doesn’t know how to
handle, and will request the data of type <code>text/plain</code>. At this point, the
owner of the clipboard (Firefox) is informed that somebody wants to paste its
data and receives a file descriptor<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> into which is must write the data. The
terminal receives another file descriptor where it can read the data. Anything
written to the first one is read out the second, so the data is transferred
directly between applications with no middleman. It’s basically a pipe; data
goes in one end, comes out the other.</p><a href="#some-notes-on-this-design"></a><h2 id="some-notes-on-this-design"><a href="#some-notes-on-this-design">Some notes on this design <span>¶</span></a></h2><p>First of all, one has to understand that, under the hood, nothing is ever
“copied into the clipboard”. When we click copy, nothing is copied. The “copy”
semantic is only a user-interface concept. What really happens is “the
application announces that it owns the clipboard; that the user has copied
something”.</p><p>A big upside of this design is that no data is copied around unnecessarily. For
example, an image editor will offer data as <code>image/png</code>, <code>image/bmp</code>,
<code>image/jpeg</code>, etc. If the data had to be sent as soon as the “copy” action
happens, then the image would have to be encoded into all these formats right
away – but likely only one of these would ever be used. One could be copying a
600MB video, only to paste somewhere were a URL is will pasted.</p><p>This approach yields the greatest flexibility, but also keeps unnecessary work
and memory usage to a minimum.</p><p>There’s a few other technical advantages to this design which are out-of-scope
here (like the compositor not needing to allocate huge amounts of memory for
clipboard data).</p><a href="#an-issue-with-this-design"></a><h2 id="an-issue-with-this-design"><a href="#an-issue-with-this-design">An issue with this design <span>¶</span></a></h2><p>A big problem with this design is that if I copy an image (e.g.: from GIMP) and
then close that application, the clipboard selection is lost. I can no longer
paste it; it’s gone forever.</p><p>This is a well-known issue on Linux desktop. There’s a couple ways around it:</p><ul><li>When something is copied and all of a program’s windows are closed, the
program can linger in the background, windowless, until is loses the
clipboard. This might be really hard to implement for some applications due
to how they’re designed, and needs to be implemented by every single on. It
works for tools which focus to copying data though (this is why I do with
<a href="https://git.sr.ht/~whynothugo/shotman">shotman</a>).</li><li>A clipboard manager. Clipboard manager used a privileged API to always be
notified when any application takes ownership of the clipboard; when this
happens, they can copy all the data, and take ownership of the clipboard
themselves. The majority of the implementations out there are broken and only
handle text. Many dump the data to disk, which makes them a bit risky if you
ever copy sensitive data into your clipboard.
I’ve written a clipboard manager that works (<a href="https://git.sr.ht/~whynothugo/clipmon">clipmon</a>), but it has one big
problem: if you copy an image that is offered in many different formats, it
has to copy all those formats. This adds a lot of unnecessary work (and
memory usage) for many scenarios.</li></ul></article></div>
  </body>
</html>
