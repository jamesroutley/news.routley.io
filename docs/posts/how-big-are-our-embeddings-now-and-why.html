<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vickiboykis.com/2025/09/01/how-big-are-our-embeddings-now-and-why/">Original</a>
    <h1>How big are our embeddings now and why?</h1>
    
    <div id="readability-page-1" class="page"><div><p>A few years ago, I wrote<a href="https://vickiboykis.com/what_are_embeddings/"> a paper on embeddings</a>. At the time, I wrote that 200-300 dimension embeddings were fairly common in industry, and that adding more dimensions during training would create diminishing returns for the effectiveness of your downstream tasks (classification, recommendation, semantic search, topic modeling, etc.)</p><p>I wrote the paper to be resilient to changes in the industry since it focuses on fundamentals and historical context rather than libraries or bleeding edge architectures, but this assumption about embedding size is now out of date and worth revisiting in the context of growing embedding dimensionality and embedding access patterns.</p><p>As a quick review, embeddings are compressed numerical representations of a variety of features (text, images, audio) that we can use for machine learning tasks like search, recommendations, RAG, and classification. The size of the embedding is how many features our item has.</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_1.png" width="400"/></figure><p>For example, let’s say we have two butterflies. We can compare them among many dimensions, including wingspan, wing color, number of antennae. Let’s say we have a 3-dimensional feature for a butterfly, it might look like this.</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_2.png" width="400"/></figure><p>Doing a visual vibe scan, we can eyeball the data and see that <code>butterfly_1</code> and <code>butterfly_3</code> are more similar to each other than to <code>butterfly_2</code> because their features are closer together.</p><p>But butterflies are 3-dimensional animals and some of these features are numerical. When we talk about embeddings in industry these days, we generally mean trying to understand the properties of text, so how does this concept work with words? We can’t directly compare words like “bird” and “butterfly” or “fly” in a given text but we can compare their numerical representations if we map them into the same shared space. We can see that “bird” and “flying” are more similar to each other than to “dog” through their numerical representations.</p><p>Intuitively, we know this is true, but how do we artificially create these relationships?</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_3.png" width="400"/></figure><p>There are different ways of creating text embeddings from a given word, all of which rely on analyzing that word in relation to the words around it in a given corpus of data. We can use traditional count-based approaches like TF-IDF based on term frequency in documents, or statistical approaches like PCA or LSA.</p><p>With the advent of deep learning models, we started learning representations generated from models like Word2Vec that maximized the probability that a left-out word would be next to other given words in the training dataset.</p><p>When we learn the embedding representation of a given word using probabilistic models, we are comparing how similar these words are to other words. Each feature is not an explicit feature like “wing color”, but rather a vibe-based latent representation in the latent space that doesn’t have a clear explanation.</p><p>For example, one dimension might be “this word is an action word” or maybe “this word is related to other words about food”, but we generally don’t know exactly what the model thinks each feature represents. In fact, this is a <a href="https://www.anthropic.com/news/mapping-mind-language-model">fascinating area of study</a> we are just starting to understand how these latent representations work through ideas like <a href="https://vgel.me/posts/representation-engineering/">control vectors</a>, a concept that Anthropic explored in the famous Golden Gate Claude paper.</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_4.png" width="400"/></figure><p>When we train a model, embedding size is initialized as a hyperparameter before model training, and we iterate on the size depending on our downstream evaluations after training. Picking the right hyperparameter is (<a href="https://archives.argmin.net/2017/12/05/kitchen-sinks/">alchemy</a>) a combination of art and science and <a href="https://docs.aws.amazon.com/wellarchitected/latest/generative-ai-lens/genperf04-bp02.html">depends on optimizing </a>training throughput, final embedding storage size, and the performance of the embedding on your downstream task both qualitatively and wrt to latency of performing search on embeddings of different sizes.</p><p>Since previous generations of models were smaller and trained in-house, hyperparameters were usually not published by companies, and as such, there was no standard agreement on embedding size. We generally, as an industry, understood <a href="https://aclanthology.org/I17-2006/">that somewhere around 300 dimensions for a given embedding model might be enough to compress all the nuance of a given textual dataset</a>. 300 was the number of dimensions typically used by earlier models like Word2Vec and <a href="https://nlp.stanford.edu/projects/glove/">GloVE</a>.</p><p>After the publication of the attention paper <a href="https://arxiv.org/abs/1810.04805">BERT was released</a> in 2018. This model’s architecture <a href="https://huggingface.co/google-bert/bert-base-uncased">introduced embeddings of 768 dimensions.</a> Although previous <a href="https://svail.github.io/persistent_rnns/">RNN</a> and LSTM models had been trained on GPUs, BERT was one of the first larger embedding models to be trained on GPUs (<a href="https://timdettmers.com/2018/10/17/tpus-vs-gpus-for-transformers-bert/">and TPUs</a>), which meant that GPU optimization now became increasingly important.</p><p>The key behind <a href="https://jiegroup-genai.readthedocs-hosted.com/en/latest/resource/">training Transformer models efficiently</a> is the ability to <a href="https://horace.io/brrr_intro.html">efficiently move data onto GPU</a> and parallelize their matrix multiplication operations between several pipelines, aka attention heads, where each attention head can focus on understanding and defining a different part of the embedding feature space. As such, the embedding needs to be able to be partitioned evenly between the number of attention heads.</p><p>BERT has 12 attention heads, so 768 dimensions was selected from a combination of trial and error and efficiently parallelizing computation to “attend” to different parts of the feature space, meaning that, in model training, each head operates on a 64-dimensional subspace of the original 768-dimensional input embedding. This itself comes from the Transformer paper, where each sub-embedding size per head <a href="https://arxiv.org/pdf/1706.03762">is commonly chosen as 64</a>.</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_5.png" width="400"/></figure><p>As a result, many BERT-style models, and related model families, used 768 as a baseline for embedding dimensions. Although it had a much larger training dataset, <a href="https://www.alignmentforum.org/posts/BMghmAxYxeSdAteDc/an-exploration-of-gpt-2-s-embedding-weights">GPT-2 also </a>implemented 768. And, although CLIP uses an embedding size of <strong>768</strong> as derived from the <a href="https://arxiv.org/abs/2010.11929">Vision Transformer </a>architecture that CLIP uses for its image encoder, and for consistency, the text encoder also uses this dimension size[^1].</p><p>Even though training cycles for BERT were fairly small (4 days for the original BERT model) compared to the months-long pretraining processes that LLMs require these days, it was still hard computationally to infer these embedding sizes, even with GPU optimizations. <a href="https://arxiv.org/abs/1908.10084">For BERT, for example,</a></p><pre><code>Finding the most similar pair in a collection of 10,000 sentences requires about 50 million inference computations (~65 hours).
</code></pre><p>So in 2019, <a href="https://github.com/UKPLab/sentence-transformers">UKP created</a> and optimized a model, SBERT, focusing on <a href="https://arxiv.org/abs/1908.10084">sentence-level representation</a>s, which unlocked faster inference, and <a href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2">Minilm</a> became the standard baseline model for document-level chunk embeddings at 384 dimensions and still performs extremely well for a number of tasks.</p><p>What else changed was the rise of the open-source HuggingFace platform where model artifacts could be shared. Previously, they were either hosted in undiscoverable repos in GitHub or locked away in scientific repositories missing metadata. The rise of HuggingFace as a platform and the <code>transformers</code> library as a centralized API into training and inference for PyTorch-based models unlocked a level of standardization: now, many more people could simply download and replicate the existing models instead of rebuilding arcane research code from scratch. This led to much more standard embedding and architecture sizes used both in academia and industry.</p><p>Although 768 held for a fairly long time, with upwards pressure from market competition on model sizes as the result of the release of GPT-2 (the backbone of ChatGPT), we started seeing standard embedding sizes increase.</p><p>Part of this was the fact that companies no longer had to infer their own embeddings. Previously, embeddings had been custom-learned in labs or in<a href="https://arxiv.org/abs/2007.03634"> companies whose core competency was processing large amounts of information</a> that could be culled in retrieval through search or recommendation.</p><p>But now, with the advent of ChatGPT and API-based model availability, embeddings became a commodity available with a GET request, and the most popular embeddings<a href="https://openai.com/index/new-and-improved-embedding-model/"> became OpenAI’s</a>, which used 1536 dimensions, in line with GPT-3, which used much more training data than any previous model. (<a href="https://lambda.ai/blog/demystifying-gpt-3">570GB versus GPT-2 which was 40GB, and 96 attention heads.)</a></p><p>It used to be the case that people only learned or fine-tune their own embeddings, but now all of the major AI providers have their own hosted sets of embeddings. Particularly common ones are OpenAI, with Cohere and Nomic close behind. Google also <a href="https://arxiv.org/abs/2503.07891">recently released embeddings for Gemini</a>, with both API and local versions being available.</p><p>In addition to standardization via HuggingFace and APIs, MTEB, <a href="https://huggingface.co/blog/mteb">which benchmarks embeddings publicly</a>, has grown as a resource where you can compare embedding models.</p><p>If we look at MTEB, <a href="https://huggingface.co/spaces/mteb/leaderboard">the embedding benchmark today</a>, we can see embedding sizes anywhere from our classic 768 to 4096 and beyond (note all of them are neatly divisible by 2, in line with architectural constraints)</p><figure><img src="https://vickiboykis.com/images/embeddings-sizes/img_6.png" width="400"/></figure><p>Finally, another consideration has been the change in the landscape with vector databases, which used to be huge, are now becoming more commoditized features in software and platforms like <a href="https://github.com/pgvector/pgvector">Postgres</a>, <a href="https://aws.amazon.com/s3/features/vectors/">S3</a>, and <a href="https://www.elastic.co/docs/explore-analyze/machine-learning/nlp/ml-nlp-text-emb-vector-search-example">Elasticsearch</a>, leading to less out of the box necessity in vector storage and performance tuning.</p><p>With the constant upward pressure on embedding sizes not limited by having to train models in-house, it’s not clear where we’ll slow down: Qwen-3, along with many others is already at 4096. It does appear that we are beginning to trim down on growth. OpenAI implemented a concept called <a href="https://arxiv.org/abs/2205.13147">matryoshka representation learning </a>that trains embeddings with the “most important” concepts first, and additional embeddings adding incremental gains, meaning that an embedding learned in 1024 dimensions might be just as useful in 64, as long as the first 64 <a href="https://huggingface.co/blog/matryoshka">dimensions compress most of the information efficiently</a>, and also making sure we re-normalize them. There are also research that indicates that not all embeddings are necessary in retrieval + search tasks, and that we can <a href="https://arxiv.org/abs/2508.17744">in fact, in some cases, truncate 50% of them anyway.</a></p><p>It’s been fascinating to watch the rise of dimensionality and the constant struggle in tradeoffs between creating ever-larger models and then the need for those embedding sizes to perform at inference and storage time, aka continuously coming up against the age-old machine learning tradeoff of recall versus precision, and the engineering tradeoff of hardware limitations versus software versus business considerations.</p><p>As these architectures have matured and internal models have become inference points of public-facing paid APIs, embeddings have gone from a mysterious byproduct of internal machine learning systems in companies with lots of data to a commodity used across many AI-powered applications across numerous application stacks.</p><p>All in all, it’s been so much fun watching this space evolve, even if it means it looks like I’ll be having to update my paper over and over again.</p></div></div>
  </body>
</html>
