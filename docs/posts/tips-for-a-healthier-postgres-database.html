<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year">Original</a>
    <h1>Tips for a Healthier Postgres Database</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<div data-widget-type="blog_content" data-x="0" data-w="12">
<div>
  <div>
    
    <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p><span>It&#39;s been a busy year building </span><a href="https://www.crunchybridge.com/" rel="nofollow">Crunchy Bridge</a> and we<span>&#39;ve shipped a lot of new awesome things.  Instead of doing a wrap-up of all the growth and exciting features, instead I wanted to take the time to try to teach a few more things to those that follow us. While onboarding customer after customer this year I&#39;ve noted a few key things everyone should put in place right away - to either improve the health of your database or to save yourself from a bad day.</span></p>
<!--more-->
<h2>Set a statement timeout</h2>
<p>Long running (usually unintentionally so) queries can wreck havoc on a database. They can hold up other queries, replication, or other database processes. Most applications are designed for typical queries to run in a few milliseconds. You may have long running queries for reporting, but these are best offloaded to a read replica for reporting and analytics. To prevent those long running queries you can set a<span> </span><span><code>statement_timeout</code></span>:</p>
<pre><span>ALTER DATABASE</span> mydatabase <span>SET</span> statement_timeout <span>=</span> <span>&#39;<span>60s</span>&#39;</span>;</pre>
<p><em>For good measure you may also want to set your<span> </span><span><code>idle_in_transaction</code></span><span> </span>timeout as well, which will cancel long running transaction that are no longer performing work.</em> </p>
<div>
<h2>Ensure you have query tracking</h2>
<p>Understanding what is going on inside your database is always a good idea. Which queries are slow? Which queries are run too many times? Enter the most useful Postgres extension that exists:<span> </span><span><code>pg_stat_statements</code>.</span></p>
<p>Pg_stat_statements records every query that runs against your database, parameterizes it, and then records a variety of metrics about it. That makes it easy to answer the above questions. If you don&#39;t have it installed already do it today by running:</p>
<div>
<pre><span>CREATE EXTENSION</span> pg_stat_statements;</pre>
</div>
<p>Once it&#39;s in place you can take a look at our<span> </span><a href="https://blog.crunchydata.com/blog/tentative-smarter-query-optimization-in-postgres-starts-with-pg_stat_statements" rel="nofollow noopener" target="_blank">deep dive</a><span> </span>on all the insights it can show you.</p>
<h2>Log slow running queries</h2>
<p>While<span> </span><span><code>pg_stat_statements</code></span><span> </span>is useful for looking at frequently run queries or queries that may always be slow, sometimes you have extreme outlier queries. With<span> </span><span><code>pg_stat_statements</code></span><span> </span>you may review your queries every few months. Meanwhile your Postgres logs likely<span> </span><a href="https://docs.crunchybridge.com/how-to/logging/" rel="nofollow noopener" target="_blank">feed into</a><span> </span>some other central system that you are monitoring daily and have alerting on. Catching these slow outlier queries early can be a great canary for things you should quickly move off to a read-replica for scaling or that you should rewrite to be more efficient. You can<span> </span><a href="https://blog.crunchydata.com/blog/logging-tips-for-postgres-featuring-your-slow-queries" rel="nofollow noopener" target="_blank">log all slow queries</a><span> </span>that take over a certain time with<span> </span><span><code>log_min_duration_statement</code></span>.</p>
<p>For many SaaS applications setting your<span> </span><span><code>log_min_duration_statement</code></span><span> </span>to something like 1 second:<span> </span><span><code>1s</code></span><span> </span>or even as low as 100 milliseconds:<span> </span><span><code>100ms</code></span><span> </span>can be a big asset.</p>
<h2>Improve your connection management</h2>
<p>If you&#39;re using Rails, Django, Hibernate or any other framework/ORM you&#39;ve likely set a connection pool in your application settings for your database. That connection pool is likely reducing latency in new connections to your database, but is also limiting the performance available for your database. On versions prior to Postgres 14, connections consumed extra overhead leaving<span> </span><span><code>idle</code></span><span>  </span>connections as wasted space. The solution to this is not to replace your in app connection pooling, but rather add a server side connection pooler such as PgBouncer. With PgBouncer you&#39;re able to scale to 10s of thousands of connections with no problem. You can take a quick look at your existing database to see if PgBouncer would help:</p>
<pre><code><span>SELECT</span> count(*), </code></pre>
<p>If you see<span> </span><span><code>idle</code></span><span> </span>is above 20 it&#39;s recommended to explore using PgBouncer. Adding PgBouncer is often a no brainer to get better performance without any heavy refactoring required. And to make it easy if you&#39;re on<span> </span><a href="https://docs.crunchybridge.com/how-to/pgbouncer/" rel="nofollow noopener" target="_blank">Crunchy Bridge</a><span> </span>it&#39;s already available to you.</p>
<h2>Find your goldilocks range for indexes</h2>
<p dir="auto">There seems to be a common lifecycle of indexes within applications. First you start off with almost none, maybe a few on primary keys. Then you start adding them, one by one, two by two, until you&#39;ve got quite a few indexes for most any query you can run. Something is slow? Throw an index at it. What you end up with is some contention on overall throughput of your database, and well a lot of indexes that became a tangled ball of yarn over time.</p>
<p dir="auto">We&#39;ve got a slew of write-ups and guides on indexes and unfortunately there isn&#39;t a &#34;this is your one thing to read and your done&#34;. But a few key things and you can be in a better place:</p>
<ul dir="auto">
<li><a href="https://blog.crunchydata.com/blog/three-easy-things-to-remember-about-postgres-indexes" rel="nofollow noopener" target="_blank">A primer on indexes</a></li>
<li><a href="https://blog.crunchydata.com/blog/cleaning-up-your-postgres-database" rel="nofollow noopener" target="_blank">Check for unused indexes</a></li>
<li><a href="https://learn.crunchydata.com/postgresql-devel/courses/basics/indextypes" rel="nofollow noopener" target="_blank">Index types in Postgres</a></li>
<li><a href="https://learn.crunchydata.com/postgresql-devel/courses/basics/introindex" rel="nofollow noopener" target="_blank">A starter lesson on indexes</a></li>
</ul>
<h2>Here&#39;s to less database problems in 2022</h2>
<p>Our goal at Crunchy is to make Postgres great. One part of that is helping our customers understand their database and providing them with support and guidance for all their Postgres needs.</p>
<p>With<span> </span><a href="https://www.crunchydata.com/products/crunchy-bridge/" rel="nofollow noopener" target="_blank">Crunchy Bridge</a><span> </span>we&#39;re working towards making all of the above easier, so it&#39;s one less thing you have to worry about. We&#39;ve already had customers migrate and see<span> </span><a href="https://www.crunchydata.com/case-studies/rival-iq/" rel="nofollow noopener" target="_blank">3-5x performance improvement</a><span> </span>over their existing cloud providers. We know if you&#39;re here you&#39;re already a fan of Postgres. In this coming year we look forward to making the developer experience of Postgres better than it&#39;s ever been.</p>
</div></span>
      
    </p>
    
  </div>
</div></div>

</div><!--end row-->
</div></div>
  </body>
</html>
