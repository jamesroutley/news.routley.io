<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nmichaels.org/musings/d4d4/d4d4/">Original</a>
    <h1>D4D4</h1>
    
    <div id="readability-page-1" class="page"><div>
    
      
      <div>
        <div>
          

          <div role="main">
            
<section id="d4d4">

<p>A co-worker of mine was looking at some disassembled ARM code the
other day, and discovered something weird. Lots of <code><span>d4d4</span></code>
instructions, scattered about. LLVM’s objdump says this is a relative
branch to <code><span>-0x58</span></code>. The weird part is that they were always
unreachable.</p>
<section id="experiments">
<h2>Experiments<a href="#experiments" title="Link to this heading">¶</a></h2>
<p>Here’s an example in a minimal reproducer I wrote:</p>
<div><div><pre><span></span><span>00020100</span><span> </span><span>&lt;</span><span>one</span><span>&gt;:</span>
<span>   20100: 4770               bx      lr</span>
<span>   20102: d4d4               bmi     0x200ae &lt;__dso_handle+0x100ae&gt; @ imm = #-0x58</span>
</pre></div>
</div>
<p>That <code><span>bx</span> <span>lr</span></code> right before the <code><span>d4d4</span></code> branches to the link
register. In other words, it returns.  Here’s the C code that goes
with this function:</p>
<div><div><pre><span></span><span>#include</span><span> </span><span>&#34;mod.h&#34;</span>

<span>static</span><span> </span><span>void</span><span> </span><span>one</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
<span>    </span><span>return</span><span>;</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
<span>    </span><span>void</span><span> </span><span>*</span><span>fn</span><span>;</span>

<span>    </span><span>fn</span><span> </span><span>=</span><span> </span><span>one</span><span>;</span>
<span>    </span><span>use_ptr</span><span>(</span><span>fn</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>
</div>
<p>The <code><span>use_ptr</span></code> function is declared in <cite>mod.h</cite> (defined in <cite>mod.c</cite>),
and what it does with the pointer is not important. You can see that
there’s a function called <code><span>one</span></code>, and that function just
returns. Thus <code><span>bx</span> <span>lr</span></code> being the only thing. But why is there an
extra <code><span>d4d4</span></code> after it in the disassembled object code? My first
thought was that it was there for alignment. Of course, Thumb
instructions are 16 bits and maybe functions need to be 32-bit
aligned. Weird that it would use a branch to a real relative address
instead of a nop or something that would cause a fault, but let’s try
expanding the experiment.</p>
<p>code:</p>
<div><div><pre><span></span><span>static</span><span> </span><span>void</span><span> </span><span>one</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
<span>    </span><span>return</span><span>;</span>
<span>}</span>

<span>static</span><span> </span><span>void</span><span> </span><span>two</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
<span>    </span><span>return</span><span>;</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
<span>    </span><span>void</span><span> </span><span>*</span><span>fn</span><span>;</span>

<span>    </span><span>fn</span><span> </span><span>=</span><span> </span><span>one</span><span>;</span>
<span>    </span><span>use_ptr</span><span>(</span><span>fn</span><span>);</span>
<span>    </span><span>fn</span><span> </span><span>=</span><span> </span><span>two</span><span>;</span>
<span>    </span><span>use_ptr</span><span>(</span><span>fn</span><span>);</span>
<span>    </span><span>return</span><span> </span><span>0</span><span>;</span>
<span>}</span>
</pre></div>
</div>
<p>And the disassembly:</p>
<div><div><pre><span></span><span>000200f4</span><span> </span><span>&lt;</span><span>main</span><span>&gt;:</span>
<span>   200f4: b580               push    {r7, lr}</span>
<span>   200f6: 466f               mov     r7, sp</span>
<span>   200f8: 4803               ldr     r0, [pc, #0xc]          @ 0x20108 &lt;main+0x14&gt;</span>
<span>   200fa: f000 f80b          bl      0x20114 &lt;use_ptr&gt;       @ imm = #0x16</span>
<span>   200fe: 4803               ldr     r0, [pc, #0xc]          @ 0x2010c &lt;main+0x18&gt;</span>
<span>   20100: f000 f808          bl      0x20114 &lt;use_ptr&gt;       @ imm = #0x10</span>
<span>   20104: 2000               movs    r0, #0x0</span>
<span>   20106: bd80               pop     {r7, pc}</span>
<span>   20108: 11 01 02 00        .word   0x00020111</span>
<span>   2010c: 13 01 02 00        .word   0x00020113</span>

<span>00020110</span><span> </span><span>&lt;</span><span>one</span><span>&gt;:</span>
<span>   20110: 4770               bx      lr</span>

<span>00020112</span><span> </span><span>&lt;</span><span>two</span><span>&gt;:</span>
<span>   20112: 4770               bx      lr</span>

<span>00020114</span><span> </span><span>&lt;</span><span>use_ptr</span><span>&gt;:</span>
<span>   20114: 4770               bx      lr</span>
</pre></div>
</div>
<p>Not only does the compiler not feel the need to align functions to
32-bit boundaries, but adding a second single-instruction function
actually got rid of the <code><span>d4d4</span></code> entirely. And note how <code><span>use_ptr</span></code> (I
made it just return also) <em>doesn’t</em> have a <code><span>d4d4</span></code> in it. Curious.</p>
<p>What happens if I go to 3 functions?</p>
<p>code:</p>
<div><div><pre><span></span><span>00020124</span><span> </span><span>&lt;</span><span>one</span><span>&gt;:</span>
<span>   20124: 4770               bx      lr</span>

<span>00020126</span><span> </span><span>&lt;</span><span>two</span><span>&gt;:</span>
<span>   20126: 4770               bx      lr</span>

<span>00020128</span><span> </span><span>&lt;</span><span>three</span><span>&gt;:</span>
<span>   20128: 4770               bx      lr</span>
<span>   2012a: d4d4               bmi     0x200d6 &lt;__dso_handle+0x100d6&gt; @ imm = #-0x58</span>

<span>0002012c</span><span> </span><span>&lt;</span><span>use_ptr</span><span>&gt;:</span>
<span>   2012c: 4770               bx      lr</span>
</pre></div>
</div>
<p>It’s back! But now only once. It seems like it aligns the end of
<code><span>main.o</span></code> so that <code><span>mod.o</span></code> can start on a 32-bit boundary. Ok, maybe
this makes sense. So let’s take a look at the compiler’s output
directly. Here’s <code><span>main.o</span></code>:</p>
<div><div><pre><span></span><span>00000028</span><span> </span><span>&lt;</span><span>one</span><span>&gt;:</span>
<span>      28: 4770               bx      lr</span>

<span>0000002a</span><span> </span><span>&lt;</span><span>two</span><span>&gt;:</span>
<span>      2a: 4770               bx      lr</span>

<span>0000002c</span><span> </span><span>&lt;</span><span>three</span><span>&gt;:</span>
<span>      2c: 4770               bx      lr</span>
</pre></div>
</div>
<p>Oh, the compiler didn’t put that in at all, it must have been the
linker! So lld is rounding the end of an object file up to 32-bit
alignment using this <code><span>d4d4</span></code> instruction. If that’s true, then
linking mod.o before main.o ought to move where the <code><span>d4d4</span></code> is.</p>
<div><div><pre><span></span><span>000200e4</span><span> </span><span>&lt;</span><span>use_ptr</span><span>&gt;:</span>
<span>   200e4: 4770               bx      lr</span>
<span>   200e6: d4d4               bmi     0x20092 &lt;__dso_handle+0x10092&gt; @ imm = #-0x58</span>

<span>000200e8</span><span> </span><span>&lt;</span><span>main</span><span>&gt;:</span>
<span>   200e8: b5d0               push    {r4, r6, r7, lr}</span>
<span>   200ea: af02               add     r7, sp, #0x8</span>
<span>   200ec: 4804               ldr     r0, [pc, #0x10]         @ 0x20100 &lt;main+0x18&gt;</span>
<span>   200ee: 4c05               ldr     r4, [pc, #0x14]         @ 0x20104 &lt;main+0x1c&gt;</span>
<span>   200f0: 47a0               blx     r4</span>
<span>   200f2: 4805               ldr     r0, [pc, #0x14]         @ 0x20108 &lt;main+0x20&gt;</span>
<span>   200f4: 47a0               blx     r4</span>
<span>   200f6: 4805               ldr     r0, [pc, #0x14]         @ 0x2010c &lt;main+0x24&gt;</span>
<span>   200f8: 47a0               blx     r4</span>
<span>   200fa: 2000               movs    r0, #0x0</span>
<span>   200fc: bdd0               pop     {r4, r6, r7, pc}</span>
<span>   200fe: bf00               nop</span>
<span>   20100: 11 01 02 00        .word   0x00020111</span>
<span>   20104: e5 00 02 00        .word   0x000200e5</span>
<span>   20108: 13 01 02 00        .word   0x00020113</span>
<span>   2010c: 15 01 02 00        .word   0x00020115</span>

<span>00020110</span><span> </span><span>&lt;</span><span>one</span><span>&gt;:</span>
<span>   20110: 4770               bx      lr</span>

<span>00020112</span><span> </span><span>&lt;</span><span>two</span><span>&gt;:</span>
<span>   20112: 4770               bx      lr</span>

<span>00020114</span><span> </span><span>&lt;</span><span>three</span><span>&gt;:</span>
<span>   20114: 4770               bx      lr</span>
</pre></div>
</div>
<p>It did! The extra instruction got moved up to align the beginning of
the object code that contains main!</p>
<p>One more check: if I use the GNU linker, does it do the same thing?</p>
<div><div><pre><span></span><span>00008000</span><span> </span><span>&lt;</span><span>use_ptr</span><span>&gt;:</span>
<span>    8000: 4770               bx      lr</span>
<span>    8002: 0000               movs    r0, r0</span>
</pre></div>
</div>
<p>No! GNU ld (2.44) inserts zeroes to align files. It’s not <code><span>nop</span></code>,
though it may as well be. ARMv7-M actually has a <code><span>nop</span></code> instruction:
<code><span>bf00</span></code> or <code><span>f3af8000</span></code> depending on encoding. You can see it in
main, inserted by the compiler between the end of the function and its
constants.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a href="#conclusion" title="Link to this heading">¶</a></h2>
<p>So now we know. LLD is inserting the weird <code><span>d4d4</span></code> instructions, and
it’s doing it to align across object file boundaries. Why did they
pick such a weird constant, though? GNU ld went with zeroes, which
seems benign.</p>
</section>
<section id="research">
<h2>Research<a href="#research" title="Link to this heading">¶</a></h2>
<p>A little bit of checking out <a href="https://github.com/llvm/llvm-project">the code</a> later, and we find this in
ARM.cpp:</p>
<div><div><pre><span></span><span>trapInstr</span><span> </span><span>=</span><span> </span><span>{</span><span>0xd4</span><span>,</span><span> </span><span>0xd4</span><span>,</span><span> </span><span>0xd4</span><span>,</span><span> </span><span>0xd4</span><span>};</span>
</pre></div>
</div>
<p>That was actually way easier than I was expecting. The git blame path
meanders a little before getting to <a href="https://github.com/llvm/llvm-project/commit/921d43fbb2db8">this commit</a>
where Rui Ueyama explains:</p>
<div><div><pre><span></span>Add trap instructions for ARM and MIPS.

This patch fills holes in executable sections with 0xd4 (ARM) or
0xef (MIPS). These trap instructions were suggested by Theo de Raadt.

llvm-svn: 306322
</pre></div>
</div>
<p>This appears to have been precipitated by <a href="https://lists.llvm.org/pipermail/llvm-bugs/2017-May/055422.html">this message</a>,
also from Rui Ueyama, to the llvm-bugs mailing list. In it, the
question is asked whether LLD should use a trap instruction for
ARM/AArch64 like x86 and x86-64’s <code><span>0xCC</span></code>. I didn’t find any replies,
though.</p>
<p>I couldn’t find any messages on the mailing list about this from Theo
de Raadt, so I guess we just have to live with Ueyama’s testimony that
he thought <code><span>0xd4</span></code> would be a good byte to repeat as a trap
instruction. But a trap instruction is supposed to halt the processor,
so what’s with the disassembler saying it’s a branch?</p>
</section>
<section id="rtfm">
<h2>RTFM<a href="#rtfm" title="Link to this heading">¶</a></h2>
<p>Let’s take a look at the ARMv7-M Architecture Reference Manual, the
<a href="https://documentation-service.arm.com/static/5f8ff0a1f86e16515cdbf82c">ARM</a>. First
of all, it says that we’re using the Thumb instruction set, and most
instructions are 16 bits. Any instructions that begin with
<code><span>0b11101</span></code>, <code><span>0b11110</span></code>, or <code><span>0b11111</span></code> are the beginnings of 32-bit
instructions, but all the rest are 16 bits. Since <code><span>d4</span></code> is
<code><span>0b11010100</span></code>, we can safely assume that the instruction decoder will
always treat it like a 16-bit instruction.</p>
<p>Next up, we have table A5-1, showing how 16-bit instructions are
encoded. The first 6 bits are the opcode, followed by 10 bits of other
stuff. As we established earlier, the bits we’re looking for are
<code><span>0b110101</span></code>. That matches <em>conditional branch and supervisor call</em>’s
<code><span>0b1101xx</span></code>. Well, so far it’s still looking like a branch..</p>
<p>Page A5-134 leads us to the statement that the encoding here is
<code><span>0b1101</span></code> followed by a 4 bit opcode. <code><span>0xd</span></code> is the <code><span>0b1101</span></code> and
the next 4 bits are the number 4: <code><span>0b0100</span></code>. This doesn’t match
<code><span>UDF</span></code>, which seems like a reasonable choice for this
purpose. Instead, any opcode not matching <code><span>111x</span></code> is a conditional
branch, explained under <code><span>B</span></code> on page A7-207, according to table A5-8.</p>
<p>This page tells us that the <code><span>B</span></code> instruction has several encodings,
but only one that begins with a <code><span>0xd</span></code>: T1.</p>
<figure>
<img alt="../../_images/branch-encoding.png" src="https://www.nmichaels.org/musings/_images/branch-encoding.png"/>
</figure>
<p>With <code><span>0xd4d4</span></code>, <code><span>cond</span></code> in this table is <code><span>0x4</span></code> or <code><span>0b0100</span></code>. That
doesn’t match UDF (again) or <code><span>SVC</span></code>. <code><span>InITBlock()</span></code> just checks if
we’re within 4 instructions of an <code><span>IT</span></code>. <code><span>IT</span></code> is a weird
instruction, but not important for our purposes. What’s important is
that <code><span>imm32</span></code> is now those least significant 8 bits, sign
extended. That’s <code><span>0xffffffd4</span></code>, or <code><span>-44</span></code>. That’s <code><span>-0x2c</span></code> in hex,
not the <code><span>-0x58</span></code> from objdump. However, immediate offsets count
half-words, not bytes. So the offset is <code><span>-88</span></code>, or <code><span>-0x58</span></code>.</p>
<p>The other field, <code><span>cond</span></code>, is <code><span>0b0100</span></code>, which means some bits in the
condition registers have to be set in order for the branch to be
taken. Which bits don’t particularly matter, since this code is
supposed to be unreachable, but for completeness, it’s <code><span>(ASPR.C</span> <span>==</span>
<span>&#39;1&#39;)</span> <span>&amp;&amp;</span> <span>(ASPR.Z</span> <span>==</span> <span>&#39;0&#39;)</span></code>.</p>
</section>
<section id="more-conclusions">
<h2>More Conclusions<a href="#more-conclusions" title="Link to this heading">¶</a></h2>
<p>So it looks to me like objdump is behaving correctly, and Theo’s
suggestion was a bad one, at least for Thumb. Instead of a trap, it’s
a relative jump. In the tiny program I made above, it jumps right out
of <code><span>.text</span></code>, but in a more substantial program, it will usually land
somewhere in code. It should be unreachable, but the whole point of a
trap instruction is to halt the processor, not send it off on a random
walk through your codebase.</p>
<p>This feels like a bug in LLD to me. The linker’s inserting something
called “trapInstr” but it’s nothing like a trap. In fact, it’s a
(conditional) jump to a constant relative address.</p>
<p>So after a fun night of spelunking through source code, commit logs,
and manuals, I feel like I’ve learned something. I guess maybe it’s
time to file a bug report.</p>
</section>
</section>



          </div>
          
        </div>
      </div>
    
  </div></div>
  </body>
</html>
