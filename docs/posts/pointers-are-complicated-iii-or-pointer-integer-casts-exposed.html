<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html">Original</a>
    <h1>Pointers Are Complicated III, or: Pointer-integer casts exposed</h1>
    
    <div id="readability-page-1" class="page"><article id="-content">
      <header>
    
    
</header>

<p>In my <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">previous blog post on pointer provenance</a>, I have shown that not thinking carefully about pointers can lead to a compiler that is internally inconsistent:
programs that are intended to be well-behaved get miscompiled by a sequence of optimizations, each of which seems intuitively correct in isolation.
We thus have to remove or at least restrict at least one of these optimizations.
In this post I will continue that trend with another example, and then I will lay down my general thoughts on how this relates to the recent <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> proposal, what it could mean for Rust more generally, and compare with C’s PNVI-ae-udi.
We will end on a very hopeful note about what this could all mean for Rust’s memory model.
There’s a lot of information packed into this post, so better find a comfortable reading position. :)</p>

<!-- MORE -->

<p>In case you don’t know what I mean by “pointer provenance”, you can either read that previous blog post or the <a href="https://doc.rust-lang.org/nightly/core/ptr/index.html#provenance">Strict Provenance documentation</a>.
The gist of it is that a pointer consists not only of the address that it points to in memory, but also of its <em>provenance</em>: an extra piece of “shadow state” that is carried along with each pointer and that tracks which memory the pointer has permission to access and when.
This is required to make sense of restrictions like “use-after-free is Undefined Behavior, even if you checked that there is a new allocation at the same address as the old one”.
Architectures like CHERI make this “shadow state” explicit (pointers are bigger than usual so that they can explicitly track which part of memory they are allowed to access),
but even when compiling for AMD64 CPUs, compilers act “as if” pointers had such extra state – it is part of the specification, part of the Abstract Machine, even if it is not part of the target CPU.</p>

<h2 id="dead-cast-elimination-considered-harmful">Dead cast elimination considered harmful</h2>

<p>The key ingredient that will help us understand the nuances of provenance is <code>restrict</code>, a C keyword to promise that a given pointer <code>x</code> does not alias any other pointer not derived from <code>x</code>.<sup id="fnref:restrict" role="doc-noteref"><a href="#fn:restrict" rel="footnote">1</a></sup>
This is comparable to the promise that a <code>&amp;mut T</code> in Rust is unique.
However, just like last time, we want to consider the limits that <code>restrict</code> combined with integer-pointer casts put on an optimizing compiler – so the actual programming language that we have to be concerned with is the IR of that compiler.
Nevertheless I will use the more familiar C syntax to write down this example; you should think of this just being notation for the “obvious” equivalent function in LLVM IR, where <code>restrict</code> is expressed via <code>noalias</code>.
Of course, if we learn that the IR has to put some limitations on what code may do, this also applies to the surface language – so we will be talking about all three (Rust, C, LLVM) quite a bit.</p>

<p>With all that out of the way, consider the following program:</p>

<figure><pre><code data-lang="c"><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;stdint.h&gt;</span><span>
</span>
<span>static</span> <span>int</span> <span>uwu</span><span>(</span><span>int</span> <span>*</span><span>restrict</span> <span>x</span><span>,</span> <span>int</span> <span>*</span><span>restrict</span> <span>y</span><span>)</span> <span>{</span>
  <span>*</span><span>x</span> <span>=</span> <span>0</span><span>;</span>

  <span>uintptr_t</span> <span>xaddr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>x</span><span>;</span>
  <span>int</span> <span>*</span><span>y2</span> <span>=</span> <span>y</span><span>-</span><span>1</span><span>;</span>
  <span>uintptr_t</span> <span>y2addr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>y2</span><span>;</span>
  <span>if</span> <span>(</span><span>xaddr</span> <span>==</span> <span>y2addr</span><span>)</span> <span>{</span>
    <span>int</span> <span>*</span><span>ptr</span> <span>=</span> <span>(</span><span>int</span><span>*</span><span>)</span><span>xaddr</span><span>;</span>
    <span>*</span><span>ptr</span> <span>=</span> <span>1</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>*</span><span>x</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>int</span> <span>i</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>0</span><span>};</span>
  <span>int</span> <span>res</span> <span>=</span> <span>uwu</span><span>(</span><span>&amp;</span><span>i</span><span>[</span><span>0</span><span>],</span> <span>&amp;</span><span>i</span><span>[</span><span>1</span><span>]);</span>
  <span>// Always prints 1.</span>
  <span>printf</span><span>(</span><span>&#34;%d</span><span>\n</span><span>&#34;</span><span>,</span> <span>res</span><span>);</span>
<span>}</span></code></pre></figure>

<p>This function takes as argument two <code>restrict</code> pointers <code>x</code> and <code>y</code>. We first write <code>0</code> into <code>*x</code>.
Then we compute <code>y2</code> as pointing to the <code>int</code> right before <code>*y</code>, and cast that and <code>x</code> to integers.
If the addresses we get are the same, we cast <code>xaddr</code> back to a pointer and write <code>1</code> to it.
Finally, we return the value stored in <code>*x</code>.</p>

<p>The <code>main</code> function simply calls <code>uwu</code> with two pointers pointing to the first two elements of an array.
Note, in particular, that this <em>will</em> make <code>xaddr</code> and <code>y2addr</code> always equal!
<code>&amp;i[1] - 1</code> denotes the same address as <code>&amp;i[0]</code>.</p>

<p>Now, let us imagine we run a few seemingly obvious optimizations on <code>uwu</code>:</p>
<ul>
  <li>Inside the <code>if</code>, we can replace <code>xaddr</code> by <code>y2addr</code> since they are both equal integers.</li>
  <li>Since this is a <code>static</code> function and the only caller makes <code>y2addr</code> always equal to <code>xaddr</code>, we know that the conditional in the <code>if</code> will always evaluate to <code>true</code>. We thus remove the test. (Alternatively, the same transformation can happen by inlining <code>uwu</code> into <code>main</code> while preserving the alias information, which <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-March/131127.html">LLVM explicitly aims for</a>.)</li>
  <li>Finally, we observe that <code>xaddr</code> is unused, so we can remove it entirely.</li>
</ul>

<p><code>uwu</code> now looks as follows:</p>

<figure><pre><code data-lang="c"><span>static</span> <span>int</span> <span>uwu</span><span>(</span><span>int</span> <span>*</span><span>restrict</span> <span>x</span><span>,</span> <span>int</span> <span>*</span><span>restrict</span> <span>y</span><span>)</span> <span>{</span>
  <span>*</span><span>x</span> <span>=</span> <span>0</span><span>;</span>

  <span>int</span> <span>*</span><span>y2</span> <span>=</span> <span>y</span><span>-</span><span>1</span><span>;</span>
  <span>uintptr_t</span> <span>y2addr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>y2</span><span>;</span>
  <span>int</span> <span>*</span><span>ptr</span> <span>=</span> <span>(</span><span>int</span><span>*</span><span>)</span><span>y2addr</span><span>;</span> <span>// &lt;-- using y2addr</span>
  <span>*</span><span>ptr</span> <span>=</span> <span>1</span><span>;</span>

  <span>return</span> <span>*</span><span>x</span><span>;</span>
<span>}</span></code></pre></figure>

<p>This might still look harmless.
However, we can do even more!
Notice how this function now consists of a store of <code>0</code> to <code>*x</code>, then a bunch of code <em>that does not involve <code>x</code> at all</em>, and then a load from <code>*x</code>.
Since <code>x</code> is a <code>restrict</code> pointer, this “code that does not involve <code>x</code>” cannot possibly mutate <code>*x</code>, as that would be a violation of the <code>restrict</code>/<code>noalias</code> guarantee.
Hence we can optimize the <code>return *x</code> to <code>return 0</code>.
This kind of optimization is the primary reason to have <code>restrict</code> annotations in the first place, so this should be uncontroversial.
Formally speaking: only pointers “derived from” <code>x</code> may access <code>*x</code>, and while the details of defining “derived from” are nasty, it should be clear that doing a bunch of operations that literally don’t involve <code>x</code> at all cannot by any stretch of the imagination produce a result that is “derived from” <code>x</code>.
(If they could, <code>restrict</code> would be basically worthless.)</p>

<p>Now, the whole program looks like this:</p>

<figure><pre><code data-lang="c"><span>static</span> <span>int</span> <span>uwu</span><span>(</span><span>int</span> <span>*</span><span>restrict</span> <span>x</span><span>,</span> <span>int</span> <span>*</span><span>restrict</span> <span>y</span><span>)</span> <span>{</span>
  <span>*</span><span>x</span> <span>=</span> <span>0</span><span>;</span>

  <span>int</span> <span>*</span><span>y2</span> <span>=</span> <span>y</span><span>-</span><span>1</span><span>;</span>
  <span>uintptr_t</span> <span>y2addr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>y2</span><span>;</span>
  <span>int</span> <span>*</span><span>ptr</span> <span>=</span> <span>(</span><span>int</span><span>*</span><span>)</span><span>y2addr</span><span>;</span>
  <span>*</span><span>ptr</span> <span>=</span> <span>1</span><span>;</span>

  <span>return</span> <span>0</span><span>;</span> <span>// &lt;-- hard-coded return value</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>int</span> <span>i</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>0</span><span>};</span>
  <span>int</span> <span>res</span> <span>=</span> <span>uwu</span><span>(</span><span>&amp;</span><span>i</span><span>[</span><span>0</span><span>],</span> <span>&amp;</span><span>i</span><span>[</span><span>1</span><span>]);</span>
  <span>// Now this prints 0!</span>
  <span>printf</span><span>(</span><span>&#34;%d</span><span>\n</span><span>&#34;</span><span>,</span> <span>res</span><span>);</span>
<span>}</span></code></pre></figure>

<p>We started out with a program that always prints <code>1</code>, and ended up with a program that always prints <code>0</code>.
This is bad news. Our optimizations changed program behavior. That must not happen! What went wrong?</p>

<p>Fundamentally, this is the same situation as in the previous blog post: this example demonstrates that either the original program already had Undefined Behavior, or (at least) one of the optimizations is wrong.
However, the only possibly suspicious part of the original program is a pointer-integer-pointer round-trip – and if casting integers to pointers is allowed, <em>surely</em> that must work.
I will, for the rest of this post, assume that replacing <code>x</code> by <code>(int*)(uintptr_t)x</code> is always allowed.
So, which of the optimizations is the wrong one?</p>

<h2 id="the-blame-game">The blame game</h2>

<p>Remember what I said earlier about <code>restrict</code> and how it matters which pointer <code>ptr</code> is “derived from”?
If we follow this lead, it may seem like the bogus optimization is the one that replaced <code>xaddr</code> by <code>y2addr</code>.
After this transformation, <code>ptr</code> is obviously “derived from” <code>y2</code> (and thus transitively from <code>y</code>) and not <code>x</code>, and so obviously <code>uwu</code> (as called from <code>main</code>) is wrong since we are doing two memory accesses (at least one of which is a write) to the same location, using two pointers that are “derived from” different <code>restrict</code> pointers!</p>

<p>However, that optimization doesn’t even have anything to do with pointers.
It just replaces one equal integer by another!
How can that possibly be incorrect?</p>

<p>What this example shows is that the notion of one value being “derived from” another is not very meaningful when considering an optimizing compiler.<sup id="fnref:consume" role="doc-noteref"><a href="#fn:consume" rel="footnote">2</a></sup>
It <em>is</em> possible to “fix” this problem and have a notion of “derived from” that works correctly even with pointer-integer round-trips.
However, this requires saying that not only pointers but also <em>integers carry provenance</em>, such that casting a pointer to an integer can preserve the provenance.
We solved one problem and created many new ones.
For once, we have to stop doing optimizations that replace one <code>==</code>-equal integer by another, unless we know they carry no provenance.
(Alternatively we could say <code>==</code>-comparing such integers is Undefined Behavior. But clearly we want to allow people to <code>==</code>-compare integers they obtained from pointer-integer casts, so this is not an option.)
That seems like a bad deal, since the code that benefits from such optimizations doesn’t even do anything shady – it is the pointer-manipulating code that is causing trouble.
The list doesn’t end here though, and because of that, this option was discarded by the C standardization process during its provenance work, and they ended up picking a “PNVI” model – provenance <em>not</em> via integers.
I think Rust should follow suit.</p>

<p>But, if it’s not the replacement of <code>xaddr</code> by <code>y2addr</code> that is wrong, then which optimization <em>is</em> the wrong one?
I will argue that the incorrect optimization is the one that removed <code>xaddr</code>.
More specifically, the bad step was removing the cast <code>(uintptr_t)x</code>, irrespective of whether the result of that cast is used or not.
Had this cast been preserved, it would have been a marker for the compiler to know that “the <code>restrict</code> guarantee of <code>x</code> ends here”, and it would not have done the final optimization of making <code>uwu</code> always return <code>0</code>.</p>

<h2 id="casts-have-a-side-effect">Casts have a side-effect</h2>

<p>How can it <em>not</em> be correct to remove an operation if its result is unused?
If we take a step back, then in general, the answer is simple – if calling <code>foo()</code> has some side-effect on the global state, like changing the value of a global variable, then of course we have to keep the call to <code>foo</code> around even if we ignore its return value.
But in this case, the operation in question is <code>(uintptr_t)x</code>, which has no side-effect – right?</p>

<p>Wrong.
This is exactly the key lesson that this example teaches us: casting a pointer to an integer <em>has a side-effect</em>, and that side-effect has to be preserved even if we don’t care about the result of the cast (in this case, the reason we don’t care is that we <em>already know</em> that <code>x</code> and <code>y2</code> will cast to the same <code>uintptr_t</code>).</p>

<p>To explain what that side-effect is, we have to get deep into the pointer provenance mindset.
<code>x</code> and <code>y</code> are both pointers, so they carry provenance that tracks which memory they have permission to access.
Specifically, <code>x</code> has permission to access <code>i[0]</code> (declared in <code>main</code>), and <code>y</code> has permission to access <code>i[1]</code>.<sup id="fnref:dyn" role="doc-noteref"><a href="#fn:dyn" rel="footnote">3</a></sup>
<code>y2</code> just inherits the permission from <code>y</code>.</p>

<p>But which permission does <code>ptr</code> get?
Since integers do not carry provenance, the details of this permission information are lost during a pointer-integer cast, and have to somehow be ‘restored’ at the integer-pointer cast.
And that is exactly the point where our problems begin.
In the original program, we argued that doing a pointer-integer-pointer round-trip is allowed (as is the intention of the C standard).
It follows that <code>ptr</code> must pick up the permission from <code>x</code> (or else the write to <code>*ptr</code> would be Undefined Behavior: <code>x</code> is <code>restrict</code>, nothing else can access that memory).
However, in the final program, <code>x</code> plays literally no role in computing <code>ptr</code>!
It would be a disaster to say that <code>ptr</code> could pick up the permission of <code>x</code> – just imagine all that <code>y</code>-manipulating code is moved into a different function.
Do we have to assume that any function we call can just do a cast to “steal” <code>x</code>’s permission?
That would entirely defeat the point of <code>restrict</code> and make <code>noalias</code> optimizations basically impossible.</p>

<p>But how can it be okay for <code>ptr</code> to pick up <code>x</code>’s permission in the original program, and <em>not</em> okay for it to pick up the same permission in the final program?
The key difference is that in the original program, <code>x</code> <em>has been cast to an integer</em>.
When you cast a pointer to an integer, you are basically declaring that its permission is “up for grabs”, and any future integer-pointer cast may end up endowing the resulting pointer with this permission.
We say that the permission has been “exposed”.
And <em>that</em> is the side-effect that <code>(uintptr_t)x</code> has!</p>

<p>Yes, this way of resolving the conflict <em>does</em> mean we will lose some optimizations.
We <em>have to</em> lose some optimization, as the example shows.
However, the crucial difference to the previous section is that <em>only code which casts pointers to integers is affected</em>.
This means we can keep the performance cost localized to code that does ‘tricky things’ around pointers – that code needs the compiler to be a bit conservative, but all the other code can be optimized without regard for the subtleties of pointer-integer-pointer round-trips.
(Specifically, <em>both</em> pointer-integer and integer-pointer casts have to be treated as impure operations, but for different reasons.
Pointer-integer casts have a side-effect as we have seen.
Integer-pointer casts are <em>non-deterministic</em> – they can produce different results even for identical inputs.
I moved the discussion of this point into the appendix below.)</p>

<h2 id="strict-provenance-pointer-integer-casts-without-side-effects">Strict provenance: pointer-integer casts <em>without</em> side-effects</h2>

<p>This may sound like bad news for low-level coding tricks like pointer tagging (storing a flag in the lowest bit of a pointer).
Do we have to optimize this code less just because of corner cases like the above?
As it turns out, no we don’t – there are some situations where it is perfectly fine to do a pointer-integer cast <em>without</em> having the “exposure” side-effect.
Specifically, this is the case if we never intend to cast the integer back to a pointer!
That might seem like a niche case, but it turns out that most of the time, we can avoid ‘bare’ integer-pointer casts, and instead use an operation like <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.with_addr"><code>with_addr</code></a> that explicitly specifies which provenance to use for the newly created pointer.<sup id="fnref:with_addr" role="doc-noteref"><a href="#fn:with_addr" rel="footnote">4</a></sup>
This is more than enough for low-level pointer shenanigans like pointer tagging, as <a href="https://gankra.github.io/blah/tower-of-weakenings/#strict-provenance-no-more-getting-lucky">Gankra demonstrated</a>.
Rust’s <a href="https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance">Strict Provenance experiment</a> aims to determine whether we can use operations like <code>with_addr</code> to replace basically all integer-pointer casts.</p>

<p>As part of Strict Provenance, Rust now has a second way of casting pointers to integers, <code>ptr.addr()</code>, which does <em>not</em> “expose” the permission of the underlying pointer, and hence can be treated like a pure operation!<sup id="fnref:experiment" role="doc-noteref"><a href="#fn:experiment" rel="footnote">5</a></sup>
We can do shenanigans on the integer representation of a pointer <em>and</em> have all these juicy optimizations, as long as we don’t expect bare integer-pointer casts to work.
As a bonus, this also makes Rust work nicely on CHERI <em>without</em> a 128bit wide <code>usize</code>, and it helps Miri, too.</p>

<p>But that is not the focus of this blog post, Gankra has <a href="https://gankra.github.io/blah/tower-of-weakenings/">already written most of what there is to say here</a>.
For this blog post, we are happy with what we learned about casts between pointers and integers.
We have found a way to resolve the conflict uncovered by the example, while keeping performance cost (due to lost optimizations) confined to just the code that is truly ambiguous, and even found alternative APIs that can be used to replace most (all?) uses of ambiguous integer-pointer casts.
All is well that ends well?
Unfortunately, no – we are not quite done yet with pointer provenance nightmares.</p>

<h2 id="lets-do-some-transmutation-magic">Let’s do some transmutation magic</h2>

<p>Languages like C or Rust typically allow programmers to re-interpret the underlying representation of a value at a different type.
In Rust, this is often called “transmutation”; in C, a common term for this is “type punning”.
The easiest way to do this in Rust is via the <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute</code></a> function, but alternatively transmutation is possible via <code>union</code>s or by casting a <code>*mut T</code> raw pointer to <code>*mut U</code>.
In C, the easiest way is to use a <code>memcpy</code> between variables of different types, but <code>union</code>-based type punning is also sometimes allowed, as is loading data of arbitrary type using a character-typed pointer.
(Other kinds of pointer-based type punning are forbidden by C’s strict aliasing rules, but Rust has no such restriction.)
The next question we are going to treat in this blog post is: what happens when we transmute a pointer to an integer?</p>

<p>Basically, imagine the original example after we replace the two casts (computing <code>xaddr</code> and <code>y2addr</code>) with a call to a function like</p>

<figure><pre><code data-lang="c"><span>static</span> <span>uintptr_t</span> <span>transmute_memcpy</span><span>(</span><span>int</span> <span>*</span><span>ptr</span><span>)</span> <span>{</span>
    <span>uintptr_t</span> <span>res</span><span>;</span>
    <span>memcpy</span><span>(</span><span>&amp;</span><span>res</span><span>,</span> <span>&amp;</span><span>ptr</span><span>,</span> <span>sizeof</span><span>(</span><span>uintptr_t</span><span>));</span>
    <span>return</span> <span>res</span><span>;</span>
<span>}</span></code></pre></figure>

<p>or</p>

<figure><pre><code data-lang="c"><span>static</span> <span>uintptr_t</span> <span>transmute_union</span><span>(</span><span>int</span> <span>*</span><span>ptr</span><span>)</span> <span>{</span>
    <span>typedef</span> <span>union</span> <span>{</span> <span>uintptr_t</span> <span>res</span><span>;</span> <span>int</span> <span>*</span><span>ptr</span><span>;</span> <span>}</span> <span>Transmute</span><span>;</span>
    <span>Transmute</span> <span>t</span><span>;</span>
    <span>t</span><span>.</span><span>ptr</span> <span>=</span> <span>ptr</span><span>;</span>
    <span>return</span> <span>t</span><span>.</span><span>res</span><span>;</span>
<span>}</span></code></pre></figure>

<p>All the same optimizations still apply – right?
This requires a compiler that can “see through” <code>memcpy</code> or union field accesses, but that does not seem too much to ask.
But now we have the same contradiction as before!
Either the original program already has Undefined Behavior, or one of the optimizations is incorrect.</p>

<p>Previously, we resolved this conundrum by saying that removing the “dead cast” <code>(uintptr_t)x</code> whose result is unused was incorrect, because that cast had the side-effect of “exposing” the permission of <code>x</code> to be picked up by future integer-pointer casts.
We could apply the same solution again, but this time, we would have to say that a <code>union</code> access (at integer type) or a  <code>memcpy</code> (to an integer) can have an “expose” side-effect and hence cannot be entirely removed even if its result is unused.
And that sounds quite bad!
<code>(uintptr_t)x</code> only happens in code that does tricky things with pointers, so urging the compiler to be careful and optimize a bit less seems like a good idea (and at least in Rust, <code>x.addr()</code> even provides a way to opt-out of this side-effect).
However, <code>union</code> and <code>memcpy</code> are all over the place.
Do we now have to treat <em>all</em> of them as having side-effects?
In Rust, due to the lack of a strict aliasing restriction (or in C with <code>-fno-strict-aliasing</code>), things get even worse, since literally <em>any</em> load of an integer from a raw pointer might be doing a pointer-integer transmutation and thus have the “expose” side-effect!</p>

<p>To me, and speaking from a Rust perspective, that sounds like bad idea.
Sure, we want to make it as easy as possible to write low-level code in Rust, and that code sometimes has to do unspeakable things with pointers.
But we <em>don’t</em> like the <em>entire ecosystem</em> to carry the cost of that decision by making it harder to remove every raw pointer load everywhere!
So what are the alternatives?</p>

<p>Well, I would argue that the alternative is to treat the original program (after translation to Rust) as having Undefined Behavior.
There are, to my knowledge, generally two reasons why people might want to transmute a pointer to an integer:</p>
<ul>
  <li>Chaining many <code>as</code> casts is annoying, so calling <code>mem::transmute</code> might be shorter.</li>
  <li>The code doesn’t actually care about the <em>integer</em> per se, it just needs <em>some way</em> to hold arbitrary data in a container of a given type.</li>
</ul>

<p>The first kind of code should just use <code>as</code> casts, and we should do what we can (via lints, for example) to identify such code and get it to use casts instead.<sup id="fnref:compat" role="doc-noteref"><a href="#fn:compat" rel="footnote">6</a></sup>
Maybe we can adjust the cast rules to remove the need for chaining, or add some <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.expose_addr">helper methods</a> that can be used instead.</p>

<p>The second kind of code should not use integers!
Putting arbitrary data into an integer type is already somewhat suspicious due to the trouble around padding (if we want to make use of those shiny new <code>noundef</code> annotations that LLVM offers, we have to disallow transmuting data with padding to integer types).
The right type to use for holding arbitrary data is <code>MaybeUninit</code>, so e.g. <code>[MaybeUninit&lt;u8&gt;; 1024]</code> for up to 1KiB of arbitrary data.
<code>MaybeUninit</code> can also hold pointers with their provenance without any trouble.</p>

<p>Because of that, I think we should move towards discouraging, deprecating, or even entirely disallowing pointer-integer transmutation in Rust.
That means a cast is the only legal way to turn a pointer into an integer, and after the discussion above we got our casts covered.
A <a href="https://github.com/rust-lang/rust/pull/95547">first careful step</a> has recently been taken on this journey; the <code>mem::transmute</code> documentation now cautions against using this function to turn pointers into integers.</p>

<h2 id="a-new-hope-for-rust">A new hope for Rust</h2>

<p>All in all, while the situation may be very complicated, I am actually more hopeful than ever that we can have both – a precise memory model for Rust <em>and</em> all the optimizations we can hope for!
The three core pillars of this approach are:</p>
<ul>
  <li>making pointer-integer casts “expose” the pointer’s provenance,</li>
  <li>offering <code>ptr.addr()</code> to learn a pointer’s address <em>without</em> exposing its provenance,</li>
  <li>and disallowing pointer-integer transmutation.</li>
</ul>

<p>Together, they imply that we can optimize “nice” code (that follows Strict Provenance, and does not “expose” or use integer-pointer casts) perfectly, without any risk of breaking code that does use pointer-integer round-trips.
In the easiest possible approach, the compiler can simply treat pointer-integer and integer-pointer casts as calls to some opaque external function.
Even if the rest of the compiler literally entirely ignores the existence of pointer-integer round-trips, it will still support such code correctly!</p>

<p>However, it’s not just compilers and optimizers that benefit from this approach.
One of my biggest quests is giving a <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">precise model</a> of the Rust aliasing rules, and that task has just gotten infinitely easier.
I used to worry <em>a lot</em> about pointer-integer round-trips while developing Stacked Borrows.
This is the entire reason why all of this “untagged pointer” mess exists.</p>

<p>Under this brave new world, I can entirely ignore pointer-integer round-trips when designing memory models for Rust.
Once that design is done, support for pointer-integer round-trips can be added as follows:</p>
<ul>
  <li>When a pointer is cast to an integer, its provenance (whatever information it is that the model attaches to pointers – in Stacked Borrows, this is called the pointer’s <em>tag</em>) is marked as “exposed”.</li>
  <li>When an integer is cast to a pointer, we <em>guess</em> the provenance that the new pointer should have from among all the provenances that have been previously marked as “exposed”.
(And I mean <em>all</em> of them, not just the ones that have been exposed “at the same address” or anything like that. People will inevitably do imperfect round-trips where the integer is being offset before being cast back to a pointer, and we should support that. As far as I know, this doesn’t really cost us anything in terms of optimizations.)</li>
</ul>

<p>This “guess” does not need to be described by an algorithm.
Through the magic that is formally known as <a href="https://en.wikipedia.org/wiki/Angelic_non-determinism">angelic non-determinism</a>, we can just wave our hands and say “the guess will be maximally in the programmer’s favor”: if <em>any</em> possible choice of (previously exposed) provenance makes the program work, then that is the provenance the new pointer will get.
Only if <em>all</em> choices lead to Undefined Behavior, do we consider the program to be ill-defined.
This may sound like cheating, but it is actually a legit technique in formal specifications.</p>

<p>Also note how it’s really <em>just</em> the integer-pointer casts that are making things so complicated here.
If it weren’t for them, we would not even need all that “exposure” machinery.
Pointer-integer casts on their own are perfectly fine!
That’s why <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.addr"><code>addr</code></a>+<a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.with_addr"><code>with_addr</code></a> is such a nice API from a memory model perspective.<sup id="fnref:fake_alloc" role="doc-noteref"><a href="#fn:fake_alloc" rel="footnote">7</a></sup></p>

<p>This approach <em>does</em> have the disadvantage that it becomes near impossible to write a tool like Miri that precisely matches the specification, since Miri cannot possibly implement this “guessing” accurately.
However, Miri can still properly check code that uses Strict Provenance operations, so hopefully this is just yet another incentive (besides the more precise specification and better optimization potential) for programmers to move their code away from integer-pointer casts and towards Strict Provenance.
And who knows, maybe there <em>is</em> a clever way that Miri can actually get reasonably close to checking this model?
It doesn’t have to be perfect to be useful.</p>

<p>What I particularly like about this approach is that it makes pointer-integer round-trips a purely local concern.
With an approach like Stacked Borrows “untagged pointers”, <em>every</em> memory operation has to define how it handles such pointers.
Complexity increases globally, and even when reasoning about Strict Provenance code we have to keep in mind that some pointers in other parts of the program might be “untagged”.
In contrast, this “guessing maximally in your favor”-based approach is entirely local; code that does not syntactically contain exposing pointer-integer or integer-pointer casts can literally forget that such casts exist at all.
This is true both for programmers thinking about their <code>unsafe</code> code, and for compiler authors thinking about optimizations.
Compositionality at its finest!</p>

<h2 id="but-what-about-c">But what about C?</h2>

<p>I have talked a lot about my vision for “solving” pointer provenance in Rust.
What about other languages?
As you might have heard, C is moving towards making <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2676.pdf">PNVI-ae-udi</a> an official recommendation for how to interpret the C memory model.
With C having so much more legacy code to care about and many more stakeholders than Rust does, this is an impressive achievement!
How does it compare to all I said above?</p>

<p>First of all, the “ae” part of the name refers to “address-exposed” – that’s exactly the same mechanism as what I described above!
In fact, I have taken the liberty to use their terminology.
So, on this front, I see Rust and C as moving into the same direction, which is great.
(Now we just need to get LLVM to also move in that direction.)
I should mention that PNVI-ae-udi does <em>not</em> account for the <code>restrict</code> modifier of C, so in a sense it is solving an easier problem than the Rust memory model which has no choice but to contend with interesting questions around aliasing restrictions.
However, if/when a more precise model of C with <code>restrict</code> emerges, I don’t think they will be moving away from the “address-exposed” model – to the contrary, as I just argued this model means we can specify <code>restrict</code> without giving a thought to pointer-integer round-trips.</p>

<p>The “udi” part of the name means “user disambiguation”, and is basically the mechanism by which an integer-pointer cast in C “guesses” the provenance it has to pick up.
The details of this are complicated, but the end-to-end effect is basically exactly the same as in the “best possible guess” model I have described above!
Here, too, my vision for Rust aligns very well with the direction C is taking.
(The set of valid guesses in C is just a lot more restricted since they do not have <code>wrapping_offset</code>, and the model does not cover <code>restrict</code>.
That means they can actually feasibly give an algorithm for how to do the guessing.
They don’t have to invoke scary terms like “angelic non-determinism”, but the end result is the same – and to me, the fact that it is equivalent to angelic non-determinism is what justifies this as a reasonable semantics.
Presenting this as a concrete algorithm to pick a suitable provenance is then just a stylistic choice.)
Kudos go to Michael Sammler for opening my eyes to this interpretation of “user disambiguation”, and arguing that angelic non-determinism might not be such a crazy idea after all.</p>

<p>What is left is the question of how to handle pointer-integer transmutation, and this is where the roads are forking.
PNVI-ae-udi explicitly says loading from a union field at integer type exposes the provenance of the pointer being loaded, if any.
So, the example with <code>transmute_union</code> would be allowed, meaning the optimization of removing the “dead” load from the <code>union</code> would <em>not</em> (in general) be allowed.
Same for <code>transmute_memcpy</code>, where the proposal says that when we access the contents of <code>ret</code> at type <code>uintptr_t</code>, that will again implicitly expose the provenance of the pointer.</p>

<p>I think there are several reasons why this choice makes sense for C, that do not apply to Rust:</p>
<ul>
  <li>There is a <em>lot</em> of legacy code. A <em>LOT</em>.</li>
  <li>There is no alternative like <code>MaybeUninit</code> that could be used to hold data without losing provenance.</li>
  <li>Strict aliasing means that not <em>all</em> loads at integer type have to worry about provenance; only loads at character type are affected.</li>
</ul>

<p>On the other hand, I am afraid that this choice might come with a significant cost in terms of lost optimizations.
As the example above shows, the compiler has to be very careful when removing any operation that can expose a provenance, since there might be integer-pointer casts later that rely on this.
(Of course, until this is actually implemented in GCC or LLVM, it will be hard to know the actual cost.)
Because of all that, I think it is reasonable for Rust to make a different choice here.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This was a long post, but I hope you found it worth reading. :)
To summarize, my concrete calls for action in Rust are:</p>
<ul>
  <li>Code that uses pointer-integer transmutation should migrate to regular casts or <code>MaybeUninit</code> transmutation ASAP.
I think we should declare pointer-integer transmutation Undefined Behavior and not accept such code as well-defined.</li>
  <li>Code that uses pointer-integer or integer-pointer <em>casts</em> might consider migrating to the Strict Provenance APIs.
You can do this even on stable with <a href="https://crates.io/crates/sptr">this polyfill crate</a>.
However, such code <em>is and remains</em> well-defined. It just might not be optimized as well as one could hope, it might not compile on CHERI, and Miri will probably miss some bugs.
If there are important use-cases not covered by Strict Provenance, we’d like to hear about them!</li>
</ul>

<p>This is a large undertaking and will require a lot of work!
However, at the end of this road is a language with a coherent, well-defined memory model <em>and</em> support for doing unspeakable things to pointers <em>without</em> incurring a (reasoning or optimization) cost on code that is perfectly nice to its pointers.
Let us work towards this future together. :)</p>

<h2 id="appendix">Appendix</h2>

<h4 id="integer-pointer-casts-are-not-pure-either">Integer-pointer casts are not pure, either</h4>

<p>I promised an example of how integer-pointer casts are “impure”, in the sense that two casts with the same input integer can produce different pointers:</p>

<figure><pre><code data-lang="c"><span>static</span> <span>int</span> <span>uwu</span><span>(</span><span>int</span> <span>*</span><span>restrict</span> <span>x</span><span>,</span> <span>int</span> <span>*</span><span>restrict</span> <span>y</span><span>)</span> <span>{</span>
  <span>*</span><span>x</span> <span>=</span> <span>0</span><span>;</span>
  <span>*</span><span>y</span> <span>=</span> <span>0</span><span>;</span>

  <span>uintptr_t</span> <span>xaddr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>x</span><span>;</span>
  <span>int</span> <span>*</span><span>y2</span> <span>=</span> <span>y</span><span>-</span><span>1</span><span>;</span>
  <span>uintptr_t</span> <span>y2addr</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>y2</span><span>;</span>
  <span>assert</span><span>(</span><span>xaddr</span> <span>==</span> <span>y2addr</span><span>);</span>

  <span>int</span> <span>*</span><span>xcopy</span> <span>=</span> <span>(</span><span>int</span><span>*</span><span>)</span><span>xaddr</span><span>;</span>
  <span>int</span> <span>*</span><span>y2copy</span> <span>=</span> <span>(</span><span>int</span><span>*</span><span>)</span><span>y2addr</span><span>;</span>
  <span>int</span> <span>*</span><span>ycopy</span> <span>=</span> <span>y2copy</span><span>+</span><span>1</span><span>;</span>

  <span>return</span> <span>*</span><span>xcopy</span> <span>+</span> <span>*</span><span>ycopy</span><span>;</span>
<span>}</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>int</span> <span>i</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>0</span><span>};</span>
  <span>uwu</span><span>(</span><span>&amp;</span><span>i</span><span>[</span><span>0</span><span>],</span> <span>&amp;</span><span>i</span><span>[</span><span>1</span><span>]);</span>
<span>}</span></code></pre></figure>

<p>If we ignore the pointer-integer round-trips, this uses <code>x</code> and <code>xcopy</code> to access <code>i[0]</code>, while using <code>y</code> and <code>ycopy</code> to access <code>i[1]</code>, so this should be uncontroversial.
<code>ycopy</code> is computed via <code>(y-1)+1</code>, but hopefully nobody disagrees with that.
Then we just add some pointer-integer round-trips.</p>

<p>But now, consider that <code>(int*)xaddr</code> and <code>(int*)y2addr</code> take the same integer as input!
If the compiler were to treat integer-pointer casts as a pure, deterministic operation, it could replace <code>(int*)y2addr</code> by <code>xcopy</code>.
However, that would mean <code>xcopy</code> and <code>ycopy</code> have the same provenance!
And there exists no provenance in this program that has access to both <code>i[0]</code> and <code>i[1]</code>.
So, either the cast has to synthesize a new provenance that has never been seen before, or doing common subexpression elimination on integer-pointer casts is wrong.</p>

<p>My personal stance is that we should not let the cast synthesize a new provenance.
This would entirely lose the benefit I discussed above of making pointer-integer round-trips a <em>local</em> concern – if these round-trips produce new, never-before-seen kinds of provenance, then the entire rest of the memory model has to define how it deals with those provenances.
We already have no choice but treat pointer-integer casts as an operation with side-effects; let’s just do the same with integer-pointer casts and remain sure that no matter what the aliasing rules are, they will work fine even in the presence of pointer-integer round-trips.</p>

<h4 id="what-about-llvm">What about LLVM?</h4>

<p>I discussed above how my vision for Rust relates to the direction C is moving towards.
What does that mean for the design space of LLVM?
Which changes would have to be made to fix (potential) miscompilations in LLVM and to make it compatible with these ideas for C and/or Rust?
Here’s the list of open problems I am aware of:</p>
<ul>
  <li>LLVM would have to to stop <a href="https://github.com/llvm/llvm-project/issues/33896">removing <code>inttoptr(ptrtoint(_))</code></a> and stop doing <a href="https://github.com/llvm/llvm-project/issues/34577">replacement of <code>==</code>-equal pointers</a>.</li>
  <li>As the first example shows, LLVM also needs to treat <code>ptrtoint</code> as a side-effecting operation that has to be kept around even when its result is unused. (Of course, as with everything I say here, there can be special cases where the old optimizations are still correct, but they need extra justification.)</li>
  <li>I think LLVM should also treat <code>inttoptr</code> as a side-effecting (and, in particular, non-deterministic) operation, as per the last example. However, this could possibly be avoided with a <code>noalias</code> model that specifically accounts for new kinds of provenance being synthesized by casts. (I am being vague here since I don’t know what that provenance needs to look like.)</li>
</ul>

<p>So far, this all applies to LLVM as a Rust and C backend equally, so I don’t think there are any good alternatives.
On the plus side, adapting this strategy for <code>inttoptr</code> and <code>ptrtoint</code> means that the recent LLVM <a href="https://lists.llvm.org/pipermail/llvm-dev/2019-March/131127.html">“Full Restrict Support”</a> can also handle pointer-integer round-trips “for free”!</p>

<p>Adding <code>with_addr</code>/<code>copy_alloc_id</code> to LLVM is not strictly necessary, since it can be implemented with <code>getelementptr</code> (without <code>inbounds</code>).
However, optimizations don’t seem to always deal well with that pattern, so it might still be a good idea to add this as a primitive operation to LLVM.</p>

<p>Where things become more subtle is around pointer-integer transmutation.
If LLVM wants to keep doing replacement of <code>==</code>-equal integers (which I strongly assume to be the case), <em>something</em> needs to give: my first example, with casts replaced by transmutation, shows a miscompilation.
If we focus on doing an <code>i64</code> load of a pointer value (e.g. as in the LLVM IR produced by <code>transmute_union</code>, or pointer-based transmutation in Rust), what are the options?
Here are the ones I have seen so far (but there might be more, of course):</p>
<ol>
  <li>The load could be said to behave like <code>ptrtoint</code>. This means it strips provenance and as a side-effect, it also exposes the pointer.</li>
  <li>The load could be said to just strip provenance <em>without</em> exposing the pointer.</li>
  <li>The load could be simply UB or return <code>poison</code>.</li>
  <li>The load could produce an integer with provenance, <em>and moreover</em> any computation on such an integer (including <code>icmp</code>) is UB (or returns <code>poison</code>).
  This has some subtle consequences, but they might be mostly harmless. For example, <code>x</code> can no longer be replaced by <code>x+0</code>.
  We cannot assume that it is safe to compare arbitrary <code>i64</code> and branch on the result, even if they are <code>noundef</code>. Or maybe <code>noundef</code> also excludes provenance?
  This is certainly the least obvious alternative.</li>
</ol>

<p>Except for the first option, these all say that my example with transmutation instead of the pointer-integer casts is UB, which avoids the optimization problems that arise from accepting that example.
That is fine for my vision for Rust, but a problem for C with PNVI-ae-udi.
Only the first option is compatible with that, but that option also means entirely removing a load is non-trivial even if its result is unused!
I hope we can avoid that cost for Rust.</p>

<p>Another interesting difference between these options is whether the resulting semantics are “monotone” with respect to provenance: is “increasing” the provenance of a value (i.e., letting it access more memory) a legal program transformation?
With the last two options, it is not, since adding provenance to a value that did not have it can introduce Undefined Behavior.
The first two options are “monotone” in this sense, which seems like a nice property.
(This is comparable to how the semantics are “monotone” with respect to <code>undef</code> and <code>poison</code>: replacing either of them by a fixed value is a legal program transformation. For <code>undef</code>/<code>poison</code> this is crucially important, for provenance it seems more like a sanity check of the semantics.)</p>

<p>In all of these cases except the last one, LLVM would probably need something like a <a href="https://gist.github.com/georgemitenkov/3def898b8845c2cc161bd216cbbdb81f">byte type</a> so that a load of arbitrary data (including a pointer with provenance) can be done without losing the provenance attached to the data.</p>

<p>A similar question arises for doing a pointer-typed load of a bare integer (integer-pointer transmutation):</p>
<ol>
  <li>The load could have the effects of a <code>inttoptr</code>. This is less clearly bad than a <code>ptrtoint</code>, but is still tricky since (at least without extra work) <code>inttoptr</code> is non-deterministic and depends on the global set of exposed provenances (so, it cannot be easily reordered up across potentially exposing operations).
  I also have <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/286#issuecomment-860189806">another example</a> showing that if <em>both</em> pointer-integer transmutation and integer-pointer transmutation work like the corresponding casts (i.e., if the first of my options is picked for both loads of pointers at integer type, and integers at pointer type), then more optimizations fail:
  removing a store that follows a load and just writes back the same value that has just been loaded is no longer correct.
  Yet, I think this is what PNVI-ae-udi mandates. Again I hope Rust can opt-out of this.</li>
  <li>The load could create a pointer with “invalid” provenance.
  That means transmutation of a pointer to an integer and back produces a pointer that cannot be used to access memory, but avoids all the analysis difficulties that come with an <code>inttoptr</code>.
  This is what I think would be best for Rust.</li>
  <li>The load could produce <code>poison</code>, but I see no good reason for doing that.</li>
</ol>

<p>Since LLVM generally errs on the side of delaying UB as long as possible if that is not in conflict with optimizations, the second option for both questions feels most “on-brand” to me personally – but in the end, these are some hard choices that the LLVM community will have to make.
I can help evaluate these trade-offs by giving structure to the design space and pointing out the inevitable consequences of certain decisions, but I can only lend a hand here – while I think and care a lot about LLVM semantics, I haven’t done any direct work on LLVM myself.
I am also not enough of an expert for which optimizations are important and the performance impact of the various options here, so I hope we can get people with that kind of background involved in the discussion as well.
For the sake of the entire ecosystem I mostly hope that LLVM will make <em>some</em> choice so that we can, eventually, leave this limbo state we are currently in.</p>







    </article></div>
  </body>
</html>
