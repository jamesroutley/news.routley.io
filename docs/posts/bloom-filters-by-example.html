<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://llimllib.github.io/bloomfilter-tutorial/">Original</a>
    <h1>Bloom Filters by Example</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <p><span><a href="https://llimllib.github.io/bloomfilter-tutorial/zh_CN/">简体中文</a></span></p>

    <p>A Bloom filter is a data structure designed to tell you, rapidly and memory-efficiently, whether an element is
      present in a set.

    </p><p>The price paid for this efficiency is that a Bloom filter is a <strong>probabilistic data structure</strong>: it
      tells us that the element either <em>definitely is not</em> in the set or <em>may be</em> in the set.

    </p><p>The base data structure of a Bloom filter is a <strong>Bit Vector</strong>. Here&#39;s a small one we&#39;ll use to
      demonstrate:

    </p>

    <p>Each empty cell in that table represents a bit, and the number below it its index. To add an element to the Bloom
      filter, we simply hash it a few times and set the bits in the bit vector at the index of those hashes to 1.

    </p><p>It&#39;s easier to see what that means than explain it, so enter some strings and see how the bit vector changes. Fnv
      and Murmur are two simple hash functions:

    </p><div id="addstring">
      <p>Enter a string: 

      </p>

      <p>Your set: [<span id="yourset"></span>]
    </p></div>

    <p>When you add a string, you can see that the bits at the index given by the hashes are set to 1. I&#39;ve used the
      color green to show the newly added ones, but any colored cell is simply a 1.

    </p><p>To test for membership, you simply hash the string with the same hash functions, then see if those values are set
      in the bit vector. If they aren&#39;t, you know that the element isn&#39;t in the set. If they are, you only know that it
      <em>might</em> be, because another element or some combination of other elements could have set the same bits.
      Again, let&#39;s demonstrate:

    </p><div id="testmembership">
      <p>Test an element for membership: 
      </p>

      <p>Is the element in the set? <span id="ismember">no</span>

      </p><p>Probability of a false positive: <span id="false_pos_prob">0%</span>
    </p></div>

    <p>And that&#39;s the basics of a bloom filter!

    </p><h2>Advanced Topics</h2>

    <p>Before I write a bit more about Bloom filters, a disclaimer: I&#39;ve never used them in production. Don&#39;t take my
      word for it. All I intend to do is give you general ideas and pointers to where you can find out more.

    </p><p>In the following text, we will refer to a Bloom filter with <em>k</em> hashes, <em>m</em> bits in the filter, and
      <em>n</em> elements that have been inserted.

    </p><h3>Hash Functions</h3>

    <p>The hash functions used in a Bloom filter should be <strong><a href="http://en.wiktionary.org/wiki/independent_function">independent</a></strong> and <strong><a href="http://en.wikipedia.org/wiki/Uniform_distribution_(discrete)">uniformly distributed</a></strong>. They
      should also be as fast as possible (cryptographic hashes such as sha1, though widely used therefore are not very
      good choices).

    </p><p>Examples of fast, simple hashes that are independent enough<sup><a href="#footnote3">3</a></sup> include <a href="https://sites.google.com/site/murmurhash/">murmur</a>, <a href="https://github.com/Cyan4973/xxHash">xxHash</a>, the <a href="http://isthe.com/chongo/tech/comp/fnv/">fnv</a> series of hashes, and <a href="https://web.archive.org/web/20061030103559/http://www.concentric.net/~Ttwang/tech/inthash.htm">HashMix</a>.

    </p><p>To see the difference that a faster-than-cryptographic hash function can make, <a href="https://github.com/bitly/dablooms/pull/19">check out this story</a> of a ~800% speedup when switching a
      bloom filter implementation from md5 to murmur.

    </p><p>In a short survey of bloom filter implementations:
    </p><ul>
      <li>
        <a href="https://github.com/chromium/chromium/blob/faf8581c2f9cdcb590d3544530c88a00c043461b/components/optimization_guide/core/bloom_filter.cc">Chromium</a>
        uses <a href="https://github.com/chromium/chromium/blob/faf8581c2f9cdcb590d3544530c88a00c043461b/components/optimization_guide/core/bloom_filter.cc#L17-L26">murmur</a>.
        (also, <a href="https://web.archive.org/web/20160306232658/http://blog.alexyakunin.com/2010/03/nice-bloom-filter-application.html">here&#39;s</a>
        a short description of how they use bloom filters)
      </li>
      <li>
        <a href="https://plan9.io/sources/plan9/sys/src/cmd/venti/srv/bloom.c">Plan9</a> uses a simple hash as proposed
        in <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.152.579&amp;rank=1">Mitzenmacher 2005</a>
      </li>
      <li>
        <a href="https://github.com/sdroege/snippets/blob/master/snippets/bloomfilter.c">Sdroege Bloom filter</a> uses
        fnv1a (included just because I wanted to show one that uses fnv.)
      </li>
      <li>
        <a href="https://github.com/squid-cache/squid/blob/master/src/store_key_md5.cc">Squid</a> uses MD5
      </li>
      <li>
        <a href="https://github.com/RedisBloom/RedisBloom/blob/be2ef438ddd4343f12d4689eeaed9be21ff491f1/src/cuckoo.h#L38">RedisBloom</a>
        uses murmur
      </li>
      <li>
        <a href="https://github.com/apache/spark/blob/93251ed77ea1c5d037c64d2292b8760b03c8e181/common/sketch/src/main/java/org/apache/spark/util/sketch/BloomFilterImpl.java#L87">Apache
          Spark</a> uses murmur
      </li>
      <li>
        <a href="https://github.com/influxdata/influxdb/blob/e20b5e99a6f92614b1b97bda0807ef6c2ab1f7e9/pkg/bloom/bloom.go#L3">influxdb</a>
        uses xxhash
      </li>
      <li>
        <a href="https://github.com/armon/bloomd/blob/23c19a7f5cbb35d7c3d970bef13bc2bfbe3625f6/src/libbloom/bloom.c#L306">bloomd</a>
        (a neat project that uses a redis-ish protocol) uses murmur for the first two hashes, <a href="https://burtleburtle.net/bob/hash/spooky.html">SpookyHash</a> for the second two hashes, and a
        combination of the two for further hashes, as described in <sup><a href="#footnote3">3</a></sup>
      </li>
      <li>
        <a href="https://github.com/hashlookup/fleur">fleur (C)</a>, <a href="https://github.com/DCSO/flor">flor
          (python)</a>, and <a href="https://github.com/DCSO/bloom">bloom (go)</a> all use fnv
      </li>
      <li>
        <a href="https://github.com/sqlite/sqlite/blob/aa07b36dd52cfb4d7690d4e8917ea0187d44b405/src/vdbe.c#L674">Sqlite</a>
        added a bloom filter for analytic queries, but I do not understand the hash algorithm. Dr. Hipp <a href="https://sqlite.org/forum/forumpost/bd59962986a5668b">explains the purpose</a> of the filters on the
        sqlite forum.
      </li>
      <li>
        <a href="https://github.com/facebook/rocksdb/blob/88bc91f3cc2b492b8a45ba2c49650f527df97ad8/util/bloom_impl.h">RocksDB</a>
        is configurable, but claims <a href="https://github.com/facebook/rocksdb/blob/88bc91f3cc2b492b8a45ba2c49650f527df97ad8/util/hash.cc#L67-L83">in
          the source</a> that xxh3, a member of the <a href="https://github.com/Cyan4973/xxHash#benchmarks">xxhash
          family</a> performed best for them
        <ul>
          <li>They also link <a href="https://www.khoury.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf">&#34;Bloom Filters in
              Probabilistic Verification&#34;</a> by Dillinger and Maniolios, but it&#39;s pretty far over my head.</li>
        </ul>
      </li>
      <li>
        <a href="https://github.com/scylladb/scylladb/blob/10a11c2886cffb99f1be06fd5bf1920d5b0953b6/utils/bloom_filter.cc#L75-L84">ScyllaDB</a>
        uses murmur
      </li>
    </ul>

    <h3>How big should I make my Bloom filter?</h3>

    <p>It&#39;s a nice property of Bloom filters that you can modify the false positive rate of your filter. A larger filter
      will have less false positives, and a smaller one more.

    </p><p>Your false positive rate will be approximately <em>(1-e<sup>-kn/m</sup>)<sup>k</sup></em>, so you can just plug
      the number <em>n</em> of elements you expect to insert, and try various values of <em>k</em> and <em>m</em> to
      configure your filter for your application.<sup><a href="#footnote2">2</a></sup>

    </p><p>This leads to an obvious question:

    </p><h3>How many hash functions should I use?</h3>

    <p>The more hash functions you have, the slower your bloom filter, and the quicker it fills up. If you have too few,
      however, you may suffer too many false positives.

    </p><p>Since you have to pick <em>k</em> when you create the filter, you&#39;ll have to ballpark what range you expect
      <em>n</em> to be in. Once you have that, you still have to choose a potential <em>m</em> (the number of bits) and
      <em>k</em> (the number of hash functions).

    </p><p>It seems a difficult optimization problem, but fortunately, given an <em>m</em> and an <em>n</em>, we have a
      function to choose the optimal value of <em>k</em>: <em>(m/n)ln(2)</em> <sup><a href="#footnote2">2</a>, <a href="#footnote3">3</a></sup>

    </p><p>So, to choose the size of a bloom filter, we:

    </p><ol>
      <li>Choose a ballpark value for <em>n</em>
      </li><li>Choose a value for <em>m</em>
      </li><li>Calculate the optimal value of <em>k</em>
      </li><li>Calculate the error rate for our chosen values of <em>n</em>, <em>m</em>, and <em>k</em>. If it&#39;s
        unacceptable, return to step 2 and change m; otherwise we&#39;re done.
    </li></ol>

    <h3>How fast and space efficient is a Bloom filter?</h3>

    <p>Given a Bloom filter with <em>m</em> bits and <em>k</em> hashing functions, both insertion and membership testing
      are <em>O(k)</em>. That is, each time you want to add an element to the set or check set membership, you just need
      to run the element through the <em>k</em> hash functions and add it to the set or check those bits.

    </p><p>The space advantages are more difficult to sum up; again it depends on the error rate you&#39;re willing to tolerate.
      It also depends on the potential range of the elements to be inserted; if it is very limited, a deterministic bit
      vector can do better. If you can&#39;t even ballpark estimate the number of elements to be inserted, you may be better
      off with a hash table or a scalable Bloom filter<sup><a href="#footnote4">4</a></sup>.

    </p><h3>What can I use them for?</h3>

    <p>I&#39;ll link you to <a href="http://en.wikipedia.org/wiki/Bloom_filter#Examples">wiki</a> instead of copying what
      they say. <a href="https://archive.org/details/pyvideo_402___handling-ridiculous-amounts-of-data-with-probabilistic-data-structures">C.
        Titus Brown</a> also has an excellent talk on an application of Bloom filters to bioinformatics.

    </p><h3>References</h3>

    <p><a name="footnote1">1: </a><a href="http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=6CA79DD1A90B3EFD3D62ACE5523B99E7?doi=10.1.1.127.9672&amp;rep=rep1&amp;type=pdf">Network
          Applications of Bloom Filters: A Survey</a>, Broder and Mitzenmacher. An excellent overview.
        </p><p><a name="footnote2">2: </a><a href="http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives">Wikipedia</a>, which has
            an excellent and comprehensive page on Bloom filters
            </p><p><a name="footnote3">3: </a><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.152.579&amp;rank=1">Less Hashing, Same
                  Performance</a>, Kirsch and Mitzenmacher
                </p><p><a name="footnote4">4: </a><a href="http://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf">Scalable
                      Bloom Filters</a>, Almeida et al

  </p></div></div>
  </body>
</html>
