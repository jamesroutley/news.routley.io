<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.the-pans.com/relational/">Original</a>
    <h1>How and why the Relational Model works for databases</h1>
    
    <div id="readability-page-1" class="page"><section>
<p>This is a note on, the Turing Award laureate, Ted Codd&#39;s revolutionary paper — <em><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjv9YXhpbf1AhW_kIkEHazED9cQFnoECAYQAQ&amp;url=https%3A%2F%2Fwww.seas.upenn.edu%2F~zives%2F03f%2Fcis550%2Fcodd.pdf&amp;usg=AOvVaw0HymNIyGsw4MDwPW98GlLb">A Relational Model of Data for Large Shared Data Banks</a>.</em> In this post, I will review the paper and add my comments with a perspective from modern distributed databases. </p><h2 id="tight-coupling">Tight coupling</h2><p>How users used to interact with databases were tightly coupled with implementation details — e.g. how bits are managed and represented on physical hardware. Users might expect to get replies in certain order because data is sorted in a specific order on disk (<em>Ordering Dependence</em>) without explicitly expressing reply ordering requirements. Indices on data were exposed directly to users, which makes changing them (especially removing them) in the future difficult (<em>Indexing Dependence</em>). Data were organized in tree structures (like folders) — e.g. employees are nested under companies, and children nested under employees. The structure has to be exposed to users, who follow this path for data access. This means changes can&#39;t be made to the tree structures (<em>Access Path Dependence</em>).</p><h2 id="abstraction">Abstraction</h2><p>Many problems in computer science are solved by introducing another level of indirection or abstraction. What if instead of leaking data store order, indices, or how we structure the data storage, we introduce a language that just <em>describes</em> the data itself. It would be completely declarative, decoupling how users would reason about the data and how it&#39;s actually organized on disk. In Ted Codd&#39;s own words,</p><blockquote>... the independence of applicaiton programs and terminal activities from growth in data types and changes in data representation ... (section 1.1)</blockquote><p>By introducing an abstraction, it hides more complexities from the users and shifts more responsibilities to the database itself. It sounds really nice. But do we describe <em>data</em> exactly? </p><h2 id="all-data-can-be-described-as-relations">All data can be described as Relations</h2><blockquote>
<p>(Given domains S<sub>1</sub>, S<sub>2</sub>,... S<sub>n</sub>, a relation) <em>R</em> is a subset of the Cartesian product S<sub>1</sub> x S<sub>2</sub> x ... x S<sub>n</sub>. (section 1.3)</p>
</blockquote>
<p>Relations can be of different degrees. Relations of a single domain is <em>unary</em>, degree 2 <em>binary</em>, and degree n <em>n-ary</em>. Relations are usually represented using an array of tuples. This is only for expository purposes. Since we are only using relations to describe the data itself and data only, &#34;an array of tuples&#34; implies nothing about how the data would actually be organized (e.g. column-oriented or whatnot). This is a profound insight by Dr. Codd in 1970!</p><p>For example, <em>employment</em> is a relation of domain <em>employees</em> and <em>companies</em>. The existence of a tuple in this relation e.g. &lt;Bob, CakeCompany&gt; describes a specific employment relationship between Bob and a company named CakeCompany. Relation is a <em>set</em>, hence duplicated entries are removed. It makes sense intuitively. There&#39;s no point describing the employment relationship between Bob and the CakeCompany more than once. Notice that tuples in a relation are also not sorted. It doesn&#39;t make sense to say that &lt;Alice, IceCreamCompany&gt; should come before &lt;Bob, CakeCompany&gt;. Otherwise, we would fall back to <em>Order Dependence</em> again. It&#39;s the job of query to perform ordering, and others (and use indices to speed up the performance).</p><p>What is a <em>relation</em> in English? Actually the dictionary definition works pretty well in this case. The following definition comes from Merriam Webster.</p><blockquote>an aspect ... that connects two or more things or parts as being or belonging or working together</blockquote><p>The dictionary definition excludes unary relations, which we can address. A <em>relation</em> is an aspect that connects things together. Its definition is so general that it can be used to <em>describe</em> <em>all</em> data. There&#39;s no formal proof of the relational model&#39;s almightiness when it comes to describing <em>data</em>. However we can go though a thought experiment to convince ourselves that it indeed can describe <em>all</em> data. </p><p>Imagine in a vacuum, there&#39;s absolutely nothing. Then comes data, one after another. There are no meanings associated with these data (imagine they are just a set of randomly generated bits). All these data are within domain <em>S — </em>which represents all possible data. There is our first <em>unary relation</em>. Even though the data itself is meaningless, and randomly generated by the universe, we can run meaningful queries against it — e.g. has the same random bits been generated before. We can create a binary relation for this randomly generated data as well — e.g. <em>former</em> and <em>latter </em>to capture the <em>order</em> relationship between elements. </p><p>As time goes, we have different kinds (<em>domains</em>) of data. Some are numbers, some are text, images, videos, or anything that can be stored. If they all only work in complete isolation – no relations across these domains — as if they are in separate universes, it would just be the same as our initial scenario. If data from multiple domains (not necessarily distinct) start to connect, more relations are formed. The meaning of <em>connection</em> here is in the most general sense — everything, <em>everything</em> in <em>this</em> universe are connected. E.g. You, who are reading this post at this moment, is absolutely connected with me in a relation defined as <em>people who read this post</em>. E.g. whatever <a href="https://jwst.nasa.gov/">JWST</a> observes in the future is also connected with you and me in a relation defined as <em>things in this universe</em> (or things under the influence of the General Relativity, or you name it).</p><p>Relation can describe data in isolation as well as connections among data. <em>All</em> data can be described as relations. From this perspective, all data in a database is just a &#34;collection of time-varying relations&#34;.</p><p>Ted Codd then went on in details about <em>how</em> to describe data in relations. There he defined <em>primary key</em>, <em>foreign key</em>, a process of <em>normalization</em>, and linguistic aspects of this declarative language for describing relations. <em>All</em> these database aspects remained virtually unchanged since 1970, which is absolutely remarkable. Thanks to the NoSQL movement, we know it&#39;s not because of a lack of trying. </p><h2 id="relational-vs-kv-and-graph-model">Relational vs. k/v and graph model</h2><p>A key/value store is just a <em>binary relation</em>. A graph model is again nothing but a degeneralized relational model. For each node, it can be a relation for all relevant attributes. Each edge is nothing more than a binary relation. You can expand the degree to be beyond 2, if you store data on the edge itself. Comparing any data model against the relational model is nonstarter. </p><p>However, in practice, people are not just comparing data models but actual databases hosting these data models. Simple key/value stores and graph stores, by restricting their data models, are generally easier to scale in a <em>distributed</em> deployment. Describing data in terms of relations is incredibly powerful, but in a distributed system, you have to decide <em>where</em> to store a relation, how to <em>shard</em> a relation, etc. Here, the relational model&#39;s generality becomes a challenge. </p><h2 id="operations-on-relations">Operations on Relations</h2><p>Now we have a relation that describes that data we have, which is great. However, a database needs to be queried to be useful (otherwise it&#39;s indistinguishable from just writing to /dev/null). Dr. Codd then went on in details about a set of operations can be performed on relations — <em>projection(π)</em>, <em>natural</em> <em>join(*)</em>, and <em>restriction(|)</em>. </p><p>A <em>projection</em> is an operation that selects a few columns from the operand <em>relation</em>. It&#39;s notation is</p><p>π<sub>i<sub>1</sub></sub>,<sub>i<sub>2</sub></sub>,...,<sub>i<sub>k</sub></sub>(R)</p>
<p>, for selecting <code>i1</code>, <code>i2</code>, ... columns from relation <em>R</em>. </p><p>The result of a <em>natural join</em> of binary relation <em>R</em> with binary relation <em>S</em> is defined as</p><p>R*S = {(a, b, c): R(a,b) ∧ S(b, c)}.</p>
<p>For <em>restriction,</em></p><p>R<sub>L</sub>|<sub>M</sub>S (the L,M restriction of R by S) is the maximal subset R&#39; of R such that π<sub>L</sub>(R&#39;) = π<sub>M</sub>(S).</p>
<p>E.g. let R be a relation for employment, π<sub>L</sub>(R) be all the employee names, and π<sub>M</sub>(S) be one tuple &lt;Bob&gt;. Then R<sub>L</sub>|<sub>M</sub>S will give me Bob&#39;s employment tuple. <em>Restriction</em> is more general of course as it can be applied to multiple columns.</p>
<p>Relational Algebra was not invented in Dr. Codd&#39;s 1970 paper, as he was applying &#34;elementary relation theory&#34;. On <a href="https://en.wikipedia.org/wiki/Relational_algebra">Wikipedia</a>, you can find other relational operations e.g. <em>selection</em>, <em>outer join</em>, etc. Some of these can be expressed by just using <em>projection</em>, <em>natural join</em>, and <em>restriction</em>.</p><p>My previous example for restriction is essentially a <em>selection</em> for Bob&#39;s employment tuple. Some selection operations might be more general, e.g. selecting employee who&#39;s older than 30. Well that can be expressed as</p><p>R<sub>L</sub>|<sub>1</sub>S, where <em>R</em> is the employment relation, π<sub>L</sub>(R) returns the age column of <em>R</em>, and <em>S</em> = {x | x &gt; 30}.</p>
<p>Again these operations are completely decoupled from how query implementations. Users describe data in relations, which do <em>not</em> exist on disk. Users describe operations upon these relations, which also do <em>not</em> imply how these operations would be implemented and translated to machine instructions. My previous restriction case is a good example. No where it says for <code>S = {x | x &gt; 30}</code>, we have to have all the integers greater than 30 stored on disk. It&#39;s just <em>describing</em> all integers greater than 30. </p><h2 id="redundancy-and-consistency">Redundancy and Consistency</h2><p>A set of relations is redundant if a relation that has a projection which can be derived from other relations. E.g. a relation <code>employee (id#, name, manager_id#, managername)</code> is redundant because</p><p>π<sub>34</sub>(employee) = π<sub>12</sub>(employee)<sub>1</sub>|<sub>1</sub>π<sub>3</sub>(employee).</p>
<p>Having redundancy means there are multiple copies of the same data in various forms. Keeping them consistent would be a challenge. Dr. Codd called it out as a challenge at the last section. The good news is that Jim Gray, another Turing Award laureate, later came up transactions which solved the consistency problem and more.</p><h2 id="50-years-and-still-counting">50+ years and still counting</h2><p>It&#39;s mind boggling how much of Ted Codd&#39;s paper published in 1970 is still true and unchanged after more than 50 years, in a field that almost everything else is rapidly changing. It really speaks to the declarative power of the relational model. It offers paramount expressiveness about data, and completely decouples user data model from physical data representation (e.g. column-based database is a good example). It&#39;s one of the greatest examples of solving a hard computer science problem by introducing another level of indirection/abstraction. </p>
</section></div>
  </body>
</html>
