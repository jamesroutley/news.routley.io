<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yonom.substack.com/p/native-json-output-from-gpt-4">Original</a>
    <h1>Native JSON Output from GPT-4</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><span>When integrating LLMs in your products, you often want to generate structured data, like JSONs. With the help of </span><a href="https://platform.openai.com/docs/guides/gpt/function-calling" rel="nofollow ugc noopener">function calling</a><span> (released June 13th 2023), this process has become much simpler! </span></p><p>In this post I will explore the new API.</p><p><span>Function calling allows GPT to call a function instead of returning a string. At the time of writing, this feature is available for the chat models </span><code>gpt3-turbo-0613</code><span> and </span><code>gpt4-0613</code><span>.</span></p><p><span>For this feature, two new parameters have been introduced in the </span><a href="https://platform.openai.com/docs/api-reference/chat/create" rel="nofollow ugc noopener">Chat Completions API</a><span>:</span></p><ul><li><p><code>functions</code><span>: An array of functions available to GPT, each with a </span><code>name</code><span>, </span><code>description</code><span> and a </span><a href="https://json-schema.org/" rel="nofollow ugc noopener">JSON Schema</a><span> of the </span><code>parameters</code><span>.</span></p></li><li><p><code>function_call</code><span>: You can optionally specify </span><code>none</code><span> or </span><code>{ &#34;name&#34;: &#34;&lt;function_name&gt;&#34; }</code><span>. You can force GPT to use a specific function (or explicitly forbid calling any functions)</span></p></li></ul><p><span>I realized that by setting the </span><code>function_call</code><span> parameter, you can reliably expect JSON as responses from GPT calls. No more strings, yay!</span></p><p>Lets see it in action with a demo app, Recipe Creator.</p><p><span>Recipe Creator is an app where the user inputs the name of a dish and is provided with instructions on how to cook it. Of course, it can be used to generate recipes for completely fictional dishes; </span><em>if you can name it, there’s a recipe for it!</em></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png" data-component-name="Image2ToDOM" rel="nofollow ugc noopener"><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png" width="1456" height="932" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/bcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:932,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbcf4d45c-57cd-4dca-b2d3-2f173af25df0_1600x1024.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>Our frontend developer has asked us to create a backend API which returns a JSON like this one:</p><pre><code>{
  &#34;ingredients&#34;: [
    { &#34;name&#34;: &#34;Ingredient 1&#34;, &#34;amount&#34;: 5, &#34;unit&#34;: &#34;grams&#34; },
    { &#34;name&#34;: &#34;Ingredient 2&#34;, &#34;amount&#34;: 1, &#34;unit&#34;: &#34;cup&#34; },
  ],
  &#34;instructions&#34;: [
    &#34;Do step 1&#34;,
    &#34;Do step 2&#34;
  ],
  &#34;time_to_cook&#34;: 5 // minutes
}</code></pre><p>Let’s get started.</p><p>First, let’s create a JSON schema based on the example dataset.</p><pre><code>schema = {
  &#34;type&#34;: &#34;object&#34;,
  &#34;properties&#34;: {
    &#34;ingredients&#34;: {
      &#34;type&#34;: &#34;array&#34;,
      &#34;items&#34;: {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {
          &#34;name&#34;: { &#34;type&#34;: &#34;string&#34; },
          &#34;unit&#34;: { 
            &#34;type&#34;: &#34;string&#34;,
            &#34;enum&#34;: [&#34;grams&#34;, &#34;ml&#34;, &#34;cups&#34;, &#34;pieces&#34;, &#34;teaspoons&#34;]
          },
          &#34;amount&#34;: { &#34;type&#34;: &#34;number&#34; }
        },
        &#34;required&#34;: [&#34;name&#34;, &#34;unit&#34;, &#34;amount&#34;]
      }
    },
    &#34;instructions&#34;: {
      &#34;type&#34;: &#34;array&#34;,
      &#34;description&#34;: &#34;Steps to prepare the recipe (no numbering)&#34;,
      &#34;items&#34;: { &#34;type&#34;: &#34;string&#34; }
    },
    &#34;time_to_cook&#34;: {
      &#34;type&#34;: &#34;number&#34;,
      &#34;description&#34;: &#34;Total time to prepare the recipe in minutes&#34;
    }
  },
  &#34;required&#34;: [&#34;ingredients&#34;, &#34;instructions&#34;, &#34;time_to_cook&#34;]
}</code></pre><p>Now, let’s call the OpenAI API and pass the JSON schema defined above:</p><pre><code>import os
import openai

openai.api_key = os.getenv(&#34;OPENAI_API_KEY&#34;)

completion = openai.ChatCompletion.create(
  model=&#34;gpt-4-0613&#34;,
  messages=[
    {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
    {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Provide a recipe for spaghetti bolognese&#34;}
  ],
  functions=[{&#34;name&#34;: &#34;set_recipe&#34;, &#34;parameters&#34;: schema}],
  function_call={&#34;name&#34;: &#34;set_recipe&#34;},
  temperature=0,
)

print(completion.choices[0].message.function_call.arguments)</code></pre><p>Here’s the result of running the above code: recipe for spaghetti bolognese</p><pre><code>{
  &#34;ingredients&#34;:[
    {&#34;name&#34;: &#34;spaghetti&#34;, &#34;unit&#34;: &#34;grams&#34;, &#34;amount&#34;: 400},
    {&#34;name&#34;: &#34;ground beef&#34;, &#34;unit&#34;: &#34;grams&#34;, &#34;amount&#34;: 500},
    {&#34;name&#34;: &#34;onion&#34;, &#34;unit&#34;: &#34;pieces&#34;, &#34;amount&#34;: 1},
    {&#34;name&#34;: &#34;garlic cloves&#34;, &#34;unit&#34;: &#34;pieces&#34;, &#34;amount&#34;: 2},
    {&#34;name&#34;: &#34;carrot&#34;, &#34;unit&#34;: &#34;pieces&#34;, &#34;amount&#34;: 1},
    {&#34;name&#34;: &#34;celery stalk&#34;, &#34;unit&#34;: &#34;pieces&#34;, &#34;amount&#34;: 1},
    {&#34;name&#34;: &#34;canned tomatoes&#34;, &#34;unit&#34;: &#34;grams&#34;, &#34;amount&#34;: 400},
    {&#34;name&#34;: &#34;red wine&#34;, &#34;unit&#34;: &#34;ml&#34;, &#34;amount&#34;: 125},
    {&#34;name&#34;: &#34;olive oil&#34;, &#34;unit&#34;: &#34;ml&#34;, &#34;amount&#34;: 30},
    {&#34;name&#34;: &#34;salt&#34;, &#34;unit&#34;: &#34;teaspoons&#34;, &#34;amount&#34;: 1},
    {&#34;name&#34;: &#34;pepper&#34;, &#34;unit&#34;: &#34;teaspoons&#34;, &#34;amount&#34;: 1}
  ],
  &#34;instructions&#34;: [
    &#34;Heat the olive oil in a large pan over medium heat. Add the finely chopped onion, carrot, celery, and minced garlic and cook until softened.&#34;,
    &#34;Add the ground beef to the pan and cook until browned.&#34;,
    &#34;Pour in the red wine and let it simmer until the alcohol has evaporated.&#34;,
    &#34;Add the canned tomatoes, salt, and pepper. Reduce the heat to low, cover the pan, and let it simmer for about 1 hour, stirring occasionally.&#34;,
    &#34;In the meantime, cook the spaghetti in a large pot of boiling salted water according to the package instructions until al dente.&#34;,
    &#34;Drain the spaghetti and add it to the pan with the Bolognese sauce. Toss well to combine.&#34;,
    &#34;Serve the Spaghetti Bolognese with a sprinkle of freshly grated Parmesan cheese on top.&#34;
  ],
  &#34;time_to_cook&#34;: 90
}</code></pre><p>Perfect! 🧑‍🍳</p><p>I believe the new API will change the way we interact with OpenAI LLMs beyond the obvious use-case of plugins.</p><p>You could already generate JSON output with the help of prompt engineering: You put some json examples as part of GPT’s context window and ask it to generate a new one (few shot prompting).</p><p>This approach works well for simple cases but is prone to errors. GPT makes simple mistakes (like missing commas, unescaped line breaks) and sometimes gets completely derailed. You can also intentionally derail GPT with prompt injection.</p><p>This means that you need to defensively parse the output of GPT in order to salvage as much usable information as possible. Libraries like Langchain or llmparser help in this process, but come with their own limitations and boilerplate code.</p><p><strong>With lower level access to the large language model, you can do much better.</strong><span> I don’t have access to GPT4’s source, but I assume OpenAI’s implementation works conceptually similar to </span><a href="https://github.com/1rgs/jsonformer" rel="nofollow ugc noopener">jsonformer</a><span>, where the token selection algorithm is changed from “choose the token with the highest logit” to “choose the token with the highest logit which is valid for the schema”.</span></p><p>This means that the burden of following the specific schema is lifted from GPT and instead embedded into the token generation process. </p><p>The example above used 136 prompt tokens and 538 completion tokens (Costing $ 0.036 for GPT4 or $ 0.0013 for GPT 3.5).</p><p>If you were to use few-shot learning to get the same results, you would have needed more prompt tokens for the same task.</p><p>Lower token usage means faster and cheaper API calls.</p><p>The more things you ask of GPT at the same time, the more likely it is to make mistakes or hallucinations.</p><p>By removing the instructions of following a specific JSON format from your prompts, you simplify the task for GPT.</p><p>My intuition is that this increases the likelihood of success, meaning that your accuracy should go up.</p><p>Furthermore, you might be able to downgrade to a smaller GPT model in places where the JSON complexity made it otherwise infeasible, and gain speed and cost reduction benefits.</p><p>I was surprised by the little amount of code needed to build the recipe example. Doing something like this used to take far more boilerplate code in my previous attempts without function calling.</p><p>It is very cool that you can “code” an “intelligent” backend API in natural language. You can build such an API in a few hours.</p><p>The process is simple enough that you can let non-technical people build something like this via a no-code interface. No-code tools can leverage this to let their users define “backend” functionality.</p><p>Early prototypes of software can use simple prompts like this one to become interactive. Running an LLM every time someone clicks on a button is expensive and slow in production, but probably still ~10x cheaper to produce than code.</p><p><span>You can do </span><a href="https://platform.openai.com/docs/guides/gpt-best-practices/give-gpts-time-to-think" rel="nofollow ugc noopener">Chain of Thought Prompting</a><span> or even implement </span><a href="https://react-lm.github.io/" rel="nofollow ugc noopener">ReAct</a><span> as part of the JSON schema (GPT seems to respect the definition order of object properties).</span></p><p><span>OpenAI’s API seems to support JSON Schema features like </span><code>#ref</code><span> (recursion) and </span><code>oneOf</code><span> (multiple choice); meaning that you should be able to implement more complex agents and recursive thought processes via JSON schema in a single API request (as long as it fits in the context window).</span></p><p>This means that you can embed complex strategies into a single API call which makes your agents run faster and consume fewer tokens (since you don’t pass the same context across multiple API calls).</p><p>Not every JSON Schema feature is supported (if/else seems to be ignored, as are consts), but I do wonder if the supported features are enough to turn the schema language into a turing-complete one.</p></div></div></div></article></div></div></div>
  </body>
</html>
