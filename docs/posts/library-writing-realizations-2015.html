<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://cbloomrants.blogspot.com/2015/09/library-writing-realizations.html">Original</a>
    <h1>Library Writing Realizations (2015)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1304141133887067554" itemprop="description articleBody"><p>

Some learnings about library writing, N years on.

</p><p>

X. People will just copy-paste your example code.

</p><p>

This is obvious but is something to keep in mind.  Example code should never be sketches.  It should be
production ready.  People will not read the comments.  I had lots of spots in example code
where I would write comments
like &#34;this is just a sketch and not ready for production; production code needs to check error returns and
handle failures and be endian-independent&#34; etc.. and of course people just copy-pasted it and didn&#39;t change
it.  That&#39;s not their fault, that&#39;s my fault.  Example code is one of the main ways people get into your library.

</p><p>

X. People will not read the docs.

</p><p>

Docs are almost useless.  Nobody reads them.  They&#39;ll read a one page quick start, and then they want to
just start digging in writing code.  Keep the intros very minimal and very focused on getting things working.

</p><p>

Also be aware that if you feel you need to write a lot of docs about something, that&#39;s a sign that maybe
things are too complicated.

</p><p>

X. Peripheral helper features should be cut.

</p><p>

Cut cut cut.  People don&#39;t need them.  I don&#39;t care how nice they are, how proud of them you are.  Pare down
mercilessly.  More features just confuse and crud things up.  This is like what a good writer should do.
Figure out what your one core function really is and cut down to that.

</p><p>

If you feel that you really need to include your cute helpers, put them off on the side, or put them in
example code.  Or even just keep them in your pocket at home so that when someone asks about &#34;how I do this&#34;
you can email them out that code.

</p><p>

But really just cut them.  Being broad is not good.  You want to be very narrow.  Solve one clearly defined
problem and solve it well.  Nobody wants a kitchen sink library.

</p><p>

X. Simplicity is better.

</p><p>

Make everything as simple as possible.  Fewer arguments on your functions.  Remove extra functions.
Cut everywhere.  If you sacrifice a tiny bit of possible efficiency, or lose some rare functionality,
that&#39;s fine.  Cut cut cut.

</p><p>

For example, to plug in an allocator for Oodle used to require 7 function pointers :
{ Malloc, Free, MallocAligned, FreeSized, MallocPage, FreePage, PageSize }.  (FreeSized for efficiency,
and the Page stuff because async IO needs page alignment).  It&#39;s now down just 2 : { MallocAligned, Free }.
Yes it&#39;s a tiny bit slower but who cares.  (and the runtime can work without any provided allocators)

</p><p>

X. Micro-efficiency is not important.

</p><p>

Yes, being fast and lean is good, but not when it makes things too complex or difficult to use.
There&#39;s a danger of a kind of mental-masturbation that us RAD-type guys can get caught in.
Yes, your big stream processing stuff needs to be competitive (eg. Oodle&#39;s LZ decompress, or Bink&#39;s
frame decode time).  But making your Init() call take 100 clocks instead of 10,000 clocks is
irrelevant to everyone but you.  And if it requires funny crap from the user, then it&#39;s actually
making things worse, not better.  Having things just work reliably and safely and easily is more
important than micro-efficiency.

</p><p>

For example, one mistake I made in Oodle is that the compressed streams are headerless; they don&#39;t contain
the compressed or decompressed size.  The reason I did that is because often the game already has that information
from its own headers, so if I store it again it&#39;s redundant and costs a few bytes.  But that was foolish - to
save a few bytes of compressed size I sacrifice error checking, robustness, and convenience for people who don&#39;t
want to write their own header.  It&#39;s micro-efficiency that costs too much.

</p><p>

Another one I realized is a mistake : to do actual async writes on Windows, you need to call SetFileValidData
on the newly enlarged file region.  That requires admin privileges.  It&#39;s too much trouble, and nobody really
cares.  It&#39;s no worth the mess.  So in Oodle2 I just don&#39;t do that, and writes are no longer async.
(everyone else who thinks they&#39;re doing async writes isn&#39;t actually, and nobody else actually checks on their
threading the way I do, so it just makes me more like everyone else).

</p><p>

X. It should just work.

</p><p>

Fragile is bad.  Any API&#39;s that have to go in some complicated sequence, do this, then this, then this.
That&#39;s bad.  (eg. JPEGlib and PNGlib).  Things should just work as simply as possible without requirements.
Operations should be single function calls when possible.
Like if you take pointers in and out, don&#39;t require them to be aligned in a certain way or padded or allocated
with your own allocators.  Make it work with any buffer the user provides.  If you have options, make things
work reasonably with just default options so the user can ignore all the option setup if they want.  Don&#39;t require Inits
before your operations.

</p><p>

In Oodle2 , you just call Decompress(pointer,size,pointer) and it should Just Work.  Things like error handling
and allocators now just fall back to reasonable light weight defaults if you don&#39;t set up anything explicitly.

</p><p>

X. Special case stuff should be external (and callbacks are bad).

</p><p>

Anything that&#39;s unique to a few users, or that people will want to be different should be out of the library.
Make it possible to do that stuff through client-side code.  As much as possible, avoid callbacks to make this
work, try to do it through imperative sequential code.

</p><p>

eg. if they want to do some incremental post-processing of data in place, it should be possible via :
{ decode a bit, process some, decode a bit , process some } on the client side.  Don&#39;t do it with a callback
that does decode_it_all( process_per_bit_callback ).

</p><p>

Don&#39;t crud up the library feature set trying to please everyone.  Some of these things can go in example code,
or in your &#34;back pocket code&#34; that you send out as needed.

</p><p>

X. You are writing the library for evaluators and new users.

</p><p>

When you&#39;re designing the library, the main person to think about is evaluators and new users.  Things need
to be easy and clear and just work for them.

</p><p>

People who actually license or become long-term users are not a problem.  I don&#39;t mean this in a cruel way,
we don&#39;t devalue them and just care about sales.  What I mean is, once you have a relationship with them as a
client, then you can talk to them, help them figure out how to use things, show them solutions.  You can
send them sample code or even modify the library for them.

</p><p>

But evaluators won&#39;t talk to you.  If things don&#39;t just work for them, they will be frustrated.  If things
are not performant or have problems, they will think the library sucks.  So the library needs to work well
for them with no help from you.  And they often won&#39;t read the docs or even use your examples.  So it needs
to go well if they just start blindly calling your APIs.

</p><p>

(this is a general principle for all software; also all GUI design, and hell just design in general.
Interfaces should be designed for the novice to get into it easy, not for the expert to be efficient
once they master it.  People can learn to use almost any interface well (*) once they are used to it,
so you don&#39;t have to worry about them.)

</p><p>

(* = as long as it&#39;s low latency, stateless, race free, reliable, predictable, which nobody in the fucking
world seems to understand any more.  A certain sequence of physical actions that you develop muscle memory
for should always produce the same result, regardless of timing, without looking at the device or screen to
make sure it&#39;s keeping up.  Everyone who fails this (eg. everyone) should be fucking fired and then shot.
But this is a bit off topic.)

</p><p>

X. Make the default log &amp; check errors.  But make the default reasonably fast.

</p><p>

This is sort of related to the evaluator issue.  The defaults of the library need to be targetted at
evaluators and new users.  Advanced users can change the defaults if they want; eg. to ship they will
turn off logging &amp; error checking.  But that should not be how you ship, or evaluators will trigger
lots of errors and get failures with no messages.  So you need to do some amount of error checking &amp;
logging so that evaluators can figure things out.  *But* they will also measure performance without
changing the settings, so your default settings must also be fast.

</p><p>

X. Make easy stuff easy.  It&#39;s okay if complicated stuff is hard.

</p><p>

Kind of self explanatory.  The API should be designed so that very simple uses require tiny bits of code.
It&#39;s okay if something complicated and rare is a pain in the ass, you don&#39;t need to design for that; just
make it possible somehow, and if you have to help out the rare person who wants to do a weird thing, that&#39;s
fine.  Specifically, don&#39;t try to make very flexible general APIs that can do everything &amp; the kitchen
sink.  It&#39;s okay to have a super simple API that covers 99% of users, and then a more complex path for the
rare cases.
</p>
</div></div>
  </body>
</html>
