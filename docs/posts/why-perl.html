<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://two-wrongs.com/why-perl">Original</a>
    <h1>Why Perl?</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
I sometimes get asked why I use Perl so much. Am I not a fan of strongly typed
functional programming? Yeah, I am. Ask me to write something that is known,
<i>for sure</i>, to become a big system and I’ll pick strongly typed functional
programming without hesitation.<span><sup>1</sup> And, of course, put me in a team that uses
Blub, and I’ll pick up Blub in a heartbeat. Except <abbr>php</abbr>. I tried to give
<abbr>php</abbr> an honest chance recently (“It has changed”, they said, “It is much better
with modern practices”) but it was painful all the way through, even when I
tried to do everything right.</span> But most of the software I write is not <i>for
sure</i> going to become a big system. Here’s what Perl does well:
</p>

<ol>
<li>It is installed by default everywhere. I don’t need administrative privileges
to deploy Perl code almost anywhere. That is extremely empowering.</li>

<li>With a great amount of discipline, Perl scripts can be successfully scaled up
into large, complex systems.</li>

<li>I can be confident that a Perl script I write today will run unaltered 10
years from now, modulo external collaborators.</li>

<li>Perl can be used nearly as a shell replacement for very quick scripting.</li>

<li>Perl has a small set of core syntax and is very extensible and flexible in
adopting new paradigms.</li>
</ol>

<p>
These requirements are listed in priority order. The most important
consideration is ubiquity. When throwing out a quick prototype, I don’t want the
deployment instructions to start with “First install a development
environment.”<span><sup>2</sup> What about containers? Maybe. I’ve had mixed experiences with
that. If nothing else, it adds a lot of extra … <i>stuff</i> to what should be a
small experiment.</span> Since prototypes always outlive their intended lifespan, it
is also very important that it is possible to write maintainable software in the
language, and that it will keep running for as long as someone is interested in
running it.
</p>

<p>
Perl is unique in fulfilling these requirements. Let’s look at some other
alternatives I’ve considered for this role, and tried to use that way for at
least a month.
</p>

<div>
<table>


<colgroup>
<col/>

<col/>

<col/>

<col/>

<col/>

<col/>
</colgroup>
<thead>
<tr>
<th scope="col">Language</th>
<th scope="col">Ubiquity</th>
<th scope="col">Scales up</th>
<th scope="col">Compatibility</th>
<th scope="col">Shell scripts</th>
<th scope="col">Extensible</th>
</tr>
</thead>
<tbody>
<tr>
<td>Perl</td>
<td>✅</td>
<td>✅*</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>

<tr>
<td>Python</td>
<td>✅*</td>
<td>✅</td>
<td>❌</td>
<td>❌*</td>
<td>❌</td>
</tr>

<tr>
<td>JavaScript</td>
<td>✅*</td>
<td>✅*</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>

<tr>
<td>Bash</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>

<tr>
<td>Common Lisp</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>

<tr>
<td>Java/C#</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>

<tr>
<td>Haskell</td>
<td>❌</td>
<td>✅</td>
<td>❌*</td>
<td>✅*</td>
<td>✅</td>
</tr>

<tr>
<td>R</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>✅*</td>
<td>✅</td>
</tr>
</tbody>
</table>

</div>

<p>
Asterisk means borderline passing or borderline failing grade, depending on
which symbol it is attached to.
</p>

<p>
Now is the time to admit that the real requirements are just the first three.
That it’s convenient for quick scripts and adaptable around new paradigms is a
small bonus – but as we see, Perl is unique also in fulfilling the first three
and beggars can’t be choosers.
</p>

<p>
What about Ruby, Raku, F#, Scala, or Prolog? I haven’t actually tried any of
them in this role for any extended period of time, so I don’t want to pass
public judgment. What I do know is that none of them are as ubiquitous as Perl,
which is the primary requirement.
</p>

            </div></div>
  </body>
</html>
