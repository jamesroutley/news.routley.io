<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/nickponline/shreg">Original</a>
    <h1>Show HN: Various shape regularization algorithms</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A Python implementation of various shape regularization algorithms for regularizing line segments and closed contours.</p>
<p dir="auto">Shape regularization is a technique used in computational geometry to clean up noisy or imprecise geometric data by aligning segments to common orientations and adjusting their positions to create cleaner, more regular shapes.</p>

<ul dir="auto">
<li><strong>Segment Regularization</strong>: Align line segments to common angles and offsets using quadratic programming optimization</li>
<li><strong>Snap Regularization</strong>: Connect nearby endpoints to create watertight polygons and meshes</li>
<li><strong>Metric Regularization</strong>: Constrain segment dimensions - equal lengths, length quantization, and equal spacing</li>
<li><strong>Contour Regularization</strong>: Simplify closed polygons by aligning edges to principal directions</li>
<li><strong>T-Junction Detection</strong>: Snap endpoints onto segment interiors for proper connectivity</li>
<li><strong>Flexible Configuration</strong>: Control maximum angle and offset tolerances</li>
<li><strong>Visualization</strong>: Built-in plotting utilities for before/after comparisons</li>
<li><strong>Pure Python</strong>: No dependencies required</li>
</ul>






<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/nickp/shreg.git
cd shreg
pip install -e ."><pre>git clone https://github.com/nickp/shreg.git
<span>cd</span> shreg
pip install -e <span>.</span></pre></div>


<p dir="auto">Regularize a set of line segments by aligning their angles and offsets:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import numpy as np
from shreg import solve_line_segments, seg

# Create some segments (each segment is [x1, y1, x2, y2])
segments = [
    seg(0.0, 0.0, 1.0, 0.02),   # Nearly horizontal
    seg(0.0, 1.0, 1.0, 1.05),   # Nearly horizontal, slightly offset
    seg(1.0, 0.0, 1.02, 1.0),   # Nearly vertical
]

# Regularize: align angles within 25 degrees, offsets within 0.5 units
result = solve_line_segments(
    segments,
    angle=True,
    offset=True,
    maximum_angle=25,
    maximum_offset=0.5
)"><pre><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>from</span> <span>shreg</span> <span>import</span> <span>solve_line_segments</span>, <span>seg</span>

<span># Create some segments (each segment is [x1, y1, x2, y2])</span>
<span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>1.0</span>, <span>0.02</span>),   <span># Nearly horizontal</span>
    <span>seg</span>(<span>0.0</span>, <span>1.0</span>, <span>1.0</span>, <span>1.05</span>),   <span># Nearly horizontal, slightly offset</span>
    <span>seg</span>(<span>1.0</span>, <span>0.0</span>, <span>1.02</span>, <span>1.0</span>),   <span># Nearly vertical</span>
]

<span># Regularize: align angles within 25 degrees, offsets within 0.5 units</span>
<span>result</span> <span>=</span> <span>solve_line_segments</span>(
    <span>segments</span>,
    <span>angle</span><span>=</span><span>True</span>,
    <span>offset</span><span>=</span><span>True</span>,
    <span>maximum_angle</span><span>=</span><span>25</span>,
    <span>maximum_offset</span><span>=</span><span>0.5</span>
)</pre></div>

<p dir="auto">Simplify a closed polygon by aligning edges to principal directions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import regularize_contour

# Define a noisy polygon (list of [x, y] points)
points = [
    [45, 29], [65, 440], [44, 498], [446, 498], [429, 325],
    [499, 309], [448, 206], [479, 148], [479, 31], [247, 88],
]

# Regularize with axis alignment
result = regularize_contour(
    points,
    principle=&#34;axis&#34;,     # Align to horizontal/vertical
    max_offset=20,        # Maximum offset for merging
)

print(f&#34;Simplified from {len(points)} to {len(result)} points&#34;)"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>regularize_contour</span>

<span># Define a noisy polygon (list of [x, y] points)</span>
<span>points</span> <span>=</span> [
    [<span>45</span>, <span>29</span>], [<span>65</span>, <span>440</span>], [<span>44</span>, <span>498</span>], [<span>446</span>, <span>498</span>], [<span>429</span>, <span>325</span>],
    [<span>499</span>, <span>309</span>], [<span>448</span>, <span>206</span>], [<span>479</span>, <span>148</span>], [<span>479</span>, <span>31</span>], [<span>247</span>, <span>88</span>],
]

<span># Regularize with axis alignment</span>
<span>result</span> <span>=</span> <span>regularize_contour</span>(
    <span>points</span>,
    <span>principle</span><span>=</span><span>&#34;axis&#34;</span>,     <span># Align to horizontal/vertical</span>
    <span>max_offset</span><span>=</span><span>20</span>,        <span># Maximum offset for merging</span>
)

<span>print</span>(<span>f&#34;Simplified from <span><span>{</span><span>len</span>(<span>points</span>)<span>}</span></span> to <span><span>{</span><span>len</span>(<span>result</span>)<span>}</span></span> points&#34;</span>)</pre></div>

<p dir="auto">Close gaps between nearby endpoints to create watertight polygons:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import snap_regularize_segments, seg

# Create segments with small gaps at corners
segments = [
    seg(0.0, 0.0, 1.0, 0.0),    # bottom edge
    seg(1.05, 0.02, 1.0, 1.0),  # right edge (gap at bottom-right)
    seg(1.0, 1.03, 0.0, 0.98),  # top edge (gap at corners)
    seg(-0.02, 1.0, 0.0, 0.0),  # left edge (gap at top-left)
]

# Snap endpoints within 0.1 units of each other
result = snap_regularize_segments(
    segments,
    epsilon=0.1,      # Distance threshold for snapping
    method=&#34;cluster&#34;  # Fast centroid-based method
)
# Result: All corners are now perfectly connected"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>snap_regularize_segments</span>, <span>seg</span>

<span># Create segments with small gaps at corners</span>
<span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>1.0</span>, <span>0.0</span>),    <span># bottom edge</span>
    <span>seg</span>(<span>1.05</span>, <span>0.02</span>, <span>1.0</span>, <span>1.0</span>),  <span># right edge (gap at bottom-right)</span>
    <span>seg</span>(<span>1.0</span>, <span>1.03</span>, <span>0.0</span>, <span>0.98</span>),  <span># top edge (gap at corners)</span>
    <span>seg</span>(<span>-</span><span>0.02</span>, <span>1.0</span>, <span>0.0</span>, <span>0.0</span>),  <span># left edge (gap at top-left)</span>
]

<span># Snap endpoints within 0.1 units of each other</span>
<span>result</span> <span>=</span> <span>snap_regularize_segments</span>(
    <span>segments</span>,
    <span>epsilon</span><span>=</span><span>0.1</span>,      <span># Distance threshold for snapping</span>
    <span>method</span><span>=</span><span>&#34;cluster&#34;</span>  <span># Fast centroid-based method</span>
)
<span># Result: All corners are now perfectly connected</span></pre></div>

<p dir="auto">Constrain segment dimensions - force equal lengths, quantize to grid units, or equalize spacing:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import metric_regularize_segments, seg

# Segments with slightly different lengths and uneven spacing
segments = [
    seg(0.0, 0.0, 1.9, 0.0),   # length ~2
    seg(0.0, 0.9, 2.1, 0.9),   # length ~2, y=0.9 (should be 1.0)
    seg(0.0, 2.0, 1.95, 2.0),  # length ~2
]

# Regularize: equal lengths, snap to 1-unit grid, equalize spacing
result = metric_regularize_segments(
    segments,
    equal_length=True,         # Force similar lengths to be equal
    length_quantization=True,  # Snap lengths to multiples of base_unit
    equal_spacing=True,        # Equalize gaps between parallel lines
    base_unit=1.0,             # Grid unit for quantization
)
# Result: All segments have length 2.0 and are evenly spaced at y=0, 1, 2"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>metric_regularize_segments</span>, <span>seg</span>

<span># Segments with slightly different lengths and uneven spacing</span>
<span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>1.9</span>, <span>0.0</span>),   <span># length ~2</span>
    <span>seg</span>(<span>0.0</span>, <span>0.9</span>, <span>2.1</span>, <span>0.9</span>),   <span># length ~2, y=0.9 (should be 1.0)</span>
    <span>seg</span>(<span>0.0</span>, <span>2.0</span>, <span>1.95</span>, <span>2.0</span>),  <span># length ~2</span>
]

<span># Regularize: equal lengths, snap to 1-unit grid, equalize spacing</span>
<span>result</span> <span>=</span> <span>metric_regularize_segments</span>(
    <span>segments</span>,
    <span>equal_length</span><span>=</span><span>True</span>,         <span># Force similar lengths to be equal</span>
    <span>length_quantization</span><span>=</span><span>True</span>,  <span># Snap lengths to multiples of base_unit</span>
    <span>equal_spacing</span><span>=</span><span>True</span>,        <span># Equalize gaps between parallel lines</span>
    <span>base_unit</span><span>=</span><span>1.0</span>,             <span># Grid unit for quantization</span>
)
<span># Result: All segments have length 2.0 and are evenly spaced at y=0, 1, 2</span></pre></div>


<p dir="auto">The algorithm optimizes segment orientations and positions to create cleaner line arrangements:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/segment_real_data.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/segment_real_data.png" alt="Segment Regularization - Real Data"/></a></p>
<p dir="auto">Angle regularization aligns crossing lines to common orientations:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/segment_angle.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/segment_angle.png" alt="Angle Regularization"/></a></p>
<p dir="auto">Combined angle and offset regularization on a hexagon:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/segment_hexagon.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/segment_hexagon.png" alt="Segment Regularization"/></a></p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Angle + Offset Regularization with Groups</h4><a id="user-content-angle--offset-regularization-with-groups" aria-label="Permalink: Angle + Offset Regularization with Groups" href="#angle--offset-regularization-with-groups"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This example from the <a href="https://doc.cgal.org/latest/Shape_regularization/index.html#title10" rel="nofollow">CGAL documentation</a> demonstrates sequential angle and offset regularization on 15 segments organized into three groups: outer boundary, top rhombus, and bottom rhombus.</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import solve_line_segments, create_cgal_example

# Load the 15 segments from the CGAL example
segments, groups = create_cgal_example()

# Regularize with tight tolerances
result = solve_line_segments(
    segments,
    angle=True,
    offset=True,
    maximum_angle=10,    # 10 degrees max angle deviation
    maximum_offset=0.1   # 0.1 units max offset
)"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>solve_line_segments</span>, <span>create_cgal_example</span>

<span># Load the 15 segments from the CGAL example</span>
<span>segments</span>, <span>groups</span> <span>=</span> <span>create_cgal_example</span>()

<span># Regularize with tight tolerances</span>
<span>result</span> <span>=</span> <span>solve_line_segments</span>(
    <span>segments</span>,
    <span>angle</span><span>=</span><span>True</span>,
    <span>offset</span><span>=</span><span>True</span>,
    <span>maximum_angle</span><span>=</span><span>10</span>,    <span># 10 degrees max angle deviation</span>
    <span>maximum_offset</span><span>=</span><span>0.1</span>   <span># 0.1 units max offset</span>
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/segment_cgal_example.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/segment_cgal_example.png" alt="CGAL 2.4 Angle + Offset Regularization"/></a></p>

<p dir="auto">Simplify complex polygons while preserving their essential shape:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/contour_simple.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/contour_simple.png" alt="Contour Regularization - Simple"/></a></p>
<p dir="auto">Complex shapes are reduced to their essential vertices:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/contour_rectangle.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/contour_rectangle.png" alt="Contour Regularization - Complex"/></a></p>

<p dir="auto">Snap regularization connects nearby endpoints to create watertight geometry. This is essential for creating closed polygons suitable for 3D extrusion, mesh generation, or CAD operations.</p>

<p dir="auto">The cluster method groups nearby endpoints and moves them to their centroid. This is the fastest approach and guarantees watertight results:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import snap_regularize_segments, seg

segments = [
    seg(0.0, 0.0, 1.0, 0.05),
    seg(1.08, 0.0, 1.05, 1.0),
    seg(1.0, 1.08, 0.0, 0.95),
    seg(-0.05, 1.0, 0.0, 0.0),
]
result = snap_regularize_segments(segments, epsilon=0.15, method=&#34;cluster&#34;)"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>snap_regularize_segments</span>, <span>seg</span>

<span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>1.0</span>, <span>0.05</span>),
    <span>seg</span>(<span>1.08</span>, <span>0.0</span>, <span>1.05</span>, <span>1.0</span>),
    <span>seg</span>(<span>1.0</span>, <span>1.08</span>, <span>0.0</span>, <span>0.95</span>),
    <span>seg</span>(<span>-</span><span>0.05</span>, <span>1.0</span>, <span>0.0</span>, <span>0.0</span>),
]
<span>result</span> <span>=</span> <span>snap_regularize_segments</span>(<span>segments</span>, <span>epsilon</span><span>=</span><span>0.15</span>, <span>method</span><span>=</span><span>&#34;cluster&#34;</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/snap_cluster.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/snap_cluster.png" alt="Snap Regularization - Cluster Method"/></a></p>

<p dir="auto">Hard constraints use quadratic programming to find the optimal positions that exactly satisfy all snap constraints while minimizing total endpoint movement:</p>
<div dir="auto" data-snippet-clipboard-copy-content="result = snap_regularize_segments(segments, epsilon=0.15, method=&#34;hard&#34;)"><pre><span>result</span> <span>=</span> <span>snap_regularize_segments</span>(<span>segments</span>, <span>epsilon</span><span>=</span><span>0.15</span>, <span>method</span><span>=</span><span>&#34;hard&#34;</span>)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/snap_hard.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/snap_hard.png" alt="Snap Regularization - Hard Constraints"/></a></p>
<div dir="auto"><h4 tabindex="-1" dir="auto">Soft Constraints (Elastic)</h4><a id="user-content-soft-constraints-elastic" aria-label="Permalink: Soft Constraints (Elastic)" href="#soft-constraints-elastic"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Soft constraints add &#34;spring&#34; forces between endpoints that should connect. This is useful when data is noisy and you&#39;re not certain endpoints should be exactly coincident:</p>
<div dir="auto" data-snippet-clipboard-copy-content="result = snap_regularize_segments(
    segments,
    epsilon=0.25,
    method=&#34;soft&#34;,
    soft_weight=50.0  # Higher = stiffer springs
)"><pre><span>result</span> <span>=</span> <span>snap_regularize_segments</span>(
    <span>segments</span>,
    <span>epsilon</span><span>=</span><span>0.25</span>,
    <span>method</span><span>=</span><span>&#34;soft&#34;</span>,
    <span>soft_weight</span><span>=</span><span>50.0</span>  <span># Higher = stiffer springs</span>
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/snap_soft.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/snap_soft.png" alt="Snap Regularization - Soft Constraints"/></a></p>

<p dir="auto">T-junctions occur when an endpoint should snap onto another segment&#39;s interior (not its endpoints). Enable T-junction detection for proper connectivity:</p>
<div dir="auto" data-snippet-clipboard-copy-content="segments = [
    seg(0.0, 0.0, 2.0, 0.0),      # horizontal line
    seg(0.0, 1.0, 2.0, 1.0),      # horizontal line
    seg(0.95, -0.08, 1.05, 1.1),  # vertical line (forms T-junctions)
]
result = snap_regularize_segments(
    segments, epsilon=0.15, method=&#34;cluster&#34;, t_junctions=True
)"><pre><span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>2.0</span>, <span>0.0</span>),      <span># horizontal line</span>
    <span>seg</span>(<span>0.0</span>, <span>1.0</span>, <span>2.0</span>, <span>1.0</span>),      <span># horizontal line</span>
    <span>seg</span>(<span>0.95</span>, <span>-</span><span>0.08</span>, <span>1.05</span>, <span>1.1</span>),  <span># vertical line (forms T-junctions)</span>
]
<span>result</span> <span>=</span> <span>snap_regularize_segments</span>(
    <span>segments</span>, <span>epsilon</span><span>=</span><span>0.15</span>, <span>method</span><span>=</span><span>&#34;cluster&#34;</span>, <span>t_junctions</span><span>=</span><span>True</span>
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/snap_tjunction.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/snap_tjunction.png" alt="Snap Regularization - T-Junctions"/></a></p>

<p dir="auto">Snap regularization works on polygons of any complexity:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/snap_complex.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/snap_complex.png" alt="Snap Regularization - Complex Polygon"/></a></p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Metric &amp; Pattern Regularization</h3><a id="user-content-metric--pattern-regularization" aria-label="Permalink: Metric &amp; Pattern Regularization" href="#metric--pattern-regularization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Metric regularization constrains the relative measurements of segments. This is useful for architectural drawings, CAD cleanup, and any domain where dimensions should follow regular patterns.</p>

<p dir="auto">Forces segments with similar lengths to be exactly equal. Useful when objects (like windows or columns) should have identical dimensions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="from shreg import metric_regularize_segments, seg

segments = [
    seg(0.0, 0.0, 2.0, 0.0),    # length 2.0
    seg(0.0, 1.0, 2.15, 1.0),   # length 2.15
    seg(0.0, 2.0, 1.9, 2.0),    # length 1.9
    seg(0.0, 3.0, 2.05, 3.0),   # length 2.05
]

result = metric_regularize_segments(
    segments,
    equal_length=True,
    length_tolerance=0.15,  # 15% relative tolerance
)
# Result: All segments now have equal length (~2.0)"><pre><span>from</span> <span>shreg</span> <span>import</span> <span>metric_regularize_segments</span>, <span>seg</span>

<span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>2.0</span>, <span>0.0</span>),    <span># length 2.0</span>
    <span>seg</span>(<span>0.0</span>, <span>1.0</span>, <span>2.15</span>, <span>1.0</span>),   <span># length 2.15</span>
    <span>seg</span>(<span>0.0</span>, <span>2.0</span>, <span>1.9</span>, <span>2.0</span>),    <span># length 1.9</span>
    <span>seg</span>(<span>0.0</span>, <span>3.0</span>, <span>2.05</span>, <span>3.0</span>),   <span># length 2.05</span>
]

<span>result</span> <span>=</span> <span>metric_regularize_segments</span>(
    <span>segments</span>,
    <span>equal_length</span><span>=</span><span>True</span>,
    <span>length_tolerance</span><span>=</span><span>0.15</span>,  <span># 15% relative tolerance</span>
)
<span># Result: All segments now have equal length (~2.0)</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/metric_equal_length.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/metric_equal_length.png" alt="Equal Length Regularization"/></a></p>

<p dir="auto">Snaps segment lengths to integer multiples of a base unit. Essential for architectural plans where walls must be multiples of a grid unit:</p>
<div dir="auto" data-snippet-clipboard-copy-content="segments = [
    seg(0.0, 0.0, 1.85, 0.0),   # length 1.85 -&gt; 2.0
    seg(0.0, 1.0, 3.15, 1.0),   # length 3.15 -&gt; 3.0
    seg(0.0, 2.0, 0.9, 2.0),    # length 0.9 -&gt; 1.0
    seg(0.0, 3.0, 2.2, 3.0),    # length 2.2 -&gt; 2.0
]

result = metric_regularize_segments(
    segments,
    length_quantization=True,
    base_unit=1.0,              # Snap to 1-meter multiples
    quantization_tolerance=0.3, # Within 30% of base unit
)"><pre><span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>1.85</span>, <span>0.0</span>),   <span># length 1.85 -&gt; 2.0</span>
    <span>seg</span>(<span>0.0</span>, <span>1.0</span>, <span>3.15</span>, <span>1.0</span>),   <span># length 3.15 -&gt; 3.0</span>
    <span>seg</span>(<span>0.0</span>, <span>2.0</span>, <span>0.9</span>, <span>2.0</span>),    <span># length 0.9 -&gt; 1.0</span>
    <span>seg</span>(<span>0.0</span>, <span>3.0</span>, <span>2.2</span>, <span>3.0</span>),    <span># length 2.2 -&gt; 2.0</span>
]

<span>result</span> <span>=</span> <span>metric_regularize_segments</span>(
    <span>segments</span>,
    <span>length_quantization</span><span>=</span><span>True</span>,
    <span>base_unit</span><span>=</span><span>1.0</span>,              <span># Snap to 1-meter multiples</span>
    <span>quantization_tolerance</span><span>=</span><span>0.3</span>, <span># Within 30% of base unit</span>
)</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/metric_quantization.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/metric_quantization.png" alt="Length Quantization"/></a></p>

<p dir="auto">Forces equal gaps between parallel lines. Perfect for regularizing staircases, window arrays, or any repeated elements:</p>
<div dir="auto" data-snippet-clipboard-copy-content="segments = [
    seg(0.0, 0.0, 3.0, 0.0),    # y=0.0
    seg(0.0, 0.9, 3.0, 0.9),    # y=0.9 (uneven)
    seg(0.0, 2.0, 3.0, 2.0),    # y=2.0
    seg(0.0, 3.1, 3.0, 3.1),    # y=3.1 (uneven)
    seg(0.0, 4.0, 3.0, 4.0),    # y=4.0
]

result = metric_regularize_segments(
    segments,
    equal_spacing=True,
    angle_tolerance=5.0,  # Lines within 5° are considered parallel
)
# Result: Lines are now evenly spaced at y=0, 1, 2, 3, 4"><pre><span>segments</span> <span>=</span> [
    <span>seg</span>(<span>0.0</span>, <span>0.0</span>, <span>3.0</span>, <span>0.0</span>),    <span># y=0.0</span>
    <span>seg</span>(<span>0.0</span>, <span>0.9</span>, <span>3.0</span>, <span>0.9</span>),    <span># y=0.9 (uneven)</span>
    <span>seg</span>(<span>0.0</span>, <span>2.0</span>, <span>3.0</span>, <span>2.0</span>),    <span># y=2.0</span>
    <span>seg</span>(<span>0.0</span>, <span>3.1</span>, <span>3.0</span>, <span>3.1</span>),    <span># y=3.1 (uneven)</span>
    <span>seg</span>(<span>0.0</span>, <span>4.0</span>, <span>3.0</span>, <span>4.0</span>),    <span># y=4.0</span>
]

<span>result</span> <span>=</span> <span>metric_regularize_segments</span>(
    <span>segments</span>,
    <span>equal_spacing</span><span>=</span><span>True</span>,
    <span>angle_tolerance</span><span>=</span><span>5.0</span>,  <span># Lines within 5° are considered parallel</span>
)
<span># Result: Lines are now evenly spaced at y=0, 1, 2, 3, 4</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/nickponline/shreg/blob/main/docs/images/metric_equal_spacing.png"><img src="https://github.com/nickponline/shreg/raw/main/docs/images/metric_equal_spacing.png" alt="Equal Spacing"/></a></p>

<p dir="auto">See <a href="https://github.com/nickponline/shreg/blob/main/API.md">API.md</a> for the complete API documentation.</p>

<p dir="auto">Run the demo examples:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Run all examples with visualization
shreg

# Run without visualization (batch mode)
shreg --no-plot

# Run only segment examples
shreg --segments

# Run only contour examples
shreg --contours"><pre><span><span>#</span> Run all examples with visualization</span>
shreg

<span><span>#</span> Run without visualization (batch mode)</span>
shreg --no-plot

<span><span>#</span> Run only segment examples</span>
shreg --segments

<span><span>#</span> Run only contour examples</span>
shreg --contours</pre></div>
<p dir="auto">Or using Python module syntax:</p>


<div dir="auto"><h3 tabindex="-1" dir="auto">Energy Minimization via Quadratic Programming</h3><a id="user-content-energy-minimization-via-quadratic-programming" aria-label="Permalink: Energy Minimization via Quadratic Programming" href="#energy-minimization-via-quadratic-programming"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The regularization problem is formulated as an <strong>energy minimization</strong> problem. Given a set of segments, we seek small adjustments (rotations and translations) that minimize an energy function while respecting constraints on maximum deviations.</p>
<p dir="auto">The energy function balances two objectives:</p>
<ul dir="auto">
<li><strong>Fidelity</strong>: Keep segments close to their original positions</li>
<li><strong>Regularity</strong>: Encourage nearby segments to share common angles and offsets</li>
</ul>
<p dir="auto">This leads to a <strong>quadratic program (QP)</strong> of the form:</p>
<div data-snippet-clipboard-copy-content="minimize    (1/2) x&#39;Px + q&#39;x
subject to  l &lt;= Ax &lt;= u"><pre><code>minimize    (1/2) x&#39;Px + q&#39;x
subject to  l &lt;= Ax &lt;= u
</code></pre></div>
<p dir="auto">where <code>x</code> contains the rotation and translation corrections for each segment, <code>P</code> encodes the fidelity cost, and the constraints enforce that angle/offset differences between nearby segments are minimized.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Segment Regularization Pipeline</h3><a id="user-content-segment-regularization-pipeline" aria-label="Permalink: Segment Regularization Pipeline" href="#segment-regularization-pipeline"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li><strong>Neighbor Detection</strong>: Use Delaunay triangulation on segment midpoints to identify nearby segment pairs efficiently</li>
<li><strong>Constraint Graph</strong>: Build constraints for angle and offset differences between neighboring segments within tolerance bounds</li>
<li><strong>QP Optimization</strong>: Solve the quadratic program using OSQP to find optimal corrections</li>
<li><strong>Application</strong>: Apply computed rotations and translations to each segment</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">Snap (Connectivity) Regularization</h3><a id="user-content-snap-connectivity-regularization" aria-label="Permalink: Snap (Connectivity) Regularization" href="#snap-connectivity-regularization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Snap regularization is formulated as a <strong>Constrained Quadratic Programming</strong> problem that minimizes endpoint movement while enforcing connectivity constraints.</p>
<p dir="auto"><strong>Variables:</strong> For N segments, the state vector contains all 4N endpoint coordinates:</p>
<div data-snippet-clipboard-copy-content="x = [x₁₁, y₁₁, x₁₂, y₁₂, ..., xₙ₂, yₙ₂]ᵀ"><pre><code>x = [x₁₁, y₁₁, x₁₂, y₁₂, ..., xₙ₂, yₙ₂]ᵀ
</code></pre></div>
<p dir="auto"><strong>Objective (Fidelity):</strong> Minimize squared distance from original positions:</p>
<div data-snippet-clipboard-copy-content="minimize (1/2) Σᵢ (||uᵢ - ûᵢ||² + ||vᵢ - v̂ᵢ||²)"><pre><code>minimize (1/2) Σᵢ (||uᵢ - ûᵢ||² + ||vᵢ - v̂ᵢ||²)
</code></pre></div>
<p dir="auto"><strong>Methods:</strong></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Method</th>
<th>Formulation</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cluster</code></td>
<td>Replace clustered endpoints with centroid</td>
<td>Fast, guaranteed watertight</td>
</tr>
<tr>
<td><code>hard</code></td>
<td>Equality constraints: vᵢ - uⱼ = 0</td>
<td>Exact connections required</td>
</tr>
<tr>
<td><code>soft</code></td>
<td>Penalty term: λ·Σ</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>Pipeline:</strong></p>
<ol dir="auto">
<li><strong>Endpoint Detection</strong>: Build KD-Tree on all 2N endpoints</li>
<li><strong>Clustering</strong>: Use Union-Find to group endpoints within ε distance</li>
<li><strong>Variable Reduction</strong> (cluster): Replace clusters with single variables</li>
<li><strong>QP Solve</strong> (hard/soft): Optimize using OSQP</li>
<li><strong>T-Junction Handling</strong>: Project endpoints onto target segments</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">Metric &amp; Pattern Regularization</h3><a id="user-content-metric--pattern-regularization-1" aria-label="Permalink: Metric &amp; Pattern Regularization" href="#metric--pattern-regularization-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Metric regularization constrains segment dimensions (length, distance). The challenge is that length calculation <code>√(Δx² + Δy²)</code> is <strong>non-linear</strong>, but QP solvers require linear constraints.</p>
<p dir="auto"><strong>Linearization:</strong> We approximate length using the segment&#39;s unit direction vector <strong>d</strong> = (dₓ, dᵧ):</p>
<div data-snippet-clipboard-copy-content="L ≈ dₓ(xₑ - xₛ) + dᵧ(yₑ - yₛ)"><pre><code>L ≈ dₓ(xₑ - xₛ) + dᵧ(yₑ - yₛ)
</code></pre></div>
<p dir="auto">This is linear in the endpoint coordinates and can be directly inserted into the constraint matrix.</p>
<p dir="auto"><strong>Constraint Formulations:</strong></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Constraint</th>
<th>Mathematical Form</th>
<th>Application</th>
</tr>
</thead>
<tbody>
<tr>
<td>Equal Length</td>
<td>L_A - L_B = 0</td>
<td>Windows, columns</td>
</tr>
<tr>
<td>Quantization</td>
<td>L = K (target)</td>
<td>Grid snapping</td>
</tr>
<tr>
<td>Equal Spacing</td>
<td>2·Pos(L₂) - Pos(L₁) - Pos(L₃) = 0</td>
<td>Stairs, arrays</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>Iterative Refinement (SQP):</strong> Because the unit vectors are computed from the <em>current</em> geometry, results are approximate if segments rotate significantly. The algorithm uses Sequential Quadratic Programming:</p>
<ol dir="auto">
<li>Compute unit vectors from current segment orientations</li>
<li>Build and solve the QP</li>
<li>Update segment coordinates</li>
<li>Repeat until convergence (or max iterations)</li>
</ol>
<p dir="auto"><strong>Pipeline:</strong></p>
<ol dir="auto">
<li><strong>Detection</strong>: Find candidate pairs/groups (similar lengths, parallel lines)</li>
<li><strong>Linearization</strong>: Compute unit direction vectors for length approximation</li>
<li><strong>Constraint Building</strong>: Build sparse constraint matrix A for detected patterns</li>
<li><strong>QP Solve</strong>: Minimize ||x - x̂||² subject to Ax = b using OSQP</li>
<li><strong>Iteration</strong>: Refine unit vectors and re-solve if needed</li>
</ol>

<p dir="auto">The contour regularization algorithm follows CGAL&#39;s approach for closed polygons:</p>
<ol dir="auto">
<li><strong>Angle Alignment</strong>: Rotate each edge to align with principal directions (modulo 90 degrees)</li>
<li><strong>Parallel Merging</strong>: Merge consecutive parallel edges that are close together</li>
<li><strong>Link Insertion</strong>: Insert connecting segments between remaining parallel edges</li>
<li><strong>Intersection</strong>: Compute intersection points to form the final regularized polygon</li>
</ol>

<ul dir="auto">
<li><code>numpy &gt;= 1.20.0</code></li>
<li><code>scipy &gt;= 1.7.0</code></li>
<li><code>osqp &gt;= 0.6.0</code></li>
<li><code>matplotlib &gt;= 3.5.0</code></li>
</ul>

<p dir="auto">Install development dependencies:</p>

<p dir="auto">Run tests:</p>

<p dir="auto">Run tests with coverage:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pytest tests/ -v --cov=shreg --cov-report=term-missing"><pre>pytest tests/ -v --cov=shreg --cov-report=term-missing</pre></div>

<ul dir="auto">
<li>Jean-Philippe Bauchet and Florent Lafarge. <strong>KIPPI: KInetic Polygonal Partitioning of Images</strong>. In <em>IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</em>, pages 3146–3154, Salt Lake City, United States, June 2018. [<a href="https://inria.hal.science/hal-01740958/document/" rel="nofollow">PDF</a>]</li>
<li><a href="https://doc.cgal.org/latest/Shape_regularization/" rel="nofollow">CGAL Shape Regularization Documentation</a></li>
<li><a href="https://osqp.org/" rel="nofollow">OSQP: Operator Splitting Quadratic Program Solver</a></li>
</ul>
</article></div></div>
  </body>
</html>
