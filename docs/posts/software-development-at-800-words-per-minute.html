<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neurrone.com/posts/software-development-at-800-wpm/">Original</a>
    <h1>Software Development at 800 Words per Minute</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content"><article><p><time datetime="2025-07-23T16:19:27.000Z">Jul 24, 2025, 12:19 AM </time>(updated <time datetime="2025-07-28T14:18:51.000Z">Jul 28, 2025, 10:18 PM </time>)</p><p>Imagine reading code not by looking at the screen, but by listening to interface elements, variables, language constructs and operators read at 800 words per minute (WPM) - over 5 times faster than normal speech. It sounds like gibberish to most, but to me, it’s as natural as you reading this sentence.</p><p>If you’ve ever wondered how someone codes without seeing the screen, or if you’re curious about accessibility in the software development process, this post is for you.</p><h2 id="table-of-contents">Table of Contents</h2><ul><li><a href="#what-is-a-screen-reader">What Is a Screen Reader?</a></li><li><a href="#do-you-really-understand-what-its-saying">Do You Really Understand What It’s Saying?</a></li><li><a href="#how-do-screen-readers-work">How Do Screen Readers Work?</a></li><li><a href="#what-applications-are-compatible-with-screen-readers">What Applications Are Compatible with Screen Readers?</a></li><li><a href="#why-develop-on-windows">Why Develop on Windows?</a></li><li><a href="#what-ide-do-you-use">What IDE Do You Use?</a></li><li><a href="#what-other-tools-do-you-use">What Other Tools Do You Use?</a></li><li><a href="#infrastructure-as-code">Infrastructure as Code</a></li><li><a href="#the-fragility-of-the-gui">The Fragility of the GUI</a></li><li><a href="#do-you-work-on-frontend-code">Do You Work on Frontend Code?</a></li><li><a href="#how-do-you-read-images">How Do You Read Images?</a></li><li><a href="#how-do-you-draw-diagrams">How Do You Draw Diagrams?</a></li><li><a href="#how-do-you-read-screen-shares">How Do You Read Screen Shares?</a></li><li><a href="#do-you-do-pair-programming">Do You Do Pair Programming?</a></li><li><a href="#the-single-channel-challenge">The Single-Channel Challenge</a></li><li><a href="#learning-at-800-wpm">Learning at 800 WPM</a></li><li><a href="#conclusion">Conclusion</a></li></ul><h2 id="what-is-a-screen-reader">What Is a Screen Reader?</h2><p>A screen reader is software that converts content on a screen into synthesized speech or braille output. Being visually impaired, using a screen reader is a necessity for me to be productive on a computer, as it reads out what you would normally see on a display.</p><p>Screen readers are built into most operating systems: Narrator on Windows, VoiceOver on Apple platforms, and Talkback on Android.</p><p>I use <a href="https://www.nvaccess.org/">NVDA (NonVisual Desktop Access)</a>, a free and open-source screen reader on Windows. Here is a video demonstrating use of NVDA with Visual Studio to write a simple application. I don’t know the speech rate of the screen reader in that video, so I’ll estimate it at somewhere between 300 to 400 WPM.</p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube-nocookie.com/embed/94swlF55tVc?si=jA7j-JwIdXkP8fMX" title="YouTube video player" width="560"></iframe><p>The above video demonstrates some of the things that screen readers verbalize:</p><ul><li>The current keyboard focus. For example, the current line of text when pressing the up / down arrow keys in a text file, or the current character when pressing left / right arrow. When moving about the interface of an application, the current control is announced</li><li>Key presses</li><li>Events like on-screen notifications, new text being written to a terminal, autocomplete suggestions becoming available or alerts in an ARIA live region</li></ul><p>I use the computer entirely via keyboard. Besides standard keyboard commands in the operating system or the current application, the screen reader also provides hundreds of additional keyboard commands for navigation and requesting specific information. With NVDA, pressing “h” jumps to the next heading on a web page, caps lock + f12 reads the current time, and caps lock + t reads the title of the currently focused window.</p><p>Think of a screen reader like a flashlight illuminating a small part of a dark room. It moves through content linearly—word by word, line by line, or element by element. If you copy the contents of a web page and paste it into a text editor, you’ll get a rough idea of how web pages are read out by a screen reader. There are keyboard shortcuts to rapidly move to different types of content (e.g. headings, links, form fields), but it doesn’t provide an instant “big picture” view of the screen. This is like reading a book rather than scanning a newspaper.</p><p>This constraint has shaped how I approach code. Since jumping around a file is slower than having the full context visible at a glance, I focus on understanding systems at a higher level first - mapping out the functions involved and how components interact, then drilling down into specifics. This mental caching reduces the need to move rapidly between different parts of a file or looking at multiple files simultaneously.</p><h2 id="do-you-really-understand-what-its-saying">Do You Really Understand What It’s Saying?</h2><figure><figcaption>This is what my screen reader sounds like when reading this section:</figcaption><audio controls="" preload="metadata"><source src="/audio/screen reader 800 WPM demo.flac" type="audio/flac"/><source src="/audio/screen reader 800 WPM demo.mp3" type="audio/mpeg"/><a href="https://neurrone.com/audio/screen%20reader%20800%20WPM%20demo.flac" download="screen reader 800 WPM demo.flac">Download FLAC audio</a></audio></figure><p>The typical reaction when listening to this is shock. To most ears, synthetic speech at 800 WPM sounds like a meaningless stream of robot chatter.</p><p>Since the rate that I absorb information is limited by how fast the screen reader is speaking, developing the ability to understand it at higher speech rates is critical. Using a computer at normal human speech rates of 150 WPM is glacially slow.</p><p>Unlike human speech, a screen reader’s synthetic voice reads a word in the same way every time. This makes it possible to get used to how it speaks. At first, it requires conscious effort to understand. With years of practice, comprehension becomes automatic. This is just like learning a new language.</p><p>I adjust its speed based on cognitive load. For routine tasks like reading emails, documentation, or familiar code patterns, 800 WPM works perfectly and allows me to process information far faster than one can usually read. I’m not working to understand what the screen reader is saying, so I can focus entirely on processing the meaning of the content. However, I slow down a little when debugging complex logic or working through denser material. At that point, the limiting factor isn’t how fast I can hear the words but how quickly I can understand their meaning.</p><h2 id="how-do-screen-readers-work">How Do Screen Readers Work?</h2><p>This is where things get technical, and why the choice of GUI framework matters.</p><p>Screen readers don’t visually interpret the screen. Instead, they get information from the accessibility tree, a structure that contains information about UI elements.</p><p>Here is how a submit button <code>&lt;button&gt;Submit&lt;/button&gt;</code> on a web page gets read:</p><ol><li>The browser constructs the Document Object Model (DOM) for the web page and renders the element visually as a button with a label of submit.</li><li>The browser exposes information about this button in the accessibility tree. It is represented by a node with a button role and a “Submit” label.</li><li>Screen readers use APIs provided by the operating system to query the accessibility tree. With this information, it reads the element’s label (“submit”) and role (button).</li></ol><p>When something interesting happens (such as a change in focus), the appropriate accessibility event gets emitted. Screen readers listen for these events to verbalize changes.</p><p>Screen readers work in a similar way for other types of applications.</p><h2 id="what-applications-are-compatible-with-screen-readers">What Applications Are Compatible with Screen Readers?</h2><p>An application’s compatibility with screen readers (and other programmatic means of accessing the UI) depends on how well it exposes information about its UI in the accessibility tree.</p><ul><li>If no information is exposed in the accessibility tree, it is unusable with a screen reader. For example, most games draw directly to the screen without exposing any accessibility information.</li><li>Some GUI frameworks like Flutter or QT have partial support for screen readers, but bugs with how they expose certain elements in the accessibility tree means applications written in these frameworks can be difficult to use.</li><li>Applications that use native controls provided by the operating system usually work well, since the native controls already do the heavy lifting of exposing their state in the accessibility tree.</li><li>For websites, web applications or applications using Electron, it depends on how well web accessibility best practices are implemented. For example, implementing that submit button by using a styled div with an onclick handler means the element is only exposed as a node with the text “Submit” without any indication that it is a button.</li></ul><p>Besides exposing state in the accessibility tree, the application should also not require the use of a mouse, since most screen reader users use the keyboard exclusively. It should be possible to navigate to every part of the application via the keyboard.</p><h2 id="why-develop-on-windows">Why Develop on Windows?</h2><p>Every developer asks me this question, usually with barely concealed horror. The answer is pragmatic: Windows is still the best operating system for screen reader users.</p><p>Though using a Mac is possible, I wouldn’t be comfortable with doing so professionally. The built-in <a href="https://www.applevis.com/blog/we-deserve-better-apple-why-i-can-no-longer-recommend-mac-fellow-blind-computer-users">VoiceOver screen reader on macOS has been neglected with severe bugs left unfixed for years</a>. Voiceover’s interaction model makes using certain types of applications like web browsers less efficient as more keystrokes are required for navigation. The <a href="https://www.applevis.com/comment/188371#comment-188371">accessibility APIs Apple provides are also insufficient for a third-party alternative to be developed</a>.</p><p>Although the Orca screen reader is available on Linux, there are numerous problems with Linux accessibility. Even something as basic as <a href="https://fireborn.mataroa.blog/blog/i-want-to-love-linux-it-doesnt-love-me-back-post-1-built-for-control-but-not-for-people/">getting audio output to work reliably is a challenge</a>. I would love to be on Linux, but this isn’t practical for me right now.</p><p>Windows might not be trendy among developers, but it’s where accessibility works best. I don’t have to worry about whether I can get audio working reliably. The NVDA screen reader works on Windows and is free and open source, actively maintained, and designed by people who are screen reader users themselves.</p><p>That said, I’m not actually developing on Windows in the traditional sense. WSL2 gives me a full Linux environment where I can run Docker containers, use familiar command-line tools, and run the same scripts and tools that my colleagues use. Windows is just the accessibility layer on top of my real development environment.</p><h2 id="what-ide-do-you-use">What IDE Do You Use?</h2><p>I use VS Code. Microsoft has made accessibility a core engineering priority, treating accessibility bugs with the same urgency as bugs affecting visual rendering. The VS Code team regularly engages with screen reader users, and it shows in the experience.</p><p>Here’s what makes VS Code work for me:</p><ul><li>Consistent keyboard shortcuts across all features, and the ability to jump to any part of the interface by keyboard</li><li>Excellent screen reader announcements for IntelliSense and error messages</li><li>Use of audio cues to indicate errors or warnings on the current line</li><li>Continued commitment to ensuring accessibility of new features and fixing accessibility regressions.</li></ul><p>Beyond the IDE, development involves many other tools: documentation sites, bug trackers, team communication platforms and code review systems. Ideally, these tools are accessible and work well with screen readers.</p><p>Usually, accessibility isn’t perfect and there are specific screens or features that don’t work well with a screen reader. If I’m really unlucky, the tool may be completely unusable. In these situations, I use the following strategies:</p><ol><li><em>Finding Alternatives</em>: unless I’m working with a team-wide tool like GitLab, I’m often able to find alternatives that work better for me. For example, <a href="https://github.com/postmanlabs/postman-app-support/issues/3121">Postman is popular for API testing but is unusable with a screen reader</a>. I use a combination of Curl and the <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">Vs Code REST Client extension</a> instead.</li><li><em>Custom Userscripts</em>: for web applications, I use <a href="https://www.greasespot.net/">Greasemonkey</a> to inject accessibility fixes into websites. For example, I had to write a <a href="https://github.com/Neurrone/greasemonkey-scripts/blob/master/gitlab%20a11y%20fixes.user.js">userscript that adds table semantics to GitLab’s diff viewer</a>. Without proper table semantics, code reviews were time-consuming since I couldn’t easily navigate to the next or previous line when reviewing code. This can be a tedious process as it requires reverse engineering the application to find the minimal changes to make to its DOM to achieve the desired effect.</li><li><em>API Integration</em>: if the interface for an application is inaccessible and an API is available, I’ll write command-line tools or simple scripts to do what I need to. Large Language Models (LLMs) are helpful in these situations.</li><li><em>Reporting Bugs</em>: I report issues when I find them, but there’s a reason why this is last on the list. Accessibility bugs rarely get prioritized unless there is a strong accessibility mandate. For example, I <a href="https://gitlab.com/gitlab-org/gitlab/-/issues/27520">reported the issue with tables on GitLab in 2019</a> and the linked Postman issue above has been open since 2017. Hence, I need to take matters into my own hands and work around such issues myself whenever I can.</li></ol><h2 id="infrastructure-as-code">Infrastructure as Code</h2><p>The shift toward Infrastructure as Code (IaC) is a huge accessibility win. Instead of clicking through many AWS console screens to set up a server, I can define it in a few lines of code:</p><pre data-language="hcl" tabindex="0"><code><span><span>resource</span><span> &#34;aws_instance&#34;</span><span> &#34;web_server&#34;</span><span> {</span></span>
<span><span>  ami</span><span>           =</span><span> &#34;ami-0c55b159cbfafe1d0&#34;</span></span>
<span><span>  instance_type</span><span> =</span><span> &#34;t2.micro&#34;</span></span>
<span></span>
<span><span>  tags</span><span> =</span><span> {</span></span>
<span><span>    Name </span><span>=</span><span> &#34;WebServer&#34;</span></span>
<span><span>    Environment </span><span>=</span><span> &#34;Production&#34;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre><p>Text files are infinitely more accessible than graphical interfaces. I can read every configuration option, use standard development tools for editing and version control, and deploy infrastructure changes from the command line.</p><h2 id="the-fragility-of-the-gui">The Fragility of the GUI</h2><p>Over the years, I’ve started seeing dependence on GUI-based tools as potential liabilities, since changes or regressions can make them less efficient for me to use, or remove my ability to use them entirely in the worst case. I’m always anxious whenever there is a UI rewrite for an application that I use, since that often regresses accessibility. For example, when Microsoft rewrote some Windows 11 screens to use a new list control, they lost support for first-letter navigation, which moves focus to the next item in a list starting with a letter by typing that letter.</p><p>Moving from clicking through screens to IaC is a great example of how I limit my exposure to the GUI.</p><p>However, I can’t avoid using the GUI entirely. I manage my risk by working with development ecosystems that don’t require use of a specific GUI-based tool. I’ve worked in Go, Python, Rust and TypeScript. For those languages, I can always fall back to the command line if necessary. For this reason, I avoid mobile development, since they require use of specific IDEs <sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="" id="user-content-fnref-1">1</a></sup>.</p><h2 id="do-you-work-on-frontend-code">Do You Work on Frontend Code?</h2><p>Creating prototypes or updating screens to match a design specification is inherently visual. Frontend will never be my strong suit, though LLMs can bridge this gap somewhat.</p><p>Though I prefer to work on backend code, I’ve been able to contribute meaningfully on the frontend as well, since there is a lot of non-visual work involved. For example, refactoring how state is tracked, communication with the backend via APIs and implementing new features with existing design components.</p><h2 id="how-do-you-read-images">How Do You Read Images?</h2><p>Though I can use magnification to look at the screen, it is still a last resort since this is slow for me.</p><p>Screen readers can’t interpret images, since they’re just pixels without semantic meaning. This is why alt text is crucial. Unfortunately, it is rare to find meaningful alt text in the wild and most applications don’t support setting alt text on images.</p><p>For images without meaningful alt text, I use Optical Character Recognition (OCR) to extract text content. However, this only works well for clear screenshots of text.</p><p>LLMs have been a game-changer. They work much better than OCR for more complex images like application screenshots, code or tables. LLMs can describe UI layouts, read text from complex images, and explain diagrams or charts. I can also prompt for the specific information I need. For example, “What error is highlighted in red in this screenshot?” or “Transcribe the code in this screenshot exactly without any other commentary”.</p><p>I have to be careful about hallucinations and avoid uploading sensitive information. Even with these limitations, AI-powered image descriptions are incredibly helpful.</p><h2 id="how-do-you-draw-diagrams">How Do You Draw Diagrams?</h2><p>Sometimes, I need to create diagrams for documentation, system design interviews or to explain complex ideas.</p><p>I use markup languages like <a href="https://mermaid.js.org/">Mermaid</a> for describing diagrams. Writing diagrams as code means I can version control them, generate them programmatically, and most importantly, read the source to understand them.</p><pre data-language="mermaid" tabindex="0"><code><span><span>graph TD</span></span>
<span><span>    A[Customer places order] --&gt; B[Check if item is available]</span></span>
<span><span>    B --&gt; C[Process payment]</span></span>
<span><span>    C --&gt; D[Send confirmation email]</span></span>
<span><span>    C --&gt; E[Package item for shipping]</span></span>
<span><span>    E --&gt; F[Ship to customer]</span></span></code></pre><figure><img alt="Refer to the Mermaid source above" src="https://neurrone.com/images/mermaid%20example.png"/><figcaption>Rendered diagram for the above Mermaid source</figcaption></figure><p>If I need to understand a programmatically generated diagram, I read its source when possible. That is usually faster than parsing it visually.</p><p>This approach has an unexpected benefit: diagrams as code encourages thinking about the logical structure rather than visual aesthetics. The result is often clearer and more maintainable.</p><p>I’ve found that LLMs work well for generating Mermaid diagrams from natural language descriptions.</p><p>Like images, a screen share is just a stream of pixels with no semantic meaning. Hence, there is nothing for a screen reader to verbalize.</p><p>I work around the issue by following along on my computer where possible. For example:</p><ul><li>Getting the materials for a presentation and having it open to the speaker’s current slide</li><li>If screen sharing a web page like internal documentation or story tickets, I have the same page open on my computer</li><li>If someone is walking through code, verbalizing the file name and current line when navigating to a new file or section of code allows me to follow along on my machine</li></ul><h2 id="do-you-do-pair-programming">Do You Do Pair Programming?</h2><p>I usually prefer not to. When I do, I use VS Code’s Live Share feature or share my screen for the other person to drive.</p><p>Pair programming is mentally exhausting for me in ways that solo development isn’t. There’s significant cognitive overhead when I’m having a conversation, maintaining shared context about where we are in the codebase and listening to my screen reader simultaneously since all this is done by ear.</p><p>Other forms of collaboration like code reviews, design discussions and debugging sessions work well for me. It’s the real-time, same-screen aspect of traditional pair programming that creates friction.</p><h2 id="the-single-channel-challenge">The Single-Channel Challenge</h2><p>Just like you can’t easily follow two people speaking at once, I can’t listen to my screen reader and someone else speaking simultaneously - they’re both competing for the same audio channel.</p><p>In these situations, I use my computer during natural pauses in the conversation or presentation. I might look back at something relevant to what was just said or navigate ahead to the section being discussed next.</p><p>If the speaker resumes talking while I’m still using my computer, I have to context switch between both audio streams. I can process both simultaneously, but only for short periods due to the intense focus required. There’s always a mental cost to switching back and forth - I might lose my place or miss something important. This was difficult at first, but like any skill, it gets easier with practice.</p><p>When the speaker relies on visual references like “this error here” or rapidly switches between screens without verbal cues, it is much harder for me to stay in sync. In these situations, I’ll ask for brief descriptions - “in the UserService class” - so I can follow along on my machine. It’s a small adjustment that makes a huge difference for me.</p><p>When materials for the discussion or presentation are available in advance, the process becomes much smoother. Being familiar with the content beforehand reduces the cognitive load significantly since I can read ahead of time. This also leads to more productive discussions, as I can come prepared with questions.</p><h2 id="learning-at-800-wpm">Learning at 800 WPM</h2><p>My learning strategies take advantage of being able to read large amounts of text quickly. However, what I said earlier about slowing down when the cognitive load is higher still applies, so my ability to understand the content becomes the bottleneck.</p><p>I learn primarily through text-based resources. I use e-books for depth and online documentation or text-based tutorials otherwise. LLMs are also very helpful for content personalized to my learning needs. Images without meaningful alt text can be an issue though.</p><p>For video content like conference talks, I read transcripts when available. Otherwise, I increase the playback speed to 2x. It is much harder to understand human speech at higher playback rates, since it is not uniform like synthetic speech.</p><h2 id="conclusion">Conclusion</h2><p>Most development content online about screen readers focus on how to make applications accessible. There’s much less written about screen reader users as participants in the development process itself. I get asked the same questions repeatedly: “How do you actually write code?” “What tools can you use?” “Do you do pair programming?” I wrote this post to answer these questions. If you’ve ever been curious about how development works from this perspective, I hope you’ve found this useful.</p><p>I also wanted to talk about the importance of accessibility in developer tooling and software in general. Every day, I experience the direct consequences of decisions made by other developers. When someone chooses semantic HTML over div soup or implements support for proper keyboard navigation, it determines how easily I can do my job. These aren’t abstract accessibility guidelines - they’re the difference between productive collaboration, wasting time on workarounds or being unable to use an application entirely.</p><p>Despite the challenges I’ve outlined, I want to end on a positive note. Software development has been incredibly fulfilling for me. Everyone has their own obstacles to navigate. Mine happen to involve using a screen reader and overcoming accessibility barriers.</p><p>The field isn’t perfect, but compared to many other careers, software development is remarkably adaptable to different ways of working. As long as you can think through problems and translate ideas into code, there’s a place for you here.</p><p><a href="https://news.ycombinator.com/item?id=44672149">Discuss this post on Hacker News</a>.</p></article></div></div>
  </body>
</html>
