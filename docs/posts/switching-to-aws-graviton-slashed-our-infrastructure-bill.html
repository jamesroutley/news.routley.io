<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://squeaky.ai/blog/development/how-switching-to-aws-graviton-slashed-our-infrastructure-bill-by-35-percent">Original</a>
    <h1>Switching to AWS Graviton slashed our infrastructure bill</h1>
    
    <div id="readability-page-1" class="page"><article><p>When we started our <a href="https://squeaky.ai" target="_blank">analytics company</a>, we knew that closely monitoring and managing our infrastructure spending was going to be really important. The numbers started out small, but we’re now capturing, processing, and consuming a lot of data.</p>

<p>On a recent search for new cost-saving opportunities, we came across a straightforward but substantial win, so I thought I’d share what we did and how we did it.</p>

<p>Before I get into exactly what we did, here’s a quick overview of the relevant infrastructure:</p>

<h2 id="infrastructure-overview">Infrastructure overview</h2>

<p>Squeaky runs entirely inside of AWS and we use as many hosted options as possible to make our infrastructure manageable for our small team. For this article, it’s worth noting:</p>

<ul>
  <li>All of our apps run in ECS on Fargate</li>
  <li>We use ElastiCache for Redis</li>
  <li>We use RDS for Postgres</li>
  <li>We use an EC2 instance for our self managed ClickHouse database</li>
</ul>

<p>These four things made up the majority of our infrastructure costs, with S3 and networking taking up the rest.</p>

<p>For the past year, Squeaky has been developed locally on M1 equipped MacBooks, with all runtimes and dependencies compatible with both <code>arm64</code> and <code>x86_64</code>. We&#39;ve never had any difficulties running the entire stack on ARM, so we decided to see if we could switch over to <a href="https://aws.amazon.com/ec2/graviton/" target="_blank" rel="noreferrer">AWS Graviton</a> to take advantage of their lower-cost ARM processors.</p>

<h2 id="updating-the-aws-managed-services">Updating the AWS managed services</h2>

<p>The first thing we decided to update was the managed services, including ElastiCache and RDS, as they were the least risky. The process was very straightforward: a single line Terraform change, followed by a short wait for both services to reach their maintenance window.</p>

<p>Whilst we made sure to take snapshots beforehand, both services changed their underlying instances with no data loss and very with little downtime.</p>

<h2 id="updating-our-applications">Updating our applications</h2>

<p>We have been using <a href="https://aws.amazon.com/fargate/" target="_blank" rel="noreferrer">Fargate</a> to run our Dockerised apps in production for around a year now, as it allows us to quickly scale up and down depending on load. We’ve had a good experience with ECS and it’s been easier to maintain than alternatives such as <a href="https://kubernetes.io/" target="_blank" rel="noreferrer">Kubernetes</a>.</p>

<p>We took the following steps to get our applications running on Graviton Fargate instances:</p>

<p>1. We wanted to change our CI/CD pipeline over to Graviton so that we could build for <code>arm64</code> in a native environment, meaning we would not need to mess around with cross-architecture builds. As we use <a href="https://aws.amazon.com/codebuild/" target="_blank" rel="noreferrer">AWS Codebuild</a>, it was a simple case of changing the instance type and image over.</p>

<pre><code><span>-</span> type  = LINUX_CONTAINER
<span>+</span> type  = ARM_CONTAINER
<span>-</span> image = aws/codebuild/amazonlinux2-x86_64-standard:4.0
<span>+</span> image = aws/codebuild/amazonlinux2-aarch64-standard:2.0</code></pre>

<p>These were an in-place change, and all our history and logs remained.</p>

<p>2. Next up we changed the Dockerfile for each app so that they used an <code>arm64</code> base image. We built the Docker images locally before continuing to check there were no issues.</p>

<pre><code><span>-</span> FROM node:18.12-alpine
<span>+</span> FROM arm64v8/node:18.12-alpine</code></pre>

<p>3. Thirdly, we disabled the auto deploy in our pipeline, and pushed up our changes so that we could build our new <code>arm64</code> artefacts and push them to ECR.</p>

<p>4. Next, we made some changes in Terraform to tell our Fargate apps to use <code>arm64</code> instead of <code>x86_64</code>. This was a simple case of telling Fargate which architecture to use within the Task Definition.</p>

<pre><code><span>+</span> runtime_platform {
<span>+</span>    cpu_architecture = &#34;ARM64&#34;
<span>+</span> }</code></pre>

<p>We applied the change app-by-app and let them gradually blue/green deploy the new Graviton containers. For around 3 minutes, traffic was served by both <code>arm64</code> and <code>x86_64</code> apps while the old containers drained and the new ones deployed.</p>

<p>5. Lastly, we monitored the apps and waited for them to reach their steady states before reenabling the auto deployment.</p>

<p>For the most part, there were zero code changes required for our apps. We have several Node.js based containers that run Next.js applications, and these required zero changes. Likewise, our data ingest API is written in Go, which also didn’t need any changes.</p>

<p>However, we did have some initial difficulties with our Ruby on Rails API. The image built fine, but it would crash on startup as aws-sdk-core was unable to find an XML parser:</p>

<pre><code>Unable to find a compatible xml library. Ensure that you have installed or added to your Gemfile one of ox, oga, libxml, nokogiri or rexml (RuntimeError)</code></pre>

<p>After some investigation it turned out that by default, Alpine linux (the base image for our Docker apps) reports it&#39;s architecture as <code>aarm64-linux-musl</code>, whereas our Nokogiri gem ships an ARM binary for <code>aarm64-linux</code>, causing it to silently fail. This was verified by switching over to a Debian based image where the reported architecture is <code>aarm64-linux</code>, where the app would start without crashing.</p>

<p>The solution was to add <code>RUN apk add gcompat</code> to our Dockerfile. You can read more about this <a target="_blank" rel="noreferrer" href="https://github.com/rubygems/rubygems/pull/5852">here</a>. I suspect this will only affect a small number of people, but it&#39;s interesting nonetheless.

</p><h2 id="updating-our-clickhouse-database">Updating our ClickHouse database</h2>

<p>This was by far the most involved process, and the only part that required any real downtime for the app. All in all the process took about 30 minutes, during which time the Squeaky app was reporting 500 errors, and our API was periodically restarting due to healthcheck failures. To prevent data loss for our customers we continued to collect data and kept it in our write buffer until the update was complete.</p>

<p>The process involved a mixture of Terraform changes, as well as some manual changes inside of the console. The steps were as follows:</p>

<p>1. We spun down all the workers that save session data. This way we could continue to ingest data, and save it when things were operational again</p>

<p>2. Next up was to take a snapshot of the EBS volume in case anything went wrong during the update</p>

<p>3. We stopped the EC2 instance, and detached our EBS volume. This was done by commenting out the volume attachment in Terraform and applying</p>

<pre><code># resource &#34;aws_volume_attachment&#34; &#34;clickhouse-attachment&#34; {
#   device_name = &#34;/dev/sdf&#34;
#   volume_id   = &#34;${aws_ebs_volume.clickhouse.id}&#34;
#   instance_id = &#34;${aws_instance.clickhouse.id}&#34;
# }</code></pre>

<p>4. We then destroyed the old instance including the root volume. Any user data was configured by the <code>user_data</code> script and would be re-created with the new instance</p>

<p>5. After that, we updated the Terraform to switch the instance over to Graviton, we had to change two things - the AMI and the instance type. The volume attachment was left commented out so that the <code>user_data</code> script would not try to reformat the volume. The Terraform apply destroyed everything that was left and recreated the instance. The <code>user_data</code> script ran on start, and installed the latest version of ClickHouse, as well as the Cloudwatch Agent.</p>

<pre><code> filter {
   name   = &#34;architecture&#34;
<span>-</span>  values = [&#34;x86_64&#34;]
<span>+</span>  values = [&#34;arm64&#34;]
 }</code></pre>

<p>6. The volume was then reattached and mounted, and the ClickHouse process was restarted to pick up the configuration and data stored on the mounted volume</p>

<p>7. All of the alarms and health checks started to turn green, and service was resumed</p>

<p>8. The workers were spun back up and the last 30 minutes or so of session data was processed. The following graph shows the brief pause in processing, followed by a huge spike as it works through the queue</p>

<figure>
  <img src="https://cdn.squeaky.ai/blog/reducing-infrastructure-costs-1.jpg" alt="Image shows the abnormal processing behaviour due to the stopped workers" loading="lazy"/>
  <figcaption>Image shows the abnormal processing behaviour due to the stopped workers.</figcaption>
</figure>

<h2 id="conclusion">Conclusion</h2>

<p>We’re strong believers in continuously improving tools and process, and that’s really paid off this time. By having all our apps running the latest versions of languages, frameworks and dependencies, we’ve been able to switch over to brand new infrastructure with almost zero code changes.</p>

<p>Switching our entire operation over to Graviton only took one day and we’ve saved approximately 35% on our infrastructure costs. When comparing our CPU and memory usage, along with latency metrics, we’ve seen no performance degradation. In fact, our overall memory footprint has dropped slightly, and we expect to see further improvements as the month rolls on.</p>

<p>It’s fair to say we&#39;re all-in on ARM, and any future pieces of infrastructure will now be powered by Graviton.</p></article></div>
  </body>
</html>
