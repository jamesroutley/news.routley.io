<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brevzin.github.io/c&#43;&#43;/2024/09/30/annotations/">Original</a>
    <h1>Code Generation in Rust vs. C&#43;&#43;26</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of the things I like to do is compare how different languages solve the same problem — especially when they end up having very different approaches. It’s always educational. In this case, a bunch of us have been working hard on trying to get reflection — a really transformative language feature — into C++26. Fundamentally, reflection itself can be divided into two pieces:</p><ol><li>Introspection — the ability to ask questions about your program during compilation</li><li>Code Generation — the ability to have your code write new code</li></ol><p><a href="https://wg21.link/p2996">P2996</a> (Reflection for C++26) is the (huge) core proposal that fundamentally deals with the first problem, along with setting the foundation for being able to extend this feature in lots of different directions in the future, including generation (for which our design is <a href="https://wg21.link/p3294">P3294</a>). But introspection, while valuable, is only half of the piece. Andrei Alexandrescu went so far as to claim in his CppCon talk that introspection without generation is useless.</p><blockquote><p>Or at least he did in the early slides he sent me and I told him to tone it down a notch, so perhaps in the actual talk (whose video I have not seen yet), he just called it… Mostly Useless.</p></blockquote><p>Now, C++ does have one code generation facility today: C macros. It’s just a very poor and primitive one. Poor because of their complete lack of hygiene to the point where you could be accidentally invoking macros without knowing it (and standard library implementations guard against that), and primitive because even remarkably simple things conceptually (like iteration or conditions) require true wizardry to implement. That said, there are still plenty of problems today for which C macros are the best solution — which really says something about the need for proper code generation facilities.</p><p>On the other hand, if we look at Rust — Rust does not actually have any introspection facilities <em>at all</em>, but it does have a mature code generation facility in the form of its declarative and procedural macros. Today, this post is just going to look at procedural macros — specifically the derive macro. We’re going to look at two problems solved by using the derive macro, how those actually work, and how we are proposing to solve the same problems in a very different way for C++26.</p><blockquote><p>Now, I’m not a Rust programmer, so I apologize in advance for getting things wrong here. Please let me know if I make any egregious mistakes.</p></blockquote><h2 id="pretty-printing-a-struct"><span>Pretty-Printing a Struct</span><a href="#pretty-printing-a-struct"><i></i></a></h2><p>Once you learn how to declare a type with some new members, one of the first things you’re going to want to do is to make your type debug-printable. Not only because in general that’s a very useful operation, but also because it’s <em>extremely</em> easy to do:</p><pre><code>#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 1, y: 2 };
    // prints: p=Point { x: 1, y: 2 }
    println!(&#34;p={p:?}&#34;);
}
</code></pre><p>That first line of code makes <code>Point</code> debug-printable — which means it prints the type name and then all the member names and values, in order.</p><blockquote><p>In my copy of the Rust Programming Language book, you’re shown how to declare a <code>struct</code> on page 82 and how to make it debug-printable on page 89. It’s basically one of the first things you’re shown how to do.</p><p>Also for this specific task, Rust has <code>dbg!(p)</code>, but I’m using <code>println!</code> just to be closer to the eventual C++ solution.</p></blockquote><p>And since this is a programmatic annotation, if I go back later and add a new field to <code>Point</code> (let’s say I decide that I wanted this to be 3-dimensional and I need a <code>z</code>), the debug-printing will be automatically updated to print the new field.</p><p>All of which is to say: Pretty easy!</p><p>The question you might ask is — how, <em>specifically</em>, does this work? What is the interaction between the <code>derive</code> macro and the <code>Debug</code> trait that causes this to work?</p><p>As I mentioned earlier, unlike what we’re proposing for C++26, Rust doesn’t have any kind of <em>introspection</em>. There is no mechanism in the language to ask for the members of <code>Point</code> and iterate over them.</p><p>Instead, the <code>derive</code> macro does something very different: it is a function that takes a token stream of the struct that it annotates and its job is to return a token stream of code to inject after the input. That injected code doesn’t actually need to be remotely related to the input (the <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros">Rust docs</a> have an example which just completely ignores the input and instead injects a function which returns <code>42</code>).</p><p>In this case, we sidestep the lack of introspection by actually getting the token sequence input of <code>Point</code>, <em>parsing it</em>, and using that parsed result to produce the output we need. I suppose this is still a kind of introspect — just one that can only be explicitly opted into in narrow circumstances.</p><p>Specifically, the <code>derive</code> macro for this example will emit the following (which I got from <code>cargo expand</code>):</p><pre><code>#[automatically_derived]
impl ::core::fmt::Debug for Point {
    #[inline]
    fn fmt(&amp;self, f: &amp;mut ::core::fmt::Formatter) -&gt; ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            &#34;Point&#34;,
            &#34;x&#34;,
            &amp;self.x,
            &#34;y&#34;,
            &amp;&amp;self.y,
        )
    }
}
</code></pre><p>It’s not especially complicated code, but the point is that Rust programmers don’t have to deal with writing this boilerplate. They just have to learn how to write one line (or really, not even one full line) of code: <code>#[derive(Debug)]</code>. That’s the power of code generation.</p><p>Nevertheless, even here the result is quite informative. Why is it <code>&amp;self.x</code> but <code>&amp;&amp;self.y</code>, with the extra reference? Here, Rust’s inability to do introspection comes into place. In Rust, your last field can be an unsized type. An unsized type can be printed, <a href="https://github.com/rust-lang/rust/blob/74fd001cdae0321144a20133f2216ea8a97da476/compiler/rustc_builtin_macros/src/deriving/debug.rs#L101-L102">but needs an extra indirection</a>. The derive macro has no way of knowing whether <code>y</code> is sized or not (in this case it’s an <code>i32</code>, which is <code>Sized</code>), so in an effort to support both cases, it just preemptively adds the extra indirection.</p><p>In C++, with what we’re proposing, if I try to be as familiar to the Rust syntax as possible, I can make it work <a href="https://godbolt.org/z/bcYE7nY4s">like this</a>:</p><pre><code>struct [[=derive&lt;Debug&gt;]] Point {
    int x;
    int y;
};

int main() {
    auto p = Point{.x=1, .y=2};
    // prints p=Point{.x=1, .y=2}
    std::println(&#34;p={}&#34;, p);
}
</code></pre><p>Now, fundamentally, there are some similarities between how C++ and Rust do formatting (which I’ve <a href="https://brevzin.github.io/c++/2023/01/02/rust-cpp-format/">touched on before</a>). In Rust, you have to provide an <code>impl</code> for the <code>Debug</code> trait. In C++, you have to specialize <code>std::formatter</code> (we don’t differentiate between <code>Debug</code> and <code>Display</code>). As I showed earlier, the Rust <code>#[derive(Debug)]</code> macro invocation injects the correct <code>impl</code> of <code>Debug</code> for the type. But in C++, we’re… not actually doing that at all.</p><p>The specific language feature I’m making use of here is called an <em>annotation</em>. It will be proposed in <a href="https://wg21.link/p3394">P3394</a> (link will work when it’s published in October 2024) and was first revealed by Daveed Vandevoorde at his <a href="https://www.youtube.com/watch?v=wpjiowJW2ks">CppCon closing keynote</a>. The goal of the proposal is to let you annotate declarations in a way that introspection can observe. Notably, no injection is happening. We’re just extending introspection a bit.</p><p>However, given that C++ <em>does</em> have introspection (or will, with P2996), that’s sufficient to get the job done. We can, up front, provide a specialization of <code>std::formatter</code> that is enabled if the type is annotated with <code>derive&lt;Debug&gt;</code>, which it itself just an empty value:</p><pre><code>template &lt;auto V&gt; struct Derive { };
template &lt;auto V&gt; inline constexpr Derive&lt;V&gt; derive;

inline constexpr struct{} Debug;

template &lt;class T&gt; requires (has_annotation(^^T, derive&lt;Debug&gt;))
struct std::formatter&lt;T&gt; {
    // ...
};
</code></pre><p>And once we have that, the body of the specialization can introspect on <code>T</code> to get all the information that we need to display: we can iterate over all the non-static data members, formatting their name and value. A simplified implementation would be (the link above has a more complicated implementation):</p><pre><code>template &lt;class T&gt; requires (has_annotation(^^T, derive&lt;Debug&gt;))
struct std::formatter&lt;T&gt; {
    constexpr auto parse(auto&amp; ctx) { return ctx.begin(); }

    auto format(T const&amp; m, auto&amp; ctx) const {
        auto out = std::format_to(ctx.out(),
                                  &#34;{}&#34;, display_string_of(^^T));
        *out++ = &#39;{&#39;;

        bool first = true;
        [:expand(nonstatic_data_members_of(^^T)):] &gt;&gt; [&amp;]&lt;auto nsdm&gt;{
            if (not first) {
                *out++ = &#39;,&#39;;
                *out++ = &#39; &#39;;
            }
            first = false;

            out = std::format_to(out,
                                 &#34;.{}={}&#34;,
                                 identifier_of(nsdm), m.[:nsdm:]);
        };

        *out++ = &#39;}&#39;;
        return out;
    }
};
</code></pre><p>In a way, we’re still generating code — templates are essentially a form of code generation in C++. But it’s interesting that here we’re achieving the same end with a very different mechanism.</p><p>Note also that this is the <em>complete</em> implementation. It is not a lot of code.</p><h2 id="json-serialization"><span>JSON Serialization</span><a href="#json-serialization"><i></i></a></h2><p>Building on the debug-printing example, where we just wanted to print all the members in order. What if we wanted to do something slightly more involved? When dealing with serialization, it’s quite common to want the serialized format to not be <em>exactly</em> the same as the names of all of your members. Sometimes the desired names for your fields have to be different. Sometimes, the desired format is even impossible to replicate in the language — the field name you want to serialize into might happen to be a language keyword, or have a space in it, or so forth.</p><p>This is why the <a href="https://serde.rs/">serde</a> library provides a lot of attributes you can add to types and members to control the logic. Taking a simple example:</p><pre><code>use serde::Serialize;
use serde_json;

#[derive(Serialize)]
struct Person {
    #[serde(rename = &#34;first name&#34;)]
    first: String,

    #[serde(rename = &#34;last name&#34;)]
    last: String,
}

fn main() {
    let person = Person {
        first: &#34;Peter&#34;.to_owned(),
        last: &#34;Dimov&#34;.to_owned(),
    };
    let j = serde_json::to_string(&amp;person).unwrap();

    // prints {&#34;first name&#34;:&#34;Peter&#34;,&#34;last name&#34;:&#34;Dimov&#34;}
    println!(&#34;{}&#34;, j);
}
</code></pre><p>As with <code>Debug</code>, the derive macro for <code>Serialize</code> will inject an implementation for us, which, in this case, looks like this:</p><pre><code>#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Person {
        fn serialize&lt;__S&gt;(
            &amp;self,
            __serializer: __S,
        ) -&gt; _serde::__private::Result&lt;__S::Ok, __S::Error&gt;
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                &#34;Person&#34;,
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &amp;mut __serde_state,
                &#34;first name&#34;,
                &amp;self.first,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &amp;mut __serde_state,
                &#34;last name&#34;,
                &amp;self.last,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
</code></pre><p>Here you can see the desired field names (<code>&#34;first name&#34;</code> and <code>&#34;last name&#34;</code>) coupled with their actual members. The funny construct <code>false as usize + 1 + 1</code> is the number of fields to be serialized (which in this case is obviously <code>2</code>). This spelling in particular is a consequence of wanting to support a different attribute.</p><p>For example, if we added a middle name that we wanted to serialize only if it wasn’t empty, there’s an attribute for that:</p><pre><code>#[derive(Serialize)]
struct Person {
    #[serde(rename = &#34;first name&#34;)]
    first: String,

    #[serde(rename = &#34;middle name&#34;, skip_serializing_if = &#34;String::is_empty&#34;)]
    middle: String,

    #[serde(rename = &#34;last name&#34;)]
    last: String,
}
</code></pre><p>Which generates the following code (with the new additions highlighted):</p><pre data-line="18-19,26-37"><code>#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Person {
        fn serialize&lt;__S&gt;(
            &amp;self,
            __serializer: __S,
        ) -&gt; _serde::__private::Result&lt;__S::Ok, __S::Error&gt;
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                &#34;Person&#34;,
                false as usize + 1 + if String::is_empty(&amp;self.middle) { 0 } else { 1 }
                    + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &amp;mut __serde_state,
                &#34;first name&#34;,
                &amp;self.first,
            )?;
            if !String::is_empty(&amp;self.middle) {
                _serde::ser::SerializeStruct::serialize_field(
                    &amp;mut __serde_state,
                    &#34;middle name&#34;,
                    &amp;self.middle,
                )?;
            } else {
                _serde::ser::SerializeStruct::skip_field(
                    &amp;mut __serde_state,
                    &#34;middle name&#34;,
                )?;
            }
            _serde::ser::SerializeStruct::serialize_field(
                &amp;mut __serde_state,
                &#34;last name&#34;,
                &amp;self.last,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
</code></pre><p>What would this look like in our annotations model? In C++, we don’t really have something like <code>serde</code> — where serialization splits up the pieces being serialized and what they are serialized into. At least, I’m not personally aware of such a library. Instead, we just have JSON libraries that handle JSON serialization, TOML libraries that handle TOML serialization, etc. Maybe that’s a consequence of missing the language support necessary to make it easy to do this kind of opt in? On the other hand, we <em>do</em> have this model for hashing — that’s <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html">Types Don’t Know #</a>.</p><p>In any event, while Rust’s and C++’s formatting approaches are similar, so the resulting implementations look similar — this isn’t true here. So instead of crafting a serde-like library in C++, I’m simply going to show what this might look like for serializing into Boost.JSON.</p><p>We’ll start with just support for <code>derive&lt;Serialize&gt;</code> and <code>rename</code>. That’s all we need to get <a href="https://godbolt.org/z/WYecTKPvY">this code to work</a>:</p><pre><code>struct [[=derive&lt;serde::Serialize&gt;]] Point {
    int x, y;
};

struct [[=derive&lt;serde::Serialize&gt;]] Person {
    [[=serde::rename(&#34;first name&#34;)]] std::string first;
    [[=serde::rename(&#34;last name&#34;)]] std::string last;
};

int main() {
    // prints {&#34;x&#34;:1,&#34;y&#34;:2}
    std::cout &lt;&lt; boost::json::value_from(Point{.x=1, .y=2}) &lt;&lt; &#39;\n&#39;;
    // prints {&#34;first name&#34;:&#34;Peter&#34;,&#34;last name&#34;:&#34;Dimov&#34;}
    std::cout &lt;&lt; boost::json::value_from(Person{.first=&#34;Peter&#34;, .last=&#34;Dimov&#34;}) &lt;&lt; &#39;\n&#39;;
}
</code></pre><p>And this whole thing is… 21 lines of code, if I keep the same <code>derive</code> variable template from before:</p><pre><code>namespace serde {
    inline constexpr struct{} Serialize{};
    struct rename { char const* field; };
}

namespace boost::json {
    template &lt;class T&gt;
        requires (has_annotation(^^T, derive&lt;serde::Serialize&gt;))
    void tag_invoke(value_from_tag const&amp;, value&amp; v, T const&amp; t) {
        auto&amp; obj = v.emplace_object();
        [:expand(nonstatic_data_members_of(^^T)):] &gt;&gt; [&amp;]&lt;auto M&gt;{
            constexpr auto field = annotation_of&lt;serde::rename&gt;(M)
                .transform([](serde::rename r){
                    return std::string_view(r.field);
                })
                .value_or(identifier_of(M));

            obj[field] = boost::json::value_from(t.[:M:]);
        };
    }
}
</code></pre><p>This should look familiar after the formatting implementation — since we’re basically also doing formatting. It’s just that instead of printing a bunch of <code>name=value</code> pairs, we’re adding them to a JSON object. And then instead of automatically using the identifier of the non-static data member in question, we first try to see if there’s a <code>rename</code> annotation. <code>annotation_of&lt;T&gt;()</code> gives us an <code>optional&lt;T&gt;</code>, so we either get the <code>rename</code> (and its underlying string) or just fallback to <code>identifier_of(M)</code>.</p><p>Adding support for <code>skip_serializing_if</code> isn’t that much more work, and I think helps really illustrate the difference between the C++ and Rust approaches. In Rust, you provide a string — that is injected to be invoked internally. In C++, we’d just provide a callable.</p><blockquote><p>This is because Rust’s attribute grammar can’t support a callable here.</p></blockquote><p>That requires adding a new annotation type:</p><pre><code>namespace serde {
      inline constexpr struct{} Serialize{};
      struct rename { char const* field; };
      template &lt;class F&gt; struct skip_serializing_if { F pred; };
  }
</code></pre><p>And then the mildly annoying part is parsing it. We need to pull out an annotation that is some specialization of <code>serde::skip_serializing_if</code>. If we find one, then we try to invoke its <code>pred</code> member — skipping serializing the value if it evaluates to <code>true</code>.</p><p>The search looks like this (note that we need <code>skip_if</code> to be <code>constexpr</code> because we need to splice it to invoke it). I’m sure this part can be cleaned up a little with a nicer library API (at the very least an <code>is_specialization_of</code>?):</p><pre><code>constexpr auto skip_if = []() -&gt; std::meta::info {
    auto res = std::meta::info();
    for (auto A : annotations_of(M)) {
        auto type = type_of(A);
        if (has_template_arguments(type)
            and template_of(type) == ^^serde::skip_serializing_if) {
            // found a specialization
            // but check to make sure we haven&#39;t found two
            // different ones.
            if (res != std::meta::info() and res != value_of(A)) {
                throw &#34;unexpected duplicate&#34;;
            }

            res = value_of(A);
        }
    }

    return res;
}();
</code></pre><p>And then, if we <em>have</em> such an annotation, we then invoke it to see if we need to skip this member. This needs to be an <code>if constexpr</code> because if <code>skip_if</code> is the null reflection, we can’t splice it. Other than that, this logic is exactly what we have to do: if we have such a <code>skip_serializing_if</code> annotation, invoke it and, if it’s false, skip this member:</p><pre><code>if constexpr (skip_if != std::meta::info()) {
    if (std::invoke([:skip_if:].pred, t.[:M:])) {
        return;
    }
}
</code></pre><p>You can see the full solution in action <a href="https://godbolt.org/z/hvqra8M7K">here</a>. It has now ballooned to… all of 51 lines of code (with the new logic to support <code>skip_serializing_if</code> highlighted):</p><pre data-line="7,22-46"><code>template &lt;auto V&gt; struct Derive { };
template &lt;auto V&gt; inline constexpr Derive&lt;V&gt; derive;

namespace serde {
    inline constexpr struct{} Serialize{};
    struct rename { char const* field; };
    template &lt;class F&gt; struct skip_serializing_if { F pred; };
}

namespace boost::json {
    template &lt;class T&gt;
        requires (has_annotation(^^T, derive&lt;serde::Serialize&gt;))
    void tag_invoke(value_from_tag const&amp;, value&amp; v, T const&amp; t) {
        auto&amp; obj = v.emplace_object();
        [:expand(nonstatic_data_members_of(^^T)):] &gt;&gt; [&amp;]&lt;auto M&gt;{
            constexpr auto field = annotation_of&lt;serde::rename&gt;(M)
                .transform([](serde::rename r){
                    return std::string_view(r.field);
                })
                .value_or(identifier_of(M));

            constexpr auto skip_if = []() -&gt; std::meta::info {
                auto res = std::meta::info();
                for (auto A : annotations_of(M)) {
                    auto type = type_of(A);
                    if (has_template_arguments(type)
                        and template_of(type) == ^^serde::skip_serializing_if) {
                        // found a specialization
                        // but check to make sure we haven&#39;t found
                        // two different ones.
                        if (res != std::meta::info() and res != value_of(A)) {
                            throw &#34;unexpected duplicate&#34;;
                        }

                        res = value_of(A);
                    }
                }

                return res;
            }();

            if constexpr (skip_if != std::meta::info()) {
                if (std::invoke([:skip_if:].pred, t.[:M:])) {
                    return;
                }
            }

            obj[field] = boost::json::value_from(t.[:M:]);
        };
    }
}
</code></pre><p>At this point, I thought there’s another fun approach to solving this problem. With just two attributes, it probably doesn’t make sense, but if I were to actually implement all of <code>serde</code>, it’d be nice to have an implementation strategy that doesn’t just handle each attribute parsing in a vacuum. Instead, what if we were to collect all the attributes into a class type — and then use that class type instead?</p><p>Let’s see what that looks like.</p><p>First, we’re going to to create a new class type — <code>serde::attributes</code>. We’re going to programmatically define it to have a member for each attribute that we have. The tricky part is the type of the member. For an attribute like <code>rename</code>, we should use <code>optional&lt;rename&gt;</code>. But for <code>skip_serializing_if</code>? We don’t know what type to use yet, so we’re just going to use <code>optional&lt;info&gt;</code> here to maintain type erasure. That is, we want to produce this type:</p><pre><code>struct attributes {
    optional&lt;rename&gt; rename;
    optional&lt;info&gt; skip_serializing_if;
};
</code></pre><p>That code makes use of <code>std::meta::define_class()</code>, the single API in P2996 that does code generation. It doesn’t do much, but it does enough for here. Note that since we’re iterating over all the members of the namespace <code>serde</code>, we have to make sure that we exclude <code>attributes</code> — which is of course in that namespace:</p><pre><code>struct attributes;
consteval {
    std::vector&lt;std::meta::info&gt; specs;
    for (auto m : members_of(^^serde)) {
        if (m == ^^attributes or not has_identifier(m)) {
            continue;
        }

        auto underlying = is_type(m) ? m : ^^std::meta::info;
        specs.push_back(data_member_spec(
            substitute(^^std::optional, {underlying}),
            {.name=identifier_of(m)}));
    }

    define_class(^^attributes, specs);
};
</code></pre><p>We can then write a parsing function that consumes the attributes of a non-static data member into an instance of <code>attributes</code>. The most annoying part here is simply finding which non-static data member of <code>attributes</code> to write into. I’m going to skip that logic for now and jump straight into how we would use the result of all of this work:</p><pre><code>namespace boost::json {
    template &lt;class T&gt;
        requires (has_annotation(^^T, derive&lt;serde::Serialize&gt;))
    void tag_invoke(value_from_tag const&amp;, value&amp; v, T const&amp; t) {
        auto&amp; obj = v.emplace_object();
        [:expand(nonstatic_data_members_of(^^T)):] &gt;&gt; [&amp;]&lt;auto M&gt;{
            constexpr auto attrs = serde::parse_attrs_from&lt;M&gt;();

            constexpr auto field = attrs.rename
                .transform([](serde::rename r){
                    return std::string_view(r.field);
                })
                .value_or(identifier_of(M));

            if constexpr (attrs.skip_serializing_if) {
                if (std::invoke(
                    [:*attrs.skip_serializing_if:].pred,
                    t.[:M:]))
                {
                    return;
                }
            }

            obj[field] = boost::json::value_from(t.[:M:]);
        };
    }
}
</code></pre><p>Sure, we moved the most complicated logic (parsing the annotations) into a function, which I’m not including in the above code block. But this is pretty nice right?</p><p>You can see the full implementation using this approach <a href="https://godbolt.org/z/jaKTe57Gf">here</a>. As I said, this is a bit overkill when we only have two attributes. But this approach means that all it takes to add a new <code>serde</code> attribute is to declare a new class or class template in the namespace and then just use it in the implementation.</p><h2 id="rust-attributes-vs-c-annotations"><span>Rust Attributes vs C++ Annotations</span><a href="#rust-attributes-vs-c-annotations"><i></i></a></h2><p>In the context of looking at serde, there are two things that stood out to me when comparing the C++ and Rust solutions: syntax and library design.</p><h3 id="syntax"><span>Syntax</span><a href="#syntax"><i></i></a></h3><p>The first thing which stood out to me most for the syntax difference on the usage side. This was my Rust declaration:</p><pre><code>#[derive(Serialize)]
struct Person {
    #[serde(rename = &#34;first name&#34;)]
    first: String,

    #[serde(rename = &#34;middle name&#34;, skip_serializing_if = &#34;String::is_empty&#34;)]
    middle: String,

    #[serde(rename = &#34;last name&#34;)]
    last: String,
}
</code></pre><p>And this was my C++ one:</p><pre><code>struct [[=derive&lt;serde::Serialize&gt;]] Person {
    [[=serde::rename(&#34;first name&#34;)]]
    std::string first;

    [[=serde::rename(&#34;middle name&#34;)]]
    [[=serde::skip_serializing_if(&amp;std::string::empty)]]
    std::string middle = &#34;&#34;;

    [[=serde::rename(&#34;last name&#34;)]]
    std::string last;
};
</code></pre><p>The C++ annotations are… busier, but this is mostly a syntactic question. Rust’s are lighter because annotations follow different grammar from the rest of the language — <code>serde(rename = &#34;first name&#34;)</code> isn’t valid Rust, and there is no call to a function named <code>serde</code> being performed here. One consequence of this is that the usage side for Rust annotations can be nicer, since it really reads like assigning values to options. And you get some flexibility with how you can use the contents of these “calls”, since you can write <code>#[arg(short)]</code> or <code>#[arg(short = &#39;k&#39;)]</code> as a nice way of indicating that you want the “default” value of <code>short</code> as opposed to specifically the value <code>k</code> (this is from <a href="https://docs.rs/clap/latest/clap/">clap</a>).</p><p>Now it’s tempting to wonder about reusing the (exceedingly oddly specific) attribute <code>using</code> syntax and allowing <code>using serde:</code> here. But it wouldn’t save that much typing at all:</p><pre><code>struct [[=derive&lt;serde::Serialize&gt;]] Person {
    // old version: 83 chars
    [[=serde::rename(&#34;middle name&#34;), =serde::skip_serializing_if(&amp;std::string::empty)]]
    std::string middle = &#34;&#34;;

    // new version: 82 chars
    [[using serde: =rename(&#34;middle name&#34;), =skip_serializing_if(&amp;std::string::empty)]]
    std::string middle = &#34;&#34;;
};
</code></pre><p>The Rust version is only 74 characters. It’s not <em>much</em> shorter, but it’s at least comfortably on the left side of the 80 column mark.</p><p>On the flip side though, it’s useful to note what Rust pays for to achieve this. With the C++ annotations design, the annotations are <em>just</em> values. There’s only a little bit of new grammar to learn (specifically the use of prefix <code>=</code>), but other than that you can already see what’s going on here. The contents of an annotation aren’t some incantation whose meaning is purely defined by the library, they are actual C++ values. Syntax highlighting already does the right thing. It’s <em>just</em> code. If you don’t know what <code>serde::skip_serializing_if</code> means, you can just go to its definition.</p><blockquote><p>Of course, in my simple implementation the definition doesn’t tell you anything. It’s just a class template with one data member. But in a real library, there would presumably be at least a comment.</p></blockquote><p>One thing you might have noticed that I did not comment on when going through the implementations of these examples was how to parse the values out of the annotations. This is because I did not need to actually do any parsing at all! The compiler does it for me. The only work I had to do was to parse the annotations I care about from a list of annotations — but that’s simply picking out values from a list. There’s no actual parsing involved. Rust libraries have to <em>actually parse</em> these token streams. For serde, that’s <a href="https://github.com/serde-rs/serde/blob/31000e1874ff01362f91e7b53794e402fab4fc78/serde_derive/src/internals/attr.rs">nearly 2,000 lines of code</a>. That’s a lot of logic that C++ annotation-based libraries will simply not have to ever write. And that matters.</p><blockquote><p>To be fair, <code>serde</code> is an older library, and newer Rust has something called <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive macro helper attributes</a> which will make this easier to do. Nevertheless, it is still up to the Rust library to do the kind of parsing that we will not have to do in C++.</p><p>Also, I didn’t pick <code>serde</code> just because it has a particularly large parsing component — I picked it because it’s so well-known and widely used as a library that even I, not a Rust programmer, am aware of it.</p></blockquote><p>Another interesting thing is that while the Rust and C++ approaches here end up doing similar things in different ways, they’re not <em>quite</em> the same. With Rust, <code>#[derive(Debug)]</code> injects the appropriate <code>impl</code> for <code>Debug</code>. With the C++ annotations approach, we are <em>not</em> injecting the appropriate specialization of <code>formatter</code>, we’re just adding a global constrained one.</p><p>That means that it <em>could</em>, without further work, be ambiguous if I make one small change:</p><pre data-line="5-7"><code>struct [[=derive&lt;Debug&gt;]] Point {
    int x;
    int y;

    // let&#39;s just make this a range for seemingly no reason
    auto begin() -&gt; int*;
    auto end() -&gt; int*;
};

int main() {
    auto p = Point{.x=1, .y=2};
    std::println(&#34;p={}&#34;, p); // error: ambiguous
}
</code></pre><p>Well, I’d have to make two small changes. The specialization I originally presented was declared like:</p><pre><code>template &lt;class T&gt; requires (has_annotation(^^T, derive&lt;Debug&gt;))
struct std::formatter&lt;T&gt; { /* ... */ };
</code></pre><p>but if I instead make it:</p><pre><code>template &lt;class T, class Char&gt; requires (has_annotation(^^T, derive&lt;Debug&gt;))
struct std::formatter&lt;T, Char&gt; { /* ... */ };
</code></pre><p>then it <a href="https://godbolt.org/z/sbcx6MW85">becomes ambiguous</a> with the formatter for ranges that I added for C++23. This can be worked around by disabling an extra variable template (which is preprocessed out in the link):</p><pre><code>template &lt;class T&gt; requires (has_annotation(^^T, derive&lt;Debug&gt;))
inline constexpr auto std::format_kind&lt;T&gt; = std::range_format::disabled;
</code></pre><p>This seems surprising that it’s necessary — since again conceptually the C++ approach is the same as the Rust one, and you might expect that adding the annotation injects the very specific, explicit specialization which cannot possibly be ambiguous with anything. It’s just that it can’t really work like that. So these kind of partial specialization ambiguities will almost certainly be an issue. Perhaps in the future we can come up with a way for annotations like <code>[[=derive&lt;Debug&gt;]]</code> to actually inject a specialization to avoid this problem. It certainly seems worth considering.</p><h3 id="library-design"><span>Library Design</span><a href="#library-design"><i></i></a></h3><p>In Rust’s <code>serde</code> library, serialization is a two-stage process. The type author opts in to serialization, which emits an implementation that functions sort of like an immediate representation of the type. Then authors of various protocols effectively can implement different backends.</p><p>In the implementation for <code>Person</code>, Rust emits an <code>impl</code> for <code>serde::Serialize</code> which takes in an arbitrary type which satisfies <code>serde::Serializer</code> (note the extra <code>r</code>). We then make a bunch of serialization calls into that <code>serializer</code> — which can then do whatever it sees fit with them. Whatever is appropriate for that protocol — whether it’s JSON or CBOR or YAML or TOML or …</p><p>A C++-ification of that implementation would look like this (to avoid getting bogged down in error handling, which isn’t relevant here, I’m just going to assume these functions throw on error rather than returning a <code>Result</code> as they do in Rust):</p><pre data-line="4-5,10"><code>template &lt;Serializer S&gt;
auto serialize(Person const&amp; p, S&amp; serializer) -&gt; void {
    auto state = serializer.serialize_struct(
        &#34;Person&#34;,
        2 + (p.middle.empty() ? 0 : 1));
    state.serialize_field(&#34;first name&#34;, p.first);
    if (not p.middle.empty()) {
        state.serialize_field(&#34;middle name&#34;, p.middle);
    } else {
        state.skip_field(&#34;middle name&#34;, p.middle);
    }
    state.serialize_field(&#34;last name&#34;, p.last);
    state.end();
}
</code></pre><p>This is a nice design for the decoupling it allows.</p><p>However, you might notice that the C++ implementation I showed earlier doesn’t do this at all. Not because I was lazy — but rather because it’s completely unnecessary with the existence of introspection. In C++, we didn’t need to emit this intermediate representation because we <em>already</em> have it in the form of basic type introspection. The Boost.JSON implementation just does all of the serialization work directly from the data members.</p><p>It’s not just a matter of writing less code, it’s a matter of not even having to deal with this extra layer of abstraction at all. It’s not like this layer is computationally expensive, I’m sure it compiles down pretty easily. It’s just that it’s unnecessary.</p><p>Consider the highlighted call to <code>skip_field</code> above. For many serialization targets (e.g. JSON), the way to skip serializing a field is simply to <em>not</em> serialize it. That’s why the default implementation of <code>skip_field</code> <a href="https://github.com/serde-rs/serde/blob/31000e1874ff01362f91e7b53794e402fab4fc78/serde/src/ser/mod.rs#L1869-L1876">does nothing</a> (as you would expect) and <code>serde_json</code> does not override it.</p><p>Likewise, consider the computation of the number of fields also highlighted above. The JSON serializer doesn’t need such a thing either, and simply ignores this value. Ditto the name of the type.</p><p>But in creating an intermediate representation — you have to create a representation rich enough to be able to handle all possible (de)serialization targets. Some of them will need the number of fields in advance or will need to leave a hole for skipped fields. So <code>serde</code> needs to provide for such.</p><p>In C++, we just don’t. The serializer for any given target can just directly do all the operations that it needs to do — because it directly has all the information at this disposal. No abstraction necessary. As a result, the C++ equivalent of the <code>serde</code> library would probably just be a list of types usable as annotations, the <code>parse_attrs_from()</code> function, and maybe a couple other little helpers.</p><p>Introspection is a pretty powerful tool.</p><h2 id="this-is-not-the-end"><span>This is not the End</span><a href="#this-is-not-the-end"><i></i></a></h2><p>I wanted to end by pointing out that there are a few language features, in different languages, that are somewhat closely related:</p><ul><li>Rust’s procedural macros</li><li>Python decorators</li><li>Herb Sutter’s metaclasses proposal</li></ul><p>All of them involve writing code — and then passing that code into a function to produce new code. Metaclasses and decorators actually replace the original code, whereas the derive macro only injects new code (although other procedural macros can also replace).</p><p>The annotation proposal looks, in spirit, related to these — but it’s a very different mechanism and shouldn’t be confused for them. It’s not injecting code at all, it’s simply enhancing introspection abilities.</p><p>Which isn’t to say that annotations aren’t useful! As I’ve hopefully demonstrated, it promises to be an incredibly useful facility that allows for writing the kinds of user-friendly library APIs that were unthinkable in C++ before now.</p><p>But this is only the beginning.</p></div></div>
  </body>
</html>
