<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ryanliptak.com/blog/better-named-character-reference-tokenization/">Original</a>
    <h1>Slightly better named character reference tokenization than Chrome, Safari, FF</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><time>2025-06-26</time>
 - <a href="https://jvns.ca/blog/categories/programming">Programming</a></p>
<p>A while back, for <span title="the actual reason will be detailed later">no real reason</span>, I tried writing an implementation of a data structure tailored to the specific use case of <a href="https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state">the <em>Named character reference state</em></a> of HTML tokenization (here&#39;s the <a href="https://github.com/squeek502/named-character-references">link to that experiment</a>). Recently, I took that implementation, ported it to C++, and <a href="https://github.com/LadybirdBrowser/ladybird/pull/3011">used it to make some efficiency gains and fix some spec compliance issues</a> in the <a href="https://ladybird.org/">Ladybird browser</a>.</p>
<p>Throughout this, I never actually looked at the implementations used in any of the major browser engines (no reason for this, just me being dumb). However, now that I <em>have</em> looked at Blink/WebKit/Gecko (Chrome/Safari/Firefox, respectively), I&#39;ve realized that my implementation seems to be either on-par or better across the metrics that the browser engines care about:</p>
<ul>
<li>Efficiency (at least as fast, if not slightly faster)</li>
<li>Compactness of the data (uses ~60% of the data size of Chrome&#39;s/Firefox&#39;s implementation)</li>
<li>Ease of use</li>
</ul>

<p>So, I thought I&#39;d take you through what I came up with and how it compares to the implementations in the major browser engines. Mostly, though, I just think the data structure I used is neat and want to tell you about it (fair warning: it&#39;s not novel).</p>
<h2>What is a named character reference?<a id="what-is-a-named-character-reference" href="#what-is-a-named-character-reference">ðŸ”—</a></h2>
<p>A named character reference is an HTML entity specified using an ampersand (<code>&amp;</code>) followed by an ASCII alphanumeric name. An ordained set of names will get transformed during HTML parsing into particular code point(s). For example, <code>&amp;bigcirc;</code> is a valid named character reference that gets transformed into the symbol â—¯, while <code>&amp;amp;</code> will get transformed into &amp;.</p>

<p>Here&#39;s a few properties of named character references that are relevant for what we&#39;ll ultimately be aiming to implement:</p>
<ul>
<li>Always start with <code>&amp;</code></li>
<li>Only contain characters in the ASCII range</li>
<li>Case-sensitive</li>
<li>Usually, but not always, end with <code>;</code></li>
<li>Are transformed into either 1 or 2 code points
<ul>
<li>Irrelevant side note: those code point(s) usually make up one <a href="https://www.unicode.org/glossary/#grapheme">grapheme</a> (i.e. most second code points are combining code points), but not always (e.g. <code>&amp;fjlig;</code> maps to <code>U+0066 U+006A</code> which are just the ASCII letters <code>fj</code>)</li>
</ul>
</li>
</ul>
<p>Most crucially, though, the mappings of named character references are <em>fixed</em>. The <a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">HTML standard</a> contains this note about named character references:</p>
<blockquote>
<p><strong>Note:</strong> This list is static and <a href="https://github.com/whatwg/html/blob/main/FAQ.md#html-should-add-more-named-character-references">will not be expanded or changed in the future</a>.</p>
</blockquote>
<p>This means that it&#39;s now safe to represent the data in the minimum amount of bits possible without any fear of needing to accommodate more named character reference mappings in the future.</p>

<h2>Named character reference tokenization overview<a id="named-character-reference-tokenization-overview" href="#named-character-reference-tokenization-overview">ðŸ”—</a></h2>
<p>I&#39;m specifically going to be talking about the <a href="https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state"><em>Named character reference state</em> of HTML tokenization</a>. You can read the spec for it if you want (it&#39;s fairly short) but there&#39;s really only one sentence we&#39;re interested in:</p>
<blockquote>
<p>Consume the maximum number of characters possible, where the consumed characters are one of the identifiers in the first column of the named character references table.</p>
</blockquote>
<p>This sentence is really the crux of the implementation, but the spec is quite hand-wavy here and conceals a lot of complexity. The example given a bit later in the spec hints at why the above sentence is not so straightforward (edited to exclude irrelevant details; for context, <code><span>&amp;not</span></code> is a valid named character reference, as is <code><span>&amp;notin;</span></code>):</p>
<blockquote>
<p><strong>Example:</strong> If the markup contains the string <code>I&#39;m <span>&amp;not</span>it; I tell you</code>, the character reference is parsed as &#34;not&#34;, as in, <code>I&#39;m Â¬it; I tell you</code>. But if the markup was <code>I&#39;m <span>&amp;notin;</span> I tell you</code>, the character reference would be parsed as &#34;notin;&#34;, resulting in <code>I&#39;m âˆ‰ I tell you</code>.</p>
</blockquote>
<p>That is, with the string <code>&amp;notit;</code>, the characters up to and including <code>&amp;noti</code> can still lead to a valid named character reference (<code>&amp;notin;</code>, among others), so we only know that <code>&amp;notit;</code> is invalid once we&#39;ve reached <code>&amp;notit</code> which can no longer lead to a valid named character reference. What this means is that there needs to be some amount of backtracking involved, as the goal is to consume only the characters that are part of the longest valid named character reference.</p>
<p>That&#39;s not the only complication, though...</p>
<h3>The spectre of <code>document.write</code><a id="the-spectre-of-document-write" href="#the-spectre-of-document-write">ðŸ”—</a></h3>
<p>Due to <code>&lt;script&gt;</code> tags, the input to HTML tokenization is <em>mutable while it is being tokenized</em>, meaning looking ahead is not always reliable/possible since we might not yet know what comes next. Consider this example:</p>
<pre><code><span>&lt;script&gt;</span><span>
</span><span>document</span><span>.</span><span>write</span><span>(</span><span>&#34;&amp;not&#34;</span><span>);</span><span>
</span><span>&lt;/script&gt;</span><span>in;</span><span>
</span></code></pre>
<p>The expected result after parsing is <code>âˆ‰</code>, meaning the resolved character reference is <code>&amp;notin;</code>. Let&#39;s go through why that is the case.</p>

<p>After the closing script tag is tokenized, the parser adds an &#34;insertion point&#34; after it, and then the script within the tag itself is executed. So, right <em>before</em> the script is executed, the tokenizer input can be visualized as (where <code><span></span></code> is the insertion point):</p>
<pre><code><span></span><span>in;</span></code></pre>
<p>And then after the <code>&lt;script&gt;</code> is executed and the <code>document.write</code> call has run, it can be visualized as:</p>
<pre><code><span>&amp;not</span><span>in;</span></code></pre>
<p>What happens from the tokenizer&#39;s perspective is that after the closing <code>&lt;/script&gt;</code> tag, <code>&amp;not</code> comes next in the input stream (which was inserted by <code>document.write</code>), and then the characters after <code>&amp;not</code> are <code>in;</code>, so ultimately a tokenizer going character-by-character should see an unbroken <code>&amp;notin;</code>, recognize that as a valid character reference, and translate it to <code>âˆ‰</code>.</p>

<p>To further show why this can be tricky to handle, consider also the possibility of <code>document.write</code> writing one character at a time, like so:</p>
<pre><code><span>&lt;script&gt;</span><span>
</span><span>for</span><span> </span><span>(</span><span>let</span><span> </span><span>char</span><span> </span><span>of</span><span> </span><span>&#34;&amp;not&#34;</span><span>)</span><span> </span><span>{</span><span>
  </span><span>document</span><span>.</span><span>write</span><span>(</span><span>char</span><span>);</span><span>
</span><span>}</span><span>
</span><span>&lt;/script&gt;</span><span>in;</span><span>
</span></code></pre>
<p>This, too, is expected to result in <code>âˆ‰</code> (i.e. <code>&amp;notin;</code>). Keep in mind that the tokenizer will advance after each <code>document.write</code> call, so if the tokenizer tries to lookahead past the insertion point at any point before the full script is run, it will resolve the wrong string as a character reference (<code>&amp;in;</code>, <code>&amp;nin;</code>, or <code>&amp;noin;</code>). Here&#39;s a visualization that shows the insertion point and the various states of the input stream after each <code>document.write</code> call:</p>
<pre><code><span id="not-insertion-point"></span><span>in;</span></code></pre>

<p>Therefore, while HTML tokenizers <em>can</em> theoretically look ahead, they can never look past the end of an insertion point.</p>
<h3>What this all means, implementation-wise<a id="what-this-all-means-implementation-wise" href="#what-this-all-means-implementation-wise">ðŸ”—</a></h3>
<p>All of this is to say that a &#34;consume the longest valid named character reference&#34; implementation probably needs to use one of two strategies:</p>
<ul>
<li>Lookahead (but never beyond an insertion point) until we&#39;re certain that we have enough characters to rule out a longer named character reference. If we do not yet have enough characters to be <em>certain</em>, backtrack and try again until we can be certain.</li>
<li>Never lookahead, and instead match character-by-character until we&#39;re certain it&#39;s no longer possible to match a longer valid named character reference. Backtrack to the end of longest full match found.</li>
</ul>
<p>The second strategy seems like the better approach to me, so that&#39;s what my implementation will be focused on. We&#39;ll see both strategies later on, though.</p>

<h2>Trie implementation<a id="trie-implementation" href="#trie-implementation">ðŸ”—</a></h2>
<p>So, we want an implementation that can iterate character-by-character and (at any point) efficiently determine if it&#39;s possible for the next character to lead to a longer valid named character reference.</p>
<p>A data structure that seems pretty good for this sort of thing is a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>. A trie is a specialized tree where each node contains a character that can come after the character of its parent node in a set of words. Below is a representation of a trie containing this small subset of named character references:</p>
<div>
  <div>
    <div>
      <p><code>&amp;not</code></p><p>â†’</p><p>Â¬</p>
      <p><code>&amp;notinva;</code></p><p>â†’</p><p>âˆ‰</p>
      <p><code>&amp;notinvb;</code></p><p>â†’</p><p>â‹·</p>
      <p><code>&amp;notinvc;</code></p><p>â†’</p><p>â‹¶</p>
      <p><code>&amp;notniva;</code></p><p>â†’</p><p>âˆŒ</p>
      <p><code>&amp;notnivb;</code></p><p>â†’</p><p>â‹¾</p>
      <p><code>&amp;notnivc;</code></p><p>â†’</p><p>â‹½</p>
    </div>
  </div>
  
</div>


<p>With such a trie, you search for the next character within the list of the current node&#39;s children (starting from the root). If the character is found within the children, you then set that child node as the current node and continue on for the character after that, etc.</p>
<p>For invalid words, this means that you naturally stop searching as soon as possible (after the first character that cannot lead to a longer match). For valid words, you trace a path through the trie and end up on an end-of-word node (and you may also pass end-of-word nodes on the way there). Here&#39;s what the path through the trie would look like for the named character reference <code>&amp;notinvc;</code>:</p>

<p>You&#39;ll notice that the mapped code point (â‹¶) is present on the diagram above as well. This is because it is trivial to use a trie as a map to look up an associated value, since each word in the set <em>must</em> end at a distinct node in the trie (e.g. no two words can share an end-of-word node). Conveniently, using the trie as a map is exactly what we want to be able to do for named character references, since ultimately we need to convert the longest matched named character reference into the relevant code point(s).</p>
<h2>A brief detour: Representing a trie in memory<a id="a-brief-detour-representing-a-trie-in-memory" href="#a-brief-detour-representing-a-trie-in-memory">ðŸ”—</a></h2>

<p>One way to represent a trie node is to use an array of optional pointers for its children (where each index into the array represents a child node with that byte value as its character), like so:</p>
<pre><code><span>const</span><span> </span><span>Node</span><span> </span><span>=</span><span> </span><span>struct</span><span> </span><span>{</span><span>
  </span><span>
  </span><span>children</span><span>:</span><span> </span><span>[</span><span>256</span><span>]</span><span>?*</span><span>Node</span><span>,</span><span>
  </span><span>end_of_word</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>Earlier, I said that trie visualizations typically put the letters on the connections between nodes rather than the nodes themselves, and, with <em>this</em> way of representing the trie, I think that makes a lot of sense, since the <em>connections</em> are the information being stored on each node.</p>

<p>So, this representation can be visualized like so:</p>

<p>With this, checking if a character can come after the current node is a straightforward <code>O(1)</code> array access:</p>
<pre><code><span>if</span><span> </span><span>(</span><span>node</span><span>.</span><span>children</span><span>[</span><span>c</span><span>]</span><span> </span><span>!=</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span>
    </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>but it comes at the cost of a lot of potentially wasted space, since most nodes will have many <code>null</code> children.</p>
<p>One way to mitigate the wasted space would be to switch from an array of children to a linked list of children, where the parent stores an optional pointer to its first child, and each child stores an optional pointer to its next sibling:</p>
<pre><code><span>const</span><span> </span><span>Node</span><span> </span><span>=</span><span> </span><span>struct</span><span> </span><span>{</span><span>
  </span><span>char</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
  </span><span>first_child</span><span>:</span><span> </span><span>?*</span><span>Node</span><span>,</span><span>
  </span><span>next_sibling</span><span>:</span><span> </span><span>?*</span><span>Node</span><span>,</span><span>
  </span><span>end_of_word</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>Now that <code>char</code> is stored <em>on</em> each node directly, I (in turn) think it makes sense to visualize the trie with the characters shown on the nodes themselves, like so:</p>

<p>While this &#39;linked list&#39; representation saves on memory, it transforms the search for a particular child into a <code>O(n)</code> linear scan across the children:</p>
<pre><code><span>var</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>starting_node</span><span>.</span><span>first_child</span><span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>null</span><span>;</span><span>
</span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span> </span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>node</span><span>.</span><span>char</span><span> </span><span>==</span><span> </span><span>c</span><span>)</span><span> </span><span>{</span><span>
        </span><span>
    </span><span>}</span><span>
    </span><span>node</span><span> </span><span>=</span><span> </span><span>node</span><span>.</span><span>next_sibling</span><span> </span><span>orelse</span><span> </span><span>return</span><span> </span><span>null</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This linear search can be slow, especially if the nodes are individually heap-allocated and therefore could be very spread out in memory, leading to a lot of random memory accesses and cache misses. Additionally, pointers themselves take up quite a bit of space (8 bytes on 64-bit machines). If we ultimately want to decrease the size of the node, getting rid of the pointer fields would be helpful as well.</p>
<p>We can solve multiple of these problems at once by:</p>
<ul>
<li>Enforcing that all nodes are proximate in memory by storing them all in one array</li>
<li>Replace all pointers with indexes into that array</li>
<li>Ensure that children are always contiguous (i.e. to access a sibling you just increment the index by 1)</li>
</ul>
<p>With this approach, <code>Node</code> could look like this:</p>
<pre><code><span>const</span><span> </span><span>Node</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span> </span><span>{</span><span>
    </span><span>char</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
    </span><span>
    </span><span>
    </span><span>first_child_index</span><span>:</span><span> </span><span>u3</span><span>,</span><span>
    </span><span>
    </span><span>
    </span><span>last_sibling</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
    </span><span>end_of_word</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>And the array of nodes for this particular example trie would look like this:</p>
<pre><code><span>const</span><span> </span><span>nodes</span><span> </span><span>=</span><span> </span><span>[</span><span>6</span><span>]</span><span>Node</span><span>{</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>1</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span>   </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>  </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>false</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>3</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;G&#39;</span><span>,</span><span> </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span> </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>false</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>5</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;H&#39;</span><span>,</span><span> </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>  </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>false</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;G&#39;</span><span>,</span><span> </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span> </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>true</span><span>  </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;L&#39;</span><span>,</span><span> </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>  </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>true</span><span>  </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>first_child_index</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;F&#39;</span><span>,</span><span> </span><span>.</span><span>last_sibling</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span>  </span><span>.</span><span>end_of_word</span><span> </span><span>=</span><span> </span><span>true</span><span>  </span><span>},</span><span>
</span><span>};</span><span>
</span></code></pre>

<p>This representation can be visualized like so:</p>


<p>This still means that searching a child list uses a <code>O(n)</code> linear scan, but this representation makes those searches <em>much</em> more friendly to the CPU, and greatly reduces the size of each node.</p>
<h3>Some hard numbers<a id="some-hard-numbers" href="#some-hard-numbers">ðŸ”—</a></h3>
<p>To get an idea of how the different representations compare, here&#39;s a breakdown for a trie containing the full set of named character references (2,231 words).</p>

<h4>Data size<a id="data-size" href="#data-size">ðŸ”—</a></h4>

<ul>
<li><strong>Representation 1</strong> (&#39;connections&#39;):
<ul>
<li>Each node contains a fixed-size array of optional child node pointers</li>
<li>Each node is <span>2056</span> bytes wide (using <code>[256]?*Node</code> as the <code>children</code> field)</li>
<li>There are 9,854 nodes in the trie, so 2,056 * 9,854 = 20,259,824 bytes total for the full trie (<span>19.32 MiB</span>)</li>
</ul>
</li>
<li><strong>Representation 2</strong> (&#39;linked list&#39;):
<ul>
<li>Each node contains a pointer to its first child and its next sibling</li>
<li>Each node is <span>24</span> bytes wide</li>
<li>There are 9,854 nodes in the trie, so 24 * 9,854 = 236,496 bytes total for the full trie (<span>230.95 KiB</span>)</li>
</ul>
</li>
<li><strong>Representation 3</strong> (&#39;flattened&#39;):
<ul>
<li>Each node contains the index of its first child, and all nodes are allocated in one contiguous array</li>
<li>Each node is <span>4</span> bytes wide</li>
<li>There are 9,854 nodes in the trie, so 4 * 9,854 = 39,416 bytes total for the full trie (<span>38.49 KiB</span>)</li>
</ul>
</li>
</ul>
<p>That is, the &#39;flattened&#39; version is <sup>1</sup>/<sub>514</sub> the size of the &#39;connections&#39; version, and <sup>1</sup>/<sub>6</sub> the size of the &#39;linked list&#39; version.</p>

<h4>Performance<a id="performance" href="#performance">ðŸ”—</a></h4>
<p>As mentioned, the &#39;linked list&#39; and &#39;flattened&#39; versions sacrifice the <code>O(1)</code> lookup of the &#39;connections&#39; version in favor of reducing the data size, so while the &#39;flattened&#39; version claws some performance back from the &#39;linked list&#39; version, the &#39;connections&#39; version is the fastest:</p>
<ul>
<li><strong>Representation 1</strong> (&#39;connections&#39;):
<ul>
<li><code><span>501.596ms</span> (<span>50ns</span> per <code>contains</code> call)</code></li>
</ul>
</li>
<li><strong>Representation 2</strong> (&#39;linked list&#39;):
<ul>
<li><code><span>965.138ms</span> (<span>96ns</span> per <code>contains</code> call)</code></li>
</ul>
</li>
<li><strong>Representation 3</strong> (&#39;flattened&#39;):
<ul>
<li><code><span>609.215ms</span> (<span>60ns</span> per <code>contains</code> call)</code></li>
</ul>
</li>
</ul>
<p>One interesting thing to note is that the above results for representations 1 &amp; 2 rely on a friendly allocation pattern for the nodes (i.e. the memory addresses of the nodes happening to end up fairly close to eachother) This is admittedly pretty likely when constructing a trie all at once, but, if we <em>intentionally force</em> a <strong>horrendous</strong> allocation pattern, where each allocated node gets put on an entirely separate <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)">page</a>, we can see the effects very clearly:</p>
<ul>
<li><strong>Representation 1</strong> (&#39;connections&#39;):
<ul>
<li><code><span>1.025s</span> (<span>102ns</span> per <code>contains</code> call)</code> (each <code>contains</code> call takes ~2x longer than it did)</li>
</ul>
</li>
<li><strong>Representation 2</strong> (&#39;linked list&#39;):
<ul>
<li><code><span>4.372s</span> (<span>437ns</span> per <code>contains</code> call)</code> (each <code>contains</code> call takes ~4x longer than it did)</li>
</ul>
</li>
<li><strong>Representation 3</strong> (&#39;flattened&#39;):
<ul>
<li>No difference since it always allocates one contiguous chunk of memory</li>
</ul>
</li>
</ul>
<p>If we run the relevant benchmarks through <a href="https://github.com/andrewrk/poop"><code>poop</code></a>, we can confirm the cause of the slowdown (these results are from the &#39;connections&#39; version):</p>
<pre><code><span>Benchmark 1</span><span>: ./trie-friendly-allocations
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>496</span><span> </span><span>Â±</span><span> </span><span>24.1</span><span>     </span><span>440</span><span> </span><span>â€¦</span><span>  </span><span>518</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>2.01</span><span>  </span><span>Â±</span><span>  </span><span>100</span><span>     </span><span>1.78</span><span>  </span><span>â€¦</span><span> </span><span>2.11</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.94</span><span>  </span><span>Â±</span><span> </span><span>26.3</span><span>     </span><span>1.94</span><span>  </span><span>â€¦</span><span> </span><span>1.94</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>107</span><span>  </span><span>Â±</span><span> </span><span>3.40</span><span>     </span><span>98.8</span><span>  </span><span>â€¦</span><span>  </span><span>109</span><span>           </span><span>2 (18%)</span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>33.1</span><span>  </span><span>Â±</span><span> </span><span>1.15</span><span>     </span><span>30.3</span><span>  </span><span>â€¦</span><span> </span><span>34.0</span><span>           </span><span>2 (18%)</span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>21.7</span><span>  </span><span>Â±</span><span> </span><span>20.7</span><span>     </span><span>21.7</span><span>  </span><span>â€¦</span><span> </span><span>21.7</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./trie-horrendous-allocations
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.07</span><span>  </span><span>Â±</span><span> </span><span>21.9</span><span>    </span><span>1.05</span><span>  </span><span>â€¦</span><span> </span><span>1.11</span><span>           </span><span>        </span><span>ðŸ’©+116.4% Â±  5.5%
</span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>4.17</span><span>  </span><span>Â±</span><span> </span><span>92.4</span><span>     </span><span>4.09</span><span>  </span><span>â€¦</span><span> </span><span>4.33</span><span>           </span><span>        </span><span>ðŸ’©+106.9% Â±  5.6%
</span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.92</span><span>  </span><span>Â±</span><span> </span><span>38.4</span><span>      </span><span>1.92</span><span>  </span><span>â€¦</span><span> </span><span>1.92</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>145</span><span>  </span><span>Â±</span><span> </span><span>1.63</span><span>      </span><span>144</span><span>  </span><span>â€¦</span><span>  </span><span>147</span><span>           </span><span>        </span><span>ðŸ’©+ 35.3% Â±  3.3%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>62.2</span><span>  </span><span>Â±</span><span>  </span><span>839</span><span>     </span><span>61.8</span><span>  </span><span>â€¦</span><span> </span><span>63.7</span><span>           </span><span>        </span><span>ðŸ’©+ 88.3% Â±  3.7%
</span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>21.5</span><span>  </span><span>Â±</span><span> </span><span>51.6</span><span>     </span><span>21.4</span><span>  </span><span>â€¦</span><span> </span><span>21.5</span><span>           </span><span>          </span><span></span></code></pre>
<p>Note that the instruction counts are roughly the same between the &#39;friendly&#39; and &#39;horrendous&#39; versions, so the increased <code>cpu_cycles</code> and <code>wall_time</code> can presumably be attributed to the increase in cache misses and pointer chasing (the trie code itself is identical between the two versions).</p>
<h4>Takeaways<a id="takeaways" href="#takeaways">ðŸ”—</a></h4>
<p>When using the &#39;flattened&#39; representation for this particular task, we&#39;re trading off a ~20% difference in lookup speed for 2-3 orders of magnitude difference in data size. This seems pretty okay, especially for what we&#39;re ultimately interested in implementing: a fully static and unchanging data structure, so there&#39;s no need to worry about how easy it is to modify after construction.</p>

<h3>An important note moving forward<a id="an-important-note-moving-forward" href="#an-important-note-moving-forward">ðŸ”—</a></h3>

<h2>DAFSA implementation<a id="dafsa-implementation" href="#dafsa-implementation">ðŸ”—</a></h2>
<p>A while back at the same Zig meetup where I gave <a href="https://www.youtube.com/watch?v=RZczLb_uI9E">a talk about my Windows resource compiler</a>, Niles Salter aka <a href="https://validark.dev/">Validark</a> gave a talk titled <em><strong>Better data structures and where to find them</strong></em>. It was nominally about <a href="https://validark.dev/DynSDT/">his novel autocomplete data structure</a>, but the stated purpose of the talk was to get people interested in learning about data structures and potentially inventing their own.</p>

<p>During the talk, I thought back to when <a href="https://github.com/watzon/zhtml/pulls?q=is%3Apr+is%3Aclosed+author%3Asqueek502">I contributed to an HTML parser implementation</a> and had to leave proper <em>named character reference tokenization</em> as a <code>TODO</code> because I wasn&#39;t sure how to approach it. I can&#39;t remember if a <a href="https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton"><em>deterministic acyclic finite state automaton</em></a> (DAFSA) was directly mentioned in the talk, or if I heard about it from talking with Niles afterwards, or if I learned of it while looking into trie variations later on (since the talk was about a novel trie variation), but, in any case, after learning about the DAFSA, it sounded like a pretty good tool for the job of named character references, so I <span title="this is the reason for all of this that was glossed over in the intro">revisited named character reference tokenization with that tool in hand</span>.</p>

<h3>What is a DAFSA?<a id="what-is-a-dafsa" href="#what-is-a-dafsa">ðŸ”—</a></h3>

<p>A DAFSA is essentially the &#39;flattened&#39; representation of a trie, but, more importantly, certain types of redundant nodes are eliminated during its construction (the particulars of this aren&#39;t too relevant here so I&#39;ll skip them; see <a href="https://stevehanov.ca/blog/?id=115">here</a> if you&#39;re interested).</p>
<p>Going back to the same subset of named character references as the example in the <a href="#trie-implementation">&#34;<em>Trie implementation</em>&#34;</a> section above, a DAFSA would represent that set of words like so:</p>

<p>As you can see, the <code>v</code>, <code>a</code>, <code>b</code>, <code>c</code> and <code>;</code> nodes are now shared between all the words that use them. This takes the number of nodes down to 13 in this example (compared to 22 for the trie).</p>
<p>The downside of this node consolidation is that we lose the ability to associate a given end-of-word node with a particular value. In this DAFSA example, <em>all words</em> except <code>not</code> end on the exact same node, so how can we know where to look for the associated value(s) for those words?</p>
<p>Here&#39;s an illustration of the problem when matching the word <code>&amp;notinvc;</code>:</p>

<p>To get around this downside, it&#39;d be possible to use something like a separate hash map or devise some minimal perfect hashing scheme to lookup the associated code point(s) for a matching word after the fact, but, luckily, we don&#39;t have to worry too much about that because it turns out it is possible to do...</p>
<h3>Minimal perfect hashing using a DAFSA<a id="minimal-perfect-hashing-using-a-dafsa" href="#minimal-perfect-hashing-using-a-dafsa">ðŸ”—</a></h3>
<p>First detailed in <a href="https://doi.org/10.1002/spe.4380230103"><em>Applications of finite automata representing large vocabularies</em></a> (ClÃ¡udio L. Lucchesi, Tomasz Kowaltowski, 1993) (<a href="https://www.ic.unicamp.br/~reltech/1992/92-01.pdf">pdf</a>), the technique for minimal perfect hashing using a DAFSA is actually rather simple/elegant:</p>
<p>Within each node, store a count of all possible valid words from that node. For the example we&#39;ve been using, those counts would look like this:</p>

<p>Then, to get a unique index for a given word, traverse the DAFSA as normal, but:</p>
<ul>
<li>For any <em>non-matching</em> node that is iterated when searching a list of children, add their <code>number</code> to the unique index</li>
<li>For nodes that <em>match</em> the current character, if the node is a valid end-of-word, add 1 to the unique index</li>
</ul>

<p>For example, if we had a DAFSA with <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> as possible first characters (in that order), and the word we&#39;re looking for starts with <code>c</code>, then we&#39;ll iterate over <code>a</code> and <code>b</code> when looking for <code>c</code> in the list of children, so we add the numbers of the <code>a</code> and <code>b</code> nodes (whatever they happen to be) to the unique index. Here&#39;s an illustration:</p>


<p>For a given word in the set, applying this algorithm will produce a number between 1 and the total number of words in the DAFSA (inclusive), and it&#39;s guaranteed that each word will end up with a unique number (i.e. this is a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function#Minimal_perfect_hash_function">minimal perfect hash</a>). Here&#39;s what that looks like for the example we&#39;ve been using:</p>


<p>After you have the unique index of a word, you can then use a lookup array for the associated values and index into it using <code>unique_index - 1</code>.</p>

<h2>Trie vs DAFSA for named character references<a id="trie-vs-dafsa-for-named-character-references" href="#trie-vs-dafsa-for-named-character-references">ðŸ”—</a></h2>
<p>Ok, so now that we have two different data structures that seem pretty well suited for named character reference matchingâ€”a trie and a DAFSAâ€”how do they compare? It&#39;s now (finally) time to start using the <a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">full set of named character references and all of their mapped code point(s)</a> to see how they stack up.</p>
<p>Some numbers to keep in mind upfront:</p>
<ul>
<li>There are 2,231 named character references total</li>
<li>A trie will use 9,854 nodes to encode the set of named character references</li>
<li>A DAFSA will use 3,872 nodes to encode the set of named character references</li>
</ul>
<h3>Another brief detour: representing the mapped value(s)<a id="another-brief-detour-representing-the-mapped-value-s" href="#another-brief-detour-representing-the-mapped-value-s">ðŸ”—</a></h3>
<p>As mentioned earlier, each named character reference is mapped to either one or two code points. Unicode code points have a range of <code>0x0</code>-<code>0x10FFFF</code>, but if we actually look at the <a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">set of code points used by named character references</a>, there are a few properties worth noting:</p>
<ul>
<li>The maximum value of the first code point is <code>U+1D56B</code>, which takes 17 bits to encode, so all first code point values can fit into a 17 bit wide unsigned integer.</li>
<li>The set of distinct <em>second</em> code point values is actually very small, with only 8 unique code points. This means that an enum that&#39;s only 4 bits wide (3 bits for the 8 different values, 1 additional bit to encode &#39;no second code point&#39;) can be used to store all the information about the second code point.</li>
</ul>
<p>With both of these properties taken together, it&#39;s possible to encode the mapped code point values for any given named character reference in 21 bits. With padding between the elements of an array of 21-bit integers, though, that will round up to 4 bytes per element (11 bits of padding), so it ends up being the same as if 32 bit integers were used.</p>
<p>Here&#39;s a diagram of a possible memory layout of an array using this representation, where <span>Â Â Â Â </span> is the bits of the first code point, <span>Â Â Â Â </span> is the bits of the second code point, and <span>Â Â Â Â </span> is the padding bits between elements:</p>
<div>
  
  <div>
    <p><span>0</span>
      <span>1</span>
      <span>2</span>
      <span>3</span>
      <span>4</span>
      <span>5</span>
      <span>6</span>
      <span>7</span>
      <span>8</span>
      <span>9</span>
      <span>10</span>
      <span>11</span>
    </p>
    
    <p><span><span>0</span></span>
      <span><span>1</span></span>
      <span><span>2</span></span>
    </p>
    
  </div>
</div>
<p>However, while using 21 bits to represent the mapped code point(s) does not automatically lead to any saved bytes over a 32 bit integer, it opens up the possibility to tightly pack an array of 21-bit elements in order to <em>actually</em> save some bytes. Yet, doing so means that storing/loading elements from the tightly packed array becomes trickier (both computationally and implementation-wise). Here&#39;s the same diagram as before, but with the elements tightly packed (no padding bits between elements):</p>
<div>
  
  <div>
  <p><span>0</span>
    <span>1</span>
    <span>2</span>
    <span>3</span>
    <span>4</span>
    <span>5</span>
    <span>6</span>
    <span>7</span>
    <span>8</span>
    <span>9</span>
    <span>10</span>
    <span>11</span>
  </p>
  
  <p><span><span>0</span></span>
    <span><span>1</span></span>
    <span><span>2</span></span>
    <span><span>3</span></span>
    <span><span>4</span></span>
  </p>
  
  </div>
</div>
<p>You&#39;ll notice that no elements past the first start or end on byte boundaries, meaning in order to load an element, a fair bit of bitwise operations are required (bit shifting, etc). This makes array accesses more expensive, but that isn&#39;t necessarily a big deal for our use case, since we only ever access the array of values once per named character reference, and only after we&#39;re certain we have a match. So, tightly bitpacking the value array is a viable way to save some extra bytes for our purposes.</p>

<h3>Data size<a id="data-size-2" href="#data-size-2">ðŸ”—</a></h3>
<p>For the DAFSA, the size calculation is pretty straightforward:</p>
<ul>
<li>The data of each node can fit into 4 bytes with a few bits to spare (expand below if you&#39;re interested in the details), and there are 3,872 nodes in the DAFSA, so that&#39;s 15,488 bytes total</li>
</ul>
<details id="nitty-gritty-dafsa-node-size-details">
<summary>Nitty-gritty DAFSA node size details</summary>
<p>Ultimately, the goal is to keep the node size less than or equal to 32 bits while storing the following data on each node:</p>
<ul>
<li>An ASCII character
<ul>
<li>This can technically be represented in 6 bits, since the actual alphabet of characters used in the list of named character references only includes 61 unique characters (&#39;1&#39;...&#39;8&#39;, &#39;;&#39;, &#39;a&#39;...&#39;z&#39;, &#39;A&#39;...&#39;Z&#39;). However, to do so you&#39;d need to convert between the 6 bit representation and the actual ASCII value of each character to do comparisons. We aren&#39;t desperate to save bits, though, so we can get away with representing this value as 8 bits, which makes comparisons with any byte value trivial.</li>
</ul>
</li>
<li>A &#34;count of all possible valid words from that node&#34;
<ul>
<li>Empirically, the highest value within our particular DAFSA for this field is <code>168</code>, which can fit into 8 bits.</li>
</ul>
</li>
<li>An &#34;end of word&#34; flag
<ul>
<li>1 bit</li>
</ul>
</li>
<li>A &#34;last sibling&#34; flag
<ul>
<li>1 bit</li>
</ul>
</li>
<li>An &#34;index of first child&#34; field
<ul>
<li>There are 3,872 nodes in our DAFSA, so all child indexes can fit into 12 bits.</li>
</ul>
</li>
</ul>
<p>In total, that&#39;s 8 + 8 + 1 + 1 + 12 = <span>30 bits</span>, so we have 2 bits to spare while remaining within the 32 bit target size with this representation.</p>
</details>
<ul>
<li>There are 2,231 named character references, and the mapped code points for each of them need either 4 bytes (if using a regular array) or 21 bits (if using a tightly bitpacked array)
<ul>
<li>For the regular array, that&#39;s 8,924 bytes total</li>
<li>For the tightly bitpacked array, that&#39;s 5,857 bytes total</li>
</ul>
</li>
</ul>
<p>So, the DAFSA <em>and</em> the lookup array for the values (together) will use either 24,412 bytes (<span>23.84 KiB</span>) or 21,345 bytes (<span>20.84 KiB</span>) total.</p>
<p>For the trie, there&#39;s slightly more to discuss around data representation before we can get to the data size calculations. It was glossed over in the <em>Trie implementation</em> section, but when using the &#39;flattened&#39; representation of a trie there are effectively two ways to handle value lookups for each word:</p>
<ol>
<li>Store an array of 2,231 values (one for each named character reference) and then also store an index into that array on each end-of-word node.
<ul>
<li>This increases the bit size needed for each node by 12 bits (since 2,231 can be encoded in 12 bits)</li>
</ul>
</li>
<li>Store an array of 9,854 values (one for each node in the trie) and then index into the value array by re-using the index of the end-of-word node.
<ul>
<li>This makes the size of the value array 4.42 times larger, but does not affect the node size</li>
</ul>
</li>
</ol>
<p>Beyond that, the details aren&#39;t <em>super</em> relevant. Suffice it to say that each node will either take up 5 bytes or 3 bytes depending on which of the two &#39;value array&#39; strategies you choose (note: I actually mean 5 bytes and 3 bytes, as they can be represented as one array of 2- or 4-byte values and one array of 1-byte values so padding between elements doesn&#39;t factor in).</p>
<p>The summary is that, depending on the particular representation, the trie will use between 57,993 bytes and 68,777 bytes (<span>56.63 KiB</span> to <span>67.16 KiB</span>) total, or, if the values array is tightly bitpacked, between 54,926 bytes and 55,227 bytes (<span>53.64 KiB</span> to <span>53.93 KiB</span>) total.</p>
<p>Ultimately, the data size of the trie is going to be at least <strong>2x larger</strong> than the equivalent DAFSA.</p>
<h3>Performance<a id="performance-2" href="#performance-2">ðŸ”—</a></h3>
<p>Luckily, there&#39;s <a href="https://github.com/chadwain/rem">an existing HTML parser implementation written in Zig called <code>rem</code></a> that uses a trie for its named character reference tokenization, so getting <a href="https://github.com/chadwain/rem/pull/15">some relevant benchmark results from actual HTML parsing</a> for a trie vs DAFSA comparison was pretty easy.</p>

<p>From <a href="https://gist.github.com/squeek502/07b7dee1086f6e9dc38c4a880addfeca">my benchmarking</a>, it turns out that the DAFSA implementation uses more instructions than the trie implementation because it needs to do extra work to build up the unique index during iteration, but the DAFSA saves on cache misses (presumably due to the smaller overall size of the DAFSA and its node re-use) and everything just about evens out in terms of wall clock time:</p>
<pre><code><span>Benchmark 1</span><span>: ./trie
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>44.4</span><span> </span><span>Â±</span><span> </span><span>1.57</span><span>    </span><span>43.0</span><span> </span><span>â€¦</span><span> </span><span>61.8</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>61.8</span><span> </span><span>Â±</span><span> </span><span>62.5</span><span>    </span><span>61.6</span><span> </span><span>â€¦</span><span> </span><span>61.9</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>49.5</span><span>  </span><span>Â±</span><span>  </span><span>463</span><span>     </span><span>48.5</span><span>  </span><span>â€¦</span><span> </span><span>51.9</span><span>          </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>76.2</span><span>  </span><span>Â±</span><span> </span><span>2.95</span><span>      </span><span>76.2</span><span>  </span><span>â€¦</span><span> </span><span>76.2</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>2.54</span><span>  </span><span>Â±</span><span> </span><span>21.6</span><span>     </span><span>2.48</span><span>  </span><span>â€¦</span><span> </span><span>2.63</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>119</span><span>  </span><span>Â±</span><span> </span><span>1.64</span><span>      </span><span>115</span><span>  </span><span>â€¦</span><span>  </span><span>128</span><span>          </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>322</span><span>  </span><span>Â±</span><span> </span><span>1.02</span><span>      </span><span>319</span><span>  </span><span>â€¦</span><span>  </span><span>328</span><span>          </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./dafsa
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>44.3</span><span> </span><span>Â±</span><span>  </span><span>561</span><span>    </span><span>43.8</span><span> </span><span>â€¦</span><span> </span><span>48.4</span><span>         </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>61.6</span><span> </span><span>Â±</span><span> </span><span>66.6</span><span>    </span><span>61.5</span><span> </span><span>â€¦</span><span> </span><span>61.7</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>53.0</span><span>  </span><span>Â±</span><span>  </span><span>566</span><span>     </span><span>52.3</span><span>  </span><span>â€¦</span><span> </span><span>54.9</span><span>          </span><span>        </span><span>ðŸ’©+  7.0% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>       </span><span>78.7</span><span>  </span><span>Â±</span><span> </span><span>2.59</span><span>      </span><span>78.7</span><span>  </span><span>â€¦</span><span> </span><span>78.7</span><span>           </span><span>        </span><span>ðŸ’©+  3.2% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>2.49</span><span>  </span><span>Â±</span><span> </span><span>30.0</span><span>     </span><span>2.43</span><span>  </span><span>â€¦</span><span> </span><span>2.60</span><span>          </span><span>        </span><span>âš¡-  2.0% Â±  0.1%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>90.9</span><span>  </span><span>Â±</span><span> </span><span>1.32</span><span>     </span><span>86.4</span><span>  </span><span>â€¦</span><span> </span><span>95.4</span><span>          </span><span>        </span><span>âš¡- 23.5% Â±  0.2%
</span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>331</span><span>  </span><span>Â±</span><span>  </span><span>730</span><span>       </span><span>330</span><span>  </span><span>â€¦</span><span>  </span><span>337</span><span>          </span><span>        </span><span>ðŸ’©+  2.9% Â±  0.0%
</span><span></span></code></pre>

<h3>Takeaways<a id="takeaways-2" href="#takeaways-2">ðŸ”—</a></h3>
<p>For the use-case of named character references, using a DAFSA instead of a trie cuts the size of the data <em>at least</em> in half while performing about the same.</p>
<h2>The Ladybird implementation<a id="the-ladybird-implementation" href="#the-ladybird-implementation">ðŸ”—</a></h2>
<p><img src="https://jvns.ca/images/better-named-character-reference-tokenization/ladybird.png"/></p>
<p>First, let&#39;s take a look at what the Ladybird implementation looked like before my changes: <a href="https://github.com/squeek502/ladybird/blob/c49dd2036bad3248a31b319df762d84f9235b7f2/Libraries/LibWeb/HTML/Parser/HTMLTokenizer.cpp#L1699-L1733">state implementation</a>, <a href="https://github.com/squeek502/ladybird/blob/c49dd2036bad3248a31b319df762d84f9235b7f2/Libraries/LibWeb/HTML/Parser/Entities.cpp">matching implementation</a>. Here&#39;s a rough summary of the approach, in pseudo-code:</p>
<pre><code><span>var</span><span> </span><span>match</span><span> </span><span>=</span><span> </span><span>null</span><span>;</span><span>

</span><span>
</span><span>var</span><span> </span><span>remaining_input</span><span> </span><span>=</span><span> </span><span>input</span><span>.</span><span>substring</span><span>(</span><span>current_offset</span><span>,</span><span> </span><span>input</span><span>.</span><span>length</span><span> </span><span>-</span><span> </span><span>current_offset</span><span>);</span><span>

</span><span>
</span><span>for</span><span> </span><span>(</span><span>var</span><span> </span><span>entity</span><span> </span><span>:</span><span> </span><span>entities</span><span>)</span><span> </span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>remaining_input</span><span>.</span><span>starts_with</span><span>(</span><span>entity</span><span>))</span><span> </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>match</span><span> </span><span>==</span><span> </span><span>null</span><span> </span><span>or</span><span> </span><span>entity</span><span>.</span><span>length</span><span> </span><span>&gt;</span><span> </span><span>match</span><span>.</span><span>length</span><span>)</span><span> </span><span>{</span><span>
            </span><span>match</span><span> </span><span>=</span><span> </span><span>entity</span><span>;</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>

</span><span>
</span><span>if</span><span> </span><span>(</span><span>match</span><span> </span><span>!=</span><span> </span><span>null</span><span>)</span><span> </span><span>{</span><span>
    </span><span>
    </span><span>consume_and_advance</span><span>(</span><span>match</span><span>.</span><span>length</span><span> </span><span>-</span><span> </span><span>1</span><span>);</span><span>

    </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This has two major problems:</p>
<ol>
<li>It is inefficient, since the input string is being compared against the entire list of named character references one-at-a-time</li>
<li>It does not handle <code>document.write</code> correctly, as previously discussed in <a href="#the-spectre-of-document-write"><em>The spectre of <code>document.write</code></em></a>. It&#39;s doing lookahead, but it does not account for insertion points, as it makes the mistake of looking <em>past</em> insertion points. So, if <code>document.write</code> is used to write one-character-at-a-time, it will attempt to resolve the named character reference before all the characters are available (e.g. in the case of <code><span id="not-insertion-point-2"></span><span>in;</span></code>, it will erroneously try matching against <code>&amp;in;</code> and then exit the named character reference state)</li>
</ol>

<p><a href="https://github.com/LadybirdBrowser/ladybird/pull/3011">My pull request</a> focused on fixing both of those problems. The data structure I used is exactly the DAFSA implementation as described so far, with a value array that is <em>not</em> bitpacked, because:</p>
<ul>
<li>As we&#39;ve seen, it doesn&#39;t affect performance, so complicating the implementation didn&#39;t seem worth it</li>
<li>Using an <code>enum</code> for the second code point would either mean using an extra bit (since enums are signed integers in C++) or using some workaround to keep it using the minimal number of bits</li>
</ul>
<p>The last piece of the puzzle that I haven&#39;t mentioned yet is the <a href="https://github.com/squeek502/ladybird/blob/ee5e3cb7d48abe2e46bb63e46a975df8520b9b6e/Libraries/LibWeb/HTML/Parser/Entities.h"><code>NamedCharacterReferenceMatcher</code></a>, which handles DAFSA traversal while providing an API well-tailored to the named character reference state, specifically. The details aren&#39;t too important, so here are the relevant bits of the exposed API:</p>
<pre><code><span>
</span><span>
</span><span>
</span><span>bool</span><span> </span><span>try_consume_code_point</span><span>(</span><span>u32</span><span> </span><span>c</span><span>);</span><span>

</span><span>
</span><span>u8</span><span> </span><span>overconsumed_code_points</span><span>();</span><span>

</span><span>
</span><span>Optional</span><span>&lt;</span><span>NamedCharacterReferenceCodepoints</span><span>&gt;</span><span> </span><span>code_points</span><span>();</span><span>
</span></code></pre>
<p>So, with all that context, here&#39;s what the Ladybird implementation looks like after my changes (slightly simplified for clarity; <a href="https://github.com/LadybirdBrowser/ladybird/blob/27ba216e3fd869e0a3bf1d78c3693e5c7993369c/Libraries/LibWeb/HTML/Parser/HTMLTokenizer.cpp#L1696-L1747">here&#39;s the full implementation</a>):</p>
<pre><code><span>BEGIN_STATE</span><span>(</span><span>NamedCharacterReference</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>matcher</span><span>.</span><span>try_consume_code_point</span><span>(</span><span>current_code_point</span><span>))</span><span> </span><span>{</span><span>
        </span><span>temporary_buffer</span><span>.</span><span>append</span><span>(</span><span>current_code_point</span><span>);</span><span>
        </span><span>continue</span><span>;</span><span> </span><span>
    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
        </span><span>DONT_CONSUME_CHARACTER</span><span>;</span><span>
    </span><span>}</span><span>

    </span><span>auto</span><span> </span><span>overconsumed_code_points</span><span> </span><span>=</span><span> </span><span>matcher</span><span>.</span><span>overconsumed_code_points</span><span>();</span><span>
    </span><span>if</span><span> </span><span>(</span><span>overconsumed_code_points</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
        </span><span>backtrack_to</span><span>(</span><span>current_offset</span><span> </span><span>-</span><span> </span><span>overconsumed_code_points</span><span>);</span><span>
        </span><span>temporary_buffer</span><span>.</span><span>shrink_by</span><span>(</span><span>overconsumed_code_points</span><span>);</span><span>
    </span><span>}</span><span>

    </span><span>auto</span><span> </span><span>mapped_code_points</span><span> </span><span>=</span><span> </span><span>matcher</span><span>.</span><span>code_points</span><span>();</span><span>
    </span><span>
    </span><span>if</span><span> </span><span>(</span><span>mapped_code_points</span><span>)</span><span> </span><span>{</span><span>
        </span><span>
    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
        </span><span>FLUSH_CODEPOINTS_CONSUMED_AS_A_CHARACTER_REFERENCE</span><span>;</span><span>
        </span><span>SWITCH_TO</span><span>(</span><span>AmbiguousAmpersand</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Note also that Ladybird follows <a href="https://youtu.be/9YM7pDMLvr4?t=1608">&#39;spec-driven development&#39;</a>, meaning that the goal is for its code to be implemented to match the text of the relevant specification as closely as possible. Here&#39;s what the <a href="https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state"><em>named character reference state</em> specification</a> looks like for reference:</p>
<blockquote>
<p><strong>13.2.5.73 Named character reference state</strong></p>
<p>Consume the maximum number of characters possible, where the consumed characters are one of the identifiers in the first column of the named character references table. Append each character to the temporary buffer when it&#39;s consumed.</p>
<ul>
<li>
<p>If there is a match</p>
<ul>
<li>...</li>
</ul>
</li>
<li>
<p>Otherwise</p>
<ul>
<li>Flush code points consumed as a character reference. Switch to the ambiguous ampersand state.</li>
</ul>
</li>
</ul>
</blockquote>
<p>Overall, these changes made the Ladybird tokenizer:</p>
<ul>
<li>About <span>1.23x faster</span> on <a href="https://github.com/AndreasMadsen/htmlparser-benchmark/tree/master/files">an arbitrary set of HTML files from real websites</a> (albeit an old set of files)</li>
<li>About <span>8x faster</span> on a <em>very</em> named-character-reference-specific benchmark (tokenizing an HTML file with nothing but tens of thousands of valid and invalid named character references)</li>
<li>Roughly <span>95 KiB smaller</span> (very crude estimate, solely judged by the difference in the final binary size)</li>
<li>Handle <code>document.write</code> emitting one-character-at-a-time correctly</li>
</ul>
<p>But that&#39;s all pretty low-hanging fruit, as the previous Ladybird implementation had some obvious problems. In fact, we can actually improve on this some more (and will later on), but I think it&#39;s worth looking at the Firefox/Chrome/Safari implementations now to see how this DAFSA version stacks up against them.</p>
<h2>Comparison to the major browser engines<a id="comparison-to-the-major-browser-engines" href="#comparison-to-the-major-browser-engines">ðŸ”—</a></h2>
<p>Before we get to the actual comparisons, there&#39;s (unfortunately) a lot that has to be discussed.</p>
<p>First, you&#39;ll notice from the Ladybird benchmarks above that an <em>8x improvement</em> in a very named-character-reference-specific benchmark only led to a <em>1.23x improvement</em> in the average case. This points to the fact that named character reference matching is not something that HTML tokenizers typically do very often, and that named character reference matching being <em>fast enough</em> is likely just fine, all things considered.</p>

<p>Second, instead of going the route of putting my DAFSA implementation into the other browsers&#39; engines to compare, I went with taking the other browsers&#39; implementations and putting them into Ladybird. Not only that, though, I also made the Firefox/Chrome/Safari implementations conform to the API of <code>NamedCharacterReferenceMatcher</code> (for reasons that will be discussed soon). So, in order for my benchmarking to be accurate you&#39;ll have to trust that:</p>
<ul>
<li>I faithfully integrated the Firefox/Chrome/Safari implementations into Ladybird</li>
<li>The performance characteristics exhibited would hold when going the other direction (putting my implementation into their tokenizer)</li>
<li>The benchmarks I&#39;m using can actually give useful/meaningful results in the first place</li>
</ul>
<p>For the first point, the only real assurance I can give you is that the same number of <a href="https://wpt.fyi/">web platform tests</a> within the <code>html/syntax/parsing</code> category were passing with each browser&#39;s implementation integrated. The second point will be discussed more later on. For the third point, we have to go on yet another detour...</p>
<h3>On the difficulty of benchmarking<a id="on-the-difficulty-of-benchmarking" href="#on-the-difficulty-of-benchmarking">ðŸ”—</a></h3>
<p>My initial benchmarking setup was straightforward:</p>
<ul>
<li>Have a separate branch of the codebase for each implementation</li>
<li>Compile separate benchmark binaries for each branch</li>
<li>Run each version and compare the results</li>
</ul>
<p>However, this approach ultimately left me with some inexplicable results. Here&#39;s an example of such results, where the benchmark that exclusively tests the relevant parts of the code shows the Blink (Chrome) implementation being slightly faster than mine:</p>
<pre><code><span>Benchmark 1</span><span>: ./TestHTMLTokenizerBlink --bench named_character_references
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>118</span><span> </span><span>Â±</span><span> </span><span>1.68</span><span>     </span><span>115</span><span> </span><span>â€¦</span><span>  </span><span>121</span><span>          </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./TestHTMLTokenizerDafsa --bench named_character_references
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>120</span><span> </span><span>Â±</span><span> </span><span>1.50</span><span>     </span><span>117</span><span> </span><span>â€¦</span><span>  </span><span>123</span><span>          </span><span>        </span><span>ðŸ’©+  2.1% Â±  0.4%
</span><span></span></code></pre>
<p>Yet, when I ran a benchmark that only <em>occasionally</em> exercises the code that I changed (a benchmark using a sample of real HTML files), I got unexpected results. What we <em>should</em> expect is either a very slight difference in the same direction, or (more realistically) no discernible difference, as this effect size should not be noticeable in the average case. Instead, I got <em>the opposite result</em> and <em>a larger effect</em>:</p>
<pre><code><span>Benchmark 1</span><span>: ./TestHTMLTokenizerBlink --bench benchfiles
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.85</span><span>  </span><span>Â±</span><span> </span><span>28.4</span><span>    </span><span>1.79</span><span>  </span><span>â€¦</span><span> </span><span>1.88</span><span>           </span><span>2 (17%)</span><span>        </span><span></span><span>Benchmark 2</span><span>: ./TestHTMLTokenizerDafsa --bench benchfiles
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.79</span><span>  </span><span>Â±</span><span> </span><span>20.7</span><span>    </span><span>1.76</span><span>  </span><span>â€¦</span><span> </span><span>1.84</span><span>           </span><span>        </span><span>âš¡-  3.2% Â±  1.1%
</span><span></span></code></pre>
<p>Taken together, the only explanation for these sorts of results would be that <em>the parts of the code that I <strong>didn&#39;t change</strong> got faster</em> in one version, and not the other.</p>
<h4>The elephant demands attention<a id="the-elephant-demands-attention" href="#the-elephant-demands-attention">ðŸ”—</a></h4>
<p>Well, this explanationâ€”that the code I didn&#39;t change got fasterâ€”is actually likely to be the correct one, and I&#39;ve known about this possibility ever since I watched the excellent talk <a href="https://www.youtube.com/watch?v=r-TLSBdHe1A">&#34;Performance Matters&#34; by Emery Berger</a>. I recommend watching the talk, but the short explanation is that changes to one part of the codebase may inadvertently cause the compiler to reorganize unrelated parts of the compiled binary in ways that affect performance (&#39;layout&#39;).</p>
<p>However, while I was aware of this possible confounder, up until now I have basically ignored it whenever doing benchmarking (and I&#39;m assuming that&#39;s true for most programmers). This is the first time I&#39;ve come face-to-face with the problem and <em>had</em> to reckon with its effects, and I think a large part of that is because I&#39;m dealing with a <em>much</em> larger codebase than I typically would when benchmarking, so there&#39;s a lot of room for inadvertent layout changes to cascade and cause noticeable performance differences.</p>

<h4>Elephant mitigation<a id="elephant-mitigation" href="#elephant-mitigation">ðŸ”—</a></h4>
<p>Unfortunately, the solution presented in the talk (<a href="https://github.com/ccurtsinger/stabilizer">Stabilizer</a>, which allows you to constantly randomize a binary&#39;s layout during runtime to control for layout-based performance differences) has bitrotted and only works with an ancient version of LLVM. So, instead, I thought I&#39;d try a different benchmarking setup to counteract the problem:</p>
<ul>
<li>Only compile one binary, and have it contain the code for all the different named character reference matching implementations</li>
<li>Choose the named character reference matching implementation to use at <em>runtime</em></li>
</ul>
<p>This introduces some dynamic dispatch overhead into the mix which may muddy the results slightly, but, in theory, this should eliminate the effects of layout differences, as whatever the binary layout happens to be, all implementations will share it. In practice, this did indeed work, but introduced another unexplained anomaly that we&#39;ll deal with afterwards. After moving all the implementations into the same binary, I got these results for the &#39;average case&#39; benchmark:</p>

<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizerFiles dafsa
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.78</span><span>  </span><span>Â±</span><span> </span><span>29.8</span><span>    </span><span>1.75</span><span>  </span><span>â€¦</span><span> </span><span>1.87</span><span>           </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>88.7</span><span> </span><span>Â±</span><span> </span><span>59.2</span><span>    </span><span>88.7</span><span> </span><span>â€¦</span><span> </span><span>88.8</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.71</span><span>  </span><span>Â±</span><span>  </span><span>127</span><span>     </span><span>6.62</span><span>  </span><span>â€¦</span><span> </span><span>7.10</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span> </span><span>99.2</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>324</span><span>  </span><span>Â±</span><span> </span><span>2.87</span><span>      </span><span>319</span><span>  </span><span>â€¦</span><span>  </span><span>331</span><span>           </span><span>2 (17%)</span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.2</span><span>  </span><span>Â±</span><span> </span><span>66.4</span><span>     </span><span>10.1</span><span>  </span><span>â€¦</span><span> </span><span>10.3</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>8.69</span><span>  </span><span>Â±</span><span> </span><span>2.99</span><span>     </span><span>7.82</span><span>  </span><span>â€¦</span><span> </span><span>18.2</span><span>           </span><span>        </span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizerFiles blink
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.79</span><span>  </span><span>Â±</span><span> </span><span>24.8</span><span>    </span><span>1.73</span><span>  </span><span>â€¦</span><span> </span><span>1.82</span><span>           </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>89.1</span><span> </span><span>Â±</span><span>  </span><span>234</span><span>    </span><span>89.0</span><span> </span><span>â€¦</span><span> </span><span>89.8</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.70</span><span>  </span><span>Â±</span><span> </span><span>57.7</span><span>     </span><span>6.62</span><span>  </span><span>â€¦</span><span> </span><span>6.79</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span>  </span><span>128</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>325</span><span>  </span><span>Â±</span><span> </span><span>1.90</span><span>      </span><span>321</span><span>  </span><span>â€¦</span><span>  </span><span>328</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.3</span><span>  </span><span>Â±</span><span> </span><span>54.3</span><span>     </span><span>10.2</span><span>  </span><span>â€¦</span><span> </span><span>10.4</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>7.86</span><span>  </span><span>Â±</span><span> </span><span>24.6</span><span>     </span><span>7.79</span><span>  </span><span>â€¦</span><span> </span><span>7.89</span><span>           </span><span>          </span><span></span><span>Benchmark 4</span><span>: ./BenchHTMLTokenizerFiles gecko
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.72</span><span>  </span><span>Â±</span><span> </span><span>9.79</span><span>    </span><span>1.70</span><span>  </span><span>â€¦</span><span> </span><span>1.74</span><span>           </span><span>        </span><span>âš¡-  3.2% Â±  1.1%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>88.8</span><span> </span><span>Â±</span><span> </span><span>83.8</span><span>    </span><span>88.7</span><span> </span><span>â€¦</span><span> </span><span>89.0</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.69</span><span>  </span><span>Â±</span><span> </span><span>41.1</span><span>     </span><span>6.63</span><span>  </span><span>â€¦</span><span> </span><span>6.76</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span> </span><span>72.3</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>323</span><span>  </span><span>Â±</span><span> </span><span>1.53</span><span>      </span><span>320</span><span>  </span><span>â€¦</span><span>  </span><span>325</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.2</span><span>  </span><span>Â±</span><span> </span><span>35.8</span><span>     </span><span>10.1</span><span>  </span><span>â€¦</span><span> </span><span>10.2</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>7.79</span><span>  </span><span>Â±</span><span> </span><span>49.1</span><span>     </span><span>7.76</span><span>  </span><span>â€¦</span><span> </span><span>7.95</span><span>           </span><span>2 (17%)</span><span>          </span><span></span></code></pre>
<p>The remaining Gecko (Firefox) <code>wall_time</code> difference is consistently reproducible, but not readily explainable using the other metrics measured, as there is no significant difference in CPU cycles, instructions, cache usage, etc. After attempting some profiling and trying to use <code>strace</code> to understand the difference, my guess is that this comes down to coincidental allocation patterns being friendlier when choosing the Gecko version.</p>

<p>If we use <code>strace -e %memory -c</code>, the <code>dafsa</code> and <code>blink</code> versions consistently use more <code>brk</code>/<code>mmap</code>/<code>munmap</code> syscalls (especially <code>brk</code>):</p>
<pre><code>Dafsa
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 47.18    0.012463         113       110           brk
 31.90    0.008427         443        19           munmap
 18.25    0.004822           9       508           mmap
  2.66    0.000703           5       134           mprotect
------ ----------- ----------- --------- --------- ----------------
100.00    0.026415          34       771           total

Blink
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 55.95    0.018094         138       131           brk
 28.81    0.009318         490        19           munmap
 12.93    0.004181           8       508           mmap
  2.32    0.000749           5       134           mprotect
------ ----------- ----------- --------- --------- ----------------
100.00    0.032342          40       792           total
</code></pre>
<p>The Gecko version, even though it uses roughly the same amount of memory overall, consistently has fewer of these syscalls:</p>
<pre><code>Gecko
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 37.07    0.006560         385        17           munmap
 31.73    0.005615          75        74           brk
 26.50    0.004689           9       506           mmap
  4.70    0.000831           6       134           mprotect
------ ----------- ----------- --------- --------- ----------------
100.00    0.017695          24       731           total
</code></pre>
<p>I don&#39;t know enough about the <code>glibc</code>/<code>libstdc++</code> allocator implementation(s) to know why this would be the case, and the magnitude of the difference reported by <code>strace</code> doesn&#39;t seem large enough to explain the results, but I&#39;m at least a little bit confident that this <em>is</em> the cause, since, after inserting padding to each <code>NamedCharacterReferenceMatcher</code> subclass to ensure they are all the same size, the <code>wall_time</code> difference went away:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizerFiles dafsa
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.81</span><span>  </span><span>Â±</span><span> </span><span>29.8</span><span>    </span><span>1.73</span><span>  </span><span>â€¦</span><span> </span><span>1.85</span><span>           </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>89.7</span><span> </span><span>Â±</span><span>  </span><span>203</span><span>    </span><span>89.5</span><span> </span><span>â€¦</span><span> </span><span>90.3</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.74</span><span>  </span><span>Â±</span><span> </span><span>58.0</span><span>     </span><span>6.68</span><span>  </span><span>â€¦</span><span> </span><span>6.87</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span>  </span><span>142</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>322</span><span>  </span><span>Â±</span><span> </span><span>2.45</span><span>      </span><span>316</span><span>  </span><span>â€¦</span><span>  </span><span>325</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.2</span><span>  </span><span>Â±</span><span> </span><span>25.1</span><span>     </span><span>10.1</span><span>  </span><span>â€¦</span><span> </span><span>10.2</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>7.84</span><span>  </span><span>Â±</span><span> </span><span>26.1</span><span>     </span><span>7.77</span><span>  </span><span>â€¦</span><span> </span><span>7.87</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizerFiles blink
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.80</span><span>  </span><span>Â±</span><span> </span><span>23.0</span><span>    </span><span>1.74</span><span>  </span><span>â€¦</span><span> </span><span>1.83</span><span>           </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>89.6</span><span> </span><span>Â±</span><span>  </span><span>205</span><span>    </span><span>89.2</span><span> </span><span>â€¦</span><span> </span><span>90.1</span><span>          </span><span>2 (17%)</span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.74</span><span>  </span><span>Â±</span><span> </span><span>37.0</span><span>     </span><span>6.68</span><span>  </span><span>â€¦</span><span> </span><span>6.82</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span>  </span><span>194</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>321</span><span>  </span><span>Â±</span><span> </span><span>1.93</span><span>      </span><span>317</span><span>  </span><span>â€¦</span><span>  </span><span>324</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.3</span><span>  </span><span>Â±</span><span> </span><span>47.5</span><span>     </span><span>10.2</span><span>  </span><span>â€¦</span><span> </span><span>10.3</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>7.87</span><span>  </span><span>Â±</span><span> </span><span>23.3</span><span>     </span><span>7.82</span><span>  </span><span>â€¦</span><span> </span><span>7.91</span><span>           </span><span>          </span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizerFiles gecko
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.80</span><span>  </span><span>Â±</span><span> </span><span>29.0</span><span>    </span><span>1.71</span><span>  </span><span>â€¦</span><span> </span><span>1.82</span><span>           </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>89.7</span><span> </span><span>Â±</span><span>  </span><span>265</span><span>    </span><span>89.5</span><span> </span><span>â€¦</span><span> </span><span>90.5</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>6.73</span><span>  </span><span>Â±</span><span> </span><span>43.3</span><span>     </span><span>6.65</span><span>  </span><span>â€¦</span><span> </span><span>6.78</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>       </span><span>16.1</span><span>  </span><span>Â±</span><span>  </span><span>156</span><span>     </span><span>16.1</span><span>  </span><span>â€¦</span><span> </span><span>16.1</span><span>           </span><span>2 (17%)</span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>321</span><span>  </span><span>Â±</span><span> </span><span>3.29</span><span>      </span><span>316</span><span>  </span><span>â€¦</span><span>  </span><span>329</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>10.2</span><span>  </span><span>Â±</span><span> </span><span>52.9</span><span>     </span><span>10.1</span><span>  </span><span>â€¦</span><span> </span><span>10.2</span><span>           </span><span>2 (17%)</span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>7.83</span><span>  </span><span>Â±</span><span> </span><span>22.2</span><span>     </span><span>7.76</span><span>  </span><span>â€¦</span><span> </span><span>7.86</span><span>           </span><span>2 (17%)</span><span>          </span><span></span></code></pre>
<p>No meaningful differences across the board, which is what we expect. What this (tentatively) means is that heap allocation is another potential confounder, and that something as inconsequential as a single allocation being a different size (in our case the <code>NamedCharacterReferenceMatcher</code> instance) may have knock-on effects that last for the rest of the program (or I&#39;m wrong about the cause and this is a red herring).</p>

<p>Consequently, this means that I won&#39;t bother with the &#39;average case&#39; benchmarking moving forward. In other words, spoiler alert: nothing in this article will move the needle on this &#39;average case&#39; benchmark.</p>
<h3>Side note: conforming to one API<a id="side-note-conforming-to-one-api" href="#side-note-conforming-to-one-api">ðŸ”—</a></h3>
<p>Something worth mentioning here is that I&#39;ve made the choice to convert the Firefox/Chrome/Safari implementations to conform to the <code>NamedCharacterReferenceMatcher</code> API used by Ladybird (instead of porting the full named character reference tokenizer state implementation from the other browsers&#39; into Ladybird). This was done for two reasons:</p>
<ul>
<li>First, to rule out differences in the tokenizer state implementation itself (tangential to the matching strategy) affecting the matching speed. This might seem strange now, but the logic behind this will be discussed in detail later.</li>
<li>Second, it made it so compiling one binary that can switch between all the different implementations at runtime (for the purposes of removing the confounding effect of layout differences) was very convenient.</li>
</ul>
<p>I&#39;m mentioning this now because it means that I&#39;ve introduced another possible source of error into my benchmarks; the Firefox/Chrome/Safari implementations that I&#39;m testing are <em>not</em> 1:1 ports, as they had to be transformed to conform to the <code>NamedCharacterReferenceMatcher</code> API (Firefox much more than Chrome/Safari).</p>

<h3>Lessons learned<a id="lessons-learned" href="#lessons-learned">ðŸ”—</a></h3>
<p>I think the big takeaway here is that there is a <em>lot</em> that can go wrong when benchmarking.</p>
<p>Aside from the more esoteric stuff mentioned above, there are also countless simple/dumb mistakes that can be made that can completely ruin a benchmark&#39;s integrity. As an example, for a good while when writing this article, I accidentally left a loop in the Chrome version that I only put there for debugging purposes. That loop was just eating CPU cycles for no reason and skewed my benchmark results pretty significantly. Luckily, I found and fixed that particular mistake, but that sort of thing could have easily gone unnoticed and caused me to draw totally invalid conclusions. Beyond that, there&#39;s other stuff I haven&#39;t mentioned like CPU architecture, compiler flags, etc, etc, etc.</p>
<p>What I&#39;m really trying to get across is something like:</p>
<ul>
<li>You should definitely be skeptical of the benchmarking results I&#39;m providing throughout this article.</li>
<li>You might want to be skeptical of <em>all</em> benchmarking results, generally.</li>
</ul>
<p>With all that out of the way, let&#39;s get into it.</p>
<h3>Comparison with Gecko (Firefox)<a id="comparison-with-gecko-firefox" href="#comparison-with-gecko-firefox">ðŸ”—</a></h3>
<p><img src="https://jvns.ca/images/better-named-character-reference-tokenization/firefox.svg"/></p>
<p>The current implementation of named character reference tokenization in the Gecko engine (Firefox&#39;s browser engine) <a href="https://github.com/validator/htmlparser/commit/531dbda0a10b6b7c55cb1f054777c8c5e6f61fec">was introduced in 2010</a>, and refined during the rest of 2010. It has <a href="https://github.com/validator/htmlparser/commits/master/translator-src/nu/validator/htmlparser/generator/GenerateNamedCharactersCpp.java">remained unchanged since then</a>.</p>

<p>It does not use any form of a trie, but instead uses a number of arrays (48 in total) to progressively narrow down the possible candidates within the set of named character references until there&#39;s no more possible candidates remaining. Here&#39;s an overview:</p>
<ul>
<li>The first character is checked to ensure that it is within the <code>a-z</code> or <code>A-Z</code> range and the first character is saved [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2036-L2039">src</a>]</li>
</ul>

<ul>
<li>The second character is then used as an index into a <code>HILO_ACCEL</code> array in order to get the &#39;row&#39; to use for the first character (there are 44 possible rows; the second character is also always within <code>a-z</code> and <code>A-Z</code>, but there happens to be 8 missing characters from the <code>A-Z</code> range) [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2072-L2073">src</a>]</li>
<li>If a valid row exists, the first character is then transformed into an index between <code>0</code> and <code>51</code> (inclusive) and that is used as an index into the &#39;row&#39; that was retrieved from the second character [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2074-L2076">src</a>]</li>
<li>The value obtained by the combination of the first two characters contains a 32-bit number:
<ul>
<li>The &#34;lo&#34; bits (the least significant 16 bits) gives you an index into the <code>NAMES</code> array starting at the first possible matching name [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2094">src</a>]</li>
<li>The &#34;hi&#34; bits (the most significant 16 bits) gives you an index into the <code>NAMES</code> array starting at the last possible matching name [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2095">src</a>]</li>
</ul>
</li>
<li>The values in the <code>NAMES</code> array are <code>struct</code>&#39;s that contain two pieces of information [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5NamedCharacters.h#L31-L39">src</a>]:
<ul>
<li>An index to the start of the remaining characters in the name, within the <code>ALL_NAMES</code> array (an array of bytes)</li>
<li>The length of the remaining characters in the name</li>
</ul>
</li>
<li>The &#34;lo&#34; and &#34;hi&#34; indexes are then incremented/decremented as candidates get ruled out, while taking note of any fully matching candidates. This happens until there are no possible candidates left (<code>hi &lt; lo</code> or <code>;</code> is seen). [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2111-L2158">src</a>]</li>
<li>The most recently matching candidate&#39;s index (if any) is then re-used to look up the mapped code point(s) within the <code>VALUES</code> array (the <code>NAMES</code> and <code>VALUES</code> arrays are the same length) [<a href="https://github.com/mozilla-firefox/firefox/blob/1f3f57e2c0f0f0a8cfaf532c9b63f722135e83b8/parser/html/nsHtml5Tokenizer.cpp#L2173-L2174">src</a>]</li>
</ul>
<p>In the very likely scenario that the above description is hard to take in, here&#39;s my best attempt at visually illustrating how it works, matching against the valid named character reference <code>&amp;notinvc;</code>:</p>
<div id="gecko-explanation">
  <p><code><b>n</b>otinvc;</code>
    <code>^</code>
  </p>
  <p><span>â˜‘</span> the first character (<code>n</code>) is within the <code>a-z</code> or <code>A-Z</code> range</p>
  <p><code>n<b>o</b>tinvc;</code>
    <code> ^</code>
  </p>
  <p>Use the second character (<code>o</code>) to get the array to use with the first character (<code>n</code>)</p>
  <div>
  <table>
    <thead>
      <tr>
        <th colspan="3">
          <code><b>HILO_ACCEL</b></code>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td><code>&#39;\x00&#39;</code></td>
        <td>N/A</td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>65</td>
        <td><code>&#39;A&#39;</code></td>
        <td><code>HILO_ACCEL_65</code></td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>110</td>
        <td><code>&#39;n&#39;</code></td>
        <td><code>HILO_ACCEL_110</code></td>
      </tr>
      <tr>
        <td>111</td>
        <td><code>&#39;o&#39;</code></td>
        <td>
          
          <code>HILO_ACCEL_111</code>
        </td>
      </tr>
      <tr>
        <td>110</td>
        <td><code>&#39;p&#39;</code></td>
        <td><code>HILO_ACCEL_112</code></td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>122</td>
        <td><code>&#39;z&#39;</code></td>
        <td><code>HILO_ACCEL_122</code></td>
      </tr>
    </tbody>
  </table>
  
  <table>
    <thead>
      <tr>
        <th colspan="3">
          
          <code><b>HILO_ACCEL_111</b></code>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td><code>&#39;A&#39;</code></td>
        <td><code>0x<span>0011</span><span>0010</span></code></td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>25</td>
        <td><code>&#39;Z&#39;</code></td>
        <td>...</td>
      </tr>
      <tr>
        <td>26</td>
        <td><code>&#39;a&#39;</code></td>
        <td>...</td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>
          
          39
        </td>
        <td><code>&#39;n&#39;</code></td>
        <td>
          
          <code>0x<span>0602</span><span>05F6</span></code>
        </td>
      </tr>
      <tr>
        <td colspan="3">...</td>
      </tr>
      <tr>
        <td>51</td>
        <td><code>&#39;z&#39;</code></td>
        <td><code title="there&#39;s only 1 named character reference that starts with &#39;z&#39; and then &#39;o&#39; (&amp;zopf;)">0x<span>08B3</span><span>08B3</span></code></td>
      </tr>
    </tbody>
  </table>
</div>
<div>
  <p><code>0x<span>0602</span><span>05F6</span></code></p>
  <p>Â Â  â†™ Â Â Â Â  â†˜</p>
  <p><code>hi</code></p>
  <p><code>lo</code></p>
  <p><code>0x<span>0602</span></code> or 1538</p>
  <p><code>0x<span>05F6</span></code> or 1526</p>
</div>
<p>Any possible matches must be between indexes 1526 and 1538 (inclusive)</p>
<p>The possible matches are:</p>
<div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1526</td>
      <td><code>pf;</code></td>
    </tr>
    <tr>
      <td>1527</td>
      <td><code>t</code></td>
    </tr>
    <tr>
      <td>1528</td>
      <td><code>t;</code></td>
    </tr>
    <tr>
      <td>1529</td>
      <td><code>tin;</code></td>
    </tr>
    <tr>
      <td>1530</td>
      <td><code>tinE;</code></td>
    </tr>
    <tr>
      <td>1531</td>
      <td><code>tindot;</code></td>
    </tr>
    <tr>
      <td>1532</td>
      <td><code>tinva;</code></td>
    </tr>
    <tr>
      <td>1533</td>
      <td><code>tinvb;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code>tinvc;</code></td>
    </tr>
    <tr>
      <td>1535</td>
      <td><code>tni;</code></td>
    </tr>
    <tr>
      <td>1536</td>
      <td><code>tniva;</code></td>
    </tr>
    <tr>
      <td>1537</td>
      <td><code>tnivb;</code></td>
    </tr>
    <tr>
      <td>1538</td>
      <td><code>tnivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
<p>Now we start to narrow those possibilities down:</p>
  
<div id="gecko-t">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td>1527</td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td>1528</td>
      <td><code><span>t</span>;</code></td>
    </tr>
    <tr>
      <td>1529</td>
      <td><code><span>t</span>in;</code></td>
    </tr>
    <tr>
      <td>1530</td>
      <td><code><span>t</span>inE;</code></td>
    </tr>
    <tr>
      <td>1531</td>
      <td><code><span>t</span>indot;</code></td>
    </tr>
    <tr>
      <td>1532</td>
      <td><code><span>t</span>inva;</code></td>
    </tr>
    <tr>
      <td>1533</td>
      <td><code><span>t</span>invb;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>t</span>invc;</code></td>
    </tr>
    <tr>
      <td>1535</td>
      <td><code><span>t</span>ni;</code></td>
    </tr>
    <tr>
      <td>1536</td>
      <td><code><span>t</span>niva;</code></td>
    </tr>
    <tr>
      <td>1537</td>
      <td><code><span>t</span>nivb;</code></td>
    </tr>
    <tr>
      <td>1538</td>
      <td><code><span>t</span>nivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div id="gecko-i">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td><s>1527</s></td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td><s>1528</s></td>
      <td><code><span>t</span><span>;</span></code></td>
    </tr>
    <tr>
      <td>1529</td>
      <td><code><span>ti</span>n;</code></td>
    </tr>
    <tr>
      <td>1530</td>
      <td><code><span>ti</span>nE;</code></td>
    </tr>
    <tr>
      <td>1531</td>
      <td><code><span>ti</span>ndot;</code></td>
    </tr>
    <tr>
      <td>1532</td>
      <td><code><span>ti</span>nva;</code></td>
    </tr>
    <tr>
      <td>1533</td>
      <td><code><span>ti</span>nvb;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>ti</span>nvc;</code></td>
    </tr>
    <tr>
      <td><s>1535</s></td>
      <td><code><span>t</span><span>n</span>i;</code></td>
    </tr>
    <tr>
      <td><s>1536</s></td>
      <td><code><span>t</span><span>n</span>iva;</code></td>
    </tr>
    <tr>
      <td><s>1537</s></td>
      <td><code><span>t</span><span>n</span>ivb;</code></td>
    </tr>
    <tr>
      <td><s>1538</s></td>
      <td><code><span>t</span><span>n</span>ivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div id="gecko-n">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td><s>1527</s></td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td><s>1528</s></td>
      <td><code><span>t</span><span>;</span></code></td>
    </tr>
    <tr>
      <td>1529</td>
      <td><code><span>tin</span>;</code></td>
    </tr>
    <tr>
      <td>1530</td>
      <td><code><span>tin</span>E;</code></td>
    </tr>
    <tr>
      <td>1531</td>
      <td><code><span>tin</span>dot;</code></td>
    </tr>
    <tr>
      <td>1532</td>
      <td><code><span>tin</span>va;</code></td>
    </tr>
    <tr>
      <td>1533</td>
      <td><code><span>tin</span>vb;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>tin</span>vc;</code></td>
    </tr>
    <tr>
      <td><s>1535</s></td>
      <td><code><span>t</span><span>n</span>i;</code></td>
    </tr>
    <tr>
      <td><s>1536</s></td>
      <td><code><span>t</span><span>n</span>iva;</code></td>
    </tr>
    <tr>
      <td><s>1537</s></td>
      <td><code><span>t</span><span>n</span>ivb;</code></td>
    </tr>
    <tr>
      <td><s>1538</s></td>
      <td><code><span>t</span><span>n</span>ivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div id="gecko-v">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td><s>1527</s></td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td><s>1528</s></td>
      <td><code><span>t</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1529</s></td>
      <td><code><span>tin</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1530</s></td>
      <td><code><span>tin</span><span>E</span>;</code></td>
    </tr>
    <tr>
      <td><s>1531</s></td>
      <td><code><span>tin</span><span>d</span>ot;</code></td>
    </tr>
    <tr>
      <td>1532</td>
      <td><code><span>tinv</span>a;</code></td>
    </tr>
    <tr>
      <td>1533</td>
      <td><code><span>tinv</span>b;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>tinv</span>c;</code></td>
    </tr>
    <tr>
      <td><s>1535</s></td>
      <td><code><span>t</span><span>n</span>i;</code></td>
    </tr>
    <tr>
      <td><s>1536</s></td>
      <td><code><span>t</span><span>n</span>iva;</code></td>
    </tr>
    <tr>
      <td><s>1537</s></td>
      <td><code><span>t</span><span>n</span>ivb;</code></td>
    </tr>
    <tr>
      <td><s>1538</s></td>
      <td><code><span>t</span><span>n</span>ivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div id="gecko-c">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td><s>1527</s></td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td><s>1528</s></td>
      <td><code><span>t</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1529</s></td>
      <td><code><span>tin</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1530</s></td>
      <td><code><span>tin</span><span>E</span>;</code></td>
    </tr>
    <tr>
      <td><s>1531</s></td>
      <td><code><span>tin</span><span>d</span>ot;</code></td>
    </tr>
    <tr>
      <td><s>1532</s></td>
      <td><code><span>tinv</span><span>a</span>;</code></td>
    </tr>
    <tr>
      <td><s>1533</s></td>
      <td><code><span>tinv</span><span>b</span>;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>tinvc</span>;</code></td>
    </tr>
    <tr>
      <td><s>1535</s></td>
      <td><code><span>t</span><span>n</span>i;</code></td>
    </tr>
    <tr>
      <td><s>1536</s></td>
      <td><code><span>t</span><span>n</span>iva;</code></td>
    </tr>
    <tr>
      <td><s>1537</s></td>
      <td><code><span>t</span><span>n</span>ivb;</code></td>
    </tr>
    <tr>
      <td><s>1538</s></td>
      <td><code><span>t</span><span>n</span>ivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>
<div id="gecko-semicolon">

<p><a href="#" id="next-char">âž¤</a>
<a href="#" id="prev-char">â®œ</a></p><div>
<table>
  <thead>
    <tr>
      <th colspan="2">
        <code><b>NAMES</b></code>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><s>1526</s></td>
      <td><code><span>p</span>f;</code></td>
    </tr>
    <tr>
      <td><s>1527</s></td>
      <td><code><span>t</span></code></td>
    </tr>
    <tr>
      <td><s>1528</s></td>
      <td><code><span>t</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1529</s></td>
      <td><code><span>tin</span><span>;</span></code></td>
    </tr>
    <tr>
      <td><s>1530</s></td>
      <td><code><span>tin</span><span>E</span>;</code></td>
    </tr>
    <tr>
      <td><s>1531</s></td>
      <td><code><span>tin</span><span>d</span>ot;</code></td>
    </tr>
    <tr>
      <td><s>1532</s></td>
      <td><code><span>tinv</span><span>a</span>;</code></td>
    </tr>
    <tr>
      <td><s>1533</s></td>
      <td><code><span>tinv</span><span>b</span>;</code></td>
    </tr>
    <tr>
      <td>1534</td>
      <td><code><span>tinvc;</span></code></td>
    </tr>
    <tr>
      <td><s>1535</s></td>
      <td><code><span>t</span><span>n</span>i;</code></td>
    </tr>
    <tr>
      <td><s>1536</s></td>
      <td><code><span>t</span><span>n</span>iva;</code></td>
    </tr>
    <tr>
      <td><s>1537</s></td>
      <td><code><span>t</span><span>n</span>ivb;</code></td>
    </tr>
    <tr>
      <td><s>1538</s></td>
      <td><code><span>t</span><span>n</span>ivc;</code></td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>
<p>I&#39;m glossing over how <em>exactly</em> the possibilities are narrowed down because it&#39;s not super relevant (if you&#39;re interested, <a href="https://github.com/mozilla-firefox/firefox/blob/ec7f9e0771ff44a5d22cfa26f4a819b739ef027b/parser/html/nsHtml5Tokenizer.cpp#L2036-L2233">here&#39;s the responsible tokenizer code</a>), but I will note that the &#39;lo&#39; and &#39;hi&#39; cursors always move linearly (i.e. each possible match is ruled out one-by-one; there&#39;s no binary search or anything like that going on).</p>
<p>This approach works well because the first two characters alone fairly reliably narrow down the possibilities to a pretty small range. Out of 2288 possible combinations of the first two characters, 1658 of them (72.5%) lead to zero possible matches. Out of the remaining combinations (those with â‰¥ 1 possible match), the mean number of matches is 3.54 with a standard deviation of 29.8, and the median number of possible matches is 2. Here&#39;s what the full distribution looks like (with the combinations that lead to zero matches included):</p>
<p>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%;" style="overflow:hidden;max-width:600px" viewBox="30 100 525 325" aria-label="A chart." id="gecko-freq-chart"><defs id="_ABSTRACT_RENDERER_ID_1864"><clipPath id="_ABSTRACT_RENDERER_ID_1865"><rect x="127" y="83" width="412" height="268"></rect></clipPath></defs><rect x="0" y="0" width="666.6666666666664" height="433.33333333333337" stroke="none" stroke-width="0" fill="transparent"></rect><g><rect x="127" y="83" width="412" height="268" stroke="none" stroke-width="0" fill-opacity="0" fill="#ffffff"></rect><g clip-path="url(#_ABSTRACT_RENDERER_ID_1865)"><g><rect x="127" y="350" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="283" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="217" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="150" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="317" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="250" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="183" width="412" height="1" stroke="none" stroke-width="0"></rect><rect x="127" y="116" width="412" height="1" stroke="none" stroke-width="0"></rect></g><g><rect x="128.5" y="130" width="4" height="220" stroke="none" stroke-width="0"></rect><rect x="136.5" y="315" width="4" height="35" stroke="none" stroke-width="0"></rect><rect x="143.5" y="332" width="4" height="18" stroke="none" stroke-width="0"></rect><rect x="150.5" y="343" width="4" height="7" stroke="none" stroke-width="0"></rect><rect x="158.5" y="345" width="4" height="5" stroke="none" stroke-width="0"></rect><rect x="165.5" y="347.83000000000004" width="4" height="2.669999999999959" stroke="none" stroke-width="0"></rect><rect x="172.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="180.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="187.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="194.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="202.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="209.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="216.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="224.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="231.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="238.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="246.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="253.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="261.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="268.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="275.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="283.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="290.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="297.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="305.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="312.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="319.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="327.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="334.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="341.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="349.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="356.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="363.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect><rect x="371.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="378.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="385.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="393.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="400.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="407.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="415.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="422.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="429.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="437.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="444.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="451.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="459.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="466.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="473.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="481.5" y="349" width="4" height="1" stroke="none" stroke-width="0"></rect><rect x="488.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="495.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="503.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="510.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="517.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="525.5" y="350" width="4" height="0" stroke="none" stroke-width="0"></rect><rect x="532.5" y="348" width="4" height="2" stroke="none" stroke-width="0"></rect></g><g><rect x="127" y="350" width="412" height="1" stroke="none" stroke-width="0"></rect></g></g><g></g><g><g><text text-anchor="end" x="133.44464285714287" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 133.44464285714287 369.4404155872192)" stroke="none" stroke-width="0">0</text></g><g><text text-anchor="end" x="170.14107142857145" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 170.14107142857145 369.4404155872192)" stroke="none" stroke-width="0">5</text></g><g><text text-anchor="end" x="206.8375" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 206.8375 369.4404155872192)" stroke="none" stroke-width="0">10</text></g><g><text text-anchor="end" x="243.53392857142856" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 243.53392857142856 369.4404155872192)" stroke="none" stroke-width="0">15</text></g><g><text text-anchor="end" x="280.2303571428571" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 280.2303571428571 369.4404155872192)" stroke="none" stroke-width="0">20</text></g><g><text text-anchor="end" x="316.9267857142857" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 316.9267857142857 369.4404155872192)" stroke="none" stroke-width="0">25</text></g><g><text text-anchor="end" x="353.62321428571425" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 353.62321428571425 369.4404155872192)" stroke="none" stroke-width="0">30</text></g><g><text text-anchor="end" x="390.31964285714287" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 390.31964285714287 369.4404155872192)" stroke="none" stroke-width="0">35</text></g><g><text text-anchor="end" x="427.0160714285714" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 427.0160714285714 369.4404155872192)" stroke="none" stroke-width="0">40</text></g><g><text text-anchor="end" x="463.7125" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 463.7125 369.4404155872192)" stroke="none" stroke-width="0">45</text></g><g><text text-anchor="end" x="500.40892857142853" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 500.40892857142853 369.4404155872192)" stroke="none" stroke-width="0">50</text></g><g><text text-anchor="end" x="537.1053571428571" y="369.4404155872192" font-family="Arial" font-size="13" transform="rotate(-30 537.1053571428571 369.4404155872192)" stroke="none" stroke-width="0">55</text></g><g><text text-anchor="end" x="114" y="355.05" font-family="Arial" font-size="13" stroke="none" stroke-width="0">0</text></g><g><text text-anchor="end" x="114" y="288.3" font-family="Arial" font-size="13" stroke="none" stroke-width="0">500</text></g><g><text text-anchor="end" x="114" y="221.55" font-family="Arial" font-size="13" stroke="none" stroke-width="0">1,000</text></g><g><text text-anchor="end" x="114" y="154.8" font-family="Arial" font-size="13" stroke="none" stroke-width="0">1,500</text></g></g></g><g><g><text text-anchor="middle" x="333" y="410.2166666666667" font-family="Arial" font-size="13" font-style="italic" stroke="none" stroke-width="0">Number of possible matches after the first two characters</text></g><g><text text-anchor="middle" x="30.05" y="217" font-family="Arial" font-size="13" font-style="italic" transform="rotate(-90 45.05 217)" stroke="none" stroke-width="0">Frequency</text></g></g><g></g></svg>

</p>

<p>Now that we have an understanding of how the Firefox implementation works, let&#39;s see how it compares using the three metrics that were mentioned at the start.</p>
<h4>Performance<a id="performance-3" href="#performance-3">ðŸ”—</a></h4>
<p>Performance between the Firefox version and the Ladybird DAFSA version is basically a wash in the primary benchmark I&#39;m using (<a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Tests/LibWeb/BenchHTMLTokenizer.cpp#L10">tokenizing a file with tens of thousands of valid and invalid named character references</a>):</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer gecko
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>113</span><span> </span><span>Â±</span><span> </span><span>1.12</span><span>     </span><span>111</span><span> </span><span>â€¦</span><span>  </span><span>115</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.4</span><span> </span><span>Â±</span><span> </span><span>93.7</span><span>    </span><span>83.0</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>226</span><span>  </span><span>Â±</span><span>  </span><span>877</span><span>      </span><span>224</span><span>  </span><span>â€¦</span><span>  </span><span>230</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>438</span><span>  </span><span>Â±</span><span> </span><span>10.6</span><span>      </span><span>438</span><span>  </span><span>â€¦</span><span>  </span><span>438</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.54</span><span>  </span><span>Â±</span><span>  </span><span>130</span><span>     </span><span>9.40</span><span>  </span><span>â€¦</span><span> </span><span>10.5</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>427</span><span>  </span><span>Â±</span><span> </span><span>11.1</span><span>      </span><span>406</span><span>  </span><span>â€¦</span><span>  </span><span>458</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>578</span><span>  </span><span>Â±</span><span> </span><span>1.79</span><span>      </span><span>575</span><span>  </span><span>â€¦</span><span>  </span><span>585</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>114</span><span> </span><span>Â±</span><span> </span><span>1.38</span><span>     </span><span>110</span><span> </span><span>â€¦</span><span>  </span><span>116</span><span>          </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.3</span><span> </span><span>Â±</span><span> </span><span>94.6</span><span>    </span><span>83.0</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>229</span><span>  </span><span>Â±</span><span>  </span><span>856</span><span>      </span><span>227</span><span>  </span><span>â€¦</span><span>  </span><span>232</span><span>           </span><span>        </span><span>ðŸ’©+  1.4% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>450</span><span>  </span><span>Â±</span><span> </span><span>10.4</span><span>      </span><span>450</span><span>  </span><span>â€¦</span><span>  </span><span>450</span><span>           </span><span>        </span><span>ðŸ’©+  2.7% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.42</span><span>  </span><span>Â±</span><span>  </span><span>128</span><span>     </span><span>9.25</span><span>  </span><span>â€¦</span><span> </span><span>10.5</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>418</span><span>  </span><span>Â±</span><span> </span><span>9.03</span><span>      </span><span>400</span><span>  </span><span>â€¦</span><span>  </span><span>443</span><span>           </span><span>        </span><span>âš¡-  2.0% Â±  0.7%
</span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>575</span><span>  </span><span>Â±</span><span> </span><span>3.01</span><span>      </span><span>570</span><span>  </span><span>â€¦</span><span>  </span><span>600</span><span>           </span><span>          </span><span></span></code></pre>
<p>However, if we tailor some benchmarks to test the scenarios where each should theoretically perform the worst, we can see some clearer differences.</p>
<p>I believe the worst case for the Firefox implementation is successfully matching the named character reference <code>&amp;supsetneqq;</code>. As mentioned earlier, <code>su</code> as the first two characters narrows down the possibilities the least, with 55 remaining possibilities, and <code>&amp;supsetneqq;</code> should take the longest to match out of the remaining possibilities.</p>
<p>Here are the results for <a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Tests/LibWeb/BenchHTMLTokenizer.cpp#L12">tokenizing a file with nothing but 30,000 <code>&amp;supsetneqq;</code> sequences in a row</a>:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer gecko gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>50.6</span><span> </span><span>Â±</span><span> </span><span>1.11</span><span>    </span><span>48.3</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>85.4</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>137</span><span>  </span><span>Â±</span><span>  </span><span>816</span><span>      </span><span>135</span><span>  </span><span>â€¦</span><span>  </span><span>140</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>278</span><span>  </span><span>Â±</span><span> </span><span>9.06</span><span>      </span><span>278</span><span>  </span><span>â€¦</span><span>  </span><span>278</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.27</span><span>  </span><span>Â±</span><span> </span><span>58.4</span><span>     </span><span>3.13</span><span>  </span><span>â€¦</span><span> </span><span>3.55</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>361</span><span>  </span><span>Â±</span><span> </span><span>10.0</span><span>      </span><span>342</span><span>  </span><span>â€¦</span><span>  </span><span>396</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>314</span><span>  </span><span>Â±</span><span> </span><span>5.29</span><span>      </span><span>306</span><span>  </span><span>â€¦</span><span>  </span><span>335</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>45.9</span><span> </span><span>Â±</span><span>  </span><span>805</span><span>    </span><span>43.6</span><span> </span><span>â€¦</span><span> </span><span>47.5</span><span>         </span><span>22 (10%)</span><span>        </span><span>âš¡-  9.3% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>83.9</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>117</span><span>  </span><span>Â±</span><span>  </span><span>635</span><span>      </span><span>116</span><span>  </span><span>â€¦</span><span>  </span><span>119</span><span>           </span><span>        </span><span>âš¡- 14.5% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>259</span><span>  </span><span>Â±</span><span> </span><span>5.16</span><span>      </span><span>259</span><span>  </span><span>â€¦</span><span>  </span><span>259</span><span>           </span><span>        </span><span>âš¡-  7.0% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.27</span><span>  </span><span>Â±</span><span>  </span><span>128</span><span>     </span><span>3.15</span><span>  </span><span>â€¦</span><span> </span><span>4.10</span><span>          </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>357</span><span>  </span><span>Â±</span><span> </span><span>7.06</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>384</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>183</span><span>  </span><span>Â±</span><span> </span><span>1.95</span><span>      </span><span>179</span><span>  </span><span>â€¦</span><span>  </span><span>193</span><span>          </span><span>21 (10%)</span><span>        </span><span>âš¡- 41.8% Â±  0.2%
</span><span></span></code></pre>
<p>On the flipside, the scenario where the Firefox implementation likely outperforms the Ladybird implementation the most is an invalid named character reference that can be rejected from the first two characters alone (I&#39;ve arbitrarily chosen <code>&amp;cz</code>).</p>
<p>Here are the results for <a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Tests/LibWeb/BenchHTMLTokenizer.cpp#L13">tokenizing a file with nothing but 30,000 <code>&amp;cz</code> sequences in a row</a>:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer gecko ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>61.4</span><span> </span><span>Â±</span><span>  </span><span>958</span><span>    </span><span>59.2</span><span> </span><span>â€¦</span><span> </span><span>63.6</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>85.5</span><span>    </span><span>64.9</span><span> </span><span>â€¦</span><span> </span><span>65.3</span><span>         </span><span>24 (15%)</span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>104</span><span>  </span><span>Â±</span><span>  </span><span>525</span><span>      </span><span>102</span><span>  </span><span>â€¦</span><span>  </span><span>106</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>194</span><span>  </span><span>Â±</span><span> </span><span>4.18</span><span>      </span><span>194</span><span>  </span><span>â€¦</span><span>  </span><span>194</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.89</span><span>  </span><span>Â±</span><span>  </span><span>125</span><span>     </span><span>5.79</span><span>  </span><span>â€¦</span><span> </span><span>6.92</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>374</span><span>  </span><span>Â±</span><span> </span><span>4.44</span><span>      </span><span>367</span><span>  </span><span>â€¦</span><span>  </span><span>385</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>163</span><span>  </span><span>Â±</span><span> </span><span>1.24</span><span>      </span><span>160</span><span>  </span><span>â€¦</span><span>  </span><span>166</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>63.0</span><span> </span><span>Â±</span><span> </span><span>1.00</span><span>    </span><span>60.1</span><span> </span><span>â€¦</span><span> </span><span>65.0</span><span>          </span><span>        </span><span>ðŸ’©+  2.6% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>74.3</span><span>    </span><span>64.8</span><span> </span><span>â€¦</span><span> </span><span>65.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>112</span><span>  </span><span>Â±</span><span>  </span><span>673</span><span>      </span><span>111</span><span>  </span><span>â€¦</span><span>  </span><span>117</span><span>           </span><span>        </span><span>ðŸ’©+  7.6% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>214</span><span>  </span><span>Â±</span><span> </span><span>4.26</span><span>      </span><span>214</span><span>  </span><span>â€¦</span><span>  </span><span>214</span><span>           </span><span>        </span><span>ðŸ’©+ 10.4% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.87</span><span>  </span><span>Â±</span><span> </span><span>54.9</span><span>     </span><span>5.77</span><span>  </span><span>â€¦</span><span> </span><span>6.19</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>375</span><span>  </span><span>Â±</span><span> </span><span>4.52</span><span>      </span><span>364</span><span>  </span><span>â€¦</span><span>  </span><span>391</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span>  </span><span>751</span><span>       </span><span>161</span><span>  </span><span>â€¦</span><span>  </span><span>166</span><span>           </span><span>          </span><span></span></code></pre>
<p>However, neither of these scenarios are likely to be all that common in reality. My hunch (but I don&#39;t have any data to back this up) is that there are two scenarios that are common in real HTML:</p>
<ul>
<li>Valid and complete named character references</li>
<li>Invalid named character references that come from accidentally putting <code>&amp;</code> directly in the markup instead of <code>&amp;amp;</code> (and therefore the <code>&amp;</code> is probably surrounded by whitespace)</li>
</ul>
<p>In the second scenario where an <code>&amp;</code> character is surrounded by whitespace, the tokenizer will never actually enter the named character reference state, since that requires <code>&amp;</code> to be followed by an ASCII alphanumeric character, so all implementations will perform the same there.</p>
<p>We can test the first scenario, though. Here are the results for <a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Tests/LibWeb/BenchHTMLTokenizer.cpp#L11">a file with nothing but 30,000 valid named character references (chosen at random) in a row</a>:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer gecko all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.6</span><span> </span><span>Â±</span><span>  </span><span>713</span><span>    </span><span>41.3</span><span> </span><span>â€¦</span><span> </span><span>45.2</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.4</span><span> </span><span>Â±</span><span> </span><span>84.8</span><span>    </span><span>54.1</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>103</span><span>  </span><span>Â±</span><span>  </span><span>545</span><span>      </span><span>102</span><span>  </span><span>â€¦</span><span>  </span><span>105</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>188</span><span>  </span><span>Â±</span><span> </span><span>10.6</span><span>      </span><span>188</span><span>  </span><span>â€¦</span><span>  </span><span>188</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.63</span><span>  </span><span>Â±</span><span> </span><span>91.6</span><span>     </span><span>3.54</span><span>  </span><span>â€¦</span><span> </span><span>4.35</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>361</span><span>  </span><span>Â±</span><span> </span><span>8.92</span><span>      </span><span>347</span><span>  </span><span>â€¦</span><span>  </span><span>386</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>383</span><span>  </span><span>Â±</span><span> </span><span>1.57</span><span>      </span><span>379</span><span>  </span><span>â€¦</span><span>  </span><span>387</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.0</span><span> </span><span>Â±</span><span>  </span><span>770</span><span>    </span><span>40.8</span><span> </span><span>â€¦</span><span> </span><span>44.3</span><span>         </span><span>30 (13%)</span><span>        </span><span>âš¡-  1.3% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.4</span><span> </span><span>Â±</span><span> </span><span>80.6</span><span>    </span><span>54.0</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>102</span><span>  </span><span>Â±</span><span>  </span><span>452</span><span>      </span><span>101</span><span>  </span><span>â€¦</span><span>  </span><span>104</span><span>           </span><span>        </span><span>âš¡-  1.3% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>191</span><span>  </span><span>Â±</span><span> </span><span>8.04</span><span>      </span><span>191</span><span>  </span><span>â€¦</span><span>  </span><span>191</span><span>          </span><span>        </span><span>ðŸ’©+  2.0% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.54</span><span>  </span><span>Â±</span><span> </span><span>63.5</span><span>     </span><span>3.45</span><span>  </span><span>â€¦</span><span> </span><span>4.09</span><span>          </span><span>        </span><span>âš¡-  2.6% Â±  0.4%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>355</span><span>  </span><span>Â±</span><span> </span><span>5.23</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>370</span><span>           </span><span>        </span><span>âš¡-  1.7% Â±  0.4%
</span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>344</span><span>  </span><span>Â±</span><span> </span><span>1.24</span><span>      </span><span>341</span><span>  </span><span>â€¦</span><span>  </span><span>348</span><span>          </span><span>        </span><span>âš¡- 10.1% Â±  0.1%
</span><span></span></code></pre>
<p>Something worth noting about why Firefox fares better here than in the <code>&amp;supsetneqq;</code> benchmark above is that the distribution of possible matches after two characters is very uneven (as mentioned previously). In 42.7% of cases (269 out of 630) where there is at least 1 possible match after the first two characters, there is <em>only</em> 1 possible match. This makes the &#39;narrowing down the matches&#39; portion of the Firefox implementation essentially just a string comparison.</p>
<p>Something else we can look at is raw matching speed in isolation (i.e. not within the context of HTML tokenization). In <a href="https://github.com/squeek502/ladybird/blob/named-character-references-test/Tests/LibWeb/BenchMatcher.cpp">my benchmarking</a>, the Firefox implementation wins out in this category:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchMatcherGecko
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>105</span><span> </span><span>Â±</span><span> </span><span>1.14</span><span>     </span><span>102</span><span> </span><span>â€¦</span><span>  </span><span>108</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.56</span><span> </span><span>Â±</span><span> </span><span>72.7</span><span>    </span><span>4.33</span><span> </span><span>â€¦</span><span> </span><span>4.72</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>426</span><span>  </span><span>Â±</span><span> </span><span>1.40</span><span>      </span><span>424</span><span>  </span><span>â€¦</span><span>  </span><span>430</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>745</span><span>  </span><span>Â±</span><span> </span><span>81.5</span><span>       </span><span>745</span><span>  </span><span>â€¦</span><span>  </span><span>745</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>8.03</span><span>  </span><span>Â±</span><span> </span><span>81.6</span><span>     </span><span>7.89</span><span>  </span><span>â€¦</span><span> </span><span>8.54</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>28.0</span><span>  </span><span>Â±</span><span> </span><span>5.70</span><span>     </span><span>21.2</span><span>  </span><span>â€¦</span><span> </span><span>46.5</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.41</span><span>  </span><span>Â±</span><span> </span><span>2.49</span><span>     </span><span>5.41</span><span>  </span><span>â€¦</span><span> </span><span>5.42</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchMatcherDafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>120</span><span> </span><span>Â±</span><span> </span><span>1.46</span><span>     </span><span>116</span><span> </span><span>â€¦</span><span>  </span><span>123</span><span>          </span><span>        </span><span>ðŸ’©+ 13.8% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.50</span><span> </span><span>Â±</span><span> </span><span>61.6</span><span>    </span><span>4.46</span><span> </span><span>â€¦</span><span> </span><span>4.59</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>487</span><span>  </span><span>Â±</span><span> </span><span>4.39</span><span>      </span><span>477</span><span>  </span><span>â€¦</span><span>  </span><span>496</span><span>           </span><span>        </span><span>ðŸ’©+ 14.3% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.02</span><span>  </span><span>Â±</span><span> </span><span>66.2</span><span>      </span><span>1.02</span><span>  </span><span>â€¦</span><span> </span><span>1.02</span><span>          </span><span>14 (17%)</span><span>        </span><span>ðŸ’©+ 36.7% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.11</span><span>  </span><span>Â±</span><span> </span><span>90.5</span><span>     </span><span>5.98</span><span>  </span><span>â€¦</span><span> </span><span>6.81</span><span>           </span><span>        </span><span>âš¡- 23.9% Â±  0.3%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>26.0</span><span>  </span><span>Â±</span><span> </span><span>4.02</span><span>     </span><span>20.3</span><span>  </span><span>â€¦</span><span> </span><span>39.8</span><span>           </span><span>        </span><span>âš¡-  7.1% Â±  5.2%
</span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>6.01</span><span>  </span><span>Â±</span><span> </span><span>20.5</span><span>     </span><span>5.98</span><span>  </span><span>â€¦</span><span> </span><span>6.06</span><span>           </span><span>        </span><span>ðŸ’©+ 11.1% Â±  0.1%
</span><span></span></code></pre>
<p>Two things to note:</p>
<ul>
<li>It&#39;s unclear how applicable this &#39;raw matching speed&#39; benchmark is for HTML tokenization (this will be discussed more later).</li>
<li>We&#39;ll make some improvements to the DAFSA implementation later that will flip these results.</li>
</ul>
<h4>Data size<a id="data-size-3" href="#data-size-3">ðŸ”—</a></h4>
<p>As noted earlier, Firefox uses a total of 48 arrays for its named character reference data:</p>
<ul>
<li><code>HILO_ACCEL</code> is an array of 123 pointers, so that&#39;s 984 bytes on a 64-bit architecture</li>
<li>There are 44 <code>HILO_ACCEL_n</code> arrays, each containing 52 32-bit integers, so that&#39;s 9,152 bytes</li>
<li><code>ALL_NAMES</code> is an array of bytes containing the complete set of characters in all named character references, excluding the first two characters of each. This adds up to 12,183 bytes in total</li>
<li><code>NAMES</code> is an array of 2,231 32-bit structs, so that&#39;s 8,924 bytes</li>
<li><code>VALUES</code> is also an array of 2,231 32-bit structs, so that&#39;s 8,924 bytes</li>
</ul>

<p>So, in total, the Firefox implementation uses 40,167 bytes (<span>39.23 KiB</span>) for its named character reference data, while Ladybird uses 24,412 bytes (<span>23.84 KiB</span>). That&#39;s a difference of 15,755 bytes (<span>15.39 KiB</span>), or, in other words, the Ladybird implementation uses <span>60.8%</span> of the data size of the Firefox implementation.</p>

<h4>Ease-of-use<a id="ease-of-use" href="#ease-of-use">ðŸ”—</a></h4>
<p>Since, for the purposes of my benchmarking, the Firefox implementation was made to conform to the API of the <code>NamedCharacterReferenceMatcher</code> that is used in the Ladybird implementation, there&#39;s no meaningful difference in terms of ease-of-use.</p>
<p>However, I&#39;ll take this opportunity to talk about what changes were made to make that happen and how the real Firefox implementation differs.</p>
<ul>
<li>The <a href="https://github.com/mozilla-firefox/firefox/blob/ec7f9e0771ff44a5d22cfa26f4a819b739ef027b/parser/html/nsHtml5Tokenizer.cpp#L2036-L2233">real Firefox implementation</a> uses 3 different tokenizer states and multiple complicated loops with <code>goto</code> statements to move between them</li>
<li>The <a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Libraries/LibWeb/HTML/Parser/Entities.cpp#L84-L148"><code>NamedCharacterReferenceMatcher</code> version</a> moves the tokenizer states into the <code>Matcher</code> and replaces the complicated loops with 2 simple loops</li>
</ul>
<p>Very crudely approximated, the implementation went from ~200 SLoC to ~110 SLoC. So, the <code>NamedCharacterReferenceMatcher</code> abstraction may represent a marginal improvement in terms of ease-of-use.</p>
<h4>Summary<a id="summary" href="#summary">ðŸ”—</a></h4>
<p>Overall, the Firefox implementation fares quite well in this comparison.</p>
<ul>
<li>It&#39;s at least as fast, with some potential performance benefits and some potential weaknesses</li>
<li>It uses more data to store the named character reference mappings, but saving 15 KiB might not be much of a concern</li>
<li>The implementation is a fair bit more complicated, but not necessarily in a meaningful way</li>
</ul>
<h3>Comparison with Blink/WebKit (Chrome/Safari)<a id="comparison-with-blink-webkit-chrome-safari" href="#comparison-with-blink-webkit-chrome-safari">ðŸ”—</a></h3>
<p><img alt="Chromium logo" src="https://jvns.ca/images/better-named-character-reference-tokenization/chromium.png"/> <img alt="WebKit logo (Safari&#39;s engine)" src="https://jvns.ca/images/better-named-character-reference-tokenization/webkit.svg"/></p>
<p><a href="https://www.chromium.org/blink/">Blink</a> (the browser engine of Chrome/Chromium) started as a fork of <a href="https://webkit.org/">WebKit</a> (the browser engine of Safari), which itself started as a fork of <a href="https://en.wikipedia.org/wiki/KHTML">KHTML</a>. There are some differences that have emerged between the two since Blink was forked from WebKit, but for the purposes of this article I&#39;m only going to benchmark against the Blink implementation and assume the results would be roughly the same for the WebKit implementation (the difference mostly comes down to data size, which I&#39;ll mention in the &#34;<em>Data size</em>&#34; section later).</p>

<p>Like Firefox, the Chrome/Safari named character reference tokenization does not use a trie. For the &#39;matching&#39; portion, the Chrome/Safari implementation is actually quite similar in concept to the Firefox implementation:</p>
<ul>
<li>Use the first character to lookup the initial range of possible matches within a sorted array of all named character references [<a href="https://github.com/chromium/chromium/blob/f7116e9d191f673257ca706d3bc998dd468ab79f/third_party/blink/renderer/core/html/parser/html_entity_search.cc#L37-L38">src</a>]</li>
<li>For each character after that, use <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/equal_range"><code>std::ranges::equal_range</code></a> to narrow the possibilities within the current range (<code>std::ranges::equal_range</code> uses binary searches to get both the <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/lower_bound"><code>std::ranges::lower_bound</code></a> and <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/upper_bound"><code>std::ranges::upper_bound</code></a>) [<a href="https://github.com/chromium/chromium/blob/f7116e9d191f673257ca706d3bc998dd468ab79f/third_party/blink/renderer/core/html/parser/html_entity_search.cc#L40-L52">src</a>]</li>
<li>If the first possible match in the resulting range is the same length as the current number of characters being matched, mark it as the most recent match [<a href="https://github.com/chromium/chromium/blob/f7116e9d191f673257ca706d3bc998dd468ab79f/third_party/blink/renderer/core/html/parser/html_entity_search.cc#L57-L61">src</a>]</li>
<li>Continue until there are no more possible matches (the range is empty) [<a href="https://github.com/chromium/chromium/blob/f7116e9d191f673257ca706d3bc998dd468ab79f/third_party/blink/renderer/core/html/parser/html_entity_search.cc#L54-L56">src</a>]</li>
</ul>
<p>The main differences from the Firefox implementation are that the Chrome/Safari version (a) only uses the first character to narrow the initial possible matches, and (b) uses binary searches to narrow the possibilities after that instead of linearly moving the <code>lo</code> and <code>hi</code> indexes.</p>
<h4>Performance<a id="performance-4" href="#performance-4">ðŸ”—</a></h4>
<p>Similar to Firefox, the performance difference in the &#39;tens of thousands of valid and invalid named character references&#39; benchmark is basically a wash:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer blink
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>115</span><span> </span><span>Â±</span><span>  </span><span>943</span><span>     </span><span>113</span><span> </span><span>â€¦</span><span>  </span><span>117</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.3</span><span> </span><span>Â±</span><span> </span><span>99.6</span><span>    </span><span>83.0</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>232</span><span>  </span><span>Â±</span><span>  </span><span>754</span><span>      </span><span>230</span><span>  </span><span>â€¦</span><span>  </span><span>234</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>461</span><span>  </span><span>Â±</span><span> </span><span>4.73</span><span>      </span><span>461</span><span>  </span><span>â€¦</span><span>  </span><span>461</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.95</span><span>  </span><span>Â±</span><span>  </span><span>299</span><span>     </span><span>9.71</span><span>  </span><span>â€¦</span><span> </span><span>12.3</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>412</span><span>  </span><span>Â±</span><span> </span><span>5.68</span><span>      </span><span>401</span><span>  </span><span>â€¦</span><span>  </span><span>425</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>747</span><span>  </span><span>Â±</span><span> </span><span>1.78</span><span>      </span><span>744</span><span>  </span><span>â€¦</span><span>  </span><span>757</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>114</span><span> </span><span>Â±</span><span> </span><span>1.26</span><span>     </span><span>110</span><span> </span><span>â€¦</span><span>  </span><span>117</span><span>          </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.3</span><span> </span><span>Â±</span><span> </span><span>77.5</span><span>    </span><span>83.1</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>228</span><span>  </span><span>Â±</span><span>  </span><span>882</span><span>      </span><span>227</span><span>  </span><span>â€¦</span><span>  </span><span>233</span><span>           </span><span>        </span><span>âš¡-  1.4% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>450</span><span>  </span><span>Â±</span><span> </span><span>7.33</span><span>      </span><span>450</span><span>  </span><span>â€¦</span><span>  </span><span>450</span><span>           </span><span>        </span><span>âš¡-  2.4% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.48</span><span>  </span><span>Â±</span><span>  </span><span>402</span><span>     </span><span>9.29</span><span>  </span><span>â€¦</span><span> </span><span>13.1</span><span>           </span><span>        </span><span>âš¡-  4.7% Â±  1.1%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>412</span><span>  </span><span>Â±</span><span> </span><span>7.21</span><span>      </span><span>398</span><span>  </span><span>â€¦</span><span>  </span><span>432</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>575</span><span>  </span><span>Â±</span><span> </span><span>6.48</span><span>      </span><span>571</span><span>  </span><span>â€¦</span><span>  </span><span>633</span><span>           </span><span>        </span><span>âš¡- 23.0% Â±  0.2%
</span><span></span></code></pre>
<p>The DAFSA is faster than Chrome in the all-<code>&amp;supsetneqq;</code> benchmark, but the difference is not as big as it was with Firefox, since Chrome uses binary searches to narrow down the possible matches whereas Firefox uses linear scans:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer blink gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>47.3</span><span> </span><span>Â±</span><span>  </span><span>782</span><span>    </span><span>45.0</span><span> </span><span>â€¦</span><span> </span><span>49.6</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>94.4</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>123</span><span>  </span><span>Â±</span><span>  </span><span>807</span><span>      </span><span>122</span><span>  </span><span>â€¦</span><span>  </span><span>126</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>290</span><span>  </span><span>Â±</span><span> </span><span>7.46</span><span>      </span><span>290</span><span>  </span><span>â€¦</span><span>  </span><span>290</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.31</span><span>  </span><span>Â±</span><span>  </span><span>200</span><span>     </span><span>3.19</span><span>  </span><span>â€¦</span><span> </span><span>5.79</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>358</span><span>  </span><span>Â±</span><span> </span><span>8.15</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>401</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>182</span><span>  </span><span>Â±</span><span> </span><span>1.82</span><span>      </span><span>178</span><span>  </span><span>â€¦</span><span>  </span><span>194</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>45.9</span><span> </span><span>Â±</span><span>  </span><span>663</span><span>    </span><span>43.6</span><span> </span><span>â€¦</span><span> </span><span>47.3</span><span>         </span><span>        </span><span>âš¡-  3.0% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>82.6</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>117</span><span>  </span><span>Â±</span><span>  </span><span>677</span><span>      </span><span>116</span><span>  </span><span>â€¦</span><span>  </span><span>120</span><span>           </span><span>        </span><span>âš¡-  5.0% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>259</span><span>  </span><span>Â±</span><span> </span><span>7.78</span><span>      </span><span>259</span><span>  </span><span>â€¦</span><span>  </span><span>259</span><span>           </span><span>        </span><span>âš¡- 10.8% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.26</span><span>  </span><span>Â±</span><span> </span><span>99.4</span><span>     </span><span>3.17</span><span>  </span><span>â€¦</span><span> </span><span>4.00</span><span>          </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>358</span><span>  </span><span>Â±</span><span> </span><span>8.14</span><span>      </span><span>342</span><span>  </span><span>â€¦</span><span>  </span><span>386</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>183</span><span>  </span><span>Â±</span><span> </span><span>3.07</span><span>      </span><span>179</span><span>  </span><span>â€¦</span><span>  </span><span>214</span><span>          </span><span>          </span><span></span></code></pre>
<p>The DAFSA is once again worse at detecting <code>&amp;cz</code> as invalid, and the results are similar to what they were with Firefox:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer blink ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>62.6</span><span> </span><span>Â±</span><span> </span><span>1.08</span><span>    </span><span>60.6</span><span> </span><span>â€¦</span><span> </span><span>64.3</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>79.4</span><span>    </span><span>64.8</span><span> </span><span>â€¦</span><span> </span><span>65.2</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>108</span><span>  </span><span>Â±</span><span>  </span><span>640</span><span>      </span><span>107</span><span>  </span><span>â€¦</span><span>  </span><span>111</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>203</span><span>  </span><span>Â±</span><span> </span><span>11.3</span><span>      </span><span>203</span><span>  </span><span>â€¦</span><span>  </span><span>203</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.92</span><span>  </span><span>Â±</span><span> </span><span>51.5</span><span>     </span><span>5.82</span><span>  </span><span>â€¦</span><span> </span><span>6.30</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>384</span><span>  </span><span>Â±</span><span> </span><span>8.88</span><span>      </span><span>366</span><span>  </span><span>â€¦</span><span>  </span><span>409</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span> </span><span>1.44</span><span>      </span><span>160</span><span>  </span><span>â€¦</span><span>  </span><span>169</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>63.9</span><span> </span><span>Â±</span><span> </span><span>1.10</span><span>    </span><span>61.8</span><span> </span><span>â€¦</span><span> </span><span>65.5</span><span>          </span><span>        </span><span>ðŸ’©+  2.0% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>92.8</span><span>    </span><span>64.8</span><span> </span><span>â€¦</span><span> </span><span>65.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>113</span><span>  </span><span>Â±</span><span>  </span><span>707</span><span>      </span><span>112</span><span>  </span><span>â€¦</span><span>  </span><span>117</span><span>           </span><span>        </span><span>ðŸ’©+  4.4% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>214</span><span>  </span><span>Â±</span><span> </span><span>10.9</span><span>      </span><span>214</span><span>  </span><span>â€¦</span><span>  </span><span>214</span><span>           </span><span>        </span><span>ðŸ’©+  5.6% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.89</span><span>  </span><span>Â±</span><span> </span><span>63.4</span><span>     </span><span>5.76</span><span>  </span><span>â€¦</span><span> </span><span>6.31</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>387</span><span>  </span><span>Â±</span><span> </span><span>9.20</span><span>      </span><span>367</span><span>  </span><span>â€¦</span><span>  </span><span>412</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>165</span><span>  </span><span>Â±</span><span> </span><span>2.77</span><span>      </span><span>162</span><span>  </span><span>â€¦</span><span>  </span><span>197</span><span>           </span><span>          </span><span></span></code></pre>
<p>For the &#39;30,000 valid named character references&#39; benchmark, the DAFSA is <em>slightly</em> faster (similar results as Firefox):</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer blink all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.9</span><span> </span><span>Â±</span><span>  </span><span>844</span><span>    </span><span>41.7</span><span> </span><span>â€¦</span><span> </span><span>47.0</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.3</span><span> </span><span>Â±</span><span> </span><span>89.2</span><span>    </span><span>54.0</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>105</span><span>  </span><span>Â±</span><span>  </span><span>959</span><span>      </span><span>104</span><span>  </span><span>â€¦</span><span>  </span><span>112</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>204</span><span>  </span><span>Â±</span><span> </span><span>6.18</span><span>      </span><span>204</span><span>  </span><span>â€¦</span><span>  </span><span>204</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.78</span><span>  </span><span>Â±</span><span>  </span><span>137</span><span>     </span><span>3.67</span><span>  </span><span>â€¦</span><span> </span><span>5.37</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>359</span><span>  </span><span>Â±</span><span> </span><span>11.2</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>457</span><span>          </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>466</span><span>  </span><span>Â±</span><span> </span><span>1.43</span><span>      </span><span>463</span><span>  </span><span>â€¦</span><span>  </span><span>472</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.1</span><span> </span><span>Â±</span><span>  </span><span>592</span><span>    </span><span>41.1</span><span> </span><span>â€¦</span><span> </span><span>44.3</span><span>         </span><span>        </span><span>âš¡-  1.8% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.4</span><span> </span><span>Â±</span><span> </span><span>79.6</span><span>    </span><span>54.1</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>102</span><span>  </span><span>Â±</span><span>  </span><span>487</span><span>      </span><span>101</span><span>  </span><span>â€¦</span><span>  </span><span>104</span><span>           </span><span>        </span><span>âš¡-  3.3% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>191</span><span>  </span><span>Â±</span><span> </span><span>5.33</span><span>      </span><span>191</span><span>  </span><span>â€¦</span><span>  </span><span>191</span><span>           </span><span>        </span><span>âš¡-  6.0% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.55</span><span>  </span><span>Â±</span><span> </span><span>74.9</span><span>     </span><span>3.46</span><span>  </span><span>â€¦</span><span> </span><span>4.21</span><span>          </span><span>        </span><span>âš¡-  6.3% Â±  0.5%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>355</span><span>  </span><span>Â±</span><span> </span><span>5.67</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>373</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>345</span><span>  </span><span>Â±</span><span> </span><span>2.12</span><span>      </span><span>342</span><span>  </span><span>â€¦</span><span>  </span><span>374</span><span>           </span><span>        </span><span>âš¡- 26.0% Â±  0.1%
</span><span></span></code></pre>
<p>In the raw matching speed benchmark, the DAFSA comes out ahead:</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizerBlink
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>144</span><span> </span><span>Â±</span><span> </span><span>1.33</span><span>     </span><span>141</span><span> </span><span>â€¦</span><span>  </span><span>148</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.55</span><span> </span><span>Â±</span><span> </span><span>65.8</span><span>    </span><span>4.33</span><span> </span><span>â€¦</span><span> </span><span>4.72</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>590</span><span>  </span><span>Â±</span><span> </span><span>2.33</span><span>      </span><span>585</span><span>  </span><span>â€¦</span><span>  </span><span>604</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.07</span><span>  </span><span>Â±</span><span> </span><span>83.4</span><span>      </span><span>1.07</span><span>  </span><span>â€¦</span><span> </span><span>1.07</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>12.3</span><span>  </span><span>Â±</span><span>  </span><span>162</span><span>     </span><span>12.1</span><span>  </span><span>â€¦</span><span> </span><span>13.0</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>27.6</span><span>  </span><span>Â±</span><span> </span><span>5.79</span><span>     </span><span>21.1</span><span>  </span><span>â€¦</span><span> </span><span>67.6</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>8.71</span><span>  </span><span>Â±</span><span> </span><span>21.1</span><span>     </span><span>8.68</span><span>  </span><span>â€¦</span><span> </span><span>8.79</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchMatcherDafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>119</span><span> </span><span>Â±</span><span> </span><span>1.47</span><span>     </span><span>116</span><span> </span><span>â€¦</span><span>  </span><span>122</span><span>          </span><span>        </span><span>âš¡- 17.6% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.52</span><span> </span><span>Â±</span><span> </span><span>65.7</span><span>    </span><span>4.46</span><span> </span><span>â€¦</span><span> </span><span>4.59</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>484</span><span>  </span><span>Â±</span><span> </span><span>4.33</span><span>      </span><span>477</span><span>  </span><span>â€¦</span><span>  </span><span>496</span><span>           </span><span>        </span><span>âš¡- 17.8% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.02</span><span>  </span><span>Â±</span><span> </span><span>80.6</span><span>      </span><span>1.02</span><span>  </span><span>â€¦</span><span> </span><span>1.02</span><span>           </span><span>        </span><span>âš¡-  4.4% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.10</span><span>  </span><span>Â±</span><span>  </span><span>177</span><span>     </span><span>5.99</span><span>  </span><span>â€¦</span><span> </span><span>7.66</span><span>           </span><span>        </span><span>âš¡- 50.5% Â±  0.4%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>25.4</span><span>  </span><span>Â±</span><span> </span><span>3.42</span><span>     </span><span>20.4</span><span>  </span><span>â€¦</span><span> </span><span>38.8</span><span>           </span><span>        </span><span>âš¡-  7.9% Â±  5.3%
</span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>6.02</span><span>  </span><span>Â±</span><span> </span><span>21.7</span><span>     </span><span>5.98</span><span>  </span><span>â€¦</span><span> </span><span>6.06</span><span>           </span><span>        </span><span>âš¡- 30.9% Â±  0.1%
</span><span></span></code></pre>
<h4>Data size<a id="data-size-4" href="#data-size-4">ðŸ”—</a></h4>
<p>The Chrome implementation uses four arrays:</p>
<ul>
<li><code>kStaticEntityStringStorage</code>, an array of all the bytes in every named character reference, with some de-duplication techniques (e.g. the sequence <code>&#39;b&#39;, &#39;n&#39;, &#39;o&#39;, &#39;t&#39;, &#39;;&#39;</code> in the array is used for <code>&amp;bnot;</code>, <code>&amp;not;</code>, and <code>&amp;not</code>). It uses 14,485 bytes total.</li>
<li><code>kStaticEntityTable</code>, an array of 2,231 12-byte wide structs containing information about each named character reference (its location in the <code>kStaticEntityStringStorage</code> array, the length of its name, the code point(s) it should be transformed into). It uses 26,722 bytes.</li>
<li><code>kUppercaseOffset</code> and <code>kLowercaseOffset</code> are each arrays of offsets into <code>kStaticEntityTable</code>, and both are used as lookup tables for the first character. Getting <code>kUppercaseOffset[char - &#39;A&#39;]</code> gives you the initial lower bound&#39;s offset and <code>kUppercaseOffset[char - &#39;A&#39; + 1]</code> gives you the initial upper bound&#39;s offset (and the same sort of thing for <code>kLowercaseOffset</code>). Each uses 54 bytes, so that&#39;s 108 bytes total.</li>
</ul>
<p>All together, the Chrome implementation uses 41,167 bytes (<span>40.39 KiB</span>) for its named character reference data, while Ladybird uses 24,412 bytes (<span>23.84 KiB</span>). That&#39;s a difference of 16,953 bytes (<span>16.56 KiB</span>), or <span>59.0%</span> of the data size of the Chrome implementation.</p>
<p>The Safari implementation uses the same four arrays, but <a href="https://github.com/WebKit/WebKit/commit/3483dcf98d883183eb0621479ed8f19451533722">has made a few more data size optimizations</a>:</p>
<ul>
<li><code>kStaticEntityStringStorage</code> does not include semicolons, and instead that information was moved to a boolean flag within the elements of the <code>kStaticEntityTable</code> array. This brings down the total bytes used by this array to 11,127 (-3,358 compared to the Chrome version)</li>
<li>The <code>HTMLEntityTableEntry</code> struct (used in the <code>kStaticEntityTable</code> array) was converted to <a href="https://github.com/WebKit/WebKit/blob/bde3bff51de25b231de2b22517438a911e2e8e3a/Source/WebCore/html/parser/HTMLEntityTable.h#L34-L43">use a bitfield</a> to reduce the size of the struct from 12 bytes to 8 bytes (57 bits). However, Clang seems to insert padding bits into the <code>struct</code> which brings it back up to 12 bytes anyway (it wants to align the <code>optionalSecondCharacter</code> and <code>nameLengthExcludingSemicolon</code> fields). So, this data size optimization may or may not actually have an effect (I&#39;m not very familiar with the rules around C++ bitfield padding, so I feel like I can&#39;t say anything definitive). If the size <em>is</em> reduced to 8 bytes, then <code>kStaticEntityTable</code> uses 8,924 less bytes (17,798 instead of 26,722).</li>
</ul>
<p>So, the Safari implementation uses either 30,040 bytes (<span>29.34 KiB</span>) if <code>HTMLEntityTableEntry</code> uses 12 bytes, or 21,116 bytes (<span>20.62 KiB</span>) if <code>HTMLEntityTableEntry</code> uses 8 bytes. This means that Safari&#39;s data size optimizations (or at least their intended effect) makes its data size <em>smaller</em> than Ladybird&#39;s (even if the Ladybird implementation tightly bitpacked its values array, it&#39;d still use 229 bytes more than the 8-byte-<code>HTMLEntityTableEntry</code> Safari version). This also shows that the larger data size of the Chrome implementation is not inherent to the approach that it uses.</p>
<h4>Ease-of-use<a id="ease-of-use-2" href="#ease-of-use-2">ðŸ”—</a></h4>
<p>For now I&#39;ll just say there&#39;s no meaningful difference, but there&#39;s a caveat that will be discussed later.</p>
<h4>Summary<a id="summary-2" href="#summary-2">ðŸ”—</a></h4>
<p>Overall, the Chrome implementation as-it-is-now fares about as well as the Firefox implementation in this comparison, but has some potential strengths/weaknesses of its own. That is, it covers one weakness of the Firefox implementation by using binary searches instead of linear scans, but it always has to narrow down the possibilities from a larger initial range (since it only uses the first character to get the range of possible matches whereas Firefox uses the first two characters).</p>
<p>The Safari version fares much better in terms of data size (potentially beating out my DAFSA version), and its size optimizations could be applied to the Chrome version as well since the core approach is the same between them.</p>
<p>At this point, though, you might be asking yourself, why don&#39;t we try...</p>
<h2>Combining Firefox, Chrome, and Safari together<a id="combining-firefox-chrome-and-safari-together" href="#combining-firefox-chrome-and-safari-together">ðŸ”—</a></h2>
<p>In theory, the best ideas from the Firefox and Chrome/Safari implementations could be combined into one new implementation:</p>
<ul>
<li>Use the combination of the first two characters to get the initial range of possible matches (like Firefox)</li>
<li>Use binary searches to narrow down the possible matches (like Chrome/Safari)</li>
<li>Don&#39;t store the first two characters in the <code>kStaticEntityStringStorage</code>/<code>ALL_NAMES</code> array (like Firefox)</li>
<li>Re-use indexes into <code>kStaticEntityStringStorage</code>/<code>ALL_NAMES</code> when possible (like Chrome/Safari, see the <code>&amp;bnot;</code>/<code>&amp;not;</code>/<code>&amp;not</code> example above)</li>
<li>Don&#39;t store semicolons in the <code>kStaticEntityStringStorage</code>/<code>ALL_NAMES</code> array (like Safari)</li>
<li>Reduce the size of the <code>HTMLEntityTableEntry</code>/<code>nsHtml5CharacterName</code> struct (like Safari intends to do)</li>
</ul>
<p>I haven&#39;t tested this combination to see how exactly it stacks up, but I would assume it&#39;d be quite good overall.</p>
<h2>Something I didn&#39;t mention about the Chrome implementation<a id="something-i-didn-t-mention-about-the-chrome-implementation" href="#something-i-didn-t-mention-about-the-chrome-implementation">ðŸ”—</a></h2>
<p>Since I converted the Chrome implementation to use Ladybird&#39;s <code>NamedCharacterReferenceMacher</code> API in an effort to improve the accuracy of my benchmarking, one major aspect of the Chrome implementation was lost in translation: the Chrome implementation doesn&#39;t actually use the character-by-character tokenization strategy we&#39;ve discussed so far.</p>
<p>Instead, it uses the &#34;lookahead (but never beyond an insertion point) until we&#39;re certain we have enough characters ...&#34; strategy mentioned back in the <a href="#what-this-all-means-implementation-wise"><em>Named character reference tokenization overview</em></a>. The very high-level summary of the approach (as it is actually implemented in Chrome) is very similar to the description of it in that section:</p>
<ul>
<li>Starting after the ampersand, lookahead as far as possible without looking beyond the end of an insertion point</li>
<li>Try to match a full named character reference</li>
<li>If you run out of characters because you hit the end of an insertion point while matching, backtrack and try again on the next tokenizer iteration (always starting the lookahead from just after the ampersand, i.e. no state is saved between attempts)</li>
</ul>

<p>The downside of the Chrome implementation in particular is actually a choice that was made that&#39;s not inherent to the overall approach: they don&#39;t preserve any matching state between tokenizer iterations and always backtrack to the <code>&amp;</code> before trying to match again. For example, when matching against something like <code>&amp;notin;</code> that&#39;s being written one-character-at-a-time (via <code>document.write</code>), the matching algorithm described in the &#34;<em><a href="#comparison-with-blink-webkit-chrome-safari">Comparison with Blink/WebKit (Chrome/Safari)</a></em>&#34; section will be executed for each of:</p>
<ul>
<li><code>&amp;n</code>, <code>&amp;no</code>, <code>&amp;not</code>, <code>&amp;noti</code>, and <code>&amp;notin</code>, each resulting in the &#39;not enough characters&#39; flag being set</li>
<li>Finally, <code>&amp;notin;</code> will be matched fully (the semicolon acts as a definitive delimiter)</li>
</ul>
<p>In theory, the redundant work that&#39;s performed in these sorts of scenarios should have a noticeable affect on performance, but, in practice, I wasn&#39;t able to prove that out with benchmarking.</p>
<details>
<summary>Details and results of my benchmarking</summary>
<ul>
<li><a href="https://gist.github.com/squeek502/29ec1404b54cff461d6fe47d539009ed">The test file</a> (inserting lots of valid named character references one-character-at-a-time using <code>document.write</code>)</li>
<li><a href="https://github.com/squeek502/ladybird/tree/blink-preserve-state">The branch containing the code under test</a> (a faithful adaptation of Blink&#39;s lookahead strategy and a runtime flag to switch to an implementation that preserves matching state between retry attempts due to &#39;not enough characters&#39;)</li>
</ul>
<pre><code><span>Benchmark 1</span><span>: ./headless-browser --dump-text pathological-write-valid.html
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.46</span><span>  </span><span>Â±</span><span> </span><span>8.11</span><span>    </span><span>1.45</span><span>  </span><span>â€¦</span><span> </span><span>1.48</span><span>           </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>62.1</span><span> </span><span>Â±</span><span>  </span><span>123</span><span>    </span><span>61.9</span><span> </span><span>â€¦</span><span> </span><span>62.3</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>5.90</span><span>  </span><span>Â±</span><span> </span><span>33.5</span><span>     </span><span>5.88</span><span>  </span><span>â€¦</span><span> </span><span>5.99</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>       </span><span>29.1</span><span>  </span><span>Â±</span><span>  </span><span>562</span><span>     </span><span>29.1</span><span>  </span><span>â€¦</span><span> </span><span>29.1</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>210</span><span>  </span><span>Â±</span><span>  </span><span>988</span><span>      </span><span>208</span><span>  </span><span>â€¦</span><span>  </span><span>211</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>8.53</span><span>  </span><span>Â±</span><span>  </span><span>322</span><span>     </span><span>7.92</span><span>  </span><span>â€¦</span><span> </span><span>9.09</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.03</span><span>  </span><span>Â±</span><span> </span><span>19.2</span><span>     </span><span>5.01</span><span>  </span><span>â€¦</span><span> </span><span>5.07</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./headless-browser --blink-preserve-state --dump-text pathological-write-valid.html
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>1.46</span><span>  </span><span>Â±</span><span> </span><span>4.52</span><span>    </span><span>1.45</span><span>  </span><span>â€¦</span><span> </span><span>1.47</span><span>           </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>62.0</span><span> </span><span>Â±</span><span>  </span><span>164</span><span>    </span><span>61.7</span><span> </span><span>â€¦</span><span> </span><span>62.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>5.88</span><span>  </span><span>Â±</span><span> </span><span>18.1</span><span>     </span><span>5.86</span><span>  </span><span>â€¦</span><span> </span><span>5.93</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>       </span><span>29.1</span><span>  </span><span>Â±</span><span>  </span><span>422</span><span>     </span><span>29.1</span><span>  </span><span>â€¦</span><span> </span><span>29.1</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>    </span><span>209</span><span>  </span><span>Â±</span><span> </span><span>1.26</span><span>      </span><span>207</span><span>  </span><span>â€¦</span><span>  </span><span>212</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>8.55</span><span>  </span><span>Â±</span><span>  </span><span>425</span><span>     </span><span>8.19</span><span>  </span><span>â€¦</span><span> </span><span>9.78</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.00</span><span>  </span><span>Â±</span><span> </span><span>27.0</span><span>     </span><span>4.97</span><span>  </span><span>â€¦</span><span> </span><span>5.07</span><span>           </span><span>          </span><span></span></code></pre>
</details>
<p>So, despite <code>HTMLEntitySearch::Advance</code> being called 4.5x more in the &#39;no state preserved&#39; benchmark, no difference shows up in the results. I believe this is because the actual matching is a small part of the work being done in this benchmark, or, in other words, there <em>is</em> a difference but it&#39;s being drowned out by all the work being done elsewhere (JavaScript being run, tokenizer input being updated, etc). I have a hunch that Ladybird in particular might be greatly exacerbating this effect and making all this tangential work slower than it theoretically needs to be, especially in the case of updating the tokenizer input. For example, Chrome uses a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">rope</a>-like <a href="https://github.com/chromium/chromium/blob/f7116e9d191f673257ca706d3bc998dd468ab79f/third_party/blink/renderer/platform/text/segmented_string.h">SegmentedString</a> to mitigate the cost of inserting into the middle of the input, while Ladybird currently <a href="https://github.com/LadybirdBrowser/ladybird/blob/3171d5763959b1a597f65d0be3a34a5ade40d789/Libraries/LibWeb/HTML/Parser/HTMLTokenizer.cpp#L2874-L2894">reallocates the entire modified input on each insertion</a>.</p>
<p>To sum up what I&#39;m trying to say:</p>
<ul>
<li>The Chrome implementation demonstrably does more work than necessary in the &#39;<code>document.write</code> one-character-at-a-time&#39; scenario because it doesn&#39;t preserve matching state between retries due to &#39;not enough characters&#39;</li>
<li>I am unable to create a relevant benchmark using Ladybird, likely due to some inefficiencies in the Ladybird tokenizer implementation, but a clear difference might show up when benchmarking the Chrome tokenizer itself (i.e. if you made the Chrome implementation preserve state in this scenario and benchmarked its tokenizer, I expect it might show <em>some</em> measurable difference)</li>
</ul>
<p>This is important to note because it is the reason I included the following point in my &#39;list of things you&#39;ll need to trust in order for my benchmarking to be accurate&#39; in the intro to the <a href="#comparison-to-the-major-browser-engines">&#34;<em>Comparison to the major browser engines</em>&#34;</a> section:</p>
<blockquote>
<ul>
<li>The performance characteristics exhibited would hold when going the other direction (putting my implementation into their tokenizer)</li>
</ul>
</blockquote>
<p>That is, I have some reason to believe &#39;going the other direction&#39; may actually be slightly <em>more</em> favorable to my DAFSA implementation, as all the code <em>outside</em> of the named character reference tokenization state itself likely will do less that will muddy benchmarking results.</p>
<h3>A benefit of the &#39;lookahead&#39; strategy<a id="a-benefit-of-the-lookahead-strategy" href="#a-benefit-of-the-lookahead-strategy">ðŸ”—</a></h3>
<p>An upside of the &#39;lookahead&#39; strategy is that, when you know there&#39;s no active insertion point, you can <em>always</em> match against the full remaining input in one go. This is potentially an improvement over the &#39;tokenize-one-character-at-a-time&#39; strategy if there is any significant amount of work that&#39;s done between tokenizer iterations. Here&#39;s some simple diagrams to illustrate the point:</p>
<div>
<div>
<svg aria-roledescription="flowchart-v2" role="graphics-document document" xmlns="http://www.w3.org/2000/svg" width="100%" id="graph-2642" style="max-width: 350px;" viewBox="100 125 400 600" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"><g id="viewport-20250626001053133" transform="matrix(1.048317551612854,0,0,1.048317551612854,185.09927368164062,151.5854949951172)" style="transform: matrix(1.04832, 0, 0, 1.04832, 185.099, 151.586);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" id="graph-2642_flowchart-v2-pointEnd"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" id="graph-2642_flowchart-v2-pointStart"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" id="graph-2642_flowchart-v2-circleEnd"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" id="graph-2642_flowchart-v2-circleStart"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" id="graph-2642_flowchart-v2-crossEnd"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" id="graph-2642_flowchart-v2-crossStart"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g><g></g><g><path marker-end="url(#graph-2642_flowchart-v2-pointEnd)" style="" id="L_A_B_0" d="M108,62L108,70.167C108,78.333,108,94.667,108,110.333C108,126,108,141,108,148.5L108,156"></path><path marker-end="url(#graph-2642_flowchart-v2-pointEnd)" style="" id="L_B_C_0" d="M108,214L108,222.167C108,230.333,108,246.667,108,262.333C108,278,108,293,108,300.5L108,308"></path><path marker-end="url(#graph-2642_flowchart-v2-pointEnd)" style="" id="L_C_D_0" d="M108,366L108,374.167C108,382.333,108,398.667,108,414.333C108,430,108,445,108,452.5L108,460"></path></g><g><g transform="translate(108, 111)"><g transform="translate(-100, -24)"><foreignObject height="48" width="200"><p><span><p>work done to move to the next character</p></span></p></foreignObject></g></g><g transform="translate(108, 263)"><g transform="translate(-100, -24)"><foreignObject height="48" width="200"><p><span><p>work done to move to the next character</p></span></p></foreignObject></g></g><g transform="translate(108, 415)"><g transform="translate(-100, -24)"><foreignObject height="48" width="200"><p><span><p>work done to move to the next character</p></span></p></foreignObject></g></g></g><g><g transform="translate(108, 35)" id="flowchart-A-0"><rect height="54" width="68.89999389648438" y="-27" x="-34.44999694824219" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>a</p></span></p></foreignObject></g></g><g transform="translate(108, 187)" id="flowchart-B-1"><rect height="54" width="68.89999389648438" y="-27" x="-34.44999694824219" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>b</p></span></p></foreignObject></g></g><g transform="translate(108, 339)" id="flowchart-C-3"><rect height="54" width="64.44999694824219" y="-27" x="-32.224998474121094" style=""></rect><g transform="translate(-2.2249984741210938, -12)" style=""><rect></rect><foreignObject height="24" width="12"><p><span><p>c</p></span></p></foreignObject></g></g><g transform="translate(108, 491)" id="flowchart-D-5"><rect height="54" width="73.35000610351562" y="-27" x="-36.67500305175781" style=""></rect><g transform="translate(-6.6750030517578125, -12)" style=""><rect></rect><foreignObject height="24" width="13.350006103515625"><p><span><p>...</p></span></p></foreignObject></g></g></g></g></g></g></svg>
<p><i>When using the &#39;character-by-character&#39; approach, any work that&#39;s done to move the input cursor is repeated before each character is matched against</i></p>
</div>
<div>
<svg aria-roledescription="flowchart-v2" role="graphics-document document" xmlns="http://www.w3.org/2000/svg" width="100%" id="graph-2080" style="max-width: 300px;" viewBox="290 25 600 850" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"><g id="viewport-20250625235739215" transform="matrix(1.839534878730774,0,0,1.839534878730774,388.2588806152344,56.50001907348633)" style="transform: matrix(1.83953, 0, 0, 1.83953, 388.259, 56.5);"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" id="graph-2080_flowchart-v2-pointEnd"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" id="graph-2080_flowchart-v2-pointStart"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" id="graph-2080_flowchart-v2-circleEnd"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" id="graph-2080_flowchart-v2-circleStart"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" id="graph-2080_flowchart-v2-crossEnd"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" id="graph-2080_flowchart-v2-crossStart"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g><g></g><g><path marker-end="url(#graph-2080_flowchart-v2-pointEnd)" style="" id="L_A_B_0" d="M108,62L108,66.167C108,70.333,108,78.667,108,86.333C108,94,108,101,108,104.5L108,108"></path><path marker-end="url(#graph-2080_flowchart-v2-pointEnd)" style="" id="L_B_C_0" d="M108,166L108,170.167C108,174.333,108,182.667,108,190.333C108,198,108,205,108,208.5L108,212"></path><path marker-end="url(#graph-2080_flowchart-v2-pointEnd)" style="" id="L_C_D_0" d="M108,270L108,278.167C108,286.333,108,302.667,108,318.333C108,334,108,349,108,356.5L108,364"></path></g><g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g><g transform="translate(108, 319)"><g transform="translate(-100, -24)"><foreignObject height="48" width="200"><p><span><p>work done to skip to the end of the match</p></span></p></foreignObject></g></g></g><g><g transform="translate(108, 35)" id="flowchart-A-0"><rect height="54" width="68.89999389648438" y="-27" x="-34.44999694824219" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>a</p></span></p></foreignObject></g></g><g transform="translate(108, 139)" id="flowchart-B-1"><rect height="54" width="68.89999389648438" y="-27" x="-34.44999694824219" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>b</p></span></p></foreignObject></g></g><g transform="translate(108, 243)" id="flowchart-C-3"><rect height="54" width="64.44999694824219" y="-27" x="-32.224998474121094" style=""></rect><g transform="translate(-2.2249984741210938, -12)" style=""><rect></rect><foreignObject height="24" width="12.4499969482421875"><p><span><p>c</p></span></p></foreignObject></g></g><g transform="translate(108, 395)" id="flowchart-D-5"><rect height="54" width="73.35000610351562" y="-27" x="-36.67500305175781" style=""></rect><g transform="translate(-6.6750030517578125, -12)" style=""><rect></rect><foreignObject height="24" width="13.350006103515625"><p><span><p>...</p></span></p></foreignObject></g></g></g></g></g></g></svg>
<p><i>When using the &#39;lookahead&#39; approach, matching happens in a tight loop and any work done to move the input cursor only happens once, after the matching is complete</i></p>
</div>
</div>
<p>There are two theoretical benefits I can think of with this:</p>
<ul>
<li>Avoiding the work done between each character may lead to better CPU cache usage/branch prediction</li>
<li>Moving the cursor ahead by <code>N</code> in one go may be more efficient than moving it ahead by one, <code>N</code> times</li>
</ul>
<p>Luckily, we don&#39;t actually need to change much about our &#39;character-by-character tokenization&#39; approach to get these benefits, as we only need to make it so we use lookahead whenever there&#39;s no active insertion point. In Ladybird, that might look something like this (<a href="https://github.com/squeek502/ladybird/blob/1a2a2774a251782f22eb6f1597ee743adf856db7/Libraries/LibWeb/HTML/Parser/HTMLTokenizer.cpp#L1703-L1731">full implementation</a>):</p>
<pre><code><span>BEGIN_STATE</span><span>(</span><span>NamedCharacterReference</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>stop_at_insertion_point</span><span> </span><span>==</span><span> </span><span>StopAtInsertionPoint</span><span>::</span><span>No</span><span>)</span><span> </span><span>{</span><span>
        </span><span>
    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
        </span><span>
    </span><span>}</span><span>

    </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>In practice, this seems to give up to a 1.13x speedup in our Ladybird benchmarks essentially for free:</p>
<details>
<summary>Benchmark results</summary>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>114</span><span> </span><span>Â±</span><span>  </span><span>934</span><span>     </span><span>112</span><span> </span><span>â€¦</span><span>  </span><span>115</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.5</span><span> </span><span>Â±</span><span> </span><span>74.9</span><span>    </span><span>83.3</span><span> </span><span>â€¦</span><span> </span><span>83.6</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>226</span><span>  </span><span>Â±</span><span>  </span><span>964</span><span>      </span><span>223</span><span>  </span><span>â€¦</span><span>  </span><span>229</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>452</span><span>  </span><span>Â±</span><span> </span><span>6.81</span><span>      </span><span>452</span><span>  </span><span>â€¦</span><span>  </span><span>452</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.64</span><span>  </span><span>Â±</span><span> </span><span>86.1</span><span>     </span><span>9.51</span><span>  </span><span>â€¦</span><span> </span><span>9.86</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>418</span><span>  </span><span>Â±</span><span> </span><span>10.5</span><span>      </span><span>399</span><span>  </span><span>â€¦</span><span>  </span><span>448</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>573</span><span>  </span><span>Â±</span><span> </span><span>2.51</span><span>      </span><span>570</span><span>  </span><span>â€¦</span><span>  </span><span>584</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-lookahead
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>108</span><span> </span><span>Â±</span><span> </span><span>1.05</span><span>     </span><span>106</span><span> </span><span>â€¦</span><span>  </span><span>111</span><span>          </span><span>        </span><span>âš¡-  5.1% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.5</span><span> </span><span>Â±</span><span> </span><span>81.5</span><span>    </span><span>83.3</span><span> </span><span>â€¦</span><span> </span><span>83.6</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>203</span><span>  </span><span>Â±</span><span>  </span><span>869</span><span>      </span><span>201</span><span>  </span><span>â€¦</span><span>  </span><span>205</span><span>           </span><span>        </span><span>âš¡- 10.5% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>377</span><span>  </span><span>Â±</span><span> </span><span>10.8</span><span>      </span><span>377</span><span>  </span><span>â€¦</span><span>  </span><span>377</span><span>           </span><span>        </span><span>âš¡- 16.6% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.57</span><span>  </span><span>Â±</span><span> </span><span>71.3</span><span>     </span><span>9.42</span><span>  </span><span>â€¦</span><span> </span><span>9.77</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>415</span><span>  </span><span>Â±</span><span> </span><span>7.59</span><span>      </span><span>401</span><span>  </span><span>â€¦</span><span>  </span><span>429</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>553</span><span>  </span><span>Â±</span><span> </span><span>2.04</span><span>      </span><span>547</span><span>  </span><span>â€¦</span><span>  </span><span>556</span><span>           </span><span>        </span><span>âš¡-  3.5% Â±  0.2%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>45.8</span><span> </span><span>Â±</span><span>  </span><span>866</span><span>    </span><span>43.7</span><span> </span><span>â€¦</span><span> </span><span>47.2</span><span>         </span><span>11 (10%)</span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.2</span><span> </span><span>Â±</span><span> </span><span>67.6</span><span>    </span><span>53.0</span><span> </span><span>â€¦</span><span> </span><span>53.4</span><span>         </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>117</span><span>  </span><span>Â±</span><span>  </span><span>601</span><span>      </span><span>116</span><span>  </span><span>â€¦</span><span>  </span><span>118</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>261</span><span>  </span><span>Â±</span><span> </span><span>6.10</span><span>      </span><span>261</span><span>  </span><span>â€¦</span><span>  </span><span>261</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.27</span><span>  </span><span>Â±</span><span> </span><span>62.6</span><span>     </span><span>3.19</span><span>  </span><span>â€¦</span><span> </span><span>3.69</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>354</span><span>  </span><span>Â±</span><span> </span><span>4.17</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>368</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>182</span><span>  </span><span>Â±</span><span> </span><span>4.28</span><span>      </span><span>178</span><span>  </span><span>â€¦</span><span>  </span><span>213</span><span>          </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-lookahead gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>40.4</span><span> </span><span>Â±</span><span>  </span><span>756</span><span>    </span><span>38.3</span><span> </span><span>â€¦</span><span> </span><span>42.0</span><span>         </span><span>13 (10%)</span><span>        </span><span>âš¡- 11.8% Â±  0.5%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.2</span><span> </span><span>Â±</span><span> </span><span>77.2</span><span>    </span><span>52.9</span><span> </span><span>â€¦</span><span> </span><span>53.4</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>93.4</span><span>  </span><span>Â±</span><span>  </span><span>546</span><span>     </span><span>92.5</span><span>  </span><span>â€¦</span><span> </span><span>95.8</span><span>           </span><span>        </span><span>âš¡- 19.9% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>190</span><span>  </span><span>Â±</span><span> </span><span>5.41</span><span>      </span><span>190</span><span>  </span><span>â€¦</span><span>  </span><span>190</span><span>           </span><span>        </span><span>âš¡- 27.1% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.31</span><span>  </span><span>Â±</span><span> </span><span>42.2</span><span>     </span><span>3.23</span><span>  </span><span>â€¦</span><span> </span><span>3.48</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>354</span><span>  </span><span>Â±</span><span> </span><span>5.07</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>372</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>153</span><span>  </span><span>Â±</span><span> </span><span>10.5</span><span>      </span><span>146</span><span>  </span><span>â€¦</span><span>  </span><span>215</span><span>          </span><span>17 (14%)</span><span>        </span><span>âš¡- 16.1% Â±  1.2%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>63.2</span><span> </span><span>Â±</span><span>  </span><span>964</span><span>    </span><span>61.6</span><span> </span><span>â€¦</span><span> </span><span>65.7</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.3</span><span> </span><span>Â±</span><span> </span><span>79.1</span><span>    </span><span>65.0</span><span> </span><span>â€¦</span><span> </span><span>65.4</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>112</span><span>  </span><span>Â±</span><span>  </span><span>606</span><span>      </span><span>111</span><span>  </span><span>â€¦</span><span>  </span><span>115</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>215</span><span>  </span><span>Â±</span><span> </span><span>8.83</span><span>      </span><span>215</span><span>  </span><span>â€¦</span><span>  </span><span>215</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.91</span><span>  </span><span>Â±</span><span>  </span><span>107</span><span>     </span><span>5.78</span><span>  </span><span>â€¦</span><span> </span><span>6.50</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>372</span><span>  </span><span>Â±</span><span> </span><span>4.43</span><span>      </span><span>363</span><span>  </span><span>â€¦</span><span>  </span><span>390</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>162</span><span>  </span><span>Â±</span><span> </span><span>1.17</span><span>      </span><span>160</span><span>  </span><span>â€¦</span><span>  </span><span>165</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-lookahead ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>62.8</span><span> </span><span>Â±</span><span> </span><span>1.08</span><span>    </span><span>61.3</span><span> </span><span>â€¦</span><span> </span><span>64.3</span><span>          </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.2</span><span> </span><span>Â±</span><span> </span><span>88.6</span><span>    </span><span>64.9</span><span> </span><span>â€¦</span><span> </span><span>65.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>111</span><span>  </span><span>Â±</span><span>  </span><span>454</span><span>      </span><span>110</span><span>  </span><span>â€¦</span><span>  </span><span>112</span><span>           </span><span>        </span><span>âš¡-  1.4% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>209</span><span>  </span><span>Â±</span><span> </span><span>7.60</span><span>      </span><span>209</span><span>  </span><span>â€¦</span><span>  </span><span>209</span><span>           </span><span>        </span><span>âš¡-  2.7% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.91</span><span>  </span><span>Â±</span><span> </span><span>68.1</span><span>     </span><span>5.78</span><span>  </span><span>â€¦</span><span> </span><span>6.09</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>374</span><span>  </span><span>Â±</span><span> </span><span>5.24</span><span>      </span><span>365</span><span>  </span><span>â€¦</span><span>  </span><span>397</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span>  </span><span>964</span><span>       </span><span>162</span><span>  </span><span>â€¦</span><span>  </span><span>168</span><span>           </span><span>          </span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.3</span><span> </span><span>Â±</span><span>  </span><span>843</span><span>    </span><span>40.9</span><span> </span><span>â€¦</span><span> </span><span>45.6</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.5</span><span> </span><span>Â±</span><span> </span><span>83.6</span><span>    </span><span>54.3</span><span> </span><span>â€¦</span><span> </span><span>54.6</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>100</span><span>  </span><span>Â±</span><span>  </span><span>744</span><span>     </span><span>98.4</span><span>  </span><span>â€¦</span><span>  </span><span>103</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>193</span><span>  </span><span>Â±</span><span> </span><span>11.0</span><span>      </span><span>193</span><span>  </span><span>â€¦</span><span>  </span><span>193</span><span>          </span><span>12 (10%)</span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.58</span><span>  </span><span>Â±</span><span> </span><span>40.3</span><span>     </span><span>3.47</span><span>  </span><span>â€¦</span><span> </span><span>3.70</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>363</span><span>  </span><span>Â±</span><span> </span><span>11.3</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>398</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>344</span><span>  </span><span>Â±</span><span> </span><span>1.99</span><span>      </span><span>341</span><span>  </span><span>â€¦</span><span>  </span><span>349</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-lookahead all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>39.4</span><span> </span><span>Â±</span><span>  </span><span>849</span><span>    </span><span>37.2</span><span> </span><span>â€¦</span><span> </span><span>40.8</span><span>         </span><span>14 (11%)</span><span>        </span><span>âš¡-  9.0% Â±  0.5%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.5</span><span> </span><span>Â±</span><span> </span><span>84.3</span><span>    </span><span>54.3</span><span> </span><span>â€¦</span><span> </span><span>54.6</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>84.8</span><span>  </span><span>Â±</span><span>  </span><span>521</span><span>     </span><span>84.0</span><span>  </span><span>â€¦</span><span> </span><span>87.4</span><span>           </span><span>        </span><span>âš¡- 15.5% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>148</span><span>  </span><span>Â±</span><span> </span><span>6.20</span><span>      </span><span>148</span><span>  </span><span>â€¦</span><span>  </span><span>148</span><span>           </span><span>        </span><span>âš¡- 23.2% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.56</span><span>  </span><span>Â±</span><span> </span><span>51.3</span><span>     </span><span>3.47</span><span>  </span><span>â€¦</span><span> </span><span>3.82</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>356</span><span>  </span><span>Â±</span><span> </span><span>7.44</span><span>      </span><span>342</span><span>  </span><span>â€¦</span><span>  </span><span>384</span><span>           </span><span>        </span><span>âš¡-  2.0% Â±  0.7%
</span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>316</span><span>  </span><span>Â±</span><span> </span><span>3.08</span><span>      </span><span>313</span><span>  </span><span>â€¦</span><span>  </span><span>347</span><span>           </span><span>        </span><span>âš¡-  8.1% Â±  0.2%
</span><span></span></code></pre>
</details>
<p>This also explains a few things that I glossed over or deferred until later throughout the article:</p>
<ul>
<li>It&#39;s the primary reason I made all the browsers&#39; implementations conform to the <code>NamedCharacterReferenceMatcher</code> API and thereby converted them all to use the &#39;character-by-character tokenization&#39; strategy (to rule out stuff like this from affecting the results without me realizing it).</li>
<li>It&#39;s the reason that the inexplicable benchmark results at the start of the <a href="#on-the-difficulty-of-benchmarking">&#34;<em>On the difficulty of benchmarking</em>&#34;</a> section showed the Chrome implementation being faster than the DAFSA implementation. I was using a faithful 1:1 port of the Chrome named character reference state at that point, and so the difference was due to the &#39;lookahead&#39; strategy rather than the matching implementation.</li>
<li>It&#39;s a partial explanation for why the results of the &#39;raw matching speed&#39; benchmark (the one that just tests <code>NamedCharacterReferenceMatcher</code> directly without involving the tokenizer) don&#39;t fully translate to equivalent differences in the tokenizer benchmarks.</li>
</ul>
<h3>Another difference I didn&#39;t mention<a id="another-difference-i-didn-t-mention" href="#another-difference-i-didn-t-mention">ðŸ”—</a></h3>
<p>Something else that I&#39;ve failed to mention until now regards exactly how backtracking is performed.</p>

<p>In Ladybird, backtracking is very straightforward: modify the input cursor&#39;s position by subtracting <code>N</code> from the current position (where <code>N</code> is the number of overconsumed code points). This is safe to do from a code point boundary perspective because the input is always UTF-8 encoded, and named character reference matching will only ever consume ASCII characters, so going back <code>N</code> bytes is guaranteed to be equivalent to going back <code>N</code> code points.</p>
<p>In all the other major browsers, though, backtracking is done by re-inserting the overconsumed code points back into the input stream, at the position just after the current code point. That is, it modifies the input stream such that the next code points to-be-tokenized will be those that were just re-inserted.</p>
<p>As of now, I&#39;m unsure if the way that Firefox/Chrome/Safari do it is <em>necessary</em> (and therefore whether or not Ladybird will need to adopt the same strategy to be fully compliant with the spec). If it <em>is</em> necessary, I&#39;m either unaware of the relevant <a href="https://wpt.fyi/">web platform test</a>, or there is a missing web platform test that checks whatever it&#39;s necessary for. If it&#39;s not necessary, then there may be an opportunity in the other browser engines to simplify backtracking when dealing with named character references.</p>
<h2>Further improvements to the DAFSA implementation<a id="further-improvements-to-the-dafsa-implementation" href="#further-improvements-to-the-dafsa-implementation">ðŸ”—</a></h2>
<p>As of the writing of this article, the DAFSA implementation that&#39;s been described so far is exactly what&#39;s in Ladybird. During the process of writing this, though, I came up with some ideas (largely inspired by the Firefox/Chrome/Safari implementations) to improve my implementation by utilizing every last possible bit I could get my hands on. This came in the form of two independent optimizations, with one of them just so happening to <em>barely</em> make the other possible.</p>

<h3>&#39;First layer&#39; acceleration<a id="first-layer-acceleration" href="#first-layer-acceleration">ðŸ”—</a></h3>
<p>A property of named character references that I missed, but that the major browser engines all take advantage of, is that the first character of a named character reference is <em>always</em> within the range of <code>a-z</code> or <code>A-Z</code> (inclusive). In terms of the DAFSA, we can take advantage of this property to accelerate the search for the first character: instead of linearly scanning across the child nodes, we can:</p>
<ul>
<li>Check if the character is an alphabetic ASCII character, and immediately reject any that aren&#39;t</li>
<li>Create a lookup table for alphabetic ASCII characters that has the resulting DAFSA state pre-computed</li>
</ul>
<p>This would turn the <code>O(n)</code> search within the &#39;first layer&#39; of the DAFSA into an <code>O(1)</code> lookup. As for what needs to be stored in the lookup table, remember that we build up a &#39;unique index&#39; when traversing a list of children, with any child that we iterate over adding its <code>number</code> field to the total:</p>
<div>
<svg width="100%" xmlns="http://www.w3.org/2000/svg" style="max-width: 200px;" viewBox="0 0 200 100" role="graphics-document document" aria-roledescription="flowchart-v2"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" id="graph-2326_flowchart-v2-pointEnd"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" id="graph-2326_flowchart-v2-pointStart"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" id="graph-2326_flowchart-v2-circleEnd"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" id="graph-2326_flowchart-v2-circleStart"><circle style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" id="graph-2326_flowchart-v2-crossEnd"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" id="graph-2326_flowchart-v2-crossStart"><path style="stroke-width: 2px; stroke-dasharray: 1px, 0px;" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g><g></g><g><path marker-end="url(#graph-2326_flowchart-v2-pointEnd)" id="L_a_b_0" d="M44,68L53,68"></path><path marker-end="url(#graph-2326_flowchart-v2-pointEnd)" id="L_a_b_0" d="M93,68L102,68"></path><path style="" id="L_root_a_0" d="M86.309,26.735L76.062,29.445C65.815,32.156,45.32,37.578,35.072,41.122C24.825,44.667,24.825,46.333,24.825,47.167L24.825,48"></path><path style="" id="L_root_b_0" d="M89.878,30.303L87.144,32.419C84.41,34.535,78.943,38.768,76.209,41.717C73.475,44.667,73.475,46.333,73.475,47.167L73.475,48"></path><path style="" id="L_root_c_0" d="M106.272,30.303L108.839,32.419C111.407,34.535,116.541,38.768,119.108,41.717C121.675,44.667,121.675,46.333,121.675,47.167L121.675,48"></path><path style="" id="L_root_d_0" d="M109.825,26.75L119.833,29.459C129.841,32.167,149.858,37.583,159.867,41.125C169.875,44.667,169.875,46.333,169.875,47.167L169.875,48"></path></g><g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g><g><g transform="translate(0, 0)"><foreignObject height="0" width="0"></foreignObject></g></g></g><g><g transform="translate(97.57498931884766, 23)" id="flowchart-root-0"><polygon transform="translate(-15,15)" points="15,0 30,-15 15,-30 0,-15"></polygon><g transform="translate(0, 0)" style=""><rect></rect><foreignObject height="0" width="0"></foreignObject></g></g><g transform="translate(24.824996948242188, 67.5)" id="flowchart-a-1"><rect height="39" width="33.649993896484375" y="-19.5" x="-16.824996948242188" ry="19.5" rx="19.5" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>a</p></span></p></foreignObject></g></g><g transform="translate(73.47499084472656, 67.5)" id="flowchart-b-2"><rect height="39" width="33.649993896484375" y="-19.5" x="-16.824996948242188" ry="19.5" rx="19.5" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>b</p></span></p></foreignObject></g></g><g transform="translate(121.67498779296875, 67.5)" id="flowchart-c-3"><rect height="39" width="32.75" y="-19.5" x="-16.375" ry="19.5" rx="19.5" style=""></rect><g transform="translate(-4, -12)" style=""><rect></rect><foreignObject height="24" width="8"><p><span><p>c</p></span></p></foreignObject></g></g><g transform="translate(169.87498474121094, 67.5)" id="flowchart-d-4"><rect height="39" width="33.649993896484375" y="-19.5" x="-16.824996948242188" ry="19.5" rx="19.5" style=""></rect><g transform="translate(-4.4499969482421875, -12)" style=""><rect></rect><foreignObject height="24" width="8.899993896484375"><p><span><p>d</p></span></p></foreignObject></g></g></g></g></g></svg>
<p><i>The <code>number</code> field of the <code>a</code> and <code>b</code> nodes contribute to the unique index when searching for <code>c</code></i></p>
</div>
<p>So, we can pre-compute the accumulated unique index that would result when matching a character in the &#39;first layer,&#39; and then store that in the lookup table. For example, the relevant data for the first four nodes in the first layer of our DAFSA looks like this:</p>
<pre><code><span>    </span><span>.{</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;A&#39;</span><span>,</span><span> </span><span>.</span><span>number</span><span> </span><span>=</span><span> </span><span>27</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;B&#39;</span><span>,</span><span> </span><span>.</span><span>number</span><span> </span><span>=</span><span> </span><span>12</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;C&#39;</span><span>,</span><span> </span><span>.</span><span>number</span><span> </span><span>=</span><span> </span><span>36</span><span> </span><span>},</span><span>
    </span><span>.{</span><span> </span><span>.</span><span>char</span><span> </span><span>=</span><span> </span><span>&#39;D&#39;</span><span>,</span><span> </span><span>.</span><span>number</span><span> </span><span>=</span><span> </span><span>54</span><span> </span><span>},</span><span>
    </span><span>
</span></code></pre>
<p>so the corresponding lookup table entries could look like this:</p>
<pre><code><span>    </span><span>0</span><span>,</span><span>
    </span><span>27</span><span>,</span><span>
    </span><span>39</span><span>,</span><span> </span><span>
    </span><span>75</span><span>,</span><span> </span><span>
    </span><span>
</span></code></pre>
<p>We can then use <code>char - &#39;A&#39;</code> (for uppercase characters) to index into the lookup table and instantly get the final unique index that would have resulted from successfully searching for that character normally (for lowercase characters you&#39;d get the index using <code>char - &#39;a&#39; + 26</code> to allow for using a lookup array with exactly 52 values).</p>
<p>This change alone provides quite a big improvement to raw matching speed, since the &#39;first layer&#39; represents the largest list of children in the DAFSA (by a significant margin):</p>
<pre><code><span>Benchmark 1</span><span>: ./bench-master
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>114</span><span> </span><span>Â±</span><span> </span><span>1.28</span><span>     </span><span>112</span><span> </span><span>â€¦</span><span>  </span><span>116</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>469</span><span>  </span><span>Â±</span><span> </span><span>2.40</span><span>      </span><span>466</span><span>  </span><span>â€¦</span><span>  </span><span>482</span><span>           </span><span>5 (11%)</span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>740</span><span>  </span><span>Â±</span><span> </span><span>1.25</span><span>       </span><span>740</span><span>  </span><span>â€¦</span><span>  </span><span>740</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.27</span><span>  </span><span>Â±</span><span> </span><span>60.6</span><span>     </span><span>6.14</span><span>  </span><span>â€¦</span><span> </span><span>6.48</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>2.05</span><span>  </span><span>Â±</span><span> </span><span>5.11</span><span>      </span><span>979</span><span>   </span><span>â€¦</span><span> </span><span>34.8</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.69</span><span>  </span><span>Â±</span><span> </span><span>13.0</span><span>     </span><span>5.67</span><span>  </span><span>â€¦</span><span> </span><span>5.75</span><span>           </span><span>8 (18%)</span><span>        </span><span></span><span>Benchmark 2</span><span>: ./bench-first-layer-accel
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>68.1</span><span> </span><span>Â±</span><span> </span><span>1.26</span><span>    </span><span>66.6</span><span> </span><span>â€¦</span><span> </span><span>70.3</span><span>          </span><span>        </span><span>âš¡- 40.2% Â±  0.4%
</span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>278</span><span>  </span><span>Â±</span><span>  </span><span>416</span><span>      </span><span>277</span><span>  </span><span>â€¦</span><span>  </span><span>279</span><span>           </span><span>        </span><span>âš¡- 40.7% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>385</span><span>  </span><span>Â±</span><span> </span><span>1.42</span><span>       </span><span>385</span><span>  </span><span>â€¦</span><span>  </span><span>385</span><span>           </span><span>        </span><span>âš¡- 47.9% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.24</span><span>  </span><span>Â±</span><span> </span><span>51.2</span><span>     </span><span>6.14</span><span>  </span><span>â€¦</span><span> </span><span>6.38</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>1.38</span><span>  </span><span>Â±</span><span>  </span><span>346</span><span>      </span><span>1.02</span><span>  </span><span>â€¦</span><span> </span><span>2.40</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>4.79</span><span>  </span><span>Â±</span><span> </span><span>4.33</span><span>     </span><span>4.78</span><span>  </span><span>â€¦</span><span> </span><span>4.80</span><span>           </span><span>        </span><span>âš¡- 15.9% Â±  0.1%
</span><span></span></code></pre>
<h3>Linear scan â†’ binary search<a id="linear-scan-binary-search" href="#linear-scan-binary-search">ðŸ”—</a></h3>
<p>The second improvement is a theoretical one for now: what if we could take the time complexity of searching a list of children from <code>O(n)</code> to <code>O(log n)</code> by using a <a href="https://en.wikipedia.org/wiki/Binary_search">binary search</a>? Let&#39;s think about what changes we&#39;d need to make for that to be possible:</p>
<ol>
<li>Every list of children would need to be sorted</li>
<li>We&#39;d need a way to know the length of a list of children upfront (right now we&#39;d have to iterate through them until we find one with the <code>last_sibling</code> flag set to know where a list of children ends)</li>
<li>We&#39;d need a way to avoid needing to iterate a list of children to build up the unique index</li>
</ol>
<p>For the first point, this is actually already the caseâ€”all lists of children <em>are</em> sorted (note: I&#39;m unsure if this is a coincidental artifact of how I&#39;m constructing my DAFSA, or if it&#39;s a common property of a DAFSA generally). For the second point, we could remove the <code>last_sibling</code> flag and replace it with a <code>children_len</code> field. For the third, we already have a model available for this with the lookup table approach we used for the first layer: we could just store an accumulated <code>number</code> in each <code>Node</code> struct instead of a per-node number.</p>

<h4>The problem<a id="the-problem" href="#the-problem">ðŸ”—</a></h4>
<p>The problem with all this is that there just aren&#39;t enough bits available to store all the information required. For context, here&#39;s the DAFSA <code>Node</code> representation being used currently:</p>
<pre><code><span>const</span><span> </span><span>Node</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span>(</span><span>u32</span><span>)</span><span> </span><span>{</span><span>
    </span><span>char</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
    </span><span>number</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
    </span><span>end_of_word</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
    </span><span>last_sibling</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
    </span><span>_extra</span><span>:</span><span> </span><span>u2</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span>
    </span><span>first_child_index</span><span>:</span><span> </span><span>u12</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>Things to note:</p>
<ul>
<li>We <em>really</em> want to retain the 32-bit size</li>
<li>We currently have 2 bits to spare (<code>_extra</code>)</li>
<li><code>number</code> and <code>first_child_index</code> are currently using the minimum bits required to encode their largest value</li>
</ul>
<p>And we want to:</p>
<ul>
<li>Remove the <code>last_sibling</code> flag and replace it with a <code>children_len</code> field
<ul>
<li>The longest list of children has a length of 52 (the root node&#39;s children), but we can ignore that since we now use a lookup table to &#39;search&#39; the first layer</li>
<li>The longest list of children excluding the first layer has a length of 24, so that requires 5 bits to store</li>
<li>So, we&#39;ll need to store 4 more bits to make this change (replacing a 1-bit field with a 5-bit field)</li>
</ul>
</li>
<li>Store cumulative numbers per-layer instead of storing per-node numbers (e.g. each node should store the number that would be accumulated by searching the list of children and matching that node&#39;s character)
<ul>
<li>For this, we would need the <code>number</code> field to be 12 bits wide, since the largest cumulative number is <code>2218</code></li>
<li>So, we&#39;ll need to store 4 more bits to make this change (replacing an 8-bit field with a 12-bit field)</li>
</ul>
</li>
</ul>
<p>Overall, we need to store 8 more bits of information but only have 2 bits to spare, so somehow we&#39;ll need to eek out 6 extra bits.</p>
<p>Let&#39;s see what we can do...</p>
<h5>A free spare bit<a id="a-free-spare-bit" href="#a-free-spare-bit">ðŸ”—</a></h5>
<p>As mentioned earlier, named character references only contain characters within the ASCII range. This means that we can use a <code>u7</code> instead of a <code>u8</code> for the <code>char</code> field. This gives us an extra spare bit essentially for free (well, it will make the CPU have to do some extra work to retrieve the value of the field, but we&#39;ll ignore that for now).</p>
<p>5 bits to go.</p>
<h5>Zeroing the first layer numbers<a id="zeroing-the-first-layer-numbers" href="#zeroing-the-first-layer-numbers">ðŸ”—</a></h5>
<p>Since we&#39;re using a lookup table for the cumulative numbers of the first layer of nodes, there&#39;s no reason to store real values in the <code>number</code> fields of those nodes in the DAFSA. Removing those values is also extremely helpful because that&#39;s where the largest values appear; the largest cumulative number outside of the first layer is 163 which can be stored in 8 bits (4 bits fewer than we thought we needed for this field).</p>
<p>1 bit to go.</p>
<h5>The final bit<a id="the-final-bit" href="#the-final-bit">ðŸ”—</a></h5>
<p>The last bit is the trickiest, as they say. Instead of jumping straight to an approach that works well, though, let&#39;s try out some interesting approaches that <em>also</em> work but are sub-optimal.</p>
<h6>6-bit <code>char</code><a id="6-bit-char" href="#6-bit-char">ðŸ”—</a></h6>
<p>From the expandable <a href="#nitty-gritty-dafsa-node-size-details">&#34;Nitty-gritty DAFSA node size details&#34;</a> section earlier:</p>
<blockquote>
<p>[The <code>char</code> field] can technically be represented in 6 bits, since the actual alphabet of characters used in the list of named character references only includes 61 unique characters (&#39;1&#39;...&#39;8&#39;, &#39;;&#39;, &#39;a&#39;...&#39;z&#39;, &#39;A&#39;...&#39;Z&#39;). However, to do so you&#39;d need to convert between the 6 bit representation and the actual ASCII value of each character to do comparisons.</p>
</blockquote>
<p>Having to do this extra work when performing any comparison against the <code>char</code> field is not ideal, to the point that it makes the binary search version perform quite a bit worse than the linear scan version (at least with the conversion function I came up with).</p>
<h6>Build the unique index during the binary search<a id="build-the-unique-index-during-the-binary-search" href="#build-the-unique-index-during-the-binary-search">ðŸ”—</a></h6>
<p>One quite-cool-but-also-not-worth-it approach is to avoid storing full cumulative <code>number</code> fields, and instead store incremental numbers that will result in the correct cumulative number if they are combined together in a specific way while performing a binary search. In practice, what that means is:</p>
<ul>
<li>While performing the binary search:
<ul>
<li>If the character we&#39;re searching for is â‰¥ the current node&#39;s character, add the current node&#39;s <code>number</code> value to the total</li>
<li>If the character we&#39;re searching for is &lt; the current node&#39;s character, do not modify the total</li>
</ul>
</li>
</ul>
<p>Here&#39;s a visualization showing how/why this can work, using a particularly relevant list of children (to be discussed afterwards):</p>
<div id="incremental-binary-search-explanation">
  <div>
  <table id="inc-bs-search">
    <thead>
      <tr>
        <th>
          <code><b>char</b></code>
        </th>
        <th>
          <code><b>number</b></code>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr id="a"><td><code>&#39;a&#39;</code></td><td>0</td></tr>
      <tr id="b"><td><code>&#39;b&#39;</code></td><td>1</td></tr>
      <tr id="c"><td><code>&#39;c&#39;</code></td><td>2</td></tr>
      <tr id="d"><td><code>&#39;d&#39;</code></td><td>14</td></tr>
      <tr id="e"><td><code>&#39;e&#39;</code></td><td>19</td></tr>
      <tr id="f"><td><code>&#39;f&#39;</code></td><td>11</td></tr>
      <tr id="h"><td><code>&#39;h&#39;</code></td><td>13</td></tr>
      <tr id="i"><td><code>&#39;i&#39;</code></td><td>20</td></tr>
      <tr id="l"><td><code>&#39;l&#39;</code></td><td>14</td></tr>
      <tr id="m"><td><code>&#39;m&#39;</code></td><td>54</td></tr>
      <tr id="o"><td><code>&#39;o&#39;</code></td><td>8</td></tr>
      <tr id="p"><td><code>&#39;p&#39;</code></td><td>13</td></tr>
      <tr id="q"><td><code>&#39;q&#39;</code></td><td>16</td></tr>
      <tr id="r"><td><code>&#39;r&#39;</code></td><td>16</td></tr>
      <tr id="s"><td><code>&#39;s&#39;</code></td><td>33</td></tr>
      <tr id="t"><td><code>&#39;t&#39;</code></td><td>4</td></tr>
      <tr id="u"><td><code>&#39;u&#39;</code></td><td>9</td></tr>
      <tr id="w"><td><code>&#39;w&#39;</code></td><td>64</td></tr>
      <tr id="z"><td><code>&#39;z&#39;</code></td><td>5</td></tr>
    </tbody>
  </table>
  <div>
    
    <svg style="height: 100%; position: absolute; left: -1rem; top: 0;" viewBox="0 0 100 500" id="inc-bs-svg">
      <g>
        <marker orient="auto" markerHeight="6" markerWidth="6" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" id="inc-binary-search-arrow-end"><path style="stroke-width: 1px; stroke-dasharray: 1px, 0px;" d="M 0 0 L 10 5 L 0 10 z"></path></marker>
        
        
        
        
        
        <g id="inc-bs-f">
          <g>
            <path marker-end="url(#inc-binary-search-arrow-end)" d="M0,263 Q 40,250 40,200 Q 40,140 3,140"></path>
            <path marker-end="url(#inc-binary-search-arrow-end)" d="M0,140 Q 45,180 3,213"></path>
            <path marker-end="url(#inc-binary-search-arrow-end)" d="M0,213 Q 15,200 3,188"></path>
            <path marker-end="url(#inc-binary-search-arrow-end)" d="M0,188 Q 15,178 3,164"></path>
          </g>
        </g>
        
        
        
      </g>
    </svg>
    <table id="inc-bs-tally-table">
      <thead>
        <tr>
          <th>tally</th>
        </tr>
      </thead>
      <tbody>
        <tr id="a"><td>+0</td></tr>
        <tr id="b"><td>+1</td></tr>
        <tr id="c"><td>+2</td></tr>
        <tr id="d"><td>+14</td></tr>
        <tr id="e"><td>+19</td></tr>
        <tr id="f">
          <td>+11<p>30</p></td>
        </tr>
        <tr id="h"><td>+13</td></tr>
        <tr id="i"><td>+20</td></tr>
        <tr id="l"><td>+14</td></tr>
        <tr id="m"><td>+54</td></tr>
        <tr id="o"><td>+8</td></tr>
        <tr id="p"><td>+13</td></tr>
        <tr id="q"><td>+16</td></tr>
        <tr id="r"><td>+16</td></tr>
        <tr id="s"><td>+33</td></tr>
        <tr id="t"><td>+4</td></tr>
        <tr id="u"><td>+9</td></tr>
        <tr id="w"><td>+64</td></tr>
        <tr id="z"><td>+5</td></tr>
      </tbody>
    </table>
  </div>
  <table id="inc-bs-expected">
    <thead>
      <tr>
        <th>expected total</th>
      </tr>
    </thead>
    <tbody>
      <tr id="a"><td>0</td></tr>
      <tr id="b"><td>1</td></tr>
      <tr id="c"><td>2</td></tr>
      <tr id="d"><td>16</td></tr>
      <tr id="e"><td>19</td></tr>
      <tr id="f"><td>30</td></tr>
      <tr id="h"><td>32</td></tr>
      <tr id="i"><td>39</td></tr>
      <tr id="l"><td>53</td></tr>
      <tr id="m"><td>54</td></tr>
      <tr id="o"><td>62</td></tr>
      <tr id="p"><td>67</td></tr>
      <tr id="q"><td>70</td></tr>
      <tr id="r"><td>86</td></tr>
      <tr id="s"><td>87</td></tr>
      <tr id="t"><td>91</td></tr>
      <tr id="u"><td>96</td></tr>
      <tr id="w"><td>151</td></tr>
      <tr id="z"><td>156</td></tr>
    </tbody>
  </table>
  </div>
  

</div>
<p>This specific list of children was chosen because 64 (the <code>number</code> value of the node with the character <code>&#39;w&#39;</code> here) is actually the largest <code>number</code> value in the entire DAFSA after transforming the <code>number</code> fields in this way. This means that instead of 8 bits to store the number field, we only need 7, thus saving the 1 bit that we&#39;re looking for.</p>
<p>Yet again, though, this extra work being done while performing the binary search cancels out the benefit of the binary search, and it ends up being marginally slower than the linear scan version.</p>
<h6>An actually good approach<a id="an-actually-good-approach" href="#an-actually-good-approach">ðŸ”—</a></h6>
<p>The approach I found that works the best is actually quite straightforward to summarize: entirely remove the first layer of nodes from the DAFSA. We can get away with this because we already have a lookup table available for the first layer, so we could theoretically just stuff all the necessary information in there instead of keeping it in the DAFSA.</p>
<p>In practice, it&#39;s not quite as simple as that, though. If you&#39;re interested in the details, expand below:</p>
<details>
<summary>Nitty-gritty details of removing the first layer from the DAFSA</summary>
<p>After adding the lookup table for the first layer, <code>NamedCharacterReferenceMatcher</code> uses this approach:</p>
<ul>
<li>Start with <code>node_index</code> set to 0</li>
<li>If <code>node_index</code> is currently 0, verify that the current character is within <code>a-z</code> or <code>A-Z</code>, and, if so, look up the cumulative unique index in the lookup table. Set the <code>node_index</code> to the <code>&lt;lookup table index&gt; + 1</code> (since the first layer of nodes in the DAFSA always follow the root node)</li>
<li>If <code>node_index</code> is not 0, do DAFSA traversal as normal (search the node&#39;s children starting at <code>nodes[node_index].first_child_index</code>)</li>
</ul>
<p>This means that we&#39;re currently relying on the first layer of nodes being in the DAFSA in order to allow for <code>node_index</code> to be used as a universal &#39;cursor&#39; that tracks where we are in the DAFSA. If we simply remove the first layer of nodes, then we&#39;d need two separate cursors: 1 that we would use for the lookup table, and 1 that we would use for the DAFSA nodes array. That might not be a bad approach, but what I went for instead is this:</p>
<ul>
<li>Instead of storing a <code>node_index</code> in <code>NamedCharacterReferenceMatcher</code>, store an optional slice of children to check (<code>?[]const Node</code>) that starts as <code>null</code></li>
<li>If <code>children_to_check</code> is <code>null</code>, use the first layer lookup table to get three pieces of information: (1) the cumulative unique index number, (2) the index of the node&#39;s first child in the DAFSA array, and (3) the length of the node&#39;s list of children. Set <code>children_to_check</code> to a slice of the DAFSA array with the retrieved length, and starting at the retrieved first child index</li>
<li>If <code>children_to_check</code> is not <code>null</code>, search within the <code>children_to_check</code> slice as normal</li>
</ul>
</details>
<p>It might not be completely obvious how this saves us a bit, but removing the first layer also happens to remove the largest values of our added <code>children_len</code> field. Somewhat miraculously, the new largest value is 13 (down from 24), so instead of needing 5 bits, we now only need 4 bits for that field.</p>
<h4>Putting it all together<a id="putting-it-all-together" href="#putting-it-all-together">ðŸ”—</a></h4>
<p>After all that, we end up with two <code>struct</code> representations for the data we&#39;re looking to store:</p>
<p>One for the first layer lookup table:</p>
<pre><code><span>const</span><span> </span><span>FirstLayerNode</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span> </span><span>{</span><span>
    </span><span>number</span><span>:</span><span> </span><span>u12</span><span>,</span><span>
    </span><span>child_index</span><span>:</span><span> </span><span>u10</span><span>,</span><span>
    </span><span>children_len</span><span>:</span><span> </span><span>u5</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>and one for the rest of the DAFSA nodes:</p>
<pre><code><span>const</span><span> </span><span>Node</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span>(</span><span>u32</span><span>)</span><span> </span><span>{</span><span>
    </span><span>char</span><span>:</span><span> </span><span>u7</span><span>,</span><span>
    </span><span>number</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
    </span><span>end_of_word</span><span>:</span><span> </span><span>bool</span><span>,</span><span>
    </span><span>children_len</span><span>:</span><span> </span><span>u4</span><span>,</span><span>
    </span><span>child_index</span><span>:</span><span> </span><span>u12</span><span>,</span><span>
</span><span>};</span><span>
</span></code></pre>

<p>With this, we can accelerate the search time for the first character drastically, and make it possible to use a binary search for all the rest of the searches we perform. In terms of raw matching speed, this provides another decent improvement over the first layer lookup table alone:</p>
<pre><code><span>Benchmark 1</span><span>: ./bench-master
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>115</span><span> </span><span>Â±</span><span> </span><span>1.73</span><span>     </span><span>112</span><span> </span><span>â€¦</span><span>  </span><span>118</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>            </span><span>754</span><span> </span><span>Â±</span><span>  </span><span>617</span><span>       </span><span>750</span><span> </span><span>â€¦</span><span>  </span><span>754</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>471</span><span>  </span><span>Â±</span><span> </span><span>2.35</span><span>      </span><span>467</span><span>  </span><span>â€¦</span><span>  </span><span>478</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>740</span><span>  </span><span>Â±</span><span> </span><span>1.65</span><span>       </span><span>740</span><span>  </span><span>â€¦</span><span>  </span><span>740</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.30</span><span>  </span><span>Â±</span><span> </span><span>53.8</span><span>     </span><span>6.14</span><span>  </span><span>â€¦</span><span> </span><span>6.38</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>6.81</span><span>  </span><span>Â±</span><span> </span><span>5.18</span><span>     </span><span>1.19</span><span>  </span><span>â€¦</span><span> </span><span>19.4</span><span>           </span><span>6 (14%)</span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.70</span><span>  </span><span>Â±</span><span> </span><span>14.3</span><span>     </span><span>5.68</span><span>  </span><span>â€¦</span><span> </span><span>5.74</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./bench-first-layer-accel
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>69.0</span><span> </span><span>Â±</span><span> </span><span>1.70</span><span>    </span><span>66.7</span><span> </span><span>â€¦</span><span> </span><span>71.3</span><span>          </span><span>        </span><span>âš¡- 40.0% Â±  0.6%
</span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>279</span><span>  </span><span>Â±</span><span> </span><span>1.18</span><span>      </span><span>277</span><span>  </span><span>â€¦</span><span>  </span><span>282</span><span>           </span><span>        </span><span>âš¡- 40.7% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>385</span><span>  </span><span>Â±</span><span> </span><span>2.77</span><span>       </span><span>385</span><span>  </span><span>â€¦</span><span>  </span><span>385</span><span>           </span><span>        </span><span>âš¡- 47.9% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.29</span><span>  </span><span>Â±</span><span> </span><span>73.4</span><span>     </span><span>6.14</span><span>  </span><span>â€¦</span><span> </span><span>6.51</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>8.70</span><span>  </span><span>Â±</span><span> </span><span>6.54</span><span>     </span><span>1.13</span><span>  </span><span>â€¦</span><span> </span><span>21.8</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>4.79</span><span>  </span><span>Â±</span><span> </span><span>9.12</span><span>     </span><span>4.78</span><span>  </span><span>â€¦</span><span> </span><span>4.82</span><span>           </span><span>        </span><span>âš¡- 15.9% Â±  0.1%
</span><span></span><span>Benchmark 3</span><span>: ./bench-first-layer-accel-binary-search-u7-char-u8-number
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>60.6</span><span> </span><span>Â±</span><span> </span><span>3.40</span><span>    </span><span>58.3</span><span> </span><span>â€¦</span><span> </span><span>81.0</span><span>          </span><span>        </span><span>âš¡- 47.3% Â±  0.9%
</span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>244</span><span>  </span><span>Â±</span><span> </span><span>1.35</span><span>      </span><span>242</span><span>  </span><span>â€¦</span><span>  </span><span>251</span><span>           </span><span>        </span><span>âš¡- 48.1% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>431</span><span>  </span><span>Â±</span><span> </span><span>3.45</span><span>       </span><span>431</span><span>  </span><span>â€¦</span><span>  </span><span>431</span><span>           </span><span>        </span><span>âš¡- 41.8% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.30</span><span>  </span><span>Â±</span><span> </span><span>87.0</span><span>     </span><span>6.12</span><span>  </span><span>â€¦</span><span> </span><span>6.47</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>6.66</span><span>  </span><span>Â±</span><span> </span><span>3.61</span><span>     </span><span>1.19</span><span>  </span><span>â€¦</span><span> </span><span>16.4</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>4.92</span><span>  </span><span>Â±</span><span> </span><span>18.7</span><span>     </span><span>4.89</span><span>  </span><span>â€¦</span><span> </span><span>5.00</span><span>          </span><span>15 (18%)</span><span>        </span><span>âš¡- 13.6% Â±  0.1%
</span><span></span></code></pre>

<p>Taken together (the Benchmark 3 results), these two optimizations make raw matching speed about 1.9x faster than it was originally.</p>

<p>As mentioned, though, these raw matching speed improvements don&#39;t translate to nearly the same improvement when benchmarking this <a href="https://github.com/squeek502/ladybird/tree/dafsa-binary-search">new implementation within the Ladybird tokenizer</a> (note also that these benchmarks don&#39;t use the &#39;lookahead when outside of an insertion point&#39; optimization).</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>113</span><span> </span><span>Â±</span><span> </span><span>1.10</span><span>     </span><span>112</span><span> </span><span>â€¦</span><span>  </span><span>115</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.3</span><span> </span><span>Â±</span><span> </span><span>78.1</span><span>    </span><span>83.1</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>         </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>228</span><span>  </span><span>Â±</span><span>  </span><span>827</span><span>      </span><span>227</span><span>  </span><span>â€¦</span><span>  </span><span>231</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>450</span><span>  </span><span>Â±</span><span> </span><span>4.99</span><span>      </span><span>450</span><span>  </span><span>â€¦</span><span>  </span><span>450</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.43</span><span>  </span><span>Â±</span><span>  </span><span>266</span><span>     </span><span>9.28</span><span>  </span><span>â€¦</span><span> </span><span>11.9</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>404</span><span>  </span><span>Â±</span><span> </span><span>4.56</span><span>      </span><span>393</span><span>  </span><span>â€¦</span><span>  </span><span>417</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>574</span><span>  </span><span>Â±</span><span> </span><span>7.43</span><span>      </span><span>570</span><span>  </span><span>â€¦</span><span>  </span><span>641</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-binary-search
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>109</span><span> </span><span>Â±</span><span> </span><span>1.10</span><span>     </span><span>107</span><span> </span><span>â€¦</span><span>  </span><span>111</span><span>          </span><span>        </span><span>âš¡-  3.8% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.3</span><span> </span><span>Â±</span><span> </span><span>74.0</span><span>    </span><span>83.1</span><span> </span><span>â€¦</span><span> </span><span>83.5</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>210</span><span>  </span><span>Â±</span><span>  </span><span>778</span><span>      </span><span>209</span><span>  </span><span>â€¦</span><span>  </span><span>212</span><span>           </span><span>        </span><span>âš¡-  7.9% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>417</span><span>  </span><span>Â±</span><span> </span><span>4.75</span><span>      </span><span>417</span><span>  </span><span>â€¦</span><span>  </span><span>417</span><span>           </span><span>        </span><span>âš¡-  7.3% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.39</span><span>  </span><span>Â±</span><span>  </span><span>124</span><span>     </span><span>9.21</span><span>  </span><span>â€¦</span><span> </span><span>10.4</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>407</span><span>  </span><span>Â±</span><span> </span><span>5.47</span><span>      </span><span>395</span><span>  </span><span>â€¦</span><span>  </span><span>423</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>533</span><span>  </span><span>Â±</span><span> </span><span>1.50</span><span>      </span><span>530</span><span>  </span><span>â€¦</span><span>  </span><span>542</span><span>           </span><span>        </span><span>âš¡-  7.0% Â±  0.3%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>45.8</span><span> </span><span>Â±</span><span>  </span><span>658</span><span>    </span><span>43.6</span><span> </span><span>â€¦</span><span> </span><span>47.0</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>84.2</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>117</span><span>  </span><span>Â±</span><span>  </span><span>581</span><span>      </span><span>116</span><span>  </span><span>â€¦</span><span>  </span><span>119</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>259</span><span>  </span><span>Â±</span><span> </span><span>5.32</span><span>      </span><span>259</span><span>  </span><span>â€¦</span><span>  </span><span>259</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.25</span><span>  </span><span>Â±</span><span> </span><span>82.1</span><span>     </span><span>3.16</span><span>  </span><span>â€¦</span><span> </span><span>4.05</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>355</span><span>  </span><span>Â±</span><span> </span><span>5.76</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>376</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>182</span><span>  </span><span>Â±</span><span> </span><span>2.45</span><span>      </span><span>178</span><span>  </span><span>â€¦</span><span>  </span><span>200</span><span>          </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-binary-search gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>42.4</span><span> </span><span>Â±</span><span>  </span><span>921</span><span>    </span><span>40.2</span><span> </span><span>â€¦</span><span> </span><span>43.8</span><span>          </span><span>        </span><span>âš¡-  7.5% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.0</span><span> </span><span>Â±</span><span> </span><span>77.8</span><span>    </span><span>52.7</span><span> </span><span>â€¦</span><span> </span><span>53.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>103</span><span>  </span><span>Â±</span><span>  </span><span>771</span><span>      </span><span>101</span><span>  </span><span>â€¦</span><span>  </span><span>106</span><span>           </span><span>        </span><span>âš¡- 12.3% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>220</span><span>  </span><span>Â±</span><span> </span><span>8.52</span><span>      </span><span>220</span><span>  </span><span>â€¦</span><span>  </span><span>220</span><span>          </span><span>        </span><span>âš¡- 15.1% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.27</span><span>  </span><span>Â±</span><span>  </span><span>109</span><span>     </span><span>3.18</span><span>  </span><span>â€¦</span><span> </span><span>4.16</span><span>          </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>360</span><span>  </span><span>Â±</span><span> </span><span>8.94</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>394</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>189</span><span>  </span><span>Â±</span><span> </span><span>7.40</span><span>      </span><span>179</span><span>  </span><span>â€¦</span><span>  </span><span>215</span><span>           </span><span>        </span><span>ðŸ’©+  3.8% Â±  0.6%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>63.2</span><span> </span><span>Â±</span><span>  </span><span>859</span><span>    </span><span>61.3</span><span> </span><span>â€¦</span><span> </span><span>64.6</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>85.1</span><span>    </span><span>64.8</span><span> </span><span>â€¦</span><span> </span><span>65.2</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>112</span><span>  </span><span>Â±</span><span>  </span><span>550</span><span>      </span><span>111</span><span>  </span><span>â€¦</span><span>  </span><span>115</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>214</span><span>  </span><span>Â±</span><span> </span><span>7.62</span><span>      </span><span>214</span><span>  </span><span>â€¦</span><span>  </span><span>214</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.87</span><span>  </span><span>Â±</span><span> </span><span>82.4</span><span>     </span><span>5.77</span><span>  </span><span>â€¦</span><span> </span><span>6.52</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>374</span><span>  </span><span>Â±</span><span> </span><span>4.78</span><span>      </span><span>365</span><span>  </span><span>â€¦</span><span>  </span><span>405</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span> </span><span>4.62</span><span>      </span><span>160</span><span>  </span><span>â€¦</span><span>  </span><span>219</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-binary-search ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>61.4</span><span> </span><span>Â±</span><span>  </span><span>833</span><span>    </span><span>59.3</span><span> </span><span>â€¦</span><span> </span><span>62.8</span><span>          </span><span>        </span><span>âš¡-  2.9% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.1</span><span> </span><span>Â±</span><span> </span><span>76.6</span><span>    </span><span>64.8</span><span> </span><span>â€¦</span><span> </span><span>65.2</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>105</span><span>  </span><span>Â±</span><span>  </span><span>573</span><span>      </span><span>104</span><span>  </span><span>â€¦</span><span>  </span><span>107</span><span>           </span><span>        </span><span>âš¡-  6.6% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>195</span><span>  </span><span>Â±</span><span> </span><span>7.30</span><span>      </span><span>195</span><span>  </span><span>â€¦</span><span>  </span><span>195</span><span>           </span><span>        </span><span>âš¡-  8.8% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.87</span><span>  </span><span>Â±</span><span> </span><span>94.8</span><span>     </span><span>5.79</span><span>  </span><span>â€¦</span><span> </span><span>6.87</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>375</span><span>  </span><span>Â±</span><span> </span><span>4.47</span><span>      </span><span>365</span><span>  </span><span>â€¦</span><span>  </span><span>388</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span> </span><span>3.11</span><span>      </span><span>162</span><span>  </span><span>â€¦</span><span>  </span><span>202</span><span>           </span><span>          </span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.3</span><span> </span><span>Â±</span><span>  </span><span>635</span><span>    </span><span>41.1</span><span> </span><span>â€¦</span><span> </span><span>44.9</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.4</span><span> </span><span>Â±</span><span> </span><span>90.7</span><span>    </span><span>54.0</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>102</span><span>  </span><span>Â±</span><span>  </span><span>651</span><span>      </span><span>101</span><span>  </span><span>â€¦</span><span>  </span><span>106</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>191</span><span>  </span><span>Â±</span><span> </span><span>8.94</span><span>      </span><span>191</span><span>  </span><span>â€¦</span><span>  </span><span>191</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.55</span><span>  </span><span>Â±</span><span> </span><span>48.8</span><span>     </span><span>3.48</span><span>  </span><span>â€¦</span><span> </span><span>3.88</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>358</span><span>  </span><span>Â±</span><span> </span><span>8.22</span><span>      </span><span>342</span><span>  </span><span>â€¦</span><span>  </span><span>387</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>344</span><span>  </span><span>Â±</span><span> </span><span>4.30</span><span>      </span><span>340</span><span>  </span><span>â€¦</span><span>  </span><span>405</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer dafsa-binary-search all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>40.4</span><span> </span><span>Â±</span><span>  </span><span>754</span><span>    </span><span>38.1</span><span> </span><span>â€¦</span><span> </span><span>42.3</span><span>         </span><span>        </span><span>âš¡-  6.7% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.4</span><span> </span><span>Â±</span><span> </span><span>73.5</span><span>    </span><span>54.1</span><span> </span><span>â€¦</span><span> </span><span>54.5</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>90.1</span><span>  </span><span>Â±</span><span>  </span><span>522</span><span>     </span><span>88.8</span><span>  </span><span>â€¦</span><span> </span><span>92.3</span><span>           </span><span>        </span><span>âš¡- 11.8% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>170</span><span>  </span><span>Â±</span><span> </span><span>7.36</span><span>      </span><span>170</span><span>  </span><span>â€¦</span><span>  </span><span>170</span><span>          </span><span>        </span><span>âš¡- 11.0% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.54</span><span>  </span><span>Â±</span><span> </span><span>32.2</span><span>     </span><span>3.46</span><span>  </span><span>â€¦</span><span> </span><span>3.68</span><span>           </span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>356</span><span>  </span><span>Â±</span><span> </span><span>6.32</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>379</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>314</span><span>  </span><span>Â±</span><span> </span><span>1.08</span><span>      </span><span>311</span><span>  </span><span>â€¦</span><span>  </span><span>319</span><span>           </span><span>        </span><span>âš¡-  8.8% Â±  0.2%
</span><span></span></code></pre>
<p>However, it&#39;s enough to put this new DAFSA implementation ahead of the Firefox and Chrome/Sarafi implementations in all of the benchmarks I&#39;m using.</p>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa-binary-search
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>110</span><span> </span><span>Â±</span><span>  </span><span>956</span><span>     </span><span>108</span><span> </span><span>â€¦</span><span>  </span><span>111</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.5</span><span> </span><span>Â±</span><span> </span><span>79.4</span><span>    </span><span>83.2</span><span> </span><span>â€¦</span><span> </span><span>83.6</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>212</span><span>  </span><span>Â±</span><span> </span><span>1.31</span><span>      </span><span>209</span><span>  </span><span>â€¦</span><span>  </span><span>217</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>420</span><span>  </span><span>Â±</span><span> </span><span>9.03</span><span>      </span><span>420</span><span>  </span><span>â€¦</span><span>  </span><span>420</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.57</span><span>  </span><span>Â±</span><span>  </span><span>186</span><span>     </span><span>9.36</span><span>  </span><span>â€¦</span><span> </span><span>10.9</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>405</span><span>  </span><span>Â±</span><span> </span><span>5.61</span><span>      </span><span>394</span><span>  </span><span>â€¦</span><span>  </span><span>421</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>535</span><span>  </span><span>Â±</span><span> </span><span>1.70</span><span>      </span><span>532</span><span>  </span><span>â€¦</span><span>  </span><span>540</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer gecko
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>113</span><span> </span><span>Â±</span><span> </span><span>1.02</span><span>     </span><span>111</span><span> </span><span>â€¦</span><span>  </span><span>115</span><span>          </span><span>        </span><span>ðŸ’©+  2.6% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.6</span><span> </span><span>Â±</span><span> </span><span>70.9</span><span>    </span><span>83.3</span><span> </span><span>â€¦</span><span> </span><span>83.6</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>225</span><span>  </span><span>Â±</span><span> </span><span>1.28</span><span>      </span><span>223</span><span>  </span><span>â€¦</span><span>  </span><span>234</span><span>           </span><span>        </span><span>ðŸ’©+  5.8% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>441</span><span>  </span><span>Â±</span><span> </span><span>7.17</span><span>      </span><span>441</span><span>  </span><span>â€¦</span><span>  </span><span>441</span><span>           </span><span>        </span><span>ðŸ’©+  5.0% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>9.85</span><span>  </span><span>Â±</span><span>  </span><span>227</span><span>     </span><span>9.64</span><span>  </span><span>â€¦</span><span> </span><span>11.3</span><span>           </span><span>        </span><span>ðŸ’©+  2.9% Â±  0.6%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>411</span><span>  </span><span>Â±</span><span> </span><span>5.54</span><span>      </span><span>402</span><span>  </span><span>â€¦</span><span>  </span><span>431</span><span>           </span><span>        </span><span>ðŸ’©+  1.5% Â±  0.4%
</span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>581</span><span>  </span><span>Â±</span><span> </span><span>19.0</span><span>      </span><span>575</span><span>  </span><span>â€¦</span><span>  </span><span>758</span><span>           </span><span>        </span><span>ðŸ’©+  8.5% Â±  0.7%
</span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizer blink
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>115</span><span> </span><span>Â±</span><span>  </span><span>856</span><span>     </span><span>113</span><span> </span><span>â€¦</span><span>  </span><span>117</span><span>          </span><span>        </span><span>ðŸ’©+  4.5% Â±  0.2%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>83.5</span><span> </span><span>Â±</span><span> </span><span>72.4</span><span>    </span><span>83.2</span><span> </span><span>â€¦</span><span> </span><span>83.6</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>232</span><span>  </span><span>Â±</span><span>  </span><span>940</span><span>      </span><span>230</span><span>  </span><span>â€¦</span><span>  </span><span>235</span><span>           </span><span>        </span><span>ðŸ’©+  9.4% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>463</span><span>  </span><span>Â±</span><span> </span><span>8.80</span><span>      </span><span>463</span><span>  </span><span>â€¦</span><span>  </span><span>463</span><span>           </span><span>        </span><span>ðŸ’©+ 10.4% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>10.2</span><span>  </span><span>Â±</span><span>  </span><span>141</span><span>     </span><span>9.94</span><span>  </span><span>â€¦</span><span> </span><span>10.9</span><span>           </span><span>        </span><span>ðŸ’©+  6.1% Â±  0.5%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>410</span><span>  </span><span>Â±</span><span> </span><span>5.40</span><span>      </span><span>398</span><span>  </span><span>â€¦</span><span>  </span><span>424</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>751</span><span>  </span><span>Â±</span><span> </span><span>1.90</span><span>      </span><span>747</span><span>  </span><span>â€¦</span><span>  </span><span>755</span><span>           </span><span>        </span><span>ðŸ’©+ 40.3% Â±  0.1%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa-binary-search gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>42.6</span><span> </span><span>Â±</span><span>  </span><span>717</span><span>    </span><span>40.3</span><span> </span><span>â€¦</span><span> </span><span>44.2</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.2</span><span> </span><span>Â±</span><span> </span><span>90.0</span><span>    </span><span>52.8</span><span> </span><span>â€¦</span><span> </span><span>53.4</span><span>         </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>103</span><span>  </span><span>Â±</span><span>  </span><span>604</span><span>      </span><span>101</span><span>  </span><span>â€¦</span><span>  </span><span>105</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>222</span><span>  </span><span>Â±</span><span> </span><span>6.94</span><span>      </span><span>222</span><span>  </span><span>â€¦</span><span>  </span><span>222</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.27</span><span>  </span><span>Â±</span><span> </span><span>96.0</span><span>     </span><span>3.19</span><span>  </span><span>â€¦</span><span> </span><span>3.98</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>356</span><span>  </span><span>Â±</span><span> </span><span>5.77</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>377</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>182</span><span>  </span><span>Â±</span><span> </span><span>3.18</span><span>      </span><span>178</span><span>  </span><span>â€¦</span><span>  </span><span>215</span><span>          </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer gecko gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>50.5</span><span> </span><span>Â±</span><span>  </span><span>831</span><span>    </span><span>48.5</span><span> </span><span>â€¦</span><span> </span><span>52.4</span><span>         </span><span>20 (10%)</span><span>        </span><span>ðŸ’©+ 18.7% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.2</span><span> </span><span>Â±</span><span> </span><span>84.3</span><span>    </span><span>53.0</span><span> </span><span>â€¦</span><span> </span><span>53.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>138</span><span>  </span><span>Â±</span><span>  </span><span>610</span><span>      </span><span>136</span><span>  </span><span>â€¦</span><span>  </span><span>139</span><span>           </span><span>        </span><span>ðŸ’©+ 33.8% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>280</span><span>  </span><span>Â±</span><span> </span><span>7.27</span><span>      </span><span>280</span><span>  </span><span>â€¦</span><span>  </span><span>280</span><span>           </span><span>        </span><span>ðŸ’©+ 26.3% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.34</span><span>  </span><span>Â±</span><span>  </span><span>118</span><span>     </span><span>3.22</span><span>  </span><span>â€¦</span><span> </span><span>4.58</span><span>           </span><span>        </span><span>ðŸ’©+  2.1% Â±  0.6%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>356</span><span>  </span><span>Â±</span><span> </span><span>5.10</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>372</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>315</span><span>  </span><span>Â±</span><span> </span><span>5.57</span><span>      </span><span>305</span><span>  </span><span>â€¦</span><span>  </span><span>346</span><span>           </span><span>        </span><span>ðŸ’©+ 72.8% Â±  0.5%
</span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizer blink gecko-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>47.1</span><span> </span><span>Â±</span><span>  </span><span>620</span><span>    </span><span>44.9</span><span> </span><span>â€¦</span><span> </span><span>48.3</span><span>         </span><span>        </span><span>ðŸ’©+ 10.6% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>53.2</span><span> </span><span>Â±</span><span> </span><span>84.0</span><span>    </span><span>52.8</span><span> </span><span>â€¦</span><span> </span><span>53.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>122</span><span>  </span><span>Â±</span><span>  </span><span>745</span><span>      </span><span>121</span><span>  </span><span>â€¦</span><span>  </span><span>127</span><span>           </span><span>        </span><span>ðŸ’©+ 18.5% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>292</span><span>  </span><span>Â±</span><span> </span><span>5.64</span><span>      </span><span>292</span><span>  </span><span>â€¦</span><span>  </span><span>292</span><span>           </span><span>        </span><span>ðŸ’©+ 31.7% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.30</span><span>  </span><span>Â±</span><span>  </span><span>139</span><span>     </span><span>3.19</span><span>  </span><span>â€¦</span><span> </span><span>4.78</span><span>          </span><span>24 (11%)</span><span>          </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>355</span><span>  </span><span>Â±</span><span> </span><span>5.58</span><span>      </span><span>343</span><span>  </span><span>â€¦</span><span>  </span><span>371</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>183</span><span>  </span><span>Â±</span><span>  </span><span>710</span><span>       </span><span>180</span><span>  </span><span>â€¦</span><span>  </span><span>185</span><span>           </span><span>          </span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa-binary-search ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>62.4</span><span> </span><span>Â±</span><span> </span><span>1.16</span><span>    </span><span>60.4</span><span> </span><span>â€¦</span><span> </span><span>64.8</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.3</span><span> </span><span>Â±</span><span> </span><span>81.8</span><span>    </span><span>64.9</span><span> </span><span>â€¦</span><span> </span><span>65.4</span><span>         </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>107</span><span>  </span><span>Â±</span><span>  </span><span>850</span><span>      </span><span>105</span><span>  </span><span>â€¦</span><span>  </span><span>114</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>196</span><span>  </span><span>Â±</span><span> </span><span>12.0</span><span>      </span><span>196</span><span>  </span><span>â€¦</span><span>  </span><span>196</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>5.92</span><span>  </span><span>Â±</span><span> </span><span>73.9</span><span>     </span><span>5.81</span><span>  </span><span>â€¦</span><span> </span><span>6.21</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>386</span><span>  </span><span>Â±</span><span> </span><span>7.90</span><span>      </span><span>369</span><span>  </span><span>â€¦</span><span>  </span><span>409</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>164</span><span>  </span><span>Â±</span><span> </span><span>1.74</span><span>      </span><span>161</span><span>  </span><span>â€¦</span><span>  </span><span>179</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer gecko ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>62.3</span><span> </span><span>Â±</span><span>  </span><span>988</span><span>    </span><span>59.7</span><span> </span><span>â€¦</span><span> </span><span>64.1</span><span>          </span><span>          </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.3</span><span> </span><span>Â±</span><span> </span><span>79.2</span><span>    </span><span>65.0</span><span> </span><span>â€¦</span><span> </span><span>65.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>106</span><span>  </span><span>Â±</span><span>  </span><span>618</span><span>      </span><span>104</span><span>  </span><span>â€¦</span><span>  </span><span>108</span><span>           </span><span>          </span><span></span><span>  </span><span>instructions</span><span>        </span><span>195</span><span>  </span><span>Â±</span><span> </span><span>12.6</span><span>      </span><span>195</span><span>  </span><span>â€¦</span><span>  </span><span>195</span><span>          </span><span>          </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.03</span><span>  </span><span>Â±</span><span>  </span><span>169</span><span>     </span><span>5.84</span><span>  </span><span>â€¦</span><span> </span><span>6.99</span><span>           </span><span>        </span><span>ðŸ’©+  1.9% Â±  0.5%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>386</span><span>  </span><span>Â±</span><span> </span><span>7.61</span><span>      </span><span>370</span><span>  </span><span>â€¦</span><span>  </span><span>413</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>165</span><span>  </span><span>Â±</span><span> </span><span>1.02</span><span>      </span><span>163</span><span>  </span><span>â€¦</span><span>  </span><span>169</span><span>           </span><span>          </span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizer blink ladybird-worst-case
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>63.4</span><span> </span><span>Â±</span><span> </span><span>1.22</span><span>    </span><span>61.0</span><span> </span><span>â€¦</span><span> </span><span>65.3</span><span>          </span><span>        </span><span>ðŸ’©+  1.7% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>65.2</span><span> </span><span>Â±</span><span> </span><span>78.2</span><span>    </span><span>65.0</span><span> </span><span>â€¦</span><span> </span><span>65.4</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>109</span><span>  </span><span>Â±</span><span>  </span><span>789</span><span>      </span><span>107</span><span>  </span><span>â€¦</span><span>  </span><span>115</span><span>           </span><span>        </span><span>ðŸ’©+  2.0% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>204</span><span>  </span><span>Â±</span><span> </span><span>11.7</span><span>      </span><span>203</span><span>  </span><span>â€¦</span><span>  </span><span>204</span><span>           </span><span>        </span><span>ðŸ’©+  3.7% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.00</span><span>  </span><span>Â±</span><span> </span><span>90.0</span><span>     </span><span>5.85</span><span>  </span><span>â€¦</span><span> </span><span>6.25</span><span>           </span><span>        </span><span>ðŸ’©+  1.4% Â±  0.3%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>388</span><span>  </span><span>Â±</span><span> </span><span>8.11</span><span>      </span><span>371</span><span>  </span><span>â€¦</span><span>  </span><span>409</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>165</span><span>  </span><span>Â±</span><span> </span><span>1.24</span><span>      </span><span>162</span><span>  </span><span>â€¦</span><span>  </span><span>173</span><span>           </span><span>          </span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchHTMLTokenizer dafsa-binary-search all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>41.0</span><span> </span><span>Â±</span><span>  </span><span>843</span><span>    </span><span>38.3</span><span> </span><span>â€¦</span><span> </span><span>42.2</span><span>         </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.5</span><span> </span><span>Â±</span><span> </span><span>87.9</span><span>    </span><span>54.3</span><span> </span><span>â€¦</span><span> </span><span>54.6</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>         </span><span>90.6</span><span>  </span><span>Â±</span><span>  </span><span>591</span><span>     </span><span>89.6</span><span>  </span><span>â€¦</span><span> </span><span>92.6</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>172</span><span>  </span><span>Â±</span><span> </span><span>9.67</span><span>      </span><span>172</span><span>  </span><span>â€¦</span><span>  </span><span>172</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.56</span><span>  </span><span>Â±</span><span>  </span><span>117</span><span>     </span><span>3.47</span><span>  </span><span>â€¦</span><span> </span><span>5.05</span><span>          </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>359</span><span>  </span><span>Â±</span><span> </span><span>9.17</span><span>      </span><span>343</span><span>  </span><span>â€¦</span><span>  </span><span>399</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>316</span><span>  </span><span>Â±</span><span> </span><span>4.49</span><span>      </span><span>312</span><span>  </span><span>â€¦</span><span>  </span><span>382</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchHTMLTokenizer gecko all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>43.7</span><span> </span><span>Â±</span><span>  </span><span>735</span><span>    </span><span>41.4</span><span> </span><span>â€¦</span><span> </span><span>44.9</span><span>         </span><span>        </span><span>ðŸ’©+  6.6% Â±  0.3%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.6</span><span> </span><span>Â±</span><span> </span><span>85.1</span><span>    </span><span>54.3</span><span> </span><span>â€¦</span><span> </span><span>54.8</span><span>          </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>103</span><span>  </span><span>Â±</span><span>  </span><span>460</span><span>      </span><span>102</span><span>  </span><span>â€¦</span><span>  </span><span>105</span><span>           </span><span>        </span><span>ðŸ’©+ 13.6% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>189</span><span>  </span><span>Â±</span><span> </span><span>4.69</span><span>      </span><span>189</span><span>  </span><span>â€¦</span><span>  </span><span>189</span><span>           </span><span>        </span><span>ðŸ’©+ 10.1% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.65</span><span>  </span><span>Â±</span><span> </span><span>93.4</span><span>     </span><span>3.54</span><span>  </span><span>â€¦</span><span> </span><span>4.77</span><span>          </span><span>        </span><span>ðŸ’©+  2.5% Â±  0.5%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>356</span><span>  </span><span>Â±</span><span> </span><span>5.90</span><span>      </span><span>344</span><span>  </span><span>â€¦</span><span>  </span><span>377</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>385</span><span>  </span><span>Â±</span><span>  </span><span>861</span><span>       </span><span>383</span><span>  </span><span>â€¦</span><span>  </span><span>388</span><span>           </span><span>        </span><span>ðŸ’©+ 21.8% Â±  0.2%
</span><span></span><span>Benchmark 3</span><span>: ./BenchHTMLTokenizer blink all-valid
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>44.6</span><span> </span><span>Â±</span><span>  </span><span>885</span><span>    </span><span>42.1</span><span> </span><span>â€¦</span><span> </span><span>46.2</span><span>         </span><span>23 (10%)</span><span>        </span><span>ðŸ’©+  8.9% Â±  0.4%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>54.5</span><span> </span><span>Â±</span><span> </span><span>87.3</span><span>    </span><span>54.1</span><span> </span><span>â€¦</span><span> </span><span>54.6</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>106</span><span>  </span><span>Â±</span><span>  </span><span>654</span><span>      </span><span>105</span><span>  </span><span>â€¦</span><span>  </span><span>109</span><span>           </span><span>        </span><span>ðŸ’©+ 17.2% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>205</span><span>  </span><span>Â±</span><span> </span><span>9.02</span><span>      </span><span>205</span><span>  </span><span>â€¦</span><span>  </span><span>205</span><span>          </span><span>        </span><span>ðŸ’©+ 19.4% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>3.80</span><span>  </span><span>Â±</span><span>  </span><span>103</span><span>     </span><span>3.69</span><span>  </span><span>â€¦</span><span> </span><span>5.07</span><span>           </span><span>        </span><span>ðŸ’©+  6.5% Â±  0.6%
</span><span></span><span>  </span><span>cache_misses</span><span>        </span><span>361</span><span>  </span><span>Â±</span><span> </span><span>9.82</span><span>      </span><span>345</span><span>  </span><span>â€¦</span><span>  </span><span>396</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>       </span><span>464</span><span>  </span><span>Â±</span><span> </span><span>1.33</span><span>      </span><span>460</span><span>  </span><span>â€¦</span><span>  </span><span>469</span><span>           </span><span>        </span><span>ðŸ’©+ 46.7% Â±  0.2%
</span><span></span></code></pre>
<pre><code><span>Benchmark 1</span><span>: ./BenchMatcherDafsaBinarySearch
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>74.6</span><span> </span><span>Â±</span><span> </span><span>1.32</span><span>    </span><span>72.1</span><span> </span><span>â€¦</span><span> </span><span>76.4</span><span>          </span><span>        </span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.57</span><span> </span><span>Â±</span><span> </span><span>70.4</span><span>    </span><span>4.46</span><span> </span><span>â€¦</span><span> </span><span>4.72</span><span>         </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>299</span><span>  </span><span>Â±</span><span> </span><span>1.18</span><span>      </span><span>296</span><span>  </span><span>â€¦</span><span>  </span><span>301</span><span>           </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>471</span><span>  </span><span>Â±</span><span> </span><span>79.5</span><span>       </span><span>471</span><span>  </span><span>â€¦</span><span>  </span><span>471</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.03</span><span>  </span><span>Â±</span><span> </span><span>49.6</span><span>     </span><span>5.90</span><span>  </span><span>â€¦</span><span> </span><span>6.18</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>26.0</span><span>  </span><span>Â±</span><span> </span><span>4.18</span><span>     </span><span>20.5</span><span>  </span><span>â€¦</span><span> </span><span>37.4</span><span>           </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.28</span><span>  </span><span>Â±</span><span> </span><span>53.2</span><span>     </span><span>5.14</span><span>  </span><span>â€¦</span><span> </span><span>5.37</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./BenchMatcherGecko
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>105</span><span> </span><span>Â±</span><span> </span><span>1.18</span><span>     </span><span>103</span><span> </span><span>â€¦</span><span>  </span><span>107</span><span>          </span><span>        </span><span>ðŸ’©+ 40.8% Â±  0.6%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.57</span><span> </span><span>Â±</span><span> </span><span>60.4</span><span>    </span><span>4.46</span><span> </span><span>â€¦</span><span> </span><span>4.72</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>426</span><span>  </span><span>Â±</span><span> </span><span>1.48</span><span>      </span><span>424</span><span>  </span><span>â€¦</span><span>  </span><span>430</span><span>           </span><span>        </span><span>ðŸ’©+ 42.4% Â±  0.2%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>745</span><span>  </span><span>Â±</span><span> </span><span>68.8</span><span>       </span><span>745</span><span>  </span><span>â€¦</span><span>  </span><span>745</span><span>           </span><span>8 (17%)</span><span>        </span><span>ðŸ’©+ 58.2% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>8.04</span><span>  </span><span>Â±</span><span> </span><span>77.0</span><span>     </span><span>7.95</span><span>  </span><span>â€¦</span><span> </span><span>8.48</span><span>           </span><span>        </span><span>ðŸ’©+ 33.3% Â±  0.4%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>27.1</span><span>  </span><span>Â±</span><span> </span><span>5.19</span><span>     </span><span>21.3</span><span>  </span><span>â€¦</span><span> </span><span>44.7</span><span>           </span><span>6 (13%)</span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>5.41</span><span>  </span><span>Â±</span><span> </span><span>2.77</span><span>     </span><span>5.41</span><span>  </span><span>â€¦</span><span> </span><span>5.42</span><span>           </span><span>        </span><span>ðŸ’©+  2.5% Â±  0.3%
</span><span></span><span>Benchmark 3</span><span>: ./BenchMatcherBlink
</span><span></span><span>  </span><span>wall_time</span><span>           </span><span>140</span><span> </span><span>Â±</span><span> </span><span>1.66</span><span>     </span><span>138</span><span> </span><span>â€¦</span><span>  </span><span>146</span><span>          </span><span>        </span><span>ðŸ’©+ 88.2% Â±  0.8%
</span><span></span><span>  </span><span>peak_rss</span><span>           </span><span>4.60</span><span> </span><span>Â±</span><span> </span><span>75.3</span><span>    </span><span>4.46</span><span> </span><span>â€¦</span><span> </span><span>4.72</span><span>         </span><span>          </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>573</span><span>  </span><span>Â±</span><span> </span><span>4.44</span><span>      </span><span>568</span><span>  </span><span>â€¦</span><span>  </span><span>594</span><span>           </span><span>4 (11%)</span><span>        </span><span>ðŸ’©+ 91.6% Â±  0.4%
</span><span></span><span>  </span><span>instructions</span><span>       </span><span>1.07</span><span>  </span><span>Â±</span><span> </span><span>70.5</span><span>      </span><span>1.07</span><span>  </span><span>â€¦</span><span> </span><span>1.07</span><span>           </span><span>7 (19%)</span><span>        </span><span>ðŸ’©+126.3% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>12.3</span><span>  </span><span>Â±</span><span>  </span><span>107</span><span>     </span><span>12.2</span><span>  </span><span>â€¦</span><span> </span><span>12.7</span><span>           </span><span>        </span><span>ðŸ’©+104.6% Â±  0.5%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>28.3</span><span>  </span><span>Â±</span><span> </span><span>5.50</span><span>     </span><span>21.3</span><span>  </span><span>â€¦</span><span> </span><span>43.8</span><span>           </span><span>        </span><span>ðŸ’©+  9.1% Â±  7.4%
</span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>8.78</span><span>  </span><span>Â±</span><span> </span><span>10.3</span><span>     </span><span>8.75</span><span>  </span><span>â€¦</span><span> </span><span>8.80</span><span>           </span><span>        </span><span>ðŸ’©+ 66.2% Â±  0.3%
</span><span></span></code></pre>
<p>So, at long last, we&#39;re at the point where the title (hopefully) becomes justified: this improved DAFSA implementation seems to be slightly better across the board.</p>
<h2>Future possibilities<a id="future-possibilities" href="#future-possibilities">ðŸ”—</a></h2>
<p>One funny aspect of this whole thing is that the problem is actually quite simple once you understand it, and there are probably a lot of different ways one could approach it. If you&#39;ve read this far, it&#39;s very likely that you have some ideas of your own on how to make something better: either a whole different approach, or an improvement to some part of one of the approaches detailed so far.</p>
<p>I&#39;ll outline some avenues I think might warrant some further attention, but I also expect that I&#39;ll miss things that someone else may consider obvious.</p>
<h3>DAFSA with first-two-character acceleration<a id="dafsa-with-first-two-character-acceleration" href="#dafsa-with-first-two-character-acceleration">ðŸ”—</a></h3>
<p>In the last section, I took inspiration from the other browsers&#39; implementations by adding a lookup table to accelerate the search for the first character, but it&#39;d also be possible to take one more page from the Firefox implementation and do the same thing for the <em>second</em> character, too.</p>
<p>I actually <a href="https://github.com/squeek502/named-character-references/tree/8222d9ec403076524073c601441df67b74b7d5c5">have tried this out</a>, and the implementation that I came up with:</p>
<ul>
<li>Uses exactly 8 KiB more data (+28.7%)</li>
<li>Frees up 2 bits from the <code>number</code> field since the largest <code>number</code> value remaining in the DAFSA is 51 (down from 163)</li>
<li>Allows using a <code>u8</code> for the <code>char</code> field instead of a <code>u7</code> (this should reduce the number of instructions needed to access that field)</li>
<li>Makes the binary search no longer worth it; the remaining lists of children are short enough that a linear search wins out</li>
</ul>
<p>Overall, these changes cut the raw lookup time by around -16% (as measured by the benchmark I&#39;m using, at least):</p>
<pre><code><span>Benchmark 1</span><span>: ./bench-first-layer-accel-binary-search
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>59.4</span><span> </span><span>Â±</span><span> </span><span>1.20</span><span>    </span><span>58.0</span><span> </span><span>â€¦</span><span> </span><span>61.4</span><span>          </span><span>        </span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>242</span><span>  </span><span>Â±</span><span>  </span><span>797</span><span>      </span><span>241</span><span>  </span><span>â€¦</span><span>  </span><span>250</span><span>          </span><span>        </span><span></span><span>  </span><span>instructions</span><span>        </span><span>431</span><span>  </span><span>Â±</span><span> </span><span>1.28</span><span>       </span><span>431</span><span>  </span><span>â€¦</span><span>  </span><span>431</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_references</span><span>   </span><span>6.21</span><span>  </span><span>Â±</span><span> </span><span>74.9</span><span>     </span><span>6.10</span><span>  </span><span>â€¦</span><span> </span><span>6.99</span><span>           </span><span>        </span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>1.53</span><span>  </span><span>Â±</span><span>  </span><span>629</span><span>      </span><span>1.01</span><span>  </span><span>â€¦</span><span> </span><span>5.03</span><span>          </span><span>        </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>4.88</span><span>  </span><span>Â±</span><span> </span><span>4.28</span><span>     </span><span>4.87</span><span>  </span><span>â€¦</span><span> </span><span>4.90</span><span>           </span><span>        </span><span></span><span>Benchmark 2</span><span>: ./bench-two-layer-accel-linear-search
</span><span></span><span>  </span><span>wall_time</span><span>          </span><span>49.7</span><span> </span><span>Â±</span><span> </span><span>2.64</span><span>    </span><span>47.4</span><span> </span><span>â€¦</span><span> </span><span>76.2</span><span>         </span><span>        </span><span>âš¡- 16.2% Â±  0.7%
</span><span></span><span>  </span><span>cpu_cycles</span><span>          </span><span>198</span><span>  </span><span>Â±</span><span> </span><span>1.20</span><span>      </span><span>197</span><span>  </span><span>â€¦</span><span>  </span><span>207</span><span>          </span><span>        </span><span>âš¡- 18.2% Â±  0.1%
</span><span></span><span>  </span><span>instructions</span><span>        </span><span>332</span><span>  </span><span>Â±</span><span> </span><span>4.83</span><span>       </span><span>332</span><span>  </span><span>â€¦</span><span>  </span><span>332</span><span>          </span><span>26 (13%)</span><span>        </span><span>âš¡- 22.8% Â±  0.0%
</span><span></span><span>  </span><span>cache_references</span><span>   </span><span>7.29</span><span>  </span><span>Â±</span><span> </span><span>48.6</span><span>     </span><span>7.19</span><span>  </span><span>â€¦</span><span> </span><span>7.44</span><span>           </span><span>        </span><span>ðŸ’©+ 17.3% Â±  0.2%
</span><span></span><span>  </span><span>cache_misses</span><span>       </span><span>1.56</span><span>  </span><span>Â±</span><span>  </span><span>442</span><span>      </span><span>1.09</span><span>  </span><span>â€¦</span><span> </span><span>3.45</span><span>           </span><span>          </span><span></span><span>  </span><span>branch_misses</span><span>      </span><span>3.96</span><span>  </span><span>Â±</span><span> </span><span>7.41</span><span>     </span><span>3.95</span><span>  </span><span>â€¦</span><span> </span><span>4.00</span><span>           </span><span>        </span><span>âš¡- 18.7% Â±  0.0%
</span><span></span></code></pre>
<p>So, for 8 KiB more data you can get another decent performance improvement, but so far I&#39;ve only implemented this version in Zig so I can&#39;t report more information on this yet (would need to port it to C++ to test it with Ladybird). This also represents my first attempt at this &#39;two layer acceleration&#39; strategy, so it&#39;s possible there&#39;s more juice to squeeze here.</p>

<h3>SIMD<a id="simd" href="#simd">ðŸ”—</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">Single instruction, multiple data (SIMD)</a> is something I have had very little experience with using up to this point, and <a href="https://github.com/squeek502/named-character-references/commit/040d3e104941344dc97d7e2d2179d49650de6120">my naive attempts at using SIMD to accelerate my DAFSA implementation</a> were not fruitful. However, it seems like there&#39;s potential to take advantage of SIMD for this type of problem (if not with a DAFSA, then with some totally different approach that takes better advantage of what SIMD is good at).</p>
<h3>Data-oriented design<a id="data-oriented-design" href="#data-oriented-design">ðŸ”—</a></h3>
<p>As I understand it, the core idea of <a href="https://en.wikipedia.org/wiki/Data-oriented_design">data-oriented design</a> is: instead of using an &#39;array of structs&#39;, use a &#39;struct of arrays&#39; where each array holds segments of data that are frequently accessed together. If applied well, this can both cut down on wasted padding bits between elements and make your code much more CPU-cache-friendly.</p>
<details>
<summary>Example for those unfamiliar with data-oriented design</summary>
<p>For example:</p>
<pre><code><span>const</span><span> </span><span>Struct</span><span> </span><span>=</span><span> </span><span>struct</span><span> </span><span>{</span><span>
  </span><span>foo</span><span>:</span><span> </span><span>u8</span><span>,</span><span>
  </span><span>bar</span><span>:</span><span> </span><span>u16</span><span>,</span><span>
</span><span>}</span><span>
</span><span>const</span><span> </span><span>array_of_structs</span><span> </span><span>=</span><span> </span><span>[</span><span>100</span><span>]</span><span>Struct</span><span>{</span><span> </span><span>...</span><span> </span><span>};</span><span>
</span></code></pre>
<p>With the above, each element will have 8 bits of padding (the fields of <code>Struct</code> use 3 bytes, but <code>@sizeOf(Struct)</code> is 4 bytes), and <code>array_of_structs</code> will use 400 bytes. Additionally, if you have a loop where you&#39;re only accessing one field like this:</p>
<pre><code><span>for</span><span> </span><span>(</span><span>&amp;</span><span>array_of_structs</span><span>)</span><span> </span><span>|</span><span>element</span><span>|</span><span> </span><span>{</span><span>
  </span><span>if</span><span> </span><span>(</span><span>element</span><span>.</span><span>foo</span><span> </span><span>==</span><span> </span><span>&#39;!&#39;</span><span>)</span><span> </span><span>return</span><span> </span><span>true</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>then you&#39;re accidentally paying the cost of the larger <code>Struct</code> size since fewer will fit into cache. If we move to a &#39;struct of arrays&#39; approach instead like so:</p>
<pre><code><span>const</span><span> </span><span>StructOfArrays</span><span> </span><span>=</span><span> </span><span>struct</span><span> </span><span>{</span><span>
  </span><span>foos</span><span>:</span><span> </span><span>[</span><span>100</span><span>]</span><span>u8</span><span> </span><span>=</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>},</span><span>
  </span><span>bars</span><span>:</span><span> </span><span>[</span><span>100</span><span>]</span><span>u16</span><span> </span><span>=</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>},</span><span>
</span><span>};</span><span>
</span></code></pre>
<p>then we&#39;re only using 300 bytes for these two arrays, and if we write a loop that only looks at <code>foos</code> like so:</p>
<pre><code><span>for</span><span> </span><span>(</span><span>&amp;</span><span>StructOfArrays</span><span>.</span><span>foos</span><span>)</span><span> </span><span>|</span><span>foo</span><span>|</span><span> </span><span>{</span><span>
  </span><span>if</span><span> </span><span>(</span><span>foo</span><span> </span><span>==</span><span> </span><span>&#39;!&#39;</span><span>)</span><span> </span><span>return</span><span> </span><span>true</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>it will be able to benefit from each element being contiguous in memory and from the fact that more elements of the array will fit into cache at a time.</p>

</details>
<p>This is something I <a href="https://github.com/squeek502/named-character-references/commit/3e06d491b3191632860bc29ea8841175fe39e05d">experimented</a> quite <a href="https://github.com/squeek502/named-character-references/commit/764e9db8aafbab7919a0e5f2725128a41ed5e330">a bit</a> with, but never got results from. I believe the problem is that the access patterns of the DAFSA don&#39;t really benefit from the &#39;struct of arrays&#39; approach, even though it seems like they might. The <code>char</code> field <em>is</em> accessed repeatedly while searching a list of children, but all the other fields of the <code>Node</code> are almost always accessed after that search is finished, so any benefit we get from having the <code>char</code> fields contiguous, we lose just as much from having the other fields farther away from their associated <code>char</code>. As far as I can tell, it&#39;s overall equally-or-more efficient to just use a plain old array-of-structs for our DAFSA nodes.</p>
<h3>Entirely different data structures<a id="entirely-different-data-structures" href="#entirely-different-data-structures">ðŸ”—</a></h3>
<p>I effectively pulled the DAFSA out of a hat, without surveying the possibilities much. Someone more well versed in the field of data structures will likely have some ideas about what&#39;s out there that could work better.</p>
<h2>Wrapping up<a id="wrapping-up" href="#wrapping-up">ðŸ”—</a></h2>
<p>This article continually and relentlessly grew in scope, and has ended up quite a bit more in-depth than I originally imagined (this is something that&#39;s <a href="https://www.ryanliptak.com/blog/every-rc-exe-bug-quirk-probably/">familiar to me, unfortunately</a>). If you&#39;ve read this far, thank you, and I hope you were able to get something out of it.</p>
<p>Throughout the process of writing, I&#39;ve accrued a number of improvements that I can make on top of my original <a href="https://github.com/LadybirdBrowser/ladybird/pull/3011">Ladybird pull request</a>:</p>
<ul>
<li>First-layer acceleration (<code>O(1)</code> lookup table)</li>
<li>Binary searches over lists of child nodes</li>
<li>(Potentially) second-layer acceleration  (<code>O(1)</code> lookup table)</li>
<li>Use the &#39;lookahead&#39; approach when there&#39;s no active insertion point</li>
<li>More efficient insertion into the tokenizer input than a full reallocation of the entire buffer</li>
</ul>
<p>So, a new pull request (or a few) to Ladybird will be forthcoming with some combination of these changes. However, I expect that exactly what those future PR(s) will look like may be shaped by the feedback I receive from this post, as I remain confident that better approaches than mine are out there, and, if you&#39;ve read this article, you have all the knowledge necessary (and then some) to come up with an implementation of your own.</p>
<p>Finally, I&#39;ll leave you with some links:</p>
<ul>
<li><a href="https://github.com/squeek502/named-character-references/">Repository for the Zig implementation of my named character reference data structure</a></li>
<li><a href="https://github.com/squeek502/ladybird/tree/all-in-one">Branch of my Ladybird fork that I used for benchmarking the different implementations</a></li>
</ul>



</div></div>
  </body>
</html>
