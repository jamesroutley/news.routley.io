<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://peter.eisentraut.org/blog/2024/08/13/the-new-postgresql-17-make-dist">Original</a>
    <h1>The new PostgreSQL 17 make dist</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>When the PostgreSQL project makes a release, the primary artifact of
that is the publication of a <a href="https://ftp.postgresql.org/pub/source/">source code
tarball</a>.  That represents the
output of all the work that went into the creation of the PostgreSQL
software up to the point of the release.  The source tarball is then
used downstream by packagers to make binary packages (or file system
images or installation scripts or similar things), or by some to build
the software from source by hand.</p>

<p>Creating a source code tarball is actually quite tricky to do by hand.
Of course, you could just run “tar” over a currently checked out
source tree.  But you need to be careful that the checkout is clean
and not locally modified.  You need to ensure that all the files that
belong in the tarball end up there and no other files.  There are
certain source control files that you don’t want to include in the
tarball.  File permissions and file ownership need to be sane.  And
all this should work consistently across platforms and across time.
Fortunately, this has all been
<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=GNUmakefile.in;h=9c18c562330c5beefb239db52359c7fa27012c1b;hb=05ffe9398b758bbb8d30cc76e9bbc638dab2d477#l85">scripted</a>
and has been pretty reliable over the years.</p>

<p>Additionally, a PostgreSQL source code tarball has included various
prebuilt files.  These are files that are not actually part of the
source code checked into Git, but they would be built as part of a
normal compilation.  For example, a source code tarball has included
prebuilt Bison and Flex files, various .c and .h files generated by
Perl scripts, and HTML and man page documentation built from DocBook
XML files.  The reason for this is a mix of convenience and
<a href="https://www.gnu.org/prep/standards/html_node/Releases.html">traditional
practice</a>.
All these output files are platform-independent and independent of
build options.  So everyone will get the same ones anyway, so we might
as well prebuild them.  Also, that way, users of the source tarball
won’t need the tools to build these files.  For example, you didn’t
actually need Perl to build PostgreSQL from a source tarball, because
all the files generated from Perl scripts were already built.  Also,
historically (very historically), PostgreSQL was pushing the limits of
Bison and Flex (or various other yacc and lex implementations, when
those were still supported), so it was convenient and less error-prone
to give everyone the same prebuilt Bison and Flex output files.</p>

<p>This system has two major problems that have now led to the point that
we got rid of it in PostgreSQL 17.</p>

<p>First, implementing and maintaining this arrangement in the build
system is quite tricky.  You need to carefully maintain the different
states of “clean source code”, “partially built source code”, and
“fully built source code”, and the commands to transition between
them.  (This was <code>make distprep</code> and <code>make all</code>, and then <code>make clean</code>
and <code>make maintainer-clean</code> to move the other way.)  Making it work
with out-of-tree (“vpath”) builds was extremely weird: If you built
from a source tarball, the Bison (etc.) output files were in the
source directory, but if you build from a Git checkout, the Bison
output files were in the build directory, and you need to support both
of these sanely.  Finally, the new Meson build system is extremely
allergic against writing build output into the source directory.</p>

<p>Some of the historical reasons are also obsolete.  It’s not a problem
anymore to get a good version of Bison and Flex installed.  Everybody
can easily get Perl installed nowadays.  The documentation build can
still be a bit tricky, but it’s generally much easier and robust than
a few decades ago.</p>

<p>Second, a lot more attention is nowadays paid to the software supply
chain.  There are security and legal reasons for this.  When users
install software, they want to know where it came from, and they want
to be sure that they got the right thing, not some fake version or
some version of dubious legal provenance.</p>

<p>The downstream packaging practice has already paid attention to this
for many years.  Packages or package repositories are
cryptographically signed, so you can be sure that what you install
came from a trustworthy source.  There have also been efforts to make
binary builds <a href="https://reproducible-builds.org/">reproducible</a>, so
that you can be sure that the binary files in your binary package are
what you’d expect them to be.  Some packagers have policies that
everything needs to be built from source, so they’d just delete and
rebuild the prebuilt files anyway.</p>

<p>At the other end of the software production pipeline, using Git as the
source control system gives some integrity guarantees that you are
getting the same source code that everybody else is getting.  So if
I’m looking at commit
<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=b18b3a8150dbb150124bd345e000d6dc92f3d6dd">b18b3a8150dbb150124bd345e000d6dc92f3d6dd</a>
and I see that same commit on various public servers, that’s probably
the same commit that everybody else is seeing.  And I can check what
the parents of that commit are and how the code got to that point and
so on.</p>

<p>But what we didn’t have until now is a transparent and reproducible
way to get from that commit to the release tarball.</p>

<p>The way the <a href="https://wiki.postgresql.org/wiki/Release_process">tarball creation
works</a> is that the
person who prepares the release runs <code>make dist</code> on a machine that is
specially kept “clean” for that purpose.  How can a third party verify
this process?  The produced tarball was not perfectly reproducible.
If you run <code>make dist</code> yourself, you’ll get a similar but not
identical tarball.  A way to verify whether a tarball was sane was to
unpack it and diff the contents against a source directory or an
unpacked tarball that you made yourself.  But this requires manual
judgment.  The Bison and Flex files won’t be the same unless you used
the identical versions.  The built documentation also won’t be
perfectly identical.  File timestamps will be different.  Also you’d
need to carefully check manually whether files are missing or too
many.  This was not fully satisfactory.</p>

<p>(This work overlapped with the discovery of the <a href="https://en.wikipedia.org/wiki/XZ_Utils_backdoor">XZ Utils
backdoor</a>, which
exploited (among other things) exactly this non-reproducible tarball
creation process.  But I want to be clear that this is a complete
coincidence, and this work was neither done as a response to that nor
are there are any suspicions that any PostgreSQL tarballs might have
been compromised.)</p>

<p>Anyway, with PostgreSQL 17, this is changed.  The tarball generation
is still invoked by calling <code>make dist</code>, but that
<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=GNUmakefile.in;h=cf6e759486eded7bf95e12617bfa2d6765eeffdf;hb=b18b3a8150dbb150124bd345e000d6dc92f3d6dd#l85">internally</a>
now calls <a href="https://git-scm.com/docs/git-archive"><code>git archive</code></a>.  <code>git
archive</code> packs the files belonging to a given Git commit into a tar
(or other) archive in a reproducible and verifiable way.  Therefore,
if I now run <code>make dist</code> on a given commit (such as a release tag),
then I will get the exact same (bit-identical) tarball as the next
person.  A packager can now trace the tarball back to the Git
repository, and in turn an end-user can trace a binary package back to
the Git repository as well (assuming reproducible builds, which is an
ongoing struggle).</p>

<p>(To be clear, this change is only in major version PostgreSQL 17 and
(presumably) future major versions.  The maintenance releases for
older major versions (16 and back) will continue to be published using
the old method until they go out of support.)</p>

<p><a href="https://www.postgresql.org/message-id/flat/40e80f77-a294-4f29-a16f-e21bc7bc75fc%40eisentraut.org">Getting this to
work</a>
was also not entirely straightforward.  You need to carefully
calibrate the <code>git archive</code> options to make sure this works
consistently across platforms and local Git configurations.  Which is
why we’re keeping the <code>make dist</code> invocation as a wrapper.  Also, you
need a new enough version of Git for this (2.38.0 or newer).
Currently, the Git version used to produce the release tarballs (on
the above-mentioned “clean” box) is too old to create reproducible
<code>.tar.gz</code> tarballs, but it will create reproducible <code>.tar.bz2</code>
tarballs.  The latter is what most users and packagers use anyway.  If
you care about this, avoid the <code>.tar.gz</code> for now.</p>

<p>I think this is progress, if you care about software supply chain
integrity.  (It’s also a relief if you care about maintaining the
build system.)  There are certainly more things that could be done.
One thing mentioned above is that reproducible builds don’t work for
PostgreSQL in all situations.  My understanding is that this needs to
be fixed elsewhere, though.  Another topic is more traceability about
how things get <em>into</em> the Git repository.  The <code>make dist</code> change only
ensures that once code is in the Git repository, you can trace it from
there, ideally all the way to the end user installation.  There are,
of course, various technical and social processes in the PostgreSQL
developer community that monitor the integrity of the source code, but
there is nothing currently that checks in a computerized,
cryptographic way the origin of what goes into the Git repository.  So
something like signed commits might be worth looking into in the
future in order to improve this further.</p>

  </div>
  
  
</article>

      </div>
    </div></div>
  </body>
</html>
