<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ferd.ca/my-favorite-erlang-container.html">Original</a>
    <h1>My favorite Erlang container</h1>
    
    <div id="readability-page-1" class="page"><article>
        
            <span>2022/07/09</span>
        
        
        

<p>Joe Armstrong wrote a blog post titled <a href="https://joearms.github.io/published/2013-11-21-My-favorite-erlang-program.html">My favorite Erlang Program</a>, which showed a very simple <em>universal server</em> written in Erlang:</p>
<div><pre><span></span><span>universal_server</span><span>()</span><span> </span><span>-&gt;</span><span></span>
<span>    </span><span>receive</span><span></span>
<span>       </span><span>{</span><span>become</span><span>,</span><span> </span><span>F</span><span>}</span><span> </span><span>-&gt;</span><span></span>
<span>           </span><span>F</span><span>()</span><span></span>
<span>    </span><span>end</span><span>.</span><span></span>
</pre></div>

<p>You could then write a small program that could fit this function <code>F</code>:</p>
<div><pre><span></span><span>factorial_server</span><span>()</span><span> </span><span>-&gt;</span><span></span>
<span>    </span><span>receive</span><span></span>
<span>       </span><span>{</span><span>From</span><span>,</span><span> </span><span>N</span><span>}</span><span> </span><span>-&gt;</span><span></span>
<span>           </span><span>From</span><span> </span><span>!</span><span> </span><span>factorial</span><span>(</span><span>N</span><span>),</span><span></span>
<span>           </span><span>factorial_server</span><span>()</span><span></span>
<span>    </span><span>end</span><span>.</span><span></span>

<span>factorial</span><span>(</span><span>0</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>1</span><span>;</span><span></span>
<span>factorial</span><span>(</span><span>N</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>N</span><span> </span><span>*</span><span> </span><span>factorial</span><span>(</span><span>N</span><span>-</span><span>1</span><span>).</span><span></span>
</pre></div>

<p>If you had an already running universal server, such as you would by having called <code>Pid = spawn(fun universal_server/0)</code>, you could then turn that universal server into the factorial server by calling <code>Pid ! {become, fun factorial_server/0}.</code></p>

<h3>Weeds growing in driveway cracks</h3>


<p>Joe Armstrong had a way to get to the essence of a lot of concepts and to think about programming as a fun thing. Unfortunately for me, my experience with the software industry has left me more or less frustrated with the way things are, even if the way things are is for very good reasons. I really enjoyed programming Erlang professionally, but I eventually got sidetracked by other factors that would lead to solid, safe software—mostly higher level aspects of socio-technical systems, and I became SRE.</p>

<p>But a part of me still really likes dreaming about the days where I could do hot code loading over entire clusters—see <a href="https://ferd.ca/a-pipeline-made-of-airbags.html">A Pipeline Made of Airbags</a>—and I kept thinking about how I could bring this back, but within the context of complex software teams running CI/CD, building containers, and running them in Kubernetes. This is no short order, because we now have decades of lessons telling everyone that you want your infrastructure to be immutable and declared in code.</p>

<p>I also have a decade of experience telling me a lot of what we&#39;ve built is a frustrating tower of abstractions over shaky ground. I know I&#39;ve experienced better, my day job is no longer about slinging my own code, and I have no pretense of respecting the tower of abstraction itself.</p>
<blockquote title="https://en.wikipedia.org/wiki/Weed">
A weed is a plant considered undesirable in a particular situation, &#34;a plant in the wrong place&#34;. Examples commonly are plants unwanted in human-controlled settings, such as farm fields, gardens, lawns, and parks. Taxonomically, the term &#34;weed&#34; has no botanical significance, because a plant that is a weed in one context is not a weed when growing in a situation where it is wanted.
</blockquote>
<p>Like the weeds that decide that the tiniest crack in a driveway is actually real cool soil to grow in, I&#39;ve decided to do the best thing given the situation and bring back Erlang live code upgrades to modern CI/CD, containerized and kubernetized infrastructure.</p>

<p>If you want the TL:DR; I wrote <a href="https://github.com/ferd/dandelion">the dandelion project</a>, which shows how to go from an Erlang/OTP app, automate the generation of live code upgrade instructions with the help of pre-existing tools and CI/CD, generate a manifest file and store build artifacts, and write the necessary configuration to have Kubernetes run said containers and do automated live code upgrades despite its best attempts at providing immutable images. Then I pepper in some basic CI scaffolding to make live code upgrading a tiny bit less risky. This post describes how it all works.</p>

<h3>A Sample App</h3>


<p>A lot of &#34;no downtime&#34; deployments you&#39;ll find for Kubernetes are actually just rolling updates with graceful connection termination. Those are always worth supporting (<a href="https://twitter.com/mononcqc/status/1494787043192446988">even if it can be annoying to get right</a>), but it has a narrow definition of downtime that&#39;s different from what we&#39;re aiming for here: no need to restart the application, dump and re-hydrate the state, nor to drop a single connection.</p>

<h4>A small server with persistent connections</h4>


<p>I wrote a really trivial application, nothing worth calling home about. It&#39;s a tiny TCP server with a bunch of acceptors where you can connect with netcat (<code>nc localhost 8080</code>) and it just displays stuff. This is the bare minimum to show actual &#34;no downtime&#34;: a single instance, changing its code definitions in a way that is directly observable to a client, without ever dropping a connection.</p>

<p><a href="https://github.com/ferd/dandelion/tree/main/erlang">The application</a> follows a <a href="https://rebar3.org/docs/basic_usage/">standard release structure for Erlang, using Rebar3 as a build tool</a>. Its supervision structure looks like this:</p>
<pre>               top level
              supervisor
               /      \
        connection   acceptors
        supervisor   supervisor
            |            |
        connection    acceptor
         workers        pool
       (1 per conn)
</pre>
<p>The acceptors supervisor starts a TCP listen socket, which is passed to each worker in the acceptor pool. Upon each accepted connection, a connection worker is started and handed the final socket. The connection worker then sits in an event loop. Every second it sends in a small ASCII drawing of a dandelion, and for every packet of data it receives (coalesced or otherwise), it sends in a line containing its version.</p>

<p>A netcat session looks like this:</p>
<pre>$ nc localhost 8080

   @
 \ |
__\!/__


   @
 \ |
__\!/__

&gt; ping!
vsn: 0.1.5

   @
 \ |
__\!/__

^C
</pre>


<h3>Universal container: a plan</h3>




<p>Modern deployments are often done with containers and Kubernetes. I&#39;m assuming you&#39;re familiar with both of these concepts, but if you want more information—in the context of Erlang—then Tristan Sloughter wrote a great article on <a href="https://adoptingerlang.org/docs/production/docker/">Docker and Erlang</a> and another one on <a href="https://adoptingerlang.org/docs/production/kubernetes/">using Kubernetes for production apps</a>.</p>

<p>In this post, I&#39;m interested in doing two things:</p>

<ol>
<li>Have an equivalent to Joe Armstrong&#39;s <em>Universal server</em></li>
<li>Force the immutable world to nevertheless let me do live code upgrades</li>
</ol>
<p>The trick here is deceptively simple, enough to think &#34;that can&#39;t be a good idea.&#34; It probably isn&#39;t.</p>

<img src="https://ferd.ca/static/img/nathan.png" alt="A tracing of Nathan fielder" title="My name is Nathan Fielder and I graduated from one of Canada&#39;s top business schools with really good grades"/>

<p>The plan? Use a regular container someone else maintains and just wedge my program&#39;s tarball in there. I can then use a <a href="https://www.nginx.com/resources/glossary/sidecar/">sidecar</a> to automate fetching updates and applying live code upgrades without Kubernetes knowing anything about it.</p>

<h3>Erlang Releases: a detour</h3>


<p>To understand how this can work, we first need to cover the basics of Erlang releases. A good overview of the Erlang Virtual Machine&#39;s structure is an article I&#39;ve written in <a href="https://adoptingerlang.org/docs/development/otp_high_level/">OTP at a high level</a>, but that I can summarize here by describing the following layers, from lowest to highest:</p>

<ul>
<li>There is an Erlang Runtime System (ERTS), which is essentially the VM itself, written in C. This can&#39;t be live upgraded, and offers features around Erlang&#39;s immutability, preemptive scheduling, memory allocation, garbage collection, and so on.</li>
<li>A few pre-loaded modules that offer core functionality around files and sockets. I don&#39;t believe that these get to be live upgraded either.</li>
<li>There is a pair of libraries (&#34;applications&#34; in Erlang-speak) called <code>kernel</code> and <code>stdlib</code> that define the most basic libraries around list processing, distributed programs, and the core of &#34;OTP&#34;, the general development framework in the language. These can be live upgraded, but pretty much nobody does that</li>
<li>Then we have the Erlang standard library. This includes things such as TLS support, HTTP clients and servers, Wx bindings, test frameworks, the compiler, and extra scaffolding around OTP niceties, to name a few.</li>
</ul>
<p>Your own project is pretty much just your own applications (&#34;libraries&#34;), bundled with select standard library libraries and a copy of the Erlang system:</p>

<img src="https://ferd.ca/static/img/release.png" alt="release schematic drawing"/>

<p>The end result of this sort of ordeal is that every Erlang project is pretty much people writing their own libraries (in blue in the drawing above), fetching bits from the Erlang base install (in red in the drawing above), and then using tools (such as Rebar3) to repackage everything into a brand new Erlang distribution. A detailed explanation of how this happens is <a href="https://adoptingerlang.org/docs/production/releases/">also in <em>Adopting Erlang</em></a>.</p>

<p>Whatever you built on one system can be deployed on an equivalent system. If you built your app on a 64 bit linux—and assuming you used static libraries for OpenSSL or LibreSSL, or have equivalent ones on a target system—then you can pack a tarball, unpack it on the other host system, and get going. Those requirements don&#39;t apply to your code, only the standard library. If you don&#39;t use <a href="https://www.erlang.org/doc/tutorial/nif.html">NIFs</a> or other C extensions, your own Erlang code, once built, is fully portable.</p>

<p>The cool thing is that Erlang supports making a sort of &#34;partial&#34; release, where you take the Erlang/OTP part (red) and your own apps (blue) in the above image, only package your own app&#39;s and a sort of &#34;figure out the Erlang/OTP part at run-time&#34; instruction, and your application is going to be entirely portable across all platforms (Windows, Linux, BSD, MacOS) and supported architectures (x86, ARM32, ARM64, etc.)</p>

<p>I&#39;m mentioning this because for the sake of this experiment, I&#39;m running things locally on a M1 macbook air (ARM64), with <a href="https://microk8s.io/">MicroK8s</a> (which runs a Linux/aarch64), but am using Github Actions, which are on an x86 linux. So rather than using a <a href="https://hub.docker.com/_/ubuntu">base ubuntu image</a> and then needing to run the same sort of hardware family everywhere down the build chain, I&#39;ll be using an <a href="https://hub.docker.com/_/erlang">Erlang image from dockerhub</a> to provide the ERTS and stdlib, and will then have the ability to make portable builds from either my laptop or github actions and deploy them onto any Kubernetes cluster—something noticeably nicer than having to deal with cross-compilation in any language.</p>

<h4>Controlling Releases</h4>


<p>The <a href="https://github.com/ferd/dandelion/blob/95f740915ec4c70f3c8684014fc6179edf79029d/erlang/rebar.config#L29-L53">release definition for Dandelion</a> accounts for the above factors, and looks like this:</p>
<div><pre><span></span><span>{</span><span>relx</span><span>,</span><span> </span><span>[{</span><span>release</span><span>,</span><span> </span><span>{</span><span>dandelion</span><span>,</span><span> </span><span>&#34;0.1.5&#34;</span><span>},</span><span> </span><span>% my release and its version (dandelion-0.1.5)</span><span></span>
<span>         </span><span>[</span><span>dandelion</span><span>,</span><span>                    </span><span>% includes the &#39;dandelion&#39; app and its deps</span><span></span>
<span>          </span><span>sasl</span><span>]},</span><span>                       </span><span>% and the &#39;sasl&#39; library, which is needed for</span><span></span>
<span>                                        </span><span>% live code upgrades to work</span><span></span>

<span>        </span><span>%% set runtime configuration values based on the environment in this file</span><span></span>
<span>        </span><span>{</span><span>sys_config_src</span><span>,</span><span> </span><span>&#34;./config/sys.config.src&#34;</span><span>},</span><span></span>
<span>        </span><span>%% set VM options in this file</span><span></span>
<span>        </span><span>{</span><span>vm_args</span><span>,</span><span> </span><span>&#34;./config/vm.args&#34;</span><span>},</span><span></span>

<span>        </span><span>%% drop source files and the ERTS, but keep debug annotations</span><span></span>
<span>        </span><span>%% which are useful for various tools, including automated</span><span></span>
<span>        </span><span>%% live code upgrade plugins</span><span></span>
<span>        </span><span>{</span><span>include_src</span><span>,</span><span> </span><span>false</span><span>},</span><span></span>
<span>        </span><span>{</span><span>include_erts</span><span>,</span><span> </span><span>false</span><span>},</span><span></span>
<span>        </span><span>{</span><span>debug_info</span><span>,</span><span> </span><span>keep</span><span>},</span><span></span>
<span>        </span><span>{</span><span>dev_mode</span><span>,</span><span> </span><span>false</span><span>}</span><span></span>
<span>]}.</span><span></span>
</pre></div>

<p>The release can be built by calling <code>rebar3 release</code> and packaged by calling <code>rebar3 tar</code>.</p>

<p>Take the resulting tarball, unpack it, and you&#39;ll get a bunch of directories: <code>lib/</code> contains the build artifact for all libraries, <code>releases/</code> contains metadata about the current release version (and the structure to store future and past versions when doing live code upgrades), and finally the <code>bin/</code> directory contains a bunch of accessory scripts to load and run the final code.</p>

<p>Call <code>bin/dandelion</code> and a bunch of options show up:</p>
<pre>$ bin/dandelion
Usage: dandelion [COMMAND] [ARGS]

Commands:

  foreground              Start release with output to stdout
  remote_console          Connect remote shell to running node
  rpc [Mod [Fun [Args]]]] Run apply(Mod, Fun, Args) on running node
  eval [Exprs]            Run expressions on running node
  stop                    Stop the running node
  restart                 Restart the applications but not the VM
  reboot                  Reboot the entire VM
...
  upgrade [Version]       Upgrade the running release to a new version
  downgrade [Version]     Downgrade the running release to a new version
  install [Version]       Install a release
  uninstall [Version]     Uninstall a release
  unpack [Version]        Unpack a release tarball
  versions                Print versions of the release available
...
</pre>
<p>So in short, your program&#39;s lifecycle can become:</p>

<ul>
<li><code>bin/dandelion foreground</code> boots the app (use <code>bin/dandelion console</code> to boot a version in a REPL)</li>
<li><code>bin/dandelion remote_console</code> pops up a REPL onto the running app by using distributed Erlang</li>
</ul>
<p>If you&#39;re doing the usual immutable infrastructure, that&#39;s it, you don&#39;t need much more. If you&#39;re doing live code upgrades, you then have a few extra steps:</p>

<ol>
<li>Write a new version of the app</li>
<li>Give it some instructions about how to do its live code upgrade</li>
<li>Pack that in a new version of the release</li>
<li>Put the tarball in <code>releases/</code></li>
<li>Call <code>bin/dandelion unpack &lt;version&gt;</code> and the Erlang VM will unpack the new tarball into its regular structure</li>
<li>Call <code>bin/dandelion install &lt;version&gt;</code> to get the Erlang VM in your release to start tracking the new version (without switching to it)</li>
<li>Call <code>bin/dandelion upgrade &lt;version&gt;</code> to apply the live code upgrade</li>
</ol>
<p>And from that point on, the new release version is live.</p>

<h4>Hot Code Upgrade Instructions</h4>


<p>I&#39;ve sort of papered over the complexity required to &#34;give it some instructions about how to do its live code upgrade.&#34; This area is generally really annoying and complex. You first start with <a href="https://www.erlang.org/doc/design_principles/appup_cookbook.html">appup files</a>, which contain instructions on upgrading individual libraries, which are then packaged into a <a href="https://www.erlang.org/doc/man/relup.html">relup</a> which provides instructions for coordinating the overall upgrade.</p>

<p>If you&#39;re running live code upgrades on a frequent basis you may want to get familiar with these, but most people never bothered, and the vast majority of live code upgrades are done by people writing manual scripts to load specific modules.</p>

<p>A very nice solution that also exists is to use <a href="https://github.com/lrascao/rebar3_appup_plugin/">Luis Rascão&#39;s <code>rebar3_appup_plugin</code></a> which will take two releases, compare their code, and auto-generate instructions on your behalf. By using it, most of the annoyances and challenges are automatically covered for you.</p>

<p>All you need to do is to make sure all versions are adequately bumped, do a few command line invocations, and package it up. This will be a prime candidate for automation soon in this post.</p>

<p>For now though, let&#39;s assume we&#39;ll just put the release in an S3 bucket that the kubernetes cluster has access to, and build our infrastructure on the Kubernetes side.</p>

<h3>Universal container: a kubernetes story</h3>


<p>Let&#39;s escape the Erlang complexity and don our DevOps hat. We now want to run the code we assume has made it safely to S3. All of it beautifully holds into <a href="https://github.com/ferd/dandelion/blob/main/k8s/dandelion.yaml">a single YAML file</a>—which, granted, can&#39;t really be beautiful on its own. I use three containers in a single kubernetes pod:</p>

<img src="https://ferd.ca/static/img/containers.png" alt="containers schematic drawing"/>

<p>All of these containers will share a &#39;release&#39; directory, by using an <a href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir">EmptyDir volume</a>. The bootstrap container will fetch the latest release and unpack it there, the <code>dandelion-release</code> container will run it, and the sidecar will be able to interact over the network to manage live code upgrades.</p>

<p>The bootstrap pod runs first, and fetches the first (and current) release from S3. I&#39;m doing so by assuming we&#39;ll have a manifest file (<code>&lt;my-s3-bucket&gt;/dandelion-latest</code>) that contains a single version number that points to the tarball I want (<code>&lt;my-s3-bucket&gt;/dandelion-&lt;version&gt;.tar.gz</code>). This can be done with a shell script:</p>
<div><pre><span></span><span>#!/usr/bin/env bash</span>
<span>set</span> -euxo pipefail
<span>RELDIR</span><span>=</span><span>${</span><span>1</span><span>:-</span><span>/release</span><span>}</span>
<span>S3_URL</span><span>=</span><span>&#34;https://</span><span>${</span><span>BUCKET_NAME</span><span>}</span><span>.s3.</span><span>${</span><span>AWS_REGION</span><span>}</span><span>.amazonaws.com&#34;</span>
<span>TAG</span><span>=</span><span>$(</span>curl <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-latest&#34;</span> -s<span>)</span>
wget -nv <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span> -O <span>&#34;/tmp/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span>
tar -xvf <span>&#34;/tmp/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span> -C <span>${</span><span>RELDIR</span><span>}</span>
rm <span>&#34;/tmp/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span>
</pre></div>

<p>This fetches the manifest, grabs the tag, fetches the release, unpacks it, and deletes the old tarball. The <code>dandelion-release</code> container, which will run our main app, can then just call the <code>bin/dandelion</code> script directly:</p>
<div><pre><span></span><span>#!/usr/bin/env bash</span>
<span>set</span> -euxo pipefail
<span>RELDIR</span><span>=</span><span>${</span><span>1</span><span>:-</span><span>/release</span><span>}</span>
<span>exec</span> <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> foreground
</pre></div>

<p>The sidecar is a bit more tricky, but can reuse the same mechanisms. Every time interval (or based on a feature flag or some server-sent signal), check the manifest, and apply the unpacking steps. Something a bit like:</p>
<div><pre><span></span><span>#!/usr/bin/env bash</span>
<span>set</span> -euxo pipefail
<span>RELDIR</span><span>=</span><span>${</span><span>2</span><span>:-</span><span>/release</span><span>}</span>
<span>S3_URL</span><span>=</span><span>&#34;https://</span><span>${</span><span>BUCKET_NAME</span><span>}</span><span>.s3.</span><span>${</span><span>AWS_REGION</span><span>}</span><span>.amazonaws.com&#34;</span>

<span>CURRENT</span><span>=</span><span>$(</span><span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> versions <span>|</span> awk <span>&#39;$3==&#34;permanent&#34; &amp;&amp; !vsn { vsn=$2 } $3==&#34;current&#34; { vsn=$2 } END { print vsn }&#39;</span><span>)</span>
<span>TAG</span><span>=</span><span>$(</span>curl <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-latest&#34;</span> -s<span>)</span>
<span>if</span> <span>[[</span> <span>&#34;</span><span>${</span><span>CURRENT</span><span>}</span><span>&#34;</span> !<span>=</span> <span>&#34;</span><span>${</span><span>TAG</span><span>}</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then</span>
    wget -nv <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span> -O <span>&#34;</span><span>${</span><span>RELDIR</span><span>}</span><span>/releases/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span>
    <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> unpack <span>${</span><span>TAG</span><span>}</span>
    <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> install <span>${</span><span>TAG</span><span>}</span>
    <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> upgrade <span>${</span><span>TAG</span><span>}</span>
<span>fi</span>
</pre></div>

<p>Call this in a loop and you&#39;re good to go.</p>

<p>Now here&#39;s the fun bit: <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMaps</a> are a Kubernetes thing that lets you take arbitrary metadata, and optionally <a href="https://kubernetes.io/docs/concepts/configuration/configmap/#using-configmaps-as-files-from-a-pod">use them as files into pods</a>. This is how we get close to our universal container.</p>

<p>By declaring <a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/k8s/dandelion.yaml#L112-L158">the three scripts above as a ConfigMap</a> and <a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/k8s/dandelion.yaml#L26-L29">mounting them in a <code>/scripts</code> directory</a>, we can then declare the 3 containers in a generic fashion:</p>
<div><pre><span></span><span>initContainers</span><span>:</span><span></span>
<span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>dandelion-bootstrap</span><span></span>
<span>  </span><span>image</span><span>:</span><span> </span><span>erlang:25.0.2</span><span></span>
<span>  </span><span>env</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>...</span><span></span>
<span>  </span><span>volumeMounts</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>release</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/release</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>scripts</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/scripts</span><span></span>
<span>  </span><span>command</span><span>:</span><span></span>
<span>    </span><span>-</span><span> </span><span>/scripts/init-latest.sh</span><span></span>
<span># Regular containers run next</span><span></span>
<span>containers</span><span>:</span><span></span>
<span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>dandelion-release</span><span></span>
<span>  </span><span>image</span><span>:</span><span> </span><span>erlang:25.0.2</span><span></span>
<span>  </span><span>env</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>...</span><span></span>
<span>  </span><span>volumeMounts</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>release</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/release</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>scripts</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/scripts</span><span></span>
<span>  </span><span>command</span><span>:</span><span></span>
<span>    </span><span>-</span><span> </span><span>/scripts/boot-release.sh</span><span></span>
<span>  </span><span>ports</span><span>:</span><span></span>
<span>    </span><span>-</span><span> </span><span>containerPort</span><span>:</span><span> </span><span>8080</span><span></span>
<span>      </span><span>hostPort</span><span>:</span><span> </span><span>8080</span><span></span>
<span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>dandelion-sidecar</span><span></span>
<span>  </span><span>image</span><span>:</span><span> </span><span>erlang:25.0.2</span><span></span>
<span>  </span><span>env</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>...</span><span></span>
<span>  </span><span>volumeMounts</span><span>:</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>release</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/release</span><span></span>
<span>  </span><span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>scripts</span><span></span>
<span>    </span><span>mountPath</span><span>:</span><span> </span><span>/scripts</span><span></span>
<span>  </span><span>command</span><span>:</span><span></span>
<span>    </span><span>-</span><span> </span><span>/scripts/update-loop.sh</span><span></span>
</pre></div>

<p>The <a href="https://github.com/ferd/dandelion/blob/main/k8s/dandelion.yaml">full file has more details</a>, but this is essentially all we need. You could <code>kubectl apply -f dandelion.yaml</code> and it would get going on its own. The rest is about providing a better developer experience.</p>

<h3>Making it Usable</h3>


<p>What we have defined now is an expected format and procedure from Erlang&#39;s side to generate code and live upgrade instructions, and a wedge to make this usable within Kubernetes&#39; own structure. This procedure is somewhat messy, and there are a lot of technical aspects that need to be coordinated to make this usable.</p>

<p>Now comes the time to work around providing a useful workflow for this.</p>

<h4>Introducing Smoothver</h4>


<p><a href="https://semver.org/">Semver</a>&#39;s alright. Most of the time I won&#39;t really care about it, though. I&#39;ll go read the changelog and see if whatever I depend on has changed or not. People will pick versions for whichever factor they want, and they&#39;ll very often put a small breaking change (maybe a bug fix!) as non-breaking because there&#39;s an intent being communicated by the version.</p>

<p>Here the semver semantics are not useful. I&#39;ve just defined a workflow that mostly depends on whether the server can be upgraded live or not, with some minor variations. This operational concern is likely to be the main concern of engineers who would work on such an application daily, particularly since as someone deploying and maintaining server-side software, I mostly own the whole pipeline and always consider the main branch to be canonical.</p>

<p>As such, I should feel free to develop my own versioning scheme. Since I&#39;m trying to reorient Dandelion&#39;s whole flow towards continuous live delivery, my versioning scheme should actually reflect and support that effort. I therefore introduce <em>Smoothver</em> (Smooth Versioning):</p>

<p>Given a version number RESTART.RELUP.RELOAD, increment the:</p>

<ul>
<li>RESTART version when you make a change that requires the server to be rebooted.</li>
<li>RELUP version when you make a change that requires pausing workers and migrating state.</li>
<li>RELOAD version when you make a change that requires reloading modules with no other transformation.</li>
</ul>
<p>The version number now communicates the relative <em>expected</em> risk of a deployment in terms of disruptiveness, carries some meaning around the magnitude of change taking place, and can be leveraged by tooling.</p>

<p>For example:</p>

<ul>
<li>Fixing a bug in a data structure is a RELOAD deploy so long as the internal representation does not change (e.g. swapping a <code>&gt;</code> for a <code>&gt;=</code> in a comparison)</li>
<li>Adding a new endpoint or route to an existing HTTP API is likely a RELOAD deploy since no existing state relies on it. Rolling it back is a business concern, not a technical one.</li>
<li>Adding or changing a field in a data structure representing a user is a RELUP operation, since rolling forward or backward implies a data transformation to remain compatible</li>
<li>Upgrading the VM version is a RESTART because the C code of the VM itself can&#39;t change</li>
<li>Bumping a stateful dependency that does not provide live code upgrades forces a RESTART version bump</li>
</ul>
<p>As with anything we do, the version bump may be wrong. But it at least carries a certain safety level in letting you know that a RESTART live code upgrade should absolutely not be attempted.</p>

<p>Engineers who get more familiar with live code upgrades will also learn some interesting lessons. For example, a RELUP change over a process that has tens of thousands of copies of itself may take a long long time to run and be worse than a rolling upgrade. An interesting thing you can do then is turn <code>RELUP</code> changes (which would require calling <a href="https://www.erlang.org/doc/man/gen_server.html#Module:code_change-3">code change instructions</a>) into basic code reloads by pattern matching an old structure and converting it on each call, turning it into a somewhat stateless roll-forward affair.</p>

<p>That&#39;s essentially converting operational burdens into dirtier code, but this sort of thing is something you do all the time with database migrations (create a new table, double-write, write only to the new one, delete the old table) and that can now be done with running code.</p>

<p>For a new development workflow that tries to orient itself towards live code upgrades, Smoothver is likely to carry a lot more useful information than Semver would (and maybe could be nice for database migrations as well, since they share concerns).</p>

<h4>Publishing the Artifacts</h4>


<p>I needed to introduce the versioning mechanism because the overall publication workflow will obey it. If you&#39;re generating a new release version that requires a RESTART bump, then don&#39;t bother generating live code upgrade instructions. If you&#39;re generating anything else, do include them.</p>

<p>I&#39;ve decided to center my workflow around git tags. If you tag your release <code>v1.2.3</code>, then <code>v1.2.4</code> or <code>v1.4.1</code> all do a live code upgrade, but <code>v2.0.0</code> won&#39;t, regardless of which branch they go to. The CI script is not too complicated, and is in three parts:</p>

<ol>
<li><a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/.github/workflows/publish-tarball.yml#L28-L46">Fetch the currently deployed manifest</a>, and see if the newly tagged version requires a live code upgrade (&#34;relup&#34;) or not</li>
<li><a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/.github/workflows/publish-tarball.yml#L49-L66">Build the release tarball</a> with the relup instructions if needed. Here I rely purely on Luis&#39;s plugin to handle all the instructions.</li>
<li><a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/.github/workflows/publish-tarball.yml#L90-L99">Put the files on S3</a></li>
</ol>
<p>That&#39;s really all there is to it. I&#39;m assuming that if you wanted to have more environments, you could setup gitops by having more tags (<code>staging-v1.2.3</code>, <code>prod-v1.2.5</code>) and more S3 buckets or paths. But everything is assumed to be driven by these builds artifacts.</p>

<p>A small caveat here is that it&#39;s technically possible to generate upgrade instructions (appup files) that map from many to many versions: how to update to 1.2.0 from 1.0.0, 1.0.1, 1.0.2, and so on. Since I&#39;m assuming a linear deployment flow here, I&#39;m just ignoring that and always generating pairs from &#34;whatever is in prod&#34; to &#34;whatever has been tagged&#34;. There are obvious race conditions in doing this, where two releases generated in parallel can specify upgrade rules from a shared release, but could be applied and rolled out in a distinct order.</p>

<h4>Using the Manifest and Smoothver</h4>


<p>Relying on the manifest and versions is requiring a few extra lines in the <a href="https://github.com/ferd/dandelion/blob/c98578a4bd97ce79693e5670ab57fd120a686387/k8s/dandelion.yaml#L133-L157">sidecar&#39;s update loop</a>. They look at the version, and if it&#39;s a RESTART bump or an older release, they ignore it:</p>
<div><pre><span></span><span># Get the running version</span>
<span>CURRENT</span><span>=</span><span>$(</span><span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> versions <span>|</span> awk <span>&#39;$3==&#34;permanent&#34; &amp;&amp; !vsn { vsn=$2 } $3==&#34;current&#34; { vsn=$2 } END { print vsn }&#39;</span><span>)</span>
<span>TAG</span><span>=</span><span>$(</span>curl <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-latest&#34;</span> -s<span>)</span>
<span>if</span> <span>[[</span> <span>&#34;</span><span>${</span><span>CURRENT</span><span>}</span><span>&#34;</span> !<span>=</span> <span>&#34;</span><span>${</span><span>TAG</span><span>}</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then</span>
    <span>IS_UPGRADE</span><span>=</span><span>$(</span><span>echo</span> <span>&#34;</span><span>$TAG</span><span> </span><span>$CURRENT</span><span>&#34;</span> <span>|</span> awk -vFS<span>=</span><span>&#39;[. ]&#39;</span> <span>&#39;($1==$4 &amp;&amp; $2&gt;$5) || ($1==$4 &amp;&amp; $2&gt;=$5 &amp;&amp; $3&gt;$6) {print 1; exit} {print 0}&#39;</span><span>)</span>
    <span>if</span> <span>[[</span> <span>$IS_UPGRADE</span> -eq <span>1</span> <span>]]</span><span>;</span> <span>then</span>
      wget -nv <span>&#34;</span><span>${</span><span>S3_URL</span><span>}</span><span>/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span> -O <span>&#34;</span><span>${</span><span>RELDIR</span><span>}</span><span>/releases/</span><span>${</span><span>RELEASE</span><span>}</span><span>-</span><span>${</span><span>TAG</span><span>}</span><span>.tar.gz&#34;</span>
      <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> unpack <span>${</span><span>TAG</span><span>}</span>
      <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> install <span>${</span><span>TAG</span><span>}</span>
      <span>${</span><span>RELDIR</span><span>}</span>/bin/<span>${</span><span>RELEASE</span><span>}</span> upgrade <span>${</span><span>TAG</span><span>}</span>
    <span>fi</span>
<span>fi</span>
</pre></div>

<p>There&#39;s some ugly awk logic, but I wanted to not host images. The script could be made a lot more solid by looking at whether we&#39;re bumping from the proper version to the next one, and in this it shares a sort of similar race condition to the generation step.</p>

<p>On the other hand, the <code>install</code> step looks at the specified upgrade instructions and will refuse to apply itself (resulting in a sidecar crash) if a bad release is applied.</p>

<p>I figure that alerting on crashed sidecars could be used to drive further automation to ask to delete and replace the pods, resulting in a rolling upgrade. Alternatively, the error itself could be used to trigger a failure in liveness and/or readiness probes, and force-automate that replacement. This is left as an exercise to the reader, I guess. The beauty of writing prototypes is that you can just decide this to be out of scope and move on, and let someone who&#39;s paid to operationalize that stuff to figure out the rest.</p>

<p>Oh and if you just change the Erlang VM&#39;s version? That changes the kubernetes YAML file, and if you&#39;re using anything like helm or some CD system (like ArgoCD), these will take care of running the rolling upgrade for you. Similarly, annotating the chart with a label of some sort indicating the RESTART version will accomplish the same purpose.</p>

<p>You may rightfully ask whether it is a good idea to bring mutability of this sort to a containerized world. I think that using S3 artifacts isn&#39;t inherently less safe than a container registry, dynamic feature flags, or relying on encryption services or DNS records for functional application state. I&#39;ll leave it at that.</p>

<h4>Adding CI validation</h4>


<p>Versioning things is really annoying. Each OTP app and library, and each release needs to be versioned properly. And sometimes you change dependencies and these dependencies won&#39;t have relup instructions available but you didn&#39;t know and that would break your live code upgrade.</p>

<p>What we can do is add a touch of automation to catch the most obvious failure situations and warn developers early about these issues. I&#39;ve done so by adding a quick <a href="https://github.com/ferd/dandelion/blob/main/.github/workflows/relup-ci.yml">relup CI step</a> to all pull requests, by using a <a href="https://github.com/ferd/dandelion/blob/main/scripts/check_versions">version check script</a> that encodes most of that logic.</p>

<p>The other thing I started experimenting with was setting up some sort of test suite for live code upgrades:</p>

<div><pre><span></span><span># This here step is a working sample, but if you were to run a more</span><span></span>
<span># complex app with external dependencies, you&#39;d also have to do a</span><span></span>
<span># more intricate multi-service setup here, e.g.:</span><span></span>
<span># https://github.com/actions/example-services</span><span></span>
<span>-</span><span> </span><span>name</span><span>:</span><span> </span><span>Run relup application</span><span></span>
<span>  </span><span>working-directory</span><span>:</span><span> </span><span>erlang</span><span></span>
<span>  </span><span>run</span><span>:</span><span> </span><span>|</span><span></span>
<span>    </span><span>mkdir relupci</span><span></span>
<span>    </span><span>tar -xvf &#34;${{ env.OLD_TAR }}&#34; -C relupci</span><span></span>
<span>    </span><span># use a simple &#34;run the task in the background&#34; setup</span><span></span>
<span>    </span><span>relupci/bin/dandelion daemon</span><span></span>
<span>    </span><span>TAG=$(echo &#34;${{ env.NEW_TAR }}&#34;  | sed -nr &#39;s/^.*([0-9]+\.[0-9]+\.[0-9]+)\.tar\.gz$/\1/p&#39;)</span><span></span>
<span>    </span><span>cp &#34;${{ env.NEW_TAR }}&#34; relupci/releases/</span><span></span>
<span>    </span><span>relupci/bin/dandelion unpack ${TAG}</span><span></span>
<span>    </span><span>relupci/bin/dandelion install ${TAG}</span><span></span>
<span>    </span><span>relupci/bin/dandelion upgrade ${TAG}</span><span></span>
<span>    </span><span>relupci/bin/dandelion versions</span><span></span>
</pre></div>


<p>The one thing that would make this one a lot cooler is to write a small extra app or release that runs in the background while the upgrade procedure goes on. It could do things like:</p>

<ul>
<li>generate constant load</li>
<li>run smoke tests on critical workflows</li>
<li>maintain live connections to show lack of failures</li>
<li>report on its state on demand</li>
</ul>
<p>By starting that process before the live upgrade and questioning it after, we could ensure that the whole process went smoothly. Additional steps could also look at logs to know if things were fine.</p>

<p>The advantage of adding CI here is that each pull request can take measures to ensure it is safely upgradable live before being merged to main, even if none of them are deployed right away. By setting that gate in place, engineers are getting a much shorter feedback loop asking them to think about live deployments.</p>

<h3>Running through a live code upgrade</h3>


<p>I&#39;ve run through a few iterations to test and check everything. I&#39;ve set up microk8s on my laptop, ran <code>kubectl -f apply dandelion.yaml</code> and showed that the pod was up and running fine:</p>
<pre>$ kubectl -n dandelion get pods
NAME                                    READY   STATUS    RESTARTS   AGE
dandelion-deployment-648db88f44-49jl8   2/2     Running   0          25H
</pre>
<p>It is possible to run into one of the containers, log on onto a REPL, and see what is going on:</p>
<div><pre><span></span><span>$ </span><span>kubectl</span><span> </span><span>-</span><span>n</span><span> </span><span>dandelion</span><span> </span><span>exec</span><span> </span><span>-</span><span>i</span><span> </span><span>-</span><span>t</span><span> </span><span>dandelion</span><span>-</span><span>deployment</span><span>-</span><span>648</span><span>db88f44</span><span>-</span><span>49</span><span>jl8</span><span> </span><span>-</span><span>c</span><span> </span><span>dandelion</span><span>-</span><span>sidecar</span><span> </span><span>--</span><span> </span><span>/</span><span>bin</span><span>/</span><span>bash</span><span></span>
<span>root</span><span>@</span><span>dandelion</span><span>-</span><span>deployment</span><span>-</span><span>648</span><span>db88f44</span><span>-</span><span>49</span><span>jl8</span><span>:</span><span>/</span><span>#</span><span> </span><span>/</span><span>release</span><span>/</span><span>bin</span><span>/</span><span>dandelion</span><span> </span><span>remote_console</span><span></span>
<span>Erlang</span><span>/</span><span>OTP</span><span> </span><span>25</span><span> </span><span>[</span><span>erts</span><span>-</span><span>13</span><span>.</span><span>0</span><span>.</span><span>2</span><span>]</span><span> </span><span>[</span><span>source</span><span>]</span><span> </span><span>[</span><span>64</span><span>-</span><span>bit</span><span>]</span><span> </span><span>[</span><span>smp</span><span>:</span><span>2</span><span>:</span><span>2</span><span>]</span><span> </span><span>[</span><span>ds</span><span>:</span><span>2</span><span>:</span><span>2</span><span>:</span><span>10</span><span>]</span><span> </span><span>[</span><span>async</span><span>-</span><span>threads</span><span>:</span><span>1</span><span>]</span><span> </span><span>[</span><span>jit</span><span>]</span><span></span>

<span>Eshell</span><span> </span><span>V13</span><span>.</span><span>0</span><span>.</span><span>2</span><span>  </span><span>(</span><span>abort</span><span> </span><span>with</span><span> </span><span>^</span><span>G</span><span>)</span><span></span>
<span>(</span><span>dandelion</span><span>@</span><span>localhost</span><span>)</span><span>1</span><span>&gt;</span><span> </span><span>release_handler</span><span>:</span><span>which_releases</span><span>().</span><span></span>
<span>[{</span><span>&#34;dandelion&#34;</span><span>,</span><span>&#34;0.1.5&#34;</span><span>,</span><span></span>
<span>  </span><span>[</span><span>&#34;kernel-8.4.1&#34;</span><span>,</span><span>&#34;stdlib-4.0.1&#34;</span><span>,</span><span>&#34;dandelion-0.1.5&#34;</span><span>,</span><span>&#34;sasl-4.2&#34;</span><span>],</span><span></span>
<span>  </span><span>permanent</span><span>},</span><span></span>
<span> </span><span>{</span><span>&#34;dandelion&#34;</span><span>,</span><span>&#34;0.1.4&#34;</span><span>,</span><span></span>
<span>  </span><span>[</span><span>&#34;kernel-8.4.1&#34;</span><span>,</span><span>&#34;stdlib-4.0.1&#34;</span><span>,</span><span>&#34;dandelion-0.1.4&#34;</span><span>,</span><span>&#34;sasl-4.2&#34;</span><span>],</span><span></span>
<span>  </span><span>old</span><span>}]</span><span></span>
</pre></div>

<p>This shows that the container had been running for a day, and already had two releases—it first booted on version 0.1.4 and had already gone through a bump to 0.1.5. I ran a <a href="https://github.com/ferd/dandelion/pull/6">small pull request</a> changing the display (and messed up versioning, which CI caught!), merged it, tagged it <code>v0.1.6</code>, and started listening to my Kubernetes cluster:</p>
<pre>$ nc 192.168.64.2 8080

   @
 \ |
__\!/__

...

   @
 \ |
__\!/__

vsn?
vsn: 0.1.5

   @
 \ |
__\!/__

      *
   @
 \ |
__\!/__

vsn?
vsn: 0.1.6
      *
   @
 \ |
__\!/__

...
</pre>
<p>This shows me interrogating the app (<code>vsn?</code>) and getting the version back, and without dropping the connection, having a little <a href="https://en.wikipedia.org/wiki/Pappus_(botany)">pappus</a> floating in the air.</p>

<p>My REPL session was still live in another terminal:</p>
<div><pre><span></span><span>(</span><span>dandelion</span><span>@</span><span>localhost</span><span>)</span><span>2</span><span>&gt;</span><span> </span><span>release_handler</span><span>:</span><span>which_releases</span><span>().</span><span></span>
<span>[{</span><span>&#34;dandelion&#34;</span><span>,</span><span>&#34;0.1.6&#34;</span><span>,</span><span></span>
<span>  </span><span>[</span><span>&#34;kernel-8.4.1&#34;</span><span>,</span><span>&#34;stdlib-4.0.1&#34;</span><span>,</span><span>&#34;dandelion-0.1.6&#34;</span><span>,</span><span>&#34;sasl-4.2&#34;</span><span>],</span><span></span>
<span>  </span><span>permanent</span><span>},</span><span></span>
<span> </span><span>{</span><span>&#34;dandelion&#34;</span><span>,</span><span>&#34;0.1.5&#34;</span><span>,</span><span></span>
<span>  </span><span>[</span><span>&#34;kernel-8.4.1&#34;</span><span>,</span><span>&#34;stdlib-4.0.1&#34;</span><span>,</span><span>&#34;dandelion-0.1.5&#34;</span><span>,</span><span>&#34;sasl-4.2&#34;</span><span>],</span><span></span>
<span>  </span><span>old</span><span>},</span><span></span>
<span> </span><span>{</span><span>&#34;dandelion&#34;</span><span>,</span><span>&#34;0.1.4&#34;</span><span>,</span><span></span>
<span>  </span><span>[</span><span>&#34;kernel-8.4.1&#34;</span><span>,</span><span>&#34;stdlib-4.0.1&#34;</span><span>,</span><span>&#34;dandelion-0.1.4&#34;</span><span>,</span><span>&#34;sasl-4.2&#34;</span><span>],</span><span></span>
<span>  </span><span>old</span><span>}]</span><span></span>
</pre></div>

<p>showing that the old releases are still around as well. And here we have it, an actual zero-downtime deploy in a kubernetes container.</p>

<h3>Conclusion</h3>


<p>Joe&#39;s favorite program could hold on a business card. Mine is maddening. But I think this is because Joe didn&#39;t care for the toolchains people were building and just wanted to do his thing. My version reflects the infrastructure we have put in place, and the processes we want and need for a team.</p>

<p>Rather than judging the scaffolding, I&#39;d invite you to think about what would change when you start centering your workflow around a living system.</p>

<p>Those of you who have worked with bigger applications that have a central database or shared schemas around network protocols (or protobuf files or whatever) know that you approach your work differently when you have to consider how it&#39;s going to be rolled out. It impacts your tooling, how you review changes, how you write them, and ultimately just changes how you reason about your code and changes.</p>

<p>In many ways it&#39;s a more cumbersome way to deploy and develop code, but you can also think of the other things that change: what if instead of having configuration management systems, you could hard-code your config in constants that just get rolled out live in less than a minute—and all your configs were tested as well as your code? Since all the release upgrades implicitly contain a release downgrade instruction set, just how much faster could you rollback (or automate rolling back) a bad deployment? Would you be less afraid of changing network-level schema definitions if you made a habit of changing them within your app? How would your workflow change if deploying took half-a-second and caused absolutely no churn nor disruption to your cluster resources most of the time?</p>

<p>Whatever structure we have in place guides a lot of invisible emergent behaviour, both in code and in how we adjust ourselves to the structure. Much of what we do is a tacit response to our environment. There&#39;s a lot of power in experimenting alternative structures, and seeing what pops up at the other end. A weed is only considered as such in some contexts. This is a freak show of a deployment mechanism, but it sort of works, and maybe it&#39;s time to appreciate the dandelions for what they can offer.</p>


    </article></div>
  </body>
</html>
