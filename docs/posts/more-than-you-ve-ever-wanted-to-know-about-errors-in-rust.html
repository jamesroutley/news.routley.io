<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.shuttle.rs/blog/2022/06/30/error-handling">Original</a>
    <h1>More than you&#39;ve ever wanted to know about errors in Rust</h1>
    
    <div id="readability-page-1" class="page"><article><p>This blog post is powered by shuttle! The serverless platform built for Rust.</p>
<hr/>
<p>To quote the Rust Book, &#39;errors are a fact of life in software&#39;. This post goes
over how to handle them.</p>
<p>Before talking about recoverable errors and the <code>Result</code> type, let&#39;s first
touch on unrecoverable errors - a.k.a  panics.</p>
<h2 id="panics">Panics</h2>
<p><a href="https://doc.rust-lang.org/std/macro.panic.html">Panics</a> are exceptions a program can throw. It stops all execution in the current thread. When a panic is thrown it returns a short description of what went wrong as well as information about the position of the the panic.</p>
<div><pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
<!-- -->    <span>panic!</span><span>(</span><span>&#34;error!&#34;</span><span>)</span><span>;</span>
<!-- -->    <span>println!</span><span>(</span><span>&#34;Never reached :(&#34;</span><span>)</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>Running the above causes:</p>
<div><pre><code>thread &#39;main&#39; panicked at &#39;error!&#39;, examples\panics.rs:2:5<!-- -->
</code></pre></div>
<p>They are similar to <code>throw</code> in JavaScript and other languages, in that they
don&#39;t require an annotation on the function to run and they can pass through
function boundaries. However in Rust, panics cannot be recovered from, there is no way to incept a panic in the current thread.</p>
<div><pre><code><span>fn</span> <span>send_message</span><span>(</span>s<span>:</span> <span>String</span><span>)</span> <span>{</span>
<!-- -->    <span>if</span> s<span>.</span><span>is_empty</span><span>(</span><span>)</span> <span>{</span>
<!-- -->       <span>panic!</span><span>(</span><span>&#34;Cannot send empty message&#34;</span><span>)</span><span>;</span>
<!-- -->    <span>}</span> <span>else</span> <span>{</span>
<!-- -->        
<!-- -->    <span>}</span>
<span>}</span>
</code></pre></div>
<p>The <code>send_message</code> function is fallible (can go wrong). If this is called
with an empty message then the program stops running. There is no way for the callee to track that an error has occurred.</p>
<p>For recoverable errors, Rust has a type for error handling in the standard
library called a <strong><code>Result</code></strong>. It is a generic type, which means the result
and error variant can basically be whatever you want.</p>
<div><pre><code><span>pub</span> <span>enum</span> <span>Result</span><span>&lt;</span><span>T</span><span>,</span> <span>E</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>Ok</span><span>(</span><span>T</span><span>)</span><span>,</span>
<!-- -->    <span>Err</span><span>(</span><span>E</span><span>)</span><span>,</span>
<span>}</span>
</code></pre></div>
<h2 id="basic-error-creation-and-handling">Basic error creation and handling</h2>
<p>At the moment our <code>send_message</code> function doesn&#39;t return anything. This means no information can be received by the callee. We can change the definition to instead return a <code>Result</code> and rather than panicking we can early return a <code>Result::Err</code>.</p>
<div><pre><code><span>fn</span> <span>send_message</span><span>(</span>s<span>:</span> <span>String</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>if</span> s<span>.</span><span>is_empty</span><span>(</span><span>)</span> <span>{</span>
<!-- -->        
<!-- -->        <span>return</span> <span>Result</span><span>::</span><span>Err</span><span>(</span><span>&#34;message is empty&#34;</span><span>)</span>
<!-- -->    <span>}</span> <span>else</span> <span>{</span>
<!-- -->        
<!-- -->    <span>}</span>
<!-- -->    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>Now our function actually returns information about what went wrong we can handle it when we call it:</p>
<div><pre><code><span>if</span> <span>let</span> <span>Err</span><span>(</span>send_error<span>)</span> <span>=</span> <span>send_message</span><span>(</span>message<span>)</span> <span>{</span>
<!-- -->    <span>show_user_error</span><span>(</span>send_error<span>)</span><span>;</span>
<span>}</span>
</code></pre></div>
<h3 id="rust-knows-when-a-result-is-unused">Rust knows when a Result is unused.</h3>
<p>In the above example we inspect the value of the item and branch on it.
However, if we didn&#39;t inspect and handle the returned Result then the Rust
compiler gives us a helpful warning about it so that you don&#39;t forget to
explicitly deal with errors in your program.</p>
<div><pre><code>|     send_message();<!-- -->
<!-- -->|     ^^^^^^^^^^^^^^^<!-- -->
<!-- -->= note: `#[warn(unused_must_use)]` on by default<!-- -->
<!-- -->= note: this `Result` may be an `Err` variant, which should be handled<!-- -->
</code></pre></div>
<h3 id="examples-of-result-in-the-standard-library">Examples of <code>Result</code> in the standard library</h3>
<p><code>Result</code> can be found in most libraries. One of my favorite examples is the
return type of the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html#tymethod.from_str">FromStr::from_str</a> trait method. With <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">str::parse</a> (which uses the <code>FromStr</code> trait) we can do the following:</p>
<div><pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
<!-- -->	<span>let</span> <span>mut</span> input <span>=</span> <span>String</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
<!-- -->	<span>std<span>::</span>io<span>::</span></span><span>stdin</span><span>(</span><span>)</span><span>.</span><span>read_line</span><span>(</span><span>&amp;</span><span>mut</span> input<span>)</span><span>.</span><span>unwrap</span><span>(</span><span>)</span><span>;</span>
<!-- -->
<!-- -->	<span>match</span> input<span>.</span><span>trim_end</span><span>(</span><span>)</span><span>.</span><span>parse</span><span>::</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>(</span><span>)</span> <span>{</span>
<!-- -->		<span>Ok</span><span>(</span>number<span>)</span> <span>=&gt;</span> <span>{</span>
<!-- -->			<span>dbg!</span><span>(</span>number<span>)</span><span>;</span>
<!-- -->		<span>}</span>
<!-- -->		<span>Err</span><span>(</span>err<span>)</span> <span>=&gt;</span> <span>{</span>
<!-- -->			<span>dbg!</span><span>(</span>err<span>)</span><span>;</span>
<!-- -->		<span>}</span>
<!-- -->	<span>}</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>(We&#39;ll ignore the <code>unwrap</code> for now 😉)</p>
<div><pre><code>$ cargo r <span>--</span>example input <span>-</span>q<!-- -->
<span>10</span>
<span>[</span>examples\input<span>.</span><span>rs</span><span>:</span><span>7</span><span>]</span> number <span>=</span> <span>10.0</span>
<!-- -->
<!-- -->$ cargo r <span>--</span>example input <span>-</span>q<!-- -->
<span>100</span>
<span>[</span>examples\input<span>.</span><span>rs</span><span>:</span><span>7</span><span>]</span> number <span>=</span> <span>100.0</span>
<!-- -->
<!-- -->$ cargo r <span>--</span>example input <span>-</span>q<!-- -->
<!-- -->bad<!-- -->
<span>[</span>examples\input<span>.</span><span>rs</span><span>:</span><span>10</span><span>]</span> err <span>=</span> <span>ParseFloatError</span> <span>{</span>
<!-- -->    <span>kind</span><span>:</span> <span>Invalid</span><span>,</span>
<span>}</span>
</code></pre></div>
<p>Here we can see when we type in a number we get a <code>Ok</code> variant with the number else we get a <a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html">ParseFloatError</a></p>
<h2 id="files-networks-and-databases">Files, networks and databases</h2>
<p><strong>All errors occur when you interact with the outside world or things
outside the Rust runtime</strong>. One of the places where a lot of errors can
occur is interacting with the file system. The <code>File::open</code> function
attempts to open a file. This can fail for a variety of reasons. The
filename is invalid, the file doesn&#39;t exist or you simply don&#39;t have
permission to read the file. Notice the errors are well-defined and known
before-hand. You can even access the error variants with the <a href="https://doc.rust-lang.org/std/io/struct.Error.html#method.kind"><code>kind</code></a> function
and in order to implement your program logic or return an instructive error
message to the user.</p>
<h3 id="aliasing-results-and-errors">Aliasing Results and errors</h3>
<p>When you&#39;re working on a project you&#39;ll often find yourself repeating
yourself when it comes to return types in function signatures:</p>
<div><pre><code><span>fn</span> <span>foo</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>SomeType</span><span>,</span> <span>MyError</span><span>&gt;</span> <span>{</span>
<span>...</span>
<span>}</span>
</code></pre></div>
<p>To give a concrete example, all functions which operate on the file system have
the same
errors (file not exists, invalid permissions). <a href="https://doc.rust-lang.org/std/io/type.Result.html">io::Result</a> is a alias over a result but means that every function does not have to specify the error type:</p>
<div><pre><code><span>pub</span> <span>type</span> <span>Result</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>=</span> <span>Result</span><span>&lt;</span><span>T</span><span>,</span> <span>io<span>::</span></span><span>Error</span><span>&gt;</span><span>;</span>
</code></pre></div>
<p>If you have an API which has a common error type, you may want to
consider this pattern.</p>
<h3 id="the-question-mark-operator">The question mark operator</h3>
<p>One of the best things about Results is the question mark operator, The
question mark operator can short circuit Result
error values. Let&#39;s look at a simple function which uploads text from a file.
This can error in a bunch of different ways:</p>
<div><pre><code><span>fn</span> <span>upload_file</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>let</span> text <span>=</span> <span>match</span> <span>std<span>::</span>fs<span>::</span></span><span>read_to_string</span><span>(</span><span>&#34;file.txt&#34;</span><span>)</span><span>.</span><span>map_err</span><span>(</span><span><span>|</span>_<span>|</span></span> <span>&#34;read file error&#34;</span><span>)</span> <span>{</span>
<!-- -->        <span>Ok</span><span>(</span>value<span>)</span> <span>=&gt;</span> value<span>,</span>
<!-- -->        <span>Err</span><span>(</span>err<span>)</span> <span>=&gt;</span> <span>{</span>
<!-- -->            <span>return</span> err<span>;</span>
<!-- -->        <span>}</span>
<!-- -->    <span>}</span><span>;</span>
<!-- -->    <span>if</span> <span>let</span> <span>Err</span><span>(</span>err<span>)</span> <span>=</span> <span>upload_text</span><span>(</span>text<span>)</span> <span>{</span>
<!-- -->        <span>return</span> err<!-- -->
<!-- -->    <span>}</span>
<!-- -->    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>Hang on, we&#39;re writing Rust not Go!</p>
<p>If a <code>?</code> is postfixed on to a Result (or anything that implements <a href="https://doc.rust-lang.org/std/ops/trait.Try.html"><code>try</code></a> so also <code>Option</code>) we can
obtain a functionally equivalent outcome with a much more readable and
concise syntax.</p>
<div><pre><code><span>fn</span> <span>upload_file</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span><span>&#39;static</span> <span>str</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>let</span> text <span>=</span> <span>std<span>::</span>fs<span>::</span></span><span>read_to_string</span><span>(</span><span>&#34;file.txt&#34;</span><span>)</span><span>.</span><span>map_err</span><span>(</span><span><span>|</span>_<span>|</span></span> <span>&#34;read file error&#34;</span><span>)</span><span>?</span><span>;</span>
<!-- -->    <span>upload_text</span><span>(</span>text<span>)</span><span>?</span><span>;</span>
<!-- -->    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>As long as the calling function also returns a <code>Result</code> with the
same <code>Error</code> type, <code>?</code> saves a ton of explicit code being written. Moreover,
the question-mark implicitly runs <a href="https://doc.rust-lang.org/std/convert/trait.Into.html#tymethod.into">Into::into</a>
(which is automatically implemented for <a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> implementors) on the error value. So we don&#39;t have to worry about converting the error before we use the operator:</p>
<div><pre><code>
<span>#[derive(derive_enum_from_into::EnumFrom)]</span>
<span>enum</span> <span>MyError</span> <span>{</span>
<!-- -->    <span>IoError</span><span>(</span><span>std<span>::</span>io<span>::</span></span><span>Error</span><span>)</span>
<!-- -->    
<span>}</span>
<!-- -->
<span>fn</span> <span>do_stuff</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>MyError</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>let</span> file <span>=</span> <span>File</span><span>::</span><span>open</span><span>(</span><span>&#34;data.csv&#34;</span><span>)</span><span>?</span><span>;</span>
<!-- -->    
<span>}</span>
</code></pre></div>
<p>We will look at more patterns for combining error types later!</p>
<h2 id="the-error-trait"><a href="https://doc.rust-lang.org/std/error/trait.Error.html">The Error trait</a></h2>
<p>The <a href="https://doc.rust-lang.org/std/error/trait.Error.html#">Error</a> trait is
defined in the standard library. It basically represents the expectations of
error values - values of type <code>E</code> in <code>Result&lt;T,E&gt;</code>.
<a href="https://doc.rust-lang.org/std/error/trait.Error.html#implementors">The Error trait is implemented for many errors</a>
and provides a unified API for information on errors. The Error trait is a bit needy and requires that the error implements both <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">Display</a>. While it can be cumbersome to implement we will see some helper libraries for doing so later on.</p>
<p>In the standard library <a href="https://doc.rust-lang.org/std/env/enum.VarError.html">VarError</a> (for reading environment variables) and <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html">ParseIntError</a> (for parsing a string slice as a integer) are different errors. When we interact them we need to differentiate between the types because they have different properties and different stack sizes. To build a combination of them we could build a sum type using an enum. Alternatively we can use dynamically dispatched traits which handle varying stack sized items and other type information.</p>
<p>Using the above mentioned try syntax (<code>?</code>) we can convert the above errors to be dynamically dispatched. This makes it easy to handle different errors without building enums to combine errors.</p>
<div><pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>std<span>::</span>error<span>::</span></span><span>Error</span><span>&gt;&gt;</span> <span>{</span>
<!-- -->    <span>let</span> key <span>=</span> <span>std<span>::</span>env<span>::</span></span><span>var</span><span>(</span><span>&#34;NUMBER_IN_ENV&#34;</span><span>)</span><span>?</span><span>;</span>
<!-- -->    <span>let</span> number <span>=</span> key<span>.</span><span>parse</span><span>::</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>(</span><span>)</span><span>?</span><span>;</span>
<!-- -->    <span>println!</span><span>(</span><span>&#34;\&#34;NUMBER_IN_ENV\&#34; is {}&#34;</span><span>,</span> number<span>)</span><span>;</span>
<!-- -->    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>While this is an easy way to handle errors, it isn&#39;t easy to differentiate
between the types and can make handling errors in libraries hard. More information on this later.</p>
<h3 id="the-error-trait-vs-results-and-enums">The Error trait vs Results and enums</h3>
<p>One thing when using an enum is we can use <code>match</code> to branch on the enum
error variants. On the other hand, with the <code>dyn</code> trait unless you go down
the down casting path it is very hard to get specific information about the
error:</p>
<div><pre><code><span>match</span> my_enum_error <span>{</span>
<!-- -->    <span>FsError</span><span>(</span>err<span>)</span> <span>=&gt;</span> <span>{</span>
<!-- -->        <span>report_fs_error</span><span>(</span>err<span>)</span>
<!-- -->    <span>}</span><span>,</span>
<!-- -->    <span>DbError</span><span>(</span><span>DbError</span> <span>{</span> err<span>,</span> database <span>}</span><span>)</span> <span>=&gt;</span> <span>{</span>
<!-- -->        <span>report_db_error</span><span>(</span>database<span>,</span> err<span>)</span>
<!-- -->    <span>}</span><span>,</span>
<span>}</span>
</code></pre></div>
<p>For reusable libraries it is better to use enums to combine errors so that
users of your library can handle the specifics themselves. But for CLIs and
other applications using the trait can be a lot simpler.</p>
<h2 id="methods-on-result">Methods on Result</h2>
<p>Result and Option contains many useful functions. Here are some functions I
commonly use:</p>
<h3 id="resultmap"><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map">Result::map</a></h3>
<p>This maps or converts the <code>Ok</code> value if it exists. This can be more concise
than using the <code>?</code> operator.</p>
<div><pre><code><span>fn</span> <span>string_to_plus_one</span><span>(</span>s<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>i32</span><span>,</span> <span>std<span>::</span>num<span>::</span></span><span>ParseIntError</span><span>&gt;</span> <span>{</span>
<!-- -->    s<span>.</span><span>parse</span><span>::</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>(</span><span>)</span><span>.</span><span>map</span><span>(</span><span><span>|</span>num<span>|</span></span> num <span>+</span> <span>1</span><span>)</span>
<span>}</span>
</code></pre></div>
<h3 id="resultok"><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.ok">Result::ok</a></h3>
<p>Useful for converting Results to Options</p>
<div><pre><code><span>assert_eq!</span><span>(</span><span>Ok</span><span>(</span><span>2</span><span>)</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>,</span> <span>Some</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
<span>assert_eq!</span><span>(</span><span>Err</span><span>(</span><span>&#34;err!&#34;</span><span>)</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>,</span> <span>None</span><span>)</span><span>;</span>
</code></pre></div>
<h3 id="optionok_or_else"><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else">Option::ok_or_else</a></h3>
<p>Useful for going the other way in converting from Options to Results</p>
<div><pre><code><span>fn</span> <span>get_first</span><span>(</span>vec<span>:</span> <span>&amp;</span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>&amp;</span><span>i32</span><span>,</span> <span>NotInVec</span><span>&gt;</span> <span>{</span>
<!-- -->    vec<span>.</span><span>first</span><span>(</span><span>)</span><span>.</span><span>ok_or_else</span><span>(</span><span><span>|</span><span>|</span></span> <span>NotInVec</span><span>)</span>
<span>}</span>
</code></pre></div>
<h3 id="error-handling-for-iteration">Error handling for iteration</h3>
<p>Using results in iterator chains can be a little confusing. Luckily <code>Result</code>
implements <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">collect</a>.
We can use this to short circuit an iterator if an error
occurs. In the following, if all the <code>parse</code>s succeed then we get collected vec of numbers result. If one fails then it instead returns a Result with the failing Err.</p>
<div><pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
<!-- -->	<span>let</span> a <span>=</span> <span>[</span><span>&#34;1&#34;</span><span>,</span> <span>&#34;2&#34;</span><span>,</span> <span>&#34;not a number&#34;</span><span>]</span>
<!-- -->		<span>.</span><span>into_iter</span><span>(</span><span>)</span>
<!-- -->		<span>.</span><span>map</span><span>(</span><span><span>|</span>a<span>|</span></span> a<span>.</span><span>parse</span><span>::</span><span>&lt;</span><span>f64</span><span>&gt;</span><span>(</span><span>)</span><span>)</span>
<!-- -->		<span>.</span><span>collect</span><span>::</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span>_<span>&gt;</span><span>,</span> _<span>&gt;&gt;</span><span>(</span><span>)</span><span>;</span>
<!-- -->	<span>dbg!</span><span>(</span>a<span>)</span><span>;</span>
<span>}</span>
</code></pre></div>
<div><pre><code>[examples\iteration.rs:6] a = Err( ParseFloatError { kind: Invalid, }, )<!-- -->
</code></pre></div>
<p>Removing the <code>&#34;not a number&#34;</code> entry</p>
<div><pre><code>[examples\iteration.rs:3] a = Ok( [ 1.0, 2.0, ], )<!-- -->
</code></pre></div>
<p>Because Rust iterators are <em>piecewise</em> and lazy the iterator can short circuit without evaluating parse on any of the later items.</p>
<h2 id="more-panic">More Panic</h2>
<h3 id="special-panics">Special panics</h3>
<p><code>todo!()</code>, <code>unimplemented!()</code>, <code>unreachable!()</code> are all wrappers for <code>panic! ()</code> which but are specialized to their situation. Panics have a special <a href="https://doc.rust-lang.org/reference/types/never.html"><code>!</code></a>
type, called the &#39;never type&#39;, which represents the result of computations
that never complete (also means it can be passed anywhere):</p>
<div><pre><code><span>fn</span> <span>func_i_havent_written_yet</span><span>(</span><span>)</span> <span>-&gt;</span> <span>u32</span> <span>{</span>
<!-- -->    <span>todo!</span><span>(</span><span>)</span>
<span>}</span>
</code></pre></div>
<p>Sometimes there is Rust code which the compiler cannot properly infer is
valid. For this type of situation, the <code>unreachable!</code> panic can be used:</p>
<div><pre><code><span>fn</span> <span>get_from_vec_else_zero</span><span>(</span>a<span>:</span> <span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>i32</span> <span>{</span>
<!-- -->    <span>if</span> <span>let</span> <span>Some</span><span>(</span>value<span>)</span> <span>=</span> a<span>.</span><span>get</span><span>(</span><span>2</span><span>)</span> <span>{</span>
<!-- -->        <span>if</span> <span>let</span> <span>Some</span><span>(</span>prev_value<span>)</span> <span>=</span> a<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span> <span>{</span>
<!-- -->            prev_value<!-- -->
<!-- -->        <span>}</span> <span>else</span> <span>{</span>
<!-- -->            <span>unreachable!</span><span>(</span><span>)</span>
<!-- -->        <span>}</span>
<!-- -->    <span>}</span> <span>else</span> <span>{</span>
<!-- -->        <span>0</span>
<!-- -->    <span>}</span>
<span>}</span>
</code></pre></div>
<h3 id="unwrapping">Unwrapping</h3>
<p><code>unwrap</code> is a method on <code>Result</code> and <code>Option</code>. They return the <code>Ok</code> or <code>Some</code>
variant or else panic...</p>
<div><pre><code>
<!-- -->
<span>let</span> value <span>=</span> <span>if</span> <span>let</span> <span>Ok</span><span>(</span>value<span>)</span> <span>=</span> result <span>{</span>
<!-- -->    value<!-- -->
<span>}</span> <span>else</span> <span>{</span>
<!-- -->    <span>panic!</span><span>(</span><span>&#34;Unwrapped!&#34;</span><span>)</span>
<span>}</span><span>;</span>
</code></pre></div>
<p>The uses-cases for this are developer error and situations the compiler can&#39;t
quite figure out.
If you are just trying something and don&#39;t want to set up a full error handling system then they can be used to ignore compiler warnings.</p>
<p>Even if the situation calls for <code>unwrap</code> you are better off using <code>expect</code>
which has an accompanying message - you&#39;ll be thanking your past self when the
<code>expect</code> error message helps you find the root cause of an issue 2 weeks
down the line.</p>
<h3 id="panics-in-the-standard-library">Panics in the standard library</h3>
<p>It is important to note that some of the APIs in the standard library <em>can</em>
panic. You should look out for these annotations in the docs. One of them is
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#panics-6">Vec::remove</a>.
If you use this you should ensure that the argument is in its indexable range.</p>
<div><pre><code><span>fn</span> <span>remove_at_idx</span><span>(</span>a<span>:</span> <span>usize</span><span>,</span> vec<span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>i32</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>if</span> a <span>&lt;</span> idx<span>.</span><span>len</span><span>(</span><span>)</span> <span>{</span>
<!-- -->        <span>Some</span><span>(</span>vec<span>.</span><span>remove</span><span>(</span>a<span>)</span><span>)</span>
<!-- -->    <span>}</span> <span>else</span> <span>{</span>
<!-- -->        <span>None</span>
<!-- -->    <span>}</span>
<span>}</span>
</code></pre></div>
<h2 id="handling-multiple-errors-and-helper-crates">Handling multiple errors and helper crates:</h2>
<p>Handling errors from multiple libraries and APIs can become challenging as
you have to deal with a bunch of different types. They are different sizes
and contain different information. To unify the types we have to build a sum
type using an enum, in order to ensure they have the same size at compile time.</p>
<div><pre><code><span>enum</span> <span>Errors</span> <span>{</span>
<!-- -->    <span>FileSystemError</span><span>(</span><span>..</span><span>)</span><span>,</span>
<!-- -->    <span>StringParseError</span><span>(</span><span>..</span><span>)</span><span>,</span>
<!-- -->    <span>NetworkError</span><span>(</span><span>..</span><span>)</span><span>,</span>
<span>}</span>
</code></pre></div>
<p>Some crates for making creating these unifying enums easier:</p>
<h3 id="thiserror"><a href="https://crates.io/crates/thiserror">thiserror</a></h3>
<p><code>thiserror</code> provides a derive implementation which adds the Error trait for us.
As previously mentioned, to implement Error we have to implement display and
thiserrors&#39; <code>#[error]</code> attributes provide templating for the displayed errors.</p>
<div><pre><code><span>use</span> <span>thiserror<span>::</span></span><span>Error</span><span>;</span>
<!-- -->
<span>#[derive(Error, Debug)]</span>
<span>pub</span> <span>enum</span> <span>DataStoreError</span> <span>{</span>
<!-- -->    <span>#[error(<span>&#34;data store disconnected&#34;</span>)]</span>
<!-- -->    <span>Disconnect</span><span>(</span><span>#[from]</span> <span>io<span>::</span></span><span>Error</span><span>)</span><span>,</span>
<!-- -->    <span>#[error(<span>&#34;the data for key `{0}` is not available&#34;</span>)]</span>
<!-- -->    <span>Redaction</span><span>(</span><span>String</span><span>)</span><span>,</span>
<!-- -->    <span>#[error(<span>&#34;invalid header (expected {expected:?}, found {found:?})&#34;</span>)]</span>
<!-- -->    <span>InvalidHeader</span> <span>{</span>
<!-- -->        expected<span>:</span> <span>String</span><span>,</span>
<!-- -->        found<span>:</span> <span>String</span><span>,</span>
<!-- -->    <span>}</span><span>,</span>
<!-- -->    <span>#[error(<span>&#34;unknown data store error&#34;</span>)]</span>
<!-- -->    <span>Unknown</span><span>,</span>
<span>}</span>
</code></pre></div>
<h3 id="anyhow"><a href="https://crates.io/crates/anyhow">anyhow</a></h3>
<p><code>anyhow</code> provides an ergonomic and idiomatic alternative to explicitly
handling errors. It is similar to the previously mentioned error trait but
has additional features such as adding context to thrown errors.</p>
<p>This is really, really, useful when you want to convey errors to an
application&#39;s users in a context-aware fashion:</p>
<div><pre><code><span>use</span> <span>anyhow<span>::</span></span><span>{</span>bail<span>,</span> <span>Result</span><span>,</span> <span>Context</span><span>}</span><span>;</span>
<!-- -->
<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>println!</span><span>(</span><span>&#34;Hello World!&#34;</span><span>)</span><span>;</span>
<!-- -->    <span>func1</span><span>(</span><span>)</span><span>.</span><span>context</span><span>(</span><span>&#34;while calling func1&#34;</span><span>)</span><span>?</span><span>;</span>
<!-- -->    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
<!-- -->
<span>fn</span> <span>func1</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>func2</span><span>(</span><span>)</span><span>.</span><span>context</span><span>(</span><span>&#34;while calling func2&#34;</span><span>)</span>
<span>}</span>
<!-- -->
<span>fn</span> <span>func2</span><span>(</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span> <span>{</span>
<!-- -->    <span>bail!</span><span>(</span><span>&#34;Hmm something went wrong &#34;</span><span>)</span>
<span>}</span>
</code></pre></div>
<div><pre><code>Error: while calling func1<!-- -->
<!-- -->
<!-- -->Caused by:<!-- -->
<!-- -->    0: while calling func2<!-- -->
<!-- -->    1: Hmm something went wrong<!-- -->
</code></pre></div>
<p>Similar to the <code>Error</code> trait, <code>anyhow</code> suffers from the fact you can&#39;t match on
<code>anyhow</code>&#39;s result error variant. This is why it is suggested in <code>anyhow</code>&#39;s
docs to use <code>anyhow</code> for applications and <code>thiserror</code> for libraries.</p>
<h3 id="eyre"><a href="https://crates.io/crates/eyre">eyre</a></h3>
<p>Finally, <code>eyre</code> is a fork of <code>anyhow</code> and adds more backtrace information.
It&#39;s highly customisable and using <a href="https://lib.rs/crates/color-eyre">color-eyre</a> we get colors in our panic messages - a little color
always brightens up the dev experience.</p>
<div><pre><code>The application panicked (crashed).<!-- -->
<!-- -->Message:  test<!-- -->
<!-- -->Location: examples\color_eyre.rs:6<!-- -->
<!-- -->
<!-- -->  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ BACKTRACE ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━<!-- -->
<!-- -->                                ⋮ 13 frames hidden ⋮<!-- -->
<!-- -->  14: core::ops::function::FnOnce::call_once&lt;enum$&lt;core::result::Result&lt;tuple$&lt;&gt;,eyre::Report&gt;, 1, 18446744073709551615, Err&gt; (*)(),tuple$&lt;&gt; &gt;&lt;unknown&gt;<!-- -->
<!-- -->      at /rustc/7737e0b5c4103216d6fd8cf941b7ab9bdbaace7c\library\core\src\ops\function.rs:227<!-- -->
<!-- -->                                ⋮ 17 frames hidden ⋮<!-- -->
</code></pre></div>
<h2 id="shuttle-stateful-serverless-for-rust"><a href="https://www.shuttle.rs/">Shuttle</a>: Stateful Serverless for Rust</h2>
<p>Deploying and managing your Rust web apps can be an expensive, anxious and time consuming process.</p>
<p>If you want a batteries included and ops-free experience, <a href="https://docs.rs/shuttle-service/latest/shuttle_service/">try out Shuttle</a>.</p></article></div>
  </body>
</html>
