<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devlog.hexops.com/2022/packed-structs-in-zig/">Original</a>
    <h1>Packed structs in Zig make bit/flag sets trivial</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><main aria-role="main"><div><p>As we’ve been building <a href="https://machengine.org/">Mach engine</a>, we’ve been using a neat little pattern in Zig that enables writing flag sets more nicely in Zig than in other languages.</p><h2 id="what-is-a-flag-set">What is a flag set?</h2><p>We’ve been rewriting <code>mach/gpu</code> (WebGPU bindings for Zig) from scratch recently, so let’s take a flag set from the WebGPU C API:</p><div><pre><code data-lang="c"><span>typedef</span> <span>uint32_t</span> <span>WGPUFlags</span><span>;</span>
<span>typedef</span> <span>WGPUFlags</span> <span>WGPUColorWriteMaskFlags</span><span>;</span>
</code></pre></div><p>Effectively, <code>WGPUColorWriteMaskFlags</code> here is a 32-bit unsigned integer where you can set specific bits in it to represent whether or not to write certain colors:</p><div><pre><code data-lang="c"><span>typedef</span> <span>enum</span> <span>WGPUColorWriteMask</span> <span>{</span>
    <span>WGPUColorWriteMask_None</span> <span>=</span> <span>0x00000000</span><span>,</span>
    <span>WGPUColorWriteMask_Red</span> <span>=</span> <span>0x00000001</span><span>,</span>
    <span>WGPUColorWriteMask_Green</span> <span>=</span> <span>0x00000002</span><span>,</span>
    <span>WGPUColorWriteMask_Blue</span> <span>=</span> <span>0x00000004</span><span>,</span>
    <span>WGPUColorWriteMask_Alpha</span> <span>=</span> <span>0x00000008</span><span>,</span>
    <span>WGPUColorWriteMask_All</span> <span>=</span> <span>0x0000000F</span><span>,</span>
    <span>WGPUColorWriteMask_Force32</span> <span>=</span> <span>0x7FFFFFFF</span>
<span>}</span> <span>WGPUColorWriteMask</span><span>;</span>
</code></pre></div><p>Then to use it you’d use the various bit operations with those masks, e.g.:</p><div><pre><code data-lang="c"><span>WGPUColorWriteMaskFlags</span> <span>mask</span> <span>=</span> <span>WGPUColorWriteMask_Red</span> <span>|</span> <span>WGPUColorWriteMask_Green</span><span>;</span>
<span>mask</span> <span>|=</span> <span>WGPUColorWriteMask_Blue</span><span>;</span> <span>// set blue bit
</span></code></pre></div><p>This all works, people have been doing it for years in C, C++, Java, Rust, and more. In Zig, we can do better.</p><h2 id="zig-packed-structs">Zig packed structs</h2><p><img src="https://user-images.githubusercontent.com/3173176/184735519-cc78d19d-73e8-4914-8f3d-fc3a15d00bb7.png"/></p><p>Zig has <code>packed struct</code>s: these let us pack memory tightly, where a <code>bool</code> is actually a single bit (in most other languages, this is not true.) Zig also has arbitrary bit-width integers, like <code>u28</code>, <code>u1</code> and so on.</p><p>We can write <code>WGPUColorWriteMaskFlags</code> from earlier in Zig using:</p><div><pre><code data-lang="zig"><span>pub</span><span> </span><span>const</span><span> </span><span>ColorWriteMaskFlags</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span> </span><span>{</span><span>
</span><span>    </span><span>red</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>green</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>blue</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>alpha</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>
</span><span>    </span><span>_padding</span><span>:</span><span> </span><span>u28</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span>
</span><span></span><span>};</span><span>
</span></code></pre></div><p>This is still just 32 bits of memory, and so can be passed to the same C APIs that expect a <code>WGPUColorWriteMaskFlags</code> - but interacting with it is much nicer:</p><div><pre><code data-lang="zig"><span>var</span><span> </span><span>mask</span><span> </span><span>=</span><span> </span><span>ColorWriteMaskFlags</span><span>{.</span><span>red</span><span> </span><span>=</span><span> </span><span>true</span><span>,</span><span> </span><span>.</span><span>green</span><span> </span><span>=</span><span> </span><span>true</span><span>};</span><span>
</span><span></span><span>mask</span><span>.</span><span>blue</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span><span> </span><span>// set blue bit
</span></code></pre></div><p>In C you would need to write code like this:</p><div><pre><code data-lang="c"><span>if</span> <span>(</span><span>mask</span> <span>&amp;</span> <span>WGPUColorWriteMask_Alpha</span><span>)</span> <span>{</span>
    <span>// alpha is set..
</span><span></span><span>}</span>
<span>if</span> <span>(</span><span>mask</span> <span>&amp;</span> <span>(</span><span>WGPUColorWriteMask_Alpha</span><span>|</span><span>WGPUColorWriteMask_Blue</span><span>))</span> <span>{</span>
    <span>// alpha and blue are set..
</span><span></span><span>}</span>
<span>if</span> <span>((</span><span>mask</span> <span>&amp;</span> <span>WGPUColorWriteMask_Green</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>// green not set
</span><span></span><span>}</span>
</code></pre></div><p>In Zig it’s just:</p><div><pre><code data-lang="zig"><span>if</span><span> </span><span>(</span><span>mask</span><span>.</span><span>alpha</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>// alpha is set..
</span><span></span><span>}</span><span>
</span><span></span><span>if</span><span> </span><span>(</span><span>mask</span><span>.</span><span>alpha</span><span> </span><span>and</span><span> </span><span>mask</span><span>.</span><span>blue</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>// alpha is set..
</span><span></span><span>}</span><span>
</span><span></span><span>if</span><span> </span><span>(</span><span>!</span><span>mask</span><span>.</span><span>green</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>// green not set
</span><span></span><span>}</span><span>
</span></code></pre></div><h2 id="comptime-validation">Comptime validation</h2><p>Making sure that our <code>ColorWriteMaskFlags</code> ends up being the same size could be a bit tricky: what if we count the number of <code>bool</code> wrong? Or what if we accidently get the padding size wrong? Then it might not be the same size as a <code>uint32</code> anymore.</p><p>Luckily, we can verify our expectations at comptime:</p><div><pre><code data-lang="zig"><span>pub</span><span> </span><span>const</span><span> </span><span>ColorWriteMaskFlags</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span> </span><span>{</span><span>
</span><span>    </span><span>red</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>green</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>blue</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>alpha</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>
</span><span>    </span><span>_padding</span><span>:</span><span> </span><span>u28</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span>
</span><span>
</span><span>    </span><span>comptime</span><span> </span><span>{</span><span>
</span><span>        </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>assert</span><span>(</span><span>@sizeOf</span><span>(</span><span>@This</span><span>())</span><span> </span><span>==</span><span> </span><span>@sizeOf</span><span>(</span><span>u32</span><span>));</span><span>
</span><span>        </span><span>std</span><span>.</span><span>debug</span><span>.</span><span>assert</span><span>(</span><span>@bitSizeOf</span><span>(</span><span>@This</span><span>())</span><span> </span><span>==</span><span> </span><span>@bitSizeOf</span><span>(</span><span>u32</span><span>));</span><span>
</span><span>    </span><span>}</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>The Zig compiler will take care of running the <code>comptime</code> code block here for us when building, and it will verify that the byte size of <code>@This()</code> (the type we’re inside of, the <code>ColorWriteMaskFlags</code> struct in this case) matches the <code>@sizeOf(u32)</code>.</p><p>Similarly we could check the <code>@bitSizeOf</code> both types if we like.</p><p>Note that <a href="https://ziglang.org/documentation/master/#sizeOf"><code>@sizeOf</code></a> may include the size of padding for more complex types, while <a href="https://ziglang.org/documentation/master/#bitSizeOf"><code>@bitSizeOf</code></a> returns the number of bits it takes to store <code>T</code> in memory <em>if the type were a field in a packed struct/union</em>. For flag sets like this, it doesn’t matter and either will do. For more complex types, be sure to recall this.</p><h2 id="explicit-backing-integers-for-packed-structs">Explicit backing integers for packed structs</h2><p>It’s worth noting that in Zig 0.10 (shipping in Nov), the new self-hosted compiler has support for <a href="https://github.com/ziglang/zig/pull/12379">explicit backing integers for packed structs</a> which will simplify this even further.</p><p>Instead of manually adding padding to make up 32 bits, one could simply write <code>packed struct(u32)</code>:</p><div><pre><code data-lang="zig"><span>pub</span><span> </span><span>const</span><span> </span><span>ColorWriteMaskFlags</span><span> </span><span>=</span><span> </span><span>packed</span><span> </span><span>struct</span><span>(</span><span>u32</span><span>)</span><span> </span><span>{</span><span>
</span><span>    </span><span>red</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>green</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>blue</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span>    </span><span>alpha</span><span>:</span><span> </span><span>bool</span><span> </span><span>=</span><span> </span><span>false</span><span>,</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><h2 id="thanks-for-reading">Thanks for reading</h2><p><img src="https://user-images.githubusercontent.com/3173176/187348488-0b52e87d-3a48-421c-9402-be78e32b5a20.png"/>
Be sure to join the new <a href="https://discord.gg/XNG3NZgCqp">Mach engine Discord server</a> where we’re building the future of Zig game development.</p></div></main></div></div>
  </body>
</html>
