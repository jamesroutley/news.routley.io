<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://404wolf.com/posts/whirlwindtourofnix/">Original</a>
    <h1>Tour of Nix</h1>
    
    <div id="readability-page-1" class="page"><div><astro-slot> <div>  <p>Okay, before we get started:</p>
<p>NO, NIX IS NOT JUST AN OPERATING SYSTEM. I’m going to talk about what it is and
what you can use it for, but <code>nixos</code> is merely a project that uses the <code>nix</code>
language/tooling. You do not need to even use <code>linux</code> to use <code>nix</code>. Okay, now
that we have that out of the way let’s get started.</p>

<p>Before even grappling with what it is, I think it’s good to understand what it
can do. Some awesome things that nix does:</p>
<ul>
<li>Consistent developer environments that are decoratively specified. This means
everyone working on a project can have the same LSP, binaries in their $PATH,
etc.</li>
<li>Pure, reproducible project builds. Nix “wraps” onto tooling you already use
for builds, and does the build in a sandbox. This means that there’s no
internet access, the time is set to <code>0</code> (UTC) (which means things like Latex
“builds”, which inject timestamps, will be reproducible too!), and more.</li>
<li>Let you configure your home directory using a project called “home manager.”
You can specify how to set up various programs and their configurations fully
declarativly with <code>nix</code> code.</li>
<li>Create very minimal docker images, that don’t have a <code>FROM</code> (that are
<code>FROM SCRATCH</code>), and only have exactly the things you need to dockerize your
project.</li>
<li>Get an android emulator going in 4 lines of code. And a million other things.</li>
</ul>
<p>Where nix really shines is reproduability. If it works once, it will probably
work again.</p>

<p>What is <strong>purity?</strong> Purity just means when you put X, Y, and Z in, you’ll get W
out. If you put X, Y, and Z in two weeks later, on a Mac, in a different time
zone, you’ll get W out. If you install a different C compiler, you’ll still get
W out. Nix can guarantee that your builds are pure.</p>
<p>What is <strong>lazy</strong>? Lazy just means that the language won’t try to evaluate
anything it does not absolutely need to evaluate. If you import every package in
existence, <code>nixpkgs</code>, <code>nix</code> will not literally build everything. But if you
reference <code>foobar</code> from <code>nixpkgs</code> then it will build it.</p>

<p>The question with so many answers. Nix is at least 4 totally different things.</p>
<p><img src="https://static.404wolf.com/map_repo_size_fresh_0001.svg" alt="So many nix packages!"/></p>
<ol>
<li>It’s a programming language. It’s functional, lazy, and can be pure. You can
do basic things like <code>{ a, b }: a + b</code>! You can also use it to do more
advanced tasks like mapping over arrays or attrsets (dictionaries), and
everything you’d want from a programming language.</li>
<li>It’s a <a href="https://search.nixos.org/">package manager</a>! The nix repository has
more packages than any other package manager (<code>apt</code>, <code>pacman</code>, etc), and more
fresh (new) packages too! All the packages are not actual binary blobs, but
<code>nix</code> code (remember, it’s a language!) that defines build instructions for
producing <code>derivations</code> (more on this later) containing over 100k different
projects. This even includes pure build instructions for things like building
<code>chrome</code> from source and packaged patched binaries like jetbrains IDEs (ikk).
Your packages are all nicely managed in a <code>nix store</code>, again, more on this
later.</li>
<li>It’s a utility library. <code>nixpkgs</code> is a library that contains a bunch of
utilities that let you do super cool things, like defining pure builds for
minimal <code>FROM SCRATCH</code> docker images. It fixes all the bloat of <code>docker</code>!</li>
<li>It’s an operating system. Because it gives you so much power in specifying an
exact state of a build output (a “derivation”), people have used it to create
<a href="https://nixos.org/">nixos</a>. NixOS is a completely decoratively specified
Linux distribution where your entire computer configuration lies in <code>.nix</code>
text files. I have configured my computer this way, and, though it was a long
process, the declarativity/reproducitivity is really nice.</li>
</ol>

<h3 id="the-nix-store">The “nix store”</h3>
<p>There is this thing called the “nix store”. It’s just a directory that’s read
only, usually at <code>/nix/store</code>. You can write nix code, using the <code>derivation</code>
keyword, to create them, but that’s very low level. I’ll let you read more about
them <a href="https://nixos.org/guides/nix-pills/06-our-first-derivation">here</a>, but in
this post we’ll just use <code>pkgs.stdenv.mkDerivation</code>, along with trivial builders
like <code>pkgs.writeShellScriptBin</code>. They are handy helper functions from the
<code>nixpkgs</code> utilities (remember when I said nix was a utility library!).
Everything in the <code>nixpkgs</code> registry outputs derivations. These “derivations”
are resulting directories in this “nix store”, that look like
<code>«derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv»</code> — they
are just subdirectories of the store. The outputs are read only because they are
in the store, and we know that everything that made its way to the store did so
in a way that was pure.</p>
<p>If you’re interested in how derivations actually work, there’s some intermediate
steps, including producing a <code>drv</code> file with instructions to nix on how to
create it. But I’m going to skip over that.</p>
<h2 id="flakes">Flakes</h2>
<p>Flakes are really just entrypoints. The older way to do things with <code>nix</code> was to
use channels. I don’t want to go too far into those, since they are lame (sorry,
it’s true), but basically, they are global references to sources. They’d let you
specify internet inputs to projects with <code>&lt;&gt;</code> syntax:</p>
<pre tabindex="0" data-language="nix"><code><span><span>{ pkgs </span><span>?</span><span> import</span><span> &lt;nixpkgs&gt;</span><span> { }</span><span>,</span><span> }:</span></span>
<span><span>...</span></span></code></pre>
<p>Where we by default get <code>nixpkgs</code> from the global “channel” (iickk)! That’s
im<strong>pure</strong>. What if nix decides to update their <code>unstable</code> branch (nixpkgs is
just a git repo!) and your package references break?</p>
<p>So from this point on I’m going to pretend channels don’t exist, and completely
stop using them (mostly). Flakes are nix’s solution to the problem. They
guarantee real purity.</p>
<p>A flake has this basic structure:</p>
<pre tabindex="0" data-language="nix"><code><span><span># flake.nix</span></span>
<span><span>{</span></span>
<span><span>  inputs</span><span> =</span><span> {}; </span><span># Specify inputs with URIs</span></span>
<span><span>  outputs</span><span> =</span><span> {self</span><span>,</span><span> ...</span><span>}: {}; </span><span># A function!</span></span>
<span><span>}</span></span></code></pre>
<p>It lives in a <code>flake.nix</code></p>
<p>Where we usually make inputs at least have
<code>nixpkgs.url = &#34;github:nixos/nixpkgs/nixos-unstable&#34;;</code>, the nix package
registry, with all the packages we may ever want. <code>self</code> is a reference to the
project at its previous commit, and flakes require you to use version control to
ensure purity of file inputs.</p>
<p>You might be thinking, “hey, <code>github:nixos/nixpkgs/nixos-unstable</code> doesn’t sound
very pure!” True. <code>flakes</code> generate lockfiles with reversions and <code>sha256</code>
hashes. When we run <code>nix flake lock</code> we get something like this.</p>
<pre tabindex="0" data-language="json"><code><span><span>// flake.lock</span></span>
<span><span>{</span></span>
<span><span>  &#34;nodes&#34;</span><span>: {</span></span>
<span><span>    &#34;nixpkgs&#34;</span><span>: {</span></span>
<span><span>      &#34;locked&#34;</span><span>: {</span></span>
<span><span>        &#34;lastModified&#34;</span><span>: </span><span>1719690277</span><span>,</span></span>
<span><span>        &#34;narHash&#34;</span><span>: </span><span>&#34;sha256-0xSej1g7eP2kaUF+JQp8jdyNmpmCJKRpO12mKl/36Kc=&#34;</span><span>,</span></span>
<span><span>        &#34;owner&#34;</span><span>: </span><span>&#34;NixOS&#34;</span><span>,</span></span>
<span><span>        &#34;repo&#34;</span><span>: </span><span>&#34;nixpkgs&#34;</span><span>,</span></span>
<span><span>        &#34;rev&#34;</span><span>: </span><span>&#34;2741b4b489b55df32afac57bc4bfd220e8bf617e&#34;</span><span>,</span></span>
<span><span>        &#34;type&#34;</span><span>: </span><span>&#34;github&#34;</span></span>
<span><span>      },</span></span>
<span><span>      &#34;original&#34;</span><span>: {</span></span>
<span><span>        &#34;owner&#34;</span><span>: </span><span>&#34;NixOS&#34;</span><span>,</span></span>
<span><span>        &#34;ref&#34;</span><span>: </span><span>&#34;nixos-unstable&#34;</span><span>,</span></span>
<span><span>        &#34;repo&#34;</span><span>: </span><span>&#34;nixpkgs&#34;</span><span>,</span></span>
<span><span>        &#34;type&#34;</span><span>: </span><span>&#34;github&#34;</span></span>
<span><span>      }</span></span>
<span><span>    },</span></span>
<span><span>  &#34;root&#34;</span><span>: </span><span>&#34;root&#34;</span><span>,</span></span>
<span><span>  &#34;version&#34;</span><span>: </span><span>7</span></span>
<span><span>}</span></span></code></pre>
<p>Flakes let us define ways to get to derivation (the things that “build their way
into” the nix store).</p>
<h3 id="a-c-hello-world">A C hello world</h3>
<p>A grain of salt: I don’t do much C. But I’m going to kick off this section with
a C hello world, specifically because C is pretty easy to compile, and has a
<em>build time</em> requirement: a compiler like <code>gcc</code>.</p>
<p>This is a bit boring, but the way we package this will be helpful for some more
fun stuff later.</p>
<p>First, we make a <code>hello.c</code> with a hello world…</p>
<pre tabindex="0" data-language="c"><code><span><span>#include</span><span> &lt;stdio.h&gt;</span></span>
<span></span>
<span><span>int</span><span> main</span><span>() {</span></span>
<span><span>  printf</span><span>(</span><span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>  return</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Okay, we’ve created the hello world. Now time to define the build with <code>nix</code>.</p>
<p>To start, a tiny bit more on flakes.</p>
<p>With flakes, there’s some special <code>outputs</code> that <code>nix</code> will look for.</p>
<ul>
<li><code>packages.${system}.default</code>
<ul>
<li>If we’re running linux (this works on mac too though), this might be
<code>packages.x86_64-linux.default</code>. This is basically the “default” thing that
gets build when we do <code>nix build</code>, but if we specify something else, like
<code>packages.${system}.foobar</code>, then we can build the derivation with the <code>nix</code>
cli using <code>nix build .#foobar</code> instead.</li>
</ul>
</li>
</ul>
<p>This means that a flake often will look something like</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  inputs</span><span> =</span><span> { ... };</span></span>
<span><span>  outputs</span><span> =</span><span> { self</span><span>,</span><span> ... </span><span>}:</span></span>
<span><span>    {</span></span>
<span><span>      packages</span><span>.</span><span>x86_64-linux</span><span> =</span><span> {</span></span>
<span><span>        default</span><span> =</span><span> pkgs</span><span>.</span><span>writeShellScriptBin</span><span> &#34;hello&#34;</span><span> &#34;echo &#39;hello!&#39;&#34;</span></span>
<span><span>      }</span><span>;</span></span>
<span><span>    };</span></span>
<span><span>}</span></span></code></pre>
<p>Having to define an export for every system when our project isn’t really system
specific is annoying, so nixers often use something called <code>flake-utils</code>, which
provides a helpful <code>eachDefaultSystem</code> utility to generate the different outputs
for different systems for us. Nix is <code>lazy</code>, so it’ll only build for the system
we need to build for when we run <code>nix build</code>.</p>
<pre tabindex="0" data-language="nix"><code><span><span>...</span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (</span></span>
<span><span>      system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        packages</span><span> =</span><span> {</span></span>
<span><span>          default</span><span> =</span><span> # (The derivation / builder)</span></span>
<span><span>        }</span><span>;</span></span>
<span><span>...</span></span></code></pre>
<p><code>eachDefaultSystem</code> is a function that intakes a function that takes an argument
<code>system</code>, that outputs the regular outputs based on it, and then provides
outputs for all systems supported by nix (but only evaluates when you need to).</p>
<p>Returning to our <code>C</code> hello world, we will use a helper function called
<code>pkgs.stdenv.mkDerivation</code>. <code>nix</code> ships with a <code>derivation</code> keyword, but that
takes a binary that expects to make the derivation, and is super raw. This
helper will do a lot of the heavy lifting by breaking things up into stages —
the <code>unpack phase</code>, <code>build phase</code>, and <code>install phase</code> (and a ton others — see
<a href="https://nixos.org/manual/nixpkgs/stable/#sec-stdenv-phases">here</a>).</p>
<p><code>buildInputs</code> specifies what should be available in the path of our builder’s
environment. We can use <code>nativeBuildInputs</code> since our <code>buildInputs</code> are only
needed during building — native implies that the program itself doesn’t need
them.</p>
<h4 id="the-sandbox">The Sandbox</h4>
<p>All <code>nix</code> builds happen in a special sandbox. The <code>src</code> argument specifies what
should exist in the sandbox. We need to move the source code over!</p>
<p>The <code>sandbox</code> does a lot to ensure that we are declarative and the output is
<strong>pure</strong>.</p>
<blockquote>
<p>When sandbox builds are enabled, Nix will set up an isolated environment for
each build process by constraining build inputs to improve reproducibility.</p>
</blockquote>
<blockquote>
<p>It is achieved by isolating build jobs from input sources whose contents are
prone to change dynamically and without notice. For example, the main file
system hierarchy is completely bypassed to prevent depending on files in
global directories, such as <code>/usr/bin</code>, where a reference to an executable may
point to different version as time goes by.</p>
</blockquote>
<p>Also, it does things like disallow networking and sets the timestamp to UNIX 0
(even time is dynamic and could lead to impurity!).</p>
<p>Okay. So let’s look at the <code>flake</code>…</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;C Hello world&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:nixos/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> ( system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        packages</span><span>.</span><span>default</span><span> =</span><span> pkgs</span><span>.</span><span>stdenv</span><span>.</span><span>mkDerivation</span><span> {</span></span>
<span><span>          pname</span><span> =</span><span> &#34;hello&#34;</span><span>;</span></span>
<span><span>          version</span><span> =</span><span> &#34;1.0&#34;</span><span>;</span></span>
<span><span>          src</span><span> =</span><span> self</span><span>; </span><span># code at the last commit</span></span>
<span><span>          nativeBuildInputs</span><span> =</span><span> [ </span><span>pkgs</span><span>.</span><span>gcc</span><span> ];</span></span>
<span><span>          buildPhase</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>            gcc -o hello ./hello.c</span></span>
<span><span>          &#39;&#39;</span><span>;</span></span>
<span><span>          installPhase</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>            mkdir -p $out/bin</span></span>
<span><span>            cp hello $out/bin</span></span>
<span><span>          &#39;&#39;</span><span>;</span></span>
<span><span>        };</span></span>
<span><span>      }</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<p>We’re not quite ready. Remember when I said that we need to use version control
to help our flakes guarantee purity?</p>
<pre tabindex="0" data-language="bash"><code><span><span>git</span><span> init</span></span>
<span><span>git</span><span> add</span><span> *</span><span>.c</span><span> *</span><span>.nix</span></span>
<span><span>git</span><span> commit</span><span> -m</span><span> &#34;Initial commit&#34;</span></span></code></pre>
<p>Okay, finally we can build and run it with nix.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>nix run</span></span>
<span><span># OR</span></span>
<span><span>nix build &amp;&amp; ./result/bin/hello</span></span></code></pre>
<p>And we get a “hello world”!</p>
<p><code>pkgs.stdenv.mkDerivation</code> resolves to a string (that’s right, a piece of text).
It’s a path to a result in the nix store. <code>nix build</code> helps us out by making a
symlinked folder <code>./result</code> that directs to that directory in the nix store
(that is read only, because it’s in the nix store).</p>
<p>Okay, enough boring hello worlds in C nonsense. Here’s something fun — binary
runtime dependencies, and Python!</p>
<h3 id="a-simple-python-script">A simple Python Script</h3>
<p>Let’s consider a simple Python script that uses selenium to navigate to
<code>https://example.com</code>. Usually this would be a little annoying since there’s a
dependency on <code>chrome</code> and <code>chromedriver</code>, but we can bundle those things with
<code>nix</code> pretty easily.</p>
<p>Here’s our basic script that goes to <code>example.com</code> and yoinks the tab’s title,
printing it to <code>stdout</code>.</p>
<pre tabindex="0" data-language="py"><code><span><span>#./main.py</span></span>
<span></span>
<span><span>from</span><span> selenium </span><span>import</span><span> webdriver</span></span>
<span></span>
<span><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span><span>  driver </span><span>=</span><span> webdriver.Chrome()</span></span>
<span><span>  driver.get(</span><span>&#39;https://example.com&#39;</span><span>)</span></span>
<span><span>  print</span><span>(driver.title)</span></span>
<span><span>  driver.quit()</span></span></code></pre>
<p>Here we have one dependency, <code>selenium</code>, and two secret ones, <code>chromedriver</code>,
and <code>chromium</code>. Usually, we’d do something like</p>
<pre tabindex="0" data-language="cmd"><code><span><span>sudo apt</span><span>-get </span><span>install chromium</span><span>-</span><span>browser</span></span>
<span><span>sudo apt</span><span>-get </span><span>install chromium</span><span>-</span><span>chromedriver</span></span></code></pre>
<p>God forbid we’re on Windows, and it’s so much worse. We might have to add</p>
<pre tabindex="0" data-language="py"><code><span><span>options </span><span>=</span><span> webdriver.ChromeOptions()</span></span>
<span><span>options.binary_location </span><span>=</span><span> &#39;/usr/bin/chromium-browser&#39;</span></span></code></pre>
<p>So let’s package it with <code>nix</code>, which will work on ALL systems (including native
macos, and windows with wsl)…</p>
<p>I have a collection of
<a href="https://github.com/404Wolf/Project-templates">Project Templates</a> for various
different languages that use popular nix tools to create derivations for
projects. I’m using <a href="https://cookiecutter.readthedocs.io/">Cookiecutter</a>, which
is a bit of an aside, but lets you template entire projects using
<a href="https://jinja.palletsprojects.com/en/3.1.x/">Jinja</a>, so you can specify what a
“directory” of a, say, Python project would look like. We’re going to use my
python script template here, which you can get at that repo if you want, but
we’ll build up to it slowly.</p>
<h4 id="pkgswriteshellscriptbin">pkgs.writeShellScriptBin</h4>
<p><code>writeShellScriptBin</code> is a nice little helper function</p>
<p>It is so simple,
<a href="https://github.com/NixOS/nixpkgs/blob/36e813a7630ff1bde9f6baa82757fabfbeb6e95c/pkgs/build-support/trivial-builders/default.nix#L169">here’s the source code</a>…</p>
<pre tabindex="0" data-language="nix"><code><span><span>writeShellScriptBin</span><span> =</span><span> name: text:</span></span>
<span><span>  writeTextFile</span><span> {</span></span>
<span><span>    inherit</span><span> name</span><span>;</span></span>
<span><span>    executable</span><span> =</span><span> true</span><span>;</span></span>
<span><span>    destination</span><span> =</span><span> &#34;/bin/</span><span>${</span><span>name</span><span>}</span><span>&#34;</span><span>;</span></span>
<span><span>    text</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>      #!</span><span>${</span><span>runtimeShell</span><span>}</span></span>
<span><span>      ${</span><span>text</span><span>}</span></span>
<span><span>    &#39;&#39;</span><span>;</span></span>
<span><span>    checkPhase</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>      ${</span><span>stdenv</span><span>.</span><span>shellDryRun</span><span>}</span><span> &#34;$target&#34;</span></span>
<span><span>    &#39;&#39;</span><span>;</span></span>
<span><span>    meta</span><span>.</span><span>mainProgram</span><span> =</span><span> name</span><span>;</span></span>
<span><span>  }</span><span>;</span></span></code></pre>
<p>runtimeShell is just <code>/nix/store/blahblahShaHashblahblah/bin/bash</code>. It literally
just makes an executable bash script.</p>
<p>Okay, so let’s use it to package our <code>python</code> program…</p>
<p>We’ll first write a <code>bash</code> script, that’s roughly similar to what we want at the
end of the day, but without binary dependencies</p>
<pre tabindex="0" data-language="bash"><code><span><span>export</span><span> PATH</span><span>=</span><span>$PATH:${pkgs.chromedriver}/bin:${pkgs.ungoogled-chromium}/bin;</span></span>
<span><span>export</span><span> PYTHONPATH</span><span>=</span><span> ???</span></span>
<span><span>${python}/bin/python3 main.py</span></span></code></pre>
<p>Something like that. <code>nix</code> can handle the <code>python</code> packages for us. I’m not
going to go too far into that for now. Notice the <code>python3.withPackages</code>. Most
popular packages are already packaged with <code>nix</code>, and it’s not hard to package
ones that aren’t (usually, some require messy runtime deps).</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;Some python script&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:nixos/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (</span></span>
<span><span>      system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>        python</span><span> =</span><span> pkgs</span><span>.</span><span>python3</span><span>.</span><span>withPackages</span><span> (python-pkgs: [ </span><span>python-pkgs</span><span>.</span><span>selenium</span><span> ]);</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        packages</span><span> =</span><span> {</span></span>
<span><span>          default</span><span> =</span></span>
<span><span>            pkgs</span><span>.</span><span>writeShellScriptBin</span><span> &#34;main&#34;</span><span> /* bash */</span><span> # (treesitter directive)</span></span>
<span><span>              &#39;&#39;</span></span>
<span><span>                export PATH=$PATH:</span><span>${</span><span>pkgs</span><span>.</span><span>chromedriver</span><span>}</span><span>/bin:</span><span>${</span><span>pkgs</span><span>.</span><span>ungoogled-chromium</span><span>}</span><span>/bin;</span></span>
<span><span>                ${</span><span>python</span><span>}</span><span>/bin/python3 main.py</span></span>
<span><span>              &#39;&#39;</span><span>;</span></span>
<span><span>        };</span></span>
<span><span>      }</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<p>Remember to <code>git init</code>, <code>git add</code> and <code>git commit</code> (I didn’t say this before,
but commiting isn’t actually necessary, if you don’t <code>nix</code> will still build but
complain that your codebase is dirty. Okay, now we’re ready.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>nix run</span></span></code></pre>
<p>It works! Chromedriver should open up, the tab should load <code>example.com</code>, and
then it should grab the tab name and close.</p>
<p><img src="https://static.404wolf.com/https://static.404wolf.com/Post-20240713170649585.webp" alt="It works!"/></p>
<p>This still is slightly impure (although, I should note that <code>nix</code> guarantees
pure builds, not pure executions, so we may never be able to be 100% sure that
the program will <em>run</em> the same way) though because we’re appending to our
$PATH, which means that we’re expecting things to exist in our PATH that may
not. I’d like to avoid “generating” bash scripts, so instead I’m going to use a
utility called <code>wrapProgram</code> to set the PATH to whatever we have at build time
as our path, which has the necessary deps and is pure (because of nix), and only
run the python script with a bash script (to make it executable — we could use
a python shebang too).</p>
<p>Here’s what that would look like…</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;Python with Selenium example&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:nixos/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (</span></span>
<span><span>      system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>        python</span><span> =</span><span> pkgs</span><span>.</span><span>python3</span><span>.</span><span>withPackages</span><span> (python-pkgs: [ </span><span>python-pkgs</span><span>.</span><span>selenium</span><span> ]);</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        packages</span><span> =</span><span> rec</span><span> {</span></span>
<span><span>          default</span><span> =</span><span> pkgs</span><span>.</span><span>stdenv</span><span>.</span><span>mkDerivation</span><span> {</span></span>
<span><span>            name</span><span> =</span><span> &#34;main&#34;</span><span>;</span></span>
<span><span>            src</span><span> =</span><span> self</span><span>;</span></span>
<span><span>            dontUnpack</span><span> =</span><span> true</span><span>;</span></span>
<span><span>            buildInputs</span><span> =</span><span> [ </span><span>pkgs</span><span>.</span><span>makeWrapper</span><span> ];</span></span>
<span><span>            installPhase</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>              mkdir -p $out/bin</span></span>
<span><span>              cp </span><span>${</span><span>script</span><span>}</span><span>/bin/* $out/bin</span></span>
<span><span>            &#39;&#39;</span><span>;</span></span>
<span><span>            postFixup</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>              wrapProgram $out/bin/main \</span></span>
<span><span>                --set PATH $PATH:</span><span>${</span></span>
<span><span>                  pkgs</span><span>.</span><span>lib</span><span>.</span><span>makeBinPath</span><span> [</span></span>
<span><span>                    pkgs</span><span>.</span><span>chromedriver</span></span>
<span><span>                    pkgs</span><span>.</span><span>ungoogled-chromium</span></span>
<span><span>                  ]</span></span>
<span><span>                }</span></span>
<span><span>            &#39;&#39;</span><span>;</span></span>
<span><span>          };</span></span>
<span><span>          script</span><span> =</span><span> pkgs</span><span>.</span><span>writeShellScriptBin</span><span> &#34;main&#34;</span><span> &#34;</span><span>${</span><span>python</span><span>}</span><span>/bin/python3 main.py&#34;</span><span>;</span></span>
<span><span>        };</span></span>
<span><span>      }</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<h3 id="bash-scripts-with-any-binary">Bash scripts with ANY binary!</h3>
<p>If we’re okay with only kinda-pure stuff though, generating bash scripts is
really fun with nix. We can write a script using literally any dependency we
want.</p>
<p>I’ll provide a neat script I made to take screenshots of regions of my screen.</p>
<p>Usually it’d look like this…</p>
<pre tabindex="0" data-language="bash"><code><span><span>FILEPATH</span><span>=</span><span>/tmp/</span><span>$(</span><span>uuidgen</span><span>)</span></span>
<span><span>grim</span><span> -g</span><span> &#34;$(</span><span>$slurp</span><span>)&#34;</span><span> &#34;https://static.404wolf.com/</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>wl-copy</span><span> --type</span><span> &#34;text/uri-list&#34;</span><span> &#34;https://static.404wolf.com/file://</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>notify-send</span><span> &#34;Successfully saved screen capture!&#34;</span><span> &#34;The png has been saved to </span><span>$FILEPATH</span><span>&#34;</span></span></code></pre>
<p>But that means I’d need to add <code>grim</code> (a utility to select a region of your
screen on Wayland), <code>wl-copy</code> (a Wayland clipboard cli utility), and
<code>notify-send</code> (a notification daemon connector cli) to my global $PATH. That’s
gross, and not nixy at all. What if I want 50 more random binary dependencies?
If you say that’s a bad idea, it’s probably because you don’t want to have to
have people install so many things to their global <code>/usr/bin</code> to install it.</p>
<p>I really like this paradigm my friend Trevor showed me…</p>
<pre tabindex="0" data-language="nix"><code><span><span>partial-screenshot</span><span> =</span><span> pkgs</span><span>.</span><span>writeShellScriptBin</span><span> &#34;partial-screenshot.sh&#34;</span><span> &#39;&#39;</span></span>
<span><span>  slurp=</span><span>${</span><span>pkgs</span><span>.</span><span>slurp</span><span>}</span><span>/bin/slurp;</span></span>
<span><span>  grim=</span><span>${</span><span>pkgs</span><span>.</span><span>grim</span><span>}</span><span>/bin/grim;</span></span>
<span><span>  wl_copy=</span><span>${</span><span>pkgs</span><span>.</span><span>wl-clipboard</span><span>}</span><span>/bin/wl-copy;</span></span>
<span><span>  notify=</span><span>${</span><span>pkgs</span><span>.</span><span>libnotify</span><span>}</span><span>/bin/notify-send;</span></span>
<span><span>  ${</span><span>builtins</span><span>.</span><span>readFile</span><span> ./scripts/partial-screenshot.sh</span><span>}</span></span>
<span><span>&#39;&#39;</span><span>;</span></span></code></pre>
<p>The various binary dependencies will resolve to their <code>nix store</code> paths, and
since nix is lazily evaluated we can use ANY binary, and it will poof into
existence at the right store path at build time. <code>builtins.readFile</code> will then
inject our regular bash script that uses the stuff…</p>
<pre tabindex="0" data-language="bash"><code><span><span>FILEPATH</span><span>=</span><span>/tmp/</span><span>$(</span><span>uuidgen</span><span>)</span></span>
<span><span>$grim -g </span><span>&#34;$(</span><span>$slurp</span><span>)&#34;</span><span> &#34;https://static.404wolf.com/</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>$wl_copy --type </span><span>&#34;text/uri-list&#34;</span><span> &#34;https://static.404wolf.com/file://</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>$notify </span><span>&#34;Successfully saved screen capture!&#34;</span><span> &#34;The png has been saved to </span><span>$FILEPATH</span><span>&#34;</span></span></code></pre>
<p>And if we do a <code>nix build</code>, we’ll get</p>
<pre tabindex="0" data-language="bash"><code><span><span>#!/nix/store/agkxax48k35wdmkhmmija2i2sxg8i7ny-bash-5.2p26/bin/bash</span></span>
<span><span>slurp</span><span>=</span><span>/nix/store/hfii9xxi8vwmlq86vh2j9dl73zzy7s1w-slurp-1.5.0/bin/slurp</span><span>;</span></span>
<span><span>grim</span><span>=</span><span>/nix/store/jkv33a361c8nlgp2kcx1azncipxdn4nh-grim-1.4.1/bin/grim</span><span>;</span></span>
<span><span>wl_copy</span><span>=</span><span>/nix/store/18rwzxp6m29m8c5bxgpxci1ad1q4kl94-wl-clipboard-2.2.1/bin/wl-copy</span><span>;</span></span>
<span><span>notify</span><span>=</span><span>/nix/store/w141cbf1p9mcyp7vqv6a4fw4hm093qb5-libnotify-0.8.3/bin/notify-send</span><span>;</span></span>
<span><span>FILEPATH</span><span>=</span><span>/tmp/</span><span>$(</span><span>uuidgen</span><span>)</span></span>
<span><span>$grim -g </span><span>&#34;$(</span><span>$slurp</span><span>)&#34;</span><span> &#34;https://static.404wolf.com/</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>$wl_copy --type </span><span>&#34;text/uri-list&#34;</span><span> &#34;https://static.404wolf.com/file://</span><span>$FILEPATH</span><span>.png&#34;</span></span>
<span><span>$notify </span><span>&#34;Successfully saved screen capture!&#34;</span><span> &#34;The png has been saved to </span><span>$FILEPATH</span><span>&#34;</span></span></code></pre>
<p>A nice, executable script, with absolute references to packages that are NOT in
our path. This is one of my favorite nix things to do.</p>
<h2 id="reproducible-developer-environments">Reproducible Developer Environments</h2>
<p>Another nice thing <code>nix</code> can do is let you create developer environments very
easily. You use <code>pkgs.mkShell</code>, which creates a derivation (remember those
still?), and then enters the environment of the derivation.</p>
<p>You can specify <code>buildInputs</code> (although you should use <code>packages</code>) to add all
the things you’d want for developing the project.</p>
<pre tabindex="0" data-language="nix"><code><span><span>devShells</span><span> =</span><span> {</span></span>
<span><span>    default</span><span> =</span><span> pkgs</span><span>.</span><span>mkShell</span><span> {</span></span>
<span><span>      packages</span><span> =</span><span> [</span></span>
<span><span>        python</span></span>
<span><span>        pkgs</span><span>.</span><span>pyright</span></span>
<span><span>        pkgs</span><span>.</span><span>black</span></span>
<span><span>      ];</span></span>
<span><span>    };</span></span>
<span><span>  }</span><span>;</span></span></code></pre>
<p>And then you can plop it in your <code>flake.nix</code> (here’s the one we worked on
earlier)</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;{{ cookiecutter.description }}&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    flake-utils</span><span>.</span><span>url</span><span> =</span><span> &#34;github:numtide/flake-utils&#34;</span><span>;</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:nixos/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span></span>
<span><span>    {</span></span>
<span><span>      self</span><span>,</span></span>
<span><span>      nixpkgs</span><span>,</span></span>
<span><span>      flake-utils</span><span>,</span></span>
<span><span>    }:</span></span>
<span><span>    flake-utils</span><span>.</span><span>lib</span><span>.</span><span>eachDefaultSystem</span><span> (</span></span>
<span><span>      system:</span></span>
<span><span>      let</span></span>
<span><span>        pkgs</span><span> =</span><span> import</span><span> nixpkgs</span><span> { </span><span>inherit</span><span> system</span><span>; };</span></span>
<span><span>        python</span><span> =</span><span> pkgs</span><span>.</span><span>python3</span><span>.</span><span>withPackages</span><span> (python-pkgs: [ </span><span>python-pkgs</span><span>.</span><span>selenium</span><span> ]);</span></span>
<span><span>      in</span></span>
<span><span>      {</span></span>
<span><span>        packages</span><span> =</span><span> {}</span><span>#snip ...</span></span>
<span><span>        devShells</span><span> =</span><span> {</span></span>
<span><span>          default</span><span> =</span><span> pkgs</span><span>.</span><span>mkShell</span><span> {</span></span>
<span><span>            shellHook</span><span> =</span><span> &#39;&#39;</span></span>
<span><span>             # run when they enter</span></span>
<span><span>              echo &#34;Welcome to the dev environment!&#34;</span></span>
<span><span>            &#39;&#39;</span><span>;</span></span>
<span><span>            packages</span><span> =</span><span> [</span></span>
<span><span>              python</span></span>
<span><span>              pkgs</span><span>.</span><span>pyright</span></span>
<span><span>              pkgs</span><span>.</span><span>black</span></span>
<span><span>            ];</span></span>
<span><span>          };</span></span>
<span><span>        };</span></span>
<span><span>      }</span></span>
<span><span>    );</span></span>
<span><span>}</span></span></code></pre>
<p>This will give you access to what our output had access to — it updates our
$PYTHONPATH so that our LSP can see the dependencies, so we can get nice red
squiggles and all the good language server support. We can add any dependencies
we want, and even add shell hooks to set up the developer environment further.</p>
<p>To enter the <code>devshell</code>, you just do <code>nix develop</code>. You can also use <code>direnv</code>,
by <a href="https://direnv.net/">installing it</a>, and then creating a <code>.envrc</code> with the
contents</p>
<pre tabindex="0" data-language="bash"><code><span><span>use</span><span> flake</span></span></code></pre>
<p>And then typing <code>direnv allow</code>. It’s a neat utility made so that when you cd
into directories it automatically enters their respective devshell. This is
great because you don’t need your python and rust and android and javascript and
typescript bun node encryption cli tools and so much other crap in the global
path. It reduces conflicts, and all developers working on your project can have
the same environment.</p>
<p>When you’re ready for a real, pure build, you can then just slap in a
<code>packages.default</code>, and then you’re set.</p>
<h2 id="some-really-cool-builders">Some really cool builders</h2>
<p>There’s a lot of nice nix abstractions out there. This includes 3rd party
builders and builtin ones. Some cool ones are</p>
<ul>
<li><a href="https://github.com/nix-community/poetry2nix">Poetry2nix</a> to build poetry
python projects easily</li>
<li><a href="https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/maven.section.md">buildMavenPackage</a>
to build java projects</li>
<li><a href="https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md">buildNpmPackage</a>
for building maven packages</li>
<li><a href="https://nixos.wiki/wiki/Go">buildGoModule</a> for building go modules</li>
<li>And builders for most other languages too!</li>
</ul>
<p>One of the issues with packaging with nix is that the <code>sandbox</code> that the
building happens in must use <code>nix</code>’s primitive <code>fetchers</code> like <code>fetchURL</code> and
<code>fetchTAR</code> before unpacking, and there’s no internet during the build step. This
poses a challenge since you can’t do things like <code>pip install</code> during the build.
These fancy builders basically let you do the downloads and specify hashes
before the build, using the <code>hashes</code> to guarantee purity (a common <code>nix</code>
technique)</p>

<p>Here is a pure, complete, declarative, plug and play NixOS configuration to
describe an entire linux system.</p>
<pre tabindex="0" data-language="nix"><code><span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;An entire system configuration&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:NixOS/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span><span> { self</span><span>,</span><span> nixpkgs</span><span>,</span><span> ... </span><span>}@inputs: {</span></span>
<span><span>    nixosConfigurations</span><span>.</span><span>my-nixos</span><span> =</span><span> nixpkgs</span><span>.</span><span>lib</span><span>.</span><span>nixosSystem</span><span> {</span></span>
<span><span>      system</span><span> =</span><span> &#34;x86_64-linux&#34;</span><span>;</span></span>
<span><span>      modules</span><span> =</span><span> [];</span></span>
<span><span>    };</span></span>
<span><span>  };</span></span>
<span><span>}</span></span></code></pre>
<p>Just a plain old super super minimal linux setup. But this isn’t really useful.
There’s no shell, no packages, no users, nothing useful.</p>
<p>So let’s add some user and set up ssh…</p>
<pre tabindex="0" data-language="nix"><code><span><span># Credit (inspiration): https://nixos-and-flakes.thiscute.world/nixos-with-flakes/get-started-with-nixos</span></span>
<span><span>{</span></span>
<span><span>  description</span><span> =</span><span> &#34;An entire system configuration&#34;</span><span>;</span></span>
<span></span>
<span><span>  inputs</span><span> =</span><span> {</span></span>
<span><span>    nixpkgs</span><span>.</span><span>url</span><span> =</span><span> &#34;github:NixOS/nixpkgs/nixos-unstable&#34;</span><span>;</span></span>
<span><span>  };</span></span>
<span></span>
<span><span>  outputs</span><span> =</span><span> {</span></span>
<span><span>    self</span><span>,</span></span>
<span><span>    nixpkgs</span><span>,</span></span>
<span><span>    ...</span></span>
<span><span>  } @ inputs: {</span></span>
<span><span>    nixosConfigurations</span><span>.</span><span>my-nixos</span><span> =</span><span> nixpkgs</span><span>.</span><span>lib</span><span>.</span><span>nixosSystem</span><span> {</span></span>
<span><span>      system</span><span> =</span><span> &#34;x86_64-linux&#34;</span><span>;</span></span>
<span><span>      modules</span><span> =</span><span> [</span></span>
<span><span>        {</span></span>
<span><span>          users</span><span>.</span><span>users</span><span>.</span><span>wolf</span><span> =</span><span> {</span></span>
<span><span>            description</span><span> =</span><span> &#34;wolf&#34;</span><span>;</span></span>
<span><span>            openssh</span><span>.</span><span>authorizedKeys</span><span>.</span><span>keys</span><span> =</span><span> [</span></span>
<span><span>              &#34;ssh-ed25519 %3Csome-public-key%3E wolf@wolf-pc&#34;</span></span>
<span><span>            ];</span></span>
<span><span>            packages</span><span> =</span><span> with</span><span> pkgs</span><span>; [</span><span>firefox</span><span>];</span></span>
<span><span>          };</span></span>
<span><span>          services</span><span>.</span><span>openssh</span><span> =</span><span> {</span></span>
<span><span>            enable</span><span> =</span><span> true</span><span>;</span></span>
<span><span>            settings</span><span> =</span><span> {</span></span>
<span><span>              PermitRootLogin</span><span> =</span><span> &#34;no&#34;</span><span>;</span></span>
<span><span>              PasswordAuthentication</span><span> =</span><span> false</span><span>;</span></span>
<span><span>            };</span></span>
<span><span>            openFirewall</span><span> =</span><span> true</span><span>;</span></span>
<span><span>          };</span></span>
<span><span>        }</span></span>
<span><span>      ];</span></span>
<span><span>    };</span></span>
<span><span>  };</span></span>
<span><span>}</span></span></code></pre>

<p>There’s a million neat nix things that I come across each week. Here’s a list of
some cool ones that might be worth checking out…</p>
<h2 id="nix-dev-containers-on-windows-wnix-wsl">Nix Dev Containers on Windows w/Nix WSL</h2>
<p>Thanks to this <a href="https://github.com/nix-community/NixOS-WSL">Nix on WSL</a> you can
set up developer containers with nix devshells, defined with flakes, on Windows.
You can also configure an entire NixOS configuration on Windows. This is much
better than using docker dev containers!</p>

<p>Thanks to Paolo Holinski for inspiration from a Recurse Center nix presentation
and Trevor Nichols for getting me into nix in the first place.</p>  </div> </astro-slot></div></div>
  </body>
</html>
