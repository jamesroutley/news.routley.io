<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/cards/pl-small">Original</a>
    <h1>Small Programs and Languages</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Small programs are interesting. But I’m also interested in small programming
languages.</p>
<p><em>Generally</em> speaking, the smaller the language, the less expressive it is.</p>
<p>One of the most well-known, least expressive languages is assembly.</p>
<p>Assembly languages are <em>very</em> syntactically and conceptually simple.  There’s
not much language at all: it’s mostly a rigid sequence of opcode mnemonics.
Even with macros, writing in assembly is mostly about understanding the puzzle
of a particular CPU’s instruction set architecture, or ISA. (You can prove this
by comparing the syntax of assembly for CISC and RISC processors. The puzzle is
totally different, while the language remains practically unchanged.)</p>
<p>An honorable mention must be made here for <a href="https://ratfactor.com/snobol/">SNOBOL</a>, which is
kind of like assembly language both for the rigid syntactic reasons listed above and
<em>also</em> because it presents a similar control flow challenge. Like a CPU, it
only understands jumps and call/return. (In every other way, SNOBOL is
wildly different, being a string matching and replacing language. It’s weird
and fun and highly effective.)</p>
<p>Moving on to syntactically tiny &#34;high-level&#34; languages, these three are
brilliant:</p>
<div>
<ul>
<li>
<p><strong>Forths</strong> win just about any &#34;smallness&#34; contest. The only syntactical construct
is the space character. Forths are mind-bendingly flexible and powerful in a way that is downright disturbing.</p>
</li>
<li>
<p><strong>Lisps</strong>, (especially Scheme?), have small core languages with very simple syntax and enormous expressive power and flexibility.</p>
</li>
<li>
<p><strong>Tcl</strong> deserves to be mentioned with Forth and Lisp. Tcl is wild because <em>everything</em> is a string in a way that is hard to appreciate at first. You can construct your own language in Tcl just as you can with Forth or Lisp.</p>
</li>
</ul>
</div>
<p>Forth, Lisp, and Tcl only require you to understand a few core ideas and give
you limitless power in return. You could fit the syntactic core of these
languages on an index card or less.</p>
<p>And yet, to wield these tools effectively requires a massive shift in thinking
if you’re used to &#34;normal&#34; Algol-like procedural languages.</p>
<p>So how about something that is both small and simple and doesn’t require a
blood sacrifice?</p>
<p>I think the Lua programming language fits the bill. Check out how small the
core language is:</p>

<p>I’ve got the printed book version of this document and it’s a thin book! The
Lua language is covered in the beginning and it is just 27 pages. <strong>27
pages!</strong> I have game manuals longer than that.</p>
<p>The C language is pretty small. I don’t think it’s super easy to program
effectively and safely with C, but there’s no denying it’s compact and
pretty expressive for its size.</p>
<p>Newcomer Zig is C-like. But I think it’s actually quite large and you need to
know a lot of it to use it effectively.  (I’m also a fan of Zig and think it’s
<a href="https://ratfactor.com/zig/hard">totally worth it</a>. The size is there for a reason.)</p>
<p>JavaScript has a core language that is quite small. Probably on par with Lua,
actually. Functions, arrays, and objects (used as dictionaries) are pretty much
all the JS I use and I like it that way!</p>
<p>As with the natural human languages, the trade-off with a bigger programming
language is, hopefully, greater expressivity.</p>
<p>Small or expressive. Which way should you lean?</p>
<p>In a wonderful talk by
<a href="https://en.wikipedia.org/wiki/David_Ungar">David Ungar</a> (wikipedia.org)
titled <em>Self and Self: Whys and Wherefores</em>, he laments the mistake
of Self’s multiple inheritance:</p>
<div>
<blockquote>
<p>&#34;It’s far better to make a system a little too simple so a person has to write extra stuff, even write it twice with a comment that says, &#39;Look over here,&#39; than to have a system that acts in strange ways and nobody can understand why. So, simplicity trumps expressiveness.&#34;</p>
</blockquote>
</div>
<p>Got that? Here’s the bullet from the slide to help you remember:</p>
<div>
<p><img src="https://ratfactor.com/cards/images/david_ungar_self_and_self2.jpg" alt="snippet of a slide that reads Simplicity trumps expressiveness"/>
</p>
</div>
<p>I think small languages can <em>also</em> be fairly expressive, but only with very,
very careful design. Recall Forth, Lisp, and Tcl.</p>
<p><strong>Microworlds:</strong> The idea of small, self-contained, learnable programming
environments <em>also</em> has a David Ungar connection I discovered while watching
his talk.  See &#34;ARK&#34; on my <a href="https://ratfactor.com/cards/microworlds">Microworlds</a> card. (Smith and Ungar
co-created the <a href="https://selflanguage.org/">Self language</a> (selflanguage.org),
which is a notable milestone in programming and still under active development
to this day.)</p>
<p><strong>Libraries:</strong>
Another easily overlooked aspect of a programming language’s apparent size is
its &#34;standard library&#34; of functions, data structures, and methods.</p>
<p>I think function libraries are subject to the exact same size versus
expressiveness challenge.</p>
<p>For example, learning the
<a href="https://ramdajs.com/">Ramda</a> (ramdajs.com)
functional programming library for JavaScript was very much like learning a new
programming language and I never managed to learn all of it. The composability
of Ramda and the consistency of its curried functions was extremely eye-opening
to me. <strong>A little bit of Ramda goes a long way!</strong></p>
<p><strong>The feels:</strong> Concision in our tools has a certain quality that goes beyond
utility. Little things just <em>spark joy</em>, you know?</p>
<p>Why are small things so delightful?</p>
</div></div>
  </body>
</html>
