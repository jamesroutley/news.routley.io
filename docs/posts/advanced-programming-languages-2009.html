<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt.might.net/articles/best-programming-languages/">Original</a>
    <h1>Advanced Programming Languages (2009)</h1>
    
    <div id="readability-page-1" class="page"><div id="abstract-container">
<div id="abstract-content">

 

 

 
  <p>Students often ask for a recommendation on what language they
  should learn next.

  If you&#39;re looking for a job in industry, my reply is to learn
  whatever is hot right now:

  C++, Java and C#--and probably Python, Ruby, PHP and Perl too. </p>


  <p> If, on the other hand, you&#39;re interested in enlightenment,
  academic research or a start-up, the criterion by which you should
  choose your next language is not employability, but expressiveness.

  In academic research and in entrepreneurship, you need to multiply
  your effectiveness as a programmer, and since you (probably) won&#39;t
  be working with an entrenched code base, you are free to use
  whatever language best suits the task at hand. </p>


  <p> Here you&#39;ll find descriptions of four good languages to
  learn--Haskell, Scala, ML and Scheme--with a list of my favorite
  features for each, and pointers on where to learn more.  </p>


  <p> Of course, this short list is by no means exhaustive.

  There are many uncommon languages that excel at niches.

  To name just a few more, there&#39;s also D for systems programming;

  Erlang or Clojure for concurrency; and

  Datalog for constraint programming.

  Then there are languages like Smalltalk--alternate yet fully capable
  universes that branched off from mainstream computing long ago.  </p>


  <p> I encourage my students to never stop learning niche languages.

  They expand your modes of thinking,
  the kinds of problems you solve quickly and
  your appreciation for the meaning of computation.</p>


  

<!--  LocalWords:  Clojure
 -->


  
</div> <!-- /#content -->
</div><div id="content-container">
<div id="article-content">

  <h2>Some advanced languages</h2>

  <ul>
    <li><a href="#haskell">Haskell</a>.</li>
    <li><a href="#scala">Scala</a>.</li>
    <li><a href="#ml">Standard ML and OCaml</a>.</li>    
    <li><a href="#scheme">Scheme</a>.</li>    
  </ul>



  <h2>Haskell</h2>

  <p>

  <a href="http://www.haskell.org/">Haskell</a> excels as a
  language for writing a compiler, an interpreter or a static
  analyzer.

  I don&#39;t do a lot of artificial intelligence, natural-language
  processing or machine-learning research, but if I did, Haskell would be my first pick there
  too.  (<a href="#scheme">Scheme</a> would be a strong second.)

  Haskell is the only widely used pure, lazy
  functional programming language.
  </p>


  <p> Like Standard ML and OCaml, Haskell uses an extension of <a href="http://en.wikipedia.org/wiki/Type_inference">Hindley-Milner-style</a>
  type inference, which means that the programmer doesn&#39;t have to
  write down (most) types, because the compiler can infer them.

  It has been my experience that it is difficult to get a bug through
  the Hindley-Milner type system.

  In fact, experienced programmers become adept at encoding
  correctness constraints directly into the Haskell type system.

  A common remark after programming in Haskell (or ML) for the first
  time is that once the program compiles, it&#39;s almost certainly
  correct.  </p>

  
  <p>
  As a pure language, side effects (mutations of variables or data
  structures and I/O) are prohibited in the language proper.

  This has forced the language&#39;s designers to think seriously about
  how to provide such functionality.

  Their answer, <a href="http://en.wikipedia.org/wiki/Monads_in_functional_programming">monads</a>,
  enables one to perform side effects and I/O inside a safely
  constrained framework.

  Naturally, Haskell lets users define their own monads, and now the
  programmer has access to monads for continuations, transducers,
  exceptions, logic programming and more.  </p>
  
  <p>
  Aside from being pure, Haskell is also lazy.

  That is, an expression in Haskell is not evaluated until (and
  unless) its result is required to make forward computational
  progress.

  Some have argued that the promised efficiency gains from laziness
  haven&#39;t materialized, but that&#39;s not of concern for me.

  I appreciate laziness for the increase in <em>expressiveness</em>.

  In Haskell, it is trivial to describe data structures of infinite
  extent.

  Where other languages permit mutually recursive functions, Haskell
  permits mutually recursive values.
  </p>


  <p> More pragmatically, I have found laziness useful in encoding option
  types, where utilizing the empty case should always nuke the
  program.

  In Haskell, you can avoid creating an option type and instead use
  <code>error</code> to produce the empty value.

  Because of laziness, every type in Haskell automatically has two
  additional values: non-termination and error.

  Used well, this eliminates much tedious pattern matching.
  </p>

  <p>
  My favorite feature of Haskell is type classes.

  Haskell&#39;s type system allows the compiler to infer the correct code
  to run based on its type context, even when that type context is
  <em>also</em> inferred.

  The example of type classes that got me excited was
  bounded lattices.

  A <a href="http://en.wikipedia.org/wiki/Lattice_(order)">bounded
  lattice</a> is a mathematical structure that has a least element
  (<code>bot</code>), a greatest element (<code>top</code>), a
  partially ordered less than relation (<code>&lt;:</code>), a join
  operation (<code>join</code>) and a meet operation
  (<code>meet</code>).
  </p>

  <p>
  In Haskell, one can define a bounded lattice as a type class:

  </p><pre>  class Lattice a where
   top  :: a
   bot  :: a
   (&lt;:) :: a -&gt; a -&gt; Bool
   join :: a -&gt; a -&gt; a
   meet :: a -&gt; a -&gt; a
  </pre><p>

  This says that if type <code>a</code> is a <code>Lattice</code>,
  then <code>a</code> supports the expected operations.
  </p>

  <p> What I really love about Haskell is that it lets the programmer
  define conditional instances of a class; for example:

  </p><pre>  instance (Ord k, Lattice a) =&gt; Lattice (Map k a) where
   bot = Map.empty
   top = error $ &#34;Cannot be represented.&#34;
   f &lt;: g = Map.isSubmapOfBy (&lt;:) f g
   f `join` g = Map.unionWith join f g
   f `meet` g = Map.intersectionWith meet f g
  </pre><p>

  This rule says that if the type <code>k</code> is an instance
  of an order (class <code>Ord</code>) and the type
  <code>a</code> is an instance of a lattice, then a map from
  <code>k</code> to <code>a</code> is also an instance of a lattice.
  </p>


  <p> As another example, you can easily turn the Cartesian product of
  two lattices into a lattice:

  </p><pre>  instance (Lattice a, Lattice b) =&gt; Lattice (a,b) where
   bot = (bot,bot)
   top = (top,top)
   (a1,b1) &lt;: (a2,b2) = (a1 &lt;: a2) ||
                      (a1 == a2 &amp;&amp; b1 &lt;: b2) 
   (a1,b1) `join` (a2,b2) = (a1 `join` a2, b1 `join` b2)
   (a1,b1) `meet` (a2,b2) = (a1 `meet` a2, b1 `meet` b2) 
  </pre>
  


  <p> It&#39;s easy to make the &#34;natural&#34; lifting of the lattice
  operations, relations and elements to almost any data structure.

  The end result is that if you use the expression <code>bot</code> or
  the relation <code>&lt;:</code> anywhere in your code, Haskell can
  infer, at compile-time, their &#34;appropriate&#34; meaning based on the type of the
  expression (which it can also infer).
  </p>


  <p> The ML languages have functors to play the role of type classes,
  but they lack the <em>ad hoc</em> polymorphism support
  of Haskell&#39;s type classes.

  Having spent a considerable amount of time programming in the MLs
  and in Haskell, the practical ramifications of inference on
  expressiveness cannot be overstated.  </p>


  <h3>Favorite features</h3>
  <ul>
    <li><a href="http://en.wikipedia.org/wiki/Type_class">Type classes</a>.</li>
    <li><a href="http://haskell.org/ghc/docs/latest/html/libraries/">A rich library</a>.</li>
    <li><a href="http://www.haskell.org/all_about_monads/html/index.html">Monads</a>.</li>
    <li><a href="http://en.wikipedia.org/wiki/List_comprehension">List comprehensions</a>.</li>
    <li>Compact, readable, whitespace-guided syntax.</li>  
  </ul>

  

  <h3>Resources</h3>
  <ul>
    <li><a href="http://www.haskell.org/">haskell.org</a>.  Downloads, documentation, tutorials and more.</li>
    
    <li><a href="http://www.haskell.org/ghc/">The Glasgow Haskell Compiler (GHC)</a>.
    GHC provides robust support for Haskell on multiple platforms.
    </li>


    <li>
     <a href="http://www.cs.tufts.edu/~kfisher/teaching.html">Kathleen Fisher&#39;s slides</a> for her class at Stanford are
     a good introduction to Haskell.
    </li>

    <li> <a href="http://book.realworldhaskell.org/read/">Real World
     Haskell</a>.
    As the title implies,
     this book pays attention to using Haskell for real
     applications (<em>e.g.</em>, web programming), instead of just for compilers, interpreters and
     program analyzers.

     <p><a href="http://www.amazon.com/gp/product/0596514980?ie=UTF8&amp;tag=mmamzn06-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596514980"><img src="https://matt.might.net/articles/best-programming-languages/images/51xQwhNrj6L._SL160_.jpg"/></a><img src="http://www.assoc-amazon.com/e/ir?t=aboutmmamzn06-20&amp;l=as2&amp;o=1&amp;a=0596514980" width="1" height="1" alt=""/>
     </p>

    </li>

  </ul>






  <h2>Scala</h2>

  <p>

  <a href="http://www.scala-lang.com/">Scala</a> 
  is a rugged, expressive, strictly superior replacement for
  Java.

  Scala is the programming language I use for tasks like writing
  web servers or IRC clients.
  
  In contrast to <a href="#ml">OCaml</a>, which was a functional language with an
  object-oriented system grafted to it, Scala feels more like a
  true hybrid.

  That is, object-oriented programmers should be able to start using
  Scala immediately, picking up the functional parts only as they choose
  to. </p>



  <p>

  I learned of Scala from <a href="http://icwww.epfl.ch/~odersky/">Martin Odersky</a>&#39;s invited
  talk at POPL 2006.

  At the time, I saw functional programming as strictly
  superior to object-oriented programming, so I didn&#39;t see a need for
  a language that fused functional and object-oriented programming.

  (That was probably because all I wrote back then were compilers,
  interpreters and static analyzers.)

  </p>

  
  
  <p>

  The need for Scala didn&#39;t become apparent to me until I wrote a
  concurrent HTTPD from scratch to support long-polled AJAX for <a href="http://www.yaplet.com/">yaplet</a>.

  In order to get multicore support, I wrote the first
  version in Java.

  I don&#39;t think Java is all that bad, and I can enjoy
  well-done object-oriented programming.

  As a functional programmer, however, the lack of terse support for 
  functional programming features (like higher-order functions) grates
  on me.

  So, I gave Scala a chance.
  
  </p>

  <p>

  Scala runs on the JVM, so I could gradually port my
  existing project into Scala.

  It also means that Scala, in addition to its own rather <a href="http://www.scala-lang.org/node/216">large library</a>, has
  access to the entire Java library as well.

  This means you can get real work done in Scala.
  </p>


  <p>

  As I started using Scala, I became impressed by how tightly the
  functional and object-oriented worlds had been blended.

  In particular, Scala has a powerful case class/pattern-matching
  system that addressed annoyances lingering from my experiences with
  Standard ML, OCaml and Haskell: the programmer can decide which
  fields of an object should be matchable (as opposed to being forced
  to match on all of them), and variable-arity arguments are
  permitted.

  In fact, Scala even allows programmer-defined patterns.
  </p>

  <p>
  I write a lot of functions that operate on abstract syntax nodes,
  so it&#39;s nice to match on only the syntactic children,
  while ignoring fields for annotations or source location.
  </p>

  <p>
  The case class system lets one split the definition of an algebraic
  data type across multiple files or across multiple parts of the same file.


  Scala also supports well-defined multiple inheritance through class-like
  constructs called traits.

  And, Scala allows operator overloading; even function application
  and collection update can be overloaded.

  Used well, this tends to make my Scala programs more intuitive and concise.
  </p>


  <p> One feature that turns out to save a lot of code, in the same
  way that type classes save code in Haskell, is implicits.

  You can imagine implicits as an API for the error-recovery phase of the type-checker.

  In short, when the type checker needs an X but got a Y, it will
  check to see if there&#39;s a function marked implicit in scope that
  converts Y into X; if it finds one, it automatically applies the
  implicit function to repair the type error.
  </p>

  <p>
  Implicits make it possible to look like you&#39;re extending the
  functionality of a type for a limited scope.

  For example, suppose you want to &#34;add&#34; an <code>escapeHTML()</code> method to type <code>String</code>.

  You can&#39;t modify the definition of <code>String</code>, but with
  implicits, you can make it so that when type-checking fails on
  <code>myString.escapeHTML()</code>, it will look for an implicit function in
  scope that can convert a <code>String</code> object into a type that
  supports the <code>escapeHTML()</code> method.  </p>

  <p> Implicits also allow cleaner domain-specific embedded
  languages (DSELs) in Scala, since they allow you to transparently
  map Scala literals (like <code>3</code> or <code>&#34;while&#34;</code>) into literals in the DSEL.</p>


  <h3>Favorite features</h3>
  <ul>
    <li><a href="http://java.sun.com/docs/books/jvms/">JVM</a> support.</li>
    <li>Intelligent <a href="http://en.wikipedia.org/wiki/Operator_overloading">operator overloading</a>.</li>
    <li>Extensive library.</li>        
    <li>Case classes/pattern matching.</li>
    <li>Extensible pattern matching.</li>
    <li>Multiple inheritance via traits.</li> 
    <li>Rich, flexible object constructors.</li>
    <li>Implicit type conversions.</li>
    <li><a href="http://en.wikipedia.org/wiki/Lazy_evaluation">Lazy fields and arguments</a>.</li> 
  </ul>



  <h3>Related blog articles</h3>
  <ul>

    <li>
     <a href="https://matt.might.net/articles/learning-scala-in-small-bites/">Scala in small bites</a>.
    </li>

    <li>
     <a href="https://matt.might.net/articles/implementation-of-lazy-list-streams-in-scala/">Example of laziness in Scala (with streams)</a>.
    </li>

    <li>
     <a href="https://matt.might.net/articles/implementation-of-immutable-purely-functional-okasaki-red-black-tree-maps-in-scala/">Okasaki Red-Black trees in Scala</a>.
    </li>

    <li>
     <a href="https://matt.might.net/articles/nonblocking-lexing-toolkit-based-on-regex-derivatives/">A DSEL for non-blocking lexers in Scala</a>.
    </li>

    <li>
     <a href="https://matt.might.net/articles/pipelined-nonblocking-extensible-web-server-with-coroutines/">A non-blocking web server in Scala, based on coroutines</a>.
    </li>

  </ul>

  

  <h3>Resources</h3>
  <ul>


    <li>

    <a href="http://www.scala-lang.org/">
    scala-lang.org</a>.  Downloads, documentation, tutorials and more.
    </li>

    
    <li>

    <a href="http://www.amazon.com/gp/product/0981531601?ie=UTF8&amp;tag=mmamzn06-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0981531601">Programming in Scala</a><img src="http://www.assoc-amazon.com/e/ir?t=mmamzn06-20&amp;l=as2&amp;o=1&amp;a=0981531601" width="1" height="1" alt=""/>

    by Martin Odersky (creator of Scala), Lex Spoon, and Bill Venners is great as both an introduction and a reference.

    </li>
  </ul>

  

  <h2>Standard ML and OCaml</h2>

  <p> The ML family is a sweet spot in the language-design
  space: strict, side-effectable and Hindley-Milner type-inferred.

  This makes these languages practical for real-world projects that need high
  performance <em>and</em> stronger guarantees of correctness.

  The ML family has gained traction with aerospace engineers (for its
  support of bug-free code) and with programmers in the financial
  industry (for the same reason).

  Standard ML was the first functional language I learned well, so I still
  remember being shocked by its expressiveness.
  </p>

  
  
  <p>
  Today, OCaml seems to be the popular ML to learn, but there is at
  least one convincing argument in SML&#39;s favor: <a href="http://www.mlton.org/">MLton</a>.

  MLton really delivers on the thesis that functional languages offer
  the best opportunities at optimization.

  As a whole-program optimizing compiler, I&#39;ve yet to see another
  compiler match its performance.

  I once created OpenGL bindings for MLton to toy around with 3D
  graphics, and the resulting program ran faster than the C++-based
  model I had used as a reference, with just 10% of the code.
  </p>

  <p>
  The functor system in SML, while more verbose than Haskell&#39;s type
  class system, is more flexible.

  Once you instantiate a type class <code>T</code> for a kind/type
  <code>k</code> in Haskell, you can&#39;t instantiate that type class
  again for that kind/type.

  With functors, each instance gets its own name, so you can have
  multiple instances of a given functor for the same type.

  It&#39;s rarely been the case that I needed such expressiveness, but
  it has been nice in those cases where I have.  </p>


  
  <p>

  The other modern branch on the ML family tree, OCaml, is good to know
  because there is a large community invested in it, which means
  that there are a lot of libraries available.

  The OCaml tool-chain is also rich, with interpreters, optimizing
  compilers and byte-code compilers available to the developer.
  </p>

  <p> Because the ML languages are more expressive than all the
  mainstream languages, but they still permit side effects, they make a nice stop on the way to learning Haskell.

  In Haskell, programmers not yet well versed in functional program
  design may find they repeatedly code themselves into a corner, where
  they don&#39;t have access to the monad that they need.

  The MLs keep the side effects &#34;escape hatch&#34; open to patch over
  incomplete design, which prevents projects from coming to a sudden,
  unexpected &#34;refactor-or-abort&#34; decision point.

  One useful measure of a language is how well it tolerates a bad or
  incomplete design for the software system, since design is something
  that  inevitably changes as a program evolves.

  In this regard, the MLs still have the upper hand over Haskell.
  </p>


  <h3>Favorite features</h3>
  <ul>
    <li>Flex records. (SML only)</li>
    <li>Pattern matching.</li>
    <li><a href="http://en.wikipedia.org/wiki/Standard_ML#Module_System">Structures and functors</a>.</li> 
  </ul>


  <h3>Resources</h3>
  




  


  <h2>Scheme</h2>

  <p> Scheme is a language with a pure core
  (λ-calculus and the theory of lists) and a design mandate to
  maximize freedom of expression.  It&#39;s untyped, which makes it ideal
  for web-based programming and rapid prototyping.
   
  Given its Lisp heritage, Scheme is a natural fit for artificial intelligence.
  </p>

  <p> With its support for arbitrary-precision numerics, Scheme is
  also my first choice for implementing
  cryptographic algorithms.

  [For examples, see my short implementations of

  <a href="https://matt.might.net/articles/implementation-of-rsa-public-key-cryptography-algorithm-in-scheme-dialect-of-lisp/">RSA</a> and the

  <a href="https://matt.might.net/articles/implementation-of-fermat-and-solovay-strassen-primality-tests-for-rsa-key-generation-in-scheme-dialect-of-lisp/">Fermat and Solovay-Strassen primality tests</a> in Scheme.]
  </p>

  
  <p>
  By far, the most compelling reason to use Scheme is its macro system.
  
  All of the macro systems available for Scheme, including the
  standard <code>syntax-rules</code> and <code>syntax-case</code>
  systems, are Turing-equivalent.
   </p>

  <p>
  Consequently, the programmer can
  reconfigure Scheme to reduce the impedance mismatch between the
  language and the task at hand.

  Combined with support for first-class continuations, it is even
  possible to embed alternate programming paradigms (like logic
  programming).  </p>

  <p>
  For example, in the code:

  </p><pre>  (let ((x (amb 3 4 5))
        (y (amb 6 7 8 )))
    (assert (= (+ x y) 12))
    (display x)
    (display y))  </pre><p>

  it is possible to write an <code>amb</code> macro that &#34;chooses&#34; the
  right argument to make a subsequent <code>assert</code> statement be
  true.  (This program prints 4 and then 8.)
  
  </p>

  <p> In Scheme, during any point in the computation, the program can
  capture the current continuation as a procedure: invoking this
  procedure returns the program to the evaluation context that existed
  when the continuation was captured.

  Programming with continuations feels like traveling back and forth
  in time and shifting between parallel universes.  </p>
  
  <p> Ultimately, Scheme is so minimal and extensible that there&#39;s not
  a whole lot to say about it, except that Scheme allows the
  programmer to extract from the language whatever the programmer is
  willing to put into it.</p>


  
<h3>Favorite features</h3>

  <ul>
    <li><a href="http://en.wikipedia.org/wiki/S-expression">S-Expressions</a> as syntax and data.</li>
    <li><a href="http://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macros</a>.</li>
    <li><a href="http://en.wikipedia.org/wiki/Continuation">Continuations</a>.</li>
    <li><a href="http://en.wikipedia.org/wiki/Higher-order_function">Higher-order functions</a>.</li>
  </ul>


  <h3>Related blog articles</h3>

  <ul>
    <li>
    <a href="https://matt.might.net/articles/implementing-a-programming-language/">Implement a programming language in 7 lines of Scheme</a>.
    </li>
    
    <li>
    <a href="https://matt.might.net/articles/compiling-scheme-to-c/">Compiling Scheme to C with flat closure conversion</a>.
    </li>

    <li>
    <a href="https://matt.might.net/articles/compiling-to-java/">Compiling Scheme directly to Java</a>.
    </li>

    <li>
    <a href="https://matt.might.net/articles/metacircular-evaluation-and-first-class-run-time-macros/">Meta-circular evaluation and first-class macros</a>.
    </li>        

    <li>
    <a href="https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">Programming with continuations</a>.
    </li>
    
    <li>
    <a href="https://matt.might.net/articles/church-encodings-demo-in-scheme/">Church encodings in Scheme</a>.
    </li>


    <li>
    <a href="https://matt.might.net/articles/implementation-of-scheme-vector-struct-in-syntax-rules/">Fast yet reflective vector structs from macro-defining macros</a>.
    </li>    
    
    <li>
    <a href="https://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/">Regular expression matching from derivatives</a>.
    </li>


  </ul>
  
  
<h3>Resources</h3>

  <ul>

    <li>

    <a href="http://www.racket-lang.org/">Racket</a> (formerly PLT
    Scheme) is a &#34;batteries included&#34; Scheme system, including a
    battle-tested IDE, a compiler and an interpreter.

    More importantly, the Racket library is immense: it has a module
    that adds a type system to the language; it has a module that
    adds pattern-matching; it has a module for OpenGL programming; and
    it has a module for continuation-based web servers.

    In Racket, there&#39;s already a module for just about everything.</li>


    <li>
    The best book I&#39;ve seen on Racket --
<a href="http://www.amazon.com/gp/product/1593274912/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1593274912&amp;linkCode=as2&amp;tag=aboutmmamzn06-20">Realm of Racket</a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=aboutmmamzn06-20&amp;l=as2&amp;o=1&amp;a=1593274912" width="1" height="1" alt=""/>
    -- introduces the features of the language through game programming:

    <p><a href="http://www.amazon.com/gp/product/1593274912/ref=as_li_ss_il?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1593274912&amp;linkCode=as2&amp;tag=mmamzn06-20"><img src="http://ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=1593274912&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=US&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=mmamzn06-20"/></a><img src="http://ir-na.amazon-adsystem.com/e/ir?t=mmamzn06-20&amp;l=as2&amp;o=1&amp;a=1593274912" width="1" height="1" alt=""/>

    </p>


    </li>
    

    <li><a href="http://www.call-with-current-continuation.org/">Chicken
    scheme</a> is a hacker-friendly implementation of Scheme.</li>

    <li><a href="http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page">Gambit Scheme</a>
    is popular for lower-level programming in Scheme, including iPhone and iPad programming.
    </li>
    

    <li><a href="http://www.r6rs.org/">R6RS</a>. The current Scheme standard.</li>

    <li>I recommend all Scheme programmers keep a copy of <a href="http://research.sun.com/people/mybio.php?uid=25706">Guy
    Steele</a>&#39;s

    <a href="http://www.amazon.com/gp/product/1555580416?ie=UTF8&amp;tag=mmamzn06-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1555580416">Common LISP: The Language</a><img src="http://www.assoc-amazon.com/e/ir?t=mmamzn06-20&amp;l=as2&amp;o=1&amp;a=1555580416" width="1" height="1" alt=""/>

    around.

    After Guy Steele developed Scheme, which is a 
    minimalist expression of the λ-calculus as a programming
    language, he designed Common Lisp, which is a
    maximalist expression of the λ-calculus as a programming
    language.

    <p><a href="http://www.amazon.com/gp/product/1555580416?ie=UTF8&amp;tag=mmamzn06-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1555580416"><img src="https://matt.might.net/articles/best-programming-languages/images/41VJS8YPYML._SL160_.jpg"/></a><img src="http://www.assoc-amazon.com/e/ir?t=aboutmmamzn06-20&amp;l=as2&amp;o=1&amp;a=1555580416" width="1" height="1" alt=""/>
    </p>

    Over the years, many of Common Lisp&#39;s features have been
    implemented as macros and libraries for Scheme.

    Whenever I find Scheme lacking, I look to see how Common Lisp did
    it, and then I roll a quick version of that for Scheme.

    The Common Lisp Object System (CLOS) is a beautiful example of
    object-oriented programming language design.  </li>

    
    <li>

<a href="http://www.amazon.com/gp/product/0070004846?ie=UTF8&amp;tag=mmamzn06-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0070004846">Structure and Interpretation of Computer Programs</a><img src="http://www.assoc-amazon.com/e/ir?t=mmamzn06-20&amp;l=as2&amp;o=1&amp;a=0070004846" width="1" height="1" alt=""/>

    is a classic.

    Until recently, this was the textbook for freshman computer
    science at MIT.

    It teaches computer science by teaching students how to implement
    interpreters. </li>

    
  </ul>




<!-- Smalltalk -->

<!-- JavaScript -->
  

<!--  LocalWords:  OCaml Hindley-Milner-style Hindley-Milner haskell.org yaplet
 -->
<!--  LocalWords:  Odersky variable-arity implicits Venners side-effectable amb
 -->
<!--  LocalWords:  MLton refactor-or-abort smlnj.org Solovay-Strassen Abelson
 -->
<!--  LocalWords:  capturable Sussman's Okasaki lexers
 -->
  

 <hr/>

 


  
</div> <!-- /#content -->
</div></div>
  </body>
</html>
