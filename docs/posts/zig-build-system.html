<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.liujiacai.net/2023/04/13/zig-build-system/">Original</a>
    <h1>Zig build system</h1>
    
    <div id="readability-page-1" class="page"><div id="outline-text-headline-1"><p>When you initialize project scaffold via <code>zig init-exe</code>, it will generate <code>build.zig</code> with detailed comments to help you understand what it does. The most frequent used commands are:</p><ul><li><code>zig build</code>, default step <code>install</code> is invoked</li><li><code>zig build test</code>, <code>test</code> step is invoked</li></ul><p>Here we introduce the most important concept in Zig&#39;s build system: <code>step</code>. A step describe one task, such as compile binary, run the test.</p><p><a href="https://github.com/ziglang/zig/blob/602029bb2fb78048e46136784e717b57b8de8f2c/lib/std/Build/Step.zig">Step.zig</a> defines <code>MakeFn</code> as step&#39;s main interface:</p><div><div><pre tabindex="0"><code data-lang="zig"><span><span><span>pub</span> <span>const</span> MakeFn <span>=</span> <span>*</span><span>const</span> <span>fn</span> (self<span>:</span> <span>*</span>Step, prog_node<span>:</span> <span>*</span>std.Progress.Node) <span>anyerror</span><span>!</span><span>void</span>;</span></span></code></pre></div></div><p>All other concrete steps implements it via composition with <code>@fieldParentPtr</code>. If readers don&#39;t know this idioms, refer to <a href="https://zig.news/david_vanderson/interfaces-in-zig-o1c">this post</a>. The following are most common used steps:</p><ul><li><code>CompileStep</code>, used to compile binary/static library/static library</li><li><code>RunStep</code>, used to execute one program</li><li><code>InstallArtifactStep</code>, used to copy build artifacts to <code>zig-out</code> directory</li></ul><p><code>std.Build</code> provides lots of convenient APIs to define steps and their relation, such as:</p><ul><li><code>addExecutable</code> define a <code>CompileStep</code> for application binary</li><li><code>addTest</code> define a <code>CompileStep</code> for test binary</li><li><code>addRunArtifact</code> define a <code>RunStep</code> for one <code>CompileStep</code></li></ul><p>Steps&#39; relation is built using <code>Step.dependOn</code> function, and their relation construct a directed acyclic graph(DAG), which is used to drive the whole build process.</p><figure><img src="https://en.liujiacai.net/images/zig-steps.svg" alt="Steps DAG"/><figcaption><p>Steps DAG</p></figcaption></figure><p>Figure above show a simple DAG of steps, steps at the top are special, and they can be invoked by <code>zig build ${topLevelStep}</code>, <code>Build.step</code> function creates such top level steps.</p><p>After explanation above, readers should have a deeper understand what <code>build.zig</code> does.</p><div><div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> std <span>=</span> @import(<span>&#34;std&#34;</span>);
</span></span><span><span>
</span></span><span><span><span>pub</span> <span>fn</span> build(b<span>:</span> <span>*</span>std.Build) <span>void</span> {
</span></span><span><span>    <span>const</span> target <span>=</span> b.standardTargetOptions(.{});
</span></span><span><span>    <span>const</span> optimize <span>=</span> b.standardOptimizeOption(.{});
</span></span><span><span>    <span>const</span> exe <span>=</span> b.addExecutable(.{
</span></span><span><span>        .name <span>=</span> <span>&#34;demo&#34;</span>,
</span></span><span><span>        .root_source_file <span>=</span> .{ .path <span>=</span> <span>&#34;src/main.zig&#34;</span> },
</span></span><span><span>        .target <span>=</span> target,
</span></span><span><span>        .optimize <span>=</span> optimize,
</span></span><span><span>    });
</span></span><span><span>    b.installArtifact(exe);
</span></span><span><span>    <span>const</span> run_cmd <span>=</span> b.addRunArtifact(exe);
</span></span><span><span>    run_cmd.step.dependOn(b.getInstallStep());
</span></span><span><span>    <span>if</span> (b.args) <span>|</span>args<span>|</span> {
</span></span><span><span>        run_cmd.addArgs(args);
</span></span><span><span>    }
</span></span><span><span>    <span>const</span> run_step <span>=</span> b.step(<span>&#34;run&#34;</span>, <span>&#34;Run the app&#34;</span>);
</span></span><span><span>    run_step.dependOn(<span>&amp;</span>run_cmd.step);
</span></span><span><span>    <span>const</span> unit_tests <span>=</span> b.addTest(.{
</span></span><span><span>        .root_source_file <span>=</span> .{ .path <span>=</span> <span>&#34;src/main.zig&#34;</span> },
</span></span><span><span>        .target <span>=</span> target,
</span></span><span><span>        .optimize <span>=</span> optimize,
</span></span><span><span>    });
</span></span><span><span>    <span>const</span> run_unit_tests <span>=</span> b.addRunArtifact(unit_tests);
</span></span><span><span>    <span>const</span> test_step <span>=</span> b.step(<span>&#34;test&#34;</span>, <span>&#34;Run unit tests&#34;</span>);
</span></span><span><span>    test_step.dependOn(<span>&amp;</span>run_unit_tests.step);
</span></span><span><span>}</span></span></code></pre></div></div></div></div>
  </body>
</html>
