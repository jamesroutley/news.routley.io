<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.wordpress.com/2025/01/06/simple-defer-ready-to-use/">Original</a>
    <h1>C: Simple Defer, Ready to Use</h1>
    
    <div id="readability-page-1" class="page"><p>With this post I will concentrate on the here and now: how to use C’s future lifesaving defer feature with existing tools and compilers.</p><div>
		
<p>I have already <a href="https://gustedt.wordpress.com/2024/09/11/braiding-the-spaghetti-implementing-defer-in-the-preprocessor/">talked several times about <code>defer</code></a>, the new feature that hopefully will make it into a future version of C. With this post I will concentrate on the here and now: how to apply that lifesaving feature with existing tools and compilers.</p>



<p>After briefly discussing the <code>defer</code> feature itself, again, I will show you a first implementation with gcc extensions, a second with C++ standard features and then I will discuss <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3434.htm">a new proposal with for <code>defer</code></a> that has a syntax that is a tiny bit more constraining than what you may have seen so far.</p>







<h2>The defer feature itself</h2>



<p>To remind you what <code>defer</code> is supposed to do, here is some toy code that uses three resources:</p>


<div><pre title="">{                             // anchor block
    void* p = malloc(25);
    defer { free(p); };          // 1st defer

    mtx_lock(&amp;mut);
    defer { mtx_unlock(&amp;mut); }; // 2nd defer

    static uint64_t critical = 0;
    critical++;
    defer { critical--; };       // 3rd defer

    while (something) cnd_wait(&amp;cond, &amp;mut);
    ... use p under protection of mut ...
}

</pre></div>


<p>This code with three so-called deferred blocks is equivalent to the following</p>


<div><pre title="">{
    void* p = malloc(25);

    mtx_lock(&amp;mut);

    static uint64_t critical = 0;
    critical++;

    while (something) cnd_wait(&amp;cond, &amp;mut);
    ... use p under protection of mut ...


    { critical--;       } // from 3rd defer
    { mtx_unlock(&amp;mut); } // from 2nd defer
    { free(p);          } // from 1st defer
}

</pre></div>


<p>only that the deferred blocks are even executed when the anchor block is left by a jump statement (such as a <code>break</code>, <code>continue</code>, <code>return</code> or even <code>goto</code>) that would be nested inside complicated <code>if</code>/<code>else</code> conditionals. Thus using <code>defer</code> here ensures that</p>



<div><ul>
<li><code>p</code>, <code>something</code> and <code>critical</code> are only used under the protection of the mutex <code>mut</code>,</li>
<li><code>critical</code> then holds the number of threads that are currently within that anchor block</li>
<li><code>mut</code> never remains locked whenever the anchor block is left.</li>
<li><code>*p</code> is deallocated whenever the anchor block is left.</li>
</ul>
</div>



<h2>Implementing defer with gcc</h2>



<p>With a minimal macro wrapper this feature works out of the box in gcc since at least two decades.  Written with C23’s attribute feature the inner macro looks as simple as the following:</p>


<div><pre title="">#define __DEFER__(F, V)      \
  auto void F(int*);         \
  [[gnu::cleanup(F)]] int V; \
  auto void F(int*)
</pre></div>


<p>Here the three lines of the macro are as follows:</p>



<ul>
<li><code>auto void F(int*);</code> forward-declares a nested (local) function <code>F</code>.</li>



<li><code>[[gnu::cleanup(F)]] int V;</code> establishes this function as a cleanup handler of an auxiliary variable <code>V</code></li>



<li>The second <code>auto void F(int*)</code> then starts the definition of the local function which is completed with the user’s compound statement as the function body.</li>
</ul>



<p>For this to work we have to provide unique names <code>F</code> and <code>V</code> such that several defer blocks may appear within the same anchor block. This is ensured by another very common extension <code>__COUNTER__</code></p>


<div><pre title="">#define defer __DEFER(__COUNTER__)
#define __DEFER(N) __DEFER_(N)
#define __DEFER_(N) __DEFER__(__DEFER_FUNCTION_ ## N, __DEFER_VARIABLE_ ## N)
</pre></div>


<p>That is basically it, a straight application of the <code>[[gnu::cleanup]]</code> feature that</p>



<ul>
<li>avoids the need for inventing safe identifiers,</li>



<li>avoids the definition of an one-shot function with internal or external linkage far away from its use,</li>



<li>integrates well and quite efficiently with the existing compiler infrastructure.</li>
</ul>



<p>Indeed, when adding a bit more magic (such as <code>[[gnu::always_inline]]</code>) the assembly that is produced is very efficient and avoids function calls, trampolines and indirections. (See also <a href="https://omeranson.github.io/blog/2022/06/12/cleanup-attribute-in-C">Omar Anson’s blog entry</a> on how efficient the cleanup attribute seems to be implemented in gcc.)</p>



<p>If you don’t like or have the C23 attribute syntax yet, you should easily be able to use gcc’s legacy <code>__attribute__((...))</code> syntax without problems. </p>



<h2>Implementing defer with C++</h2>



<p>Yes! I think it would even make sense for C++, but what do I know. </p>



<p>At least the following implementation shows that the feature fits directly into C++’s model of binding actions to a scope. In fact, implementing the defer feature with the properties as desired in C++ is a student excercise. It can be done with a <code>template</code> class and lambdas.</p>


<div><pre title="">template&lt;typename T&gt;
struct __df_st  : T {
  [[gnu::always_inline]]
  inline
  __df_st(T g) : T(g) {
    // empty
  }
  [[gnu::always_inline]]
  inline
  ~__df_st() {
    T::operator()();
  }
};

#define __DEFER__(V)  __df_st const V = [&amp;](void)-&gt;void

</pre></div>


<p>Lambda expressions have a unique type for each expression. Such a lambda expression is taken here as a template parameter to the constructor <code>__df_st&lt;T&gt;::__df_st(T)</code>. The destructor <code>__df_st&lt;T&gt;::~__df_st()</code> of the variable then invokes the lambda when <code>V</code> leaves its scope. The <code>[&amp;]</code> in</p>


<div><pre title="">[&amp;](void)-&gt;void { some code }
</pre></div>


<p>ensures that all outer variables are fully accessible at the point of execution of the lambda. Therefore, such an implementation provides the full functionality that we need for our first example from above.</p>



<p>Note, that the <code>__COUNTER__</code> pseudo-macro is also quite commonly implemented by C++ compilers and is now even proposed as an <a href="https://isocpp.org/files/papers/P3384R0.html">addition to C++26</a>. Thus with a similar macro as for gcc above we can implement the <code>defer</code> macro itself:</p>


<div><pre title="">#define defer __DEFER(__COUNTER__)
#define __DEFER(N) __DEFER_(N)
#define __DEFER_(N) __DEFER__(__DEFER_VARIABLE_ ## N)
</pre></div>


<h2>A note on the syntax for defer</h2>



<p>As we have seen above existing implementations (let’s also count the one for C++) use quite different features under the hood: </p>



<p>One uses a function declaration where a compound statement of the user code as in </p>


<div><pre title="">    defer { mtx_unlock(&amp;mut); };
</pre></div>


<p>ends up being a function body. Here the terminating <code>;</code> is superfluous, but doesn’t hurt much, either.</p>



<p>The other declares a expression that also needs <code>{}</code> to limit the user code and a terminating <code>;</code> because underneath it is an object declaration.</p>



<p>I think we should combine these different syntax requirements, such that implementors (or library providers) may easily start providing this feature with what they have. I have recently made a new proposal to the C standards committee in that sense:</p>



<p><a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3434.htm">Even simpler defer for direct integration, N3434</a></p>



<p>It has the advantage, I think, that it is much easier and more direct that previous proposals and that it combines the possibility of implementing the feature in the language or in the library. Therefore the defer features is proposed as a “block item” in a compound statement (its anchor) and then defined via the syntax rules</p>



<div><blockquote>
<p><em>defer-block:</em></p>
</blockquote>
<blockquote>
<blockquote>
<p><code>defer</code> <em>deferred-block</em> <code>;</code></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>deferred-block:</em></p>
</blockquote>
<blockquote>
<blockquote>
<p><em>compound-statement</em></p>
</blockquote>
</blockquote>
</div>

			
				</div></div>
  </body>
</html>
