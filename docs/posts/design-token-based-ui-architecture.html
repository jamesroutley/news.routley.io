<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinfowler.com/articles/design-token-based-ui-architecture.html">Original</a>
    <h1>Design Token-Based UI Architecture</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Design tokens, or “tokens” are fundamental design decisions represented
    as data. They are the foundational building blocks of design systems.</p>

<p>Since the release of the <a href="https://second-editors-draft.tr.designtokens.org/format/">second editor’s
    draft</a> of the
    design token specification in 2022 and the <a href="https://www.w3.org/community/design-tokens/2022/06/14/call-to-implement-the-second-editors-draft-and-share-feedback/">call for tool
    makers</a>
    to start implementing and providing feedback, the landscape of design token
    tools has evolved rapidly. Tools like code generators, documentation
    systems, and UI design software are now better equipped to support design
    tokens, underscoring their growing importance in modern UI architecture.</p>

<p>In this article, I&#39;ll explain what design tokens are, when they are useful and how to apply
    them effectively. We&#39;ll focus on key architectural decisions that are often difficult to change later, including:</p>

<ol>
<li>How to organize design tokens in layers to balance scalability, maintainability and developer experience.</li>

<li>Whether all tokens should be made available to product teams or just a subset.</li>

<li>How to automate the distribution process of tokens across teams.</li>
</ol>

<section id="RoleOfDesignTokens">
<h2>Role of design tokens</h2>

<p>Around 2017, I was involved in a large project that used the <a href="https://martinfowler.com/articles/micro-frontends.html">Micro
      Frontend
      Architecture</a> to
      scale development teams. In this setup, different teams were responsible
      for different parts of the user interface, which could be even on the same
      page. Each team could deploy its micro-frontend independently.</p>

<p>There were various cases where components would be displayed on top of
      each other (such as dialogs or toasts appearing on top of content areas),
      which were not part of the same micro frontend. Teams used the CSS
      property <code>z-index</code> to control the stacking order, often relying on magic
      numbers—arbitrary values that weren’t documented or standardized. This approach
      did not scale as the project grew. It led to issues that took effort to
      fix, as cross-team collaboration was needed.</p>

<p>The issue was eventually addressed with design tokens and I think makes
      a good example to introduce the concept. The respective token file might
      have looked similar to this:</p>

<pre>{
  &#34;z-index&#34;: {
    &#34;$type&#34;: &#34;number&#34;,
    &#34;default&#34;: {
      &#34;$value&#34;: 1
    },
    &#34;sticky&#34;: {
      &#34;$value&#34;: 100
    },
    &#34;navigation&#34;: {
      &#34;$value&#34;: 200
    },
    &#34;spinner&#34;: {
      &#34;$value&#34;: 300
    },
    &#34;toast&#34;: {
      &#34;$value&#34;: 400
    },
    &#34;modal&#34;: {
      &#34;$value&#34;: 500
    }
  }
}
</pre>

<p>The design tokens above represent the set of <code>z-index</code> values that can
      be used in the application and the name gives developers a good idea of
      where to use them. A token file like this can be integrated into the
      designers’ workflow and also be used to generate code, in a format that
      each team requires. For example, in this case, the token file might have
      been used to generate CSS or SCSS variables:</p>

<div>
<div>
<p>css
</p>

<pre>  :root {
    --z-index-default: 1;
    --z-index-sticky: 100;
    --z-index-navigation: 200;
    --z-index-spinner: 300;
    --z-index-toast: 400;
    --z-index-modal: 500;
  }</pre>
</div>

<div>
<p>scss
</p>

<pre>  
  $z-index-default: 1;
  $z-index-sticky: 100;
  $z-index-navigation: 200;
  $z-index-spinner: 300;
  $z-index-toast: 400;
  $z-index-modal: 500;</pre>
</div>
</div>

<section id="WhatAreDesignTokens">
<h3>What are design tokens?</h3>

<p>Salesforce <a href="https://www.smashingmagazine.com/2019/11/smashing-podcast-episode-3/">originally introduced design tokens</a> to streamline design
      updates to multiple
      platforms.</p>

<p>The Design Tokens Community Group <a href="https://second-editors-draft.tr.designtokens.org/format/#introduction">describes design tokens</a> as “a
      methodology for expressing design decisions in a platform-agnostic way so
      that they can be shared across different <b>disciplines</b>, <b>tools</b>, and
      <b>technologies</b></p>

<p>Let’s break this down:</p>

<ul>
<li><b>Cross-Disciplinary Collaboration:</b> Design tokens act as a common language
        that aligns designers, developers, product managers, and other disciplines. By
        offering a single source of truth for design decisions, they ensure that
        everyone involved in the product life cycle is on the same page, leading to more
        efficient workflows.</li>

<li><b>Tool integration:</b> Design tokens can be integrated into various design
        and development tools, including UI design software, token editors, translation
        tools (code generators), and documentation systems. This enables design updates
        to be quickly reflected in the code base and are synchronized across teams.</li>

<li><b>Technology adaptability:</b> Design tokens can be translated into different
        technologies like CSS, SASS, and JavaScript for the web, and even used on native
        platforms like Android and iOS. This flexibility enables design consistency
        across a variety of platforms and devices.</li>
</ul>
</section>
</section>

<section id="EstablishingASingleSourceOfTruth">
<h2>Establishing a single source of truth</h2>

<p>A key benefit of design tokens is their ability to serve as a single
      source of truth for both design and engineering teams. This ensures that
      multiple products or services maintain visual and functional
      consistency.</p>

<p>A <a href="https://tr.designtokens.org/format/#translation-tool">translation
      tool</a> takes one or
      more design token files as input and generates platform-specific code as
      output. Some translation tools can also produce documentation for the
      design tokens in the form of HTML. At the time of writing, popular
      translation tools include ﻿<a href="https://styledictionary.com/">Style
      Dictionary</a>,
      ﻿<a href="https://github.com/salesforce-ux/theo">Theo</a>, ﻿<a href="https://diez.org/">Diez</a>
      or ﻿<a href="https://specifyapp.com/">Specify App</a>.</p>




</section>

<section id="AutomatedDesignTokenDistribution">
<h2>Automated design token distribution</h2>

<p>In this section, we’ll explore how to automate the distribution of
      design tokens to product teams.</p>

<p>Let’s assume our goal is to provide teams with updated, tech-specific
      design tokens immediately after a designer makes a change. To achieve
      this, we can automate the translation and distribution process using a
      deployment pipeline for design tokens. Besides platform-specific code
      artifacts (like CSS for the web, XML for Android etc.), the pipeline might
      also deploy the documentation for the design tokens.</p>

<p>One crucial requirement is keeping design tokens under version control.
      Thankfully, plugins for popular design tools like Figma already integrate
      with Git providers like GitHub. It&#39;s considered best practice to use the
      Git repository as the single source of truth for design tokens—not the
      design tool itself. However, this requires the plugin to support syncing
      both ways between the repository and the design tool, which not all
      plugins do. As of now, Tokens Studio is a plugin that offers this
      bidirectional syncing. For detailed guidance on integrating Tokens Studio
      with different Git providers, please refer to their
      <a href="https://docs.tokens.studio/token-storage-and-sync/sync-provider-overview">documentation</a>.
      The tool enables you to configure a target branch and supports a
      trunk-based as well as a pull-request-based workflow.</p>

<p>Once the tokens are under version control, we can set up a deployment
      pipeline to build and deploy the artifacts needed by the product teams,
      which include platform-specific source code and documentation. The source
      code is typically packaged as a library and distributed via an artifact
      registry. This approach gives product teams control over the upgrade
      cycle. They can adopt updated styles by simply updating their
      dependencies. These updates may also be applied indirectly through updates of component
      libraries that use the token-based styles.</p>

<div id="token-distribution.svg"><p><img src="https://martinfowler.com/articles/design-token-based-ui-architecture/token-distribution.svg"/></p><p>Figure 2: Automated design token distribution</p>
</div>



<p>This overall setup has allowed teams at Thoughtworks to roll out
      smaller design changes across multiple front-ends and teams in a single
      day.</p>

<section id="FullyAutomatedPipeline">
<h3>Fully automated pipeline</h3>

<p>The most straightforward way to design the pipeline would be a
          fully automated trunk-based workflow. In this setup, all changes
          pushed to the main branch will be immediately deployed as long as they
          pass the automated quality gates.</p>

<p>Such a pipeline might consist of the following jobs:</p>

<ol>
<li><b>Check:</b> Validate the design token files using a design token validator
            or a JSON validator.</li>

<li><b>Build:</b> Use a translation tool like <a href="https://styledictionary.com/">Style
            Dictionary</a> to convert design token files into
            platform-specific formats. This job might also build the docs using the
            translation tool or by integrating a dedicated documentation tool.</li>

<li><b>Test:</b> This job is highly dependent on the testing strategy. Although
            some tests can be done using the design token file directly (like checking the
            color contrast), a common approach is to test the generated code using a
            documentation tool such as Storybook. Storybook has excellent <a href="https://storybook.js.org/docs/writing-tests">test
            support</a> for visual regression
            tests, accessibility tests, interaction tests, and other test types.</li>

<li><b>Publish:</b> Publish updated tokens to a package manager (for example,
            npm). The release process and versioning can be fully automated with a package
            publishing tool that is based on <a href="https://www.conventionalcommits.org/">Conventional
            Commits</a> like
            <a href="https://github.com/semantic-release/semantic-release">semantic-release</a>.
            semantic-release also allows the deployment of packages to multiple platforms.
            The publish job might also deploy documentation for the design tokens.</li>

<li><b>Notify:</b> Inform teams of the new token version via email or chat, so
            that they can update their dependencies.</li>
</ol>

<div id="pipeline-fully-automated.svg"><p><img src="https://martinfowler.com/articles/design-token-based-ui-architecture/pipeline-fully-automated.svg"/></p><p>Figure 3: Fully automated deployment pipeline</p>
</div>


</section>

<section id="PipelineIncludingManualApproval">
<h3>Pipeline including manual approval</h3>

<p>Sometimes fully automated quality gates are not sufficient. If a
          manual review is required before publishing, a common approach is to
          deploy an updated version of the documentation with the latest design
          token to a preview environment (a temporary environment).</p>

<p>If a tool like Storybook is used, this preview might contain not
          only the design tokens but also show them integrated with the
          components used in the application.</p>

<p>An approval process can be implemented via a pull-request workflow.
          Or, it can be a manual approval / deployment step in the pipeline.</p>

<div id="pipeline-incl-review.svg"><p><img src="https://martinfowler.com/articles/design-token-based-ui-architecture/pipeline-incl-review.svg"/></p><p>Figure 4: Deployment pipeline with manual approval</p>
</div>


</section>
</section>

<section id="OrganizingTokensInLayers">
<h2>Organizing tokens in layers</h2>

<p>As discussed earlier, design tokens represent design decisions as data.
      However, not all decisions operate at the same level of detail. Instead,
      ideally, general design decisions guide more specific ones. Organizing
      tokens (or design decisions) into layers allows designers to make
      decisions at the right level of abstraction, supporting consistency and
      scalability.</p>

<p>For instance, making individual color choices for every new component isn’t practical.
      Instead, it’s more efficient to define a foundational color palette and then
      decide how and where those colors are applied. This approach reduces the
      number of decisions while maintaining a consistent look and feel.</p>

<p>There are three key types of design decisions for which design tokens
      are used. They build on top of one another:</p>

<ul>
<li><b>What</b> design options are available to use?</li>

<li><b>How</b> are those styles applied across the user interface?</li>

<li><b>Where</b> exactly are those styles applied (in which components)?</li>
</ul>

<p>There are various names for these three types of tokens (as usual,
      naming is the hard part). In this article, we’ll use the terms <a href="https://samiamdesigns.substack.com/p/a-new-approach-to-naming-design-tokens">proposed
      by Samantha
      Gordashko</a>:
      option tokens, decision tokens and component tokens.</p>

<p>Let’s use our color example to illustrate how design tokens can
      answer the three questions above.</p>

<section id="OptionTokensDefiningWhatDesignOptionsAreProvided">
<h3>Option tokens: defining what design options are provided</h3>

<p><i>Option tokens</i> (also called <i>primitive tokens</i>, <i>base tokens</i>, <i>core
      tokens</i>, <i>foundation tokens</i> or <i>reference tokens</i>) define <b>what</b>
      styles can be used in the application. They define things like color
      palettes, spacing/sizing scales or font families. Not all of them are
      necessarily used in the application, but they present reasonable
      options.</p>

<p>Using our example, let’s assume we have a color palette with 9 shades for each color,
      ranging from very light to highly saturated. Below, we define the blue tones and grey tones as option-tokens:</p>

<pre>{
  &#34;color&#34;: {
    &#34;$type&#34;: &#34;color&#34;,
    &#34;options&#34;: {
      &#34;blue-100&#34;: {&#34;$value&#34;: &#34;#e0f2ff&#34;},
      &#34;blue-200&#34;: {&#34;$value&#34;: &#34;#cae8ff&#34;},
      &#34;blue-300&#34;: {&#34;$value&#34;: &#34;#b5deff&#34;},
      &#34;blue-400&#34;: {&#34;$value&#34;: &#34;#96cefd&#34;},
      &#34;blue-500&#34;: {&#34;$value&#34;: &#34;#78bbfa&#34;},
      &#34;blue-600&#34;: {&#34;$value&#34;: &#34;#59a7f6&#34;},
      &#34;blue-700&#34;: {&#34;$value&#34;: &#34;#3892f3&#34;},
      &#34;blue-800&#34;: {&#34;$value&#34;: &#34;#147af3&#34;},
      &#34;blue-900&#34;: {&#34;$value&#34;: &#34;#0265dc&#34;},
      &#34;grey-100&#34;: {&#34;$value&#34;: &#34;#f8f8f8&#34;},
      &#34;grey-200&#34;: {&#34;$value&#34;: &#34;#e6e6e6&#34;},
      &#34;grey-300&#34;: {&#34;$value&#34;: &#34;#d5d5d5&#34;},
      &#34;grey-400&#34;: {&#34;$value&#34;: &#34;#b1b1b1&#34;},
      &#34;grey-500&#34;: {&#34;$value&#34;: &#34;#909090&#34;},
      &#34;grey-600&#34;: {&#34;$value&#34;: &#34;#6d6d6d&#34;},
      &#34;grey-700&#34;: {&#34;$value&#34;: &#34;#464646&#34;},
      &#34;grey-800&#34;: {&#34;$value&#34;: &#34;#222222&#34;},
      &#34;grey-900&#34;: {&#34;$value&#34;: &#34;#000000&#34;},
      &#34;white&#34;: {&#34;$value&#34;: &#34;#ffffff&#34;}
    }
  }
}</pre>

<p>Although it’s highly useful to have reasonable options, option tokens fall short
      of being sufficient for guiding developers on how and where to apply them.</p>
</section>

<section id="DecisionTokensDefiningHowStylesAreApplied">
<h3>Decision tokens: defining how styles are applied</h3>

<p><i>Decision tokens</i> (also called <i>semantic tokens</i> or <i>system tokens</i>)
      specify <b>how</b> those style options should be applied contextually across
      the UI.</p>

<p>In the context of our color example, they might include decisions like the following:</p>

<ul>
<li>grey-100 is used as a surface color.</li>

<li>grey-200 is used for the background of disabled elements.</li>

<li>grey-400 is used for the text of disabled elements.</li>

<li>grey-900 is used as a default color for text.</li>

<li>blue-900 is used as an accent color.</li>

<li>white is used for text on accent color backgrounds.</li>
</ul>

<p>The corresponding decision token file would look like this:</p>

<pre>{
  &#34;color&#34;: {
    &#34;$type&#34;: &#34;color&#34;,
    &#34;decisions&#34;: {
      &#34;surface&#34;: {
        &#34;$value&#34;: &#34;{color.options.grey-100}&#34;,
        &#34;description&#34;: &#34;Used as a surface color.&#34;
      },
      &#34;background-disabled&#34;: {
        &#34;$value&#34;: &#34;{color.options.grey-200}&#34;,
        &#34;description&#34;:&#34;Used for the background of disabled elements.&#34;
      },
      &#34;text-disabled&#34;: {
        &#34;$value&#34;: &#34;{color.options.grey-400}&#34;,
        &#34;description&#34;: &#34;Used for the text of disabled elements.&#34;
      },
      &#34;text&#34;: {
        &#34;$value&#34;: &#34;{color.options.grey-900}&#34;,
        &#34;description&#34;: &#34;Used as default text color.&#34;
      },
      &#34;accent&#34;: {
        &#34;$value&#34;: &#34;{color.options.blue-900}&#34;,
        &#34;description&#34;: &#34;Used as an accent color.&#34;
      },
      &#34;text-on-accent&#34;: {
        &#34;$value&#34;: &#34;{color.options.white}&#34;,
        &#34;description&#34;: &#34;Used for text on accent color backgrounds.&#34;
      }
    }
  }
}</pre>

<p>As a developer, I would mostly be interested in the decisions, not the
      options. For example, color tokens typically contain a long list of options (a
      color palette), while very few of those options are actually used in
      the application. The tokens that are actually relevant when deciding which
      styles to apply, would be usually the decision tokens.</p>

<p>Decision tokens use
      <a href="https://tr.designtokens.org/format/#alias-reference">references</a> to the
      option tokens. I think of organizing tokens this way as a layered
      architecture. In other articles, I have often seen the term <i>tier</i> being
      used, but I think <i>layer</i> is the better word, as there is no physical
      separation implied. The diagram below visualizes the two layers we talked
      about so far:</p>

<div id="2-layer.svg"><p><img src="https://martinfowler.com/articles/design-token-based-ui-architecture/2-layer.svg"/></p><p>Figure 5: 2-layer pattern</p>
</div>


</section>

<section id="ComponentTokensDefiningWhereStylesAreApplied">
<h3>Component tokens: defining where styles are applied</h3>

<p><i>Component tokens</i> (or <i>component-specific tokens</i>) map the <i>decision
      tokens</i> to specific parts of the UI. They show <b>where</b> styles are
      applied.</p>

<p>The term <i>component</i> in the context of design tokens does not always
      map to the technical term component. For example, a button might be
      implemented as a UI component in some applications, while other
      applications just use the <code>button</code> HTML element instead. <i>Component
      tokens</i> could be used in both cases.</p>

<p>Component tokens can be organised in a <a href="https://tr.designtokens.org/format/#group"><i>group</i></a> referencing multiple decision tokens. In our example, this references
      might include text- and background-colors for different variants of the button (primary, secondary) as well as disabled buttons.
      They might also include references to tokens of other types (spacing/sizing, borders etc.) which I&#39;ll omit in the
      following example:</p>

<pre>{
  &#34;button&#34;: {
    &#34;primary&#34;: {
      &#34;background&#34;: {
        &#34;$value&#34;: &#34;{color.decisions.accent}&#34;
      },
      &#34;text&#34;: {
        &#34;$value&#34;: &#34;{color.decisions.text-on-accent}&#34;
      }
    },
    &#34;secondary&#34;: {
      &#34;background&#34;: {
        &#34;$value&#34;: &#34;{color.decisions.surface}&#34;
      },
      &#34;text&#34;: {
        &#34;$value&#34;: &#34;{color.decisions.text}&#34;
      }
    },
    &#34;background-disabled&#34;: {
      &#34;$value&#34;: &#34;{color.decisions.background-disabled}&#34;
    },
    &#34;text-disabled&#34;: {
      &#34;$value&#34;: &#34;{color.decisions.text-disabled}&#34;
    }
  }
}</pre>

<p>To some degree, component tokens are simply the result of applying
      decisions to specific components. However, as this
      example shows, this process isn’t always straightforward—especially for
      developers without design experience. While decision tokens can offer a
      general sense of which styles to use in a given context, component tokens
      provide additional clarity.</p>

<div id="3-layer.svg"><p><img src="https://martinfowler.com/articles/design-token-based-ui-architecture/3-layer.svg"/></p><p>Figure 6: 3-layer pattern</p>
</div>



<p><b>Note:</b> there may be “snowflake” situations where layers are skipped.
      For example, it might not be possible to define a general decision for
      every single component token, or those decisions might not have been made
      yet (for example at the beginning of a project).</p>
</section>


</section>

<section id="TokenScope">
<h2>Token scope</h2>

<p>I already mentioned that while option tokens are very helpful to
    designers, they might not be relevant for application developers using the
    platform-specific code artifacts. Application developers will typically be
    more interested in the decision/component tokens.</p>

<p>Although token scope is not yet included in the design token
    spec, some design
    systems already separate tokens into private (also called <i>internal</i>) and
    public (also called <i>global</i>) tokens. For example, the Salesforce Lightning
    Design System introduced <a href="https://www.lightningdesignsystem.com/design-tokens/">a flag for each
    token</a>. There are
    various reasons why this can be a good idea:</p>

<ul>
<li>it guides developers on which tokens to use</li>

<li>fewer options provide a better developer experience</li>

<li>it reduces the file size as not all tokens need to be included</li>

<li>private/internal tokens can be changed or removed without breaking
      changes</li>
</ul>

<p>A downside of making option tokens private is that developers would rely
    on designers to always make those styles available as decision or component
    tokens. This could become an issue in case of limited availability of the
    designers or if not all decisions are available, for example at the start of
    a project.</p>

<p>Unfortunately, there is no standardized solution yet for implementing
    scope for design tokens. So the approach depends on the tool-chain of the
    project and will most likely need some custom code.</p>

<section id="File-basedScope">
<h3>File-based scope</h3>

<p>Using Style Dictionary, we can use a
      <a href="https://styledictionary.com/reference/hooks/filters/"><i>filter</i></a> to
      expose only public tokens. The most straightforward approach would be to
      filter on the file ending. If we use different file endings for component,
      decision and option tokens, we can use a filter on the file path, for
      example, to make the option tokens layer private.</p>

<p>Style Dictionary config
</p>

<pre>  const styleDictionary = new StyleDictionary({
    &#34;source&#34;: [&#34;color.options.json&#34;, &#34;color.decisions.json&#34;],
    &#34;platforms&#34;: {
      &#34;css&#34;: {
        &#34;transformGroup&#34;: &#34;css&#34;,
        &#34;files&#34;: [
          {
            &#34;destination&#34;: &#34;variables.css&#34;,
<span>            &#34;filter&#34;: token =&gt; !token.filePath.endsWith(&#39;options.json&#39;),</span>
            &#34;format&#34;: &#34;css/variables&#34;
          }
        ]
      }
    }
  });</pre>

<p>The resulting CSS variables would contain
      only these decision tokens, and not the option tokens.</p>

<p>Generated CSS variables
</p>

<pre>  :root {
    --color-decisions-surface: #f8f8f8;
    --color-decisions-background-disabled: #e6e6e6;
    --color-decisions-text-disabled: #b1b1b1;
    --color-decisions-text: #000000;
    --color-decisions-accent: #0265dc;
    --color-decisions-text-on-accent: #ffffff;
  }</pre>
</section>

<section id="AMoreFlexibleApproach">
<h3>A more flexible approach</h3>

<p>If more flexibility is needed, it might be preferable to add a scope
      flag to each token and to filter based on this flag:</p>

<p>Style Dictionary config
</p>

<pre>  const styleDictionary = new StyleDictionary({
    &#34;source&#34;: [&#34;color.options.json&#34;, &#34;color.decisions.json&#34;],
    &#34;platforms&#34;: {
      &#34;css&#34;: {
        &#34;transformGroup&#34;: &#34;css&#34;,
        &#34;files&#34;: [
          {
            &#34;destination&#34;: &#34;variables.css&#34;,
<span>            &#34;filter&#34;: {
              &#34;public&#34;: true
            },</span>
            &#34;format&#34;: &#34;css/variables&#34;
          }
        ]
      }
    }
  });</pre>

<p>If we then add the flag to the decision tokens, the resulting CSS would
      be the same as above:</p>

<p>Tokens with scope flag
</p>

<pre>  {
    &#34;color&#34;: {
      &#34;$type&#34;: &#34;color&#34;,
      &#34;decisions&#34;: {
        &#34;surface&#34;: {
          &#34;$value&#34;: &#34;{color.options.grey-100}&#34;,
          &#34;description&#34;: &#34;Used as a surface color.&#34;,
<span>          &#34;public&#34;: true</span>
        },
        &#34;background-disabled&#34;: {
          &#34;$value&#34;: &#34;{color.options.grey-200}&#34;,
          &#34;description&#34;:&#34;Used for the background of disabled elements.&#34;,
<span>          &#34;public&#34;: true</span>
        },
        &#34;text-disabled&#34;: {
          &#34;$value&#34;: &#34;{color.options.grey-400}&#34;,
          &#34;description&#34;: &#34;Used for the text of disabled elements.&#34;,
<span>          &#34;public&#34;: true</span>
        },
        &#34;text&#34;: {
          &#34;$value&#34;: &#34;{color.options.grey-900}&#34;,
          &#34;description&#34;: &#34;Used as default text color.&#34;,
<span>          &#34;public&#34;: true</span>
        },
        &#34;accent&#34;: {
          &#34;$value&#34;: &#34;{color.options.blue-900}&#34;,
          &#34;description&#34;: &#34;Used as an accent color.&#34;,
<span>          &#34;public&#34;: true</span>
        },
        &#34;text-on-accent&#34;: {
          &#34;$value&#34;: &#34;{color.options.white}&#34;,
          &#34;description&#34;: &#34;Used for text on accent color backgrounds.&#34;,
<span>          &#34;public&#34;: true</span>
        }
      }
    }
  }</pre>

<p>Generated CSS variables
</p>

<pre>  :root {
    --color-decisions-surface: #f8f8f8;
    --color-decisions-background-disabled: #e6e6e6;
    --color-decisions-text-disabled: #b1b1b1;
    --color-decisions-text: #000000;
    --color-decisions-accent: #0265dc;
    --color-decisions-text-on-accent: #ffffff;
  }</pre>

<p>Such flags can now also be set <a href="https://help.figma.com/hc/en-us/articles/360039238193-Hide-styles-components-and-variables-when-publishing#h_01HD20M7HS9044NHB2YBJNE9C2">through the Figma
      UI</a>
      (if using Figma variables as a source of truth for design tokens). It is
      available as
      <a href="https://www.figma.com/plugin-docs/api/properties/Variable-hiddenfrompublishing/"><code>hiddenFromPublishing</code></a>
      flag via the Plugins API.</p>
</section>
</section>

<section id="ShouldIUseDesignTokens">
<h2>Should I use design tokens?</h2>

<p>Design tokens offer significant benefits for modern UI architecture,
      but they may not be the right fit for every project.</p>

<div>
<div>
<p><b>Benefits</b> include:</p>

<ul>
<li>Improved lead time for design changes</li>

<li>Consistent design language and UI architecture across platforms and
            technologies</li>

<li>Design tokens being relatively lightweight from an implementation point of
            view</li>
</ul>
</div>

<div>
<p><b>Drawbacks</b> include:</p>

<ul>
<li>Initial effort for automation</li>

<li>Designers might have to (to some degree) interact with Git</li>

<li>Standardization is still in progress</li>
</ul>
</div>
</div>

<p>Consider the following when deciding whether to adopt design
      tokens:</p>

<section id="WhenToUseDesignTokens">
<h3>When to use design tokens</h3>

<ol>
<li><b>Multi-Platform or Multi-Application Environments:</b> When working across
          multiple platforms (web, iOS, Android…) or maintaining several applications or
          frontends, design tokens ensure a consistent design language across all of
          them.</li>

<li><b>Frequent Design Changes</b>: For environments with regular design
          updates, design tokens provide a structured way to manage and propagate changes
          efficiently.</li>

<li><b>Large Teams</b>: For teams with many designers and developers, design
          tokens facilitate collaboration.</li>

<li><b>Automated Workflows</b>: If you’re familiar with CI/CD pipelines, the
          effort to add a design token pipeline is relatively low. There are also
          commercial offerings.</li>
</ol>
</section>

<section id="WhenDesignTokensMightNotBeNecessary">
<h3>When design tokens might not be necessary</h3>

<ol>
<li><b>Small projects:</b> For smaller projects with limited scope and minimal
          design complexity, the overhead of managing design tokens might not be worth the
          effort.</li>

<li><b>No issue with design changes:</b> If the speed of design changes,
          consistency and collaboration between design and engineering are not an issue,
          then you might also not need design tokens.</li>
</ol>
</section>
</section>

<hr/>
</div></div>
  </body>
</html>
