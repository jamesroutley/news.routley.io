<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/graph-types/">Original</a>
    <h1>The hunt for the missing data type</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>A (directed) <dfn>graph</dfn> is a set of nodes, connected by arrows (<dfn>edges</dfn>). The nodes and edges may contain data. Here are some graphs:</p>

<center>
<figure> 
  <img src="https://www.hillelwayne.com/post/graph-types/img/graph-examples.gv.png" title="Four graphs, with circles for nodes and arrows for edges."/> 

  <figcaption>
    All graphs made with graphviz 

  <a href="https://www.hillelwayne.com/post/graph-types/img/graph-examples.gv">(source)</a>

  </figcaption>
</figure>
</center>


<p>Graphs are ubiquitous in software engineering:</p>

<ol>
<li>Package dependencies form directed graphs, as do module imports.</li>
<li>The internet is a graph of links between webpages.</li>
<li>Model checkers analyze software by exploring the “state space” of all possible configurations. Nodes are states, edges are valid transitions between states.</li>
<li>Relational databases are graphs where the nodes are records and the edges are foreign keys.</li>
<li>Graphs are a generalization of linked lists, binary trees, and hash tables.</li>
</ol>

<p>Graphs are also widespread in business logic. Whitepapers with references form graphs of citations. Transportation networks are graphs of routes. Social networks are graphs of connections. If you work in software development long enough, you will end up encountering graphs <em>somewhere</em>.</p>

<p>I see graphs everywhere and use them to analyze all sorts of systems. At the same time, I dread actually using graphs in my code. There is almost no graph support in any mainstream language. None have it as a built-in type, very few have them in the standard library, and many don’t have a robust third-party library in the ecosystem. Most of the time, I have to roll graphs from scratch. There’s a gap between how often software engineers could use graphs and how little our programming ecosystems support them. Where are all the graph types?</p>

<p>As I ran into more and more graphs in my work, this question became more and more intriguing to me. So late last year I finally looked for an answer. I put a <a href="https://buttondown.email/hillelwayne/archive/if-you-work-on-a-big-language-id-like-to-talk/">call out</a> on <a href="https://buttondown.email/hillelwayne/">my newsletter</a> asking for people with relevant expertise— graph algorithm inventors, language committee members, graph library maintainers— to reach out. I expected to interview a dozen people, but in the end I only needed to talk to four:</p>

<ol>
<li><strong>Zayenz</strong>: Former core developer of the <a href="https://www.gecode.org/">Gecode constraint solver</a>, and who has “implemented every graph algorithm there is”</li>
<li><strong>Bradford</strong>: Author of the <a href="https://github.com/praetorian-inc/noseyparker/">Nosey Parker</a> security library and inventor of several new graph algorithms</li>
<li><strong><a href="https://ntietz.com/">Nicole</a></strong>: Former graph database engineer</li>
<li><strong>Kelly</strong>: Maintainer on the <a href="https://networkx.org/">NetworkX</a> python graph library and <a href="https://github.com/boothby/repiet">compiler developer</a>.</li>
</ol>

<p>After these four people all gave similar answers, I stopped interviewing and start writing.</p>

<h2 id="the-reasons">The reasons</h2>

<h3 id="there-are-too-many-design-choices">There are too many design choices</h3>

<p>So far I’ve been describing <em>directed</em> graphs. There are also <em>undirected</em> graphs, where edges don’t have a direction. Both directed and undirected graphs can either be <dfn>simple graphs</dfn>, where there is a maximum of one edge between two nodes, or <dfn>multigraphs</dfn>, where there can be many edges. And then for each of <em>those</em> types we have hypergraphs, where an edge can connect three or more nodes, and ubergraphs, where edges can point to other edges. For each possible variation you have more choices to make: do you assign ids to edges or just to nodes? What data can be stored in a node, and what can be stored in an edge? That’s a lot of decisions for a library to make!</p>

<p>But wait, do these distinctions matter at all? A simple graph is just a degenerate multigraph, and and undirected edge can be losslessly transformed into two directed edges. A language could just provide directed hyperubermultigraphs and let users restrict it however they want.</p>

<p>There are two problems with this. First of all, it changes the interface, like whether various operations return single values or lists. Second, as I’ll discuss later, graph algorithm performance is a serious consideration and the special cases <em>really matter</em>. Kelly raised the example of <a href="https://en.wikipedia.org/wiki/Maximum_weight_matching">maximum weight matching</a>. If you know that your graph is “bipartite”, you can use a particular fast algorithm to find a matching, while for other graphs you need to use a slow, more general algorithm.</p>

<center>
<figure> 
  <img src="https://www.hillelwayne.com/post/graph-types/img/bipartite.gv.png" title="A bipartite graph"/> 

  <figcaption>
    A bipartite graph 

  <a href="https://www.hillelwayne.com/post/graph-types/img/bipartite.gv">(source)</a>

  </figcaption>
</figure>
</center>


<blockquote>
<p>[It] ties back to the “algorithm dispatch problem.”  Given a Problem P, a Graph G, and Algorithms A, B, C to solve P on G… which one do you run?  If we don’t know that G is bipartite, and Algorithm C only works on bipartite graphs, how much time can we afford to determine whether or not G is bipartite? — <em>Kelly</em></p>
</blockquote>

<p>The perfect graph library would support a lot of different kinds of graphs. But that takes time away from supporting what people want to <em>do</em> with graphs. Graph algorithms are notoriously hard to get right. In <a href="https://www.python.org/doc/essays/graphs/">this essay</a>, the inventor of Python implemented his own <code>find_shortest_path</code> algorithm. It had to be updated with corrections five times!</p>

<blockquote>
<p>Every single implementation of pagerank that I compared to was wrong. — <em>Nicole</em></p>
</blockquote>

<p>So which algorithms should come with the library? “The amount of things people want to do with graphs is absurd,” Kelly told me. That matches my experience, and the experiences of all my interviewees. It sometimes seems like graphs are <em>too powerful</em>, that all their possibilities are beyond my understanding. “The question is,” Kelly said, “where do you draw the line?”</p>

<p>For NetworkX, “the line” is approximately 500 distinct graph algorithms, by themselves making up almost 60,000 lines of code. By comparison, the entire Python standard library, composed of 300 packages, is just under 600,000 lines.</p>

<p>With all that, it’s unsurprising that you don’t see graphs in standard libraries. The language maintainers would have to decide which types of graphs to support, what topologies to special-case, and what algorithms to include. It makes sense to push this maintenance work onto third parties. This is already the mainstream trend in language development; even Python, famous for being “batteries included”, is <a href="https://peps.python.org/pep-0594/">removing 20 batteries</a>.</p>

<p>Third parties can make opinionated decisions on how to design graphs and what algorithms to include. But then they’re faced with the next problem: once you have a graph interface, how do you represent it?</p>

<h3 id="there-are-too-many-implementation-choices">There are too many implementation choices</h3>

<p>Let’s imagine we’re supporting only barebones simple directed graphs: nodes have identities, edges do not, neither has any associated data. How do we encode this graph?</p>

<center>
<figure> 
  <img src="https://www.hillelwayne.com/post/graph-types/img/many-encodings.gv.png" title="A graph diagram of `a -&gt; b -&gt; c -&gt; {a, b}`"/> 

  <figcaption>
     

  <a href="https://www.hillelwayne.com/post/graph-types/img/many-encodings.gv">(source)</a>

  </figcaption>
</figure>
</center>


<p>Here are four possible ways a programming language could internally store it:</p>

<ol>
<li>Edge list: <code>[[a, b], [b, c], [c, a], [c, b]]</code></li>
<li>Adjacency list: <code>[[b], [c], [a, b]]</code></li>
<li>Adjacency matrix: <code>[0 1 0; 0 0 1; 1 1 0]</code></li>
<li>A set of three structs with references to each other</li>
</ol>

<p>Different graph operations have different performance characteristics on different representations. Take a directed graph with 100 nodes and 200 edges. If we use an adjacency matrix representation, we need a 100×100 matrix containing 200 ones and 9,800 zeros.  If we instead use an edge list we need only 200 pairs of nodes. Depending on your PL and level of optimizations that could be a memory difference of 20x or more.</p>

<p>Now instead take a graph with 100 nodes and 8,000 edges and try to find whether an edge exists between node 0 and node 93. In the matrix representation, that’s an O(1) lookup on <code>graph[0][93]</code>. In the edge list representation, that’s an O(|edge|) iteration through all 8,000 edges.</p>

<p>Graphs with only a few edges are <dfn>sparse</dfn> and graphs with almost all edges are <dfn>dense</dfn>. The same program may need to do both operations on both kinds of graph topologies: if you’re constructing a graph from external data, you could start out with a sparse graph and later have a dense one. There’s no “good option” for the internal graph representation.</p>

<p>And all this trouble is just for the most barebones directed graph! What about implementing node data? Edge data? Different types of nodes and edges? Most third party libraries roughly fall in one of two categories:</p>

<ol>
<li><p>Offer a single rich datatype that covers all use-cases at the cost of efficiency. NetworkX stores graph as a dict of dicts of dicts, so that both nodes and edges can have arbitrary data.</p></li>

<li><p>Offer separate graph types for each representation, and rely on the user to store node and edge data separately from the graph type.</p></li>
</ol>

<p>An example of the second case would be <a href="https://docs.rs/petgraph/latest/petgraph/index.html">Petgraph</a>, the most popular graph library for Rust. Petgraph has <code>graph</code>, <code>graphmap</code>, and <code>matrix_graph</code> for different use-cases. Bradford used Petgraph for <a href="https://github.com/praetorian-inc/noseyparker/">Nosey Parker</a>, a security tool that scans for secrets across an entire history of a git repo. His benchmarking graph is CPython, which has 250k commits and 1.3M objects but only a few edges per commit node. He went with an adjacency list.</p>

<p>Supporting many representations has a serious downside: you have to do a lot more work to add algorithms. If you write a separate version of the algorithm for each graph representation, you’re tripling or quadrupling the maintenance burden. If you instead write a generic abstraction over polymorphic types, then your library is less performant. One programmer I talked to estimated that a hand-rolled graph algorithm can be 20x faster or more than a generic algorithm.</p>

<p>And this gets into every interviewee’s major complaint.</p>

<h3 id="performance-is-too-important">Performance is too important</h3>

<blockquote>
<p>A “generic” graph implementation often doesn’t cut it. <em>— Bradford</em></p>
</blockquote>

<p>This is the big one.</p>

<p>Many, many graph algorithms are NP-complete or harder. While NP-complete is often tractable <a href="https://www.hillelwayne.com/post/np-hard/">for large problems</a>, graphs can be <em>enormous</em> problems. The choice of representation plays a big role in how fast you can complete it, as do the specifics of your algorithm implementation.</p>

<p>Everyone I talked to had stories about this. In Nosey Parker, Bradford needed to reconstruct a snapshot of the filesystem for each commit, which meant traversing the object graph. None of the <a href="https://docs.rs/petgraph/latest/petgraph/visit/index.html">four provided graph walkers</a> scaled to his use case. Instead he had to design a “semi-novel” <a href="https://github.com/praetorian-inc/noseyparker/blob/aaacceaa4baf0fb6a9c98c95b9b063ed74654349/crates/input-enumerator/src/git_metadata_graph.rs#L337">graph traversal algorithm</a> on the fly, which reduced the memory footprint by a factor of a thousand.</p>

<blockquote>
<p>I was able to get working a proof of concept pretty quickly with [petgraph], but then… this is one of those cases where the performance constraints end up meeting reality. <em>— Bradford</em></p>
</blockquote>

<p>Zayenz raised a different problem: what if the graph is simply too big to work with? He gave the example of finding a solution to the <a href="https://en.wikipedia.org/wiki/15_Puzzle">15 puzzle</a>. This is done by running a <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search</a> on the state space. A state space with <a href="https://mediatum.ub.tum.de/doc/1283911/60434.pdf">over 20 trillion states</a>.</p>

<blockquote>
<p>If you generate all the nodes, you’ve lost already. — <em>Zayenz</em></p>
</blockquote>

<p>Zayenz oversaw one research project to add graphs to the Gecode constraint solver. They eventually found that a generic graph type simply couldn’t compete with handpicking the representation for the problem.</p>

<p>Even graph databases, designed entirely around running complex graph algorithms, struggle with this problem. Nicole, the graph database engineer, told me about some of the challenges with optimizing even basic graph operations.</p>

<blockquote>
<p>If you’re doing a traversal, you either have to limit your depth or accept you’re going to visit the entire graph. When you do a depth search, like “go out three steps from this and find the path if it exists”, then you’re just committing to visiting quite a bit of data. <em>— Nicole</em></p>
</blockquote>

<p>After leaving that job, she worked as a graph query performance consultant. This usually meant migrating off the graph database. She told me about one such project: to speed the graph queries up, she left one computation as-is and rewrote the rest as MapReduce procedures. “Which was a lot harder to understand,” she said, “But would actually finish overnight.”</p>

<p>All of this means that if you have graph problems you want to solve, you need a lot of control over the specifics of your data representation and algorithm. You simply cannot afford to leave performance on the table.</p>

<h2 id="it-was-unanimous">It was unanimous</h2>

<p>So, the reasons we don’t have widespread graph support:</p>

<ul>
<li>There are many different kinds of graphs</li>
<li>There are many different representations of each kind of graph</li>
<li>There are many different graph algorithms</li>
<li>Graph algorithm performance is very sensitive to graph representation and implementation details</li>
<li>People run very expensive algorithms on very big graphs.</li>
</ul>

<p>This explains why languages don’t support graphs in their standard libraries: too many design decisions, too many tradeoffs, and too much maintenance burden. It explains why programmers might avoid third party graph libraries, because they’re either too limited or too slow. And it explains why programmers might not want to think about things in terms of graphs except in extreme circumstances: it’s just too hard to work with them.</p>

<p>Since starting this research, I’ve run into several new graph problems in my job. I still appreciate analyzing systems as graphs and dread implementing them. But now I know why everybody else dreads them, too. Thank you for reading!</p>

<p><em>Thanks to <a href="https://predr.ag/">Predrag Gruevski</a> for research help, <a href="https://lars.hupel.info/">Lars Hupel</a>, <a href="https://predr.ag/">Predrag Gruevski</a>, <a href="https://www.danluu.com">Dan Luu</a>, and <a href="https://medium.com/@bellmar">Marianne Bellotti</a> for feedback, and to all of the people who agreed to do interviews. If you liked this post, come join my <a href="https://buttondown.email/hillelwayne/">newsletter</a>! I write new essays there every week.</em></p>

<p><em>I train companies in formal methods, making software development faster, cheaper, and safer. Learn more <a href="https://www.hillelwayne.com/consulting/">here</a>.</em></p>

<hr/>

<h2 id="appendix-languages-with-graph-types">Appendix: Languages with Graph Types</h2>

<h3 id="graph-querying-languages">Graph Querying Languages</h3>

<p>Graph querying languages (GQLs) are to graph databases what SQL is to relational databases. There is no widely-used standard, but two of the most popular are <a href="https://www.w3.org/TR/sparql11-query/">SPARQL</a> for querying <a href="https://en.wikipedia.org/wiki/Resource_Description_Framework">RDF triples</a> and Neo4j’s <a href="https://neo4j.com/product/cypher-graph-query-language/">cypher</a>. Ironically, <a href="https://graphql.org/">GraphQL</a> is <a href="https://graphql.org/faq/#is-graphql-a-database-language-like-sql"><em>not</em></a> a graph querying language, instead being named for its connection to the <a href="https://en.wikipedia.org/wiki/Facebook_Graph_Search">Facebook Graph Search</a>. I considered graph databases themselves mostly distinct from graphs in programming languages, but their query languages show how graphs could work in a PL.</p>

<p>The main difference between all GQLs and SQL is that the “joins” (relationships) are first-class entities. Imagine a dataset of movies and people, where people act in, direct, or produce movies. In SQL you’d implement each relationship as a many-to-many tables, which makes it easy to query “who acted in movie X” but hard to query “who had any role in movie Y, and what was that role”. In SPARQL relationships are just edges, making the same query easy.</p>
<div><pre><code data-lang="sparql"><span></span><span>PREFIX</span> <span>mv:</span> <span>&lt;your_movie_ontology_URL&gt;</span>
<span>SELECT</span> <span>?person</span> <span>?role</span>
<span>WHERE</span> <span>{</span>
    <span>?person</span> <span>?role</span> <span>mv:</span><span>casablanca</span><span>.</span>
<span>}</span>
</code></pre></div>

<p>Cypher has a similar construct. GQLs can also manipulate edges: reverse them, compose them together, take the transitive closure, etc. If we wanted to find all actors with some degree of separation from Kevin Bacon, we could write</p>
<div><pre><code data-lang="sparql"><span></span><span>PREFIX</span> <span>mv:</span> <span>&lt;your_movie_ontology_URL&gt;</span>
<span>SELECT</span> <span>?a</span>
<span>WHERE</span> <span>{</span>
    <span>mv:</span><span>kbacon</span> <span>(:</span><span>acted_in/</span><span>^:</span><span>acted_in</span><span>)</span><span>+</span> <span>?a.</span>
    <span># a/b = join two lookups</span>
    <span># ^a = reverse a</span>
    <span># a+ = transitive closure</span>
<span>}</span>
</code></pre></div>

<p>SPARQL cannot give the length of the path nor do computation <em>along</em> the path, like collecting the chain of movies linking two actors. GQLs that support this are significantly more complicated.</p>

<p>My main takeaway from looking at GQLs is that there’s a set of useful traversal primitives that a PL with graph support would need to provide. Interestingly, the formal specification language <a href="https://alloytools.org/">Alloy</a> has all of these primitives for its “relation” datatype. For this reason I find working with a graph representation in Alloy much easier than in a proper programming language. That said, these all work with labeled edges and may not work for other graph representations.</p>

<h3 id="mainstream-languages-with-graphs-in-the-standard-library">Mainstream Languages with Graphs in the Standard Library</h3>

<p><strong>Python</strong> added a <a href="https://docs.python.org/3/library/graphlib.html">graphlib</a> in 2020. Based on the discussion <a href="https://bugs.python.org/issue17005">here</a>, it was because topological sorting is a “fundamental algorithm” and it would be useful for “pure Python implementations of MRO [Method Resolution Order] logic”. Graphlib has no other methods besides <code>TopologicalSorter</code>, which only takes graphs represented as node dicts. Unusually, the direction of the node dict is <em>reversed</em>: the graph <code>a -&gt; b</code> is represented as <code>{b: [a]}</code>.</p>

<p>As of 2023, nothing in <a href="https://github.com/search?q=repo%3Apython%2Fcpython%20TopologicalSorter&amp;type=code">CPython uses graphlib</a> and there are <a href="https://github.com/search?q=%2F%28from%7Cimport%29+graphlib%2F+language%3Apython+NOT+is%3Afork&amp;type=code">fewer than 900 files referencing it on Github</a>. By comparison, another package added in 2020, zoneinfo, appears in over 6,000 files, and the term <code>def topological_sort(</code> appears in 4,000. I’d guess a lot of these are from before 2020, though. Some skimming suggests that all of these custom topological sorts take different graph representations than graphlib, so they wouldn’t be convertable regardless. Graph representation matters.</p>

<p>There are two other languages I found with graph types: <a href="https://www.erlang.org/doc/man/digraph.html#">Erlang</a> and <a href="https://www.swi-prolog.org/pldoc/man?section=ugraphs">SWI-Prolog</a>. I don’t know either language and cannot tell when they were added; with Erlang, at least, it was before 2008. I reached out to a person on the Erlang core language committee but did not hear back.</p>

<h3 id="graph-languages">Graph languages</h3>

<p>Programming languages where “everything is a graph” in the same way that everything in bash a string and everything in lisp is a list. Some examples include <a href="https://github.com/UoYCS-plasma/GP2">GP2</a> and <a href="http://jenshweber.github.io/grape/">Grape</a>. Based on some correspondence with people in the field, right now this is still highly academic.</p>

<h3 id="mathematics-software-languages">Mathematics Software Languages</h3>

<p>Mathematica, MATLAB, Maple, etc all have graph libraries of some form or another. I am not paying the thousands of dollars in licensing needed to learn more.</p>


</div>

    



  </article></div>
  </body>
</html>
