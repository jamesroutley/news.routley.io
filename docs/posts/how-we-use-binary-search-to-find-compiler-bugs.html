<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bernsteinbear.com/blog/cinder-jit-bisect/">Original</a>
    <h1>How we use binary search to find compiler bugs</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>I work on <a href="https://github.com/facebookincubator/cinder">Cinder</a>, a just-in-time
(JIT) compiler built on top of CPython. If you aren’t familiar with Cinder and
want to learn more, <a href="https://bernsteinbear.com/blog/cinder-jit-inliner/">a previous post about the
inliner</a> gives a decent overview of the JIT. This
post will talk about how we use binary search to isolate miscompiled functions,
a technique that is applicable to any compiler if you have the right
infrastructure.</p>

<h2 id="motivation">Motivation</h2>

<p>Sometimes—frequently—I change an optimization pass or a code generation
step and I break something. In the best case scenario, I end up with a failing
test and the test name or body gives me enough clues to fix my silly little
mistake.  But in the worst case I can’t even boot to the Python prompt because
I messed something up so badly. This can manifest as an exception, a failing
<code>assert</code>, or even a segmentation fault.</p>

<p>Since the runtime could have compiled any number of functions in that boot
process or test run, there are a lot of moving parts. I generally don’t want to
look at the source, intermediate representations, and assembly of 1000
different Python functions. That’s too much. It would be nice to have one to
two functions to look at and make inferences. This is where bisect comes in.</p>

<h2 id="bisect">Bisect</h2>

<p>You may have heard of bisecting from geometry or from <a href="https://git-scm.com/docs/git-bisect"><code>git
bisect</code></a><sup id="fnref:git-bisect" role="doc-noteref"><a href="#fn:git-bisect" rel="footnote">1</a></sup>. Those are the two places I heard about it.
It means <em>to cut in half</em>. In our case and the Git case, not just once—many
times!</p>

<p>We want to take our list of compiled functions and continuously cut it in half
until we reach a very small group of functions that cause us trouble.</p>

<p>Say we run <code>./python -X jit some_program.py</code> and it crashes. In the course of
this run, the JIT compiles functions <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>, runs some code,
and aborts. We can’t know which function is miscompiled, so we will try and
bisect:</p>

<ul>
  <li>Try <code>A</code> and <code>B</code> together. Success.</li>
  <li>Try <code>C</code> and <code>D</code> together. Crash.</li>
  <li>Try <code>C</code>. Success.</li>
  <li>Try <code>D</code>. Crash.</li>
</ul>

<p>Looks like <code>D</code> is the troublemaker.</p>

<p>Since we can discard half of this set each time, we can find our miscompiled
functions in logarithmic time<sup id="fnref:algo" role="doc-noteref"><a href="#fn:algo" rel="footnote">2</a></sup>. That’s awesome. Even on slow-running
repros, this rarely takes significant time. At worst, I go make tea.</p>

<h2 id="requirements">Requirements</h2>

<p>While it’s excellent in many cases, bisecting has some prerequisites:</p>

<ul>
  <li>A consistent reproducer. If your program non-deterministically fails, the
bisect results won’t make any sense.</li>
  <li>Stable enough identifiers for functions. In this case we use the module name
and fully qualified function name.</li>
  <li>The ability to set the list of functions to compile. This requires some
cooperation from the runtime.</li>
  <li>The ability to figure out which functions have been compiled. This also
requires some cooperation from the runtime.</li>
</ul>

<p>We already have the second two due to some server architecture constraints.</p>

<h2 id="implementation-details">Implementation details</h2>

<p>Cinder can be run with <code>-X jit-list-file=somefile.txt</code> and will only compile
functions on the JIT list (but will still only compile on first run).</p>

<p>The bisect script is a wrapper like <code>./jitlist_bisect.py ./python -X jit ...</code>
which interprets the debug output to figure out which functions were compiled
and passes in the JIT list.</p>

<p>Sometimes a JIT list will cause the crash but each split half won’t. In that
case we hold each half fixed and try bisecting the other half to figure out
what candidates we need. <em>Update:</em> I have been told that this is called delta
debugging.</p>

<p>The script is less than 200 lines of Python and can be found
<a href="https://github.com/facebookincubator/cinder/blob/b1c65a7c3cd557854299d5c66bbfe6de1f4ed49d/Tools/scripts/jitlist_bisect.py">here</a>. A typical run looks like this:</p>

<div><div><pre><code>$ ./Tools/scripts/jitlist_bisect.py ./build/python -X jit -m unittest test.test_import
INFO:root:Generating initial jit-list
INFO:root:Verifying jit-list
INFO:root:step fixed[0] and jitlist[504]
INFO:root:504 candidates
INFO:root:252 candidates
INFO:root:126 candidates
INFO:root:63 candidates
INFO:root:32 candidates
INFO:root:16 candidates
INFO:root:8 candidates
INFO:root:4 candidates
INFO:root:2 candidates
Bisect finished with 1 functions in jitlist.txt
$ cat jitlist.txt
warnings:_add_filter
$
</code></pre></div></div>

<p>Time to go look at the <code>warnings</code> module.</p>

<h2 id="other-thoughts">Other thoughts</h2>

<p>Manually or automatically slimming down your reproducing source code also helps
with this approach. It makes the repro runtime shorter and sometimes removes
other moving parts like needing to send network traffic or something. We can
probably use some form of tracing and bisect to automatically slim the repro.</p>

<p>Compiler and interpreter unit tests can be a pain to write but they have saved
me countless times over the past couple of years. Being able to isolate each
and every small optimizer change is so, so helpful.</p>

<h2 id="similar-work">Similar work</h2>

<p>Speaking of automatically slimming the repro, <a href="https://embed.cs.utah.edu/creduce/">C-Reduce</a> is a tool by
John Regehr and his collaborators. It takes a C source file and runner script
and automatically bisects it to some failing case. From their homepage:</p>

<blockquote>
  <p>C-Reduce is a tool that takes a large C, C++, or OpenCL file that has a
property of interest (such as triggering a compiler bug) and automatically
produces a much smaller C/C++ file that has the same property. It is intended
for use by people who discover and report bugs in compilers and other tools
that process source code.</p>
</blockquote>

<p>Incidentally, at the time of writing, their website looks pretty similar to
this one.</p>

<p>Hacker News user <em>eimrine</em> also notes that this is similar to
<a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a>, a technique to find bugs by changing input data or input
programs.</p>

<p>Victor Stinner wrote <a href="https://vstinner.github.io/python-test-bisect.html"><code>test.bisect</code></a> to debug failing tests in
CPython. This is useful when they only fail in certain arrangements!</p>

<hr/>

<!-- Footnotes -->


        </div></div>
  </body>
</html>
