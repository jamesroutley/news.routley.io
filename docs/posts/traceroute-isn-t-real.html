<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gekk.info/articles/traceroute.htm">Original</a>
    <h1>Traceroute Isn&#39;t Real</h1>
    
    <div id="readability-page-1" class="page">
<p><strong><a href="http://tinylogger.com/">gekk.info</a> Â« <a href="http://tinylogger.com/max/index.html">articles</a></strong></p>






<div>
<p><small>Updated - see 1 addendum at bottom.</small></p></div>

<p>There is no such thing as traceroute.</p>
<p>I used to deliver network training at work. It was freeform, I was given wide latitude to design it as I saw fit, so I focused on things that I had seen people struggling with - clearly explaining VLANs in a less abstract manner than most literature, for instance, as well as actually explaining how QoS queuing works, which very few people understand properly.</p>
<p>One of the &#34;chapters&#34; in my presentation was about traceroute, and it more or less said <em>&#34;Don&#39;t use it, because you don&#39;t know how, and almost nobody you&#39;ll talk to does either, so try your best to ignore them.&#34;</em> This is not just my opinion, it&#39;s backed up by people much more experienced than me. For a good summary I highly recommend <a href="https://www.slideshare.net/RichardSteenbergen/a-practical-guide-to-correctly-troubleshooting-with-traceroute" target="_blank" rel="nofollow noopener noreferrer">this presentation</a>.</p>
<p>But as good as that deck is, I always felt it left out a crucial piece of information: Traceroute, <em>as far as the industry is concerned</em>, does not exist.</p>
<p>Look it up. There is no RFC. There are no ports for traceroute, no rules in firewalls to accommodate it, no best practices for network operators. Why is that?</p>
<h3>Traceroute has no history</h3>
<p>First off: Yes, there <em>is</em> a traceroute RFC. It&#39;s <a href="https://datatracker.ietf.org/doc/html/rfc1393" target="_blank" rel="nofollow noopener noreferrer">RFC1393</a>, it&#39;s 31 years old, and to my knowledge nothing supports it. The RFCs are jam-packed with brilliant ideas nobody implemented. This is one of them. The traceroute we have is completely unrelated to this.</p>
<p>Unsurprisingly however, it&#39;s a good description of how a traceroute protocol <em>should</em> work. You send a packet to a given destination, with a special flag set, and any machine it passes through observes the flag and says &#34;oh, this packet is meant to be traced,&#34; so it generates an ICMP Traceroute response and sends it back to the originating host.</p>
<p>The host, then, sends a single packet and receives a flood of responses describing the path that packet took, definitively. Great! Or, I mean, it would be, if anything supported it. And if it was 1993.</p>
<p>As the linked presentation explains, traceroute simply no longer works in the modern world, at least not &#34;as designed&#34; - and it no longer <em>can</em> work that way, for several reasons not the least that networks have been abstracted in ways it did not anticipate.</p>
<p>There are now things like MPLS, which operate by encapsulating IP - in other words, putting a bag over a packets head, throwing it in the back of a van, driving it across town and letting it loose so it has no idea how far it&#39;s traveled. Without getting much further into how that works: It is completely impossible for it to satisfy the expectations of traceroute.</p>
<p>This &#34;tool&#34; works purely at layer 3, so it&#39;s impossible for it to adapt to the sort of &#34;layer 12-dimensional-chess&#34; type shenanigan that MPLS does - and there are other problems, but they&#39;re all getting ahead of reality, since traceroute never even worked correctly as intended, and there&#39;s no reason it would.</p>
<p>Traceroute, you see, is &#34;clever,&#34; which is an engineering term that means &#34;fragile.&#34; When programmers discover something &#34;clever,&#34; any ability they may have had to assess its sustainability or purpose-fit often goes out the window, because it&#39;s far more important to embrace the &#34;cleverness&#34; than to solve a problem reliably.</p>
<p>The RFC process is likely not perfect - it&#39;s basically an enormous committee system, so, that&#39;s troubling - but it does at least constitute a review and consensus process. Had someone written out a spec for traceroute, and then vendors had agreed to implement it, that would be one thing. But that is not what happened.</p>
<h3>Traceroute is a filthy hack</h3>
<p>From the traceroute man page (1987):</p>
<pre>Implemented by Van Jacobson from a suggestion by Steve Deering.
Debugged by a cast of thousands with particularly cogent
suggestions or fixes from C. Philip Wood, Tim Seaver and Ken Adelman.</pre>
<p>I can&#39;t find any proper history of the tool, but my <em>impression</em> and my <em>assumption</em> is that it is simply a behavior that someone <em>noticed was possible</em>. Engineers did not get together and design a system for this; some people just realized that it was <em>a side effect of other network behavior not intended to accomplish this goal.</em></p>
<p>In other words, it&#39;s an exploit, and that is really the best way to describe both how it works, and why it&#39;s a bad idea.</p>
<hr/>
<p><strong>Here&#39;s how traceroute works:</strong></p>
<p>When you send a packet to a destination, it often has to go through multiple routers, or &#34;hops.&#34;</p>
<p>To prevent packets from cycling indefinitely in a network due to routing loops (router A points to router B which points to router A...) they include a Time-To-Live field, which is set to a reasonably high value when a packet is created, and each machine that the packet passes through decrements that field by one.</p>
<p>When the field hits zero, the packet gets thrown away. <em>As a courtesy,</em> the router that&#39;s dropping the packet has the <em>option</em> to generate a new packet, using the ICMP protocol, with the subtype <em>&#34;TTL Exceeded,&#34;</em> and send it back to the originating machine, to let it know there&#39;s something wrong with the network path.</p>
<p>These clever fellows in 1987 realized that by manipulating the TTL value, you can choose which router will send that ICMP message.</p>
<p>Send a packet with the TTL set to 1. The first router you hit will decrement it to zero. The packet is now &#34;dead&#34;, so it drops the packet, and sends back TTL Exceeded. That response will originate from the router&#39;s own IP address - congratulations, you now have the IP of the first hop.</p>
<p>Now send another with the TTL set to 2. The first router will decrement it to 1 and pass it, and the <em>second</em> one will decrement to zero and drop it. Now you have <em>its</em> IP address.</p>
<p>Repeat, increasing TTL each time, until the final hop responds. You now have your complete path.</p>
<hr/>
<p>This is indeed quite clever, but don&#39;t lose sight of what is going on here. TTL Exceeded is simply <em>not meant for this.</em> It is a message meant to diagnose a specific, unrelated kind of network malfunction. It&#39;s not intended for tracing paths, and for reasons I&#39;ll explain, it&#39;s also exactly the kind of feature that may exist in a lab, and in the first few experimental networks, but gets abandoned as soon as money enters the picture.</p>
<h3>DJ Shadow - Why Hip Hop Sucks In 96 (It&#39;s The Money)</h3>
<p><em>TTL Exceeded</em> is not a &#34;feature.&#34;</p>
<p>Features are things that enable functionality. It doesn&#39;t do that.</p>
<p>Features are things that affect end-user experience. It doesn&#39;t do that.</p>
<p>TTL Exceeded is purely informational. It&#39;s useful to exactly one person: a network engineer. It would be absolutely untenable to report this sort of error to an end user, since there&#39;s positively nothing they can do about it, so no application will ever do this.</p>
<p>Not only were these messages not intended for end users, they weren&#39;t even intended for network operators as we know them now.</p>
<p>In 1987, virtually every network admin could get an email address for the admin of pretty much any other network, worldwide, with a couple phone calls or a whois lookup. That meant it was practical to troubleshoot <em>other peoples networks</em>, which are often where these errors are seen. Nowadays? Forget about it. Hah. Wow. <em>No way.</em></p>
<p>If you get a TTL Exceeded while trying to reach another host through the <em>internet</em>, there is a zero percent probability that you can get traction on your problem unless you are a Fortune 500 - and even then it will be tough. At least half the companies that are likely to be involved simply do not provide any form of support for problems involving less than millions of hosts.</p>
<p>It is, generally speaking, not possible to call AT&amp;T and say &#34;Hey, when I try to ping one of your subscribers in California from a Level3 circuit in New York, I&#39;m hitting a routing loop.&#34; I have worked for an ISP with direct peering with those networks and that simply never worked. We got incompetent, consumer-grade support techs and the issue went nowhere, if we even had a contact at all.</p>
<p>It&#39;s even harder to call the exchange partners, the network providers that may sit in between AT&amp;T and Level3 in this equation. Nobody will even tell you who they are, and if they did, <em>there is simply nobody to call.</em> Those phone numbers don&#39;t exist unless you&#39;re a network engineer at one of their direct partners who is calling to report that a fiber port is down.</p>
<p>No, AT&amp;T is not going to push your complaint up the line to XO. Haha. No.</p>
<p>Problems like this are fairly rare these days, which makes it even less likely that anyone will be on hand to work on them. Most of the time, IME, they get resolved through Brownian Troubleshooting: large scale network maintenance happens for unrelated reasons and <em>incidentally</em> fixes the problem.</p>
<p>So traceroute, on an internet scale, has been useless for ages. You think you see a routing problem? So what? There&#39;s absolutely nothing you can do about it.</p>
<p>With that information, go ahead and ask yourself if you think anyone, at any network hardware company, has given a shit about implementing TTL Exceeded since the 90s. The answer is obvious: No. Without a doubt, this is not on anyone&#39;s priority list.</p>
<p>If you&#39;re at Juniper, nobody is clamoring for this. You do not have ISPs threatening to switch to Cisco (lmao!) just because you didn&#39;t implement TTL Exceeded correctly, because they aren&#39;t using it. The kind of problems ISPs care about are &#34;we lost the entire US northeast&#34; or &#34;we can&#39;t reach Comcast, at all.&#34; The NOCs involved at that point may use traceroute, but they will get by without it. Nobody is going to make a C-level escalation with Juniper over it.</p>
<p>So, as a network hardware vendor, with a certain budget and a whole galaxy of internet standards to implement, are you going to put time into this? Absolutely not.</p>
<p>Academics, perhaps. People doing research and experiments at universities 35 years ago might have stuck to the specs religiously, but there is <em>no financial reason whatsoever to implement this correctly.</em></p>
<p>But then, we&#39;re ahead of ourselves again. Because what is a &#34;correct&#34; implementation?</p>
<h3>Nothing involving a router is &#34;correct&#34;, but</h3>
<p>RFC 792, <em>&#34;INTERNET CONTROL MESSAGE PROTOCOL&#34;,</em> explains how to implement TTL Exceeded (which I believe is technically called &#34;Time Exceeded&#34;):</p>
<pre>   Description

      If the gateway processing a datagram finds the time to live field
      is zero it must discard the datagram.  The gateway <em>may</em> also notify
      the source host via the time exceeded message.

      If a host reassembling a fragmented datagram cannot complete the
      reassembly due to missing fragments within its time limit it
      discards the datagram, and it <em>may</em> send a time exceeded message.</pre>
<p>Anyone who knows how to read an RFC understands the crushing solemnity of MAY.</p>
<p>Something that you MAY do is something that WILL NOT be done when it counts. MAY, in RFC terminology, means exactly what the dictionary says it should: The implementer can do it if they want.</p>
<p>That means that it is &#34;standards-compliant&#34; to create a router that has absolutely no implementation of ICMP TTL Exceeded. &#34;May&#34; can mean &#34;never.&#34; It is completely up to the vendor.</p>
<p>And wouldn&#39;t you know it: vendors <em>do</em>, in fact, choose to <em>never</em> send these messages, and for good reason: It&#39;s hard!</p>
<p>The linked presentation (seriously! read it! please! you will benefit!) addresses why this is, and in short it comes down to the fact that routers are basically supercomputers. Consider that a core router at an ISP is potentially handling <em>billions</em> of packets per second. Running all that through a conventional CPU is absurd, and nobody has done this in decades.</p>
<p>Instead, routers contain custom, purpose-built hardware - called the <em>data plane</em> - consisting of dedicated silicon with the sole ability to look at <em>the parts of a packet that matter for routing purposes</em> and ask a couple very simple questions, e.g. <em>&#34;Do I have a way to get this to its next hop?&#34;</em> and <em>&#34;does it still have time to live?&#34;</em></p>
<p>There are probably other details, but you get my point - it&#39;s <em>highly</em> optimized.</p>
<p>99.99% of the packets that pass through such a device simply come in one port, get glanced at, and are then hurled out of another port so the silicon can get on to the next packet. During all of this, the actual <em>computer</em> part of the router, the thing that can make complex decisions, is idle.</p>
<p>Yes, routers do contain general-purpose computers; they&#39;re pitiful little things. From the linked presentation (read it!!):</p>
<pre>A 320-640+ Gbps router may only have a 600MHz CPU
ICMP generation is <em>NOT</em> a priority for the router.
</pre>
<p>Yeah. The CPU is... Not Fast.</p>
<p>As I implied, this is how supercomputers often work: you have a <em>massive</em> array of extremely fast processors, that can only solve certain, very well defined kinds of problems, and then off to the side you have some horrible little Core i3 Ideapad Yoga whose sole job is to feed program and data into the thing and then pull the string on its back.</p>
<p>With a supercomputer, feeding it invalid data will simply crash the process and you&#39;ll have to start all over. That&#39;s not an option with networks, since you can&#39;t control the incoming data, so routers need a way to handle exception scenarios. That&#39;s where the computer - known as the <em>control plane</em> - comes in.</p>
<p>In addition to feeding configs to the data plane, the control plane CPU is responsible for handling unexpected situations. If an interface goes down, the data plane simply starts dropping packets (if it has no other paths.) It takes no other actions; it&#39;s the control plane&#39;s job to notice this event and do something about it, e.g. sending SNMP traps so someone in a NOC can investigate.</p>
<p>I don&#39;t know how many <em>TTLs</em> get <em>Exceeded</em> these days, but even if a router sees tons of them every day, there&#39;s nothing it can do to fix the problem, and sending TTL Exceeded is a <em>MAY</em>, not a <em>MUST</em>, so no vendor is going to spend an extra $100,000 to design circuitry to generate and return those responses. That means that any packet that runs out of TTL will have to get forwarded to the control plane, which will decide if and when to send a response.</p>
<p>It goes without saying that the control plane is a very busy little bee. It&#39;s bad enough that it has to handle all the &#34;exceptions&#34;, which are going to be <em>plentiful</em> in a carrier network with millions of hosts passing through it, but it <em>also</em> has to handle any actual self-destined traffic.</p>
<p>In addition to the millions of hosts that an internet router has to arbitrate between, it also has its own IP addresses, which people rudely try to interact with all day long. When you ping a router, you&#39;re making that poor little 600MHz ARM chip find time to deal with your traffic, <em>not</em> the terabit-per-second monster that it&#39;s married to. Same goes for SNMP queries, regular config backups, and other forms of management access.</p>
<p>Other than traceroute, <em>TTL Exceeded</em> serves very little purpose in the modern world, and with traceroutes being such a tiny percentage of traffic, it is perfectly reasonable for network admins to not care if it works or not. When you put all this together, it becomes apparent that most network providers are never going to spend a second thinking about this.</p>
<p>You can easily confirm this is true. Run a traceroute... anywhere. Yahoo dot com. You will see nodes that never respond, 9 times out of 10.</p>
<h3>The Worst Diagnostics In The World</h3>
<p>I cannot even guess how many times I have seen network techs see one hop not respond and say &#34;well it looks like hop 5 is down, so that&#39;s your problem,&#34; even though hop 6 is responding.</p>
<p>It is impossible for me to imagine how they think the internet works, but they&#39;re playing against a stacked deck, because traceroute is just <em>the worst diagnostic tool imaginable.</em></p>
<p>A good tool gives you a go, a no-go, or information. That is, it tells you something is working, or broken, or provides data you can interpret.</p>
<p>Traceroute does provide a single &#34;go&#34; outcome: If you see a trace get <em>all the way through to the last node</em>, well, okay, that&#39;s a success. The path is probably fine.</p>
<p>However, it also only provides a single &#34;no-go&#34; outcome, and it&#39;s not the one people think. Lack of response from hosts is not a failure. The <em>sole</em> failure you can identify reliably from traceroute is a network loop. If you see the same pair of nodes respond over and over, then you have a loop.</p>
<p>...and that information is almost completely useless, because this is the exact problem that TTL Exceeded is meant to diagnose, so you can just use it as intended. Just ping the target, and you&#39;ll see a TTL Exceeded response from one of the two routers that is looping the packet, identifying the failure point. Admittedly, traceroute does tell you <em>both</em> of those names, which is convenient.</p>
<p>Inadvertent routing loops are incredibly rare however, and 99% of the ones that I have seen were actually caused by network interfaces being down, and would have been discovered and resolved through ordinary, thorough network review.</p>
<p>As far as information? Well, read the presentation. The information provided by traceroute is limited, objectively incorrect and misleading in many cases, and fiendishly hard to interpret.</p>
<p>Lack of response from a node means nothing.</p>
<p>Even if <em>all</em> the nodes past a certain point aren&#39;t responding, <em>that also means nothing.</em></p>
<p>If the nodes have high latency, <em>that also means nothing.</em></p>
<p>If they respond on some probes and not others, <em>that also means nothing.</em></p>
<p><em>Nothing you see in a traceroute means anything, because it is all accidental.</em></p>
<p>You are sending a packet through a network that <em>did not plan for it</em>. Nobody has taken steps to ensure your traceroute should succeed. There are no &#34;Traceroute&#34; checkboxes or statements in router configs. There&#39;s a really spicy reason for that, too: Traceroute does not even meet the most minimal definitions of a network protocol.</p>
<p>It&#39;s not a special kind of ICMP message, or a UDP or TCP packet that uses a defined port. You cannot &#34;permit traceroute&#34; in a firewall, because it has no standard characteristics. A lot of people think traceroute sends pings - this is an option, but never the default behavior AFAIK.</p>
<p>By default, traceroute simply sends <em>a gibberish UDP packet on a random pair of ephemeral ports.</em> The entire point is to be thrown away before a host even gets a <em>chance</em> to consume it, so the contents are irrelevant.</p>
<p>That means that if you were <em>trying</em> to prepare a network to handle traceroute, you wouldn&#39;t be able to. From a network perspective, traceroute does not exist.</p>
<p>It&#39;s simply an exploit, a trick someone discovered, so it&#39;s to be expected that it has no defined qualities. It&#39;s just random junk being thrown at a host, hoping that everything along the paths responds in a way that they are <em>explicitly not required to.</em> Is it any surprise that the resulting signal to noise ratio is awful?</p>
<h3>So What Does All This Mean</h3>
<p>It means that you can&#39;t run a traceroute unless you <em>know what you expect to see.</em></p>
<p>When you&#39;re tracing inside a network that you control - such as a large enterprise WAN, multiple sites connected with VPNs, or an ISP that you work for - you can guess what each hop will look like, or at least look at the results and suss out whether they looks like they &#34;should.&#34;</p>
<p>If you trace from, say, a server at one business location to one at another, you might see your local prem router, then a network edge router, a few core routers, another edge and then another prem router.</p>
<p>From this you can guess, pretty reliably, that you made it all the way to the destination, but either had trouble reaching the specific host (investigate the local router/firewall) or that the host is ACLed or doesn&#39;t send ICMP responses (do packet captures on the host.)</p>
<p>If you&#39;re tracing through a network you don&#39;t control, you have <em>no idea</em> how it&#39;s supposed to work. If you&#39;re a seasoned network tech who&#39;s seen some shit (and, ideally, worked on provider-scale networks) then you can run a traceroute over an unknown network and <em>maybe, possibly,</em> suss out something, but there are no guidelines, it&#39;s pure gut feeling: <em>does this look right?</em></p>
<p>If you aren&#39;t that experienced however, you should avoid it, because you are not immune to propaganda. When you see high latency, hops not responding or whatever, that information will stick in your head. Despite your best efforts, it will affect the course of your troubleshooting even though you would not be able to say, if asked, what those results <em>meant</em> and what should be <em>done with them.</em></p>
<p>As a diagnostician, you should ask yourself one question before performing any test: <em>&#34;What would I do if the outcome was x? And what if it was y?&#34;</em></p>
<p>Can you fill in x and y? Can you answer either question? If not - why run the test?</p>
<p>And if you <em>do</em> run the traceroute anyway, <em>god forbid</em> you mention it to someone else. Do not write down the results unless you think you actually know what they mean, because no matter how offhandedly you do it, whoever comes across it is <em>guaranteed</em> to see it as a lifeline.</p>
<p>Network techs are mostly incompetent. It is a sad truth, and it&#39;s not their fault. People get pressed into jobs that they are told are far less complicated than they actually are. It has been my experience that <em>easily</em> 75% of people working networking jobs are operating in a state of absolute terror, trying to keep their head above water with problems they don&#39;t really understand at all.</p>
<p>If you say &#34;hop five isn&#39;t responding,&#34; congratulations - you just identified &#34;the cause of the problem&#34; as far as all those folks are concerned, and there&#39;s no way to get that piss out of the pool.</p>
<p>Whoever you said it in front of is going to refuse, <em>aggressively</em>, to do a lick of additional troubleshooting until &#34;hop five&#34; starts responding. If that&#39;s clearly a node that nobody on the conf call or email thread has access to, then everyone&#39;s going to throw up their hands and say &#34;Well I Guess We Just Have To Hope It Starts Working.&#34; I have seen this countless times.</p>
<p>It happens because, fundamentally, troubleshooting networks <em>sucks.</em></p>
<p>If you don&#39;t have total control of the entire path, end to end, with admin access <em>and</em> expertise on every node along the way, there is no way to get a complete picture of what&#39;s going on. That kind of access is extremely rare; you&#39;re probably a high-ranking network architect if you have it; and <em>even with all that access</em> there are still plenty of cases where you simply cannot see what&#39;s wrong, because it&#39;s happening either too fast, or in a place that&#39;s impossible to inspect.</p>
<p>As a result, networking is full of superstition. People casting spells, executing words of power, trying to read tea leaves and declaring that the end times are coming, not because the hard info isn&#39;t available, but because it&#39;s incredibly difficult to obtain and interpret.</p>
<h3>The Thanksgiving Uncle Problem</h3>
<p>Read the presentation. It does a better job than this messy post at illustrating the problem. Even if you don&#39;t understand networking, by the time you&#39;re done, you will be convinced that this is too complicated for <em>most people</em>, full stop. There are just too many unknowns.</p>
<p>You will hate me for making you read this. You will regret it, because you will now be the only person in every conversation who understands these things, and the knowledge is damning. You will have to sit, silently, as everyone around you makes egregious errors in diagnostics that lead them down completely incorrect paths. This is the <em>Thanksgiving Uncle Problem.</em></p>
<p>That&#39;s the situation where you, a gay leftist, go to Thanksgiving dinner with the family, and a shitty uncle sits across from you and begins telling lies about society, about people of color, about gay marriage, and so on. If you&#39;re self-destructive, you engage him. It will not go well.</p>
<p>The reason for this is that, in order for him to accept <em>anything</em> you say, he needs to accept that many of his foundational beliefs about the world are wrong. Ideas like &#34;the police protect us&#34; and &#34;children need a mom and a dad&#34; have been part of his worldview for so long that he has, without question, made <em>millions</em> of decisions based on these assumptions.</p>
<p>In order for him to discard them, he has to admit that he has been making a fool of himself, doing incredibly wrong and often <em>harmful</em> things, for his entire life. That is too much guilt to handle, and he - and most people - will do anything possible to avoid accepting it. Certainly, this is not a door he&#39;s willing to open when he&#39;s on his fourth mimosa and doing his best not to think about the goddamn insurance adjuster job he has to go back to on Monday.</p>
<p>So you will read this slideshow, and then you will sit on conference calls thinking, &#34;My god. They are all wrong. And they&#39;ve always been wrong. And <em>I can&#39;t help them,</em> because they will fight me tooth and claw to continue being wrong.&#34;</p>
<p>I have no advice on how to deal with this, but it&#39;s better to be correct than to be comfortable.</p>
<p><small>Footnote: Ironically, it seems very possible to me that the systems that most consistently enable this are the cheapest routers on the market. Every single home &#34;gateway&#34; ever sold runs Linux, where the ICMP implementation is a core kernel feature, not a user provided daemon.</small></p><small>
<p>I would not be surprised at all if the Linux kernel devs actually <em>have</em> made sure that TTL Exceeded is implemented and enabled by default - and since most Linux-based routers do everything in pure software, there is no data/control plane split to worry about, so sending an Exceeded is more or less &#34;free.&#34;</p>
</small><p><small>This would only make a difference for traceroute if Linux was used for anything other than the cheapest endpoint routers, but it&#39;s still very funny.</small></p>
<hr/>
<h2>Addendum #1</h2>
<p>I reviewed that slide deck again and learned that I conflated a couple concepts.</p>
<p>Yes, the control plane <em>may</em> be responsible for handling exceptions, including ICMP generation, but it is apparently more likely (at least, at the scale of equipment that I am discussing) that the data plane has a <em>fast path</em> and <em>slow path</em>, both located in the data plane, and the slowpath is responsible for handling this work. The control plane, in such a device, <em>only</em> handles data destined to the router&#39;s own IP.</p>
<p>However, the slowpath is (per Richard Steenbergen, the author of that presentation; we will trust his research is valid) <em>still</em> a general-purpose CPU instead of custom silicon, so functionally, the point I was making is still valid: There is a very slow computer handling these packets.</p>
<p>Steenbergen uses this fact to make the point that, because these slow-path CPUs <em>are</em> so slow, they are usually rate-limited. Yes, this means that <em>some number of TTL Exceeded messages will simply be thrown away, even if they are enabled.</em></p>
<p>The example given is that a handful of users running MTR (do not get me started on this bastard program) can actually hit this rate limit. This is an outstanding example because I have seen something similar in practice.</p>
<p>Consider what that would look like, and how common it would be: If you have a NOC full of people who think they know what they&#39;re doing, but don&#39;t, that only enhances the probability that everyone is trying to troubleshoot on their own instead of doing a screenshare and coordinating their efforts - thus, you have six guys running MTR to the same IP.</p>
<p>If they hit that rate limit, what do they see? Nodes suddenly not responding! Randomly, in fact - sometimes responding, sometimes not! That means it&#39;s not just a hop that doesn&#39;t respond to traceroutes, but <em>packet loss!</em> Wow! We found the problem!</p>
<p>Of course, if four of them hit Ctrl+C, the PL would mysteriously vanish. Huh! Weird! Well, it must be an intermittent issue in <em>squints at resolved hostname</em> Hurricane Electric&#39;s network. I&#39;m <em>sure</em> they have a flapping port they haven&#39;t noticed (lol.) Just send them a trouble ticket!</p>
<p>By the time this useless waste of effort has resolved (e.g. HE has received, acked, investigated, and declared the ticket No Trouble Found and rejected it) the problem has probably gone away due to unrelated network weather effects. The NOC guys all tell each other that HE was lying about their broken network, slap each other on the back for being smarter than the other bastards, and go out for beers.</p>
<p>How do I know this? Because I&#39;ve been part of it!</p>
<p>My employer used to have an unholy number of customer sites terminated with little Linux shitboxes - you know the sort, they used to be common as dirt. Tiny Soekris-esque SBCs in folded sheet metal boxes with 12V power supplies, running horrible little SoCs and a copy of Busybox from before the fall of Rome. We had reasons for it that I won&#39;t go into.</p>
<p>These things were underpowered to put it mildly. They could route maybe 30 mbps, and if you turned on any firewall functionality that dropped to 10. This was at a time when a <em>tremendous</em> number of customers were on connections no faster than 5 mbps, so, this wasn&#39;t a huge problem. We got rid of them all when bandwidths skyrocketed.</p>
<p>But what used to happen is that you&#39;d have three or four people looking at one of these things at once, and you&#39;d start seeing packet loss. And there you go, the customer has a bad connection. Kick it to the ISP and close the ticket, right?</p>
<p>I can&#39;t count how many times this happened, but I do remember after about four years of doing this, I had come up with a method for getting more accurate latency stats: just ping -i .1. Absolutely <em>hammer</em> the thing with pings while you have the customer test their usual business processes, and it&#39;ll be easier to see latency spikes if something is eating up too much bandwidth.</p>
<p>What I discovered is that running two of these in parallel would produce exactly 50% packet loss, with total reliability. I then tested and found that if I just fired up three or four <em>normal</em> pings, at the default interval, it would do the same thing. 30% or 40% packet loss.</p>
<p>There is no telling how many issues we prolonged because everyone was running their own pings simultaneously and the kernel was getting overloaded and throwing some of them out. This is a snapshot of every network support center, everywhere. It is a bad scene.</p>

	<p><a href="http://tinylogger.com/max/index.html">List of Articles</a></p>

</div>
  </body>
</html>
