<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/">Original</a>
    <h1>The Basics of Vim Regular Expressions</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/regex_basics/gnu_and_vim.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/regex_basics/gnu_and_vim.jpg" alt="Regular expressions using Vim and GNU Grep"/></picture><p>“We should never write regular expressions. They are difficult to learn, understand, and maintain. They can spiral in a wormhole of quantum complexity. We should burn them to the ground!”</p><p>That was Dave, your colleague developer, patronizing you for using a simple regex to parse an HTML file. Even if you don’t like the tone of your colleague, you ask yourself: are regular expressions that bad? Should we use them?</p><p>It’s true that writing regular expressions (also called “regex” or “regexp”) in a codebase can be problematic. Like any bunch of code, they will change overtime, and eventually <a href="https://thevaluable.dev/fighting-software-entropy/">get more and more complex</a>. Also, their conciseness can make them difficult to parse with our poor brain.</p><p>That said, we don’t have to write regexes in a codebase; we can also use them for one-off tasks. You need to find a specific entry in a gigantic pile of logs? You need to replace a specific HTML attribute with another one, whatever its value? Regexes can help you!</p><p>That’s what we’ll focus on in this article: writing regular expressions for different tasks.</p><p>To write regexes, we need tools supporting them; we’ll use mostly Vim here, but also GNU Grep to see the difference between two (similar) regex flavors.</p><p>In this article, we’ll try to answer these questions:</p><ul><li>What are regular expressions for?</li><li>What are metacharacters? Why are they different from the characters we all know and love?</li><li>What are the most common regex engines (also called “regex flavors”) available?</li><li>What are the common metacharacters we can use in our regexes?</li></ul><p>To understand how regular expressions work, we’ll use, throughout this article, <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">this example file</a> you can download and open in Vim (or <a href="https://raw.githubusercontent.com/Phantas0s/the_valuable_dev_companion/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">copy-paste</a> if you want). That way, you won’t read a boring article in the worst passive way, but you’ll be the acting Hero of the Regular Expression Journey™. I’ve written some small exercises you’ll find throughout this article, for you to test your knowledge, and to remember what we speak about.</p><p>Each exercise will have a solution using Vim’s regex engine as well as the PCRE one, using GNU grep (and sometimes the CLI perl when we need to substitute some text). As a result, to follow along, make sure that you have both Vim (or Neovim), GNU Grep, and eventually Perl installed on your computer.</p><p>One of the most important things to keep in mind when creating your regexes: the perfect regex is rarely necessary. Try something good enough to solve your problem, instead of crafting the most general regex for five hours.</p><p>Regexes are not that difficult when you get the hang of it, but there is a lot to cover; that’s why this article will be part of a series of article about regexes, and more specifically regexes in Vim.</p><p>That’s it! We’re now ready to craft our regexes like a Plain Text God©.</p><h2 id="the-goal-of-regular-expressions">The Goal of Regular Expressions</h2><p>The goal of a regex is to match some text to perform some action(s). For example:</p><ul><li>Searching a specific text pattern in a text file.</li><li>Searching and replacing a specific pattern (using the <a href="https://thevaluable.dev/vim-advanced#the-substitute-commands">substitute command</a> <code>:s</code> in Vim, for example).</li><li>Operating on the lines matching a specific pattern (using the <a href="https://thevaluable.dev/vim-advanced#the-global-command">global command</a> <code>:g</code> in Vim, for example).</li></ul><p>That’s why regular expressions are so powerful: they allow us to define abstract text patterns to do what we want to do, effectively and efficiently.</p><h2 id="characters-and-metacharacters">Characters and Metacharacters</h2><p>The simplest regex patterns we can create are composed of characters. In that case, the characters of your pattern will try to match the characters of your text.</p><p>For example, the regex <code>vim</code> will match the three consecutive characters <code>v</code>, <code>i</code>, and <code>m</code> in your text. To search for these characters in Vim, you can first open the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">HTML file provided for this article</a>, and then you can search by running the command <code>/vim</code>. Indeed, Vim’s search support regexes by default.</p><p>But using only characters in a regex force us to know the exact characters (and their order) we want to search for, or act upon. What if we want to match a more general pattern, where we know some characters, but others could be anything and everything?</p><p>It’s where <em>metacharacters</em> become useful. They offer us the mean to match a bunch of characters, even if we don’t know precisely what these characters are.</p><p>For example, if you run <code>/[abc]</code> in Vim, you won’t match the consecutive characters <code>[</code>, <code>a</code>, <code>b</code>, <code>c</code>, and <code>]</code> this time. Instead, you’ll match every single character which is either <code>a</code>, <code>b</code>, or <code>c</code>. The square brackets are metacharacters: they won’t match <code>[</code> or <code>]</code> in our text, but they have a special <em>meaning</em>. The regex engine, which is in charge of interpreting regexes, will understand that we want to use a character class here; more on that later.</p><p>So, metacharacters have a meaning, unlike literal characters we want to match one to one. With metacharacters, we can make our regular expressions more <a href="https://thevaluable.dev/abstraction-type-software-example/">abstract</a>, and, therefore, more general, more suitable for many different possible text patterns.</p><p>You’ll notice that a metacharacter could also be a character we want to match in our text. Said differently, a metacharacter has always its “character counterpart”. For example, what if we don’t want to use these metacharacters <code>[</code> or <code>]</code>, but we really want to match the character <code>[</code> or <code>]</code> in our text? This is a question which can get tricky quickly, so we’ll come back to that.</p><p>This concept of metacharacter is important to understand; we’ll often use the term “characters” and “metacharacters” in this series of articles. If you don’t understand the difference while reading the rest of this article, you can try to come back to this section to clarify your doubts.</p><p>Also, don’t be surprised to find the concept of “atom” in Vim’s help. It’s almost synonym to “metacharacter”, except that it always match one character in the text.</p><div><div><ul><li><code>:help pattern-searches</code></li><li><code>:help atom</code></li></ul></div></div><h2 id="regex-engines">Regex Engines</h2><p>There are many different regex engine (also called “regex flavors”) out there. As we saw above, these engines interpret the different metacharacters of a regex. That is, depending on the engine you’re using, you won’t have the same metacharacters available. The meaning of the different metacharacters can also be different from one engine to another. To make everything more complicated, regex engines can also have different versions, offering slightly take on their metacharacters.</p><p>But there are islands of hope in this lake of confusion: many regex flavors are based on the Perl regular expression engine. It’s not really a standard, but it’s considered as such by many. That’s why many resources out there will simplify everything by saying that the most used regex engines are all “Perl-style”, or PCRE, for Perl Compatible Regular Expression.</p><p>In fact, PCRE is simply a library written in C; many developers used it to create their own regex engine implementations in different tools or programming languages. That’s why it’s considered as one of the most common regex engine.</p><p>That said, all these “Perl-style” regex engines don’t necessarily have everything PCRE defines. In the case of Vim, its regex engine is not even based on PCRE, but it still has many metacharacters in common with PCRE. Yet, it also has some new, unique metacharacters, and weird quirks.</p><p>What’s important to remember: it’s not because a regex works as expected in your tool of choice that it will work the same way in another tool. Look at the specifics of the regex flavors you’re working with, and adjust your regexes accordingly.</p><p>In this article, we’ll mostly see the basics of regex in Vim. To show the differences with a “Perl-style” regex engine, all the solutions of the exercises are also using GNU Grep with its PCRE engine. It will give you the general knowledge for you to be able to work with most regex engines out there.</p><h2 id="vim-regex-engine-or-the-escaping-hell">Vim Regex Engine or the Escaping Hell</h2><p>Vim regex’s flavor is based on an old engine from the equally old “ed”, the <a href="https://www.gnu.org/fun/jokes/ed-msg.en.html" target="_blank" rel="noopener">standard</a> editor. This engine was created even before PCRE was a thing, and, therefore, it has some specificities you won’t find anywhere else.</p><p>If you look at some Vim regexes online, the most obvious oddity will jump at your face: they have many escaped characters. For example, if you want to use both parentheses “(” and “)” as metacharacters for grouping (we’ll see what it means below in this article), you’ll need to escape them: “(” will become “(” and “)” will become “)”.</p><p>Do you think it’s annoying? I do. Especially since not every character need to be escaped to get its metacharacter counterpart, only some of them. Speaking of inconsistencies! Who wants to learn by heart what should be escaped and what shouldn’t? Not me, not Dave (your colleague developer), and maybe not you.</p><p>There is a “magic” way to go around this weird quirk however, to get a more consistent behavior. We need to use <code>\v</code> at the beginning of our regexes. This stands for “very magic”. What? Are we magicians, now? Well, maybe you always have been, deep inside.</p><p>We’ll look more in depth at this concept of “magic” in the second article of this series. For now, just remember this: with the “very magic” <code>\v</code> at the beginning of a regex pattern, every character which can be a metacharacter will be a metacharacter. If you need to match the character itself, and not using the metacharacter, you’ll need to escape it. In every case.</p><p>For example, if I want to use the metacharacters <code>(</code> and <code>)</code>, I can simply run the following in Vim:</p><div><pre><code data-lang="vim">/\<span>v</span><span>(</span><span>whatIsearch</span><span>)</span><span>
</span></code></pre></div><p>Here, the parentheses are metacharacters (we’ll see what they mean later). On the other hand, if I want to match the characters <code>(</code> and <code>)</code> in my text, I’ll need to escape them with a backslash <code>\</code>:</p><div><pre><code data-lang="vim">/\<span>v</span>\<span>(</span><span>someContent</span>\<span>)</span><span>
</span></code></pre></div><p>We’ll always use the “very magic” <code>\v</code> before each pattern in this article if they contain any metacharacter, for the sake of consistency.</p><p>Last important point: to look at Vim’s help for a specific metacharacter, you’ll often have to prefix it with the search symbol <code>/</code>, and then the metacharacter you want to look at. Sometimes, you’ll also need to escape it! I included the different help commands you can run in Vim to find these metacharacters throughout the article, so you’ll see what I’m talking about.</p><h2 id="common-metacharacters">Common Metacharacters</h2><p>Let’s now look at the common metacharacters we can use to create our awesome regular expressions. This section is meant to be pretty general; you’ll have access to these metacharacters in most regex engines, including Vim. A general knowledge about these metacharacters will help you tremendously if you need to manipulate plain text. You know, like a developer searching a specific pattern in a mountain of delicious XML. It can also be very useful for writers.</p><p>If you use often use a shell (or if you want to), many CLIs support regexes, too.</p><h3 id="the-full-stop">The Full Stop</h3><p>The full stop “.” might be the easiest metacharacter to understand: it represents any character. For example, what would you do if you wanted to match the characters <code>vim</code> and the character that directly follows, whatever this character is? This will be our first exercise; you can use Vim’s search to solve it, or/and GNU Grep with the option <code>-P</code> to use its PCRE engine. Searching in the file <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example.html</a> will give you a couple of matches.</p><div id="toggle-1"><p><label for="toggle-input-1">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>vvim</span>.<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;vim.&#39;</span> example.html
</code></pre></div><p>With this regex, you’ll match “vim” followed by any character. If you search in the file <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html">example.html</a>, the regex will match <code>vim-</code> or <code>vim_</code> for example. It also matches substring: the characters “vim)” from “Neovim)” will be matched.</p></div></div><div><p><code>:help /\.</code></p></div><h3 id="character-classes">Character Classes</h3><p>It’s nice to have the full stop to match any character, but you’ll often want to match some <em>specific</em> characters, not all of them. Character classes (also called character sets) are great for that.</p><h4 id="general-concept">General Concept</h4><p>A character class represents only one character (like the full stop) from a specific set of characters. To create this set, you need to use the metacharacters <code>[</code> followed by the character(s) you want to include. To close the set, use <code>]</code>.</p><p>For example, if you want to search and match the characters “v”, “i”, or “m”, you can run the following in Vim:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>vim</span>]<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[vim]&#39;</span> example.html
</code></pre></div><p>Keep in mind that a character class always represent <em>one</em> character from a set, whatever the number of characters there is in the set. That’s why our example matches the characters <code>v</code>, <code>i</code>, or <code>m</code>, whether or not they are consecutive characters. That’s also why, when you hit <code>n</code> or <code>N</code> in vim, you’ll jump from one character to another, not from one word <code>vim</code> to another. Another consequence of this fact: the order of characters in your character class doesn’t matter. The following also works:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>ivm</span>]<span>
</span></code></pre></div><h5 id="ranges">Ranges</h5><p>Some characters are metacharacters inside the square brackets, and only inside them. The hyphen <code>-</code> is one of them. If you search for it, it will match the character <code>-</code>, as follows:</p><div><pre><code data-lang="vim">/\<span>v</span><span>-</span><span>
</span></code></pre></div><p>No metacharacters here. But inside the character class, the hyphen represents a range, if and only if it’s surrounded by two other characters. These two characters are the beginning and the end of the range. For example:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>a</span><span>-</span><span>z</span>]<span>
</span></code></pre></div><p>This regex will match a character ranged from <code>a</code> to <code>z</code> included. Said differently, it will match all lowercase letters.</p><p>If the hyphen is not surrounded by two characters, it won’t be a metacharacter. For example, <code>/[a-]</code> and <code>/[-z]</code> will match the characters “a” or “-”, and “-” or “z”, respectively.</p><p>Now, how would you match all uppercase characters from the alphabets? What about matching all numbers from 0 to 9? How would you match both ranges?</p><div id="toggle-2"><p><label for="toggle-input-2">Click to see the solution</label>
</p><div><p>To match all uppercase letters:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>A</span><span>-</span><span>Z</span>]<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[A-Z]&#39;</span> example.html
</code></pre></div><p>To match all numbers from 0 to 9:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>0-9</span>]<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[0-9]&#39;</span> example.html
</code></pre></div><p>To match both ranges:</p><div><pre><code data-lang="vim">/\<span>v</span>[<span>0-9</span>A<span>-</span><span>Z</span>]<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[0-9A-Z]&#39;</span> example.html
</code></pre></div><p>The order doesn’t matter; <code>/\v[A-Z0-9]</code> works too, for example.</p></div></div><h5 id="negated-character-classes">Negated Character Classes</h5><p>The hyphen is not the only metacharacter which is exclusive to the character class. You can also use the caret <code>^</code> after the opening squared brackets <code>[</code> to negate the character class. That is, instead of saying “I want to match these characters”, you’re saying “I want to match every character <em>except</em> these characters”.</p><p>This is exactly what the following does:</p><div><pre><code data-lang="vim">/\<span>v</span>[^<span>abc</span>]<span>
</span></code></pre></div><p>The order is important here: to act as metacharacter, the caret <code>^</code> needs to be placed just after the opening square bracket <code>[</code>. The regex <code>[a^bc]</code> is not equivalent to the one above, for example.</p><p>I’ve a question I always wanted to ask you: how would you match any character, except the cursed characters <code>e</code>, <code>m</code>, <code>a</code>, <code>c</code>, and <code>s</code>?</p><div id="toggle-3"><p><label for="toggle-input-3">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span>[^<span>smeca</span>]<span>
</span></code></pre></div><div><pre><code data-lang="vim"><span>grep</span> <span>-</span><span>P</span> <span>&#39;[^smeca]&#39;</span> <span>example</span>.<span>html</span><span>
</span></code></pre></div><p>You can put the letters in any order, the result will be the same. Always put the character <code>^</code> after the opening bracket of the character class, however. Do I repeat myself? Yes, but it’s for our own good.</p></div></div><h4 id="shorthand-classes">Shorthand Classes</h4><p>It can be quite tedious to write all the possible ranges we want in our regexes. Luckily, there are also a bunch of <em>shorthand classes</em> we can use.</p><p>We’ll see here the most general shorthands; Vim has many more under its sleeves. We’ll see them in the next article of this series, focusing on Vim specifically. For now, here are the shorthands you can try out:</p><table><tbody><tr><th>Character class</th><th>Description</th><th>Equivalent</th></tr><tr><td><code>\s</code></td><td>Whitespace characters</td><td><ul><li></li></ul></td></tr><tr><td><code>\d</code></td><td>Digits from 0 to 9</td><td>[0-9]</td></tr><tr><td><code>\w</code></td><td>Word characters</td><td>[0-9A-Za-z_]</td></tr></tbody></table><p>The uppercase version of these shorthands can be used to negate the character class. For example, to include everything except digits in your character class, we can use <code>\D</code>, which is equivalent to <code>[^0-9]</code>.</p><p>We can also use these common <a href="https://en.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a> character classes:</p><table><tbody><tr><th>Character class</th><th>Description</th><th>Equivalent</th></tr><tr><td><code>[:alnum:]</code></td><td>Uppercase and lowercase letters, as well as digits</td><td><code>A-Za-z0-9</code></td></tr><tr><td><code>[:alpha:]</code></td><td>Uppercase and lowercase letters</td><td><code>A-Za-z</code></td></tr><tr><td><code>[:digit:]</code></td><td>Digits from 0 to 9</td><td><code>0-9</code></td></tr><tr><td><code>[:lower:]</code></td><td>Lowercase letters</td><td><code>a-z</code></td></tr><tr><td><code>[:upper:]</code></td><td>Uppercase letters</td><td><code>A-Z</code></td></tr><tr><td><code>[:blank:]</code></td><td>Space and tab</td><td><code>[ \t]</code></td></tr><tr><td><code>[:punct:]</code></td><td>Punctuation characters (all graphic characters except letters and digits)</td><td><ul><li></li></ul></td></tr><tr><td><code>[:space:]</code></td><td>Whitespace characters (space, tab, new line, return, NL, vertical tab, and form feed)</td><td><code>[ \t\n\r\v\f]</code></td></tr><tr><td><code>[:xdigit:]</code></td><td>Hexadecimal digits</td><td><code>A-Fa-f0-9</code></td></tr></tbody></table><p>Let’s do our usual exercises to keep our athletic shape. Using the shorthands described above, how would you:</p><ul><li>Search for dates with the format “2022-01-01”?</li><li>Search for three characters: an uppercase letter, followed by two lowercase ones?</li></ul><div id="toggle-4"><p><label for="toggle-input-4">Click to see the solution</label>
</p><div><p>To search for the date:</p><div><pre><code data-lang="vim">/\<span>v</span>\<span>d</span>\<span>d</span>\<span>d</span>\<span>d</span><span>-</span>\<span>d</span>\<span>d</span><span>-</span>\<span>d</span>\<span>d</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;\d\d\d\d-\d\d-\d\d&#39;</span> example.html
</code></pre></div><p>For the uppercase and lowercase letters:</p><div><pre><code data-lang="vim">/\<span>v</span>[[:<span>upper</span>:]][[:<span>lower</span>:]][[:<span>lower</span>:]]<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[[:upper:]][[:lower:]][[:lower:]]&#39;</span> example.html
</code></pre></div><p>We need here to create three character classes here, one for each character.</p></div></div><div><div><ul><li><code>:help /\[]</code></li><li><code>:help whitespace</code></li><li><code>:help [:alnum:]</code></li></ul></div></div><h3 id="quantifiers">Quantifiers</h3><p>We’ve seen how to match a single character using different metacharacters, like the full stop or character classes. What about matching multiple time the same character?</p><p>For example, let’s say that we want to search for every year in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example file</a>. A year is a number with four digits; we could do the following:</p><div><pre><code data-lang="vim">/[<span>0-9</span>][<span>0-9</span>][<span>0-9</span>][<span>0-9</span>]<span>
</span></code></pre></div><p>It works, but it’s quite verbose. Imagine if we want to replace a full datetime in a file! We would need to spawn character ranges until our fingers are on fire.</p><p>We could improve it by using the shorthands we’ve already seen, but we still need to repeat them a couple of times.</p><div><pre><code data-lang="vim">/\<span>d</span>\<span>d</span>\<span>d</span>\<span>d</span><span>
</span></code></pre></div><p>It’s a good use case for <em>quantifiers</em>. They allow us to match multiple times the character preceding them. Here’s a list of these quantifiers:</p><table><tbody><tr><th>Metacharacter</th><th>Description</th></tr><tr><td><code>*</code></td><td>Matches the preceding (meta)character 0 or more time.</td></tr><tr><td><code>+</code></td><td>Matches the preceding (meta)character 1 or more time.</td></tr><tr><td><code>=</code></td><td>Matches the preceding (meta)character 0 or 1 time.</td></tr><tr><td><code>{n,m}</code></td><td>Matches the preceding (meta)character from n to m times.</td></tr><tr><td><code>{n}</code></td><td>Matches the preceding (meta)character exactly n times.</td></tr><tr><td><code>{,m}</code></td><td>Matches the preceding (meta)character from 0 to m.</td></tr></tbody></table><p>Note that the quantifier <code>=</code> doesn’t exist in the PCRE world.</p><p>Now that you have The Knowledge™, can you rewrite our regular expression to find the years composed of four digits?</p><div id="toggle-5"><p><label for="toggle-input-5">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span>[<span>0-9</span>]{<span>4</span>}<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;[0-9]{4}&#39;</span> example.html
</code></pre></div><p>Using a shorthand for more swag:</p><div><pre><code data-lang="vim">/\<span>v</span>\<span>d</span>{<span>4</span>}<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;\d{4}&#39;</span> example.html
</code></pre></div></div></div><p>Here’s another exercise: can you replace every single year in the file by “2023”, using a regular expression with a quantifier?</p><div id="toggle-6"><p><label for="toggle-input-6">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim"><span>:</span>%<span>s</span><span>/\v\d{4}/</span><span>2023</span><span>
</span></code></pre></div><p>We use here the <a href="https://thevaluable.dev/vim-advanced#the-substitute-commands">substitution command</a>, allowing us to use regular expressions to match what we want to replace.</p><p>If you have Perl installed, you can run PCRE substitution in your shell, as follows:</p><div><pre><code data-lang="bash">perl -pe <span>&#39;s/\d{4}/2023/g&#39;</span> example.html
</code></pre></div><p>It will output the whole file after the substitution. We can also pipe the above to Grep with the replacement pattern, to only output what was replaced:</p><div><pre><code data-lang="bash">perl -pe <span>&#39;s/\d{4}/2023/g&#39;</span> example.html <span>|</span> grep <span>2023</span>
</code></pre></div></div></div><p>Another exercise: using shorthands, how would you match a date of the format “2022.01”, with any number of digits (from 1 to infinity) after the dot character <code>.</code>?</p><div id="toggle-7"><p><label for="toggle-input-7">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span>\<span>d</span>{<span>4</span>}\.\<span>d</span><span>+</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;\d{4}\.\d+&#39;</span> example.html
</code></pre></div><p>We need to escape the dot character <code>.</code> here: we want to match the character, not using the metacharacter. You can try not to escape the dot to see the difference.</p></div></div><div><p><code>:help /multi</code></p></div><h3 id="grouping-and-backreference">Grouping and Backreference</h3><p>Grouping can be useful to repeat different characters using a group and a quantifier, and backreferencing our groups can also be useful to get part of the search pattern and add it to the replacement pattern, when we do some substitutions.</p><h4 id="grouping">Grouping</h4><p>We’ve looked at quantifiers above: they are applied to the character (or metacharacter) just before it. What if we want to apply them on multiple different characters? It’s where grouping can be useful.</p><p>Let’s say that we want to find all the datetimes composed of the digits and characters “00:00:”. We can see that the pattern <code>00:</code> is repeated two times, so we can use a group with a quantifier as follows:</p><div><pre><code data-lang="vim">/\<span>v</span><span>(</span><span>00</span>:<span>)</span>{<span>2</span>}<span>
</span></code></pre></div><p>I’ve terrible news! The HTML of our file <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example.html</a> is incorrect: there are some divs which are empty and never closed!</p><p>Using a quantifier with a group, how would you match the characters <code>&lt;div&gt;&lt;div&gt;</code>? How would you delete them?</p><div id="toggle-8"><p><label for="toggle-input-8">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span><span>(</span>\<span>&lt;</span><span>div</span>\<span>&gt;)</span>{<span>2</span>}<span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;(&lt;div&gt;){2}&#39;</span> example.html
</code></pre></div><p>In Vim, the characters ‘&lt;’ and ‘&gt;’ can be used as <em>metacharacters</em> for word boundaries; we’ll see them below in this article. Here, we want to match the <em>characters</em> ‘&lt;’ and ‘&gt;’, so we need to escape them. Notice that word bounderies use different metacharacters in the PCRE engine; that’s why we don’t need to escape <code>&lt;</code> and <code>&gt;</code> with Grep.</p><p>We can delete these aberrations as follows:</p><div><pre><code data-lang="vim"><span>:</span>%<span>s</span>/\<span>v</span><span>(</span>\<span>&lt;</span><span>div</span>\<span>&gt;)</span>{<span>2</span>}<span>
</span></code></pre></div><div><pre><code data-lang="bash">perl -pe <span>&#39;s/(&lt;div&gt;){2}//&#39;</span> example.html
</code></pre></div></div></div><h4 id="backreference">Backreference</h4><p>What if we only want to replace the first two digits of a date? How to match the whole date pattern, but only replacing a part of it? It’s where grouping and backreferences come in handy.</p><p>Again, to search and replace in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">HTML file</a>, let’s use the substitution command in Vim.</p><p>First, we need to create one or more group in the search pattern. Then, we can refer to these groups in the replacement pattern, using the metacharacters <code>\1</code> to <code>\9</code>. The first group can be referenced using <code>\1</code>, the second one with <code>\2</code>, and so on.</p><p>For example, here’s how you would replace the first two digits of our years:</p><div><pre><code data-lang="vim"><span>:</span>%<span>s</span><span>/\v\d\d(\d\d)/</span><span>19</span>\<span>1</span><span>
</span></code></pre></div><p>Let’s look at the replacement pattern <code>19\1</code>. We replace here the whole four-digits number <code>\d\d(\d\d)</code> with only <code>19</code>, and then we do a backreference <code>\1</code> to our first (and only) group, effectively concatenating the two last digits captured by the group to the replacement pattern <code>19</code>.</p><p>This is tricky to explain, so let’s try to solve another problem. How would you replace the value of every HTML attribute <code>style</code> with <code>text-align: left</code> ?</p><p>Here’s a tip: before substituting anything, you can first try your regex by using Vim search, to see if everything works as expected. If it does, then you can try to substitute what you want to substitute. It’s more difficult to see the mistakes in your regex if you substitute everything directly.</p><div id="toggle-9"><p><label for="toggle-input-9">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim"><span>:</span>%<span>s</span><span>/\v(style\=&#34;).+&#34;/</span>\<span>1</span>text<span>-</span><span>align</span>: <span>left</span>&#34;<span>
</span></code></pre></div><p>We can also use Perl to do some substitution using the PCRE engine, and pipe it to Grep to only output what we changed:</p><div><pre><code data-lang="bash">perl -pe <span>&#39;s/(style\=&#34;).+&#34;/\1text-align: left&#34;/&#39;</span> example.html <span>|</span> grep <span>&#39;style=&#39;</span>
</code></pre></div></div></div><div><p><code>:help /\(</code></p></div><h3 id="anchors">Anchors</h3><p>Metacharacters are not only meant to match one or multiple characters. We can also match <em>positions</em>. In that case, you don’t include characters in the match; instead, you want your match to target a specific position. Because of that, these metacharacters are said to have “zero-width”.</p><p>Anchors are part of this kind of metacharacters. Here are the two most common ones:</p><table><tbody><tr><th>Metacharacter</th><th>Description</th></tr><tr><td>^</td><td>Start of the line</td></tr><tr><td>$</td><td>End of the line</td></tr></tbody></table><p>These metacharacters effectively <em>anchor</em> the matches at these positions. Let’s try it: can you match every single HTML tag at the beginning of a line?</p><div id="toggle-10"><p><label for="toggle-input-10">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span>^\<span>&lt;</span>.<span>+</span>\<span>&gt;</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;^&lt;.+&gt;&#39;</span> example.html
</code></pre></div><p>Again, the characters <code>&lt;</code> and <code>&gt;</code> are word boundaries metacharacters in Vim, but not in the PCRE engine.</p></div></div><p>We can also substitute anchors. In that case, we won’t replace any characters, but insert characters at a given position. It can be interesting to add characters at the beginning of each line, or at the end.</p><p>Here’s an interesting exercise: using Vim’s <a href="https://thevaluable.dev/vim-advanced#the-global-command">global command</a>, how can you delete every empty line in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example file</a>?</p><div id="toggle-11"><p><label for="toggle-input-11">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim"><span>:</span>%<span>g</span><span>/\v^$/</span><span>d</span><span>
</span></code></pre></div><p>The regex <code>^$</code> only match lines which have no character between the beginning and the end of the line; they are the empty lines we want to delete. We run the command <code>d</code> (delete) on each of them to… delete them.</p><p>An empty line is not necessarily devoid of characters, however. We could have spaces or tabs between the beginning and the end of the line. If we also want to delete these lines, we could run the following:</p><div><pre><code data-lang="vim"><span>:</span>%<span>g</span><span>/\v^[[:space:]]*$/</span><span>d</span><span>
</span></code></pre></div><p>All the lines composed only of 0 or more whitespaces (including spaces and tabs) will be deleted.</p></div></div><div><div><ul><li><code>:help /^</code></li><li><code>:help /$</code></li><li><code>:help /zero-width</code></li></ul></div></div><h3 id="word-boundaries">Word Boundaries</h3><p>Word boundaries are another good example of zero-width metacharacters. Let’s first try to search for “vim” in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example file</a> by running the following command in Vim:</p><div><pre><code data-lang="vim">/<span>vim</span><span>
</span></code></pre></div><p>You’ll notice that you’ll match all the words “vim”, but also the substring “vim” in “Neovim”. What if we don’t want to match any substring, that is, we only want to match the <em>word</em> “vim”?</p><p>It’s where word boundaries are useful. Using the PCRE flavor, you can use the metacharacter <code>\b</code> as follows:</p><div><pre><code data-lang="bash">grep -P <span>&#39;\bvim\b&#39;</span> example.html
</code></pre></div><p>Vim uses a different syntax. To mark the boundaries of our words, we need to use the metacharacter <code>&lt;</code> at the beginning, and the metacharacter <code>&gt;</code> at the end. For example, to search for the word “vim” in Vim (excluding the substring “vim”):</p><div><pre><code data-lang="vim">/\<span>v</span><span>&lt;</span><span>vim</span><span>&gt;</span><span>
</span></code></pre></div><p>By the way, how would you match the word ‘of’ (but not the substring ‘of’) in our example file?</p><div id="toggle-12"><p><label for="toggle-input-12">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span><span>&lt;</span><span>of</span><span>&gt;</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;\bof\b&#39;</span> example.html
</code></pre></div></div></div><div><p><code>:help /\&lt;</code></p></div><h3 id="alternations">Alternations</h3><p>The metacharacter <code>|</code> allows us to match multiple regexes at once. For example, if we want to match <code>class</code> and <code>href</code>, we can do the following:</p><div><pre><code data-lang="vim">/\<span>vclass</span><span>|</span><span>href</span><span>
</span></code></pre></div><p>How would you match, using Vim’s search, the HTML class “la” (and not the substring “la”), as well as the class “la-twitter”? You shouldn’t match any other class beginning with “la” and followed by a dash “-”.</p><div id="toggle-13"><p><label for="toggle-input-13">Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>v</span><span>&lt;</span><span>la</span><span>&gt;</span>[^<span>-</span>]<span>|</span><span>la</span><span>-</span><span>twitter</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;\bla\b[^-]|la-twitter&#39;</span> example.html
</code></pre></div></div></div><div><p><i></i>Vim help</p><p><code>:help /\|</code></p></div><h3 id="greedy-and-non-greedy-quantifiers">Greedy And Non-Greedy Quantifiers</h3><p>We’ve seen already what’s a quantifier, but we didn’t look at how these quantifiers work; and, trust me, we should care about that.</p><p>Let’s try to search in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/regular-expression-basics-vim-grep/example.html" target="_blank" rel="noopener">example file</a> using Vim, to match all HTML attributes “name” and their values:</p><div><pre><code data-lang="vim">/\<span>vname</span>\<span>=</span><span>&#34;.*&#34;</span><span>
</span></code></pre></div><p>If you look at the 6th line of the file, you’ll see that we’ve match <code>name=&#34;twitter:card&#34; content=&#34;summary_large_image&#34;</code>. Why did we also match the HTML attribute “content” and its value here?</p><p>All the quantifiers we’ve seen until now are “greedy”. To explain what it means, we need to look at how the regex engine is working:</p><ol><li>The engine match the consecutive characters <code>n</code>,<code>a</code>,<code>m</code>, <code>e</code>, and <code>&#34;</code>.</li><li>The engine reaches <code>.*</code>. The star <code>*</code> is a <em>greedy quantifier</em>, so it will match the preceding character (or metacharacter) as much as possible. Here, the preceding metacharacter is a full stop <code>.</code> (matching any character), so it will match every character until the end of the line.</li><li>The engine reaches the last character of the regex, the double quote<code>&#34;</code> in our example. Everything until the end of the line is still matched, so it will backtrack and “un-match” everything until it finds the character <code>&#34;</code>.</li></ol><p>It’s interesting to note that if the greedy quantifier was followed by more characters (instead of a single double quote <code>&#34;</code>), it would backtrack, match everything, and backtrack again for each of them!</p><p>It’s the same for the PCRE engine, and many other flavors. I’m not lying; here, try it for yourself:</p><div><pre><code data-lang="bash">grep -P <span>&#39;name\=&#34;.*&#34;&#39;</span> example.html
</code></pre></div><p>Grep works also line by line, but it’s not the case for every tool. Other ones work on multiple lines; it means that backtracking won’t happen before the match reaches the end of the file. Needless to say that even more content could be matched in that case.</p><p>To solve our problem, we need to use <em>non-greedy quantifiers</em>. In Vim, we’ll need to use the curly brackets notation <code>{}</code>, followed by a hyphen <code>-</code> after the opening bracket.</p><p>This notation might look weird to those who are already familiar with other regex engines. For example, with Perl-style flavors, you need to add a question mark after the quantifier itself to get the non-greedy version. For example:</p><div><pre><code data-lang="bash">grep -P <span>&#39;name=&#34;.*?&#34;&#39;</span> example.html
</code></pre></div><p>Here’s the list of non-greedy quantifiers for Vim, and their greedy counterparts:</p><table><tbody><tr><th>Greedy quantifier</th><th>Non-greedy quantifier</th><th>Description</th></tr><tr><td><code>*</code></td><td><code>{-}</code></td><td>Match the preceding (meta)character 0 or more time.</td></tr><tr><td><code>+</code></td><td><code>{-1,}</code></td><td>Match the preceding (meta)character 1 or more time.</td></tr><tr><td><code>=</code></td><td><code>{-0,1}</code></td><td>Match the preceding (meta)character 0 or 1 time.</td></tr><tr><td><code>{n,m}</code></td><td><code>{-n,m}</code></td><td>Match the preceding (meta)character from n to m times.</td></tr><tr><td><code>{n}</code></td><td><code>{-n}</code></td><td>Match the preceding (meta)character exactly n times.</td></tr><tr><td><code>{,m}</code></td><td><code>{-,m}</code></td><td>Match the preceding (meta)character from 0 to m.</td></tr></tbody></table><p>Now that we have our non-greedy quantifiers for Vim, let’s use them! How would you match the HTML attributes “name”, their values, and their surrounding double quotes?</p><div id="toggle-14"><p><label for="toggle-input-14"><i></i>Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">/\<span>vname</span>\<span>=</span><span>&#34;.{-}&#34;</span><span>
</span></code></pre></div><div><pre><code data-lang="bash">grep -P <span>&#39;name=&#34;.*?&#34;&#39;</span> example.html
</code></pre></div></div></div><p>Another, slightly more complicated exercise: how would you match every HTML attribute “property”, their values, and the surrounding double quotes? Another rule you need to follow: the value should begin by “og:” and be followed by at least one character; this character shouldn’t be a double quote.</p><p>Said differently, your regex should match <code>property=&#34;og:type&#34;</code>, but not <code>property=&#34;og:&#34;</code>.</p><div id="toggle-15"><p><label for="toggle-input-15"><i></i>Click to see the solution</label>
</p><div><div><pre><code data-lang="vim">\<span>vproperty</span>\<span>=</span><span>&#34;og:[^=]{-1,}&#34;</span><span>
</span></code></pre></div><p>First, we use the non-greedy quantifier <code>{-1,}</code>; its greedy counterpart is <code>+</code>.
Second, we don’t use the full stop to match any character, because we don’t want to match any character. We want to match any character <em>except</em> the double quotes. As a rule of thumb, when you want to exclude characters, you need to use a negated character class with the characters you want to blacklist.</p><p>In the PCRE world, we need to use the quantifier “+” followed by a question mark to make it non-greedy:</p><div><pre><code data-lang="bash">grep -P <span>&#39;property=&#34;og:[^=]+?&#34;&#39;</span> example.html
</code></pre></div></div></div><div><p><i></i>Vim help</p><div><ul><li><code>:help non-greedy</code></li><li><code>:help /\{-</code></li></ul></div></div><h2 id="the-regexes-have-been-unraveled">The Regexes Have Been Unraveled</h2><p>Even if the metacharacters you can use (and their meaning) will depend on the regex engine you use, this article stays general enough to give us a good understanding of the very basics of regular expressions in general. So, what are these important generality we should try to remember?</p><ul><li>Regular expressions are powerful to perform some general operations on plain text, using specific text patterns.</li><li>A metacharacter is a character which has a special meaning in a regular expression.</li><li>There are many regex engines (or regex flavors) out there. They are often similar, but they don’t necessarily have the same set of metacharacters. These metacharacters can also have a different meaning.</li><li>The most common type of regex engine is called “Perl-style”, or PCRE.</li><li>Vim follow some of the PCRE standards, but there are many differences too.</li><li>Some characters can be used as metacharacters in a specific context, like the caret <code>^</code> for negating character classes. Outside a character class, the caret has another meaning.</li><li>There are many different ways to represent the same range in a character class: <code>0-9</code> is equivalent to <code>[:digit:]</code>, which is equivalent to <code>\d</code>.</li><li>Vim uses the characters <code>&lt;</code> and <code>&gt;</code> for word boundaries, PCRE uses <code>\b</code> and… <code>\b</code>.</li><li>A greedy quantifier match as many characters as possible (depending on what precede the quantifier), and then backtrack to the characters (or metacharacters) following the quantifier.</li><li>A non-greedy quantifier look up the character (or metacharacter) followed by the quantifier and stop when it’s found, without including as many characters as possible.</li><li>Grouping is useful if you need to repeat more than one character multiple time, by using a quantifier after your group.</li><li>You can also backreference a group. It’s useful if you want to reference a group of characters in a replacement pattern for example.</li><li>There are metacharacters which don’t match any character, but instead match a position. These metacharacters are called ‘zero-width’.</li><li>Anchors are good examples of zero-width metacharacters.</li></ul><p>You can now appreciate the power of regular expressions to quickly isolate some (more or less) general text pattern in your plain text, to replace them, or to perform any action on them. You can use Vim, Grep, or Perl to do so, three powerful tools which can solve quickly your problems.</p><div><p>Related Sources</p><ul><li><a href="https://www.regular-expressions.info/quickstart.html" target="_blank" rel="noopener">Regular-Expressions.info</a></li><li><a href="https://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816" target="_blank" rel="noopener">Comparison of regex flavors</a></li></ul></div></section></article></div></div>
  </body>
</html>
