<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iolanguage.org/guide/guide.html">Original</a>
    <h1>The Io Language</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
            <h2>Introduction<a name="Introduction"></a></h2>

            
                    <h3>Overview</h3><p>



                    Io is a dynamic prototype-based programming language. The ideas in Io are mostly inspired by Smalltalk[1] (all values are objects), Self[2] (prototype-based), NewtonScript[3] (differential inheritance), Act1[4] (actors and futures for concurrency), Lisp[5] (code is a runtime inspectable / modifiable tree) and Lua[6] (small, embeddable).


                    <a name="Introduction-Perspective"></a></p><h3>Perspective</h3>


                    <!-- <h4>Why Another Language?</h4> --><p>

                    The focus of programming language research for the last thirty years has been to combine the expressive power of high level languages like Smalltalk and the performance of low level languages like C. The results have neither been as fast as C or as expressive as Smalltalk. Io&#39;s purpose is to refocus attention on expressiveness by exploring higher level dynamic programming features with greater levels of runtime flexibility combined with simplified programming syntax and semantics.

                    </p><p>

                        In Io, all values are objects (of which, anything can change at runtime, including slots, methods and inheritance), all code is made up of expressions (which are runtime inspectable and modifiable) and all expressions are made up of dynamic message sends (including assignment and control structures). Execution contexts themselves are objects and activatable objects such as methods/blocks and functions are unified into blocks with assignable scope. Concurrency is made more easily manageable through actors and implemented using coroutines for scalability.



                    <a name="Introduction-Goals"></a>
                    </p><h4>Goals</h4><p>



                    To be a language that is:
                    </p><p>

                        simple
                        </p><ul>
                            <li>conceptually simple and consistent
                                </li><li>easily embedded and extended
                        </li></ul><p>
                        powerful
                        </p><ul>
                            <li>highly dynamic and introspective
                                </li><li>highly concurrent (via coroutines and async i/o)
                        </li></ul><p>
                        practical
                        </p><ul>
                            <li>fast enough
                                </li><li>multi-platform
                                    </li><li>unrestrictive BSD/MIT license
                                        </li><li>comprehensive standard packages in distro
                        </li></ul>




                    <h3>Downloading</h3><p>



                        Io distributions are available at:
                        </p><pre><a href="http://iolanguage.org">http://iolanguage.org</a></pre>



                    <h3>Installing</h3><p>
 
 

                    First compile the Io vm:

                    </p><pre>make vm
sudo make install 
</pre>


                    <h4>Addon Dependencies</h4><p> Some of Io&#39;s addons require libraries that may not be installed on your system already. To install these automatically, type either:

                    </p><pre>su -c &#34;sudo make aptget&#34;
</pre><p> or:

                    </p><pre>su -c &#34;make emerge&#34;
</pre><p> or:

                    </p><pre>sudo make port
</pre><p> Depending on which package installer you use. (<a href="http://macports.org">port</a> is for OSX)

                    </p><h4>Compiling All Addons</h4><p> To build, from the top folder, run:

                    </p><pre>make 
</pre><p> Binaries will be placed in the _build/binaries subfolder. To install:

                    </p><pre>sudo make install 
</pre><p> or, if you&#39;d like the install to simply link to your development folder:

                    </p><pre>sudo make linkInstall
</pre><p> and to run all unit tests:

                    </p><pre>make test
</pre><p> Don&#39;t worry if some of the addons won&#39;t build unless it&#39;s a particular addon that you need. Addons are just optional libraries.

                    </p><h4>Compiling an Addon</h4><p> To make a particular addon, you can do:

                    </p><pre>make AddonName
</pre><p> After doing a pull from the source control repo, be sure to do:

                    </p><pre>make clean; make
</pre><p> To test just the vm:

                    </p><pre>make testvm
</pre><p> And to update the reference documentation (found in docs/IoReference.html) from the source code:

                    </p><pre>make doc
</pre>




                    <h3>Binaries</h3><p>
 

                    Io builds two executables and places them in the binaries folder. They are:

                    </p><pre>io_static
io
</pre><p> The io_static executable contains the vm with a minimal set of primitives all statically linked into the executable. The io executable contains just enough to load the iovm dynamically linked library and is able to dynamically load io addons when they are referenced.




                    <a name="Introduction-Running-Scripts"></a></p><h3>Running Scripts</h3><p>




                    An example of running a script:

                    </p><pre>io samples/misc/HelloWorld.io
</pre><p> There is no main() function or object that gets executed first in Io. Scripts are executed when compiled.




                    <a name="Introduction-Interactive-Mode"></a></p><h3>Interactive Mode</h3><p>




                    Running:

                    </p><pre>./_build/binaries/io
</pre><p> Or, if Io is installed, running:

                    </p><pre>io
</pre><p> will open the Io interpreter prompt.
                    </p><p>
                        You can evaluate code by entering it directly. Example:

                        </p><pre>Io&gt; &#34;Hello world!&#34; println
==&gt; Hello world!
</pre><p> Expressions are evaluated in the context of the Lobby:

                        </p><pre>Io&gt; print
[printout of lobby contents]
</pre><p> If you have a .iorc file in your home folder, it will be evaled before the interactive prompt starts.



                    <a name="Introduction-Inspecting-Objects"></a></p><h3>Inspecting objects</h3><p>


                    You can get a list of the slots of an object like this:

                    </p><pre>Io&gt; someObject slotNames
</pre><p> To show them in sorted order:

                    </p><pre>Io&gt; someObject slotNames sort
</pre><p> For a nicely formatted description of an object, the slotSummary method is handy:

                    </p><pre>Io&gt; slotSummary
==&gt;  Object_0x20c4e0:
  Lobby = Object_0x20c4e0
  Protos = Object_0x20bff0
  exit = method(...)
  forward = method(...)
</pre><p> Exploring further:

                    </p><pre>Io&gt; Protos
==&gt;  Object_0x20bff0:
  Addons = Object_0x20c6f0
  Core = Object_0x20c4b0

Io&gt; Protos Addons
==&gt;  Object_0x20c6f0:
  ReadLine = Object_0x366a10
</pre><p> Only ReadLine is seen in the Addons since no other Addons have been loaded yet.
                    </p><p>
                        Inspecting a method will print a decompiled version of it:

                        </p><pre>Io&gt; Lobby getSlot(&#34;forward&#34;)
==&gt; # io/Z_Importer.io:65
method(
    Importer import(call)
)
</pre>

                        <h4>doFile and doString</h4><p> A script can be run from the interactive mode using the doFile method:

                        </p><pre>doFile(&#34;scriptName.io&#34;)
</pre><p> The evaluation context of doFile is the receiver, which in this case would be the lobby. To evaluate the script in the context of some other object, simply send the doFile message to it:

                        </p><pre>someObject doFile(&#34;scriptName.io&#34;)
</pre><p> The doString method can be used to evaluate a string:

                        </p><pre>Io&gt; doString(&#34;1+1&#34;)
==&gt; 2
</pre><p> And to evaluate a string in the context of a particular object:

                        </p><pre>someObject doString(&#34;1 + 1&#34;)
</pre>

                        <h4>Command Line Arguments</h4><p> Example of printing out command line arguments:

                        </p><pre>System args foreach(k, v, write(&#34;&#39;&#34;, v, &#34;&#39;\n&#34;))
</pre>

                        <h4>launchPath</h4><p> The System &#34;launchPath&#34; slot is set to the location of the initial source file that is executed; when the interactive prompt is started (without specifying a source file to execute), the launchPath is the current working directory:

                        </p><pre>System launchPath
</pre>


    </div> <!-- end chapter -->
    <div>
 
                    <h2>Syntax<a name="Syntax"></a></h2>


                    <h3>Expressions</h3><p>


                    Io has no keywords or statements. Everything is an expression composed entirely of messages, each of which is a runtime accessible object. The informal BNF description:

                    </p><pre>exp        ::= { message | terminator }
message    ::= symbol [arguments]
arguments  ::= &#34;(&#34; [exp [ { &#34;,&#34; exp } ]] &#34;)&#34;
symbol     ::= identifier | number | string
terminator ::= &#34;\n&#34; | &#34;;&#34;
</pre><p> For performance reasons, String and Number literal messages have their results cached in their message objects.




                    <a name="Syntax-Messages"></a></p><h3>Messages</h3><p>




                    Message arguments are passed as expressions and evaluated by the receiver. Selective evaluation of arguments can be used to implement control flow. Examples:

                    </p><pre>for(i, 1, 10, i println)
a := if(b == 0, c + 1, d)
</pre><p> In the above code, &#34;for&#34; and &#34;if&#34; are just normal messages, not special forms or keywords.
                    </p><p>

                        Likewise, dynamic evaluation can be used with enumeration without the need to wrap the expression in a block. Examples:

                        </p><pre>people select(person, person age &lt; 30)
names := people map(person, person name)
</pre><p> Methods like map and select will typically apply the expression directly to the values if only the expression is provided:

                        </p><pre>people select(age &lt; 30)
names := people map(name)
</pre><p> There is also some syntax sugar for operators (including assignment), which are handled by an Io macro executed on the expression after it is compiled into a message tree. Some sample source code:

                        </p><pre>Account := Object clone
Account balance := 0
Account deposit := method(amount,
    balance = balance + amount
)

account := Account clone
account deposit(10.00)
account balance println
</pre><p> Like Self[2], Io&#39;s syntax does not distinguish between accessing a slot containing a method from one containing a variable.



                    <a name="Syntax-Operators"></a></p><h3>Operators</h3><p>




                    An operator is just a message whose name contains no alphanumeric characters (other than &#34;;&#34;, &#34;_&#34;, &#39;&#34;&#39; or &#34;.&#34;) or is one of the following words: or, and, return. Example:

                    </p><pre>1 + 2
</pre><p> This just gets compiled into the normal message:

                    </p><pre>1 +(2)
</pre><p> Which is the form you can use if you need to do grouping:

                    </p><pre>1 +(2 * 4)
</pre><p> Standard operators follow C&#39;s precedence order, so:

                    </p><pre>1 + 2 * 3 + 4
</pre><p> Is parsed as:

                    </p><pre>1 +(2 *(3)) +(4)
</pre><p> User defined operators (that don&#39;t have a standard operator name) are performed left to right.

</p><h4>OperatorTable</h4><p>

Operators can also be added or removed, or have their precedence changed by using the global OperatorTable object. For example:

</p><pre>OperatorTable addOperator(&#34;!!&#34;, 3)</pre><p>

adds the !! operator with a precedence of 3. Note that this change will not affect the source file in which the OperatorTable is modified as the full file is parsed before it is evaluated.



                    <a name="Syntax-Assignment"></a></p><h3>Assignment</h3><p>



                    Io has three assignment operators:

                    </p><p>
                        <table>
                            <tbody><tr>
                                <th>
                                    operator
                                </th>
                                <th>
                                    action
                                </th>
                            </tr>

                            <tr>
                                <td>
                                    ::=
                                </td>
                                <td>
                                    Creates slot, creates setter, assigns value
                                </td>
                            </tr>

                            <tr>
                                <td>
                                    :=
                                </td>
                                <td>
                                    Creates slot, assigns value
                                </td>
                            </tr>

                            <tr>
                                <td>
                                    =
                                </td>
                                <td>
                                    Assigns value to slot if it exists, otherwise raises exception
                                </td>
                            </tr>

                        </tbody></table>
                        </p><p>

                            These operators are compiled to normal messages whose methods can be overridden. For example:


                            </p><p>
                                <table>
                                    <tbody><tr>
                                        <th>
                                            source
                                        </th>
                                        <th>
                                            compiles to
                                        </th>
                                    </tr>

                                    <tr>
                                        <td>
                                            a ::= 1
                                        </td>
                                        <td>
                                            newSlot(&#34;a&#34;, 1)
                                        </td>
                                    </tr>

                                    <tr>
                                        <td>
                                            a := 1
                                        </td>
                                        <td>
                                            setSlot(&#34;a&#34;, 1)
                                        </td>
                                    </tr>

                                    <tr>
                                        <td>
                                            a = 1
                                        </td>
                                        <td>
                                            updateSlot(&#34;a&#34;, 1)
                                        </td>
                                    </tr>

                                </tbody></table>
                                </p><p>

                                    On Locals objects, updateSlot is overridden so it will update the slot in the object in which the method was activated if the slot is not found the locals. This is done so update assignments in methods don&#39;t require self to be an explicit target.




                    <a name="Syntax-Numbers"></a>
                    </p><h3>Numbers</h3><p>




                    The following are examples of valid number formats:

                    </p><pre>123
123.456
0.456
.456
123e-4
123e4
123.456e-7
123.456e2
</pre><p> Hex numbers are also supported (in any casing):

                    </p><pre>0x0
0x0F
0XeE
</pre>



                    <h3>Strings</h3><p>



                    Strings can be defined surrounded by a single set of double quotes with escaped quotes (and other escape characters) within.

                    </p><pre>s := &#34;this is a \&#34;test\&#34;.\nThis is only a test.&#34;
</pre><p> Or for strings with non-escaped characters and/or spanning many lines, triple quotes can be used.

                    </p><pre>s := &#34;&#34;&#34;this is a &#34;test&#34;.
This is only a test.&#34;&#34;&#34;
</pre>


                    <h3>Comments</h3><p>


                    Comments of the //, /**/ and # style are supported. Examples:

                    </p><pre>a := b // add a comment to a line

/* comment out a group
a := 1
b := 2
*/
</pre><p> The &#34;#&#34; style is useful for unix scripts:

                    </p><pre>#!/usr/local/bin/io
</pre><p> That&#39;s it! You now know everything there is to know about Io&#39;s syntax. Control flow, objects, methods, exceptions are expressed with the syntax and semantics described above.



                </p></div> <!-- end chapter -->
                <div>
                    

                    <h2>Objects<a name="Objects"></a></h2>




                    <!--
<div class=quote>
In all other languages we've considered [Fortran, Algol60, Lisp, APL, Cobol, Pascal], a program consists of passive data-objects on the one hand and the executable program that manipulates these passive objects on the other. Object-oriented programs replace this bipartite structure with a homogeneous one: they consist of a set of data systems, each of which is capable of operating on itself. <br>
- David Gelernter and Suresh J Jag
</div>
-->


                    <h3>Overview</h3><p>





                    Io&#39;s guiding design principle is simplicity and power through conceptual unification.
                    </p><p>

                        <table>
                            <tbody><tr>
                                <th>
                                    concept
                                </th>
                                <th>
                                    unifies
                                </th>
                            </tr>

                            <tr>
                                <td>
                                    scopable blocks
                                </td>
                                <td>
                                    functions, methods, closures
                                </td>
                            </tr>

                            <tr>
                                <td>
                                    prototypes
                                </td>
                                <td>
                                    objects, classes, namespaces, locals
                                </td>
                            </tr>

                            <tr>
                                <td>
                                    messages
                                </td>
                                <td>
                                    operators, calls, assigns, var access
                                </td>
                            </tr>
                        </tbody></table>



                    <a name="Objects-Prototypes"></a>
                    </p><h3>Prototypes</h3><p>




                    In Io, everything is an object (including the locals storage of a block and the namespace itself) and all actions are messages (including assignment). Objects are composed of a list of key/value pairs called slots, and an internal list of objects from which they inherit called protos. A slot&#39;s key is a symbol (a unique immutable sequence) and its value can be any type of object.

                    </p><h4>clone and init</h4><p> New objects are made by cloning existing ones. A clone is an empty object that has the parent in its list of protos. When an object is cloned, the new instance&#39;s init slot will be activated which gives the object a chance to initialize itself. Like NewtonScript[3], slots in Io are create-on-write.

                    </p><pre>me := Person clone
</pre><p> To add an instance variable or method, simply set it:

                    </p><pre>myDog name := &#34;rover&#34;
myDog sit := method(&#34;I&#39;m sitting\n&#34; print)
</pre>


                    <h3>Inheritance</h3><p>


                    When an object receives a message it looks for a matching slot, if not found, the lookup continues depth first recursively in its protos. Lookup loops are detected (at runtime) and avoided. If the matching slot contains an activatable object, such as a Block or CFunction, it is activated; if it contains any other type of value it returns the value. Io has no globals and the root object in the Io namespace is called the Lobby.
                    </p><p>
                        Since there are no classes, there&#39;s no difference between a subclass and an instance. Here&#39;s an example of creating the equivalent of a subclass:

                        </p><pre>Io&gt; Dog := Object clone
==&gt; Object_0x4a7c0 
</pre><p> The above code sets the Lobby slot &#34;Dog&#34; to a clone of the Object object; the protos list of this new object contains only a reference to Object, essentially indicating that a subclass of Object has been created. Instance variables and methods are inherited from the objects referenced in the protos list. If a slot is set, it creates a new slot in our object instead of changing the protos:

                        </p><pre>  Io&gt; Dog color := &#34;red&#34;
  Io&gt; Dog
  ==&gt; Object_0x4a7c0:
    color := &#34;red&#34;
</pre>


                        <h4>Multiple Inheritance</h4><p> You can add any number of protos to an object&#39;s protos list. When responding to a message, the lookup mechanism does a depth first search of the proto chain.




                    <a name="Objects-Methods"></a></p><h3>Methods</h3><p>



                    A method is an anonymous function which, when called, creates an object to store its locals and sets the locals object&#39;s proto pointer and its self slot to the target of the message. The Object method method() can be used to create methods. Example:

                    </p><pre>method((2 + 2) print)
</pre><p> An example of using a method in an object:

                    </p><pre>Dog := Object clone
Dog bark := method(&#34;woof!&#34; print)
</pre><p> The above code creates a new &#34;subclass&#34; of object named Dog and adds a bark slot containing a method that prints &#34;woof!&#34;. Example of calling this method:

                    </p><pre>Dog bark
</pre><p> The default return value of a method is the result of the last expression.

                    </p><h4>Arguments</h4><p> Methods can also be defined to take arguments. Example:

                    </p><pre>add := method(a, b, a + b)
</pre><p> The general form is:

                    </p><pre><i>
method(&lt;arg name 0&gt;, &lt;arg name 1&gt;, ..., &lt;do message&gt;)
</i></pre>



                    <h3>Blocks</h3><p>





                    A block is the same as a method except it is lexically scoped. That is, variable lookups continue in the context of where the block was created instead of the target of the message which activated the block. A block can be created using the Object method block(). Example of creating a block:

                    </p><pre>b := block(a, a + b)
</pre>

                    <h4>Blocks vs. Methods</h4><p> This is sometimes a source of confusion so it&#39;s worth explaining in detail. Both methods and blocks create an object to hold their locals when they are called. The difference is what the &#34;proto&#34; and &#34;self&#34; slots of that locals object are set to. In a method, those slots are set to the target of the message. In a block, they&#39;re set to the locals object where the block was created. So a failed variable lookup in a block&#39;s locals continue in the locals where it was created. And a failed variable lookup in a method&#39;s locals continue in the object to which the message that activated it was sent.

                    </p><h4>call and self slots</h4><p> When a locals object is created, its self slot is set (to the target of the message, in the case of a method, or to the creation context, in the case of a block) and its call slot is set to a Call object that can be used to access information about the block activation:

                        </p><table>
                            <tbody><tr>
                                <th>
                                    slot
                                </th>
                                <th>
                                    returns
                                </th>
                            </tr>
                            <tr>
                                <td>
                                    call sender
                                </td>
                                <td>
                                    locals object of caller
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    call message
                                </td>
                                <td>
                                    message used to call this method/block
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    call activated
                                </td>
                                <td>
                                    the activated method/block
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    call slotContext
                                </td>
                                <td>
                                    context in which slot was found
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    call target
                                </td>
                                <td>
                                    current object
                                </td>
                            </tr>
                        </tbody></table>
                        </div> <!-- end chapter -->
    <div>
                    <h2>Control Flow<a name="Control-Flow"></a></h2>


                    <h3>true, false and nil</h3><p>




                    There are singletons for true, false and nil. nil is typically used to indicate an unset or missing value.

                    <a name="Control-Flow-Comparison"></a></p><h3>Comparison</h3><p>


                    The comparison methods:

                    </p><pre>==, !=, &gt;=, &lt;=, &gt;, &lt; 
</pre><p> return either the true or false. The compare() method is used to implement the comparison methods and returns -1, 0 or 1 which mean less-than, equal-to or greater-than, respectively.


                    <a name="Control-Flow-If-Then-Else"></a></p><h3>if, then, else</h3><p>

                    The if() method can be used in the form:
                    </p><pre><i>
if(&lt;condition&gt;, &lt;do message&gt;, &lt;else do message&gt;)
</i></pre><p> Example:

                    </p><pre>if(a == 10, &#34;a is 10&#34; print)
</pre><p> The else argument is optional. The condition is considered false if the condition expression evaluates to false or nil, and true otherwise.
                    </p><p>
                        The result of the evaluated message is returned, so:

                        </p><pre>if(y &lt; 10, x := y, x := 0)
</pre><p> is the same as:

                        </p><pre>x := if(y &lt; 10, y, 0)
</pre><p> Conditions can also be used in this form:

                        </p><pre>if(y &lt; 10) then(x := y) else(x := 2)
</pre><p> elseif() is supported:

                        </p><pre>if(y &lt; 10) then(x := y) elseif(y == 11) then(x := 0) else(x := 2)
</pre>


                    <h3>ifTrue, ifFalse</h3><p>



                    Also supported are Smalltalk style ifTrue, ifFalse, ifNil and ifNonNil methods:

                    </p><pre>(y &lt; 10) ifTrue(x := y) ifFalse(x := 2)
</pre><p> Notice that the condition expression must have parenthesis surrounding it.



                    <a name="Control-Flow-Loop"></a></p><h3>loop</h3><p>



                    The loop method can be used for &#34;infinite&#34; loops:

                    </p><pre>loop(&#34;foo&#34; println)
</pre>


                    <h3>repeat</h3><p>


                    The Number repeat method can be used to repeat a loop a given number of times.

                    </p><pre>3 repeat(&#34;foo&#34; print)
==&gt; foofoofoo
</pre>



                    <h3>while</h3><p>


                    Arguments:

                    </p><pre><i>while(&lt;condition&gt;, &lt;do message&gt;)</i></pre><p> Example:

                    </p><pre>a := 1
while(a &lt; 10, 
    a print
    a = a + 1
)
</pre>


                    <h3>for</h3><p>


                    Arguments:

                    </p><pre><i>for(&lt;counter&gt;, &lt;start&gt;, &lt;end&gt;, &lt;optional step&gt;, &lt;do message&gt;)</i></pre><p> The start and end messages are only evaluated once, when the loop starts. Example:

                    </p><pre>for(a, 0, 10, 
    a println
)
</pre><p> Example with a step:

                    </p><pre>for(x, 0, 10, 3, x println)
</pre><p> Which would print:

                    </p><pre>0
3
6
9
</pre><p> To reverse the order of the loop, add a negative step:

                    </p><pre>for(a, 10, 0, -1, a println)
</pre><p> Note: the first value will be the first value of the loop variable and the last will be the last value on the final pass through the loop. So a loop of 1 to 10 will loop 10 times and a loop of 0 to 10 will loop 11 times.


                    <a name="Control-Flow-Break-Continue"></a></p><h3>break, continue</h3><p>


                    loop, repeat, while and for support the break and continue methods. Example:

                    </p><pre>for(i, 1, 10, 
    if(i == 3, continue)
    if(i == 7, break)
    i print
)
</pre><p> Output:

                    </p><pre>12456
</pre>



                    <h3>return</h3><p>


                    Any part of a block can return immediately using the return method. Example:

                    </p><pre>Io&gt; test := method(123 print; return &#34;abc&#34;; 456 print)
Io&gt; test
123
==&gt; abc
</pre><p> Internally, break, continue and return all work by setting a IoState internal variable called &#34;stopStatus&#34; which is monitored by the loop and message evaluation code.

    </p></div> <!-- end chapter -->
    <div>
                    <h2>Importing<a name="Importing"></a></h2><p>
               
               

                        The Importer proto implements Io&#39;s built-in auto importer feature. If you put each of your proto&#39;s in their own file, and give the file the same name with and &#34;.io&#34; extension, the Importer will automatically import that file when the proto is first referenced. The Importer&#39;s default search path is the current working directory, but can add search paths using its addSearchPath() method.


    </p></div> <!-- end chapter -->
    <div>
                    <h2>Concurrency<a name="Concurrency"></a></h2>


                    <h3>Coroutines</h3><p>



                    Io uses coroutines (user level cooperative threads), instead of preemptive OS level threads to implement concurrency. 
                    This avoids the substantial costs (memory, system calls, locking, caching issues, etc) associated with native threads and allows Io to support a high level of concurrency.
                    Io&#39;s coroutines stacks are much smaller than native thread stacks but can automatically increase in size (by chaining coroutines) as needed. 

                    </p><p>
                    Io&#39;s <a href="#Primitives-Networking">networking libraries</a> leverage coroutines by automatically pausing the calling coroutine (and scheduling another) when waiting 
                    on read/write operations, and resuming them when the result (which may be an error or timeout exception) of the read/write is available.

                    <a name="Concurrency-Scheduler"></a></p><h3>Scheduler</h3><p>


                    The Scheduler object is responsible for resuming coroutines that are yielding. The current scheduling system uses a simple first-in-first-out policy with no priorities.



                    <a name="Concurrency-Actors"></a></p><h3>Actors</h3><p>


                    An actor is an object with its own thread (in our case, its own coroutine) which it uses to process its queue of asynchronous messages. Any object in Io can be sent an asynchronous message by using the asyncSend() or futureSend() messages.
                    </p><p>
                        Examples:

                        </p><pre>result := self foo // synchronous 
futureResult := self futureSend(foo) // async, immediately returns a Future
self asyncSend(foo) // async, immediately returns nil
</pre><p> When an object receives an asynchronous message it puts the message in its queue and, if it doesn&#39;t already have one, starts a coroutine to process the messages in its queue. Queued messages are processed sequentially in a first-in-first-out order. Control can be yielded to other coroutines by calling &#34;yield&#34;. Example:

                        </p><pre>obj1 := Object clone
obj1 test := method(for(n, 1, 3, n print; yield))
obj2 := obj1 clone
obj1 asyncSend(test); obj2 asyncSend(test)
while(Scheduler yieldingCoros size &gt; 1, yield)
</pre><p> This would print &#34;112233&#34;. Here&#39;s a more real world example:

                        </p><pre>HttpServer handleRequest := method(aSocket,
    HttpRequestHandler clone asyncSend(handleRequest(aSocket))
)
</pre>

                    <h3>Futures</h3><p>





                    A future is a special kind of reference which is immediately returned from an futureSend() message which acts as a placeholder for the eventual result of the message. Io&#39;s futures are transparent. That is, when the result is ready, the future becomes the result. 
                    
                    If a message is sent to a future (besides the two methods it implements), it waits until it turns into the result before processing the message. Actors with transparent futures can dramatically simplify synchronization.

                    </p><h4>Auto Deadlock Detection</h4><p> An advantage of using futures is that when a future requires a wait, it will check to see if pausing to wait for the result would cause a deadlock and if so, avoid the deadlock and raise an exception. Since each future knows which actor it is waiting on, and each actor knows which (if any) future it is waiting on, Io can check for a deadlock by traversing this list.

                    </p><h4>Futures and the Command Line Interface</h4><p> The command line will attempt to print the result of expressions evaluated in it, so if the result is a Future, it will attempt to print it and this will wait on the result of Future. Example:

                    </p><pre>Io&gt; q := method(wait(1))
Io&gt; futureSend(q)
[1-second delay]
==&gt; nil
</pre><p> To avoid this, just make sure the Future isn&#39;t the result. Example:

                    </p><pre>Io&gt; futureSend(q); nil
[no delay]
==&gt; nil
</pre>


                    <h3>Yield</h3><p>


                    An object will automatically yield between processing each of its asynchronous messages. The yield method only needs to be called if a yield is required during an asynchronous message execution.

                    <a name="Concurrency-Pause and Resume"></a></p><h4>Pause and Resume</h4><p> It&#39;s also possible to pause and resume an object. See the concurrency methods of the Object primitive for details and related methods.

    </p></div> <!-- end chapter -->
    <div>
                    <h2>Exceptions<a name="Exceptions"></a></h2>

                    <h3>Raise</h3><p>



                    An exception can be raised by calling raise() on an exception proto.

                    </p><pre>Exception raise(&#34;generic foo exception&#34;)
</pre>

                    <!--
<pre><i>
exceptionProto raise(<description>)
</i></pre>

There are three predefined children of the Exception proto: Error, Warning and Notification. Examples: 

<pre>
Exception raise("generic foo exception")
Warning raise("No defaults found, creating them")
Error raise("Not enough memory")
</pre>
-->



                    <h3>Try and Catch</h3><p>




                    To catch an exception, the try() method of the Object proto is used. try() will catch any exceptions that occur within it and return the caught exception or nil if no exception is caught.

                    </p><pre><i>
e := try(&lt;doMessage&gt;)
</i></pre><p> To catch a particular exception, the Exception catch() method can be used. Example:

                    </p><pre>e := try(
    // ...
) 

e catch(Exception,
    writeln(e coroutine backTraceString)
)
</pre><p> The first argument to catch indicates which types of exceptions will be caught. catch() returns the exception if it doesn&#39;t match and nil if it does.



                    <a name="Exceptions-Pass"></a></p><h3>Pass</h3><p>


                    To re-raise an exception caught by try(), use the pass method. This is useful to pass the exception up to the next outer exception handler, usually after all catches failed to match the type of the current exception:

                    </p><pre>e := try(
    // ...
) 

e catch(Error,
    // ...
) catch(Exception,
    // ...
) pass
</pre>



                    <h3>Custom Exceptions</h3><p>



                    Custom exception types can be implemented by simply cloning an existing Exception type:

                    </p><pre>MyErrorType := Error clone
</pre>

    </div> <!-- end chapter -->
    <div>
                    <h2>Primitives<a name="Primitives"></a></h2><p>


                        Primitives are objects built into Io whose methods are typically implemented in C and store some hidden data in their instances. For example, the Number primitive has a double precision floating point number as its hidden data and its methods that do arithmetic operations are C functions. All Io primitives inherit from the Object prototype and are mutable. That is, their methods can be changed. The reference docs contain more info on primitives.
                        </p><p>

                            This document is not meant as a reference manual, but an overview of the base primitives and bindings is provided here to give the user a jump start and a feel for what is available and where to look in the reference documentation for further details.


                    <a name="Primitives-Object"></a>
                    </p><h3>Object</h3>



                    <h4>The ? Operator</h4><p> Sometimes it&#39;s desirable to conditionally call a method only if it exists (to avoid raising an exception). Example:

                    </p><pre>if(obj getSlot(&#34;foo&#34;), obj foo)
</pre><p> Putting a &#34;?&#34; before a message has the same effect:

                    </p><pre>obj ?foo
</pre>

  
  
                    <h3>List</h3><p>



                    A List is an array of references and supports all the standard array manipulation and enumeration methods. Examples:
                    </p><p>
                        Create an empty list:

                        </p><pre>a := List clone
</pre><p> Create a list of arbitrary objects using the list() method:

                        </p><pre>a := list(33, &#34;a&#34;)
</pre><p> Append an item:

                        </p><pre>a append(&#34;b&#34;)
==&gt; list(33, &#34;a&#34;, &#34;b&#34;)
</pre><p> Get the list size:

                        </p><pre>a size
==&gt; 3
</pre><p> Get the item at a given index (List indexes begin at zero):

                        </p><pre>a at(1)
==&gt; &#34;a&#34;
</pre><p> Note: List indexes begin at zero and nil is returned if the accessed index doesn&#39;t exist.
                        </p><p>
                            Set the item at a given index:

                            </p><pre>a atPut(2, &#34;foo&#34;)
==&gt; list(33, &#34;a&#34;, &#34;foo&#34;, &#34;b&#34;)

a atPut(6, &#34;Fred&#34;)
==&gt; Exception: index out of bounds
</pre><p> Remove an item at a given index:

                            </p><pre>a remove(&#34;foo&#34;)
==&gt; list(33, &#34;a&#34;, &#34;b&#34;)
</pre><p> Inserting an item at a given index:

                            </p><pre>a atInsert(2, &#34;foo&#34;)
==&gt; list(33, &#34;a&#34;, &#34;foo&#34;, &#34;56&#34;)
</pre>

                            <h4>foreach</h4><p> The foreach, map and select methods can be used in three forms:

                            </p><pre>Io&gt; a := list(65, 21, 122)
</pre><p> In the first form, the first argument is used as an index variable, the second as a value variable and the 3rd as the expression to evaluate for each value.

                            </p><pre>Io&gt; a foreach(i, v, write(i, &#34;:&#34;, v, &#34;, &#34;))
==&gt; 0:65, 1:21, 2:122,
</pre><p> The second form removes the index argument:

                            </p><pre>Io&gt; a foreach(v, v println)
==&gt; 65
21
122
</pre><p> The third form removes the value argument and simply sends the expression as a message to each value:

                            </p><pre>Io&gt; a foreach(println)
==&gt; 65
21
122
</pre>

                            <h4>map and select</h4><p> Io&#39;s map and select (known as filter in some other languages) methods allow arbitrary expressions as the map/select predicates.

                            </p><pre>Io&gt; numbers := list(1, 2, 3, 4, 5, 6)

Io&gt; numbers select(isOdd)
==&gt; list(1, 3, 5)

Io&gt; numbers select(x, x isOdd)
==&gt; list(1, 3, 5)

Io&gt; numbers select(i, x, x isOdd)
==&gt; list(1, 3, 5)

Io&gt; numbers map(x, x*2)
==&gt; list(2, 4, 6, 8, 10, 12)

Io&gt; numbers map(i, x, x+i)
==&gt; list(1, 3, 5, 7, 9, 11)

Io&gt; numbers map(*3)
==&gt; list(3, 6, 9, 12, 15, 18)
</pre><p> The map and select methods return new lists. To do the same operations in-place, you can use selectInPlace() and mapInPlace() methods.


                    <a name="Primitives-Sequence"></a></p><h3>Sequence</h3><p>




                    In Io, an immutable Sequence is called a Symbol and a mutable Sequence is the equivalent of a Buffer or String. Literal strings(ones that appear in source code surrounded by quotes) are Symbols. Mutable operations cannot be performed on Symbols, but one can make mutable copy of a Symbol calling its asMutable method and then perform the mutation operations on the copy. Common string operations Getting the length of a string:

                    </p><pre>&#34;abc&#34; size
==&gt; 3
</pre><p> Checking if a string contains a substring:

                    </p><pre>&#34;apples&#34; containsSeq(&#34;ppl&#34;)
==&gt; true
</pre><p> Getting the character (byte) at position N:

                    </p><pre>&#34;Kavi&#34; at(1)
==&gt; 97
</pre><p> Slicing:

                    </p><pre>&#34;Kirikuro&#34; slice(0, 2)
==&gt; &#34;Ki&#34;

&#34;Kirikuro&#34; slice(-2)  # NOT: slice(-2, 0)!
==&gt; &#34;ro&#34;

Io&gt; &#34;Kirikuro&#34; slice(0, -2)
# &#34;Kiriku&#34;
</pre><p> Stripping whitespace:

                    </p><pre>&#34;  abc  &#34; asMutable strip
==&gt; &#34;abc&#34;

&#34;  abc  &#34; asMutable lstrip
==&gt; &#34;abc  &#34;

&#34;  abc  &#34; asMutable rstrip
==&gt; &#34;  abc&#34;
</pre><p> Converting to upper/lowercase:

                    </p><pre>&#34;Kavi&#34; asUppercase
==&gt; &#34;KAVI&#34;
&#34;Kavi&#34; asLowercase
==&gt; &#34;kavi&#34;
</pre><p> Splitting a string:

                    </p><pre>&#34;the quick brown fox&#34; split
==&gt; list(&#34;the&#34;, &#34;quick&#34;, &#34;brown&#34;, &#34;fox&#34;)
</pre><p> Splitting by others character is possible as well.

                    </p><pre>&#34;a few good men&#34; split(&#34;e&#34;)
==&gt; list(&#34;a f&#34;, &#34;w good m&#34;, &#34;n&#34;)
</pre><p> Converting to number:

                    </p><pre>&#34;13&#34; asNumber
==&gt; 13

&#34;a13&#34; asNumber
==&gt; nil
</pre><p> String interpolation:

                    </p><pre>name := &#34;Fred&#34;
==&gt; Fred
&#34;My name is #{name}&#34; interpolate
==&gt; My name is Fred
 </pre><p> Interpolate will eval anything with #{} as Io code in the local context. The code may include loops or anything else but needs to return an object that responds to asString.



                    <a name="Primitives-Ranges"></a></p><h3>Ranges</h3><p>



                    A range is a container containing a start and an end point, and instructions on how to get from the start, to the end. Using Ranges is often convenient when creating large lists of sequential data as they can be easily converted to lists, or as a replacement for the for() method.

                    </p><h4>The Range protocol</h4><p> Each object that can be used in Ranges needs to implement a &#34;nextInSequence&#34; method which takes a single optional argument (the number of items to skip in the sequence of objects), and return the next item after that skip value. The default skip value is 1. The skip value of 0 is undefined. An example:

                    </p><pre>Number nextInSequence := method(skipVal,
    if(skipVal isNil, skipVal = 1)
    self + skipVal
)
</pre><p> With this method on Number (it&#39;s already there in the standard libraries), you can then use Numbers in Ranges, as demonstrated below:

                    </p><pre>1 to(5) foreach(v, v println)
</pre><p> The above will print 1 through 5, each on its own line.



                    <a name="Primitives-File"></a></p><h3>File</h3><p>




                    The methods openForAppending, openForReading, or openForUpdating are used for opening files. To erase an existing file before opening a new open, the remove method can be used. Example:

                    </p><pre>f := File with(&#34;foo.txt&#34;)
f remove
f openForUpdating
f write(&#34;hello world!&#34;)
f close
</pre>



                    <h3>Directory</h3><p>



                    Creating a directory object:

                    </p><pre>dir := Directory with(&#34;/Users/steve/&#34;)
</pre><p> Get a list of file objects for all the files in a directory:

                    </p><pre>files := dir files
==&gt; list(File_0x820c40, File_0x820c40, ...)
</pre><p> Get a list of both the file and directory objects in a directory:

                    </p><pre>items := Directory items
==&gt; list(Directory_0x8446b0, File_0x820c40, ...)

items at(4) name
==&gt; DarkSide-0.0.1 # a directory name
</pre><p> Setting a Directory object to a certain directory and using it:

                    </p><pre>root := Directory clone setPath(&#34;c:/&#34;)
==&gt; Directory_0x8637b8

root fileNames
==&gt; list(&#34;AUTOEXEC.BAT&#34;, &#34;boot.ini&#34;, &#34;CONFIG.SYS&#34;, ...)
</pre><p> Testing for existence:

                    </p><pre>Directory clone setPath(&#34;q:/&#34;) exists
==&gt; false
</pre><p> Getthing the current working directory:

                    </p><pre>Directory currentWorkingDirectory
==&gt; &#34;/cygdrive/c/lang/IoFull-Cygwin-2006-04-20&#34;
</pre>



                    <h3>Date</h3><p>


                    Creating a new date instance:

                    </p><pre>d := Date clone
</pre><p> Setting it to the current date/time:

                    </p><pre>d now
</pre><p> Getting the date/time as a number, in seconds:

                    </p><pre>Date now asNumber
==&gt; 1147198509.417114

Date now asNumber
==&gt; 1147198512.33313
</pre><p> Getting individual parts of a Date object:

                    </p><pre>d := Date now
==&gt; 2006-05-09 21:53:03 EST

d
==&gt; 2006-05-09 21:53:03 EST

d year
==&gt; 2006

d month
==&gt; 5

d day
==&gt; 9

d hour
==&gt; 21

d minute
==&gt; 53

d second
==&gt; 3.747125
</pre><p> Find how long it takes to execute some code:

                    </p><pre>Date cpuSecondsToRun(100000 repeat(1+1))
==&gt; 0.02
</pre>


                    <h3>Networking</h3><p>


                    All of Io&#39;s networking is done with asynchronous sockets underneath, but operations like reading and writing to a socket appear to be synchronous since the calling coroutine is unscheduled until the socket has completed the operation, or an error or timeout occurs. Note that you&#39;ll need to first reference the associated addon in order to cause it to load before using its objects. In these examples, you&#39;ll have to reference &#34;Socket&#34; to get the Socket addon to load first.
                    </p><p>
                        Creating a URL object:

                        </p><pre>url := URL with(&#34;http://example.com/&#34;)
</pre><p> Fetching an URL:

                        </p><pre>data := url fetch  
</pre><p> Streaming a URL to a file:

                        </p><pre>url streamTo(File with(&#34;out.txt&#34;))
</pre><p> A simple whois client:

                        </p><pre>whois := method(host,
    socket := Socket clone \
		setHostName(&#34;rs.internic.net&#34;) setPort(43) 
    socket connect streamWrite(host, &#34;\n&#34;)
    while(socket streamReadNextChunk, nil)
    return socket readBuffer
)
</pre><p> A minimal web server:

                        </p><pre>WebRequest := Object clone do(
    handleSocket := method(aSocket,
        aSocket streamReadNextChunk
        request := aSocket readBuffer \
			betweenSeq(&#34;GET &#34;, &#34; HTTP&#34;)
        f := File with(request) 
        if(f exists, 
			f streamTo(aSocket)
		, 
			aSocket streamWrite(&#34;not found&#34;)
		)
        aSocket close
    )
)

WebServer := Server clone do(
    setPort(8000)
    handleSocket := method(aSocket, 
        WebRequest clone asyncSend(handleSocket(aSocket))
    )
)

WebServer start
</pre>


                    <h3>XML</h3><p>


                    Using the XML parser to find the links in a web page:

                    </p><pre>SGML // reference this to load the SGML addon
xml := URL with(&#34;http://www.yahoo.com/&#34;) fetch asXML
links := xml elementsWithName(&#34;a&#34;) map(attributes at(&#34;href&#34;))
</pre>



                    <h3>Vector</h3><p>


                    Io&#39;s Vectors are built on its Sequence primitive and are defined as:

                    </p><pre>Vector := Sequence clone setItemType(&#34;float32&#34;)
</pre><p> The Sequence primitive supports SIMD acceleration on a number of float32 operations. Currently these include add, subtract, multiple and divide but in the future can be extended to support most math, logic and string manipulation related operations. Here&#39;s a small example:

                    </p><pre>iters := 1000
size := 1024
ops := iters * size

v1 := Vector clone setSize(size) rangeFill
v2 := Vector clone setSize(size) rangeFill

dt := Date secondsToRun(
    iters repeat(v1 *= v2)
)

writeln((ops/(dt*1000000000)) asString(1, 3), &#34; GFLOPS&#34;)
</pre><p> Which when run on </p><u>2Ghz Mac Laptop</u><p>, outputs:

                    </p><pre>1.255 GFLOPS
</pre><p> A similar bit of C code (without SIMD acceleration) outputs:

                    </p><pre>0.479 GFLOPS
</pre><p> So for this example, Io is about three times faster than plain C. 

                    </p><!--
</div>

<h2>Metaprogramming<a name="Metaprogramming"></a></h2>

</i>forthcoming...

Object
setIsActivatable
forward
introspection 
getSlot, slotSummary, docs, namespaces
Block 
setScope()
setPassStops()
setDoesCatchStops()
doesCatchStops
setMessage()
Message
Manipulating Message Trees
setNext()
setArgumentNames()
setCachedResult()
Syntax
squareBrackets()
curlyBrackets()
operators
adding
precedence ordering
-->

    </div> <!-- end chapter -->
    <div>
                    <h2>Unicode<a name="Unicode"></a></h2>


                    <h3>Sequences</h3><p>




                    In Io, symbols, strings, and vectors are unified into a single Sequence prototype which is an array of any available hardware data type such as:

                    </p><pre>uint8, uint16, uint32, uint64
int8, int16, int32, int64
float32, float64
</pre>


                    <h3>Encodings</h3><p>




                    Also, a Sequence has a encoding attribute, which can be:

                    </p><pre>number, ascii, ucs2, ucs4, utf8
</pre><p> UCS-2 and UCS-4 are the fixed character width versions of UTF-16 and UTF-32, respectively. A String is just a Sequence with a text encoding, a Symbol is an immutable String and a Vector is a Sequence with a number encoding.
                    </p><p>
                        UTF encodings are assumed to be big endian.
                        </p><h3>Conversion</h3><p>
       
       
       
       
                           The Sequence object has a number of conversion methods:
       
</p><pre>asUTF8
asUCS2
asUCS4
</pre>

                    <h3>Source Code</h3><p>



                    Io source files are assumed to be in UTF8 (of which ASCII is a subset). When a source file is read, its symbols and strings are stored in Sequences in their minimal fixed character width encoding. Examples:

                    </p><pre>Io&gt; &#34;hello&#34; encoding
==&gt; ascii

Io&gt; &#34;π&#34; encoding
==&gt; ucs2

Io&gt; &#34;∞&#34; encoding
==&gt; ucs2
</pre><p> We can also inspect the internal representation:

                    </p><pre>Io&gt; &#34;π&#34; itemType
==&gt; uint16

Io&gt; &#34;π&#34; itemSize
==&gt; 2
</pre>



 
     </div> <!-- end chapter -->
    <div>
                    <h2>Embedding<a name="Embedding"></a></h2>


                    <h3>Conventions</h3><p>




                    Io&#39;s C code is written using object oriented style conventions where structures are treated as objects and functions as methods. Familiarity with these may help make the embedding APIs easier to understand.

                    </p><h4>Structures</h4><p> Member names are words that begin with a lower case character with successive words each having their first character upper cased. Acronyms are capitalized. Structure names are words with their first character capitalized. Example:

                    </p><pre>typdef struct 
{
    char *firstName;
    char *lastName;
    char *address;
} Person;
</pre>

                    <h4>Functions</h4><p> Function names begin with the name of structure they operate on followed by an underscore and the method name. Each structure has a new and free function.
                    </p><p>

                        Example:

                        </p><pre>List *List_new(void);
void List_free(List *self);
</pre><p> All methods (except new) have the structure (the &#34;object&#34;) as the first argument the variable is named &#34;self&#34;. Method names are in keyword format. That is, for each argument, the method name has a description followed by an underscore. The casing of the descriptions follow that of structure member names.
                        </p><p>
                            Examples:

                            </p><pre>int List_count(List *self); // no argument 
void List_add_(List *self, void *item); // one argument
void Dictionary_key_value_(Dictionary *self, 
	char *key, char *value); 
</pre>

                            <h4>File Names</h4><p> Each structure has its own separate .h and .c files. The names of the files are the same as the name of the structure. These files contain all the functions(methods) that operate on the given structure.



                    <a name="Embedding-IoState"></a></p><h3>IoState</h3><p>





                    An IoState can be thought of as an instance of an Io &#34;virtual machine&#34;, although &#34;virtual machine&#34; is a less appropriate term because it implies a particular type of implementation.

                    </p><h4>Multiple states</h4><p> Io is multi-state, meaning that it is designed to support multiple state instances within the same process. These instances are isolated and share no memory so they can be safely accessed simultaneously by different os threads, though a given state should only be accessed by one os thread at a time.

                    </p><h4>Creating a state</h4><p> Here&#39;s a simple example of creating a state, evaluating a string in it, and freeing the state:

                    </p><pre>#include &#34;IoState.h&#34;

int main(int argc, const char *argv[]) {
    IoState *self = IoState_new();
    IoState_init(self);
    IoState_doCString_(self, &#34;writeln(\&#34;hello world!\&#34;&#34;);
    IoState_free(self);
    return 0;
}
</pre>



                    <h3>Values</h3><p>




                    We can also get return values and look at their types and print them:

                    </p><pre>IoObject *v = IoState_doCString_(self, someString);
char *name = IoObject_name(v);
printf(&#34;return type is a ‘%s&#39;, name);
IoObject_print(v);
</pre>

                    <h4>Checking value types</h4><p> There are some macro short cuts to help with quick type checks:

                    </p><pre>if (ISNUMBER(v)) {
    printf(&#34;result is the number %f&#34;, IoNumber_asFloat(v));
} else if(ISSEQ(v)) {
    printf(&#34;result is the string %s&#34;, IoSeq_asCString(v));
} else if(ISLIST(v)) {
    printf(&#34;result is a list with %i elements&#34;, 
		IoList_rawSize(v));
}
</pre><p> Note that return values are always proper Io objects (as all values are objects in Io). You can find the C level methods (functions like IoList_rawSize()) for these objects in the header files in the folder Io/libs/iovm/source.

     </p></div> <!-- end chapter -->
    <div>
                    <h2>Bindings<a name="Bindings"></a></h2><p>


                        Documentation on how to write bindings/addons forthcoming..


    </p></div> <!-- end chapter -->
    <div>
                    <h2>Appendix<a name="Appendix"></a></h2>

                    <h3>Grammar</h3>




                    <h4>messages</h4>
                    <pre>expression ::= { message | sctpad }
message ::= [wcpad] symbol [scpad] [arguments]
arguments ::= Open [argument [ { Comma argument } ]] Close
argument ::= [wcpad] expression [wcpad]
</pre>

                    <h4>symbols</h4>

                    <pre>symbol ::= Identifier | number | Operator | quote
Identifier ::= { letter | digit | &#34;_&#34; }
Operator ::= { &#34;:&#34; | &#34;.&#34; | &#34;&#39;&#34; | &#34;~&#34; | &#34;!&#34; | &#34;@&#34; | &#34;$&#34; | 
&#34;%&#34; | &#34;^&#34; | &#34;&amp;&#34; | &#34;*&#34; | &#34;-&#34; | &#34;+&#34; | &#34;/&#34; | &#34;=&#34; | &#34;{&#34; | &#34;}&#34; | 
&#34;[&#34; | &#34;]&#34; | &#34;|&#34; | &#34;\&#34; | &#34;&lt;&#34; | &#34;&gt;&#34; | &#34;?&#34; }
</pre>

                    <h4>quotes</h4>
                    <pre>quote ::= MonoQuote | TriQuote
MonoQuote ::= &#34;&#34;&#34; [ &#34;\&#34;&#34; | not(&#34;&#34;&#34;)] &#34;&#34;&#34;
TriQuote ::= &#34;&#34;&#34;&#34;&#34; [ not(&#34;&#34;&#34;&#34;&#34;)] &#34;&#34;&#34;&#34;&#34;
</pre>

                    <h4>spans</h4>
                    <pre>Terminator ::= { [separator] &#34;;&#34; | &#34;\n&#34; | &#34;\r&#34; [separator] }
separator ::= { &#34; &#34; | &#34;\f&#34; | &#34;\t&#34; | &#34;\v&#34; }
whitespace ::= { &#34; &#34; | &#34;\f&#34; | &#34;\r&#34; | &#34;\t&#34; | &#34;\v&#34; | &#34;\n&#34; }
sctpad ::= { separator | Comment | Terminator }
scpad ::= { separator | Comment }
wcpad ::= { whitespace | Comment }
</pre>

                    <h4>comments</h4>
                    <pre>Comment ::= slashStarComment | slashSlashComment | poundComment
slashStarComment ::= &#34;/*&#34; [not(&#34;*/&#34;)] &#34;*/&#34;
slashSlashComment ::= &#34;//&#34; [not(&#34;\n&#34;)] &#34;\n&#34;
poundComment ::= &#34;#&#34; [not(&#34;\n&#34;)] &#34;\n&#34;
</pre>

                    <h4>numbers</h4>
                    <pre>number ::= HexNumber | Decimal
HexNumber ::= &#34;0&#34; anyCase(&#34;x&#34;) { [ digit | hexLetter ] }
hexLetter ::= &#34;a&#34; | &#34;b&#34; | &#34;c&#34; | &#34;d&#34; | &#34;e&#34; | &#34;f&#34;
Decimal ::= digits | &#34;.&#34; digits | 
	digits &#34;.&#34; digits [&#34;e&#34; [-] digits]
</pre>

                    <h4>characters</h4>
                    <pre>Comma ::= &#34;,&#34;
Open ::= &#34;(&#34; | &#34;[&#34; | &#34;{&#34;
Close ::= &#34;)&#34; | &#34;]&#34; | &#34;}&#34;
letter ::= &#34;a&#34; ... &#34;z&#34; | &#34;A&#34; ... &#34;Z&#34;
digit ::= &#34;0&#34; ... &#34;9&#34;
digits ::= { digit }
</pre><p> The uppercase words above designate elements the lexer treats as tokens.


  
  
                    <a name="Appendix-Credits"></a></p><h3>Credits</h3><p>


                    Io is the product of all the talented folks who taken the time and interest to make a contribution. The complete list of contributors is difficult to keep track of, but some of the recent major contributors include; Jonathan Wright, Jeremy Tregunna, Mike Austin, Chris Double, Rich Collins, Oliver Ansaldi, James Burgess, Baptist Heyman, Ken Kerahone, Christian Thater, Brian Mitchell, Zachary Bir and many more. The mailing list archives, repo inventory and release history are probably the best sources for a more complete record of individual contributions.


                    <a name="Appendix-References"></a></p><h3>References</h3>


                    <table>
                        <tbody><tr>
                            <td>
                                1
                            </td>
                            <td>
                                
                            </td>
                        </tr>

                        <tr>
                            <td colspan="2"></td>
                        </tr>

                        <tr>
                            <td>
                                2
                            </td>
                            <td>
                                
                        </td>
                        </tr>

                        <tr>
                            <td colspan="2"></td>
                        </tr>

                        <tr>
                            <td>
                                3
                            </td>
                            <td>
                                
                        </td>
                        </tr>

                        <tr>
                            <td colspan="2"></td>
                        </tr>

                        <tr>
                            <td>
                                4
                            </td>
                            <td>
                                
                        </td>
                        </tr>

                        <tr>
                            <td colspan="2"></td>
                        </tr>

                        <tr>
                            <td>
                                5
                            </td>
                            <td>
                                
                        </td>
                        </tr>

                        <tr>
                            <td colspan="2"></td>
                        </tr>

                        <tr>
                            <td>
                                6
                            </td>
                            <td>
                                
                        </td>
                        </tr>
                    </tbody></table>



                    <h3>License</h3><p>



                    Copyright 2006-2010 Steve Dekorte. All rights reserved.
                    </p><p>
                        Redistribution and use of this document with or without modification, are permitted provided that the copies reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
                    </p><p>
                            This documentation is provided &#34;as is&#34; and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the authors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this documentation, even if advised of the possibility of such damage.

                  
        </p></div> <!-- end chapter -->
    </div></div>
  </body>
</html>
