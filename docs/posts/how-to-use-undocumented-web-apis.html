<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2022/03/10/how-to-use-undocumented-web-apis/">Original</a>
    <h1>How to use undocumented web APIs</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Hello! A couple of days I wrote about <a href="https://jvns.ca/blog/2022/03/08/tiny-programs/">tiny personal programs</a>, and I mentioned that
it can be fun to use “secret” undocumented APIs where you need to copy your
cookies out of the browser to get access to them.</p>
<p>A couple of people asked how to do this, so I wanted to explain how because
it’s pretty straightforward. We’ll also talk a tiny bit about what can go
wrong, ethical issues, and how this applies to your undocumented APIs.</p>
<p>As an example, let’s use Google Hangouts. I’m picking this not because it’s the
most useful example (I think there’s an official API which would be much more
practical to use), but because many sites where this is actually useful are
smaller sites that are more vulnerable to abuse. So we’re just going to use
Google Hangouts because I’m 100% sure that the Google Hangouts backend is
designed to be resilient to this kind of poking around.</p>
<p>Let’s get started!</p>
<h3 id="step-1-look-in-developer-tools-for-a-promising-json-response">step 1: look in developer tools for a promising JSON response</h3>
<p>I start out by going to <a href="https://hangouts.google.com">https://hangouts.google.com</a>, opening the network tab in
Firefox developer tools and looking for JSON responses. You can use Chrome developer tools too.</p>
<p>Here’s what that looks like</p>
<p><img src="https://jvns.ca/images/network-tab.png"/></p>
<p>The request is a good candidate if it says “json” in the “Type” column”</p>
<p>I had to look around for a while until I found something interesting, but
eventually I found a “people” endpoint that seems to return information about
my contacts. Sounds fun, let’s take a look at that.</p>
<h3 id="step-2-copy-as-curl">step 2: copy as cURL</h3>
<p>Next, I right click on the request I’m interested in, and click “Copy” -&gt; “Copy as cURL”.</p>
<p>Then I paste the <code>curl</code> command in my terminal and run it. Here’s what happens.</p>
<pre><code>$ curl &#39;https://people-pa.clients6.google.com/v2/people/?key=REDACTED&#39; -X POST ........ (a bunch of headers removed)
Warning: Binary output can mess up your terminal. Use &#34;--output -&#34; to tell 
Warning: curl to output it to your terminal anyway, or consider &#34;--output 
Warning: &lt;FILE&gt;&#34; to save to a file.
</code></pre>
<p>You might be thinking – that’s weird, what’s this “binary output can mess up
your terminal” error? That’s because by default, browsers send an
<code>Accept-Encoding: gzip, deflate</code> header to the server, to get compressed
output.</p>
<p>We could decompress it by piping the output to <code>gunzip</code>, but I find it simpler
to just not send that header. So let’s remove some irrelevant headers.</p>

<p>Here’s the full <code>curl</code> command line that I got from the browser. There’s a lot here!
I start out by splitting up the request with backslashes (<code>\</code>) so that each header is on a different line to make it easier to work with:</p>
<pre><code>curl &#39;https://people-pa.clients6.google.com/v2/people/?key=REDACTED&#39; \
-X POST \
-H &#39;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:96.0) Gecko/20100101 Firefox/96.0&#39; \
-H &#39;Accept: */*&#39; \
-H &#39;Accept-Language: en&#39; \
-H &#39;Accept-Encoding: gzip, deflate&#39; \
-H &#39;X-HTTP-Method-Override: GET&#39; \
-H &#39;Authorization: SAPISIDHASH REDACTED&#39; \
-H &#39;Cookie: REDACTED&#39;
-H &#39;Content-Type: application/x-www-form-urlencoded&#39; \
-H &#39;X-Goog-AuthUser: 0&#39; \
-H &#39;Origin: https://hangouts.google.com&#39; \
-H &#39;Connection: keep-alive&#39; \
-H &#39;Referer: https://hangouts.google.com/&#39; \
-H &#39;Sec-Fetch-Dest: empty&#39; \
-H &#39;Sec-Fetch-Mode: cors&#39; \
-H &#39;Sec-Fetch-Site: same-site&#39; \
-H &#39;Sec-GPC: 1&#39; \
-H &#39;DNT: 1&#39; \
-H &#39;Pragma: no-cache&#39; \
-H &#39;Cache-Control: no-cache&#39; \
-H &#39;TE: trailers&#39; \
--data-raw &#39;personId=101777723309&amp;personId=1175339043204&amp;personId=1115266537043&amp;personId=116731406166&amp;extensionSet.extensionNames=HANGOUTS_ADDITIONAL_DATA&amp;extensionSet.extensionNames=HANGOUTS_OFF_NETWORK_GAIA_GET&amp;extensionSet.extensionNames=HANGOUTS_PHONE_DATA&amp;includedProfileStates=ADMIN_BLOCKED&amp;includedProfileStates=DELETED&amp;includedProfileStates=PRIVATE_PROFILE&amp;mergedPersonSourceOptions.includeAffinity=CHAT_AUTOCOMPLETE&amp;coreIdParams.useRealtimeNotificationExpandedAcls=true&amp;requestMask.includeField.paths=person.email&amp;requestMask.includeField.paths=person.gender&amp;requestMask.includeField.paths=person.in_app_reachability&amp;requestMask.includeField.paths=person.metadata&amp;requestMask.includeField.paths=person.name&amp;requestMask.includeField.paths=person.phone&amp;requestMask.includeField.paths=person.photo&amp;requestMask.includeField.paths=person.read_only_profile_info&amp;requestMask.includeField.paths=person.organization&amp;requestMask.includeField.paths=person.location&amp;requestMask.includeField.paths=person.cover_photo&amp;requestMask.includeContainer=PROFILE&amp;requestMask.includeContainer=DOMAIN_PROFILE&amp;requestMask.includeContainer=CONTACT&amp;key=REDACTED&#39;
</code></pre>
<p>This can seem like an overwhelming amount of stuff at first, but you don’t need
to think about what any of it means at this stage. You just need to delete
irrelevant lines.</p>
<p>I usually just figure out which headers I can delete with trial and error – I
keep removing headers until the request starts failing. In general you probably
don’t need <code>Accept*</code>, <code>Referer</code>, <code>Sec-*</code>, <code>DNT</code>, <code>User-Agent</code>, and caching
headers though.</p>
<p>In this example, I was able to cut the request down to this:</p>
<pre><code>curl &#39;https://people-pa.clients6.google.com/v2/people/?key=REDACTED&#39; \
-X POST \
-H &#39;Authorization: SAPISIDHASH REDACTED&#39; \
-H &#39;Content-Type: application/x-www-form-urlencoded&#39; \
-H &#39;Origin: https://hangouts.google.com&#39; \
-H &#39;Cookie: REDACTED&#39;\
--data-raw &#39;personId=101777723309&amp;personId=1175339043204&amp;personId=1115266537043&amp;personId=116731406166&amp;extensionSet.extensionNames=HANGOUTS_ADDITIONAL_DATA&amp;extensionSet.extensionNames=HANGOUTS_OFF_NETWORK_GAIA_GET&amp;extensionSet.extensionNames=HANGOUTS_PHONE_DATA&amp;includedProfileStates=ADMIN_BLOCKED&amp;includedProfileStates=DELETED&amp;includedProfileStates=PRIVATE_PROFILE&amp;mergedPersonSourceOptions.includeAffinity=CHAT_AUTOCOMPLETE&amp;coreIdParams.useRealtimeNotificationExpandedAcls=true&amp;requestMask.includeField.paths=person.email&amp;requestMask.includeField.paths=person.gender&amp;requestMask.includeField.paths=person.in_app_reachability&amp;requestMask.includeField.paths=person.metadata&amp;requestMask.includeField.paths=person.name&amp;requestMask.includeField.paths=person.phone&amp;requestMask.includeField.paths=person.photo&amp;requestMask.includeField.paths=person.read_only_profile_info&amp;requestMask.includeField.paths=person.organization&amp;requestMask.includeField.paths=person.location&amp;requestMask.includeField.paths=person.cover_photo&amp;requestMask.includeContainer=PROFILE&amp;requestMask.includeContainer=DOMAIN_PROFILE&amp;requestMask.includeContainer=CONTACT&amp;key=REDACTED&#39;
</code></pre>
<p>So I just need 4 headers: <code>Authorization</code>, <code>Content-Type</code>, <code>Origin</code>, and <code>Cookie</code>. That’s a lot more manageable.</p>
<h3 id="step-4-translate-it-into-python">step 4: translate it into Python</h3>
<p>Now that we know what headers we need, we can translate our <code>curl</code> command into a Python program!
This part is also a pretty mechanical process, the goal is just to send exactly the same data with Python as we were with curl.</p>
<p>Here’s what that looks like. This is exactly the same as the previous <code>curl</code>
command, but using Python’s <code>requests</code>. I also broke up the very long request body
string into an array of tuples to make it easier to work with
programmmatically.</p>
<pre><code>import requests
import urllib

data = [
    (&#39;personId&#39;,&#39;101777723&#39;), # I redacted these IDs a bit too
    (&#39;personId&#39;,&#39;117533904&#39;),
    (&#39;personId&#39;,&#39;111526653&#39;),
    (&#39;personId&#39;,&#39;116731406&#39;),
    (&#39;extensionSet.extensionNames&#39;,&#39;HANGOUTS_ADDITIONAL_DATA&#39;),
    (&#39;extensionSet.extensionNames&#39;,&#39;HANGOUTS_OFF_NETWORK_GAIA_GET&#39;),
    (&#39;extensionSet.extensionNames&#39;,&#39;HANGOUTS_PHONE_DATA&#39;),
    (&#39;includedProfileStates&#39;,&#39;ADMIN_BLOCKED&#39;),
    (&#39;includedProfileStates&#39;,&#39;DELETED&#39;),
    (&#39;includedProfileStates&#39;,&#39;PRIVATE_PROFILE&#39;),
    (&#39;mergedPersonSourceOptions.includeAffinity&#39;,&#39;CHAT_AUTOCOMPLETE&#39;),
    (&#39;coreIdParams.useRealtimeNotificationExpandedAcls&#39;,&#39;true&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.email&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.gender&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.in_app_reachability&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.metadata&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.name&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.phone&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.photo&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.read_only_profile_info&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.organization&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.location&#39;),
    (&#39;requestMask.includeField.paths&#39;,&#39;person.cover_photo&#39;),
    (&#39;requestMask.includeContainer&#39;,&#39;PROFILE&#39;),
    (&#39;requestMask.includeContainer&#39;,&#39;DOMAIN_PROFILE&#39;),
    (&#39;requestMask.includeContainer&#39;,&#39;CONTACT&#39;),
    (&#39;key&#39;,&#39;REDACTED&#39;)
]
response = requests.post(&#39;https://people-pa.clients6.google.com/v2/people/?key=REDACTED&#39;,
    headers={
        &#39;X-HTTP-Method-Override&#39;: &#39;GET&#39;,
        &#39;Authorization&#39;: &#39;SAPISIDHASH REDACTED&#39;,
        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
        &#39;Origin&#39;: &#39;https://hangouts.google.com&#39;,
        &#39;Cookie&#39;: &#39;REDACTED&#39;,
    },
    data=urllib.parse.urlencode(data),
)

print(response.text)
</code></pre>
<p>I ran this program and it works – it prints out a bunch of JSON! Hooray!</p>
<p>You’ll notice that I replaced a bunch of things with <code>REDACTED</code>, that’s because
if I included those values you could access the Google Hangouts API for my
account which would be no good.</p>
<h3 id="and-we-re-done">and we’re done!</h3>
<p>Now I can modify the Python program to do whatever I want, like passing
different parameters or parsing the output.</p>
<p>I’m not going to do anything interesting with it because I’m not actually
interested in using this API at all, I just wanted to show what the process looks like.</p>
<p>But we get back a bunch of JSON that you could definitely do something with.</p>
<h3 id="curlconverter-looks-great">curlconverter looks great</h3>
<p>Someone commented that you can translate curl to Python (and a bunch of other
languages!) automatically with <a href="https://curlconverter.com/">https://curlconverter.com/</a> which looks amazing
– I’ve always done it manually. I tried it out on this example and it seems
to work great.</p>
<h3 id="figuring-out-how-the-api-works-is-nontrivial">figuring out how the API works is nontrivial</h3>
<p>I don’t want to undersell how difficult it can be to figure out how an unknown
API works – it’s not obvious! I have no idea what a lot of the parameters to
this Google Hangouts API do!</p>
<p>But a lot of the time there are some parameters that seem pretty straightforward,
like <code>requestMask.includeField.paths=person.email</code> probably means “include each
person’s email address”. So I try to focus on the parameters I <em>do</em> understand
more than the ones I <em>don’t</em> understand.</p>
<h3 id="this-always-works-in-theory">this always works (in theory)</h3>
<p>Some of you might be wondering – can you always do this?</p>
<p>The answer is sort of yes – browsers aren’t magic! All the information
browsers send to your backend is just HTTP requests. So if I copy all of the
HTTP headers that my browser is sending, I think there’s literally no way for
the backend to tell that the request <em>isn’t</em> sent by my browser and is actually
being sent by a random Python program.</p>
<p>Of course, we removed a bunch of the headers the browser sent so theoretically
the backend <em>could</em> tell, but usually they won’t check.</p>
<p>There are some caveats though – for example a lot of Google services have
backends that communicate with the frontend in a totally inscrutable (to me)
way, so even though in theory you could mimic what they’re doing, in practice
it might be almost impossible. And bigger APIs that encounter more abuse
will have more protections.</p>
<p>Now that we’ve seen how to use undocumented APIs like this, let’s talk about
some things that can go wrong.</p>
<h3 id="problem-1-expiring-session-cookies">problem 1: expiring session cookies</h3>
<p>One big problem here is that I’m using my Google session cookie for
authentication, so this script will stop working whenever my browser session
expires.</p>
<p>That means that this approach wouldn’t work for a long running program (I’d
want to use a real API), but if I just need to quickly grab a little bit of data as a
1-time thing, it can work great!</p>
<h3 id="problem-2-abuse">problem 2: abuse</h3>
<p>If I’m using a small website, there’s a chance that my little Python script
could take down their service because it’s doing way more requests than they’re
able to handle. So when I’m doing this I try to be respectful and not make too
many requests too quickly.</p>
<p>This is especially important because a lot of sites which don’t have official
APIs are smaller sites with less resources.</p>
<p>In this example obviously this isn’t a problem – I think I made 20 requests
total to the Google Hangouts backend while writing this blog post, which they
can definitely handle.</p>
<p>Also if you’re using your account credentials to access the API in a excessive
way and you cause problems, you might (very reasonably) get your account
suspended.</p>
<p>I also stick to downloading data that’s either mine or that’s intended to be
publicly accessible – I’m not searching for vulnerabilities.</p>
<h3 id="remember-that-anyone-can-use-your-undocumented-apis">remember that anyone can use your undocumented APIs</h3>
<p>I think the most important thing to know about this isn’t actually how to use <em>other
people’s</em> undocumented APIs. It’s fun to do, but it has a lot
of limitations and I don’t actually do it that often.</p>
<p>It’s much more important to understand that anyone can do this to <em>your</em>
backend API! Everyone has developer tools and the network tab, and it’s pretty
easy to see which parameters you’re passing to the backend and to change them.</p>
<p>So if anyone can just change some parameters to get another user’s information,
that’s no good. I think most developers building publicly availble APIs know
this, but I’m mentioning it because everyone needs to learn it for the first
time at some point :)</p>
</div></div>
  </body>
</html>
