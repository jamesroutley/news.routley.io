<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.adept.ai/blog/flashier-attention">Original</a>
    <h1>FlashAttention: Fast Transformer training with long sequences</h1>
    
    <div id="readability-page-1" class="page"><div><p>Since <a href="https://arxiv.org/abs/2205.14135">FlashAttention</a> was released 6 months ago, it has been adopted by many organizations and research labs to speed up their training &amp; inference (see this <a href="https://github.com/HazyResearch/flash-attention/blob/main/usage.md">page</a> for a partial list).</p>
<p>For the last 2 months I’ve been collaborating with Adept as a part-time research fellow and we’ve been developing some improvements to FlashAttention to make it even better! In this post, we describe one key improvement that we’re particularly excited about: making FlashAttention fast for long sequences to enable training large language models with longer context.</p>
<p>As an example, for sequence length 8k, FlashAttention is now up to 2.7x faster than a standard Pytorch implementation, and up to 2.2x faster than the optimized implementation from Megatron-LM, even at small batch size. As we will see, training with longer context yields higher quality models. As we’ve <a href="https://ai.stanford.edu/blog/longer-sequences-next-leap-ai/">mentioned</a> before, we believe that modeling longer sequences could help us take the next leap in AI, and FlashAttention is one component to scale Transformers to longer context. At Adept, we’ve been training large Transformers (<a href="https://www.adept.ai/blog/act-1">ACT-1</a>) to take actions with the goal of building an AI teammate. Understanding webpages, software tool interfaces, and multi-turn user interactions can require contexts that far exceed the common 2k standard.</p>
<h2 id="motivation-long-sequences">Motivation: Long sequences</h2>
<p>Scaling up the context length of Transformers is a challenge, since the multihead attention layer at their heart has runtime and memory requirement quadratic in the input sequence length. Ideally, we would like to go beyond the standard 2k sequence length limit to train models to understand books, high resolution images, webpages, multi-turn user interactions, and long-form videos.</p>
<p>FlashAttention is an algorithm that reorders the attention computation and leverages classical techniques (tiling, recomputation) to significantly speed it up and reduce memory usage from quadratic to linear in sequence length. This works great for most cases, but it was not optimized for the case of super long sequences (where batch sizes and numbers of heads are small) due to insufficient parallelism. If one trains large Transformers on long sequences with modern parallelism techniques (data parallel, pipeline parallel, tensor parallel) to split the data and model among many GPUs, the batch size can get very small (e.g. batch size of 1 with pipeline parallelism, and number of heads around 8-12 with tensor parallelism). This is the case we would like to optimize for.</p>
<h2 id="attention-parallelism-to-optimize-for-long-sequences">Attention parallelism to optimize for long sequences</h2>
<p>For each attention head, to reduce memory reads/writes, FlashAttention uses classical tiling techniques to load blocks of query, key, and value from GPU HBM (its main memory) to SRAM (its fast cache), compute attention with respect to that block, and write back the output to HBM. This reduction in memory reads/writes brings significant speedup (2-4x) in most cases.</p>
<figure><img src="https://www.adept.ai/images/blog/flashier-attention/01.png"/></figure>
<p>The first version of FlashAttention parallelizes over batch size and number of heads. For those familiar with CUDA programming, we use 1 <a href="https://en.wikipedia.org/wiki/Thread_block_(CUDA_programming)">thread block</a> to process one attention head, and there are overall batch_size * num_heads threadblocks. Each thread block is scheduled to run on a streaming multiprocessor (SM), and there are 108 of these SMs on an A100 GPU for example. This scheduling is efficient when batch_size * num_heads is large (say &gt;= 80), since we can effectively use almost all of the compute resources on the GPU.</p>
<p>In the case of long sequences (which usually means small batch sizes or small number of heads), to make better use of the multiprocessors on the GPU, we now additionally parallelize over the sequence length dimension. This results in significant speedup for this regime.</p>
<p>Here is the forward pass computation expressed schematically. We have multiple workers (i.e. thread blocks) to process one attention head, and each worker takes care of a block of rows of the attention matrix. As the rows of the attention matrix don’t depend on each other, we don’t need to communicate between the workers.</p>
<p>In the backward pass, we parallelize things slightly differently: each worker now takes care of a block of columns of the attention matrix. The workers need to communicate to aggregate the gradient with respect to the query, which can be done with <a href="https://on-demand.gputechconf.com/gtc/2013/presentations/S3101-Atomic-Memory-Operations.pdf">atomic operations</a>. We found that parallelizing by columns here is faster than parallelizing by rows due to the reduced communication between the workers (parallelizing by columns requires aggregating the gradient of the query, while parallelizing by rows requires aggregating the gradient of the key and value).</p>
<figure><img src="https://www.adept.ai/images/blog/flashier-attention/02.png"/></figure>
<p>Image caption: In the forward pass, we parallelize the workers (thread blocks) where each worker takes care of a block of rows of the attention matrix. In the backward pass, each worker takes care of a block of rows of the attention matrix.</p>
<p>Attention layer benchmark: We compare here the time taken by the forward + backward pass, as we increase the sequence length (and decrease the batch size to keep the total number of tokens the same). We keep the number of heads at 12 and head dimension at 128. Time is measured on an A100 40GB GPU. Compared to Pytorch and Megatron-LM attention implementations, FlashAttention is between 2.2x and 2.7x faster for longer sequences (8k).</p>
<figure><img src="https://www.adept.ai/images/blog/flashier-attention/03.png"/></figure>
<p>End-to-end training benchmark: when we use FlashAttention to train Transformers of size up to 2.7B on sequences of length 8k, we achieve a training efficiency of up to 175 TFLOPs/sec per A100 (equivalent to model FLOPs efficiency of 56%, we don’t need to do any activation checkpointing). This is 2.2 times faster than Megatron-LM, as shown in the figure below. Moreover, training with 8k context length with FlashAttention is only 7% less hardware efficient than training with 2k context length, as compared to Megatron-LM where increasing context length from 2k to 8k drops hardware efficiency by 1.9x. FlashAttention has made it much easier to train on long sequences.</p>
<figure><img src="https://www.adept.ai/images/blog/flashier-attention/04.png"/></figure>
<h2 id="evaluation-better-language-models-with-longer-sequence-lengths">Evaluation: better language models with longer sequence lengths</h2>
<p>We train GPT3 models with 1.3B and 2.7B parameters for 400B tokens on the <a href="https://arxiv.org/abs/2101.00027">Pile</a>, with either 2K or 8K context. On both pretraining metrics (validation perplexity) and downstream evaluation (e.g. accuracy on the ChapterBreak challenge dataset), models with longer context outperforms models with shorter context.</p>
<p><img src="https://www.adept.ai/images/blog/flashier-attention/05-table.png" alt="FlashAttention table"/></p><p>We evaluate these models on the <a href="https://arxiv.org/abs/2204.10878">ChapterBreak</a> dataset (a challenge dataset for long-range language models where one is supposed to distinguish the right text that follows a chapter break). As one increases the context length, the accuracy of the models increases.</p>
<figure><img src="https://www.adept.ai/images/blog/flashier-attention/05.png"/></figure>
<p>On both metrics, increasing the context length beyond the standard 2K yields consistent quality improvement.</p>
<h2 id="looking-forward-more-use-cases-for-long-sequence-lengths">Looking forward: more use cases for long sequence lengths</h2>
<p>FlashAttention is just a step towards equipping models with long context, by making it fast to train models on long sequences. ML models are now widely deployed, interacting with billions of users a day. As these models become more personalized, capturing the history of user interaction becomes crucial. The future AI agents should be able to remember its past actions and users’ feedback. Moreover, as ML models are going to be multi-modal (e.g., text, vision, speech, etc.), long context modeling will play an even bigger role. Long context will allow models to understand books, high resolution images, and videos.</p>
<p>We are excited about this vision! If you have an application that you think could benefit from these ideas, please let us know!</p>
<p><a href="https://tridao.me/">Tri Dao</a></p>
<hr/>

</div></div>
  </body>
</html>
