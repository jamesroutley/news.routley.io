<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fossa.com/blog/understanding-purl-specification-package-url/">Original</a>
    <h1>Understanding the PURL Specification (Package URL)</h1>
    
    <div id="readability-page-1" class="page"><div><p>The Package URL (PURL) specification is an open standard for uniquely identifying software packages across different ecosystems. It was <a href="https://aboutcode.org/2023/purl-universal-software-package-identification">created in 2017</a> by Philippe Ombredanne, an open source tooling maintainer who needed a better way to standardize references to software packages.</p>
<p>A PURL is a specially formatted URL that describes a software package&#39;s location or identity in a package registry. It encodes the package type (e.g. npm, Maven, PyPI), the name (and optional group or namespace), version, and other qualifiers in a single string.</p>
<p>PURL&#39;s purpose is to provide a simple, universal identifier for software components, making it easy to track and share what components are in your software. Although PURL has several important use cases, the combination of its universal properties and machine-readability in particular have made it an essential part of enabling the modern SBOM landscape.</p>
<p>In this blog, we&#39;ll explain in more depth how PURL works (including differences in different ecosystems), how it’s used in <a href="https://fossa.com/learn/sboms/">SBOMs</a>, how it compares to CPE and other component identifiers, and more.</p>
<h2 id="how-purl-works"><a aria-label="Link to section" href="#how-purl-works"><span></span></a>How PURL Works</h2>
<p>A Package URL is structured similarly to a web URL, with multiple components separated by specific symbols. The general syntax is:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="text" data-theme="github-dark"><code data-language="text" data-theme="github-dark"><span data-line=""><span>pkg:&lt;type&gt;/</span></span>
<span data-line=""><span>    &lt;namespace&gt;/</span></span>
<span data-line=""><span>    &lt;name&gt;@&lt;version&gt;</span></span>
<span data-line=""><span>    ?&lt;qualifiers&gt;#&lt;subpath&gt;</span></span></code></pre></figure>
<p>Each part of this string has a specific meaning, which we&#39;ll outline below; you can also reference the <a href="https://github.com/package-url/purl-spec">PURL Spec’s GitHub README</a> and <a href="https://github.com/package-url/purl-spec/blob/main/PURL-TYPES.rst">PURL Types page</a> for additional context.</p>
<p><strong>Required Fields</strong></p>
<ul>
<li>
<p><strong><code>scheme</code>:</strong> The scheme is always <code>pkg</code>, indicating a package URL (just like <code>http</code> or <code>https</code> in web URLs). This constant prefix helps tools recognize a PURL immediately.</p>
</li>
<li>
<p><strong><code>type</code>:</strong> The package <em>type</em> or ecosystem, such as <code>npm</code>, <code>maven</code>, <code>pypi</code>, <code>nuget</code>, <code>gem</code> (RubyGems), etc.</p>
</li>
<li>
<p><strong><code>name</code>:</strong> The name of the package (artifact or module name).</p>
</li>
</ul>
<p><strong>Optional Fields</strong></p>
<ul>
<li>
<p><strong><code>namespace</code>:</strong> An optional namespace or group for the package, which is specific to the ecosystem. For example, in Maven, this would be the groupId (<code>org.apache.logging.log4j</code>), in Docker it might be an image owner, or in GitHub it could be an organization/user. Not all ecosystems have namespaces.</p>
</li>
<li>
<p><strong><code>version</code>:</strong> The version of the package (if applicable). Not all PURLs include a version (e.g. if you want to refer to a package in general), but typically an SBOM or vulnerability reference will include a specific version here.</p>
</li>
<li>
<p><strong><code>qualifiers</code>:</strong> Additional key-value pairs to further qualify the package, prefixed by <code>?</code> and separated by <code>&amp;</code>. Qualifiers are optional and depend on the package type.</p>
</li>
<li>
<p><strong><code>subpath</code>:</strong> An optional subpath within the package, appended after a <code>#</code>. This can point to a specific file or directory inside the package. It&#39;s used when you need to reference a particular piece of a package&#39;s content.</p>
</li>
</ul>
<p>It&#39;s important to note that while the above fields are optional when determining whether a PURL is valid, in practice, they play very important roles in making it possible to uniquely identify a package. Specifically, namespace and version are important for all ecosystems, and qualifier and subpath are important in particular for Linux ecosystems.</p>
<p>To help bring everything together, let&#39;s consider an example PURL for a Maven Central artifact:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="text" data-theme="github-dark"><code data-language="text" data-theme="github-dark"><span data-line=""><span>pkg:maven/</span></span>
<span data-line=""><span>    org.apache.logging.log4j/</span></span>
<span data-line=""><span>    log4j-core@2.14.1</span></span></code></pre></figure>
<p>This identifies the Apache Log4j Core library version 2.14.1 from the Maven ecosystem (groupId org.apache.logging.log4j, artifactId log4j-core).</p>
<h3 id="purl-ecosystem-coverage"><a aria-label="Link to section" href="#purl-ecosystem-coverage"><span></span></a>PURL Ecosystem Coverage</h3>
<p>PURL supports a broad array of programming language ecosystems and package managers out of the box. Common types include <code>npm</code> (Node.js/JavaScript packages), <code>pypi</code> (Python packages), <code>maven</code> (Java artifacts), <code>nuget</code> (.NET packages), <code>gem</code> (Ruby Gems), <code>golang</code> (Go modules), <code>cargo</code> (Rust crates), <code>docker</code> (container images), and system packages like <code>deb</code> (Debian/Ubuntu) or <code>rpm</code> (Fedora/RedHat).</p>
<p>Each type definition specifies how to interpret the namespace and qualifiers for that ecosystem. For instance, Docker PURLs use the image name as the name and tag or digest as the version (e.g. <code>pkg:docker/nginx@1.21.0</code> or by digest), and may use a qualifier for the registry URL.</p>
<p>There&#39;s even a <code>generic</code> type as a catch-all for things that don&#39;t fit an existing ecosystem (for example, a proprietary or legacy component) or for ecosystems that build custom distributions, such as yocto or buildroot. We should note, however, that SBOM and software composition analysis tools vary widely in their ability to understand generic PURLs, so we do recommend you talk to your current (or prospective) vendor if this is an important feature for you.</p>
<h2 id="purl-and-sboms"><a aria-label="Link to section" href="#purl-and-sboms"><span></span></a>PURL and SBOMs</h2>
<p>The most common Package URL use case that we see today is the role it plays in enabling the SBOM (software bill of materials) ecosystem. SBOMs are essentially a list of components (libraries, frameworks, modules, etc.) that make up a software product, and PURLs play a critical role in SBOMs by acting as the unique identifiers for each component.</p>
<p>The NTIA&#39;s 2021 publication on <a href="https://fossa.com/blog/minimum-required-elements-software-bill-of-materials/">mandatory SBOM minimum elements</a> doesn&#39;t explicitly require PURL; rather, it lists PURL as one of several candidates for the mandatory software component identifier field. However, in our extensive practice supporting SBOM programs across multiple customers, it&#39;s become crystal clear that using PURLs — more so than any other type of identifier — is the best way to ensure SBOM accuracy and usability.</p>
<p>One big reason is that PURLs are vital to unlocking SBOM enrichment. Consider the example of an SBOM that includes open source licensing information. PURL will allow the SBOM consumer to verify that the stated licenses are actually the ones associated with a given component, not just the ones the SBOM producer decided to include. The same holds true on the vulnerability side.</p>
<p>In addition to enriching inaccurate or incomplete data, PURL helps SBOM consumers fill in anything that&#39;s missing entirely from an SBOM. We often see this with supplier fields as well as licensing and copyright information. (Licensing fields aren&#39;t required per the NTIA minimum elements, so enrichment comes in handy for SBOM consumers who care about the license compliance use case.)</p>
<p>As you might expect, both the <a href="https://fossa.com/learn/cyclonedx/">CycloneDX</a> and <a href="https://fossa.com/learn/spdx/">SPDX</a> SBOM formats support PURL. For example, a CycloneDX SBOM will list each dependency with something like:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="json" data-theme="github-dark"><code data-language="json" data-theme="github-dark"><span data-line=""><span>{</span></span>
<span data-line=""><span>  &#34;name&#34;</span><span>: </span><span>&#34;lodash&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;version&#34;</span><span>: </span><span>&#34;4.17.21&#34;</span><span>,</span></span>
<span data-line=""><span>  &#34;purl&#34;</span><span>: </span><span>&#34;pkg:npm/lodash@4.17.21&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>SPDX also supports PURLs, though in a slightly different way. In SPDX v2.2 and later, Package URLs can be included as an <strong>External Reference</strong> of type: <code>purl</code> on a package entry.</p>
<p>The alignment of both major <a href="https://fossa.com/blog/sbom-formats-compared-explained/">SBOM formats</a> in supporting PURL underscores its importance. It allows SBOM producers and consumers to consistently identify components even when converting between CycloneDX and SPDX formats (so no component gets “lost in translation” due to naming differences).</p>
<h2 id="purl-vs-cpe"><a aria-label="Link to section" href="#purl-vs-cpe"><span></span></a>PURL vs. CPE</h2>
<p>Another commonly used software identifier is <strong>CPE (Common Platform Enumeration)</strong>. CPE is an older standard (maintained by NIST) for identifying software products, widely used in vulnerability databases like the U.S. National Vulnerability Database (NVD). Both CPE and PURL are machine-readable naming schemes for software, but they were designed for different contexts and have distinct advantages.</p>
<h3 id="similarities-between-purl-and-cpe"><a aria-label="Link to section" href="#similarities-between-purl-and-cpe"><span></span></a>Similarities Between PURL and CPE</h3>
<p>Both PURL and CPE aim to uniquely identify a piece of software in a structured format, and both use a standardized syntax. In fact, all modern identifiers (including SWID tags and others) <a href="https://faddom.com/common-platform-enumeration/">provide a way</a> to include key metadata like name and version in a machine-parsable string. This means in theory, either could be used to index vulnerabilities or list components.</p>
<p>Additionally, CPE and PURL aren&#39;t mutually exclusive — it&#39;s possible to include both in an SBOM or database for completeness. Both identifiers also require some agreed-upon namespace of naming (CPE has a dictionary of vendor and product names; PURL relies on package ecosystems&#39; naming conventions). And, importantly, both are recognized by standards bodies (CPE by NIST/ISO, PURL <a href="https://tc54.org/purl/">in progress via ECMA</a>).</p>
<h3 id="differences-between-cpe-and-purl"><a aria-label="Link to section" href="#differences-between-cpe-and-purl"><span></span></a>Differences Between CPE and PURL</h3>
<p>CPE was designed to identify IT products and platforms, primarily for inventorying enterprise software and linking to vulnerabilities in the NVD. A CPE name also has a rigid format: e.g.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="text" data-theme="github-dark"><code data-language="text" data-theme="github-dark"><span data-line=""><span>cpe:2.3:a:apache:</span></span>
<span data-line=""><span>    log4j:1.2.17:</span></span>
<span data-line=""><span>    *:*:*:*:*:*:*</span></span></code></pre></figure>
<p>This encodes vendor (<code>apache</code>), product (<code>log4j</code>), version (<code>1.2.17</code>), and other fields (like edition, language, etc.). It works well for software where there is a clear vendor-product pairing (often commercial or big software packages).</p>
<p>PURL, on the other hand, is <em>package-focused</em>, born out of the open source package world. It captures the package manager context (e.g. Maven vs npm) which CPE lacks, and it aligns with how developers obtain the software (via package repositories).</p>
<p>Another difference is complexity vs simplicity. CPE strings can be complex and sometimes require referencing a dictionary to get the naming right (for instance, knowing that “Apache Log4j” in CPE is vendor=<code>apache</code> product=<code>log4j</code>). There may be multiple CPE entries for what a developer thinks of as one library (due to different editions or platforms), and conversely, not all open source libraries have CPEs assigned unless a vulnerability is found and someone created them in the NVD. PURLs are more straightforward — they use the names as found in package ecosystems and don’t require a central authority to define each product.</p>
<p>As <a href="https://aboutcode.org/2023/purl-universal-software-package-identification/#:~:text=In%20contrast%2C%20identifiers%20previously%20used,CPE">PURL founder Philippe Ombredanne explained</a>, identifying a vulnerable library via PURL is as easy as reading its observable attributes (name, version) from code or manifests, whereas CPE demands extra knowledge of an external naming scheme.</p>
<h3 id="why-fossa-recommends-purl"><a aria-label="Link to section" href="#why-fossa-recommends-purl"><span></span></a>Why FOSSA Recommends PURL</h3>
<p>Given the prevalence of open source, PURL is generally better at handling the “long tail” of thousands of library dependencies. It&#39;s already used in many vulnerability intelligence sources. In fact, almost every major vulnerability database besides the NVD has started using PURLs or similar package identifiers.</p>
<p>Like we mentioned earlier, accurate component identification is the foundation of successful vulnerability management and SBOM initiatives, and PURL solves many of the issues that exist with CPEs — including that user-provided CPEs might be too generic or use wildcards, leading to false matches.</p>
<p>In fairness, we should also note PURL&#39;s one major downside: lack of commercial product support. There aren&#39;t many (if any) registered types/namespaces for commercial products in PURL. This is an area where CPE is generally a better option (and is a big reason why CPE and PURL can be viewed as complementary).</p>
<h2 id="purl-the-bottom-line"><a aria-label="Link to section" href="#purl-the-bottom-line"><span></span></a>PURL: The Bottom Line</h2>
<p>The Package URL (PURL) specification plays an important role in standardizing how developers and organizations identify and manage software components. In order to properly associate existing and new vulnerabilities or licenses, organizations need an ability to first uniquely identify packages. And, like we discussed earlier in this post, our view is that PURL is the unique identifier most suited for accurate and scalable software supply chain transparency and security initiatives.</p>
<p>For more information on all things software supply chain security — and to learn how your team can use FOSSA to automate SBOM and open source vulnerability management — you can <a href="https://fossa.com/products/scan/">check out our website</a>.</p></div></div>
  </body>
</html>
