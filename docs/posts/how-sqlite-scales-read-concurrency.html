<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/sqlite-internals-wal/">Original</a>
    <h1>How SQLite Scales Read Concurrency</h1>
    
    <div id="readability-page-1" class="page"><section> <img src="https://podviaznikov.com/blog/2022-08-24/cover.jpg" alt="A photo album of all my beloved sandwiches."/> <p><a href="http://fly.io/">Fly.io</a> runs apps close to users around the world, by taking containers and upgrading them to full-fledged virtual machines running on our own hardware around the world. Sometimes those containers run SQLite and we make that easy too. <a href="https://fly.io/docs/speedrun/">Give us a whirl</a> and get up and running quickly.</p><p>If you scour Hacker News &amp; Reddit for advice about databases, some common words of caution are that SQLite doesn&#39;t scale or that it is a single-user database and it&#39;s not appropriate for your web-scale application.</p> <p>Like any folklore, it has some historical truth. But it&#39;s also so wildly out-of-date.</p> <p>In our <a href="https://podviaznikov.com/blog/sqlite-internals-rollback-journal/">last post</a>, we talked about the <em>rollback journal.</em> That was SQLite&#39;s original transactional safety mechanism and it left much to be desired in terms of scaling.</p> <p>In 2010, SQLite introduced a second method called the <em>write-ahead log</em>, or as it&#39;s more commonly referred to: the WAL.</p> <h2 id="refresher-on-the-rollback-journal"><a href="#refresher-on-the-rollback-journal" aria-label="Anchor"></a>Refresher on the Rollback Journal</h2><p>The rollback journal worked by copying the old version of changed pages to another file so that they can be copied back to the main database file if the transaction rolls back.</p> <p>The WAL does the opposite. It writes the new version of a page to another file and leaves the original page in-place in the main database file.</p> <p>So how does this simple change enable SQLite to scale? Let&#39;s revisit our sandwich shop example from the <a href="https://podviaznikov.com/blog/sqlite-internals-rollback-journal/">last post</a> to see how the WAL would make things run more smoothly.</p> <h2 id="sandwiches-at-scale"><a href="#sandwiches-at-scale" aria-label="Anchor"></a>Sandwiches at Scale</h2><p>In our sandwich shop example, we had to choose between a single sandwich maker making sandwiches and one or more inventory specialists inventorying ingredients. We couldn&#39;t do both at the same time. This is how the rollback journal works; a writer can alter the database or readers can read from the database—but not both at the same time.</p> <p>This is a problem since making a complicated, time-consuming sandwich will prevent inventory from being taken. Also, a single slow inventory counter will prevent any sandwiches from being made.</p> <p>A simple solution would be to take a photo of every ingredient after a sandwich is made. That way inventory counters could look at the photos to take inventory. However, it would be slow and inefficient to take a photo of every ingredient after a sandwich since many ingredients wouldn&#39;t change. For example, if you&#39;re making a grilled cheese then you&#39;re not going to touch the pickles, right? Right!?</p> <p>A better solution would be to only take photos of the ingredients you took from after each sandwich. You can add these photos to a binder and now the inventory folks can see a point-in-time snapshot of the ingredients without interfering with the sandwich maker.</p> <p>This is how the WAL works, in concept.</p> <h2 id="enabling-the-sandwich-log"><a href="#enabling-the-sandwich-log" aria-label="Anchor"></a>Enabling the Sandwich Log</h2><p>Let&#39;s create a <code>sandwiches.db</code> that will store our current count of ingredients:</p> <div><pre><code><span>CREATE</span> <span>TABLE</span> <span>ingredients</span> <span>(</span>
    <span>id</span> <span>INTEGER</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
    <span>name</span> <span>TEXT</span><span>,</span>
    <span>count</span> <span>INTEGER</span>
<span>);</span>
</code></pre></div><p>To enable our write-ahead log journaling mode, we just need to use the <code>journal_mode</code> PRAGMA:</p> <div><pre><code><span>PRAGMA</span> <span>journal_mode</span> <span>=</span> <span>wal</span><span>;</span>
</code></pre></div><p>Internally, this command performs a rollback journal transaction to update the database header so it&#39;s safe to use like any other transaction. The database header has a read &amp; write version at bytes 18 &amp; 19, respectively, that are used to determine the journal mode. They&#39;re set to <code>0x01</code> for rollback journal and <code>0x02</code> for write-ahead log. They&#39;re typically both set to the same value.</p> <h2 id="altering-the-ingredient-count"><a href="#altering-the-ingredient-count" aria-label="Anchor"></a>Altering the Ingredient Count</h2><p>Now that we are using the WAL, we can add our initial inventory counts:</p> <div><pre><code><span>INSERT</span> <span>INTO</span> <span>ingredients</span> <span>(</span><span>name</span><span>,</span> <span>count</span><span>)</span>
<span>VALUES</span> <span>(</span><span>&#39;onions&#39;</span><span>,</span> <span>10</span><span>),</span> <span>(</span><span>&#39;tomatoes&#39;</span><span>,</span> <span>5</span><span>),</span> <span>(</span><span>&#39;lettuce&#39;</span><span>,</span> <span>20</span><span>);</span>
</code></pre></div><p>Instead of updating our <code>sandwiches.db</code> database file, our change is written to a <code>sandwiches.db-wal</code> file in the same directory. Let&#39;s fire up our <code>hexdump</code> tool and see what&#39;s going on.</p> <h3 id="starting-with-the-wal-header"><a href="#starting-with-the-wal-header" aria-label="Anchor"></a>Starting With the WAL Header</h3><p>The WAL file starts with a 32-byte header:</p> <div><pre><code>377f0682 002de218 00001000 00000000 5a20ee38 f926b5d3 0dd5236d 9972220b
</code></pre></div><p>Most SQLite files start with a <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a> and the WAL is no exception. Every WAL file starts with either <code>0x377f0682</code> or <code>0x377f0683</code> which indicate whether checksums in the file are in little-endian or big-endian format, respectively. Nearly all modern processors are little-endian so you&#39;ll almost always see <code>0x377f0682</code> as the first 4 bytes of a SQLite WAL file.</p> <p>Next, the <code>0x002de218</code> is the WAL format version. This is the big-endian integer representation of <code>3007000</code> which means it&#39;s the WAL version created in SQLite 3.7.0. There&#39;s currently only one version number for WAL files.</p> <p>The next four bytes, <code>0x00001000</code>, are the page size. We&#39;re using the default page size of 4,096 bytes. The next four after that are <code>0x00000000</code> which is the checkpoint sequence number. This is a number that gets incremented on each <em>checkpoint</em>. We&#39;ll discuss checkpointing later in this post.</p> <p>After that, we have an 8-byte &#34;salt&#34; value of <code>0x5a20ee38f926b5d3</code>. The term &#34;salt&#34; is typically used in cryptography (and sandwiches, actually) but in this case it&#39;s a little different. Sometimes the WAL needs to restart from the beginning but it doesn&#39;t always delete the existing WAL data. Instead it just overwrites the previous WAL data.</p> <p>In order for SQLite to know which WAL pages are new and which are old, it writes the salt to the WAL header and every subsequent WAL frame. If SQLite encounters a frame whose salt doesn&#39;t match the header&#39;s salt, then it knows that it&#39;s a frame from an old version of the WAL and it ignores it.</p> <p>Finally, we have an 8-byte checksum of <code>0x0dd5236d9972220b</code> which is meant to verify the integrity of the WAL header and prevent partial writes. If we accidentally overwrite half the header and then the computer shuts down, we can detect that by calculating and comparing the checksum.</p> <h3 id="adding-wal-entries"><a href="#adding-wal-entries" aria-label="Anchor"></a>Adding WAL Entries</h3><p>The WAL works by appending new data to the <code>-wal</code> file so we&#39;ll see an entry for a single page in our WAL file. It starts with a 24-byte header and then writes 4,096 bytes of page data.</p> <div><pre><code>00000002 00000002 5a20ee38 f926b5d3 5333783e 42122b82 [page data...]
</code></pre></div><p>The first 4 bytes, <code>0x00000002</code>, are the page number for the entry. This is saying that our page data following the header is meant to overwrite page 2.</p> <p>The next 4 bytes, also <code>0x00000002</code>, indicate the database size, in pages, after the transaction. This field actually performs double duty. For transactions that alter multiple pages, this field is only set on the last page in the transaction. Earlier pages set it to zero. This means we can delineate sections of the WAL by transaction. It also means that a transaction isn&#39;t considered &#34;committed&#34; until the last page is written to the WAL file.</p> <p>After that we see our salt value <code>0x5a20ee38f926b5d3</code> copied from the header. This lets us know that it is a contiguous block of WAL entries starting from the beginning of the WAL. Finally, we have an 8-byte checksum of <code>0x5333783e42122b82</code> which is computed based on the WAL header checksum plus the data in the WAL entry and page data.</p> <h3 id="overlaying-our-wal-pages"><a href="#overlaying-our-wal-pages" aria-label="Anchor"></a>Overlaying Our WAL Pages</h3><p>Every transaction that occurs will simply write the new version of changed pages to the end of the WAL file. This append-only approach gives us an interesting property. The state of the database can be reconstructed at any point in time simply by using the latest version of each page seen in the WAL starting from a given transaction.</p> <p>In the diagram below, we have the logical view of a b-tree inside SQLite and an associated WAL file with 3 transactions. Before the WAL file exists, we have three pages in our database, represented in black.</p> <p>The first transaction (in green) updates pages 1 and 2. A snapshot of the database after this transaction can be constructed by using WAL entries for pages 1 and 2 and the original page from the database for page 3.</p> <p>Our second transaction (in red) only updates page 2. If we want a snapshot after this transaction, we&#39;ll use page 1 from the first transaction, page 2 from the second transaction, and page 3 from the database file.</p> <p>The last transaction (in orange) updates pages 2 &amp; 3 so the entire b-tree is now read from the WAL.</p> <p><img src="https://podviaznikov.com/blog/2022-08-24/btrees.png" alt="Several states of the b-tree as represented in transactions starting at different points of time."/></p> <p>The beauty of this approach is that we are no longer overwriting our pages so every transaction can reconstruct its original state from when it started. It also means that write transactions can occur without interfering with in-progress read transactions.</p> <h2 id="retiring-our-gastronomical-photo-album"><a href="#retiring-our-gastronomical-photo-album" aria-label="Anchor"></a>Retiring Our Gastronomical Photo Album</h2><p>You may have noticed one problem with our append-only album of ingredient photos—it keeps getting bigger. Eventually it will become too large to handle. Also, we really don&#39;t care about the ingredient photos that we took 400 sandwiches ago. We only want to allow sandwich makers and inventory counters to do their work at the same time.</p> <p>In SQLite, we resolve this issue with the &#34;checkpointing&#34; procedure. Checkpointing is when SQLite copies the latest version of each page in the WAL back into the main database file. In our diagram below, page 1 is copied from the first transaction but pages 2 &amp; 3 are copied from the third transaction. The prior versions of page 2 are ignored because they are not the latest.</p> <p><img src="https://podviaznikov.com/blog/2022-08-24/checkpointing.png" alt="The latest version of each page is copied back to the main database in a process called checkpointing."/></p> <p>SQLite can perform this process incrementally when old transactions are not in use but eventually, it needs to wait until there are no active transactions if it wants to fully checkpoint and restart the WAL file.</p> <p>This naive approach can be problematic on databases that constantly have open transactions as SQLite will not force a checkpoint on its own and the WAL file can continue to grow. You can force SQLite to block new read &amp; write transactions so it can restart the WAL by issuing a <a href="https://www.sqlite.org/pragma.html#pragma_wal_checkpoint">wal_checkpoint</a> PRAGMA:</p> <div><pre><code><span>-- restart but don&#39;t truncate WAL</span>
<span>PRAGMA</span> <span>wal_checkpoint</span><span>(</span><span>RESTART</span><span>);</span>
</code></pre></div><p>or</p> <div><pre><code><span>-- restart and truncate WAL to zero bytes</span>
<span>PRAGMA</span> <span>wal_checkpoint</span><span>(</span><span>TRUNCATE</span><span>);</span>
</code></pre></div><h2 id="building-a-photo-index"><a href="#building-a-photo-index" aria-label="Anchor"></a>Building a Photo Index</h2><p>As our photo album grows, it gets slower to find the latest version of each photo in order to reconstruct our sandwich shop state. You have to start from the beginning of the album and find the last version of a page every time you want to look up a photo.</p> <p>A better option would be to have an index in the photo album that lists all the locations of photos for each ingredient. Let&#39;s say you have 20 photos of banana peppers. You can look up &#34;banana peppers&#34; in the index and find the location of the latest one in the album.</p> <h3 id="writing-our-index"><a href="#writing-our-index" aria-label="Anchor"></a>Writing Our Index</h3><p>SQLite builds a similar index and it&#39;s stored in the &#34;shared memory&#34; file, or SHM file, next to the database and WAL files.</p> <p>But SQLite&#39;s index is a bit funny looking at first glance: it&#39;s a list of page numbers and a hash map. The goal of the index is to tell the SQLite client the latest version of a page in the WAL up to a given position in the WAL. Since each transaction starts from a different position in the WAL, they can have different answers to exactly which version of a page they see.</p> <p>The SHM index is built out of 32KB blocks that each hold 4,096 page numbers and a hash map of 8,192 slots. When WAL entries are written, their page numbers are inserted into the SHM&#39;s page number list in WAL order. Then a hash map position is calculated based on the page number and the index of the page number is stored in the hash map.</p> <p>Clear as mud? Let&#39;s walk through an example.</p> <p><img src="https://podviaznikov.com/blog/2022-08-24/shm.png" alt="Diagram of the shared memory file which is constructed of a list of page number and a hash map to the indexes of the page number list."/></p> <p>In the diagram above, our first transaction in the WAL (green) updates pages 1 &amp; 2. They get written to the WAL, but the page numbers are also added to the page numbers list in the SHM file. SQLite calculates a hash map slot position for each page using the formula: <code>(pgno * 383)%8192</code>. In the hash map slot, we&#39;ll write the index of the page in our page number list. This is also <code>1</code> &amp; <code>2</code>, respectively. Don&#39;t read too much into the exact hash map positions in the diagram. There&#39;s some loss of fidelity in simplifying 8,192 slots down to 14!</p> <p>This hash-based mapping will generally spread out our page numbers across our hash map and leave empty space between them. Also, we are guaranteed to have a lot of empty slots in the hash map since there are double the number of hash map slots as there are page number spots. This will be useful when looking up our pages later.</p> <p>Our next transaction (red) only updates page 2. We&#39;ll write that page to the third entry in our page number list. However, when we calculate our hash map position, we have a collision with the entry for page 2 in transaction 1. They both point at the same slot. So instead of writing to that slot, we&#39;ll write our page number list index, <code>3</code>, to the next empty slot.</p> <p>Finally, our third transaction updates pages 2 &amp; 3. We&#39;ll write those to indexes <code>4</code> &amp; <code>5</code> in our page number list and then write those indexes to our hash map slots. Again, our page 2 collides with updates in the first two transactions so we&#39;ll write the index to the first empty slot after the hash map position.</p> <h3 id="reading-our-index"><a href="#reading-our-index" aria-label="Anchor"></a>Reading Our Index</h3><p>Now that we have our index built, we can quickly look up the latest version of any given page for a transaction. Let&#39;s say we&#39;ve started a read transaction just after transaction #2 completed. We only want to consider versions of pages in the WAL up to entry #3 since WAL entries in index 4 &amp; 5 occurred after our read transaction started.</p> <p>If we want to look up page 2, we&#39;ll first calculate the hash position and then read all the indexes until we reach an empty slot. For page 2, this is indexes 2, 3, &amp; 4. Since our transaction started at entry #3, we can ignore entries after index 3 so we can discard index 4. Out of this set, index 3 is the latest version so our SQLite transaction will read page 2 from WAL entry 3.</p> <p>Astute readers may notice that we can have collisions across multiple pages. What happens if page 2 &amp; page 543 in a database compute the same slot? SQLite will double check each entry in the page numbers list to make sure it&#39;s the actual page we&#39;re looking for and it will discard any others automatically.</p> <h2 id="choosing-a-journaling-strategy"><a href="#choosing-a-journaling-strategy" aria-label="Anchor"></a>Choosing a Journaling Strategy</h2><p>While there are always trade-offs between design choices, the vast majority of applications will benefit from WAL mode. The SQLite web site <a href="https://sqlite.org/wal.html">helpfully lists some edge cases</a> where the rollback journal would be a better choice such as when using multi-database transactions. However, those situations are rare for most applications.</p> <p>Now that you understand how data is stored and transactions are safely handled, we&#39;ll take a look at the query side of SQLite in our next post which will cover the SQLite Virtual Machine.</p>  </section></div>
  </body>
</html>
