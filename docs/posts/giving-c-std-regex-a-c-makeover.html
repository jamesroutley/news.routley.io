<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2024/09/04/">Original</a>
    <h1>Giving C&#43;&#43; std:regex a C makeover</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  
  <time datetime="2024-09-04">
    September 04, 2024
  </time>
  <p>
    nullprogram.com/blog/2024/09/04/
  </p>

  <p>Suppose you’re working in C using one of the major toolchains — that is,
it’s mainly a C++ implementation — and you need regular expressions. You
could integrate a library, but there’s a regex implementation in the C++
standard library included with your compiler, just within reach. As a
resourceful engineer, using an asset already in hand seems prudent. But
it’s a C++ interface, and you’re using C instead of C++ for a reason,
perhaps <em>to avoid dealing with C++</em>. Have no worries. This article is
about wrapping <a href="https://en.cppreference.com/w/cpp/regex"><code>std::regex</code></a> in a tidy C interface which not only
hides all the C++ machinery, but <em>utterly tames it</em>. It’s not so much
practical as a potpourri of interesting techniques.</p>

<p>If you’d like to skip ahead, here’s the full source up front. Tested with
<a href="https://github.com/skeeto/w64devkit">w64devkit</a>, MSVC <code>cl</code>, and <code>clang-cl</code>: <strong><a href="https://github.com/skeeto/scratch/tree/master/regex-wrap">scratch/regex-wrap</a></strong></p>

<h3 id="interface-design">Interface design</h3>

<p>The C interface I came up with, <code>regex.h</code>:</p>

<div><div><pre><code><span>#pragma once
#include</span> <span>&lt;stddef.h&gt;</span><span>
</span>
<span>#define S(s) (str){s, sizeof(s)-1}
</span>
<span>typedef</span> <span>struct</span> <span>{</span>
    <span>char</span>     <span>*</span><span>data</span><span>;</span>
    <span>ptrdiff_t</span> <span>len</span><span>;</span>
<span>}</span> <span>str</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>char</span> <span>*</span><span>beg</span><span>;</span>
    <span>char</span> <span>*</span><span>end</span><span>;</span>
<span>}</span> <span>arena</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>regex</span> <span>regex</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
    <span>str</span>      <span>*</span><span>data</span><span>;</span>
    <span>ptrdiff_t</span> <span>len</span><span>;</span>
<span>}</span> <span>strlist</span><span>;</span>

<span>regex</span>  <span>*</span><span>regex_new</span><span>(</span><span>str</span><span>,</span> <span>arena</span> <span>*</span><span>);</span>
<span>strlist</span> <span>regex_match</span><span>(</span><span>regex</span> <span>*</span><span>,</span> <span>str</span><span>,</span> <span>arena</span> <span>*</span><span>);</span>
</code></pre></div></div>

<p>Longtime readers will find it familiar: <a href="https://nullprogram.com/blog/2023/10/08/">my favorite</a> non-owning,
counted strings form in place of null-terminated strings — similar to C++
<code>std::string_view</code> — and <a href="https://nullprogram.com/blog/2023/09/27/">arena allocation</a>. Yes, such fundamental
types wouldn’t “belong” to a regex library like this, but imagine they’re
standardized by the project or whatever. Also, this is purely a C header,
not a C/C++ polyglot, and will not be used by the C++ portion.</p>

<p>In particular note the lack of “free” functions. <strong>The regex engine
allocates everything in the arena</strong>, including all temporary working
memory used while compiling, matching, etc. So in a sense, it could be
called <a href="https://nullprogram.com/blog/2018/06/10/">a <em>non-allocating library</em></a>. This requires a bit of C++
abuse: I will not call some C++ regex destructors. It shouldn’t matter
because they only redundantly manage memory in the arena.  (If regex
objects are holding file handles or something else unnecessary then its
implementation so poor as to not be worth using, and we should just use a
better regex library.)</p>

<p>Now’s a good time to mention a caveat: In order to pull this off the regex
library lives in its own Dynamic-Link Library with its own copy of the C++
standard library, i.e. statically linked. My demo is Windows-only, but
this concept theoretically extends to shared objects on Linux. Since it’s
a C interface that doesn’t expose standard library objects, the DLL can be
used by programs compiled with different toolchains. Though that wouldn’t
apply to my inciting hypothetical.</p>

<p>Example usage:</p>

<div><div><pre><code><span>regex</span>  <span>*</span><span>re</span> <span>=</span> <span>regex_new</span><span>(</span><span>S</span><span>(</span><span>&#34;(</span><span>\\</span><span>w+)&#34;</span><span>),</span> <span>perm</span><span>);</span>
<span>str</span>     <span>s</span>  <span>=</span> <span>S</span><span>(</span><span>&#34;Hello, world! This is a test.&#34;</span><span>);</span>
<span>strlist</span> <span>m</span>  <span>=</span> <span>regex_match</span><span>(</span><span>re</span><span>,</span> <span>s</span><span>,</span> <span>perm</span><span>);</span>
<span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>m</span><span>.</span><span>len</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>printf</span><span>(</span><span>&#34;%2td = %.*s</span><span>\n</span><span>&#34;</span><span>,</span> <span>i</span><span>,</span> <span>(</span><span>int</span><span>)</span><span>m</span><span>.</span><span>data</span><span>[</span><span>i</span><span>].</span><span>len</span><span>,</span> <span>m</span><span>.</span><span>data</span><span>[</span><span>i</span><span>].</span><span>data</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>This program prints:</p>

<div><div><pre><code> 0 = Hello
 1 = world
 2 = This
 3 = is
 4 = a
 5 = test
</code></pre></div></div>

<p>If matching lots of source strings, scope the arena to the loop and then
the results, and any regex working memory, are automatically freed in O(1)
at the end of each iteration:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>ninputs</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>arena</span>   <span>scratch</span> <span>=</span> <span>*</span><span>perm</span><span>;</span>
    <span>strlist</span> <span>matches</span> <span>=</span> <span>regex_match</span><span>(</span><span>re</span><span>,</span> <span>inputs</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>scratch</span><span>);</span>
    <span>// ... consume matches ...</span>
<span>}</span>
</code></pre></div></div>

<h3 id="c-implementation">C++ implementation</h3>

<p>On the C++ side the first thing I do is replace <code>new</code> and <code>delete</code>, which
is how I force it to allocate from the arena. This replaces <code>new</code>/<code>delete</code>
for <em>globally</em>, but recall that the regex library has its own, private C++
implementation. Replacements apply only to itself even if there’s other
C++ present in the process. If this is the only C++ in the process then it
doesn’t require such careful isolation.</p>

<p>I can’t tell <code>std::regex</code> about the arena — it calls <code>operator new</code> the
usual way, without extra arguments — so I have to smuggle it in through a
thread-local variable:</p>

<div><div><pre><code><span>static</span> <span>thread_local</span> <span>arena</span> <span>*</span><span>perm</span><span>;</span>
</code></pre></div></div>

<p>If I’m sure the library is only used by a single thread then I can omit
<code>thread_local</code>, but it’s useful here to demonstrate and measure. Using it
in my operator replacements:</p>

<div><div><pre><code><span>void</span> <span>*</span><span>operator</span> <span>new</span><span>(</span><span>size_t</span> <span>size</span><span>,</span> <span>std</span><span>::</span><span>align_val_t</span> <span>align</span><span>)</span>
<span>{</span>
    <span>arena</span>    <span>*</span><span>a</span>     <span>=</span> <span>perm</span><span>;</span>
    <span>ptrdiff_t</span> <span>ssize</span> <span>=</span> <span>size</span><span>;</span>
    <span>ptrdiff_t</span> <span>pad</span>   <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>a</span><span>-&gt;</span><span>end</span> <span>&amp;</span> <span>((</span><span>int</span><span>)</span><span>align</span> <span>-</span> <span>1</span><span>);</span>
    <span>if</span> <span>(</span><span>ssize</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>ssize</span> <span>&gt;</span> <span>a</span><span>-&gt;</span><span>end</span> <span>-</span> <span>a</span><span>-&gt;</span><span>beg</span> <span>-</span> <span>pad</span><span>)</span> <span>{</span>
        <span>throw</span> <span>std</span><span>::</span><span>bad_alloc</span><span>{};</span>
    <span>}</span>
    <span>return</span> <span>a</span><span>-&gt;</span><span>end</span> <span>-=</span> <span>size</span> <span>+</span> <span>pad</span><span>;</span>
<span>}</span>

<span>void</span> <span>*</span><span>operator</span> <span>new</span><span>(</span><span>size_t</span> <span>size</span><span>)</span>
<span>{</span>
    <span>return</span> <span>operator</span> <span>new</span><span>(</span>
        <span>size</span><span>,</span>
        <span>std</span><span>::</span><span>align_val_t</span><span>(</span><span>__STDCPP_DEFAULT_NEW_ALIGNMENT__</span><span>)</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Starting in C++17, replacing the global allocator requires definitions for
both plain <code>new</code>/<code>delete</code> and aligned <code>new</code>/<code>delete</code>. The <a href="https://en.cppreference.com/w/cpp/memory/new/operator_new">many other
variants</a>, including arrays, call these four and so may be skipped.
Allocating over-aligned objects isn’t a special case for arenas, so I
implemented plain <code>new</code> by calling aligned <code>new</code>. I’d prefer to <a href="https://nullprogram.com/blog/2024/04/14/">allocate
through a template</a> so that I can “see” the type, but that’s not an
option in this case.</p>

<p>After converting to signed sizes <a href="https://nullprogram.com/blog/2024/05/24/">because they’re simpler</a>, it’s the
usual from-the-end allocation. I prefer <code>-fno-exceptions</code> but <code>std::regex</code>
is inherently <em>exceptional</em> — and I mean that in at least two bad ways —
so they’re required. The good news is this library gracefully and reliably
handles out-of-memory errors. (The arena makes this trivial to test, so
try it for yourself!)</p>

<p>I added a little extra flair replacing <code>delete</code>:</p>

<div><div><pre><code><span>void</span> <span>operator</span> <span>delete</span><span>(</span><span>void</span> <span>*</span><span>)</span> <span>noexcept</span> <span>{}</span>
<span>void</span> <span>operator</span> <span>delete</span><span>(</span><span>void</span> <span>*</span><span>,</span> <span>std</span><span>::</span><span>align_val_t</span><span>)</span> <span>noexcept</span> <span>{}</span>

<span>void</span> <span>operator</span> <span>delete</span><span>(</span><span>void</span> <span>*</span><span>p</span><span>,</span> <span>size_t</span> <span>size</span><span>)</span> <span>noexcept</span>
<span>{</span>
    <span>arena</span> <span>*</span><span>a</span> <span>=</span> <span>perm</span><span>;</span>
    <span>if</span> <span>(</span><span>a</span><span>-&gt;</span><span>end</span> <span>==</span> <span>(</span><span>char</span> <span>*</span><span>)</span><span>p</span><span>)</span> <span>{</span>
        <span>a</span><span>-&gt;</span><span>end</span> <span>+=</span> <span>size</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The two mandatory replacements are no-ops because that’s simply how arenas
work. We don’t free individual objects, but many at once. It’s <em>completely
optional</em>, but I also replaced sized <code>delete</code> for little other reason than
<a href="https://nullprogram.com/blog/2023/12/17/">sized deallocation is cool</a>. C++ destructs in reverse order, so
this is likely to work out. At least with GCC libstdc++, it freed about a
third of the workspace memory before returning to C. I’d rather it didn’t
try to free anything at all, but since it’s going to call <code>delete</code> anyway
I can get some use out of it.</p>

<p>Interesting side note: In a rough benchmark these replacements made MSVC
<code>std::regex</code> matching four times faster! I expected a <em>small</em> speedup, but
not that. In the typical case it appears to be wasting most of its time on
allocation. On the other hand, libstdc++ <code>std::regex</code> is overall quite a
bit slower than MSVC, and my replacements had no performance effect. It’s
spending its time elsewhere, and the small gains are lost interacting with
the thread-local.</p>

<p>Finally the meat:</p>

<div><div><pre><code><span>extern</span> <span>&#34;C&#34;</span> <span>std</span><span>::</span><span>regex</span> <span>*</span><span>regex_new</span><span>(</span><span>str</span> <span>re</span><span>,</span> <span>arena</span> <span>*</span><span>a</span><span>)</span>
<span>{</span>
    <span>perm</span> <span>=</span> <span>a</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>return</span> <span>new</span> <span>std</span><span>::</span><span>regex</span><span>(</span><span>re</span><span>.</span><span>data</span><span>,</span> <span>re</span><span>.</span><span>data</span><span>+</span><span>re</span><span>.</span><span>len</span><span>);</span>
    <span>}</span> <span>catch</span> <span>(...)</span> <span>{</span>
        <span>return</span> <span>{};</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>It sets the thread-local to the arena, then constructs with “iterators” at
each end of the input. All exceptions are caught and turned into a null
return. Depending on need, we may want to indicate <em>why</em> it failed — out
of memory, invalid regex, etc. — by returning an error value of some sort.
An exercise for the reader.</p>

<p>The matcher is a little more complicated:</p>

<div><div><pre><code><span>extern</span> <span>&#34;C&#34;</span> <span>strlist</span> <span>regex_match</span><span>(</span><span>std</span><span>::</span><span>regex</span> <span>*</span><span>re</span><span>,</span> <span>str</span> <span>s</span><span>,</span> <span>arena</span> <span>*</span><span>a</span><span>)</span>
<span>{</span>
    <span>perm</span> <span>=</span> <span>a</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>std</span><span>::</span><span>cregex_iterator</span> <span>it</span><span>(</span><span>s</span><span>.</span><span>data</span><span>,</span> <span>s</span><span>.</span><span>data</span><span>+</span><span>s</span><span>.</span><span>len</span><span>,</span> <span>*</span><span>re</span><span>);</span>
        <span>std</span><span>::</span><span>cregex_iterator</span> <span>end</span><span>;</span>

        <span>strlist</span> <span>r</span> <span>=</span> <span>{};</span>
        <span>r</span><span>.</span><span>len</span>  <span>=</span> <span>std</span><span>::</span><span>distance</span><span>(</span><span>it</span><span>,</span> <span>end</span><span>);</span>
        <span>r</span><span>.</span><span>data</span> <span>=</span> <span>new</span> <span>str</span><span>[</span><span>r</span><span>.</span><span>len</span><span>]();</span>
        <span>for</span> <span>(</span><span>ptrdiff_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>it</span> <span>!=</span> <span>end</span><span>;</span> <span>it</span><span>++</span><span>,</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
            <span>r</span><span>.</span><span>data</span><span>[</span><span>i</span><span>].</span><span>data</span> <span>=</span> <span>s</span><span>.</span><span>data</span> <span>+</span> <span>it</span><span>-&gt;</span><span>position</span><span>();</span>
            <span>r</span><span>.</span><span>data</span><span>[</span><span>i</span><span>].</span><span>len</span>  <span>=</span> <span>it</span><span>-&gt;</span><span>length</span><span>();</span>
        <span>}</span>
        <span>return</span> <span>r</span><span>;</span>

    <span>}</span> <span>catch</span> <span>(...)</span> <span>{</span>
        <span>return</span> <span>{};</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>I create a <code>char *</code> “cregex” iterator, again giving it each end of the
input. I hope it’s not just making a copy (MSVC <code>std::regex</code> does <em>grumble
grumble</em>). The result is allocated out of the arena. As before, exceptions
convert to a null return. Callers can distinguish errors because no-match
results have a non-null pointer. The iterator, being a local variable, is
destroyed before returning, uselessly calling <code>delete</code>. I could avoid this
by allocating it with <code>new</code>, but in practice it doesn’t matter.</p>

<p>You might have noticed the lack of <code>declspec(dllexport)</code>. <a href="https://nullprogram.com/blog/2023/08/27/">DEF files are
great</a>, and I’ve come to appreciate and prefer them. GCC and MSVC
accept them as another input on the command line, and the source need not
be aware exports. My <code>regex.def</code>:</p>

<div><div><pre><code>LIBRARY regex
EXPORTS
regex_new
regex_match
</code></pre></div></div>

<p>In w64devkit, the command to build the DLL:</p>

<div><div><pre><code>$ g++ -shared -std=c++17 -o regex.dll regex.cpp regex.def
</code></pre></div></div>

<p>The MSVC command almost maps 1:1 to the GCC command:</p>

<div><div><pre><code>$ cl /LD /std:c++17 /EHsc regex.cpp regex.def
</code></pre></div></div>

<p>In either case only the C interface is exported (via <a href="https://nullprogram.com/blog/2024/06/30/">peports</a>):</p>

<div><div><pre><code>$ peports -e regex.dll
EXPORTS
        1       regex_match
        2       regex_new
</code></pre></div></div>

<h3 id="reasons-against">Reasons against</h3>

<p>Though this library is conveniently on hand, and my minimalist C wrapper
interface is nicer than a typical C regex library interface, and even
hides some <code>std::regex</code> problems, trade-offs must be considered:</p>

<ul>
  <li>No Unicode support, particularly UTF-8</li>
  <li><code>std::regex</code> implementations are universally poor and slow</li>
  <li>libstdc++ <code>std::regex</code> is especially slow to compile</li>
  <li>Isolating in a DLL (if needed) is inconvenient</li>
  <li>DLL is 200K (MSVC) to 700K (GCC) or so</li>
</ul>

<p>Depending on what I’m doing, some of these may have me looking elsewhere.</p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
