<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vitaut.net/posts/2024/binary-size/">Original</a>
    <h1>Honey, I shrunk {fmt}: bringing binary size to 14k and ditching the C&#43;&#43; runtime</h1>
    
    <div id="readability-page-1" class="page"><div><div v-pre=""><p><img src="https://vitaut.net/img/kennedy.jpg#floatright" alt="" title="We do this not because it is easy, but because we thought it would be easy."/></p><p><a href="https://github.com/fmtlib/fmt">The {fmt} formatting library</a> is known for its small binary footprint,
often producing code that is several times smaller per function call compared
to alternatives like IOStreams, Boost Format, or, somewhat ironically,
tinyformat. This is mainly achieved through careful application of type erasure
on various levels, which effectively minimizes template bloat.</p><p>Formatting arguments are passed via type-erased <code>format_args</code>:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>auto</span> <span>vformat</span><span>(</span><span>string_view</span> <span>fmt</span><span>,</span> <span>format_args</span> <span>args</span><span>)</span> <span>-&gt;</span> <span>std</span><span>::</span><span>string</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span><span>...</span> <span>T</span><span>&gt;</span>
</span></span><span><span><span>auto</span> <span>format</span><span>(</span><span>format_string</span><span>&lt;</span><span>T</span><span>...</span><span>&gt;</span> <span>fmt</span><span>,</span> <span>T</span><span>&amp;&amp;</span><span>...</span> <span>args</span><span>)</span> <span>-&gt;</span> <span>std</span><span>::</span><span>string</span> <span>{</span>
</span></span><span><span>  <span>return</span> <span>vformat</span><span>(</span><span>fmt</span><span>,</span> <span>fmt</span><span>::</span><span>make_format_args</span><span>(</span><span>args</span><span>...));</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>As you can see, <code>format</code> delegates all its work to <code>vformat</code>, which is not a
template.</p><p>Output iterators and other output types are also type-erased through a specially
designed buffer API.</p><p>This approach confines template usage to a minimal top-level layer, leading to
both a smaller binary size and <a href="https://vitaut.net/posts/2024/faster-cpp-compile-times/">faster build times</a>.</p><p>For example, the following code:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>// test.cc
</span></span></span><span><span><span></span><span>#include</span> <span>&lt;fmt/base.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>fmt</span><span>::</span><span>print</span><span>(</span><span>&#34;The answer is {}.&#34;</span><span>,</span> <span>42</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>compiles to just</p><pre tabindex="0"><code>.LC0:
        .string &#34;The answer is {}.&#34;
main:
        sub     rsp, 24
        mov     eax, 1
        mov     edi, OFFSET FLAT:.LC0
        mov     esi, 17
        mov     rcx, rsp
        mov     rdx, rax
        mov     DWORD PTR [rsp], 42
        call    fmt::v11::vprint(fmt::v11::basic_string_view&lt;char&gt;, fmt::v11::basic_format_args&lt;fmt::v11::context&gt;)
        xor     eax, eax
        add     rsp, 24
        ret
</code></pre><p><a href="https://godbolt.org/z/PMKdPPnYn">godbolt</a></p><p>It is much smaller than the equivalent IOStreams code and comparable to that
of <code>printf</code>:</p><pre tabindex="0"><code>.LC0:
        .string &#34;The answer is %d.&#34;
main:
        sub     rsp, 8
        mov     esi, 42
        mov     edi, OFFSET FLAT:.LC0
        xor     eax, eax
        call    printf
        xor     eax, eax
        add     rsp, 8
        ret
</code></pre><p><a href="https://godbolt.org/z/soTjfno71">godbolt</a></p><p>Unlike <code>printf</code>, {fmt} offers full runtime type safety. Errors in format strings
can be caught at compile time, and even when the format string is determined at
runtime, errors are managed through exceptions, preventing undefined behavior,
memory corruption, and potential crashes. Additionally, {fmt} calls are
generally more efficient, particularly when using positional arguments, which C
varargs are not well-suited for.</p><p>Back in 2020, I dedicated some time to <a href="https://vitaut.net/posts/2020/reducing-library-size/">optimizing the library size</a>,
successfully reducing it to under 100kB (just ~57kB with <code>-Os -flto</code>).
A lot has changed since then. Most notably, {fmt} now uses the exceptional
<a href="https://github.com/jk-jeon/dragonbox">Dragonbox</a> algorithm for floating-point formatting, kindly
contributed by its author, Junekey Jeon. Let’s explore how these changes have
impacted the binary size and see if further reductions are possible.</p><p>But why, some say, the binary size? Why choose this as our goal?</p><p>There has been considerable interest in using {fmt} on memory-constrained
devices, see e.g. <a href="https://github.com/fmtlib/fmt/issues/758">#758</a> and <a href="https://github.com/fmtlib/fmt/issues/1226">#1226</a> for just two examples from
the distant past. A particularly intriguing use case is retro computing, with
people using {fmt} on systems like Amiga (<a href="https://github.com/fmtlib/fmt/issues/4054">#4054</a>).</p><p>We’ll apply the same methodology as in <a href="https://vitaut.net/posts/2020/reducing-library-size/">previous work</a>, examining the
executable size of a program that uses {fmt}, as this is most relevant to end
users. All tests will be conducted on an aarch64 Ubuntu 22.04 system with GCC
11.4.0.</p><p>First, let’s establish the baseline: what is the binary size for the latest
version of {fmt} (11.0.2)?</p><pre tabindex="0"><code>$ git checkout 11.0.2
$ g++ -Os -flto -DNDEBUG -I include test.cc src/format.cc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 75K Aug 30 19:24 a.out
</code></pre><p>The resulting binary size is 75kB (stripped). The positive takeaway is that
despite numerous developments over the past four years, the size has not
significantly regressed.</p><p>Now, let’s explore potential optimizations. One of the first adjustments you
might consider is disabling locale support. All the formatting in {fmt} is
locale-independent by default (which breaks with the C++’s tradition of having
wrong defaults), but it is still available as an opt in via the <code>L</code> format
specifier. It can be disabled in a somewhat obscure way via the
<code>FMT_STATIC_THOUSANDS_SEPARATOR</code> macro:</p><pre tabindex="0"><code>$ g++ -Os -flto -DNDEBUG &#34;-DFMT_STATIC_THOUSANDS_SEPARATOR=&#39;,&#39;&#34; \
      -I include test.cc src/format.cc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 71K Aug 30 19:25 a.out
</code></pre><p>Disabling locale support reduces the binary size to 71kB.</p><p>Next, let’s examine the results using our trusty tool, <a href="https://github.com/google/bloaty">Bloaty</a>:</p><pre tabindex="0"><code>$ bloaty -d symbols a.out

    FILE SIZE        VM SIZE
 --------------  --------------
  43.8%  41.1Ki  43.6%  29.0Ki    [121 Others]
   6.4%  6.04Ki   8.1%  5.42Ki    fmt::v11::detail::do_write_float&lt;&gt;()
   5.9%  5.50Ki   7.5%  4.98Ki    fmt::v11::detail::write_int_noinline&lt;&gt;()
   5.7%  5.32Ki   5.8%  3.88Ki    fmt::v11::detail::write&lt;&gt;()
   5.4%  5.02Ki   7.2%  4.81Ki    fmt::v11::detail::parse_replacement_field&lt;&gt;()
   3.9%  3.69Ki   3.7%  2.49Ki    fmt::v11::detail::format_uint&lt;&gt;()
   3.2%  3.00Ki   0.0%       0    [section .symtab]
   2.7%  2.50Ki   0.0%       0    [section .strtab]
   2.3%  2.12Ki   2.9%  1.93Ki    fmt::v11::detail::dragonbox::to_decimal&lt;&gt;()
   2.0%  1.89Ki   2.4%  1.61Ki    fmt::v11::detail::write_int&lt;&gt;()
   2.0%  1.88Ki   0.0%       0    [ELF Section Headers]
   1.9%  1.79Ki   2.5%  1.66Ki    fmt::v11::detail::write_float&lt;&gt;()
   1.9%  1.78Ki   2.7%  1.78Ki    [section .dynstr]
   1.8%  1.72Ki   2.4%  1.62Ki    fmt::v11::detail::format_dragon()
   1.8%  1.68Ki   1.5%    1016    fmt::v11::detail::format_decimal&lt;&gt;()
   1.6%  1.52Ki   2.1%  1.41Ki    fmt::v11::detail::format_float&lt;&gt;()
   1.6%  1.49Ki   0.0%       0    [Unmapped]
   1.5%  1.45Ki   2.2%  1.45Ki    [section .dynsym]
   1.5%  1.45Ki   2.0%  1.31Ki    fmt::v11::detail::write_loc()
   1.5%  1.44Ki   2.2%  1.44Ki    [section .rodata]
   1.5%  1.40Ki   1.1%     764    fmt::v11::detail::do_write_float&lt;&gt;()::{lambda()#2}::operator()()
 100.0%  93.8Ki 100.0%  66.6Ki    TOTAL
</code></pre><p>Unsurprisingly, a significant portion of the binary size is dedicated to numeric
formatting, particularly floating-point numbers. FP formatting also relies on
sizable tables, which aren’t shown here. But what if floating-point support
isn’t required? {fmt} provides a way to disable it, though the method is
somewhat ad hoc and doesn’t extend to other types.</p><p>The core issue is that formatting functions need to be aware of all formattable
types. Or do they? This is true for <code>printf</code> as defined by the C standard, but
not necessarily for {fmt}. {fmt} supports an extension API that allows
formatting arbitrary types without knowing the complete set of types in advance.
While built-in and string types are handled specially for performance reasons,
focusing on binary size might warrant a different approach. By removing this
special handling and routing every type through the extension API, you can avoid
paying for types you don’t use.</p><p>I did an experimental <a href="https://github.com/fmtlib/fmt/commit/377cf20">implementation of this idea</a>. With the
<code>FMT_BUILTIN_TYPES</code> macro set to 0, only <code>int</code> is handled specially, and all
other types go through the general extension API. We still need to know about
<code>int</code> for dynamic width and precision, for example</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>fmt</span><span>::</span><span>print</span><span>(</span><span>&#34;{:{}}</span><span>\n</span><span>&#34;</span><span>,</span> <span>&#34;hello&#34;</span><span>,</span> <span>10</span><span>);</span> <span>// prints &#34;hello     &#34;
</span></span></span></code></pre></div><p>This gives you the “don’t pay for what you don’t use” model, though it comes
with a slight increase in per-call binary size. If you do format floating-point
numbers or other types, the relevant code will still be included in the build.
While it’s possible to make the FP implementation smaller, we won’t delve into
that here.</p><p>With <code>FMT_BUILTIN_TYPES=0</code>, the binary size in our example reduced to 31kB,
representing a substantial improvement:</p><pre tabindex="0"><code>$ git checkout 377cf20
$ g++ -Os -flto -DNDEBUG \
      &#34;-DFMT_STATIC_THOUSANDS_SEPARATOR=&#39;,&#39;&#34; -DFMT_BUILTIN_TYPES=0 \
      -I include test.cc src/format.cc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 31K Aug 30 19:37 a.out
</code></pre><p>However, the updated Bloaty results reveal some lingering locale artifacts,
such as <code>digit_grouping</code>:</p><pre tabindex="0"><code>$ bloaty -d fullsymbols a.out

    FILE SIZE        VM SIZE
 --------------  --------------
  41.8%  18.0Ki  39.7%  11.0Ki    [84 Others]
   6.4%  2.77Ki   0.0%       0    [section .symtab]
   5.3%  2.28Ki   0.0%       0    [section .strtab]
   4.6%  1.99Ki   6.9%  1.90Ki    fmt::v11::detail::format_handler&lt;char&gt;::on_format_specs(int, char const*, char const*)
   4.4%  1.88Ki   0.0%       0    [ELF Section Headers]
   4.1%  1.78Ki   5.8%  1.61Ki    fmt::v11::basic_appender&lt;char&gt; fmt::v11::detail::write_int_noinline&lt;char, fmt::v11::basic_appender&lt;char&gt;, unsigned int&gt;(fmt::v11::basic_appender&lt;char&gt;, fmt::v11::detail::write_int_arg&lt;unsigned int&gt;, fmt::v11::format_specs const&amp;, fmt::v11::detail::locale_ref) (.constprop.0)
   3.7%  1.60Ki   5.8%  1.60Ki    [section .dynstr]
   3.5%  1.50Ki   4.8%  1.34Ki    void fmt::v11::detail::vformat_to&lt;char&gt;(fmt::v11::detail::buffer&lt;char&gt;&amp;, fmt::v11::basic_string_view&lt;char&gt;, fmt::v11::detail::vformat_args&lt;char&gt;::type, fmt::v11::detail::locale_ref) (.constprop.0)
   3.5%  1.49Ki   4.9%  1.35Ki    fmt::v11::basic_appender&lt;char&gt; fmt::v11::detail::write_int&lt;fmt::v11::basic_appender&lt;char&gt;, unsigned __int128, char&gt;(fmt::v11::basic_appender&lt;char&gt;, unsigned __int128, unsigned int, fmt::v11::format_specs const&amp;, fmt::v11::detail::digit_grouping&lt;char&gt; const&amp;)
   3.1%  1.31Ki   4.7%  1.31Ki    [section .dynsym]
   3.0%  1.29Ki   4.2%  1.15Ki    fmt::v11::basic_appender&lt;char&gt; fmt::v11::detail::write_int&lt;fmt::v11::basic_appender&lt;char&gt;, unsigned long, char&gt;(fmt::v11::basic_appender&lt;char&gt;, unsigned long, unsigned int, fmt::v11::format_specs const&amp;, fmt::v11::detail::digit_grouping&lt;char&gt; const&amp;)
</code></pre><p>After disabling these artifacts in commits <a href="https://github.com/fmtlib/fmt/commit/e582d37">e582d37</a> and
<a href="https://github.com/fmtlib/fmt/commit/b3ccc2d">b3ccc2d</a>, and introducing a more user-friendly option to opt out via
the <code>FMT_USE_LOCALE</code> macro, the binary size drops to 27kB:</p><pre tabindex="0"><code>$ git checkout b3ccc2d
$ g++ -Os -flto -DNDEBUG -DFMT_USE_LOCALE=0 -DFMT_BUILTIN_TYPES=0 \
      -I include test.cc src/format.cc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 27K Aug 30 19:38 a.out
</code></pre><p>The library includes several areas where size is traded off for speed.
For example, consider this function used to compute the number of decimal
digits:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>auto</span> <span>do_count_digits</span><span>(</span><span>uint32_t</span> <span>n</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span>
</span></span><span><span><span>// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
</span></span></span><span><span><span>// This increments the upper 32 bits (log10(T) - 1) when &gt;= T is added.
</span></span></span><span><span><span></span><span>#  define FMT_INC(T) (((sizeof(#T) - 1ull) &lt;&lt; 32) - T)
</span></span></span><span><span><span></span>  <span>static</span> <span>constexpr</span> <span>uint64_t</span> <span>table</span><span>[]</span> <span>=</span> <span>{</span>
</span></span><span><span>      <span>FMT_INC</span><span>(</span><span>0</span><span>),</span>          <span>FMT_INC</span><span>(</span><span>0</span><span>),</span>          <span>FMT_INC</span><span>(</span><span>0</span><span>),</span>           <span>// 8
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>10</span><span>),</span>         <span>FMT_INC</span><span>(</span><span>10</span><span>),</span>         <span>FMT_INC</span><span>(</span><span>10</span><span>),</span>          <span>// 64
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>100</span><span>),</span>        <span>FMT_INC</span><span>(</span><span>100</span><span>),</span>        <span>FMT_INC</span><span>(</span><span>100</span><span>),</span>         <span>// 512
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>1000</span><span>),</span>       <span>FMT_INC</span><span>(</span><span>1000</span><span>),</span>       <span>FMT_INC</span><span>(</span><span>1000</span><span>),</span>        <span>// 4096
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>10000</span><span>),</span>      <span>FMT_INC</span><span>(</span><span>10000</span><span>),</span>      <span>FMT_INC</span><span>(</span><span>10000</span><span>),</span>       <span>// 32k
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>100000</span><span>),</span>     <span>FMT_INC</span><span>(</span><span>100000</span><span>),</span>     <span>FMT_INC</span><span>(</span><span>100000</span><span>),</span>      <span>// 256k
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>1000000</span><span>),</span>    <span>FMT_INC</span><span>(</span><span>1000000</span><span>),</span>    <span>FMT_INC</span><span>(</span><span>1000000</span><span>),</span>     <span>// 2048k
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>10000000</span><span>),</span>   <span>FMT_INC</span><span>(</span><span>10000000</span><span>),</span>   <span>FMT_INC</span><span>(</span><span>10000000</span><span>),</span>    <span>// 16M
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>100000000</span><span>),</span>  <span>FMT_INC</span><span>(</span><span>100000000</span><span>),</span>  <span>FMT_INC</span><span>(</span><span>100000000</span><span>),</span>   <span>// 128M
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>1000000000</span><span>),</span> <span>FMT_INC</span><span>(</span><span>1000000000</span><span>),</span> <span>FMT_INC</span><span>(</span><span>1000000000</span><span>),</span>  <span>// 1024M
</span></span></span><span><span><span></span>      <span>FMT_INC</span><span>(</span><span>1000000000</span><span>),</span> <span>FMT_INC</span><span>(</span><span>1000000000</span><span>)</span>                        <span>// 4B
</span></span></span><span><span><span></span>  <span>};</span>
</span></span><span><span>  <span>auto</span> <span>inc</span> <span>=</span> <span>table</span><span>[</span><span>__builtin_clz</span><span>(</span><span>n</span> <span>|</span> <span>1</span><span>)</span> <span>^</span> <span>31</span><span>];</span>
</span></span><span><span>  <span>return</span> <span>static_cast</span><span>&lt;</span><span>int</span><span>&gt;</span><span>((</span><span>n</span> <span>+</span> <span>inc</span><span>)</span> <span>&gt;&gt;</span> <span>32</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The table used here is 256 bytes. There isn’t a one-size-fits-all solution,
and changing it unconditionally might negatively impact other use cases.
Fortunately, we have a fallback implementation of this function for scenarios
where <code>__builtin_clz</code> is unavailable, such as with <code>constexpr</code>:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span> <span>constexpr</span> <span>auto</span> <span>count_digits_fallback</span><span>(</span><span>T</span> <span>n</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span>
</span></span><span><span>  <span>int</span> <span>count</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>for</span> <span>(;;)</span> <span>{</span>
</span></span><span><span>    <span>// Integer division is slow so do it for a group of four digits instead
</span></span></span><span><span><span></span>    <span>// of for every digit. The idea comes from the talk by Alexandrescu
</span></span></span><span><span><span></span>    <span>// &#34;Three Optimization Tips for C++&#34;. See speed-test for a comparison.
</span></span></span><span><span><span></span>    <span>if</span> <span>(</span><span>n</span> <span>&lt;</span> <span>10</span><span>)</span> <span>return</span> <span>count</span><span>;</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>n</span> <span>&lt;</span> <span>100</span><span>)</span> <span>return</span> <span>count</span> <span>+</span> <span>1</span><span>;</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>n</span> <span>&lt;</span> <span>1000</span><span>)</span> <span>return</span> <span>count</span> <span>+</span> <span>2</span><span>;</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>n</span> <span>&lt;</span> <span>10000</span><span>)</span> <span>return</span> <span>count</span> <span>+</span> <span>3</span><span>;</span>
</span></span><span><span>    <span>n</span> <span>/=</span> <span>10000u</span><span>;</span>
</span></span><span><span>    <span>count</span> <span>+=</span> <span>4</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>All that remains is to provide users with control over when to use the fallback
implementation via (you guessed it) another configuration macro,
<code>FMT_OPTIMIZE_SIZE</code>:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>auto</span> <span>count_digits</span><span>(</span><span>uint32_t</span> <span>n</span><span>)</span> <span>-&gt;</span> <span>int</span> <span>{</span>
</span></span><span><span><span>#ifdef FMT_BUILTIN_CLZ
</span></span></span><span><span><span></span>  <span>if</span> <span>(</span><span>!</span><span>is_constant_evaluated</span><span>()</span> <span>&amp;&amp;</span> <span>!</span><span>FMT_OPTIMIZE_SIZE</span><span>)</span> <span>return</span> <span>do_count_digits</span><span>(</span><span>n</span><span>);</span>
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>  <span>return</span> <span>count_digits_fallback</span><span>(</span><span>n</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>With this and a few similar adjustments, we reduced the binary size to 23kB:</p><pre tabindex="0"><code>$ git checkout 8e3da9d
$ g++ -Os -flto -DNDEBUG -I include \
      -DFMT_USE_LOCALE=0 -DFMT_BUILTIN_TYPES=0 -DFMT_OPTIMIZE_SIZE=1 \
      test.cc src/format.cc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 23K Aug 30 19:41 a.out
</code></pre><p>We could likely reduce the binary size even further with additional tweaks,
but let’s address the elephant in the room which is, of course, the C++ standard
library. What’s the point of optimizing the size when you end up getting
a megabyte or two of the C++ runtime?</p><p>While {fmt} relies minimally on the standard library, is it possible to
remove it completely as a dependency? One obvious problem is exceptions and
those can be disabled via <code>FMT_THROW</code>, e.g. by defining it to <code>abort</code>.
In general it is not recommended but it might be OK for some use cases
especially considering that most errors are caught at compile time.</p><p>Let’s try it out and compile with <code>-nodefaultlibs</code> and exceptions disabled:</p><pre tabindex="0"><code>$ g++ -Os -flto -DNDEBUG -I include \
      -DFMT_USE_LOCALE=0 -DFMT_BUILTIN_TYPES=0 -DFMT_OPTIMIZE_SIZE=1 \
      &#39;-DFMT_THROW(s)=abort()&#39; -fno-exceptions test.cc src/format.cc \
      -nodefaultlibs -lc

/usr/bin/ld: /tmp/cc04DFeK.ltrans0.ltrans.o: in function `fmt::v11::basic_memory_buffer&lt;char, 500ul, std::allocator&lt;char&gt; &gt;::grow(fmt::v11::detail::buffer&lt;char&gt;&amp;, unsigned long)&#39;:
&lt;artificial&gt;:(.text+0xaa8): undefined reference to `std::__throw_bad_alloc()&#39;
/usr/bin/ld: &lt;artificial&gt;:(.text+0xab8): undefined reference to `operator new(unsigned long)&#39;
/usr/bin/ld: &lt;artificial&gt;:(.text+0xaf8): undefined reference to `operator delete(void*, unsigned long)&#39;
/usr/bin/ld: /tmp/cc04DFeK.ltrans0.ltrans.o: in function `fmt::v11::vprint_buffered(_IO_FILE*, fmt::v11::basic_string_view&lt;char&gt;, fmt::v11::basic_format_args&lt;fmt::v11::context&gt;) [clone .constprop.0]&#39;:
&lt;artificial&gt;:(.text+0x18c4): undefined reference to `operator delete(void*, unsigned long)&#39;
collect2: error: ld returned 1 exit status
</code></pre><p>Amazingly, this approach mostly works. The only remaining dependency on the C++
runtime comes from <code>fmt::basic_memory_buffer</code>, which is a small stack-allocated
buffer that can grow into dynamic memory if necessary.</p><p><code>fmt::print</code> can write directly into the <code>FILE</code> buffer and generally
doesn’t require dynamic allocation. So we could remove the dependency on
<code>fmt::basic_memory_buffer</code> from <code>fmt::print</code>. However, since it may be used
elsewhere, a better solution is to replace the default allocator with one that
uses <code>malloc</code> and <code>free</code> instead of <code>new</code> and <code>delete</code>.</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span> <span>struct</span> <span>allocator</span> <span>{</span>
</span></span><span><span>  <span>using</span> <span>value_type</span> <span>=</span> <span>T</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>T</span><span>*</span> <span>allocate</span><span>(</span><span>size_t</span> <span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>FMT_ASSERT</span><span>(</span><span>n</span> <span>&lt;=</span> <span>max_value</span><span>&lt;</span><span>size_t</span><span>&gt;</span><span>()</span> <span>/</span> <span>sizeof</span><span>(</span><span>T</span><span>),</span> <span>&#34;&#34;</span><span>);</span>
</span></span><span><span>    <span>T</span><span>*</span> <span>p</span> <span>=</span> <span>static_cast</span><span>&lt;</span><span>T</span><span>*&gt;</span><span>(</span><span>malloc</span><span>(</span><span>n</span> <span>*</span> <span>sizeof</span><span>(</span><span>T</span><span>)));</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>!</span><span>p</span><span>)</span> <span>FMT_THROW</span><span>(</span><span>std</span><span>::</span><span>bad_alloc</span><span>());</span>
</span></span><span><span>    <span>return</span> <span>p</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>void</span> <span>deallocate</span><span>(</span><span>T</span><span>*</span> <span>p</span><span>,</span> <span>size_t</span><span>)</span> <span>{</span> <span>free</span><span>(</span><span>p</span><span>);</span> <span>}</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>This reduces binary size to just 14kB:</p><pre tabindex="0"><code>$ git checkout c0fab5e
$ g++ -Os -flto -DNDEBUG -I include \
      -DFMT_USE_LOCALE=0 -DFMT_BUILTIN_TYPES=0 -DFMT_OPTIMIZE_SIZE=1 \
      &#39;-DFMT_THROW(s)=abort()&#39; -fno-exceptions test.cc src/format.cc \
      -nodefaultlibs -lc
$ strip a.out &amp;&amp; ls -lh a.out
-rwxrwxr-x 1 vagrant vagrant 14K Aug 30 19:06 a.out
</code></pre><p>Considering that a C program with an empty <code>main</code> function is 6kB on this
system, {fmt} now adds less than 10kB to the binary.</p><p>We can also easily verify that it no longer depends on the C++ runtime:</p><pre tabindex="0"><code>$ ldd a.out
        linux-vdso.so.1 (0x0000ffffb0738000)
        libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffb0530000)
        /lib/ld-linux-aarch64.so.1 (0x0000ffffb06ff000)
</code></pre><p>Hope you found this interesting and happy embedded formatting!</p><hr id="EOF"/><p>Last modified on 2024-08-30</p></div></div></div>
  </body>
</html>
