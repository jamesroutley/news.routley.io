<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devonperoutky.super.site/blog-posts/mediocre-engineers-guide-to-https">Original</a>
    <h1>Mediocre Engineer&#39;s Guide to HTTPS</h1>
    
    <div id="readability-page-1" class="page"><article id="block-blog-posts-mediocre-engineers-guide-to-https"><p><img src="https://files.oaiusercontent.com/file-SyCerofEEDgemcHfPpquHWxP?se=2024-05-26T17%3A15%3A21Z&amp;sp=r&amp;sv=2023-11-03&amp;sr=b&amp;rscc=max-age%3D31536000%2C%20immutable&amp;rscd=attachment%3B%20filename%3D53c7983c-c33e-4b28-80ff-ad5cdd387868.webp&amp;sig=MN94zDnTPF%2BB0jZFNe434yjt40e6dIcfT%2BQiedrSLBg%3D" alt="image" width="1000" height="1000" loading="lazy"/></p><p id="block-1998249233964d6a9eb55daccbfe3f52">As a mediocre engineer, I took Internet and HTTPS communication for granted and never dove any deeper. Today we’re improving as engineers and learning a rough overview of how internet communication works, specifically focusing on HTTP and TLS. </p><p id="block-1368c2582b544d89b9b6e5ceaa4505e7">The Internet is “just” a network of interconnected computer networks. The term &#34;Internet&#34; literally means &#34;between networks.&#34; It operates as a packet-switched <a href="https://en.wikipedia.org/wiki/Mesh_networking" target="_blank" rel="noopener noreferrer">mesh network</a>  with best-effort delivery, meaning there are no guarantees on whether a packet will be delivered or how long it will take. The reason why the internet appears to operate so smoothly (at least from a technical perspective) is the layers of abstraction that handle retries, ordering, deduplication, security and so many other things behind the scenes. Letting us developers just focus on the application layer (aka. Writing HTTP requests from San Francisco for $300K/year).</p><p id="block-bcd57619f52340a6b4a3740814acdb99">Each layer provides certain functionalities, which can be fulfilled by different <a href="https://en.wikipedia.org/wiki/Communication_protocol" target="_blank" rel="noopener noreferrer">protocols</a>. Such modularization makes it possible to replace the protocol on one layer without affecting the protocols on the other layers. </p><p id="block-f3f543d42a414fd58b32dc5d1cf53fd1">Here’s a simple table of the layers.</p><p id="block-94f37ea75a6e470ab5914504988ed3c7">We’ll go over these layers more in-depth layer, but first, let’s see this in action.</p><span id="48f58523ccfd407ea9e5bfc91b3e3387"></span><p id="block-742e68fb1d8e4609a5702f12c4aed900">Here is the path of an HTTP request through these layers (Skipping physical layer for brevity). </p><p><img alt="image" loading="lazy" width="1152" height="593.8407079646017" decoding="async" data-nimg="1" srcset="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/ca58d5c9-2241-4a54-b3f3-9ec8faf474d3/HTTP_Request/w=1200,quality=90,fit=scale-down 1x, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/ca58d5c9-2241-4a54-b3f3-9ec8faf474d3/HTTP_Request/w=3840,quality=90,fit=scale-down 2x" src="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/ca58d5c9-2241-4a54-b3f3-9ec8faf474d3/HTTP_Request/w=3840,quality=90,fit=scale-down"/></p><span id="22a8490d95884f838d770d5dca6c2e27"></span><h2 id="block-22a8490d95884f838d770d5dca6c2e27"><strong>1. Sender Makes a Request</strong></h2><p id="block-703f8b4331bb4dfdaa98b13c10bd4f42">The process begins at the Application layer, where the client (usually a web browser) constructs an HTTP request. HTTP is a text-based protocol, meaning that all this data is sent as plain text over the wire.</p><p id="block-767d620578254e20a3e191991e6a0813">The first line typically includes:</p><ul><li id="block-0737eb93a83249f889dd3c75935821a4"><strong>HTTP method</strong> (GET, POST, etc)</li><li id="block-519d12ef20924e38bdd0caf86ba7a7ac"><strong>Requested Resource</strong> (Example: <code>/index.html</code> )</li><li id="block-2f8cfb6260e34987a06c71d3eafc58d2"><strong>Protocol version.</strong></li></ul><p id="block-fc6d85d690f240c3bc0fcf0e6da72ee2">The remainder of the HTTP message contains headers in a <code>key: value</code> format an an optional message body.</p><p id="block-1568506ca59942e584c6cdfe28690665"><strong>Example: HTTP Request</strong></p><div id="block-678fdecfaf5746c0b58bc53188515a4c"><!--$--><pre><code>GET /index.html HTTP/1.1
Host: www.example.com
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36</code></pre><!--/$--><figcaption></figcaption></div><span id="63b5bd78e0cd4a5c91f14115b45f3c50"></span><h2 id="block-63b5bd78e0cd4a5c91f14115b45f3c50"><strong>2. DNS Lookup</strong>: </h2><p id="block-08fc51e57efd4e328212001a1c0b1c18">The Domain Name System (DNS) translates the human-readable domain name (<code><strong>www.example.com</strong></code>) into an IP address (e.g., <code><strong>93.184.216.34</strong></code>). The client queries DNS servers to resolve the domain name to its corresponding IP address. This process may involve multiple DNS servers, including recursive resolvers and authoritative DNS servers.</p><span id="f968956e32b84f5aaaed3368df807c89"></span><h2 id="block-f968956e32b84f5aaaed3368df807c89"><strong>3. TCP Handshake</strong>: </h2><div id="block-2080a89c76a44d87938410373c724375"><p>Once the IP address is obtained, the client initiates a TCP connection with the server on port 80 (the standard port for HTTP). This involves a three-way handshake:</p><div><ul><li id="block-e235ca0e62fd4a7d831984686e3c9533"><strong>SYN</strong>: The client sends a SYN (synchronize) packet to the server to request a connection.</li><li id="block-0c63649455534d7ebf44cfb63af07be6"><strong>SYN-ACK</strong>: The server responds with a SYN-ACK (synchronize-acknowledge) packet to acknowledge the request.</li><li id="block-9f1e466cc134465498261098ef8e7ce3"><strong>ACK</strong>: The client sends an ACK (acknowledge) packet back to the server, establishing a reliable connection.</li></ul></div></div><p id="block-418edba54cc541d8844afe4b2adaada1">The TCP communication is usually referred to as the <strong>Transport Layer </strong>from our <a href="https://devonperoutky.super.site/blog-posts/mediocre-engineers-guide-to-https#block-19e359d441e74b65b499aa031ac19a0a">table</a> earlier</p><span id="5614ab20bd1f445c980ec96553f97ce6"></span><h2 id="block-5614ab20bd1f445c980ec96553f97ce6">4. Transmit HTTP Request</h2><p id="block-1b76c34b9c014a1cb0c985b0a8798d4a">With the TCP connection in place, the client sends the actual HTTP request. As mentioned, HTTP is a text-based protocol, so the request headers and the body (if any) are sent as plain text.</p><span id="145c998254ff4d8c9f1554b68a2849e4"></span><h2 id="block-145c998254ff4d8c9f1554b68a2849e4">5. Packets routed across Internet to Server</h2><p id="block-109ab65911674b148dcb1e9e0614a783"><strong>⚠️⚠️⚠️⚠️⚠️ We’re going deep here ⚠️⚠️⚠️⚠️⚠️</strong></p><p id="block-3d7cc6a5080b4adeb756e080caf06c5b">When a client sends a request, the data packets don&#39;t travel directly to the server. Instead, they follow a path through various network devices, primarily routers, which determine the best route for the packets to reach the server network gateway. From there, the link layer comes into play. </p><span id="e908d8f6125247daad89e708ffc8ee50"></span><h3 id="block-e908d8f6125247daad89e708ffc8ee50"><span>Step-by-step explanation of how text makes it across the internet</span></h3><ol type="1"><li id="block-a1cc75b6e1234d2797266724188010bc"><span><strong>Initial Transmission</strong></span><span>:</span></li><p id="block-f2d984846c964ad397d008ed96ebf1ab"><span>The client&#39;s device encapsulates the HTTP request data into TCP segments and then into IP packets. These packets are further encapsulated into smaller chunks, referred to as frames, suitable for the Link Layer (e.g., Ethernet frames if using a wired connection).</span></p><li id="block-d83e93ae59ed425a9136e25a3a6c5a98"><span><strong>Local Network</strong></span><span>:</span></li><p id="block-9a5e34baa6054546af5cec303f8043c7"><span>The </span><span><u>frames</u></span><span> are transmitted over the local network to the client&#39;s router. The Link Layer handles the communication within this local network, ensuring the frames reach the router.</span></p><li id="block-f8afcf2f859e4215b85fda65cae7e2cf"><span><strong>Local Router Processing</strong></span><span>:</span></li><p id="block-5ba4a7bd1a5646839de55d591efc1695"><span>The router receives the </span><span><u>frames</u></span><span>, strips off the Link Layer headers, and processes the </span><span><u>IP packets</u></span><span>. The router examines the destination IP address in the packets and determines the next hop on the path to the server.</span></p><li id="block-06c537acc04b4d7b882f6b2e6fcc20a1"><span><strong>Routing Across Networks</strong></span><span>:</span></li><p id="block-afe6e9f691594e47ba7d83668602106e"><span>The router forwards the </span><span><u>packets</u></span><span> to the next network, often through one or more intermediary routers. Each intermediary router repeats the process: receiving the packets, determining thenext hop, and forwarding them.</span></p><li id="block-b5db38366c6d4c439dad47c470d44461"><span><strong>Final Network</strong></span></li><p id="block-4bfb2e6a9a364f75ae635b044555bfd2"><span>Eventually, the packets reach a router on the same network as the destination server. This router performs the final routing decision and sends the packets to the appropriate local device (the server).</span></p><li id="block-04b6b1c90e21498abe43327bbbe8f79d"><span><strong>Server Reception</strong></span><span>:</span></li><p id="block-d909b573e4f3426e9b059acb986ac990"><span>The server&#39;s router forwards the packets over the local network segment to the server. The Link Layer ensures the frames are correctly transmitted to the server&#39;s network interface. (It has been doing that for every machine → machine communication for this whole time.</span></p><li id="block-2f427ea42aa74d26bac0939c08417ea4"><span><strong>Server Processing</strong></span><span>:</span></li><p id="block-8d80e9952f5744c1ac83110d45b75e82"><span>The server receives the frames, extracts the IP packets, and processes the encapsulated TCP segments to reconstruct the original HTTP request. The server then generates an HTTP response and the process reverses to send the response back to the client.</span></p></ol><div id="block-fafbe45b106c4b779bb412cfed552041"><p><span>⁉️</span></p><p><span>The process of sending packets across the internet (The Network Layer) is used for essentially all communication over the internet. So it was used for all the steps earlier (like resolving the domain name, the TCP handshake, etc) however there’s only so much that can be explained at once.</span></p></div><span id="0ab8d0947866452b9713493cfb3519f5"></span><h3 id="block-0ab8d0947866452b9713493cfb3519f5">6. Server Response</h3><p id="block-2bbe5598ff7541caab2dc6757a5ade45">The server receives the HTTP request and processes it. After processing the request, the server sends an HTTP response back to the client. The response includes:</p><ul><li id="block-08a8ec1b27224379ad4d6a7d17ce6793"><strong>Protocol </strong>(The HTTP version being used)</li><li id="block-3322a169a498421494300106c93f279f"><strong>Status information</strong> (The HTML Status code like 200, 404, etc)</li><li id="block-4083bc86a8dd4eef9bb5bdf4431bc681"><strong>Response headers </strong>(Like Request Header but Response)</li><li id="block-0fed1b0e5b1b4f21b924cbe18b77cda9"><strong>Requested content/Body </strong>(The actual content, such as HTML of the request page or JSON data)</li></ul><div id="block-a2d5b9d6a7724f67a92c78c5ab1d56ce"><!--$--><pre><code>HTTP/1.1 200 OK
Date: Sat, 26 May 2023 10:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html
Content-Length: 3456

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><!--/$--><figcaption></figcaption></div><p id="block-d0c55da17da9434aaa513595aba2248e">You may have seen something like this when debugging requests.</p><p><img alt="image" loading="lazy" width="3584" height="790" decoding="async" data-nimg="1" sizes="(max-width: 546px) 100vw, 100vw" srcset="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=640,quality=90,fit=scale-down 640w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=750,quality=90,fit=scale-down 750w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=828,quality=90,fit=scale-down 828w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=1080,quality=90,fit=scale-down 1080w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=1200,quality=90,fit=scale-down 1200w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=1920,quality=90,fit=scale-down 1920w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=2048,quality=90,fit=scale-down 2048w, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=3840,quality=90,fit=scale-down 3840w" src="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/cfcdb0b7-d20d-4a0c-a50f-720d59a0fe82/Screenshot_2024-05-26_at_12.22.31_AM/w=3840,quality=90,fit=scale-down"/></p><span id="ca9b1955aebd4ed59067e3b73e134d79"></span><h3 id="block-ca9b1955aebd4ed59067e3b73e134d79"><strong>7. Content Rendering</strong>:</h3><p id="block-133981dba71246abad9f111a6b735bef">The client receives the HTTP response and processes it. The browser interprets the HTML and renders the content on the screen. If the response includes additional resources (e.g., images, CSS, JavaScript), the browser will make further HTTP requests to fetch these resources, following the same process.</p><p id="block-b998fa13a597479ba2ea7842c6dac815">So now that we’ve gotten a basic HTTP request out of the way, there’s only one problem. <strong>It’s not secure at all.</strong> Anyone listening on the connection can view 100% of the data being passed back-and-forth. Additionally, someone could pretend to be a server such that the client is tricked into sending valuable information. That’s where the<strong> Security Layer </strong>comes into play</p><span id="5b6b6b8f5d5641d8882d359d116c590b"></span><h2 id="block-5b6b6b8f5d5641d8882d359d116c590b">Little Layer Review</h2><p id="block-e8104121e6514d22813ef4b058cf16a6">While we’re here, let’s do a brief review of the layers and their purpose, while we introduce the Security Layer.</p><ul><li id="block-3e7722a6582d49b0a62a14ce929edd28"><strong>Application Layer</strong>: Where applications create and communicate user data. This is what you have interacted the most with. Uses transport layer services for reliable or unreliable data transmission. Protocols include HTTP, FTP, SSH, SMTP. Uses ports to address processes/services.</li><li id="block-e09a25aa99564ff5a94c57feddad8591"><strong>Security Layer</strong>: Ensures secure communication by providing encryption, authentication, and data integrity. Common protocols include TLS (Transport Layer Security) and its predecessor SSL (Secure Sockets Layer). This layer protects data in transit and verifies the identity of the communicating parties.</li><li id="block-0bd8b1ee0128440bb42d46446bdfadcf"><strong>Transport Layer</strong>: Manages host-to-host communications, providing channels for application data. Includes:</li><ul><li id="block-0cab7c49029940768e83bbcf46e8b76b"><strong>UDP</strong>: Unreliable, connectionless datagram service.</li><li id="block-d782767e32af4504879f5b72770ae1e5"><strong>TCP</strong>: Reliable, connection-oriented service with flow control and connection establishment.</li></ul><li id="block-4a45ee7a4b4e409fb0ad59acfd91bd96"><strong>Internet Layer</strong>: Exchanges datagrams across network boundaries, enabling internetworking and defining IP addresses and routing. Primary protocol: Internet Protocol (IP).</li><li id="block-2ad67991731e43f38cc59fd7d9ecac4c"><strong>Link Layer</strong>: Manages local network communications without routers. Defines local network topology and interfaces for transmitting datagrams to neighboring hosts.</li></ul><p id="block-860fc5693f23441a96124c617d542a6d">Specifically pay attention to the <strong>Security Layer</strong>, as that layer is the defining difference between an <strong> </strong>HTTP request (which we just covered) and an HTTPS request (<a href="https://devonperoutky.super.site/blog-posts/intro-to-llms-for-engineers-1">~86% of the current internet</a> and growing).</p><span id="9ae044f73fbd4f999ce8add94e367939"></span><p id="block-cf2642a730224c2c8095a54d53a3e341"><strong>HTTPS is HTTP with encryption and verification</strong>. While there are multiple ways of securing HTTP communication over the internet, the current implementation everyone uses is <u>Transport Layer Security (TLS)</u><strong>. </strong></p><p id="block-30d821f3a0314b38964004bdd0ad1f80">TLS is how the client and server can verify each other identities and ensure all the payloads are encrypted in a way both parties will be able to decrypt them. The <strong><u>TLS handshake process</u></strong>, specifically, determines how the client and server will exchange encryption and verification keys. Once the keys have been exchanged, the client and server will communicate using HTTP as normal, and use the keys to encrypt and verify messages. </p><p id="block-73388ade2aae4b83b815a524bf1f480c">The flow of an HTTPS is the exact same as the HTTP request we covered previously, with the addition of a Security Layer in between the Application Layer and the Transport Layer (although typically TCP is used for the TLS handshake).
</p><p><img alt="image" loading="lazy" width="1296" height="665.2035398230089" decoding="async" data-nimg="1" srcset="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/6532134b-285a-4eb6-b7cc-f0c40ee67c91/HTTPS_Request/w=1920,quality=90,fit=scale-down 1x, https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/6532134b-285a-4eb6-b7cc-f0c40ee67c91/HTTPS_Request/w=3840,quality=90,fit=scale-down 2x" src="https://images.spr.so/cdn-cgi/imagedelivery/j42No7y-dcokJuNgXeA0ig/6532134b-285a-4eb6-b7cc-f0c40ee67c91/HTTPS_Request/w=3840,quality=90,fit=scale-down"/></p><span id="1fa6c45c12cc415cb427356fbfc72218"></span><h2 id="block-1fa6c45c12cc415cb427356fbfc72218">TLS Handshake</h2><p id="block-75e17b3f97754f688f99896501faede7">The TLS handshake is for the client and server to agree on a few different aspects of the communication. Specifically, the collection of algorithms that will be used for verifying, compressing, and encrypting messages.
</p><div id="block-60dd5e8feda6454085da7ed62ad8c17f"><p><span>🔒</span></p><p><span>This collection of algorithms are referred to as <strong>cipher suites. </strong>To be specific all of them except the compression algorithm are considered the cipher suite, but for brevity I’ll refer to the full collection of them the cipher suite going forward.</span></p></div><p id="block-43a0857c2c2b4ce4b34b2ca84e94276f">By agreeing on all these algorithms, exchanging random seeds, and the server’s SSL certificate containing the private key; the client and server can generate a symmetric key that will be used to encrypt and verify the messages being passed back and forth. This process of agreeing on cipher suites and distributing the necessary information (seeds and SSL cert) is referred to as the TLS handshake.</p><p id="block-fa7824a867e94ffa9035f89e790b29b7"><strong>Note:</strong> All communication happens over TCP, the <span>blue steps</span><span> indicate the TCP handshake and the </span><span>yellow steps</span><span> are TLS handshake .</span></p><span id="7fc77a5a056141e8aa638adda7e798ce"></span><h3 id="block-7fc77a5a056141e8aa638adda7e798ce">TLS Handshake</h3><ol type="1"><li id="block-7990d5473bde4f89986fbb37071545da"><strong>Client Hello</strong></li><ol type="a"><li id="block-f4bd7289f8e34482933e221b301cdd85">The client will send a “Client Hello”, which is an TCP message to the server specifying the <strong>cipher suites </strong>it supports, as well as the supported TLS version and a random number (called the Client Random)</li></ol><li id="block-12a24cee9f61447bbda18e45a07f2baa"><strong>Server Hello</strong></li><ol type="a"><li id="block-e1cacd7c4aed4af2bd82a1d444271560">The server will respond with a “Server Hello” which is a TCP message containing the chosen TLS version, the chosen cipher suite algorithms, and it’s own random number (the Server Random)</li></ol><li id="block-6f4fd96e106147e1ac5fb194e3615f1d"><strong>Certificate Verification</strong></li><ol type="a"><li id="block-4d1ab374647e4075ab7bae9d50b137dd">The client verifies the server’s SSL certificate with the Certificate Authority and retrieves the server’s public key.</li></ol><li id="block-cced34ed4fd54e04b1cbb677dd95f199"><strong>Premaster Secret Generation</strong></li><ol type="a"><li id="block-74c81de02c25438f958a3ce8884874bd">The client generates a premaster secret, encrypts it with the server’s public key, and sends it to the server.</li></ol><li id="block-b91a1b0000de4706b92b2a6e2e0eeb1b"><strong>Decryption</strong></li><ol type="a"><li id="block-9ca454a04df94d10ab9ece93a79b9dd6">The server decrypts the premaster secret using its private key.</li></ol><li id="block-6841419b1dd34aeca82e2d542bdb9f8a"><strong>Session Key Creation</strong></li><ol type="a"><li id="block-e5ba213c21db48c4b6fab4f701e2c66d">Both client and server use the client random, server random, and premaster secret to create session keys.</li></ol><li id="block-10d2f3104bea49a4968f842a78d01502"><strong>Client Ready</strong></li><ol type="a"><li id="block-dd364090e6b94e65be93d6143928956f">The client sends a &#34;finished&#34; message encrypted with a session key.</li></ol><li id="block-87b374581526436ea408c147ca1b4c17"><strong>Server Ready</strong></li><ol type="a"><li id="block-4dd7b9c44ec642cdaca3d6dde3771c6f">The server sends a &#34;finished&#34; message encrypted with a session key.</li></ol><li id="block-a23d176288e04830a456c7cee69b11c9"><strong>Secure HTTP Communication</strong></li><ol type="a"><li id="block-4abc1c42b2674f3589d9a8e4091543f7">The session keys are used for secure symmetric encryption, ensuring both parties can now communicate securely.</li></ol></ol><p id="block-3a43f458d59445c1bb128242fab04396">Boom. That’s the TLS handshake, except for one more thing, and that is….</p><span id="c7300fc061d5483daaa88154bb2cea66"></span><h2 id="block-c7300fc061d5483daaa88154bb2cea66"><strong>Everything you’ve learned here is a lie.</strong></h2><p id="block-748f13c3db0b45e980f02abac5401976">The process we just describe is for the original version of TLS, which is outdated compared to the more modern version of TLS 1.3. </p><span id="b2d72c0ae8ce49a286ca653d39478c83"></span><p id="block-42e96c42e27f47949c4b262d121c19ba">The process we just went through is a little outdated, but it’s a great place to start due to it introducing the necessary concepts of what needs to be agreed upon for secure server &lt;&gt; client communication.</p><p id="block-1cf8f0e225a24ef3b0eac1bb72dff256">Current version of TLS (&gt;1.3) do not support RSA (and various other cipher suites) for security reasons. The newer versions are more opinionated, allow significantly fewer options, which makes them simpler, more secure, and faster. However, the components and concepts are all very much the same. You still have an TLS handshake process that agrees on the compression method, the server-authentication, and key exchange in the pursuit of generating a symmetric encryption key for securing the data of the packets being exchanged via TCP.</p><p id="block-70bf2930e55c440e98223a7e82186d83">TLS 1.3 does not support RSA, nor other cipher suites and parameters that are vulnerable to attack. It also shortens the TLS handshake, making a TLS 1.3 handshake both faster and more secure.</p><p id="block-f73c3f405aa44b13b0bf43b4cf1b4e7a">The basic steps of a TLS 1.3 handshake are:</p><ul><li id="block-2d2c6f2fbe6a4de182531bb7ac50549a"><strong>Client hello:</strong> The client sends a client hello message with the protocol version, the client random, and a list of cipher suites. Because support for insecure cipher suites has been removed from TLS 1.3, the number of possible cipher suites is vastly reduced. The client hello also includes the parameters that will be used for calculating the premaster secret. Essentially, the client is assuming that it knows the server’s preferred key exchange method (which, due to the simplified list of cipher suites, it probably does). This cuts down the overall length of the handshake — one of the important differences between TLS 1.3 handshakes and TLS 1.0, 1.1, and 1.2 handshakes.</li><li id="block-4e0c35e5fe8d48efbea3d6ba668dda9b"><strong>Server generates master secret:</strong> At this point, the server has received the client random and the client&#39;s parameters and cipher suites. It already has the server random, since it can generate that on its own. Therefore, the server can create the master secret.</li><li id="block-7b89dcadff024e2ca7135ff4b7b516d8"><strong>Server hello and &#34;Finished&#34;:</strong> The server hello includes the server’s certificate, digital signature, server random, and chosen cipher suite. Because it already has the master secret, it also sends a &#34;Finished&#34; message.</li><li id="block-03476ed7815c44f5bfa3e457b2685ed6"><strong>Final steps and client &#34;Finished&#34;:</strong> Client verifies signature and certificate, generates master secret, and sends &#34;Finished&#34; message.</li><li id="block-be2119fe75b14ac9ac017fb33d32730f"><strong>Secure symmetric encryption achieved</strong></li></ul><p id="block-78ea5c7befc64dbb910682ef36d6d94b">There you go. Go out and ace your technical interviews now.</p><span id="a4074de1cd2343cd893d699766bd6194"></span><p id="block-326cb4391197400d933099a5de91b7fa">If you want to read more posts like these, you can subscribe.</p><p id="block-2d0390f0ef7d4b08a1159647f5c8ef85">In addition to writing mediocre <a href="https://devonperoutky.super.site/">technical blog posts</a>, I also offer consultancy services and run a <a href="http://jedsoftware.com" target="_blank" rel="noopener noreferrer">development agency</a>. I have <a href="https://devonperoutky.super.site/">built a lot of things</a>, including</p><p id="block-9848e6aa25ce403ea43eacdb95ebd9c6">…an RAG AI chatbot and search tool for corporate knowledge bases that was acquired by Brex</p><p id="block-e0cd77c7dc5342b5941f0569a38fe713">…distributed Python and Scala services at Twilio and Valon</p><p id="block-f7fc1b7ce3c84f52adf41ed5e1454c64">…award-winning Military Recall App chosen by SAIC for the US Department of Defense</p><p id="block-0b35458c6a09400a976be6ee8f4249b3">I’ve also helped led teams at some of these elite startups. If you are looking for software development services or consultation for a project, I might be able to help. Feel free to reach out at <a href="mailto:devonperoutky@gmail.com" target="_blank" rel="noopener noreferrer">devonperoutky@gmail.com</a>.</p></article></div>
  </body>
</html>
