<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipotoole.com/how-i-found-a-bug-in-sqlite/">Original</a>
    <h1>I found a bug in SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p><a href="https://github.com/rqlite/rqlite" target="_blank" rel="noopener noreferrer">rqlite</a><img src="https://www.philipotoole.com/wp-content/uploads/2022/12/bug.png" alt="" width="150" height="150" srcset="https://www.philipotoole.com/wp-content/uploads/2022/12/bug.png 512w, https://www.philipotoole.com/wp-content/uploads/2022/12/bug-300x300.png 300w, https://www.philipotoole.com/wp-content/uploads/2022/12/bug-150x150.png 150w" sizes="(max-width: 150px) 100vw, 150px"/> is a lightweight, open-source, distributed relational database written in <a href="https://golang.org" target="_blank" rel="noopener noreferrer">Go</a>, which uses <a href="http://sqlite.com" target="_blank" rel="noopener noreferrer">SQLite</a> as its storage engine. Recently I introduced <a href="https://www.philipotoole.com/rqlite-trading-durability-for-performance/">a high-performance write-path</a> into rqlite and, to my <a href="https://www.sqlite.org/testing.html" target="_blank" rel="noopener noreferrer">great surprise</a>, it exposed a bug in SQLite.</p>

<p>The SQLite team <a href="https://www.sqlite.org/src/info/15f0be8a640e7bfa" target="_blank" rel="noopener noreferrer">quickly addressed the issue</a> but let’s take a look at the behavior I saw, and how I finally created a simple test which reproduced the issue.</p>
<h2>It always starts with a new feature</h2>
<p>rqlite <a href="https://github.com/rqlite/rqlite/releases/tag/v7.5.0" target="_blank" rel="noopener noreferrer">7.5.0</a> introduced <em><a href="https://www.philipotoole.com/rqlite-trading-durability-for-performance/">Queued Writes</a> </em>— allowing users to write large amounts of data to rqlite in a high-performance manner. Of course, this meant that the SQLite INSERT rate would also increase, which, of course, was the point.</p>
<p>During my <a href="https://github.com/rqlite/rqlite/tree/master/cmd/rqbench" target="_blank" rel="noopener noreferrer">load testing</a> of Queued Writes, I would sometimes run the <a href="https://github.com/rqlite/rqlite/blob/master/DOC/CLI.md" target="_blank" rel="noopener noreferrer">rqlite CLI</a>, and keep an eye on test progress by issuing the following command periodically:</p>
<pre>127.0.0.1:4001&gt; SELECT COUNT(*) FROM logs</pre>
<p>Imagine my surprise when I would occasionally get back:</p>
<pre>ERR! database disk image is malformed</pre>
<p>Well, that’s strange. rqlite runs <a href="https://github.com/rqlite/rqlite/blob/master/README.md#in-memory-databases" target="_blank" rel="noopener noreferrer">an in-memory database</a> by default. How could the disk image be corrupted? I put it down to re-use of an error code within SQLite, which is a fairly common practice in programming generally. <strong>But then I made the real mistake.</strong> I didn’t take the error seriously enough and decided it was probably something transient, never to be seen again.</p>
<h2>The real world intrudes</h2>
<p>On November 1st a rqlite user, <span><a href="https://github.com/jvarruda" target="_blank" rel="noopener noreferrer">João Arruda</a>, filed the following issue on GitHub:<br/>
</span></p>
<p><a href="https://github.com/rqlite/rqlite/issues/1103" target="_blank" rel="noopener noreferrer"><img src="https://www.philipotoole.com/wp-content/uploads/2022/12/GitHubMalformedIssue.png" alt="" width="756" height="563" srcset="https://www.philipotoole.com/wp-content/uploads/2022/12/GitHubMalformedIssue.png 756w, https://www.philipotoole.com/wp-content/uploads/2022/12/GitHubMalformedIssue-300x223.png 300w" sizes="(max-width: 756px) 100vw, 756px"/></a></p>
<p>There was no denying it now — this was a real issue, and potentially a serious one. Who wants to see errors about “malformed disk image” when using a <em>database</em>?</p>
<p>The first thing to do was to think about what was happening — and could I reproduce what <span>João</span> was seeing? I fired up my load test again, increased the INSERT rate until the disk IO was maxed out, and started querying the database via the CLI — and hit the issue again.</p>
<pre>ERR! database disk image is malformed</pre>
<p>What my testing did show was that this was a <em>query-time</em> issue only. Once the INSERT traffic ceased the correct number of records were always in the database — and those records always looked fine. So that was the good news — whatever was going on was not <strong>actually</strong> corrupting the database.</p>
<h2>Let’s unit test it</h2>
<p>The next was to simplify the setup. Could I write a test that would bring out the issue? Thinking about what was going on I realised it wasn’t much more complicated than queries being performed on one database connection, while rows were being concurrently inserted on a different connection. Shouldn’t be too difficult to reproduce, right?</p>
<p>And it wasn’t. I wrote <a href="https://github.com/otoolep/go-sqlite3/blob/2bc68fd6cbd8c563cba27d597b123be6b8963d66/malformed_test.go" target="_blank" rel="noopener noreferrer">a simple unit test in Go</a>, which involved no rqlite code, and ran it.</p>
<pre>$ go <span>test</span> -run Test_TableCreationInMemoryLoadRaw
--- FAIL: Test_TableCreationInMemoryLoadRaw (2.30s)
    malformed_test.go:59: rows had error after <span>Next</span>() (1203 loops): database disk image is malformed
FAIL
<span>exit</span> status 1
FAIL	github.com/mattn/go-sqlite3	2.303s</pre>
<p>Boom! Now I knew I was onto something. Next step was to check with the maintainers of the <a href="https://github.com/mattn/go-sqlite3" target="_blank" rel="noopener noreferrer">Go SQLite driver</a> used by rqlite. They confirmed <a href="https://github.com/mattn/go-sqlite3/pull/1108#issuecomment-1308200668" target="_blank" rel="noopener noreferrer">there was something going on deep in SQLite</a>, and wasn’t a problem with the Go code.</p>
<h2>If you didn’t code it in C, it didn’t happen</h2>
<p>Now it was time to post on the SQLite forum. I <a href="https://sqlite.org/forum/forumpost/f12698c69b5c0fd9" target="_blank" rel="noopener noreferrer">made my first post in early November</a>, looking for help. I asked why should my queries see a corrupt disk image, with an in-memory database? While I got some response to my question, there was no real progress. I recognized that a Go-only example wouldn’t be too convincing to the SQLite community. There were just too many layers between my code and the SQLite implementation — too many reasons why it could be my usage of SQLite, and not SQLite itself.</p>
<p>So time to write a simple C program! Would I bring out the issue? Would it disappear? Either way I hoped to learn something.</p>
<p><a href="https://github.com/otoolep/sqlite-c-test/blob/main/in-memory.c" target="_blank" rel="noopener noreferrer">I put together a C program pretty easily</a> — the SQLite C API is surprisingly easy to code against. And then I compiled and executed it:</p>
<pre><code>$ gcc in-memory.c -pthread -l sqlite3
$ ./a.out 
Running SQLite version 3.39.4
THREADSAFE=1
Failed to step data: database disk image is malformed</code></pre>
<p>And there you go.  <strong>A simple use of SQLite and my perfectly-fine queries encounter a corrupt database</strong>. It was <a href="https://sqlite.org/forum/forumpost/d443fb0730" target="_blank" rel="noopener noreferrer">time to post on the SQLite forum again</a>. And very soon afterwards the SQLite team confirmed <a href="https://sqlite.org/forum/forumpost/705955d7110e89a5" target="_blank" rel="noopener noreferrer">it was a bug in SQLite</a>, and <a href="https://www.sqlite.org/src/info/15f0be8a640e7bfa" target="_blank" rel="noopener noreferrer">patched their source code</a>.</p>
<p>Looking at the patch it appears that my query connection was getting access to the database when it shouldn’t have — and then seeing a database that was in the middle of changing. The query code interpreted this as a corrupt database, and returned an error to my code.</p>
<p>This was all very gratifying. I realised finding this bug was probably the most impactful thing I’d done in my entire software career! I quickly <a href="https://github.com/rqlite/go-sqlite3/commit/4dde487be162d653b748f14b608abdd4ac834cbf" target="_blank" rel="noopener noreferrer">patched my copy of SQLite</a>, not waiting for a new SQLite release. I rebuilt rqlite and could no longer reproduce the issue.</p>
<p>And finally <span>João</span> <a href="https://rqlite.slack.com/archives/C0324J4LC91/p1670599162114529?thread_ts=1670413278.095309&amp;cid=C0324J4LC91" target="_blank" rel="noopener noreferrer">confirmed it no longer occurred in his production setup</a> either:</p>
<p><a href="https://www.philipotoole.com/wp-content/uploads/2022/12/SlackSQLiteBug.png"><img src="https://www.philipotoole.com/wp-content/uploads/2022/12/SlackSQLiteBug.png" alt="" width="929" height="611" srcset="https://www.philipotoole.com/wp-content/uploads/2022/12/SlackSQLiteBug.png 929w, https://www.philipotoole.com/wp-content/uploads/2022/12/SlackSQLiteBug-300x197.png 300w, https://www.philipotoole.com/wp-content/uploads/2022/12/SlackSQLiteBug-768x505.png 768w" sizes="(max-width: 929px) 100vw, 929px"/></a>As a result <a href="https://github.com/rqlite/rqlite/releases/tag/v7.12.1" target="_blank" rel="noopener noreferrer">rqlite 7.12.1 was released</a>, including the fix for this issue.</p>
<h2>Lessons learned</h2>
<p>The lesson learned here is the same as it always is. <strong>The computers are doing exactly what you tell them to do</strong>. They don’t randomly insert errors in your system, and the computers are not making stuff up as they go along. Ignoring the issue when I saw it first was a big mistake, and was not being intellectually honest.</p>
<p>Many thanks to <span>João</span> for filing the issue on GitHub, <a href="https://github.com/rittneje" target="_blank" rel="noopener noreferrer">rittneje@</a> who maintains the Go SQLite driver at the center of rqlite and helped show it was a SQLite issue, and <a href="https://www.sqlite.org/crew.html" target="_blank" rel="noopener noreferrer">SQLite team</a> for fixing the bug so quickly.</p>
	</div></div>
  </body>
</html>
