<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.graplsecurity.com/post/attacking-firecracker">Original</a>
    <h1>Attacking Firecracker: AWS&#39; MicroVM Monitor Written in Rust</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>By: Valentina Palmiotti, <a href="https://twitter.com/chompie1337" target="_blank"><strong>@chompie1337</strong></a><br/></p><p>At <a target="_blank" href="https://www.graplsecurity.com/"><strong>Grapl</strong></a> we believe that in order to build the best defensive system we need to deeply understand attacker behaviors. As part of that goal we&#39;re investing in offensive security research. Keep up with our blog for new research on high risk vulnerabilities, exploitation, and advanced threat tactics.</p><p>This blog post covers attacking a vulnerability in <a href="https://firecracker-microvm.github.io/" target="_blank"><strong>Firecracker</strong></a>,<strong> </strong>an open source micro-virtual machine (<a target="_blank" href="https://qemu.readthedocs.io/en/latest/system/i386/microvm.html">microVM</a>) monitor written in the <a target="_blank" href="https://www.rust-lang.org/">Rust programming language.</a> It was developed for use in <a target="_blank" href="https://aws.amazon.com/lambda/">AWS Lambda</a>, a serverless software-as-a-service (SaaS) application hosting service. Firecracker is also used for AWS’ similar <a target="_blank" href="https://aws.amazon.com/fargate/">Fargate</a> service that provides a way to run containers without having to manage servers for container orchestration. Due to the risks that are introduced via <a target="_blank" href="https://www.techtarget.com/whatis/definition/multi-tenancy">multi-tenancy</a>, Firecracker was intentionally designed with security mind.</p><p>In this post, we’ll cover the following topics:<br/></p><ul role="list"><li>What is Firecracker? </li><li>Why attack it?</li><li>How does it work?</li><li>Root cause analysis of a memory corruption vulnerability, <a target="_blank" href="https://nvd.nist.gov/vuln/detail/CVE-2019-18960"><strong>CVE-2019-18960</strong></a></li><li>Exploit primitives and analysis of exploitability</li><li>Reflections and takeaways as they relate to security </li></ul><p>I had no knowledge of Firecracker (or Rust) prior to conducting this research. My hope is that this post will be useful for those wanted to learn about virtualization, Firecracker, KVM and provide some clarity on the various layers of virtualization and VM escape exploitation.</p><h2>Firecracker: What is it?</h2><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/6319010551a1fe4b028b3724_firecracker_logo%20(2).svg" loading="lazy" alt=""/></p></figure><p>Firecracker is an open source virtual machine monitor (VMM) created and maintained by Amazon Web Services (AWS). Per Amazon’s website, Firecracker is a “new virtualization and open source technology that enables service owners to operate secure multi-tenant container-based services by combining the speed, resource efficiency, and performance enabled by containers with the security and isolation offered by traditional VMs.” <a target="_blank" href="https://aws.amazon.com/about-aws/whats-new/2018/11/firecracker-lightweight-virtualization-for-serverless-computing/">[1]</a>.  </p><p>Firecracker is comparable to <a target="_blank" href="https://www.qemu.org/">QEMU</a>; they are both VMMs that utilize <a target="_blank" href="https://ubuntu.com/blog/kvm-hyphervisor">KVM</a>, a hypervisor built into the Linux kernel. Firecracker was designed to prioritize security and efficiency for serverless workloads. This led to some key design differences to QEMU.  Firecracker is much less flexible than QEMU. In order to minimize complexity and attack surface, Firecracker forgoes non-essential functionality. QEMU, on the other hand, has had <a target="_blank" href="http://cvekey">many vulnerabilities</a> arise from complex device implementations. </p><h2>Why Firecracker?<br/></h2><p>Technology like Firecracker is of particular interest to Grapl because we’re building a multi-tenant system with customer provided code execution. Therefore, it is of upmost importance that multi-tenant boundaries can not be violated. Firecracker is used by AWS to isolate runtimes from each other. Before deciding to use Firecracker in production, we conducted a security review of the product to evaluate whether it was appropriate for our use case. We also wanted to conduct offensive driven research to come up with hardening measures that are effective and worthwhile to implement in our environment. Because Grapl’s use case is specific, unlike AWS which has to run arbitrary applications, we can enforce more constraints on our application (such as execution time, resource usage, credential limitations, the files available to it, etc).  This research came as a result of our security review.</p><h2>How Does it Work?</h2><p>First, I’ll briefly explain generally how a virtual machine monitor (VMM) uses KVM and then get into the specifics of Firecracker.</p><h3>KVM</h3><div><p>KVM (Kernel-based Virtual Machine) is a <a href="https://medium.com/teamresellerclub/type-1-and-type-2-hypervisors-what-makes-them-different-6a1755d6ae2c">type-1 hypervisor</a> built into the Linux kernel (for x86) that allows a host to run multiple isolated virtual machines. It consists of two loadable kernel modules. The first, <span>kvm.ko</span>, provides the virtualization infrastructure. The second is a processor specific module (for either Intel or AMD) which takes a slice of the host’s physical CPU and maps it directly to the guest’s virtual CPU.</p>

<p>Each guest VM runs as a regular Linux process in the host.  KVM in the kernel exposes a low level <a href="https://www.kernel.org/doc/html/latest/virt/kvm/api.html">API</a> to user space processes via <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">ioctls</a> to the <span>/dev/kvm</span> device. Through this API, the VMM user space process can create new VMs, assign vCPUs and physical memory, and intercept I/O or memory accesses to provide the guest access to emulated or virtualization-aware hardware devices <a href="https://googleprojectzero.blogspot.com/2021/06/an-epyc-escape-case-study-of-kvm.html">[2]</a>.</p></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/63190c1ca347abfefb2a7770_firecracker_1%20(Copy)%20(1).svg" loading="lazy" alt=""/></p></figure><h3>Firecracker Design</h3><p>Firecracker is a VMM that uses the Linux Kernel’s KVM virtualization infrastructure to provide Linux and OSv microVMs on Linux hosts. On the host, there is one Firecracker process per microVM.</p><p>There were some important design decisions with respect to security. The goal of Firecracker is to be a minimal VMM, so it only provides a <i>limited</i> number of emulated devices. These devices are: block storage (<span>virtio-blk</span>), network (<span>virtio-net</span>), vsock (<span>virtio-vsock</span>), balloon driver (<span>virtio-balloon</span>), a serial console, and a partial I8042 keyboard controller used only to stop the VM <a href="https://www.talhoffman.com/2021/07/18/firecracker-internals/">[4]</a>. For comparison, QEMU has support for over 40 emulated devices, from which vulnerabilities are reported often.</p><p>Storage is done via block device rather than file system passthrough, to avoid giving the guest access to the host’s Linux kernel filesystem code, which is complex (and often has exploitable bugs). Firecracker also exposes a REST based configuration API over UNIX domain socket <a target="_blank" href="https://assets.amazon.science/96/c6/302e527240a3b1f86c86c3e8fc3d/firecracker-lightweight-virtualization-for-serverless-applications.pdf">[3]</a>. </p><div><p>The Firecracker <span>virtio-vsock</span> design, to support host-guest communication via socket, is also security conscious. The standard way is to use <span>vhost</span> (like what QEMU does), which requires a guest to pass data directly to a <span>vhost</span> kernel module on the host. Instead, Firecracker has its own <span>vsock</span> device as a backend to avoid exposing this additional attack surface. I will describe this design more in detail in the next section.</p>

<p>Firecracker can be further constrained using the <a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/jailer.md">jailer</a> program, which applies a set of sandboxing restrictions (such as <span><a href="https://en.wikipedia.org/wiki/Seccomp">seccomp</a></span>) to the process.</p></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/631916976b4fff56992d7feb_Firecracker_2%20(2).svg" loading="lazy" alt=""/></p></figure><h3>virtio-vsock</h3><div><p>The vulnerability we’ll discuss is found in the <span>vsock</span> implementation of Firecracker. I will explain this design a bit more in depth in the current section.</p><p><span>virtio-vsock</span> is a guest/host communication device that allows applications on the guest and host to communicate via socket <a href="https://wiki.qemu.org/Features/VirtioVsock#:~:text=virtio-vsock%20is%20a%20host,-agent%20or%20SPICE%20vdagent)">[5]</a>. The standard way of implementing <span>vsock</span>, like what is done by QEMU, is by using the <span>vhost-vsock</span> kernel module. The <span><a href="https://chromium.googlesource.com/chromiumos/platform2/+/9e91613d2da1b3d6cfb1c77681444e688ce99cf4/vm_tools/docs/vsock.md">vhost-vsock</a></span> kernel module provides <span>virtio</span> device emulation in the kernel, handling the communication with the guest <a href="https://stefano-garzarella.github.io/posts/2019-11-08-kvmforum-2019-vsock/">[6]</a>. This allows the guest to pass untrusted data directly to a module running on the host’s kernel.</p>

<p>Firecracker, on the other hand, emulates the <span>virtio-vsock</span> device itself in user space, implementing the device model over <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">MMIO</a>. The <span>vsock</span> device is exposed to the host via a UNIX socket. Firecracker mediates communication between an <span>AF_VSOCK</span> socket (on the guest end) and an <span>AF_UNIX</span> socket (on the host end) <a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/vsock.md">[7]</a>. This solution has the advantage of avoiding a new kernel attack surface and there’s also less dependency on host kernel features, like <span>vhost</span>.</p></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/63191e3fda2ebff6cb726dca_Firecracker_3%60%20(2).svg" loading="lazy" alt=""/></p></figure><h2>The Vulnerability</h2><p>There have only been three CVEs registered for Firecracker since its creation, and only one that can potentially lead to RCE on the host. In addition to being an RCE vulnerability, I chose to look at <a target="_blank" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18960">CVE-2019-18960</a> because it is a memory corruption vulnerability. Being completely new to Rust, I thought it would be worthwhile to examine how memory corruption vulnerabilities can still occur in a memory safe language. </p><div><p>The vulnerability is found in the <span>vsock</span> device implementation of Firecracker. As explained in a previous section, Firecracker implements the <span>virtio-vsock</span> device model over MMIO. That means that Firecracker reads directly from the guest’s memory, which also resides in Firecracker’s own process memory.</p>

<p>When a VM is created, Firecracker allocates the memory used for the guest’s RAM <a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/memory_model/src/mmap.rs#L59">using mmap</a>. This is represented by a vector of <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/memory_model/src/guest_memory.rs#L40">MemoryRegion</a></span> structures.</p></div><div><pre><code>pub struct MemoryRegion {
    mapping: MemoryMapping,
    guest_base: GuestAddress,
}</code></pre></div><div><p>Here <span>guest_base</span>, a <span>GuestAddress</span> structure, stores a 64 bit base physical address on the guest. The <span>MemoryMapping</span> structure, <span>mapping</span>, stores a pointer to the associated memory in the Firecracker process along with the size.</p>

<p>Firecracker performs I/O on the <span>vsock</span> device using the standard <span>virtio</span> <a href="https://developer.ibm.com/articles/l-virtio/">interface</a>. The drivers running in the guest’s kernel communicate with Firecracker through shared buffers. The guest allocates one or more buffers representing the request, registers these buffers with a descriptor table (an array), and signals that the buffers are ready to be consumed via a ring data structure (called a <span>virtqueue</span>). Each index of a descriptor table contains a descriptor which contains information about the guest provided buffer <a href="https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html#fn:footnote-virtio">[9]</a>.</p></div><div><pre><code>struct Descriptor {
    addr: u64,
    len: u32,
    flags: u16,
    next: u16,
}</code></pre></div><div><p>If specified in <span>flags</span>, descriptors can be chained together with <span>next</span> containing the descriptor table index of the chained descriptor. <span>virtio-vsock</span>, buffers in a descriptor chain are used to construct a <span>vsock</span> packet. Something to note at this point: the buffer information in the descriptor comes from the guest, and it should be treated as untrusted.</p>

<p>When creating a new <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/devices/src/virtio/queue.rs#L38">DescriptorChain</a></span>, the function <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/devices/src/virtio/queue.rs#L108">is_valid</a></span> is called. Here is where <span>addr</span> and <span>len</span> are checked to make sure the buffer received from the guest is valid.</p></div><div><pre><code>fn is_valid(&amp;self) -&gt; bool {
        !(self
            .mem
            .checked_offset(self.addr, self.len as usize)
            .is_none()
            || (self.has_next() &amp;&amp; self.next &gt;= self.queue_size))
}</code></pre></div><div><pre><code>/// Returns the address plus the offset if it is in range.
pub fn checked_offset(&amp;self, base: GuestAddress, offset: usize) -&gt; Option&lt;GuestAddress&gt; {
    if let Some(addr) = base.checked_add(offset) {
        for region in self.regions.iter() {
            if addr &gt;= region.guest_base &amp;&amp; addr &lt; region_end(region) {
                    return Some(addr);
            }
        }
    }
    None
}</code></pre></div><p>In the code snippet above on line 3, the <span>base</span> address is being added to <span>offset</span> (size of the I/O buffer in this case) to check if resulting address results in an integer overflow. If that check passes, the guest’s <span>MemoryRegion</span>s are iterated through to see if the resulting address falls within a valid region. However, this check is not sufficient. There are two problems that could occur; the base and result address may belong to two different regions, and the base address may not even exist in a valid region.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/63192c1437e439d55179d75f_Firecracker_4%20(3).svg" loading="lazy" alt=""/></p></figure><div><p>Now, for this bug to be exploitable, we need a way for the out of bounds buffer to be used. That is where <span>vsock</span> comes in. Recall that <span>vsock</span> packets are constructed from descriptor chains.</p>

<p>Let’s look at the <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/devices/src/virtio/vsock/packet.rs#L93">VsockPacket</a></span> structure and how it is <a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/devices/src/virtio/vsock/packet.rs#L106">created</a>. The first descriptor buffer in a descriptor chain will contain the packet header, and the following contains the packet data. Both the header and the data to both are stored as raw pointers, along with the packet size inside the <span>VsockPacket</span> structure.</p></div><div><pre><code>pub struct VsockPacket {
    hdr: *mut u8,
    buf: Option&lt;*mut u8&gt;,
    buf_size: usize,
}</code></pre></div><p>The pointers to both are copied into the structure after being returned from <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/memory_model/src/guest_memory.rs#L386">get_host_address</a></span>.</p><div><pre><code>let mut pkt = Self {
    hdr: head
        .mem
        .get_host_address(head.addr)
        .map_err(VsockError::GuestMemory)? as *mut u8,
        buf: None,
        buf_size: 0,
};

pkt.buf_size = buf_desc.len as usize;
pkt.buf = Some(
    buf_desc
        .mem
        .get_host_address(buf_desc.addr)
        .map_err(VsockError::GuestMemory)? as *mut u8,
);</code></pre></div><p>The <span>get_host_address</span> function takes a physical address from the guest and returns the corresponding address in the Firecracker process’ memory.</p><div><pre><code>pub fn get_host_address(&amp;self, guest_addr: GuestAddress) -&gt; Result&lt;*const u8&gt; {
        self.do_in_region(guest_addr, 1, |mapping, offset| {
            // This is safe; `do_in_region` already checks that offset is in
            // bounds.
            Ok(unsafe { mapping.as_ptr().add(offset) } as *const u8)
        })
    }</code></pre></div><p>A memory region base address and the <span>offset</span> of the guest address from the base is calculated in  <span><a href="https://github.com/firecracker-microvm/firecracker/blob/effaab05e4b02b25c578273d966e04c98d2cf2e1/memory_model/src/guest_memory.rs#L434&#34;">do_in_region</a></span> and the addition of the two is returned as the resulting pointer. On line 5 in the code snippet above, there is an <span>unsafe</span> block. In Rust, a block of code can be prefixed with the <span>unsafe</span> keyword to permit operations such as dereferencing a raw pointer, reading or writing to a mutable static variable, accessing a field of a union (other than to assign it), or calling an <span>unsafe</span> function <a href="https://doc.rust-lang.org/reference/unsafety.html">[10]</a>. In the code snippet above, the comment states that the operation in the <span>unsafe</span> block is safe to allow because <span>do_in_region</span> checks that the offset is in bounds. Let’s take a look:</p><div><pre><code>fn do_in_region&lt;F, T&gt;(&amp;self, guest_addr: GuestAddress, size: usize, cb: F) -&gt; Result&lt;T&gt;
    where
        F: FnOnce(&amp;MemoryMapping, usize) -&gt; Result&lt;T&gt;,
    {
        for region in self.regions.iter() {
            if guest_addr &gt;= region.guest_base &amp;&amp; guest_addr &lt; region_end(region) {
                let offset = guest_addr.offset_from(region.guest_base);
                if size &lt;= region.mapping.size() - offset {
                    return cb(&amp;region.mapping, offset);
                }
                break;
            }
        }
        Err(Error::InvalidGuestAddressRange(guest_addr, size))
    }</code></pre></div><div><p>As seen above, there is a bounds check performed. The function takes a parameter, <span>size</span>, and checks if the size of the buffer fits within the region. This ensures that the pointer being returned has space inside the <span>MemoryRegion</span> for the expected amount of memory that will be accessed.</p>

<p>Now referring back to the calling function, <span>get_host_address</span>,  note that 1 is always passed in as the size, instead of the actual size of the corresponding buffer. This means that as long as the buffer address starts in a valid region, it can overrun the region if its size is large enough. Due to the first check in <span>checked_offset</span>, the overrun has to end in a valid memory region to get this far, though.</p></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/63193c5a745f32dd9a020ae8_Firecracker_5%20(2).svg" loading="lazy" alt=""/></p></figure><p>This is interesting, because without this second bug, the previously discussed bug would not be exploitable.</p><p>Now after constructing a <span>VsockPacket</span>, the raw pointer stored in <span>buf</span> will be used to do read/write operations with the packet data to manage communications with the UNIX socket on the host. This can be used to obtain a read/write primitive outside of the guest’s memory space within the Firecracker process.</p><h2>Exploit Primitives</h2><p>To exploit this vulnerability an attacker has to have kernel execution in a guest VM. This is in order to execute at the level of the guest’s <span>virtio-vsock</span> driver. The first step of writing an exploit for this vulnerability is to write a kernel module to trigger it. The module has to register an invalid buffer with the <span>vsock</span> device. This is done by writing an invalid address and length combination in a descriptor table entry.</p><p>Before beginning to write code, I wanted to first look at what exploit primitives can be constructed with the vulnerability, theoretically. I had some concerns:<br/></p><p><strong>a)</strong> The area of out of bound’s memory that can be read/written to is limited to a specific area.<br/></p><p>and<br/></p><p><strong>b)</strong> Runtime mitigations in Rust are restrictive.</p><div><p>The first step is to investigate the area of memory that can be controlled. To trigger the vulnerability, there must be at least more than one <span>MemoryRegion</span> associated with a guest’s memory space.</p>

<p>Let’s look at how the regions are created for x86_64 VMs:</p></div><div><pre><code>const MEM_32BIT_GAP_SIZE: usize = (768 &lt;&lt; 20);
 
/// Returns a Vec of the valid memory addresses.
/// These should be used to configure the GuestMemory structure for the platform.
/// For x86_64 all addresses are valid from the start of the kernel except a
/// carve out at the end of 32bit address space.
pub fn arch_memory_regions(size: usize) -&gt; Vec&lt;(GuestAddress, usize)&gt; {
    let memory_gap_start = GuestAddress(FIRST_ADDR_PAST_32BITS - MEM_32BIT_GAP_SIZE);
    let memory_gap_end = GuestAddress(FIRST_ADDR_PAST_32BITS);
    let requested_memory_size = GuestAddress(size);
    let mut regions = Vec::new();

    // case1: guest memory fits before the gap
    if requested_memory_size &lt;= memory_gap_start {
        regions.push((GuestAddress(0), size));
    // case2: guest memory extends beyond the gap
    } else {
        // push memory before the gap
        regions.push((GuestAddress(0), memory_gap_start.offset()));
        regions.push((
            memory_gap_end,
            requested_memory_size.offset_from(memory_gap_start),
        ));
    }

    regions
}</code></pre></div><div><p>Here we can see that if the guest requires more than 0xD0000000 bytes of memory, a second <span>MemoryRegion</span> is created for the remaining memory. I also looked at the <span>aarch64</span> implementation, but it’s not possible to trigger the creation of more than one <span>MemoryRegion</span> for a VM in that architecture.</p>

<p>With this information, we know what to do: create a buffer descriptor with a physical address lower than the boundary of the first <span>MemoryRegion</span> (0xD0000000) and provide a length that overruns this address. The diagram below shows the basic exploit primitive we can theoretically achieve: </p></div><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/631951e88f55ac3b1c57a2fd_Firecracker_6%20(3).svg" loading="lazy" alt=""/></p></figure><h2>Exploitability</h2><p>In order to evaluate the exploitability of this vulnerability we need to investigate what memory can be accessed with the exploit primitive. </p><p>To answer this question, I did some debugging from within Firecracker.  First, I configured a Firecracker microVM to require enough memory to create two <span>MemoryRegion</span>s and printed their addresses during runtime. Below is a screenshot of Firecracker’s memory map after the <span>MemoryRegion</span>s have been created for the guest.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/63195a1cd4d35d6ee4a1d108_z45eq3w8.png" loading="lazy" alt=""/></p></figure><div><p>Note that the mappings for the two <span>MemoryRegion</span>s are contiguous. However, the mapping for the first <span>MemoryRegion</span> occurs at a higher address than the second <span>MemoryRegion</span>. Since our exploit primitive gives us the ability to overflow the mapping for the first <span>MemoryRegion</span>, we have the ability to overwrite at addresses higher than 0x7f1b3f118000 in the Firecracker process*. </p>

<p>There are some interesting areas of memory, such as the stack, that reside at higher addresses in the process. However, the pages mapped at address 0x7f1b3f11a000 are marked with <span>PROT_NONE</span> permissions, and act as a guard page. This means that we cannot overwrite onto the stack - if we have to do a contiguous write beginning from within the first <span>MemoryRegion</span> mapping we will <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segfault</a>. This gives us DoS of the Firecracker process, which isn’t very powerful if the attacker already has guest kernel execution.</p>

<p>I looked further into how <span>MemoryRegion</span>s are mapped, and found nothing that would help gain a more favorable allocation. I dumped the limited accessible area of memory at 0x7f1b3f118000-0x7f1b3f11a00 and found it was entirely NULL bytes. My inclination is that it is unlikely there is anything of interest there. </p>

<p>Since this vulnerability has been patched, the MMIO code that Firecracker uses has been overhauled. Now, “guard” pages are created to surround every guest memory region. <a href="hhttps://github.com/firecracker-microvm/firecracker/blob/2a5a6bc7155959d73f76f2af15125b7fd2798013/src/vm-memory/src/lib.rs#L27">The guard region is mapped</a> with <span>PROT_NONE</span>, so that any access to this region will cause a <span>SIGSEGV</span> segfault. This mitigation protects against the exploitation of the exact type of vulnerability we are trying to exploit here.</p>

<p>While the aforementioned protection hadn’t been implemented at the time this vulnerability was patched, it’s an interesting coincidence that a guard page is inhibiting exploitation. The guard page in this case is being mapped somewhere else, possibly at the time the ELF loading. I looked the memory maps of the other processes on the Firecracker host machine and they did not consistently have guard (<span>PROT_NONE</span>) mappings. To further experiment,  I wrote a small Rust program and saw that it did had a guard mapping in its memory map, albeit of a different size. I speculate it comes as a result of some sort of Rust mitigation.</p>

<p>This creates at a big road block for exploitation as the memory we can overflow into doesn’t contain anything interesting. At this time I decided to move on, but I have some ideas if I were to continue. Out of curiosity, I would do more analysis to figure out what is creating the mystery guard page. I would also try to see if  triggering an offset copy is possible. That is, a way such that the <span>VsockPacket</span>&#39;s data buffer is accessed at an offset, and miss the guard page completely. <span>VsockPacket</span>s are exchanged to and from Firecracker’s <span>vsock</span> backend which manages the UNIX socket on the host. I would analyze this part of the code to find other possible primitives.  I encourage anyone interested to pick up where I left off on this exploit and share their ideas.</p>

<p>*The size of the overflow is restricted to <span>vsock</span>
 packet size limits, among other things.</p></div><h2>Hardening</h2><p>While Firecracker’s design is security focused, there are a some hardening measures that can be used to further lock down the attack surface. <br/></p><p>First, limit untrusted code to running with the lowest privileges possible. Additionally, hardening the guest operating system and running a fully patched kernel is crucial. Without guest kernel execution, an attacker has no way to exploit the vulnerability covered in this post. <br/></p><p>The primary recommendation from the authors of Firecracker is to use <a target="_blank" href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/jailer.md">jailer</a>, a program designed to isolate the Firecracker process in order to enhance security. In the case of exploiting the discussed vulnerability, a takeover of the Firecracker process yields a restrictive execution environment. An attacker would need to bypass all the restrictions imposed by jailer to escalate privileges and execute outside of the Firecracker process. Read a step by step account of what the jailer program does on startup <a target="_blank" href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/jailer.md">here</a>. </p><p>Among the things jailer does is load a <span><a href="https://en.wikipedia.org/wiki/Seccomp">seccomp</a></span> filter for Firecracker, with a per thread profile. This means the different threads in the Firecracker process have different set of system calls that can be called from within the context, depending on the thread’s job. This is nice, but an attacker already in the Firecracker process can trivially hijack another thread that has access to different system calls. Therefore, jailer’s <span>seccomp</span> policy should be treated as a union of all of the thread’s allowable system calls. Currently, <span>io_uring</span> system calls are included in Firecracker’s <span>seccomp</span> filter. Because it redefines how system calls are executed, <span>io_uring</span> offers a <span>seccomp</span> bypass for the supported system calls. This is because <span>seccomp</span>  filtering occurs on system call entry after a thread <a href="https://www.geeksforgeeks.org/user-mode-and-kernel-mode-switching/">context switch</a>, but system calls executed via <span>io_uring</span> do not go through the normal system call entry. Therefore, Firecracker’s <span>seccomp</span> policy should be treated as its union with all system calls supported by <span>io_uring</span>.</p><h2>Security Reflections and Takeaways</h2><p>There are some of the major security takeaways gleaned from doing this short research project exploiting Firecracker:<br/></p><h4><strong>On the Kernel:</strong><br/></h4><p>Kernel hardening and attack surface reduction is critical, despite the potential to impose restrictions on use or negatively impact performance. Given a Firecracker vulnerability like the one covered in this post, protecting the kernel prevents an attacker with access to the attack surface. If an attacker did successfully exploit this vulnerability, they would have access to the host and any other VMs executing on that host. </p><p>Because of the nature system call filtering via <span>seccomp</span>, <span>io_uring</span> still presents a major security disruption in sandboxing. While it seems most appropriate to use LSM to restrict <span>io_uring</span>, that introduces requirements on the host that may be suboptimal. You can read more about <span>io_uring</span> in my blog post <a href="https://www.graplsecurity.com/post/iou-ring-exploiting-the-linux-kernel">here</a>.</p><h4><strong>On Firecracker Design:</strong></h4><p>The Firecracker team’s decision to forgo <span>vhost</span> and implement the back end resulted in a critical vulnerability being introduced. However, the same vulnerability would be much more critical if it were found in the <span>vhost</span> kernel code. Due to the relatively small size of the code base, the memory safety of Rust, the limited attack surface, and the newly introduced mitigations, it’s unlikely these types of vulnerabilities will be common or practically exploitable. 
</p><h4>On Rust:</h4><p>Though Rust is a memory safe language, memory corruption vulnerabilities are still possible. Rust uses <span>&amp;</span> references, which are like pointers in C (&#34;raw pointers&#34;), but with many restrictions that allow Rust to achieve memory safety <a href="https://doc.rust-lang.org/reference/types/pointer.html">[11]</a>. However, Rust provides an escape hatch, the <span>unsafe</span> keyword, for bypassing these <span>&amp;</span> restrictions. This is how Rust programs are able to call into native libraries and still able to validate the safety of <span>&amp;</span> references in other parts of the Rust code. Rust does not permit converting a pointer returned from a C library to an <span>&amp;</span> reference, because Rust is unable to validate the safety of the other library. These raw pointers are stored as <span>*const T</span> and <span>*mut T</span> in Rust, which we see in the vulnerable code snippets in this post. Given that the developer must explicitly tell Rust to avoid safety checks within <span>unsafe</span> blocks, it is the developer&#39;s responsibility to ensure the operations are safe in all possible cases.</p><p>Although not all exploitable bugs are that of memory safety, an interesting project for a vulnerability researcher is to search for unsafe blocks in Rust codebases and look for cases where they can be abused. Code comments asserting the safety of these blocks are clues into the assumptions the developer has made, indicating exactly what should be checked. To this aim, a researcher might be interested in <a target="_blank" href="https://crates.io/crates/cargo-geiger">cargo-geiger,</a> which can help identify unsafe blocks in a codebase as well as their dependencies. </p><p>In a <a href="https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html">recent blogpost</a>, the Kani Rust Verifier was used to formally verify the correctness of Firecracker’s <span>virtio</span>
 device code, with respect to a simple <span>virtio</span> requirement. The proof is for a property described in the <span>virtio</span><a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html">device specifiction</a>, and is a requirement for the behavior of the guest’s <span>virtio</span> driver. Here, they prove the property is always upheld regardless of malicious device requests from the guest. An interesting experiment would be to repeat the process with all the requirements found in the <span>virtio</span> spec, in particular those that apply to the guest’s driver. </p><h3>Takeaways for Grapl’s Multi-tenant Architecture</h3><p>This research was critical to understanding what strategies work best for hardening our multi-tenant architecture. Based on this work, we concluded there should be a focus on hardening the guest operating system. This limits an attacker’s ability to exploit the guest kernel, thus cutting off a considerable attack surface.</p><p>As such, we’ve focused on restricting the process within the VM to make escalation to kernel more difficult. This involves leveraging multiple linux sandboxing primitives, primarily through <a href="https://www.redhat.com/sysadmin/mastering-systemd">systemd’s native sandboxing features</a> features, including a restrictive <span>seccomp</span> filter</p><p>Given the difficulty in exploiting Firecracker <em>even with</em> control over the kernel, we feel confident in our solution.</p><h2>Conclusion</h2><p>Security research is critical to Grapl as a company. It helps us keep customer data safe, understand the technology we use at a deeper level, and think through advanced attack scenarios. As part of this research we generated ideas for detection logic, areas for further hardening, and more, which feeds back into product development.</p><p>Ultimately, we walk away from this research with a very positive view of Firecracker, a much deeper understanding of its internals, and confidence in our mitigations.</p><h2>Acknowledgements</h2><p>My amazing colleagues at<strong> </strong><a target="_blank" href="https://www.graplsecurity.com/"><strong>Grapl</strong></a>: <br/></p><p><a target="_blank" href="https://mobile.twitter.com/_inickles"><strong>Ian Nickles</strong></a>, for his help with instrumentation, Rust, and general research. <br/></p><p><a target="_blank" href="https://twitter.com/and_zza"><strong>Andréa</strong></a>, for her incredible work on the diagrams. <br/></p><p><a target="_blank" href="https://twitter.com/InsanityBit"><strong>Colin O’Brien</strong></a>, for his help with Rust.<br/></p><p><a target="_blank" href="https://twitter.com/wwiimmaaxx"><strong>Max Wittek</strong></a>, for his help with Firecracker. </p><h2>References<br/></h2><ol start="1" role="list"><li><a target="_blank" href="https://aws.amazon.com/about-aws/whats-new/2018/11/firecracker-lightweight-virtualization-for-serverless-computing/">https://aws.amazon.com/about-aws/whats-new/2018/11/firecracker-lightweight-virtualization-for-serverless-computing/</a></li><li><a target="_blank" href="https://googleprojectzero.blogspot.com/2021/06/an-epyc-escape-case-study-of-kvm.html">https://googleprojectzero.blogspot.com/2021/06/an-epyc-escape-case-study-of-kvm.html</a></li><li><a target="_blank" href="https://assets.amazon.science/96/c6/302e527240a3b1f86c86c3e8fc3d/firecracker-lightweight-virtualization-for-serverless-applications.pdf">https://assets.amazon.science/96/c6/302e527240a3b1f86c86c3e8fc3d/firecracker-lightweight-virtualization-for-serverless-applications.pdf</a></li><li><a target="_blank" href="https://www.talhoffman.com/2021/07/18/firecracker-internals/">https://www.talhoffman.com/2021/07/18/firecracker-internals/</a></li><li><a target="_blank" href="https://wiki.qemu.org/Features/VirtioVsock#:~:text=virtio-vsock%20is%20a%20host,-agent%20or%20SPICE%20vdagent">https://wiki.qemu.org/Features/VirtioVsock#:~:text=virtio-vsock%20is%20a%20host,-agent%20or%20SPICE%20vdagent</a></li><li><a target="_blank" href="https://stefano-garzarella.github.io/posts/2019-11-08-kvmforum-2019-vsock/">https://stefano-garzarella.github.io/posts/2019-11-08-kvmforum-2019-vsock/</a></li><li><a target="_blank" href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/vsock.md">https://github.com/firecracker-microvm/firecracker/blob/main/docs/vsock.md</a></li><li><a target="_blank" href="https://developer.ibm.com/articles/l-virtio/">https://developer.ibm.com/articles/l-virtio/</a></li><li><a target="_blank" href="https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html">https://model-checking.github.io/kani-verifier-blog/2022/07/13/using-the-kani-rust-verifier-on-a-firecracker-example.html</a></li><li><a target="_blank" href="https://doc.rust-lang.org/reference/unsafety.html">https://doc.rust-lang.org/reference/unsafety.html</a></li><li><a href="https://doc.rust-lang.org/reference/types/pointer.html" target="_blank">https://doc.rust-lang.org/reference/types/pointer.html</a><br/></li></ol><p>‍</p><p>‍</p></div></div>
  </body>
</html>
