<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://curves.ulfheim.net/">Original</a>
    <h1>The Animated Elliptic Curve</h1>
    
    <div id="readability-page-1" class="page"><div>

<p><span>Visualizing Elliptic Curve Cryptography</span></p><p>
    Every TLS 1.3 session starts with a key exchange
    made via an elliptic curve. The most popular curve is
    Curve25519, and the exchange involves adding a &#34;base point&#34;
    <span>P</span>
    to itself over and over again:
</p>
<figure>
    
    <figcaption>Curve25519 point addition</figcaption>
</figure>
<p>
    We&#39;re looking at the heart of TLS 1.3 key exchange,
    but what&#39;s going on? Let&#39;s break it down into simple parts.
</p>

<h2>Adding points on a curve</h2>
<p>
    The elliptic curves we&#39;re going to use are in this form:
    `y^2 = x^3 + Ax + B`
    <br/>

</p><figure>
    
    <figcaption>Examples of elliptic curves</figcaption>
</figure>

<p>
    Let&#39;s define <strong>point addition</strong>: a way to combine two points on an elliptic
    curve to yield a third point (also on the curve).

</p><div>
<p><strong>Point addition:</strong></p><ul>
    <li>draw a line between the two points
        (or if you&#39;re adding a point to itself, make a line tangent to the curve at that
        point),</li>
    <li>find where that line intersects the curve,</li>
    <li>and finally negate the y-value of that point.</li>
</ul>
</div> <!-- skinny-block -->

<figure>
    
    <figcaption>Repeated addition of a point P</figcaption>
</figure>

<p>
    Point addition has two useful properties which we&#39;ll need later:
</p><ul>
    <li><strong>commutative</strong>: adding points in any order results in the same point:
        <p>
        P+Q+R = R+Q+P = P+R+Q
        </p>
    </li><li><strong>associative</strong>: addition of additions has the same result as adding the points individually:
    
</li>
</ul>
<p>See the animation below which adds points in random order.
    The result is always the expected point.</p>

<figure>
    
    <figcaption>Point addition is associative and commutative</figcaption>
</figure>

<h2>Finite field math</h2>
<p>Next let&#39;s put curves aside and introduce a new set of math operations,
    the operations of the finite field <span>Fp</span>.

</p><p>A finite field is just a set of numbers. In this section we&#39;ll set
    `p` to 23 (a prime number). The finite field <span>F23</span> is the list
    of numbers 0 through 22:
</p><p>
`\mathbb{F}_23 = {0, 1, 2, …, 22}`
</p>

<p>
    All the math operations below use only those 23 numbers as inputs as outputs. <strong>No negative numbers,
    no floating point, and nothing higher than 22</strong>.

</p><h5>Addition / Subtraction</h5>
<p>
    Adding and subtracting in finite fields is pretty simple. Values of 23 and greater will wrap around to
    zero, and values below zero will wrap around to 22:
    <canvas id="canvas-field-add-sub" width="500" height="80"></canvas>

</p><p>You might also know this as &#34;modulo 23&#34;, or as the remainder after dividing a number by 23.

</p><h5>Multiplication</h5>
<p>
    Multiplication is also straightforward. Similar to addition, the result is taken modulo 23:

    <canvas id="canvas-field-mult" width="500" height="80"></canvas>

</p><h5>Negation</h5>
<p>
    You might be used to negation as flipping a value&#39;s sign from positive to negative
    (or vice versa). Another definition would be finding the value
    `\text{-}n` for `n` that satisfies this equation:
</p><p>
`n + \text{-}n = 0`
</p>

<p>
    In <span>Fp</span>, we can solve the above and negate a number by subtracting
    it from `p`:

    <canvas id="canvas-field-negate" width="500" height="80"></canvas>

</p><h5>Division (multiplicative inverse)</h5>
<p>
    Let&#39;s define division in <span>Fp</span> around the concept
    that any non-zero number divided by itself is 1:
</p><p>
`\frac{n}{n} = 1`
</p>
<p>Or if we expand some terms:
</p><p>
`n \cdot \frac{1}{n} = 1`
</p>
<p>Let&#39;s use a different notation for `1//n` which is easier to fit on a line:
</p><p>
`n \cdot n^(\text{-}1) = 1`
</p>

<p>
    In our <span>Fp</span> multiplication it&#39;s possible for two
    positive integers to equal 1 when multiplied together.
    It turns out that for each positive integer in <span>Fp</span> there is one
    positive integer that acts as this &#34;multiplicative inverse&#34; solution to the equation above:
    <canvas id="canvas-field-div" width="500" height="80"></canvas>

</p><p>
    To tie it all together, when working in <span>Fp</span>
    any time we need to divide by a number `n` we will instead
    multiply by its multiplicative inverse `n^(\text{-}1)`,
    the number which satisfies the equation `n \cdot n^(\text{-}1) = 1`.

</p><p>
    The inverse for each number in
    <span>F23</span> is provided <a target="_blank" href="https://curves.ulfheim.net/inverse23.html">in this table</a>.

</p><h5>Square root</h5>
<p>
    Our last operation to define is taking a square root.
    We&#39;ll define the square root of `n`
    as a number in <span>Fp</span>
    which satisfies this equation:

</p><p>
`sqrt(n) \times sqrt(n) = n`
</p>

<canvas id="canvas-field-sqrt" width="500" height="80"></canvas>

<p>
    Only half of the non-zero members of <span>Fp</span> have a solution to the square root
    equation. They also have two solutions: much like how real numbers have a positive and negative solution
    for square root, our finite field members have two solutions (each the negation of the other).

</p><p>The solutions for <span>F23</span> are
    provided <a target="_blank" href="https://curves.ulfheim.net/sqrt23.html">in this table</a>.

</p><h2>Elliptic curves <em>and</em> finite fields</h2>
<p>
    Now we can combine the two concepts of elliptic curves and finite field math.
    Let&#39;s start with an elliptic curve equation:
</p><p>
`y^2 = x^3 + 9x + 1`
</p>

<p>For our finite field let&#39;s use the prime number 61:

</p><p>
`\mathbb{F}_61 = {0, 1, 2, …, 60}`
</p>


<p>
    The tables for <a href="https://curves.ulfheim.net/inverse61.html" target="_blank">division</a>
    and <a href="https://curves.ulfheim.net/sqrt61.html" target="_blank">square roots</a>
    in <span>F61</span> are pre-computed for convenience.

</p><p>
    Finally, we&#39;ll nominate one of the points on this curve to be the &#34;base point&#34;:
</p><p>
`P = (5,7)`
</p>

<p>
    Let&#39;s call the combination of the definitions above &#34;Curve61&#34;.
    What would it look like to plot this curve on a graph? Starting with `x=0`
    and working through each number from 0 to 60, using the math operations we defined above:

</p><table>
    <tbody><tr>
        <td>`x = 0`:</td>
        <td>`y^2 = 0^3 + 9\cdot0 + 1 = 1 % 61 = 1 =&gt;`
        </td><td>`y = sqrt(1) =` 1 and 60</td>
    </tr>
    <tr>
        <td>`x = 1`:</td>
        <td>`y^2 = 1^3 + 9\cdot1 + 1 = 11 % 61 = 11 =&gt;`
        </td><td>`y = sqrt(11) =` undefined</td>
    </tr>
    <tr>
        <td>`x = 2`:</td>
        <td>`y^2 = 2^3 + 9\cdot2 + 1 = 27 % 61 = 27 =&gt;`
        </td><td>`y = sqrt(27) =` 24 and 37</td>
    </tr>
    <tr>
        <td>`x = 3`:</td>
        <td>`y^2 = 3^3 + 9\cdot3 + 1 = 55 % 61 = 55 =&gt;`
        </td><td>`y = sqrt(27) = ` undefined</td>
    </tr>
    <tr>
        <td>`x = 4`:</td>
        <td>`y^2 = 4^3 + 9\cdot4 + 1 = 101 % 61 = 40 =&gt;`
        </td><td>`y = sqrt(40) = ` undefined</td>
    </tr>
    <tr>
        <td>`x = 5`:</td>
        <td>`y^2 = 5^3 + 9\cdot5 + 1 = 171 % 61 = 49 =&gt;`
        </td><td>`y = sqrt(49) = ` 7 and 54</td>
    </tr>
    <tr>
        <td colspan="3">... and so on</td>
</tr></tbody></table>

<p>
    The resulting graph looks like this:
</p><figure>
    
    <figcaption>Curve61: An elliptic curve plotted in <span>Fp</span></figcaption>
</figure>

<h5>Point Addition</h5>
<p>
    We can still add points on this curve, using the math of <span>F61</span> and
    the rules of point addition: draw lines between two points, find the curve intersection,
    then negate the point&#39;s y-value.

</p><figure>
    
    <figcaption>Curve61 point addition</figcaption>
</figure>

<p>This animation shows finite field math wrapping from 61 to 0, sometimes many times, before intersection
    with a curve point. Finding the values algebraically is relatively easy, just remember to
    use the rules of finite field math for these formulas:

</p><div>
<p>
    To add two points `P: (x_1, y_1)` and `Q: (x_2, y_2)` to get a third point `R: (x_3, y_3)`:
</p><div><p>
`\lambda = \frac{y_2 - y_1}{x_2 - x_1}`
</p></div>

<p>
    If `P` and `Q` are the same point, then adding them is called &#34;doubling&#34; the point.
    The formula for this is the same, but the slope (lambda) is the curve tangent:

</p><p>
`\lambda = \frac{3x_1^2 + 9}{2y_1}`
</p>
</div> <!-- skinny-block -->

<h5>Efficient Point Multiplication</h5>
<p>
    The point at 100P is the point `P` added to itself 100 times. It can <em>also</em> be thought of as the point being
    multiplied by the number 100. You&#39;ll see this referred to as &#34;scalar multiplication&#34;, and it&#39;s just
    another way to refer to repeated point addition.

</p><p>
    We can get to arbitrarily large multiplication of `P` quickly using a &#34;double-and-add&#34; method:
</p><ul>
    <li>Repeatedly double `P` to get `\{2P, 4P, 8P, 16P, 32P, …\}`</li>
    <li>Add combinations of the above points to get any needed multiple of `P`</li>
</ul>

<figure>
    <div>
    <div>
    <canvas id="canvas-double-and-add" width="500" height="400"></canvas>
    
    </div>
    </div>
    <figcaption>Double-and-add method for point <span id="dbl-add-np">nP</span></figcaption>
</figure>


<h2>Key exchange</h2>
<p>
    Now we have enough to start doing cryptographic work. We&#39;re going to do a key exchange with
    Curve61, much in the same way that TLS 1.3 does a key exchange with Curve25519.

</p><p>
    Alice and Bob want to start a private conversation. To do this, they&#39;re going to agree on a number without
    any eavesdroppers being able to tell what the number is. With an agreed-upon number they can
    derive a key for one of the many fast and secure ciphers (such as AES) and encrypt their conversation.

</p><p>
    The process looks like this:
</p><ul>
    <li>Alice and Bob agree to use Curve61, described in the section above
    </li><li>Alice picks a random number `k_a`
    </li><li>Alice computes the coordinates of `k_(a)P` and sends it to Bob as `A`
    </li><li>Bob picks a random number `k_b`
    </li><li>Bob computes the coordinates of `k_(b)P` and sends it to Alice as `B`
    </li><li>Alice computes the coordinates of `k_(a)B`, which is `k_(a)(k_(b)P)`
    </li><li>Bob computes the coordinates of `k_(b)A`, which is `k_(b)(k_(a)P)`
</li></ul>

<p>Because point addition on Curve61 is associative, both `k_b(k_aP)` and `k_a(k_bP)` are the same
    point: they&#39;re just the base point added to itself `k_a \times k_b` times.  Since they&#39;re the
    same point, both Alice and Bob have agreed on the same number: the coordinates of `k_ak_bP`.

</p><p>
    Enter numbers for Bob and Alice&#39;s private keys below and watch a key exchange occur:

</p>

<figure>
    <div>
    <p>Alice:</p>
    <canvas id="canvas-alice" width="500" height="300" data-visible="always">
    </canvas>
    <p>Bob:</p>
    <canvas id="canvas-bob" width="500" height="300" data-visible="always">
    </canvas>
    </div>
</figure>

<h2>The real curve</h2>

<p>
    We&#39;ve played around with a toy curve of 72 points, and you&#39;ve seen what it means to add points or
    perform a key exchange. But how does this compare to real curves used in real cryptography?

</p><p>
    The most common curve used for key exchange is Curve25519. That curve has a simple equation:
</p><p>
`y^2 = x^3 + 486662x^2 + x`
</p>

<p>
    Where our toy curve used <span>F61</span>, a field with 61 numbers in it,
    Curve25519 uses `\mathbb{F}_(2^255\text{-}19)`. The prime number used for that field,
    `2^255-19`, is a very large (77-digit) number. Other than the size, the field looks the same as the one
    we&#39;ve been using:
</p><p>
`\mathbb{F}_(2^255\text{-}19) = {0, 1, 2, …, 2^255-20}`
</p>

<p>
    Where our toy curve used a base point that can only be added to itself 73 times before repeating,
    `\mathbb{F}_(2^255\text{-}19)` uses a base point that can be added to itself over
    `2^252` times before repeating.

</p><p>
    When peers use Curve25519 to perform key exchange, they select a random 256-bit number (though 5 of those
    bits are then overridden; see <a href="https://x25519.ulfheim.net">my X25519 site</a> for more details). That&#39;s
    `2^251` possible point multiplications for an attacker to guess at, which is a very large (76-digit) number.

</p><p>
    We can add and double points on Curve25519 in much the same way that we did on Curve61, though
    the formula changes due to the different curve equation
    (see <a href="https://en.wikipedia.org/wiki/Montgomery_curve#Addition">Wikipedia</a> for details).
    Using point addition we can perform a key exchange in the same way that we did with our toy curve.

</p><p>
    For in-depth information on Curve25519, including the choice of curve equation,
    the choice of prime number used for <span>Fp</span>,
    and the exact details of key exchange I can recommend
    <a href="https://cr.yp.to/ecdh/curve25519-20060209.pdf">the author&#39;s paper</a> and also
    <a href="https://martin.kleppmann.com/papers/curve25519.pdf">this technical analysis</a>.
    Most of these details are streamlining of the concepts listed on this page to keep the exchange
    mechanism secure and performant, and should not fundamentally conflict with what&#39;s explained here.

</p><p>
    <span>❦</span>
    </p> <!-- epilogue -->

</div></div>
  </body>
</html>
