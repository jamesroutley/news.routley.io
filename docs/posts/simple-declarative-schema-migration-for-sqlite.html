<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://david.rothlis.net/declarative-schema-migration-for-sqlite/">Original</a>
    <h1>Simple declarative schema migration for SQLite</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
      
      

<p>At <a href="https://stb-tester.com">my company</a> we use a small SQLite database. We define the schema in a single file with SQL <em>CREATE TABLE</em> statements. If we add tables, columns, or indexes, our application will create them automatically the next time it starts up.</p>
<p>This is superior to explicit database migration scripts:</p>
<ul>
<li>We (usually) don’t need to write the database migration SQL manually.</li>
<li>This brings some of the benefits of schemaless databases to SQL, particularly around speed of development / ease of experimentation.</li>
<li>The auto-migration code gives us some guarantees that the resulting database schema will match our SQL file.</li>
<li>We can downgrade too, by dropping tables or columns (if we don’t mind losing data). This is important for CI where switching between branches can cause the schema to change regularly.</li>
</ul>
<p>We’ve been using this since 2019 and it works well, though I must admit our database is small (a dozen tables, ~40MB) and it doesn’t change <em>that</em> often (65 changes to our schema in those 3 years, according to <em>git log</em>).</p>
<section id="how-it-works">
<h2>How it works</h2>
<p>We define our database schema in a single file —let’s call it <em>schema.sql</em>— with normal <em>CREATE TABLE</em> and <em>CREATE INDEX</em> statements.</p>
<p>When our application starts up, our migrator creates a new in-memory database and executes the schema to create a “pristine” or “desired” version of the database:</p>

<p>We query sqlite’s internal <a href="https://www.sqlite.org/schematab.html">sqlite_schema</a> table to get the tables from both the “pristine” and “actual” databases:</p>

<p>Then we can work out new or removed tables:</p>

<p>The above query gives us the <em>CREATE TABLE</em> sql, which we can execute to create the new tables:</p>
<pre><code>sqlite&gt; select name, sql from sqlite_schema where type = &#34;table&#34;;
name|sql
Node|CREATE TABLE &#34;Node&#34;(...)
...</code></pre>
<p>Similarly for indexes:</p>
<pre><code>sqlite&gt; select name, sql from sqlite_schema where type = &#34;index&#34;;
name|sql
Node_node_id|CREATE UNIQUE INDEX Node_node_id on Node(node_id)
...</code></pre>
<p>To detect changes to existing tables we use <a href="https://sqlite.org/pragma.html#pragma_table_info">PRAGMA table_info</a>, which returns a list of the table’s columns:</p>
<pre><code>sqlite&gt; pragma table_info(Node);
cid|name|type|notnull|dflt_value|pk
0|node_oid|INTEGER|1||1
1|node_id|TEXT|1||0
...</code></pre>
<p>If there are new or changed columns, we follow the <a href="https://www.sqlite.org/lang_altertable.html#otheralter">12 step procedure</a> in the SQLite documentation. In short we create a new table, copy the data from the old table into the new table, drop the old table, and rename the new table. This particular sequence is important to avoid breaking foreign keys.</p>
<p>We use a similar technique (querying <em>sqlite_schema</em> and <em>table_info</em>) to generate an Entity Relationship Diagram using <a href="https://graphviz.org/">Graphviz</a>, for our documentation.</p>
</section>
<section id="orm-agnostic">
<h2>ORM agnostic</h2>
<p>With this technique you can define your database schema however you like. We use <em>CREATE TABLE</em> statements in a single sql file, but maybe you use an ORM that can create the database tables based on your ORM-ey code. You just need to create a new temporary database from scratch; our technique then compares the current database versus the new temporary database.</p>
</section>
<section id="limitations">
<h2>Limitations</h2>
<p>The schema changes that we can make are limited to the following operations:</p>
<ol type="1">
<li>Adding a new table.</li>
<li>Adding, deleting or modifying an index.</li>
<li>Adding a column to an existing table as long as the new column can be NULL or has a DEFAULT value specified.</li>
<li>Changing a column to remove NULL or DEFAULT as long as all values in the database are not NULL.</li>
<li>Changing the type of a column (note that SQLite’s typing is, uh, <a href="https://sqlite.org/flextypegood.html">flexible</a>).</li>
</ol>
<p>And if you don’t mind losing data:</p>
<ol start="6" type="1">
<li>Dropping a table.</li>
<li>Dropping a column.</li>
</ol>
<p>(For those you need to opt in by specifying <em>allow_deletions=True</em>.)</p>
<p>Our migrator doesn’t support triggers &amp; views — not for any fundamental reason, it’s just that we don’t use SQLite triggers &amp; views in our application.</p>
<p>Our migrator may change the values of <a href="https://www.sqlite.org/rowidtable.html">rowid</a> columns (which are generated internally by SQLite) because we call <a href="https://www.sqlite.org/lang_vacuum.html">VACUUM</a> to re-pack the database file.</p>
<p>Our migrator doesn’t do <em>data</em> migrations (where you’re changing the format of existing data or populating new columns based on other columns). You still need to write those manually.</p>
</section>
<section id="manual-migrations">
<h2>Manual migrations</h2>
<p>In our initial design, our migrator would check the <em><a href="https://www.sqlite.org/pragma.html#pragma_user_version">user_version</a></em> pragma and refuse to auto-migrate if <em>user_version</em> had changed. In theory we would bump <em>user_version</em> in our <em>schema.sql</em> file when the changes were too complex for the migrator. In practice, we never used this; instead we write explicit SQL to bring the database into a state that the auto-migrator will be happy with.</p>
<p>For example, if we have removed a table from the schema and we don’t care about the data in it, we write <em>DROP TABLE IF EXISTS</em> before running the migrator. This is idempotent so it won’t hurt if it is run again. In due course this migration can be removed from the code, after the change has been rolled out to all the relevant servers.</p>
<p>Data migrations can be run after the auto-migrator, once the new tables &amp; columns are in place.</p>
<p>For example:</p>

<p>This example runs the manual &amp; automatic migrations in the same transaction (in case that’s important to you). <code>DBMigrator</code> is a Python context manager so that we can run the last step of the <a href="https://www.sqlite.org/lang_altertable.html#otheralter">12 step procedure</a> (re-enabling foreign key constraints) after all your manual migrations, because that step can only be run after committing the transaction.</p>
</section>
<section id="continuous-integration">
<h2>Continuous Integration</h2>
<p>Our unit tests (for our product, not for this migration system specifically) create an in-memory database from scratch each time, using something like this:</p>

<p>Since there’s nothing to migrate <em>from</em>, these unit tests aren’t testing the schema migration.</p>
<p>We also have some integration tests (our product is a distributed IoT-style system so the integration tests include a real “portal” or central server and real “nodes” running on our product’s actual hardware). These integration tests re-use a database that persists across CI runs. Our CI might run tests from different branches with divergent schemas, so before CI we run the migrator with <em>allow_deletions=True</em> to downgrade to the schema on our “main” branch. Then the actual migration will be exercised when our application starts up.</p>
</section>
<section id="implementation">
<h2>Implementation</h2>
<p>Here’s the code — I extracted it from our proprietary codebase but I haven’t tested it in isolation:</p>
<ul>
<li><a href="https://david.rothlis.net/declarative-schema-migration-for-sqlite/migrator.py">migrator.py</a></li>
<li><a href="https://david.rothlis.net/declarative-schema-migration-for-sqlite/test_migrator.py">Unit tests</a></li>
</ul>
<p>The above code is Copyright © 2019-2022 Stb-tester.com Ltd. We release it under the MIT license.</p>
<p>See the code in “Manual migrations”, above, for a usage example.</p>
</section>
<section id="credits">
<h2>Credits</h2>
<p>Design &amp; code by my colleague <a href="https://blog.williammanley.net">William Manley</a>, partly inspired by <a href="https://news.ycombinator.com/item?id=19881330">liyanchang’s comment on Hacker News</a>.</p>
</section>


    </div></div>
  </body>
</html>
