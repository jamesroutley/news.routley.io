<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cppstories.com/2018/12/fromchars/">Original</a>
    <h1>C&#43;&#43; String Conversion: Exploring std:from_chars in C&#43;&#43;17 to C&#43;&#43;26</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p><img src="https://www.cppstories.com/2018/images/2018-12-03-string-conversion-routines-from-chars.png" alt=""/></p>                
        <p>With the introduction of C++17, the C++ Standard Library expanded its capabilities for converting text to numbers with the addition of <code>std::from_chars</code>. This low-level, high-performance API offers significant advantages over previous methods, such as <code>atoi</code> and <code>stringstream</code>. In this article, we will explore the evolution of string conversion routines from C++17 through C++26, highlighting key improvements like <code>constexpr</code> support and enhanced error handling. Let’s dive into the details and see how <code>std::from_chars</code> can transform your approach to string conversion.</p>
<p><strong>Updated in Oct 2024:</strong> Added notes from <code>constexpr</code> support in C++23, and C++26 improvements, plus more Compiler Explorer examples.</p>
<h2 id="before-c17">
Before C++17 
  
<a href="#before-c17" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>C++, before C++17, offered several options when it comes to string conversion:</p>
<ul>
<li><code>sprintf</code> / <code>snprintf</code></li>
<li><code>sscanf</code></li>
<li><code>atol</code></li>
<li><code>strtol</code></li>
<li><code>strstream</code></li>
<li><code>stringstream</code></li>
<li><code>to_string</code></li>
<li><code>stoi</code> and similar functions</li>
</ul>
<p>And with C++17 you get another option: <code>std::from_chars</code>! Wasn’t the old stuff good enough? Why do we need new methods?</p>
<p>In short: because <code>from_chars</code> is low-level, and offers the best possible performance.</p>
<p>The new conversion routines are:</p>
<ul>
<li>non-throwing</li>
<li>non-allocating</li>
<li>no locale support</li>
<li>memory safety</li>
<li>error reporting gives additional information about the conversion outcome</li>
</ul>
<p>The API might not be the most friendly to use, but it’s easy enough to wrap it into some facade.</p>
<p>A simple example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>const</span> <span>std</span><span>::</span><span>string</span> <span>str</span> <span>{</span> <span>&#34;12345678901234&#34;</span> <span>};</span>
</span></span><span><span><span>int</span> <span>value</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span><span>std</span><span>::</span><span>from_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span><span>str</span><span>.</span><span>data</span><span>()</span> <span>+</span> <span>str</span><span>.</span><span>size</span><span>(),</span> <span>value</span><span>);</span>
</span></span><span><span><span>// error checking ommited...
</span></span></span></code></pre></div><h2 id="the-series">
The Series 
  
<a href="#the-series" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>This article is part of my series about C++17 Library Utilities. Here’s the list of the topics in the series:</p>
<ul>
<li><a href="https://www.cppstories.com/2018/04/refactoring-with-c17-stdoptional.html">Refactoring with <code>std::optional</code></a></li>
<li><a href="https://www.cppstories.com/2018/05/using-optional.html">Using <code>std::optional</code></a></li>
<li><a href="https://www.cppstories.com/2018/05/errors-and-optional.html">Error handling and <code>std::optional</code></a></li>
<li><a href="https://www.cppstories.com/2018/06/variant.html">Everything You Need to Know About <code>std::variant</code> from C++17</a></li>
<li><a href="https://www.cppstories.com/2018/06/any.html">Everything You Need to Know About <code>std::any</code> from C++17</a></li>
<li><a href="https://www.cppstories.com/2018/07/string-view-perf.html"><code>std::string_view</code> Performance</a> and <a href="https://www.cppstories.com/2018/07/string-view-perf-followup.html">followup</a></li>
<li><a href="https://www.cppstories.com/2018/08/searchers.html">C++17 string searchers</a> and <a href="https://www.cppstories.com/2018/08/searcher-preprocessing.html">followup</a></li>
<li>Conversion utilities: <a href="https://www.cppstories.com/2018/12/fromchars/">on <code>std::from_chars</code> - from a string to a number</a> and <a href="https://www.cppstories.com/2019/11/tochars/">on <code>std::to_chars</code> - from numbers into strings</a></li>
<li><a href="https://www.cppstories.com/2019/01/filesize.html">How to get File Size in C++?</a> and <a href="https://www.cppstories.com/2019/01/filesizeadvantages.html">std:filesystem::file_size Advantages and Differences</a></li>
<li><a href="https://www.cppstories.com/2019/04/dir-iterate.html">How To Iterate Through Directories</a></li>
</ul>
<p><a href="https://leanpub.com/cpp17indetail?utm_source=blog&amp;utm_campaign=stdcpp17series"><img src="https://www.cppstories.com/2018/images/cpp17indetail.png" alt=""/></a></p>
<p>Resources about C++17 STL:</p>
<ul>
<li><a href="https://leanpub.com/cpp17indetail?utm_source=blog&amp;utm_campaign=stdcpp17series"><strong>C++17 In Detail</strong></a> by Bartek!</li>
<li><a href="https://leanpub.com/cpp17">C++17 - The Complete Guide</a> by Nicolai Josuttis</li>
<li><a href="https://pluralsight.pxf.io/c/1192940/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fcplusplus-fundamentals-c17">C++ Fundamentals Including C++ 17</a> by Kate Gregory</li>
<li><a href="https://pluralsight.pxf.io/c/1192940/424552/7490?u=https%3A%2F%2Fwww.pluralsight.com%2Fcourses%2Fcplusplus-14-practical-features">Practical C++14 and C++17 Features</a> - by Giovanni Dicanio</li>
<li><a href="http://amzn.to/2v6KkmV">C++17 STL Cookbook</a> by Jacek Galowicz</li>
</ul>
<p>Let’s have a look at the API now.</p>
<h2 id="converting-from-characters-to-numbers-from_chars">
Converting From Characters to Numbers: <code>from_chars</code> 
  
<a href="#converting-from-characters-to-numbers-from_chars" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p><code>std::from_chars</code>, available in the <code>&lt;charconv&gt;</code> headers, is a set of overloaded functions: for integral types and floating point types.</p>
<p>For integral types we have the following functions:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>std</span><span>::</span><span>from_chars_result</span> <span>from_chars</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>first</span><span>,</span> 
</span></span><span><span>                                  <span>const</span> <span>char</span><span>*</span> <span>last</span><span>,</span> 
</span></span><span><span>                                  <span>TYPE</span> <span>&amp;</span><span>value</span><span>,</span>
</span></span><span><span>                                  <span>int</span> <span>base</span> <span>=</span> <span>10</span><span>);</span>
</span></span></code></pre></div><p>Where <code>TYPE</code> expands to all available signed and unsigned integer types and <code>char</code>.</p>
<p><code>base</code> can be a number ranging from 2 to 36.</p>
<p>Then there’s the floating point version:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>std</span><span>::</span><span>from_chars_result</span> <span>from_chars</span><span>(</span><span>const</span> <span>char</span><span>*</span> <span>first</span><span>,</span> 
</span></span><span><span>                   <span>const</span> <span>char</span><span>*</span> <span>last</span><span>,</span> 
</span></span><span><span>                   <span>FLOAT_TYPE</span><span>&amp;</span> <span>value</span><span>,</span>
</span></span><span><span>                   <span>std</span><span>::</span><span>chars_format</span> <span>fmt</span> <span>=</span> <span>std</span><span>::</span><span>chars_format</span><span>::</span><span>general</span><span>);</span>
</span></span></code></pre></div><p><code>FLOAT_TYPE</code> expands to <code>float</code>, <code>double</code> or <code>long double</code>.</p>
<p><code>chars_format</code> is an enum with the following values: <code>scientific</code>,</p>
<p><code>fixed</code>, <code>hex</code> and <code>general</code> (which is a composition of <code>fixed</code> and <code>scientific</code>).</p>
<p>The return value in all of those functions (for integers and floats) is <code>from_chars_result</code>:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>struct</span> <span>from_chars_result</span> <span>{</span>
</span></span><span><span>    <span>const</span> <span>char</span><span>*</span> <span>ptr</span><span>;</span>
</span></span><span><span>    <span>std</span><span>::</span><span>errc</span> <span>ec</span><span>;</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p><code>from_chars_result</code> holds valuable information about the conversion process.</p>
<p>Here’s the summary:</p>


<table>
<thead>
<tr>
<th>Return Condition</th>
<th>State of <code>from_chars_result</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Success</td>
<td><code>ptr</code> points at the first character not matching the pattern, or has the value equal to <code>last</code> if all characters match and <code>ec</code> is value-initialized.</td>
</tr>
<tr>
<td>Invalid conversion</td>
<td><code>ptr</code> equals <code>first</code> and <code>ec</code> equals <code>std::errc::invalid_argument</code>. <code>value</code> is unmodified.</td>
</tr>
<tr>
<td>Out of range</td>
<td>The number it too large to fit into the value type. <code>ec</code> equals <code>std::errc::result_out_of_range</code> and <code>ptr</code> points at the first character not matching the pattern. <code>value</code> is unmodified.</td>
</tr>
</tbody>
</table>

<p>The new routines are very low level, so you might be wondering why is that. Titus Winters added <a href="http://disq.us/p/1xy9sse">a great summary in comments</a>:</p>
<blockquote>
<p>The intent of those APIs is *not* for people to use them directly,
but to build more interesting/useful things on top of them. These are
primitives, and we (the committee) believe they have to be in the
standard because there isn’t an efficient way to do these operations
without calling back out to nul-terminated C routines</p>
</blockquote>
<h2 id="examples">
Examples 
  
<a href="#examples" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>Here are two examples of how to convert a string into a number using <code>from_chars</code>, to <code>int</code> and<code>float</code>.</p>
<h3 id="integral-types">
Integral types 
  
<a href="#integral-types" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h3>

<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;charconv&gt; // from_char, to_char</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;string&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>const</span> <span>std</span><span>::</span><span>string</span> <span>str</span> <span>{</span> <span>&#34;12345678901234&#34;</span> <span>};</span>
</span></span><span><span>    <span>int</span> <span>value</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>auto</span> <span>res</span> <span>=</span> <span>std</span><span>::</span><span>from_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span> 
</span></span><span><span>                                     <span>str</span><span>.</span><span>data</span><span>()</span> <span>+</span> <span>str</span><span>.</span><span>size</span><span>(),</span> 
</span></span><span><span>                                     <span>value</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>())</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;value: &#34;</span> <span>&lt;&lt;</span> <span>value</span> 
</span></span><span><span>                  <span>&lt;&lt;</span> <span>&#34;, distance: &#34;</span> <span>&lt;&lt;</span> <span>res</span><span>.</span><span>ptr</span> <span>-</span> <span>str</span><span>.</span><span>data</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>::</span><span>invalid_argument</span><span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;invalid argument!</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>::</span><span>result_out_of_range</span><span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;out of range! res.ptr distance: &#34;</span> 
</span></span><span><span>                  <span>&lt;&lt;</span> <span>res</span><span>.</span><span>ptr</span> <span>-</span> <span>str</span><span>.</span><span>data</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The example is straightforward, it passes a string <code>str</code> into <code>from_chars</code> and then displays the result with additional information if possible.</p>
<p>your task is to run the code <a href="https://godbolt.org/z/5bxe8jx3E">@Compiler Explorer</a>.</p>
<p>Does “12345678901234” fit into the number? Or you see some errors from the conversion API?</p>
<h3 id="floating-point">
Floating Point 
  
<a href="#floating-point" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h3>

<p>Here’s the floating pointer version:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;charconv&gt; // from_char, to_char</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;string&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>const</span> <span>std</span><span>::</span><span>string</span> <span>str</span> <span>{</span> <span>&#34;16.78&#34;</span> <span>};</span>
</span></span><span><span>    <span>double</span> <span>value</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>auto</span> <span>format</span> <span>=</span> <span>std</span><span>::</span><span>chars_format</span><span>::</span><span>general</span><span>;</span>
</span></span><span><span>    <span>const</span> <span>auto</span> <span>res</span> <span>=</span> <span>std</span><span>::</span><span>from_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span> 
</span></span><span><span>                                 <span>str</span><span>.</span><span>data</span><span>()</span> <span>+</span> <span>str</span><span>.</span><span>size</span><span>(),</span> 
</span></span><span><span>                                 <span>value</span><span>,</span> 
</span></span><span><span>                                 <span>format</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>())</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;value: &#34;</span> <span>&lt;&lt;</span> <span>value</span> 
</span></span><span><span>                  <span>&lt;&lt;</span> <span>&#34;, distance: &#34;</span> <span>&lt;&lt;</span> <span>res</span><span>.</span><span>ptr</span> <span>-</span> <span>str</span><span>.</span><span>data</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>::</span><span>invalid_argument</span><span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;invalid argument!</span><span>\n</span><span>&#34;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>else</span> <span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>::</span><span>result_out_of_range</span><span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;out of range! res.ptr distance: &#34;</span> 
</span></span><span><span>                  <span>&lt;&lt;</span> <span>res</span><span>.</span><span>ptr</span> <span>-</span> <span>str</span><span>.</span><span>data</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Run at <a href="https://godbolt.org/z/66nbshE74">Compiler Explorer</a></p>
<p>Here’s the example output that we can get:</p>


<table>
<thead>
<tr>
<th><code>str</code> value</th>
<th><code>format</code> value</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1.01</code></td>
<td><code>fixed</code></td>
<td><code>value: 1.01, distance 4</code></td>
</tr>
<tr>
<td><code>-67.90000</code></td>
<td><code>fixed</code></td>
<td><code>value: -67.9, distance: 9</code></td>
</tr>
<tr>
<td><code>20.9</code></td>
<td><code>scientific</code></td>
<td><code>invalid argument!, res.ptr distance: 0</code></td>
</tr>
<tr>
<td><code>20.9e+0</code></td>
<td><code>scientific</code></td>
<td><code>value: 20.9, distance: 7</code></td>
</tr>
<tr>
<td><code>-20.9e+1</code></td>
<td><code>scientific</code></td>
<td><code>value: -209, distance: 8</code></td>
</tr>
<tr>
<td><code>F.F</code></td>
<td><code>hex</code></td>
<td><code>value: 15.9375, distance: 3</code></td>
</tr>
<tr>
<td><code>-10.1</code></td>
<td><code>hex</code></td>
<td><code>value: -16.0625, distance: 5</code></td>
</tr>
</tbody>
</table>

<p>The <code>general</code> format is a combination of <code>fixed</code> and <code>scientific</code> so it handles regular floating point string with the additional support for <code>e+num</code> syntax.</p>
<h2 id="performance">
Performance 
  
<a href="#performance" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>I did some benchmarks, and the new routines are blazing fast!</p>
<p>Some numbers:</p>
<ul>
<li>On GCC it’s around 4.5x faster than <code>stoi</code>, 2.2x faster than <code>atoi</code> and almost 50x faster than <code>istringstream</code>.</li>
<li>On Clang it’s around 3.5x faster than <code>stoi</code>, 2.7x faster than <code>atoi</code> and 60x faster than <code>istringstream</code>!</li>
<li>MSVC performs around 3x faster than <code>stoi</code>, ~2x faster than <code>atoi</code> and almost 50x faster than <code>istringstream</code></li>
</ul>
<p>You can find the results in my book on C++17: <a href="https://leanpub.com/cpp17indetail?utm_source=blog&amp;utm_campaign=stdcpp17series"><strong>C++17 In Detail</strong></a>.</p>
<h2 id="c23-updates">
C++23 Updates 
  
<a href="#c23-updates" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>In C++23 we got one improvement for our functions: <a href="https://wg21.link/P2291R3">P2291</a></p>
<blockquote>
<p><code>constexpr</code> for integral overloads of <code>std::to_chars()</code> and <code>std::from_chars()</code>.</p>
</blockquote>
<p>It’s already implemented in GCC 13, Clang 16, and MSVC 19.34.</p>
<p>Together with <code>std::optional</code> that can also work in the <code>constexpr</code> context we can create the following example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;charconv&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;optional&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;string_view&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>constexpr</span> <span>std</span><span>::</span><span>optional</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>to_int</span><span>(</span><span>std</span><span>::</span><span>string_view</span> <span>sv</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>int</span> <span>value</span> <span>{};</span>
</span></span><span><span>    <span>const</span> <span>auto</span> <span>ret</span> <span>=</span> <span>std</span><span>::</span><span>from_chars</span><span>(</span><span>sv</span><span>.</span><span>begin</span><span>(),</span> <span>sv</span><span>.</span><span>end</span><span>(),</span> <span>value</span><span>);</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>ret</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>{})</span>
</span></span><span><span>        <span>return</span> <span>value</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>{};</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>static_assert</span><span>(</span><span>to_int</span><span>(</span><span>&#34;hello&#34;</span><span>)</span> <span>==</span> <span>std</span><span>::</span><span>nullopt</span><span>);</span>
</span></span><span><span>    <span>static_assert</span><span>(</span><span>to_int</span><span>(</span><span>&#34;10&#34;</span><span>)</span> <span>==</span> <span>10</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Run <a href="https://godbolt.org/z/aTPe9T7oE">@Compiler Explorer</a></p>
<h2 id="c26-updates">
C++26 Updates 
  
<a href="#c26-updates" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>The work is not complete, and looks like in C++26 we’ll have more additions:</p>
<p>See <a href="https://wg21.link/P2497R0">P2497R0</a> wchich is already accepted into the working draft of C++26:</p>
<blockquote>
<p>Testing for success or failure of <code>&lt;charconv&gt;</code> functions</p>
</blockquote>
<p>The feature is already implemented in GCC 14 and Clang 18.</p>
<p>In short <code>from_chars_result</code> (as well as <code>to_chars_result</code>) gets a <code>bool</code> conversion operator:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>constexpr</span> <span>explicit</span> <span>operator</span> <span>bool</span><span>()</span> <span>const</span> <span>noexcept</span><span>;</span>
</span></span></code></pre></div><p>And it has to return <code>ec == std::errc{}</code>.</p>
<p>This means our code can be a bit simpler:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>if</span> <span>(</span><span>res</span><span>.</span><span>ec</span> <span>==</span> <span>std</span><span>::</span><span>errc</span><span>())</span> <span>{</span> <span>...</span> <span>}</span>
</span></span></code></pre></div><p>can become:</p>
<p>For example:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// ...
</span></span></span><span><span><span></span><span>const</span> <span>auto</span> <span>res</span> <span>=</span> <span>std</span><span>::</span><span>from_chars</span><span>(</span><span>str</span><span>.</span><span>data</span><span>(),</span> 
</span></span><span><span>                                 <span>str</span><span>.</span><span>data</span><span>()</span> <span>+</span> <span>str</span><span>.</span><span>size</span><span>(),</span> 
</span></span><span><span>                                 <span>value</span><span>,</span> 
</span></span><span><span>                                 <span>format</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>(</span><span>res</span><span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;value: &#34;</span> <span>&lt;&lt;</span> <span>value</span> 
</span></span><span><span>              <span>&lt;&lt;</span> <span>&#34;, distance: &#34;</span> <span>&lt;&lt;</span> <span>res</span><span>.</span><span>ptr</span> <span>-</span> <span>str</span><span>.</span><span>data</span><span>()</span> <span>&lt;&lt;</span> <span>&#39;\n&#39;</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// ...
</span></span></span></code></pre></div><p>Run <a href="https://godbolt.org/z/WE8T7anET">@Compiler Explorer</a></p>
<h2 id="compiler-support-for-stdfrom_chars-in-c">
Compiler Support for <code>std::from_chars</code> in C++ 
  
<a href="#compiler-support-for-stdfrom_chars-in-c" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<ul>
<li>
<p><strong>Visual Studio:</strong> Full support for <code>std::from_chars</code> was introduced in Visual Studio 2019 version 16.4, with floating-point support starting from VS 2017 version 15.7. Visual Studio 2022 includes C++23 features like <code>constexpr</code> for integral overloads.</p>
</li>
<li>
<p><strong>GCC:</strong> Starting with GCC 11.0, <code>std::from_chars</code> offers full support, including integer and floating-point conversions. The latest GCC versions, such as GCC 13, incorporate <code>constexpr</code> integral support.</p>
</li>
<li>
<p><strong>Clang:</strong> Clang 7.0 introduced initial support for integer conversions. Clang 16 and above support <code>constexpr</code> for integral overloads.</p>
</li>
</ul>
<p>For the most accurate and up-to-date information see <a href="https://en.cppreference.com/w/cpp/compiler_support/17">CppReference, Compiler Support</a>.</p>
<h2 id="summary">
Summary 
  
<a href="#summary" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h2>

<p>If you want to convert text into a number and you don’t need any extra stuff like locale support then <code>std::from_chars</code> might be the best choice. It offers great performance, and what’s more, you’ll get a lot of information about the conversion process (for example how much characters were scanned).</p>
<p>The routines might be especially handy with parsing JSON files, 3d textual model representation (like OBJ file formats), etc.</p>
<p>What’s more the new functions can be evan used at compile-time (as of C++23), and have even better error checking in C++26.</p>
<h3 id="references">
References 
  
<a href="#references" aria-hidden="true">
<svg height="24" viewBox="0 0 24 24" width="22" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M0 0h24v24H0z" fill="none"></path><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"></path></svg>
    </a> 
    
</h3>

<p>If you want to read more about existing conversion routines, new ones and also see some benchmarks you can see two great posts at @fluentcpp:</p>
<ul>
<li><a href="https://www.fluentcpp.com/2018/07/24/how-to-convert-a-string-to-an-int-in-c/">How to Convert a String to an int in C++</a> and</li>
<li><a href="https://www.fluentcpp.com/2018/07/27/how-to-efficiently-convert-a-string-to-an-int-in-c/">How to *Efficiently* Convert a String to an int in C++</a> written by JFT.</li>
<li><a href="https://lemire.me/blog/2022/07/27/comparing-strtod-with-from_chars-gcc-12/">Comparing strtod with <code>from_chars</code> (GCC 12) – Daniel Lemire’s blog</a></li>
</ul>
<h4 id="your-turn">
Your Turn 
    
</h4>

<ul>
<li>Have you played with the new conversion routines?</li>
<li>What do you usually use to convert text into numbers?</li>
</ul>

      </div></div>
  </body>
</html>
