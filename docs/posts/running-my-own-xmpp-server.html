<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dmcc.io/journal/xmpp-turn-stun-coturn-prosody/">Original</a>
    <h1>Running My Own XMPP Server</h1>
    
    <div id="readability-page-1" class="page"><p>Notes from setting up Prosody in Docker for federated messaging, with file sharing, voice calls, and end-to-end encryption.</p><section><p>About a year ago I <a href="https://blog.dmcc.io/journal/2025_my_privacy_reboot/">moved my personal messaging to Signal</a> as part of a broader push to take ownership of my digital life. That went well. Most of my contacts made the switch, and I’m now at roughly 95% Signal for day-to-day conversations. But Signal is still one company running one service. If they shut down tomorrow or change direction, I’m back to square one.</p><p>XMPP fixes that. It’s federated, meaning your server talks to other XMPP servers automatically and you’re never locked into a single provider. Your messages live on your hardware. The protocol has been around since 1999 and it’s not going anywhere. I’d tried XMPP years ago and bounced off it, but the clients have come a long way since then. <a href="https://monal-im.org/">Monal</a> and <a href="https://conversations.im/">Conversations</a> are genuinely nice to use now.</p><p>This post covers everything I did to get a fully working XMPP server running with <a href="https://prosody.im/">Prosody</a> in Docker, from DNS records through to voice calls.</p><h2 id="prerequisites">Prerequisites</h2><ul><li>A server with Docker and Docker Compose</li><li>A domain you control</li><li>TLS certificates (Let’s Encrypt works well)</li></ul><h2 id="dns-records">DNS records</h2><p>XMPP uses SRV records to let clients and other servers find yours. You’ll need these in your DNS:</p><div><pre><code data-lang="fallback">_xmpp-client._tcp.xmpp.example.com  SRV  0 5 5222 xmpp.example.com.
_xmpp-server._tcp.xmpp.example.com  SRV  0 5 5269 xmpp.example.com.
</code></pre></div><p>Port 5222 is for client connections, 5269 is for server-to-server federation. You’ll also want an A record pointing <code>xmpp.example.com</code> to your server’s IP.</p><p>If you want HTTP file uploads (I’d recommend it), add a CNAME or A record for <code>upload.xmpp.example.com</code> pointing to the same server. Same for <code>conference.xmpp.example.com</code> if you want group chats with a clean subdomain, though Prosody handles this internally either way.</p><h2 id="tls-certificates">TLS certificates</h2><p>Prosody won’t start without certificates. I use Let’s Encrypt with the Cloudflare DNS challenge so I don’t need to expose port 80:</p><div><pre><code data-lang="bash">docker run --rm <span>\
</span><span></span>  -v ~/docker/xmpp/certs:/etc/letsencrypt <span>\
</span><span></span>  -v ~/docker/xmpp/cloudflare.ini:/etc/cloudflare.ini:ro <span>\
</span><span></span>  certbot/dns-cloudflare certonly <span>\
</span><span></span>  --dns-cloudflare <span>\
</span><span></span>  --dns-cloudflare-credentials /etc/cloudflare.ini <span>\
</span><span></span>  -d xmpp.example.com
</code></pre></div><p>The <code>cloudflare.ini</code> file contains your API token:</p><div><pre><code data-lang="ini"><span>dns_cloudflare_api_token</span> <span>=</span> <span>your-cloudflare-api-token</span>
</code></pre></div><p>After certbot runs, fix the permissions so Prosody can read the certs:</p><div><pre><code data-lang="bash">chmod -R <span>755</span> ~/docker/xmpp/certs/live/ ~/docker/xmpp/certs/archive/
chmod <span>644</span> ~/docker/xmpp/certs/archive/xmpp.example.com/*.pem
</code></pre></div><p>Set up a cron to renew monthly:</p><div><pre><code data-lang="bash"><span>0</span> <span>3</span> <span>1</span> * * docker run --rm -v ~/docker/xmpp/certs:/etc/letsencrypt <span>\
</span><span></span>  -v ~/docker/xmpp/cloudflare.ini:/etc/cloudflare.ini:ro <span>\
</span><span></span>  certbot/dns-cloudflare renew <span>\
</span><span></span>  --dns-cloudflare-credentials /etc/cloudflare.ini <span>\
</span><span></span>  <span>&amp;&amp;</span> docker restart xmpp
</code></pre></div><h2 id="the-docker-setup">The Docker setup</h2><p>The <code>docker-compose.yml</code>:</p><div><pre><code data-lang="yaml"><span>services</span>:<span>
</span><span>  </span><span>prosody</span>:<span>
</span><span>    </span><span>image</span>:<span> </span>prosodyim/prosody:<span>13.0</span><span>
</span><span>    </span><span>container_name</span>:<span> </span>xmpp<span>
</span><span>    </span><span>restart</span>:<span> </span>unless-stopped<span>
</span><span>    </span><span>ports</span>:<span>
</span><span>      </span>- <span>&#34;5222:5222&#34;</span><span>
</span><span>      </span>- <span>&#34;5269:5269&#34;</span><span>
</span><span>    </span><span>volumes</span>:<span>
</span><span>      </span>- prosody-data:/var/lib/prosody<span>
</span><span>      </span>- ./prosody.cfg.lua:/etc/prosody/prosody.cfg.lua:ro<span>
</span><span>      </span>- ./certs/live/xmpp.example.com/fullchain.pem:/etc/prosody/certs/xmpp.example.com.crt:ro<span>
</span><span>      </span>- ./certs/live/xmpp.example.com/privkey.pem:/etc/prosody/certs/xmpp.example.com.key:ro<span>
</span><span>
</span><span></span><span>volumes</span>:<span>
</span><span>  </span><span>prosody-data</span>:<span>
</span></code></pre></div><p>Two ports exposed: 5222 for clients, 5269 for federation. The data volume holds user accounts and message archives. Config and certs are mounted read-only.</p><h2 id="prosody-configuration">Prosody configuration</h2><p>This is the core of it. I’ll walk through the key sections rather than dumping the whole file.</p><h3 id="modules">Modules</h3><p>Prosody is modular. My module list:</p><div><pre><code data-lang="lua">modules_enabled <span>=</span> {
    <span>-- Core</span>
    <span>&#34;roster&#34;</span>; <span>&#34;saslauth&#34;</span>; <span>&#34;tls&#34;</span>; <span>&#34;dialback&#34;</span>; <span>&#34;disco&#34;</span>;
    <span>&#34;posix&#34;</span>; <span>&#34;ping&#34;</span>; <span>&#34;register&#34;</span>; <span>&#34;time&#34;</span>; <span>&#34;uptime&#34;</span>; <span>&#34;version&#34;</span>;

    <span>-- Security</span>
    <span>&#34;blocklist&#34;</span>;

    <span>-- Multi-device &amp; mobile</span>
    <span>&#34;carbons&#34;</span>; <span>&#34;csi_simple&#34;</span>;
    <span>&#34;smacks&#34;</span>;         <span>-- Stream Management (reliable delivery)</span>
    <span>&#34;cloud_notify&#34;</span>;   <span>-- Push notifications for mobile</span>

    <span>-- Message archive</span>
    <span>&#34;mam&#34;</span>;

    <span>-- User profiles &amp; presence</span>
    <span>&#34;vcard_legacy&#34;</span>; <span>&#34;pep&#34;</span>; <span>&#34;bookmarks&#34;</span>;

    <span>-- Admin</span>
    <span>&#34;admin_shell&#34;</span>;
}
</code></pre></div><p>The ones I found matter most for a good mobile experience: <code>carbons</code> syncs messages across all your devices instead of delivering to whichever one happened to be online. <code>smacks</code> (Stream Management) handles flaky connections gracefully, so messages aren’t lost when your phone briefly drops signal. <code>cloud_notify</code> enables push notifications so mobile clients don’t need a persistent connection, which is essential for battery life. And <code>mam</code> (Message Archive Management) stores history server-side for search and cross-device sync.</p><h3 id="security-settings">Security settings</h3><div><pre><code data-lang="lua">c2s_require_encryption <span>=</span> <span>true</span>
s2s_require_encryption <span>=</span> <span>true</span>
s2s_secure_auth <span>=</span> <span>true</span>
authentication <span>=</span> <span>&#34;internal_hashed&#34;</span>
allow_registration <span>=</span> <span>false</span>
</code></pre></div><p>All connections are encrypted and registration is disabled since I create accounts manually with <code>prosodyctl</code>. I’ve enabled <code>s2s_secure_auth</code>, which means Prosody will reject connections from servers with self-signed or misconfigured certificates. You’ll lose federation with some poorly configured servers, but if you’re self-hosting for privacy reasons it doesn’t make much sense to relax authentication for other people’s mistakes.</p><h3 id="omemo-encryption">OMEMO encryption</h3><p>TLS encrypts connections in transit, but the server itself can still read your messages. If you’re self-hosting, that means you’re trusting yourself, which is fine. But if other people use your server, or if you just want the belt-and-braces approach, OMEMO adds end-to-end encryption so that not even the server operator can read message content.</p><p>OMEMO is built on the same encryption that Signal uses, so I’m comfortable trusting it. There’s nothing to configure on the server side either. OMEMO is handled entirely by the clients. Monal, Conversations, and Gajim all support it, and in most cases it’s enabled by default for new conversations. I’d recommend turning it on for everything and leaving it on.</p><h3 id="message-archive">Message archive</h3><div><pre><code data-lang="lua">archive_expires_after <span>=</span> <span>&#34;1y&#34;</span>
default_archive_policy <span>=</span> <span>true</span>
</code></pre></div><p>Messages are kept for a year and archiving is on by default. Clients can opt out per-conversation if they want.</p><h3 id="http-for-file-uploads">HTTP for file uploads</h3><div><pre><code data-lang="lua">http_interfaces <span>=</span> { <span>&#34;*&#34;</span> }
http_ports <span>=</span> { <span>5280</span> }
https_ports <span>=</span> { }
http_external_url <span>=</span> <span>&#34;https://xmpp.example.com&#34;</span>
</code></pre></div><p>Prosody serves HTTP on port 5280 internally. I leave HTTPS to my reverse proxy (Caddy), which handles TLS termination. The <code>http_external_url</code> tells Prosody what URL to hand clients when they upload files.</p><h3 id="virtual-host-and-components">Virtual host and components</h3><div><pre><code data-lang="lua">VirtualHost <span>&#34;xmpp.example.com&#34;</span>
    ssl <span>=</span> {
        key <span>=</span> <span>&#34;/etc/prosody/certs/xmpp.example.com.key&#34;</span>;
        certificate <span>=</span> <span>&#34;/etc/prosody/certs/xmpp.example.com.crt&#34;</span>;
    }

Component <span>&#34;conference.xmpp.example.com&#34;</span> <span>&#34;muc&#34;</span>
    modules_enabled <span>=</span> { <span>&#34;muc_mam&#34;</span> }
    restrict_room_creation <span>=</span> <span>&#34;local&#34;</span>

Component <span>&#34;upload.xmpp.example.com&#34;</span> <span>&#34;http_file_share&#34;</span>
    http_file_share_size_limit <span>=</span> <span>10485760</span>    <span>-- 10 MB</span>
    http_file_share_expires_after <span>=</span> <span>2592000</span>  <span>-- 30 days</span>
    http_external_url <span>=</span> <span>&#34;https://xmpp.example.com&#34;</span>
</code></pre></div><p>The MUC (Multi-User Chat) component gives you group chats with message history via <code>muc_mam</code>. I restrict room creation to local users so random federated accounts can’t spin up rooms on my server.</p><p>The file share component handles image and file uploads. A 10 MB limit and 30-day expiry keeps disk usage under control.</p><h2 id="reverse-proxy-for-file-uploads">Reverse proxy for file uploads</h2><p>Prosody’s HTTP port needs to be reachable from the internet for file uploads to work. I use Caddy:</p><div><pre><code data-lang="fallback">xmpp.example.com {
    reverse_proxy xmpp:5280
}
</code></pre></div><p>When a client sends an image, Prosody hands it a URL like <code>https://xmpp.example.com/upload/...</code> and the receiving client fetches it over HTTPS.</p><h2 id="creating-accounts">Creating accounts</h2><p>With registration disabled, accounts are created from the command line:</p><div><pre><code data-lang="bash">docker <span>exec</span> -it xmpp prosodyctl adduser danny@xmpp.example.com
</code></pre></div><p>It prompts for a password. Done. Log in from any XMPP client.</p><h2 id="firewall">Firewall</h2><p>Open the XMPP ports:</p><div><pre><code data-lang="bash">sudo ufw allow <span>5222</span> comment <span>&#39;XMPP client&#39;</span>
sudo ufw allow <span>5269</span> comment <span>&#39;XMPP federation&#39;</span>
</code></pre></div><p>Port 80/443 for the reverse proxy if you haven’t already. If your server is behind a router, forward 5222 and 5269.</p><h2 id="voice-and-video-calls">Voice and video calls</h2><p>Text and file sharing work at this point. Voice and video calls need one more piece: a TURN/STUN server. Without it, clients behind NAT can’t establish direct media connections.</p><p>I run <a href="https://github.com/coturn/coturn">coturn</a> alongside Prosody. The two share a secret, and Prosody generates temporary credentials for clients automatically.</p><p>Generate a shared secret:</p><p>The coturn <code>docker-compose.yml</code>:</p><div><pre><code data-lang="yaml"><span>services</span>:<span>
</span><span>  </span><span>coturn</span>:<span>
</span><span>    </span><span>image</span>:<span> </span>coturn/coturn:latest<span>
</span><span>    </span><span>container_name</span>:<span> </span>coturn<span>
</span><span>    </span><span>restart</span>:<span> </span>unless-stopped<span>
</span><span>    </span><span>network_mode</span>:<span> </span>host<span>
</span><span>    </span><span>volumes</span>:<span>
</span><span>      </span>- ./turnserver.conf:/etc/coturn/turnserver.conf:ro<span>
</span><span>    </span><span>tmpfs</span>:<span>
</span><span>      </span>- /var/lib/coturn<span>
</span></code></pre></div><p>It runs with <code>network_mode: host</code> because TURN needs real network interfaces to handle NAT traversal. Docker’s port mapping breaks this.</p><p>The <code>turnserver.conf</code>:</p><div><pre><code data-lang="fallback">listening-port=3478
tls-listening-port=5349
min-port=49152
max-port=49200
relay-threads=2
realm=xmpp.example.com
use-auth-secret
static-auth-secret=YOUR_SECRET_HERE
no-multicast-peers
no-cli
no-tlsv1
no-tlsv1_1
denied-peer-ip=10.0.0.0-10.255.255.255
denied-peer-ip=172.16.0.0-172.31.255.255
denied-peer-ip=192.168.0.0-192.168.255.255
log-file=stdout
</code></pre></div><p>If your server is behind NAT, add:</p><div><pre><code data-lang="fallback">external-ip=YOUR_PUBLIC_IP/YOUR_PRIVATE_IP
</code></pre></div><p>Then tell Prosody about it. Add <code>&#34;turn_external&#34;</code> to your modules, and inside the <code>VirtualHost</code> block:</p><div><pre><code data-lang="lua">    turn_external_host <span>=</span> <span>&#34;xmpp.example.com&#34;</span>
    turn_external_port <span>=</span> <span>3478</span>
    turn_external_secret <span>=</span> <span>&#34;YOUR_SECRET_HERE&#34;</span>
</code></pre></div><p>Open the firewall ports:</p><div><pre><code data-lang="bash">sudo ufw allow <span>3478</span> comment <span>&#39;STUN/TURN&#39;</span>
sudo ufw allow <span>5349</span> comment <span>&#39;TURNS&#39;</span>
sudo ufw allow 49152:49200/udp comment <span>&#39;TURN relay&#39;</span>
</code></pre></div><p>Verify with <code>docker exec xmpp prosodyctl check turn</code>.</p><h2 id="clients">Clients</h2><p>On iOS I went with <a href="https://monal-im.org/">Monal</a>, which is open source and supports all the modern XEPs. Push notifications work well. On Android, <a href="https://conversations.im/">Conversations</a> seems to be the go-to. On desktop, <a href="https://gajim.org/">Gajim</a> covers Linux and Windows, and Monal has a macOS build.</p><p>All of them support OMEMO encryption, file sharing, group chats, and voice/video calls.</p><h2 id="verifying-your-setup">Verifying your setup</h2><p>Prosody has solid built-in diagnostics:</p><div><pre><code data-lang="bash">docker <span>exec</span> xmpp prosodyctl check
</code></pre></div><p>This checks DNS records, TLS certificates, connectivity, and module configuration. Fix anything it flags. The error messages are genuinely helpful.</p><p>The <a href="https://compliance.conversations.im/">XMPP Compliance Tester</a> is worth running too. Mine scored above 90% after getting the config right.</p><h2 id="final-thoughts">Final thoughts</h2><p>The whole setup runs in two small Docker containers and a reverse proxy entry. Prosody, file uploads, message archive, push notifications, group chats, voice calls.</p><p>I still use Signal for most day-to-day conversations and I’m not planning to stop. But having my own XMPP server means I’m not entirely dependent on any single service. I can message anyone on any XMPP server, not just people who signed up to the same one. It’s a nice fallback to have.</p><p>If you’re already running Docker on a server somewhere, it’s a good weekend project.</p></section></div>
  </body>
</html>
