<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2023/12/18/boom/">Original</a>
    <h1>Smashing the stack for pain and misery</h1>
    
    
<p>
I need to remind people how easy it is to forget just one of the many 
gotchas of working on this ridiculous computer stuff.  One missed nugget 
of data at a critical moment can leave you scratching your head and 
going &#34;WTF&#34; for longer than would otherwise seem reasonable.
</p>
<p>
Here&#39;s something that happened to me last week.  I was working on a 
stupid little utility that runs on my machines and lets me keep tabs on 
what&#39;s going on with systemd.  If it gets unhappy because any of the 
services have stopped running, then this thing will let me know about 
it.  For the handful of systems I have to worry about, it gets the job 
done.
</p>
<p>
Now, since I&#39;m in &#34;holiday mode&#34;, I&#39;m largely working on my laptop 
instead of sshing back to a Linux box somewhere else.  This laptop is a 
Mac, so it&#39;s mostly compatible with what I&#39;m doing.  Obviously, it 
doesn&#39;t run systemd, but that wouldn&#39;t stop me from tidying up a tool in 
test mode.  I was working on this thing, and noticed it started blowing 
up in strange places.  Also, it was a really strange &#34;bus error&#34;.  To 
me, that says &#34;binaries on NFS&#34; or &#34;unaligned access on some 
architectures&#34;.  I&#39;m not doing either sort of thing here.
</p>
<p>
gdb was not really an option at that moment for various annoying 
reasons so I resorted to &#34;debug via printf&#34; - putting little notes to 
say &#34;I got here&#34; and whatnot.  They kept changing.  I&#39;d think I had it 
nailed down, and it would move!
</p>
<p>
Eventually, I got it down to something truly odd: it was blowing up in a 
worker thread, and it was the point where that thread started up and 
read in a config file from the disk.  The line of code looked something 
like this, where I call into one of my own helper libraries:
</p>
<pre class="terminal">auto raw = file::ReadFileToString(kDefaultConfigPath);
</pre>
<p>
Okay, I said to myself, let&#39;s find out what&#39;s going on in that function 
and started sprinkling my &#34;I got here&#34; notes into there.  One of those 
notes was at the very top of that function and just said &#34;got into 
ReadFileToString&#34;.  It never ran.
</p>
<p>
I removed the call to that function.  It stopped crashing.
</p>
<p>
So, what&#39;s in that function that&#39;s so spooky?  Well, it opens a file 
descriptor, does the usual sanity checks on it, and then creates a 
buffer that it&#39;ll pass to read()... and herein lies the problem:
</p>
<pre class="terminal">  char buf[1048576];
</pre>
<p>
Yep, just having that there was blowing the stack, and the bus error is 
how it manifested in that particular arrangement of function calls 
within the worker thread.
</p>
<p>
That&#39;s right, if you&#39;re already pressed for stack space and then enter a 
function with something like that, you might just explode.  Here&#39;s a 
contrived example with an even bigger buffer to demonstrate it with just 
a single innocent-seeming function call:
</p>
<pre class="terminal">mac$ cat bs.cc 
#include &lt;stdio.h&gt;

#include &lt;memory&gt;
#include &lt;thread&gt;

static void do_thing() {
  char buf[1048576 * 8];
  buf[0] = &#39;\0&#39;;
}

int main(int argc, char** argv) {
  if (argc != 1) {
    printf(&#34;running in worker thread\n&#34;);

    auto worker = std::make_unique&lt;std::thread&gt;(&amp;do_thing);
    worker-&gt;join();
    return 0;
  }

  printf(&#34;running in main\n&#34;);
  do_thing();
  return 0;
}
</pre>
<p>
The fun part is that on a Mac, the flavor of error changes between &#34;bus 
error&#34; and &#34;segmentation fault&#34; just by shoveling it into a thread.
</p>
<pre class="terminal">mac$ ./bs 
running in main
zsh: segmentation fault  ./bs
mac$ ./bs foo
running in worker thread
zsh: bus error  ./bs foo
mac$ 
</pre>
<p>
Nice, right?  Further complicating matters is that on a boring old 
x86_64 Linux box, it gets reported as a segmentation fault both ways.
</p>
<pre class="terminal">linux$ ./bs
running in main
Segmentation fault
linux$ ./bs foo
running in worker thread
Segmentation fault
</pre>
<p>
A simple twiddling of the ulimits will change the behavior ever so 
slightly:
</p>
<pre class="terminal">linux$ ulimit -s unlimited
linux$ ./bs
running in main
linux$ ./bs foo
running in worker thread
Segmentation fault
linux$ 
</pre>
<p>
Fun fun fun.  Obviously, I need to rethink the way I manage my buffers.
</p>

  </body>
</html>
