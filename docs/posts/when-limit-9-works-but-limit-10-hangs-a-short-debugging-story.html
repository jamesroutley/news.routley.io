<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neon.tech/blog/when-limit-9-works-but-limit-10-hangs">Original</a>
    <h1>When LIMIT 9 works but LIMIT 10 hangs: A short debugging story</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>I got a Slack message from colleagues at a major partner. They’d updated their dev environment to support WebSockets, so that Neon’s serverless driver could be used there, but then they’d run into a weird issue. </p>



<p>The nub of it was this:</p>



<p>This hangs:</p>


<figure><pre><code><span>const { </span><span>rows</span><span> } </span><span>=</span><span> await </span><span>sql</span><span>`</span><span>SELECT * FROM pokemon ORDER BY random() LIMIT 10</span><span>`</span><span>;</span></code></pre></figure>


<p>This works</p>


<figure><pre><code><span>const { </span><span>rows</span><span> } </span><span>=</span><span> await </span><span>sql</span><span>`</span><span>SELECT * FROM pokemon LIMIT 10</span><span>`</span><span>;</span></code></pre></figure>


<p>Reproducibly, the query without an ORDER BY ran fine every time. Reproducibly, the query with <code>ORDER BY random()</code> failed every time. Usually, it hung. Occasionally, it came back with an immediate <code>Error: Connection terminated unexpectedly</code>. Either way: it never worked. </p>



<p>I was intrigued by this. I was also keen to fix it.</p>



<p><a href="https://www.npmjs.com/package/@neondatabase/serverless">Our serverless driver</a> redirects the Postgres binary protocol — which is ordinarily carried over TCP — over a WebSocket connection, <a href="https://neon.tech/blog/serverless-driver-for-postgres">so that it can be used from serverless platforms</a> that support WebSockets but not TCP.</p>



<p>Our partner was using <a href="https://www.npmjs.com/package/undici">undici</a> to support WebSockets in Node 18 and above, and <a href="https://www.npmjs.com/package/ws">ws</a> to support them in Node 17 and below. Node 17 and below worked, Node 18 and above didn’t. Plus, undici’s WebSockets support was labelled as ‘experimental’. So they’d identified undici as a good place to start looking for the problem.</p>



<p>I created a minimal test case to run in Node, and saved it as wstest.mjs:</p>


<figure><pre><code><span>
</span><span></span><span>
</span><span></span><span>import</span><span> </span><span>{</span><span> </span><span>WebSocket</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;undici&#39;</span><span>;</span><span>
</span>
<span></span><span>
</span><span></span><span>
</span>
<span></span><span>const</span><span> query </span><span>=</span><span> </span><span>&#39;SELECT * FROM pokemon ORDER BY random() LIMIT 10&#39;</span><span>;</span><span>
</span>
<span></span><span>import</span><span> </span><span>{</span><span> neonConfig</span><span>,</span><span> </span><span>Pool</span><span> </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@neondatabase/serverless&#39;</span><span>;</span><span>
</span>
<span>neonConfig</span><span>.</span><span>webSocketConstructor</span><span> </span><span>=</span><span> </span><span>WebSocket</span><span>;</span><span>
</span>
<span></span><span>const</span><span> connectionString </span><span>=</span><span> 
</span>
<span>  </span><span>&#39;postgres://jawj:passwd@proj-name.eu-central-1.aws.neon.tech/main&#39;</span><span>;</span><span>
</span>
<span></span><span>const</span><span> pool </span><span>=</span><span> </span><span>new</span><span> </span><span>Pool</span><span>(</span><span>{</span><span> connectionString </span><span>}</span><span>)</span><span>;</span><span>
</span><span></span><span>const</span><span> result </span><span>=</span><span> </span><span>await</span><span> pool</span><span>.</span><span>query</span><span>(</span><span>query</span><span>)</span><span>;</span><span>
</span><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>result</span><span>)</span><span>;</span><span>
</span><span>pool</span><span>.</span><span>end</span><span>(</span><span>)</span><span>;</span></code></pre></figure>


<p>Of the four possible combinations of uncommenting here — (ws, undici) x (short query, long query) — the long query sent via undici was the only one that kept failing.</p>



<h2>Wiresharking</h2>



<p>To try to see where things were getting stuck, I opened <a href="https://www.wireshark.org/">Wireshark</a>, entered a capture filter (<code>host proj-name.eu-central-1.aws.neon.tech</code>), ran my test script, and began eyeballing network packets.</p>



<p>But — oh. Our driver’s WebSockets are secure, over `<code>wss:</code>`, so all I saw was the start of a TLS 1.3 negotiation and then lots of encrypted TLS ‘application data’ packets.</p>



<p>What I needed was to supply Wireshark with the TLS keys. Happily, it turns out that Node makes this very straightforward. A brief web search later, I ran:</p>


<figure><pre><code><span>node</span><span> --tls-keylog</span><span>=</span><span>keylog.txt wstest.mjs</span></code></pre></figure>


<p>I then pointed Wireshark at <code>keylog.txt</code> (via <em>Preferences … &gt; Protocols &gt; TLS &gt; (Pre-)Master-Secret log filename</em>), restarted the capture, and ran the script again.</p>



<p>(1)</p>



<p><img alt="Post image" width="1024" height="600" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=640&amp;q=85 640w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=750&amp;q=85 750w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=828&amp;q=85 828w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=1080&amp;q=85 1080w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=1200&amp;q=85 1200w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=1920&amp;q=85 1920w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=2048&amp;q=85 2048w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=3840&amp;q=85 3840w" src="https://neon.tech/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-25.png&amp;w=3840&amp;q=85"/></p><p>Progress: now we can see the decrypted data. Highlighted in green we have a GET request followed by a <code>HTTP/1.1 101 Switching Protocols</code> message, indicating that the WebSocket connection got accepted by the server. But following that, Wireshark doesn’t identify <strong>any</strong> WebSocket traffic. Just a single substantive message is recorded, and Wireshark sees it only as a decrypted (but still opaque) TLS transmission.</p>



<p><em>Note: a database password is shown in, or recoverable from, several screenshots on this page. This password has since been changed!</em></p>



<p>How does this compare with what we get when we use the ws WebSocket package instead?</p>



<p>(2)</p>



<p><img alt="Post image" loading="lazy" width="1024" height="599" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=640&amp;q=85 640w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=750&amp;q=85 750w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=828&amp;q=85 828w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=1080&amp;q=85 1080w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=1200&amp;q=85 1200w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=1920&amp;q=85 1920w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=2048&amp;q=85 2048w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=3840&amp;q=85 3840w" src="https://neon.tech/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-27.png&amp;w=3840&amp;q=85"/></p><p>The next substantive packet after the <code>Switching Protocols</code> message has the same 222-byte length as before. But this time it’s identified as a <code>WebSocket Binary</code> message (we can also see that it’s <a href="https://security.stackexchange.com/questions/113297/whats-the-purpose-of-the-mask-in-a-websocket">masked</a>, and that it constitutes the final — and indeed only — installment of the data being sent in this particular transmission).</p>



<p>Let’s unmask the data by using the relevant tab at the bottom of the bottom-right-hand pane, and see what’s being sent.</p>



<p>(3)</p>



<p><img alt="Post image" loading="lazy" width="1024" height="599" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=640&amp;q=85 640w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=750&amp;q=85 750w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=828&amp;q=85 828w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=1080&amp;q=85 1080w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=1200&amp;q=85 1200w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=1920&amp;q=85 1920w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=2048&amp;q=85 2048w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=3840&amp;q=85 3840w" src="https://neon.tech/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2Fimage-26.png&amp;w=3840&amp;q=85"/></p><p>There are three separate short binary Postgres-protocol messages jammed together here: a <a href="https://www.postgresql.org/docs/current/protocol-message-formats.html#PROTOCOL-MESSAGE-FORMATS-STARTUPMESSAGE">StartupMessage</a>, a <a href="https://www.postgresql.org/docs/current/protocol-message-formats.html#PROTOCOL-MESSAGE-FORMATS-PASSWORDMESSAGE">PasswordMessage</a>, and <a href="https://www.postgresql.org/docs/current/protocol-message-formats.html#PROTOCOL-MESSAGE-FORMATS-QUERY">Query</a> message (we pipeline these for speed, <a href="https://neon.tech/blog/quicker-serverless-postgres">as I’ve mentioned before</a>). This is all fine and just as expected.</p>



<p>So: what’s the difference between screenshots 1 and 2, which are the undici and ws versions of the same communication? Byte 1 is the same in both: it says that this is the final (only) packet of this binary transmission. Byte 2 is the same in both, too: it says that the transmission is masked, and that we should treat the next two bytes as a 16-bit payload length.</p>



<p>So then bytes 3 and 4 should be that 16-bit payload length — and this is where things fall apart. The ws message says we have 126 bytes (<code>00000000 01111110</code>) of payload. That sounds plausible. The undici message says we have 25,888 bytes (<code>01100101 00100000</code>) of payload … in a 222 byte packet? Yeah: this one is fishy.</p>



<p>I tried some more requests using undici, and the 2-byte payload length field was different every time. It appeared to contain essentially random numbers. Usually, the supposed payload length was longer than the real length of 126 bytes, and then the request hung, waiting on the promised additional data that was never actually going to be sent. Occasionally, the supposed payload length was shorter than the real length, and in those cases I got that <code>Connection terminated unexpectedly</code> error I noted earlier.</p>



<h2>WebSocket payload lengths</h2>



<p>It was time to read up on the WebSocket framing protocol and, in particular, how payload lengths are communicated. In the name of saving a few bytes here and there, it turns out there are <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.2">three different ways a WebSocket payload length can be encoded</a> in a WebSocket frame. Lengths up to 125 bytes are expressed in the last 7 bits (after the mask bit) of the second byte of the frame. For lengths between 126 and 65,535 bytes, those seven bits are set to 126 (<code>1111110</code>), and bytes 3 and 4 hold the length. And for lengths of more than 65,535 bytes, the seven bits are set to 127 (<code>1111111</code>), and the length is then found in the next 8 bytes, 3 through 10.</p>



<p><a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.2">The RFC</a> illustrates this with the following figure:</p>


<figure><pre><code><span>0</span><span>                   </span><span>1</span><span>                   </span><span>2</span><span>                   </span><span>3</span><span>
</span><span></span><span>0</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span> </span><span>6</span><span> </span><span>7</span><span> </span><span>8</span><span> </span><span>9</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span> </span><span>6</span><span> </span><span>7</span><span> </span><span>8</span><span> </span><span>9</span><span> </span><span>0</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span> </span><span>5</span><span> </span><span>6</span><span> </span><span>7</span><span> </span><span>8</span><span> </span><span>9</span><span> </span><span>0</span><span> </span><span>1</span><span>
</span>+-+-+-+-+-------+-+-------------+-------------------------------+
<span></span><span>|</span><span>F</span><span>|</span><span>R</span><span>|</span><span>R</span><span>|</span><span>R</span><span>|</span><span> opcode</span><span>|</span><span>M</span><span>|</span><span> Payload len </span><span>|</span><span>    Extended payload length    </span><span>|</span><span>
</span><span></span><span>|</span><span>I</span><span>|</span><span>S</span><span>|</span><span>S</span><span>|</span><span>S</span><span>|</span><span>  </span><span>(</span><span>4</span><span>)</span><span>  </span><span>|</span><span>A</span><span>|</span><span>     </span><span>(</span><span>7</span><span>)</span><span>     </span><span>|</span><span>             </span><span>(</span><span>16</span><span>/64</span><span>)</span><span>           </span><span>|</span><span>
</span><span></span><span>|</span><span>N</span><span>|</span><span>V</span><span>|</span><span>V</span><span>|</span><span>V</span><span>|</span><span>       </span><span>|</span><span>S</span><span>|</span><span>             </span><span>|</span><span>   </span><span>(</span><span>if payload </span><span>len</span><span>==</span><span>126</span><span>/127</span><span>)</span><span>   </span><span>|</span><span>
</span><span></span><span>|</span><span> </span><span>|</span><span>1</span><span>|</span><span>2</span><span>|</span><span>3</span><span>|</span><span>       </span><span>|</span><span>K</span><span>|</span><span>             </span><span>|</span><span>                               </span><span>|</span><span>
</span>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
<span></span><span>|</span><span>     Extended payload length continued, </span><span>if</span><span> payload len </span><span>==</span><span> </span><span>127</span><span>  </span><span>|</span><span>
</span>+ - - - - - - - - - - - - - - - +-------------------------------+
<span></span><span>|</span><span>                               </span><span>|</span><span>Masking-key, </span><span>if</span><span> MASK </span><span>set</span><span> to </span><span>1</span><span>  </span><span>|</span><span>
</span>+-------------------------------+-------------------------------+
<span></span><span>|</span><span> Masking-key </span><span>(</span><span>continued</span><span>)</span><span>       </span><span>|</span><span>          Payload Data         </span><span>|</span><span>
</span>+-------------------------------- - - - - - - - - - - - - - - - +
<span></span><span>:</span><span>                     Payload Data continued </span><span>..</span><span>.                </span><span>:</span><span>
</span>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
<span></span><span>:</span><span>                     Payload Data continued </span><span>..</span><span>.                </span><span>|</span><span>
</span>+---------------------------------------------------------------+</code></pre></figure>


<p>A-ha! There’s a clue here about why a shorter query might succeed where a longer query fails. We already saw that the longer query above, <code>SELECT * FROM pokemon ORDER BY random() LIMIT 10</code>, brings the total payload to 126 bytes. As luck would have it, this is exactly the smallest value that requires a 16-bit extended payload length. </p>



<p>By contrast, the shorter query (the one without an <code>ORDER BY</code> clause) will clearly result in a shorter payload length: one that thus fits in the 7 bits of the second byte, and thus exercises a different code path. In fact, we can see that shortening our failing query by just one character — for example, <code>LIMIT 9</code> in place of <code>LIMIT 10</code> — would be enough to change the path taken here. </p>



<h2>Hacking on undici</h2>



<p>With all this in mind, I began to poke around in the undici GitHub repo. It was mercifully straightforward to find the relevant code in <a href="https://github.com/nodejs/undici/blob/ab2e0ce9cbdef85e215dd5b2f268b644b308012b/lib/websocket/frame.js">lib/websocket/frame.js</a>. I homed in on these few lines:</p>


<figure><pre><code><span>let</span><span> payloadLength </span><span>=</span><span> bodyLength </span><span>
</span><span>    </span><span>
</span><span>    </span><span>if</span><span> </span><span>(</span><span>bodyLength </span><span>&gt;</span><span> maxUnsigned16Bit</span><span>)</span><span> </span><span>{</span><span>
</span><span>      </span><span>
</span><span>      payloadLength </span><span>=</span><span> </span><span>127</span><span>
</span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>(</span><span>bodyLength </span><span>&gt;</span><span> </span><span>125</span><span>)</span><span> </span><span>{</span><span>
</span><span>      </span><span>
</span><span>      payloadLength </span><span>=</span><span> </span><span>126</span><span>
</span><span>    </span><span>}</span><span>
</span>
<span>    </span><span>const</span><span> buffer </span><span>=</span><span> </span><span>Buffer</span><span>.</span><span>allocUnsafe</span><span>(</span><span>bodyLength </span><span>+</span><span> offset</span><span>)</span><span>
</span><span>    </span><span>
</span><span>    </span><span>if</span><span> </span><span>(</span><span>payloadLength </span><span>===</span><span> </span><span>126</span><span>)</span><span> </span><span>{</span><span>
</span><span>      </span><span>new</span><span> </span><span>DataView</span><span>(</span><span>buffer</span><span>.</span><span>buffer</span><span>)</span><span>.</span><span>setUint16</span><span>(</span><span>2</span><span>,</span><span> bodyLength</span><span>)</span><span>
</span><span>    </span><span>}</span></code></pre></figure>


<p>These lines are how the 16-bit length value gets written: by creating a throwaway <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView</a> into the buffer that holds the WebSocket frame, and calling its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16">setUint16()</a> method. It’s perhaps a little unexpected that the value isn’t written using the buffer’s own <a href="https://nodejs.org/api/buffer.html#bufwriteuint16bevalue-offset">writeUInt16BE()</a> method. But the logic seems basically sound, right? Right?</p>



<p>At this point, I think I made a cup of tea.</p>



<p>I came back to the laptop, recaffeinated, and it hit me! I remembered I’d had a similar <em>am-I-going-mad?</em> run-in with JavaScript’s DataView while working on <a href="https://github.com/jawj/subtls">subtls</a>. Data wasn’t being written where it was supposed to be written, and I’d been at a loss to understand why. After a few minutes tearing my hair out, I’d figured out the fix, and as part of <a href="https://github.com/jawj/subtls/commit/2e86814506e6d70bd106648753b9c5199425fa91#diff-3d2b59189eeedc2d428ddd632e97658fe310f587f7cb63b01f9b98ffc11c0197">a bigger overall commit</a> I’d added two additional arguments to new DataView():</p>



<p><img alt="Post image" loading="lazy" width="703" height="131" decoding="async" data-nimg="1" sizes="(max-width: 767px) 100vw" srcset="/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=640&amp;q=85 640w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=750&amp;q=85 750w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=828&amp;q=85 828w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=1080&amp;q=85 1080w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=1200&amp;q=85 1200w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=1920&amp;q=85 1920w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=2048&amp;q=85 2048w, /_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=3840&amp;q=85 3840w" src="https://neon.tech/_next/image?url=https%3A%2F%2Fneon-hwp.dreamhosters.com%2Fwp-content%2Fuploads%2F2023%2F05%2FScreenshot-2023-05-24-at-14.43.55.png&amp;w=3840&amp;q=85"/></p><h2>Buffers, ArrayBuffers and subarrays</h2>



<p>How did <em>that</em> fix work? Well, any particular Buffer (or typed array) in Node is backed by an ArrayBuffer. That can either be a dedicated ArrayBuffer, which has the same size as the Buffer itself, or it can be a slice of a larger ArrayBuffer. </p>



<p>A common way to create the latter sort of Buffer — one that’s backed by some part of a larger <code>ArrayBuffer</code> — is to call the <a href="https://nodejs.org/api/buffer.html#bufsubarraystart-end">subarray()</a> method of an existing buffer. No memory gets copied here. What’s returned by subarray() is a new Buffer object backed by<em> part of the same block of memory</em> that backs the buffer it was called on. This is very useful for optimizing speed and memory use.</p>



<p>Of course, when buffers share the same memory, we have to remember that writing to either one of them could make changes to the other. And, of course, when we do anything with a larger <code>ArrayBuffer</code> that underlies a smaller <code>Buffer</code> — such as passing it to a new <code>DataView</code>, as undici did — we absolutely <strong>must</strong> make sure we reference the appropriate part of it. (To be honest, it’s a pretty nasty footgun that new <code>DataView()</code> defaults <code>byteOffset</code> to zero and <code>byteLength</code> to the <code>ArrayBuffer</code>’s length, rather than insisting that these arguments are provided explicitly).</p>



<p>Long story short: adding the relevant byteLength and byteOffset to the call to new <code>DataView()</code> immediately fixed undici’s WebSockets issue. <a href="https://github.com/nodejs/undici/pull/2106">I filed a PR</a> and logged off for the day feeling pretty good about it.<br/></p>



<h2>Wait, what?</h2>



<p>I was awake for an hour or two in the middle of the night, thoughts wandering, when it occurred to me that I didn’t fully understand why this fix had worked here. Sure, it couldn’t do any harm to add in <code>byteLength</code> and <code>byteOffset</code>, but why should they be needed? After all, the buffer whose <code>ArrayBuffer</code> is passed to the <code>DataView</code> was allocated only a few lines before. Nobody appears to have called <code>subarray()</code> here.</p>



<p><a href="https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize">Looking at the docs</a> the following morning, I learned something new. <code>Buffer.allocUnsafe()</code> isn’t unsafe <strong>only</strong> because it omits to zero out the bytes of the buffer it hands over, which was what I’d thought I knew. <code>Buffer.allocUnsafe()</code> <strong>also</strong> reserves the right to allocate small buffers as sub-arrays of a global pool it keeps lying around for the purpose. (This pool on my installation of Node <a href="https://nodejs.org/api/buffer.html#class-property-bufferpoolsize">is set to 8192 bytes</a>, and buffers up to half that size may be allocated from it).</p>



<p>The upshot is that the buffer allocated for a modestly-sized WebSocket frame will very likely have a non-zero <code>byteOffset</code> into its backing <code>ArrayBuffer</code>, because its backing <code>ArrayBuffer</code> is that global pool. Assuming a zero <code>byteOffset</code> for it is therefore Very Bad in two different ways:</p>



<ol>
<li>The 16-bit payload length that was supposed to be written as bytes 3 and 4 of the WebSocket frame is not written there. So, instead, what ends up as the alleged payload length, in bytes 3 and 4, is whatever arbitrary data was there already.<br/></li>



<li>That 16-bit payload length is actually written somewhere else, as bytes 3 and 4 of <code>Buffer.allocUnsafe()</code>’s global pool. These bytes may well be part of another active buffer, and thus we also stand a good chance of corrupting data elsewhere.</li>
</ol>



<h2>A happy ending</h2>



<p>I now knew why the fix worked.</p>



<p>The undici team asked me to also add a unit test for the change, which I did. At the same time, I took the opportunity to simplify the code by using <a href="https://nodejs.org/api/buffer.html#bufwriteuint16bevalue-offset">writeUInt16BE()</a> as an alternative to a <code>DataView.</code> My pull request was merged, and has now been released in version 5.22.1 of undici.</p>



<h2>Performance: a footnote</h2>



<p><a href="https://github.com/nodejs/undici/pull/2107">A follow-up pull request</a> by an undici dev explains that the DataView approach was originally taken for reasons of performance. I was surprised that creating a throw-away object for this single write would be the quickest way to do things, so I did a little benchmarking of some alternatives:</p>


<figure><pre><code><span>
</span><span></span><span>new</span><span> </span><span>DataView</span><span>(</span><span>b</span><span>.</span><span>buffer</span><span>)</span><span>.</span><span>setUint16</span><span>(</span><span>2</span><span>,</span><span> value</span><span>)</span><span>
</span>
<span></span><span>
</span><span></span><span>new</span><span> </span><span>DataView</span><span>(</span><span>b</span><span>.</span><span>buffer</span><span>,</span><span> b</span><span>.</span><span>byteOffset</span><span>,</span><span> b</span><span>.</span><span>byteLength</span><span>)</span><span>.</span><span>setUint16</span><span>(</span><span>2</span><span>,</span><span> value</span><span>)</span><span>
</span>
<span></span><span>
</span><span>b</span><span>.</span><span>writeUInt16BE</span><span>(</span><span>value</span><span>,</span><span> </span><span>2</span><span>)</span><span>;</span><span>
</span>
<span></span><span>
</span><span>b</span><span>[</span><span>2</span><span>]</span><span> </span><span>=</span><span> value </span><span>&gt;&gt;&gt;</span><span> </span><span>8</span><span>;</span><span>
</span><span>b</span><span>[</span><span>3</span><span>]</span><span> </span><span>=</span><span> value </span><span>&amp;</span><span> </span><span>0xff</span><span>;</span></code></pre></figure>



</div></div>
  </body>
</html>
