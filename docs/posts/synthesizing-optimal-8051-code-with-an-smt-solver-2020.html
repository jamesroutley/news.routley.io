<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lab.whitequark.org/notes/2020-04-06/synthesizing-optimal-8051-code/">Original</a>
    <h1>Synthesizing optimal 8051 code with an SMT solver (2020)</h1>
    
    <div id="readability-page-1" class="page"><article>
        <header>
          
          <time datetime="2020-04-06 16:44:20 +0000">2020-04-06</time>
          
          
          
          Tags:
          
          
        </header>

        <section>
          <p>While working on an application targeting Nordic nRF24LE1, a wireless SoC with a fairly slow 8051 core, I was wondering if I can have fast, or at least not unusably slow, cryptography. Most cryptographic algorithms involve wide rotates, and the 8051 only has instructions for rotating a 8-bit accumulator by one bit at a time. In this note I explore deriving optimal code for rotating values in registers (that may be bigger than 8 bits) by multiple bits.</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#code-generator" id="markdown-toc-code-generator">Code generator</a></li>
  <li>
<a href="#results" id="markdown-toc-results">Results</a>    <ul>
      <li><a href="#bit-rotates" id="markdown-toc-bit-rotates">8-bit rotates</a></li>
      <li><a href="#bit-rotates-1" id="markdown-toc-bit-rotates-1">16-bit rotates</a></li>
    </ul>
  </li>
</ul>



<p>My chosen approach (thanks to <a href="https://www.cs.utah.edu/~regehr/">John Regehr</a> for the <a href="https://twitter.com/johnregehr/status/1212563858524499968">suggestion</a>) is to implement an interpreter for an abstract 8051 assembly representation in <a href="https://racket-lang.org">Racket</a> and then use <a href="https://emina.github.io/rosette/">Rosette</a> to translate assertions about the results of interpreting an arbitrary piece of code into a query for an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a>.</p>

<p>Rosette greatly simplifies this task because it lets me avoid learning anything about SMT solvers, and only requires me to understand the constraints of its symbolic execution approach. (Only a small subset of Racket is safe to use in Rosette, and functions outside of that subset are hard to use correctly without an in-depth understaning of how Rosette works.)</p>



<p>The following code generates all possible optimal (more on that below) 8-bit and 16-bit rotates. It uses a rather hacky and complicated scheme where it runs several solvers in parallel, one per CPU, each aiming for a particular fixed number of instructions, and then picks the smallest result as the solvers finish. This is because at the time of writing it, I did not understand that Rosette allows optimizing exists-forall problems. (It is quite easy to do so, as I describe <a href="https://lab.whitequark.org/notes/2020-04-06/minimizing-logic-expressions/">in a later note</a>.)</p>

<p>However, that turned out to be a blessing in disguise; when writing this note, I <a href="https://lab.whitequark.org/files/synth51/synth51-broken.rkt">rewrote the query as an optimization problem</a> for the solver, and it doesn’t seem like that would work for this use case. First, of the solvers that can be used by Rosette, only Z3 supports quantified formulas, whereas Boolector had the best performance with the simpler queries. Second, even for very small programs (such as 8-bit rotates, which all fit in 4 instructions, and even restricting the usable registers to 2 out of 8), the memory footprint of Z3 grows extremely quickly, and I always ran out of memory before getting a solution.</p>

<p>By “optimal” here I mean “optimal within the limited model being used”, of course. The model I’m using specifically omits any memory access (preventing the use of the <code>XCHD</code> instruction among other things), and in general has a very limited number of instructions to make solver runtime manageable. It is possible (but unlikely) that some of the instructions missing in the model but present in every 8051 CPU provide a faster way to do rotates. It is possible (and fairly likely) that your specific flavor of 8051 CPU provides a faster way to do rotates that involves memory-mapped I/O; indeed, nRF24LE1 does, but I was interested in more portable code.</p>

<figure><figcaption>synth51.rkt (<a href="https://lab.whitequark.org/files/synth51/synth51.rkt">download</a>)</figcaption><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
</pre></td>
<td><pre><span>#</span><span>lang</span> <span>rosette/safe</span>

<span>(</span><span>require</span> <span>(</span><span>only-in</span> <span>racket</span> <span>hash</span> <span>in-range</span> <span>for</span> <span>for/list</span> <span>with-handlers</span> <span>flush-output</span>
                  <span>thread</span> <span>thread-wait</span> <span>break-thread</span> <span>exn:break?</span>
                  <span>make-semaphore</span> <span>semaphore-wait</span> <span>semaphore-post</span> <span>call-with-semaphore/enable-break</span>
                  <span>processor-count</span><span>))</span>
<span>(</span><span>require</span> <span>rosette/solver/smt/z3</span>
         <span>rosette/solver/smt/boolector</span>
         <span>rosette/solver/smt/yices</span><span>)</span>
<span>;(current-solver (z3 #:logic &#39;QF_BV #:options (hash</span>
<span>;   &#39;:parallel.enable &#39;true</span>
<span>;   &#39;:parallel.threads.max 4)))</span>
<span>;(current-solver (yices #:logic &#39;QF_BV))</span>
<span>(</span><span>current-solver</span> <span>(</span><span>boolector</span> <span>#:logic</span> <span>&#39;QF_BV</span><span>))</span>

<span>(</span><span>require</span> <span>rosette/lib/angelic</span>
         <span>rosette/lib/match</span><span>)</span>
<span>(</span><span>current-bitwidth</span> <span>5</span><span>)</span>

<span>; bit operations</span>
<span>(</span><span>define</span> <span>(</span><span>rotate-right</span> <span>s</span> <span>i</span> <span>x</span><span>)</span>
  <span>(</span><span>cond</span>
    <span>[(</span><span>=</span> <span>i</span> <span>0</span><span>)</span> <span>x</span><span>]</span>
    <span>[</span><span>else</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>(</span><span>-</span> <span>i</span> <span>1</span><span>)</span> <span>0</span> <span>x</span><span>)</span> <span>(</span><span>extract</span> <span>(</span><span>-</span> <span>s</span> <span>1</span><span>)</span> <span>i</span> <span>x</span><span>))]))</span>
<span>(</span><span>define</span> <span>(</span><span>rotate-left</span> <span>s</span> <span>i</span> <span>x</span><span>)</span>
  <span>(</span><span>cond</span>
    <span>[(</span><span>=</span> <span>i</span> <span>0</span><span>)</span> <span>x</span><span>]</span>
    <span>[</span><span>else</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>(</span><span>-</span> <span>s</span> <span>i</span> <span>1</span><span>)</span> <span>0</span> <span>x</span><span>)</span> <span>(</span><span>extract</span> <span>(</span><span>-</span> <span>s</span> <span>1</span><span>)</span> <span>(</span><span>-</span> <span>s</span> <span>i</span><span>)</span> <span>x</span><span>))]))</span>

<span>(</span><span>define</span> <span>(</span><span>replace-bit</span> <span>s</span> <span>i</span> <span>x</span> <span>y</span><span>)</span>
  <span>(</span><span>define</span> <span>m</span> <span>(</span><span>bvshl</span> <span>(</span><span>bv</span> <span>1</span> <span>s</span><span>)</span> <span>(</span><span>integer-&gt;bitvector</span> <span>i</span> <span>s</span><span>)))</span>
  <span>(</span><span>cond</span>
    <span>[(</span><span>bveq</span> <span>y</span> <span>(</span><span>bv</span> <span>0</span> <span>1</span><span>))</span> <span>(</span><span>bvand</span> <span>x</span> <span>(</span><span>bvnot</span> <span>m</span><span>))]</span>
    <span>[(</span><span>bveq</span> <span>y</span> <span>(</span><span>bv</span> <span>1</span> <span>1</span><span>))</span> <span>(</span><span>bvor</span> <span>x</span> <span>m</span><span>)]</span>
    <span>[</span><span>else</span> <span>(</span><span>assert</span> <span>#f</span><span>)]))</span>

<span>; CPU state</span>
<span>(</span><span>struct</span> <span>state</span> <span>(</span><span>A</span> <span>C</span> <span>Rn</span><span>)</span> <span>#:mutable</span> <span>#:transparent</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)</span>
  <span>(</span><span>vector-ref</span> <span>(</span><span>state-Rn</span> <span>S</span><span>)</span> <span>n</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-Rn-set!</span> <span>S</span> <span>n</span> <span>v</span><span>)</span>
  <span>(</span><span>vector-set!</span> <span>(</span><span>state-Rn</span> <span>S</span><span>)</span> <span>n</span> <span>v</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R0</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>0</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R1</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>1</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R2</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>2</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R3</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>3</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R4</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>4</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R5</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>5</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R6</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>6</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>state-R7</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>7</span><span>))</span>

<span>(</span><span>define-symbolic</span> <span>A</span> <span>R0</span> <span>R1</span> <span>R2</span> <span>R3</span> <span>R4</span> <span>R5</span> <span>R6</span> <span>R7</span> <span>(</span><span>bitvector</span> <span>8</span><span>))</span>
<span>(</span><span>define-symbolic</span> <span>C</span> <span>(</span><span>bitvector</span> <span>1</span><span>))</span>
<span>(</span><span>define</span> <span>(</span><span>make-state</span><span>)</span>
  <span>(</span><span>state</span> <span>A</span> <span>C</span> <span>(</span><span>vector</span> <span>R0</span> <span>R1</span> <span>R2</span> <span>R3</span> <span>R4</span> <span>R5</span> <span>R6</span> <span>R7</span><span>)))</span>

<span>; instructions</span>
<span>(</span><span>struct</span> <span>MOV-A-Rn</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>MOV-Rn-A</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>ANL-A-Rn</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>ORL-A-Rn</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>XRL-A-Rn</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>XCH-A-Rn</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>MOV-A-i</span> <span>(</span><span>i</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>ANL-A-i</span> <span>(</span><span>i</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>ORL-A-i</span> <span>(</span><span>i</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>SWAP-A</span> <span>()</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>CLR-C</span> <span>()</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>MOV-C-An</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>MOV-An-C</span> <span>(</span><span>n</span><span>)</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>RLC-A</span> <span>()</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>RRC-A</span> <span>()</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>RL-A</span> <span>()</span> <span>#:transparent</span><span>)</span>
<span>(</span><span>struct</span> <span>RR-A</span> <span>()</span> <span>#:transparent</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>print-insn</span> <span>insn</span><span>)</span>
  <span>(</span><span>match</span> <span>insn</span>
    <span>[(</span><span>MOV-A-Rn</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;MOV A, R~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>MOV-Rn-A</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;MOV R~s, A~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>ANL-A-Rn</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;ANL A, R~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>ORL-A-Rn</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;ORL A, R~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>XRL-A-Rn</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;XRL A, R~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>XCH-A-Rn</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;XCH A, R~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>MOV-A-i</span> <span>i</span><span>)</span>  <span>(</span><span>printf</span> <span>&#34;MOV A, #0x~x~n&#34;</span> <span>(</span><span>bitvector-&gt;natural</span> <span>i</span><span>))]</span>
    <span>[(</span><span>ANL-A-i</span> <span>i</span><span>)</span>  <span>(</span><span>printf</span> <span>&#34;ANL A, #0x~x~n&#34;</span> <span>(</span><span>bitvector-&gt;natural</span> <span>i</span><span>))]</span>
    <span>[(</span><span>ORL-A-i</span> <span>i</span><span>)</span>  <span>(</span><span>printf</span> <span>&#34;ORL A, #0x~x~n&#34;</span> <span>(</span><span>bitvector-&gt;natural</span> <span>i</span><span>))]</span>
    <span>[(</span><span>SWAP-A</span><span>)</span>     <span>(</span><span>printf</span> <span>&#34;SWAP A~n&#34;</span><span>)]</span>
    <span>[(</span><span>CLR-C</span><span>)</span>      <span>(</span><span>printf</span> <span>&#34;CLR C~n&#34;</span><span>)]</span>
    <span>[(</span><span>MOV-C-An</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;MOV C, ACC.~s~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>MOV-An-C</span> <span>n</span><span>)</span> <span>(</span><span>printf</span> <span>&#34;MOV ACC.~s, C~n&#34;</span> <span>n</span><span>)]</span>
    <span>[(</span><span>RLC-A</span><span>)</span>      <span>(</span><span>printf</span> <span>&#34;RLC A~n&#34;</span><span>)]</span>
    <span>[(</span><span>RRC-A</span><span>)</span>      <span>(</span><span>printf</span> <span>&#34;RRC A~n&#34;</span><span>)]</span>
    <span>[(</span><span>RL-A</span><span>)</span>       <span>(</span><span>printf</span> <span>&#34;RL A~n&#34;</span><span>)]</span>
    <span>[(</span><span>RR-A</span><span>)</span>       <span>(</span><span>printf</span> <span>&#34;RR A~n&#34;</span><span>)]))</span>

<span>; sketches</span>
<span>(</span><span>define</span> <span>(</span><span>??insn</span><span>)</span>
  <span>(</span><span>define</span> <span>n</span> <span>(</span><span>choose*</span> <span>0</span> <span>1</span><span>))</span><span>; 2 3 4 5 6 7))</span>
  <span>(</span><span>define-symbolic*</span> <span>i</span> <span>(</span><span>bitvector</span> <span>8</span><span>))</span>
  <span>;(define i (choose* (bv #xf0 8) (bv #x0f 8)))</span>
  <span>(</span><span>choose*</span> <span>(</span><span>MOV-A-Rn</span> <span>n</span><span>)</span>
           <span>(</span><span>MOV-Rn-A</span> <span>n</span><span>)</span>
           <span>(</span><span>ANL-A-Rn</span> <span>n</span><span>)</span>
           <span>(</span><span>ORL-A-Rn</span> <span>n</span><span>)</span>
           <span>(</span><span>XRL-A-Rn</span> <span>n</span><span>)</span>
           <span>(</span><span>XCH-A-Rn</span> <span>n</span><span>)</span>
           <span>(</span><span>MOV-A-i</span> <span>i</span><span>)</span>
           <span>(</span><span>ANL-A-i</span> <span>i</span><span>)</span>
           <span>(</span><span>ORL-A-i</span> <span>i</span><span>)</span>
           <span>(</span><span>SWAP-A</span><span>)</span>
           <span>(</span><span>CLR-C</span><span>)</span>
           <span>(</span><span>MOV-C-An</span> <span>n</span><span>)</span>
           <span>(</span><span>MOV-An-C</span> <span>n</span><span>)</span>
           <span>(</span><span>RLC-A</span><span>)</span>
           <span>(</span><span>RRC-A</span><span>)</span>
           <span>(</span><span>RL-A</span><span>)</span>
           <span>(</span><span>RR-A</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>??prog</span> <span>fuel</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>=</span> <span>fuel</span> <span>0</span><span>)</span> <span>null</span>
      <span>(</span><span>cons</span> <span>(</span><span>??insn</span><span>)</span> <span>(</span><span>??prog</span> <span>(</span><span>-</span> <span>fuel</span> <span>1</span><span>)))))</span>

<span>; symbolic interpreter</span>
<span>(</span><span>define</span> <span>(</span><span>run-insn</span> <span>S</span> <span>insn</span><span>)</span>
  <span>(</span><span>match</span> <span>insn</span>
    <span>[(</span><span>MOV-A-Rn</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>))]</span>
    <span>[(</span><span>MOV-Rn-A</span> <span>n</span><span>)</span>
     <span>(</span><span>state-Rn-set!</span> <span>S</span> <span>n</span> <span>(</span><span>state-A</span> <span>S</span><span>))]</span>
    <span>[(</span><span>ANL-A-Rn</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>bvand</span> <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)))]</span>
    <span>[(</span><span>ORL-A-Rn</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>bvor</span>  <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)))]</span>
    <span>[(</span><span>XRL-A-Rn</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>bvxor</span> <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)))]</span>
    <span>[(</span><span>XCH-A-Rn</span> <span>n</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)]</span> <span>[</span><span>Rn</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>Rn</span><span>)</span> <span>(</span><span>state-Rn-set!</span> <span>S</span> <span>n</span> <span>A</span><span>))]</span>
    <span>[(</span><span>MOV-A-i</span> <span>i</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>i</span><span>)]</span>
    <span>[(</span><span>ANL-A-i</span> <span>i</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>bvand</span> <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>i</span><span>))]</span>
    <span>[(</span><span>ORL-A-i</span> <span>i</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>bvor</span>  <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>i</span><span>))]</span>
    <span>[(</span><span>SWAP-A</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>3</span> <span>0</span> <span>A</span><span>)</span> <span>(</span><span>extract</span> <span>7</span> <span>4</span> <span>A</span><span>))))]</span>
    <span>[(</span><span>CLR-C</span><span>)</span>
     <span>(</span><span>set-state-C!</span> <span>S</span> <span>(</span><span>bv</span> <span>0</span> <span>1</span><span>))]</span>
    <span>[(</span><span>MOV-C-An</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-C!</span> <span>S</span> <span>(</span><span>extract</span> <span>n</span> <span>n</span> <span>(</span><span>state-A</span> <span>S</span><span>)))]</span>
    <span>[(</span><span>MOV-An-C</span> <span>n</span><span>)</span>
     <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>replace-bit</span> <span>8</span> <span>n</span> <span>(</span><span>state-A</span> <span>S</span><span>)</span> <span>(</span><span>state-C</span> <span>S</span><span>)))]</span>
    <span>[(</span><span>RLC-A</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)]</span> <span>[</span><span>C</span> <span>(</span><span>state-C</span> <span>S</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>6</span> <span>0</span> <span>A</span><span>)</span> <span>C</span><span>))</span>
       <span>(</span><span>set-state-C!</span> <span>S</span> <span>(</span><span>extract</span> <span>7</span> <span>7</span> <span>A</span><span>)))]</span>
    <span>[(</span><span>RRC-A</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)]</span> <span>[</span><span>C</span> <span>(</span><span>state-C</span> <span>S</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>concat</span> <span>C</span> <span>(</span><span>extract</span> <span>7</span> <span>1</span> <span>A</span><span>)))</span>
       <span>(</span><span>set-state-C!</span> <span>S</span> <span>(</span><span>extract</span> <span>0</span> <span>0</span> <span>A</span><span>)))]</span>
    <span>[(</span><span>RL-A</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>6</span> <span>0</span> <span>A</span><span>)</span> <span>(</span><span>extract</span> <span>7</span> <span>7</span> <span>A</span><span>))))]</span>
    <span>[(</span><span>RR-A</span><span>)</span>
     <span>(</span><span>let</span> <span>([</span><span>A</span> <span>(</span><span>state-A</span> <span>S</span><span>)])</span>
       <span>(</span><span>set-state-A!</span> <span>S</span> <span>(</span><span>concat</span> <span>(</span><span>extract</span> <span>0</span> <span>0</span> <span>A</span><span>)</span> <span>(</span><span>extract</span> <span>7</span> <span>1</span> <span>A</span><span>))))]</span>
    <span>))</span>

<span>; program verifier</span>
<span>(</span><span>define</span> <span>(</span><span>verify-prog</span> <span>prog</span> <span>asserts</span><span>)</span>
  <span>(</span><span>define</span> <span>S</span>  <span>(</span><span>make-state</span><span>))</span>
  <span>(</span><span>define</span> <span>S*</span> <span>(</span><span>make-state</span><span>))</span>
  <span>(</span><span>define</span> <span>solution</span>
    <span>(</span><span>verify</span>
     <span>#:guarantee</span>
     <span>(</span><span>begin</span>
       <span>(</span><span>for-each</span> <span>(</span><span>curry</span> <span>run-insn</span> <span>S*</span><span>)</span> <span>prog</span><span>)</span>
       <span>(</span><span>asserts</span> <span>S</span> <span>S*</span><span>))))</span>
  <span>(</span><span>if</span> <span>(</span><span>unsat?</span> <span>solution</span><span>)</span> <span>#t</span>
      <span>(</span><span>begin</span>
        <span>(</span><span>displayln</span> <span>(</span><span>evaluate</span> <span>S</span>  <span>solution</span><span>))</span>
        <span>(</span><span>displayln</span> <span>(</span><span>evaluate</span> <span>S*</span> <span>solution</span><span>))</span>
        <span>#f</span><span>)))</span>

<span>; program synthesizer</span>
<span>(</span><span>define</span> <span>(</span><span>synthesize-prog</span> <span>sketch</span> <span>asserts</span><span>)</span>
  <span>(</span><span>define</span> <span>S</span>  <span>(</span><span>make-state</span><span>))</span>
  <span>(</span><span>define</span> <span>S*</span> <span>(</span><span>make-state</span><span>))</span>
  <span>(</span><span>define</span> <span>solution</span>
    <span>(</span><span>synthesize</span>
     <span>#:forall</span> <span>S</span>
     <span>#:guarantee</span>
     <span>(</span><span>begin</span>
       <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>insn</span><span>)</span> <span>(</span><span>run-insn</span> <span>S*</span> <span>insn</span><span>))</span> <span>sketch</span><span>)</span>
       <span>(</span><span>asserts</span> <span>S</span> <span>S*</span><span>))))</span>
  <span>(</span><span>if</span> <span>(</span><span>unsat?</span> <span>solution</span><span>)</span> <span>#f</span>
      <span>(</span><span>evaluate</span> <span>sketch</span> <span>solution</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>optimize-prog</span> <span>max-fuel</span> <span>sketch-gen</span> <span>asserts</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>worker</span> <span>fuel</span><span>)</span>
    <span>(</span><span>define</span> <span>prog</span> <span>(</span><span>synthesize-prog</span> <span>(</span><span>sketch-gen</span> <span>fuel</span><span>)</span> <span>asserts</span><span>))</span>
    <span>(</span><span>if</span> <span>prog</span>
        <span>(</span><span>begin</span>
          <span>(</span><span>eprintf</span> <span>&#34;sat! ~s~n&#34;</span> <span>fuel</span><span>)</span>
          <span>(</span><span>for-each</span> <span>print-insn</span> <span>prog</span><span>))</span>
        <span>(</span><span>begin</span>
          <span>(</span><span>eprintf</span> <span>&#34;unsat! ~s~n&#34;</span> <span>fuel</span><span>)</span>
          <span>(</span><span>if</span> <span>(</span><span>&gt;=</span> <span>fuel</span> <span>max-fuel</span><span>)</span> <span>#f</span>
              <span>(</span><span>worker</span> <span>(</span><span>+</span> <span>fuel</span> <span>1</span><span>))))))</span>
  <span>(</span><span>worker</span> <span>0</span><span>))</span>

<span>(</span><span>define</span> <span>(</span><span>optimize-prog/parallel</span> <span>max-fuel</span> <span>sketch-gen</span> <span>asserts</span><span>)</span>
  <span>(</span><span>define</span> <span>solved</span> <span>(</span><span>box</span> <span>#f</span><span>))</span>
  <span>(</span><span>define</span> <span>solved-fuel</span> <span>(</span><span>box</span> <span>1000</span><span>))</span>
  <span>(</span><span>define</span> <span>threads</span> <span>(</span><span>box</span> <span>&#39;</span><span>()))</span>
  <span>(</span><span>define</span> <span>report-sema</span> <span>(</span><span>make-semaphore</span> <span>1</span><span>))</span>
  <span>(</span><span>define</span> <span>(</span><span>worker</span> <span>fuel</span><span>)</span>
    <span>(</span><span>cond</span>
      <span>[(</span><span>or</span> <span>(</span><span>not</span> <span>(</span><span>unbox</span> <span>solved</span><span>))</span> <span>(</span><span>&lt;</span> <span>fuel</span> <span>(</span><span>unbox</span> <span>solved-fuel</span><span>)))</span>
       <span>(</span><span>define</span> <span>prog</span> <span>(</span><span>synthesize-prog</span> <span>(</span><span>sketch-gen</span> <span>fuel</span><span>)</span> <span>asserts</span><span>))</span>
       <span>(</span><span>call-with-semaphore/enable-break</span> <span>report-sema</span>
        <span>(</span><span>lambda</span> <span>()</span>
          <span>(</span><span>if</span> <span>prog</span>
              <span>(</span><span>begin</span>
                <span>(</span><span>eprintf</span> <span>&#34;sat! ~s~n&#34;</span> <span>fuel</span><span>)</span>
                <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>thd-fuel</span><span>)</span>
                            <span>(</span><span>if</span> <span>(</span><span>&gt;</span> <span>(</span><span>cdr</span> <span>thd-fuel</span><span>)</span> <span>fuel</span><span>)</span>
                                <span>(</span><span>break-thread</span> <span>(</span><span>car</span> <span>thd-fuel</span><span>))</span>
                                <span>(</span><span>void</span><span>)))</span> <span>(</span><span>unbox</span> <span>threads</span><span>))</span>
                <span>(</span><span>if</span> <span>(</span><span>or</span> <span>(</span><span>not</span> <span>(</span><span>unbox</span> <span>solved</span><span>))</span> <span>(</span><span>&lt;</span> <span>fuel</span> <span>(</span><span>unbox</span> <span>solved-fuel</span><span>)))</span>
                    <span>(</span><span>begin</span>
                      <span>(</span><span>set-box!</span> <span>solved-fuel</span> <span>fuel</span><span>)</span>
                      <span>(</span><span>set-box!</span> <span>solved</span> <span>prog</span><span>))</span>
                    <span>(</span><span>void</span><span>)))</span>
              <span>(</span><span>eprintf</span> <span>&#34;unsat! ~s~n&#34;</span> <span>fuel</span><span>))))]))</span>
  <span>(</span><span>define</span> <span>core-sema</span> <span>(</span><span>make-semaphore</span> <span>(</span><span>processor-count</span><span>)))</span>
  <span>(</span><span>for</span> <span>([</span><span>fuel</span> <span>(</span><span>in-range</span> <span>(</span><span>add1</span> <span>max-fuel</span><span>))])</span>
    <span>(</span><span>semaphore-wait</span> <span>core-sema</span><span>)</span>
    <span>(</span><span>define</span> <span>thd</span>
      <span>(</span><span>thread</span> <span>(</span><span>lambda</span> <span>()</span>
                <span>(</span><span>with-handlers</span> <span>([</span><span>exn:break?</span> <span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>void</span><span>))])</span>
                  <span>(</span><span>worker</span> <span>fuel</span><span>))</span>
                <span>(</span><span>semaphore-post</span> <span>core-sema</span><span>))))</span>
    <span>(</span><span>set-box!</span> <span>threads</span> <span>(</span><span>cons</span> <span>(</span><span>cons</span> <span>thd</span> <span>fuel</span><span>)</span> <span>(</span><span>unbox</span> <span>threads</span><span>))))</span>
  <span>(</span><span>for-each</span> <span>(</span><span>lambda</span> <span>(</span><span>thd-fuel</span><span>)</span> <span>(</span><span>thread-wait</span> <span>(</span><span>car</span> <span>thd-fuel</span><span>)))</span> <span>(</span><span>unbox</span> <span>threads</span><span>))</span>
  <span>(</span><span>if</span> <span>(</span><span>not</span> <span>(</span><span>unbox</span> <span>solved</span><span>))</span> <span>(</span><span>void</span><span>)</span>
      <span>(</span><span>begin</span>
        <span>(</span><span>for-each</span> <span>print-insn</span> <span>(</span><span>unbox</span> <span>solved</span><span>))</span>
        <span>(</span><span>flush-output</span><span>))))</span>

<span>(</span><span>define</span> <span>(</span><span>assert-preserve</span> <span>S</span> <span>S*</span> <span>.</span> <span>regs</span><span>)</span>
  <span>(</span><span>define</span> <span>(</span><span>assert-preserve-reg</span> <span>n</span><span>)</span>
    <span>(</span><span>assert</span> <span>(</span><span>bveq</span> <span>(</span><span>state-Rn-ref</span> <span>S</span> <span>n</span><span>)</span> <span>(</span><span>state-Rn-ref</span> <span>S*</span> <span>n</span><span>))))</span>
  <span>(</span><span>for-each</span> <span>assert-preserve-reg</span> <span>regs</span><span>))</span>

<span>; examples</span>
<span>(</span><span>define</span> <span>(</span><span>optimize-8b-rotate-right</span> <span>n</span><span>)</span>
  <span>(</span><span>optimize-prog/parallel</span>
   <span>4</span>
   <span>(</span><span>lambda</span> <span>(</span><span>fuel</span><span>)</span> <span>(</span><span>??prog</span> <span>fuel</span><span>))</span>
   <span>(</span><span>lambda</span> <span>(</span><span>S</span> <span>S*</span><span>)</span>
     <span>(</span><span>assert</span> <span>(</span><span>bveq</span> <span>(</span><span>rotate-right</span> <span>8</span> <span>n</span> <span>(</span><span>state-R0</span> <span>S</span><span>))</span> <span>(</span><span>state-R0</span> <span>S*</span><span>)))</span>
     <span>(</span><span>assert-preserve</span> <span>S</span> <span>S*</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>))))</span>
<span>(</span><span>for</span> <span>([</span><span>n</span> <span>(</span><span>in-range</span> <span>8</span><span>)])</span>
 <span>(</span><span>time</span>
  <span>(</span><span>printf</span> <span>&#34;; rotate right R0 by ~a~n&#34;</span> <span>n</span><span>)</span> <span>(</span><span>flush-output</span><span>)</span>
  <span>(</span><span>optimize-8b-rotate-right</span> <span>n</span><span>)</span>
  <span>(</span><span>printf</span> <span>&#34;; &#34;</span><span>)))</span>

<span>(</span><span>define</span> <span>(</span><span>optimize-16b-rotate-right</span> <span>n</span><span>)</span>
  <span>(</span><span>optimize-prog/parallel</span>
   <span>20</span>
   <span>(</span><span>lambda</span> <span>(</span><span>fuel</span><span>)</span>
    <span>(</span><span>if</span> <span>(</span><span>=</span> <span>fuel</span> <span>0</span><span>)</span> <span>&#39;</span><span>()</span>
      <span>(</span><span>append</span>
       <span>; help the synthesizer out a bit</span>
       <span>(</span><span>list</span> <span>(</span><span>MOV-A-Rn</span> <span>(</span><span>choose*</span> <span>0</span> <span>1</span><span>)))</span>
       <span>(</span><span>??prog</span> <span>fuel</span><span>)</span>
       <span>(</span><span>list</span> <span>(</span><span>MOV-Rn-A</span> <span>(</span><span>choose*</span> <span>0</span> <span>1</span><span>))))))</span>
   <span>(</span><span>lambda</span> <span>(</span><span>S</span> <span>S*</span><span>)</span>
     <span>(</span><span>define</span> <span>R10</span>  <span>(</span><span>concat</span> <span>(</span><span>state-R1</span> <span>S</span> <span>)</span> <span>(</span><span>state-R0</span> <span>S</span> <span>)))</span>
     <span>(</span><span>define</span> <span>R10*</span> <span>(</span><span>concat</span> <span>(</span><span>state-R1</span> <span>S*</span><span>)</span> <span>(</span><span>state-R0</span> <span>S*</span><span>)))</span>
     <span>(</span><span>assert</span> <span>(</span><span>bveq</span> <span>(</span><span>rotate-right</span> <span>16</span> <span>n</span> <span>R10</span><span>)</span> <span>R10*</span><span>))</span>
     <span>(</span><span>assert-preserve</span> <span>S</span> <span>S*</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>))))</span>
<span>(</span><span>for</span> <span>([</span><span>n</span> <span>(</span><span>in-range</span> <span>16</span><span>)])</span>
 <span>(</span><span>time</span>
  <span>(</span><span>printf</span> <span>&#34;; rotate right R1:R0 by ~a~n&#34;</span> <span>n</span><span>)</span> <span>(</span><span>flush-output</span><span>)</span>
  <span>(</span><span>optimize-16b-rotate-right</span> <span>n</span><span>)</span>
  <span>(</span><span>printf</span> <span>&#34;; &#34;</span><span>)))</span>
</pre></td>
</tr></tbody></table></code></pre></figure>



<p>Generating the optimal 8-bit and 16-bit rotates took about half a day on a modern laptop (Dell XPS13 9360, using all cores and with mitigations disabled). Because of that I have not attempted generating wider ones so far.</p>

<h2 id="bit-rotates">8-bit rotates</h2>

<p>The following code lists all optimal 8-bit rotates, by 0 to 7 bits.</p>

<figure><figcaption>rot8.asm (<a href="https://lab.whitequark.org/files/synth51/rot8.asm">download</a>)</figcaption><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td>
<td><pre>; rotate right R0 by 0
; rotate right R0 by 1
MOV A, R0
RR A
MOV R0, A
; rotate right R0 by 2
MOV A, R0
RR A
RR A
MOV R0, A
; rotate right R0 by 3
XCH A, R0
RL A
SWAP A
MOV R0, A
; rotate right R0 by 4
MOV A, R0
SWAP A
MOV R0, A
; rotate right R0 by 5
MOV A, R0
SWAP A
RR A
XCH A, R0
; rotate right R0 by 6
MOV A, R0
RL A
RL A
MOV R0, A
; rotate right R0 by 7
MOV A, R0
RL A
MOV R0, A
</pre></td>
</tr></tbody></table></code></pre></figure>

<h2 id="bit-rotates-1">16-bit rotates</h2>

<p>The following code lists all optimal 16-bit rotates, by 0 to 15 bits. I find the approach the solver used for the rotate by 10 nothing short of brilliant, and the approach it took for rotate by 3/5/11/13 pretty neat as well.</p>

<figure><figcaption>rot16.asm (<a href="https://lab.whitequark.org/files/synth51/rot16.asm">download</a>)</figcaption><pre><code><table><tbody><tr>
<td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
</pre></td>
<td><pre>; rotate right R1:R0 by 0
; rotate right R1:R0 by 1
MOV A, R1
MOV C, ACC.0
XCH A, R0
RRC A
XCH A, R0
RRC A
MOV R1, A
; rotate right R1:R0 by 2
MOV A, R1
MOV C, ACC.0
XCH A, R0
RRC A
XCH A, R0
RRC A
MOV C, ACC.0
XCH A, R0
RRC A
XCH A, R0
RRC A
MOV R1, A
; rotate right R1:R0 by 3
MOV A, R0
XRL A, R1
MOV R1, A
ANL A, #0xf8
XRL A, R0
SWAP A
RL A
XCH A, R1
SWAP A
RL A
XRL A, R1
MOV R0, A
; rotate right R1:R0 by 4
MOV A, R0
XRL A, R1
ANL A, #0xf0
XCH A, R1
XRL A, R1
SWAP A
XCH A, R0
XRL A, R1
SWAP A
MOV R1, A
; rotate right R1:R0 by 5
MOV A, R1
XRL A, R0
ANL A, #0x1f
XCH A, R0
XRL A, R0
RR A
SWAP A
XCH A, R0
XRL A, R1
SWAP A
RR A
MOV R1, A
; rotate right R1:R0 by 6
MOV A, R1
RLC A
XCH A, R0
RLC A
XCH A, R1
RLC A
MOV C, ACC.7
XCH A, R1
RLC A
XCH A, R1
RLC A
MOV R0, A
; rotate right R1:R0 by 7
MOV A, R0
MOV C, ACC.7
MOV A, R1
RLC A
XCH A, R0
RLC A
MOV R1, A
; rotate right R1:R0 by 8
MOV A, R1
XCH A, R0
MOV R1, A
; rotate right R1:R0 by 9
MOV A, R1
RRC A
MOV A, R0
RRC A
XCH A, R1
RRC A
MOV R0, A
; rotate right R1:R0 by 10
MOV A, R1
XRL A, R0
ANL A, #0x3
XRL A, R1
RR A
RR A
XCH A, R0
XRL A, R1
RR A
RR A
XRL A, R0
MOV R1, A
; rotate right R1:R0 by 11
MOV A, R1
XRL A, R0
MOV R1, A
ANL A, #0x7
XRL A, R0
RL A
SWAP A
XCH A, R1
RL A
SWAP A
XRL A, R1
MOV R0, A
; rotate right R1:R0 by 12
MOV A, R0
XRL A, R1
ANL A, #0xf0
XCH A, R1
XRL A, R1
SWAP A
XCH A, R1
XRL A, R0
SWAP A
MOV R0, A
; rotate right R1:R0 by 13
MOV A, R1
XRL A, R0
ANL A, #0xe0
XCH A, R0
XRL A, R0
SWAP A
RR A
XCH A, R0
XRL A, R1
RR A
SWAP A
MOV R1, A
; rotate right R1:R0 by 14
MOV A, R1
MOV C, ACC.7
XCH A, R0
RLC A
XCH A, R0
RLC A
MOV C, ACC.7
XCH A, R0
RLC A
XCH A, R0
RLC A
MOV R1, A
; rotate right R1:R0 by 15
MOV A, R1
MOV C, ACC.7
XCH A, R0
RLC A
XCH A, R0
RLC A
MOV R1, A
</pre></td>
</tr></tbody></table></code></pre></figure>

        </section>
      </article></div>
  </body>
</html>
