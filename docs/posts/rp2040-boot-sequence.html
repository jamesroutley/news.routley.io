<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vanhunteradams.com/Pico/Bootloader/Boot_sequence.html">Original</a>
    <h1>RP2040 Boot Sequence</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<div>
<h3 id="What-happens-between-applying-power-to-an-RP2040,-and-main()-getting-executed?">What happens between applying power to an RP2040, and <code>main()</code> getting executed?<a href="#What-happens-between-applying-power-to-an-RP2040,-and-main()-getting-executed?">¶</a></h3><h4 id="V.-Hunter-Adams"><a href="https://vanhunteradams.com">V. Hunter Adams</a><a href="#V.-Hunter-Adams">¶</a></h4>
</div>
</div>
</div><div><div>
<div>
<h2 id="What&#39;s-in-this-document?">What&#39;s in this document?<a href="#What&#39;s-in-this-document?">¶</a></h2><p>This document has been assembled to supplement a set of instructions about writing one&#39;s own bootloader for the RP2040. Writing a bootloader requires some understanding of the boot sequence, but it became a bit too cumbersome to include that explanation in the bootloader documentation.</p>
<p>In this document, I&#39;ve attempted to walk through everything that happens between applying power to an RP2040 and the first line of <code>main()</code> being executed. Some of these steps are covered in more depth than others, but I&#39;ve attempted to at least enumerate each one. The steps with extensive explanations are those which are of most relevance for writing one&#39;s own bootloader. These include the exit from boot2 process, and the interaction between the reset handler and the linker script. The parts of the boot sequence that the programmer is unlikely or unable to modify (bootROM code, and the stage 2 bootloader which configures the external flash chip) are given a more cursory treatment.</p>
<h3 id="Contents">Contents<a href="#Contents">¶</a></h3><blockquote><ul>
<li><a href="#RP2040-boot-sequence">RP2040 boot sequence</a><blockquote><ul>
<li><a href="#Hardware-controlled-boot-sequence">Hardware-controlled boot sequence</a></li>
<li><a href="#Processor-controlled-boot-sequence">Processor-controlled boot sequence</a></li>
<li><a href="#Boot-stage-2">Boot stage 2</a></li>
<li><a href="#Exit-from-boot-stage-2">Exit from boot stage 2</a></li>
<li><a href="#The-Reset-Handler">The Reset Handler</a><blockquote><ul>
<li><a href="#Brief-tangent-on-linker-scripts">Brief tangent on linker scripts</a></li>
<li><a href="#Back-to-the-reset-handler">Back to the reset handler</a></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>

</div>
</div>
</div><div><div>
<div>
<h2 id="RP2040-boot-sequence">RP2040 boot sequence<a href="#RP2040-boot-sequence">¶</a></h2><p>The RP2040 datasheet separates the boot sequence into the &#34;hardware-controlled&#34; section which happens <em>before</em> the processors begin executing the bootrom, and the &#34;processor-controlled&#34; section during which processor cores 0 and 1 begin to execute the bootrom. The second stage of the bootloader (which lives at the beginning of the user&#39;s program) then runs <em>after</em> the bootrom.</p>
<p>Let us consider each of these steps in turn, and then we&#39;ll add another step to this process.</p>
<h3 id="Hardware-controlled-boot-sequence">Hardware-controlled boot sequence<a href="#Hardware-controlled-boot-sequence">¶</a></h3><p>The hardware-controlled boot sequence is responsible for safely turning on the minimum number of peripherals that are required for the processors to begin executing code. Starting from a totally powered-off RP2040, the sequence is as follows:</p>
<ol>
<li>Power is applied to the chip, and the <code>RUN</code> pin is high. The chip will be <em>held in reset</em> for as long as <code>RUN</code> is not high.</li>
<li>The RP2040&#39;s on-chip voltage regulator automatically powers on as soon as an input supply is available. The system waits until the digital core supply (DVDD) which comes from this voltage regulator is stable.</li>
<li>The Power-On State Machine starts. Various hardware blocks and peripherals must be powered on in a particular order for everything to startup properly, since some require that others are already running (for example, we don&#39;t want to start the clock generators until we have a stable clock source). The power-on state machine brings a series of peripherals out of reset in a safe order. In particular:<blockquote><ul>
<li>The ring oscillator is started. Once it&#39;s stable . . .</li>
<li>The crystal oscillator is reset (though not yet started, this occurs in <code>runtime_init</code>)</li>
<li>The <code>clk_ref</code> and <code>clk_sys</code> clock generators are brought out of reset. <code>clk_ref</code> runs using the ring oscillator with no divider, and <code>clk_sys</code> runs from <code>clk_ref</code>. In other words, we start clocking the system off the ring oscillator.</li>
<li>The reset controller resets all non-boot peripherals</li>
<li>The system checks some registers to confirm the boot state of the chip, and whether there&#39;s an invalid program in flash</li>
<li>The system brings XIP, ROM/SRAM, and the bus fabric out of reset</li>
<li>The system brings the processors out of reset, which begin executing bootcode from ROM</li>
</ul>
</blockquote>
</li>
</ol>
<figure>
    <img width="500" height="500" src="https://vanhunteradams.com/Pico/Bootloader/power_on.png" alt="missing"/>
    <center><figcaption>Power-on state machine (from RP2040 datasheet)</figcaption></center>
</figure><p>This is a <em>fully automated process</em>. This whole sequence comes baked into the RP2040 and requires no input from the user to work. There exist some registers that user software can use to override and check the status of the power-on state machine, or the user can configure a watchdog to restart the power-on state machine, but user code does not include this process nor overwrite it when we reprogram the chip.</p>
<h3 id="Processor-controlled-boot-sequence">Processor-controlled boot sequence<a href="#Processor-controlled-boot-sequence">¶</a></h3><p>The processor-controlled boot sequence runs from ROM. This sequence too is &#34;baked in&#34; to the RP2040 when we purchase it. This sequence is summarized in the flowchart below. This sequence begins on line 225 of <a href="https://github.com/raspberrypi/pico-bootrom/blob/master/bootrom/bootrom_rt0.S">this file from the bootrom</a> and it concludes in <code>main()</code> of <a href="https://github.com/raspberrypi/pico-bootrom/blob/master/bootrom/bootrom_main.c">this file</a>. In brief, the RP2040 reads the <code>SIO_CPUID1</code> register to confirm that it is core 0. If it&#39;s not core 0, it stalls and waits to be started by core 0. If it <em>is</em> core 0, then it proceeds to the next step of the process. In the event that the rescue flag is set, the core halts to wait for instruction from a debugger. Otherwise, the core checks the watchdog scratch registers for some magic numbers to see whether it should boot to some code loaded into SRAM. If it finds those magic numbers, it vectors to that code. If not, it branches to <code>main()</code> in <code>bootrom_main.c</code>.</p>
<p>In the event that the user is <em>not</em> holding down the <code>BOOTSEL</code> button, the RP2040 will attempt a flash boot. To do so, it initializes the SSI channel over which it communicates with external flash memory and associates a particular set of GPIO&#39;s with that channel. Then, it starts looking for the start of a valid application! It does so by repeatedly loading the first 256 bytes from flash memory to SRAM using all possible combinations of SSI clock phase and polarity. For each attempt, it computes a checksum to see if it read a valid boot2 second stage in flash memory (it tries all combinations because it doesn&#39;t know precisely which external chip it might be communicating with, and different ones may use different modes).</p>
<p>In the event that it finds a valid boot2, it branches to the boot2 entry point! Otherwise, it enters the USB device mode to wait for a new program from the user over the USB interface.</p>
<figure>
    <img width="500" height="500" src="https://vanhunteradams.com/Pico/Bootloader/processor_controlled.png" alt="missing"/>
    <center><figcaption>Processor-controlled boot sequence (from RP2040 datasheet)</figcaption></center>
</figure><h3 id="Boot-stage-2">Boot stage 2<a href="#Boot-stage-2">¶</a></h3><p>The RP2040 stores its program code in <em>external</em> flash memory, and it is compatible with a number of different external flash chips. All compatible chips use a QSPI interface, which allows for the bootrom to copy the first 256 bytes of flash memory (where the boot2 code lives) into SRAM. This bootcode is executed from SRAM because the rest of flash remains inaccessible to the XIP address window until some further (flash-chip-specific) configurations are performed. These configurations are the responsibility of the boot2 code.</p>
<p>If you look in the SDK, you&#39;ll find a <a href="https://github.com/raspberrypi/pico-sdk/tree/master/src/rp2_common/boot_stage2">whole library</a> of different <em>versions</em> of boot2. Each of these versions corresponds to a different flash memory chip, and each is <em>exactly</em> 256 bytes long (padded if need be). At compile-time, the compiler checks a flag to determine which flash memory chip is being used and loads the appropriate boot2 code. <em>This is why boot2 isn&#39;t baked into ROM.</em> We need for the programmer to be able to select the right configurations for their particular flash chip, which wouldn&#39;t be possible if the code came baked in. You&#39;ll find these flags in the <a href="https://github.com/raspberrypi/pico-sdk/tree/master/src/boards/include/boards">board files</a> for RP2040-based boards. For instance, the <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/boards/include/boards/pico.h">pico.h</a> file specifies <code>PICO_BOOT_STAGE2_CHOOSE_W25Q080 1</code>. This is a message to the compiler to please select the <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/boot_stage2/boot2_w25q080.S">particlar boot2 program</a> associated with the W25Q080 flash chip. In brief, it configures the SSI and flash chip to enable continuous reads without any prefixes, which maximizes the speed at which these reads can occur.</p>
<h3 id="Exit-from-boot-stage-2">Exit from boot stage 2<a href="#Exit-from-boot-stage-2">¶</a></h3><p>The last code that runs in boot stage 2 is that which is contained in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/boot_stage2/asminclude/boot2_helpers/exit_from_boot2.S">exit_from_boot.S</a>. I&#39;m considering this separately because it&#39;s of particular interest for illustrating how user application code starts getting executed. The code is copied below:</p>

<pre><code>armasm
// If entered from the bootrom, lr (which we earlier pushed) will be 0,
// and we vector through the table at the start of the main flash image.
// Any regular function call will have a nonzero value for lr.
check_return:
    pop {r0}
    cmp r0, #0
    beq vector_into_flash
    bx r0
vector_into_flash:
    ldr r0, =(XIP_BASE + 0x100)
    ldr r1, =(PPB_BASE + M0PLUS_VTOR_OFFSET)
    str r0, [r1]
    ldmia r0, {r0, r1}
    msr msp, r0
    bx r1</code></pre>
<p>This exit routine does the following:</p>
<p><code>check_return</code>:</p>
<ol>
<li>Pop a value from the stack into register <code>r0</code></li>
<li>Compare the value in register <code>r0</code> with 0.</li>
<li>If the value in register <code>r0</code> is <strong>nonzero</strong>, interpret that value as an address and branch to it.</li>
<li>Otherwise, branch to <code>vector_in_flash</code>.</li>
</ol>
<p><code>vector_into_flash</code>:</p>
<ol>
<li>Load <code>(XIP_BASE + 0x100)</code> into register <code>r0</code>. <blockquote><ul>
<li>Note that <code>XIP_BASE</code> represents the base address of execute-in-place memory, and is defined to be <code>0x10000000</code> in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2040/hardware_regs/include/hardware/regs/addressmap.h">addressmap.h</a>. This is in agreement with the address map provided on page 24 of the <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040 datasheet</a>.</li>
<li>An offset of <code>0x100</code> from this base address puts us exactly 256 bytes after the base address. In other words, we&#39;re loading the first address <em>after</em> the 256-byte stage 2 bootloader. If you take a look at the <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_standard_link/memmap_default.ld">linker script</a>, you&#39;ll notice that the <em>first</em> thing which appears after boot2 is the vector table. This vector table lives in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_standard_link/crt0.S"><code>crt0.s</code></a>. Per standard ARM convention, the first element of the vector table is the main stack pointer, and the second element of the vector table is the address of the reset handler.</li>
</ul>
</blockquote>
</li>
<li>Load <code>(PPB_BASE + M0PLUS_VTOR_OFFSET)</code> into register <code>r1</code>.<blockquote><ul>
<li>Like the <code>XIP_BASE</code>, <code>PPB_BASE</code> is defined in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2040/hardware_regs/include/hardware/regs/addressmap.h">addressmap.h</a>. This represents the base address of the Cortex M0+, and is defined as <code>0xe0000000</code>, which agrees with the address map provided on page 24 of the <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040 datasheet</a>. </li>
<li>Furthermore, <code>M0PLUS_VTOR_OFFSET</code>, defined in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2040/hardware_regs/include/hardware/regs/m0plus.h"><code>m0plus.h</code></a>, is set to <code>0x0000ed08</code>. This agrees with page 86 of the <a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf">RP2040 datasheet</a>, which indicates that the VTOR register (which holds the vector table offset address) lives at an offset of 0xED08 from the PPB base address.</li>
</ul>
</blockquote>
</li>
<li>Store the value <em>in</em> <code>r0</code> to the memory location <em>pointed to</em> by <code>r1</code>. This sets the value in the VTOR register to the <em>address</em> of the vector table.</li>
<li>Load the value <em>from</em> memory address <em>pointed to</em> by <code>r0</code> (top of the vector table) into register <code>r0</code>, then increment by 1 load the data from the <em>next</em> address into <code>r1</code>. The data now contained in <code>r0</code> is the stack pointer address, and the value now contained in <code>r1</code> is the address of the reset handler.</li>
<li>Move the value <em>in</em> <code>r0</code> to the main stack pointer (sets up stack pointer)</li>
<li>Branch to the address stored in <code>r1</code>. This takes us to the reset handler.</li>
</ol>
<p>We&#39;re going to consider the reset handler next. But it&#39;s <em>this</em> exit sequence which best informs how we vector into user application code. As long as our application code linker script is organized in accordance with ARM Cortex M0+ conventions, then we can vector to that code by setting the main stack pointer, setting the VTOR register, and branching to the reset handler. It&#39;s this reset handler which ultimately then branches to <code>main()</code> in the user&#39;s program.</p>
<h3 id="The-Reset-Handler">The Reset Handler<a href="#The-Reset-Handler">¶</a></h3><p>Generally speaking, every microcontroller will contain (at least) two types of memory: flash and RAM. Flash memory is non-volatile (information is retained through power cycles), it is generally <em>static</em> (that is, not being updated as the program is running), and there is generally <em>more of it</em> than RAM. RAM, on the other hand, is <em>volatile</em> memory (it loses information when power is removed). Because microcontrollers retain their programs through power cycles, it may stand to reason that our program code is stored in flash memory (at least initially). RAM is of critical importance for these programs to run, however! It is in RAM that we store our program variables with values that get updated as the program runs.</p>
<p>When we load a new program onto the microcontroller via some sort of flash programmer, it only re-programs the flash. Before the new program which we&#39;ve loaded into flash can execute, however, the microcontroller must initialize RAM. Because RAM is volatile, it must perform this initialization every time the system boots up.</p>
<p><em>This initialization is the responsibility of the reset handler</em>. The reset handler copies relevant sections of data from flash memory into RAM (we&#39;ll talk about these in more detail in just a moment), initializes other sections of RAM, and then executes a platform entry. This platform entry involves branching to a runtime initialization function that starts-up necessary peripherals, and then branching the user user application&#39;s <code>main</code> function.</p>
<p>Before we can have an informed discussion about the RP2040&#39;s reset handler, we must go on a brief tangent about <em>linker scripts</em> and <em>memory organization.</em></p>
<h4 id="Brief-tangent-on-linker-scripts">Brief tangent on linker scripts<a href="#Brief-tangent-on-linker-scripts">¶</a></h4><p>A translation process occurs to transform the source code which we humans write to the machine code that the microcontroller runs. This process begins with the compiler, which takes our source code (e.g. C programs) as input, and generates machine code in the form of <em>object files</em> as an output. These object files are generated into different <em>sections</em>. The details of these sections depend on the object format used by the compiler, but a very common one is the Executable Linkable Format (ELF). A compiler which uses the ELF object file format will generate object files in the following sections:</p>
<ul>
<li><code>.text</code>: Executable code $\longrightarrow$ generally in flash, unless copied to RAM (possible on RP2040)</li>
<li><code>.data</code>: Initialized data (i.e. variables) $\longrightarrow$ RAM</li>
<li><code>.bss</code> : Uninitizialized data (i.e. variables) $\longrightarrow$ RAM</li>
<li><code>.const</code>: Constant data (and the original home of initialized data which will be copied to <code>.data</code>) $\longrightarrow$ flash</li>
</ul>
<p>The object files generated by the compiler do not yet have associated memory addresses in the target microcontroller. It&#39;s the job of the <em>linker script</em> to organize the object files generated by the compiler in accordance with the memory layout for the target microcontroller as specified (generally) by that microcontroller&#39;s datasheet. It specifies things like the location and size of flash and RAM, the location of the stack and heap, where .bss should be initialized, etc.</p>
<p>Let&#39;s take a look at the RP2040&#39;s <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_standard_link/memmap_default.ld">default linker script</a> to see how this works. At the top of the linker script, we find the memory layout specified:</p>

<pre><code>linker
MEMORY
{
    FLASH(rx) : ORIGIN = 0x10000000, LENGTH = 2048k
    RAM(rwx) : ORIGIN =  0x20000000, LENGTH = 256k
    SCRATCH_X(rwx) : ORIGIN = 0x20040000, LENGTH = 4k
    SCRATCH_Y(rwx) : ORIGIN = 0x20041000, LENGTH = 4k
}</code></pre>
<p>This specifies the <em>base address</em> (i.e. ORIGIN) of each relevant section of memory, the readability/writability/executability of that part of memory, and the length of that part of memory. So, for instance, we see that flash memory starts at address 0x10000000, and that it is 2048 kilobytes long. RAM starts at 0x20000000 and is 256 kilobytes long. The subsequent section of the linker script (the <code>SECTIONS</code> section) organizes all of the object files generated by the compiler according to this memory layout. <strong>By the way</strong>, if we wanted to store our program code <em>elsewhere</em> in flash (say, because we had to put it above a custom bootloader), we could do so by simply adjusting the origin and length of the FLASH part of the memory layout.</p>
<p>Each of those object files created by the compiler will contain some or all of the sections mentioned previously (<code>.text</code>, <code>.data</code>., <code>.bss</code>., etc.). The SECTIONS part of the linker script organizes all those input sections into output sections, and places those output sections in memory. We could absolutely do this by naming every single section from every single object file, but that doesn&#39;t scale very well. So, we&#39;ll use some shortcuts.</p>
<p>But let&#39;s begin by looking at the very top of the SECTIONS part of the linker script, where we will find the stage 2 bootlaoder (remember that this <em>must</em> live in the first 256 bytes of flash). Every code snippet in the rest of this section lives in the SECTIONS { } part of the linker.</p>

<pre><code>    .flash_begin : {
        __flash_binary_start = .;
    } &gt; FLASH

    .boot2 : {
        __boot2_start__ = .;
        KEEP (*(.boot2))
        __boot2_end__ = .;
    } &gt; FLASH</code></pre>
<p>The first stanza creates an output section called <code>.flash_begin</code>, but it doesn&#39;t actually load anything into flash! All that it does is set the value of a <em>symbol</em> (essentially a variable, which will be accessible by our reset handler) to &#34;.&#34;. The dot, in the context of the linker script, represents the <em>current memory address</em> in the linker script. Because we haven&#39;t loaded anything into memory yet, this dot represents the base address of flash memory. We store this base address in a symbol called <code>__flash_binary_start</code>.</p>
<p>The second stanza creates an output section called <code>.boot2</code>. We associate a symbol with the start of the <code>.boot2</code> section, and then we use an escape character to ask the linker to please load all object files with names including &#34;.boot2&#34; to flash memory at this address. We can confirm that everything is going to the expected places in memory by looking at the <em>map file</em> (one of the outputs of the linker). The map file specifies precisely what lives at every address in memory. I can&#39;t provide a link to the map file, because it&#39;s generated by the compiler when you compile your code. Here, for instance, is a snippet from the map file for the blinky demo:</p>

<pre><code>.flash_begin    0x0000000010000000        0x0
                0x0000000010000000                __flash_binary_start = .

.boot2          0x0000000010000000      0x100
                0x0000000010000000                __boot2_start__ = .
 *(.boot2)
 .boot2         0x0000000010000000      0x100 
                0x0000000010000100                __boot2_end__ = .
                0x0000000000000001</code></pre>
<p>We see that the flash binary start is at address <code>0x0000000010000000</code>, and that the first item loaded into flash memory, at that base address, is <code>.boot2</code>. We also see that the address associated with <code>__boot2_end__</code> is <code>0x0000000010000100</code>, or precisely 256 bytes above the base address.</p>
<p>Looking back at the linker file, the next output section which is loaded (still into flash) is .text, pasted below. Just below boot2, we load the vector table, followed by the binary info header, followed by the reset handler. After the reset handler is the .text sections of all object files (sans a few exclusions), followed by our constructors and destructors.</p>

<pre><code>linker
.text : {
        __logical_binary_start = .;
        KEEP (*(.vectors))
        KEEP (*(.binary_info_header))
        __binary_info_header_end = .;
        KEEP (*(.reset))
        *(.init)
        *(EXCLUDE_FILE(*libgcc.a: *libc.a:*lib_a-mem*.o *libm.a:) .text*)
        *(.fini)
        /* Pull all c&#39;tors into .text */
        *crtbegin.o(.ctors)
        *crtbegin?.o(.ctors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        /* Followed by destructors */
        *crtbegin.o(.dtors)
        *crtbegin?.o(.dtors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        *(.eh_frame*)
        . = ALIGN(4);
    } &gt; FLASH</code></pre>
<p>If you look back at the map file, you&#39;ll find the vector table immediately after boot2, followed by the binary info header, followed by reset, etc. In other words, the map file is showing us a memory layout that precisely matches that which we specified in the linker script. This pattern continues. Jumping ahead a little in the linker script, I&#39;d like to consider the <code>.data</code> section. Remember, this is the section which contains <em>initialized</em> variables which will by dynamically updated as the program runs. So, the contents of this section will need to be copied into RAM when the system boots up, but of course the flash loader cannot write to RAM. Let&#39;s look at how the linker handles this:</p>

<pre><code>    .data : {
        __data_start__ = .;
        *(vtable)

        *(.time_critical*)

        /* remaining .text and .rodata; i.e. stuff we exclude above because we want it in RAM */
        *(.text*)
        . = ALIGN(4);
        *(.rodata*)
        . = ALIGN(4);

        *(.data*)

        . = ALIGN(4);
        *(.after_data.*)
        . = ALIGN(4);
        /* preinit data */
        PROVIDE_HIDDEN (__mutex_array_start = .);
        KEEP(*(SORT(.mutex_array.*)))
        KEEP(*(.mutex_array))
        PROVIDE_HIDDEN (__mutex_array_end = .);

        . = ALIGN(4);
        /* preinit data */
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP(*(SORT(.preinit_array.*)))
        KEEP(*(.preinit_array))
        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);
        /* init data */
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))
        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);
        /* finit data */
        PROVIDE_HIDDEN (__fini_array_start = .);
        *(SORT(.fini_array.*))
        *(.fini_array)
        PROVIDE_HIDDEN (__fini_array_end = .);

        *(.jcr)
        . = ALIGN(4);
        /* All data end */
        __data_end__ = .;
    } &gt; RAM AT&gt; FLASH
    /* __etext is (for backwards compatibility) the name of the .data init source pointer (...) */
    __etext = LOADADDR(.data);</code></pre>
<p>Note that the specified address for the output section is <code>&gt; RAM AT&gt; FLASH</code>. What this means is that this output section will be <em>loaded into flash</em> at the address given by the symbol <code>__etext</code> in the snippet above. The reset handler will then copy this section to RAM, such that it lives between addresses <code>__data_start__</code> and <code>__data_end__</code>. This is the second section loaded into RAM, so it will appear just underneath the first (which happens to be a copy of the vector table, copied to the beginning of RAM). Referring back to the map file once again, we can see that this is the case:</p>

<pre><code>.ram_vector_table
                0x0000000020000000       0xc0
 *(.ram_vector_table)
 .ram_vector_table
                0x0000000020000000       0xc0 
                0x0000000020000000                ram_vector_table

.data           0x00000000200000c0      0x18c load address 0x0000000010001e7c
                0x00000000200000c0                __data_start__ = .</code></pre>
<p>The RAM vector table lives at the very bottom of RAM, and is followed immediately after by the <code>.data</code> section. But not that <code>.data</code> has a <em>load address</em> within flash. This load address is available to our reset handler via that <code>__etext</code> symbol. The reset handler&#39;s first job will be to copy the contents of this <code>.data</code> section from flash to the appropriate place in RAM. Then, it&#39;ll clear the <code>.bss</code> section (uninitialized variables). Then it&#39;ll start performing platform entry.</p>
<h4 id="Back-to-the-reset-handler">Back to the reset handler<a href="#Back-to-the-reset-handler">¶</a></h4><p>The RP2040 reset handler lives in <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_standard_link/crt0.S">crt0.S</a>. Please note that the RP2040 supports a few different boot options, which allow for the user to force executable code into RAM for faster execution. For sake of simplifying this explanation, I&#39;m going to consider the &#34;normal&#34; situation in which executable code lives in flash memory. For that reason, you may notice that I omit some conditionals associated with the &#34;run from flash&#34; mode when I copy snippets from crt0.S into this document.</p>
<p>Let us consider each phase of the reset handler in turn.</p>
<p><strong>1. CPU check</strong>: The first reset handler code which runs is copied below. The RP2040 is a dual-core microcontroller, with <em>two</em> internal ARM Cortex M0&#39;s. These two cores are named CPU 0 and CPU 1. All of the initialization occurs on CPU 0, while CPU 1 is held in a dormant state until CPU 0 wakes and initializes it (the subject of a future discussion). So, the first thing that the reset handler does is make sure that it is indeed CPU 0. It can do so by reading the CPUID register, which contains a 0 for CPU0 and a 1 for CPU1.</p>

<pre><code>armasm
type _reset_handler,%function
.thumb_func
_reset_handler:
    // Only core 0 should run the C runtime startup code; core 1 is normally
    // sleeping in the bootrom at this point but check to be sure
    ldr r0, =(SIO_BASE + SIO_CPUID_OFFSET)
    ldr r0, [r0]
    cmp r0, #0
    bne hold_non_core0_in_bootrom</code></pre>
<p>Note that this CPU check is a defensive maneuver. CPU 1 should never even be able to make it out of ROM, but this code is meant to catch it in the event that it does. The above code loades the value <code>(SIO_BASE + SIO_CPUID_OFFSET)</code> into register <code>r0</code>. This is the address of the CPUID register. It then loads the value contained at the memory address pointed to by <code>r0</code> into <code>r0</code>. This will be 0 for CPU0, and 1 for CPU1. It then compares this value to 0. In the event that the value in <code>r0</code> (the CPUID) is not equal to 0, the code branches to <code>hold_non_core0_in_bootrom</code>. This keeps CPU1 in standby until CPU0 wakes it. Otherwise, if the value in <code>r0</code> <em>is</em> 0, then we fall thru to the next step of the reset handler.</p>
<p><strong>2. Perform <code>.data</code> copy</strong>: The next step of the bootloader is to copy the <code>.data</code> section, the <code>.scratch_x</code> section, and the <code>.scratch_y</code> section from flash to RAM. It does this by making use of those symbols which we created in the linker script, which specify the start and end addresses for each of these sections in RAM, and which specify the load addresses of each of these sections in flash. All of these addresses are organized into something called the <code>data_cpy_table</code>, which is pasted below:</p>

<pre><code>.align 2
data_cpy_table:
.word __etext
.word __data_start__
.word __data_end__

.word __scratch_x_source__
.word __scratch_x_start__
.word __scratch_x_end__

.word __scratch_y_source__
.word __scratch_y_start__
.word __scratch_y_end__

.word 0 // null terminator</code></pre>
<p>This table contains 10 words. The first 3 words represent the load address of the <code>.data</code> section in flash (remember that symbol name <code>__extext</code> from the linker script?), the start address for the <code>.data</code> section in RAM, and the end address for the <code>.data</code> section in RAM. The reset handler will start at the address <code>__etext</code> in flash, and copy data to RAM starting at the address given by <code>__data_start__</code>. It&#39;ll keep going until it hits the address <code>__data_end__</code>. Then, it&#39;ll go through exactly the same process for the two subsequent scratch sections. The null terminator at the end of the table is used to indicate the <em>end</em> of the table. Let&#39;s now look at how the reset handler implements this copying.</p>
<p>After falling thru the CPUID check above, we hit this snippet of code:</p>

<pre><code>    adr r4, data_cpy_table
1:
    ldmia r4!, {r1-r3}
    cmp r1, #0
    beq 2f
    bl data_cpy
    b 1b</code></pre>
<p>This snippet loads the address of the base of the <code>data_cpy_table</code> into register <code>r4</code>. If you look at the table above, this corresponds to the address of the <em>first word</em> in the table, which is that of <code>__etext</code>, or the load address of the <code>.data</code> section.</p>
<p>The next instruction then loads the value at the memory address pointed to by <code>r4</code> into <code>r1</code> (<code>__etext</code>), then increments <code>r4</code>. It loads the data at the <em>new</em> address pointed to by <code>r4</code> into <code>r2</code> (<code>__data_start__</code>, the next word in the table), and then increments <code>r4</code> again. It then loads the data at the <em>new</em> address pointed to by <code>r4</code> into <code>r3</code> (<code>__data_end__</code>, the next word in the table).</p>
<p>The next instruction compares the value in <code>r1</code> to 0. If the two are equal, it means that we&#39;ve reached the null terminator in the <code>data_cpy_table</code> and we jump to the program label 2 (we&#39;ll get to that in a moment). But if they aren&#39;t! Then we jump and link to a program label called <code>data_cpy</code>. Lets look at the code at the <code>data_cpy</code> program label:</p>

<pre><code>data_cpy_loop:
    ldm r1!, {r0}
    stm r2!, {r0}
data_cpy:
    cmp r2, r3
    blo data_cpy_loop
    bx lr</code></pre>
<p>The first thing that happens in <code>data_cpy</code> is that we compare <code>r2</code> and <code>r3</code>. Remember that <code>r2</code> contains the start address, in RAM, for the <code>.data</code> section, and <code>r3</code> contains the end address. In the event that <code>r2</code> is less than <code>r3</code>, we branch to the <code>data_cpy</code> loop.</p>
<p>The <code>data_cpy</code> loop loads the value from the memory address pointed to by <code>r1</code> into <code>r0</code>, and auto-increments <code>r1</code>. It then stores the value from <code>r0</code> to the memory address pointed to by <code>r2</code>, and auto-increments <code>r2</code>. This means that <code>r2</code>, the address <em>to which we are copying</em> has moved closer to <code>r3</code>, the address at which we <em>stop</em> copying.</p>
<p>The program falls back thru to the <code>data_cpy</code> program label, and the process continues until <code>r2</code> and <code>r3</code> are equal. That is, until we&#39;ve copied all the data to our designated stop-point, as given by the linker script. Once that&#39;s the case, we branch <em>back</em> to the link register, which takes us back up to the <code>1</code> program label above. As before, this loads the value at the memory address pointed to by <code>r4</code> into <code>r1</code> (<code>__scratch_x_source__</code>), then increments <code>r4</code>. It loads the data at the <em>new</em> address pointed to by <code>r4</code> into <code>r2</code> (<code>__scratch_x_start__</code>, the next word in the table), and then increments <code>r4</code> again. It then loads the data at the <em>new</em> address pointed to by <code>r4</code> into <code>r3</code> (<code>__scratch_x_end__</code>, the next word in the table). As before, we compare the value in <code>r1</code> to 0. If the two are equal, it means that we&#39;ve reached the null terminator in the <code>data_cpy_table</code> and we jump to the program label 2 (still not there). Otherwise, we jump <em>back</em> to the <code>data_cpy</code> label to copy this <em>next</em> section of data.</p>
<p>This process then repeats one more time to copy the final <code>.scratch_y</code> section from flash to RAM, after which the first instruction in the 1 program label will load the null terminator into <code>r1</code>. This is our signal that we&#39;ve reached the end of the <code>data_cpy_table</code>, and so we take the branch to the program label 2. Let&#39;s see what happens there:</p>

<pre><code>2:
    // Zero out the BSS
    ldr r1, =__bss_start__
    ldr r2, =__bss_end__
    movs r0, #0
    b bss_fill_test
bss_fill_loop:
    stm r1!, {r0}
bss_fill_test:
    cmp r1, r2
    bne bss_fill_loop</code></pre>
<p>Similarly to before, we load the start address of the <code>.bss</code> section into <code>r1</code>, the end address into <code>r2</code>, and then we put a 0 into <code>r0</code>. Then, we take an unconditional branch to <code>bss_fill_test</code>. The code in <code>bss_fill_test</code> compares the values of <code>r1</code> and <code>r2</code>. In the event that they are not equal, it branches to <code>bss_fill_loop</code>, which writes the data contained in the register <code>r0</code> (0) to the memory address pointed to by <code>r1</code>, and then automatically increments <code>r1</code>. The code then falls back thru to <code>bss_fill_test</code>. The consequence is that 0&#39;s will be written to all memory addresses between <code>__bss_start__</code> and <code>__bss_end__</code>. This zeroes all uninitialized variables, just like we want.</p>
<p>After having intialized the <code>.data</code>, <code>.scratch_x</code>, <code>.scratch_y</code>, and <code>.bss</code> sections as described above, the code falls thru to <code>platform_entry</code>, pasted below:</p>

<pre><code>platform_entry: // symbol for stack traces
    // Use 32-bit jumps, in case these symbols are moved out of branch range
    // (e.g. if main is in SRAM and crt0 in flash)
    ldr r1, =runtime_init
    blx r1
    ldr r1, =main
    blx r1
    ldr r1, =exit
    blx r1</code></pre>
<p>This first loads the register <code>r1</code> with the address of the function <code>runtime_init</code>. The second instruction branches and links, so that the <code>runtime_init</code> function will run, and then we&#39;ll return to this line of the assembler program. What&#39;s that <code>runtime_init</code> function doing? You can find it at line 67 of <a href="https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_runtime/runtime.c">this file</a>. In brief, it does the following:</p>
<blockquote><ul>
<li>Resets all peripherals</li>
<li>Calls all constructor functions</li>
<li>Starts the XOSC, PLL&#39;s, and clocks</li>
<li>Initializes spinlocks</li>
<li>Initializes interrupts and alarms</li>
</ul>
</blockquote>
<p>After having performed this runtime initialization, the program <em>returns</em> to the <code>platform_entry</code> snippet above. It loads the register <code>r1</code> with the address of the function <code>main</code>, and then branches to it.</p>
<p>At this point, the user application code is runnning.</p>

</div>
</div>
</div></div>
  </body>
</html>
