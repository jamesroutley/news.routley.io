<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://irreducible.io/blog/my-wasm-interpreter/">Original</a>
    <h1>I Wrote a WebAssembly VM in C</h1>
    
    <div id="readability-page-1" class="page"><div>  <article> <header>   <span>Jan 26, 2025</span> </header> <section> <p>For the last 6 months, I’ve been spending my (limited) free time on evenings and weekends
writing a <a href="https://github.com/irrio/semblance">WebAssembly VM</a> in C.
After repeatedly throwing away small side-projects, this was
an extremely productive experience for me as an engineer. I’m writing
this in order to put together some take-aways and organize my thoughts on what I learned.</p>

<p>WebAssembly is a standardized instruction set and bytecode format for a
virtual stack machine that is designed to run untrusted client-side code
in Web browsers at <a href="https://00f.net/2023/01/04/webassembly-benchmark-2023/">near-native</a> speed.</p>
<p>The <a href="https://webassembly.org/">WebAssembly standard</a> evolved
out of the <a href="https://web.archive.org/web/20140209035139/https://github.com/kripken/emscripten/wiki">Emscripten C/C++ to Javascript compiler</a>.
Emscripten transpiled LLVM IR to Javascript in order to allow C and C++
code to run on the Web. Over time, browser developers worked
with the Emscripten project to restrict its generated code to a simple subset of Javascript
that could be optimized for performance. This subset of Javascript was standardized
as <a href="http://asmjs.org/">asm.js</a>. Eventually, a standalone bytecode format was designed
to avoid the overhead of Javascript altogether, which, among other things, is difficult
to parse efficiently. That’s where we got Wasm.</p>
<p>In recent years WebAssembly has been gaining popularity outside the browser.
Wasm’s secure sandbox offers a lightweight
alternative to containers and virtual machines in the cloud:
<a href="https://www.fastly.com">Fastly</a> and <a href="https://shopify.com">Shopify</a>
have built their <a href="https://www.fastly.com/products/edge-compute">Edge Compute</a> and
<a href="https://shopify.dev/docs/apps/build/functions">Functions</a> products on top
of WebAssembly engines. Its security and performance guarantees, plus the ability
to target Wasm from a multitude of source languages makes it an attractive platform
to build plugin ecosystems: <a href="https://zed.dev/blog/zed-decoded-extensions">Zed’s extension system</a>
is built on Wasm.</p>
<p>There is an industry-wide effort to support the use of WebAssembly outside of the Browser
led by the <a href="https://bytecodealliance.org">Bytecode Alliance</a>. The Bytecode Alliance
leads the development of the <a href="https://wasmtime.dev/">Wasmtime</a> runtime in order to standardize
the <a href="https://wasi.dev/">WebAssembly System Interface</a> (WASI). WASI enables
WebAssembly modules to communicate with the host operating system through a set of POSIX-like
hostcalls. With WASI, WebAssembly has a standardized way to interact with standard input and output,
filesystems, networks, and other common interfaces to the outside world.</p>

<p>Like many other software engineers, I had fallen into a cyclical pattern where I would begin an
awesome new side-project and then quickly get bored and move on to the next shiny thing
after a few weeks. This left me feeling unproductive as
I didn’t have anything tangible to show as a result of all my tinkering.</p>
<p>I needed a large project that I could invest my effort into over a sustained period of time.
A project that would get me out of my comfort zone and expose me to a lower level of the
computing stack than I usually work with at my day job.</p>
<p>Many of my abandoned side-projects failed due to a lack of direction.
I needed a project that had clear goals and tangible outcomes.</p>
<p>I had recently made it through a rough job search where I felt my generalist
engineering profile was impacting my ability to secure stable work. I was looking
for something I could specialize in to build up more of a T-shaped skillset.
I was getting fatigued with application level web dev and wanted to move my
career towards a lower level of the stack.</p>
<p>Around this time I started buying into some of the WebAssembly hype.
Being able to design a bespoke computing environment
with <a href="https://component-model.bytecodealliance.org/design/wit.html">custom syscalls</a>
sounded, to me, like an incredible platform engineering tool.</p>

<p>I decided I’d write a WebAssembly interpreter.
My goals for the project were primarily to familiarize
myself with the <a href="https://webassembly.github.io/spec/core/intro/introduction.html">WebAssembly Core Specification</a>.
I wanted to come out of this project ready to start contributing
to an industrial grade runtime like Wasmtime. I decided to
call the project <a href="https://github.com/irrio/semblance">Semblance</a>.</p>
<p>Because the project is just for learning purposes, I had no intention
of implementing <a href="https://webassembly.github.io/spec/core/exec/instructions.html">every opcode</a>
or passing the <a href="https://github.com/WebAssembly/spec/tree/main/test/core">core test suite</a>.
If I could get a “Hello, World!” to run I’d be happy.</p>
<p>Let’s take a high-level tour through the code and I’ll explain the
interpreter’s lifecycle during the execution of a WebAssembly module.</p>
<p>But first I need to start with a disclaimer: I am not, nor have I ever been,
a professional C developer, I know this is not ideal C. But I am trying to
improve, I would happily <a href="https://github.com/irrio/semblance">welcome a code review</a>
from a friendly greybeard.</p>
<p>We’ll start with a simple hello world in C</p>
<pre tabindex="0" data-language="c"><code><span><span>extern</span><span> void</span><span> puts</span><span>(</span><span>char</span><span> *</span><span>str</span><span>);</span></span>
<span></span>
<span><span>void</span><span> hello</span><span>() {</span></span>
<span><span>  puts</span><span>(</span><span>&#34;Hello, World!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>We can compile this to WebAssembly with Clang</p>
<pre tabindex="0" data-language="bash"><code><span><span>clang</span><span> --target=wasm32</span><span> \</span></span>
<span><span>    -nostdlib</span><span> \</span></span>
<span><span>    -Wl,--no-entry</span><span> \</span></span>
<span><span>    -Wl,--export-all</span><span> \</span></span>
<span><span>    -Wl,--allow-undefined</span><span> \</span></span>
<span><span>    -O3</span><span> \</span></span>
<span><span>    -o</span><span> hello.wasm</span><span> \</span></span>
<span><span>    hello.c</span></span>
<span></span></code></pre>
<p>Now let’s invoke the exported <code>hello</code> function with <code>semblance</code></p>
<pre tabindex="0" data-language="bash"><code><span><span>semblance</span><span> hello.wasm</span><span> --invoke</span><span> hello</span></span>
<span></span></code></pre>
<p>The program begins by initializing some memory on the stack
to hold our parsed command line arguments, our decoded
WebAssembly module, and the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">store</a>
which will encapsulate all of our module’s runtime state.
We parse the command line arguments and exit if they’re invalid.</p>
<pre tabindex="0" data-language="c"><code><span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    CliArgs args;</span></span>
<span><span>    WasmModule wmod;</span></span>
<span><span>    WasmStore store;</span></span>
<span></span>
<span><span>    wmod_init</span><span>(</span><span>&amp;</span><span>wmod);</span></span>
<span><span>    wrun_store_init</span><span>(</span><span>&amp;</span><span>store);</span></span>
<span></span>
<span><span>    cli_parse_or_exit</span><span>(</span><span>&amp;</span><span>args, argc, argv);</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>args</span><span>.</span><span>help</span><span>) {</span></span>
<span><span>        printf</span><span>(</span><span>&#34;</span><span>%s\n</span><span>&#34;</span><span>, </span><span>cli_usage_str</span><span>());</span></span>
<span><span>        return</span><span> 0</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>After that initial setup, the first thing the interpreter
is going to do is decode the <a href="https://webassembly.github.io/spec/core/binary/modules.html#binary-module">binary format</a>.
Starting by looking for the <code>&#34;\0asm&#34;</code> magic bytes at the beginning
of the file, verifying that the <code>version</code> of the binary format is <code>1</code>,
and then moving on to decode each of the contained <a href="https://webassembly.github.io/spec/core/binary/modules.html#sections">sections</a>.</p>
<pre tabindex="0" data-language="c"><code><span><span>WasmDecodeResult </span><span>wbin_decode_module</span><span>(</span><span>size_t</span><span> size</span><span>, WasmHeader </span><span>*</span><span>header</span><span>, WasmModule </span><span>*</span><span>wmod</span><span>) {</span></span>
<span><span>    if</span><span> (</span></span>
<span><span>        size </span><span>&lt;</span><span> sizeof</span><span>(WasmHeader)</span></span>
<span><span>        ||</span><span> header</span><span>-&gt;</span><span>magic_bytes</span><span>[</span><span>0</span><span>] </span><span>!=</span><span> &#39;</span><span>\0</span><span>&#39;</span></span>
<span><span>        ||</span><span> header</span><span>-&gt;</span><span>magic_bytes</span><span>[</span><span>1</span><span>] </span><span>!=</span><span> &#39;a&#39;</span></span>
<span><span>        ||</span><span> header</span><span>-&gt;</span><span>magic_bytes</span><span>[</span><span>2</span><span>] </span><span>!=</span><span> &#39;s&#39;</span></span>
<span><span>        ||</span><span> header</span><span>-&gt;</span><span>magic_bytes</span><span>[</span><span>3</span><span>] </span><span>!=</span><span> &#39;m&#39;</span></span>
<span><span>    ) </span><span>return</span><span> wbin_err</span><span>(WasmDecodeErrMagicBytes, </span><span>0</span><span>);</span></span>
<span></span>
<span><span>    wmod</span><span>-&gt;</span><span>meta</span><span>.</span><span>version</span><span> =</span><span> header</span><span>-&gt;</span><span>version</span><span>;</span></span>
<span><span>    if</span><span> (</span><span>header</span><span>-&gt;</span><span>version</span><span> !=</span><span> 1</span><span>) </span><span>return</span><span> wbin_err</span><span>(WasmDecodeErrUnsupportedVersion, </span><span>0</span><span>);</span></span>
<span></span>
<span><span>    return</span><span> wbin_decode_sections</span><span>(size </span><span>-</span><span> sizeof</span><span>(WasmHeader), </span><span>header</span><span>-&gt;</span><span>sections</span><span>, wmod);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>WasmDecodeResult </span><span>wbin_read_module</span><span>(</span><span>char</span><span> *</span><span>path</span><span>, WasmModule </span><span>*</span><span>wmod</span><span>) {</span></span>
<span><span>    int</span><span> fd </span><span>=</span><span> open</span><span>(path, O_RDONLY);</span></span>
<span><span>    if</span><span> (fd </span><span>&lt;</span><span> 0</span><span>) </span><span>return</span><span> wbin_err_io</span><span>(errno);</span></span>
<span></span>
<span><span>    struct</span><span> stat stats;</span></span>
<span><span>    int</span><span> stat_err </span><span>=</span><span> fstat</span><span>(fd, </span><span>&amp;</span><span>stats);</span></span>
<span><span>    if</span><span> (stat_err </span><span>==</span><span> -</span><span>1</span><span>) </span><span>return</span><span> wbin_err_io</span><span>(errno);</span></span>
<span></span>
<span><span>    WasmHeader</span><span>*</span><span> data </span><span>=</span><span> mmap</span><span>(</span><span>NULL</span><span>, </span><span>stats</span><span>.</span><span>st_size</span><span>, PROT_READ, MAP_PRIVATE, fd, </span><span>0</span><span>);</span></span>
<span><span>    if</span><span> ((</span><span>size_t</span><span>) data </span><span>==</span><span> -</span><span>1</span><span>) </span><span>return</span><span> wbin_err_io</span><span>(errno);</span></span>
<span></span>
<span><span>    int</span><span> close_err </span><span>=</span><span> close</span><span>(fd);</span></span>
<span><span>    if</span><span> (close_err </span><span>!=</span><span> 0</span><span>) </span><span>return</span><span> wbin_err_io</span><span>(errno);</span></span>
<span></span>
<span><span>    return</span><span> wbin_decode_module</span><span>(</span><span>stats</span><span>.</span><span>st_size</span><span>, data, wmod);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>    wbin_read_module_or_exit</span><span>(</span><span>&amp;</span><span>args, </span><span>&amp;</span><span>wmod);</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>After successfully decoding the module, our <code>WasmModule</code> struct
will be filled in with <code>hello.wasm</code>’s
<a href="https://webassembly.github.io/spec/core/syntax/modules.html#modules">functions, types, imports, datas, etc</a>.</p>
<pre tabindex="0" data-language="c"><code><span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span>    wasm_type_idx_t</span><span> type_idx;</span></span>
<span><span>    VEC</span><span>(WasmValueType) locals;</span></span>
<span><span>    WasmExpr body;</span></span>
<span><span>} WasmFunc;</span></span>
<span></span>
<span><span>typedef</span><span> VEC</span><span>(WasmFunc) WasmFuncs;</span></span>
<span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span>    WasmTypes types;</span></span>
<span><span>    WasmFuncs funcs;</span></span>
<span><span>    WasmTables tables;</span></span>
<span><span>    WasmMems mems;</span></span>
<span><span>    WasmGlobals globals;</span></span>
<span><span>    WasmElems elems;</span></span>
<span><span>    WasmDatas datas;</span></span>
<span><span>    WasmStart start;</span></span>
<span><span>    WasmImports imports;</span></span>
<span><span>    WasmExports exports;</span></span>
<span><span>    WasmCustoms customs;</span></span>
<span><span>    WasmMeta meta;</span></span>
<span><span>} WasmModule;</span></span>
<span></span></code></pre>
<p>Next we’ll resolve any of the module’s imports.
At this time <code>env::puts</code> is the only
host function provided by <code>semblance</code>.
Importing a host function involves <a href="https://webassembly.github.io/spec/core/exec/modules.html#allocation">allocating</a>
a native function pointer in the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">store</a>
and placing the resulting <code>funcaddr</code> into the
module’s <code>imports</code> array.</p>
<pre tabindex="0" data-language="c"><code><span><span>VEC</span><span>(WasmValue) </span><span>hostcall_puts</span><span>(WasmStore </span><span>*</span><span>store</span><span>, </span><span>VEC</span><span>(WasmValue) </span><span>*</span><span>args</span><span>) {</span></span>
<span><span>    VEC</span><span>(WasmValue) out;</span></span>
<span><span>    vec_init</span><span>(</span><span>&amp;</span><span>out);</span></span>
<span></span>
<span><span>    WasmValue </span><span>*</span><span>arg </span><span>=</span><span> args</span><span>-&gt;</span><span>ptr</span><span>;</span></span>
<span><span>    int32_t</span><span> offset </span><span>=</span><span> arg</span><span>[</span><span>0</span><span>].</span><span>num</span><span>.</span><span>i32</span><span>;</span></span>
<span></span>
<span><span>    WasmMemInst </span><span>*</span><span>mem </span><span>=</span><span> store</span><span>-&gt;</span><span>mems</span><span>.</span><span>ptr</span><span>;</span></span>
<span><span>    void</span><span> *</span><span>data </span><span>=</span><span> mem</span><span>[</span><span>0</span><span>].</span><span>data</span><span>.</span><span>ptr</span><span>;</span></span>
<span></span>
<span><span>    printf</span><span>(</span><span>&#34;</span><span>%s</span><span>&#34;</span><span>, (</span><span>char</span><span>*</span><span>)(data </span><span>+</span><span> offset));</span></span>
<span></span>
<span><span>    return</span><span> out;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>WasmExternVal </span><span>register_hostcall_puts</span><span>(WasmStore </span><span>*</span><span>store</span><span>) {</span></span>
<span><span>    WasmFuncType puts_type;</span></span>
<span><span>    vec_init</span><span>(</span><span>&amp;</span><span>puts_type</span><span>.</span><span>input_type</span><span>);</span></span>
<span><span>    WasmValueType arg1 </span><span>=</span><span> {</span></span>
<span><span>        .kind </span><span>=</span><span> WasmValueTypeNum,</span></span>
<span><span>        .</span><span>value</span><span>.</span><span>num</span><span> =</span><span> WasmNumI32</span></span>
<span><span>    };</span></span>
<span><span>    vec_push_back</span><span>(</span><span>&amp;</span><span>puts_type</span><span>.</span><span>input_type</span><span>, </span><span>sizeof</span><span>(WasmValueType), </span><span>&amp;</span><span>arg1);</span></span>
<span><span>    vec_init</span><span>(</span><span>&amp;</span><span>puts_type</span><span>.</span><span>output_type</span><span>);</span></span>
<span><span>    wasm_func_addr_t</span><span> putsaddr </span><span>=</span><span> wrun_store_alloc_hostfunc</span><span>(store, puts_type, hostcall_puts);</span></span>
<span><span>    WasmExternVal out </span><span>=</span><span> {</span></span>
<span><span>        .kind </span><span>=</span><span> WasmExternValFunc,</span></span>
<span><span>        .</span><span>val</span><span>.</span><span>func</span><span> =</span><span> putsaddr</span></span>
<span><span>    };</span></span>
<span><span>    return</span><span> out;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>    VEC</span><span>(WasmExternVal) imports;</span></span>
<span><span>    vec_init</span><span>(</span><span>&amp;</span><span>imports);</span></span>
<span></span>
<span><span>    for</span><span> (</span><span>size_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> wmod</span><span>.</span><span>imports</span><span>.</span><span>len</span><span>; i</span><span>++</span><span>) {</span></span>
<span><span>        WasmImport </span><span>*</span><span>import </span><span>=</span><span> vec_at</span><span>(</span><span>&amp;</span><span>wmod</span><span>.</span><span>imports</span><span>, </span><span>sizeof</span><span>(WasmImport), i);</span></span>
<span><span>        if</span><span> (</span><span>wmod_name_eq</span><span>(</span><span>&amp;</span><span>import</span><span>-&gt;</span><span>module_name</span><span>, </span><span>&#34;env&#34;</span><span>) </span><span>&amp;&amp;</span><span> wmod_name_eq</span><span>(</span><span>&amp;</span><span>import</span><span>-&gt;</span><span>item_name</span><span>, </span><span>&#34;puts&#34;</span><span>)) {</span></span>
<span><span>            WasmExternVal func_puts </span><span>=</span><span> register_hostcall_puts</span><span>(</span><span>&amp;</span><span>store);</span></span>
<span><span>            vec_push_back</span><span>(</span><span>&amp;</span><span>imports, </span><span>sizeof</span><span>(WasmExternVal), </span><span>&amp;</span><span>func_puts);</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Now we’re ready to <a href="https://webassembly.github.io/spec/core/exec/modules.html#instantiation">instantiate</a>
the module. The instantiation of a module involves a <a href="https://webassembly.github.io/spec/core/valid/conventions.html">validation
step</a>
that performs typechecking and other tests to ensure that the module
is well formed. Additionally, memories, globals and tables are initialized
and the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#start-function"><code>start</code></a>
function is invoked. Instantiation results in a <code>WasmModuleInst</code> that represents
the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-moduleinst">runtime structure</a>
of the module with it’s <code>exports</code> ready for consumption.</p>
<pre tabindex="0" data-language="c"><code><span><span>typedef</span><span> enum</span><span> {</span></span>
<span><span>    WasmExternValFunc,</span></span>
<span><span>    WasmExternValTable,</span></span>
<span><span>    WasmExternValMem,</span></span>
<span><span>    WasmExternValGlobal</span></span>
<span><span>} WasmExternValKind;</span></span>
<span></span>
<span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span>    WasmExternValKind kind;</span></span>
<span><span>    union</span><span> {</span></span>
<span><span>        wasm_func_addr_t</span><span> func;</span></span>
<span><span>        wasm_table_addr_t</span><span> table;</span></span>
<span><span>        wasm_mem_addr_t</span><span> mem;</span></span>
<span><span>        wasm_global_addr_t</span><span> global;</span></span>
<span><span>    } val;</span></span>
<span><span>} WasmExternVal;</span></span>
<span></span>
<span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span>    WasmName name;</span></span>
<span><span>    WasmExternVal val;</span></span>
<span><span>} WasmExportInst;</span></span>
<span></span>
<span><span>typedef</span><span> struct</span><span> {</span></span>
<span><span>    WasmFuncType </span><span>*</span><span>types;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_func_addr_t</span><span>) funcaddrs;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_table_addr_t</span><span>) tableaddrs;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_mem_addr_t</span><span>) memaddrs;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_global_addr_t</span><span>) globaladdrs;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_elem_addr_t</span><span>) elemaddrs;</span></span>
<span><span>    VEC</span><span>(</span><span>wasm_data_addr_t</span><span>) dataaddrs;</span></span>
<span><span>    VEC</span><span>(WasmExportInst) exports;</span></span>
<span><span>} WasmModuleInst;</span></span>
<span></span>
<span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>    WasmModuleInst </span><span>*</span><span>winst </span><span>=</span><span> wrun_instantiate_module</span><span>(</span><span>&amp;</span><span>wmod, </span><span>&amp;</span><span>store, </span><span>&amp;</span><span>imports);</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Next we need to resolve the exported function to invoke based
on the <code>--invoke</code> command line argument.</p>
<pre tabindex="0" data-language="c"><code><span><span>WasmExternVal </span><span>wrun_resolve_export</span><span>(WasmModuleInst </span><span>*</span><span>winst</span><span>, </span><span>char</span><span> *</span><span>name</span><span>) {</span></span>
<span><span>    for</span><span> (</span><span>size_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> winst</span><span>-&gt;</span><span>exports</span><span>.</span><span>len</span><span>; i</span><span>++</span><span>) {</span></span>
<span><span>        WasmExportInst </span><span>*</span><span>wexp </span><span>=</span><span> vec_at</span><span>(</span><span>&amp;</span><span>winst</span><span>-&gt;</span><span>exports</span><span>, </span><span>sizeof</span><span>(WasmExportInst), i);</span></span>
<span><span>        if</span><span> (</span><span>wmod_name_eq</span><span>(</span><span>&amp;</span><span>wexp</span><span>-&gt;</span><span>name</span><span>, name)) {</span></span>
<span><span>            return</span><span> wexp</span><span>-&gt;</span><span>val</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    assert</span><span>(</span><span>false</span><span>);</span><span> // export not found</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>    WasmExternVal export </span><span>=</span><span> wrun_resolve_export</span><span>(winst, </span><span>args</span><span>.</span><span>invoke</span><span>);</span></span>
<span><span>    assert</span><span>(</span><span>export</span><span>.</span><span>kind</span><span> ==</span><span> WasmExternValFunc);</span></span>
<span></span>
<span><span>    // ...</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Finally, we’re ready to invoke the function. Invocation
requires some setup, mainly initializing the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#stack">stack</a>
and the function’s <a href="https://webassembly.github.io/spec/core/exec/runtime.html#activation-frames">activation frame</a>.
But ultimately we arrive at the core of the
interpreter: the opcode switch loop. The opcode switch loop
walks the sequence of <a href="https://webassembly.github.io/spec/core/exec/instructions.html">Wasm instructions</a>
in the function body, taking action on the <code>stack</code> and the <code>store</code> accordingly.</p>
<pre tabindex="0" data-language="c"><code><span><span>WasmResultKind </span><span>wrun_exec_expr</span><span>(WasmStore </span><span>*</span><span>store</span><span>, WasmStack </span><span>*</span><span>stack</span><span>, WasmInstruction </span><span>*</span><span>expr</span><span>) {</span></span>
<span><span>    WasmInstruction</span><span>*</span><span> ip </span><span>=</span><span> expr;</span></span>
<span><span>    while</span><span> (</span><span>true</span><span>) {</span></span>
<span><span>        switch</span><span> (</span><span>ip</span><span>-&gt;</span><span>opcode</span><span>) {</span></span>
<span><span>           case</span><span> WasmOpI32Const:</span></span>
<span><span>                wrun_stack_push_i32</span><span>(stack, ip</span><span>-&gt;</span><span>params._const.value.i32);</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            case</span><span> WasmOpI64Const:</span></span>
<span><span>                wrun_stack_push_i64</span><span>(stack, ip</span><span>-&gt;</span><span>params._const.value.i64);</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            case</span><span> WasmOpF32Const:</span></span>
<span><span>                wrun_stack_push_f32</span><span>(stack, ip</span><span>-&gt;</span><span>params._const.value.f32);</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            case</span><span> WasmOpF64Const:</span></span>
<span><span>                wrun_stack_push_f64</span><span>(stack, ip</span><span>-&gt;</span><span>params._const.value.f64);</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            case</span><span> WasmOpI32Ge_s: {</span></span>
<span><span>                WasmValue a;</span></span>
<span><span>                WasmValue b;</span></span>
<span><span>                wrun_stack_pop_val</span><span>(stack, </span><span>&amp;</span><span>b);</span></span>
<span><span>                wrun_stack_pop_val</span><span>(stack, </span><span>&amp;</span><span>a);</span></span>
<span><span>                WasmValue out </span><span>=</span><span> {</span></span>
<span><span>                    .</span><span>num</span><span>.</span><span>i32</span><span> =</span><span> a</span><span>.</span><span>num</span><span>.</span><span>i32</span><span> &gt;=</span><span> b</span><span>.</span><span>num</span><span>.</span><span>i32</span></span>
<span><span>                };</span></span>
<span><span>                wrun_stack_push_val</span><span>(stack, </span><span>&amp;</span><span>out);</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>            case</span><span> WasmOpCall: {</span></span>
<span><span>                // ...</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            }</span></span>
<span><span>            case</span><span> WasmOpNop:</span></span>
<span><span>                break</span><span>;</span></span>
<span><span>            case</span><span> WasmOpUnreachable:</span></span>
<span><span>                return</span><span> Trap;</span></span>
<span><span>            case</span><span> WasmOpExprEnd: {</span></span>
<span><span>                // ...</span></span>
<span><span>                return</span><span> Ok;</span></span>
<span><span>            }</span></span>
<span></span>
<span><span>            // ...</span></span>
<span></span>
<span><span>            default</span><span>:</span></span>
<span><span>                printf</span><span>(</span><span>&#34;unhandled opcode [</span><span>%s</span><span>]</span><span>\n</span><span>&#34;</span><span>, </span><span>wmod_str_opcode</span><span>(ip</span><span>-&gt;</span><span>opcode</span><span>));</span></span>
<span><span>                return</span><span> Trap;</span></span>
<span><span>        }</span></span>
<span><span>        ip</span><span>++</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Let’s zoom in on the <code>WasmOpCall</code> case to see how a module invokes our
<code>env::puts</code> host function through the <a href="https://webassembly.github.io/spec/core/exec/instructions.html#xref-syntax-instructions-syntax-instr-control-mathsf-call-x"><code>call</code></a>
instruction. At a high level, we use the <code>call</code> opcode’s immediate
parameter <code>funcidx</code> to resolve the function instance from the <code>store</code>.
Using the type information in the function instance <code>finst</code>, we pop the function’s
arguments off of the <code>stack</code> and then check <code>finst-&gt;kind</code> to
determine whether we are calling a Wasm function or a native host function.
If we are calling a host function, we perform a native call against the
<code>hostfunc</code> function pointer with our popped <code>args</code>
and then push any return values onto the stack.</p>
<pre tabindex="0" data-language="c"><code><span><span>case WasmOpCall: {</span></span>
<span><span>    WasmActivation </span><span>*</span><span>frame </span><span>=</span><span> wrun_stack_find_current_frame</span><span>(stack);</span></span>
<span><span>    wasm_func_idx_t</span><span> funcidx </span><span>=</span><span> ip</span><span>-&gt;</span><span>params</span><span>.</span><span>call</span><span>.</span><span>funcidx</span><span>;</span></span>
<span><span>    wasm_func_addr_t</span><span> funcaddr </span><span>=</span><span> *</span><span>(</span><span>wasm_func_addr_t</span><span>*</span><span>)</span><span>vec_at</span><span>(</span><span>&amp;</span><span>frame</span><span>-&gt;</span><span>inst</span><span>-&gt;</span><span>funcaddrs</span><span>, </span><span>sizeof</span><span>(</span><span>wasm_func_addr_t</span><span>), funcidx);</span></span>
<span><span>    WasmFuncInst </span><span>*</span><span>finst </span><span>=</span><span> vec_at</span><span>(</span><span>&amp;</span><span>store</span><span>-&gt;</span><span>funcs</span><span>, </span><span>sizeof</span><span>(WasmFuncInst), funcaddr </span><span>-</span><span> 1</span><span>);</span></span>
<span><span>    size_t</span><span> numargs </span><span>=</span><span> finst</span><span>-&gt;</span><span>functype</span><span>.</span><span>input_type</span><span>.</span><span>len</span><span>;</span></span>
<span><span>    VEC</span><span>(WasmValue) args;</span></span>
<span><span>    vec_init_with_capacity</span><span>(</span><span>&amp;</span><span>args, </span><span>sizeof</span><span>(WasmValue), numargs);</span></span>
<span><span>    for</span><span> (</span><span>size_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> numargs; i</span><span>++</span><span>) {</span></span>
<span><span>        WasmValue argval;</span></span>
<span><span>        wrun_stack_pop_val</span><span>(stack, </span><span>&amp;</span><span>argval);</span></span>
<span><span>        vec_push_back</span><span>(</span><span>&amp;</span><span>args, </span><span>sizeof</span><span>(WasmValue), </span><span>&amp;</span><span>argval);</span></span>
<span><span>    }</span></span>
<span><span>    switch</span><span> (</span><span>finst</span><span>-&gt;</span><span>kind</span><span>) {</span></span>
<span><span>        case</span><span> WasmFuncInstWasm: {</span></span>
<span><span>            // ...</span></span>
<span><span>        }</span></span>
<span><span>        case</span><span> WasmFuncInstHost: {</span></span>
<span><span>            VEC</span><span>(WasmValue) ret </span><span>=</span><span> ((WasmHostFunc)</span><span>finst</span><span>-&gt;</span><span>val</span><span>.</span><span>hostfunc</span><span>)(store, </span><span>&amp;</span><span>args);</span></span>
<span><span>            for</span><span> (</span><span>size_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> ret</span><span>.</span><span>len</span><span>; i</span><span>++</span><span>) {</span></span>
<span><span>                WasmValue </span><span>*</span><span>retval </span><span>=</span><span> vec_at</span><span>(</span><span>&amp;</span><span>ret, </span><span>sizeof</span><span>(WasmValue), i);</span></span>
<span><span>                wrun_stack_push_val</span><span>(stack, retval);</span></span>
<span><span>            }</span></span>
<span><span>            vec_free</span><span>(</span><span>&amp;</span><span>ret);</span></span>
<span><span>            break</span><span>;</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    vec_free</span><span>(</span><span>&amp;</span><span>args);</span></span>
<span><span>    break</span><span>;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Eventually, the opcode switch loop will arrive
at the <code>hello</code> function’s <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-control"><code>end</code></a>
opcode. At which point we return back to our <code>main</code> function
and the program ends.</p>
<pre tabindex="0" data-language="c"><code><span><span>int</span><span> main</span><span>(</span><span>int</span><span> argc</span><span>, </span><span>char</span><span> *</span><span>argv</span><span>[]</span><span>) {</span></span>
<span></span>
<span><span>    // ...</span></span>
<span></span>
<span><span>    VEC</span><span>(WasmValue) fn_args;</span></span>
<span><span>    vec_init</span><span>(</span><span>&amp;</span><span>fn_args);</span></span>
<span><span>    DynamicWasmResult wres </span><span>=</span><span> wrun_invoke_func</span><span>(winst, </span><span>export</span><span>.</span><span>val</span><span>.</span><span>func</span><span>, </span><span>&amp;</span><span>fn_args, </span><span>&amp;</span><span>store);</span></span>
<span><span>    wrun_result_dump_dynamic</span><span>(</span><span>&amp;</span><span>wres);</span></span>
<span></span>
<span><span>    return</span><span> wres</span><span>.</span><span>result</span><span>.</span><span>kind</span><span> !=</span><span> Ok;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>To put it all together: we should see our message on
standard output.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Hello, World!</span></span>
<span><span>Ok []</span></span>
<span><span></span></span></code></pre>
<p>I can’t describe how satisfying it felt to see <code>Hello, World!</code>
print to my terminal the first time that worked.</p>

<p>In my eyes this project was a huge success.
The opcode coverage isn’t anywhere near complete,
but it can execute some simple “Hello, World!” programs.
The code is messy, it’s slow, it leaks memory, and I’m confident it’s
vulnerable to malicious modules, but it works! Plus it taught me a ton
about the core WebAssembly specification and got me out
of my comfort zone as an engineer.</p>
<p>After hacking together my own interpreter, I feel that
I have enough WebAssembly specific knowledge to begin
contributing to an industrial grade runtime like Wasmtime.</p>
<p>Over time I’ll continue hacking on a few opcodes
here and there. But I think it’s time to retire
this as my primary project. I’m not sure what’s next yet,
but my gauge for what I can accomplish as a side project
has been recalibrated.</p> </section> </article>  </div></div>
  </body>
</html>
