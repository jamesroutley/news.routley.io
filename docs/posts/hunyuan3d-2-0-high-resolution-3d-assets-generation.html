<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Tencent/Hunyuan3D-2">Original</a>
    <h1>Hunyuan3D 2.0 – High-Resolution 3D Assets Generation</h1>
    
    <div id="readability-page-1" class="page"><article><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Here is the leetcode link for this problem<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>I recently tried two medium-difficulty Leetcode problems with [Jaseem Abid](<a href="https://www.linkedin.com/in/jaseemabid/">https://www.linkedin.com/in/jaseemabid/<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, my partner in leet crime.</p>
<p>Although distinct, these two problems were very similar in some ways, so although I will publish them as separate write-ups, I think that I was able to apply lessons learned in the first to the second:</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>t</li>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></li>
</ul>
<p>Here’s my writeup for that next one: <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/19)-Longest-Palindromic-Substring" data-slug="devnotes/LeetCode-Journal/19)-Longest-Palindromic-Substring">19) Longest Palindromic Substring</a>.</p>
<p>I started with a classic mistake: I spent a little two long trying to come up with solutions. These three approaches commented out at the top represent 6 minutes.</p>
<p>I realized that iterating through every possible substring and checking to see if it had repeating characters would have n cubed time complexity, so I sort of balked and tried to think of a better way, but didn’t quite succeed, so I ended up just trying that n cubed approach.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// iterate through each index</span></span>
<span data-line=""><span>// save longst found substring as I iterate a second time from index</span></span>
<span data-line=""><span>// n^3</span></span>
<span data-line=""> </span>
<span data-line=""><span>// dynamic programming</span></span>
<span data-line=""><span>// substrings</span></span>
<span data-line=""><span>// iterate from each index,</span></span>
<span data-line=""> </span>
<span data-line=""><span>// bfs</span></span>
<span data-line=""><span>// split it half from middle index</span></span>
<span data-line=""><span>// from there check substrings backwards and forwards</span></span>
<span data-line=""><span>// </span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> longestSubString</span><span>:</span><span> string</span><span>[] </span><span>=</span><span> [s[</span><span>0</span><span>]]</span></span>
<span data-line=""><span>    let</span><span> sA </span><span>=</span><span> s.split[</span><span>&#39;&#39;</span><span>] </span><span>// &lt; Turn it into an array</span></span>
<span data-line=""><span>    for</span><span> (</span><span>const</span><span> startingIndex</span><span> in</span><span> sA){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        const</span><span> remainingString</span><span> =</span><span> sA.</span><span>slice</span><span>(startingIndex, sA.</span><span>length</span><span>)</span></span>
<span data-line=""><span>        const</span><span> tempString</span><span>:</span><span> string</span><span>[] </span><span>=</span><span> []</span></span>
<span data-line=""><span>        for</span><span> (</span><span>const</span><span> j</span><span> in</span><span> remainingString){</span></span>
<span data-line=""><span>            if</span><span> (tempString.</span><span>includes</span><span>(remainingString[j])){</span></span>
<span data-line=""><span>                break</span></span>
<span data-line=""><span>            } </span><span>else</span><span> {</span></span>
<span data-line=""><span>                tempString.</span><span>push</span><span>(remainingString[j])</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        if</span><span> (tempString.</span><span>length</span><span> &gt;</span><span> longestSubString.</span><span>length</span><span>){</span></span>
<span data-line=""><span>            longestSubString </span><span>=</span><span> tempString</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>(tempString)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longestSubString.</span><span>length</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>I invite you to disagree, but I think the result of my session was some really difficult to read code. Also, it doesn’t work - it also outputs ‘1’. The <code>console.log(tempString)</code> line never gets called.</p>
<p>Considering I took 2 weeks off from leetcode and hopped onto one of my first medium problems, I don’t think I did awful. However, I certainly failed this in the interview context.</p>
<p>Jaseem had some awesome feedback, some of it quite new to me. He told me about something called “Wishful Programming”. Wishful programming is a technique somewhere between writing real code and pseudocode where you substitute solvable problems for placeholder functions, or other structures, that may or may not exist.</p>
<p>When I heard this I likened it to art - one of the keys to being a good painter is starting big, and moving into the details. If you paint the general shapes and colors first before the details, you can avoid creating details that you need to do over. Also in art, it can be easy to get perspective, color and contour pretty wrong if you are <em>too focused</em> on the “small picture”.</p>
<p>I think that wishful thinking shows how this is the same for programming. It’s better to get the shape of the algorithm down before picking less important details. In the above code, I got caught up in the method by which slicing up substrings, even though the substrings themselves were really just abstractions I relied on to get their length. And yet much of my code was focused on string manipulation, making it much harder to read and to reason about.</p>
<p>I tried again, although to be honest I still didn’t really use wishful programming. Having tried a version of the sliding window technique, I was able to try it more earnestly:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>s.</span><span>length</span><span>) </span><span>return</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // sliding window</span></span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> end </span><span>=</span><span> 1</span><span> // exclusive</span></span>
<span data-line=""><span>    let</span><span> longestSubstring </span><span>=</span><span> 1</span></span>
<span data-line=""><span>    const</span><span> ss</span><span> =</span><span> s.</span><span>split</span><span>(</span><span>&#39;&#39;</span><span>)</span></span>
<span data-line=""><span>    let</span><span> workingChars </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    workingChars.</span><span>add</span><span>(ss[</span><span>0</span><span>])</span></span>
<span data-line=""><span>    let</span><span> longest </span><span>=</span><span> 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // abcabcbb length of 8</span></span>
<span data-line=""><span>    // so we start with a window of 0, 1</span></span>
<span data-line=""><span>    // And a set of just &#39;a&#39;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (start </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if</span><span> (workingChars.</span><span>has</span><span>(ss[end])){</span></span>
<span data-line=""><span>            workingChars </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        if</span><span> (workingChars.</span><span>has</span><span>(ss[end])){</span></span>
<span data-line=""><span>            workingChars </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>            start</span><span>++</span></span>
<span data-line=""><span>            if</span><span> (end </span><span>&lt;</span><span> start) end </span><span>=</span><span> start</span></span>
<span data-line=""><span>            continue</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        longest </span><span>=</span><span> Math.</span><span>max</span><span>(longest, end</span><span>-</span><span>start)</span></span>
<span data-line=""><span>        console.</span><span>log</span><span>({start, end, workingChars, longest})</span></span>
<span data-line=""><span>        workingChars.</span><span>add</span><span>(ss[end])</span></span>
<span data-line=""><span>        end</span><span>++</span></span>
<span data-line=""><span>        if</span><span> (end </span><span>&gt;</span><span> s.</span><span>length</span><span>) </span><span>break</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> longest</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>This approach uses a set, which seemed like a good approach. However it always seems to return the length of the entire string. I’m actually coming back to this after a couple days so I won’t even try to consider what I was trying to do here, I’ll just move onto a successful solurion.</p>
<p>I found this solution, which is very close to what I was aiming for:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="TS" data-theme="github-light github-dark"><code data-language="TS" data-theme="github-light github-dark"><span data-line=""><span>function lengthOfLongestSubstring(s: string): number {</span></span>
<span data-line=""><span>  let start=0, end=0, max=0;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  let mySet = new Set();</span></span>
<span data-line=""><span>  while(end &lt; s.length) {</span></span>
<span data-line=""><span>    if(!mySet.has(s[end])) {</span></span>
<span data-line=""><span>      mySet.add(s[end++]);</span></span>
<span data-line=""><span>      max = Math.max(max, mySet.size);</span></span>
<span data-line=""><span>    } else mySet.delete(s[start++]);</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  return max;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p><strong>Clever thing #1</strong>
Wow wild! I just learned that <code>end++</code> evaluates to the current value of end AND THEN increments afterwards. Would have though it evaluates to the incremented value.</p>
<p><strong>Clever thing #2</strong>
Also really interesting how they are using the set size. This is really clever - it allows the set data structure to have two jobs</p>
<ol>
<li>The obvious one of checking if we are still in non-repeat territory</li>
<li>An easy way to check the length of our window.</li>
</ol>
<p>Clever thing #3
Using<code>!mySet.has(...)</code> is more readable than starting with the <code>mySet.has(...)</code> case.</p>
<p>I think it is just as doable to do something like <code>end-start</code>, but not sure yet.</p>
<p>I’m just gonna go ahead and type this out in english because it’s fun.</p>
<p>I think it is just as doable to do something like <code>end-start</code>, but not sure yet.</p>
<p>I’m just gonna go ahead and type this out in english because it’s fun.</p>
<p>We have a string of length n. Start out with a collapsed window at the beginning of the string.
As long as the end of the window is less than the length (same as saying less than or equal to max index), go on one of two paths.</p>
<p>First, check if the that window contains duplicates. If not, update the current length if it’s longer than the previous length. Also increment the end for next go.</p>
<p>If it DOES contain duplicates, all we need to do is delete the duplicate value from the set and increment the start.
That’s really the most confusing part to me.
Incrementing the start, that makes sense. Move the window forward - keeping moving it forward until the dupe is gone. Although we should only have to move it forward once, as we are doing this AS SOON AS A DUPLICATE appears, so any duplicates that come up will always be at the beginning and end of the window.</p>
<p>As such, we move the window start forward.</p>
<p>But…why remove the current value from the set?</p>
<p>Well, the next thing that will be run is that <code> if(!mySet.has(s[end]))</code> line. If we didn’t remove the value from the set, we’d get stuck here, because we wouldn’t make it past this conditional and we’d go back to the duplicate case again, just moving the starting window farther and farther forward. In fact, the <code>while</code> loop would never finish, because <code>end</code> would stop progessing.</p>
<p>I have to tell myself ‘don’t worry!’ here. If we remove the duplicate value from the set, we now <em>do</em> make it past the <code>if(!mySet.has(s[end])</code> conditional, and the first thing we do in that conditional block as add or value. And then of course increment <code>end</code>! So next time through, we’ll catch a duplicate value - we won’t miss it.</p>
<p>In this way, the values added to the set are <em>always</em> the first instance of that value found.</p>
<p>I feel this is probably entirely clear by now <em>or</em> I am just getting more and more confusing, but maybe the easiest way to illustrate why/how this works is to take an example string, <code>abcabcdefg</code></p>
<p>Right when we start out, <code>end</code> is <code>0</code> so we check to see if <code>a</code> is in our set. It’s not, so we add it and increment <code>end</code> to point to an index of <code>1</code>.</p>
<p>Cool, now it’s <code>1</code>, so we move on. Everything is chill until <code>end</code> is <code>4</code>. At this point, we check that first conditional and find, oh shit! <code>a</code> IS already in our set! Don’t panic everyone.</p>
<p>BECAUSE <code>a</code> is already in our set, we’re going to halt forward incrementation of <code>end</code>. Instead, we’ll remove <code>a</code> from the set and we’ll move our <code>start</code> value to be 1, omitting that first <code>a</code>. Few. Okay now our window doesn’t include any dupes.</p>
<p>We go back and check that first conditional of <code>if (!mySet.has(s[end]))</code> and find that this time, our set has NO <code>a</code> value, which is the value of our current <code>end</code> of <code>4</code>. Dope. That means we can go ahead and add it, increment the end, and continue on our way. Once we get to the final index, we can exit our for loop, and whatever that longest window length was, that’s what our function returns.</p>
<p>Okay. I won’t use the expression “beating a dead horse” because that implies it’s productive to beat live horses, but I certainly spelled that out pretty clearly.</p>
<p>Let me see if I can write it without aide now.</p>
<p>YES. I got it! Should look almost the same:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, end </span><span>=</span><span> 0</span><span>, max </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> uniqueNums</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    const</span><span> finalIndex</span><span> =</span><span> s.</span><span>length</span><span> -</span><span> 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (end </span><span>&lt;=</span><span> finalIndex){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>uniqueNums.</span><span>has</span><span>(s[end])){</span></span>
<span data-line=""><span>            uniqueNums.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span>
<span data-line=""><span>            max </span><span>=</span><span> Math.</span><span>max</span><span>(max, uniqueNums.size)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> uniqueNums.</span><span>delete</span><span>(s[start</span><span>++</span><span>])</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> max</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Man that really felt like cheating. But I learned a lot more from studying someone else’s answer than my own uncoordinated code. The way I rationalize this - all too soon, I will forget this algo and get a chance to try it as if for the first time, with just an inkling of this method.</p>

<p>Peeked at the approach - couldn’t remember a ton of the details. Came up with this after 2 simple errors and 4:27 secons:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> longSub </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    // okay so the idea is create a window.</span></span>
<span data-line=""><span>    // The window starts super small</span></span>
<span data-line=""><span>    let</span><span> start</span><span>=</span><span>0</span><span>, end</span><span>=</span><span>0</span><span>, max </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    // So I&#39;m gonna make a set</span></span>
<span data-line=""><span>    // And check to see if I have seen a char from set, if so,</span></span>
<span data-line=""><span>    // move start forward</span></span>
<span data-line=""><span>    const</span><span> uniqueChars</span><span> =</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    while</span><span> (end </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>uniqueChars.</span><span>has</span><span>(s[end])){</span></span>
<span data-line=""><span>            uniqueChars.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span>
<span data-line=""><span>            longSub </span><span>=</span><span> Math.</span><span>max</span><span>(longSub, end</span><span>-</span><span>start)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            uniqueChars.</span><span>delete</span><span>(s[start</span><span>++</span><span>])</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> longSub</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Okay tried again, fixed it up again, was able to write it from memory in 59 seconds:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, end </span><span>=</span><span> 0</span><span>, max </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> q </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""><span>    while</span><span> (end </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>q.</span><span>has</span><span>(s[end])){</span></span>
<span data-line=""><span>            q.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span>
<span data-line=""><span>            max </span><span>=</span><span> Math.</span><span>max</span><span>(max, end</span><span>-</span><span>start)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> q.</span><span>delete</span><span>(s[start</span><span>++</span><span>])</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> max</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>

<p>I found the order of lines 7 and 8 matter:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> lengthOfLongestSubstring</span><span>(</span><span>s</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> start </span><span>=</span><span> 0</span><span>, end </span><span>=</span><span> 0</span><span>, max </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    const</span><span> uniqueChars</span><span>:</span><span> Set</span><span>&lt;</span><span>string</span><span>&gt; </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (end </span><span>&lt;</span><span> s.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>uniqueChars.</span><span>has</span><span>(s[end])){</span></span>
<span data-line=""><span>            uniqueChars.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span>
<span data-line=""><span>            max </span><span>=</span><span> Math.</span><span>max</span><span>(end</span><span>-</span><span>start, max)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> uniqueChars.</span><span>delete</span><span>(s[start</span><span>++</span><span>])</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    return</span><span> max</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>The incrementing line here actually does two functions - it increments <code>end</code> so we can continue, and it <em>also</em> adds one to end for this current permutation.</p>
<p>Correct:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>uniqueChars.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span>
<span data-line=""><span>max </span><span>=</span><span> Math.</span><span>max</span><span>(end</span><span>-</span><span>start, max)</span></span></code></pre></figure>
<p>Incorrect:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>max </span><span>=</span><span> Math.</span><span>max</span><span>(end</span><span>-</span><span>start, max)</span></span>
<span data-line=""><span>uniqueChars.</span><span>add</span><span>(s[end</span><span>++</span><span>])</span></span></code></pre></figure>
<p>Take the following example:
<code>a--b--c--d--a--b--c</code>
<code>0--1--2--3--4--5--6</code></p>
<p><code>abcd</code> is the longest string. As I iterate through my algo, the farthest I’ll get before adjusting my <code>start</code> value is <code>3</code>.</p>
<p><code>3-0</code> is of course ‘3’, but the longest string I’ve found here is <code>abcd</code>, with a length of 4. So by placing the incrementing <em>before</em> the length evaluation line, I can correctly evaluate the length of a the 0-indexed string. Super eloquent! Because I grabbed this answer from someone else, I didn’t realize I was doing this.</p>
<p>Another thing I didn’t totally realize was that JS and TS allowed strings to be accessed by index without be converted into an array.</p>
<p><strong>Tried again</strong>
And made a silly omission it took me a while to find - I did <code>Math.max(right, max)</code>
instead of <code>Math.max(right-left, max)</code>, as just discussed.</p></article></div>
  </body>
</html>
