<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mathspp.com/blog/how-to-create-a-python-package-in-2022">Original</a>
    <h1>How to create a Python package in 2022</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>How do you create a Python package? How do you set up automated testing and code coverage? How do you publish the package? That&#39;s what this article teaches you.</p>

        <!--
<div class="notices green">
<p>Want to improve your Python üêç problem-solving skills?
The Python Problem-Solving Bootcamp is just starting!
<a href="https://mathspp.gumroad.com/l/pythonbootcamp">Join now</a>!</p>
</div>-->
        
<figure><img title="Photo by Claudio Schwarz on Unsplash." alt="The back of a delivery truck stuffed with cardboard packages, piled on top of each other." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/thumbnail.png"/><figcaption>Photo by Claudio Schwarz on Unsplash.</figcaption></figure>

<p>In order to create a Python package, you need to write the code that implements the functionality you want to put in your package,
and then you need to publish it to <a href="https://pypi.org" target="_blank" rel="nofollow noopener noreferrer">PyPI</a>.
That is the bare minimum.</p>
<p>Nowadays, you can also set up a variety of other things to make your life easier down the road:</p>
<ul>
<li>continuous testing of your package;</li>
<li>code coverage reports;</li>
<li>pre-commit hooks (to ensure proper code formatting, for example);</li>
<li>automatic publishing to <a href="https://pypi.org" target="_blank" rel="nofollow noopener noreferrer">PyPI</a> every time you make a new release;</li>
<li>...</li>
</ul>
<p>This article will guide you through all of these steps.
I want to create a Python package with all the bells and whistles,
so I need to figure out how that is done.
However, be mindful that this article is my account of my findings as I try to figure out how to set everything up myself.
If you notice I am doing something wrong, <em>do</em> let me know!</p>
<p>Again, this article contains <strong>more than what is needed</strong> to create and publish a Python package.
If you want the bare minimums (and depending on what you define as ‚Äúthe bare minimums‚Äù),
it should be enough to read up until the section ‚Äú<a href="#write-tests">Write tests</a>‚Äù.</p>

<p>Typically, if you are creating a Python package, that&#39;s either because you have some code you would like to share with others,
or because you have an <em>idea</em> for something you would like to share.</p>
<p>In my case, I want to package the <a href="https://mathspp.com/blog/custom-json-encoder-and-decoder">custom JSON encoder and decoder</a> mechanism I wrote about recently,
which allows you to <a href="https://mathspp.com/blog/custom-json-encoder-and-decoder#extending-the-json-format">extend the JSON standard</a>.</p>

<p>I will start by setting up the dependency management of my package, and I will use <a href="https://python-poetry.org/" target="_blank" rel="nofollow noopener noreferrer">Poetry</a>.
The reason I&#39;m going for <a href="https://python-poetry.org/" target="_blank" rel="nofollow noopener noreferrer">Poetry</a> in this article is because I see a lot of other packages using it successfully,
so I reckon they are probably doing something right.</p>
<p>(I confess I frequently check how the <a href="https://github.com/textualize/" target="_blank" rel="nofollow noopener noreferrer">Textualize repositories</a> are set up,
and I try to mimic that.
They use <a href="https://python-poetry.org/" target="_blank" rel="nofollow noopener noreferrer">Poetry</a>, so I&#39;ll do the same.)</p>
<h2>Pick a name</h2>
<p>[Naming matters][pydont-naming-matters] <strong>a lot</strong> in programming.
You do not need a definitive name for your package at this point, but I know I want my package to be called <code>extendedjson</code>,
so I can actually start creating everything with the correct name.</p>
<p>When picking a name for your package, make sure to head over to <a href="https://pypi.org" target="_blank" rel="nofollow noopener noreferrer">PyPI</a> and check if it is available!</p>
<h2>Initialise the project with Poetry</h2>
<p>Go ahead and create a folder with your package name.
That&#39;s <code>extendedjson</code> for me.</p>
<p>Then, inside that folder, create a new project with <a href="https://python-poetry.org/" target="_blank" rel="nofollow noopener noreferrer">Poetry</a> by running the command</p>
<pre><code>poetry new .</code></pre>
<p>This will set up a couple of things for you:</p>
<pre><code>extendedjson
‚îú‚îÄ‚îÄ‚îÄextendedjson
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ__init__.py
‚îú‚îÄ‚îÄ‚îÄtests
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄ__init__.py
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄtest_extendedjson.py
‚îú‚îÄ‚îÄ‚îÄpyproject.toml
‚îî‚îÄ‚îÄ‚îÄREADME.rst</code></pre>
<p>Take a look at the file <code>pyproject.toml</code>, which was filled in with some default information for me:</p>
<pre><code>[tool.poetry]
name = &#34;extendedjson&#34;
version = &#34;0.1.0&#34;
description = &#34;&#34;
authors = [&#34;Rodrigo Gir√£o Serr√£o &lt;5621605+RodrigoGiraoSerrao@users.noreply.github.com&gt;&#34;]

[tool.poetry.dependencies]
python = &#34;^3.8&#34;

[tool.poetry.dev-dependencies]
pytest = &#34;^5.2&#34;

[build-system]
requires = [&#34;poetry-core&gt;=1.0.0&#34;]
build-backend = &#34;poetry.core.masonry.api&#34;</code></pre>
<p>The TOML file contains settings and configurations for your package,
and each heading inside the square brackets <code>[]</code> defines a section.
For example, the file starts with the section <code>[tool.poetry]</code> where we have some configuration options for Poetry itself.
Then, we have the package dependencies, which amount to Python, for now.
After that, we have dependencies that are specific to the development of the package, i.e., things that you depend on when you are implementing functionality, testing your code, etc., but that aren&#39;t really needed by the end user.
Finally, we see some settings for the build system.</p>
<p>We are going to go ahead and leave the defaults as-is, because they are aligned with what I want right now.
The only thing I&#39;ll change is the file <code>README.rst</code>, because I prefer markdown files over reStructured Text.</p>
<p>After creating a new project, we can use Poetry to install all the dependencies in a virtual environment:</p>
<pre><code>poetry install</code></pre>
<p>This should create a file <code>poetry.lock</code> in your root directory, containing information about the specific versions of all the installed dependencies.</p>
<p>I did this already because I won&#39;t be having many dependencies,
but you can check <a href="https://python-poetry.org/" target="_blank" rel="nofollow noopener noreferrer">Poetry</a>&#39;s documentation on how to add more dependencies,
or you can keep reading and I&#39;ll show you how in a second.</p>

<p>Now that we have the file structure set up, I will initialise a GitHub repository to host the code:</p>
<pre><code>git init
git add *
git commit -m &#34;First commit&#34;
git branch -M main
git remote add origin https://github.com/mathspp/extendedjson.git
git push -u origin main</code></pre>
<p>And we&#39;re live!
The <a href="https://github.com/mathspp/extendedjson" target="_blank" rel="nofollow noopener noreferrer"><code>extendedjson</code> repository</a> is up!</p>
<h2>Set up some pre-commit hooks</h2>
<p>The next thing we are doing is setting up some commit hooks.
This is just an extra step I&#39;m taking because it helps keep things homogeneous.</p>
<p>For example, we can easily set up a pre-commit hook that ensures files will never have extra whitespace hanging at the end of lines,
or we can <a href="https://mathspp.com/blog/til/run-black-formatter-on-pre-commit">set up <code>black</code> as a pre-commit hook</a> to make sure all code is always properly formatted.</p>

<p>First, we add <code>pre-commit</code> as a <em>development</em> dependency with Poetry:</p>
<pre><code>poetry add -D pre-commit</code></pre>
<p>Then, we commit the updated dependencies:</p>
<pre><code>git add poetry.lock pyproject.toml
git commit -m &#34;Add pre-commit devt dependency.&#34;</code></pre>
<p>Now, to set up <code>pre-commit</code>, we create a file <code>.pre-commit-config.yaml</code> in the root directory,
and we just set it up how we want.
This is how my <code>.pre-commit-config.yaml</code> file looks like:</p>
<pre><code># See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.0.1
    hooks:
      - id: check-toml
      - id: check-yaml
      - id: end-of-file-fixer
      - id: mixed-line-ending
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black
  - repo: https://github.com/PyCQA/isort
    rev: 5.10.1
    hooks:
      - id: isort
        args: [&#34;--profile&#34;, &#34;black&#34;]</code></pre>
<p>After this, we install the hooks and then we run them once, just for good measure.</p>
<pre><code>pre-commit install
pre-commit run all-files</code></pre>
<p>Make sure your Poetry virtual environment is active!
Running <code>poetry shell</code> will do the trick.</p>
<p>Now it is time to commit the changes to the repository,
the ones from adding the new dependency and then the ones that came from running the pre-commit hooks:</p>
<pre><code>git add pyproject.toml poetry.lock .pre-commit-config.yaml
git commit -m &#34;Add pre-commit devt dependency.&#34;
git add *
git commit -m &#34;Run all pre-commits.&#34;
git push</code></pre>

<p>Woops! Maybe I should have done this sooner, but I don&#39;t think it is too far down the road for me to do this now!
For this project, I am going with the permissive MIT license,
but bear in mind that your project might have different needs!</p>
<p>Adding the MIT license can be done from the repository webpage,
so I will do just that and then I&#39;ll actually pull the license into the local repository.</p>

<p>Now I will try to upload the stub package to the <strong>test</strong> PyPI repository, https://test.pypi.org.
This lets everyone test their packaging/publishing workflows without messing with the real repository.</p>
<h2>Configure the test repository</h2>
<p>First, we tell Poetry about this test repository:</p>
<pre><code>poetry config repositories.testpypi https://test.pypi.org/legacy/</code></pre>
<p>This makes it so that Poetry is aware of that repository, which we called <code>testpypi</code>.</p>
<h2>Get an API key</h2>
<p>Next up, we need to get an API key so that Poetry can actually push to the <code>testpypi</code> repository.
For that, you need to <a href="https://test.pypi.org/account/register/" target="_blank" rel="nofollow noopener noreferrer">create an account on TestPyPI</a> and then create a new API key under your account settings.</p>
<p>After grabbing your API key, you can configure Poetry to use it:</p>
<pre><code>poetry config http-basic.testpypi __token__ pypi-your-api-token-here</code></pre>
<h2>Build and upload your package</h2>
<p>The step immediately before uploading your package is building it!
After building the package, you can try uploading it to TestPyPI:</p>
<pre><code>poetry build
poetry publish -r testpypi</code></pre>
<p>Once you have done that, and assuming all goes well,
your package should be <a href="https://test.pypi.org/project/extendedjson/" target="_blank" rel="nofollow noopener noreferrer">live on TestPyPI</a>.</p>
<figure><img title="Screenshot of `extendedjson` uploaded to TestPyPI." alt="Screenshot of TestPyPI where it is visible that a stub for `extendedjson` was successfully uploaded." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_testpypi.png"/><figcaption>Screenshot of `extendedjson` uploaded to TestPyPI.</figcaption></figure>
<h2>Ignore the build products</h2>
<p>When you build your package, a folder <code>dist</code> is created,
and that&#39;s where you can find the things that Poetry built for you.</p>
<p>We don&#39;t want to push these to GitHub, so we&#39;ll go ahead and add the folder <code>dist</code> to the <code>.gitignore</code> file.</p>

<p>The next thing we are going to do is to actually populate the package with the actual code,
and then publish it to the real <a href="https://pypi.org" target="_blank" rel="nofollow noopener noreferrer">PyPI</a> repository.</p>
<h2>Add the code</h2>
<p>So, I will start by grabbing my <a href="https://mathspp.com/blog/custom-json-encoder-and-decoder">custom JSON encoder and decoder mechanism</a>,
and put it in the <code>extendedjson/__init__.py</code> file.</p>
<h2>Changelog management</h2>
<p>Next, I want to record this change in a changelog, so I will add one more development dependency, <a href="https://pypi.org/project/scriv/" target="_blank" rel="nofollow noopener noreferrer">scriv</a>.
Scriv is a command-line tool for helping developers maintain useful changelogs.</p>
<p>This step is entirely optional, but I like using scriv,
so I&#39;ll briefly describe what I did to set it up.</p>
<p>Once again, adding a development dependency with Poetry is straightforward:</p>
<pre><code>poetry add -D scriv[toml]</code></pre>
<p>Next, I configure scriv in my file <code>pyproject.toml</code> to use markdown files for the changelog fragments,
I create the directory <code>changelog.d</code> where the changelog fragments will live,
and now I can create a fragment that keeps track of my code change:</p>
<pre><code>scriv create</code></pre>
<p>Scriv will now create a small file where I&#39;m supposed to jot down the changes I made.
In my case, it&#39;s just this:</p>
<pre><code>### Added

- Classes `ExtendedEncoder` and `ExtendedDecoder` to allow extension of the JSON format.</code></pre>
<h2>Committing everything</h2>
<p>At this point there is a lot that needs to be committed:</p>
<pre><code>git add pyproject.toml poetry.lock changelog.d/.gitkeep
git commit -m &#34;Add scriv as devt dependency.&#34;
git add changelog.d/* extendedjson/__init__.py
git commit -m &#34;Add ExtendedEncoder and ExtendedDecoder.&#34;</code></pre>

<p>Now that we have real code to distribute, we can publish it to the real PyPI repository!</p>
<h2>Configure PyPI</h2>
<p>Because Poetry is built with Python in mind, configuring PyPI is a tad easier than TestPyPI.
Simply go to your <a href="https://pypi.org" target="_blank" rel="nofollow noopener noreferrer">PyPI</a> account (create one if needed!),
grab an API key,
and then tell Poetry to use it:</p>
<pre><code>poetry config pypi-token.pypi pypi-your-token-here</code></pre>
<h2>Build and publish</h2>
<p>Now we can publish our code, but we <strong>must build it first</strong>,
which we do with the flag <code>--build</code>:</p>
<pre><code>poetry publish --build</code></pre>
<p>There it goes!
Now you can <a href="https://pypi.org/project/extendedjson/" target="_blank" rel="nofollow noopener noreferrer">get <code>extendedjson</code> from PyPI</a>!</p>
<figure><img title="A screenshot of the `extendedjson` page on PyPI." alt="&#34;A screenshot of the `extendedjson` page on PyPI, showing it was successfully uploaded.&#34;" src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_pypi.png"/><figcaption>A screenshot of the `extendedjson` page on PyPI.</figcaption></figure>
<h2>Do a victory lap</h2>
<p>After uploading a new project to PyPI for the first time, I always like doing a small victory lap...</p>
<p>I just install the module, import it, exit Python, and then uninstall it:</p>
<pre><code>Œª python -m pip install extendedjson
# ...

Œª python
Python 3.9.7 (tags/v3.9.7:1016ef3, Aug 30 2021, 20:19:38) [MSC v.1929 64 bit (AMD64)] on win32
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; import extendedjson as xjson
&gt;&gt;&gt; xjson.ExtendedEncoder
&lt;class &#39;extendedjson.ExtendedEncoder&#39;&gt;
&gt;&gt;&gt; exit()

Œª python -m pip uninstall extendedjson
Found existing installation: extendedjson 0.1.0
Uninstalling extendedjson-0.1.0:
  Would remove:
    c:\users\rodri\appdata\roaming\python\python39\site-packages\extendedjson-0.1.0.dist-info\*
    c:\users\rodri\appdata\roaming\python\python39\site-packages\extendedjson\*
Proceed (Y/n)? y
  Successfully uninstalled extendedjson-0.1.0

Œª # Victory lap completed.</code></pre>
<figure><img title="`extendedjson` being used in the REPL." alt="&#34;A screenshot of a terminal window showing `extendedjson` being used inside a Python REPL.&#34;" src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_extendedjson_repl.png"/><figcaption>`extendedjson` being used in the REPL.</figcaption></figure>

<p>Let&#39;s prepare a GitHub release for version 0.1.0.</p>
<h2>Prepare the release</h2>
<p>I&#39;ll start by putting <em>some</em> info on the README file, which is currently empty.
I&#39;ll also let Poetry know that the package information is in there, by specifying</p>
<pre><code>readme = &#34;README.md&#34;</code></pre>
<p>in the file <code>pyproject.toml</code>.</p>
<p>The first sentence will be a short description of what <code>extendedjson</code> is for,
which I&#39;ll also add as the project description under the Poetry configurations.
Next, I&#39;ll add a short example and link to the article where I wrote about the code.</p>
<p>Finally, I&#39;ll use scriv to collect the changelog fragment into the CHANGELOG file that I&#39;ll use:</p>
<pre><code>scriv collect</code></pre>
<p>Then, I&#39;ll take the short sentence from the README file and make it the repository description.
And I&#39;ll also add some subject tags.</p>
<h2>Tag the commit history</h2>
<p>After all these nice changes are into place and committed,
let&#39;s tag the commit history to say that <em>this</em> point in time is version 0.1.0:</p>
<pre><code>git tag -a v0.1.0 -m &#34;Initial version.&#34;</code></pre>
<p>And now, it&#39;s release time!</p>
<p>I tried using the command <code>scriv github-release</code> to do the release for me,
but something wasn&#39;t working, so I made the release manually.</p>
<h2>Publish the release</h2>
<p>After you create a tag, it is very straightforward to create a release!
Just go to the <code>/tags</code> page in your repository and click the three dots next to your tag:
it will have an option to create a release out of that tag.</p>

<p>Some may say I should have done this sooner, but let&#39;s write tests for our code.
Poetry already created a directory <code>tests</code> for us,
together with a file <code>tests/test_extendedjson.py</code>:</p>
<pre><code>from extendedjson import __version__

def test_version():
    assert __version__ == &#34;0.1.0&#34;</code></pre>
<p>We&#39;ll extend these tests to actually cover the functionality that the package provides.</p>
<p>To run all the tests, all you need to do is run the command <code>pytest</code>:</p>
<pre><code>Œª pytest
========================= test session starts =========================
platform win32 -- Python 3.8.5, pytest-5.4.3, py-1.11.0, pluggy-0.13.1
rootdir: C:\Users\rodri\Documents\Programming\extendedjson
collected 5 items

tests\test_extendedjson.py .....                                 [100%]

========================== 5 passed in 0.06s ==========================</code></pre>
<p>After adding tests, we commit them and prepare a patch release for version 0.1.1.</p>

<h2>Understanding tox</h2>
<p><a href="https://tox.wiki/en/latest/" target="_blank" rel="nofollow noopener noreferrer">tox</a> is a tool that aims to automate and standardise testing in Python,
and it is a tool that I want to set up to automate a lot of tasks:</p>
<ul>
<li>testing (with <code>pytest</code>);</li>
<li>linting (with <code>flake8</code>, <code>pylint</code>, <code>mccabe</code>);</li>
<li>formatting (with <code>black</code>);</li>
<li>test coverage (with <code>coverage</code>); and</li>
<li>later on, building the documentation.</li>
</ul>
<p>At the time of writing, <a href="https://tox.wiki/en/latest/example/basic.html#pyproject-toml-tox-legacy-ini" target="_blank" rel="nofollow noopener noreferrer">tox doesn&#39;t yet have native support to be configured from <code>pyproject.toml</code></a>,
so we&#39;ll configure tox in the standard way, which is through a file <code>tox.ini</code>.</p>
<p>I was trying to understand what my file <code>tox.ini</code> was going to look like, based off of another file <code>tox.ini</code>:</p>
<pre><code>[tox]
isolated_build = True
envlist = py37,py38,py39

[testenv]
deps =
    black
    coverage
    flake8
    mccabe
    mypy
    pylint
    pytest
commands =
    black podsearch
    flake8 podsearch
    pylint podsearch
    mypy podsearch
    coverage erase
    coverage run --include=podsearch/* -m pytest -ra
    coverage report -m</code></pre>
<p>The section <code>deps</code> lists the dependencies that tox needs,
and the section <code>commands</code> lists all the commands that tox will run for us.</p>
<p>I have been trying to understand what dependencies go in <code>deps</code>,
and what dependencies go in <code>pyproject.toml</code>.</p>
<p>As I understand it, the command <code>poetry add</code> manages your (development) dependencies
for things that you need to use directly,
either while using the package or while developing the package.
The dependencies listed in tox are all the dependencies for the commands that tox will run,
<em>even if there is overlap</em>.
That is because tox manages virtual environments for the dependencies,
and those virtual environments are independent from Poetry&#39;s.</p>
<p>I was also trying to understand what the option <code>isolated_build</code> does.
<a href="https://tox.wiki/en/latest/example/package.html" target="_blank" rel="nofollow noopener noreferrer">Reading the docs</a>, I understand that tox builds packages following a default procedure,
which differs from the procedure that Poetry follows.
So, <code>isolated_build = True</code> probably tells tox that building will be handled by another tool/in some other way.</p>
<h2>A simple tox configuration</h2>
<p>For a very first try, I created a simple file <code>tox.ini</code> with just a couple of dependencies:</p>
<pre><code>[tox]
isolated_build = True
envlist = py38,py39,py310

[testenv]
deps =
    black
    pytest
commands =
    black --check extendedjson
    pytest .</code></pre>
<p>This will test my package on Python versions 3.8, 3.9, and 3.10,
and it will check that the code is well-formatted and it will run the tests.
That&#39;s it.</p>
<h2>Running tox</h2>
<p>To run tox, I can either run everything with the simple command</p>
<pre><code>Œª tox</code></pre>
<p>or I can run a single environment by specifying it.
For example, if I only want to run all the commands for Python 3.10,
I would use the following command:</p>
<pre><code>Œª tox -e py310</code></pre>
<p>The first time an environment is ran, tox has to do some setup,
but most of the setup is cached, so subsequent runs should be faster!</p>
<p>When you run tox, and if all goes well,
you should see a couple of success messages at the end:</p>
<pre><code>Œª tox
# ...
  py38: commands succeeded
  py39: commands succeeded
  py310: commands succeeded
  congratulations :)</code></pre>
<h2>Expanding the tox configuration</h2>
<p>Now that I&#39;ve seen how tox works, I feel more confident in expanding the configuration:</p>
<pre><code>[tox]
isolated_build = True
envlist = py38,py39,py310

[testenv]
deps =
    black
    flake8
    isort
    mccabe
    pylint
    pytest
commands =
    black --check extendedjson
    isort --check extendedjson
    flake8 extendedjson --max-complexity 10
    pylint extendedjson
    pytest .</code></pre>
<p>The configuration was extended to include flake8, pylint, and the mccabe complexity checker.
(The complexity checker is a plugin for flake8,
and it&#39;s why I added the <code>--max-complexity 10</code> argument to the command <code>flake8 extendedjson</code>.)</p>
<p>Running tox now blows right in my face, because pylint says my code quality is just 5.22 out of 10!
Well, that sucks!</p>

<p>There is no point in automating all these tests and checks if then we ignore the output,
so let&#39;s improve the code quality of the package.
Thankfully, pylint tells me exactly what the issues are:</p>
<pre><code>************* Module extendedjson
extendedjson\__init__.py:1:0: C0114: Missing module docstring (missing-module-docstring)
extendedjson\__init__.py:6:0: C0115: Missing class docstring (missing-class-docstring)
extendedjson\__init__.py:7:4: W0237: Parameter &#39;o&#39; has been renamed to &#39;obj&#39; in overridden &#39;ExtendedEncoder.default&#39; method (arguments-renamed)
extendedjson\__init__.py:7:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
extendedjson\__init__.py:19:0: C0115: Missing class docstring (missing-class-docstring)
extendedjson\__init__.py:24:4: C0116: Missing function or method docstring (missing-function-docstring)
extendedjson\__init__.py:24:4: E0202: An attribute defined in json.decoder line 319 hides this method (method-hidden)</code></pre>
<p>These were all fixed in a fairly small <a href="https://github.com/mathspp/extendedjson/commit/6a58086cdfadcf4085eea2a39a766dd20df257ba" target="_blank" rel="nofollow noopener noreferrer">commit</a>,
and now tox is all happy again:</p>
<pre><code>Œª tox
# ...
  py38: commands succeeded
  py39: commands succeeded
  py310: commands succeeded
  congratulations :)</code></pre>

<p>Now I want to setup code coverage!
I hope this is easy enough...</p>
<p>I started by going to the <a href="https://coverage.readthedocs.io/en/6.4.1/index.html" target="_blank" rel="nofollow noopener noreferrer">coverage.py documentation</a> and followed the steps indicated.
Two minutes later, I already had my first coverage report:</p>
<figure><img title="Screenshot of my first coverage report." alt="A screenshot of a simple, dark webpage containing the coverage.py coverage report of my package. It shows a couple of highlighted red lines which correspond to code that has not been covered." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_coverage_report.png"/><figcaption>Screenshot of my first coverage report.</figcaption></figure>
<p>To build this report, all I did was</p>
<ol>
<li>install coverage.py with <code>python -m pip install coverage</code>;</li>
<li>use coverage.py to run my tests with <code>coverage run --source=extendedjson --branch -m pytest .</code>; and</li>
<li>create the HTML report with <code>coverage html</code>.</li>
</ol>
<p>The command that runs coverage.py could have been as simple as <code>coverage run -m pytest .</code>,
but I used the two arguments you can see above to tweak the execution:</p>
<ul>
<li>
<code>--source=extendedjson</code> says we care about the coverage of the code inside <code>extendedjson</code>,
which can find files in that folder that haven&#39;t been touched <em>and</em> it ignores the source code in the tests.</li>
<li>
<code>--branch</code> tells coverage.py to investigate which branching paths are and are not taken in the code,
which is more fine-grained than just checking which statements run.</li>
</ul>
<h2>Running coverage.py with tox</h2>
<p>For this test run of coverage.py, I ran everything locally and by hand.
What I want to do now is to have tox run coverage.py for me.
For that, I just need to add coverage.py to the dependency list in the file <code>tox.ini</code>
and then I need to add the two relevant coverage.py commands in the list of commands:</p>
<pre><code>[tox]
isolated_build = True
envlist = py38,py39,py310

[testenv]
deps =
    black
    coverage
    # ...
commands =
    # ...
    coverage run --source=extendedjson --branch -m pytest .
    coverage report -m</code></pre>
<p>This sets up tox to run coverage.py for me.
However, there is something that isn&#39;t clear yet:
do I want tox to fail if code coverage isn&#39;t 100%?
Or am I using tox simply for the fact that it does automate the code coverage report generation?</p>
<p>Either way, I only have 85% code coverage right now, so let&#39;s work on improving that.</p>
<h2>100% code coverage</h2>
<p>To achieve 100% code coverage I need to make sure that each statement in my code runs at least once when the tests run.
At this point, this just means that I need to write a couple of tests for which encoding and decoding fails,
because those are the cases that I haven&#39;t covered yet.</p>
<p>This is not terribly difficult to do, which means I eventually got to 100% code coverage:</p>
<figure><img title="Screenshot of the 100% code coverage report." alt="A screenshot of the code coverage report header, with a bright arrow pointing to the 100% code coverage value." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_coverage_100.png"/><figcaption>Screenshot of the 100% code coverage report.</figcaption></figure>
<p>Having done that, now is a good time to make a new minor release (0.1.2) that contains full code coverage.</p>
<h2>Forcing 100% code coverage</h2>
<p>Right now, tox will run code coverage and it will build the coverage report,
but it will succeed, regardless of the coverage percentage achieved.</p>
<p>If you specify a level of code coverage that you want to always have,
like 100%, you could modify your tox configuration:
as it turns out, the command <code>coverage report</code> accepts an argument <code>--fail-under</code>
that tells coverage.py to exit with a non-zero status code if the coverage is below a certain threshold.
This means tox would say you failed.</p>
<p>To configure tox in this way, just modify your coverage report command:</p>
<pre><code># ...

commands =
    # ...
    coverage run --source=extendedjson --branch -m pytest .
    coverage report -m --fail-under 100  # This can be another target threshold.</code></pre>
<p>Right now, I&#39;m not sure if I&#39;ll set tox to fail when the code coverage is under 100,
so I&#39;ll leave this alone for now.</p>

<p>GitHub Actions is a service that GitHub provides that lets you run your workflows in the cloud.
For example, linting your code and running the tests.
What is more, these <em>actions</em> that you run can be customised to trigger at specific times,
for example, when we push code to the main branch or when people make pull requests against that branch.</p>
<h2>Running linters and tests</h2>
<p>GitHub Actions are defined by YAML files that live in the directory <code>.github/workflows</code>,
so we are going to go ahead and create the file <code>.github/workflows/build.yaml</code>.
This will define a GitHub action that runs tox.</p>
<p>In order to set this up and test it while I go, I created a new branch <code>1.3</code>.
This release will contain a bit more functionality in the code itself,
and the CI/CD we are setting up <em>right now</em>.</p>
<p>By cross-referencing some sources, I came up with the YAML file you can find below.
I will go over what everything means in just a second.</p>
<pre><code># .github/workflows/build.yaml
name: extendedjson CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [&#34;3.8&#34;, &#34;3.9&#34;, &#34;3.10&#34;]

    steps:
      - name: Checkout sources
        uses: actions/checkout@v2

      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install tox tox-gh-actions
      - name: Run tox
        run: tox</code></pre>
<p>After saving the file, I committed it, pushed it to GitHub,
and then created a pull request from the branch <code>1.3</code> into <code>main</code>.
Because of the newly added GitHub Action, a couple of things started happening when the PR was made.</p>
<p>After a couple of seconds, I got a green checkmark next to the commit and GitHub told me that ‚ÄúAll checks have passed‚Äù,
next to the button that lets me merge the pull request:</p>
<figure><img title="GitHub Actions ran three successful checks." alt="A screenshot of the GitHub pull request interface, where I can see a lot of reassuring green checks and messages, saying my GitHub Action has run successfully." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_all_checks_passed.png"/><figcaption>GitHub Actions ran three successful checks.</figcaption></figure>
<p>By clicking the link ‚Äúshow all checks‚Äù or by navigating to the tab ‚ÄúActions‚Äù,
which is right next to the tab ‚ÄúPull requests‚Äù, you can see more information regarding the run.
When we open that interface, we get an overview of all the workflows we have and the latest runs.
On the left, we can find the workflows identified by the <code>name</code> information we defined at the top of the YAML file.</p>
<figure><img title="The workflow name, as defined in the YAML file." alt="A screenshot of the GitHub Actions tab where we can see the workflow we just set up, identified by its name." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_workflow_name.png"/><figcaption>The workflow name, as defined in the YAML file.</figcaption></figure>
<p>I am getting too carried away, explaining how all of this works, so let me cut to the chase:
while I was taking a look around, I noticed that running tox had taken <strong>zero</strong> seconds.
When I looked closer, I realised tox wasn&#39;t running a single environment...</p>
<p>As it turns out, I was making use of the tox plugin <code>tox-gh-actions</code> but I didn&#39;t set it up correctly yet.
Remember that tox can run all your linting and testing in isolated environments for multiple Python versions.
As it turns out, we can also ask GitHub Actions to run our checks in multiple Python versions...
But we don&#39;t want GitHub Actions to go over all the Python versions I care about,
and then have tox test all Python versions again, because that would duplicate a lot of effort.</p>
<p>Instead, we use <code>tox-gh-actions</code> to let tox know which environments should run,
and we define that in the file <code>tox.ini</code>, to which I added this configuration:</p>
<pre><code>[gh-actions]
python =
    3.8: py38
    3.9: py39
    3.10: py310</code></pre>
<p>This maps Python version from the GitHub action to the tox environments we care about.
I added this configuration and committed it, which triggered the workflow again...
And this time, it failed!
It failed because my new code hadn&#39;t been linted yet,
and one of the linters complained.
I proceeded to fixing the code and committing the changes, until I had a passing build.</p>
<p>Now that GitHub Actions is happy, let me briefly go over what I set up in the YAML file:</p>
<p>First, I defined the name of the workflow with <code>name: ...</code>.
Then, I defined the triggers for the workflow:</p>
<pre><code>on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]</code></pre>
<p>This means the workflow runs when code is pushed to the branch <code>main</code> or when people open pull requests for the branch <code>main</code>.
Finally, we define the things that actually need to run by defining ‚Äújobs‚Äù, which are just a series of steps you want to go over.
Jobs are defined in <code>jobs:</code>, and you can have multiple of them.
In our case, we only have a single job called <code>build</code>:</p>
<pre><code>jobs:
  build: ...</code></pre>
<p>Notice that the fact that the file is <code>build.yaml</code> and this job is called <code>build</code> is for consistency,
but none of these names have any real effect on what GitHub Actions does for us.</p>
<p>After creating a job, we need to specify what are its steps, i.e., the sequence of actions that need to happen.
That&#39;s what the section <code>steps</code> is for:</p>
<pre><code>jobs:
  build:
    # ...

    steps:
      - name: Checkout sources
        uses: actions/checkout@v2

      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install tox tox-gh-actions

      - name: Run tox
        run: tox</code></pre>
<p>Each step may run commands or make use of other actions.
The first two steps make use of actions provided by GitHub:</p>
<ol>
<li>the first action, <code>checkout</code>, clones your repository into the machine running the action; and</li>
<li>the second action installs Python on that machine.</li>
</ol>
<p>By using <code>with: python-version: ...</code> we can specify which Python version we want.
And then, instead of hardcoding a Python version, we use the variable <code>matrix.python-version</code>.
What&#39;s that?</p>
<p>Well, above the steps, we defined a ‚Äúmatrix strategy‚Äù,
which just means we are going to run this job for different combinations of variables that we care about.
In our case, we just want to run this job for multiple Python versions:</p>
<pre><code>jobs:
  build:
    # ...
    strategy:
      matrix:
        python-version: [&#34;3.8&#34;, &#34;3.9&#34;, &#34;3.10&#34;]</code></pre>
<p>So, <code>strategy: matrix: ...</code> means we can specify our custom variables (like <code>python-version</code>) and then the job will run for each value of that variable.
In our case, we specified Python versions 3.8, 3.9, and 3.10.</p>
<p>Finally, we upgrade <code>pip</code>, install tox and the GH Actions plugin, and then run tox.</p>
<p>The only thing that I didn&#39;t cover yet is the <code>runs-on: ubuntu-latest</code>,
which just specifies the operating system (and version) that the host machine is running on.</p>
<p>You should check <a href="https://docs.github.com/en/actions" target="_blank" rel="nofollow noopener noreferrer">the GitHub Actions documentation</a> for more information on all of this.</p>
<h2>Integrating with Codecov</h2>
<p>After setting up the initial version of CI, I noticed my checks were passing but I only had 77% code coverage.
So, I ended up setting coverage.py to fail when my coverage isn&#39;t 100%.
I did that by going to the file <code>tox.ini</code> and adding <code>--fail-under 100</code> to the command <code>coverage report -m</code>:</p>
<pre><code># ...

[testenv]
# ...
commands =
    # ...
    coverage report -m --fail-under 100</code></pre>
<p>I added tests to get my coverage to 100% and I committed those tests.
Next, I will integrate <a href="https://about.codecov.io/" target="_blank" rel="nofollow noopener noreferrer">Codecov</a> with my project, so that we get nice code coverage reports on pull requests.
I&#39;ll start by logging in with my GitHub account over at the <a href="https://about.codecov.io/" target="_blank" rel="nofollow noopener noreferrer">Codecov website</a>,
and then I just need to modify my workflow YAML file to upload the coverage data to Codecov.
This needs to happen <em>after</em> tox has run:</p>
<pre><code># ...
jobs:
  build:
    # ...

    steps:
      # ...

      - name: Run tox
        run: tox

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v2
        with:
            fail_ci_if_error: true</code></pre>
<p>On top of this, we do one other minor modification on the <code>on</code> dictionary:</p>
<pre><code>name: extendedjson CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# ...</code></pre>
<p>By adding <code>workflow-dispatch:</code>, we make it possible to rerun a workflow that completed successfully.
From <a href="https://hynek.me/articles/python-github-actions/#coverage" target="_blank" rel="nofollow noopener noreferrer">other sources I read</a>, it looks like this might be needed in some weird cases when Codecov fails to do what it should be doing.</p>
<p>Commit all the changes and push, and let us see if I was able to set everything up correctly!
And it was not! Codecov was not finding the coverage report because I wasn&#39;t writing a coverage report in a format understood by Coverage.
All I had to do was add a <code>coverage xml</code> command to the file <code>tox.ini</code>:</p>
<pre><code># ...

[testenv]
# ...
commands =
    # ...
    coverage xml</code></pre>
<p>After this was fixed, Codecov worked perfectly and commented my PR saying my coverage is 100%:</p>
<figure><img title="Codecov automatically comments with a coverage report." alt="A screenshot of my GitHub pull request with an automatic comment by Codecov with a simple coverage report stating I have 100% code coverage." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_codecov_comment.png"/><figcaption>Codecov automatically comments with a coverage report.</figcaption></figure>
<h2>Publishing to PyPI automatically</h2>
<p>The final step in this endeavour is publishing automatically to PyPI every time we make a new release.
There are actions that publish Python packages to PyPI for us,
but I want to do this by hand.
In essence, I need to create a GitHub Action such that the steps mimic what I wrote above regarding publish to PyPI with Poetry.
So, the action will have these steps:</p>
<ol>
<li>Use the checkout action to checkout the repository.</li>
<li>Set up Python.</li>
<li>Install Poetry.</li>
<li>Configure Poetry with a PyPI token.</li>
<li>Build and publish the package.</li>
</ol>
<p>The only step that requires some extra care is the one where we configure Poetry with the token.
We cannot write the token explicitly in the YAML file, so we need to create a GitHub secret with a token.</p>
<p>I went to PyPI, created a new token, and added it to the repository on GitHub:</p>
<figure><img title="The secret ‚ÄúPYPI_TOKEN‚Äù on GitHub." alt="A screenshot of the GitHub repository settings in the ‚Äúsecrets‚Äù tab, where we can see the name of a new secret called ‚ÄúPYPI_TOKEN‚Äù." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_gh_secrets.png"/><figcaption>The secret ‚ÄúPYPI_TOKEN‚Äù on GitHub.</figcaption></figure>
<p>This makes it usable from within actions.
Here is the new action file <code>.github/workflows/publish.yaml</code>:</p>
<pre><code>name: Publish to PyPI

on:
  release:
    types: [ published ]
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout sources
        uses: actions/checkout@v2

      - name: Setup Python
        uses: actions/setup-python@v2
        with:
          python-version: &#34;3.10&#34;

      - name: Install poetry and dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install poetry

      - name: Configure poetry
        env:
          pypi_token: ${{ secrets.PyPI_TOKEN }}
        run: poetry config pypi-token.pypi $pypi_token

      - name: Build and publish
        run: poetry publish --build</code></pre>
<p>Commit the workflow and push.
Now, I just need to prepare everything for a release.
Then, when I create the <code>0.1.3</code> release, GitHub should publish to PyPI for me...
Which it did!</p>

<p>To conclude this endeavour, let us finish up by adding nice badges to the README file!
This is what we are adding:</p>
<figure><img title="Some neat README badges." alt="A screenshot of the README file where we can see five neat-looking badges that give relevant information regarding the status of the project." src="https://mathspp.com/user/pages/02.blog/how-to-create-a-python-package-in-2022/_readme_badges.png"/><figcaption>Some neat README badges.</figcaption></figure>
<p>To add these badges, all we need to do is add links to some images that are automatically generated for us.
Here is the change to the README file:</p>
<pre><code># extendedjson

 &gt; Easily extend JSON to encode and decode arbitrary Python objects.

[![PyPI Version][pypi-image]][pypi-url]
[![Build Status][build-image]][build-url]
[![Code Coverage][coverage-image]][coverage-url]
[![][stars-image]][stars-url]
[![][versions-image]][versions-url]

...

&lt;!-- Badges: --&gt;

[pypi-image]: https://img.shields.io/pypi/v/extendedjson
[pypi-url]: https://pypi.org/project/extendedjson/
[build-image]: https://github.com/mathspp/extendedjson/actions/workflows/build.yaml/badge.svg
[build-url]: https://github.com/mathspp/extendedjson/actions/workflows/build.yaml
[coverage-image]: https://codecov.io/gh/mathspp/extendedjson/branch/main/graph/badge.svg
[coverage-url]: https://codecov.io/gh/mathspp/extendedjson/
[stars-image]: https://img.shields.io/github/stars/mathspp/extendedjson/
[stars-url]: https://github.com/mathspp/extendedjson
[versions-image]: https://img.shields.io/pypi/pyversions/extendedjson/
[versions-url]: https://pypi.org/project/extendedjson/</code></pre>
<p>If you go to <a href="https://shields.io/" target="_blank" rel="nofollow noopener noreferrer">shields.io</a> you can find <em>hundreds</em> of different badges that you can add to your own projects.
Just have fun selecting all the appropriate badges you want to add!</p>

<p>That is it for now.
Throughout this article, we</p>
<ul>
<li>created a Python package;</li>
<li>set up Poetry for dependency management;</li>
<li>set up a GitHub repository to host the code;</li>
<li>defined some pre-commit hooks to make sure we only make commits that meet certain criteria;</li>
<li>added a (fairly permissive) license to the project;</li>
<li>configured Poetry to allow uploading to PyPI and a test version of PyPI;</li>
<li>tested uploading the package to a test version of PyPI;</li>
<li>added Scriv to help us with changelog management and generation;</li>
<li>tagged and published a release of our project;</li>
<li>wrote a bunch of tests;</li>
<li>automated testing and linting with tox;</li>
<li>checked code coverage and got it to 100%;</li>
<li>set up CI/CD with GitHub actions to run linting and testing;</li>
<li>integrated with Codecov to get coverage reports in our pull requests;</li>
<li>created a GitHub action to publish our package to PyPI automatically; and</li>
<li>added some nifty badges to the README file.</li>
</ul>
<p>I hope this was useful for you!
If you have any other steps you follow in your own packages,
feel free to leave a comment below!</p>
<p>That&#39;s it for now! <a href="https://mathspp.com/subscribe">Stay tuned</a> and I&#39;ll see you around!</p>
        <!--
!!!! Want to improve your Python üêç problem-solving skills?
!!!! The Python Problem-Solving Bootcamp is just starting!
!!!! [Join now](https://mathspp.gumroad.com/l/pythonbootcamp)!
-->
<p>I hope you learned something new!
If you did, consider following the footsteps of the readers who <a href="https://buymeacoffee.com/mathspp">bought me a slice of pizza üçï</a>.
Your small contribution helps me produce this content for free and without spamming you with annoying ads.</p>        

<ul>
  <li>Poetry documentation, <a href="https://python-poetry.org/docs/">https://python-poetry.org/docs/</a> [last accessed 21-06-2022];</li>
  <li>Poetry documentation, Configuring credentials, <a href="https://python-poetry.org/docs/repositories/#configuring-credentials">https://python-poetry.org/docs/repositories/#configuring-credentials</a> [last accessed 21-06-2022];</li>
  <li>‚ÄúHow to make an awesome Python package‚Äù, <a href="https://antonz.org/python-packaging/">https://antonz.org/python-packaging/</a> [last accessed 27-07-2022];</li>
  <li>Pre-commit, <a href="https://pre-commit.com/">https://pre-commit.com/</a> [last accessed 21-06-2022];</li>
  <li>tox, <code>pyproject.toml</code> tox legacy ini, <a href="https://tox.wiki/en/latest/example/basic.html#pyproject-toml-tox-legacy-ini">https://tox.wiki/en/latest/example/basic.html#pyproject-toml-tox-legacy-ini</a> [last accessed 25-06-2022];</li>
  <li>tox, Packaging, <a href="https://tox.wiki/en/latest/example/package.html">https://tox.wiki/en/latest/example/package.html</a> [last accessed 25-06-2022];</li>
  <li>mccabe, McCabe complexity checker for Python, <a href="https://pypi.org/project/mccabe/">https://pypi.org/project/mccabe/</a> [last accessed 28-06-2022];</li>
  <li>Coverage.py documentation, <a href="https://coverage.readthedocs.io/en/6.4.1/index.html">https://coverage.readthedocs.io/en/6.4.1/index.html</a> [last accessed 28-06-2022];</li>
  <li>pytest documentation, <a href="https://docs.pytest.org/en/7.1.x/">https://docs.pytest.org/en/7.1.x/</a> [last accessed 28-06-2022];</li>
  <li>GitHub Actions documentation, <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a> [last accessed 25-07-2022];</li>
  <li>Pylint documentation, <a href="https://pylint.pycqa.org/en/latest">https://pylint.pycqa.org/en/latest</a> [last accessed 25-07-2022];</li>
  <li>Codecov, <a href="https://about.codecov.io/">https://about.codecov.io/</a> [last accessed 25-07-2022];</li>
  <li>‚ÄúPython in GitHub Actions‚Äù, Hynek Schlawack, <a href="https://hynek.me/articles/python-github-actions">https://hynek.me/articles/python-github-actions</a> [last accessed 25-07-2022];</li>
</ul>
    </div></div>
  </body>
</html>
