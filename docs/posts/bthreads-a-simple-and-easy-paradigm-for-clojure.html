<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thomascothran.tech/2024/10/a-new-paradigm/">Original</a>
    <h1>Bthreads: A Simple and Easy Paradigm for Clojure</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>Asynchronous programs are hard to reason about. But is this intrinsic to asynchrony? Or might we be using the wrong paradigms?</p>
<p>Behavioral programming is a programming paradigm that aims to make asynchronous, event-driven systems both simple <em>and</em> easy by using a system centered on behavioral threads (bthreads). In my <a href="https://thomascothran.tech/2024/09/in-clojure/">previous article</a>, I introduced the idea of behavioral programming in Clojure.</p>
<p>In this article, we dive deeper. I hope to convince you that, compared to the alternatives:</p>
<ol>
<li>Bthreads decouple complex (and stateful!) application behaviors,</li>
<li>Bthreads are more natural to reason about</li>
</ol>
<p>Bthreads are both simple and easy. The simplicity is evident. Bthreads define isolated stateful application behaviors that communicate by requesting or blocking events.</p>
<h2 id="tic-tac-toe-example">Tic Tac Toe Example</h2>
<p>To see why bthreads are easy, we will consider an example: programming a tic tac toe game. Programming games involves rules that can come into conflict (and hence need prioritization). In addition to rules (what must occur), there are strategies (what a rational player should do). Some events in tic tac toe originate from a human player. Other events are generated from the program, such as wins, draws, and computer moves.</p>
<h3 id="teaching-a-bprogram">Teaching a bprogram</h3>
<p>Behavioral programming is performed by “teaching” the computer in a way similar to how we would teach a human. We might start teaching a person by saying “tic tac toe is a turn-based game, first player x goes; then, player y.” We teach our program in a similar fashion.</p>
<pre><code>(require &#39;[tech.thomascothran.pavlov.bthread :as bthread])

(defn make-enforce-turn-bthreads
  []
  (let [moves (for [x-coord [0 1 2]
                    y-coord [0 1 2]
                    player [:x :o]]
                [x-coord y-coord player])

        x-moves
        (into #{}
              (comp (filter (comp (partial = :x) last)))
              moves)

        o-moves
        (into #{}
              (comp (filter (comp (partial = :o) last)))
              moves)]

    (bthread/seq
     (interleave (repeat {:wait-on x-moves
                          :block o-moves})
                 (repeat {:wait-on o-moves
                          :block x-moves})))))
</code></pre>
<p>We use <code>pavlov</code>’s <code>seq</code> function, which creates a bthread from a sequence. Each map is a bid, which blocks all of one player’s possible moves until the other player moves.</p>
<pre><code>{:wait-on x-moves
 :block o-moves}
</code></pre>
<p>This can be read as: “block all of o’s moves until x makes a move”. When <code>x</code> makes a move, the bid is accepted, and the bthread makes its next bid:</p>
<pre><code>{:wait-on o-moves
 :block x-moves}
</code></pre>
<p>This is read as: “block all of player x’s moves until player o moves”.</p>
<p>We represent each move as <code>[x-coordinate, y-coordinate, player]</code>.</p>
<h3 id="only-one-player-per-square">Only one player per square</h3>
<p>In Monopoly, two players can be on the same square at the same time. However, in tic tac toe, a square can only belong to one player.</p>
<pre><code>(defn make-no-double-placement-bthreads
  &#34;You can&#39;t pick another player&#39;s square!&#34;
  []
  (for [x-coordinate [0 1 2]
        y-coordinate [0 1 2]
        player [:x :o]]
    (bthread/seq
     [{:wait-on #{[x-coordinate y-coordinate player]}}
      {:block #{[x-coordinate y-coordinate :x]
                [x-coordinate y-coordinate :o]}}])))
</code></pre>
<p>The sequence consists of only two events. First, our bthread waits on a move to be made:</p>
<pre><code>{:wait-on #{[x-coordinate y-coordinate player]}}
</code></pre>
<p>This can be read as: “when this move occurs, make the next bid”. And the next bid simply blocks any further moves in that square:</p>
<pre><code>{:block #{[x-coordinate y-coordinate :x]
          [x-coordinate y-coordinate :o]}}
</code></pre>
<p>This bthread does not listen for any other events. It does not have a <code>:request</code> or <code>:wait-on</code> key. As a result, it blocks until the bprogram exits.</p>
<h3 id="bthread-reducers">Bthread reducers</h3>
<p>So far we have used <code>seq</code> to create bthreads. Sometimes this isn’t enough. We can also use <code>bthread/reduce</code> to construct a bthread.</p>
<p>The reduce function is used here to accumulate state across multiple iterations of event processing. Reduce takes up to three arguments:</p>
<pre><code>(bthread/reduce reducing-fn
                initial-value
                options)
</code></pre>
<p>Let’s take a very straightforward example:</p>
<pre><code>(def bthread
  (b/reduce (fn [{:keys [times-called] :as _accumulated-value} _event]
              (when-not (= times-called 3)
                {:request #{:more}
                 :times-called (inc times-called)}))
            {:times-called 0}))
</code></pre>
<p>We initialize the accumulated value as <code>{:times-called 0}</code>. The accumulated value passed to our reducing function is its previous bid. Because bids are just maps, we can add additional data to them.</p>
<p>We take advantage of this to track the number of times the bthread has executed. When it has executed three times previously, it returns <code>nil</code>. A bthread that returns <code>nil</code> is removed from the bprogram.</p>
<h3 id="how-to-win">How to win</h3>
<p>Let’s create a bthread for each winning path. Each move is represented as <code>[x-coordinate, y-coordinate, player]</code>. For example, <code>[0 0 :x]</code>.</p>
<p>An example of a winning path would be <code>#{[0 0 :x] [1 0 :x] [2 0 :x]}</code>. We’ll pass this into <code>make-winning-bthread</code>:</p>
<pre><code>(defn make-winning-bthread
  &#34;for a winning path (e.g., three diagonal squares
  selected by the same player), emit a win event
  and terminate the program.&#34;
  [winning-paths]
  (bthread/reduce
   (fn [{:keys [remaining-events] :as acc} event]
     (if event ;; event is nil on bprogram initialization
       (let [event-type (event/type event)]
         (if (= remaining-events #{event-type})
           {:request #{{:type [(last event-type) :wins]
                        :terminal true}}
            :remaining-events #{}}
           (update acc :remaining-events disj event-type)))
       acc))
   ;; Initial value
   {:remaining-events (set winning-paths)
    :wait-on (into #{}
                   (map (fn [event] {:type event}))
                   winning-paths)}
   {:priority 100})) ;; overrides other bids
</code></pre>
<p>Just as we kept <code>times-called</code> as an accumulated value, so we keep the <code>remaining-events</code>. We can visualize how this changes in a table:</p>
<table>
  <thead>
      <tr>
          <th>Iteration</th>
          <th>Event</th>
          <th>New <code>remaining-paths</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td><code>nil</code></td>
          <td><code>#{[0 0 :x] [1 0 :x] [2 0 :x]}</code></td>
      </tr>
      <tr>
          <td>1</td>
          <td><code>[1 0 :x]</code></td>
          <td><code>#{[0 0 :x] [2 0 :x]}</code></td>
      </tr>
      <tr>
          <td>2</td>
          <td><code>[0 0 :x]</code></td>
          <td><code>#{[2 0 :x]}</code></td>
      </tr>
      <tr>
          <td>3</td>
          <td><code>[2 0 :x]</code></td>
          <td><code>#{}</code></td>
      </tr>
  </tbody>
</table>
<p>Whenever an event from winning-paths occurs, the reduce function iterates and returns the next bid.</p>
<h4 id="priorities">Priorities</h4>
<p>Notice that we do provide <code>bthread/reduce</code> with an optional argument that sets its priority to <code>1</code>. Why do we need to prioritize bthreads?</p>
<p>Multiple bthreads will be notified of an event, and each will produce a bid. But only one requested event can be selected. The bid with the highest priority wins. In <code>pavlov</code>, by default the priority is 0. But this could result in, for example, a bid for a computer move being selected even though the player has just won.</p>
<p>For example, suppose our tic tac toe game looks like this:</p>
<pre><code>[x _ o
 x _ _
 x _ o]
</code></pre>
<p>And we have the following bids:</p>
<table>
  <thead>
      <tr>
          <th>bthread</th>
          <th>request</th>
          <th>wait-on</th>
          <th>block</th>
          <th>priority</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>detect-wins</td>
          <td><code>#{[:win :x]}</code></td>
          <td></td>
          <td></td>
          <td>0</td>
      </tr>
      <tr>
          <td>computer-moves</td>
          <td><code>#{[2 1 :o]}</code></td>
          <td></td>
          <td></td>
          <td>0</td>
      </tr>
  </tbody>
</table>
<p>What <em>should</em> happen? <code>X</code> should win. However, if the <code>detect-wins</code> thread has the same priority as <code>computer-moves</code>, then the choice between competing bids is non-deterministic.</p>
<p>If we set the priority of the <code>detect-wins</code> bthread higher than <code>computer-moves</code>, then the selected event will be <code>[:win x]</code></p>
<h3 id="computer-moves">Computer moves</h3>
<p>It’s no fun to play tic tac toe against ourselves. We want the computer to play us. Let’s suppose we will be <code>X</code>, and the computer <code>O</code>.</p>
<p>It’s important to know what we <em>do not</em> have to do.</p>
<p>We do not have to figure out which squares are open. A standard approach might involve a function a bit like this:</p>
<pre><code>(defn next-move
  &#34;Without worrying about strategy, let&#39;s pick a square&#34;
  [{:keys [board]} player]
  (-&gt; (remove occupied? board)
      first
      (make-move player))
</code></pre>
<p><code>next-move</code> has no strategy; it simply selects the next unoccupied square. This conflates two concerns: enforcing the rule that a square can only be chosen once and determining the next move.</p>
<p>The equivalent bthread could be:</p>
<pre><code>(defn make-computer-picks-bthreads
  &#34;Without worrying about strategy, let&#39;s pick a square&#34;
  [player]
  (bthread/seq
   (for [x-coordinate [0 1 2], y-coordinate [0 1 2]]
     {:request #{{:type [x-coordinate y-coordinate player]}}})))
</code></pre>
<p>But wait – we are requesting all the squares on the board. Don’t we have to remember to block the occupied squares? Don’t we have to retract our bid if the game is over? Do we need to retract our bid if the game is over? Do we need to ensure that the computer waits for the player to take their turn? The answer to these questions is no. These concerns have already been handled by the specific bthreads designed for them.</p>
<h3 id="testing">Testing</h3>
<p>One of the most useful aspects of behavioral programming is how easy testing isolated behaviors becomes.</p>
<p>Suppose we want to test the bthread that detects wins. Here’s what it looks like:</p>
<pre><code>(deftest test-winning-bthreads
  (testing &#34;Given a bthread that watches a crossing win pattern for player x
    When that crossing pattern is filled in by player x
    Then the bthread requests a win event&#34;
    (let [bthread (make-winning-bthread
                   #{[0 0 :x] [2 2 :x] [1 1 :x]})
          bid1 (bthread/bid bthread {:type [1 1 :x]})
          bid2 (bthread/bid bthread {:type [2 2 :x]})
          bid3 (bthread/bid bthread {:type [0 0 :x]})]
      (is (= #{[0 0 :x] [2 2 :x]} (:remaining-events bid1))
          &#34;Track which events are left to reach a win for x after the first move&#34;)
      (is (= #{[0 0 :x]} (:remaining-events bid2))
          &#34;Track which events are left to reach a win for x after the second move&#34;)
      (is (= #{{:type [:x :wins] :terminal true}} (:request bid3))
          &#34;Request a win when all the winning moves have been made&#34;))))
</code></pre>
<p>Of course, in a real game it is not possible for one player to move three times in a row. But that rule differs from the rules about winning. Testing is the best way we have to quickly verify we are properly separating concerns.</p>
<h2 id="representation">Representation</h2>
<p>Rather than sharing a central representation, each bthread contains its own independent view of the world.</p>
<p>Most tic-tac-toe implementations would represent the board with something like this vector:</p>
<pre><code>[nil :o   nil
 nil :x   nil
 nil nil :x]
</code></pre>
<p>Then we define operations performed against that representation. For example:</p>
<pre><code>(defn draw?
  &#34;useful when determining whether a draw has occurred&#34;
  [board]
  (and (nil? (winner board))
       (every? keyword? board)
</code></pre>
<p>But our bthread implementation above:</p>
<ol>
<li>Has no shared representation of the board, and</li>
<li><em>Never represents the board as a whole</em>.</li>
</ol>
<p>Nothing about behavioral programming prevents us from creating a bthread that maintains its data structure representing the entire board. A bthread could maintain its own representation of the board as a vector. But this representation is derived from the events and isolated to the bthread.</p>
<h2 id="conclusion">Conclusion</h2>
<p>My purpose in this post is to show, by example, how programs can be “taught” incrementally using a similar progression to the way we would teach a human being. Arguably this can be a more natural way of thinking about how a program behaves. This ease is not purchased at the price of simplicity. Rather, it results from the strict separation of behaviors into bthreads, as well as the constrained semantics of behavioral programming (i.e, ask, refuse, wait).</p>
<p>This paradigm is flexible enough for various applications, such as stream processing (using Kafka or Kinesis) and managing complex UIs, and it includes established patterns for distributed systems. Hopefully this post inspires some glimmer of the possible applications of behavioral programming.</p>

    </div></div>
  </body>
</html>
