<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cceckman.com/writing/aclock/software/">Original</a>
    <h1>A Daylight-Aware Clock: Software</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This article covers the software I’ve written for my <a href="https://cceckman.com/writing/aclock/">daylight clock</a>,
and some of the adventures along the way.</p>
<p>(Un)finished product first:</p>
<div>
<p><img id="sim" src="https://cceckman.com/writing/aclock/software/web-sim.webp"/></p>
<p id="js-warning">If you see this message, the simulator code hasn&#39;t loaded yet. Sorry!</p>

</div>
<p>Code <a href="https://cceckman.com/r/aclock" rel="external" target="_blank">here</a>.
Thanks to <a href="https://ntietz.com/" rel="external" target="_blank">Nicole</a> for the suggestion of making the simulator web-compatible!</p>


<h2 id="hardware-prep">Hardware prep</h2>
<p>I’ll list the full Bill of Materials when talking about the electronics.
For software purposes, we’re working with:</p>
<ul>
<li><a href="https://www.adafruit.com/product/2846" rel="external" target="_blank">1m (60 count) SK6812RGBW strip</a> for the edge</li>
<li><a href="https://www.adafruit.com/product/420" rel="external" target="_blank">32x16 LED Matrix</a> for the face</li>
<li><a href="https://www.adafruit.com/product/4867" rel="external" target="_blank">SCD30 CO2 sensor w/ breakout</a></li>
<li><a href="https://www.adafruit.com/product/2345" rel="external" target="_blank">LED Matrix HAT</a></li>
<li><a href="https://www.raspberrypi.com/products/raspberry-pi-3-model-b/" rel="external" target="_blank">Raspberry Pi 3 Model B</a></li>
</ul>
<h3 id="demos-and-drivers">Demos and drivers</h3>
<p>I started by reading the Adafruit tutorials for the
<a href="https://learn.adafruit.com/adafruit-rgb-matrix-plus-real-time-clock-hat-for-raspberry-pi" rel="external" target="_blank">LED Matrix</a> and <a href="https://learn.adafruit.com/neopixels-on-raspberry-pi/overview" rel="external" target="_blank">NeoPixel strip</a>
separately, to make sure the hardware works.
These tutorials were good for that purpose, but
I wasn’t excited about using CircuitPython for the whole project.
I had a couple hiccups while trying to install the software,<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
and I wasn’t sure I’d be able to maintain a Python-based environment.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>Luckily, the Python libraries Adafruit uses are
in turn backed by C/C++ libraries:
<a href="https://github.com/hzeller/rpi-rgb-led-matrix" rel="external" target="_blank">rpi-led-matrix</a> and <a href="https://github.com/jgarff/rpi_ws281x" rel="external" target="_blank">rpi-ws281x</a>.
Both of these libraries also have Rust bindings: for the <a href="https://docs.rs/rpi-led-matrix/latest/rpi_led_matrix/" rel="external" target="_blank">matrix</a> and <a href="https://docs.rs/rs_ws281x/" rel="external" target="_blank">NeoPixel</a>.</p>
<h3 id="display-layouts">Display layouts</h3>
<p>The lower-level libraries have lots more options,
e.g. to use different GPIO and pixel layouts.
I had to experiment to figure out which settings to use.</p>
<h4 id="neopixel-layout">NeoPixel layout</h4>
<p>I reconfigured the hardware and NeoPixel software to use GPIO10
(SPI MOSI) for the NeoPixel data.
This leaves GPIO18 open if I want to use it for the “quality” setting on the matrix later.
I made sure SPI was enabled via <code>raspi-config</code> so the library could use the relevant kernel driver.</p>
<p>The NeoPixels have 4 <code>u8</code> channels: R, G, B, W…
but they aren’t necessarily delivered to the hardware in that order.
I illuminated one channel at a time:<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>type</span> <span>NeoPixelValues</span><span> </span><span>=</span><span> </span><span>[</span><span>u8</span><span>;</span><span>4</span><span>];</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>pixels</span>: <span>&amp;</span><span>mut</span><span> </span><span>[</span><span>NeoPixelValues</span><span>]</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span><span>
</span></span></span><span><span><span></span><span>for</span><span> </span><span>px</span><span> </span><span>in</span><span> </span><span>pixels</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>px</span><span> </span><span>=</span><span> </span><span>[</span><span>255</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>];</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>thread</span>::<span>sleep</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>10</span><span>));</span><span>
</span></span></span><span><span><span></span><span>for</span><span> </span><span>px</span><span> </span><span>in</span><span> </span><span>pixels</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>px</span><span> </span><span>=</span><span> </span><span>[</span><span>0</span><span>,</span><span> </span><span>255</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>];</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span></span><span>/* ditto for third and fourth channels */</span><span>
</span></span></span></code></pre></div><p>and looked at the pixel strip to see which colors actually lit up.
Turns out I had a <strong>GRBW</strong>-ordered panel!
Luckily, that’s a
<a href="https://github.com/cceckman/aclock/commit/b98c1d2092968b19a26849b8bf04355d0bd91028#diff-64aa9b484d4b3759cc0dd469329aa5a6bab87366c6c55eb61d9a1d1129201fcdR122" rel="external" target="_blank">setup-time option</a>,
so the rest of the program can treat the values as RGBW tuples.</p>
<h4 id="matrix-layout">Matrix layout</h4>
<p>The matrix’s orientation took me longer to work out.
My test program illuminated one pixel at a time:<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>for</span><span> </span><span>x</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>32</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>  </span><span>for</span><span> </span><span>y</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>16</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>display</span><span>.</span><span>clear</span><span>().</span><span>unwrap</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>display</span><span>.</span><span>draw_iter</span><span>(</span><span>std</span>::<span>iter</span>::<span>once</span><span>(</span><span>Pixel</span><span>(</span><span>
</span></span></span><span><span><span>      </span><span>Point</span>::<span>new</span><span>(</span><span>x</span><span>,</span><span> </span><span>y</span><span>),</span><span>
</span></span></span><span><span><span>      </span><span>Rgb888</span>::<span>new</span><span>(</span><span>255</span><span>,</span><span> </span><span>255</span><span>,</span><span> </span><span>255</span><span>)</span><span>
</span></span></span><span><span><span>    </span><span>));</span><span>
</span></span></span><span><span><span>    </span><span>thread</span>::<span>sleep</span><span>(</span><span>Duration</span>::<span>from_millis</span><span>(</span><span>10</span><span>))</span><span>
</span></span></span><span><span><span>  </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>I varied the library’s <a href="https://docs.rs/rpi-led-matrix/latest/rpi_led_matrix/struct.LedMatrixOptions.html" rel="external" target="_blank">address settings</a>
in several ways to try to make the output look
right. Mostly, <a href="https://github.com/cceckman/aclock/commit/17eea20fc351a9cdfae722e6fddd87cb891c8c50#diff-64aa9b484d4b3759cc0dd469329aa5a6bab87366c6c55eb61d9a1d1129201fcdR31-R57" rel="external" target="_blank">I got it wrong</a>!
Eventually I determined my 32x16 panel acts like two chained 16x16 panels.</p>
<h2 id="iterating-quickly">Iterating quickly</h2>
<p>With the basic hardware settings configured,
I wanted to quickly iterate on the content displayed:
Does the daylight arc look reasonable?
Is the font legible?</p>
<p>I worked out a couple tricks to quickly deploy to hardware,
and built a simulator to run the software on my dev machine.</p>
<h3 id="cross-compiling-rust-and-c-for-raspberry-pi">Cross-compiling Rust and C++ for Raspberry Pi</h3>
<p>I was a little worried that incorporating the C/C++ libraries
into my build would make it hard to cross-compile.
But it was surprisingly easy to get set up!</p>
<p>Cargo can crossbuild Rust for RPi 64-bit <a href="https://github.com/cceckman/aclock/blob/aac8dd9d885fa0679022bc3a0bc9b556f67c6771/server/server.do#L9" rel="external" target="_blank">using the <code>--target</code> flag</a>…
as long as you’re careful to <a href="https://github.com/cceckman/aclock/blob/aac8dd9d885fa0679022bc3a0bc9b556f67c6771/server/.cargo/config.toml#L3" rel="external" target="_blank">specify the linker in .cargo/config.toml</a>.</p>
<p>The <code>-sys</code> crates for the LED libraries include build steps,
which seem to pick up the <code>CC</code> and <code>CXX</code> <a href="https://github.com/cceckman/aclock/blob/aac8dd9d885fa0679022bc3a0bc9b556f67c6771/server/server.do#L7" rel="external" target="_blank">environment variables</a>
with no hassle.</p>
<p>I bundled all this into a <a href="https://redo.readthedocs.io/" rel="external" target="_blank">redo</a> rule
that let me crossbuild any of the binaries in my crate with <code>redo &lt;name&gt;.bin</code>:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>
</span></span><span><span>redo-ifchange Cargo.toml Cargo.lock <span>$(</span>find src/<span>)</span>
</span></span><span><span>
</span></span><span><span><span>set</span> -eu
</span></span><span><span>
</span></span><span><span><span>if</span> uname -m <span>|</span> grep -q x86
</span></span><span><span><span>then</span>
</span></span><span><span>    <span>export</span> <span>CXX</span><span>=</span>aarch64-linux-gnu-g++
</span></span><span><span>    <span>export</span> <span>CC</span><span>=</span>aarch64-linux-gnu-gcc
</span></span><span><span>    <span>TARGET</span><span>=</span><span>&#34;--target aarch64-unknown-linux-gnu&#34;</span>
</span></span><span><span><span>else</span>
</span></span><span><span>    <span>TARGET_DIR</span><span>=</span><span>&#34;target/&#34;</span>
</span></span><span><span><span>fi</span>
</span></span><span><span>
</span></span><span><span><span># Build normally first, to show errors in the stderr stream</span>
</span></span><span><span>cargo build --release <span>$TARGET</span> --no-default-features --features hardware
</span></span><span><span>
</span></span><span><span>cargo build --release <span>$TARGET</span> --message-format<span>=</span>json --no-default-features --features hardware <span>\
</span></span></span><span><span><span></span><span>|</span> jq -r <span>&#34;select(.target.name == \&#34;</span><span>$2</span><span>\&#34;) | select(.executable) | .executable&#34;</span> <span>\
</span></span></span><span><span><span></span>&gt;<span>&#34;</span><span>$3</span><span>&#34;</span>
</span></span><span><span>
</span></span><span><span><span>OUTPUT</span><span>=</span><span>&#34;</span><span>$(</span>cat <span>&#34;</span><span>$3</span><span>&#34;</span><span>)</span><span>&#34;</span>
</span></span><span><span>rm <span>&#34;</span><span>$3</span><span>&#34;</span>
</span></span><span><span>cp <span>&#34;</span><span>$OUTPUT</span><span>&#34;</span> <span>&#34;</span><span>$3</span><span>&#34;</span>
</span></span></code></pre></div><h3 id="file-transfer-over-serial">File transfer over serial</h3>
<p>I worked on this project at a couple of locations where I didn’t have WiFi,
just a USB-serial connection to the Pi.
At first, I didn’t know how to upload new binaries to the Raspberry Pi.</p>
<p>I wound up using the <a href="https://linux.die.net/man/8/picocom" rel="external" target="_blank"><code>picocom</code></a>
serial client on my laptop, which can transfer files if
<a href="https://linux.die.net/man/1/sz" rel="external" target="_blank"><code>sz</code></a> is installed on the other end
(serial “server”).
I made sure <code>sz</code> was installed on the Pi before leaving the house, and all was <em>almost</em> well.</p>
<p>The remaining problem was transfer time.
At time of writing, a debug build of the main program is 19MB –
at a typical 115200 baud, that’s a 20-minute transfer!</p>
<p>Using <code>--release</code> builds and transferring <code>gzip</code>ped binaries resulted
in much more managable sizes (&lt; 1MB) and times (&lt;1 minute).
This worked fine: mostly “offline time” was working on the physical design,
so I didn’t need to carry debug info onto the Pi.</p>
<h3 id="display-simulation">Display simulation</h3>
<p>The <a href="https://docs.rs/rpi-led-matrix/latest/rpi_led_matrix/" rel="external" target="_blank">rpi_led_matrix</a> Rust crate
implements traits defined in <a href="https://docs.rs/embedded-graphics/latest/embedded_graphics/" rel="external" target="_blank">embedded_graphics</a> –
that is, the matrix library implements the embedded_graphics interface.
Another implementation is the
<a href="https://docs.rs/embedded-graphics-simulator/latest/embedded_graphics_simulator/" rel="external" target="_blank">embedded_graphics_simulator</a>
crate, which outputs to a desktop window instead of a physical matrix.
This is a great feature!</p>
<p>I was able to quickly drop this into place instead of the LED matrix output.
However, I couldn’t render a separate window for the LED strip at the same time;
<a href="https://github.com/embedded-graphics/simulator/issues/47" rel="external" target="_blank">this is a known issue with the simulator</a>.</p>
<p>To work around this, I refactored the main logic expect a different “output” trait:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>trait</span><span> </span><span>Displays</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>/// Set the color of the edge pixels
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>edge</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span>-&gt; <span>&amp;</span><span>mut</span><span> </span><span>[</span><span>NeoPixelColor</span><span>];</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Draw onto a buffer for the face (LED matrix)
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>face</span><span>(</span><span>
</span></span></span><span><span><span>        </span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>)</span><span> </span>-&gt; <span>impl</span><span> </span><span>embedded_graphics_core</span>::<span>draw_target</span>::<span>DrawTarget</span><span>&lt;</span><span>Color</span><span> </span><span>=</span><span> </span><span>Rgb888</span><span>,</span><span> </span><span>Error</span><span> </span><span>=</span><span> </span><span>Infallible</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>/// Flush any pending pixels: update the edge and face.
</span></span></span><span><span><span></span><span>    </span><span>fn</span> <span>flush</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>)</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>String</span><span>&gt;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>I used the aforementioned Raspbery Pi-specific libraries to implement
this “for real”.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>
For simulation, I added a one-pixel margin around the display,
then a border to show the NeoPixel colors.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>
This let me experiment with layouts, font sizes, etc.
without deploying to the hardware stack.</p>
<p>I could also run the simulator faster than real-time, and capture the results
as a video:</p>
<figure><img src="https://cceckman.com/writing/aclock/software/year-sim.webp" alt="Simulation of the clock. The time and info line are rendered in a pixel font; the edge shows daylight hours, with blue lights trailing off into the twilight."/><figcaption>
      <p>In this version of the software, the line of text below the time alternates between showing the date and showing temperature and humidity. A number at the left of the lower line displays a CO2 concentration in parts per thousand, with a color indicator.</p>
    </figcaption>
</figure>
<p>When I told <a href="https://ntietz.com/" rel="external" target="_blank">Nicole</a> about this simulation,
she immediately suggested running the simulator in the browser – which you see <a href="#">above</a>!
The geometry of the web simulator is more representative of what the clock will look like.</p>
<h2 id="when-is-the-sunrise-really">When is the sunrise? (Really?)</h2>
<p>The key feature of this clock is showing the sun-light hours,
given the clock’s latitude and longitude.</p>
<p>Initially, I used a library called <code>satkit</code>
to compute sunrise and sunset times, since it provided
<a href="https://docs.rs/satkit/latest/satkit/lpephem/sun/fn.riseset.html" rel="external" target="_blank">a convenient function</a>
for just that purpose.</p>
<p>But once I had the <a href="#simulation">simulator</a> running for a year’s duration,
I noticed a problem.
Using an example location of Washington, DC,
the daylight hours <em>lengthened</em> until the winter solstice,
then abruptly shrunk:</p>
<pre tabindex="0"><code>2024-11-08 04:59:22 -05:00 // 2024-11-08 18:43:41 -05:00
...
2024-12-19 04:48:20 -05:00 // 2024-12-19 19:22:28 -05:00
2024-12-20 04:48:49 -05:00 // 2024-12-20 19:23:00 -05:00
2024-12-21 07:23:31 -05:00 // 2024-12-21 16:49:18 -05:00
2024-12-22 07:23:59 -05:00 // 2024-12-22 16:49:50 -05:00
</code></pre><p>A discontinuity doesn’t happen unless we <a href="https://en.wikipedia.org/wiki/The_Stolen_Earth" rel="external" target="_blank">teleport the planet</a>!
Moreover, I’ve lived in DC in December – sunrise is not in the 4AM hour.</p>
<p>To their credit, the library author <a href="https://github.com/ssmichael1/satkit/issues/3" rel="external" target="_blank">fixed the issue promptly</a>.
But I also realized <code>satkit</code> brought along a lot of <a href="https://ntietz.com/blog/parsing-arguments-rust-no-deps/#this-no-dependencies-thing" rel="external" target="_blank">dependencies that my clock didn’t need</a>,
e.g. an HTTP library for fetching updated ephemerides.</p>
<p>I decided to rewrite the rise/set functions from scratch.
I found <a href="https://gml.noaa.gov/grad/solcalc/" rel="external" target="_blank">NOAA’s site</a> on solar calculations,
including <a href="https://gml.noaa.gov/grad/solcalc/solareqns.PDF" rel="external" target="_blank">this “just-the-equations” worksheet</a>.
I struggled a bit with getting the units right,
but I was able to line it up with equations in the
spreadsheets <a href="https://gml.noaa.gov/grad/solcalc/calcdetails.html" rel="external" target="_blank">here</a>
and get a working function.<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></p>
<p>As the <a href="https://go-proverbs.github.io" rel="external" target="_blank">Go proverb</a> says, “A little copying is better than a little coupling.”</p>
<h2 id="future-steps">Future steps</h2>
<p>All the code is available in the <a href="https://cceckman.com/r/aclock" rel="external" target="_blank">repository</a>
if you want to try it out!</p>
<p>I haven’t fully tested out the integration of the SCD30 atmosphere sensor package,
nor have I enabled the HAT’s on-board RTC.
I need to experiment with what is legible, and useful, once more of the physical design is put together.</p>
<p>There’s also lots of bonus features that having a full-fledged server could offer.
<a href="https://ntietz.com/" rel="external" target="_blank">Nicole</a> suggested a pomodoro timer that runs along the edge;
<a href="https://hannahilea.com/" rel="external" target="_blank">Hannah</a> suggested an interactive map, where the clock would “travel” to the touched location.</p>
<p>If you have ideas, suggestions, or other feedback, let me know!</p>



</div></div>
  </body>
</html>
