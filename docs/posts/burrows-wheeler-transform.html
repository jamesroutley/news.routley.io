<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform">Original</a>
    <h1>Burrows–Wheeler Transform</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div>
<table><caption>Burrows–Wheeler transform</caption><tbody><tr><th scope="row">Class</th><td>preprocessing for lossless compression</td></tr><tr><th scope="row">Data structure</th><td>string</td></tr><tr><th scope="row"><a href="https://en.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Worst-case</a> <a href="https://en.wikipedia.org/wiki/Time_complexity" title="Time complexity">performance</a></th><td>O(n)</td></tr><tr><th scope="row"><a href="https://en.wikipedia.org/wiki/Best,_worst_and_average_case" title="Best, worst and average case">Worst-case</a> <a href="https://en.wikipedia.org/wiki/Space_complexity" title="Space complexity">space complexity</a></th><td>O(n)</td></tr></tbody></table>
<p>The <b>Burrows–Wheeler transform</b> (<b>BWT</b>, also called <b>block-sorting compression</b>) rearranges a <a href="https://en.wikipedia.org/wiki/Character_string_(computer_science)" title="Character string (computer science)">character string</a> into runs of similar characters. This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as <a href="https://en.wikipedia.org/wiki/Move-to-front_transform" title="Move-to-front transform">move-to-front transform</a> and <a href="https://en.wikipedia.org/wiki/Run-length_encoding" title="Run-length encoding">run-length encoding</a>.  More importantly, the transformation is <i>reversible</i>, without needing to store any additional data except the position of the first original character. The BWT is thus a &#34;free&#34; method of improving the efficiency of text compression algorithms, costing only some extra computation. The Burrows–Wheeler transform is an <a href="https://en.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a> used to prepare data for use with <a href="https://en.wikipedia.org/wiki/Data_compression" title="Data compression">data compression</a> techniques such as <a href="https://en.wikipedia.org/wiki/Bzip2" title="Bzip2">bzip2</a>. It was invented by <a href="https://en.wikipedia.org/wiki/Michael_Burrows" title="Michael Burrows">Michael Burrows</a> and <a href="https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)" title="David Wheeler (computer scientist)">David Wheeler</a> in 1994 while Burrows was working at <a href="https://en.wikipedia.org/wiki/DEC_Systems_Research_Center" title="DEC Systems Research Center">DEC Systems Research Center</a> in <a href="https://en.wikipedia.org/wiki/Palo_Alto" title="Palo Alto">Palo Alto</a>, California. It is based on a previously unpublished transformation discovered by Wheeler in 1983. The  algorithm can be implemented efficiently using a <a href="https://en.wikipedia.org/wiki/Suffix_array" title="Suffix array">suffix array</a> thus reaching linear time complexity.<sup id="cite_ref-Burrows1994_1-0"><a href="#cite_note-Burrows1994-1">[1]</a></sup>
</p>


<h2><span id="Description">Description</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=1" title="Edit section: Description">edit</a><span>]</span></span></h2>
<p>When a <a href="https://en.wikipedia.org/wiki/Character_string_(computer_science)" title="Character string (computer science)">character string</a> is transformed by the BWT, the transformation <a href="https://en.wikipedia.org/wiki/Permutation" title="Permutation">permutes</a> the order of the characters. If the original string had several substrings that occurred often, then the transformed string will have several places where a single character is repeated multiple times in a row.
</p><p>For example:
</p>
<table>
<tbody><tr>
<th>Input
</th>
<td><code>SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES</code>
</td></tr>
<tr>
<th>Output
</th>
<td><code>TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT</code><sup id="cite_ref-2"><a href="#cite_note-2">[2]</a></sup>
</td></tr></tbody></table>
<p>The output is easier to compress because it has many repeated characters.
In this example the transformed string contains six runs of identical characters:
<code>XX</code>,
<code>SS</code>,
<code>PP</code>,
<code>..</code>,
<code>II</code>,
and
<code>III</code>, which together make 13 out of the 44 characters.
</p>
<h2><span id="Example">Example</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=2" title="Edit section: Example">edit</a><span>]</span></span></h2>
<p>The transform is done by <a href="https://en.wikipedia.org/wiki/Sorting" title="Sorting">sorting</a> all the <a href="https://en.wikipedia.org/wiki/Circular_shift" title="Circular shift">circular shifts</a> of a text in <a href="https://en.wikipedia.org/wiki/Lexicographic_order" title="Lexicographic order">lexicographic order</a> and by extracting the last column and the index of the original string in the set of sorted permutations of <code>S</code>.
</p><p>Given an input string <code>S = ^BANANA<span>|</span></code> (step 1 in the table below), rotate it <i>N</i> times (step 2), where <code>N = 8</code> is the length of the <code>S</code> string considering also the symbol <code>^</code> representing the start of the string and the red <span>|</span> character representing the &#39;<a href="https://en.wikipedia.org/wiki/End-of-file" title="End-of-file">EOF</a>&#39; pointer; these rotations, or circular shifts, are then sorted lexicographically (step 3). The output of the encoding phase is the last column <code>L = BNN^AA<span>|</span>A</code> after step 3, and the index (0-based) <code>I</code> of the row containing the original string <code>S</code>, in this case <code>I = 7</code>.
</p>
<table>

<tbody><tr>
<th colspan="5">Transformation
</th></tr>
<tr>
<th>1. Input
</th>
<th>2. All</th>
<th>3. Sort into</th>
<th>4. Take the</th>
<th>5. Output
</th></tr>
<tr>
<td>
<pre>^BANANA<span>|</span>
</pre>
</td>
<td>
<pre>^BANANA<span>|</span>
<span>|</span>^BANANA
A<span>|</span>^BANAN
NA<span>|</span>^BANA
ANA<span>|</span>^BAN
NANA<span>|</span>^BA
ANANA<span>|</span>^B
BANANA<span>|</span>^
</pre>
</td>
<td>
<pre><b>A</b>NANA<span>|</span>^B
<b>A</b>NA<span>|</span>^BAN
<b>A</b><span>|</span>^BANAN
<b>B</b>ANANA<span>|</span>^
<b>N</b>ANA<span>|</span>^BA
<b>N</b>A<span>|</span>^BANA
<b>^</b>BANANA<span>|</span>
<span><b>|</b></span>^BANANA
</pre>
</td>
<td>
<pre><span>ANANA<span>|</span>^</span><b>B</b>
<span>ANA<span>|</span>^BA</span><b>N</b>
<span>A<span>|</span>^BANA</span><b>N</b>
<span>BANANA<span>|</span></span><b>^</b>
<span>NANA<span>|</span>^B</span><b>A</b>
<span>NA<span>|</span>^BAN</span><b>A</b>
<span>^BANANA</span><span><b>|</b></span>
<span><span>|</span>^BANAN</span><b>A</b>
</pre>
</td>
<td>
<pre>BNN^AA<span>|</span>A
</pre>
</td></tr></tbody></table>
<p>The following <a href="https://en.wikipedia.org/wiki/Pseudocode" title="Pseudocode">pseudocode</a> gives a simple (though inefficient) way to calculate the BWT and its inverse.  It assumes that the input string <code>s</code> contains a special character &#39;EOF&#39; which is the last character and occurs nowhere else in the text.
</p>
<pre><b>function</b> BWT (<i>string</i> s)
    create a table, where the rows are all possible rotations of s
    sort rows alphabetically
    <b>return</b> (last column of the table)
</pre>
<pre><b>function</b> inverseBWT (<i>string</i> s)
    create empty table
    <b>repeat</b> length(s) <b>times</b>
        // first insert creates first column
        insert s as a column of table before first column of the table
        sort rows of the table alphabetically
    <b>return</b> (row that ends with the &#39;EOF&#39; character)
</pre>
<h2><span id="Explanation">Explanation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=3" title="Edit section: Explanation">edit</a><span>]</span></span></h2>
<p>To understand why this creates more-easily-compressible data, consider transforming a long English text frequently containing the word &#34;the&#34;. Sorting the rotations of this text will group rotations starting with &#34;he &#34; together, and the last character of that rotation (which is also the character before the &#34;he &#34;) will usually be &#34;t&#34;, so the result of the transform would contain a number of &#34;t&#34; characters along with the perhaps less-common exceptions (such as if it contains &#34;ache &#34;) mixed in. So it can be seen that the success of this transform depends upon one value having a high probability of occurring before a sequence, so that in general it needs fairly long samples (a few kilobytes at least) of appropriate data (such as text).
</p><p>The remarkable thing about the BWT is not that it generates a more easily encoded output—an ordinary sort would do that—but that it does this <i>reversibly</i>, allowing the original document to be re-generated from the last column data.
</p><p>The inverse can be understood this way. Take the final table in the BWT algorithm, and erase all but the last column. Given only this information, you can easily reconstruct the first column. The last column tells you all the characters in the text, so just sort these characters alphabetically to get the first column. Then, the last and first columns (of each row) together give you all <i>pairs</i> of successive characters in the document, where pairs are taken cyclically so that the last and first character form a pair. Sorting the list of pairs gives the first <i>and second</i> columns. Continuing in this manner, you can reconstruct the entire list. Then, the row with the &#34;end of file&#34; character at the end is the original text. Reversing the example above is done like this:
</p>
<table>
<tbody><tr>
<th colspan="4">Inverse transformation
</th></tr>
<tr>
<th colspan="4">Input
</th></tr>
<tr>
<td colspan="4">
<pre>BNN^AA<span>|</span>A
</pre>
</td></tr>
<tr>
<th>Add 1
</th>
<th>Sort 1
</th>
<th>Add 2
</th>
<th>Sort 2
</th></tr>
<tr>
<td>
<pre>B
N
N
^
A
A
<span>|</span>
A
</pre>
</td>
<td>
<pre>A
A
A
B
N
N
^
<span>|</span>
</pre>
</td>
<td>
<pre>BA
NA
NA
^B
AN
AN
<span>|</span>^
A<span>|</span>
</pre>
</td>
<td>
<pre>AN
AN
A<span>|</span>
BA
NA
NA
^B
<span>|</span>^
</pre>
</td></tr>
<tr>
<th>Add 3
</th>
<th>Sort 3
</th>
<th>Add 4
</th>
<th>Sort 4
</th></tr>
<tr>
<td>
<pre>BAN
NAN
NA<span>|</span>
^BA
ANA
ANA
<span>|</span>^B
A<span>|</span>^
</pre>
</td>
<td>
<pre>ANA
ANA
A<span>|</span>^
BAN
NAN
NA<span>|</span>
^BA
<span>|</span>^B
</pre>
</td>
<td>
<pre>BANA
NANA
NA<span>|</span>^
^BAN
ANAN
ANA<span>|</span>
<span>|</span>^BA
A<span>|</span>^B
</pre>
</td>
<td>
<pre>ANAN
ANA<span>|</span>
A<span>|</span>^B
BANA
NANA
NA<span>|</span>^
^BAN
<span>|</span>^BA
</pre>
</td></tr>
<tr>
<th>Add 5
</th>
<th>Sort 5
</th>
<th>Add 6
</th>
<th>Sort 6
</th></tr>
<tr>
<td>
<pre>BANAN
NANA<span>|</span>
NA<span>|</span>^B
^BANA
ANANA
ANA<span>|</span>^
<span>|</span>^BAN
A<span>|</span>^BA
</pre>
</td>
<td>
<pre>ANANA
ANA<span>|</span>^
A<span>|</span>^BA
BANAN
NANA<span>|</span>
NA<span>|</span>^B
^BANA
<span>|</span>^BAN
</pre>
</td>
<td>
<pre>BANANA
NANA<span>|</span>^
NA<span>|</span>^BA
^BANAN
ANANA<span>|</span>
ANA<span>|</span>^B
<span>|</span>^BANA
A<span>|</span>^BAN
</pre>
</td>
<td>
<pre>ANANA<span>|</span>
ANA<span>|</span>^B
A<span>|</span>^BAN
BANANA
NANA<span>|</span>^
NA<span>|</span>^BA
^BANAN
<span>|</span>^BANA
</pre>
</td></tr>
<tr>
<th>Add 7
</th>
<th>Sort 7
</th>
<th>Add 8
</th>
<th>Sort 8
</th></tr>
<tr>
<td>
<pre>BANANA<span>|</span>
NANA<span>|</span>^B
NA<span>|</span>^BAN
^BANANA
ANANA<span>|</span>^
ANA<span>|</span>^BA
<span>|</span>^BANAN
A<span>|</span>^BANA
</pre>
</td>
<td>
<pre>ANANA<span>|</span>^
ANA<span>|</span>^BA
A<span>|</span>^BANA
BANANA<span>|</span>
NANA<span>|</span>^B
NA<span>|</span>^BAN
^BANANA
<span>|</span>^BANAN
</pre>
</td>
<td>
<pre>BANANA<span>|</span>^
NANA<span>|</span>^BA
NA<span>|</span>^BANA
^BANANA<span>|</span>
ANANA<span>|</span>^B
ANA<span>|</span>^BAN
<span>|</span>^BANANA
A<span>|</span>^BANAN
</pre>
</td>
<td>
<pre>ANANA<span>|</span>^B
ANA<span>|</span>^BAN
A<span>|</span>^BANAN
BANANA<span>|</span>^
NANA<span>|</span>^BA
NA<span>|</span>^BANA
^BANANA<span>|</span>
<span>|</span>^BANANA
</pre>
</td></tr>
<tr>
<th colspan="4">Output
</th></tr>
<tr>
<td colspan="4">
<pre>^BANANA<span>|</span>
</pre>
</td></tr></tbody></table>
<h2><span id="Optimization">Optimization</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=4" title="Edit section: Optimization">edit</a><span>]</span></span></h2>
<p>A number of <a href="https://en.wikipedia.org/wiki/Optimization_(computer_science)" title="Optimization (computer science)">optimizations</a> can make these algorithms run more efficiently without changing the output. There is no need to represent the table in either the encoder or decoder. In the encoder, each row of the table can be represented by a single pointer into the strings, and the sort performed using the indices. In the decoder, there is also no need to store the table, and in fact no sort is needed at all. In time proportional to the alphabet size and string length, the decoded string may be generated one character at a time from right to left. A &#34;character&#34; in the algorithm can be a byte, or a bit, or any other convenient size.
</p><p>One may also make the observation that mathematically, the encoded string can be computed as a simple modification of the <a href="https://en.wikipedia.org/wiki/Suffix_array" title="Suffix array">suffix array</a>, and suffix arrays can be computed with linear time and memory. The BWT can be defined with regards to the suffix array SA of text T as (1-based indexing):
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/887d46efbb40f6f35ac2b8a5a3a60e42cef84bb2" aria-hidden="true" alt="{\displaystyle BWT[i]={\begin{cases}T[SA[i]-1],&amp;{\text{if }}SA[i]&gt;0\\\$,&amp;{\text{otherwise}}\end{cases}}}"/></span><sup id="cite_ref-3"><a href="#cite_note-3">[3]</a></sup>
</p><p>There is no need to have an actual &#39;EOF&#39; character. Instead, a pointer can be used that remembers where in a string the &#39;EOF&#39; would be if it existed. In this approach, the output of the BWT must include both the transformed string, and the final value of the pointer. The inverse transform then shrinks it back down to the original size: it is given a string and a pointer, and returns just a string.
</p><p>A complete description of the algorithms can be found in Burrows and Wheeler&#39;s paper, or in a number of online sources.<sup id="cite_ref-Burrows1994_1-1"><a href="#cite_note-Burrows1994-1">[1]</a></sup> The algorithms vary somewhat by whether EOF is used, and in which direction the sorting was done. In fact, the original formulation did not use an EOF marker.<sup id="cite_ref-Manzini_4-0"><a href="#cite_note-Manzini-4">[4]</a></sup>
</p>
<h2><span id="Bijective_variant">Bijective variant</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=5" title="Edit section: Bijective variant">edit</a><span>]</span></span></h2>
<p>Since any rotation of the input string will lead to the same transformed string, the BWT cannot be inverted without adding an EOF marker to the end of the input or doing something equivalent, making it possible to distinguish the input string from all its rotations.  Increasing the size of the alphabet (by appending the EOF character) makes later compression steps awkward.
</p><p>There is a <a href="https://en.wikipedia.org/wiki/Bijective" title="Bijective">bijective</a> version of the transform, by which the transformed string uniquely identifies the original, and the two have the same length and contain exactly the same characters, just in a different order.<sup id="cite_ref-5"><a href="#cite_note-5">[5]</a></sup><sup id="cite_ref-6"><a href="#cite_note-6">[6]</a></sup>
</p><p>The bijective transform is computed by factoring the input into a non-increasing sequence of <a href="https://en.wikipedia.org/wiki/Lyndon_word" title="Lyndon word">Lyndon words</a>; such a factorization exists and is unique by the <a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Fox%E2%80%93Lyndon_theorem" title="Chen–Fox–Lyndon theorem">Chen–Fox–Lyndon theorem</a>,<sup id="cite_ref-7"><a href="#cite_note-7">[7]</a></sup> and may be found in linear time.<sup id="cite_ref-8"><a href="#cite_note-8">[8]</a></sup> The algorithm sorts the rotations of all the words; as in the Burrows–Wheeler transform, this produces a sorted sequence of <i>n</i> strings. The transformed string is then obtained by picking the final character of each string in this sorted list.  The one important caveat here is that strings of different lengths are not ordered in the usual way; the two strings are repeated forever, and the infinite repeats are sorted.  For example, &#34;ORO&#34; precedes &#34;OR&#34; because &#34;OROORO...&#34; precedes &#34;OROROR...&#34;.
</p><p>For example, the text &#34;^BANANA<span>|</span>&#34; is transformed into &#34;ANNBAA^<span>|</span>&#34; through these steps (the red <span>|</span> character indicates the <a href="https://en.wikipedia.org/wiki/End-of-file" title="End-of-file">EOF</a> pointer) in the original string. The EOF character is unneeded in the bijective transform, so it is dropped during the transform and re-added to its proper place in the file.
</p><p>The string is broken into Lyndon words so the words in the sequence are decreasing using the comparison method above. (Note that we&#39;re sorting &#39;^&#39; as succeeding other characters.)  &#34;^BANANA&#34; becomes (^) (B) (AN) (AN) (A).
</p>
<table>

<tbody><tr>
<th colspan="5">Bijective transformation
</th></tr>
<tr>
<th>Input
</th>
<th>All</th>
<th>Sorted alphabetically
</th>
<th>Last column</th>
<th>Output
</th></tr>
<tr>
<td>
<pre>^BANANA<span>|</span>
</pre>
</td>
<td>
<pre><b>^</b>^^^^^^^... (^)
<b>B</b>BBBBBBB... (B)
<b>ANAN</b>ANAN... (AN)
<b>NANA</b>NANA... (NA)
<b>ANAN</b>ANAN... (AN)
<b>NANA</b>NANA... (NA)
<b>A</b>AAAAAAA... (A)
</pre>
</td>
<td>
<pre><b>A</b>AAAAAAA... (A)
<b>A</b>NANANAN... (AN)
<b>A</b>NANANAN... (AN)
<b>B</b>BBBBBBB... (B)
<b>N</b>ANANANA... (NA)
<b>N</b>ANANANA... (NA)
<b>^</b>^^^^^^^... (^)
</pre>
</td>
<td>
<pre><b>A</b>AAAAAAA... (<b>A</b>)
A<b>N</b>ANANAN... (A<b>N</b>)
A<b>N</b>ANANAN... (A<b>N</b>)
<b>B</b>BBBBBBB... (<b>B</b>)
N<b>A</b>NANANA... (N<b>A</b>)
N<b>A</b>NANANA... (N<b>A</b>)
<b>^</b>^^^^^^^... (<b>^</b>)
</pre>
</td>
<td>
<pre>ANNBAA^<span>|</span>
</pre>
</td></tr></tbody></table>
<table>
<tbody><tr>
<th colspan="4">Inverse bijective transform
</th></tr>
<tr>
<th colspan="4">Input
</th></tr>
<tr>
<td colspan="4">
<pre>ANNBAA^
</pre>
</td></tr>
<tr>
<th>Add 1
</th>
<th>Sort 1
</th>
<th>Add 2
</th>
<th>Sort 2
</th></tr>
<tr>
<td>
<pre>A
N
N
B
A
A
^
</pre>
</td>
<td>
<pre>A
A
A
B
N
N
^
</pre>
</td>
<td>
<pre>AA
NA
NA
BB
AN
AN
^^
</pre>
</td>
<td>
<pre>AA
AN
AN
BB
NA
NA
^^
</pre>
</td></tr>
<tr>
<th>Add 3
</th>
<th>Sort 3
</th>
<th>Add 4
</th>
<th>Sort 4
</th></tr>
<tr>
<td>
<pre>AAA
NAN
NAN
BBB
ANA
ANA
^^^
</pre>
</td>
<td>
<pre>AAA
ANA
ANA
BBB
NAN
NAN
^^^
</pre>
</td>
<td>
<pre>AAAA
NANA
NANA
BBBB
ANAN
ANAN
^^^^
</pre>
</td>
<td>
<pre>AAAA
ANAN
ANAN
BBBB
NANA
NANA
^^^^
</pre>
</td></tr>
<tr>
<th colspan="4">Output
</th></tr>
<tr>
<td colspan="4">
<pre>^BANANA
</pre>
</td></tr></tbody></table>
<p>Up until the last step, the process is identical to the inverse Burrows–Wheeler process, but here it will not necessarily give rotations of a single sequence; it instead gives rotations of Lyndon words (which will start to repeat as the process is continued).  Here, we can see (repetitions of) four distinct Lyndon words: (A), (AN) (twice), (B), and (^).  (NANA... doesn&#39;t represent a distinct word, as it is a cycle of ANAN....)
At this point, these words are sorted into reverse order: (^), (B), (AN), (AN), (A).  These are then concatenated to get
</p>
<dl><dd>^BANANA</dd></dl>
<p>The Burrows–Wheeler transform can indeed be viewed as a special case of this bijective transform; instead of the traditional introduction of a new letter from outside our alphabet to denote the end of the string, we can introduce a new letter that compares as preceding all existing letters that is put at the beginning of the string.  The whole string is now a Lyndon word, and running it through the bijective process will therefore result in a transformed result that, when inverted, gives back the Lyndon word, with no need for reassembling at the end.
</p><p>Relatedly, the transformed text will only differ from the result of BWT by one character per Lyndon word; for example, if the input is decomposed into six Lyndon words, the output will only differ in six characters.
For example, applying the bijective transform gives:
</p>
<table>
<tbody><tr>
<th>Input
</th>
<td><code>SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES</code>
</td></tr>
<tr>
<th>Lyndon words
</th>
<td><code><span>S</span><span>IX</span><span>.MIXED.PIXIES.SIFT.SIXTY.PIXIE</span><span>.DUST</span><span>.BOXES</span></code>
</td></tr>
<tr>
<th>Output
</th>
<td><code>STEYDST.E.IXXIIXXSMPPXS.B..EE..SUSFXDIOIIIIT</code>
</td></tr></tbody></table>
<p>The bijective transform includes eight runs of identical
characters. These runs are, in order: <code>XX</code>,
<code>II</code>,
<code>XX</code>,
<code>PP</code>,
<code>..</code>,
<code>EE</code>,
<code>..</code>,
and
<code>IIII</code>.
</p><p>In total, 18 characters are used in these runs.
</p>
<h2><span id="Dynamic_Burrows.E2.80.93Wheeler_transform"></span><span id="Dynamic_Burrows–Wheeler_transform">Dynamic Burrows–Wheeler transform</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=6" title="Edit section: Dynamic Burrows–Wheeler transform">edit</a><span>]</span></span></h2>
<p>When a text is edited, its Burrows–Wheeler transform will change. Salson <i>et al.</i><sup id="cite_ref-Salson2009_9-0"><a href="#cite_note-Salson2009-9">[9]</a></sup> propose an algorithm that deduces the Burrows–Wheeler transform of an edited text from that of the original text, doing a limited number of local reorderings in the original Burrows–Wheeler transform, which can be faster than constructing the Burrows–Wheeler transform of the edited text directly.
</p>
<h2><span id="Sample_implementation">Sample implementation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=7" title="Edit section: Sample implementation">edit</a><span>]</span></span></h2>
<p>This <a href="https://en.wikipedia.org/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> implementation sacrifices speed for simplicity: the program is short, but takes more than the linear time that would be desired in a practical implementation. It essentially does what the pseudocode section does.
</p><p>Using the <a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes#STX" title="C0 and C1 control codes">STX/ETX control codes</a> to mark the start and end of the text, and using <code>s[i:] + s[:i]</code> to construct the <code>i</code>th rotation of <code>s</code>, the forward transform takes the last character of each of the sorted rows:
</p>
<div dir="ltr"><pre><span></span><span>def</span> <span>bwt</span><span>(</span><span>s</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>&#34;&#34;&#34;Apply Burrows–Wheeler transform to input string.&#34;&#34;&#34;</span>
    <span>assert</span> <span>&#34;</span><span>\002</span><span>&#34;</span> <span>not</span> <span>in</span> <span>s</span> <span>and</span> <span>&#34;</span><span>\003</span><span>&#34;</span> <span>not</span> <span>in</span> <span>s</span><span>,</span> <span>&#34;Input string cannot contain STX and ETX characters&#34;</span>
    <span>s</span> <span>=</span> <span>&#34;</span><span>\002</span><span>&#34;</span> <span>+</span> <span>s</span> <span>+</span> <span>&#34;</span><span>\003</span><span>&#34;</span>  <span># Add start and end of text marker</span>
    <span>table</span> <span>=</span> <span>sorted</span><span>(</span><span>s</span><span>[</span><span>i</span><span>:]</span> <span>+</span> <span>s</span><span>[:</span><span>i</span><span>]</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>s</span><span>)))</span>  <span># Table of rotations of string</span>
    <span>last_column</span> <span>=</span> <span>[</span><span>row</span><span>[</span><span>-</span><span>1</span><span>:]</span> <span>for</span> <span>row</span> <span>in</span> <span>table</span><span>]</span>  <span># Last characters of each row</span>
    <span>return</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>last_column</span><span>)</span>  <span># Convert list of characters into string</span>
</pre></div>
<p>The inverse transform repeatedly inserts <code>r</code> as the left column of the table and sorts the table.  After the whole table is built, it returns the row that ends with ETX, minus the STX and ETX.
</p>
<div dir="ltr"><pre><span></span><span>def</span> <span>ibwt</span><span>(</span><span>r</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>&#34;&#34;&#34;Apply inverse Burrows–Wheeler transform.&#34;&#34;&#34;</span>
    <span>table</span> <span>=</span> <span>[</span><span>&#34;&#34;</span><span>]</span> <span>*</span> <span>len</span><span>(</span><span>r</span><span>)</span>  <span># Make empty table</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>r</span><span>)):</span>
        <span>table</span> <span>=</span> <span>sorted</span><span>(</span><span>r</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>table</span><span>[</span><span>i</span><span>]</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>r</span><span>)))</span>  <span># Add a column of r</span>
    <span>s</span> <span>=</span> <span>[</span><span>row</span> <span>for</span> <span>row</span> <span>in</span> <span>table</span> <span>if</span> <span>row</span><span>.</span><span>endswith</span><span>(</span><span>&#34;</span><span>\003</span><span>&#34;</span><span>)][</span><span>0</span><span>]</span>  <span># Find the correct row (ending in ETX)</span>
    <span>return</span> <span>s</span><span>.</span><span>rstrip</span><span>(</span><span>&#34;</span><span>\003</span><span>&#34;</span><span>)</span><span>.</span><span>strip</span><span>(</span><span>&#34;</span><span>\002</span><span>&#34;</span><span>)</span>  <span># Get rid of start and end markers</span>
</pre></div>
<p>Following implementation notes from Manzini, it is equivalent to use a simple <a href="https://en.wikipedia.org/wiki/Null_character" title="Null character">null character</a> suffix instead. The sorting should be done in <a href="https://en.wikipedia.org/wiki/Colexicographic_order" title="Colexicographic order">colexicographic order</a> (string read right-to-left), i.e. <code id="" dir="ltr">sorted(..., key=lambda s: s[::-1])</code> in Python.<sup id="cite_ref-Manzini_4-1"><a href="#cite_note-Manzini-4">[4]</a></sup> (The above control codes actually fail to satisfy EOF being the last character; the two codes are actually the <i>first</i>. The rotation holds nevertheless.)
</p>
<h2><span id="BWT_Applications">BWT Applications</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=8" title="Edit section: BWT Applications">edit</a><span>]</span></span></h2>
<p>As a <a href="https://en.wikipedia.org/wiki/Lossless_compression" title="Lossless compression">lossless compression</a> algorithm the Burrows–Wheeler Transform offers the important quality that its encoding is reversible and hence the original data may be recovered from the resulting compression. The lossless quality of Burrows Algorithm has provided for different algorithms with different purposes in mind. To name a few, Burrows Wheeler Transform is used in algorithms for <a href="https://en.wikipedia.org/wiki/Sequence_alignment" title="Sequence alignment">sequence alignment</a>, <a href="https://en.wikipedia.org/wiki/Image_compression" title="Image compression">image compression</a>, <a href="https://en.wikipedia.org/wiki/Data_compression" title="Data compression">data compression</a>, etc. The following is a compilation of some uses given to the Burrows–Wheeler Transform.
</p>
<h3><span id="BWT_for_Sequence_Alignment">BWT for Sequence Alignment</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=9" title="Edit section: BWT for Sequence Alignment">edit</a><span>]</span></span></h3>
<p>The advent of <a href="https://en.wikipedia.org/wiki/Next-generation_sequencing" title="Next-generation sequencing">next-generation sequencing</a> (NGS) techniques at the end of the 2000s decade has led to another application of the Burrows–Wheeler transformation. In NGS, <a href="https://en.wikipedia.org/wiki/DNA" title="DNA">DNA</a> is fragmented into small pieces, of which the first few bases are <a href="https://en.wikipedia.org/wiki/DNA_sequencing" title="DNA sequencing">sequenced</a>, yielding several millions of &#34;reads&#34;, each 30 to 500 <a href="https://en.wikipedia.org/wiki/Base_pair" title="Base pair">base pairs</a> (&#34;DNA characters&#34;) long. In many experiments, e.g., in <a href="https://en.wikipedia.org/wiki/ChIP-Seq" title="ChIP-Seq">ChIP-Seq</a>, the task is now to align these reads to a reference <a href="https://en.wikipedia.org/wiki/Genome" title="Genome">genome</a>, i.e., to the known, nearly complete sequence of the organism in question (which may be up to several billion base pairs long). A number of alignment programs, specialized for this task, were published, which initially relied on <a href="https://en.wikipedia.org/wiki/Hash_function" title="Hash function">hashing</a> (e.g., <a href="https://en.wikipedia.org/w/index.php?title=Eland_(software)&amp;action=edit&amp;redlink=1" title="Eland (software) (page does not exist)">Eland</a>, SOAP,<sup id="cite_ref-Li,_R2008_10-0"><a href="#cite_note-Li,_R2008-10">[10]</a></sup> or <a href="https://en.wikipedia.org/w/index.php?title=Maq&amp;action=edit&amp;redlink=1" title="Maq (page does not exist)">Maq</a><sup id="cite_ref-Li,_H2008_11-0"><a href="#cite_note-Li,_H2008-11">[11]</a></sup>). In an effort to reduce the memory requirement for sequence alignment, several alignment programs were developed (<a href="https://en.wikipedia.org/wiki/Bowtie_(sequence_analysis)" title="Bowtie (sequence analysis)">Bowtie</a>,<sup id="cite_ref-Langmead2009_12-0"><a href="#cite_note-Langmead2009-12">[12]</a></sup> BWA,<sup id="cite_ref-Li,_H2009_13-0"><a href="#cite_note-Li,_H2009-13">[13]</a></sup> and SOAP2<sup id="cite_ref-Li,_R2009_14-0"><a href="#cite_note-Li,_R2009-14">[14]</a></sup>) that use the Burrows–Wheeler transform.
</p>
<h3><span id="BWT_for_Image_Compression">BWT for Image Compression</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=10" title="Edit section: BWT for Image Compression">edit</a><span>]</span></span></h3>
<p>The Burrows–Wheeler Transformation has proved to be fundamental for <a href="https://en.wikipedia.org/wiki/Image_compression" title="Image compression">image compression</a> applications. For example, <sup id="cite_ref-Collin,_P2019_15-0"><a href="#cite_note-Collin,_P2019-15">[15]</a></sup> Showed a compression pipeline based on the application of the Burrows–Wheeler Transformation followed by Inversion, Run-Length, and Arithmetic encoders. The pipeline developed in this case is known as Burrows–Wheeler Transform with an Inversion Encoder (BWIC).  The results shown by BWIC  are shown to outperform the compression performance of well-known and widely used algorithms like <a href="https://en.wikipedia.org/wiki/Lossless_JPEG" title="Lossless JPEG">Lossless_JPEG</a> and <a href="https://en.wikipedia.org/wiki/JPEG_2000" title="JPEG 2000">JPEG_2000</a>. BWIC is shown to outperform <a href="https://en.wikipedia.org/wiki/Lossless_JPEG" title="Lossless JPEG">Lossless_JPEG</a> and <a href="https://en.wikipedia.org/wiki/JPEG_2000" title="JPEG 2000">JPEG_2000</a> in terms of final compression size of radiography medical images on the order of 5.1% and 4.1% respectively. The improvements are achieved by combining BWIC and a pre-BWIC scan of the image in a vertical snake order fashion. More recently, additional works like that of <sup id="cite_ref-Devadoss,_CP2019_16-0"><a href="#cite_note-Devadoss,_CP2019-16">[16]</a></sup> have shown the implementation of the Burrows–Wheeler Transform in conjunction with the known <a href="https://en.wikipedia.org/wiki/Move-to-front_transform" title="Move-to-front transform">Move-to-front transform</a>(MTF) achieve near lossless compression of images. 
</p>
<h3><span id="BWT_for_Compression_of_Genomic_Databases">BWT for Compression of Genomic Databases</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=11" title="Edit section: BWT for Compression of Genomic Databases">edit</a><span>]</span></span></h3>
<p>Cox et al. <sup id="cite_ref-Cox,_AJ2012_17-0"><a href="#cite_note-Cox,_AJ2012-17">[17]</a></sup> presented a genomic compression scheme that uses BWT as the algorithm applied during the first stage of compression of several genomic datasets including the human genomic information. Their work proposed that BWT compression could be enhanced by including a second stage compression mechanism called same-as-previous encoding (&#34;SAP&#34;), which makes use of the fact that suffixes of two or more prefix letters could be equal. With the compression mechanism BWT-SAP, Cox et al. showed that in the genomic database ERA015743, 135.5 GB in size, the compression scheme BWT-SAP compresses the ERA015743 dataset by around 94%, to 8.2 GB.
</p>
<h3><span id="BWT_for_Sequence_Prediction">BWT for Sequence Prediction</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=12" title="Edit section: BWT for Sequence Prediction">edit</a><span>]</span></span></h3>
<p>BWT has also been proved to be useful on sequence prediction which is a common area of study in <a href="https://en.wikipedia.org/wiki/Machine_learning" title="Machine learning">machine learning</a> and <a href="https://en.wikipedia.org/wiki/Natural_Language_Processing" title="Natural Language Processing">Natural Language Processing</a>. In particular, Ktistakis et al. <sup id="cite_ref-Ktistakis,_R2019_18-0"><a href="#cite_note-Ktistakis,_R2019-18">[18]</a></sup> proposed a sequence prediction scheme called SuBSeq that exploits the lossless compression of data of the Burrows–Wheeler Transform. SuBSeq exploits BWT by extracting the <a href="https://en.wikipedia.org/wiki/FM-index" title="FM-index">FM-index</a> and then performing a series of operations called backwardSearch, forwardSearch, neighbourExpansion, and getConsequents in order to search for predictions given a <a href="https://en.wikipedia.org/wiki/Suffix" title="Suffix">suffix</a>. The predictions are then classified based on a weight and put into an array from which the element with the highest weight is given as the prediction from the SuBSeq algorithm. SuBSeq has been show to outperform <a href="https://en.wikipedia.org/wiki/State_of_the_art" title="State of the art">state of the art</a> algorithms for sequence prediction both in terms of training time and accuracy.
</p>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=13" title="Edit section: References">edit</a><span>]</span></span></h2>
<div>
<div><ol>
<li id="cite_note-Burrows1994-1"><span>^ <a href="#cite_ref-Burrows1994_1-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Burrows1994_1-1"><sup><i><b>b</b></i></sup></a></span> <span><cite id="CITEREFBurrowsWheeler1994"><a href="https://en.wikipedia.org/wiki/Michael_Burrows" title="Michael Burrows">Burrows, Michael</a>; <a href="https://en.wikipedia.org/wiki/David_Wheeler_(British_computer_scientist)" title="David Wheeler (British computer scientist)">Wheeler, David J.</a> (1994), <a rel="nofollow" href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.html"><i>A block sorting lossless data compression algorithm</i></a>, Technical Report 124, Digital Equipment Corporation</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A+block+sorting+lossless+data+compression+algorithm&amp;rft.pub=Technical+Report+124%2C+Digital+Equipment+Corporation&amp;rft.date=1994&amp;rft.aulast=Burrows&amp;rft.aufirst=Michael&amp;rft.au=Wheeler%2C+David+J.&amp;rft_id=http%3A%2F%2Fwww.hpl.hp.com%2Ftechreports%2FCompaq-DEC%2FSRC-RR-124.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-2"><span><b><a href="#cite_ref-2">^</a></b></span> <span><cite><a rel="nofollow" href="https://github.com/adrien-mogenet/scala-bwt/blob/master/src/main/scala/me/algos/bwt/BurrowsWheelerCodec.scala">&#34;adrien-mogenet/scala-bwt&#34;</a>. <i>GitHub</i><span>. Retrieved <span>19 April</span> 2018</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=unknown&amp;rft.jtitle=GitHub&amp;rft.atitle=adrien-mogenet%2Fscala-bwt&amp;rft_id=https%3A%2F%2Fgithub.com%2Fadrien-mogenet%2Fscala-bwt%2Fblob%2Fmaster%2Fsrc%2Fmain%2Fscala%2Fme%2Falgos%2Fbwt%2FBurrowsWheelerCodec.scala&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-3"><span><b><a href="#cite_ref-3">^</a></b></span> <span><cite id="CITEREFSimpsonDurbin2010">Simpson, Jared T.; Durbin, Richard (2010-06-15). <a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2881401">&#34;Efficient construction of an assembly string graph using the FM-index&#34;</a>. <i>Bioinformatics</i>. <b>26</b> (12): i367–i373. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtq217">10.1093/bioinformatics/btq217</a>. <a href="https://en.wikipedia.org/wiki/ISSN_(identifier)" title="ISSN (identifier)">ISSN</a> <a rel="nofollow" href="https://www.worldcat.org/issn/1367-4803">1367-4803</a>. <a href="https://en.wikipedia.org/wiki/PMC_(identifier)" title="PMC (identifier)">PMC</a> <span title="Freely accessible"><a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2881401">2881401</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/20529929">20529929</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bioinformatics&amp;rft.atitle=Efficient+construction+of+an+assembly+string+graph+using+the+FM-index&amp;rft.volume=26&amp;rft.issue=12&amp;rft.pages=i367-i373&amp;rft.date=2010-06-15&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2881401%23id-name%3DPMC&amp;rft.issn=1367-4803&amp;rft_id=info%3Apmid%2F20529929&amp;rft_id=info%3Adoi%2F10.1093%2Fbioinformatics%2Fbtq217&amp;rft.aulast=Simpson&amp;rft.aufirst=Jared+T.&amp;rft.au=Durbin%2C+Richard&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2881401&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Manzini-4"><span>^ <a href="#cite_ref-Manzini_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Manzini_4-1"><sup><i><b>b</b></i></sup></a></span> <span><cite id="CITEREFManzini1999">Manzini, Giovanni (1999-08-18). <a rel="nofollow" href="https://people.unipmn.it/manzini/papers/mfcs99x.pdf">&#34;The Burrows–Wheeler Transform: Theory and Practice&#34;</a> <span>(PDF)</span>. <i>Mathematical Foundations of Computer Science 1999: 24th International Symposium, MFCS&#39;99 Szklarska Poreba, Poland, September 6-10, 1999 Proceedings</i>. Springer Science &amp; Business Media. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/9783540664086" title="Special:BookSources/9783540664086"><bdi>9783540664086</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=The+Burrows%E2%80%93Wheeler+Transform%3A+Theory+and+Practice&amp;rft.btitle=Mathematical+Foundations+of+Computer+Science+1999%3A+24th+International+Symposium%2C+MFCS%2799+Szklarska+Poreba%2C+Poland%2C+September+6-10%2C+1999+Proceedings&amp;rft.pub=Springer+Science+%26+Business+Media&amp;rft.date=1999-08-18&amp;rft.isbn=9783540664086&amp;rft.aulast=Manzini&amp;rft.aufirst=Giovanni&amp;rft_id=https%3A%2F%2Fpeople.unipmn.it%2Fmanzini%2Fpapers%2Fmfcs99x.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-5"><span><b><a href="#cite_ref-5">^</a></b></span> <span><cite id="CITEREFGilScott2009">Gil, J.; Scott, D. A. (2009), <a rel="nofollow" href="http://bijective.dogma.net/00yyy.pdf"><i>A bijective string sorting transform</i></a> <span>(PDF)</span></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A+bijective+string+sorting+transform&amp;rft.date=2009&amp;rft.aulast=Gil&amp;rft.aufirst=J.&amp;rft.au=Scott%2C+D.+A.&amp;rft_id=http%3A%2F%2Fbijective.dogma.net%2F00yyy.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-6"><span><b><a href="#cite_ref-6">^</a></b></span> <span><cite id="CITEREFKufleitner2009">Kufleitner, Manfred (2009), &#34;On bijective variants of the Burrows–Wheeler transform&#34;,  in Holub, Jan; Žďárek, Jan (eds.), <a rel="nofollow" href="http://www.stringology.org/event/2009/p07.html"><i>Prague Stringology Conference</i></a>, pp. 65–69, <a href="https://en.wikipedia.org/wiki/ArXiv_(identifier)" title="ArXiv (identifier)">arXiv</a>:<span title="Freely accessible"><a rel="nofollow" href="https://arxiv.org/abs/0908.0239">0908.0239</a></span>, <a href="https://en.wikipedia.org/wiki/Bibcode_(identifier)" title="Bibcode (identifier)">Bibcode</a>:<a rel="nofollow" href="https://ui.adsabs.harvard.edu/abs/2009arXiv0908.0239K">2009arXiv0908.0239K</a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=On+bijective+variants+of+the+Burrows%E2%80%93Wheeler+transform&amp;rft.btitle=Prague+Stringology+Conference&amp;rft.pages=65-69&amp;rft.date=2009&amp;rft_id=info%3Aarxiv%2F0908.0239&amp;rft_id=info%3Abibcode%2F2009arXiv0908.0239K&amp;rft.aulast=Kufleitner&amp;rft.aufirst=Manfred&amp;rft_id=http%3A%2F%2Fwww.stringology.org%2Fevent%2F2009%2Fp07.html&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span>.</span>
</li>
<li id="cite_note-7"><span><b><a href="#cite_ref-7">^</a></b></span> <span>*<cite id="CITEREFLothaire1997"><a href="https://en.wikipedia.org/wiki/M._Lothaire" title="M. Lothaire">Lothaire, M.</a> (1997), <i>Combinatorics on words</i>, Encyclopedia of Mathematics and Its Applications, vol. 17, Perrin, D.; Reutenauer, C.; Berstel, J.; Pin, J. E.; Pirillo, G.; Foata, D.; Sakarovitch, J.; Simon, I.; Schützenberger, M. P.; Choffrut, C.; Cori, R.; Lyndon, Roger; Rota, Gian-Carlo. Foreword by Roger Lyndon (2nd ed.), <a href="https://en.wikipedia.org/wiki/Cambridge_University_Press" title="Cambridge University Press">Cambridge University Press</a>, p. 67, <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-521-59924-5" title="Special:BookSources/978-0-521-59924-5"><bdi>978-0-521-59924-5</bdi></a>, <a href="https://en.wikipedia.org/wiki/Zbl_(identifier)" title="Zbl (identifier)">Zbl</a> <a rel="nofollow" href="https://zbmath.org/?format=complete&amp;q=an:0874.20040">0874.20040</a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Combinatorics+on+words&amp;rft.series=Encyclopedia+of+Mathematics+and+Its+Applications&amp;rft.pages=67&amp;rft.edition=2nd&amp;rft.pub=Cambridge+University+Press&amp;rft.date=1997&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A0874.20040%23id-name%3DZbl&amp;rft.isbn=978-0-521-59924-5&amp;rft.aulast=Lothaire&amp;rft.aufirst=M.&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-8"><span><b><a href="#cite_ref-8">^</a></b></span> <span><cite id="CITEREFDuval1983">Duval, Jean-Pierre (1983), &#34;Factorizing words over an ordered alphabet&#34;, <i>Journal of Algorithms</i>, <b>4</b> (4): 363–381, <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1016%2F0196-6774%2883%2990017-2">10.1016/0196-6774(83)90017-2</a>, <a href="https://en.wikipedia.org/wiki/ISSN_(identifier)" title="ISSN (identifier)">ISSN</a> <a rel="nofollow" href="https://www.worldcat.org/issn/0196-6774">0196-6774</a>, <a href="https://en.wikipedia.org/wiki/Zbl_(identifier)" title="Zbl (identifier)">Zbl</a> <a rel="nofollow" href="https://zbmath.org/?format=complete&amp;q=an:0532.68061">0532.68061</a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Journal+of+Algorithms&amp;rft.atitle=Factorizing+words+over+an+ordered+alphabet&amp;rft.volume=4&amp;rft.issue=4&amp;rft.pages=363-381&amp;rft.date=1983&amp;rft_id=%2F%2Fzbmath.org%2F%3Fformat%3Dcomplete%26q%3Dan%3A0532.68061%23id-name%3DZbl&amp;rft.issn=0196-6774&amp;rft_id=info%3Adoi%2F10.1016%2F0196-6774%2883%2990017-2&amp;rft.aulast=Duval&amp;rft.aufirst=Jean-Pierre&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span>.</span>
</li>
<li id="cite_note-Salson2009-9"><span><b><a href="#cite_ref-Salson2009_9-0">^</a></b></span> <span><cite id="CITEREFSalsonLecroqLéonardMouchard2009">Salson M, Lecroq T, Léonard M, Mouchard L (2009). &#34;A Four-Stage Algorithm for Updating a Burrows–Wheeler Transform&#34;. <i>Theoretical Computer Science</i>. <b>410</b> (43): 4350–4359. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1016%2Fj.tcs.2009.07.016">10.1016/j.tcs.2009.07.016</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Theoretical+Computer+Science&amp;rft.atitle=A+Four-Stage+Algorithm+for+Updating+a+Burrows%E2%80%93Wheeler+Transform&amp;rft.volume=410&amp;rft.issue=43&amp;rft.pages=4350-4359&amp;rft.date=2009&amp;rft_id=info%3Adoi%2F10.1016%2Fj.tcs.2009.07.016&amp;rft.aulast=Salson&amp;rft.aufirst=M&amp;rft.au=Lecroq%2C+T&amp;rft.au=L%C3%A9onard%2C+M&amp;rft.au=Mouchard%2C+L&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Li,_R2008-10"><span><b><a href="#cite_ref-Li,_R2008_10-0">^</a></b></span> <span><cite id="CITEREFLi_R2008">Li R;  et al. (2008). <a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtn025">&#34;SOAP: short oligonucleotide alignment program&#34;</a>. <i>Bioinformatics</i>. <b>24</b> (5): 713–714. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<span title="Freely accessible"><a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtn025">10.1093/bioinformatics/btn025</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/18227114">18227114</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bioinformatics&amp;rft.atitle=SOAP%3A+short+oligonucleotide+alignment+program&amp;rft.volume=24&amp;rft.issue=5&amp;rft.pages=713-714&amp;rft.date=2008&amp;rft_id=info%3Adoi%2F10.1093%2Fbioinformatics%2Fbtn025&amp;rft_id=info%3Apmid%2F18227114&amp;rft.au=Li+R&amp;rft_id=%2F%2Fdoi.org%2F10.1093%252Fbioinformatics%252Fbtn025&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Li,_H2008-11"><span><b><a href="#cite_ref-Li,_H2008_11-0">^</a></b></span> <span><cite id="CITEREFLiRuanDurbin2008">Li H, Ruan J, Durbin R (2008-08-19). <a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2577856">&#34;Mapping short DNA sequencing reads and calling variants using mapping quality scores&#34;</a>. <i>Genome Research</i>. <b>18</b> (11): 1851–1858. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1101%2Fgr.078212.108">10.1101/gr.078212.108</a>. <a href="https://en.wikipedia.org/wiki/PMC_(identifier)" title="PMC (identifier)">PMC</a> <span title="Freely accessible"><a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2577856">2577856</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/18714091">18714091</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Genome+Research&amp;rft.atitle=Mapping+short+DNA+sequencing+reads+and+calling+variants+using+mapping+quality+scores&amp;rft.volume=18&amp;rft.issue=11&amp;rft.pages=1851-1858&amp;rft.date=2008-08-19&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2577856%23id-name%3DPMC&amp;rft_id=info%3Apmid%2F18714091&amp;rft_id=info%3Adoi%2F10.1101%2Fgr.078212.108&amp;rft.aulast=Li&amp;rft.aufirst=H&amp;rft.au=Ruan%2C+J&amp;rft.au=Durbin%2C+R&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2577856&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Langmead2009-12"><span><b><a href="#cite_ref-Langmead2009_12-0">^</a></b></span> <span><cite id="CITEREFLangmeadTrapnellPopSalzberg2009">Langmead B, Trapnell C, Pop M, Salzberg SL (2009). <a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2690996">&#34;Ultrafast and memory-efficient alignment of short DNA sequences to the human genome&#34;</a>. <i>Genome Biology</i>. <b>10</b> (3): R25. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1186%2Fgb-2009-10-3-r25">10.1186/gb-2009-10-3-r25</a>. <a href="https://en.wikipedia.org/wiki/PMC_(identifier)" title="PMC (identifier)">PMC</a> <span title="Freely accessible"><a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2690996">2690996</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/19261174">19261174</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Genome+Biology&amp;rft.atitle=Ultrafast+and+memory-efficient+alignment+of+short+DNA+sequences+to+the+human+genome&amp;rft.volume=10&amp;rft.issue=3&amp;rft.pages=R25&amp;rft.date=2009&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2690996%23id-name%3DPMC&amp;rft_id=info%3Apmid%2F19261174&amp;rft_id=info%3Adoi%2F10.1186%2Fgb-2009-10-3-r25&amp;rft.aulast=Langmead&amp;rft.aufirst=B&amp;rft.au=Trapnell%2C+C&amp;rft.au=Pop%2C+M&amp;rft.au=Salzberg%2C+SL&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2690996&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Li,_H2009-13"><span><b><a href="#cite_ref-Li,_H2009_13-0">^</a></b></span> <span><cite id="CITEREFLiDurbin2009">Li H, Durbin R (2009). <a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2705234">&#34;Fast and accurate short read alignment with Burrows–Wheeler Transform&#34;</a>. <i>Bioinformatics</i>. <b>25</b> (14): 1754–1760. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtp324">10.1093/bioinformatics/btp324</a>. <a href="https://en.wikipedia.org/wiki/PMC_(identifier)" title="PMC (identifier)">PMC</a> <span title="Freely accessible"><a rel="nofollow" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2705234">2705234</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/19451168">19451168</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bioinformatics&amp;rft.atitle=Fast+and+accurate+short+read+alignment+with+Burrows%E2%80%93Wheeler+Transform&amp;rft.volume=25&amp;rft.issue=14&amp;rft.pages=1754-1760&amp;rft.date=2009&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2705234%23id-name%3DPMC&amp;rft_id=info%3Apmid%2F19451168&amp;rft_id=info%3Adoi%2F10.1093%2Fbioinformatics%2Fbtp324&amp;rft.aulast=Li&amp;rft.aufirst=H&amp;rft.au=Durbin%2C+R&amp;rft_id=%2F%2Fwww.ncbi.nlm.nih.gov%2Fpmc%2Farticles%2FPMC2705234&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Li,_R2009-14"><span><b><a href="#cite_ref-Li,_R2009_14-0">^</a></b></span> <span><cite id="CITEREFLi_R2009">Li R;  et al. (2009). <a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtp336">&#34;SOAP2: an improved ultrafast tool for short read alignment&#34;</a>. <i>Bioinformatics</i>. <b>25</b> (15): 1966–1967. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<span title="Freely accessible"><a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbtp336">10.1093/bioinformatics/btp336</a></span>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/19497933">19497933</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bioinformatics&amp;rft.atitle=SOAP2%3A+an+improved+ultrafast+tool+for+short+read+alignment&amp;rft.volume=25&amp;rft.issue=15&amp;rft.pages=1966-1967&amp;rft.date=2009&amp;rft_id=info%3Adoi%2F10.1093%2Fbioinformatics%2Fbtp336&amp;rft_id=info%3Apmid%2F19497933&amp;rft.au=Li+R&amp;rft_id=%2F%2Fdoi.org%2F10.1093%252Fbioinformatics%252Fbtp336&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Collin,_P2019-15"><span><b><a href="#cite_ref-Collin,_P2019_15-0">^</a></b></span> <span><cite id="CITEREFCollinArnavutKoc2015">Collin P, Arnavut Z, Koc B (2015). <a rel="nofollow" href="https://ieeexplore.ieee.org/document/7319012">&#34;Lossless compression of medical images using Burrows–Wheeler Transformation with Inversion Coder&#34;</a>. <i>2015 37th Annual International Conference of the IEEE Engineering in Medicine and Biology Society (EMBC)</i>. Vol. 2015. pp. 2956–2959. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1109%2FEMBC.2015.7319012">10.1109/EMBC.2015.7319012</a>. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-1-4244-9271-8" title="Special:BookSources/978-1-4244-9271-8"><bdi>978-1-4244-9271-8</bdi></a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/26736912">26736912</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)" title="S2CID (identifier)">S2CID</a> <a rel="nofollow" href="https://api.semanticscholar.org/CorpusID:4460328">4460328</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Lossless+compression+of+medical+images+using+Burrows%E2%80%93Wheeler+Transformation+with+Inversion+Coder&amp;rft.btitle=2015+37th+Annual+International+Conference+of+the+IEEE+Engineering+in+Medicine+and+Biology+Society+%28EMBC%29&amp;rft.pages=2956-2959&amp;rft.date=2015&amp;rft_id=info%3Adoi%2F10.1109%2FEMBC.2015.7319012&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A4460328%23id-name%3DS2CID&amp;rft_id=info%3Apmid%2F26736912&amp;rft.isbn=978-1-4244-9271-8&amp;rft.aulast=Collin&amp;rft.aufirst=P&amp;rft.au=Arnavut%2C+Z&amp;rft.au=Koc%2C+B&amp;rft_id=https%3A%2F%2Fieeexplore.ieee.org%2Fdocument%2F7319012&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Devadoss,_CP2019-16"><span><b><a href="#cite_ref-Devadoss,_CP2019_16-0">^</a></b></span> <span><cite id="CITEREFDevadossSankaragomathi2019">Devadoss CP, Sankaragomathi B (2019). <a rel="nofollow" href="https://link.springer.com/article/10.1007/s10586-018-1801-3">&#34;Near lossless medical image compression using block BWT–MTF and hybrid fractal compression techniques&#34;</a>. <i>Cluster Computing</i>. <b>22</b>: 12929–12937. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1007%2Fs10586-018-1801-3">10.1007/s10586-018-1801-3</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)" title="S2CID (identifier)">S2CID</a> <a rel="nofollow" href="https://api.semanticscholar.org/CorpusID:33687086">33687086</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Cluster+Computing&amp;rft.atitle=Near+lossless+medical+image+compression+using+block+BWT%E2%80%93MTF+and+hybrid+fractal+compression+techniques&amp;rft.volume=22&amp;rft.pages=12929-12937&amp;rft.date=2019&amp;rft_id=info%3Adoi%2F10.1007%2Fs10586-018-1801-3&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A33687086%23id-name%3DS2CID&amp;rft.aulast=Devadoss&amp;rft.aufirst=CP&amp;rft.au=Sankaragomathi%2C+B&amp;rft_id=https%3A%2F%2Flink.springer.com%2Farticle%2F10.1007%2Fs10586-018-1801-3&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Cox,_AJ2012-17"><span><b><a href="#cite_ref-Cox,_AJ2012_17-0">^</a></b></span> <span><cite id="CITEREFCoxBauerJakobiRosone2012">Cox AJ, Bauer MJ, Jakobi T, Rosone G (2012). <a rel="nofollow" href="http://arxiv.org/abs/1205.0192">&#34;Large-scale compression of genomic sequence databases with the Burrows–Wheeler transform&#34;</a>. <i>Bioinformatics</i>. Oxford University Press. <b>28</b> (11): 1415–1419. <a href="https://en.wikipedia.org/wiki/ArXiv_(identifier)" title="ArXiv (identifier)">arXiv</a>:<span title="Freely accessible"><a rel="nofollow" href="https://arxiv.org/abs/1205.0192">1205.0192</a></span>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1093%2Fbioinformatics%2Fbts173">10.1093/bioinformatics/bts173</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" title="PMID (identifier)">PMID</a> <a rel="nofollow" href="https://pubmed.ncbi.nlm.nih.gov/22556365">22556365</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Bioinformatics&amp;rft.atitle=Large-scale+compression+of+genomic+sequence+databases+with+the+Burrows%E2%80%93Wheeler+transform&amp;rft.volume=28&amp;rft.issue=11&amp;rft.pages=1415-1419&amp;rft.date=2012&amp;rft_id=info%3Aarxiv%2F1205.0192&amp;rft_id=info%3Apmid%2F22556365&amp;rft_id=info%3Adoi%2F10.1093%2Fbioinformatics%2Fbts173&amp;rft.aulast=Cox&amp;rft.aufirst=AJ&amp;rft.au=Bauer%2C+MJ&amp;rft.au=Jakobi%2C+T&amp;rft.au=Rosone%2C+G&amp;rft_id=http%3A%2F%2Farxiv.org%2Fabs%2F1205.0192&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
<li id="cite_note-Ktistakis,_R2019-18"><span><b><a href="#cite_ref-Ktistakis,_R2019_18-0">^</a></b></span> <span><cite id="CITEREFKtistakisFournier-VigerPuglisiRaman2019">Ktistakis R, Fournier-Viger P, Puglisi SJ, Raman R (2019). <a rel="nofollow" href="https://link.springer.com/chapter/10.1007/978-3-030-27618-8_7">&#34;Succinct BWT-Based Sequence Prediction&#34;</a>. <i>Database and Expert Systems Applications</i>. Lecture Notes in Computer Science. Vol. 11707. pp. 91–101. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1007%2F978-3-030-27618-8_7">10.1007/978-3-030-27618-8_7</a>. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" title="ISBN (identifier)">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-3-030-27617-1" title="Special:BookSources/978-3-030-27617-1"><bdi>978-3-030-27617-1</bdi></a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)" title="S2CID (identifier)">S2CID</a> <a rel="nofollow" href="https://api.semanticscholar.org/CorpusID:201058996">201058996</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.atitle=Succinct+BWT-Based+Sequence+Prediction&amp;rft.btitle=Database+and+Expert+Systems+Applications&amp;rft.series=Lecture+Notes+in+Computer+Science&amp;rft.pages=91-101&amp;rft.date=2019&amp;rft_id=https%3A%2F%2Fapi.semanticscholar.org%2FCorpusID%3A201058996%23id-name%3DS2CID&amp;rft_id=info%3Adoi%2F10.1007%2F978-3-030-27618-8_7&amp;rft.isbn=978-3-030-27617-1&amp;rft.aulast=Ktistakis&amp;rft.aufirst=R&amp;rft.au=Fournier-Viger%2C+P&amp;rft.au=Puglisi%2C+SJ&amp;rft.au=Raman%2C+R&amp;rft_id=https%3A%2F%2Flink.springer.com%2Fchapter%2F10.1007%2F978-3-030-27618-8_7&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ABurrows%E2%80%93Wheeler+transform"></span></span>
</li>
</ol></div></div>
<h2><span id="External_links">External links</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Burrows%E2%80%93Wheeler_transform&amp;action=edit&amp;section=14" title="Edit section: External links">edit</a><span>]</span></span></h2>
<ul><li><a rel="nofollow" href="http://marknelson.us/1996/09/01/bwt/">Article by Mark Nelson on the BWT</a></li>
<li><a rel="nofollow" href="http://bijective.dogma.net/00yyy.pdf">A Bijective String-Sorting Transform, by Gil and Scott</a></li>
<li><a rel="nofollow" href="https://web.archive.org/web/20170306035431/https://encode.ru/attachment.php?attachmentid=959&amp;d=1249146089">Yuta&#39;s openbwt-v1.5.zip contains source code for various BWT routines including BWTS for bijective version</a></li>
<li><a rel="nofollow" href="https://arxiv.org/abs/0908.0239">On Bijective Variants of the Burrows–Wheeler Transform, by Kufleitner</a></li>
<li><a rel="nofollow" href="http://google-opensource.blogspot.com/2008/06/debuting-dcs-bwt-experimental-burrows.html">Blog post</a> and <a rel="nofollow" href="https://code.google.com/p/dcs-bwt-compressor/">project page</a> for an open-source compression program and library based on the Burrows–Wheeler algorithm</li>
<li><a rel="nofollow" href="https://www.youtube.com/watch?v=P3ORBMon8aw">MIT open courseware lecture on BWT (Foundations of Computational and Systems Biology)</a></li>
<li><a rel="nofollow" href="https://github.com/abderrahimh/ARahim">League Table Sort (LTS) or The Weighting algorithm to BWT by Abderrahim Hechachena</a></li></ul>

<!-- 
NewPP limit report
Parsed by mw1355
Cached time: 20220918233402
Cache expiry: 1814400
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.401 seconds
Real time usage: 0.510 seconds
Preprocessor visited node count: 1618/1000000
Post‐expand include size: 93079/2097152 bytes
Template argument size: 697/2097152 bytes
Highest expansion depth: 8/100
Expensive parser function count: 3/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 71666/5000000 bytes
Lua time usage: 0.226/10.000 seconds
Lua memory usage: 5933096/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  380.336      1 -total
 55.31%  210.364      1 Template:Reflist
 29.45%  112.008      5 Template:Citation
 24.58%   93.487      1 Template:Burrows_Wheeler_1994
 18.78%   71.436      6 Template:Navbox
 17.91%   68.116      1 Template:Compression_Methods
 15.79%   60.071      1 Template:Short_description
 11.46%   43.599      9 Template:Cite_journal
  9.73%   37.002      2 Template:Pagetype
  7.55%   28.723      1 Template:Infobox_algorithm
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:36777-0!canonical and timestamp 20220918233401 and revision id 1088422306.
 -->
</div>
</div></div>
  </body>
</html>
