<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2023/cubic-spline-interpolation/">Original</a>
    <h1>Cubic spline interpolation</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>This post explains how cubic spline interpolation works, and presents a full
implementation in JavaScript, hooked up to a SVG-based visualization.
As a side effect, it also covers Gaussian elimination and presents a JavaScript
implementation of that as well.</p>
<p>I love topics that mix math and programming in a meaningful way, and cubic
spline interpolation is an excellent example of such a topic. There&#39;s a bunch
of linear algebra here and some calculus, all connected with code to create
a useful tool.</p>
<div id="motivation">
<h2>Motivation</h2>
<p>In an <em>interpolation</em> problem, we&#39;re given a set of points (we&#39;ll be using
2D points <em>X,Y</em> throughout this post) and are asked to estimate Y values for
Xs not in this original set, specifically for Xs that lie between Xs of the
original set (estimation for Xs outside the bounds of the original set
is called <em>extrapolation</em>).</p>
<p>As a concrete example, consider the set of points (0, 1), (1, 3), (2, 2); here
they are plotted in the usual coordinate system:</p>
<p><img alt="Three points on a 2D plot" src="https://eli.thegreenplace.net/images/2023/interp-3points.png"/></p><p>Interpolation is estimating the value of Y for Xs between 0 and 2, given just
this data set. Obviously, the more complex the underlying function/phenomenon,
and the fewer original points we&#39;re given, interpolation becomes more difficult
to do accurately.</p>
<p>There are many techniques to interpolate between a given set of points.
<a href="https://en.wikipedia.org/wiki/Polynomial_interpolation">Polynomial interpolation</a> can perfectly fit N
points with an N-1 degree polynomial, but this approach can be problematic for
large a N; high-degree polynomials tend to overfit their data, and suffer from
other numerical issues like <a href="https://en.wikipedia.org/wiki/Runge&#39;s_phenomenon">Runge&#39;s phenomenon</a>.</p>
<p>Instead of interpolating all the points with a single function, a very popular
alternative is using <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">Splines</a>, which are piece-wise
polynomials. The idea is to fit a low-degree polynomial between every pair of
adjacent points in the original data set; for N points, we get N-1 different
polynomials. The simplest and best known variant of this technique is linear
interpolation:</p>
<p><img alt="Three points on a 2D plot with linear interpolation connecting them" src="https://eli.thegreenplace.net/images/2023/interp-linear.png"/></p><p>Linear interpolation has clear benefits: it&#39;s very fast, and when N is large
it produces reasonable results. However, for small Ns the result isn&#39;t great,
and the approximation is very crude. Here&#39;s the linear spline interpolation of
the <a href="https://en.wikipedia.org/wiki/Sinc_function">Sinc function</a> sampled
at 7 points:</p>
<p><img alt="Sinc function with linear interpolation" src="https://eli.thegreenplace.net/images/2023/interp-sinc-linear.png"/></p><p>We can certainly do much better.</p>
<p>How about higher-degree splines? We can try second degree polynomials, but it&#39;s
better to jump straight to cubic (third degree). Here&#39;s why: to make our
interpolation realistic and aesthetically pleasing, we want the neighboring
polynomials not only to touch at the original points (the linear splines already
do this), but to actually look like they&#39;re part of the same curve. For this
purpose, we want the <em>slope</em> of the polynomials to be continuous, meaning that
if two polynomials meet at point P, their first derivatives at this point are
equal. Moreover, to ensure smoothness and to minimize needless bending <a href="#footnote-1" id="footnote-reference-1">[1]</a>, we
also want the second derivatives of the two polynomials to be equal at P. The
lowest degree of polynomial that gives us this level of control is 3 (since the
second derivative of a quadratic polynomial is constant); hence cubic splines.</p>
<p>Here&#39;s a cubic spline interpolating between the three points of the original
example:</p>
<p><img alt="Three points on a 2D plot with cubic spline interpolation connecting them" src="https://eli.thegreenplace.net/images/2023/interp-cubic.png"/></p><p>And the <em>Sinc</em> function:</p>
<p><img alt="Sinc function with cubic spline interpolation connecting them" src="https://eli.thegreenplace.net/images/2023/interp-sinc-cubic.png"/></p><p>Because of the continuity of first and second derivatives, cubic splines look
very natural; on the other hand, since the degree of each polynomial remains
at most 3, they don&#39;t overfit too much. Hence they&#39;re such a popular tool for
interpolation and design/graphics.</p>
<p>All the plots in this post have been produced by <a href="https://github.com/eliben/code-for-blog/tree/master/2023/js-gauss-spline">JavaScript code</a>
that implements cubic spline interpolation from scratch. Let&#39;s move on to learn
how it works.</p>
</div>
<div id="setting-up-equations-for-cubic-spline-interpolation">
<h2>Setting up equations for cubic spline interpolation</h2>
<p>Given a set of N points, we want to produce N-1 cubic polynomials between these
points. While these are distinct polynomials, they are connected through mutual
constraints on the original points, as we&#39;ll see soon.</p>
<p>More formally, we&#39;re going to define N-1 polynomials in the inclusive range
:</p>
<p>For each polynomial, we have to find 4 coefficients: <em>a</em>, <em>b</em>, <em>c</em> and <em>d</em>;
in total, for N-1 polynomials we&#39;ll need 4N-4 coefficients. We&#39;re going to
find these coefficients by expressing the constraints we have as linear
equations, and then solving a system of linear equations. We&#39;ll need 4N-4
equations to ensure we can find a unique solution for 4N-4 unknowns.</p>
<p>Let&#39;s use our sample set of three original points to demonstrate how this
calculation works: (0, 1), (1, 3), (2, 2). Since N is 3, we&#39;ll be looking for
two polynomials and a total of 8 coefficients.</p>
<p>The first set of constraints is obvious - each polynomial has to pass through
the two points it&#39;s interpolating between. The first polynomial passes through
the points (0, 1) and (1, 3), so we can write the equations:</p>
<p>The second polynomial passes through the points (1, 3) and (2, 2), resulting
in the equations:</p>
<p>We have 4 equations, and need 4 more.</p>
<p>We constrain the first and second derivatives of the polynomials to be equal at
the points where they meet. In our example, there are only two polynomials that
meet at a single point, so we&#39;ll get two equations: their derivatives are equal
at point (1, 3).</p>
<p>Recall that the first and second derivatives of a cubic polynomial are:</p>
<p>The equation we get from equating the first derivatives is:</p>
<p>Or, expressed as a linear equation of all coefficients:</p>
<p>Similarly, the equation we get from equating the second derivatives is:</p>
<p>Expressed as a linear equation of all coefficients:</p>
<p>This brings us to a total of 6 equations. The last two equations will come from
<em>boundary conditions</em>. Notice that - so far - we didn&#39;t say much about how our
interpolating polynomials behave at the end points, except that they pass
through them. Boundary conditions are constraints we create to define how our
polynomials behave at these end points.
There are several approaches to this,
but here we&#39;ll just discuss the most commonly-used one: a <em>natural</em> spline.
Mathematically it says that the first polynomial has a second derivative of 0
at the first original point, and the last polynomial has a second derivative of
0 at the last original point. In our example:</p>
<p>Substituting the second derivative equations:</p>
<p>We have 8 equations now:</p>
<p>To restate the obvious - while our example only uses 2 polynomials, this
approach generalizes to any number. For N original points, we&#39;ll interpolate
with N-1 polynomials, resulting in 4N-4 coefficients. We&#39;ll get:</p>
<ul>
<li>2N-2 equations from setting the points these polynomials pass through</li>
<li>N-2 equations from equating first derivatives at internal points</li>
<li>N-2 equations from equating second derivatives at internal points</li>
<li>2 equations from boundary conditions</li>
</ul>
<p>For a total of 4N-4 equations.</p>
<p>The code that constructs these equations from a given set of points is available
<a href="https://github.com/eliben/code-for-blog/blob/master/2023/js-gauss-spline/spline.js">in this file</a>.</p>
</div>
<div id="solving-the-equations">
<h2>Solving the equations</h2>
<p>We now have 8 equations with 8 variables. Some of them are trivial, so it&#39;s
tempting to just solve the system by hand, and indeed one can do it very easily.
In the general case, however, it would be quite difficult - imagine
interpolating 10 polynomials resulting in 36 equations!</p>
<p>Fortunately, the full power of linear algebra is now at our disposal. We can
express this set of linear equations as a matrix multiplication problem
, where <em>A</em> is a matrix of coefficients, <em>x</em> is a vector of
unknowns and <em>b</em> is the vector of right-hand side constants:</p>
<p>Solving this system is straightforward using <a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elimination</a>.
<a href="https://github.com/eliben/code-for-blog/blob/master/2023/js-gauss-spline/eqsolve.js">Our JavaScript implementation</a>
does this in a few steps:</p>
<ul>
<li>Performs Gaussian elimination to bring <em>A</em> into row-echelon form, using the
<a href="https://en.wikipedia.org/wiki/Gaussian_elimination#Pseudocode">algorithm outlined on Wikipedia</a>. This
approach tries to preserve numerical stability by selecting the row with the
largest (in absolute value) value for each column <a href="#footnote-2" id="footnote-reference-2">[2]</a>.</li>
<li>Further transforms the resulting matrix into <em>reduced</em> row-echelon form
(a.k.a. Gauss-Jordan elimination)</li>
<li>Extracts the solution.</li>
</ul>
<p>In our example, the solution ends up being the vector (-0.75, 0, 2.75, 1, 0.75,
-4.5, 7.25, -0.5); therefore, the interpolating polynomials are:</p>
</div>
<div id="performing-the-interpolation-itself">
<h2>Performing the interpolation itself</h2>
<p>Now that we have the interpolating polynomials, we can generate any number of
interpolated points. For all <em>x</em> between 0 and 1 we use ,
and for <em>x</em> between 1 and 2 we use . In our JavaScript
code this is done by the <tt>doInterpolate</tt> function. We&#39;ve already seen
the result:</p>
<p><img alt="Three points on a 2D plot with cubic spline interpolation connecting them" src="https://eli.thegreenplace.net/images/2023/interp-cubic.png"/>
</p></div>
<div id="code">
<h2>Code</h2>
<p>The complete code sample for this post <a href="https://github.com/eliben/code-for-blog/tree/master/2023/js-gauss-spline">is available on GitHub</a>.
It includes functions for constructing equations for cubic splines from an
original set of points, code for solving linear equations with Gauss-Jordan
elimination, and a demo HTML page that plots the points and linear/spline
interpolations.</p>
<p>The code is readable, heavily-commented JavaScript with no dependencies (except
D3 for the plotting).</p>
<p>An additional demo that uses similar functionality is <a href="https://eliben.github.io/line-plotting/">line-plotting</a>; it plots arbitrary mathematical
functions with optional interpolation (when the number of sampled points is
low).</p>
<hr/>


</div>

            </div></div>
  </body>
</html>
