<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.phoenixframework.org/blog/phoenix-liveview-1.0-released?release=1.0">Original</a>
    <h1>Phoenix LiveView 1.0.0 is here</h1>
    
    <div id="readability-page-1" class="page"><div><p>
LiveView 1.0.0 is out!</p>
<p>
This 1.0 milestone comes six years after the first LiveView commit.</p>
<p>
  <img src="https://www.phoenixframework.org/images/blog/lv-1.0/commits.png" alt=""/>
</p>
<h2>
Why LiveView</h2>
<p>
I started LiveView to scratch an itch. I wanted to create dynamic server-rendered applications without writing JavaScript. I was tired of the inevitable ballooning complexity that it brings.</p>
<p>
Think realtime form validations, updating the quantity in a shopping cart, or real-time streaming updates. Why does it require moving mountains to solve in a traditional stack? We write the HTTP glue or GraphQL schemas  and resolvers, then we figure out which validation logic needs shared or dup’d. It goes on and on from there – how do we get localization information to the client? What data serializers do we need? How do we wire up WebSockets and IPC back to our code? Is our js bundle getting too large? I guess it’s time to start turning the Webpack or Parcel knobs. Wait Vite is a thing now? Or I guess Bun configuration is what we want? We’ve all felt this pain.</p>
<p>
The idea was, what if we removed these problems entirely? HTTP can go away, and the server can handle all the rendering and dynamic update concerns. It felt like a heavy approach, but I knew Elixir and Phoenix was perfectly suited for it.</p>
<p>
Six years later this programming model still feels like cheating.  Everything is super fast. Payloads are tiny. Latency is best-in-class. Not only do you write less code, there’s simply less to think about when writing features.</p>
<h2>
Real-time foundations unlock superpowers</h2>
<p>
Interesting things happen when you give every user and UI a real-time, bidirectional foundation as a matter of course. You suddenly have superpowers. You almost don’t notice it. Being freed from all the mundane concerns of typical full-stack development lets you focus on just shipping features. And with Elixir, you start shipping features that other platforms can’t even conceive as possible.</p>
<p>
Want to <a href="https://fly.io/phoenix-files/phoenix-dev-blog-server-logs-in-the-browser-console/">ship real-time server logs to the js console in development</a>? No problem!</p>
<video src="/images/blog/lv-1.0/server-logs.mp4" autoplay="autoplay" loop="loop" controls="controls" muted="muted">
</video>
<p>
What about supporting production hot code upgrades where browsers can auto re-render anytime CSS stylesheets, images, or templates change – without losing state or dropping connections? Sure!</p>
<video src="/images/blog/lv-1.0/hot-deploy.mp4" autoplay="autoplay" loop="loop" controls="controls" muted="muted">
</video>
<p>
Or maybe you have an app deployed planet-wide where you do work across the cluster and aggregate the results in real-time back to the UI. Would you believe the entire LiveView, including the template markup and RPC calls, is <a href="https://github.com/fly-apps/wps/blob/0cd4f4d46e873b3a0937fe230d26f5a195687ecf/lib/wps_web/live/page_speed_live.ex">350 LOC</a>?</p>
<video src="/images/blog/lv-1.0/what.mp4" controls="controls">
</video>
<p>
These are the kinds of applications that LiveView enables. It feels incredible to ship these kinds of things, but it took a while to arrive here for good reasons. There was a lot to solve to make this programming model truly great.</p>
<h2>
How it started</h2>
<p>
Conceptually, what I really wanted is something like what we do in React – change some state, our template re-renders automatically, and the UI updates. But instead of a bit of UI running on the client, what if we ran it on the server? The LiveView could look like this:</p>
<pre><code><span>defmodule</span><span> </span><span>ThermoLive</span><span> </span><span data-group-id="2588148176-1">do</span><span>
  </span><span>def</span><span> </span><span>render</span><span data-group-id="2588148176-2">(</span><span>assigns</span><span data-group-id="2588148176-2">)</span><span> </span><span data-group-id="2588148176-3">do</span><span>
    </span><span>~H&#34;&#34;&#34;</span><span>
    </span><span>&lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>&#34;</span><span>thermostat</span><span>&#34;</span><span>&gt;</span><span>
      </span><span>&lt;</span><span>p</span><span>&gt;</span><span>Temperature: </span><span data-group-id="7103186600-1">{</span><span>@thermostat</span><span>.</span><span>temperature</span><span data-group-id="7103186600-1">}</span><span>&lt;/</span><span>p</span><span>&gt;</span><span>
      </span><span>&lt;</span><span>p</span><span>&gt;</span><span>Mode: </span><span data-group-id="7103186600-2">{</span><span>@thermostat</span><span>.</span><span>mode</span><span data-group-id="7103186600-2">}</span><span>&lt;/</span><span>p</span><span>&gt;</span><span>
      </span><span>&lt;</span><span>button</span><span> </span><span>phx-click</span><span>=</span><span>&#34;</span><span>inc</span><span>&#34;</span><span>&gt;</span><span>+</span><span>&lt;/</span><span>button</span><span>&gt;</span><span>
      </span><span>&lt;</span><span>button</span><span> </span><span>phx-click</span><span>=</span><span>&#34;</span><span>dec</span><span>&#34;</span><span>&gt;</span><span>-</span><span>&lt;/</span><span>button</span><span>&gt;</span><span>
    </span><span>&lt;/</span><span>div</span><span>&gt;</span><span>
    </span><span>&#34;&#34;&#34;</span><span>
  </span><span data-group-id="2588148176-3">end</span><span>

  </span><span>def</span><span> </span><span>mount</span><span data-group-id="2588148176-4">(</span><span data-group-id="2588148176-5">%{</span><span>&#34;id&#34;</span><span> </span><span>=&gt;</span><span> </span><span>id</span><span data-group-id="2588148176-5">}</span><span>,</span><span> </span><span>_session</span><span>,</span><span> </span><span>socket</span><span data-group-id="2588148176-4">)</span><span> </span><span data-group-id="2588148176-6">do</span><span>
    </span><span>thermostat</span><span> </span><span>=</span><span> </span><span>ThermoControl</span><span>.</span><span>get_thermostat!</span><span data-group-id="2588148176-7">(</span><span>id</span><span data-group-id="2588148176-7">)</span><span>
    </span><span>:ok</span><span> </span><span>=</span><span> </span><span>ThermoControl</span><span>.</span><span>subscribe</span><span data-group-id="2588148176-8">(</span><span>thermostat</span><span data-group-id="2588148176-8">)</span><span>
    </span><span data-group-id="2588148176-9">{</span><span>:ok</span><span>,</span><span> </span><span>assign</span><span data-group-id="2588148176-10">(</span><span>socket</span><span>,</span><span> </span><span>thermostat</span><span>:</span><span> </span><span>thermostat</span><span data-group-id="2588148176-10">)</span><span data-group-id="2588148176-9">}</span><span>
  </span><span data-group-id="2588148176-6">end</span><span>

  </span><span>def</span><span> </span><span>handle_info</span><span data-group-id="2588148176-11">(</span><span data-group-id="2588148176-12">{</span><span>ThermoControl</span><span>,</span><span> </span><span data-group-id="2588148176-13">%</span><span data-group-id="2588148176-13">ThermoStat</span><span data-group-id="2588148176-13">{</span><span data-group-id="2588148176-13">}</span><span> </span><span>=</span><span> </span><span>new_thermo</span><span data-group-id="2588148176-12">}</span><span>,</span><span> </span><span>_</span><span>,</span><span> </span><span>socket</span><span data-group-id="2588148176-11">)</span><span> </span><span data-group-id="2588148176-14">do</span><span>
    </span><span data-group-id="2588148176-15">{</span><span>:noreply</span><span>,</span><span> </span><span>assign</span><span data-group-id="2588148176-16">(</span><span>socket</span><span>,</span><span> </span><span>thermostat</span><span>:</span><span> </span><span>new_thermo</span><span data-group-id="2588148176-16">)</span><span data-group-id="2588148176-15">}</span><span>
  </span><span data-group-id="2588148176-14">end</span><span>

  </span><span>def</span><span> </span><span>handle_event</span><span data-group-id="2588148176-17">(</span><span>&#34;inc&#34;</span><span>,</span><span> </span><span>_</span><span>,</span><span> </span><span>socket</span><span data-group-id="2588148176-17">)</span><span> </span><span data-group-id="2588148176-18">do</span><span>
    </span><span>thermostat</span><span> </span><span>=</span><span> </span><span>ThermoControl</span><span>.</span><span>inc</span><span data-group-id="2588148176-19">(</span><span>socket</span><span>.</span><span>assigns</span><span>.</span><span>thermostat</span><span data-group-id="2588148176-19">)</span><span>
    </span><span data-group-id="2588148176-20">{</span><span>:noreply</span><span>,</span><span> </span><span>assign</span><span data-group-id="2588148176-21">(</span><span>socket</span><span>,</span><span> </span><span>thermostat</span><span>:</span><span> </span><span>thermostat</span><span data-group-id="2588148176-21">)</span><span data-group-id="2588148176-20">}</span><span>
  </span><span data-group-id="2588148176-18">end</span><span>
</span><span data-group-id="2588148176-1">end</span></code></pre>
<p>
Like React, we have a render function and something that sets our initial state when the LiveView mounts. When state changes, we call render with the new state and the UI is updated.</p>
<p>
Interactions like <code>phx-click</code> on the <code>+</code> or <code>-</code> button, can be sent as RPC’s from client to server and the server can respond with fresh page HTML. These client/server messages use Phoenix Channels which <a href="https://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections">scale to millions of connections per server</a>.</p>
<p>
Likewise, if the server wants to send an update to the client, such as another user changing the thermostat, the client can listen for it and replace the page HTML in the same fashion. My naive first pass on the <code>phoenix_live_view.js</code> client looked something like this.</p>
<pre><code><span>let</span><span> </span><span>main</span><span> </span><span>=</span><span> </span><span>document</span><span>.</span><span>querySelector</span><span data-group-id="3081006925-1">(</span><span>&#34;[phx-main]&#34;</span><span data-group-id="3081006925-1">)</span><span>
</span><span>let</span><span> </span><span>channel</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>socket</span><span>.</span><span>channel</span><span data-group-id="3081006925-2">(</span><span>&#34;lv&#34;</span><span data-group-id="3081006925-2">)</span><span>
</span><span>channel</span><span>.</span><span>join</span><span data-group-id="3081006925-3">(</span><span data-group-id="3081006925-3">)</span><span>.</span><span>receive</span><span data-group-id="3081006925-4">(</span><span>&#34;ok&#34;</span><span>,</span><span> </span><span data-group-id="3081006925-5">(</span><span data-group-id="3081006925-6">{</span><span>html</span><span data-group-id="3081006925-6">}</span><span data-group-id="3081006925-5">)</span><span> </span><span>=&gt;</span><span> </span><span>main</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>html</span><span data-group-id="3081006925-4">)</span><span>
</span><span>channel</span><span>.</span><span>on</span><span data-group-id="3081006925-7">(</span><span>&#34;update&#34;</span><span>,</span><span> </span><span data-group-id="3081006925-8">(</span><span data-group-id="3081006925-9">{</span><span>html</span><span data-group-id="3081006925-9">}</span><span data-group-id="3081006925-8">)</span><span> </span><span>=&gt;</span><span> </span><span>main</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>html</span><span data-group-id="3081006925-7">)</span><span>

</span><span>window</span><span>.</span><span>addEventListener</span><span data-group-id="3081006925-10">(</span><span>&#34;click&#34;</span><span>,</span><span> </span><span>e</span><span> </span><span>=&gt;</span><span> </span><span data-group-id="3081006925-11">{</span><span>
  </span><span>let</span><span> </span><span>event</span><span> </span><span>=</span><span> </span><span>e</span><span>.</span><span>getAttribute</span><span data-group-id="3081006925-12">(</span><span>&#34;phx-click&#34;</span><span data-group-id="3081006925-12">)</span><span>
  </span><span>if</span><span data-group-id="3081006925-13">(</span><span>!</span><span>event</span><span data-group-id="3081006925-13">)</span><span data-group-id="3081006925-14">{</span><span> </span><span>return</span><span> </span><span data-group-id="3081006925-14">}</span><span>
  </span><span>channel</span><span>.</span><span>push</span><span data-group-id="3081006925-15">(</span><span>&#34;event&#34;</span><span>,</span><span> </span><span data-group-id="3081006925-16">{</span><span>event</span><span data-group-id="3081006925-16">}</span><span data-group-id="3081006925-15">)</span><span>.</span><span>receive</span><span data-group-id="3081006925-17">(</span><span>&#34;ok&#34;</span><span>,</span><span> </span><span data-group-id="3081006925-18">(</span><span data-group-id="3081006925-19">{</span><span>html</span><span data-group-id="3081006925-19">}</span><span data-group-id="3081006925-18">)</span><span> </span><span>=&gt;</span><span> </span><span>main</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>html</span><span data-group-id="3081006925-17">)</span><span>
</span><span data-group-id="3081006925-11">}</span><span data-group-id="3081006925-10">)</span></code></pre>
<p>
This is how LiveView started. We went to the server for interactions, re-rendered the entire template on state change, and sent the entire page down to the client. The client then swapped out the inner HTML.</p>
<p>
It worked, but it was not great. Partial state changes required re-executing the entire template and sending down gobs of HTML for otherwise tiny updates.</p>
<p>
Still the basic programming model was exactly what I wanted. As HTTP fell away from my concerns, entire layers of full-stack considerations disappeared.</p>
<p>
Next the challenge was making this something truly great. Little did we know we’d accidentally our way to outperforming many SPA use-cases along the way.</p>
<h2>
How we optimized the programming model</h2>
<p>
LiveView’s diffing engine solved two problems with a single mechanism. The first problem was only executing those dynamic parts of a template that actually changed from a previous render. The second was only sending the minimal data necessary to update the client.</p>
<p>
It solves both by splitting the template into static and dynamic parts. Considering the following LiveView template:</p>
<pre><code><span>~H&#34;&#34;&#34;</span><span>
</span><span>&lt;</span><span>p</span><span> </span><span>class</span><span>=</span><span data-group-id="3060953488-1">{</span><span>@mode</span><span data-group-id="3060953488-1">}</span><span>&gt;</span><span>Temperature: </span><span data-group-id="3060953488-2">{</span><span>format_unit</span><span data-group-id="9068738118-1">(</span><span>@temperature</span><span data-group-id="9068738118-1">)</span><span data-group-id="3060953488-2">}</span><span>&lt;/</span><span>p</span><span>&gt;</span><span>
</span><span>&#34;&#34;&#34;</span></code></pre>
<p>
At compile time, we convert the template into a struct like this:</p>
<pre><code><span data-group-id="4442233026-1">%</span><span data-group-id="4442233026-1">Phoenix.LiveView.Rendered</span><span data-group-id="4442233026-1">{</span><span>
  </span><span>static</span><span>:</span><span> </span><span data-group-id="4442233026-2">[</span><span>&#34;&lt;p class=</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>\</span><span>&#34;&gt;Temperature:&#34;</span><span>,</span><span> </span><span>&#34;&lt;/p&gt;&#34;</span><span data-group-id="4442233026-2">]</span><span>
  </span><span>dynamic</span><span>:</span><span> </span><span data-group-id="4442233026-3">fn</span><span> </span><span>assigns</span><span> </span><span>-&gt;</span><span>
    </span><span data-group-id="4442233026-4">[</span><span>
      </span><span>if</span><span> </span><span>changed?</span><span data-group-id="4442233026-5">(</span><span>assigns</span><span>,</span><span> </span><span>:mode</span><span data-group-id="4442233026-5">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>assigns</span><span>.</span><span>mode</span><span>,</span><span>
      </span><span>if</span><span> </span><span>changed?</span><span data-group-id="4442233026-6">(</span><span>assigns</span><span>,</span><span> </span><span>:temperature</span><span data-group-id="4442233026-6">)</span><span>,</span><span> </span><span>do</span><span>:</span><span> </span><span>format_unit</span><span data-group-id="4442233026-7">(</span><span>assigns</span><span>.</span><span>temperature</span><span data-group-id="4442233026-7">)</span><span>
    </span><span data-group-id="4442233026-4">]</span><span>
  </span><span data-group-id="4442233026-3">end</span><span>
</span><span data-group-id="4442233026-1">}</span></code></pre>
<p>
We know the static parts never change, so they are split from the dynamic Elixir expressions. Next, we compile each expression with change tracking based on the variables accessed within each expression. On render, we compare the previous template values with the new and only execute the template expression if the value has changed.</p>
<p>
Instead of sending the entire template down on change, we can send the client all the static and dynamic parts on <code>mount</code>. After mount  we only send the partial diff of dynamic values for each update.</p>
<p>
To see how this works, we can imagine the following payload being sent on <code>mount</code> for the template above:</p>
<pre><code><span data-group-id="0732066450-1">{</span><span>
  </span><span>s</span><span>:</span><span> </span><span data-group-id="0732066450-2">[</span><span>&#34;&lt;p class=</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>&#34;&gt;Temperature: &#34;</span><span>,</span><span> </span><span>&#34;&lt;/p&gt;&#34;</span><span data-group-id="0732066450-2">]</span><span>,</span><span>
  </span><span>0</span><span>:</span><span> </span><span>&#34;cooling&#34;</span><span>,</span><span>
  </span><span>1</span><span>:</span><span> </span><span>&#34;68℉&#34;</span><span>
</span><span data-group-id="0732066450-1">}</span></code></pre>
<p>
The client receives a map of static values in the <code>s</code> key, and dynamic values keyed by their index in the statics. For the client to render the full template string, it only needs to zips the static list with the dynamic values. For example:</p>
<pre><code><span data-group-id="4665559507-1">[</span><span>&#34;&lt;p class=</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>&#34;cooling&#34;</span><span>,</span><span> </span><span>&#34;</span><span>\&#34;</span><span>&gt;Temperature: &#34;</span><span>,</span><span> </span><span>&#34;68℉&#34;</span><span>,</span><span> </span><span>&#34;&lt;/p&gt;&#34;</span><span data-group-id="4665559507-1">]</span><span>.</span><span>join</span><span data-group-id="4665559507-2">(</span><span>&#34;&#34;</span><span data-group-id="4665559507-2">)</span><span>
</span><span>&#34;&lt;p class=</span><span>\&#34;</span><span>cooling</span><span>\&#34;</span><span>&gt;Temperature: 68℉&lt;/p&gt;&#34;</span></code></pre>
<p>
With the client holding a static/dynamic cache, optimizing network updates is no work at all. Any server render following <code>mount</code>  simply returns the new dynamic values at their known index. Unchanged dynamic values and statics are ignored entirely.</p>
<p>
If a LiveView runs <code>assign(socket, :temperature, 70)</code>, the <code>render/1</code> function is invoked, and the following payload gets sent down the wire:</p>
<pre><code><span data-group-id="7408994240-1">{</span><span>1</span><span>:</span><span> </span><span>&#34;70℉&#34;</span><span data-group-id="7408994240-1">}</span></code></pre>
<p>
Thats it! To update the UI, the client simply merges this object with its static/dynamic cache:</p>
<pre><code><span data-group-id="8352654252-1">{</span><span>                     </span><span data-group-id="8352654252-2">{</span><span>
                        </span><span>s</span><span>:</span><span> </span><span data-group-id="8352654252-3">[</span><span>&#34;&lt;p class=</span><span>\&#34;</span><span>&#34;</span><span>,</span><span> </span><span>&#34;&gt;Temperature: &#34;</span><span>,</span><span> </span><span>&#34;&lt;/p&gt;&#34;</span><span data-group-id="8352654252-3">]</span><span>,</span><span>
                        </span><span>0</span><span>:</span><span> </span><span>&#34;cooling&#34;</span><span>,</span><span>
  </span><span>1</span><span>:</span><span> </span><span>&#34;70F&#34;</span><span>     </span><span>=&gt;</span><span>       </span><span>1</span><span>:</span><span> </span><span>&#34;70℉&#34;</span><span>
</span><span data-group-id="8352654252-2">}</span><span>                     </span><span data-group-id="8352654252-1">}</span></code></pre>
<p>
Then the data is zipped together on the client to produce the full HTML of the UI.</p>
<p>
Of course <code>innerHTML</code> updates blow away UI state and are expensive to perform. So like any client-side framework, we compute minimal DOM diffs to efficiently update the DOM. In fact, we’ve had folks migrate from React to Phoenix LiveView because <a href="https://podcast.thinkingelixir.com/156">LiveView client rendering was faster what their React app could offer</a>.</p>
<p>
Optimizations continued from there. Including fingerprinting, for comprehensions, tree sharing, and more. You can <a href="https://dashbit.co/blog/latency-rendering-liveview">read all about each optimization</a> on the Dashbit blog.</p>
<p>
We apply these optimizations <em>automatically and for free</em> thanks to our stateful client and server connection. Most other server rendered HTML solutions send the whole fragment on every update or require users to fine tune updates by hand.</p>
<h2>
Best in class latency</h2>
<p>
We’ve seen how LiveView payloads are smaller than the best hand-written JSON API or GraphQL query, but it’s even better than that. Every LiveView holds a connection to the server so page navigation happens via live navigation. TLS handshakes, current user auth, etc happen a <em>single time</em> for the lifetime of the user’s visit. This allows page navigation to happen via a single WebSocket frame, and fewer database queries for any client action. The result is fewer round trips from the client, and simply less work done by the server. This provides less latency for the end-user compared to an SPA fetching data or sending mutations up to a server.</p>
<p>
Holding a stateful connections comes at the cost of server memory, but it’s far cheaper than folks expect. At a baseline, a given channel connection consumes 40kb of memory. This gives a 1GB server a theoretical ceiling of ~25,000 concurrent LiveViews. Of course the more state you store, the more memory you consume, but you only hold onto the state you need. We also have <code>stream</code> primitives for handling large collections without impacting memory. Elixir and the Erlang VM were designed for this. Scaling a stateful system to millions of concurrent users isn’t theoretical – we do it all the time. See WhatsApp, Discord, or <a href="https://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections">our own benchmarks</a> as examples.</p>
<p>
With the programming model optimized on both client and server, we expanded into higher level building blocks that take advantage of our unique diffing engine.</p>
<h2>
Reusable Components with HEEx</h2>
<p>
Change tracking and minimal diffs were ground-breaking features, but our HTML templates still lacked composability. The best we could offer is “partial”-like template rendering where a function could encapsulate some partial template content. This works, but it composes poorly and is mismatched in the way we write markup. Fortunately Marlus Saraiva from the <a href="https://surface-ui.org/">Surface project</a> spearheaded development of an HTML-aware component system and contributed back to the LiveView project. With HEEx components, we have a declarative component system, HTML validation, and  compile-time checking of component attributes and slots.</p>
<p>
HEEx components are just annotated functions. They look like this:</p>
<pre><code><span>@doc</span><span> </span><span>&#34;&#34;&#34;
Renders a button.

## Examples

    &lt;.button&gt;Send!&lt;/.button&gt;
    &lt;.button phx-click=&#34;go&#34;&gt;Send!&lt;/.button&gt;
&#34;&#34;&#34;</span><span>
</span><span>attr</span><span> </span><span>:type</span><span>,</span><span> </span><span>:string</span><span>,</span><span> </span><span>default</span><span>:</span><span> </span><span>nil</span><span>
</span><span>attr</span><span> </span><span>:rest</span><span>,</span><span> </span><span>:global</span><span>,</span><span> </span><span>include</span><span>:</span><span> </span><span>~w(disabled form name value)</span><span>

</span><span>slot</span><span> </span><span>:inner_block</span><span>,</span><span> </span><span>required</span><span>:</span><span> </span><span>true</span><span>

</span><span>def</span><span> </span><span>button</span><span data-group-id="5635279201-1">(</span><span>assigns</span><span data-group-id="5635279201-1">)</span><span> </span><span data-group-id="5635279201-2">do</span><span>
  </span><span>~H&#34;&#34;&#34;</span><span>
  </span><span>&lt;</span><span>button</span><span>
    </span><span>type</span><span>=</span><span data-group-id="4932554850-1">{</span><span>@type</span><span data-group-id="4932554850-1">}</span><span>
</span><span>    </span><span>class</span><span>=</span><span>&#34;</span><span>rounded-lg bg-zinc-900 hover:bg-zinc-700 py-2 px-3 text-white</span><span>&#34;</span><span>
    </span><span data-group-id="4932554850-2">{</span><span>@rest</span><span data-group-id="4932554850-2">}</span><span>
  </span><span>&gt;</span><span>
    </span><span data-group-id="4932554850-3">{</span><span>render_slot</span><span data-group-id="5635279201-3">(</span><span>@inner_block</span><span data-group-id="5635279201-3">)</span><span data-group-id="4932554850-3">}</span><span>
  </span><span>&lt;/</span><span>button</span><span>&gt;</span><span>
  </span><span>&#34;&#34;&#34;</span><span>
</span><span data-group-id="5635279201-2">end</span></code></pre>
<p>
An invalid call to a component, such as <code>&lt;.button click=&#34;bad&#34;&gt;</code> produces a compile-time warning:</p>
<pre><code>warning: undefined attribute &#34;click&#34; for component AppWeb.CoreComponents.button/1
  lib/app_web/live/page_live.ex:123: (file)</code></pre>
<p>
Slots allows the component to accept arbitrary content from a caller. This allows components to be much more extensible by the caller without creating a bunch of bespoke partial templates to handle every scenario.</p>
<h2>
Streamlined HEEx syntax</h2>
<p>
When we introduced HEEx and function components, we added a new syntax for interpolating values within tag attributes along with <code>:if</code> and <code>:for</code> conveniences for conditionally generating templates. It looked like this:</p>
<pre><code><span>&lt;</span><span>div</span><span> </span><span>:if</span><span>=</span><span data-group-id="3259069850-1">{</span><span>@some_condition?</span><span data-group-id="3259069850-1">}</span><span>&gt;</span><span>
  </span><span>&lt;</span><span>ul</span><span>&gt;</span><span>
    </span><span>&lt;</span><span>li</span><span> </span><span>:for</span><span>=</span><span data-group-id="3259069850-2">{</span><span>val</span><span> </span><span>&lt;-</span><span> </span><span>@values</span><span data-group-id="3259069850-2">}</span><span>&gt;</span><span>Value </span><span data-group-id="3259069850-3">&lt;%=</span><span> </span><span>val</span><span> </span><span data-group-id="3259069850-3">%&gt;</span><span>&lt;/</span><span>li</span><span>&gt;</span><span>
  </span><span>&lt;/</span><span>ul</span><span>&gt;</span><span>
</span><span>&lt;/</span><span>div</span><span>&gt;</span></code></pre>
<p>
Note the use of standard EEx <code>&lt;%= %&gt;</code> interpolation. With the release of LiveView 1.0, we are extending the HTML-aware <code>{}</code> attribute interpolation syntax to within tag bodies as well. This means you can now interpolate values directly within the tag body in a streamlined syntax:</p>
<pre><code><span>&lt;</span><span>div</span><span> </span><span>:if</span><span>=</span><span data-group-id="6635342574-1">{</span><span>@some_condition?</span><span data-group-id="6635342574-1">}</span><span>&gt;</span><span>
  </span><span>&lt;</span><span>ul</span><span>&gt;</span><span>
    </span><span>&lt;</span><span>li</span><span> </span><span>:for</span><span>=</span><span data-group-id="6635342574-2">{</span><span>val</span><span> </span><span>&lt;-</span><span> </span><span>@values</span><span data-group-id="6635342574-2">}</span><span>&gt;</span><span>Value </span><span data-group-id="6635342574-3">{</span><span>val</span><span data-group-id="6635342574-3">}</span><span>&lt;/</span><span>li</span><span>&gt;</span><span>
  </span><span>&lt;/</span><span>ul</span><span>&gt;</span><span>
</span><span>&lt;/</span><span>div</span><span>&gt;</span></code></pre>
<p>
The EEx <code>&lt;%= %&gt;</code> remains supported and is required for generating dynamic blocks of distinct markup, as well as for interpolating values within <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags.</p>
<h2>
HEEx markup annotations</h2>
<p>
Gone are the days of examining your browser’s HTML and then hunting for where that HTML was generated within your code. The final browser markup can be rendered  within several nested layers of component calls. How do we quickly trace back who rendered what?</p>
<p>
HEEx solves this with a <code>debug_heex_annotations</code> configuration. When set, all rendered markup will be annotated with the file:line of the function component definition, <em>as well as,</em> the file:line of the caller invocation of the component. In practice your dev HTML will look like this in the browser inspector:</p>
<p>
  <img src="https://www.phoenixframework.org/images/blog/lv-1.0/heex-anno.png" alt="Debug HEEx annotations"/>
</p>
<p>
It annotates the document both at the caller site and the function component definition. If you find the above hard to navigate, you can use the new <code>Phoenix.LiveReloader</code> features that have your editor jump to an element’s nearest caller or definition file:line when clicked with a special key sequence of your choosing.</p>
<p>
Let’s see it in action:</p>
<video src="/images/blog/lv-1.0/keydebug.mp4" autoplay="autoplay" loop="loop" controls="controls" muted="muted">
</video>
<p>
First, we can see how holding <code>c</code> while clicking jumped to the caller file:Line location for that <code>&lt;.button&gt;</code> invocation. Next, we see that holding <code>d</code> while clicking the button jumped to the function definition file:line.</p>
<p>
This is such a simple quality of life improvement. It will become a key part of your workflow as soon as you try it out.</p>
<h2>
Interactive Uploads</h2>
<p>
A few years ago, LiveView tackled the file upload problem. Something that should be easy has historically been unnecessarily difficult. We wanted a single abstraction for interactive uploads for both direct to cloud, and direct to server use-cases.</p>
<p>
With a few lines of server code you can have file uploads with drag and drop, file progress, selection pruning, file previews, and more.</p>
<p>
More recently, we defined an <code>UploadWriter</code> behavior. This gives you access to the raw upload stream as it’s being chunked by the client. This lets you do things like <a href="https://fly.io/phoenix-files/streaming-uploads-with-liveview/">stream uploads to a different server</a> or <a href="https://youtu.be/GICJ42OyBGg?si=8SaAL2Sh74qsFaI3&amp;t=1930">transcode a video as it’s being uploaded</a>.</p>
<p>
Since the uploads happen over the existing LiveView connection, reflecting the upload progress or advanced file operations <a href="https://github.com/fly-apps/thumbnail_generator/blob/ce7e2ede394eed3b2a1b1aa5e41d323643950f5e/lib/thumbs_web/live/home_live.ex">become trivial to implement</a>:</p>
<video src="/images/blog/lv-1.0/puppy.mp4" autoplay="autoplay" loop="loop" controls="controls">
</video>
<h2>
Streams and Async</h2>
<p>
Following uploads, we shipped a streams primitive for efficiently handling large collections without needing to hold those collections in server memory. We also introduced <code>assign_async</code> and <code>start_async</code> primitives, which makes handling async operations and rendering async results a breeze.</p>
<p>
For example, imagine you have an expensive operation that calls out to an external service. The results can be latent or spotty, or both.  Your LiveView can use <code>assign_async/2</code> to offload this operation to a new process and <code>&lt;.async_result&gt;</code> to render the results with each loading, success, or failure state.</p>
<pre><code><span>def</span><span> </span><span>render</span><span data-group-id="4891046976-1">(</span><span>assigns</span><span data-group-id="4891046976-1">)</span><span> </span><span data-group-id="4891046976-2">do</span><span>
  </span><span>~H&#34;&#34;&#34;</span><span>
  </span><span>&lt;</span><span>.async_result</span><span> </span><span>:let</span><span>=</span><span data-group-id="3242930733-1">{</span><span>org</span><span data-group-id="3242930733-1">}</span><span> </span><span>assign</span><span>=</span><span data-group-id="3242930733-2">{</span><span>@org</span><span data-group-id="3242930733-2">}</span><span>&gt;</span><span>
    </span><span>&lt;</span><span>:loading</span><span>&gt;</span><span>Loading organization </span><span>&lt;</span><span>.spinner</span><span> </span><span>/&gt;</span><span>&lt;/</span><span>:loading</span><span>&gt;</span><span>
    </span><span>&lt;</span><span>:failed</span><span> </span><span>:let</span><span>=</span><span data-group-id="3242930733-3">{</span><span>_failure</span><span data-group-id="3242930733-3">}</span><span>&gt;</span><span>there was an error loading the organization</span><span>&lt;/</span><span>:failed</span><span>&gt;</span><span>
    </span><span data-group-id="3242930733-4">{</span><span>org</span><span>.</span><span>name</span><span data-group-id="3242930733-4">}</span><span>
  </span><span>&lt;/</span><span>.async_result</span><span>&gt;</span><span>
  </span><span>&#34;&#34;&#34;</span><span>
</span><span data-group-id="4891046976-2">end</span><span>

</span><span>def</span><span> </span><span>mount</span><span data-group-id="4891046976-3">(</span><span data-group-id="4891046976-4">%{</span><span>&#34;slug&#34;</span><span> </span><span>=&gt;</span><span> </span><span>slug</span><span data-group-id="4891046976-4">}</span><span>,</span><span> </span><span>_</span><span>,</span><span> </span><span>socket</span><span data-group-id="4891046976-3">)</span><span> </span><span data-group-id="4891046976-5">do</span><span>
  </span><span data-group-id="4891046976-6">{</span><span>:ok</span><span>,</span><span> </span><span>assign_async</span><span data-group-id="4891046976-7">(</span><span>:org</span><span>,</span><span> </span><span data-group-id="4891046976-8">fn</span><span> </span><span>-&gt;</span><span> </span><span data-group-id="4891046976-9">{</span><span>:ok</span><span>,</span><span> </span><span data-group-id="4891046976-10">%{</span><span>org</span><span>:</span><span> </span><span>fetch_org</span><span data-group-id="4891046976-11">(</span><span>slug</span><span data-group-id="4891046976-11">)</span><span data-group-id="4891046976-10">}</span><span data-group-id="4891046976-9">}</span><span> </span><span data-group-id="4891046976-8">end</span><span data-group-id="4891046976-7">)</span><span data-group-id="4891046976-6">}</span><span>
</span><span data-group-id="4891046976-5">end</span></code></pre>
<p>
Now instead of worrying about an async task crashing the UI, or carefully monitoring async ops while updating the template with a bunch of conditionals, you have a single abstraction for performing the work and rendering the results. As soon as the LiveView disconnects, the async processes are cleaned up, ensuring no wasted resources go to a UI that is no longer around.</p>
<p>
Here we can also see slots in action with the <code>&lt;:loading&gt;</code> and <code>&lt;:failed&gt;</code> slots of the  <code>&lt;.async_result&gt;</code> function component. Slots allow the caller to extend components with their own dynamic content, including their own markup and function component calls.</p>
<h2>
LiveView goes mainstream</h2>
<p>
LiveView and <a href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor">.NET Blazor</a> both started about the same time. I like to think both projects helped spearhead the adoption of this programming model.</p>
<p>
Since getting started, this model has been embraced in various ways in the Go, Rust, Java, PHP, JavaScript, Ruby, and Haskell communities. And I’m sure others I haven’t yet heard of.</p>
<p>
Most don’t offer LiveView’s declarative model. Instead developers are required to annotate how individual elements are updated and removed, leading to fragile applications, akin to client-side applications before the introduction of React and other declarative frameworks. Most also lack the optimizations LiveView developers get for free. Large payloads are sent on every event unless developers manually fine tune them.</p>
<p>
React itself liked the idea of putting React on the server so much, they shipped their own <a href="https://react.dev/reference/rsc/server-components">React Server Components</a> to tackle a cross section of similar goals with LiveView. In the case of RSC, pushing real-time events are left to external means.</p>
<p>
React, like most, chose different tradeoffs because <em>they had no choice</em>. The majority skip the stateful, bidirectional communication layer because most platforms are poorly suited for it. Elixir and the Erlang VM are truly what make this programming model shine. And we have only barely discussed our built-in globally distributed clustering and PubSub. There are truly extraordinary features built into the platform that are at your fingertips.</p>
<h2>
Try it out</h2>
<p>
Now is a great time to dive in and give LiveView a try! We have launched <code>new.phoenixframework.org</code> which lets you get up and running in seconds with Elixir and your first Phoenix project with a single command:</p>
<p>
For osx/linux:</p>
<pre><code>$ curl https://new.phoenixframework.org/myapp | sh</code></pre>
<p>
For Windows PowerShell:</p>
<pre><code>&gt; curl.exe -fsSO https://new.phoenixframework.org/app.bat; .\app.bat</code></pre>
<p>
For existing applications, check the <a href="https://github.com/phoenixframework/phoenix_live_view/blob/main/CHANGELOG.md">changelog</a> for breaking changes to bring your existing apps up to speed.</p>
<h2>
What’s Next</h2>
<p>
Following this release, we’ll be continuing efforts around collocated JavaScript hooks, enhancing Web Component integration, supporting navigation guards, and more as outlined in our issue tracker.</p>
<h2>
Special Thanks</h2>
<p>
Arriving here wouldn’t have been possible without the help of the Phoenix team, especially Steffen Deusch, who has tackled countless LiveView issues over the last year.</p>
<p>
Happy Hacking!</p>
<p>
–Chris</p>
</div></div>
  </body>
</html>
