<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rabbitictranslator.com/contribute-to-kde-without-cpp/">Original</a>
    <h1>You can contribute to KDE with non-C&#43;&#43; code</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Not everything made by KDE uses C++. This is probably obvious to some people, but it’s worth mentioning nevertheless.</p>
<p>And I don’t mean this as just “well duh, KDE uses QtQuick which is written with C++ <em>and QML</em>”. I also don’t mean this as “well duh, Qt has a lot of bindings to other languages”. I mean explicitly “KDE has tools written <em>primarily</em> in certain languages and specialized formats”.</p>
<p>Note that I said “specialized formats”. I don’t <em>want</em> to restrict this blog post to only programming languages.</p>
<p>I’ll be straight to the point. You can contribute to KDE with:</p>
<ul>
<li><a href="#python">Python</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#perl">Perl</a></li>
<li><a href="#containers">Containerfile / Docker / Podman</a></li>
<li><a href="#websites">HTML / SCSS / JavaScript</a></li>
<li><a href="#wasm">Web Assembly</a></li>
<li><a href="#flatpak-snap">Flatpak / Snap</a></li>
<li><a href="#cmake">CMake</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#rust">Rust</a></li>
</ul>
<p>Here’s how.</p>
<h2 id="how-to-find-projects-by-language">How to find projects by language</h2>
<p>You’ll need to <a href="https://community.kde.org/Infrastructure/GitLab">create an account</a> on <a href="https://invent.kde.org/">KDE Invent</a>. After logging in, you can click on the “Explore projects” button in the corner and click on the huge search field in the middle of the screen: it will list the option “Language”.</p>
<p>Click on it and you’ll be prompted with a select list of languages used at KDE. Then press Enter.</p>
<h2 id="python">Python</h2>
<p>While it is possible to use Kirigami with Python (either PyQt or PySide) and <a href="https://develop.kde.org/docs/getting-started/python/">we have a tutorial for that</a>, it is not as useful as can be: we don’t current have bindings for KDE Frameworks to be used in Python code. It’s planned, though.</p>
<p>No, the cool tool we use everywhere is <a href="https://develop.kde.org/docs/apps/tests/">Appium tests</a>. These are automated tests done to GUI applications by interacting directly with them as though the tests were done by a human, that is to say, by clicking on GUI elements and by typing on text fields automatically.</p>
<p>In recent years KDE has implemented Appium tests in a lot of KDE software as part of the <a href="https://community.kde.org/Goals/Automate_and_systematize_internal_processes">Automatization Goal</a>. To achieve this, KDE made a <a href="https://invent.kde.org/sdk/selenium-webdriver-at-spi">Selenium Webdriver</a> that leverages the de facto accessibility standard on Linux, <a href="https://www.freedesktop.org/wiki/Accessibility/AT-SPI2/">AT-SPI2</a>. If a KDE project that has a GUI doesn’t yet have Appium tests, go for it. By the way, the webdriver also has a few Python scripts!</p>
<p>We do have a few projects that are written in C++ but make heavy use of Python, like <a href="https://invent.kde.org/kdevelop/kdevelop">KDevelop</a>, <a href="https://invent.kde.org/multimedia/kdenlive/-/tree/master/data/scripts">Kdenlive</a>, <a href="https://invent.kde.org/sdk/lokalize/-/tree/master/scripts">Lokalize</a> and <a href="https://invent.kde.org/pim/ktimetracker/-/tree/master/test">KTimeTracker</a>.</p>
<p><a href="https://invent.kde.org/kdevelop/kdev-python">KDevelop’s plugin for Python</a> especially has been in maintenance for years now! It would be great if it could be revived so people would use KDE’s IDE more.</p>
<p>Another cool project to contribute to is <a href="https://invent.kde.org/sdk/kde-builder">kde-builder</a>, the replacement to our main <a href="#perl">Perl-written</a> development tool <a href="https://develop.kde.org/docs/getting-started/building/kdesrc-build-setup/">kdesrc-build</a>.</p>
<p>One that we sorely need for generating our QML API is <a href="https://invent.kde.org/sdk/doxyqml">Doxyqml</a>, which uses <a href="https://www.doxygen.nl/">Doxygen</a> under the hood.</p>
<p>And another project that’s intimately related to Linux translations, <a href="https://invent.kde.org/sdk/pology">pology</a>, which is a collection of tools for processing <a href="https://www.gnu.org/software/gettext/">PO files</a>. It’s used in Lokalize.</p>
<p><a href="https://invent.kde.org/packaging/craft">Craft</a> is a tool that lets you build, install, and package software for Windows, MacOS, Android and Linux. It’s pretty cool, like kdesrc-build but without requiring to build everything yourself (you can install the latest cached prebuilt package instead). It has <a href="https://community.kde.org/Craft">documentation</a> in the Community wiki.</p>
<p>It works by writing straightforward recipes that are used to build KDE software, named <a href="https://invent.kde.org/packaging/craft-blueprints-kde">Craft Blueprints</a>, that let you set a program’s dependencies, metadata, or how it’s going to be packaged. It’s a full blown solution that is used even outside KDE. It has <a href="https://community.kde.org/Craft/Blueprints">documentation</a> in the Community wiki as well. There are dozens of blueprints you can help with!</p>
<p>Python is also used for KDE websites and systems administration.</p>
<p>Some of <a href="https://invent.kde.org/websites">our websites</a> that use <a href="#hugo">Hugo</a> have a file called <code>custom_generation.py</code> that is used to write the specifics of how to deploy a website with the KDE CI in case a project needs something special.</p>
<p>A simple example is used by <a href="https://invent.kde.org/websites/kate-editor-org/-/blob/master/scripts/custom_generation.py">Kate</a>, but a more complex case is the <a href="https://invent.kde.org/documentation/develop-kde-org/-/tree/master/scripts">KDE Developer Website</a>.</p>
<p>The <a href="https://community.kde.org/Infrastructure/Continuous_Integration_System">KDE Gitlab CI infrastructure</a> uses a lot of Python. You can see that especially with <a href="https://invent.kde.org/sysadmin/ci-utilities">ci-utilities</a>, which uses several Python scripts to automate tasks in its Gitlab templates.</p>
<p>Another sysadmin Python project that you can contribute to is the <a href="https://invent.kde.org/sysadmin/ci-notary-service">CI Notary Service</a>, used to sign packages for deployment, like Windows, MacOS or Flatpak. Naturally, this requires some platform-specific knowledge.</p>
<p>There are many other projects where you can contribute with Python, and it’s most definitely the top used language in KDE other than C++, QML and CMake.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://develop.kde.org/docs/apps/tests/">Appium tests</a></li>
<li><a href="https://invent.kde.org/sdk/selenium-webdriver-at-spi">Selenium Webdriver</a></li>
<li>apps like <a href="https://invent.kde.org/kdevelop/kdevelop">KDevelop</a> / <a href="https://invent.kde.org/kdevelop/kdev-python">KDevelop’s plugin for Python</a> / <a href="https://invent.kde.org/multimedia/kdenlive/-/tree/master/data/scripts">Kdenlive</a> / <a href="https://invent.kde.org/sdk/lokalize/-/tree/master/scripts">Lokalize</a> / <a href="https://invent.kde.org/pim/ktimetracker/-/tree/master/test">KTimeTracker</a></li>
<li><a href="https://invent.kde.org/sdk/kde-builder">kde-builder</a></li>
<li><a href="https://invent.kde.org/sdk/doxyqml">Doxyqml</a></li>
<li><a href="https://invent.kde.org/sdk/pology">pology</a></li>
<li><a href="https://invent.kde.org/packaging/craft">Craft</a></li>
<li><a href="https://invent.kde.org/packaging/craft-blueprints-kde">Craft Blueprints</a></li>
<li><a href="https://invent.kde.org/websites">KDE websites</a></li>
<li><a href="https://invent.kde.org/sysadmin/ci-utilities">ci-utilities</a></li>
<li><a href="https://invent.kde.org/sysadmin/ci-notary-service">CI Notary Service</a></li>
</ul>
<p>My personal recommendations are:</p>
<ul>
<li><a href="https://invent.kde.org/sdk/doxyqml">Doxyqml</a>: we sorely need to improve our QML API generation!</li>
<li><a href="https://invent.kde.org/packaging/craft-blueprints-kde">Craft Blueprints</a>: the sheer quantity of them!</li>
<li><a href="https://develop.kde.org/docs/apps/tests/">Appium tests</a>: we need to make sure all our software is tested and working!</li>
<li><a href="https://invent.kde.org/websites">KDE websites</a></li>
<li><a href="https://invent.kde.org/sdk/pology">pology</a>: we have barely any experts on GNU gettext and Python!</li>
<li><a href="https://invent.kde.org/sdk/selenium-webdriver-at-spi">Selenium Webdriver</a></li>
<li><a href="https://invent.kde.org/kdevelop/kdev-python">KDevelop’s plugin for Python</a></li>
</ul>
<p>You should also take a look at this Akademy 2024 talk when it comes out:</p>
<ul>
<li><a href="https://conf.kde.org/event/6/contributions/208/">Pythonizing Qt</a>, by PySide’s main Qt developer Cristián Maureira-Fredes</li>
</ul>
<h2 id="ruby">Ruby</h2>
<p>We use Ruby mainly for two things: Jekyll-based websites and some specialized tools.</p>
<p>Jekyll is a tool written in Ruby to create static websites, so we don’t really need much help with its Ruby code. If you do have experience with Jekyll though, you can take a look at the <a href="https://community.kde.org/KDE.org/Jekyll">KDE Jekyll Website guide</a> and <a href="https://invent.kde.org/websites/jekyll-kde-theme">KDE’s Aether Theme for Jekyll</a> and search for some websites yourself.</p>
<p>Now the interesting part is the specialized tools.</p>
<p>I’ve mentioned Appium just above in the Python section, but <a href="https://appium.io/docs/en/2.2/ecosystem/#clients">Appium</a> and <a href="https://www.selenium.dev/documentation/">Selenium</a> can actually be used with several languages, including Ruby. That means KDE’s Selenium AT-SPI Webdriver <a href="https://invent.kde.org/sdk/selenium-webdriver-at-spi/-/blob/master/examples/kinfocentertest.rb">can be used with Ruby</a> to write Appium tests too.</p>
<p>KDE’s <a href="https://invent.kde.org/sysadmin/gitlab-triaging">Gitlab Triaging</a> tool used by the <a href="https://community.kde.org/Gardening">Gardening Team</a> is written entirely in Ruby (Gitlab itself uses a lot of Ruby too, so it makes sense).</p>
<p>The <a href="https://invent.kde.org/sysadmin/bugzilla-bot">Bugzilla Bot</a>, the one that automatically manages bug reports on <a href="https://bugs.kde.org">https://bugs.kde.org</a>, is also a tool that could use some love. As a tool that affects a huge amount of bug reports, any issues related to it will be significant.</p>
<p>The set of tools we use to make it easier to publish software releases, <a href="https://invent.kde.org/sdk/releaseme">Releaseme</a>, is very solid and only really known by KDE’s software maintainers.</p>
<p>Lastly we have an experimental <a href="https://invent.kde.org/packaging/homebrew-kde">Homebrew KDE repository</a>. Homebrew after all is a macOS package manager written in Ruby and whose recipes are written in Ruby.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://invent.kde.org/websites/jekyll-kde-theme">KDE’s Aether Theme for Jekyll</a></li>
<li><a href="https://invent.kde.org/sdk/selenium-webdriver-at-spi/-/blob/master/examples/kinfocentertest.rb">Appium tests</a></li>
<li><a href="https://invent.kde.org/sysadmin/gitlab-triaging">Gitlab Triaging tool</a></li>
<li><a href="https://invent.kde.org/sysadmin/bugzilla-bot">Bugzilla Bot</a></li>
<li><a href="https://invent.kde.org/sdk/releaseme">Releaseme</a></li>
<li><a href="https://invent.kde.org/packaging/homebrew-kde">Homebrew KDE repository</a></li>
</ul>
<h2 id="perl">Perl</h2>
<p>We don’t really have many projects written in Perl. There’s one we do have that is major: <a href="https://invent.kde.org/sdk/kdesrc-build">kdesrc-build</a>, the main tool we have used for a long time to easily build KDE software from the master branch (or any branch really) together with its dependencies. It is basically our main contribution entrypoint for new developers.</p>
<p>It is currently lacking a maintainer and enough activity, and there’s a new tool around the block called <a href="https://invent.kde.org/sdk/kde-builder">kde-builder</a> written in Python which is supposed to supersede it, but realistically the transition period from one tool to the next (as well as a migration plan) and the fact the tool is incredibly mature and stable means kdesrc-build will still be present for a long time.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://invent.kde.org/sdk/kdesrc-build">kdesrc-build</a></li>
</ul>
<h2 id="containers">Containerfile / Docker / Podman</h2>
<p>While this isn’t a language, it’s a specialized format with a lot of use in KDE infrastructure.</p>
<p>The two most notable examples of this are the sysadmin repositories <a href="https://invent.kde.org/sysadmin/ci-images">ci-images</a> and <a href="https://invent.kde.org/sysadmin/ci-utilities">ci-utilities</a>. The former consists of container images and the latter includes, among other things, <a href="https://docs.gitlab.com/ee/topics/build_your_application.html">Gitlab templates</a> using said images for <a href="https://community.kde.org/Infrastructure/Continuous_Integration_System">KDE’s continuous integration and delivery</a>.</p>
<p>We actually have very few system administrators and their work basically keeps KDE running. I’m sure they would appreciate the help.</p>
<p>If you have never dealt with Gitlab templates and you are not yet confident to mess around with KDE templates, you can do what I did before I got to write the above continuous integration wiki page: selfhost Gitlab on your own machine to learn the tools. I have a <a href="https://codeberg.org/herzenschein/herz-quadlet/src/branch/main/gitlab">podman quadlet</a> just for selfhosting Gitlab that makes it easy. Gitlab does use over 6 GiB of RAM by default, though!</p>
<p>To summarize:</p>
<ul>
<li><a href="https://invent.kde.org/sysadmin/ci-images">ci-images</a></li>
<li><a href="https://invent.kde.org/sysadmin/ci-utilities">ci-utilities</a></li>
</ul>
<p>See also the section on <a href="#wasm">Web Assembly</a>, as it mentions a specialized tool that uses a container image under the hood.</p>
<p>You should also take a look at this Akademy 2024 talk when it comes out:</p>
<ul>
<li><a href="https://conf.kde.org/event/6/contributions/218/">KDE’s CI and CD infrastructure</a>, by four of our KDE Sysadmins</li>
</ul>
<h2 id="websites">HTML / SCSS / JavaScript</h2>
<p>We have a sore need for web developers! We have an insane number of websites and few people to go through them.</p>
<p>But we need specifically web developers who are willing to work with <a href="https://gohugo.io/">Hugo</a>. Maybe a bit of Jekyll as well, as mentioned before in the <a href="#ruby">Ruby section</a> we do have a few websites written in it.</p>
<p>Hugo itself is written in Go, like Jekyll is written in Ruby. Unlike Jekyll, however, the website portion of Hugo does make use of a specialized <a href="https://gohugo.io/templates/">template system</a> that is based on Golang’s <a href="https://pkg.go.dev/text/template">text/template</a> and <a href="https://pkg.go.dev/html/template">html/template</a>. Still, it’s not a difficult template system to learn, and most of the necessary knowledge will still be web technologies. It’s fairly easy to get it going.</p>
<p>Our main web developers already have their hands full with high-demand web stuff like <a href="https://invent.kde.org/websites/hugo-kde">KDE’s Extensions for Hugo</a> and the main <a href="https://invent.kde.org/websites/kde-org">kde.org website</a>, and they still have to maintain many others.</p>
<p>In particular, the <a href="https://develop.kde.org/">KDE Developer website</a> has many issues that can only be addressed by web folks, one of which is a serious accessibility issue: <a href="https://invent.kde.org/documentation/develop-kde-org/-/issues/141">low contrast in text</a>. I have marked most issues that only web folks can help with with the <a href="https://invent.kde.org/documentation/develop-kde-org/-/issues/?label_name%5B%5D=Needs%20Web%20review%2Fassistance">“Needs web review/assistance” label</a>.</p>
<p>In addition to Hugo and Jekyll, I believe we still have a few remaining websites that use PHP, Wordpress, Drupal and need porting away from those technologies, and of course several websites that are just plain unmaintained or poorly maintained. You can see a list of all websites available in the <a href="https://invent.kde.org/websites">Websites Group</a>.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://invent.kde.org/websites">list of all websites</a></li>
<li><a href="https://invent.kde.org/documentation/develop-kde-org/-/issues/?label_name%5B%5D=Needs%20Web%20review%2Fassistance">KDE Developer’s website</a></li>
</ul>
<h2 id="wasm">Web Assembly</h2>
<p>We have one tool written in web assembly that is unmaintained, decommissioned, and we’d very much love to get working again!</p>
<p>The tool is QML Online. It’s a website that lets you write QML code (and even Kirigami code) directly and generate the GUI on the website itself. It was excellent for prototyping and sharing code, but it unfortunately was not ported to Qt6. So far I have seen no other similar project (there’s like 5 out there) that managed to surpass it.</p>
<p>I have updated the <a href="https://invent.kde.org/webapps/qmlonline">project’s readme</a> with better build instructions, and it works locally with Qt5, but the main container image it is based on needs to be ported to use Qt6 instead so we can get it running again. We need both someone who knows their way around containers <em>and</em> Qt6 for Web Assembly.</p>
<p>To summarize:</p>
<ul>
<li>Revive <a href="https://invent.kde.org/webapps/qmlonline">QML Online</a></li>
</ul>
<h2 id="flatpak-snap">Flatpak / Snap</h2>
<p>Both packaging technologies are very well regarded at KDE, but they have different culture and environments, even if they are very technically similar.</p>
<p>The relationship between KDE software and Flatpak is more like KDE being upstream: you will see Flatpak manifests directly on many KDE projects, and we do have a <a href="https://develop.kde.org/docs/packaging/flatpak/">flatpak tutorial on our KDE Developer platform</a>. It is also completely distribution agnostic, as you can build it on any distribution.</p>
<p>The relationship between KDE software and Snaps is more like Snap being upstream: it’s Canonical, Ubuntu and Ubuntu-based distros that do the packaging work. That is already more or less the case even outside KDE: Snap on most non-Ubuntu distributions is actually maintained by Canonical, and Snap issues on such distros is redirected to them. You will not really see Snap manifests in KDE software repositories, and the main tutorial for it is made by Canonical.</p>
<p>In practice, this means you can contribute to Flatpak manifests for KDE software directly on KDE’s repos (including for Flathub), and you can contribute to Snap manifests for KDE software by getting in contact with the folks that do Snap outside KDE (including for the Snap store), which includes the KDE neon people.</p>
<p>In Flatpak’s case the work is coordinated in a <a href="https://community.kde.org/Matrix#Development/Contributors">KDE Flatpak Matrix group</a>, while in Snap’s case the work is mostly done by the <a href="https://community.kde.org/Guidelines_and_HOWTOs/Snap#Help">KDE neon maintainers</a> and Snap developers over the <a href="https://forum.snapcraft.io/">Snapcraft Forum</a>.</p>
<p>Both are actually very easy to onboard: if you are generally acquainted with how to build software, you can get started very easily with either.</p>
<p>To summarize:</p>
<ul>
<li>flatpak: most <a href="https://invent.kde.org/">KDE projects on Invent</a>, including those that don’t have a manifest yet</li>
<li>flatpak: all <a href="https://flathub.org/">KDE projects on Flathub</a>, including making new ones with help from the <a href="https://community.kde.org/Matrix#Development/Contributors">KDE Flatpak Matrix group</a></li>
<li>snap: on the <a href="https://forum.snapcraft.io/">Snap forums</a> and with help from the <a href="https://community.kde.org/Guidelines_and_HOWTOs/Snap#Help">KDE neon maintainers</a></li>
</ul>
<h2 id="cmake">CMake</h2>
<p>This is a bit of specialized knowledge that needs mention.</p>
<p>I find modern CMake itself to be rather pleasant <em>to use</em> once you know what to do, and KDE’s <a href="https://api.kde.org/frameworks/extra-cmake-modules/html/index.html">extra-cmake-modules</a> (ECM) makes it much more convenient for C++ and Qt projects in general (not just KDE). I’m in the middle of reading <a href="https://crascit.com/professional-cmake/">Professional CMake</a> and loving it.</p>
<p>But actual CMake code in custom modules used for real life projects can be as complicated a beast as any Turing-complete code. For this reason, having more CMake experts looking into ECM code wouldn’t hurt.</p>
<p>It is otherwise possible to contribute to most KDE projects with CMake easily as almost everything uses CMake. What are the possible venues?</p>
<ul>
<li>Knowing standard CMake: there is an <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">introductory tutorial</a> on the CMake website itself. Standard CMake is the same everywhere, and modern CMake especially is always considered an improvement over old CMake. For the main differences between old and modern CMake you can take a look at the <a href="https://youtu.be/bsXLMQ6WgIk">Effective CMake talk</a> by Daniel Pfeiffer on YouTube.</li>
<li>Knowing Qt CMake: Qt has some <a href="https://doc.qt.io/qt-6/cmake-manual.html">specialized API</a> that is used for QML apps or to deploy applications. KDE uses the former but not the latter. It requires knowing standard CMake, and its knowledge is pretty valuable.</li>
<li>Knowing KDE’s ECM: ECM improves on top of standard CMake and Qt CMake, reducing a lot of boilerplate. It requires knowing standard CMake and Qt CMake.</li>
</ul>
<p>Basically what I’m saying is: if you know <em>some</em> CMake, you can contribute to any KDE project, and if you know <em>a lot</em> of CMake, you can contribute to ECM.</p>
<p>To summarize:</p>
<ul>
<li>most KDE projects using CMake</li>
<li><a href="https://api.kde.org/frameworks/extra-cmake-modules/html/index.html">extra-cmake-modules</a></li>
</ul>
<h2 id="java">Java</h2>
<p>We actually do have a few projects using Java. The most notable is probably <a href="https://invent.kde.org/network/kdeconnect-android">KDE Connect Android</a>, which is written exclusively in Java to be entirely native for the platform rather than use Qt’s crossplatform facilities.</p>
<p>Other KDE apps that <em>do</em> use Qt’s crossplatform facilities unavoidably also need to touch Java, as Qt does integrate with Java/Kotlin and needs some Java files to allow for deployment. <a href="https://doc.qt.io/qt-6/android-how-it-works.html">Qt’s Android documentation</a> is probably best to explain this, but we also have some docs on <a href="https://develop.kde.org/docs/packaging/android/building_applications/">how we automate building KDE software for Android using Craft</a> which might be relevant if you want to look into the whole Android process as is done by KDE.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://invent.kde.org/network/kdeconnect-android">KDE Connect Android</a></li>
<li>most KDE projects that build on Android</li>
</ul>
<h2 id="rust">Rust</h2>
<p>I was originally refraining from writing a section just for Rust because I myself don’t know the right places where you can contribute to KDE with Rust code, and I personally think we should focus on investing on our Python ecosystem.</p>
<p>The most I know is that KDE has a <a href="https://invent.kde.org/sdk/rust-qt-binding-generator">Rust-to-Qt bindings generator</a>, and we have a <a href="https://community.kde.org/Rust">KDE Rust wiki page</a> detailing some things.</p>
<p>But then I saw that <a href="https://redstrate.com/">redstrate</a> is making an Akademy 2024 talk whose name is <a href="https://conf.kde.org/event/6/contributions/203/">C++, Rust and Qt: Easier than you think</a>, and just this very talk should be enough to warrant its own section.</p>
<p>Perhaps this should help with the current situation involving Rust adoption: lots of people outside KDE hype for Rust, but few outside people actually help make it happen. It’s a bit of a chicken-and-egg situation, naturally, but still: we need people making it happen, not so much people hyping it.</p>
<p>In any case, I do also know <em>non-KDE</em> projects you can contribute to with Rust, which ultimately would help improve the Rust ecosystem for KDE.</p>
<p>In case you didn’t know, I was a moderator for the <a href="https://www.reddit.com/r/kde/">KDE Subreddit</a>, and I’m the one who made that very long onboarding sidebar on the new Reddit version of the website and kept it up-to-date for years. I didn’t (and still don’t quite) particularly care about Rust myself, but I did make a honorable mention to it on the sidebar regardless, and I’ll use it as base here, with what I now know, in order of priority:</p>
<ul>
<li><a href="https://cxx.rs/">cxx</a> lets you use C++ in Rust projects and use Rust in C++ projects.</li>
<li><a href="https://github.com/KDAB/cxx-qt">cxx-qt</a> lets you use Qt in Rust projects and use Rust in Qt projects.</li>
<li><a href="https://rust-qt.github.io/">Rust-Qt or Ritual</a> includes bindings for Rust to use C++, and thus also Qt.</li>
<li><a href="https://github.com/woboq/qmetaobject-rs">QMetaObject-rs</a> includes bindings for Rust to use QML, and thus also QtQuick.</li>
</ul>
<p>The reason for the ordering is that cxx and cxx-qt currently seem to be the most promising projects. After all, cxx is bidirectional, and cxx-qt is made by KDAB, and we have (and have had) several people from KDAB contributing to KDE, even as contractors.</p>
<p>Furthermore, from what I’ve heard it seems likely that, if someone is going to make bindings for KDE Frameworks in Rust, they will probably need to be done using cxx.</p>
<p>Based on my own personal experience, both cxx and cxx-qt were very nice to use when writing Rust-only code, just so you know.</p>
<p>In another turn of events, however, if we were to see a boon in Ritual and QMetaObject-rs, it’s also quite possible that those could help improve the KDE Rust ecosystem.</p>
<p>To summarize:</p>
<ul>
<li><a href="https://community.kde.org/Rust">KDE Rust wiki page</a></li>
<li><a href="https://invent.kde.org/sdk/rust-qt-binding-generator">Rust-to-Qt bindings generator</a></li>
<li><a href="https://cxx.rs/">cxx</a></li>
<li><a href="https://github.com/KDAB/cxx-qt">cxx-qt</a></li>
<li><a href="https://rust-qt.github.io/">Ritual</a></li>
<li><a href="https://github.com/woboq/qmetaobject-rs">QMetaObject-rs</a></li>
</ul>
<p>You should also take a look at this Akademy 2024 talk when it comes out:</p>
<ul>
<li><a href="https://conf.kde.org/event/6/contributions/203/">C++, Rust and Qt: Easier than you think</a></li>
</ul>

      </div></div>
  </body>
</html>
