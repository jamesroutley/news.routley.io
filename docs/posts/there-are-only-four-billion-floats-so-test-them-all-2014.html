<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://randomascii.wordpress.com/2014/01/27/theres-only-four-billion-floatsso-test-them-all/">Original</a>
    <h1>There Are Only Four Billion Floats–So Test Them All (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>A few months ago I saw a blog post touting fancy new SSE3 functions for implementing vector <em>floor</em>, <em>ceil</em>, and <em>round</em> functions. There was the inevitable proud proclaiming of impressive performance and correctness. However the <em>ceil</em> function gave the wrong answer for many numbers it was supposed to handle, including odd-ball numbers like ‘one’.</p>
<p>The <em>floor</em> and <em>round</em> functions were similarly flawed. The reddit discussion of these problems then discussed two other sets of vector math functions. Both of them were similarly buggy.</p>
<p>Fixed versions of some of these functions were produced, and they are greatly improved, but some of them still have bugs.</p>
<p>Floating-point math is hard, but testing these functions is trivial, and fast. Just do it.</p>

<p>The functions <em>ceil,</em> <em>floor</em>, and<em> round</em> are particularly easy to test because there are presumed-good CRT (<a href="https://en.wikipedia.org/wiki/Runtime_system">C RunTime</a>) functions that you can check them against. And, you can test every float bit-pattern (all four billion!) in about ninety seconds. It’s actually very easy. Just iterate through all four-billion (technically 2^32) bit patterns, call your test function, call your reference function, and make sure the results match. Properly comparing <a href="https://randomascii.wordpress.com/2012/04/21/exceptional-floating-point/">NaN</a> and zero results takes a bit of care but it’s still not too bad.</p>
<blockquote><p>Aside: floating-point math has a reputation for producing results that are unpredictably wrong. This reputation is then used to justify sloppiness, which then justifies the reputation. In fact IEEE floating-point math is designed to, whenever practical, give the best possible answer (correctly rounded), and functions that extend floating-point math should follow this pattern, and only deviate from it when it is clear that correctness is too expensive.</p></blockquote>
<p>Later on I’ll show the implementation for my <em>ExhaustiveTest</em> function but for now here is the function declaration:</p>
<pre>typedef float(*Transform)(float);

// Pass in a range of float representations to compare against.
// start and stop are inclusive. Pass in 0, 0xFFFFFFFF to scan all
// floats. The floats are iterated through by incrementing
// their integer representation.
void ExhaustiveTest(uint32_t start, uint32_t stop, Transform TestFunc,
            Transform RefFunc, const char* desc)</pre>
<p>Typical test code that uses ExhaustiveTest is shown below. In this case I am testing the original SSE 2 <em>_mm_ceil_ps2</em> function that started the discussion, with a wrapper to translate between float and __m128. The function didn’t claim to handle floats outside of the range of 32-bit integers so I restricted the test range to just those numbers:</p>
<pre>float old_mm_ceil_ps2(float f)
{
    __m128 input = { f, 0, 0, 0 };
    __m128 result = old_mm_ceil_ps2(input);
    return result.m128_f32[0];
}

int main()
{
    // This is the biggest number that can be represented in
    // both float and int32_t. It’s 2^31-128.
    Float_t maxfloatasint(2147483520.0f);
    const uint32_t signBit = 0×80000000;
    ExhaustiveTest(0, (uint32_t)maxfloatasint.i, old_mm_ceil_ps2, ceil,
                &#34;old _mm_ceil_ps2&#34;);
    ExhaustiveTest(signBit, signBit | maxfloatasint.i, old_mm_ceil_ps2, ceil,
                &#34;old _mm_ceil_ps2&#34;);
}</pre>
<p>Note that this code uses the Float_t type to get the integer representation of a particular float. I described Float_t years ago in <a href="https://randomascii.wordpress.com/2012/01/11/tricks-with-the-floating-point-format/">Tricks With the Floating-Point Format</a> .</p>
<h2>How did the original functions do?</h2>
<p><em>_mm_ceil_ps2</em> claimed to handle all numbers in the range of 32-bit integers, which is already ignoring about 38% of floating-point numbers. Even in that limited range it had 872,415,233 errors – that’s a 33% failure rate over the 2,650,800,128 floats it tried to handle. <em>_mm_ceil_ps2</em> got the wrong answer for all numbers between 0.0 and <em>FLT_EPSILON</em> * 0.25, all odd numbers below 8,388,608, and a few other numbers. A fixed version was quickly produced after the errors were pointed out.</p>
<p>Another set of vector math functions that was discussed was DirectXMath. The 3.03 version of DirectXMath’s <em>XMVectorCeiling</em> claimed to handle all floats. However it failed on lots of tiny numbers, and on most odd numbers. In total there were 880,803,839 errors out of the 4,294,967,296 numbers (all floats) that it tried to handle. The one redeeming point for <em>XMVectorCeiling</em> is that these bugs have been known and fixed for a while, but you need the latest Windows SDK (comes with VS 2013) in order to get the fixed 3.06 version. And even the 3.06 version doesn’t entirely fix <em>XMVectorRound</em>.</p>
<p>The LiraNuna / glsl-sse2 family of functions were the final set of math functions that were mentioned. The LiraNuna <em>ceil</em> function claimed to handle all floats but it gave the wrong answer on 864,026,625 numbers. That’s better than the others, but not by much.</p>
<p>I didn’t exhaustively test the <em>floor</em> and <em>round</em> functions because it would complicate this article and wouldn’t add significant value. Suffice it to say that they have similar errors.</p>
<h2>Sources of error</h2>
<p>Several of the <em>ceil</em> functions were implemented by adding 0.5 to the input value and rounding to nearest. This does not work. This technique fails in several ways:</p>
<ol>
<li>Round to nearest even is the default IEEE rounding mode. This means that 5.5 rounds to 6, and 6.5 also rounds to 6. That’s why many of the <em>ceil</em> functions fail on odd integers. This technique also fails on the largest float smaller than 1.0 because this plus 0.5 gives 1.5 which rounds to 2.0.</li>
<li>For very small numbers (less than about <em>FLT_EPSILON</em> * 0.25) adding 0.5 gives 0.5 exactly, and this then rounds to zero. Since about 40% of the positive floating-point numbers are smaller than FLT_EPSILON*0.25 this results in a lot of errors – over 850 million of them!</li>
</ol>
<p>The 3.03 version of DirectXMath’s <em>XMVectorCeiling</em> used a variant of this technique. Instead of adding 0.5 they added <em>g_XMOneHalfMinusEpsilon</em>. Perversely enough the value of this constant doesn’t match its name – it’s actually one half minus 0.75 times <em>FLT_EPSILON</em>. Curious. Using this constant avoids errors on 1.0f but it still fails on small numbers and on odd numbers greater than one.</p>
<h2>NaN handling</h2>
<p>The fixed version of <em>_mm_ceil_ps2</em> comes with a handy template function that can be used to extend it to support the full range of floats. Unfortunately, due to an implementation error, it fails to handle NaNs. This means that if you call <em>_mm_safeInt_ps&lt;new_mm_ceil_ps2&gt;()</em> with a NaN then you get a normal number back. Whenever possible NaNs should be ‘sticky’ in order to aid in tracking down the errors that produce them.</p>
<p>The problem is that the wrapper function uses <em>cmpgt</em> to create a mask that it can use to retain the value of large floats – this mask is all ones for large floats. However since all comparisons with NaNs are false this mask is zero for NaNs, so a garbage value is returned for them. If the comparison is switched to <em>cmple</em> and the two mask operations (<em>and</em> and <em>andnot</em>) are switched then NaN handling is obtained for free. Sometimes correctness doesn’t cost anything. Here’s a fixed version:</p>
<pre>template&lt; __m128 (FuncT)(const __m128&amp;) &gt;
inline __m128 _mm_fixed_safeInt_ps(const __m128&amp; a){
    __m128 v8388608 = *(__m128*)&amp;_mm_set1_epi32(0x4b000000);
    __m128 aAbs = _mm_and_ps(a, *(__m128*)&amp;_mm_set1_epi32(0x7fffffff));
    // In order to handle NaNs correctly we need to use le instead of gt.
    // Using le ensures that the bitmask is clear for large numbers *and*
    // NaNs, whereas gt ensures that the bitmask is set for large numbers
    // but not for NaNs.
    __m128 aMask = _mm_cmple_ps(aAbs, v8388608);
    // select a if greater then 8388608.0f, otherwise select the result of
    // FuncT. Note that &#39;and&#39; and &#39;andnot&#39; were reversed because the
    // meaning of the bitmask has been reversed.
    __m128 r = _mm_xor_ps(_mm_andnot_ps(aMask, a), _mm_and_ps(aMask, FuncT(a)));
    return r;
}</pre>
<p>With this fix and the latest version of <em>_mm_ceil_ps2</em> it becomes possible to handle all 4 billion floats correctly.</p>
<h2>Conventional wisdom Nazis</h2>
<p>Conventional wisdom says that you should never compare two floats for equality – you should always use an epsilon. Conventional wisdom is wrong.</p>
<p>I’ve written in great detail about how to compare floating-point values using an epsilon, but there are times when it is just not appropriate. Sometimes there really is an answer that is correct, and in those cases anything less than perfection is just sloppy.</p>
<p>So yes, I’m proudly comparing floats to see if they are equal.</p>
<h2>How did the fixed versions do?</h2>
<p>After the flaws in these functions were pointed out fixed versions of <em>_mm_ceil_ps2</em> and its sister functions were quickly produced and these new versions work better.</p>
<p>I didn’t test every function, but here are the results from the final versions of functions that I did test:</p>
<ul>
<li>
<ul>
<li>XMVectorCeiling 3.06: zero failures</li>
<li>XMVectorFloor 3.06: zero failures</li>
<li>XMVectorRound 3.06: 33,554,432 errors on incorrectly handled boundary conditions</li>
<li>_mm_ceil_ps2 with _mm_safeInt_ps: 16777214 failures on NaNs</li>
<li>_mm_ceil_ps2 with _mm_fixed_safeInt_ps: zero failures</li>
<li>LiraNuna ceil: this function was not updated so it still has</li>
</ul>
</li>
</ul>
<p>864,026,625 failures.</p>
<p>Exhaustive testing works brilliantly for functions that take a single float as input. I used this to great effect when rewriting all of the CRT math functions for a game console some years ago. On the other hand, if you have a function that takes multiple floats or a double as input then the search space is too big. In that case a mixture of test cases for suspected problem areas and random testing should work. A trillion tests can complete in a reasonable amount of time, and it should catch most problems.</p>
<h2>Test code</h2>
<p>Here’s a simple function that can be used to test a function across all floats. The sample code linked below contains a more robust version that tracks how many errors are found.</p>
<pre>// Pass in a uint32_t range of float representations to test.
// start and stop are inclusive. Pass in 0, 0xFFFFFFFF to scan all
// floats. The floats are iterated through by incrementing
// their integer representation.
void ExhaustiveTest(uint32_t start, uint32_t stop, Transform TestFunc,
    Transform RefFunc, const char* desc)
{
    printf(&#34;Testing %s from %u to %u (inclusive).\n&#34;, desc, start, stop);
    // Use long long to let us loop over all positive integers.
    long long i = start;
    while (i &lt;= stop)
    {
        Float_t input;
        input.i = (int32_t)i;
        Float_t testValue = TestFunc(input.f);
        Float_t refValue = RefFunc(input.f);
        // If the results don’t match then report an error.
        if (testValue.f != refValue.f &amp;&amp;
            // If both results are NaNs then we treat that as a match.
            (testValue.f == testValue.f || refValue.f == refValue.f))
        {
            printf(&#34;Input %.9g, expected %.9g, got %1.9g        \n&#34;,
            input.f, refValue.f, testValue.f);
        }

        ++i;
    }
}</pre>
<h2>Subtle errors</h2>
<p>My test code misses one subtle difference – it fails to detect one type of error. Did you spot it?</p>
<p>The correct result for ceil(-0.5f) is -0.0f. The sign bit should be preserved. The vector math functions all fail to do this. In most cases this doesn’t matter, at least for game math, but I think it is at least important to acknowledge this (minor) imperfection. If the compare function was put into ‘fussy’ mode (just compare the representation of the floats instead of the floats) then each of the <em>ceil</em> functions would have an additional billion or so failures, from all of the floats between -0.0 and -1.0.</p>
<h2>References</h2>
<p>The original post that announced <em>_mm_ceil_ps2</em> can be found here – with corrected code:</p>
<p><a title="http://dss.stephanierct.com/DevBlog/?p=8" href="http://dss.stephanierct.com/DevBlog/?p=8">http://dss.stephanierct.com/DevBlog/?p=8</a></p>
<p>This post discusses the bugs in the 3.03 version of DirectXMath and how to get fixed versions:</p>
<p><a title="http://blogs.msdn.com/b/chuckw/archive/2013/03/06/known-issues-directxmath-3-03.aspx" href="http://blogs.msdn.com/b/chuckw/archive/2013/03/06/known-issues-directxmath-3-03.aspx">http://blogs.msdn.com/b/chuckw/archive/2013/03/06/known-issues-directxmath-3-03.aspx</a></p>
<p>This post links to the LiraNuna glsl-sse2 math library:</p>
<p><a title="https://github.com/LiraNuna/glsl-sse2" href="https://github.com/LiraNuna/glsl-sse2">https://github.com/LiraNuna/glsl-sse2</a></p>
<p>The original reddit discussion of these functions can be found here:</p>
<p><a title="http://w3.reddit.com/r/programming/comments/1p2yys/sse3_optimized_vector_floor_ceil_round_and_mod/" href="http://w3.reddit.com/r/programming/comments/1p2yys/sse3_optimized_vector_floor_ceil_round_and_mod/">http://w3.reddit.com/r/programming/comments/1p2yys/sse3_optimized_vector_floor_ceil_round_and_mod/</a></p>
<p>Sample code for VC++ 2013 to run these tests. Just uncomment the test that you want to run from the body of <em>main</em>.</p>
<p><a href="https://www.cygnus-software.com/ftp_pub/test4billion.zip">https://www.cygnus-software.com/ftp_pub/test4billion.zip</a></p>
<p>The reddit discussion of this post can be found <a href="http://www.reddit.com/r/programming/comments/1wc4dg/theres_only_four_billion_floatsso_test_them_all/">here</a>, and then <a href="https://www.reddit.com/r/programming/comments/705lxv/there_are_only_four_billion_floatsso_test_them_all/">here</a>.</p>
<p>The hacker news discussion of this post can be found <a href="https://news.ycombinator.com/item?id=7135261">here</a>, and then <a href="https://news.ycombinator.com/item?id=15252426#15253328">here</a>. And again in 2020 it can be found <a href="https://news.ycombinator.com/item?id=24745563">here</a>.</p>
<p>I’ve written before about running tests on all of the floats. The last time I was exhaustively testing round-tripping of printed floats, which took long enough that I showed how to <a href="https://randomascii.wordpress.com/2012/03/11/c-11-stdasync-for-fast-float-format-finding/">easily parallelize it</a> and then I <a href="https://randomascii.wordpress.com/2013/02/07/float-precision-revisited-nine-digit-float-portability/">verified that they round-tripped between VC++ and gcc</a>. This time the tests ran so quickly that it wasn’t even worth spinning up extra threads.</p>
											</div></div>
  </body>
</html>
