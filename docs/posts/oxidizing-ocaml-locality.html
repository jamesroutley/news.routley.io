<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janestreet.com/oxidizing-ocaml-locality/">Original</a>
    <h1>Oxidizing OCaml: Locality</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Coming from OCaml, the Rust programming language has many appealing
features.  Rust’s system for tracking lifetime and ownership allows
users to safely express patterns that are awkward in OCaml, such as:</p>

<ul>
  <li>Stack-allocated values and custom allocation schemes.</li>
  <li>Managed resources that can’t be (easily) garbage collected,
e.g. file descriptors or GPU memory.</li>
  <li>Mutable data structures in the presence of concurrency.</li>
</ul>

<p>On the other hand, Rust’s approach comes with some trade-offs.
Eschewing garbage collection requires careful consideration of lifetime
and ownership throughout a codebase. Emphasizing lifetime-polymorphism
can also make type inference untenable, a design choice that wouldn’t
fit OCaml.</p>

<p>At Jane Street, we’ve been working on extending OCaml to better support
these use cases, without giving up the principles that make OCaml a
convenient and flexible language.</p>

<p>To do so, we’re introducing a system of <em>modes</em>, which track
properties like the locality and uniqueness of OCaml values. Modes
allow the compiler to emit better, lower-allocation code, empower
users to write safer APIs, and with the advent of multicore,
statically guarantee data race freedom—all in a lightweight way
that only affects those in need.</p>



<p>The OCaml compiler does not statically track lifetimes. Instead, it
relies on a garbage collector to figure out a suitable lifespan for each
value at runtime. Values are collected only after they become
unreferenced, so OCaml programs are memory-safe.</p>

<p>To a first approximation, this model requires allocating all values on
the heap. Fortunately, OCaml’s <a href="https://dev.realworldocaml.org/garbage-collector.html">generational
GC</a> can
efficiently handle short-lived values—minor-heap allocation
simply advances a ring buffer.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/minorheap.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/minorheap.svg" alt="Diagram of minor heap allocation."/></a>

</p>


<p>However, placing <em>everything</em> on the heap is still a pessimistic
approach. Where possible, using a specialized allocator could improve
performance. For example, the minor heap is typically larger than cache,
so future allocations are likely to evict live values.  Stack allocation
would immediately re-use freed space, eliminating this concern.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/stack.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/stack.svg" alt="Diagram of stack allocation."/></a>

</p>


<p>Providing an alternative to heap allocation would also have other
benefits:</p>

<ul>
  <li>
    <p>Every minor heap allocation brings us closer to the next minor
collection cycle. A minor collection incurs some fixed overhead,
but more importantly, frequent collection causes more values to be
moved to the major heap. Promoted values become much costlier to
collect later on.</p>
  </li>
  <li>
    <p>At Jane Street, we often write “zero-allocation” code, which must
never trigger a GC cycle. A stack allocator would make it much
easier to write programs that do not touch the heap.</p>
  </li>
</ul>

<p>When such performance concerns are relevant, one should arguably be
using a language based on explicit memory management, like Rust.
However, garbage collection is genuinely useful; explicit management is
a burden on users. Ideally, a language could provide a spectrum of
allocation strategies freely interoperable within a single
application. With modes, users can write OCaml with all the usual GC
guarantees—but when performance is paramount, opt into the
consideration of lifetimes, ownership, and concurrency.</p>

<h2 id="local-variables">Local Variables</h2>

<p>In OCaml, it turns out that many short-lived values can be
stack-allocated. To safely refer to such values, we introduce
<strong>local</strong> variables.</p>

<p>Determining whether a variable is local involves checking a certain
condition on its lifetime. Consider the following function:</p>

<div><pre><code><span>let</span> <span>is_int</span> <span>str</span> <span>=</span>
    <span>let</span> <span>opt</span> <span>=</span> <span>Int</span><span>.</span><span>of_string_opt</span> <span>str</span> <span>in</span>
    <span>match</span> <span>opt</span> <span>with</span>
    <span>|</span> <span>Some</span> <span>_</span> <span>-&gt;</span> <span>true</span>
    <span>|</span> <span>None</span> <span>-&gt;</span> <span>false</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>is_int</span> <span>:</span> <span>string</span> <span>-&gt;</span> <span>bool</span>
</code></pre>
  </div>
</div>

<p>Naively, this function incurs a heap allocation. The compiler does
not know the lifetime of <code>opt</code>—our function could return it, or
even store it in a global variable. Because <code>opt</code> could <em>escape</em> this
function, the value referenced by <code>opt</code> may need to live forever.
Therefore, it must be heap-allocated.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/optheap.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/optheap.svg" alt="Diagram of `opt` placed on the heap."/></a>

</p>


<p>As the programmer, however, we can deduce that a shorter lifetime
suffices. In fact, <code>opt</code> only needs to live until we <code>match</code> on it.
When <code>is_int</code> returns, <code>opt</code> is no longer accessible, so it could have
safely been allocated in stack memory local to <code>is_int</code>.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/optstack.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/optstack.svg" alt="Diagram of `opt` placed on the stack."/></a>

</p>


<p>Specifically, <code>opt</code> is local because its lifetime does not exceed its
enclosing stack frame, which we call its <strong>region</strong>. At runtime,
entering <code>is_int</code> begins a region by saving the current stack pointer;
exiting ends the region and reclaims stack-allocated memory. Since <code>opt</code>
is only accessible within this region, it may safely be allocated in the
corresponding stack frame.</p>

<p><em>Note that a stack-allocated value is not necessarily stored on the
control flow stack, as seen in languages that support <code>alloca()</code>. In
this example, we request space from a stack-based allocator backed by
entirely unrelated memory.</em></p>

<h2 id="the-locality-mode">The Locality Mode</h2>

<p>So, local variables are those that do not escape their region. To
formalize this constraint in a manner the compiler can check, we
introduce <strong>modes</strong>.</p>

<ul>
  <li>
    <p>By default, variables have the <code>global</code> mode. A global variable
has the capability to escape any region, so always references the
heap.</p>
  </li>
  <li>
    <p>Variables with the new <code>local</code> mode cannot escape their enclosing
region, so may refer to the stack.</p>
  </li>
</ul>

<p>A mode is attached to a variable upon declaration, either in a <code>let</code>
binding or in a function parameter.  In both cases, the compiler will
check that the value does not escape its region.</p>

<div><pre><code><span>let</span> <span>foo</span> <span>(</span><span>local</span> <span>x</span><span>)</span> <span>=</span>
    <span>let</span> <span>local</span> <span>y</span> <span>=</span> <span>0</span> <span>in</span>
    <span>x</span><span>,</span> <span>y</span>
<span>;;</span>
</code></pre>
</div>
<pre>3 | x, y
    ^
Error: this value escapes its region.
</pre>

<p>A <code>local</code> parameter represents a promise by the callee: the function
will not store a reference to the value anywhere that could be accessed
after the function returns. Intuitively, it’s safe to pass a
stack-allocated value to a function if we know the value’s lifetime will
not be extended.</p>

<div><pre><code><span>let</span> <span>is_empty</span> <span>(</span><span>local</span> <span>str</span><span>)</span> <span>=</span>
    <span>String</span><span>.</span><span>length</span> <span>str</span> <span>=</span> <span>0</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>is_empty</span> <span>:</span> <span>string</span> <span>@</span> <span>local</span> <span>-&gt;</span> <span>bool</span>
</code></pre>
  </div>
</div>

<p>Here, the syntax <code>string @ local</code> denotes that <code>is_empty</code> takes its parameter
“at” the local mode.</p>

<p>Even without explicit mode annotations, the compiler can statically
determine which variables may escape their enclosing region. Such
variables are assigned the global mode; all others are automatically
inferred to be local. At this point, the compiler may construct values
bound to <code>local</code> variables using stack allocation.</p>

<h2 id="local-returns">Local Returns</h2>

<p>Returning a local value from a function should appear contradictory,
since a function’s result has clearly escaped its region. On the other
hand, if functions can only return globals, constructing fully
stack-allocated values becomes difficult—they can only be built up
from literals. The solution:</p>

<div><pre><code><span>let</span> <span>local_list</span> <span>()</span> <span>=</span>
    <span>exclave</span> <span>[</span><span>1</span><span>;</span> <span>2</span><span>;</span> <span>3</span><span>]</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>local_list</span> <span>:</span> <span>unit</span> <span>-&gt;</span> <span>int</span> <span>list</span> <span>@</span> <span>local</span>
</code></pre>
  </div>
</div>

<p>The <code>exclave</code> keyword ends the current region and executes the given
expression in the <em>enclosing</em> region. The caller receives a local
variable prohibited from escaping the <em>caller’s</em> region.  Therefore,
it’s safe to allocate that value on the caller’s stack frame—the
difference is simply which region the value lives in.</p>

<div><pre><code><span>let</span> <span>bar</span> <span>()</span> <span>=</span>
    <span>let</span> <span>list</span> <span>=</span> <span>local_list</span> <span>()</span> <span>in</span>
    <span>list</span>
<span>;;</span>
</code></pre>
</div>
<pre>3 | list
    ^^^^
Error: this value escapes its region.
</pre>

<p>Local-returning functions are the primary method of creating
stack-allocated values, as they can programmatically build up local data
structures. This mechanism also allows functions to return their local
parameters.</p>

<p>Lastly, recall that the ‘locals’ stack is distinct from the control flow
stack, making this behavior easy to implement.</p>

<h2 id="locality-in-apis">Locality in APIs</h2>

<p>Locality doesn’t only facilitate stack allocation—it also lets
us design safer APIs. The following code exhibits a common pattern
for resource management:</p>

<div><pre><code><span>Core_unix</span><span>.</span><span>with_file</span> <span>&#34;file&#34;</span> <span>~</span><span>mode</span><span>:[</span> <span>O_RDONLY</span> <span>]</span> <span>~</span><span>f</span><span>:(</span><span>fun</span> <span>fd</span> <span>-&gt;</span> <span>(* ... *)</span><span>)</span>
</code></pre>
</div>

<p>Here, a file descriptor is opened, passed to a lambda function, and
closed after the function returns. This API lets users eschew manually
closing the file descriptor. However, there’s no guarantee that the
descriptor is not used after it’s closed.</p>

<div><pre><code><span>let</span> <span>stash</span> <span>=</span> <span>ref</span> <span>0</span> <span>in</span>
<span>Core_unix</span><span>.</span><span>with_file</span> <span>&#34;file&#34;</span> <span>~</span><span>mode</span><span>:[</span> <span>O_RDONLY</span> <span>]</span> <span>~</span><span>f</span><span>:(</span><span>fun</span> <span>fd</span> <span>-&gt;</span> <span>stash</span> <span>:=</span> <span>fd</span><span>);</span>
<span>Core_unix</span><span>.</span><span>close</span> <span>!</span><span>stash</span>
</code></pre>
</div>
<pre>Exception: Unix.Unix_error(Unix.EBADF, &#34;close&#34;, ...)
</pre>

<p>Of course, this design can be improved by making <code>fd</code> a <code>local</code>
parameter. After changing the signature of <code>with_file</code> to the
following…</p>

<div><pre><code><span>val</span> <span>with_file</span> <span>:</span> <span>string</span> <span>-&gt;</span> <span>mode</span><span>:</span><span>open_flag</span> <span>list</span> <span>-&gt;</span> <span>f</span><span>:(</span><span>File_descr</span><span>.</span><span>t</span> <span>@</span> <span>local</span> <span>-&gt;</span> <span>&#39;</span><span>a</span><span>)</span> <span>-&gt;</span> <span>&#39;</span><span>a</span>
</code></pre>
</div>
<p>…the callback must promise not to stash away the file descriptor.
Therefore, we know the file won’t be used after the callback returns.</p>

<p>In this example, we’re using modes to require a promise from the
<em>caller</em>. This usage might feel similar to local returns, and for good
reason. Formally, when a parameter is used <em>contravariantly</em>, its mode
represents a restriction on the <em>callee</em>, but when used <em>covariantly</em>
(as seen here), it instead represents a restriction on the <em>caller</em>.</p>



<p>Above, we declared a local integer <code>x</code> using the syntax <code>let local</code>.
Notably, we didn’t simply add a type annotation—the <code>local</code> mode
does not operate on types. In fact, the mode of <code>x</code> is entirely separate
from the type of <code>x</code>.</p>

<p>Types describe data structures, that is, how to build up and take apart
values.  On the other hand, a mode encodes a property <em>independent of
data layout</em>, so may be attached to a variable of any type.  To
illustrate this behavior, type annotations specify a variable at a mode
using the syntax <code>type @ mode</code>.</p>

<div><pre><code><span>let</span> <span>local</span> <span>x</span> <span>=</span> <span>0</span>
<span>let</span> <span>local</span> <span>y</span> <span>=</span> <span>&#34;string&#34;</span>
<span>let</span> <span>local</span> <span>z</span> <span>=</span> <span>[</span><span>0</span><span>.</span><span>0</span><span>;</span> <span>1</span><span>.</span><span>0</span><span>]</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>x</span> <span>:</span> <span>int</span> <span>@</span> <span>local</span>
<span>val</span> <span>y</span> <span>:</span> <span>string</span> <span>@</span> <span>local</span>
<span>val</span> <span>z</span> <span>:</span> <span>float</span> <span>list</span> <span>@</span> <span>local</span>
</code></pre>
  </div>
</div>

<p>In the case of locality, the salient property is whether a value may
escape its region.  Variables with the <code>global</code> mode can escape any
region, so global values are correspondingly heap allocated.
Conversely, the <code>local</code> mode restricts a variable to its region; a local
value may be stack allocated.</p>

<h2 id="locality-vs-lifetimes">Locality vs. Lifetimes</h2>

<p>Encoding locality with a mode has some advantages compared to Rust’s
type-centric approach. In Rust, reference types are parameterized over
specific regions represented by lifetime variables.  This design is more
expressive than locality, which only distinguishes values that may
escape all regions from those that cannot escape any.</p>

<p>On the other hand, lifetime variables are a source of pervasive
complexity.  When references are inherently polymorphic, essentially all
functions become lifetime-polymorphic as well. For example, whenever a
reference lacks a lifetime annotation, an implicit lifetime variable
appears:</p>

<div><pre><code><span>fn</span> <span>print_string</span><span>(</span><span>s</span><span>:</span> <span>&amp;</span><span>str</span><span>);</span>

<span>// Is equivalent to...</span>

<span>fn</span> <span>print_string</span><span>&lt;</span><span>&#39;</span><span>a</span><span>&gt;</span><span>(</span><span>s</span><span>:</span> <span>&amp;</span><span>&#39;</span><span>a</span> <span>str</span><span>);</span>
</code></pre>
</div>

<p>Since Rust supports first-class functions, the result is that
higher-order functions require higher-order polymorphism, for which type
inference is undecidable in general.</p>

<p>OCaml’s modes do not affect type inference—they preserve the types
of existing code, so users truly don’t need to consider modes they
aren’t actively using.  In OCaml, type inference, higher-order
functions, and garbage collection are all important parts of the
development workflow, so we consider the local mode to be a good fit.</p>

<h2 id="modes-are-deep">Modes are Deep</h2>

<p>Above, we noted that a mode describes a property independent of data
layout.  Such properties are <em>deep</em>, as opposed to the <em>shallow</em> layout
encoded by a type.  To understand this distinction, consider the
following type:</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>list</span> <span>=</span>
    <span>|</span> <span>Empty</span>
    <span>|</span> <span>More</span> <span>of</span> <span>&#39;</span><span>a</span> <span>*</span> <span>&#39;</span><span>a</span> <span>list</span>
</code></pre>
</div>

<p>Destructuring a value of type <code>&#39;a list</code> produces two possible outcomes:
either the empty list, or a pair of a value and another list of
arbitrary shape. Hence, the type only describes the value’s top-level
structure.</p>

<div><pre><code><span>let</span> <span>process</span> <span>list</span> <span>=</span>
    <span>match</span> <span>list</span> <span>with</span>
    <span>|</span> <span>Empty</span> <span>-&gt;</span> <span>(* ... *)</span>
    <span>|</span> <span>More</span> <span>(</span><span>head</span><span>,</span> <span>remaining</span><span>)</span> <span>-&gt;</span> <span>(* ... *)</span>
<span>;;</span>
</code></pre>
</div>

<p>Conversely, destructuring a <code>global</code> variable of type <code>&#39;a list</code> produces
either an empty list, or a pair of a <em>global</em> value and another <em>global</em>
list. That is, if the root node of the list may escape its region, the
subsequent nodes clearly can too—so the entire list must be
heap-allocated.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/listheap.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/listheap.svg" alt="Diagram of a list placed on the heap."/></a>

</p>


<p>The same logic applies to the <code>local</code> case: destructuring a local
list produces a local value and another local list. It is possible to
create a local list consisting entirely of stack allocations, so we
must ensure that the contents of a local list also do not escape.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/liststack.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/liststack.svg" alt="Diagram of a list placed on the stack."/></a>

</p>


<p>Deepness enables the compiler to validate usage of local data
structures:</p>

<div><pre><code><span>let</span> <span>head</span> <span>(</span><span>local</span> <span>list</span><span>)</span> <span>=</span>
    <span>match</span> <span>list</span> <span>with</span>
    <span>|</span> <span>Empty</span> <span>-&gt;</span> <span>None</span>
    <span>|</span> <span>More</span> <span>(</span><span>head</span><span>,</span> <span>_)</span> <span>-&gt;</span> <span>Some</span> <span>head</span>
<span>;;</span>
</code></pre>
</div>
<pre>4 | | More (v, _) -&gt; Some head
                          ^^^^
Error: This value escapes its region
</pre>

<p>If locality didn’t exhibit “deepness,” it wouldn’t be very
useful—we could stack allocate the root node of a list, but we’d
have no way to express that further nodes may also be stack-allocated.</p>

<h2 id="sub-modes">Sub-Modes</h2>

<p>Given deepness, locality might appear to be an “all or nothing”
choice—so far, we’ve allocated our data structures either entirely
on the stack or entirely on the heap.  To break this dichotomy, we will
explore another important property of modes: each <strong>mode axis</strong> admits a
natural sub-typing relation.</p>

<p>In the case of locality, it’s intuitively safe to use a global variable
as if it were local. For example, a function expecting a local parameter
promises equivalent behavior whether or not the parameter actually lives
on the stack. Therefore, we say <code>global</code> is a <strong>sub-mode</strong> of <code>local</code>
and allow global values to be used at the local mode.</p>

<div><pre><code><span>let</span> <span>localize</span> <span>x</span> <span>=</span> <span>exclave</span> <span>x</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>localize</span> <span>:</span> <span>&#39;</span><span>a</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>@</span> <span>local</span>
</code></pre>
  </div>
</div>

<p>It is safe for a local value to reference a global, but not vice versa.
At runtime, this means we can create pointers from the stack to the
heap, but not from the heap to the stack.  For example, we can create a
local, fully stack-allocated list whose nodes refer to heap-allocated
values.</p>

<div><pre><code><span>let</span> <span>rec</span> <span>localize</span> <span>list</span> <span>=</span> <span>exclave</span>
    <span>match</span> <span>list</span> <span>with</span>
    <span>|</span> <span>Empty</span> <span>-&gt;</span> <span>Empty</span>
    <span>|</span> <span>More</span> <span>(</span><span>head</span><span>,</span> <span>remaining</span><span>)</span> <span>-&gt;</span> <span>More</span> <span>(</span><span>head</span><span>,</span> <span>localize</span> <span>remaining</span><span>)</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>localize</span> <span>:</span> <span>&#39;</span><span>a</span> <span>list</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>list</span> <span>@</span> <span>local</span>
</code></pre>
  </div>
</div>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/listvalheap.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/listvalheap.svg" alt="Diagram of a list on the stack referencing values on the heap."/></a>

</p>


<p>We could also create a local list where only the first node is
stack-allocated—say, if we locally append to a global list.</p>

<div><pre><code><span>let</span> <span>local_cons</span> <span>(</span><span>local</span> <span>head</span><span>)</span> <span>remaining</span> <span>=</span> <span>exclave</span>
    <span>More</span> <span>(</span><span>head</span><span>,</span> <span>remaining</span><span>)</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>local_cons</span> <span>:</span> <span>&#39;</span><span>a</span> <span>@</span> <span>local</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>list</span> <span>-&gt;</span> <span>&#39;</span><span>a</span> <span>list</span> <span>@</span> <span>local</span>
</code></pre>
  </div>
</div>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/listpartial.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/listpartial.svg" alt="Diagram of a list partially on the stack and the heap."/></a>

</p>


<p>What we <em>cannot</em> create is a global list containing a stack-allocated
node. Again, modes are deep, so any global list must have only captured
globals. This preserves the invariant that whenever a node is
heap-allocated, all nodes reachable from it are also heap-allocated.</p>

<p>More rigorously, we could say that as we traverse a value, the current
mode monotonically increases with depth. This restriction should also
make intuitive sense, since any list without this property contains a
pointer from the heap to the stack. Such a pointer is potential
use-after-free bug—the heap node may still be reachable after the
stack frame has been freed.</p>

<p><a href="https://the.scapegoat.dev/oxidizing-ocaml-locality/listbad.svg"><img src="https://the.scapegoat.dev/oxidizing-ocaml-locality/listbad.svg" alt="Diagram of an impossible list that moves from the stack to the heap and back."/></a>

</p>


<p>The above layout can be represented using Rust lifetimes, which support
subtyping.  However, safely manipulating such data structures requires
significantly more reasoning on the programmer’s part. Lifetime
variables refer to arbitrary regions, so subtyping relationships must be
explicitly specified.  Locality offers a compromise: considering just
one lifetime—the current region—makes efficient stack
allocation easy to use in many practical scenarios. Values with other
lifetimes are still managed by the garbage collector.</p>

<h2 id="global-record-fields">Global Record Fields</h2>

<p>Because modes are deep, a local record always contains local values.
Such fields may be stack allocated, so must be prohibited from escaping
the current region.  However, since global is a sub-mode of local, inner
values may also be heap allocated—and sometimes the programmer
knows they always will be.  In this case, locality is unnecessarily
restrictive.</p>

<p>Therefore, we also support annotating record fields with an explicit
<code>global</code> mode. The compiler forbids initializing a global field using a
local variable.  Global fields are hence allowed to escape their region:</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>box</span> <span>=</span> <span>{</span> <span>global</span> <span>x</span> <span>:</span> <span>&#39;</span><span>a</span> <span>}</span>

<span>let</span> <span>unwrap</span> <span>(</span><span>local</span> <span>box</span><span>)</span> <span>=</span>
    <span>box</span><span>.</span><span>x</span>
<span>;;</span>
</code></pre>
</div>
<div>
  <div><pre><code><span>val</span> <span>unwrap</span> <span>:</span> <span>&#39;</span><span>a</span> <span>box</span> <span>@</span> <span>local</span> <span>-&gt;</span> <span>&#39;</span><span>a</span>
</code></pre>
  </div>
</div>

<p>Explicitly mutable record fields are automatically considered global. If
this were not the case, a function could leak a local variable by
storing it within a local parameter, violating region safety. For
example:</p>

<div><pre><code><span>type</span> <span>&#39;</span><span>a</span> <span>box</span> <span>=</span> <span>{</span> <span>mutable</span> <span>x</span> <span>:</span> <span>&#39;</span><span>a</span> <span>option</span> <span>}</span>

<span>let</span> <span>clear</span> <span>(</span><span>local</span> <span>box</span><span>)</span> <span>=</span>
    <span>let</span> <span>local</span> <span>y</span> <span>=</span> <span>None</span> <span>in</span>
    <span>box</span><span>.</span><span>x</span> <span>&lt;-</span> <span>y</span>
<span>;;</span>
</code></pre>
</div>
<pre>5 | box.x &lt;- y
             ^
Error: this value escapes its region.
</pre>



<p>At Jane Street, we’ve been using locality in production for some time.
Developers who work on performance sensitive systems use locals daily,
and those who don’t are largely unfamiliar with the feature—which
means we’ve successfully limited the costs to the users who care.
Therefore, we consider locality’s expressivity and performance benefits
well worth the additional language complexity.</p>

<p>Building on locality’s success, the compilers team is now implementing
additional modes for describing ownership constraints. In part 2, we
will explore new mode axes representing <em>uniqueness</em> and <em>linearity</em>.</p>

    </div></div>
  </body>
</html>
