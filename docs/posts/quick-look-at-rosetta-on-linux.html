<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://threedots.ovh/blog/2022/06/quick-look-at-rosetta-on-linux/">Original</a>
    <h1>Quick Look at Rosetta on Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
	
	

	

	
	<main id="content">

	<div>
		<div>
						<article id="post-447">
				<div>
<p>Yesterday, Apple did release RosettaLinux as part of the macOS Ventura preview. Let’s take a first quick look…</p>



<h2>Location</h2>



<p>RosettaLinux is located at <code>/Library/Apple/usr/libexec/oah/RosettaLinux</code>. A <code>rosetta</code> ELF executable is present on that directory.</p>



<h2>Does it do AoT?</h2>



<p>No. Rosetta on Linux exclusively operates in JIT mode, at least for the time being.</p>



<h2>Mapping to the VM</h2>



<p>That directory is mapped through <code>virtiofs</code> to the virtual machine. <code>binfmt_misc</code> is then used to make execution attempts of x86_64 binaries run through Rosetta.</p>



<p>When the Rosetta directory is mapped to the virtual machine, all of the VM runs in <em>Total Store Ordering</em> mode. This provides the guarantees needed by Rosetta to provide x86-compatible memory model semantics.</p>



<p>If TSO mode is not present or not active on a given Arm platform, Rosetta explicitly does not provide those guarantees. It does <em>not</em> try to handle that use case. As such, to provide proper semantics on those environments, you can use <code>taskset</code> to bind applications using Rosetta to a single core.</p>



<h2>Not-really-DSMOS*</h2>



<p>Rosetta has a mechanism to restrict it to <code>Virtualization.framework</code> virtual machines. The <code>ioctl</code> is passed through <code>virtiofs</code> to the host.</p>



<p>A re-creation of that mechanism is pasted below:</p>



<pre><code>  char* AppleRosettaKey = &#34;Our hard work\nby these words guarded\nplease don&#39;t steal\n Apple Inc&#34;;

  int fd = openat(AT_FDCWD ,&#34;/proc/self/exe&#34;, 0);

  if (fd &lt; 0) {
    rosetta_error(&#34;Unable to open /proc/self/exe: %lu&#34;, fd);
  }

  char key[45];
  int ioctl_result = ioctl(fd, _IOC(_IOC_READ, 0x61, 0x22, 0x45), key);

  if (ioctl_result &lt; 0 || memcmp(key,AppleRosettaKey,0x45) != 0) {
    rosetta_error(
                 &#34;Rosetta is only intended to run on Apple Silicon with a macOS host \
                 using Virtualization.framework with Rosetta mode enabled&#34;
                 );
  }
</code></pre>



<p>As we can see, the mechanism is quite trivial to bypass. However, please rely on another solution if you’re running on non-Apple hardware.</p>



<h2>Running it on non-Apple CPUs?</h2>



<p>Running it on a Mac is fun, but what if we try to run it on other processors? </p>



<h3>Tegra Xavier testing</h3>



<p>My first thought was the Tegra Xavier processor, which provides sequential consistency in hardware. As such, it satisfies the programmer-visible memory ordering constraints required for Rosetta to be functional. </p>



<p>However, Rosetta relies on <code>FEAT_FlagM</code> flag manipulation instructions. Those are not implemented on Carmel. As such, I skipped over to another potential testing target.</p>



<p>And the <code>CNTFRQ_EL0</code> timer frequency of 31.25MHz on Xavier doesn’t match with what Rosetta expects either.</p>



<h3>Graviton3 testing</h3>



<p>Which Arm platforms are easily accessible with flag manipulation instructions? There are some, such as the AWS Graviton3 processor, which uses Arm’s Neoverse V1 core.</p>



<pre><code>rosetta error: Unsupported counter frequency, check value of CNTFRQ_EL0
Trace/breakpoint trap</code></pre>



<p>Rosetta supports <code>CNTFRQ_EL0</code> timer frequencies of 24 MHz and 1.00GHz, which is unlike the 1.05 GHz value used by the Graviton3 platform.</p>



<p>Let’s override the value reported to Rosetta with 1.00 GHz. This is close enough for things to work fine for testing purposes. </p>



<p>This allows to make a <a rel="noreferrer noopener" href="https://browser.geekbench.com/v5/cpu/compare/15338732?baseline=15338946" target="_blank">Geekbench 5 run</a>, showing ~70% of native performance for Rosetta 2 on a c7g.large dual-core instance. Anecdotally, the HDR subtest of Geekbench anomalously gives higher performance inside of the Rosetta environment than outside for this configuration. </p>



<p>However, a reminder that x86 memory ordering semantics aren’t provided is required to put that score into perspective.</p>



<p><em>* Don’t Steal Mac OS X, the system used to restrict x86_64 macOS from running on non-Apple hardware.</em></p>
</div>

			</article>
			
		</div>
	</div>

</main><!--/.neve-main-->



</div></div>
  </body>
</html>
