<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.fogus.me/2013/07/17/an-introduction-to-deep-code-walking-macros-with-clojure/">Original</a>
    <h1>An introduction to deep code-walking macros with Clojure (2013)</h1>
    
    <div id="readability-page-1" class="page"><div id="body">

                <div id="post-5416">
                 <h3><a href="https://blog.fogus.me/2013/07/17/an-introduction-to-deep-code-walking-macros-with-clojure/" title="An introduction to deep code-walking macros with Clojure">An introduction to deep code-walking macros with Clojure</a></h3>
                 <p><span>Jul 17, 2013 </span></p><p>With the release of the <a href="https://github.com/clojure/core.async">core.async</a> library the Clojure community has been exposed to the joys<sup id="fnref:0"><a href="#fn:0" rel="footnote">1</a></sup> of <a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/">Communicating Sequential Processes</a> and <a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">Go-style asynchronousity</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote">2</a></sup>.  While this is all very exciting and new for the Clojure community at-large, a likewise interesting aspect of core.async’s release has been exposed — deep code-walking macros — a subject I will give an overview of herein.<sup id="fnref:2"><a href="#fn:2" rel="footnote">3</a></sup></p>

<p>In chapter 17 of <em><a href="http://www.joyofclojure.com/">The Joy of Clojure</a></em> we show an example of a macro called <code>defformula</code> that allows you to define spreadsheet-like cells in Clojure using <a href="http://blog.fogus.me/2011/09/23/clojurescript-watchers-and-validators/">watchers</a>.  For that example we intentionally required that the formulas defined be preceded by a binding vector, like so:</p>

<pre>(defformula avg [at-bats ab hits h]
  (float (/ @hits @at-bats)))
</pre>

<p>This allowed us to tie formula-internal variable names with existing reference types without requiring our implementation to garner the ties programmatically.  The point of that section had to do with <a href="http://en.wikipedia.org/wiki/Observer_pattern">the Observer Pattern</a>, so we didn’t want to clutter the discussion with other concerns.  However, we can use the same example to illustrate deep code-walking macros (DCWM) and doing so will lead to a different implementation.  For this post I’ll talk about only two types<sup id="fnref:3"><a href="#fn:3" rel="footnote">4</a></sup> of DCWMs, namely: additive transformers and in-place transformers.</p>

<h2>Deep walking for additive transforms</h2>

<p>The <code>defformula</code> macro in <a href="http://www.joyofclojure.com">The Joy of Clojure</a> was indeed an additive transformer.  That is, the macro took an expression and augmented it with additional stuff, specifically calls to <code>add-watch</code>.  However, having the binding vector allowed us to assume reference type dereferencing forms (things like <code>@foo</code>).  However, if I want to infer dereferencing forms within an expression then I will need to dive into it and find them.  To do that I’d first like to have a function <code>deref-form?</code> that takes something and checks if it’s a dereferencing form, implemented below:</p>

<pre>(ns formulas 
  (:require [clojure.walk :as walk]))

(defn deref-form? [form]
  (boolean
    (when (seq? form)       ;; &lt;1&gt;                                                                                       
      (let [[op &amp; _] form]
        (and
         op
         (symbol? op)
         (or                 ;; &lt;2&gt;                                                                                      
          (= op &#39;deref)
          (= op &#39;clojure.core/deref)))))))
</pre>

<ol>
<li>Only work on seqs</li>
<li>Check for <code>deref</code> calls</li>
</ol>

<p>You’ll notice that the <code>deref-form</code> assumes that the <code>form</code> given is a read-expanded dereferencing form rather than a <a href="http://clojure.org/reader">reader-macro</a> for (i.e. <code>(deref foo)</code> rather than <code>@foo</code>).  Given that assumption, it’ll work as follows:</p>

<pre>(deref-form? 42)
;;=&gt; false

(deref-form? [deref :foo])
;;=&gt; false

(deref-form? (quote (deref foo)))
;;=&gt; true

(deref-form? `(deref foo))
;;=&gt; true
</pre>

<p>Seems right.  Now that I can identify a dereferencing form I’d like to dive into an expression and gather up all of the names that serve as the target in said dereferencing forms.  The function to do this very task named <code>find-derefs</code> is implemented below:</p>

<pre>(defn find-derefs [expr]
  (if (coll? expr)
    (-&gt;&gt; expr
         walk/macroexpand-all  ;; &lt;1&gt;                                                                                  
         (tree-seq coll? seq)  ;; &lt;2&gt;                                                                                  
         (filter deref-form?)  ;; &lt;3&gt;                                                                                  
         (map second)          ;; &lt;4&gt;                                                                                  
         set)                  ;; &lt;5&gt;                                                                                  
    #{}))
</pre>

<ol>
<li>Expand all sub-forms</li>
<li>Build a seq of all composite forms</li>
<li>Take only the <code>deref</code> forms</li>
<li>Take only their operands</li>
<li>Make a set out of them</li>
</ol>

<p>You’ll notice that with the use of <code>walk/macroexpand-all</code> I can ensure that any nested <code>@foo</code>s are turned into the equivalent <code>(clojure.core/deref foo)</code> calls.  This lets me build up a set of the embedded dereferenced targets in expressions:</p>

<pre>(find-derefs :a)
;;=&gt; #{}

(find-derefs 42)
;;=&gt; #{}

(find-derefs [])
;;=&gt; #{}

(find-derefs &#39;(inc @c1))
;;=&gt; #{c1}

(find-derefs &#39;[{:foo @bar, :baz [@quux]}])
;;=&gt; #{quux bar}
</pre>

<p>The <code>find-derefs</code> function basically builds the information that the binding form in JoC provided explicitly.  Now that I can get at the names embedded in an expression, I can now implement a macro to build spreadsheet-like formulas whose values are dependent on the embedded references within:</p>

<pre>(defmacro formula [expr]
  `(let [formula#   (agent ~expr)               ;; &lt;1&gt;                                                               
         update-fn# (fn [key# ref# o# n#]       ;; &lt;2&gt;                                                               
                      (send formula#
                            (fn [_#] ~expr)))]
     (doseq [r# ~(find-derefs expr)]            ;; &lt;3&gt;
       (add-watch r#                            ;; &lt;4&gt;
         :update-formula
         update-fn#))

     formula#))
</pre>

<ol>
<li>Set the Agent’s initial value based on result of the formula</li>
<li>Build a function to update the Agent with the new formula calculation</li>
<li>For every internal dereference in <code>expr</code>…</li>
<li>… build a call setting a watcher that updates the formula value on change</li>
</ol>

<p>The body of a <code>formula</code> is just an expression that depends on zero or more embedded dereferences.  Not only does <code>formula</code> deeply walk the expression to find the dereferences, but it also augments a normal call to <code>agent</code> (holding the result of the formula) with calls to <code>add-watch</code> on the embedded (i.e. its dependents) reference types that automatically update the <code>formula</code>‘s value whenever any of its dependents change.  That is, rather than just define an Agent that holds the result of some expression like <code>(agent (float (/ @hits @at-bats)))</code> the <code>formula</code> macro builds something like the following:</p>

<pre>(let* [formula (agent (float (/ (deref hits) 
                                (deref at-bats))))
       update-fn (fn [key ref o n]
                   (send formula
                     (fn [_]
                       (float (/ (deref hits) 
                                 (deref at-bats))))))]
   (doseq [r #{hits at-bats}]
     (add-watch r :update-formula update-fn))

   formula)
</pre>

<p>That’s quite a transformation!  Because of this transformation <code>formula</code> allows you to do the following:</p>

<pre>(def hits (ref 25))
(def at-bats (ref 100))

(def avg (formula (float (/ @hits @at-bats))))

@avg
;;=&gt; 0.25
</pre>

<p>As shown, the <code>avg</code> formula holds the result of the division of the numbers stored in the Refs <code>hits</code> and <code>at-bats</code>.  What is so cool about DCWMs is that they <strong>allow me to define rich semantics</strong> for the simple <code>formula</code> expression and augment it with spreadsheet-like capabilities:</p>

<pre>(dosync
  (alter at-bats inc)
  (alter hits inc))

@avg
;;=&gt; 0.25742576
</pre>

<p>As shown, changing the values stored in the Refs automatically updates the value stored in the formula <code>avg</code>.  This is cool stuff, but that’s not all as I’ll show below.</p>

<h2>Deep walking for in-place transforms</h2>

<p>Not only can I change the semantics of an expression using a DCWM, but I can also completely transform the expression as it’s traversed.  Assume that for whatever reason I wanted to not deal directly with the embedded references inside of a formula.  Instead, I want to refer to them through the Vars that hold them.  That is, instead of doing this:</p>

<pre>(float (/ (clojure.core/deref hits) 
          (clojure.core/deref at-bats)))
</pre>

<p>I want to do this:</p>

<pre>(float (/ @@#&#39;hits @@#&#39;at-bats))
</pre>

<p>What that odd looking carrier-lost-like menagerie means is:</p>

<pre>@      @      #&#39;hits
deref  deref  get the Var holding the reference
</pre>

<p>Or:</p>

<ul>
<li>Get the Var</li>
<li>Dereference it</li>
<li>Then dereference whatever it held</li>
</ul>

<p>As an intermediate step toward transforming dereferencing calls into this indirect Var-lookup, I’ll use the <code>clojure.walk/postwalk-replace</code> function to insert some magic, like so:</p>

<pre>(defn via-magic [expr]
  (walk/postwalk-replace        ;; &lt;1&gt;
    &#39;{clojure.core/deref magic  ;; &lt;2&gt;
      deref magic}
    expr))
</pre>

<p>You can see what <code>via-magic</code> does below:</p>

<pre>(via-magic (quote (float (/ @hits @at-bats))))

;;=&gt; (float (/ (magic hits) (magic at-bats)))
</pre>

<p>So it just replaces the symbol <code>deref</code> with the symbol <code>magic</code> — nothing drastic.  The cool part is that I can implement <code>magic</code> as a macro that itself transforms a symbolic name<sup id="fnref:4"><a href="#fn:4" rel="footnote">5</a></sup> into a series of calls like the one shown before:</p>

<pre>(defmacro magic [ref-name]
  `(let [v# (resolve (quote ~ref-name))] ;; &lt;1&gt;
     (deref (deref v#))))                ;; &lt;2&gt;
</pre>

<ol>
<li>Look up the Var by symbol</li>
<li>Dereference the Var first, then dereference what it contained</li>
</ol>

<p>The transformation above ensures that any time a dereference occurs it happens <em>through the Var</em> rather than directly.  You’ll notice that if I use <code>magic</code> directly I’ll get the same answer:</p>

<pre>(magic at-bats)
;;=&gt; 101
</pre>

<p>Because <code>magic</code> will eventually get me the value stored in the Var-held reference type, I can interpose its use within a new version of the <code>formula</code> macro at the right place:</p>

<pre>(defmacro formula [expr]
  `(let [formula#   (agent ~expr)          ;; &lt;1&gt;
         update-fn# 
          (fn [key# ref# o# n#]            ;; &lt;2&gt;
            (send formula#
                  (fn [_#]
                    ~(via-magic expr))))]  ;; &lt;3&gt;
     (doseq [r# ~(find-derefs expr)]
       (add-watch r#                       ;; &lt;4&gt;
                  :update-formula
                  update-fn#))

     formula#))
</pre>

<ol>
<li>Assume Vars exist for the initial value, so don’t use <code>magic</code></li>
<li>Build the updating watch function like before, except…</li>
<li>… use <code>magic</code> to look up through the Var</li>
<li>Again add watches to all of the dereferencing sub-forms</li>
</ol>

<p>You’ll notice that I only chose to lookup through the Vars in one place, namely, the point of update of the <code>formula</code> itself.  There would be problems if I re-define either of the <code>formula</code>‘s dependencies.  That is, the update will break because the new embedded reference will not have the needed watchers.  In any case, the new implementation of <code>formula</code> works like the old:</p>

<pre>(def hits (ref 25))
(def at-bats (ref 100))

(def avg (formula (float (/ @hits @at-bats))))

@avg
;;=&gt; 0.25

(dosync (alter hits #(+ 10 %))

@avg
;;=&gt; 0.35
</pre>

<p>The new <code>formula</code> macro, in addition to walking the expression to look for dereferncing forms, changed the call-sites of the embedded <code>deref</code>s at the point of update only.  Specifically it generated something like the following code:</p>

<pre>(let* [formula 
        (agent (float (/ (deref hits)        ;; &lt;1&gt;
                         (deref at-bats))))
       update-fn 
        (fn [key ref o n]
          (send formula
                (fn [_]
                  (float 
                    (/ (let* [v (resolve &#39;hits)] 
                         @@v)                ;; &lt;2&gt;
                       (let* [v (resolve &#39;at-bats)] 
                         @@v))))))]
   (doseq [r #{hits at-bats}]                ;; &lt;3&gt;         
     (add-watch r :update-formula update-fn))

   formula)
</pre>

<ol>
<li>Non-<code>magic</code> expansion</li>
<li>Using <code>magic</code> the Vars are looked up at the time of the formula’s update</li>
<li>Assume that the Var will never be re-bound</li>
</ol>

<p>I could make <code>formula</code> even more complicated by ensuring that even on a Var re-define the formula updates <em>and</em> the proper watches are applied to the new reference type, but I leave that as an exercise to the reader.<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup></p>

<p>I could probably go on<sup id="fnref:5"><a href="#fn:5" rel="footnote">7</a></sup> and on about deep code-walking macros, but I hope that this introduction gives an idea not only why they’re so powerful, but also why people (myself included) in the Clojure community are so excited by this technique.</p>

<p>Happy hacking!</p>

<p>:F</p>



            </div>
            <!-- end comments_wrapper -->            </div></div>
  </body>
</html>
