<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.fuzzbuzz.io/go-fuzzing-basics/">Original</a>
    <h1>Go Fuzz Testing</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/Article"><section itemprop="articleBody"><p>How many bugs can you find in this function? It looks simple enough - take a string, and overwrite the first <code>n</code> characters with a new user-defined character. For example, if we ran <code>OverwriteString(&#34;Hello, World!&#34;, &#34;A&#34;, 5)</code>, we would expect the output: <code>&#34;AAAAA, World!&#34;</code>.</p>
<div data-language="go"><pre><code>



<span>func</span> <span>OverwriteString</span><span>(</span>str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>string</span> <span>{</span>
	
	
	<span>if</span> n <span>&gt;</span> <span>len</span><span>(</span>str<span>)</span> <span>{</span>
		<span>return</span> strings<span>.</span><span>Repeat</span><span>(</span><span>string</span><span>(</span>value<span>)</span><span>,</span> <span>len</span><span>(</span>str<span>)</span><span>)</span>
	<span>}</span>

	result <span>:=</span> <span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span> <span>{</span>
		result<span>[</span>i<span>]</span> <span>=</span> value
	<span>}</span>
	<span>return</span> <span>string</span><span>(</span>result<span>)</span>
<span>}</span></code></pre></div>
<p>In the time it takes to give the code a quick visual once-over, <a href="https://go.dev/doc/fuzz/" target="_blank" rel="nofollow">Go’s new fuzz testing tool</a> can run over 5 million procedurally generated inputs through the function, and in this case find an input that causes an out-of-bounds array access in just <em>one second</em>.</p>
<p>It turns out running the function with this set of arguments: <code>OverwriteString(&#34;0000&#34;, rune(&#39;A&#39;), 4)</code> causes a panic:</p>
<div data-language="bash"><pre><code>--- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.05s<span>)</span>
    --- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.00s<span>)</span>
        testing.go:1349: panic: runtime error: index out of range <span>[</span><span>4</span><span>]</span> with length <span>4</span>
            goroutine <span>96</span> <span>[</span>running<span>]</span>:
            runtime/debug.Stack<span>(</span><span>)</span>
            	/home/everest/sdk/gotip/src/runtime/debug/stack.go:24 +0x90
            testing.tRunner.func1<span>(</span><span>)</span>
           <span>..</span>.<span>&lt;</span>snip<span>&gt;</span> 
    
    Failing input written to testdata/fuzz/FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f
    To re-run:
    go <span>test</span> -run<span>=</span>FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f</code></pre></div>
<p>Fuzz testing (or fuzzing) is a powerful testing technique that’s great at discovering bugs and vulnerabilities that developers typically miss, and has a strong track record of discovering <a href="https://github.com/dvyukov/go-fuzz#trophies" target="_blank" rel="nofollow">hundreds of critical bugs in open-source Go code</a>.</p>
<p>Extend our little example problem to a thousand-line codepath in a critical application, and a fuzzer churning through billions of inputs can take only a few minutes to discover subtle bugs that would otherwise take days to unravel in production. What follows is a first look at how to ramp up on Go’s latest testing tool and start discovering your own bugs as quickly as possible.</p>
<h2>Getting Started</h2>
<p>We’ll be using the new fuzz testing features in Go 1.18, so before we get started, make sure that your <code>$ go version</code> is at least 1.18. Head to <a href="https://go.dev/dl/" target="_blank" rel="nofollow">https://go.dev/dl</a> to update your <code>go</code> tool if you’re on an earlier version.</p>
<p>If you’d like to follow along, you can find the code for this post at <a href="https://github.com/fuzzbuzz/go-fuzzing-tutorial" target="_blank" rel="nofollow">github.com/fuzzbuzz/go-fuzzing-tutorial</a>. For the remainder of this tutorial, you can assume all commands you see are run from inside the <code>introduction</code> directory.</p>
<p>This is the most basic incarnation of a fuzz test: </p>
<div data-language="go"><pre><code>

<span>func</span> <span>FuzzBasicOverwriteString</span><span>(</span>f <span>*</span>testing<span>.</span>F<span>)</span> <span>{</span>
	f<span>.</span><span>Fuzz</span><span>(</span><span>func</span><span>(</span>t <span>*</span>testing<span>.</span>T<span>,</span> str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>{</span>
		<span>OverwriteString</span><span>(</span>str<span>,</span> value<span>,</span> n<span>)</span>
	<span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>Contrary to a unit test, which expects a specific behavior from a fixed input, a fuzz test runs thousands of procedurally generated inputs through the function it’s testing, without the developer needing to manually come up with inputs. In this specific case, we passed the function we wish to test to <code>f.Fuzz</code>, so the fuzzer will generate a new <code>string</code>, <code>rune</code>, and <code>int</code> to fill the arguments for each test iteration.</p>
<p>By default, fuzzing will detect crashes, hangs, and extreme memory usage, so even without writing any assertions we’ve already built a useful robustness test for our function.</p>
<p>To run this test, type:</p>
<div data-language="shell"><pre><code>go <span>test</span> -fuzz FuzzBasicOverwriteString</code></pre></div>
<p>Within about a second, you should see the test exit with an error signature similar to this:</p>
<div data-language="bash"><pre><code>--- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.05s<span>)</span>
    --- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.00s<span>)</span>
        testing.go:1349: panic: runtime error: index out of range <span>[</span><span>4</span><span>]</span> with length <span>4</span>
<span>..</span>.SNIP
    Failing input written to testdata/fuzz/FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f
    To re-run:
    go <span>test</span> -run<span>=</span>FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f</code></pre></div>
<p>The fuzzer provides the location of the specific input that caused the problem, inside the <code>testdata/fuzz/FuzzBasicOverwriteString</code> directory. If you open up this file, you can take a look at the actual values that caused our function to panic:</p>
<div data-language="bash"><pre><code>go <span>test</span> fuzz v1
string<span>(</span><span>&#34;00&#34;</span><span>)</span>
rune<span>(</span><span>&#39;A&#39;</span><span>)</span>
int<span>(</span><span>2</span><span>)</span></code></pre></div>
<p>Now that we’ve found a bug, we can go into our code and fix the problem. Taking a look at the line of code that actually caused the panic (<code>overwrite_string.go:16</code>), it seems the code tried to access index 4 of a string with length 4, which caused an array index out of range error. You can fix the bug by changing the <code>if n &gt; len(str)</code> check to test for greater than or equal to instead: <code>if n &gt;= len(str)</code>:</p>
<div data-language="go"><pre><code>



<span>func</span> <span>OverwriteString</span><span>(</span>str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>string</span> <span>{</span>
	
	
	<span>if</span> n <span>&gt;=</span> <span>len</span><span>(</span>str<span>)</span> <span>{</span>
		<span>return</span> strings<span>.</span><span>Repeat</span><span>(</span><span>string</span><span>(</span>value<span>)</span><span>,</span> <span>len</span><span>(</span>str<span>)</span><span>)</span>
	<span>}</span>

	result <span>:=</span> <span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span> <span>{</span>
		result<span>[</span>i<span>]</span> <span>=</span> value
	<span>}</span>
	<span>return</span> <span>string</span><span>(</span>result<span>)</span>
<span>}</span></code></pre></div>
<p>This will make sure the loop is only entered if <code>n</code> is at least 1 less than the string length. We <em>could</em> fix the for loop’s bounds as well, but that hides a more interesting bug later on, so for now, we can pretend it was overlooked. </p>
<p>Confirm this fixes the bug by re-running the crashing test case using the command the fuzzer provided in the output:</p>
<div data-language="bash"><pre><code>$ go <span>test</span> -v -count<span>=</span><span>1</span> -run<span>=</span>FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f

<span>==</span><span>=</span> RUN   FuzzBasicOverwriteString
<span>==</span><span>=</span> RUN   FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f
--- PASS: FuzzBasicOverwriteString <span>(</span><span>0</span>.00s<span>)</span>
    --- PASS: FuzzBasicOverwriteString/2bac7bdf139ad0b2de37275db2a606ecb335bd344500173b451e9dfc3658c12f <span>(</span><span>0</span>.00s<span>)</span>
PASS
ok  	github.com/fuzzbuzz/go-fuzzing-tutorial/introduction	<span>0</span>.001s</code></pre></div>
<p>Go’s fuzzer will automatically run each input in the <code>testdata</code> directory as a unit test any time <code>go test</code> is run (these inputs are collectively called “seeds”). Committing the <code>testdata</code> directory to version control will save this input as a permanent regression test to ensure the bug is never reintroduced.</p>
<h2>A Happy Accident</h2>
<p>Now, I will fully admit that as I was writing this, I expected this change to satisfy the basic fuzz test, but if you re-run the fuzzer after this change you’ll notice that an entirely new bug manifests:</p>
<div data-language="bash"><pre><code>$ go <span>test</span> -fuzz FuzzBasicOverwriteString
fuzz: elapsed: 0s, gathering baseline coverage: <span>0</span>/17 completed
fuzz: elapsed: 0s, gathering baseline coverage: <span>17</span>/17 completed, now fuzzing with <span>8</span> workers
fuzz: minimizing <span>177</span>-byte failing input <span>file</span>
fuzz: elapsed: 0s, minimizing
--- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.17s<span>)</span>
    --- FAIL: FuzzBasicOverwriteString <span>(</span><span>0</span>.00s<span>)</span>
        testing.go:1349: panic: runtime error: index out of range <span>[</span><span>60</span><span>]</span> with length <span>60</span>
            goroutine <span>2911</span> <span>[</span>running<span>]</span>:
            runtime/debug.Stack<span>(</span><span>)</span>
            	/home/everest/sdk/gotip/src/runtime/debug/stack.go:24 +0x90
            testing.tRunner.func1<span>(</span><span>)</span>
            	/home/everest/sdk/gotip/src/testing/testing.go:1349 +0x1f2
            panic<span>(</span><span>{</span>0x5b3700, 0xc00289c798<span>}</span><span>)</span>
            	/home/everest/sdk/gotip/src/runtime/panic.go:838 +0x207
            github.com/fuzzbuzz/go-fuzzing-tutorial/introduction.OverwriteString<span>(</span><span>{</span>0xc00288ef00, 0x3d<span>}</span>, 0x83, 0x3c<span>)</span>
            	/home/everest/src/fuzzbuzz/go-fuzzing-tutorial/introduction/overwrite_string.go:20 +0x270
            github.com/fuzzbuzz/go-fuzzing-tutorial/introduction.FuzzBasicOverwriteString.func1<span>(</span>0x5?, <span>{</span>0xc00288ef00?, 0x0?<span>}</span>, 0x0?, 0x0?<span>)</span>
            	/home/everest/src/fuzzbuzz/go-fuzzing-tutorial/introduction/overwrite_string_test.go:24 +0x38
            reflect.Value.call<span>(</span><span>{</span>0x598d60?, 0x5cfb58?, 0x13?<span>}</span>, <span>{</span>0x5c179f, 0x4<span>}</span>, <span>{</span>0xc0028c2de0, 0x4, 0x4?<span>}</span><span>)</span>
            	/home/everest/sdk/gotip/src/reflect/value.go:556 +0x845
            reflect.Value.Call<span>(</span><span>{</span>0x598d60?, 0x5cfb58?, 0x514?<span>}</span>, <span>{</span>0xc0028c2de0, 0x4, 0x4<span>}</span><span>)</span>
            	/home/everest/sdk/gotip/src/reflect/value.go:339 +0xbf
            testing.<span>(</span>*F<span>)</span>.Fuzz.func1.1<span>(</span>0x0?<span>)</span>
            	/home/everest/sdk/gotip/src/testing/fuzz.go:337 +0x231
            testing.tRunner<span>(</span>0xc0028e7380, 0xc0028ec5a0<span>)</span>
            	/home/everest/sdk/gotip/src/testing/testing.go:1439 +0x102
            created by testing.<span>(</span>*F<span>)</span>.Fuzz.func1
            	/home/everest/sdk/gotip/src/testing/fuzz.go:324 +0x5b8
            
    
    Failing input written to testdata/fuzz/FuzzBasicOverwriteString/2ee896e38866e089811eeece13f9919795072e6cc05ee9f782d68d1663d204c7
    To re-run:
    go <span>test</span> -run<span>=</span>FuzzBasicOverwriteString/2ee896e38866e089811eeece13f9919795072e6cc05ee9f782d68d1663d204c7
FAIL
<span>exit</span> status <span>1</span>
FAIL	github.com/fuzzbuzz/go-fuzzing-tutorial/introduction	<span>0</span>.174s</code></pre></div>
<p>The actual input the fuzzer generated may look different in your case, but this is the test case that was generated for me:</p>
<div data-language="go"><pre><code><span>go</span> test fuzz v1
<span>string</span><span>(</span><span>&#34;000000000000000000000000000000Ö00000000000000000000000000000&#34;</span><span>)</span>
<span>rune</span><span>(</span><span>&#39;\u0083&#39;</span><span>)</span>
<span>int</span><span>(</span><span>60</span><span>)</span></code></pre></div>
<p>At first glance, this bug looks almost exactly like the one you just fixed. Trying to access index 60 of a 60-character long string shouldn’t be possible, since the function would return at the initial if statement. But herein lies the power of fuzzing - it uncovers edge cases developers haven’t considered, and this is in fact an entirely separate bug. </p>
<p>If you inspect your crashing input you’ll likely notice, like mine, that one of the characters is a Unicode character. That is, it is represented by more than one byte. In my case, it’s <code>Ö</code>. Sure, this input string is 60 characters long, but it’s <em>61 bytes long</em>. And it turns out that in Go, taking the <code>len</code> of a string returns the number of <em>bytes</em> in the string, not the number of characters (or runes, to use Go’s terminology).</p>
<p>This is easy to check for yourself. If you run the following snippet of Go code:</p>
<div data-language="go"><pre><code>str <span>:=</span> <span>&#34;Ö&#34;</span>
runeArray <span>:=</span> <span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span>
fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Str len:&#34;</span><span>,</span> <span>len</span><span>(</span>str<span>)</span><span>,</span> <span>&#34;Rune array len:&#34;</span><span>,</span> <span>len</span><span>(</span>runeArray<span>)</span><span>)</span></code></pre></div>
<p>You’ll see the following output:</p>
<div data-language="bash"><pre><code>Str len: <span>2</span> Rune array len: <span>1</span></code></pre></div>
<p>With that information about Go’s string implementation top-of-mind, rewrite the if statement again, from <code>if n &gt;= len(str)</code> to <code>if n &gt;= utf8.RuneCountInString(str)</code>. We want to compare apples to apples, or in this case, quantities of characters to characters, not bytes:</p>
<div data-language="go"><pre><code>



<span>func</span> <span>OverwriteString</span><span>(</span>str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>string</span> <span>{</span>
	
	
	<span>if</span> n <span>&gt;=</span> utf8<span>.</span><span>RuneCountInString</span><span>(</span>str<span>)</span> <span>{</span>
		<span>return</span> strings<span>.</span><span>Repeat</span><span>(</span><span>string</span><span>(</span>value<span>)</span><span>,</span> <span>len</span><span>(</span>str<span>)</span><span>)</span>
	<span>}</span>

	result <span>:=</span> <span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span> <span>{</span>
		result<span>[</span>i<span>]</span> <span>=</span> value
	<span>}</span>
	<span>return</span> <span>string</span><span>(</span>result<span>)</span>
<span>}</span></code></pre></div>
<p>Run the fuzz test once more, and watch it churn away, attempting to find another input to crash our function:</p>
<div data-language="shell"><pre><code>go <span>test</span> -fuzz FuzzBasicOverwriteString</code></pre></div>
<p>You <em>should</em> let this run for a while to make sure that there aren’t any other bugs lurking around, but you can at least be confident that the function doesn’t crash on the most basic of inputs. You can press <code>ctrl-C</code> to stop the fuzzer.</p>
<h2>Functional Bugs</h2>
<p>Up to this point, we’ve found bugs that result in crashes. Denial of service is a big deal, but all we know is that this function doesn’t crash on unexpected inputs. It’s also important to test the <em>correctness</em> of the function. There are a number of ways to approach this, but with fuzz testing, it’s best to try to think of a <em>an invariant (or property)</em> that will always hold true for your code. </p>
<p>An example of an invariant for <code>OverwriteString</code> is that the function should never fill <em>more</em> characters than the number it’s asked to. More concretely, if asked to overwrite “Hello, world!” with 5 “A” characters, it should be possible to check that the remaining characters in the string are still “, world!”.</p>
<p>This can be generalized with the following test:</p>
<div data-language="go"><pre><code>

<span>func</span> <span>FuzzOverwriteStringSuffix</span><span>(</span>f <span>*</span>testing<span>.</span>F<span>)</span> <span>{</span>
	f<span>.</span><span>Add</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>,</span> <span>&#39;A&#39;</span><span>,</span> <span>15</span><span>)</span>

	f<span>.</span><span>Fuzz</span><span>(</span><span>func</span><span>(</span>t <span>*</span>testing<span>.</span>T<span>,</span> str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>{</span>
		result <span>:=</span> <span>OverwriteString</span><span>(</span>str<span>,</span> value<span>,</span> n<span>)</span>
		<span>if</span> n <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> n <span>&lt;</span> utf8<span>.</span><span>RuneCountInString</span><span>(</span>str<span>)</span> <span>{</span>
			
			resultSuffix <span>:=</span> <span>string</span><span>(</span><span>[</span><span>]</span><span>rune</span><span>(</span>result<span>)</span><span>[</span>n<span>:</span><span>]</span><span>)</span>
			strSuffix <span>:=</span> <span>string</span><span>(</span><span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span><span>[</span><span>:</span><span>]</span><span>)</span>
			<span>if</span> resultSuffix <span>!=</span> strSuffix <span>{</span>
				t<span>.</span><span>Fatalf</span><span>(</span><span>&#34;OverwriteString modified too many characters! Expected %s, got %s.&#34;</span><span>,</span> strSuffix<span>,</span> resultSuffix<span>)</span>
			<span>}</span>
		<span>}</span>
	<span>}</span><span>)</span>
<span>}</span></code></pre></div>
<p>Running the test will produce another bug:</p>
<div data-language="bash"><pre><code>$ go <span>test</span> -fuzz FuzzOverwriteStringSuffix

fuzz: elapsed: 0s, gathering baseline coverage: <span>0</span>/54 completed
fuzz: minimizing <span>66</span>-byte failing input <span>file</span>
fuzz: elapsed: 0s, gathering baseline coverage: <span>8</span>/54 completed
--- FAIL: FuzzOverwriteStringSuffix <span>(</span><span>0</span>.03s<span>)</span>
    --- FAIL: FuzzOverwriteStringSuffix <span>(</span><span>0</span>.00s<span>)</span>
        overwrite_string_test.go:38: OverwriteString modified too many characters<span>!</span> Expected <span>0</span>, got A.
    
    Failing input written to testdata/fuzz/FuzzOverwriteStringSuffix/148139e8febb077401421c031a9bd3c3315179c5a66c90349102d223b451ec02
    To re-run:
    go <span>test</span> -run<span>=</span>FuzzOverwriteStringSuffix/148139e8febb077401421c031a9bd3c3315179c5a66c90349102d223b451ec02
FAIL
<span>exit</span> status <span>1</span>
FAIL	github.com/fuzzbuzz/go-fuzzing-tutorial/introduction	<span>0</span>.031s</code></pre></div>
<p>Note that this time it’s not a panic, but instead a message that looks very similar to a unit test failure. It turns out there’s been a functional bug in this code the whole time.</p>
<p>Since it checks if the loop index is <code>&lt;=</code> on line 20, it’s been filling in one too many characters without realizing it. Changing the loop condition from <code>i &lt;= n</code> to <code>i &lt; n</code> solves this problem.</p>
<p>The final <code>OverwriteString</code> function should look like this:</p>
<div data-language="go"><pre><code>



<span>func</span> <span>OverwriteString</span><span>(</span>str <span>string</span><span>,</span> value <span>rune</span><span>,</span> n <span>int</span><span>)</span> <span>string</span> <span>{</span>
	
	
	<span>if</span> n <span>&gt;=</span> utf8<span>.</span><span>RuneCountInString</span><span>(</span>str<span>)</span> <span>{</span>
		<span>return</span> strings<span>.</span><span>Repeat</span><span>(</span><span>string</span><span>(</span>value<span>)</span><span>,</span> <span>len</span><span>(</span>str<span>)</span><span>)</span>
	<span>}</span>

	result <span>:=</span> <span>[</span><span>]</span><span>rune</span><span>(</span>str<span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span> <span>{</span>
		result<span>[</span>i<span>]</span> <span>=</span> value
	<span>}</span>
	<span>return</span> <span>string</span><span>(</span>result<span>)</span>
<span>}</span></code></pre></div>
<p>If you run the fuzzer once more, you should be greeted with the fuzzer reliably running thousands of inputs per second without discovering another bug. </p>
<p>Ideally this fuzz test would run for at least a few minutes to increase confidence in this code’s correctness (especially if it were testing more than a 10 line function). </p>
<p>The bugs in this post were found in a few seconds, but some bugs can take hours or days of fuzzing as the fuzzer needs time to explore the entire state space of the software under test. We’ll cover the art of continuous fuzzing at scale in a follow-up post in the next few weeks.</p>
<h2>Wrapping up</h2>
<p>This was just a brief introduction to fuzz testing with Go. There are more advanced topics we could get into, but the examples discussed today are really all you need to start adding fuzz tests to your own projects. </p>
<p>In the coming weeks we’ll dive deeper into the types of bugs you can find, investigate some real-world fuzzing bugs, and discuss how to automate your fuzzing so that CI finds bugs while you’re asleep. You can subscribe to our updates below to get notified when the next part comes out.</p>
<p>In the meantime, if you’d like to take this tutorial a little further, consider that we’ve only written a fuzz test that checks the part of the string we <em>shouldn’t</em> change. How would you write a fuzz test that confirms that we’ve actually modified the desired characters correctly?</p></section></article></div>
  </body>
</html>
