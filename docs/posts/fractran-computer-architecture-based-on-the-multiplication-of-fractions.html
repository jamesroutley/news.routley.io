<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiki.xxiivv.com/site/fractran.html">Original</a>
    <h1>Fractran: Computer architecture based on the multiplication of fractions</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Fractran is a computer architecture based entirely on the multiplication of fractions.</h2>

<p>A <b>prime</b> is a number that can only be divided by itself one, since these
numbers can&#39;t be divided, they can considered the DNA of other numbers. The
factoring of a number into <a href="https://wiki.xxiivv.com/site/primes.html">prime numbers</a>, for example: 18 = 2 × 3<sup>2</sup>,
exposes values which Fractran utilizes as <i>registers</i>. There are two parts to a Fractran program:</p>

<ol>
	<li><a href="#acc">The Accumulator</a></li>
	<li><a href="#rules">The Fractions</a></li>
</ol>

<figure>
	<img src="https://wiki.xxiivv.com/media/refs/vogue-fractran.jpg" width="300" alt="流行通信"/>
	<figcaption>Typical Fractran Programmer</figcaption>
</figure>

<h3 id="acc">The Accumulator</h3>

<table>
	<tbody><tr><th rowspan="2">Accumulator</th><th colspan="4">Registers</th></tr>
	<tr><th>r2</th><th>r3</th><th>r5</th><th>r7</th></tr>
	<tr><th>6</th><td>1</td><td>1</td><td></td><td></td></tr>
	<tr><th>18</th><td>1</td><td>2</td><td></td><td></td></tr>
	<tr><th>1008</th><td>4</td><td>2</td><td></td><td>1</td></tr>
	<tr><th>5402250</th><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</tbody></table>

<p>The <b>Accumulator</b> is a single number whose prime factorization holds the
value of registers(2, 3, 5, 7, 11, 13, 17, ..). For example, if the state of
the accumulator is 1008(2⁴ × 3² × 7), r2 has the value 4, r3 has the value
2, r7 has the value 1, and all other registers are unassigned.</p>

<h3>The Fraction</h3>

<img src="https://wiki.xxiivv.com/media/refs/fractran.adder1.png" width="140px"/>

<p>A <b>Fraction</b> represents an instruction that tests one or more
registers by the prime factors of its numerator and denominator. To evaluate
the result of a rule we take the the accumulator, if multiplying it by this
<a href="https://wiki.xxiivv.com/site/fractions.html">fraction</a> will give us an integer, we will update the accumulator with the
result.</p>

<table>
	<tbody><tr>
		<th>2/3</th>
		<th>15/256</th>
		<th>21/20</th>
	</tr>
	<tr>
		<td>(<span>2</span><sup>1</sup>)/(<span>3</span><sup>1</sup>)</td>
		<td>(<span>3</span><sup>1</sup> × <span>5</span><sup>1</sup>)/(<span>2</span><sup>6</sup>)</td>
		<td>(<span>3</span><sup>1</sup> × <span>7</span><sup>1</sup>)/(<span>2</span><sup>2</sup> × <span>5</span><sup>1</sup>)</td>
	</tr>
	<tr>
		<td>
<pre>if(<span>r3</span> &gt;= <span>1</span>){ 
	<span>r3</span> -= <span>1</span>;
	<span>r2</span> += <span>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>if(<span>r2</span> &gt;= <span>6</span>){ 
	<span>r2</span> -= <span>6</span>;
	<span>r3</span> += <span>1</span>;
	<span>r5</span> += <span>1</span>;
	return;
}</pre>
		</td>
		<td>
<pre>if(<span>r2</span> &gt;= <span>2</span> &amp;&amp; <span>r5</span> &gt;= <span>1</span>){ 
	<span>r2</span> -= <span>2</span>; 
	<span>r5</span> -= <span>1</span>; 
	<span>r3</span> += <span>1</span>; 
	<span>r7</span> += <span>1</span>;
	return;
}</pre>
		</td>
	</tr>
</tbody></table>

<p>Operations become more readable when broken down into their primes. We can
think of every prime number as having a register which can take on non-negative
integer values. Each fraction is an instruction that operates on some of the
registers.</p>

<h3 id="notation">A Notation</h3>

<p>While Fractran is commonly reduced to just another opaque esoteric language,
portraying it as such is doing a disservice to the relatively simple idea at
its core and to the researchers who might otherwise benefit by venturing deeper
into a relatively unexplored field of computation.</p>

<p><a href="https://wryl.tech" target="_blank">Wryl</a>, who created <a href="https://wiki.xxiivv.com/site/modal.html">Modal</a>, demonstrated to me an interesting connection between Fractran and <a href="https://wiki.xxiivv.com/site/rewriting.html">rewriting languages</a>. We need only to compile our rules and point the prime registers to symbols in a dictionary to see this relationship more clearly.</p>

<pre>:: left side &gt; right side  <i>15/6 left.2 side.3 &gt; side.3 right.5</i>

AC 6 left side  <i>accumulator</i>
00 6 × 15/6 = 15, side right  <i>result</i>
</pre>

<p>This documentation will represent registers with names(x, y, foo-bar, baz, ..). Fractions will be
written as rewrite rules starting with <code>::</code>, a left-side, a
spacer(&gt;) and a right-side. The notation indicates which registers to replace
on the left-side, and what to replace them with on the right-side.</p>

<img src="https://wiki.xxiivv.com/media/refs/fractran.multiply.png" width="220px"/>

<h3>Programming In Fractran</h3>

<p>In a rule definition, which is a fraction where prime factorization is written as symbols, we find symbols to the left-side of the spacer(&gt;) to be rewritten by what is found on the right-side. Each new symbol is added to the dictionary and represented internally as a prime number.</p>

<pre>:: flour sugar apples &gt; apple-cake
:: apples oranges cherries &gt; fruit-salad
:: fruit-salad apple-cake &gt; fruit-cake

sugar oranges apples cherries flour apples
</pre>

<p>Rules are tested in a sequence from the first to the last, when a valid rewrite rule is encountered, the accumulator is updated by the product of the multiplication of the accumulator with the fraction, and search for the next rule starts back again from the beginning.</p>
<p>In other words, it helps to visualize the fractions in a program as a list of rewrite rules that tests the accumulator against its left-side, and starts back at the top of the list after updating the accumulator when it is a match, or keep going when it does not.</p>

<pre>AC 21450 flour sugar apples apples oranges cherries 
00 21450 × 7/30 = 5005, apples apple-cake oranges cherries 
01 5005 × 17/715 = 119, apple-cake fruit-salad 
02 119 × 19/119 = 19, fruit-cake 
</pre>

<p>Fractran has a single operation(multiply), and can be explained in 10 seconds. John Conway proposed this programming system as a way to cut through the complexity of other computation paradigms.</p>

<ul>
    <li>For each fraction in a list for which the multiplication of the accumulator and the fraction is an integer, replace the accumulator by the result of that multiplication.</li>
    <li>Repeat this rule until no fraction in the list produces an integer when multiplied by the accumulator, then halt.</li>
</ul>

<p>That&#39;s all!</p>

<figure>
	<img src="https://wiki.xxiivv.com/media/refs/fractran.png" width="340"/>
	<figcaption>The Book of Numbers, <a href="https://en.wikipedia.org/wiki/John_Horton_Conway" target="_blank">John Conway</a></figcaption>
</figure>

<h3>Logic &amp; Arithmetic</h3>

<p>Logic in rewrite rules is typically implemented as multiple rules, where each one is a potential location in the <a href="https://wiki.xxiivv.com/site/logic.html">truth table</a>, here is <b>logical and</b> between two registers(x&amp;y) as example:</p>

<pre>:: x y and &gt; true
:: x and &gt; false
:: y and &gt; false

AC 30 x y and 
00 30 × 7/30 = 7, true
</pre>

<p>You can get the <b>sum</b> of two registers(x+y) by moving the value of one register into the other. The <i>naming</i> of the x register in advance ensures that the highest number will be stored in the lowest register:</p>

<pre>:: x
:: y &gt; x

AC 144 x^4 y^2
00 144 × 2/3 = 96, x^5 y
00 96 × 2/3 = 64, x^6
</pre>

<p>You can get the <b>difference</b> between two registers(x-y) by consuming the value of two registers at once, and moving the remains to the first:</p>

<pre>:: x y &gt;
:: y &gt; x

AC 576 x^6 y^2
00 576 × 1/6 = 96, x^5 y 
00 96 × 1/6 = 16, x^4
</pre>

<p>You can get the <b>product</b> of two registers(x*y) by keeping an intermediate result and state register. Keeping the resulting product, by <i>naming</i> the first register for the result, prevents the accumulator grow too much in size:</p>

<pre>:: r acc x y

:: iter acc &gt; x iter
:: iter &gt;
:: x y &gt; r acc y 
:: y &gt; iter
:: x &gt; 

AC 8575 x^2 y^2
.. r^6
</pre>

<p>Similarly to the multiplication, you can get the <b>quotient</b> and <b>remainder</b> of two registers(x/y) by doing a series of subtractions:</p>

<pre>:: x y res rem div1 acc1 div2 acc2

:: x y div1 &gt; rem acc1
:: acc1 &gt; div1
:: y div1 &gt; 
:: div1 &gt; res div2
:: rem div2 &gt; y acc2
:: acc2 &gt; div2
:: div2 &gt; div1
:: y &gt;

AC x^7 y^2 div1
.. res^3 rem
</pre>

<h3>Example: Tic-Tac-Toe</h3>

<p>To handle <b>output</b>, nothing special is to be done, the resulting accumulator at the end of an evaluation is a valid output value, some have offered schemes like <a href="https://malisper.me/building-fizzbuzz-fractran-bottom/" target="_blank">assigning an alphabet</a> to a series of registers. The advantage with symbolic rewriting is that registers are already assigned whole tokens, so we shall use those instead.</p>

<p>To handle <b>input</b>, we can type in new symbol tokens and appending their value to the accumulator when evaluation halts. We can implement a <i>tic-tac-toe</i> in a mere 16 rules:</p>

<pre><i>Reserve the first registers for the player moves:</i>

:: x#a o#a x#b o#b x#c o#c
:: x#d o#d x#e o#e x#f o#f
:: x#g o#g x#h o#h x#i o#i

<i>This register remains active until the game ends:</i>

game

<i>A symbol to draw the value of registers in a grid:</i>

&#34;

  Set move in the format x#a, o#b, x#c, etc:

  a b c  |  {x#a o#a .} {x#b o#b .} {x#c o#c .}
  d e f  |  {x#d o#d .} {x#e o#e .} {x#f o#f .}
  g h i  |  {x#g o#g .} {x#h o#h .} {x#i o#i .}

 &#34;

<i>Rules for each possible victory states:</i>

:: game x#a x#b x#c &gt; x#a x#b x#c &#34;Player X wins!&#34; 
:: game o#a o#b o#c &gt; o#a o#b o#c &#34;Player O wins!&#34;
:: game x#d x#e x#f &gt; x#d x#e x#f &#34;Player X wins!&#34; 
:: game o#d o#e o#f &gt; o#d o#e o#f &#34;Player O wins!&#34;
:: game x#g x#h x#i &gt; x#g x#h x#i &#34;Player X wins!&#34; 
:: game o#g o#h o#i &gt; o#g o#h o#i &#34;Player O wins!&#34;
:: game x#a x#e x#i &gt; x#a x#e x#i &#34;Player X wins!&#34; 
:: game o#a o#e o#i &gt; o#a o#e o#i &#34;Player O wins!&#34;
:: game x#g x#e x#c &gt; x#g x#e x#c &#34;Player X wins!&#34; 
:: game o#g o#e o#c &gt; o#g o#e o#c &#34;Player O wins!&#34;
:: game x#a x#d x#g &gt; x#a x#d x#g &#34;Player X wins!&#34; 
:: game o#a o#d o#g &gt; o#a o#d o#g &#34;Player O wins!&#34;
:: game x#b x#e x#h &gt; x#b x#e x#h &#34;Player X wins!&#34; 
:: game o#b o#e o#h &gt; o#b o#e o#h &#34;Player O wins!&#34;
:: game x#c x#f x#i &gt; x#c x#f x#i &#34;Player X wins!&#34; 
:: game o#c o#f o#i &gt; o#c o#f o#i &#34;Player O wins!&#34;
</pre>

<p>Program don&#39;t need to specify anything other than these 16 rules, as players can already input their moves in the format of its register names: x#a, o#b, x#c, etc.</p>

<pre>  Set move in the format x#a, o#b, x#c, etc:

  a b c  |  x o o
  d e f  |  . x .
  g h i  |  . . x

  Player X wins!
</pre>


<h3>Notes</h3>

<p>Fractran operators are <a href="https://wiki.xxiivv.com/site/reversible_computing.html">reversible</a>, meaning that some programs can be run backward, back to its original state. To undo an operation, evaluation is undone by inverting the numerator and denumerator:</p>

<pre>AC 19, fruit-cake
02 19 × 119/19 = 119, apple-cake fruit-salad
01 119 × 715/17 = 5005, apples apple-cake oranges cherries
00 5005 × 30/7 = 21450, apples apples flour sugar oranges cherries
</pre>

<p>To explore Fractran further, have a look at some of the examples:</p>

<ul>
	<li><a href="https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/fizzbuzz.fra" target="_blank">Fizzbuzz</a></li>
	<li><a href="https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/tictactoe.fra" target="_blank">Tic-Tac-Toe</a></li>
	<li><a href="https://git.sr.ht/~rabbits/fractran/tree/main/item/examples/life.fra" target="_blank">Game Of Life</a></li>
</ul>

<h3>Implementation</h3>

<p>The rewriting implementation of the runtime can be implemented in about <a href="https://wiki.xxiivv.com/site/ansi_c.html">300
lines</a>.</p>



<q>The wise marvels at the commonplace.</q>
<cite>Confucius</cite>

<ul>
	<li><a href="https://git.sr.ht/~rabbits/fractran" target="_blank">Fractran Interpreter(C89)</a></li>
	<li><a href="https://tjwei.github.io/Fractran" target="_blank">Fractran Interpreter(Web)</a></li>
	<li><a href="https://esoteric.codes/blog/an-intro-to-fractran" target="_blank">Intro to Fractran</a></li>
	<li><a href="https://raganwald.com/2020/05/03/fractran.html" target="_blank">Remembering John Conway</a></li>
	<li><a href="https://esolangs.org/wiki/Fractran" target="_blank">On Esolang</a></li>
</ul>


<ul></ul><p><b>incoming</b> <a href="https://wiki.xxiivv.com/site/phutball.html">phutball</a> <a href="https://wiki.xxiivv.com/site/firth.html">firth</a> <a href="https://wiki.xxiivv.com/site/primes.html">primes</a> <a href="https://wiki.xxiivv.com/site/fractions.html">fractions</a> </p></div></div>
  </body>
</html>
