<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kressler/fast-containers">Original</a>
    <h1>High-performance header-only container library for C&#43;&#43;23 on x86-64</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/kressler/fast-containers/workflows/CI/badge.svg"><img src="https://github.com/kressler/fast-containers/workflows/CI/badge.svg" alt="CI"/></a></p>
<p dir="auto">High-performance header-only container library for C++23 on x86-64.</p>

<ul dir="auto">
<li><strong>B+Tree</strong> (<code>kressler::fast_containers::btree</code>) - Cache-friendly B+tree with SIMD search and hugepage support</li>
<li><strong>Dense Map</strong> (<code>kressler::fast_containers::dense_map</code>) - Fixed-size sorted array used internally by btree nodes</li>
<li><strong>Hugepage Allocators</strong> - Pooling allocators that reduce TLB misses and allocation overhead
<ul dir="auto">
<li><code>HugePageAllocator</code> - Single-size allocator for uniform allocations</li>
<li><code>MultiSizeHugePageAllocator</code> - Multi-size pooling for variable-sized allocations (e.g., Abseil btree)</li>
<li><code>PolicyBasedHugePageAllocator</code> - Advanced control with shared pools</li>
</ul>
</li>
</ul>

<p dir="auto">The B+tree implementation provides significant performance improvements over industry standards for large trees. For some workloads with large trees, we&#39;ve observed:</p>
<ul dir="auto">
<li><strong>vs Abseil B+tree:</strong> 2-5× faster across insert/find/erase operations</li>
<li><strong>vs std::map:</strong> 2-5× faster across insert/find/erase operations</li>
</ul>
<p dir="auto">See <a href="https://github.com/kressler/fast-containers/blob/main/results/btree_benchmark_results.md">benchmark results</a> for detailed performance analysis.</p>
<p dir="auto"><strong>Important qualifications:</strong></p>
<ul dir="auto">
<li>Performance advantages are most significant for large tree sizes where TLB misses and allocation costs dominate</li>
<li>Benchmarks currently focus on 10M element trees; smaller tree sizes have not been comprehensively tested</li>
<li>Results are specific to the tested configurations (8-byte keys, 32-byte and 256-byte values)</li>
</ul>
<p dir="auto"><strong>Key advantages over Abseil&#39;s btree:</strong></p>
<ul dir="auto">
<li><strong>Hugepage allocator integration:</strong> 3-5× speedup from reduced TLB misses and pooled allocations</li>
<li><strong>SIMD-accelerated search:</strong> 3-10% faster node searches using AVX2 instructions</li>
<li><strong>Tunable node sizes:</strong> Optimize cache behavior for your specific key/value sizes</li>
</ul>

<p dir="auto"><strong>Work in progress</strong> This is a work in progress. I don&#39;t have plans for major changes to the B+tree currently, but am actively cleaning up the implementation.</p>
<p dir="auto"><strong>Platforms</strong> This library is really only built and tested on Linux, on x86-64 CPUs with AVX2 support. In theory, it could be built for Windows, though that hasn&#39;t been tested. The SIMD implementations are x86-64 specific. Timing in the custom benchmarks is also x86-64 specific (via use of <code>rdtscp</code>).</p>
<p dir="auto"><strong>History/Motivations</strong> This project started as an exploration of using AI agents for software development. Based on experience tuning systems using Abseil&#39;s B+tree, I was curious if performance could be improved through SIMD instructions, a customized allocator, and tunable node sizes. Claude proved surprisingly adept at helping implement this quickly, and the resulting B+tree showed compelling performance improvements, so I&#39;m making it available here.</p>
<hr/>


<p dir="auto"><strong>Prerequisites:</strong></p>
<ul dir="auto">
<li>C++23 compiler (GCC 14+, Clang 19+)</li>
<li>CMake 3.30+</li>
<li>AVX2-capable CPU (Intel Haswell 2013+, AMD Excavator 2015+)</li>
</ul>
<p dir="auto"><strong>Include in your project:</strong></p>
<ol dir="auto">
<li>
<p dir="auto">Add as a git submodule:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git submodule add https://github.com/kressler/fast-containers.git third_party/fast-containers"><pre>git submodule add https://github.com/kressler/fast-containers.git third_party/fast-containers</pre></div>
</li>
<li>
<p dir="auto">Link in CMakeLists.txt:</p>
<div dir="auto" data-snippet-clipboard-copy-content="add_subdirectory(third_party/fast-containers)
target_link_libraries(your_target PRIVATE fast_containers::fast_containers)"><pre><span>add_subdirectory</span>(third_party/fast-containers)
<span>target_link_libraries</span>(your_target <span>PRIVATE</span> fast_containers::fast_containers)</pre></div>
</li>
<li>
<p dir="auto">Include headers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;fast_containers/btree.hpp&gt;
#include &lt;fast_containers/hugepage_allocator.hpp&gt;"><pre>#<span>include</span> <span><span>&lt;</span>fast_containers/btree.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>fast_containers/hugepage_allocator.hpp<span>&gt;</span></span></pre></div>
</li>
</ol>
<hr/>


<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;fast_containers/btree.hpp&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main() {
  // Create a btree mapping int64_t keys to int32_t values
  // Using defaults: auto-computed node sizes, Linear search
  using Tree = kressler::fast_containers::btree&lt;int64_t, int32_t&gt;;

  Tree tree;

  // Insert key-value pairs
  tree.insert(42, 100);
  tree.insert(17, 200);
  tree.insert(99, 300);

  // Find a value
  auto it = tree.find(42);
  if (it != tree.end()) {
    std::cout &lt;&lt; &#34;Found: &#34; &lt;&lt; it-&gt;second &lt;&lt; std::endl;  // Prints: 100
  }

  // Iterate over all elements (sorted by key)
  for (const auto&amp; [key, value] : tree) {
    std::cout &lt;&lt; key &lt;&lt; &#34; -&gt; &#34; &lt;&lt; value &lt;&lt; std::endl;
  }

  // Erase an element
  tree.erase(17);

  // Check size
  std::cout &lt;&lt; &#34;Size: &#34; &lt;&lt; tree.size() &lt;&lt; std::endl;  // Prints: 2
}"><pre>#<span>include</span> <span><span>&lt;</span>fast_containers/btree.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstdint<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>iostream<span>&gt;</span></span>

<span>int</span> <span>main</span>() {
  <span><span>//</span> Create a btree mapping int64_t keys to int32_t values</span>
  <span><span>//</span> Using defaults: auto-computed node sizes, Linear search</span>
  <span>using</span> Tree = kressler::fast_containers::btree&lt;<span>int64_t</span>, <span>int32_t</span>&gt;;

  Tree tree;

  <span><span>//</span> Insert key-value pairs</span>
  tree.<span>insert</span>(<span>42</span>, <span>100</span>);
  tree.<span>insert</span>(<span>17</span>, <span>200</span>);
  tree.<span>insert</span>(<span>99</span>, <span>300</span>);

  <span><span>//</span> Find a value</span>
  <span>auto</span> it = tree.<span>find</span>(<span>42</span>);
  <span>if</span> (it != tree.<span>end</span>()) {
    std::cout &lt;&lt; <span><span>&#34;</span>Found: <span>&#34;</span></span> &lt;&lt; it-&gt;<span>second</span> &lt;&lt; std::endl;  <span><span>//</span> Prints: 100</span>
  }

  <span><span>//</span> Iterate over all elements (sorted by key)</span>
  <span>for</span> (<span>const</span> <span>auto</span>&amp; [key, value] : tree) {
    std::cout &lt;&lt; key &lt;&lt; <span><span>&#34;</span> -&gt; <span>&#34;</span></span> &lt;&lt; value &lt;&lt; std::endl;
  }

  <span><span>//</span> Erase an element</span>
  tree.<span>erase</span>(<span>17</span>);

  <span><span>//</span> Check size</span>
  std::cout &lt;&lt; <span><span>&#34;</span>Size: <span>&#34;</span></span> &lt;&lt; tree.<span>size</span>() &lt;&lt; std::endl;  <span><span>//</span> Prints: 2</span>
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">B+tree with Hugepage Allocator (Recommended for Performance)</h3><a id="user-content-btree-with-hugepage-allocator-recommended-for-performance" aria-label="Permalink: B+tree with Hugepage Allocator (Recommended for Performance)" href="#btree-with-hugepage-allocator-recommended-for-performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;fast_containers/btree.hpp&gt;
#include &lt;fast_containers/hugepage_allocator.hpp&gt;
#include &lt;cstdint&gt;
#include &lt;cassert&gt;

int main() {
  // Use the hugepage allocator for 3-5× performance improvement
  // Allocator type must match the btree&#39;s value_type (std::pair&lt;Key, Value&gt;)
  using Allocator = kressler::fast_containers::HugePageAllocator&lt;
      std::pair&lt;int64_t, int32_t&gt;&gt;;

  using Tree = kressler::fast_containers::btree&lt;
    int64_t,                                 // Key type
    int32_t,                                 // Value type
    96,                                      // Leaf node size
    128,                                     // Internal node size
    std::less&lt;int64_t&gt;,                      // Comparator
    kressler::fast_containers::SearchMode::SIMD,  // SIMD search
    Allocator                                // Hugepage allocator
  &gt;;

  // Tree will default-construct the allocator (256MB initial pool, 64MB growth)
  // The btree automatically creates separate pools for leaf and internal nodes
  Tree tree;

  // Insert 10 million elements - hugepages reduce TLB misses
  for (int64_t i = 0; i &lt; 10&#39;000&#39;000; ++i) {
    tree.insert(i, i * 2);
  }

  // Find operations are much faster with hugepages
  auto it = tree.find(5&#39;000&#39;000);
  assert(it != tree.end() &amp;&amp; it-&gt;second == 10&#39;000&#39;000);
}"><pre>#<span>include</span> <span><span>&lt;</span>fast_containers/btree.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>fast_containers/hugepage_allocator.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstdint<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cassert<span>&gt;</span></span>

<span>int</span> <span>main</span>() {
  <span><span>//</span> Use the hugepage allocator for 3-5× performance improvement</span>
  <span><span>//</span> Allocator type must match the btree&#39;s value_type (std::pair&lt;Key, Value&gt;)</span>
  <span>using</span> Allocator = kressler::fast_containers::HugePageAllocator&lt;
      std::pair&lt;<span>int64_t</span>, <span>int32_t</span>&gt;&gt;;

  <span>using</span> Tree = kressler::fast_containers::btree&lt;
    <span>int64_t</span>,                                 <span><span>//</span> Key type</span>
    <span>int32_t</span>,                                 <span><span>//</span> Value type</span>
    <span>96</span>,                                      <span><span>//</span> Leaf node size</span>
    <span>128</span>,                                     <span><span>//</span> Internal node size</span>
    std::less&lt;<span>int64_t</span>&gt;,                      <span><span>//</span> Comparator</span>
    kressler::fast_containers::SearchMode::SIMD,  <span><span>//</span> SIMD search</span>
    Allocator                                <span><span>//</span> Hugepage allocator</span>
  &gt;;

  <span><span>//</span> Tree will default-construct the allocator (256MB initial pool, 64MB growth)</span>
  <span><span>//</span> The btree automatically creates separate pools for leaf and internal nodes</span>
  Tree tree;

  <span><span>//</span> Insert 10 million elements - hugepages reduce TLB misses</span>
  <span>for</span> (<span>int64_t</span> i = <span>0</span>; i &lt; <span>10&#39;000&#39;000</span>; ++i) {
    tree.<span>insert</span>(i, i * <span>2</span>);
  }

  <span><span>//</span> Find operations are much faster with hugepages</span>
  <span>auto</span> it = tree.<span>find</span>(<span>5&#39;000&#39;000</span>);
  <span>assert</span>(it != tree.<span>end</span>() &amp;&amp; it-&gt;<span>second</span> == <span>10&#39;000&#39;000</span>);
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Advanced: Policy-Based Allocator for Shared Pools</h3></div>
<p dir="auto">For multiple trees or fine-grained control over pool sizes, use <code>PolicyBasedHugePageAllocator</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;fast_containers/btree.hpp&gt;
#include &lt;fast_containers/policy_based_hugepage_allocator.hpp&gt;
#include &lt;cstdint&gt;

int main() {
  // Create separate pools for leaf and internal nodes with custom sizes
  auto leaf_pool = std::make_shared&lt;kressler::fast_containers::HugePagePool&gt;(
      512 * 1024 * 1024, true);  // 512MB for leaves
  auto internal_pool = std::make_shared&lt;kressler::fast_containers::HugePagePool&gt;(
      256 * 1024 * 1024, true);  // 256MB for internals

  // Create policy that routes types to appropriate pools
  kressler::fast_containers::TwoPoolPolicy policy{leaf_pool, internal_pool};

  // Create allocator with the policy
  using Allocator = kressler::fast_containers::PolicyBasedHugePageAllocator&lt;
      std::pair&lt;int64_t, int32_t&gt;,
      kressler::fast_containers::TwoPoolPolicy&gt;;

  Allocator alloc(policy);

  using Tree = kressler::fast_containers::btree&lt;
    int64_t, int32_t, 96, 128, std::less&lt;int64_t&gt;,
    kressler::fast_containers::SearchMode::SIMD, Allocator&gt;;

  // Multiple trees can share the same pools
  Tree tree1(alloc);
  Tree tree2(alloc);

  // Both trees share leaf_pool for leaves and internal_pool for internals
  tree1.insert(1, 100);
  tree2.insert(2, 200);
}"><pre>#<span>include</span> <span><span>&lt;</span>fast_containers/btree.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>fast_containers/policy_based_hugepage_allocator.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstdint<span>&gt;</span></span>

<span>int</span> <span>main</span>() {
  <span><span>//</span> Create separate pools for leaf and internal nodes with custom sizes</span>
  <span>auto</span> leaf_pool = std::make_shared&lt;kressler::fast_containers::HugePagePool&gt;(
      <span>512</span> * <span>1024</span> * <span>1024</span>, <span>true</span>);  <span><span>//</span> 512MB for leaves</span>
  <span>auto</span> internal_pool = std::make_shared&lt;kressler::fast_containers::HugePagePool&gt;(
      <span>256</span> * <span>1024</span> * <span>1024</span>, <span>true</span>);  <span><span>//</span> 256MB for internals</span>

  <span><span>//</span> Create policy that routes types to appropriate pools</span>
  kressler::fast_containers::TwoPoolPolicy policy{leaf_pool, internal_pool};

  <span><span>//</span> Create allocator with the policy</span>
  <span>using</span> Allocator = kressler::fast_containers::PolicyBasedHugePageAllocator&lt;
      std::pair&lt;<span>int64_t</span>, <span>int32_t</span>&gt;,
      kressler::fast_containers::TwoPoolPolicy&gt;;

  Allocator <span>alloc</span>(policy);

  <span>using</span> Tree = kressler::fast_containers::btree&lt;
    <span>int64_t</span>, <span>int32_t</span>, <span>96</span>, <span>128</span>, std::less&lt;<span>int64_t</span>&gt;,
    kressler::fast_containers::SearchMode::SIMD, Allocator&gt;;

  <span><span>//</span> Multiple trees can share the same pools</span>
  Tree <span>tree1</span>(alloc);
  Tree <span>tree2</span>(alloc);

  <span><span>//</span> Both trees share leaf_pool for leaves and internal_pool for internals</span>
  tree1.<span>insert</span>(<span>1</span>, <span>100</span>);
  tree2.<span>insert</span>(<span>2</span>, <span>200</span>);
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Advanced: Multi-Size Hugepage Allocator for Variable-Sized Allocations</h3><a id="user-content-advanced-multi-size-hugepage-allocator-for-variable-sized-allocations" aria-label="Permalink: Advanced: Multi-Size Hugepage Allocator for Variable-Sized Allocations" href="#advanced-multi-size-hugepage-allocator-for-variable-sized-allocations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For containers that allocate variable-sized objects (like <code>absl::btree_map</code>), use <code>MultiSizeHugePageAllocator</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;fast_containers/multi_size_hugepage_allocator.hpp&gt;
#include &lt;absl/container/btree_map.h&gt;
#include &lt;array&gt;
#include &lt;cstdint&gt;

int main() {
  // absl::btree_map allocates different-sized nodes (leaf vs internal)
  // MultiSizeHugePageAllocator routes allocations to size-class-specific pools

  using ValueType = std::array&lt;std::byte, 32&gt;;
  using Allocator = kressler::fast_containers::MultiSizeHugePageAllocator&lt;
      std::pair&lt;const int64_t, ValueType&gt;&gt;;

  // Helper function creates allocator with default settings
  // - 64MB initial size per size class
  // - Hugepages enabled
  // - 64MB growth size per size class
  auto alloc = kressler::fast_containers::make_multi_size_hugepage_allocator&lt;
      std::pair&lt;const int64_t, ValueType&gt;&gt;();

  // Create absl::btree_map with hugepage allocator
  absl::btree_map&lt;int64_t, ValueType, std::less&lt;int64_t&gt;, Allocator&gt; tree(alloc);

  // Insert 1 million elements - multiple size classes created automatically
  for (int64_t i = 0; i &lt; 1&#39;000&#39;000; ++i) {
    tree[i] = ValueType{};
  }

  // Find operations benefit from reduced TLB misses
  auto it = tree.find(500&#39;000);
}"><pre>#<span>include</span> <span><span>&lt;</span>fast_containers/multi_size_hugepage_allocator.hpp<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>absl/container/btree_map.h<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>array<span>&gt;</span></span>
#<span>include</span> <span><span>&lt;</span>cstdint<span>&gt;</span></span>

<span>int</span> <span>main</span>() {
  <span><span>//</span> absl::btree_map allocates different-sized nodes (leaf vs internal)</span>
  <span><span>//</span> MultiSizeHugePageAllocator routes allocations to size-class-specific pools</span>

  <span>using</span> ValueType = std::array&lt;std::byte, <span>32</span>&gt;;
  <span>using</span> Allocator = kressler::fast_containers::MultiSizeHugePageAllocator&lt;
      std::pair&lt;<span>const</span> <span>int64_t</span>, ValueType&gt;&gt;;

  <span><span>//</span> Helper function creates allocator with default settings</span>
  <span><span>//</span> - 64MB initial size per size class</span>
  <span><span>//</span> - Hugepages enabled</span>
  <span><span>//</span> - 64MB growth size per size class</span>
  <span>auto</span> alloc = kressler::fast_containers::make_multi_size_hugepage_allocator&lt;
      std::pair&lt;<span>const</span> <span>int64_t</span>, ValueType&gt;&gt;();

  <span><span>//</span> Create absl::btree_map with hugepage allocator</span>
  absl::btree_map&lt;<span>int64_t</span>, ValueType, std::less&lt;<span>int64_t</span>&gt;, Allocator&gt; <span>tree</span>(alloc);

  <span><span>//</span> Insert 1 million elements - multiple size classes created automatically</span>
  <span>for</span> (<span>int64_t</span> i = <span>0</span>; i &lt; <span>1&#39;000&#39;000</span>; ++i) {
    tree[i] = ValueType{};
  }

  <span><span>//</span> Find operations benefit from reduced TLB misses</span>
  <span>auto</span> it = tree.<span>find</span>(<span>500&#39;000</span>);
}</pre></div>
<p dir="auto"><strong>How it works:</strong></p>
<ul dir="auto">
<li>Allocations are routed to size classes based on requested size</li>
<li>Size classes: 0-512B (64B alignment), 513-2048B (256B alignment), 2049+B (power-of-2)</li>
<li>Each size class maintains its own <code>HugePagePool</code> with uniform-sized blocks</li>
<li>Pools created on-demand as different sizes are requested</li>
<li>Provides 2-3× performance improvement for <code>absl::btree_map</code> over standard allocator</li>
</ul>
<p dir="auto"><strong>When to use each allocator:</strong></p>
<ul dir="auto">
<li><strong><code>HugePageAllocator</code></strong>: Simple, automatic separate pools per type (recommended for our btree)</li>
<li><strong><code>MultiSizeHugePageAllocator</code></strong>: Variable-sized allocations (e.g., <code>absl::btree_map</code>, other STL containers with allocator support)</li>
<li><strong><code>PolicyBasedHugePageAllocator</code></strong>: Fine-grained control, shared pools across trees, custom pool sizes</li>
</ul>

<p dir="auto">The <code>btree</code> class provides an API similar to <code>std::map</code>:</p>
<p dir="auto"><strong>Insertion:</strong></p>
<ul dir="auto">
<li><code>std::pair&lt;iterator, bool&gt; insert(const Key&amp; key, const Value&amp; value)</code></li>
<li><code>std::pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args)</code></li>
<li><code>Value&amp; operator[](const Key&amp; key)</code></li>
</ul>
<p dir="auto"><strong>Lookup:</strong></p>
<ul dir="auto">
<li><code>iterator find(const Key&amp; key)</code></li>
<li><code>const_iterator find(const Key&amp; key) const</code></li>
<li><code>iterator lower_bound(const Key&amp; key)</code></li>
<li><code>iterator upper_bound(const Key&amp; key)</code></li>
<li><code>std::pair&lt;iterator, iterator&gt; equal_range(const Key&amp; key)</code></li>
</ul>
<p dir="auto"><strong>Removal:</strong></p>
<ul dir="auto">
<li><code>size_type erase(const Key&amp; key)</code></li>
<li><code>iterator erase(iterator pos)</code></li>
</ul>
<p dir="auto"><strong>Iteration:</strong></p>
<ul dir="auto">
<li><code>iterator begin()</code> / <code>const_iterator begin() const</code></li>
<li><code>iterator end()</code> / <code>const_iterator end() const</code></li>
<li>Range-based for loops supported</li>
</ul>
<p dir="auto"><strong>Capacity:</strong></p>
<ul dir="auto">
<li><code>size_type size() const</code></li>
<li><code>bool empty() const</code></li>
<li><code>void clear()</code></li>
</ul>
<p dir="auto"><strong>Other:</strong></p>
<ul dir="auto">
<li><code>void swap(btree&amp; other) noexcept</code></li>
<li><code>key_compare key_comp() const</code></li>
<li><code>value_compare value_comp() const</code></li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="template &lt;
  typename Key,
  typename Value,
  std::size_t LeafNodeSize = default_leaf_node_size&lt;Key, Value&gt;(),
  std::size_t InternalNodeSize = default_internal_node_size&lt;Key&gt;(),
  typename Compare = std::less&lt;Key&gt;,
  SearchMode SearchModeT = SearchMode::Linear,
  typename Allocator = std::allocator&lt;std::pair&lt;Key, Value&gt;&gt;
&gt;
class btree;"><pre><span>template </span>&lt;
  <span>typename</span> Key,
  <span>typename</span> Value,
  std::<span>size_t</span> LeafNodeSize = default_leaf_node_size&lt;Key, Value&gt;(),
  std::<span>size_t</span> InternalNodeSize = default_internal_node_size&lt;Key&gt;(),
  <span>typename</span> Compare = std::less&lt;Key&gt;,
  SearchMode SearchModeT = SearchMode::Linear,
  <span>typename</span> Allocator = std::allocator&lt;std::pair&lt;Key, Value&gt;&gt;
&gt;
<span>class</span> <span>btree</span>;</pre></div>
<p dir="auto"><strong>Parameters:</strong></p>
<ul dir="auto">
<li>
<p dir="auto"><code>Key</code>, <code>Value</code>: The key and value types</p>
</li>
<li>
<p dir="auto"><code>LeafNodeSize</code>: Number of key-value pairs per leaf node</p>
<ul dir="auto">
<li><strong>Default</strong>: Auto-computed heuristic targeting ~2KB (32 cache lines)</li>
<li>Formula: <code>2048 / (sizeof(Key) + sizeof(Value))</code>, rounded to multiple of 8, clamped to [8, 64]</li>
<li>Manual tuning: Larger values (64-96) for small values, smaller values (8-16) for large values</li>
</ul>
</li>
<li>
<p dir="auto"><code>InternalNodeSize</code>: Number of child pointers per internal node</p>
<ul dir="auto">
<li><strong>Default</strong>: Auto-computed heuristic targeting ~1KB (16 cache lines)</li>
<li>Formula: <code>1024 / (sizeof(Key) + sizeof(void*))</code>, rounded to multiple of 8, clamped to [16, 64]</li>
<li>Generally leave at default (stores only 8-byte pointers)</li>
</ul>
</li>
<li>
<p dir="auto"><code>Compare</code>: Comparison function (must satisfy <code>ComparatorCompatible&lt;Key, Compare&gt;</code>)</p>
<ul dir="auto">
<li><strong>Default</strong>: <code>std::less&lt;Key&gt;</code></li>
<li>Also supports <code>std::greater&lt;Key&gt;</code> for descending order</li>
</ul>
</li>
<li>
<p dir="auto"><code>SearchMode</code>: How to search within a node</p>
<ul dir="auto">
<li><strong>Default</strong>: <code>SearchMode::Linear</code> (scalar linear search)</li>
<li><code>SearchMode::SIMD</code>: AVX2-accelerated search (3-10% faster, requires AVX2 CPU and SIMD-compatible keys: int32_t, uint32_t, int64_t, uint64_t, float, double)</li>
<li><code>SearchMode::Binary</code>: Binary search</li>
</ul>
</li>
<li>
<p dir="auto"><code>Allocator</code>: Memory allocation strategy</p>
<ul dir="auto">
<li><strong>Default</strong>: <code>std::allocator&lt;std::pair&lt;Key, Value&gt;&gt;</code></li>
<li><strong>Recommended for performance</strong>: <code>HugePageAllocator&lt;std::pair&lt;Key, Value&gt;&gt;</code> for working sets &gt;1GB (3-5× faster)
<ul dir="auto">
<li>Automatically creates separate pools for leaf and internal nodes via rebind</li>
<li>Default: 256MB initial pool, 64MB growth per pool</li>
<li>Requires hugepages configured: <code>sudo sysctl -w vm.nr_hugepages=&lt;num_pages&gt;</code></li>
<li>Falls back to regular pages if unavailable</li>
</ul>
</li>
<li><strong>For variable-sized allocations</strong>: <code>MultiSizeHugePageAllocator&lt;std::pair&lt;Key, Value&gt;&gt;</code>
<ul dir="auto">
<li>Routes allocations to size-class-specific pools</li>
<li>Use with <code>absl::btree_map</code> or other containers that allocate different-sized objects</li>
<li>Provides 2-3× speedup for Abseil btree over standard allocator</li>
</ul>
</li>
<li><strong>Advanced control</strong>: <code>PolicyBasedHugePageAllocator&lt;std::pair&lt;Key, Value&gt;, TwoPoolPolicy&gt;</code>
<ul dir="auto">
<li>Fine-grained control over pool sizes</li>
<li>Share pools across multiple trees</li>
<li>Separate pools for leaf and internal nodes with custom sizes</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>

<p dir="auto">Benchmarks comparing against Abseil&#39;s <code>btree_map</code> and <code>std::map</code> are available in <a href="https://github.com/kressler/fast-containers/blob/main/results/btree_benchmark_results.md">results/btree_benchmark_results.md</a>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Performance Highlights (8-byte keys, 32-byte values, 10M elements)</h3><a id="user-content-performance-highlights-8-byte-keys-32-byte-values-10m-elements" aria-label="Permalink: Performance Highlights (8-byte keys, 32-byte values, 10M elements)" href="#performance-highlights-8-byte-keys-32-byte-values-10m-elements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Our btree with hugepages</strong> (<code>btree_8_32_96_128_simd_hp</code>):</p>
<ul dir="auto">
<li><strong>INSERT P99.9</strong>: 1,023 ns</li>
<li><strong>FIND P99.9</strong>: 864 ns</li>
<li><strong>ERASE P99.9</strong>: 1,086 ns</li>
</ul>
<p dir="auto"><strong>Our btree with standard allocator</strong> (<code>btree_8_32_96_128_simd</code>):</p>
<ul dir="auto">
<li>INSERT P99.9: 3,155 ns (<strong>3.1× slower</strong> than with hugepages)</li>
<li>FIND P99.9: 950 ns (<strong>1.1× slower</strong> than with hugepages)</li>
<li>ERASE P99.9: 1,323 ns (<strong>1.2× slower</strong> than with hugepages)</li>
</ul>
<p dir="auto"><strong>vs. Abseil btree with hugepages</strong> (<code>absl_8_32_hp</code> using <code>MultiSizeHugePageAllocator</code>):</p>
<ul dir="auto">
<li>INSERT P99.9: 1,401 ns (<strong>27% slower</strong>)</li>
<li>FIND P99.9: 1,190 ns (<strong>38% slower</strong>)</li>
<li>ERASE P99.9: 1,299 ns (<strong>20% slower</strong>)</li>
</ul>
<p dir="auto"><strong>vs. Abseil btree with standard allocator</strong> (<code>absl_8_32</code>):</p>
<ul dir="auto">
<li>INSERT P99.9: 3,287 ns (<strong>3.2× slower</strong>)</li>
<li>FIND P99.9: 1,342 ns (<strong>55% slower</strong>)</li>
<li>ERASE P99.9: 1,679 ns (<strong>55% slower</strong>)</li>
</ul>
<p dir="auto"><strong>vs. std::map</strong> (<code>map_8_32</code>):</p>
<ul dir="auto">
<li>INSERT P99.9: 3,587 ns (<strong>3.5× slower</strong>)</li>
<li>FIND P99.9: 2,312 ns (<strong>2.7× slower</strong>)</li>
<li>ERASE P99.9: 2,253 ns (<strong>2.1× slower</strong>)</li>
</ul>

<p dir="auto"><strong>Hugepage allocators provide massive performance improvements:</strong></p>
<ul dir="auto">
<li>Our btree: <strong>2-3× faster</strong> with hugepages vs. standard allocator</li>
<li>Abseil btree: <strong>2× faster</strong> with <code>MultiSizeHugePageAllocator</code> vs. standard allocator</li>
<li>Critical for large working sets (&gt;1M elements)</li>
</ul>
<p dir="auto"><strong>Our implementation maintains significant advantages even with fair comparison:</strong></p>
<ul dir="auto">
<li><strong>20-67% faster</strong> than Abseil btree even when both use hugepage allocators</li>
<li>Advantages from SIMD search, tunable node sizes, and optimized bulk transfers</li>
<li>Performance gap widens with larger values (256 bytes: <strong>21-135% faster</strong>)</li>
</ul>
<p dir="auto"><strong>Performance varies by tree size:</strong></p>
<ul dir="auto">
<li>Large trees (10M elements): Our btree dominates all metrics</li>
<li>Small trees (10K elements): Competition intensifies, std::map becomes viable for some workloads</li>
<li>See <a href="https://github.com/kressler/fast-containers/blob/main/results/btree_benchmark_results.md">benchmark results</a> for detailed analysis</li>
</ul>
<p dir="auto">The hugepage allocator is the single most important optimization, providing benefits by reducing TLB misses (helps find operations) and making allocations extremely cheap through pooling (helps insert/erase operations).</p>
<hr/>

<div dir="auto"><h3 tabindex="-1" dir="auto">Using CMake Presets (Recommended)</h3><a id="user-content-using-cmake-presets-recommended" aria-label="Permalink: Using CMake Presets (Recommended)" href="#using-cmake-presets-recommended"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="# List available presets
cmake --list-presets

# Configure, build, and test in one workflow
cmake --preset release
cmake --build --preset release
ctest --preset release

# Common presets:
cmake --preset debug          # Debug build
cmake --preset release        # Release with AVX2 (default)
cmake --preset asan           # AddressSanitizer build
cmake --preset release-no-avx2  # Release without AVX2"><pre><span><span>#</span> List available presets</span>
cmake --list-presets

<span><span>#</span> Configure, build, and test in one workflow</span>
cmake --preset release
cmake --build --preset release
ctest --preset release

<span><span>#</span> Common presets:</span>
cmake --preset debug          <span><span>#</span> Debug build</span>
cmake --preset release        <span><span>#</span> Release with AVX2 (default)</span>
cmake --preset asan           <span><span>#</span> AddressSanitizer build</span>
cmake --preset release-no-avx2  <span><span>#</span> Release without AVX2</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Manual Build (Alternative)</h3><a id="user-content-manual-build-alternative" aria-label="Permalink: Manual Build (Alternative)" href="#manual-build-alternative"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="# Clone with submodules
git clone --recursive https://github.com/kressler/fast-containers.git
cd fast-containers

# Configure
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release

# Build
cmake --build build

# Run tests
ctest --test-dir build --output-on-failure"><pre><span><span>#</span> Clone with submodules</span>
git clone --recursive https://github.com/kressler/fast-containers.git
<span>cd</span> fast-containers

<span><span>#</span> Configure</span>
cmake -S <span>.</span> -B build -DCMAKE_BUILD_TYPE=Release

<span><span>#</span> Build</span>
cmake --build build

<span><span>#</span> Run tests</span>
ctest --test-dir build --output-on-failure</pre></div>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ENABLE_AVX2</code></td>
<td><code>ON</code> (Release), <code>OFF</code> (Debug)</td>
<td>Enable AVX2 SIMD optimizations</td>
</tr>
<tr>
<td><code>ENABLE_ASAN</code></td>
<td><code>OFF</code></td>
<td>Enable AddressSanitizer</td>
</tr>
<tr>
<td><code>ENABLE_ALLOCATOR_STATS</code></td>
<td><code>OFF</code></td>
<td>Enable allocator statistics</td>
</tr>
<tr>
<td><code>ENABLE_LTO</code></td>
<td><code>ON</code></td>
<td>Enable Link-Time Optimization</td>
</tr>
<tr>
<td><code>ENABLE_NUMA</code></td>
<td>Auto-detected</td>
<td>Enable NUMA support (requires libnuma)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<hr/>


<ol dir="auto">
<li>
<p dir="auto">Clone with submodules:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone --recursive https://github.com/kressler/fast-containers.git
cd fast-containers"><pre>git clone --recursive https://github.com/kressler/fast-containers.git
<span>cd</span> fast-containers</pre></div>
</li>
<li>
<p dir="auto">One-time development setup:</p>

<p dir="auto">This installs pre-commit hooks and configures clang-tidy.</p>
</li>
</ol>

<p dir="auto"><strong>Automatic formatting and checks</strong> (via pre-commit hook):</p>
<div dir="auto" data-snippet-clipboard-copy-content="git commit  # Automatically formats code and runs clang-tidy"><pre>git commit  <span><span>#</span> Automatically formats code and runs clang-tidy</span></pre></div>
<p dir="auto">The pre-commit hook will:</p>
<ul dir="auto">
<li>Format all staged C++ files with clang-format</li>
<li>Check production headers with clang-tidy</li>
<li>Fail the commit if warnings are found</li>
<li>Auto-create build directories if missing</li>
</ul>
<p dir="auto"><strong>Manual formatting:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake --build build --target format"><pre>cmake --build build --target format</pre></div>
<p dir="auto"><strong>Manual static analysis:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake --build build --target clang-tidy
# Or manually:
clang-tidy-19 -p cmake-build-clang-tidy include/fast_containers/*.hpp"><pre>cmake --build build --target clang-tidy
<span><span>#</span> Or manually:</span>
clang-tidy-19 -p cmake-build-clang-tidy include/fast_containers/<span>*</span>.hpp</pre></div>
<p dir="auto"><strong>Requirements:</strong></p>
<ul dir="auto">
<li>clang-format (for code formatting)</li>
<li>clang-tidy-19 (for static analysis)</li>
<li>cmake (to auto-create build directories)</li>
</ul>
<p dir="auto"><strong>Bypass hook</strong> (when needed):</p>


<ol dir="auto">
<li>
<p dir="auto">Make your changes</p>
</li>
<li>
<p dir="auto">Build and test:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cmake --build build &amp;&amp; ctest --test-dir build"><pre>cmake --build build <span>&amp;&amp;</span> ctest --test-dir build</pre></div>
</li>
<li>
<p dir="auto">Commit (auto-formatted and checked):</p>
<div dir="auto" data-snippet-clipboard-copy-content="git add .
git commit -m &#34;Your changes&#34;
# Pre-commit hook runs automatically"><pre>git add <span>.</span>
git commit -m <span><span>&#34;</span>Your changes<span>&#34;</span></span>
<span><span>#</span> Pre-commit hook runs automatically</span></pre></div>
</li>
</ol>

<ul dir="auto">
<li>Follow Google C++ Style Guide (enforced by clang-format)</li>
<li>Use C++23 features</li>
<li>Write tests for new functionality using Catch2</li>
<li>Production code must be clang-tidy clean (enforced in CI and pre-commit)</li>
<li>Run <code>cmake --build build --target format</code> before submitting PRs</li>
</ul>
<hr/>

<div data-snippet-clipboard-copy-content=".
├── include/
│   └── fast_containers/         # Public header files
│       ├── btree.hpp, btree.ipp
│       ├── dense_map.hpp, dense_map.ipp
│       ├── hugepage_allocator.hpp
│       ├── multi_size_hugepage_allocator.hpp
│       ├── multi_size_hugepage_pool.hpp
│       ├── policy_based_hugepage_allocator.hpp
│       └── hugepage_pool.hpp
├── tests/                       # Unit tests (Catch2)
│   ├── test_btree.cpp
│   ├── test_dense_map.cpp
│   ├── test_hugepage_allocator.cpp
│   └── test_policy_based_allocator.cpp
├── src/
│   ├── benchmarks/              # Google Benchmark performance tests
│   │   ├── dense_map_search_benchmark.cpp
│   │   └── hugepage_allocator_benchmark.cpp
│   └── binary/                  # Standalone benchmark executables
│       ├── btree_benchmark.cpp
│       └── btree_stress.cpp
├── scripts/
│   └── interleaved_btree_benchmark.py  # A/B testing harness
├── results/
│   └── btree_benchmark_results.md      # Performance analysis
├── third_party/                 # Git submodules
│   ├── catch2/                  # Unit testing framework
│   ├── benchmark/               # Google Benchmark
│   ├── histograms/              # Latency histogram library
│   ├── abseil-cpp/              # Comparison baseline
│   ├── lyra/                    # Command-line parsing
│   └── unordered_dense/         # Dense hash map
├── hooks/                       # Git hooks (install with setup-dev.sh)
│   └── pre-commit               # Auto-format and clang-tidy
└── CMakeLists.txt               # Build configuration"><pre><code>.
├── include/
│   └── fast_containers/         # Public header files
│       ├── btree.hpp, btree.ipp
│       ├── dense_map.hpp, dense_map.ipp
│       ├── hugepage_allocator.hpp
│       ├── multi_size_hugepage_allocator.hpp
│       ├── multi_size_hugepage_pool.hpp
│       ├── policy_based_hugepage_allocator.hpp
│       └── hugepage_pool.hpp
├── tests/                       # Unit tests (Catch2)
│   ├── test_btree.cpp
│   ├── test_dense_map.cpp
│   ├── test_hugepage_allocator.cpp
│   └── test_policy_based_allocator.cpp
├── src/
│   ├── benchmarks/              # Google Benchmark performance tests
│   │   ├── dense_map_search_benchmark.cpp
│   │   └── hugepage_allocator_benchmark.cpp
│   └── binary/                  # Standalone benchmark executables
│       ├── btree_benchmark.cpp
│       └── btree_stress.cpp
├── scripts/
│   └── interleaved_btree_benchmark.py  # A/B testing harness
├── results/
│   └── btree_benchmark_results.md      # Performance analysis
├── third_party/                 # Git submodules
│   ├── catch2/                  # Unit testing framework
│   ├── benchmark/               # Google Benchmark
│   ├── histograms/              # Latency histogram library
│   ├── abseil-cpp/              # Comparison baseline
│   ├── lyra/                    # Command-line parsing
│   └── unordered_dense/         # Dense hash map
├── hooks/                       # Git hooks (install with setup-dev.sh)
│   └── pre-commit               # Auto-format and clang-tidy
└── CMakeLists.txt               # Build configuration
</code></pre></div>

<ul dir="auto">
<li><strong>Language</strong>: C++23</li>
<li><strong>Build System</strong>: CMake 3.30+</li>
<li><strong>Testing</strong>: Catch2 v3.11.0</li>
<li><strong>Code Formatting</strong>: clang-format (Google C++ Style)</li>
<li><strong>Static Analysis</strong>: clang-tidy-19</li>
</ul>
</article></div></div>
  </body>
</html>
