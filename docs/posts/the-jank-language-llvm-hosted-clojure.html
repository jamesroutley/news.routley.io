<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jank-lang.org/">Original</a>
    <h1>The Jank Language: LLVM Hosted Clojure</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div><div><div><p>The jank programming language</p><p>jank is a <strong>general-purpose programming language</strong> which embraces the <strong>interactive, value-oriented</strong> nature of Clojure as well as the desire for <strong>native compilation and minimal runtimes</strong>. jank is <strong>100% compatible with Clojure</strong>.</p><p>Where jank differs from Clojure is that its host is C++ on top of an <strong>LLVM-based JIT</strong>. Furthermore, jank has a built-in <strong>gradual type system</strong> which allows for malli-style type annotations which result in <strong>static type analysis</strong>. This allows jank to offer the same benefits of <strong>REPL-based development</strong> while being able to reach much further into the lands of both <strong>correctness and performance</strong>.</p><p>Still, jank is a Clojure dialect and thus includes its <strong>code-as-data philosophy and powerful macro system</strong>. jank remains a functional-first language which builds upon Clojure&#39;s rich set of <strong>persistent, immutable data structures</strong>. When mutability is needed, jank offers a software transaction memory and reactive Agent system to ensure <strong>clean and correct multi-threaded designs</strong>.</p></div></div></div></div></section><section id="how-it-works"><div><div><div><p><span>01</span></p><h3>Iterate like you would with Clojure</h3><p>As you iterate in the REPL and figure out your data shapes, static typing will not be in your way.</p></div><div><div><pre><code><span><span>(</span><span>defn</span><span> unqualify</span></span>
<span><span>  </span><span>&#34;Strip the namespace from a keyword.&#34;</span></span>
<span><span>  [kw]</span></span>
<span><span>  (</span><span>-&gt;</span><span> kw name keyword))</span></span>
<span></span></code></pre></div></div></div><div><div><p><span>02</span></p><h3>Add type annotations to lock down data shapes</h3><p>Rather than using spec or malli to define your contracts, use jank&#39;s malli-like type definitions and then gain static type checking for any direct or indirect uses of that data.</p></div><div><div><pre><code><span><span>(</span><span>defn</span><span> unqualify</span></span>
<span><span>  </span><span>&#34;Strip the namespace from a keyword.&#34;</span></span>
<span><span>  [kw]</span></span>
<span><span>  (</span><span>-&gt;</span><span> kw name keyword))</span></span>
<span><span>(</span><span>type</span><span> unqualify [:fn [:keyword] :unqualified-keyword])</span></span>
<span></span></code></pre></div></div></div><div><div><p><span>03</span></p><h3>Compile to machine code</h3><p>jank is built on an LLVM-based JIT. With AOT enabled, both statically and dynamically linked executables can be generated. The jank compiler itself has very speedy start times and low memory usage.</p></div><div><div><pre><code><span><span>$ </span><span>time</span><span> jank hello-world.clj</span></span>
<span><span>hello world</span></span>
<span></span>
<span><span>real  0m0.101s</span></span>
<span><span>user  0m0.058s</span></span>
<span><span>sys   0m0.035s</span></span>
<span></span></code></pre></div><div><pre><code><span><span>$ </span><span>time</span><span> clj hello-world.clj</span></span>
<span><span>hello world</span></span>
<span></span>
<span><span>real  0m0.703s</span></span>
<span><span>user  0m1.957s</span></span>
<span><span>sys   0m0.109s</span></span>
<span></span></code></pre></div></div></div></div></section><section id="features"><div><div><div><div><div><div><h3>100% compatible with Clojure</h3></div><p>Any Clojure library without interop will compile into your jank projects.</p></div><div><p>Use your favorite nREPL editor plugin. jank uses an LLVM-based JIT to compile machine code on the fly.</p></div></div><div><div><p>Add types where you want them or disable static typing altogether. Generate dynamic binaries or static binaries, both using AOT compilation. Your choice.</p></div><div><p>Leiningen, LSP, nREPL planned from the start. jank&#39;s compiler is also written with tooling in mind, so it can be used for lexing, parsing, and analysis.</p></div></div></div></div></div></section><section id="examples"><div><div><div><h3>Generate a movie index</h3><p>jank has very powerful capabilities for representing and transforming arbitrary data. Here, idiomatic usages of <code>reduce</code>, <code>zipmap</code>, <code>repeat</code>, and <code>merge-with</code> help create an index from genre to movie id with ease. No lenses are required for working with nested data.</p></div><div><div><pre><code><span><span>(</span><span>def</span><span> movies {:the-weather-man {:title </span><span>&#34;The Weather Man&#34;</span></span>
<span><span>                               :genres [:drama :comedy]</span></span>
<span><span>                               :tomatometer </span><span>59</span><span>}</span></span>
<span><span>             :nightcrawler {:title </span><span>&#34;Nightcrawler&#34;</span></span>
<span><span>                            :genres [:drama :crime :thriller]</span></span>
<span><span>                            :tomatometer </span><span>95</span><span>}</span></span>
<span><span>             :the-bourne-identity {:title </span><span>&#34;The Bourne Identity&#34;</span></span>
<span><span>                                   :genres [:action :thriller]</span></span>
<span><span>                                   :tomatometer </span><span>84</span><span>}})</span></span>
<span></span>
<span><span>(</span><span>def</span><span> genre-&gt;movie (</span><span>reduce</span><span> (</span><span>fn</span><span> [acc [id movie]]</span></span>
<span><span>                            (</span><span>let</span><span> [{:keys [genres]} movie</span></span>
<span><span>                                  genre-&gt;this-movie (</span><span>zipmap</span><span> genres (</span><span>repeat</span><span> [id]))]</span></span>
<span><span>                              (</span><span>merge-with</span><span> into acc genre-&gt;this-movie)))</span></span>
<span><span>                          {}</span></span>
<span><span>                          movies))</span></span>
<span></span>
<span><span>; genre-&gt;movie is now a useful index.</span></span>
<span><span>; =&gt;</span></span>
<span><span>{:drama [:the-weather-man :nightcrawler],</span></span>
<span><span> :comedy [:the-weather-man],</span></span>
<span><span> :crime [:nightcrawler],</span></span>
<span><span> :thriller [:nightcrawler],</span></span>
<span><span> :action [:the-bourne-identity]}</span></span>
<span></span>
<span><span>; We can look up all movies by genre.</span></span>
<span><span>(</span><span>-&gt;&gt;</span><span> (</span><span>genre-&gt;movie</span><span> :thriller)</span></span>
<span><span>     (</span><span>map</span><span> movies)</span></span>
<span><span>     (</span><span>sort-by</span><span> :tomatometer))</span></span>
<span><span>; =&gt;</span></span>
<span><span>({:title </span><span>&#34;The Bourne Identity&#34;</span><span>,</span></span>
<span><span>  :genres [:action :thriller],</span></span>
<span><span>  :tomatometer </span><span>84</span><span>}</span></span>
<span><span> {:title </span><span>&#34;Nightcrawler&#34;</span><span>,</span></span>
<span><span>  :genres [:drama :crime :thriller],</span></span>
<span><span>  :tomatometer </span><span>95</span><span>})</span></span>
<span></span></code></pre></div></div></div><div><div><h3>Convert bytes to human readable format</h3><p>Beyond the traditional <code>map</code>, <code>filter</code>, and <code>reduce</code>, jank provides a powerful <code>loop</code> macro for more imperative-style loops while still being purely functional. Each <code>loop</code> has one or more corresponding <code>recur</code> usages which must be in tail position.</p></div><div><div><pre><code><span><span>(</span><span>defn</span><span> size-&gt;human-readable</span></span>
<span><span>  </span><span>&#34;Converts a size, in bytes, to a human readable format, such as 0 B, 1.5 kB,</span></span>
<span><span>   10 GB, etc.&#34;</span></span>
<span><span>  [size-in-bytes]</span></span>
<span><span>  (</span><span>if</span><span> (</span><span>and</span><span> (</span><span>&lt;</span><span> </span><span>-1000</span><span> size-in-bytes) (</span><span>&lt;</span><span> size-in-bytes </span><span>1000</span><span>))</span></span>
<span><span>    (</span><span>str</span><span> size-in-bytes </span><span>&#34; B&#34;</span><span>)</span></span>
<span><span>    (</span><span>let</span><span> [res (</span><span>loop</span><span> [acc size-in-bytes</span></span>
<span><span>                     suffixes </span><span>&#34;kMGTPE&#34;</span><span>]</span></span>
<span><span>                (</span><span>if-not</span><span> (</span><span>or</span><span> (</span><span>&lt;=</span><span> acc </span><span>-999950</span><span>) (</span><span>&lt;=</span><span> </span><span>999950</span><span> acc))</span></span>
<span><span>                  {:size acc</span></span>
<span><span>                   :suffix (</span><span>first</span><span> suffixes)}</span></span>
<span><span>                  (</span><span>recur</span><span> (</span><span>/</span><span> acc </span><span>1000</span><span>) (</span><span>drop</span><span> </span><span>1</span><span> suffixes))))]</span></span>
<span><span>      (</span><span>format</span><span> </span><span>&#34;%.1f %cB&#34;</span><span> (</span><span>float</span><span> (</span><span>/</span><span> (:size res) </span><span>1000</span><span>)) (:suffix res)))))</span></span>
<span></span>
<span><span>(</span><span>assert</span><span> (</span><span>=</span><span> </span><span>&#34;0 B&#34;</span><span> (</span><span>size-&gt;human-readable</span><span> </span><span>0</span><span>)))</span></span>
<span><span>(</span><span>assert</span><span> (</span><span>=</span><span> </span><span>&#34;57.0 kB&#34;</span><span> (</span><span>size-&gt;human-readable</span><span> (</span><span>*</span><span> </span><span>57</span><span> </span><span>1000</span><span>))))</span></span>
<span></span></code></pre></div></div></div><div><div><h3>Truncate a string to a max length</h3><p>jank&#39;s strings, as well as most of its other data structures, are immutable. However, jank provides such powerful tools for working with data that mutability is very rarely a concern.</p></div><div><div><pre><code><span><span>(</span><span>def</span><span> max-text-length </span><span>256</span><span>)</span></span>
<span><span>(</span><span>defn</span><span> truncate</span></span>
<span><span>  </span><span>&#34;Truncates the text to be no longer than the max length.&#34;</span></span>
<span><span>  [text max-length]</span></span>
<span><span>  (</span><span>cond</span></span>
<span><span>    (</span><span>&lt;=</span><span> max-length </span><span>0</span><span>)</span></span>
<span><span>    </span><span>&#34;&#34;</span></span>
<span></span>
<span><span>    (</span><span>&lt;=</span><span> (</span><span>count</span><span> text) max-length)</span></span>
<span><span>    text</span></span>
<span></span>
<span><span>    :else</span></span>
<span><span>    (</span><span>str</span><span> (</span><span>subs</span><span> text </span><span>0</span><span> (</span><span>dec</span><span> max-length)) </span><span>&#34;…&#34;</span><span>)))</span></span>
<span></span>
<span><span>(</span><span>assert</span><span> (</span><span>=</span><span> </span><span>&#34;&#34;</span><span> (</span><span>truncate</span><span> </span><span>&#34;wowzer&#34;</span><span> </span><span>0</span><span>)))</span></span>
<span><span>(</span><span>assert</span><span> (</span><span>=</span><span> </span><span>&#34;wow…&#34;</span><span> (</span><span>truncate</span><span> </span><span>&#34;wowzer&#34;</span><span> </span><span>4</span><span>)))</span></span>
<span></span></code></pre></div></div></div><div><div><h3>Redefine any var</h3><p>Every <code>def</code> or <code>defn</code> exists within a var, which is a stable, namespace-level container for values. Vars can be redefined to contain different values. <code>with-redefs</code> redefines a var within its body&#39;s scope, which is very useful for removing side effects from test cases or forcing functions to return specific values.</p></div><div><div><pre><code><span><span>(</span><span>defn</span><span> post! [_request]</span></span>
<span><span>  </span><span>; Assuming this performs some network effect.</span></span>
<span><span>  {:status </span><span>200</span></span>
<span><span>   :body (</span><span>pr-str</span><span> {:order </span><span>7821</span><span>})})</span></span>
<span></span>
<span><span>(</span><span>defn</span><span> submit-order! []</span></span>
<span><span>  (</span><span>let</span><span> [request {:url </span><span>&#34;/submit-order&#34;</span><span>}</span></span>
<span><span>        order (</span><span>post!</span><span> request)</span></span>
<span><span>        order-body (</span><span>-&gt;</span><span> order :body read-string)]</span></span>
<span><span>    (</span><span>if</span><span> (</span><span>contains?</span><span> order-body :error)</span></span>
<span><span>      </span><span>; This is the code path we want to test.</span></span>
<span><span>      {:error </span><span>&#34;failed to submit&#34;</span></span>
<span><span>       :request request</span></span>
<span><span>       :response order-body}</span></span>
<span><span>      (:order order-body))))</span></span>
<span></span>
<span><span>; Later on, in tests, skip the side effect by redefining.</span></span>
<span><span>(</span><span>deftest</span><span> submit-order</span></span>
<span><span>  (</span><span>testing</span><span> </span><span>&#34;failed post&#34;</span></span>
<span><span>    (</span><span>with-redefs</span><span> [post! (</span><span>fn</span><span> [_]</span></span>
<span><span>                          </span><span>; Fake error to see how the rest of the code handles it.</span></span>
<span><span>                          {:status </span><span>500</span></span>
<span><span>                           :body (</span><span>pr-str</span><span> {:error </span><span>&#34;uh oh&#34;</span><span>})})]</span></span>
<span><span>      (</span><span>is</span><span> (</span><span>=</span><span> </span><span>&#34;failed to submit&#34;</span><span> (:error (</span><span>submit-order!</span><span>)))))))</span></span>
<span></span></code></pre></div></div></div></div></section></div></div>
  </body>
</html>
