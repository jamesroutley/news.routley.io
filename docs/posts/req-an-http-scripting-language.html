<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrewpillar.com/programming/2022/02/26/req-an-http-scripting-language/">Original</a>
    <h1>Req â€“ An HTTP Scripting Language</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
				
				<div><p>Programming languages are always something that have fascinated me, how they&#39;re
designed, how they&#39;re implemented, and how they&#39;re used. Whether they&#39;re a DSL
(domain specific language) or more of a generic programming language. A
programming language is always something I had wanted to take a stab at
creating, even if it ended up being terrible, or being of no true utility, but
only for the sake of learning. Well, over the Christmas break I decided to
occupy my time on developing a language, one that was small and simple, designed
for a specific use case that I had encountered but hadn&#39;t found a solution for.
The language that I ended up developing was <a href="https://github.com/andrewpillar/req">req</a>, a language designed
only for HTTP scripting.</p>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#why">Why</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="overview">Overview</h2>
<p>What do I mean when I say HTTP scripting? Perhaps an example would be best to
demonstrate, followed by an explanation,</p>
<pre><code>Token = env &#34;GH_TOKEN&#34;;
Headers = (
    Authorizationn: &#34;Bearer $(Token)&#34;,
);

Resp = GET &#34;https://api.github.com/user&#34; $Headers -&gt; send;

if $Resp.StatusCode == 200 {
    User = decode json $Resp.Body;
    writeln _ &#34;Hello $(User[&#34;login&#34;])&#34;;
}
</code></pre>
<p>Above is what req looks like. It looks like your typical language, however it
offers first-class support for making HTTP requests and working with their
responses. The language makes use of builtin commands to handle the sending
of requests, the encoding/decoding of data, and the reading/writing of data.
These commands also return values that can be stored in variables. The output
of one command can be sent as the input of another command via the <code>-&gt;</code>
operator. There is no support for user defined commands.</p>
<p>That&#39;s what the language looks like, and this is how it is run,</p>
<pre><code>$ req user.req
</code></pre>
<p>the above example makes use of the <code>GH_TOKEN</code> environment variable, so if we
wanted it to actually function we would need to make sure that was set
before invocation,</p>
<pre><code>$ GH_TOKEN=&lt;token&gt; req user.req
</code></pre>
<p>So, from a brief overview you can see that there is some familiarity with other
languages out there. I call this a scripting language, as opposed to a
programming language, as it is interpreted, and extremely limited in scope and
capabilities.</p>
<p>req can also be used via the REPL, which is accessed simply by invoking the
binary and passing no arguments to it. This can be used as a scratchpad to plan
out what you want your scripts to do, or as a means of exploring an HTTP service
and its endpoints,</p>
<pre><code>$ req
req devel a5ddbe7 Sat Jan 29 11:34:38 2022 +0000
&gt; Resp = GET &#34;https://httpbin.org/json&#34; -&gt; send
&gt; writeln _ $Resp
HTTP/2.0 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Content-Length: 429
Content-Type: application/json
Date: Sat, 26 Feb 2022 14:14:56 GMT
Server: gunicorn/19.9.0

{
  &#34;slideshow&#34;: {
    &#34;author&#34;: &#34;Yours Truly&#34;,
    &#34;date&#34;: &#34;date of publication&#34;,
    &#34;slides&#34;: [
      {
        &#34;title&#34;: &#34;Wake up to WonderWidgets!&#34;,
        &#34;type&#34;: &#34;all&#34;
      },
      {
        &#34;items&#34;: [
          &#34;Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great&#34;,
          &#34;Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets&#34;
        ],
        &#34;title&#34;: &#34;Overview&#34;,
        &#34;type&#34;: &#34;all&#34;
      }
    ],
    &#34;title&#34;: &#34;Sample Slide Show&#34;
  }
}
</code></pre>
<h2 id="why">Why</h2>
<p>Now, why did I want to create yet another scripting language. Two reasons.</p>
<p>The first was for the sake of learning. Some time ago I had received copies of
the books <a href="https://interpreterbook.com/">Writing An Interpreter In Go</a> and
<a href="https://compilerbook.com/">Writing A Compiler In Go</a>. I had worked through the
first book at the start of 2020, and enjoyed what I had learned, wanted to put
what I had learned to practice. At the time however, I couldn&#39;t think of a fun
or interesting language that I would have wanted to develop, so I shelved the
prospect of it for some time, which brings me to my second reason...</p>
<p>I think most developers have to interact with an HTTP service at some point
during their day job, in a way which would require some form of scripting.
Perhaps you&#39;re trying to debug an API, so you pull open a terminal and fire off
a few <a href="https://curl.se/">curl</a> requests, and see what response comes back. Or maybe you
want to scrape a site for its information. Either way, you&#39;re doing something
that involves some tinkering.</p>
<p>I have been there too. And it is this scenario that made me wonder if there was
a tool out there that allowed for easily working with HTTP requests and their
responses in a programmatic way. Sure, you could use curl and shell scripting,
and wrangle the data through sed, awk, and jq to get the data you need, but this
approach can be fragile. On the other hand you could use a full fledged
programming language. This way, you would have more control, but it can be
perhaps a bit too verbose at times if all you want to do is send off an HTTP
request.</p>
<p>This is was prompted my development on req. A high-level scripting language that
allows you to easily send out HTTP requests, and work with their responses. The
main benefit of the language, in my opinion, is that it tries to make working
with HTTP requests as semantic as possible, take the following,</p>
<pre><code>Resp = GET &#34;https://httpbin.org/json&#34; -&gt; send;
</code></pre>
<p>here we want to send a <code>GET</code> request to the <code>https://httpbin.org/json</code> endpoint.
Writing this out either in a script or the REPL can feel more natural than what
you might otherwise write when using curl, for example. Then let&#39;s say we want
to decode the response data into JSON,</p>
<pre><code>Data = decode json $Resp.Body;
</code></pre>
<p>again, it&#39;s like we&#39;re describing what we want to do with the response. This is
what I wanted to achieve with this language, keep it limited in scope, and
hopefully offer some utility in the realm of HTTP scripting.</p>
<h2 id="conclusion">Conclusion</h2>
<p>What I&#39;ve covered in this post is a simple overview of the language, and the
reasons behind it&#39;s implementation. I haven&#39;t gone into my justifications
as to how/why the language was designed the way it was, but that could perhaps
be another post down the line. If what I&#39;ve shown so far interests you, then
feel free to take a look at the code for it on GitHub:
<a href="https://github.com/andrewpillar/req">https://github.com/andrewpillar/req</a> and feel free to spool through the
<a href="https://github.com/andrewpillar/req/tree/main/docs">documentation</a> there too, to get a sense of the language.</p>
</div>
			</div>
			


		</div></div>
  </body>
</html>
