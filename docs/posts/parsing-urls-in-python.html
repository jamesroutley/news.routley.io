<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tkte.ch/articles/2024/03/15/parsing-urls-in-python.html">Original</a>
    <h1>Parsing URLs in Python</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    <header>
      
    </header>
    <section>
      <p>tl;dr - Try <a href="https://github.com/tktech/can_ada">can_ada</a> if you need to parse URLs in Python.</p>
<h2>URLs</h2>
<p>Parsing URLs <em>correctly</em> is surprisingly hard. Who even defines what a &#34;correct&#34;
URL is? URLs have evolved drastically since they were originally defined in
<a href="https://tools.ietf.org/html/rfc1738">1994</a>. The <a href="https://whatwg.org/">WHATWG</a> has a <a href="https://url.spec.whatwg.org/">URL specification</a> that
is comprehensive and has helped standardize the behavior of URLs across
browsers, but this specification still isn&#39;t universal and ambiguities like
&#34;how many slashes are you allowed&#34; can definitely get on <a href="https://daniel.haxx.se/blog/2017/01/30/one-url-standard-please">your nerves</a>:</p>
<blockquote cite="Daniel Stenberg">
    So browsers accept URLs written with thousands of forward slashes instead of
    two. That is not a good reason for the spec to say that a URL may
    legitimately contain a thousand slashes. I’m totally convinced there’s no
    critical content anywhere using such formatted URLs and no soul will be sad
    if we’d restricted the number to a single-digit. So we should. And yeah,
    then browsers should reject URLs using more.
</blockquote>

<p><em>However</em>, if you&#39;re creating something new and want to handle URLs, the
WHATWG&#39;s URL specification probably is the best place to start.</p>
<h2>URLs in Python</h2>
<p>If you&#39;re working in Python, you&#39;d probably start with the built-in <code>urllib</code>
module. It&#39;s been around forever, but unfortunately it&#39;s not compliant with
<em>any</em> URL specification, either the much older <a href="https://tools.ietf.org/html/rfc3986">rfc3978</a>:</p>
<blockquote cite="CPython source code">
    RFC 3986 is considered the current standard and any future changes to
    urlparse module should conform with it. The urlparse module is
    currently not entirely compliant with this RFC due to defacto
    scenarios for parsing, and for backward compatibility purposes, some
    parsing quirks from older RFCs are retained. The testcases in
    test_urlparse.py provides a good indicator of parsing behavior.
</blockquote>

<p>... or the WHATWG URL Parser spec:</p>
<blockquote cite="CPython source code">
    The WHATWG URL Parser spec should also be considered. We are not compliant
    with it either due to existing user code API behavior expectations (Hyrum&#39;s
    Law). It serves as a useful guide when making changes.
</blockquote>

<p>Having existed for over 16 years, so many projects depend on the urllib module
parsing URLs in <em>exactly</em> the way it does that it&#39;s unlikely to ever change in
any significant fashion.</p>
<h2>Ada</h2>
<p>The <a href="https://github.com/ada-url/ada">Ada</a> project is a new (2024) attempt to create a URL parsing library
that adheres to the WHATWG URL specification and works <a href="https://github.com/ada-url/ada?tab=readme-ov-file#ada-is-fast">really, really fast</a>,
parsing 7 URLs for every 1 parsed by cURL. Written in C++, it now has bindings
to several other languages, including <a href="https://github.com/ada-url/ada-python">Python</a>, and has become the
URL parsing library used by Node.js as of version 18 to great success:</p>
<blockquote cite="State of Node.js Performance 2023">
    Since Node.js 18, a new URL parser dependency was added to Node.js — Ada.
    This addition bumped the Node.js performance when parsing URLs to a new
    level. Some results could reach up to an improvement of 400%.
</blockquote>

<p>The ada-python binding is perfectly functional, and the official binding for the
project. However, the ada-python bindings are built on <a href="https://cffi.readthedocs.io/en/latest/">CFFI</a>, an approach
that has the binding between C and Python written in Python itself, which loses
some of the performance benefits of using Ada in the first place when most of
the time is spent just making the function call.</p>
<h2>can_ada</h2>
<p><a href="https://lemire.me">Daniel Lemire</a>, one of the developers behind the Ada project asked me to
<a href="https://github.com/ada-url/ada-python/pull/1#issuecomment-1550405501">take a look</a> at the ada-python bindings and out of that was born
<a href="https://github.com/tktech/can_ada">can_ada</a>, a new Python binding that uses <a href="https://pybind11.readthedocs.io/en/stable/">pybind11</a> and template magic
to generate the binding code, which is then compiled into a Python extension
module. This approach has the potential to be much faster than the ada-python
bindings, and indeed when comparing the two bindings, the new can_ada binding
is about 2x faster than the ada-python bindings which in turn is about 2x
faster than <code>urllib.parse</code>!</p>
<div><pre><span></span><code><span>---------------------------------------------------------------------------------</span>
<span>Name (time in ms)              Min                 Max                Mean       </span>
<span>---------------------------------------------------------------------------------</span>
<span>test_can_ada_parse         54</span><span>.</span><span>1304 (1</span><span>.</span><span>0)       54</span><span>.</span><span>6734 (1</span><span>.</span><span>0)       54</span><span>.</span><span>3699 (1</span><span>.</span><span>0) </span>
<span>test_ada_python_parse     107</span><span>.</span><span>5653 (1</span><span>.</span><span>99)     108</span><span>.</span><span>1666 (1</span><span>.</span><span>98)     107</span><span>.</span><span>7817 (1</span><span>.</span><span>98)</span>
<span>test_urllib_parse         251</span><span>.</span><span>5167 (4</span><span>.</span><span>65)     255</span><span>.</span><span>1327 (4</span><span>.</span><span>67)     253</span><span>.</span><span>2407 (4</span><span>.</span><span>66)</span>
<span>---------------------------------------------------------------------------------</span>
</code></pre></div>

<p>At the same time, using the pybind11 approach allows for a very succinct and
<a href="https://github.com/TkTech/can_ada/blob/main/src/binding.cpp">readable</a> binding definition, coming in at just <strong>60</strong> lines of code and
almost a 1:1 with the underlying C++ API.</p>
<p>Binary builds are available now for CPython 3.7 to 3.12, and PyPy 3.7 to 3.9 on
many OS&#39;s and architectures. Install it with pip or <a href="https://github.com/tktech/can_ada">get the source</a>:</p>


<h2>Example</h2>
<div><pre><span></span><code><span>import</span> <span>can_ada</span>
<span>urlstring</span> <span>=</span> <span>&#34;https://www.GOoglé.com/./path/../path2/&#34;</span>
<span>url</span> <span>=</span> <span>can_ada</span><span>.</span><span>parse</span><span>(</span><span>urlstring</span><span>)</span>
<span># prints www.xn--googl-fsa.com, the correctly parsed domain name according</span>
<span># to WHATWG</span>
<span>print</span><span>(</span><span>url</span><span>.</span><span>hostname</span><span>)</span>
<span># prints /path2/, which is the correctly parsed pathname according to WHATWG</span>
<span>print</span><span>(</span><span>url</span><span>.</span><span>pathname</span><span>)</span>
</code></pre></div>

<p>Compare this to the urllib version, which is not WHATWG compliant:</p>
<div><pre><span></span><code><span>import</span> <span>urllib.parse</span>
<span>urlstring</span> <span>=</span> <span>&#34;https://www.GOoglé.com/./path/../path2/&#34;</span>
<span>url</span> <span>=</span> <span>urllib</span><span>.</span><span>parse</span><span>.</span><span>urlparse</span><span>(</span><span>urlstring</span><span>)</span>
<span># prints www.googlé.com</span>
<span>print</span><span>(</span><span>url</span><span>.</span><span>hostname</span><span>)</span>
<span># prints /./path/../path2/</span>
<span>print</span><span>(</span><span>url</span><span>.</span><span>path</span><span>)</span>
</code></pre></div>
    </section>
  </article>
</div></div>
  </body>
</html>
