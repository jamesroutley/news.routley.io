<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mbernste.github.io/posts/sourcecoding/">Original</a>
    <h1>Shannon’s Source Coding Theorem (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><header><p><i aria-hidden="true"></i> 13 minute read</p><p><strong><i aria-hidden="true"></i> Published:</strong> <time datetime="2020-10-19T00:00:00-07:00">October 19, 2020</time></p></header><section itemprop="text"><p><em>The mathematical field of information theory attempts to mathematically describe the concept of “information”. In the first two posts, we discussed the concepts of self-information and information entropy. In this post, we step through Shannon’s Source Coding Theorem to see how the information entropy of a probability distribution describes the best-achievable efficiency required to communicate samples from the distribution.</em></p><h2 id="introduction">Introduction</h2><p>So far, we have discussed how, intuitively, according to Information Theory, “information” can be interpreted as the amount of surprise experienced when we learn the outcome of some random process. Information Theory expresses this “surprise” by counting the minimum number of symbols that would be required to communicate the outcome of this random process to another person/agent.</p><p>This idea of measuring “surprise” by some number of “symbols” is made concrete by Shannon’s Source Coding Theorem. Shannon’s Source Coding Theorem tells us that if we wish to communicate samples drawn from some distribution, then on average, we will require at least as many symbols as the <a href="https://mbernste.github.io/posts/entropy/">entropy</a> of that distribution to unambiguously communicate those samples. Said differently, the theorem tells us that the entropy provides a lower bound on how much we can compress our description of the samples from the distribution before we inevitably lose information (“information” used here in the colloquial sense).</p><p>In this post, we will walk through Shannon’s theorem. My understanding of this material came, in part, from watching this excellent series of videos by <a href="https://www.youtube.com/watch?v=UrefKMSEuAI&amp;t=8s">mathematicalmonk on YouTube</a>. This post attempts to distill much of the information presented in these videos in my own words, keeping only the parts of the explanation necessary to get through the theorem.</p><h2 id="encoding-and-communicating-samples-from-a-distribution">Encoding and communicating samples from a distribution</h2><p>Recall from the <a href="https://mbernste.github.io/posts/entropy/">previous post</a>, we discussed how the information entropy of a random variable tells you, on average, the minimum number of symbols that you will need to use to communicate the outcome of a random variable. That is, let us say we have two people, Person A and Person B, who are trying to communicate with one another. Specifically, Person A is observing samples, drawn one at a time, from some distribution X. Person A then wishes to communicate each sample to Person B. For example, \(X\) might be a dice and Person A wishes to communicate to Person B the outcomes of repeated dice rolls.</p><p>This framework is depicted below:</p><center><img src="https://raw.githubusercontent.com/mbernste/mbernste.github.io/master/images/CommunicationChannel.png" alt="drawing" width="800"/></center><p>Let us rigorously describe the mathematical framework in which Person A is communicating messages to Person B. To do so, we will introduce a bunch of fundamental concepts from <a href="https://en.wikipedia.org/wiki/Coding_theory">Coding Theory</a>.</p><p>First, instead of calling each draw from \(X\) a “sample”, we will instead call each draw a <strong>symbol</strong>. The idea here is that Person A is going to come up with some random sequence of symbols, each drawn from a distribution \(X\), and attempt to communicate this random message, composed of the random sequence of symbols, to Person B. We’ll call this random message the <strong>sequence of source symbols</strong>:</p>\[X_1, X_2, X_3, \dots, X_m \overset{\text{i.i.d.}}{\sim} X\]<p>The idea of each \(X_i\) being a “symbol”, intuitively implies that the number of outcomes that each \(X_i\) can take on is finite. To make this concrete, we will assert that \(X\) is a categorical distribution. That is,</p>\[X_1, X_2, X_3, \dots, X_m \overset{\text{i.i.d.}}{\sim} \text{Cat}(\boldsymbol{\theta})\]<p>such that</p>\[\forall i \ X_i \in \mathcal{X}\]<p>where \(\mathcal{X}\) is a finite set of symbols called the <strong>source alphabet</strong> and \(\boldsymbol{\theta}\) is a vector describing the probabilities that a given \(X_i\) will take on a given symbol in \(\mathcal{X}\).</p><p>Before communicating each source symbol $X_i$ to Person B, Person A will first <em>encode</em> each symbol using a <strong>code function</strong> \(C\). The code function \(C\) takes as input a source symbol and outputs a sequence of symbols from a new set of symbols called the <strong>code alphabet</strong>, denoted \(\mathcal{A}\). The code is called a <strong>\(b\)-ary code</strong> if the size of the code alphabet is \(b\). That is, if \(\vert\mathcal{A}\vert = b\). For example, if \(\mathcal{A}\) consists of two symbols, we call the code 2-ary (a.k.a. binary).</p><p>To make this concrete, let’s look at a simplified, 2-ary version of <a href="https://en.wikipedia.org/wiki/Morse_code">Morse Code</a> for encoding the English alphanumeric symbols into two symbols: “dots” and “dashes”. In Morse Code, the source alphabet, \(\mathcal{X}\) consists of the alphanumeric symbols, the code alphabet \(\mathcal{A}\) consists of only a dot and dash, and the code function \(C\) maps each alphanumeric symbol to a sequence of dots and dashes. More specifically:</p><center><img src="https://raw.githubusercontent.com/mbernste/mbernste.github.io/master/images/MorseCode.png" alt="drawing" width="400"/></center><p>For example, the name “Morse” would be encoded as follows:</p><center><img src="https://raw.githubusercontent.com/mbernste/mbernste.github.io/master/images/morse_code_example.png" alt="drawing" width="400"/></center><p>Stated more rigorously, if we denote \(\mathcal{A}^*\) to be the <em>set of sequences</em> of code symbols</p>\[\mathcal{A}^* := \{a_1, a_2, \dots, a_k \mid k \geq 0, \forall i \ a_i \in \mathcal{A}\}\]<p>then \(C\) is a function</p>\[C: \mathcal{X} \rightarrow \mathcal{A}^*\]<p>We refer call each element \(\alpha \in C(\mathcal{X})\) a <strong>code word</strong>, where \(C(\mathcal{X})\) is the <a href="https://en.wikipedia.org/wiki/Image_(mathematics)">image</a> of \(C\). We denote the length of a code word \(\alpha \in C(\mathcal{X})\) as \(\vert\alpha\vert\). In the above example, the length of code word “\(\cdot\) - \(\cdot\)” (i.e. \(C(X_3)\)) is simply 3.</p><p>For the purposes of our discussion, we will focus only on <strong>uniquely decodable</strong> code functions. A code function is uniquely decodable if it is an <a href="https://en.wikipedia.org/wiki/Inverse_function">invertible function</a>. Stated plainly, if a code \(C\) is uniquely decodable, then we can always decode the code words unambiguously into the original sequence of source symbols using the inverse of \(C\). Most codes used in practice are uniquely decodable. A non-uniquely decodable code would not be very useful since Person B who receives the encoded message from Person A would be unable to unambiguously decode Person A’s message.</p><h2 id="shannons-source-coding-theorem">Shannon’s Source Coding Theorem</h2><p>Given some categorical distribution \(X\), Shannon’s Source Code Theorem tells us that no matter what \(C\) you choose, the smallest possible <em>expected code word length</em> is the entropy of \(X\). That is,</p>\[E\left[\vert C(X)\vert \right] = \sum_{x \in \mathcal{X}} \vert C(X) \vert P(X = x) \geq - \sum_{x \in \mathcal{X}} P(X = x)\log P(X = x) = H(X)\]<p>More formally:</p><p><span><strong>Theorem 1 (Shannon’s Source Coding Thoerem):</strong> Given a categorical random variable \(X\) over a finite source alphabet \(\mathcal{X}\) and a code alphabet \(\mathcal{A}\), then for all uniquely decodable \(C : \mathcal{X} \rightarrow \mathcal{A}^*\), it holds that \(E[\vert C(X)\vert] \geq H(X)\).</span></p><p>The expected code word length of \(X\) under some code \(C\) tells us how efficiently one can “compress” the information in \(X\). If on average, \(C\) is able to produce small code words for each symbol drawn from \(X\), then we are able to more efficiently communicate these symbols. Shannon’s Source Coding Theorem tells us that the entropy of \(X\) is, in some sense, the true “information content” of the random variable because there is no \(C\) that will enable you to compress \(X\) past \(X\)’s entropy.</p><h2 id="proof">Proof</h2><p>To prove the theorem, we will utilize another result (which we will prove in another blog post): the converse of the <a href="https://en.wikipedia.org/wiki/Kraft–McMillan_inequality">Kraft-McMillan Inequality</a>. This theorem goes as follows:</p><p><span><strong>Theorem 2 (Converse of Kraft-McMillan Inequality):</strong> Given a finite source alphabet \(\mathcal{X} := \{x_1, x_2, \dots, x_m\}\), an integer \(B\), and a function \(\ell\) where</span></p><center><span>$$\ell: \mathcal{X} \rightarrow \mathbb{Z}+$$</span></center><p><span>(where \(\mathbb{Z}+\) is the set of strictly positive integers) such that</span></p><center><span>$$\sum_{x \in \mathcal{X}} \frac{1}{B^{\ell(x)}} \leq 1$$</span></center><p><span>then there exists a \(B\)-ary uniquely decodable code \(C\).</span></p><p>Basically, this says that if you have some set of integers \(\{\ell(x) \mid x \in \mathcal{X}\}\) that satisfiy a certain inequality, then there exists a uniquely decodable \(C\) that will map each source symbol \(x \in \mathcal{X}\) to a code word with length \(\ell(x)\).</p><p>The Kraft-McMillan Inequality will enable us to formulate an optimization problem that attempts to minimize the expected code word length under some hypothetical code function \(C\) that produces code words of length \(\ell(x)\). That is, where \(\ell(x) = \vert C(x) \vert\). This optimization problem is as follows:</p><center>$$\underset{\ell : \mathcal{X} \rightarrow \mathbb{Z}+}{\text{min}} \sum_{x \in \mathcal{X}} \ell(x) P(X = x)$$</center><p>subject to</p><center>$$\sum_{x \in \mathcal{X}} \frac{1}{B^{\ell(x)}} \leq 1$$</center><p>The constraint in this optimization problem ensures that for any set of code word lengths we consider, according to the Kraft-McMillan inequality there will exist a valid uniquely decodable code!</p><p>To make the notation a bit easier to deal with, let us order the elements of \(\mathcal{X}\) and let \(x_1, x_2, \dots, x_m\) denote each element of \(\mathcal{X}\). Let \(\ell_i := \ell(x_i)\). Finally, let \(p_i := P(X = x_i)\). Now the optimization problem becomes:</p>\[\underset{\ell_1, \ell_2, \dots, \ell_m \in \mathbb{Z}+}{\text{min}} \sum_{i=1}^m \ell_i p_i\]<p>subject to</p>\[\sum_{i=1}^m \frac{1}{B^{\ell_i}} \leq 1\]<p>Before we solve this optimization problem, we note that because we are requiring that \(\ell_1, \ell_2, \dots, \ell_m\) be integers, this optimization problem, called an <a href="https://en.wikipedia.org/wiki/Integer_programming">integer program</a>, is challenging to solve due to the discrete nature of the <a href="https://en.wikipedia.org/wiki/Feasible_region#:~:text=In%20mathematical%20optimization%2C%20a%20feasible,%2C%20equalities%2C%20and%20integer%20constraints">feasible set</a>. We will thus <em>relax</em> this optimization problem by enabling the \(\ell_1, \ell_2, \dots, \ell_m\) values to be any real number instead of requiring them to be integers. Thus, the optimization problem becomes:</p>\[\underset{\ell_1, \ell_2, \dots, \ell_m \in \mathbb{R}}{\text{min}} \sum_{i=1}^m \ell_i p_i\]<p>subject to</p>\[\sum_{i=1}^m \frac{1}{B^{\ell_i}} \leq 1\]<p>You may notice a problem with this relaxation. What if the solution to this problem has fractional or negative values for any of the \(\ell_1, \ell_2, \dots, \ell_m\)? What does it mean to have a negative code word length? Indeed, this is concerning; however, we note that our relaxation has <em>expanded</em> the feasible set from only positive integers to <em>all</em> real numbers. Thus, if we evaluate the objective function at the solution to this relaxed optimization problem, the value for the objective function will be <em>at least as small</em> as the objective function evaluated at the solution to the non-relaxed problem. Thus, this solution will still lead us to a lower bound for the expected code word length!</p><p>Okay, so are goal right now is to solve this relaxed optimization problem. How do we do it? We’re now going to show that this optimization problem can be re-formulated to an equivalent optimization problem in which the inequality in the constraint becomes an equality:</p>\[\underset{\ell_1, \ell_2, \dots, \ell_m \in \mathbb{R}}{\text{min}} \sum_{i=1}^m \ell_i p_i\]<p>subject to</p>\[\sum_{i=1}^m \frac{1}{B^{\ell_i}} = 1\]<p>To show that this is truly equivalent, we will use a quick proof by contradiction. Let’s let \(\ell_1^*, \ell_2^*, \dots, \ell_m^*\) be the values for \(\ell_1, \ell_2, \dots, \ell_m\) that solve the optimization problem. Now, let’s assume, for the sake of contradiction, that this solution is such that the summation in the constraint is strictly less than one:</p>\[\sum_{i=1}^m \frac{1}{B^{\ell_i^*}} &lt; 1\]<p>What would this assumption imply? First, it implies that every \(\ell_i^*\) <em>must</em> be strictly greater than 0. Too see why, assume that for some \(i\), \(\ell_i^* \leq 0\). Under this scenario</p>\[\ell_i \leq 0 \implies \frac{1}{B^{\ell_i^*}} \geq 1 \implies \sum_{i=1}^m \frac{1}{B^{\ell_i^*}} \geq 1\]<p>which breaks our assumption. So under this assumption, each \(\ell_i^*\) is strictly positive.</p><p>Now, let’s look at the objective function. Because we assume that \(\ell_1^*, \ell_2^*, \dots, \ell_m^*\) is a solution, it thus minimizes the objective function \(\sum_{i=1}^m \ell_i p_i\). However, there is nothing stopping us from choosing new values for each \(\ell_i\), which we denote \(\ell_i^{**}\) such that \(0 &lt; \ell_i^{**} &lt; \ell_i^*\). If we do so, then it follows that the objective function will be smaller for these new values. That is,</p>\[0 &lt; \ell_i^{**} &lt; \ell_i^* \implies \sum_{i=1}^m \ell_i^{**} p_i &lt; \sum_{i=1}^m \ell_i^* p_i\]<p>Because \(\ell_i^{**}\) further minimizes the objective function, it must be the case that \(\ell_i^*\) is not the true solution! Thus, our original assumption that the solution leads to \(\sum_{i=1}^m \frac{1}{B^{\ell_i}} &lt; 1\) must be wrong! Indeed, it must be the case that</p>\[\sum_{i=1}^m \frac{1}{B^{\ell_i^*}} = 1\]<p>So far, we’ve made a bunch of changes to this optimization problem to make it ever more straightforward to solve. Can we go further? Let’s do a quick change of variables and let</p>\[q_i := \frac{1}{B^{\ell_i}}\]<p>This then implies that</p>\[\ell_i = \log_B \frac{1}{q_i}\]<p>which leads to a new form of the optimziation problem:</p>\[\underset{q_1, q_2, \dots, q_m \in \mathbb{R}+}{\text{min}} \sum_{i=1}^m p_i \log_B \frac{1}{q_i}\]<p>subject to</p>\[\sum_{i=1}^m q_i = 1\]<p>where \(\mathbb{R}+\) is the set of strictly positive real numbers. This optimization problem can now easily be solved using <a href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=lagrange+multipliers&amp;ie=UTF-8&amp;oe=UTF-8">Lagrange Multipliers</a>!</p><p>To do so, we form the Lagrangian:</p>\[\mathcal{L}(q_1, \dots, q_m, \lambda) := \sum_{i=1}^m p_i \log_B \frac{1}{q_i} + \lambda\left(\sum_i q_i - 1\right)\]<p>We now compute the partial derivative with respect to each \(q_i\) and set it to 0:</p>\[\begin{align*} \frac{\partial}{\partial q_i} \sum_{i=1}^m p_i \log_B \frac{1}{q_i} + \lambda\left(\sum_i q_i - 1\right) &amp;= 0 \\ \implies -\frac{p_i}{q_i \log B} + \lambda &amp;= 0 \\ \implies q_i &amp;= \frac{p_i}{\lambda \log B}\end{align*}\]<p>Now, with the the equation \(\sum_{i=1}^m q_i = 1\) and each partial derivative set to zero, we solve for \(q_i\) and \(\lambda\). Plugging \(q_i = \frac{p_i}{\lambda \log B}\) into the equation \(\sum_{i=1}^m q_i = 1\), we get</p>\[\lambda \log B = \sum_{i=1}^m p_i \implies \lambda \log B = 1 \implies \lambda = \frac{1}{\log B}\]<p>Finally we plug this back into each \(q_i = \frac{p_i}{\lambda \log B}\) and see that</p>\[\forall i, \ p_i = q_i\]<p>Recall, each \(q_i\) is a variable that we substituted for \(\frac{1}{B^{\ell_i}}\), which means that our final solution is given by</p>\[\ell_i^* = \log_B \frac{1}{p_i}\]<p>Plugging in this solution to the objective function we arrive at our final lower bound on the expected code word length! It is simply</p>\[\sum_{i=1}^m p_i \log_B \frac{1}{p_i}\]<p>This is precisely the entropy of \(X\)!</p></section></div></div>
  </body>
</html>
