<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://litchipi.github.io/infosec/2023/01/24/git-code-audit-viewed-as-rust-programmer.html">Original</a>
    <h1>The Git source code audit, viewed as a Rust programmer</h1>
    
    <div id="readability-page-1" class="page"><div> <p>On January 17th 2023, <strong>X41</strong> and <strong>Gitlab</strong> published a report of the source code audit they performed on Git (funded by the <strong>OSTIF</strong> foundation).</p> <p>This post is based on the (<em>great</em>) report available <a href="https://www.x41-dsec.de/static/reports/X41-OSTIF-Gitlab-Git-Security-Audit-20230117-public.pdf">here</a> and aims to investigate how Rust mitigates some of the vulnerabilities shown in this report, but also to put some light on <strong>what it doesn’t</strong> mitigate by itself, and how a programmer can address these issues using good practices.</p> <blockquote> <p>The role of these kinds of studies are primordial, and the <strong>OSTIF</strong> allows to fund such initiatives. </p> </blockquote> <p>If I say anthing that is wrong / oversimplified, <em>do tell me please</em> and I will correct this article in consequence.</p>  <p>The explanations are <em>intentionally kept simple</em>, please refer to the corresponding report section for more informations. </p> <h2 id="git-cr-22-01">GIT-CR-22-01</h2> <p>This vulnerability (described at section <em>4.1.1</em>) is an <em>Uncontrolled Resource Consumption</em> (<a href="https://cwe.mitre.org/data/definitions/400.html">CWE 400</a>), leading to a possible Denial of Service. </p> <div><div><pre><code><span>while</span> <span>(</span><span>slen</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>int</span> <span>len</span> <span>=</span> <span>slen</span><span>;</span>      <span>// Here if slen is too big, it loops backs to 0</span>
    <span>// Allocate some memory</span>
    <span>slen</span> <span>-=</span> <span>len</span><span>;</span>        <span>// len = 0, slen &gt; 0, so the loop goes infinite</span>
<span>}</span>
</code></pre></div></div> <p>When the input text grows, the value of <code>slen</code> does as well, and researchers suceeded to allocate <strong>2.5GB</strong> of memory using a <em>30MB</em> file.</p> <p>Let’s try to reproduce the same kind of loop in Rust now:</p> <div><div><pre><code><span>let</span> <span>mut</span> <span>slen</span><span>:</span> <span>u64</span> <span>=</span> <span>(</span><span>u32</span><span>::</span><span>MAX</span> <span>as</span> <span>u64</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>while</span> <span>slen</span> <span>&gt;</span> <span>0</span> <span>{</span>
    <span>let</span> <span>len</span><span>:</span> <span>u32</span> <span>=</span> <span>slen</span> <span>as</span> <span>u32</span><span>;</span>
    <span>println!</span><span>(</span><span>&#34;Some memory allocation&#34;</span><span>);</span>
    <span>slen</span> <span>-=</span> <span>len</span> <span>as</span> <span>u64</span><span>;</span>
<span>}</span>
</code></pre></div></div> <p>This code compiles without any warning and gives you a nice infinite loop indeed. </p> <p>Lesson number one: <strong>Rust doesn’t protect from casting overflows</strong> if you cast naively using <code>as</code>. However you can use the <code>try_into</code> function for casting that will return a <code>Result&lt;T, T::Error&gt;</code> triggered if such things happen.</p> <h2 id="git-cr-22-02">GIT-CR-22-02</h2> <p>This vulnerability (described at section <em>4.1.2</em>) is an <em>Out of Bound Read</em> (<a href="https://cwe.mitre.org/data/definitions/125.html">CWE 125</a>), allowing possible sensitive data reading, or even a buffer overflow.</p> <p>When dealing with strings, the computer maps the data in memory as:</p> <div><div><pre><code>Letters: &#34;r&#34;  &#34;u&#34;  &#34;s&#34;  &#34;t&#34;
Bytes:   0x72 0x75 0x73 0x74 0x00
</code></pre></div></div> <p>Notice the <code>0x00</code> byte at the end ? That’s how the computer can detect the end of the string. </p> <div><div><pre><code><span>int</span> <span>next_char</span> <span>=</span> <span>get_next_char</span><span>(</span><span>some_string</span><span>);</span>
<span>if</span> <span>(</span><span>!</span><span>next_char</span><span>)</span> <span>{</span>
    <span>// The char is the end of the string</span>
<span>}</span>
</code></pre></div></div> <p>However imagine <code>get_next_char</code> doesn’t return the value, but <em>a pointer</em> to this value, then <code>!char</code> doesn’t check if the value is <code>0</code> anymore, but it checks if the <em>pointer is a <code>NULL</code> pointer</em>, which <strong>it won’t be</strong> even if its value may be <code>0</code>.</p> <p>This vulnerability is a clever exploit of how the code <em>forgets to dereference</em> the returned pointer (pointing to somewhere in the string) when performing a condition. Because this condition will be <em>always true</em>, it allows the execution of a function with invalid inputs, leading to the vulnerable behavior.</p> <p>In Rust, you have to use an explicit <code>unsafe</code> block to perform operations on raw pointers like this, and that doesn’t give you the “full power”. </p> <p>You should <strong>not use unsafe</strong> Rust as long as you don’t have a <em>very specific reason</em> to use it.</p> <h2 id="git-cr-22-03">GIT-CR-22-03</h2> <p>This vulnerability (described at section <em>4.1.3</em>) is an <em>Integer overflow to Buffer overflow</em> (<a href="https://cwe.mitre.org/data/definitions/680.html">CWE 680</a>), that could lead to code execution.</p> <p>The issue here is that in Windows 64bit, the size of an <code>unsigned long</code> is <strong>4 bytes</strong>, whereas it is <strong>8 bytes</strong> on Linux 64bit. </p> <div><div><pre><code><span>size_t</span> <span>msg_A_len</span> <span>=</span> <span>get_message_length</span><span>(</span><span>msg_a</span><span>);</span>
<span>size_t</span> <span>msg_B_len</span> <span>=</span> <span>get_message_length</span><span>(</span><span>msg_b</span><span>);</span>
<span>unsigned</span> <span>long</span> <span>new_buffer_len</span> <span>=</span> <span>msg_A_len</span> <span>+</span> <span>msg_B_len</span> <span>+</span> <span>2</span><span>;</span>
</code></pre></div></div> <p>Indeed, we can overflow the bounds of the <code>unsigned long new_buffer_len</code>, looping back to <code>0</code>. Now we can get big inputs that make the <code>new_buffer_len</code> variable small. </p> <div><div><pre><code><span>char</span><span>*</span> <span>new_buffer</span> <span>=</span> <span>malloc</span><span>(</span><span>new_buffer_len</span><span>);</span>
<span>memcpy</span><span>(</span><span>new_buffer</span><span>,</span> <span>msg_a</span><span>,</span> <span>msg_A_len</span><span>);</span>
<span>memcpy</span><span>(</span><span>new_buffer</span> <span>+</span> <span>msg_A_len</span><span>,</span> <span>msg_b</span><span>,</span> <span>msg_B_len</span><span>);</span>
</code></pre></div></div> <p>In the case when <code>new_buffer_len &lt; (msg_A_len + msg_B_len)</code>, that would mean we just <em>wrote more bytes</em> into memory than the allocated <em>memory was able to contain</em>, we just <strong>overflowed</strong> the buffer.</p> <p>Now let’s do something similar in Rust shall we ?</p> <div><div><pre><code><span>println!</span><span>(</span><span>&#34;size of usize: {}&#34;</span><span>,</span> <span>std</span><span>::</span><span>mem</span><span>::</span><span>size_of</span><span>::</span><span>&lt;</span><span>usize</span><span>&gt;</span><span>());</span>
<span>// size of usize: 8</span>

<span>let</span> <span>msg_a_len</span><span>:</span> <span>u64</span> <span>=</span> <span>u64</span><span>::</span><span>MAX</span> <span>&gt;&gt;</span> <span>1</span><span>;</span>
<span>let</span> <span>msg_b_len</span><span>:</span> <span>u64</span> <span>=</span> <span>u64</span><span>::</span><span>MAX</span> <span>&gt;&gt;</span> <span>1</span><span>;</span>
<span>assert_eq!</span><span>(</span><span>msg_a_len</span> <span>+</span> <span>msg_b_len</span> <span>+</span> <span>1</span><span>,</span> <span>u64</span><span>::</span><span>MAX</span><span>);</span>

<span>let</span> <span>new_buffer_len</span><span>:</span> <span>usize</span> <span>=</span> <span>(</span><span>msg_a_len</span> <span>as</span> <span>usize</span><span>)</span> <span>+</span> <span>(</span><span>msg_b_len</span> <span>as</span> <span>usize</span><span>)</span> <span>+</span> <span>3</span><span>;</span>
<span>// debug compilation:     thread panick here because of integer overflow</span>

<span>let</span> <span>some_array</span><span>:</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span> <span>=</span> <span>Vec</span><span>::</span><span>with_capacity</span><span>(</span><span>new_buffer_len</span><span>);</span>
<span>println!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>some_array</span><span>.capacity</span><span>());</span>
<span>// release compilation:         1</span>
</code></pre></div></div> <p>Several things on this:</p> <ul> <li>I am running on a <code>x86_64</code> machine, meaning <code>usize</code> is the same length as an <code>u64</code>, so this code does not reproduce what actually happens in this vulnerability.</li> <li>Notice the casts that we are required to do in order to make this compile, <em>this is a hint</em> that the programmer have to check his bounds.</li> <li>The overflow protection is only on in <code>debug</code> mode (and can be set/unset in the <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">compilation profile</a>)</li> <li>This code <strong>cannot be exploited</strong> in safe code to perform a <em>memory overflow</em>, because you would have to use a <code>Vec</code> here, which has <em>all the safeguards</em> to not overflow. Arrays are <em>not possible</em> here as their size has to be known at compile time.</li> <li>The size of each numeric type (except <code>usize</code>) <em>is obvious</em> to the developper and <em>doesn’t change</em> across platforms, this is by itself a great protection as long as we pay attention to the types we use. (<code>let size: i32</code> is not a good practice at all.)</li> </ul> <p>This kinds of issues can <strong>definitly happen</strong> in Rust if you use <code>as</code> castings all the time, and even if the memory size of variable is much more simple in Rust than in C, <code>usize</code> size in memory is arch-dependant (as described in the <a href="https://doc.rust-lang.org/std/primitive.usize.html">usize type documentation</a>).</p> <p>The issue may exist in Rust, but the <strong>memory vulnerability</strong> doesn’t (at least in safe Rust), attempts to write something and run some code would lead to the program termination.</p> <h2 id="git-cr-22-04">GIT-CR-22-04</h2> <p>This vulnerability (described at section <em>4.1.4</em>) is a <em>Synchronous Access of Remote Resource without Timeout</em> (<a href="https://cwe.mitre.org/data/definitions/1088.html">CWE 1088</a>), leading to a possible Denial of Service.</p> <p>This issue is really simple to understand. When initiating a new connection for a <code>git clone</code> operation, no timeout is set, meaning that if the remote endpoint doesn’t answer, the connection is kept open.</p> <p>If an attacker open X connections to endpoints he controls (and that doesn’t send any data), then the connections are kept active in <code>git</code>, the resources aren’t freed, leading to a Denial of Service.</p> <p>Rust is not really protected by that kinds of things, and it’s to the attention of the developper to pay attention to <em>always</em> put some kind of <em>boundaries</em> to the connections, wether it is a hard limit of simultaneously opened connections, a timeout, etc …</p> <p>Timeouts can be annoying to set up, but they may really be worth it as there is nothing as unexpected as a bad Internet connection, a crash from a distant server, or any kind of I/O scenario a sane programmer wouldn’t think of.</p> <p>Even a long one is useful for these cases.</p> <h2 id="git-cr-22-05">GIT-CR-22-05</h2> <p>This vulnerability (described at section <em>4.1.5</em>) is an <em>Inefficient Regular Expression Complexity</em> (<a href="https://cwe.mitre.org/data/definitions/1333.html">CWE 1333</a>), leading to a possible Denial of Service by consumming excessive CPU resources.</p> <p>This vulnerability happens because somewhere in the code, the user input gets interpreted as a regular expression. </p> <p>See the <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS">OWASP article</a> about this kind of attacks.</p> <p>For the <a href="https://docs.rs/regex/latest/regex/">regex</a> crate, the reference when dealing with regular expressions in Rust, the security is taken seriously and some features at the root cause of this kind of problems are simply not implemented. That mean that the crate is less powerful than other systems out there, but it is a tradeoff that the developpers chose to make.</p> <p>See the “<a href="https://docs.rs/regex/latest/regex/#untrusted-input">Untrusted inputs</a>” section from the docs of the crate for more details</p> <h2 id="git-cr-22-06">GIT-CR-22-06</h2> <p>This vulnerability (described at section <em>4.1.6</em>) is a <em>Heap-based Buffer Overflow</em> (<a href="https://cwe.mitre.org/data/definitions/122.html">CWE 122</a>), leading in the worst case scenario to arbitrary code execution.</p> <p>This is also a vulnerability caused by the overflow of the type <code>int</code> when getting numbers bigger than its bounds and loops back to the minimum bound, in this case negative:</p> <div><div><pre><code><span>size_t</span> <span>len</span> <span>=</span> <span>get_length</span><span>(</span><span>buffer</span><span>);</span>
<span>size_t</span> <span>padding</span> <span>=</span> <span>get_padding</span><span>(</span><span>input_string</span><span>);</span>

<span>int</span> <span>offset</span> <span>=</span> <span>padding</span> <span>-</span> <span>len</span><span>;</span>
<span>memcpy</span><span>(</span><span>buff</span> <span>+</span> <span>offset</span><span>,</span> <span>input_string</span><span>,</span> <span>len</span><span>);</span>
</code></pre></div></div> <p>However here this is much more problematic as it allows to set a negative offset, and so perform a <code>memcpy</code> operation <strong>before</strong> the start of the buffer, and write data controlled by the attacker.</p> <p>Heap overflows may not be as bad as Stack overflows, but they do have really nasty exploit possible (see <a href="https://ctf101.org/binary-exploitation/heap-exploitation/">CTF101 article</a> about it).</p> <p>Now would that kind of things be possible in a world covered in (<em>safe</em>) Rust ? </p> <p>However you would have to choose between different types to use, meaning that for this situation to happen, you would have to explicitly write <code>i64 offset</code>, as <code>usize</code> is unsigned and neither are <code>u8 u16 u32 u64</code>.</p> <p>I decided to count this as a <em>protection</em>, as the amount of work required to make this behavior happen assures that you brought it on yourself. </p> <div><div><pre><code><span>let</span> <span>input_string</span> <span>=</span> <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;this is longer than the length of the buffer&#34;</span><span>);</span>
<span>let</span> <span>strlen</span><span>:</span> <span>usize</span> <span>=</span> <span>input_string</span><span>.len</span><span>();</span>

<span>let</span> <span>bufflen</span><span>:</span> <span>usize</span> <span>=</span> <span>10</span><span>;</span>
<span>let</span> <span>buffer</span> <span>=</span> <span>String</span><span>::</span><span>with_capacity</span><span>(</span><span>bufflen</span><span>);</span>

<span>let</span> <span>offset</span><span>:</span> <span>i64</span> <span>=</span> <span>(</span><span>bufflen</span> <span>as</span> <span>i64</span><span>)</span> <span>-</span> <span>(</span><span>strlen</span> <span>as</span> <span>i64</span><span>);</span>
<span>let</span> <span>ptr</span> <span>=</span> <span>buffer</span><span>.as_mut_ptr</span><span>();</span>
<span>unsafe</span> <span>{</span>
    <span>std</span><span>::</span><span>ptr</span><span>::</span><span>copy</span><span>(</span><span>input_string</span><span>.as_ptr</span><span>(),</span> <span>ptr</span><span>.offset</span><span>(</span><span>offset</span><span>),</span> <span>input_string</span><span>.len</span><span>());</span>
<span>}</span>
</code></pre></div></div> <blockquote> <p>Thanks to <code>u/pluuth</code> for pointing out the correct unsafe code here, I previously thought it was much more complex to get an issue like this to appear in Rust. I still count it as “protected” because of the mandatory <code>unsafe</code> block and the type casts you need to use.</p> </blockquote> <h2 id="git-cr-22-07">GIT-CR-22-07</h2> <p>This vulnerability (described at section <em>4.1.7</em>) is another <em>Heap-based Buffer Overflow</em> (<a href="https://cwe.mitre.org/data/definitions/122.html">CWE 122</a>), similarly leading in the worst case scenario to arbitrary code execution.</p> <p>This is yet another <code>int</code> type overflow when handling big inputs (displaying how important this is), however this vulnerability is really <strong>critical</strong> as now an attacker can commit a malicious <code>.gitattributes</code> file into a remote repository, and the vulnerability will be triggered to anybody trying to <code>clone</code> or <code>pull</code> the repository.</p> <p>Here the recommendation for this issue is to use a <code>size_t</code> type in order to prevent the integer overflow, however it’s also pointed out to <strong>limit the size</strong> of the lines in the <code>.gitattributes</code> file.</p> <p>However as this is can be only exploited for memory manipulation, this is where (safe) Rust protects us. It becomes critical because of the possible arbitrary code execution following, however this could be used in Rust to create <em>infinite loops</em>, trigger conditions, etc …</p> <h2 id="git-cr-22-08">GIT-CR-22-08</h2> <p>This vulnerability (described at section <em>4.1.8</em>) is an <em>Uncontrolled Resource Consumption</em> (<a href="https://cwe.mitre.org/data/definitions/400.html">CWE 400</a>), leading to a possible Denial of Service.</p> <p>The report isn’t really clear about this, but when applying a patch, this code gets triggered:</p> <div><div><pre><code><span>// apply.c:4687</span>
<span>static</span> <span>int</span> <span>apply_patch</span><span>(</span><span>struct</span> <span>apply_state</span> <span>*</span><span>state</span><span>,</span>
		       <span>int</span> <span>fd</span><span>,</span>
		       <span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span>
		       <span>int</span> <span>options</span><span>)</span>
<span>{</span>
    <span>// ...</span>
    <span>offset</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span><span>offset</span> <span>&lt;</span> <span>buf</span><span>.</span><span>len</span><span>)</span> <span>{</span>
            <span>nr</span> <span>=</span> <span>parse_chunk</span><span>(</span><span>state</span><span>,</span> <span>buf</span><span>.</span><span>buf</span> <span>+</span> <span>offset</span><span>,</span> <span>buf</span><span>.</span><span>len</span> <span>-</span> <span>offset</span><span>,</span> <span>patch</span><span>);</span>
            <span>if</span> <span>(</span><span>nr</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
                <span>// Error case</span>
            <span>}</span>
            <span>// Some operations</span>
            <span>offset</span> <span>+=</span> <span>nr</span><span>;</span>
    <span>}</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div> <p>The vulnerability here comes from an issue making the <code>parse_chunk</code> returns 0, resulting in an infinite loop.</p> <p>It’s caused by yet another integer overflow, when parsing a <em>binary patch</em> file. With a header / payload long enough, you can overflow the variables, and the return value from the function gets overflowed:</p> <div><div><pre><code><span>// apply.c:2124</span>
<span>static</span> <span>int</span> <span>parse_chunk</span><span>(</span><span>struct</span> <span>apply_state</span> <span>*</span><span>state</span><span>,</span>
                       <span>char</span> <span>*</span><span>buffer</span><span>,</span> <span>unsigned</span> <span>long</span> <span>size</span><span>,</span> <span>struct</span> <span>patch</span> <span>*</span><span>patch</span><span>)</span>
<span>{</span>
    <span>// ...</span>
    <span>return</span> <span>offset</span> <span>+</span> <span>hdrsize</span> <span>+</span> <span>patchsize</span><span>;</span>
<span>}</span>
</code></pre></div></div> <p>As an <code>int</code> can be overflowed to a negative value, a malicious patch can return <code>0</code> here, and performing a <code>git apply</code> over the patch would result in an infinite loop, and a Denial of Service.</p> <p>This is a case that <em>could totally apply</em> to a Rust code if we are not careful enough, the best protection is to <strong>use proper numeric types</strong> to ensure a size doesn’t get negative, but you should also <em>learn to notice</em> the conditions that would make any loop go infinite, and check for these conditions.</p>  <p>Remember that the Rust “safety” is only relative and under particular conditions, it’s not the same if you are writing for embedded systems, or in the Linux kernel (as <a href="https://lkml.org/lkml/2022/9/19/1105">Linus explained</a> in some of the mails), and it only works if <em>you set up</em> everything Rust needs to achieve safety</p> <blockquote> <p>And the <em>reality</em> is that there are no absolute guarantees. Ever. </p> </blockquote> <p>Rust is implemented so it eliminates undefined behaviors, and handles the “wrong answer” case by returning an error, or panicking. This is a choice that makes total sense when building a software / an application, but it’s not a universal “best way to do”, it depends on what you do.</p> <blockquote> <p>Not completing the operation at all, is <em>not</em> really any better than getting the wrong answer, it’s only more debuggable. </p> </blockquote> <p>Let’s review some good practices (generally speaking) in Rust to ensure we don’t hit too much errors, or create some vulnerabilities.</p> <h2 id="casting-overflow">Casting overflow</h2> <p>If you upcast <code>u32</code> to <code>u64</code>, you can use the keyword <code>as</code>, but when you downcast <code>u64</code> to <code>u32</code>, use <code>try_into</code> instead. </p> <p>As <code>usize</code> size in memory is arch-dependant (see <a href="https://doc.rust-lang.org/std/primitive.usize.html">the docs</a>), I advice to use numeric variable types that have a fixed memory space, like <code>u64</code>, <code>i32</code> or <code>f32</code>, as much as possible to reduce the possibility of an integer overflow panick. </p> <h2 id="limit-input-size">Limit input size</h2> <p>This isn’t specific to Rust, but why using <code>u64</code> and checking for overflows everywhere when you can simply <em>limit</em> any input length is <code>&lt; u8::MAX</code> ? (Or whatever type you use)</p> <p>Input sanitization is important, and the size of the input is one aspects of it, you should never overlook it as it can lead to nasty behaviors. You may think that “it will never happen, to have a blog post title larger than 65536 characters”, but an attacker <em>will</em> think of this case, and <strong>break</strong> your code.</p> <h2 id="unsafe-rust">Unsafe Rust</h2> <p>If you use some <em>unsafe</em> in your Rust code, be <strong>very careful</strong> of what is written inside, make it <em>as little</em> as possible, as <em>tested</em> as possible, and only if you cannot make it using <em>another way</em>.</p> <p>It may be ok to use unsafe blocks in these situations:</p> <ul> <li>Writing to a memory address in embedded systems and kernel code</li> <li>Importing code from another programming langage, like C</li> <li>Having a global mut pointer, in single threaded application, and only if really necessary</li> <li>When implementing the <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root#Overview_of_the_code">Quake 3 inverse square root</a> function, or anything similarly esoteric</li> </ul> <p>If something breaks in an unexpected way, the unsafe parts of the code must become primary suspects, so keep it as clear, simple and documented as possible.</p> <p>If the use of <code>unsafe</code> really improves the performances, add some benchmarks in order to prove it, and if one day the gap between the <code>safe</code> and <code>unsafe</code> implementation is getting close, consider moving back to the all-safe implementation.</p> <p>In any case, if you <strong>do</strong> have <code>unsafe</code> in your code, <em>test it extensively</em>, plug your CI to perform the tests before any merge, and make sure all of it is well tested.</p> <h2 id="limit-the-scale-of-your-software">Limit the scale of your software</h2> <ul> <li>If you <em>add a data</em> struct to some <code>Vec</code> everytime someone connects to your server, this is a resource consumption.</li> <li>If you <em>start a thread</em> performing some kind of <em>computation</em> when someone connects to your server, this is a ressource consumption.</li> </ul> <p>In both cases (and many other kind of examples), you need to think of “What happens if the whole Earth wants to connect to my app ?”</p> <p>Answer is, your server will crash, or melt. So put in place <strong>some limits</strong> to the number of users, or an (inexpensive) waiting queue from which users will be redirected once a “resource unit” will be available. </p> <p>I personally think that you can have applications serving millions of users running on a tiny server, if you smartly <em>designed the way your resources are being used</em>, and put in place ways to <em>improve</em> the behavior of your software <strong>under stress</strong>.</p>  <h2 id="rusts-protection">Rust’s protection</h2> <p>Rust by itself, when not using any <em>unsafe</em>, is preventing against some vulnerabilities, including <strong>2 Critical</strong>, <em>1 high</em> and 1 medium.</p> <p>However it didn’t protect against 4 Low vulnerabilities.</p> <p>Note that most of the protection was not because the vulnerability didn’t occur, but more because <em>it’s not exploitable</em>, or at least with less critical impact. This is what the rules of Rust concerning memory manipulation protects you from.</p> <p>However as the issues causing these vulnerabilities can still happen, you can still have vulnerabilities, and <em>may have critical ones</em> if you only rely on “Rust is safe”.</p> <p>Rust <em>in most cases</em> is memory safe, but not all exploits are about memory exploitation, <strong>nothing</strong> is <em>always</em> safe, always <strong>doubt</strong> the security of a software, wether you code it or buy it. </p> <h2 id="writing-secure-rust-code">Writing secure Rust code</h2> <p>The bottom line is that <strong>you should be careful</strong> when writing code, especially when handling system’s inputs (wether it is human or network / disk). </p> <p>You may think that it’s only meant for big opensource project and that your code is OK without all of this, but I think <strong>it’s important to train</strong> as these “good practices” only become automatic <em>if repeated</em> enough. So try to think a little about security when building the next (blazing fast) GNU tool rewritten in Rust, or anything else really. </p> <h2 id="donate-to-ostif">Donate to OSTIF</h2> <p>You can make a donation to the OSTIF fund by following <a href="https://ostif.org/donate-to-ostif/">this link</a>.</p> <p>The report is accessible <a href="https://www.x41-dsec.de/static/reports/X41-OSTIF-Gitlab-Git-Security-Audit-20230117-public.pdf">here</a> and the summary can be seen on <a href="https://x41-dsec.de/security/research/news/2023/01/17/git-security-audit-ostif/">X41’s website</a>.</p> <p>Once again, if you fund anthing that is wrong / oversimplified in this article, <strong>please tell me</strong> so I can correct it right away.</p> <blockquote> <p>Special thanks to </p> </blockquote> </div></div>
  </body>
</html>
