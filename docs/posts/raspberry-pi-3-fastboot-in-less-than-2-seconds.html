<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.furkantokac.com/rpi3-fast-boot-less-than-2-seconds/">Original</a>
    <h1>Raspberry Pi 3 fastboot in less than 2 seconds</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p><a href="https://www.furkantokac.com/rpi3-fast-boot-2-saniyede-acilan-sistem">
Bu yazıyı Türkçe oku.|Read the post in Turkish.
</a>
 <!-- raw HTML omitted --></p>
<p>This post tells about my journey of fast-booting a Raspberry Pi 3 (RPI). In addition to that, some optimizations are discussed that can be applied to a Qt (QML) application. In the end, we will have a RPI that boots from power-up to Linux shell in 1.75 seconds, power-up to Qt (QML) application in 2.82 seconds.</p>
<p><em><strong>Edit</strong></em> : There are requests for a demo image that have a USB and network support. I’ll work on it in my free time. You can work on it by yourself. If you are stuck, don’t hesitate to ask a question from the support link below. I have briefly touched on the topic <a href="https://github.com/furkantokac/buildroot/issues/1">here</a>.</p>
<p><strong>Technical support</strong> : <a href="https://github.com/furkantokac/buildroot/issues">github.com/furkantokac/buildroot/issues</a></p>

<p>
  <iframe src="https://www.youtube.com/embed/eQW0QNUPb2o" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<hr/>
<h2 id="outline">Outline</h2>
<p><strong>1.</strong> Introduction</p>
<h2 id="1-introduction">1. Introduction</h2>
<p>First of all, we should know the target device well since some critical stages of the boot optimization process are low-level (hardware dependent). We need to be able to answer questions such as what is the boot sequence of the device, which files are running in which order to boot the device, which files are 100% required etc. Besides that, optimizations should be done and tested one by one, so that the effect can be seen.</p>
<p>The boot process of RPI is kind of different from the other, traditional devices. RPI’s boot process is based on GPU rather than CPU. I recommend that you dig into more on this topic on the internet. (see <a href="https://thekandyancode.wordpress.com/2013/09/21/how-the-raspberry-pi-boots-up/">1</a>, <a href="http://exileinparadise.com/raspberry_pi_boot">9</a>)</p>
<p>RPI uses Broadcom’s closed-source chip as System on Chip (SoC). Therefore, SoC-related softwares are provided to us as binary. (see <a href="https://github.com/raspberrypi/firmware">2</a>) So we cannot customize them without reverse engineering. That is why the most difficult parts of the RPI boot optimization process are SoC-related ones.</p>
<h2 id="2-project-requirements">2. Project Requirements</h2>
<ul>
<li>RPI shall be used as a device.</li>
<li>Buildroot shall be used for Linux customization.</li>
<li>RPI’s GPIO, UART shall be usable.</li>
<li>GPIO, UART shall be usable on Qt.</li>
<li>Qt (QML) application shall automatically be started.</li>
</ul>
<h2 id="3-raspberry-boot-files">3. Raspberry Boot Files</h2>
<p>The files related to RPI’s boot process and their purposes are briefly as the following;</p>
<ul>
<li><strong>bootcode.bin</strong>: This is the 2nd Stage Bootloader, which is run by the 1st Stage Bootloader which is embedded into the RPI by the manufacturer. Runs on the GPU. Activates the RAM. Its purpose is to run start.elf (3rd Stage Bootloader).</li>
<li><strong>config.txt</strong>: Contains the GPU settings. Used by start.elf.</li>
<li><strong>cmdline.txt</strong>: Contains the Kernel parameters that will be passed to the Kernel when executing it. Used by start.elf.</li>
<li><strong>.dtb</strong>: The compiled Device Tree file. It contains hardware descriptions of the device, like GPIO pins, display ports, etc. It is used by start.elf and kernel.img.</li>
<li><strong>start.elf</strong>: This is the 3rd Stage Bootloader run by bootcode.bin. It contains the GPU driver. Its purpose is to split RAM between the GPU and the CPU, apply the settings inside the config.txt file to the GPU, make the necessary adjustments by reading the corresponding .dtb file, and run the kernel.img with the parameters in the cmdline.txt file. After performing these operations, it’ll keep running on the device as a GPU driver till the device is turned off.</li>
<li><strong>kernel.img</strong>: This is the Linux Kernel, run by start.elf. After Kernel runs, we have full control over everything.</li>
<li><strong>Basic logic</strong>: power-up the RPI -&gt; embedded software inside RPI runs -&gt; bootcode.bin runs -&gt; start.elf runs -&gt; read config.txt -&gt; read .dtb -&gt; read cmdline.txt -&gt; kernel.img runs</li>
</ul>
<h2 id="4-raspberry-boot-optimization">4. Raspberry Boot Optimization</h2>
<p>RPI boot process from power-up to Qt application is as the following;</p>
<h4 id="k1---raspberry-boot-stage">K1 - Raspberry boot stage</h4>
<p>In this part, the software embedded into the device by the manufacturer runs the bootcode.bin. Because bootcode.bin is closed-source, we can’t configure it directly so there are 2 things we can do. We either try different versions of the bootcode.bin files, or we try to change the files that are run by bootcode.bin. (we ignore the reverse-engineering)</p>
<p>We go to RPI’s GIT page (see <a href="https://github.com/raspberrypi/firmware/tree/master/boot">12</a>) and see that there are no different versions of bootcode.bin available. We go to the old commits of bootcode.bin and try the old versions, we see that there is no change in speed. We can move on to the other option.</p>
<p>Let’s check for start.elf. On the RPI’s Git page, we see that there are different versions of start.elf files: start_cd.elf, start_db.elf, start_x.elf. We check the differences of the files and see that start_cd.elf is a simplified version of the start.elf. In the start_cd.elf, GPU features are cropped, this may cause a problem but let’s try it. When we change our start.elf by start_cd.elf, the boot process is 0.5sec faster than before. However, when we run the Qt app, it fails. So why it fails, can we fix it ? Our GUI application runs on OpenGL ES and start_cd.elf does not allocate enough memory for the GPU. Although we have tried to overcome this difficulty, we have not succeeded, but I believe that it can be solved if more time is spent on it.</p>
<h4 id="k2---linux-pre-boot-stage">K2 - Linux pre-boot stage</h4>
<p>This part is handled by start.elf. Since start.elf is closed-source, we cannot directly work on it, but there are open-source files associated with start.elf: bcm2710-rpi-3-b.dtb, kernel.img</p>
<p>The first thing we can do is to check if any of these files slow down the start.elf. When we remove the Device Tree, Kernel does not boot. There are 2 possibilities here; the problem is either start.elf or Kernel. We need to find a way to test it. An application that can run without Device Tree will do the trick, which is a barebone RPI application. If we write a small application and let the start.elf run this application instead of Kernel, we can see that removing Device Tree creates any speed change. As a second option, we can compile U-Boot and run U-Boot instead of Kernel, but the first option is cool. We write a barenone LED blink application (see <a href="https://github.com/furkantokac/raspberrypi3-tutorials">13</a>). When we run it, we see that removing the Device Tree makes the boot process faster for 1.0sec. We also try to change the default name of the Device Tree (bcm2710-rpi-3-b.dtb). It still works. So here is the conclusion: Device Tree is processed by start.elf even if we do not boot the Kernel, and start.elf specifically searches for the name “bcm2710-rpi-3-b.dtb”. To sum up, either we should get rid of the Device Tree or use it by changing its name.</p>
<p>Renaming the Device Tree option can be handled as the following; We can write a barebone software thats gonna be run by start.elf and handle the Kernel booting process by using renamed Device Tree. There will be time loss because we need to run an extra code here. Therefore, lets check the other option, which is cancelling the Device Tree.</p>
<p>We saw in our test that the Device Tree is absolutely necessary for booting the Kernel and not necessary for the start.elf. If the Device Tree is related to the Kernel, we can somehow try to hardcode the Device Tree configurations into the Kernel. When we search about Device Tree, we see that similar option already exists for the Kernel. (see <a href="https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf">3</a> on page 11) When we make the necessary settings (K3 contains information about this setting), we see that the Kernel can boot successfully. Lets test if everything works OK.</p>
<p>After the tests, we observe that;</p>
<ul>
<li>Qt application works OK.</li>
<li>UART stop working.</li>
<li>We see that the boot time of the Kernel is slower by 0.7sec.</li>
</ul>
<p>Lets check what is the problem with UART. We save the boot log of the Kernel where UART has problem and boot log of the Kernel where UART is running. (By boot log, I mean output of “dmesg” command). When we compare the logs, there is a difference in the line starting with “Kernel command line:”. In the system where UART is running, “8250.nr_uarts = 1” parameter is passed to the Kernel. We put this parameter into the cmdline.txt file of the problematic Kernel and it works like a charm. Lets move on the other problem.</p>
<p>We should check what slows down the boot process about 1.0sec. We will use the same logs again. When we compare the problematic system’s log and non-problematic system’s log, we see that there is an extra log in the problematic system that contains the word “random”, and the delay is there. When we try to close the “random” settings from the Kernel one by one, we find the problematic setting of the Kernel. (K3 has information about this setting) When we turn off the setting, we see that everything is back to normal. Mission completed.</p>
<p>As a result, boot process is faster about 2.0 seconds. The total time spent for K2 is 0.25sec. Our improvements can continue here, like we can optimize the Device Tree, but I think that we can spend time more efficiently by moving to the next step, so lets move.</p>
<h4 id="k3---linux-boot-stage">K3 - Linux boot stage</h4>
<p>We have explained some of the Kernel optimizations in part K2. This part has a list of Kernel features that we’ve played on. To see how a specific feature affects the Kernel booting process, please visit the Git page of the project (see <a href="https://github.com/furkantokac/buildroot/blob/ftdev/board/ftdev/rpi3/docs/distro_optimization/fcond04/README.config">5</a>) and, do detailed research online about the setting if it is required.</p>
<p><strong>Enabled Features</strong></p>
<pre tabindex="0"><code>ARM_APPENDED_DTB    : Embedding device tree for faster boot.
ARM_ATAG_DTB_COMPAT : Required to pass some parameters to kernel.
</code></pre><p><strong>Disable Features</strong></p>
<pre tabindex="0"><code>NET
SOUND
HW_RANDOM           # 0.7sn
ALLOW_DEV_COREDUMP  # 0.2sn (Core Release: 2.80a)
STRICT_KERNEL_RWX   #===\ 0.1sn
STRICT_MODULE_RWX   #===/
NAMESPACES          # 0.1sn
FTRACE              # 0.5sn

# Disable USB support
USB_SUPPORT

# Disable debugging
BLK_DEBUG_FS
DEBUG_BUGVERBOSE
DEBUG_FS
DEBUG_MEMORY_INIT
SLUB_DEBUG
PRINTK
BUG
DM_DELAY
ELF_CORE
KGDB
PRINT_QUOTA_WARNING
AUTOFS4_FS

# Followings are mostly affects the size
MEDIA_DIGITAL_TV_SUPPORT
MEDIA_ANALOG_TV_SUPPORT
MEDIA_CAMERA_SUPPORT
MEDIA_RADIO_SUPPORT
INPUT_MOUSEDEV
INPUT_JOYDEV
INPUT_JOYSTICK
INPUT_TABLET
INPUT_TOUCHSCREEN
IIO
RC_CORE
HID_LOGITECH
HID_MAGICMOUSE
HID_A4TECH
HID_ACRUX
HID_APPLE
HID_ASUS
</code></pre><h4 id="k4---init-system">K4 - Init system</h4>
<p>InitSystem does not take a lot of time, but the fastest-running code is non-running code :) That’s why we have removed the BusyBox. The only process that is required for us from BusyBox is File System Mounting. We can simply embed this process into the application.</p>
<p>All we need to do is putting the following code anywhere in the Qt program:</p>
<p>Of course, this code should be put into the right place because this process may take time so we don’t want our application is being blocked by this process. After that, we put our application in “/sbin/” folder with the name “init” and the process is completed. Kernel automatically runs the “/sbin/init” after it loads the userspace so the first thing that runs after userspace is loaded will be our application.</p>
<h4 id="k5---application">K5 - Application</h4>
<p>Qt Creator offers detailed debugging tools. Using these tools, we can determine what is slowing down of Qt application starting process.</p>
<p><strong>Static Compilation</strong></p>
<p><strong>Stripping</strong></p>
<p><strong>QML Lazy Load</strong></p>
<p><strong>Embedding Source Files in the Application</strong></p>
<h2 id="5-more-optimization">5. More Optimization!</h2>
<p>Although there are infinitely different possibilities in this section, we discuss the ones that will have a big impact in an acceptable amount of time. Besides that, there are some bits of advice.</p>
<p><strong>Code</strong>: G1</p>
<p><strong>Code</strong>: G2</p>
<p><strong>Code</strong>: G3</p>
<p><strong>Code</strong>: G4</p>
<p><strong>Code</strong>: G5</p>
<p><strong>Code</strong>: G100</p>
<p><strong>Code</strong>: G101</p>
<h2 id="6-in-a-nutshell">6. In A Nutshell..</h2>
<p>If you want to just have a fast-boot image for your RPI without going into the details, follow these steps;</p>
<ol>
<li><code>git clone https://github.com/furkantokac/buildroot</code></li>
<li><code>cd buildroot</code></li>
<li><code>make ftdev_rpi3_fastboot_defconfig</code></li>
<li><code>make</code></li>
<li>At this stage, the ready-to-run RPI image will be available in the <code>buildroot/output/images</code> folder. You can write it to the SD device and boot RPI directly. When the system is up, the terminal should be displayed directly on the screen.</li>
</ol>
<p>The image you gonna have has no overclock so you can faster the booting process by overclocking your RPI. Also, you can compile your own Qt application statically and replace it with <code>sbin/init</code> to run it on startup. USB drivers are removed so you can not control the RPI by a USB keyboard or mouse.</p>
<h2 id="7-result">7. Result</h2>
<p>“Normal” section has the measurements of the default Buildroot image. Only the boot delay time is reduced to 0.</p>
<p>“ftDev” section has the measurements of the optimized image.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>K1</strong></th>
<th><strong>K2</strong></th>
<th><strong>K3</strong></th>
<th><strong>K4</strong></th>
<th><strong>K5</strong></th>
<th><strong>Toplam</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Normal</strong></td>
<td>1.25sn</td>
<td>2.12sn</td>
<td>5.12sn</td>
<td>0.12sn</td>
<td>1.56sn</td>
<td>10.17sn</td>
</tr>
<tr>
<td><strong>ftDev</strong></td>
<td>1.25sn</td>
<td>0.25sn</td>
<td>0.25sn</td>
<td>0.00sn</td>
<td>1.07sn</td>
<td>2.82sn</td>
</tr>
</tbody>
</table>
<p>Note: Measurements are done by recording the boot process with a high-speed camera. Therefore, they are accurate.</p>
<h2 id="8-references">8. References</h2>
<p><strong>1.</strong> <a href="https://thekandyancode.wordpress.com/2013/09/21/how-the-raspberry-pi-boots-up/">How the Raspberry Pi boots up</a></p>

		</div></div>
  </body>
</html>
