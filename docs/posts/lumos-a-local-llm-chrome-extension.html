<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/andrewnguonly/Lumos">Original</a>
    <h1>Show HN: Lumos, a local LLM Chrome extension</h1>
    
    <div id="readability-page-1" class="page"><div>
            
    <p><a href="https://www.stanistan.com/" title="stanistan /">go /</a></p><article>
        
        

        

        

        <section>
            <p>I&#39;ve been working on a <a rel="nofollow noreferrer" href="https://veun-http-demo.stanistan.com">demo-server</a> for the <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun">veun</a> library,
and this has been interesting. The goal of the demo is to have some real-world
facsimile of something that one would build and I wanted to figure out some of
the warts and patterns of using the library for this use case.</p>

<p><img src="https://www.stanistan.com/processed_images/veun-http-demo-screenshot.16fa0ecbb775bf84.png"/>
</p>
<h2 id="a-list-of-things-in-no-particular-order">A list of things in no particular order</h2>
<ul>
<li>
<p>I&#39;ve stopped actively updating the series on <em>how I&#39;m building view-trees</em>.
It&#39;s its own thing now.</p>
</li>
<li>
<p>The demo-server is a practice in literate programming. I don&#39;t know
why exactly, as this is a ton more work to get things to be ok, but having
demo components with no real explanation didn&#39;t feel right. I knew what was possible,
but wanted the server to be fully self-documenting as a demo.</p>
<p>This is basically the only part of the demo repo that <em>isn&#39;t</em> shown in the UI, but
you can <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun-http-demo/blob/main/cmd/lit-gen/main.go">read the <code>lit-gen</code> command source</a>. I may move this out to its
own package.</p>
</li>
<li>
<p>There&#39;s a <code>veun/el</code> package. Originally, the library was built only using templates.
I wanted functional composition, and for testing and really small <em>renderable</em> pieces,
using <code>veun.Raw</code> was sufficient, but it felt <em>wrong</em>.</p>
<p>The first version of the package was a function that looked like <code>el.El(&#34;h1&#34;)</code>, but eventually
I added codegen so that you could do <code>el.H1()</code>. There is actually <em>no way</em> to directly
instantiate an HTML element that isn&#39;t already defined as a function. There&#39;s also
support for void elements, and you can&#39;t add child nodes to them (because the type doesn&#39;t
implement the functionality).</p>
<p>The package also does HTML encoding for attributes (<code>el.Attrs</code>) and the text primitive <code>el.Text</code>,
which <code>veun.Raw</code> does not.</p>
<p>An added benefit of this is that it should be more performant to generate views using
this package than going through template invocation in pathological cases: recursive
tree views (which the demo nav is an example of). Going through recursive dynamic slot
function dispatch in <code>text/template</code> is <em>slower</em>.</p>
</li>
<li>
<p>Also added <code>veun/template</code>. The functions and types in this package were all originally
in <code>veun</code>. After introducing <code>veun/el</code>, which I started using a lot more than expected,
it felt like the right API decision to have both of these packages be separate.</p>
</li>
<li>
<p>Built-in handlers.
Something I think is elegant: <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun/blob/3dc2a4257076026ef008cebb78686717064d5c75/vhttp/handler/checked.go#L7-L19"><code>handler.Checked</code></a>,
and its <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun-http-demo/blob/main/docs/cmd/demo-server/routes.go.md#closing-out-the-server">usage</a>. Basically, <code>Checked</code> goes through a cascade of
handlers and if any of them are 404s will go to the next one. This allows for a fall
through of dynamic pages, static urls, and custom 404s while still being able to use
built-ins like <code>http.HandlerNotFound()</code>.</p>
<p>There are a couple of other ones, like <code>handler.OnlyRoot</code>, that are great for
the <code>/</code> base case when using the standard libary&#39;s <code>http.ServeMux</code>.</p>
</li>
<li>
<p>When adding the <code>&lt;!DOCTYPE html&gt;</code> to my server, I learned that my implementation of
handler checked didn&#39;t write headers in the write order and this ended up serving
all static files as <code>text/plain</code>, which was a fun bug to track down and <a rel="nofollow noreferrer" href="https://github.com/stanistan/veun/commit/3dc2a4257076026ef008cebb78686717064d5c75">fix</a>.</p>
</li>
<li>
<p>When adding the <code>notFoundHandler</code> to the demo server, I realized that if the server
was being crawled, rendering a 404 would be kind of expensive.</p>
<p>I wanted this handler to be much closer to static and be doing as little compute as
possible. This view isn&#39;t going to change for <em>every single not found request</em>.</p>
<p><a rel="nofollow noreferrer" href="https://github.com/stanistan/veun/blob/main/memo.go">Adding <code>MustMemo</code></a> was really useful here. The fact that <code>veun.Raw</code> is just a string that
directly becomes <code>template.HTML</code> made it trivial to keep all of the interfaces working
transparently.</p>
</li>
</ul>

        </section>

        

    </article>

            
        </div></div>
  </body>
</html>
