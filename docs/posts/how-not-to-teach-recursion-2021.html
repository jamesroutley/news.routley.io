<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://parentheticallyspeaking.org/articles/how-not-to-teach-recursion/">Original</a>
    <h1>How not to teach recursion (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>We all know how to teach recursion. We’ve done it for decades. We pick some
honored, time-tested examples—<wbr/>Fibonacci numbers and factorial being leading
candidates—<wbr/>and use them to teach the general idea. They’re so canonical they
come directly from the gods: you can find these in books by people like
Niklaus Wirth.</p><p>But I’m here to tell you they got it wrong, and everyone’s been getting it
wrong ever since. Students come away underwhelmed and baffled, and go on to
become the next generation of teachers who repeat this process. However, we
need not repeat this cycle; we have much better methods.</p><h3>1<tt> </tt><a name="(part._.Some_.Canonical_.Examples)"></a>Some Canonical Examples</h3><p>Let’s start by looking at what’s wrong with our canonical examples.</p><h4>1.1<tt> </tt><a name="(part._.Factorial)"></a>Factorial</h4><p>First off, almost nobody has ever needed to compute a factorial. I’ve been
programming for about 35 years and the only times I’ve needed to compute a
factorial was when doing recreational mathematics or using programming to
explore some especially thorny combinatorics problem. Otherwise, I’ve never had
any need for factorials.</p><p>Second, the answer isn’t <span>meaningful</span>. Quick, what’s the factorial of 13?
Most people have no idea and (related to the above) don’t care. There’s nothing
recognizable about the answer. The only reason most programmers recognize the
number 3628800 is because we’ve tested factorial on a “big enough number” to
confirm that it worked, not because we actually cared about it. If you adopt a
curriculum that asks students to <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/wk-examplar/">develop examples
before they write code</a>, students would be hard-pressed to write the answer
independently; many would resort to implementing it first and plugging in the
answer.</p><p>Third, factorial has poor numeric properties in most languages. Unless you have
built-in, automatic support for big numbers, you will soon either get answers
that print in odd-looking scientific notation, or worse, overflow (on many
languages, with default integers, factorial of 17 is -288522240).</p><p>Finally, many students have written factorial-like programs before, perhaps
even factorial itself, using loops. A natural question they (should!) ask an
instructor is, “Why should I do this again?” The answer, inevitably, is,
“Because I’m asking you to.” There’s no better way to turn off a student.</p><p>So let’s summarize the “recursion experience”: a useless problem, with
unrecognizable answers, with wonky-looking behavior, using an unnecessary new
technique that you’re forced to use “because”.</p><h4>1.2<tt> </tt><a name="(part._.Fibonacci)"></a>Fibonacci</h4><p>Let’s turn our gaze to Fibonacci.</p><p>First off, almost nobody has ever needed to compute a Fibonacci number,
either. I’ve been programming for about 35 years and the only times I’ve needed
it was when doing recrea—<wbr/>you see where this is going.<span><span><span>I do find them
useful to convert beween miles and kilometers, though.</span></span></span></p><p>Second, the answer isn’t meaningful, and students would again be hard-pressed
to write the answer independently (what, keep track of all those
calls?!?). Third, it has poor numeric properties: around 44, Fibonacci is
correct, then becomes negative (which is obviously incorrect), then immediately
again is a very reasonable-looking positive number that just happens to be
completely wrong. The main reason we haven’t cared for decades is because we
really just don’t have much use for Fibonacci numbers.</p><p>Finally, it has atrocious time-complexity.</p><p>So let’s summarize the “recursion experience”: a useless problem, with
unrecognizable answers, with wonky-looking behavior, that runs really sloooowly
(and worse, the slowness first creeps up on you stealthily and then suddenly
administers a hammer-blow to the back of your head). In fact, its main value is
as a function that you should <span>not</span> write (straightforwardly) recursively.</p><p>This is how we teach recursion.</p><h4>1.3<tt> </tt><a name="(part._.Euclid_s_.Algorithm)"></a>Euclid’s Algorithm</h4><p>Oh, I’m not done.</p><p>Another famous mathematician, another famous function.</p><p>Okay, I’ll grant, many students have at least heard of the greatest common
divisor. They may vaguely recall using it in school for dealing with
fractions. So it has familiarity going for it.</p><p>Unfortunately, it was useful in a context that <span>no longer makes
sense</span>. Once you have a programming language, you have a calculator. Unless
you’re implementing a calculator (and perhaps even then), you have no real need
to implement Euclid’s algorithm.</p><p>And even if you do, admit it: you don’t remember why Euclid’s algorithm
works. I certainly have to re-derive why it produces the right answer every
time I’ve implemented it (purely for illustrative purposes, every few
years). Otherwise, it’s just a mystical pattern.</p><p>So what’s the lesson we get from Euclid’s algorithm? That recursion is for
encoding mystical patterns for no-longer-useful functions? In fact, is
recursion useful for anything <span>other</span> than weird math functions?</p><h4>1.4<tt> </tt><a name="(part._.Towers_of_.Hanoi)"></a>Towers of Hanoi</h4><p>Oh yes it is! Maybe that’s why we have this old standby.</p><p>First, we’ll start with some invented Eastern mysticism. Orientalism is always
a good pedagogic device, right?</p><p>Next, it’s a problem fraught with questions of representation: how exactly do
you represent the content of the towers? That is actually a somewhat
interesting question for a beginning student, but (a) it’s not obvious until
you’ve had some programming practice, and (b) it has absolutely nothing to do
with recursion. So you have a hard, unrelated sub-problem in the middle of your
example that “demonstrates” recursion. Doesn’t that utterly violate the
pedagogic principle of changing just one thing at a time so students can focus
on what’s salient? (And don’t forget, this is another problem with exponential
time behavior!)</p><p>Furthermore, if you don’t tell students the (recursive) solution and leave them
to figure it out for themselves, you haven’t given them a programming problem:
you’ve given them a puzzle. Those are different things. In particular, the
Towers of Hanoi is a particularly <span>difficult</span> kind of recursion—<wbr/>oh, you
didn’t know there are different kinds of recursion? Read on.</p><p>Finally, again, does anyone care? Do students believe they would be called on
to help monks move disks around? What other problem is similar to this one? And
if there are any, do we teach them, or do we present these magnificently
isolated monks…in magnificent isolation?</p><p>What’s worse is that so many of these are fundamentally <span>static</span> problems:
there are only so many interesting inputs, and each one has a completely
deterministic solution, so once one builds up a table of outputs for standard
inputs, the problem is essentially solved. For such problems, it would be smart
(especially when the run-time complexity is exponential in the input) to just
stash the answers and never run the code again.<span><span><span>Yes, I know,
memoization.</span></span></span></p><h3>2<tt> </tt><a name="(part._.Recursion_versus_.Cyclicity)"></a>Recursion versus Cyclicity</h3><p>Another standard, time-honored pedagogic device is the dumb joke: “to
understand recursion you must understand recursion”, and so on.</p><p>These confuse recursion with cyclicity.</p><p>If you don’t understand the difference, don’t use the dumb jokes.</p><p>If you do understand the difference, don’t use the dumb jokes then
either. They’re still <span>dumb</span> jokes.</p><h3>3<tt> </tt><a name="(part._.Is_.Recursion_in_the_.Problem_)"></a>Is Recursion in the Problem?</h3><p>An attempt at a better answer might be that a <span>problem</span> is “inherently”
recursive. However, that’s just a limitation of viewpoint. There’s nothing more
inherently recursive than iterative about factorial. All the problems above can
be expressed even more declaratively, as in a mathematical specification, that
eliminates any implementation directive (e.g.: the greatest common divisor is the
<span>greatest</span>, <span>common</span>, <span>divisor</span>: the definition of the problem
says nothing about how to find it, and searching through all numbers to find
divisors that are common and taking the largest one is no less valid a
solution).</p><p>No, the essence lies elsewhere. But we’re getting closer.</p><h3>4<tt> </tt><a name="(part._.How_to_.Teach_.Recursion)"></a>How to Teach Recursion</h3><p>Wait up, I didn’t promise this. Check the title again.</p><p>But I know, I can’t just stop here. So I’ll give you a brief peek of how to
proceed.</p><p>In <span><a href="https://htdp.org/">How to Design Programs</a></span> (<span>HTDP</span>), we have a rather different view of
recursion. The key idea is this.</p><h4>4.1<tt> </tt><a name="(part._.Function_.Follows_.Form)"></a>Function Follows Form</h4><p>Where does recursion come from? <span>HTDP</span> argues that it arises from
<span>self-references in data</span>. That is, <span>recursive data suggest recursive
solutions</span>. This is the key insight you need for understanding recursion. Not
only does it make sense once you think about it, it also demonstrates why most
other approaches to teaching recursion are essentially incorrect.</p><p><span>HTDP</span> teaches a design “recipe”. In it, you describe your program’s (or
function’s) data structures, and identify self-references in these
data. Self-referential data are pretty straightforward: even kids can understand
them. For instance, even a child informed about biology can answer basic
questions like these:
</p><div><table><tbody><tr><td><p><span>- Does a child have (biological) parents?</span></p></td></tr><tr><td><p><span>- Yes.</span></p></td></tr><tr><td><p><span>- How many?</span></p></td></tr><tr><td><p><span>- Two, a (biological) male and (biological) female.</span></p></td></tr><tr><td><p><span>- Does the female have parents?</span></p></td></tr><tr><td><p><span>- Yes.</span></p></td></tr><tr><td><p><span>- How many?</span></p></td></tr><tr><td><p><span>- Two, a (biological) mother and a (biological) father.</span></p></td></tr><tr><td><p><span>- Does the male…</span></p></td></tr></tbody></table></div><p>They can see where this goes. They grasp the idea of a (biological) family tree
pretty intuitively. They can similarly see other kinds of self-referential data
even at a young age, well before they program.</p><p>Next, <span>HTDP</span> explains how the structure of the data suggest a structure to the
solution. This solution structure is generic, and called the “template”. You
arrive at this entirely mechanically from the data structure, even before
you’ve contemplated the exact problem you’re trying to solve.</p><p>(The template is not a rule, it’s a suggestion. It helps you overcome the
“blank page” problem by offering the outline of a suggestion. Sometimes, the
template leads to a correct but insufficiently-efficient solution. Such a
solution is still useful as a reference solution against which to test more
efficient proposals.)</p><p>Separately, you write down examples of your problem. In the process you explore
how the self-reference in the solution (what one would call “recursion”) can
help you solve the task. (<span><a href="https://papl.cs.brown.edu/2020/">Programming and Programming Languages</a></span> explores this in more detail.)</p><p>And that’s where recursive functions come from. This form of recursion is
called structural recursion, because the recursive form follows the structure
of the datum.</p><h4>4.2<tt> </tt><a name="(part._.One_.Datatype__.Many_.Problems)"></a>One Datatype, Many Problems</h4><p>One of the added advantages of working with recursive data is that a given
datatype will often generate many problems. This has the virtue of seting up
comparisons and contrasts. A student’s effort at getting familiar with the
datatype and writing good examples of it can pay off in multiple settings.</p><p>Students can also be exposed to different datatypes for the same problem
space (as I discuss below). This lets them contemplate the benefits and
disadvantages that each representation has over the others. This is a problem
of general value, unrelated to recursion, that
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/ghlrfk-design-alt-data-org/">hasn’t been studied enough</a>,
but it also lends itself particularly well to recursive settings.</p><h4>4.3<tt> </tt><a name="(part._.When_.Recursion_.Becomes_.Difficult)"></a>When Recursion Becomes Difficult</h4><p>Later, HtDP teaches <span>generative</span> recursion, for when structural recursion is
insufficient. Generative recursion requires an “a ha!”, because you have to come up with
the non-structural solution.<span><span><span>Why the term “generative”? Read the book.</span></span></span>
Consider, for instance, lists defined recursively with a singleton head and the
rest of the list as a tail. For such lists, there is a <span>natural</span> sorting
algorithm: the one that follows structurally.</p><blockquote><p>Exercise</p></blockquote><p>I say it’s “natural” because it’s the one you would arrive at with the least
work and that best reflects the structure of the datum. Other standard sorting
solutions require some generative step.</p><p>However, what is structural varies, naturally, by the structure. Imagine you
instead represent lists by appending two sub-lists.</p><blockquote><p>Exercise</p><div><blockquote><p>What is the natural (structural) sorting algorithm now?</p></blockquote></div></blockquote><h4>4.4<tt> </tt><a name="(part._.Back_to_the_.Canonical_.Problems)"></a>Back to the Canonical Problems</h4><p>In principle, natural numbers are also recursive data: a number is either zero
or the successor of another natural number. However, this way of thinking is
not natural to students (most don’t see natural numbers and immediately think,
“Oh, a self-referential datatype!” the way they learn to with, say, a tree). So
<span>HTDP</span> introduces recursion over the naturals much later than other books
do. It’s just not that interesting.</p><p>Given this setup, we can actually see problems like factorial and Fibonacci as
structurally recursive functions. Euclid’s Algorithm is still not
structural—<wbr/>it’s very much generative.  Towers of Hanoi sits in an interesting
middle ground. But we’ve already seen why those problems are awful, so there’s
no need to dwell on them further!</p><h4>4.5<tt> </tt><a name="(part._.Going_.Beyond_.Loops)"></a>Going Beyond Loops</h4><p>The power of recursion lies not only in capturing certain patterns of data, but
also in generalizing loops. You can accumulate data, as you would with loops,
but you can also return data, even return data <span>as you process</span>. But
recursion is even more useful than that: you can recur <span>mutually</span>,
capturing rich patterns of interconnection in data. For an unusual example of
this, see
<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/sk-automata-macros/">this paper</a>.</p><h4>4.6<tt> </tt><a name="(part._.That_.Was_.Pretty_.Dense)"></a>That Was Pretty Dense</h4><p>It sure was! I’ve tried to distill a few hundred pages down to about
one. The un-distilled <span>HTDP</span> is available, fully and for free,
<a href="https://htdp.org/">online</a>.</p></div></div></div>
  </body>
</html>
