<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://phoboslab.org/log/2023/02/qoa-time-domain-audio-compression">Original</a>
    <h1>QOA, the Quite OK Audio Format</h1>
    
    <div id="readability-page-1" class="page"><div>	
	<div>
		
		<p>— Thursday, February 2nd 2023</p>
	</div>
	

	<p>Audio formats typically fall into one of three categories: <em>“lossless”</em>, 
<em>“complicated”</em> or  <em>“bad”</em>. After developing a
<a href="https://qoiformat.org/">simple image format</a>
last year, I tried to come up with an audio format that fits neither of these
categories.</p>
<p>In other words: a format that is <strong>lossy</strong>, <strong>simple</strong> and <strong>quite ok</strong>.
Naturally, it&#39;s called QOA — the Quite OK Audio Format.</p>
<p><img src="https://phoboslab.org/content/assets/qoa-comparison-chart.png" alt="Comparison of Audio Codecs"/>
<em>As hopefully evident by the generous use of Comic Sans: this chart 
is subjective.</em></p>
<p><strong>tl;dr</strong>: QOA is a lossy, time domain audio compression format with a constant
bitrate of 277 kbits/s for Stereo 44100hz. 400 lines of C, single header, 
<a href="https://github.com/phoboslab/qoa">source on github</a>, lots of <a href="https://phoboslab.org/files/qoa-samples">audio samples here</a>.</p>

<h2>Why?</h2>
<p>After having a lot of fun with the QOI image format I became interested in what
the landscape for audio formats looks like. The story has some parallels to that
of image formats lined out in the 
<a href="https://phoboslab.org/log/2021/11/qoi-fast-lossless-image-compression">QOI announcement</a>.</p>
<p>The 1970s and 1980s saw a lot of experimentation with very simple differential
pulse-code modulation (DPCM) formats and then MP3, Vorbis and Opus came along, 
promising ever lower bitrates at the cost of spiraling complexity.</p>
<p>Unlike with image formats, storing anything other than the shortest sound 
snippets losslessly was unthinkable for decades, because of the
(for the time still massive) file size requirements. The first lossless audio
format to gain widespread adoption (FLAC) was released 6 years after MP3.</p>
<p>There still remains a huge gap between lossless codecs at ~800kb/s and MP3 at 
128kb/s with seemingly little interest to fill it — apart from some speech and 
Bluetooth codecs that are much more complex than their quality would lead to 
believe and have as many patents as Qualcomm has lawyers (a lot).</p>
<h2>The Triangle of Neglect</h2>
<p>If you are building a game and want to play some sound effects and music, your
options are quite dire:</p>
<ul>
<li>use Vorbis (preferably through 
<a href="https://github.com/nothings/stb/blob/master/stb_vorbis.c">stb_vorbis</a>), unpack
all sound effects at load-time into RAM as uncompressed PCM and spare some CPU
cycles at run-time to decode music</li>
<li>use 4-bit ADPCM and live with the bad quality</li>
<li>build your own high-quality 8-bit ADPCM and live with the big file sizes</li>
</ul>
<p>The last two options are still quite popular. Most GameCube games 
used their own 8-bit ADPCM format, EA invented a bunch of different ADPCM 
flavors for their games and so did many others. Likewise, it looks like <a href="https://github.com/godotengine/godot-proposals/issues/4264#issuecomment-1076660702">4-bit 
ADPCM is still being used in some applications</a> 
when you need to play a lot of different sound effects. So you have a choice
between poor compression and poor quality.</p>
<p>Lossless codecs offer no benefit as a delivery format in games and none of the 
popular perceptual audio codecs have low enough complexity for real-time decoding
of many simultaneous sound effcts. 
There is one exception of course: Bink. A closed source solution made by 
<a href="http://www.radgametools.com">the usual suspects</a> and 
<a href="https://www.unrealengine.com/en-US/blog/bink-video-and-bink-audio-now-available-in-unreal-engine-for-free">tailored to the games industry</a>.</p>
<blockquote>
<p>Bink Audio is a performance-oriented audio codec that is capable of perceptually
lossless 10:1 compression with decode speeds closer to ADPCM than MP3 or Vorbis.   </p>
</blockquote>
<p>It&#39;s difficult to find more information on the Bink Audio Codec. It 
<a href="https://wiki.multimedia.cx/index.php/Bink_Audio">appears to</a> operate in the 
frequency domain like MP3 or Vorbis, which comes with some inherent complexity.</p>
<h2>A Short Overview of the Audio Codec Landscape</h2>
<p>Audio compression schemes can be broadly divided into two different approaches:</p>
<h3>Time Domain Codecs</h3>
<p>Time Domain codecs go over the PCM data sample by sample. They try to predict 
the next sample and only store the difference (the <em>“residual”</em>) from this 
prediction. The prediction can be as simple as just assuming the next sample 
will be the same as the current one, or that the difference between samples will
stay the same – i.e.  that the <em>“velocity”</em> is constant for now (<em>“2nd order predictor”</em>).</p>
<p>ADPCM codecs typically do some variation of this. These are lossy codecs, as 
they store each remaining residual in 4 bits (as mentioned before, some 
variations with 8 bits per residual exist). Since these 4-bits only give
you 16 different values to work with ADPCM also tries to predict the magnitude
of the next sample and maps those 16 values to smaller or larger ranges 
accordingly.</p>
<p><a href="https://wiki.multimedia.cx/index.php/Category:ADPCM_Audio_Codecs">MultimediaWiki</a> 
has some good documentation on these formats. 
<a href="https://wiki.multimedia.cx/index.php/IMA_ADPCM">IMA_ADPCM</a> is one 
of the more popular flavors of ADPCM.</p>
<p>Lossless codecs such as FLAC and WavPack go one step further with their predictions
by running some filter over a block of (say 8000) samples to figure out how each
sample correlates with the previous samples. This is called 
<em>“autocorrelation”</em> – i.e the correlation of the signal with itself. The 
coefficients that describe the correlation for these block are written in the 
file along with the residual for each sample. The residual in this case is 
simply what remains after all the correlation has been eliminated.</p>
<p>Assuming all the residuals are now quite small, they are compressed with a 
scheme that allows storing small numbers with fewer bits. In the case of FLAC 
<a href="https://en.wikipedia.org/wiki/Golomb_coding#Rice_coding">rice coding</a> is used;
WavPack does <a href="https://www.wavpack.com/WavPack.pdf">something slightly different</a>.</p>
<p>All in all FLAC is not a complicated format. Not quite 400-lines-simple, but far
from the complexities of Opus. Looking at the 
<a href="https://github.com/xiph/flac/tree/master/src/libFLAC">code of libflac</a>
certainly does not give this impression – the 
<a href="https://github.com/SerenityOS/serenity/blob/master/Userland/Libraries/LibAudio/FlacLoader.cpp">FLACLoader of SerinityOS</a>
is a much more pleasant read.</p>
<p>If you&#39;re looking for an even simpler lossless codec, David Bryant, the author
of WavPack, has another project going: <a href="https://github.com/dbry/slac/blob/master/libslac.c">SLAC</a>.</p>
<p>WavPack itself is more complicated in that it does multiple passes of different 
decorellation filters and uses a bunch of other clever tricks that – even after
studying the source code quite a bit – I can&#39;t fully grasp. In turn, it offers a
lot more features and flexibility over FLAC. This includes a lossy compression mode,
down to 2.4 bits per sample. Maintaining acceptable quality at this minimum 
bitrate comes at the cost of a lot of computational complexity. At 3 bits per
sample the amount of work the en- and decoder have to do can be much more relaxed.</p>
<p>There are a lot more lossless audio codecs that operate in the time domain and
a whole bunch more lossy ADPCM variants. But to the best of my knowledge, WavPack
remains and outlier in offering lossy time domain compression with good compression 
ratio <em>and</em> good quality.</p>
<h3>Frequency Domain / Transform Codecs</h3>
<p>Encoders operating in the frequency domain take a block of time domain samples, figure out
which frequencies are present, throw away frequencies that are unimportant 
(often determined by a <a href="https://en.wikipedia.org/wiki/Psychoacoustics">psychoacoustic model</a>,
specifically <a href="https://en.wikipedia.org/wiki/Auditory_masking">auditory masking</a>) and write the amount of each 
remaining frequency to the stream. A decoder reverses the process and creates
a time domain signal using the encoded frequencies.</p>
<p>Most of these codecs use some flavor of <a href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">DCT</a>
to do this transformation from time domain to frequency domain. 
<a href="https://en.wikipedia.org/wiki/Modified_discrete_cosine_transform">MDCT</a> is 
a popular choice. It transforms the samples in overlapping blocks using a 
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>.</p>
<p>This transformation, the windowing that has to be applied before and the
subsequent psychoacoustic modeling requires some heavy lifting that is only ever
described in an obtuse language that wallows in different foreign alphabets and 
single letter variable names. 
(Steven Wittens made <a href="https://twitter.com/unconed/status/678412252752519168">a better version of this joke</a>)</p>
<p>Virtually all <em>modern</em> codecs use some variation of this as their basis, often 
with some form of entropy coding (huffman or others) generously sprinkled on top. 
MP2, MP3, Vorbis, Opus, AAC, WMA and all kinds of recent telephony and Bluetooth
codecs are some examples.</p>
<p>There is a reason for this widespread use: it works.</p>
<p>Opus specifically is <em>excellent</em>. It does it all, from extremely low bitrates 
to perceptually lossless. All streamable with very little delay. Though Opus&#39; trick 
is to use two different codecs under the hood: one in the time domain, one in the
frequency domain. Depending on the bitrate you get one or the other – or even
both in a hybrid mode. It&#39;s a technical marvel.</p>
<p>The point is: these codecs are decidedly not simple. Neither conceptually nor 
computationally.</p>
<h2>The Quite OK Audio Format</h2>
<p>QOA&#39;s main objective was simplicity. Naturally, it is a time domain codec. It 
does not transform samples, it has no psychoacoustic model, no entropy coding, 
no stereo de-correlation, no floating point math and the decoder is free of
divisions (the encoder uses a division to figure out the encoded size for a 
<code>malloc()</code>). The whole thing fits in 400 lines of C (plus comments).</p>
<p>QOA has a bunch of other nice properties:</p>
<ul>
<li>It&#39;s fixed rate, so trivially seekable by just jumping to the nearest frame offset</li>
<li>Everything is 64 bit aligned. There&#39;s no bit-wise reading required</li>
<li>It&#39;s theoretically streamable with just 20 samples delay (0.45ms at 44100hz)</li>
<li>It does not cut off higher frequencies, like many transform codecs do</li>
</ul>
<h3>Quality</h3>
<p>QOA has been designed to be transparent for the vast majority of audio signals. To my
(admittedly aging) ears there&#39;s no detectable difference between the uncompressed
original and the compressed QOA version.</p>
<p>There are exceptions though. For some sounds QOA can introduce a bit of noise that
is audible <em>if</em> you wear headphones and turn up the volume. This is white noise, that
many people, me included, find way less jarring than the typical pre-echo and
metallic sounds that badly compressed transform codecs introduce.</p>
<p>As with any lossy codec some detail is lost along the way and QOA is no exception.
If QOA is suitable for your application is a question that I cannot answer. Please 
listen to the <a href="https://phoboslab.org/files/qoa-samples/">QOA Test Samples</a> to get your own impression.</p>
<p>I&#39;m sure the quality of the encoder could still be improved by implementing
noise shaping, pre-computing the best LMS weights for a whole block (for static 
files) or through other means.</p>
<h3>Bitrate</h3>
<p>The bitrate for QOA is only depended on the sample rate and number of channels
of the audio signal. Each sample is encoded with exactly 3.2 bits. Together with
the frame headers QOA compresses 44khz stereo to 277 kbits/s.
This is about twice the bitrate of a “good enough” quality MP3 at 128 kbits/s.</p>
<p>Depending on your requirements you may be able to reduce the file size further
by just lowering the sample rate. If that sounds like cheating, keep in mind 
that MP3 at 128kbit/s typically cuts off anything above ~16khz, too. If
you would do the same for QOA – i.e. resample to 32khz first – you&#39;d arrive at
201 kbits/s for stereo. As another example, speech at 8khz mono clocks in at 25 kbits/s.</p>
<h2>Technical Details</h2>
<p>For <em>“CD quality audio”</em> 44100 samples per second are stored with a 
resolution of 16 bits per sample. A single sample therefore can have a value in the 
range of <code>-32768</code> to <code>32767</code>. This sample-rate and bit-depth is considered to be 
more than adequate to cover the full range of human hearing by anyone who 
doesn&#39;t buy gold plated network switches to widen the sound stage.</p>
<p>(If you haven&#39;t read Monty&#39;s <a href="https://people.xiph.org/~xiphmont/demo/neil-young.html">Why 24/192 Music Downloads are Very Silly Indeed</a>
or seen <a href="https://www.youtube.com/watch?v=FG9jemV1T7I">A Digital Media Primer for Geeks</a>
and <a href="https://www.youtube.com/watch?v=cIQ9IXSUzuM">Digital Show &amp; Tell</a>
about this topic, you&#39;re in for a treat)</p>
<p>For QOA the sample-rate can be anything between 1hz and 16mhz, but it is limited
to reproducing samples at 16 bit depth. </p>
<p>The whole encoding process works like this:</p>
<ol>
<li>predict the next sample</li>
<li>calculate the residual (how far off the prediction from the actual sample is)</li>
<li>divide the residual by some scalefactor to squeeze it into 3 bits</li>
<li>store the scalefactor and the residual to the stream</li>
</ol>
<h3>Prediction</h3>
<p>Like for other time domain codecs, the heart of QOA is in the prediction of the
next sample. QOA uses a “sign-sign” <a href="https://en.wikipedia.org/wiki/Least_mean_squares_filter">Least Mean Squares Filter</a>
with 4 weights (“taps”). The prediction is simply the sum of the 4 weights 
multiplied with the 4 previous samples.</p>
<pre><code><span>int</span> qoa_lms_predict<span>(</span>qoa_lms_t <span>*</span>lms<span>)</span> <span>{</span>
    <span>int</span> prediction <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>QOA_LMS_LEN</span><span>;</span> i<span>++)</span> <span>{</span>
        prediction <span>+=</span> lms<span>-&gt;</span>weights<span>[</span>i<span>]</span> <span>*</span> lms<span>-&gt;</span>history<span>[</span>i<span>];</span>
    <span>}</span>
    <span>return</span> prediction <span>&gt;&gt;</span> <span>13</span><span>;</span>
<span>}</span></code></pre>
<p>In the encoder, the sample to encode minus the prediction gives us the prediction
error or  “residual”. This residual is then quantized (through the magic of a 
process called “division”) and later stored in the encoded data. </p>
<p>The quantized value is immediately dequantized again and added to the prediction 
to form the reconstructed sample. This quantize/dequantize step in the encoder 
is important, because it ensures that the en- and decoder always arrive at the 
same samples and therefore the same predictions.</p>
<pre><code><span>int</span> sample_to_encode <span>=</span> sample_data<span>[</span>si<span>];</span>
<span>int</span> predicted <span>=</span> qoa_lms_predict<span>(&amp;</span>lms<span>);</span>
<span>int</span> residual <span>=</span> sample_to_encode <span>-</span> predicted<span>;</span>
<span>int</span> quantized <span>=</span> <span>;</span>
<span>int</span> dequantized <span>=</span> <span>;</span>
<span>int</span> reconstructed <span>=</span> qoa_clamp<span>(</span>predicted <span>+</span> dequantized<span>,</span> <span>-</span><span>32768</span><span>,</span> <span>32767</span><span>);</span>
qoa_lms_update<span>(&amp;</span>lms<span>,</span> reconstructed<span>,</span> dequantized<span>);</span></code></pre>
<p>The residual and the reconstructed sample are fed back into the LMS to update the 
prediction weights. If the sample at <code>history[n]</code> is greater or equal <code>0</code>, the 
residual is added to <code>weight[n]</code>, else it is subtracted from <code>weight[n]</code>. Note 
that the residual can be positive or negative, so this will always nudge the 
weights in the right direction.</p>
<p>We also rotate the 4 history samples with the reconstructed one. The oldest one
is discarded and the newest one added at the end.</p>
<pre><code><span>void</span> qoa_lms_update<span>(</span>qoa_lms_t <span>*</span>lms<span>,</span> <span>int</span> reconstructed<span>,</span> <span>int</span> residual<span>)</span> <span>{</span>
    <span>int</span> delta <span>=</span> residual <span>&gt;&gt;</span> <span>4</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>QOA_LMS_LEN</span><span>;</span> i<span>++)</span> <span>{</span>
        lms<span>-&gt;</span>weights<span>[</span>i<span>]</span> <span>+=</span> lms<span>-&gt;</span>history<span>[</span>i<span>]</span> <span>&lt;</span> <span>0</span> <span>?</span> <span>-</span>delta <span>:</span> delta<span>;</span>
    <span>}</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>QOA_LMS_LEN</span><span>-</span><span>1</span><span>;</span> i<span>++)</span> <span>{</span>
        lms<span>-&gt;</span>history<span>[</span>i<span>]</span> <span>=</span> lms<span>-&gt;</span>history<span>[</span>i<span>+</span><span>1</span><span>];</span>
    <span>}</span>
    lms<span>-&gt;</span>history<span>[</span><span>QOA_LMS_LEN</span><span>-</span><span>1</span><span>]</span> <span>=</span> reconstructed<span>;</span>
<span>}</span></code></pre>
<p>Updating the weights ensures that our next prediction is more accurate than the 
previous one – that is, if the signal characteristics don&#39;t change much.</p>
<p>How much exactly the weights should influence the prediction is important: too 
little and your predictor is not adapting to a change in the signal fast enough, 
too much and you will miss-predict all over the place.</p>
<p>Note that the right shift <code>residual &gt;&gt; 4</code> in <code>qoa_lms_update()</code> is just there to 
ensure that the weights will stay within the 16 bit range (I have not
proven that they do, but with all my test samples: they do). The right shift
<code>prediction &gt;&gt; 13</code> in <code>qoa_lms_predict()</code> above then does the rest. There is 
probably some scientific method to figure this out exactly, but I used
good old trial and error to arrive at these values.</p>
<h3>Quantization</h3>
<p>Quantization is the process of mapping big values to smaller values. This “mapping”
can be a simple division, which, if you caught the theme of this whole thing, is 
what QOA does. Almost.</p>
<p>QOA quantizes the residuals in “slices” of 20 samples each. The samples for each
slice  are divided by one of 16 different divisors - here called the “scalefactor”.
The scalefactors in QOA are fixed and they become less accurate at the higher end.</p>
<pre><code><span>int</span> qoa_scalefactor_tab<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span>
    <span>1</span><span>,</span> <span>7</span><span>,</span> <span>21</span><span>,</span> <span>45</span><span>,</span> <span>84</span><span>,</span> <span>138</span><span>,</span> <span>211</span><span>,</span> <span>304</span><span>,</span> <span>421</span><span>,</span> <span>562</span><span>,</span> <span>731</span><span>,</span> <span>928</span><span>,</span> <span>1157</span><span>,</span> <span>1419</span><span>,</span> <span>1715</span><span>,</span> <span>2048</span>
<span>};</span></code></pre>
<p>After the division we map values in the range of <code>-8</code> to <code>8</code> into 3 bits (i.e we map
17 different values to 8). This is done with a lookup table, where each of the entries 
in the <code>qoa_quant_tab</code> is an index into the <code>qoa_dequant_tab</code>:</p>
<pre><code><span>int</span> qoa_quant_tab<span>[</span><span>17</span><span>]</span> <span>=</span> <span>{</span>
    <span>7</span><span>,</span> <span>7</span><span>,</span> <span>7</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> 
    <span>0</span><span>,</span>                      
    <span>0</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>6</span><span>,</span> <span>6</span>  
<span>};</span>

<span>float</span> qoa_dequant_tab<span>[</span><span>8</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>.</span><span>75</span><span>,</span> <span>-</span><span>0</span><span>.</span><span>75</span><span>,</span> <span>2</span><span>.</span><span>5</span><span>,</span> <span>-</span><span>2</span><span>.</span><span>5</span><span>,</span> <span>4</span><span>.</span><span>5</span><span>,</span> <span>-</span><span>4</span><span>.</span><span>5</span><span>,</span> <span>7</span><span>,</span> <span>-</span><span>7</span><span>};</span></code></pre>
<p>Like the scalefactors, this <code>qoa_quant_tab</code> becomes less accurate at the higher end. 
For example, the values <code>6</code>, <code>7</code> and <code>8</code> are all mapped to the same index <code>6</code>. The 
<code>qoa_dequant_tab</code> maps those 3 initial values back to <code>7</code> – the average of <code>6</code>, <code>7</code> &amp; <code>8</code>.</p>
<p>In the actual code we don&#39;t use a floating point <code>qoa_dequant_tab</code> but pre-compute the 
tab for each of the 16 scalefactors. This results in a lookup table of 16 * 8 values.</p>
<p>The scalefactor for each slice of 20 residuals is chosen by brute force: We encode 
each slice with each of those 16 scalefactors and then use the one that produced 
the least amount of error. The whole encoding loop of a slice looks like this:</p>
<pre><code><span>for</span> <span>(</span><span>int</span> scalefactor <span>=</span> <span>0</span><span>;</span> scalefactor <span>&lt;</span> <span>16</span><span>;</span> scalefactor<span>++)</span> <span>{</span>
    <span>int</span> error_for_this_scalefactor <span>=</span> <span>0</span><span>;</span>

    <span>for</span> <span>(</span><span>int</span> si <span>=</span> slice_start<span>;</span> si <span>&lt;</span> slice_end<span>;</span> si<span>++)</span> <span>{</span>
        <span>int</span> sample <span>=</span> sample_data<span>[</span>si<span>];</span>
        <span>int</span> predicted <span>=</span> qoa_lms_predict<span>(&amp;</span>lms<span>);</span>

        <span>int</span> residual <span>=</span> sample <span>-</span> predicted<span>;</span>
        <span>int</span> scaled <span>=</span> qoa_div<span>(</span>residual<span>,</span> scalefactor<span>);</span>
        <span>int</span> clamped <span>=</span> qoa_clamp<span>(</span>scaled<span>,</span> <span>-</span><span>8</span><span>,</span> <span>8</span><span>);</span>
        <span>int</span> quantized <span>=</span> qoa_quant_tab<span>[</span>clamped <span>+</span> <span>8</span><span>];</span>
        <span>int</span> dequantized <span>=</span> qoa_dequant_tab<span>[</span>scalefactor<span>][</span>quantized<span>];</span>
        <span>int</span> reconstructed <span>=</span> qoa_clamp<span>(</span>predicted <span>+</span> dequantized<span>,</span> <span>-</span><span>32768</span><span>,</span> <span>32767</span><span>);</span>
        qoa_lms_update<span>(&amp;</span>lms<span>,</span> reconstructed<span>,</span> dequantized<span>);</span>

        <span>int</span> error <span>=</span> <span>(</span>sample <span>-</span> reconstructed<span>);</span>
        error_for_this_scalefactor <span>+=</span> error <span>*</span> error<span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>error_for_this_scalefactor <span>&lt;</span> best_error<span>)</span> <span>{</span>
        best_error <span>=</span> error_for_this_scalefactor
        best_scalefactor <span>=</span> scalefactor<span>;</span>
    <span>}</span>
<span>}</span></code></pre>
<h3>Bit Packing</h3>
<p>So we have quantized a slice of 20 residuals by one of 16 scalefactors. Each
residual fits into 3 bits. Time to write the slice to the stream:</p>
<pre><code>╭─ QOA_SLICE ── 64 bits, 20 samples ──────────────┬───────────/  /────────────╮
|        Byte[0]         |        Byte[1]         |  Byte[2]  \  \  Byte[7]   |
| 7  6  5  4  3  2  1  0 | 7  6  5  4  3  2  1  0 | 7  6  5   /  /    2  1  0 |
├────────────┼────────┼──┴─────┼────────┼─────────┼─────────┼─\  \──┼─────────┤
|  sf_index  │  r00   │   r01  │   r02  │  r03    │   r04   │ /  /  │   r19   |
╰────────────┴────────┴────────┴────────┴─────────┴─────────┴─\  \──┴─────────╯</code></pre>
<p>Here, I hope, it becomes quite apparent why one slice consists of 20 × 3bit 
samples. Making a slice 64 bits makes it possible to load it into a <code>uint64_t</code>
and shift the individual residuals out one by one.</p>
<p>QOA stores 256 slices per channel into a <em>“frame”</em>. These frames are completely
independent and can be decoded individually. A frame comes with a header that
describes the audio format (sample-rate and number of channels) and contains
the weights and the history needed to get the LMS going.</p>
<p>Finally, a QOA file is prefixed with a file header that contains the magic number
<code>&#39;qoaf&#39;</code> and the number of samples per channel in the file.</p>
<p>As you might have guessed, the file header is 64 bits, the frame header is 
64 bits and the LMS state (weights and history) is 64 bits per channel.</p>
<pre><code><span>struct</span> <span>{</span>
    <span>struct</span> <span>{</span>
        <span>char</span>     magic<span>[</span><span>4</span><span>];</span>                 uint32_t samples<span>;</span>              <span>}</span> file_header<span>;</span>                 
    <span>struct</span> <span>{</span>
        <span>struct</span> <span>{</span>
            uint8_t  num_channels<span>;</span>             uint24_t samplerate<span>;</span>               uint16_t fsamples<span>;</span>                 uint16_t fsize<span>;</span>                <span>}</span> frame_header<span>;</span>            
        <span>struct</span> <span>{</span>
            <span>struct</span> <span>{</span>
                int8_t history<span>;</span>                    int8_t weight<span>;</span>                 <span>}</span> lms_entry<span>[</span><span>4</span><span>];</span>                <span>}</span> lms_state<span>[</span>num_channels<span>];</span> 

        qoa_slice_t slices<span>[</span><span>256</span><span>][</span>num_channels<span>];</span>     <span>}</span> frames<span>[];</span>
<span>}</span> qoa_file<span>;</span></code></pre>
<p>The End.</p>
<p>What makes QOA work is 1) a reasonably good predictor and 2) storing the 
scalefactor for a bunch of samples <em>explicitly</em> instead of guessing the right
one from context, like ADPCM does.</p>
<p>If you have a minute, please take a look at the 
<a href="https://github.com/phoboslab/qoa/blob/master/qoa.h">QOA source code</a>. You have
seen much of it here already, but some details have been omitted for 
brevity. I spend a good amount of time to make the source as readable as 
possible and explain exactly what&#39;s going on.</p>
<h2>Conclusion</h2>
<p>Nothing here is new. I invented no revolutionary compression technique, I did 
not write a predictor that is better than existing ones. Everything here has 
been well established for the past 50 years.</p>
<p>I <em>just</em> put the pieces together. It took me a year to find the right ones, 
though.</p>
<p>You may not even care about the result. After all, QOA is slower than ADPCM,
doesn&#39;t compress as much as MP3 and sounds worse than FLAC (duh). But I believe
it fills a gap that was worth filling.</p>
<p>And I learned <em>a lot</em>. During the process I built countless experiments; some 
with very whacky ideas that amounted to nothing and some others that may be worth
exploring further.</p>
<p>QOA is hackable. If you have some specific needs, you can modify it to store 
2bit residuals or use a variable bit depth per slice. Changing the LMS 
length is just one <code>#define</code> away.</p>
<p>What is presented here is just a compromise with an extremist view on simplicity.</p>
<h2>Addendum</h2>
<h3>Higher Bit-Depths</h3>
<p>As established above 44khz/16bit is more than adequate to cover the full range
of human hearing. I do not discount that there are legitimate uses for higher
bit depths (e.g. during production &amp; mixing), but none of these apply to a lossy
<em>delivery</em> format.</p>
<p>If you compress your intermediate files during production with QOA, you are doing
it wrong. Use WavPack or FLAC.</p>
<h3>Metadata</h3>
<p>QOA files have not metadata. There&#39;s no point to having any. I do not expect 
anyone to re-encode their music library. QOA has been designed to be embeddable 
and in this scenario you most certainly know what files you are dealing with.</p>
<h3>Endianness</h3>
<p>Everything in QOA is big endian. Yes, virtually all CPUs these days are little 
endian. Yes, there&#39;s a tiny of overhead for reading big endian <code>int64_t</code> on these
machines. </p>
<p>I pondered the endianess question quite a bit and came to the conclusion that
big endian is <em>the</em> sensible choice. You can read <em>everything</em> in QOA with a
<code>read_uint64()</code> function that shuffles big endian to the host endianess and then
mask &amp; shift the individual values out. This is true for file and frame headers, 
the LMS state and the actual data slices.</p>
<p>Storing slice bytes backwards just <em>feels</em> wrong. The layout on disk would make 
no sense. Explaining the backwards slice format would complicate a format that I
worked very hard to simplify.</p>
<p><a href="https://qoiformat.org/">QOI</a> got a lot criticism for it&#39;s endiannes. So, as a 
preventive measure – before you complain please ask yourself: does it really matter?</p></div></div>
  </body>
</html>
