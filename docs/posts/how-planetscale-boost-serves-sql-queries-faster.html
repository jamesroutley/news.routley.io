<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/how-planetscale-boost-serves-your-sql-queries-instantly">Original</a>
    <h1>How PlanetScale Boost serves SQL queries faster</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>Today, we’re launching the limited beta of PlanetScale Boost, which improves the performance and throughput of your application’s SQL queries by up to 1,000×. PlanetScale Boost is a state-of-the-art partial materialization engine that runs alongside your PlanetScale database.</p>
<p>If you saw our <a href="https://planetscale.com/blog/introducing-planetscale-boost">PlanetScale Boost launch blog post</a>, you may have thought: <em>“Big deal, that’s just a cache”</em> or maybe you thought, <em>“That’s just a materialized view — SQL Server had those back in the 90s.”</em> But as it turns out, PlanetScale Boost is neither of those, yet it is a little bit of both. It is a new design for a caching architecture that is more performant than a cache and more efficient than a materialized view. It is something much more powerful and much more exciting. And I’d like to explain to you how it works.</p>
<p>To make this explanation simpler, let’s ground it with an actual example. We will investigate the internal workings of a PlanetScale Boost instance caching a single, specific query. Say we’re running a version control hosting website (let us call it <em>GitHat</em>) where people can push their code repositories and star them. The tables in our SQL schema could be something straightforward, such as this:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>CREATE</span><span> </span><span>TABLE</span><span> repository (</span></span>
<span><span>    id </span><span>bigint</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span> AUTO_INCREMENT,</span></span>
<span><span>    owner_id </span><span>bigint</span><span>,</span></span>
<span><span>    </span><span>name</span><span> </span><span>varchar</span><span>(</span><span>255</span><span>),</span></span>
<span><span>    </span><span>PRIMARY</span><span> </span><span>KEY</span><span>(id)</span></span>
<span><span>);</span></span>
<span></span>
<span><span>CREATE</span><span> </span><span>TABLE</span><span> star (</span></span>
<span><span>    id </span><span>bigint</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span> AUTO_INCREMENT,</span></span>
<span><span>    repository_id </span><span>bigint</span><span>,</span></span>
<span><span>    </span><span>user_id</span><span> </span><span>bigint</span><span>,</span></span>
<span><span>    </span><span>PRIMARY</span><span> </span><span>KEY</span><span>(id)</span></span>
<span><span>);</span></span></code></pre></div></div>
<p>To get the star count for a specific repository, we’d craft a SQL query that joins the count of stars per repository with the actual information for the repository:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>SELECT</span><span> repository.id, repository.owner_id, repository.name, starcount.stars</span></span>
<span><span>FROM</span><span> repository</span></span>
<span><span>    </span><span>LEFT JOIN</span><span> (</span><span>SELECT</span><span> star.repository_id, </span><span>COUNT</span><span>(star.user_id) </span><span>AS</span><span> stars</span></span>
<span><span>               </span><span>FROM</span><span> star </span><span>GROUP BY</span><span> star.repository_id) </span><span>AS</span><span> starcount</span></span>
<span><span>    </span><span>ON</span><span> (repository.id </span><span>=</span><span> starcount.repository_id) </span><span>WHERE</span><span> repository.id </span><span>=</span><span> ?;</span></span></code></pre></div></div>
<p>And yes, I know what you’re thinking. <em>“This query is <strong>bananas</strong>, man. I would never run this in production!”</em>. I know! I agree. The query is not particularly hard to understand, but if you try running it in a standard relational database, you’ll see that as soon as you have a few thousand <code>star</code> rows, the execution time of the query balloons out of control.</p>
<p>Although this query uses the relational model cleanly to fetch the data you require for your application, this is not a query you can run in a relational database. It’s just too expensive. You’d have to do <em>something else</em> to figure out the star count for your repositories. Maybe de-normalize the data. Migrate your database to keep a star count in the <code>repository</code> table. Or maybe keep the count in a Redis instance and update your application so that starring a repository writes to your database <em>and</em> to Redis.</p>
<p>Or, maybe, hear me out: Why not press a button and make the query <em>instantaneous</em>? That’s a compelling alternative to re-architecting your data model and/or application. And that’s what we offer with PlanetScale Boost. Let’s see what it takes to make this happen.</p>
<h2 id="a-query-execution-plan"><a href="#a-query-execution-plan">A query execution plan<span aria-label="Permalink to A query execution plan" role="complementary">#</span></a></h2>
<p>A plan is the most fundamental abstraction behind serving a query in a database — doubly so if it’s a <em>relational</em> database. <a href="https://planetscale.com/vitess">Vitess</a>, the open-source database that powers PlanetScale, is definitely acquainted with the concept of planning. Every time you send a SQL query to your PlanetScale database, its internal gateway nodes <em>plan</em> it first. We parse the SQL syntax of your query to understand what data is being asked for, which tables that data is stored in, and how the data must be processed or aggregated. This process results in a tree of primitive operations and sub-queries that will be routed to one or many of the shards in the database. This is what we call <em>a plan</em>.</p>
<p>Since each shard in your database is backed by a separate MySQL instance, once the SQL for each sub-query is sent to a shard, it is planned again! MySQL goes through the same process, but this time trying to figure out how to most efficiently fetch the requested data from the tables on-disk and the cheapest way to process or aggregate it. It really is plans all the way down!</p>
<p>PlanetScale Boost’s most fundamental operation also revolves around a plan. When you are using <a href="https://planetscale.com/blog/introducing-planetscale-insights-advanced-query-monitoring">Insights</a> and pick a query to be optimized, the first thing we do is <em>plan it</em>. Since our goal is to be highly compatible with your PlanetScale database, our planning is performed using the same technology that we use to plan normal queries in Vitess, the <a href="https://vitess.io/blog/2021-11-02-why-write-new-planner/"><code>gen4</code> planner</a>. It is, however, a slightly modified version of this planner because the resulting plan we’re looking for is quite different than the one Vitess would generate. It is, in fact, an <em>inverted</em> version of the plan.</p>
<p>When Vitess’ <code>gen4</code> plans a query you’ve just sent to your database, the goal of the plan is <em>to pull</em> data. We figure out in which shards the data lives, what’s the most efficient way to fetch it, and what’s the most efficient way to process it to generate the actual results of your query. But no matter how much we optimize this process, this <em>is</em> a very expensive process.</p>
<p>With PlanetScale Boost, we’re trying to do the opposite. Instead of planning how to fetch the data every time you <em>read</em> from your database, we want to plan how to process the data every time you <em>write</em> to your database. We want to process your data, so that reading from it afterward becomes essentially free. We want a very complex plan to apply to your <em>writes</em>, so there’s no planning to be done for your <em>reads</em>; a plan where we <em>push</em> data on writes instead of <em>pulling</em> data on reads.</p>

<p>Observing readers will notice that our <em>push</em> plan looks suspiciously similar to a dataflow plan, like the one that a materialization engine would use to create a materialized view. It’s true! But there’s much more to it, and it all boils down to <em>when</em> we run our plan.</p>
<h2 id="a-materialized-view-and-a-cache"><a href="#a-materialized-view-and-a-cache">A materialized view and a cache<span aria-label="Permalink to A materialized view and a cache" role="complementary">#</span></a></h2>
<p>Suppose PlanetScale Boost was just a <a href="https://en.wikipedia.org/wiki/Materialized_view">materialized view</a>. In that case, we’d have to run this plan immediately, using all the data in your database as input. That’s how materialization engines work: You define a <em>view</em> using SQL. The engine materializes the view by transforming all the rows in the underlying database to generate a fully materialized table representing your query. Then, the engine keeps it constantly updated as writes happen to the database. The main advantage of this approach is that the table is quite efficient when queried, unlike the <em>virtual</em> Views that all relational databases support. But there are also disadvantages: these views are not very ergonomic when developing you application, and most importantly, they are <em>wildly expensive</em>. You need to materialize the results for every possible row in your database, even though most of these rows will never be read. Doing this for many different views that apply to many different queries is not sustainable.</p>
<p>So no, we don’t do that because PlanetScale Boost is not a materialized view. But what is it, then? A cache? Let’s see. If PlanetScale Boost was <em>just</em> a cache, it wouldn’t run any plans. Caches don’t care about planning at all! They sit there idly, waiting for a request to come in. When the request arrives, if they know the answer, they return it immediately. Otherwise, they fall back to a slow backend (in this case, your main database) to fetch the answer and keep a copy before returning it to you.</p>
<p>Then, the big question is: How long do they keep that copy of the answer? At some point, the data from the underlying database will change, and the cache needs to stop returning the old answer because it is stale. As many of you know, knowing when to invalidate data from a cache is a hard problem. In fact, some people call it “one of the hardest problems in computer science.” Right. That sounds ominous. So… let&#39;s just not do that. Let’s do something else instead.</p>
<p>Here&#39;s what we&#39;re going to do: we will start listening to changes from our underlying database, much like a materialized view would. But we’re going to start from <em>right now</em>, not since the beginning. We will only replay some of the data in our database.</p>
<p>In a traditional relational database, following all the changes that happen in real-time means subscribing to a replication log (e.g., MySQL’s binlog). But PlanetScale is not a traditional database! Your PlanetScale database is powered by Vitess, and can be composed of many small shards. These shards are individual MySQL instances that keep independent copies of your data and allow you to horizontally scale as much as you need. Because of this design, to follow along with the changes to your whole PlanetScale database, we need to use an abstraction called <a href="https://vitess.io/docs/14.0/concepts/vstream/"><em>VStream</em></a>, which correctly and efficiently aggregates and unifies all the events amongst all the nodes in your database cluster.</p>
<p>Now that we’re correctly following all the change events, we can execute our plan! We’re going to run our plan — which looked a lot like a dataflow plan to create a fully materialized view — but only with the most recent changes to your database. “Running” the plan in our new system implies deploying it to a set of nodes (a Boost cluster). The Boost cluster lives alongside your database’s shards and continuously processes the events relayed by the VStream. The result of processing these events is a <strong>partially materialized view</strong> that can be accessed by the database’s edge tier. This view contains some, but not all, of the rows that could be queried.</p>
<h2 id="a-peek-into-the-flow"><a href="#a-peek-into-the-flow">A peek into the flow<span aria-label="Permalink to A peek into the flow" role="complementary">#</span></a></h2>
<p>Constructing a partially materialized view is similar to constructing a fully materialized one with some caveats. As new rows are written to your database, they are relayed via VStreaming to your Boost cluster and processed sequentially by the different operator nodes we previously planned. However, these “rows” do not flow as simple raw data.</p>
<p>If you think about it, the change events we receive from our database are not only <code>INSERT</code>s. You can also <code>UPDATE</code> and <code>DELETE</code> rows from your database! Hence, a removal is a <em>negative delta</em>, and an update is a pair of a <em>negative and positive deltas</em> with the previous and new versions of the value. This elegant design applies to all levels of the stack. The state changes from the underlying database we receive as events from the VStream are tracked as deltas, and the state changes in the internal operators, too!</p>
<p>Let’s break down how these deltas flow exactly. Say a user has starred a repository in our web application. In our relational schema, that implies inserting a new row into the <code>star</code> table that represents such a star, such as:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>INSERT</span><span> </span><span>INTO</span><span> star (repository_id, </span><span>user_id</span><span>) </span><span>VALUES</span><span> (</span><span>4</span><span>, </span><span>23</span><span>)</span></span></code></pre></div></div>
<p>As soon as your PlanetScale database has processed the write and stored it into whichever shard it belongs to, the new row is reflected in the VStream that the Boost cluster is subscribed to.</p>

<p>Because of the shape of our original query, our plan has decided that all new row events for the <code>star</code> table must flow directly to an <em>aggregation operator</em>. That makes sense! Our query was, in essence, a join between an aggregation (the count of stars grouped by the repository) and the full row data for each repository. So when a new star is added to the database, we must first aggregate it with a dedicated operator in our dataflow.</p>
<p>Now, what does an operator <em>actually do</em>? That really depends on the operator, of course. PlanetScale Boost has implementations for more than a dozen different SQL constructs. The only thing they have in common is that they process deltas to update their internal state and emit deltas that reflect the changes in their internal state.</p>
<p>The behavior of the aggregation operator is quite intuitive. It can perform most of the aggregation functions that you can find in MySQL’s SQL syntax (<code>SUM</code>, <code>COUNT</code>, <code>MIN</code>, <code>MAX</code>, etc.), and it does so by keeping the intermediate state of the aggregation in memory and updating it incrementally.</p>
<p>In our example, since our aggregation query has a <code>GROUP_BY star.repository_id</code>, our intermediate state is keyed by the <code>repository_id</code> of the star. Updating the count requires finding the row of the intermediate state that maps to our star’s repository and increasing its counter. All that’s left is reflecting that our operator’s state <em>has changed</em>, so the downstream operators are aware of this fact. We’ve seen how to do that: PlanetScale Boost relays deltas inside its dataflow precisely because they represent state changes. At the edge of our system, the VStream emitted a positive delta, representing a brand new <code>star</code> being inserted into the database. Much in the same way, our aggregation operator now emits a pair of deltas: A negative one with the old value of the counter and a positive one with the new value. This is all the information that all the operators downstream will require to update their state.</p>
<p>Speaking of which… there are indeed more operators downstream! After aggregating the sub-query, our dataflow plan needs to join each aggregated row with its matching equivalent in the <code>repository</code> table. That’s where the <code>JOIN</code> operator comes in.</p>

<p>In this operator, as the deltas from the left side flow in our direction, we need to match them with a row from the right side. However, the right side of our <code>JOIN</code> is a remote table in our underlying database. To significantly improve the performance of joins in practice, we keep an intermediate cache with the most recently seen rows for that side of the join. Since our target <code>repository</code> row is warm in a cache, we can access it immediately and generate the result by joining all the columns on both sides and emitting a new pair of deltas.</p>
<p>These deltas are critically important because they will update the partially materialized state that the users see. They flow directly into the View node, representing our partially materialized view, and will update its state by replacing the old value for the row with the new one. In practice, the View is nothing but a glorified hash map, and yet it has many interesting technicalities that allow us to update it atomically while users are reading from it — but this is a topic for another day. Once the view is updated, the flow for our initial <code>star</code> row is completed, and we continue processing more events from the VStream.</p>
<h2 id="a-“cache”-hit-and-a-miss"><a href="#a-“cache”-hit-and-a-miss">A “cache” hit and a miss<span aria-label="Permalink to A “cache” hit and a miss" role="complementary">#</span></a></h2>
<p>The process of creating and maintaining a partially materialized view is complex, but this complexity has been our goal since the beginning. We want to make writes hard, so reads can be simple, and I think we’ve succeeded.</p>
<p>Once the partially materialized view is in place, what happens when you read from your PlanetScale database is trivial in comparison: Our database’s edge tier parses and normalizes the SQL syntax of every <code>SELECT</code> query you perform. If its shape matches any of the queries you’ve optimized with PlanetScale Boost, the query’s execution is simplified immensely. Instead of the usual approach of using Vitess’ <code>gen4</code> planner to fetch and compose data from each shard, we extract the parameters based on the placeholder locations you configured and use those values to perform a lookup in the partially materialized view. That’s it. When reading from your database, we transform complex and expensive SQL expressions into simple lookups in a hash map.</p>
<p>What’s the original SQL query’s asymptotic complexity when running across the multiple shards of your PlanetScale database? I don’t know! I didn’t finish my computer science degree! But I know the asymptotic complexity of a Boosted query: It’s <code>O(1)</code> on average, and that really shows in the benchmarks.</p>
<p>Speaking of averages: We’re missing one last critical detail about this system’s performance. Everything we’ve seen so far has been a best-case scenario. It’s always great when your cache is warm, and you can serve your queries instantaneously. But one of the most critical properties of any caching architecture is how it behaves when the data you’re looking for is <em>not</em> available. Again, let’s try to understand what PlanetScale Boost does in this case by comparing it with our two architectural cousins: Materialized views and caches.</p>
<p>In a materialized view, a miss would <em>never</em> happen because the view is fully materialized! That’s the point of it. It is expensive to maintain and occupies a lot of memory, but it always has all the data available. So if the results you’re looking for don’t exist in the materialized view, they do not exist in the underlying database.</p>
<p>A cache, on the other hand, can definitely miss. Misses in a cache are expensive because you must fall back to the underlying system to compute and fetch the expected result. Sometimes this computation is <em>very expensive</em> — if it weren’t, it would be pointless to cache it in the first place! So, for the first time the value is fetched, it’s very likely that it will cause a massive spike in the 99th percentile of your application’s request times or maybe even a timeout.</p>
<p>A query in PlanetScale Boost can also miss, but we try to be much smarter about the way we resolve these misses. As we’ve just seen, updating the partially materialized state accessible to the clients implies keeping a bit of <em>intermediate state</em> for most SQL operations. Aggregations must be, <em>huh</em>, aggregated. Rows for both sides of a join must be remembered to make their computation more efficient. <code>ORDER BY</code> state must be kept, and sorted. The list goes on and on…</p>
<p>This intermediate state, which may seem wasteful at first, has one huge advantage. By keeping it, we can do something that a traditional materialization engine cannot do: <strong>We can run the dataflow in reverse</strong>. The same state that helps us maintain our partial view more efficiently also helps us resolve misses much more efficiently by <em>querying into it</em>.</p>
<p>Let’s look at our example query again: Say we’re looking for the star count of <code>:repository_id = 7</code>.</p>

<p>In this example, the result for repository <code>7</code> is missing from the final materialized view, but it is <em>not</em> missing from our aggregation operator because somebody has starred the repository recently. When trying to resolve our miss from the final view, we do not simply fall back to the database to perform the full query. Instead, we ask our view’s parent for the specific data we’re missing.</p>
<p>Here the parent doesn’t have the data (otherwise, it would be available in our view), but it has a more effective way of calculating it: Recursively asking its parent for the data again. Our <code>JOIN</code> operator in the dataflow has <em>two</em> parents (as you’d expect from a join), so we first ask the operator on the left side, and receive an aggregation result that was already warm in memory. All we’re missing is the other side of the join, which we query for in our right parent. Since the right side of the join is the <code>repository</code> table, we have to fall back to our underlying database to fetch its data, namely, the single row we’re missing for our <code>repository</code>. When the row is returned from our database, our <code>JOIN</code> operator can perform the join against the aggregated result from the left side and store it in the final view so the client can access it.</p>
<p>The performance implications of this are fascinating. Yes, just like a traditional cache, we have to fall back to the underlying system when we miss on a query. But unlike a traditional cache, the data we fetch from the database is not the original query the client asked for. Instead, we can really cheaply and efficiently figure out the minimal amount of information required to compute the final result and ask for only that. In this specific example, instead of a complex JOIN with a nested aggregation, we filled our miss with a point query that runs very quickly and looks like this:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>SELECT</span><span> repository.id, repository.owner_id, repository.name </span><span>FROM</span><span> repository </span><span>WHERE</span><span> repository.id </span><span>=</span><span> </span><span>7</span></span></code></pre></div></div>
<p>In practice, falling back to the underlying database is not trivial when the database is a large collection of disjoint shards. Which shard contains the data we’re looking for? What if the data we’re looking for is an aggregation instead of one or more rows? These are hard questions to solve. We will talk about this in future posts.</p>
<h2 id="the-future-of-planetscale-boost"><a href="#the-future-of-planetscale-boost">The future of PlanetScale Boost<span aria-label="Permalink to The future of PlanetScale Boost" role="complementary">#</span></a></h2>
<p>There are so many more details I’d like to share about PlanetScale Boost and all the technologies that power it, but this post is already long enough as it is. You can look forward to a series of blog posts about the evolution of the system and the many challenges we’ve faced while bringing partially materialized views to our multi-shard database engine.</p>
<p>I’d like to finish by highlighting that this technical miracle would not be possible without the seminal paper on which we based our implementation: <a href="https://www.usenix.org/conference/osdi18/presentation/gjengset"><em>Noria: dynamic, partially-stateful data-flow for high-performance web applications</em></a> (Gjengset et al., OSDI ’18). The paper describes a standalone database engine that can only be queried, with amazing performance, via partially materialized views.</p>
<p>Re-architecting this brilliant academic idea to act as an optimization layer on top of a production-ready distributed database like Vitess has been an incredibly difficult and interesting task. Still, today’s release is just the start of a long journey for PlanetScale Boost.</p>
<p>We have a very ambitious roadmap that includes supporting more query patterns, more SQL constructs, and even better performance (<em>Is that even possible?</em>). All this while continuously focusing on reliability to ensure that the results from your Boosted queries are always consistent with those returned directly from your PlanetScale database.</p>
<p>Starting today, we’re allowing a select group to preview PlanetScale Boost in a limited beta. <a href="https://planetscale.com/features/boost">Sign up for the waitlist today</a> and we will reach out with more information. We hope to find any slow query patterns you currently use in your applications that we don’t support and hear any other feedback.</p>
</div></section></article></div>
  </body>
</html>
