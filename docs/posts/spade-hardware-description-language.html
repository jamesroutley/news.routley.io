<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spade-lang.org/">Original</a>
    <h1>Spade Hardware Description Language</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<div>
  
<p>Spade is a new hardware description language which makes hardware
description easier and less error-prone. It does this by taking lessons from
software programming languages, and adding language level support for common
hardware constructs, all without compromising low level control over what
hardware gets generated.</p>
<h2 id="key-features">Key Features</h2>
<h3 id="language-level-pipelines">Language Level Pipelines</h3>
<p>Pipelines are a first class construct in Spade, making re-timing and
re-pipelining trivial. The <code>reg</code> separates code into stages, meaning you never
have to manually define pipeline registers, and that behavior is separated
from physical implementation.</p>
<p>When you need to update your design to meet timing, you can simply add or move
<code>reg</code> statements. The compiler is
smart enough to figure out when these changes affect the timing of instantiating
modules and tells you where to update your code to keep the original behavior.</p>
<pre data-lang="spade"><code data-lang="spade"><span>pipeline</span><span>(</span><span>4</span><span>) X(clk</span><span>:</span><span> clk</span><span>,</span><span> a</span><span>: </span><span>int&lt;32&gt;</span><span>,</span><span> b</span><span>: </span><span>int&lt;32&gt;) </span><span>-&gt; </span><span>int&lt;64&gt; {
</span><span>        </span><span>let</span><span> product </span><span>=</span><span> a </span><span>*</span><span> b</span><span>;
</span><span>    </span><span>reg </span><span>* </span><span>3</span><span>;
</span><span>        </span><span>let</span><span> result </span><span>= </span><span>f</span><span>(a</span><span>,</span><span> product)</span><span>;
</span><span>    </span><span>reg</span><span>;
</span><span>        result
</span><span>}
</span></code></pre>
<p>For more complex pipelines with feedback, such as a processor data path,
re-timing becomes less trivial, but being able to reason about signals in
stages instead of individual registers is still very helpful.</p>
<h3 id="types-and-enums">Types and Enums</h3>
<p>Spade has a powerful type system with structs, arrays, tuples and <em>sum types</em>
called <code>enums</code>.
A strong type system makes interoperability with external or internal modules
easier, and means you can refactor your code with confidence. The compiler will
tell you where your changes affect the behavior of your code.</p>
<p>Enums are of particular importance: unlike the enums of C and Verilog, they can
have associated payload.</p>
<p>You can model a value which may or may not be available with the <code>Option</code> enum:</p>
<pre data-lang="spade"><code data-lang="spade"><span>enum </span><span>Option</span><span>&lt;T&gt; {
</span><span>    </span><span>Some</span><span>(val</span><span>:</span><span> T)</span><span>,
</span><span>    </span><span>None
</span><span>}
</span></code></pre>
<p>Or why not model the instruction set of a CPU?</p>
<pre data-lang="spade"><code data-lang="spade"><span>enum </span><span>Insn </span><span>{
</span><span>    Set { dreg</span><span>: </span><span>int&lt;5&gt;</span><span>,</span><span> val</span><span>: </span><span>int&lt;32&gt; }</span><span>,
</span><span>    Add { dreg</span><span>: </span><span>int&lt;5&gt;</span><span>,</span><span> lhs</span><span>: </span><span>int&lt;5&gt;</span><span>,</span><span> rhs</span><span>: </span><span>int&lt;5&gt; }</span><span>,
</span><span>    Sub { dreg</span><span>: </span><span>int&lt;5&gt;</span><span>,</span><span> lhs</span><span>: </span><span>int&lt;5&gt;</span><span>,</span><span> rhs</span><span>: </span><span>int&lt;5&gt; }</span><span>,
</span><span>    Jump { target</span><span>: </span><span>int&lt;32&gt; }
</span><span>}
</span></code></pre>
<p>The compiler ensures that fields can only be accessed if the value is of the
correct type. For example, if the instruction is a <code>Jump</code>, there is no way to
access a <code>dreg</code> field.</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Enums work really well with pattern matching which allows you to check
conditions and easily bind sub-values to variables.</p>
<p>You can easily build an ALU:</p>
<pre data-lang="spade"><code data-lang="spade"><span>fn </span><span>alu</span><span>(</span><span>insn</span><span>:</span><span> Insn, </span><span>rs1</span><span>: </span><span>int&lt;32&gt;, </span><span>rs2</span><span>: </span><span>int&lt;32&gt;) </span><span>-&gt; </span><span>int&lt;32&gt; {
</span><span>    </span><span>let</span><span> adder_result </span><span>= </span><span>match</span><span> insn {
</span><span>        Insn</span><span>::</span><span>Add(</span><span>_</span><span>, </span><span>_</span><span>, </span><span>_</span><span>) </span><span>=&gt;</span><span> rs1 </span><span>+</span><span> rs2</span><span>,
</span><span>        Insn</span><span>::</span><span>Sub(</span><span>_</span><span>, </span><span>_</span><span>, </span><span>_</span><span>) </span><span>=&gt;</span><span> rs1 </span><span>-</span><span> rs2</span><span>,
</span><span>        Insn</span><span>::</span><span>Set(</span><span>_</span><span>,</span><span> val) </span><span>=&gt; </span><span>sext</span><span>(val)</span><span>,
</span><span>        Insn</span><span>::</span><span>Jump(</span><span>_</span><span>) </span><span>=&gt; </span><span>0</span><span>,
</span><span>    }</span><span>;
</span><span>
</span><span>    </span><span>trunc</span><span>(adder_result)
</span><span>}
</span></code></pre>
<p>Or select the first of two values, and 0 if none are present:</p>
<pre data-lang="spade"><code data-lang="spade"><span>let</span><span> result </span><span>= </span><span>match </span><span>(a</span><span>,</span><span> b) {
</span><span>    (</span><span>Some </span><span>(x)</span><span>, </span><span>_</span><span>) </span><span>=&gt;</span><span> x</span><span>,
</span><span>    (</span><span>_</span><span>, </span><span>Some</span><span>(x)) </span><span>=&gt;</span><span> x</span><span>,
</span><span>    </span><span>_ =&gt; </span><span>0
</span><span>}
</span></code></pre>
<p>The compiler makes sure that all cases are covered. For example, if you add a
new instruction to the <code>Insn</code> type, it will force you to deal with that case in
the ALU.</p>
<h3 id="type-inference">Type inference</h3>
<p>Spade has powerful type inference which gives you the benefits of static types,
without all the typing.</p>
<h3 id="great-error-messages">Great Error Messages</h3>
<p>The compiler should be your friend. Error messages give you as much information
as possible</p>
<pre data-lang="text"><code data-lang="text"><span>error: Match branches have incompatible type
</span><span>30 +-Insn::Add(_, _, _) =&gt; rs1 + rs2,
</span><span>   |                       ^^^^^^^^^
</span><span>   |                       This branch has type int&lt;33&gt;
</span><span>32 | Insn::Set(_, val) =&gt; val,
</span><span>   |                      ^^^ But this one has type int&lt;32&gt;
</span><span>   |
</span><span>   = Expected: 33 in: int&lt;33&gt;
</span><span>   =      Got: 32 in: int&lt;32&gt;
</span></code></pre>
<p>Bad error messages are considered a bug. Please report them!</p>
<h3 id="helpful-tooling">Helpful tooling</h3>
<p>Spade comes with a great set of tools around the language</p>
<ul>
<li>The official build tool <a href="https://gitlab.com/spade-lang/swim">Swim</a> manages
your dependencies, calls synthesis tools and runs your tests. It can even
create a new project for you with a single command!
<ul>
<li>Of course you can put the generated Verilog into your regular build flow
as well.</li>
</ul>
</li>
<li>Tests are written in <a href="https://www.cocotb.org/">cocotb</a> allowing you to take
advantage of python for all your testing needs. When you need higher
performance tests, you can also use <a href="https://verilator.org">verilator</a></li>
<li>VCDs coming out of tests are automatically translated to include Spade type
information so you never have to decode individual bits in your waveform.</li>
</ul>
<h3 id="planned-features">Planned features</h3>
<p>There are also some planned features:</p>
<ul>
<li>Integer ranges as types.</li>
<li>Generics with traits</li>
<li>Clock domain information on types.
<ul>
<li>Mixing domains without explicit synchronization is a compilation error.</li>
<li>Related: clock domain inference where the domain is obvious.</li>
</ul>
</li>
<li>And more...</li>
</ul>
<h2 id="using-spade">Using Spade</h2>
<p>To get started, read the (work in progress) <a href="https://docs.spade-lang.org/">spade book</a>.</p>
<p>For an overview of what Spade is, have a look at this
<a href="https://www.youtube.com/watch?v=N6GiefZDhss">talk from OSDA 2023</a>.
Documentation is very much a work in progress, but some is available in our
<a href="https://docs.spade-lang.org">book</a>.</p>
<p>Spade is in its early stages, so everything is subject to change. You can build
things with it but be prepared for bugs and missing features.</p>
<h3 id="learn-more">Learn more</h3>
<p>Feel free to follow the development either on <a href="https://gitlab.com/spade-lang/spade/">Gitlab</a>
or in our <a href="https://discord.gg/YtXbeamxEX">Discord community server</a>.</p>
<h2 id="publications">Publications</h2>
<p>To cite Spade itself, use the <a href="https://zenodo.org/record/7713114">zenodo record</a>.</p>
<ul>
<li><a href="https://orcid.org/0000-0001-7089-9697">Frans Skarman</a>, <a href="https://orcid.org/0000-0002-2571-1058">Lucas Klemmer</a> <a href="https://orcid.org/0000-0003-3470-3911">Oscar Gustafsson</a> <a href="https://orcid.org/0000-0002-1490-6175">Daniel Große</a>.
<a href="https://spade-lang.org/fdl2023.pdf"><strong>Enhancing Compiler-Driven HDL Design with Automatic Waveform Analysis</strong></a>.
September 2023. In: <em>Forum on specification &amp; Design Languages (FDL)</em>.  
</li>
<li><a href="https://orcid.org/0000-0001-7089-9697">Frans Skarman</a>, <a href="https://orcid.org/0000-0003-3470-3911">Oscar Gustafsson</a>.
<a href="https://doi.org/10.48550/arXiv.2304.03079"><strong>Spade: An Expression-Based HDL With Pipelines</strong></a>.
April 2023. In: <em>3rd Workshop on Open-Source Design Automation (OSDA)</em>.  
</li>
<li><a href="https://orcid.org/0000-0001-7089-9697">Frans Skarman</a>, <a href="https://orcid.org/0000-0003-3470-3911">Oscar Gustafsson</a>.
<a href="https://capra.cs.cornell.edu/latte23/paper/2.pdf"><strong>Abstraction in the Spade Hardware Description Language</strong></a>.
March 2023. In: <em>3rd Workshop on Languages, Tools, and Techniques for Accelerator Design (LATTE)</em>.  
</li>
<li><a href="https://orcid.org/0000-0001-7089-9697">Frans Skarman</a>, <a href="https://orcid.org/0000-0003-3470-3911">Oscar Gustafsson</a>.
<a href="https://doi.org/10.1109/FPL57034.2022.00075"><strong>Spade: An HDL Inspired by Modern Software Languages</strong></a>.
August 2022. In: <em>32nd International Conference on Field-Programmable Logic and Applications (FPL)</em>.  
</li>
</ul>
<h2 id="talks">Talks</h2>
<ul>
<li><a href="https://orcid.org/0000-0001-7089-9697">Frans Skarman</a>
<a href="https://spade-lang.org/latchup24.pdf"><strong>Spade - An HDL Inspired by Modern Software Languages</strong></a>.
May 2024. At: <em>LatchUp 2024</em>.  
</li>
</ul>
<h2 id="development">Development</h2>
<!-- TODO: Is this nice to screen readers? -->
<p><a href="https://liu.se/en/organisation/liu/isy">
    <img src="https://spade-lang.org/liu-primary-black.svg" alt="Linköping University logo"/>
    <img src="https://spade-lang.org/liu-primary-white.svg" alt="Linköping University logo"/>
</a></p><p>Spade is currently being developed as an Open Source project at the
<a href="https://liu.se/en/organisation/liu/isy/da">Division of Computer Engineering</a>,
<a href="https://liu.se/en/organisation/liu/isy">Department of Electrical Engineering</a>,
<a href="https://liu.se">Linköping University</a>, Sweden.</p>

<p>The Spade compiler and other tooling is licensed under the <a href="https://gitlab.com/spade-lang/spade/-/blob/master/LICENSE-EUPL-1.2.txt">EUPL-1.2
license</a>.
The Spade standard library and this website is licensed under the terms of both
the <a href="https://gitlab.com/spade-lang/spade/-/blob/master/MIT%20License">MIT
license</a> and
the <a href="https://gitlab.com/spade-lang/spade/-/blob/master/LICENSE-APACHE2.0.txt">Apache
license</a>.</p>

</div>



      </div></div>
  </body>
</html>
