<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.humprog.org/~stephen/blog/2024/09/05/">Original</a>
    <h1>A tiny self-remaking C program</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Diverting trains of thought, wasting precious time</p>
<!--<p>05 09 2024</p>-->
        <h2>Thu, 05 Sep 2024</h2>
<a name="self-remaking"><h3>A tiny self-remaking C program</h3>

</a><p><a name="self-remaking">In </a><a href="https://www.humprog.org/%7Estephen/blog/2024/08/27#how-to-wrap-cc-really">my last post</a>
I floated the idea of writing a slow, edit-prone shell script instead as a self-rebuilding
C program.</p>

<p>Just for fun, here is the briefest way I&#39;ve found to make a one-file C program self-rebuilding.
Note that it only works given an <tt>env</tt> that implements the <tt>-S</tt> option.
That includes the <tt>env</tt> in GNU Coreutils 8.30 or above, and (so I&#39;m told) FreeBSD&#39;s.
So regard it as a total hack not for serious use!
Of course for a more portable version
you can use <tt>#!/bin/sh</tt> and the self-extracting
shell script trick, at a cost of embedding more lines of shell script.</p>

<pre>#!/usr/bin/env -S sh -c &#39;[ &#34;$0&#34;.bin -nt &#34;$0&#34; ] || tail -n+2 &#34;$0&#34; | cc -x c - -o &#34;$0&#34;.bin || exit 1; exec &#34;$0&#34;.bin &#34;$@&#34;&#39;
#include &lt;stdio.h&gt;

int main(void)
{
    printf(&#34;Hello, world!\n&#34;);
    return 0;
}
</pre>

<p>What&#39;s interesting to me is that this models what I&#39;ve long been thinking of
as the right conceptual basis for build systems:
”build is the first stage of execution”.
Even the nicest approaches to build that I&#39;ve seen,
such as the <a href="https://www.microsoft.com/en-us/research/publication/build-systems-la-carte/">“à la carte” paper</a>,
still see the exercise as one of building a collection of strings that
are to be executed as opaque commands.
But commands themselves are just computations;
    they have semantics (e.g. some are pure functions, so their outputs
    are cacheable).
We should be thinking of build as a computation, just as execution is a computation.
Why not all part of the same computation?</p>

<p>Obviously, we want to cache intermediate results—as a way to start execution faster.
    (This comes at the cost of being specialised to our prior inputs: whatever stuff we ingested
    during build.)
The first line above is a bit like a specialised version of “make”
    just for this program,
    including the incrementality (only rebuild if timestamps dictate).
    For a larger program with a “proper” build system,
    it&#39;s not clear what we&#39;d do.</p>

<p>Rebuilding freshly modified source and then running it straight away is also
only what you want to do on a development machine, not for “proper”
deployment—unless
your build system incorporates enough checks that it establishes the assurances you want.
Should tests be integrated into build?
The recent <a href="https://www.openwall.com/lists/oss-security/2024/03/29/4"><tt>xz</tt> backdoor</a>
gives an argument against.
But conversely,
one could argue that any built binary should be subjected to
the greatest available scrutiny before it is run.
The problem in <tt>xz</tt>&#39;s case was that the scrutiny was itself
complex enough to hide the insertion of a back door;
maybe we just need better scrutiny of the scrutiny?
I have no strong opinions about that as yet.</p>
<p>
<i>[<a href="https://www.humprog.org/%7Estephen/blog/devel">/devel</a>] 
<a href="https://www.humprog.org/%7Estephen/blog/2024/09/05#self-remaking">permanent link</a>
<a href="https://www.humprog.org/~stephen/#contact">contact</a>
</i>
</p>
<hr/>
<p><a href="http://blosxom.sourceforge.net/"><img src="https://www.humprog.org/~stephen/blog/pb_blosxom.gif" alt="Powered by blosxom"/></a></p><p>
<span>
<a href="http://validator.w3.org/check?uri=referer">validate this page</a>
</span>
</p>
</div></div>
  </body>
</html>
