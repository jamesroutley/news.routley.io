<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acko.net/blog/the-gpu-banana-stand/">Original</a>
    <h1>The GPU Banana Stand</h1>
    
    <div id="readability-page-1" class="page"><article>

  
    <img src="https://acko.net/files/gpu-banana-stand/cover.jpg" alt="The GPU Banana Stand"/>
  

  
  
    <div><p>
  <h2>Freshly whipped WebGPU, with ice cream</h2>
</p></div>



<img src="https://acko.net/files/gpu-banana-stand/cover.jpg" alt="Cover Image - Fluid Dynamics"/>

<div><div>

<p>I recently rolled out version 0.7 of <a href="https://usegpu.live" target="_blank">Use.GPU</a>, my declarative/reactive WebGPU library.</p>

<p>This includes features and goodies by itself. But most important are the code patterns which are all nicely slotting into place. This continues to be welcome news, even to me, because it&#39;s a novel architecture for the space, drawing heavily from both reactive web tech and functional programming.</p>

<p>Some of the design choices are quite different from other frameworks, but that&#39;s entirely expected: I am not seeking the most performant solution, but the most composable. Nevertheless, it still has fast and minimal per-frame code, with plenty of batching. It just gets there via an unusual route.</p>

<p>WebGPU is not available for general public consumption yet, but behind the dev curtain Use.GPU is already purring like a kitten. So I mainly want more people to go poke at it. Cos everything I&#39;ve been saying about incrementalism can work, and does what it says on the box. It&#39;s still alpha, but there are <a href="https://usegpu.live/docs/guides-getting-started" target="_blank">examples and documentation</a> for the parts that have stabilized, and most importantly, it&#39;s already pretty damn fun.</p>

<p>If you have a dev build of Chrome or Firefox on hand, you can follow along with the <a href="https://usegpu.live/demo/index.html" target="_blank">actual demos</a>. For everyone else, there&#39;s video.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/us2SXQLbDIM" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<h2>Immediate + Retained</h2>

<p>To recap, I built a clone of the core React run-time, called <i>Live</i>, and used it as the basis for a set of declarative and reactive components.</p>

<p>Here&#39;s how I approached it. In WebGPU, to render 1 image in pseudo code, you will have something like:</p>

<pre><code>const main = (props) =&gt; {
  const device = useGPUDevice(); // access GPU
  const resource = useGPUResource(device); // allocate a resource

  // ...

  dispatch(device, ...); // do some compute
  draw(device, resource, ...); // and/or do some rendering
};</code></pre>


<p>This is classic imperative code, aka <i>immediate mode</i>. It&#39;s simple but runs only once.</p>

<p>The classic solution to making this interactive is to add an event loop at the bottom. You then need to write specific code to update specific <code>resources</code> in response to specific events. This is called <i>retained</i> mode, because the <code>resources</code> are all created once and explicitly kept. It&#39;s difficult to get right and gets more convoluted as time goes by.</p>

<p>Declarative programming says instead that if you want to make this interactive, this should be equivalent to just calling <code>main</code> repeatedly with new input <code>props</code> aka args. Each <code>use…()</code> call should then either return the same thing as before or not, depending on whether its arguments changed: the <code>use</code> prefix signifies memoization, and in practice this involves React-like hooks such as <code>useMemo</code> or <code>useState</code>.</p>

<p>In a declarative model, resources can be dropped and recreated on the fly in response to changes, and code downstream is expected to cope. Existing resources are still kept somewhere, but the retention is implicit and hands-off. This might seem like an enormous source of bugs, but the opposite is true: if any upstream value is allowed to change, that means you are free to pass <i>down</i> changed values whenever you like too.</p>

<p>That&#39;s essentially what Use.GPU does. It lets you write code that feels immediate, but is heavily retained on the inside, tracking fine grained dependencies. It does so by turning every typical graphics component into a heavily memoized constructor, while throwing away most of the other usual code. It uses &lt;JSX&gt; so instead of <code>dispatch()</code> you write <code>&lt;Dispatch&gt;</code>, but the principle remains the same.</p>

<p>Like React, you don&#39;t actually re-run all of <code>main(...)</code> every time: every <code>&lt;Component&gt;</code> boundary is actually a resume checkpoint. If you crack open a random Use.GPU component, you will see the same <code>main()</code> shape inside.</p>

</div></div>

<div>

<p><img src="https://acko.net/files/gpu-banana-stand/iphone.jpg" alt="Revolutionary UI - Interplay of hardware and software (Steve Jobs)"/>
</p>

</div>



<div>
  <p><a href="https://acko.net/files/gpu-banana-stand/fluid-sim-tree.png"><img src="https://acko.net/files/gpu-banana-stand/fluid-sim-tree.png" alt="Example component tree"/></a></p><p><em>A Live component tree, showing changes in green.</em></p>
</div>

<div><div>

<h2>3 in 1</h2>

<p>Live goes <a href="https://usegpu.live/docs/guides-live-vs-react" target="_blank">far beyond</a> the usual React semantics, introducing continuations, tree reductions, captures, and more. These are used to make the entire library self-hosted: everything is made out of components. There is no special layer underneath to turn the declarative model into something else. There is only the Live run-time, which does not know anything about graphics or GPUs.</p>

<p>The result is a tree of functions which is simultaneously:</p>

<ul>
<li>an execution trace</li>
<li>the application state</li>
<li>a dependency graph of that state</li>
</ul>

<p>When these 3 concerns are aligned, you get a fully incremental program. It behaves like a big reactive AST expression that builds and rewrites itself. This way, Live is an evolution of React into a fully rewindable, memoized <i>effect run-time</i>.</p>

<p>That&#39;s a mouthful, but when working with Use.GPU, it all comes down to that <code>main()</code> function above. This is exactly the mental model you should be having. All the rest is just window dressing to assemble it.</p>

<p>Instead of hardcoded <code>draw()</code> calls, there is a loop <code>for (let task of tasks) task()</code>. Maintaining that list of <code>tasks</code> is what all the reactivity is ultimately in service of: to apply minimal changes to the code to be run every frame, or the resources it needs. And to determine if it needs to run at all, or if we&#39;re still good.</p>

<p>So the tree in Use.GPU is executable <i>code</i> knitting itself together, and not data at all. This is very different from most typical scene trees or render graphs: these are pure data representations of objects, which are traversed up and down by static code, chasing existing pointers.</p>

<p>The tree form captures more than hierarchy. It also captures order, which is crucial for both dispatch sequencing and 2D layering. Live map-reduce lets parents respond to children without creating cycles, so it&#39;s still all 100% one-way data flow. It&#39;s like a node graph, but there is no artificial separation between the graph and the code.</p>

</div></div>



<div><div>

<p>You already have to decide where in your code particular things happen; a reactive tree is merely a disciplined way to do that. Like a borrow checker, it&#39;s mainly there for your own good, turning something that would probably work fine in 95% of cases into something that works 100%. And like a borrow checker, you will sometimes want to tell it to just f off, and luckily, there are a few ways to do that too.</p>

<p>The question it asks is whether you still want to write classic GPU orchestration code, knowing that the first thing you&#39;ll have to do is allocate some resources with no convenient way to track or update them. Or whether you still want to use node-graph tools, knowing that you can&#39;t use functional techniques to prevent it from turning into spaghetti.</p>

<p>If this all sounds a bit abstract, below are more concrete examples.</p>


<h2>Compute Pipelines</h2>

<p>One big new feature is proper support for compute shaders.</p>

<p>GPU compute is meant to be rendering without all the awful legacy baggage: just some GPU memory buffers and some shader code that does reading and writing. Hence, compute shaders can inherit all the goodness in Use.GPU that has already been refined for rendering.</p>

<p>I used it to build a neat fluid dynamics smoke sim example, with fairly decent numerics too.</p>

<p>The basic element of a compute pipeline is just <code>&lt;Dispatch&gt;</code>. This takes a shader, a workgroup count, and a few more optional props. It has two callbacks, one whether to dispatch conditionally, the other to initialize just-in-time data. Any of these props can change at any time, but usually they don&#39;t.</p>

<p>If you place this anywhere inside a <code>&lt;WebGPU&gt;&lt;Compute&gt;...&lt;/Compute&gt;&lt;/WebGPU&gt;</code>, it will run as expected. <code>WebGPU</code> will manage the device, while <code>Compute</code> will gather up the compute calls. This simple arrangement can also recover from device loss. If there are other dispatches or computes beside it, they will be run in tree order. This works because <code>WebGPU</code> provides a <code>DeviceContext</code> and gathers up dispatches from children.</p>

<p>This is just minimum viable compute, but not very convenient, so other components build on this:</p>

<p>- <code>&lt;ComputeData&gt;</code> creates a buffer of a particular format and size. It can auto-size to the screen, optionally at xN resolution. This can also track N frames of history, like a rotating double or triple buffer. You can use it as a data source, or pass it to <code>&lt;Stage target={...}&gt;</code> to write to it.</p>

<p>- <code>&lt;Kernel&gt;</code> wraps <code>&lt;Dispatch&gt;</code> and runs a compute shader once for every sample in the target. It has conveniences to auto-bind buffers with history, as well as textures and uniforms. It can cycle history every frame. It will also read workgroup size from the shader code and auto-size the dispatch to match the input on the fly.</p>

<p>With these ingredients, a fluid dynamics sim (without visualization) becomes:</p>

</div></div>

<div>
  <p><a href="https://acko.net/files/gpu-banana-stand/fluid-sim-tree-2.png"><img src="https://acko.net/files/gpu-banana-stand/fluid-sim-tree-2.png" alt="Zooming in on component tree"/></a></p><p><em>The expanded result.</em></p>
</div>

<div><div>

<pre><code>&lt;Gather
  children={[
    // Velocity + density field
    &lt;ComputeData format=&#34;vec4&lt;f32&gt;&#34; history={3} resolution={1/2} /&gt;,
    // Divergence
    &lt;ComputeData format=&#34;f32&#34; resolution={1/2} /&gt;,
    // Curl
    &lt;ComputeData format=&#34;f32&#34; resolution={1/2} /&gt;,
    // Pressure
    &lt;ComputeData format=&#34;f32&#34; history={1} resolution={1/2} /&gt;
  ]}
  then={([
    velocity,
    divergence,
    curl,
    pressure,
  ]: StorageTarget[]) =&gt; (
    &lt;Loop live&gt;
      &lt;Compute&gt;
        &lt;Suspense&gt;
          &lt;Stage targets={[divergence, curl]}&gt;
            &lt;Kernel shader={updateDivCurl}
                       source={velocity} /&gt;
          &lt;/Stage&gt;
          &lt;Stage target={pressure}&gt;
            &lt;Iterate count={50}&gt;
              &lt;Kernel shader={updatePressure}
                         source={divergence}
                         history swap /&gt;
            &lt;/Iterate&gt;
          &lt;/Stage&gt;
          &lt;Stage target={velocity}&gt;
            &lt;Kernel shader={generateInitial}
                       args={[Math.random()]}
                       initial /&gt;
            &lt;Kernel shader={projectVelocity}
                       source={pressure}
                       history swap /&gt;
            &lt;Kernel shader={advectForwards}
                       history swap /&gt;
            &lt;Kernel shader={advectBackwards}
                       history swap /&gt;
            &lt;Kernel shader={advectMcCormack}
                       source={curl}
                       history swap /&gt;
          &lt;/Stage&gt;
        &lt;/Suspense&gt;
      &lt;/Compute&gt;
    &lt;/Loop&gt;
  )
/&gt;</code></pre>

</div></div>



<div><div>

<p>Explaining why this simulates smoke is beyond the scope of this post, but you can understand most of what it does just by reading it top to bottom:</p>

<ul>
<li>It will create 4 data buffers: <code>velocity</code>, <code>divergence</code>, <code>curl</code> and <code>pressure</code></li>
<li>It will set up 3 compute stages in order, targeting the different buffers.</li>
<li>It will run a series of compute kernels on those targets, using the output of one kernel as the input of the next.</li>
<li>All this will loop live.</li>
</ul>

<p>Each of the <code>shaders</code> is imported directly from a <code>.wgsl</code> file, because shader closures are a native data type in Use.GPU.</p>

<p>The appearance of <code>&lt;Suspense&gt;</code> in the middle mirrors the React mechanism of the same name. Here it will defer execution until all the shaders have been compiled, preventing a partial pipeline from running. The semantics of Suspense are realized via map-reduce over the tree inside: if any of them yeet a <code>SUSPEND</code> symbol, the entire tree is suspended. So it can work for anything, not just compute dispatches.</p>

<p>What is most appealing here is the ability to declare data sources, name them using variables, and just hook them up to a big chunk of pipeline. You aren&#39;t forced to use excessive nesting like in React, which comes with its own limitations and ergonomic issues. And you don&#39;t have to generate monolithic chunks of JSX, you can use normal code techniques to organize that part too.</p>

</div></div>

<div>

<p><img src="https://acko.net/files/gpu-banana-stand/debug-viz.jpg" alt="Debug visualization - Divergence, Curl, Pressure"/>
</p>

</div>



<div>
  <p><a href="https://acko.net/files/gpu-banana-stand/ui-tree.png"><img src="https://acko.net/files/gpu-banana-stand/ui-tree.png" alt="Example component UI tree"/></a></p><p><em>A tree of layout components, reduced into shapes, reduced into layers.</em></p>
</div>

<div><div>
  
<h2>HTML/GPU</h2>

<p>The fluid sim example includes a visualization of the 3 internal vector fields. This leverages Use.GPU&#39;s HTML-like layout system. But the 3 &#34;divs&#34; are each directly displaying a GPU buffer.</p>

<p>The data is colored using a shader, defined using a <code>wgsl</code> template.</p>

<pre><code>const debugShader = wgsl`
  @link fn getSample(i: u32) -&gt; vec4&lt;f32&gt; {};
  @link fn getSize() -&gt; vec4&lt;u32&gt; {};
  @optional @link fn getGain() -&gt; f32 { return 1.0; };

  fn main(uv: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt; {
    let gain = getGain(); // Configurable parameter
    let size = getSize(); // Source array size

    // Convert 2D UV to linear index
    let iuv = vec2&lt;u32&gt;(uv * vec2&lt;f32&gt;(size.xy));
    let i = iuv.x + iuv.y * size.x;

    // Get sample and apply orange/blue color palette
    let value = getSample(i).x * gain;
    return sqrt(vec4&lt;f32&gt;(value, max(value * .1, -value * .3), -value, 1.0));
  }
`;

const DEBUG_BINDINGS = bundleToAttributes(debugShader);

const DebugField = ({field, gain}) =&gt; {
  const boundShader = useBoundShader(
    debugShader,
    DEBUG_BINDINGS,
    [field, () =&gt; field.size, gain || 1]
  );
  const textureSource = useLambdaSource(boundShader, field);
  return (
    &lt;Element
      width={field.size[0] / 2}
      height={field.size[1] / 2}
      image={ {texture: textureSource} }
    /&gt;
  );
};
</code></pre>


<p>Above, the <code>DebugField</code> component binds the coloring shader to a vector <code>field</code>. It turns it into a <i>lambda source</i>, which just adds array size metadata (by copying from <code>field</code>).</p>

<p><code>DebugField</code> returns an <code>&lt;Element&gt;</code> with the shader as its <code>image</code>. This works because the equivalent of CSS <code>background-image</code> in Use.GPU can accept a shader function <code>(uv: vec2&lt;f32&gt;) -&gt; vec4&lt;f32&gt;</code>.</p>

</div></div>

<div><div>

<p>So this is all that is needed to slap a live, procedural texture on a UI element. You can use all the standard image alignment and sizing options here too, because why wouldn&#39;t you?</p>

<p>Most UI elements are simple and share the same basic archetype, so they will be batched together as much as drawing order allows. Elements with unique shaders however are realized using 1 draw call per element, which is fine because they&#39;re pretty rare.</p>

<p>This part is not new in 0.7, it&#39;s just gotten slightly more refined. But it&#39;s easy to miss that it can do this. Where web browsers struggle to make their rendering model truly extensible, Use.GPU instead invites you to jump right in using first-class tools. Cos again: <i>shader closures</i> are a <i>native data type</i> the same way that there was <i>money</i> in that <i>banana stand</i>. I don&#39;t know how to be any clearer than this.</p>

<p>The shader snippets will end up inlined in the right places with all the right bindings, so you can just go nuts.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/m63lDb7pw7M" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<h2>Dual Contouring</h2>

<p>3D plotting isn&#39;t complete without rendering implicit surfaces. In WebGL this was very hard to do well, but in WebGPU it&#39;s entirely doable. Hence there is a <code>&lt;DualContourLayer&gt;</code> that can generate a surface for any level in a volume. I chose <a href="https://www.boristhebrave.com/2018/04/15/dual-contouring-tutorial/" target="_blank">dual contouring</a> over e.g. marching cubes because it&#39;s always topologically sound, and also easy to explain.</p>

<p>Given a volume of data, you can classify each data point as inside or outside. You can then create a &#34;minecraft&#34; or &#34;q-bert&#34; mesh of cube faces, which cleanly separates all inside points from outside. This mesh will be topologically closed, provided it fits within the volume.</p>

<p><a href="https://www.boristhebrave.com/2018/04/15/dual-contouring-tutorial/" target="_blank"><img src="https://acko.net/files/gpu-banana-stand/dc_tee_comparison.svg" alt="dual contouring grid"/></a></p>

<p>In practice, you check every X, Y and Z edge between every adjacent pair of points, and place a cube face that sits across perpendicular. This creates cubes that are offset by half a cell, which is where the &#34;dual&#34; in the name comes from.</p>

<p><a href="https://www.boristhebrave.com/2018/04/15/dual-contouring-tutorial/" target="_blank"><img src="https://acko.net/files/gpu-banana-stand/dc_single_face.png" alt="dual contouring grid"/></a></p>

<p>The last step is to make it smooth by projecting all the vertices onto the actual surface (as best you can), somewhere inside each containing cell. For &#34;proper&#34; dual contouring, this uses both the field and its gradients, using a difficult-to-stabilize least-squares fit. But high quality gradients are usually not available for numeric data, so I use a simpler linear technique, which is more stable.</p>

</div></div>

<p><img src="https://acko.net/files/gpu-banana-stand/dual-contour-flat.png" alt="dual contouring flat"/>
</p>

<p><img src="https://acko.net/files/gpu-banana-stand/dual-contour-smooth.png" alt="dual contouring smooth"/>
</p>

<div><div>

<p>The resulting mesh looks smooth, but does not have clean edges on the volume boundary, revealing the cube-shaped nature. To hide this, I generate a border of 1 additional cell in each direction. This is trimmed off from the final mesh using a per-pixel scissor in a shader. I also apply anti-aliasing similar to SDFs, so it&#39;s indistinguishable from actual mesh edges.</p>

<p><img src="https://acko.net/files/gpu-banana-stand/scissor.png" alt="edge scissor"/></p>

<p><code>&lt;DualContourLayer&gt;</code> is the currently the most complex geometry component in the whole set. But in use, it&#39;s a simple layer which you just feed volume data to get a shaded mesh. On the inside it&#39;s realized using 2 compute dispatches and an indirect draw call, as well as a non-trivial vertex and fragment shader. It also plays nice with the lighting system, and the material system, the transform system, and so on, each of which comes from the surrounding context.</p>

<p>I&#39;m very happy with the result, though I&#39;m pretty disappointed in compute shaders tbh. The GPU ergonomics are plain terrible: despite knowing virtually nothing about the hardware you&#39;re on, you&#39;re expected to carefully optimize your dispatch size, memory access patterns, and more. It&#39;s pretty absurd.</p>

<p>The most basic case of &#34;embarrassingly parallel shader&#34; isn&#39;t even optimized for: you have to dispatch at least as many threads as the hardware supports, or it may have up to 2x, 4x, 8x... slowdown as X% sits idle. Then, with a workgroup size of e.g. 64, if the data length isn&#39;t a multiple of 64, you have to manually trim off those last threads in the shader yourself.</p>

<p>There are basically two worlds colliding here. In one world, you would never dream to size anything other than some (multiple of) power-of-two, because that would be inefficient. In the other world, it&#39;s ridiculous to expect that data comes in power-of-two sizes. In some ways, this is the real GPU ↔︎ CPU gap.</p>

<p>Use.GPU obviously chooses the world where such trade-offs are unreasonable impositions. It has lots of ergonomics around getting data in, in various forms, and it tries to paper over differences where it can.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/bTiOoB2S7U4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<h2>Transforms and Differentials</h2>

<p>Most 3D engines will organize their objects in a tree using matrix transforms.</p>

<p>In React or Live, this is trivial because it maps to the normal component update cycle, which is batched and dispatched in tree order. You don&#39;t need dirty flags: if a matrix changes somewhere, all children affected by it will be re-evaluated.</p>

<pre><code>const Node = ({matrix, children}) =&gt; {
  const parent = useContext(MatrixContext);
  const combined = matrixMultiply(parent, matrix);
  return provide(MatrixContext, combined, children);
};
</code></pre>


<p>This is a common theme in Use.GPU: a mechanism that normally would have to be coded disappears almost entirely, because it can just re-use native tree semantics. However, Use.GPU goes much further. Matrix transforms are just one kind of transform. While they are a very convenient sweet spot, it&#39;s insufficient as a general case.</p>

<p>
<img src="https://acko.net/files/gpu-banana-stand/transformcontext.png" alt="dual contouring smooth"/>
</p>

<p>So its <code>TransformContext</code> doesn&#39;t hold a matrix, it holds any shader function <code>vec4&lt;f32&gt; -&gt; vec4&lt;f32&gt;</code>. This operates on the positions. When you nest one transform in the other, it will chain both shader functions in series. The transforms are inlined directly into the affected vertex shaders. If a transform changes, downstream draw calls can incorporate it and get new shaders.</p>

<p>If you used this for ordinary matrices, they wouldn&#39;t merge and it would waste GPU cycles. Hence there are still classic matrix transforms in e.g. the GLTF package. This then compacts into a single <code>vec4&lt;f32&gt; -&gt; vec4&lt;f32&gt;</code> transform per mesh, which can compose with other, general transforms.</p>

<p>You can compose e.g. a spherical coordinate transform with a stereographic one, animate both, and it works.</p>

<p>It&#39;s weird, but I feel like I have to stress and justify that this is Perfectly Fine™... even more, that it&#39;s Okay To Do Transcendental Ops In Your Vertex Shader, because I do. I think most graphics dev readers will grok what I mean: focusing on performance-über–alles can smother a whole category of applications in the crib, when the more important thing is just getting to try them out at all.</p>

<p>Dealing with arbitrary transforms poses a problem though. In order to get proper shading in 3D, you need to transform not just the positions, but also the tangents and normals. The solution is a <code>DifferentialContext</code> with a shader function <code>(vector: vec4&lt;f32&gt;, base: vec4&lt;f32&gt;, contravariant: bool) -&gt; vec4&lt;f32&gt;</code>. It will transform the differential <code>vector</code> at a point <code>base</code> in either a covariant (tangent) or contravariant (normal) way.</p>

<p>There&#39;s also a differential combinator: it can <a href="https://gitlab.com/unconed/use.gpu/-/blob/master/packages/wgsl/src/transform/diff-chain.wgsl" target="_blank">chain analytical differentials</a> if provided, transforming the base point along. If there&#39;s no analytic differential, it will substitute a <a href="https://gitlab.com/unconed/use.gpu/-/blob/master/packages/wgsl/src/transform/diff-epsilon.wgsl" target="_blank">numeric one</a> instead.</p>

<p>You can e.g. place an implicit surface inside a cylindrical transform, and the result will warp and shade correctly. Differential indicators like tick marks on axes will also orient themselves automatically. This might seem like a silly detail, but it&#39;s exactly this sort of stuff that I&#39;m after: ways to make 3D graphics parts more useful as general primitives to build on, rather than just serving as a more powerful triangle blaster.</p>

<p>It&#39;s all composable, so all optional. If you place a simple GLTF model into a bare draw pass, it will have a classic <code>projection</code> × <code>view</code> × <code>model</code> vertex shader with vanilla normals and tangents. In fact, if your geometry isn&#39;t shaded, it won&#39;t have normals or tangents at all.</p>

<p>Content like map tiles also benefits from Use.GPU&#39;s sophisticated z-biasing mechanism, to ensure correct visual layering. This is an evolution of classic polygon offset. The crucial trick here is to just size the offset proportionally to the actual point or line width, effectively treating the point as a sphere and the line as tube. However, as Use.GPU has 2.5D points and lines, getting this all right was quite tricky.</p>

<p>But, setting <code>zBias={+1}</code> on a line works to bias it exactly over a matching surface, regardless of the line width, regardless of 2D vs 3D, and regardless of which side it is viewed from. This is IMO the API that you want. At glancing angles <code>zBias</code> automatically loses effect, so there is no popping.</p>
  
<h2>A DSL for DSLs</h2>

<p>You could just say &#34;oh, so this is just a domain-specific language for render and compute&#34; and wonder how this is different from any previous plug-and-play graphics solution.</p>

<p>Well first, it&#39;s not a proxy for anything else. If you want to do something that you can&#39;t do with <code>&lt;Kernel&gt;</code>, you aren&#39;t boxed in, because a <code>&lt;Kernel&gt;</code> is just a <code>&lt;Dispatch&gt;</code> with bells on. Even then, <code>&lt;Dispatch&gt;</code> is also replaceable, because a <code>&lt;Dispatch&gt;</code> is just a <code>&lt;Yeet&gt;</code> of a lambda you could write yourself. And a <code>&lt;Compute&gt;</code> is ultimately also a yeet, of a per-frame lambda that calls the individual kernel lambdas.</p>

<p>This principle is pervasive throughout Use.GPU&#39;s API design. It invites you to use its well-rounded components as much as possible, but also, to crack them open and use the raw parts if they&#39;re not right for you. These components form a few different play sets, each suited to particular use cases and levels of proficiency. None of this has the pretense of being no-code; it merely does low-code in a way that does not obstruct full-code.</p>

<p>You can think of Use.GPU as a process of run-time macro-expansion. This seems quite appropriate to me, as the hairy problem being solved is preparing and dispatching code for another piece of hardware.</p>

<p>Second, there is a lot of value in DSLs for pipeline-like things. Graphs are just no substitute for real code, so DSLs should be real programming languages with escape hatches baked in by default. Much of the value here isn&#39;t in the comp-sci cred, but rather in the much harder work of untangling the mess of real-time rendering at the API level.</p>

<p>The resulting programs also have another, notable quality: the way they are structured is a pretty close match to how GPU code runs... as async dispatches of functions which are only partially ordered, and mainly only at the point where results are gathered up. In other words, Use.GPU is not just a blueprint for how the CPU side can look, it also points to a direction where CPU and GPU code can be made much more isomorphic than today.</p>

<p>When fully expanded, the resulting trees can still be quite the chonkers. But every component has a specific purpose, and the data flow is easy to follow using the included Live Inspector. A lot of work has gone into making the semantics of Live legible and memorable.</p>

</div></div>

<div>
<p><img src="https://acko.net/files/gpu-banana-stand/quote.png" alt="jsx quoting + reconciling"/></p><p><em>Quoting: it&#39;s just like Lisp, but incremental.</em></p>
</div>



<div><div>

<h2>Re-re-re-concile</h2>

<p>The neatest trick IMO is where the per-frame lambdas go when emitted.</p>

<p>In 0.7, Live treats the draw calls similar to how React treats the HTML DOM: as something to be reconciled out-of-band. But what is being reconciled is not HTML, it&#39;s just other Live JSX, which ends up in a new part of the current tree. So this will also run it. You can even portal back and forth at will between the two sub-trees, while respecting data causality and context scope.</p>

<p>Along the way Live has gained actual bona-fide <code>&lt;Quote&gt;</code> and <code>&lt;Unquote&gt;</code> operators, to drive this recursive <code>&lt;Reconcile&gt;</code>. This means Use.GPU now neatly sidesteps Greenspun&#39;s law by containing a <i>complete</i> and <i>well-specified</i> version of a Lisp. Score.</p>

<p>You could also observe that the Live run-time could itself be implemented in terms of Quote and Unquote, and you would probably be correct. But this is the kind of code transform that would buy only a modicum of algorithmic purity at the cost of a lot of performance. So I&#39;m not going there, and leave that exercise for the programming language people. And likely that would eventually result in an optimization pass to bring it closer to what it already is today.</p>

<p>My real point is, when you need to write code to produce code, it needs to be Lisp or something very much like it. But <i>not because of purity</i>. It&#39;s because otherwise you will end up denying your API consumers affordances you would find essential yourself.</p>

<p>Typescript is not the ideal language to do this in, but under the circumstances, it is one of the least worst. AFAIK no language has the resumable generator semantics Live has, and I need a modern graphics API too, so practical concerns win out instead. Mirroring React is also good, because the tooling for it is abundant, and the patterns are well known by many.</p>

<p>This same tooling is also what lets me import WGSL into TS without reinventing all the wheels, and just piggy backing on the existing ES module system. Though try getting Node.js, TypeScript and Webpack to all agree what a <code>.wgsl</code> module should be for, it&#39;s uh... a challenge.</p>

<p>* * *</p>

<p>The story of Use.GPU continues to evolve and continues to get simpler too. 0.7 makes for a pretty great milestone, and the <a href="https://usegpu.live/docs/roadmap">roadmap</a> is looking pretty green already.</p>

<p>There are still a few known gaps and deliberate oversights. This is in part because Use.GPU focuses on use cases that are traditionally neglected in graphics engines: quality vector graphics, direct data visualization, generative geometry, scalable UI, and so on. It took months before I ever added lighting and PBR, because the unlit, unshaded case had enough to chew on by itself.</p>

<p>Two obvious missing features are post-FX and occlusion culling.</p>

<p>Post-FX ought to be a straightforward application of the same pipelines from compute. However, doing this right also means building a good solution for producing derived render passes, such as normal and depth. The same also applies to shadow maps, which are also absent for the same reason.</p>

<p>Occlusion culling is a funny one, because it&#39;s hard to imagine a graphics renderer without it. The simple answer is that so far I haven&#39;t needed it because rendering 3D worlds is not something that has come up yet. My Subpixel SDF visualization example reached 1 million triangles easily, without me noticing, because it wasn&#39;t an issue even on an older laptop.</p>

<p>Most of those triangles are generative points and lines, drawn directly from compact source data:</p>

</div></div>



<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/4cTSSAMlIY0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>
  
<p>This is the same video from last time, I know, but here&#39;s the thing:</p>

<p>There is not a single browser engine where you could dump a million elements into a page and still have something that performs, at all. Just doesn&#39;t exist. In Use.GPU you can get there by accident. On a single thread too. Without the indirection of a retained DOM, you just have code that reduces code that dispatches code to produce pixels.</p>

</div></div>


  

  
</article></div>
  </body>
</html>
