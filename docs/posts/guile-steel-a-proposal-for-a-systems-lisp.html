<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dustycloud.org/blog/guile-steel-proposal/">Original</a>
    <h1>Guile Steel: a proposal for a systems Lisp</h1>
    
    <div id="readability-page-1" class="page"><div><p>Before we get into this kind of stream-of-consciousness outline, I&#39;d
like to note that very topically to this, over at the
<a href="https://spritely.institute/">Spritely Institute</a> (where I&#39;m CTO, did
I mention on here yet that I&#39;m the CTO of a nonprofit to improve
networked communication on the internet on this blog?  because I don&#39;t
think I did) we
<a href="https://spritely.institute/news/the-spritely-institute-publishes-a-scheme-primer.html">published</a>
a <a href="https://spritely.institute/static/papers/scheme-primer.html">Scheme Primer</a>,
and the feedback to it has been just lovely.
This post isn&#39;t a Spritely Institute thing (at least, not yet, though
if its ideas manifested it could be possible we might use some of the
tech), but since it&#39;s about Scheme, I thought I&#39;d mention that.</p><p>This blogpost outlines something I&#39;ve had kicking around in my head
for a while: the desire for a modern &#34;systems lisp&#34;, you know, kind of
like Rust, except hopefully much better than Rust, and in Lisp.  (And,
if it turns out to be for not other reason, it might simply be better
by <em>being</em> written in a Lisp.)  But let&#39;s be clear: I haven&#39;t written
anything, this blogpost is a ramble, it&#39;s just kind of a set of
<em>feelings</em> about what I&#39;d like, what I think is possible.</p><p>Let&#39;s open by saying that there&#39;s no real definition of what a
&#34;systems language&#34; is... but more or less what people mean is,
&#34;something like C&#34;.  In other words, what people nowadays consider a
low-level language, even though C used to be considered a high level
language.  And what people <em>really</em> mean is: it&#39;s fast, it&#39;s
statically typed, and it&#39;s really for the bit-fiddling types of speed
demons out there.</p><p>Actually, let&#39;s put down a few asides for a moment.  People have
conflated two <em>different</em> benefits fo &#34;statically typed&#34; languages
because they&#39;ve mostly been seen together:</p><ul><li>Static typing for ahead-of-time more-correct programs</li><li>Static typing for faster or leaner programs (which subdivides in
terms of memory and CPU benefits, more or less)</li></ul><p>In the recent <a href="https://fossandcrafts.org">FOSS &amp; Crafts</a> episode
<a href="https://fossandcrafts.org/episodes/47-what-is-lisp.html">What is Lisp?</a>
we talk a bit about how the assumptions that dynamically typed
languages are &#34;slow&#34; is really due to lack of hardware support,
and that lisp machines actually had hardware support directly (tagged
memory architecture and hardware garbage collection) and even wrote
low-level parts of their systems like the &#34;graphics drivers&#34; directly
in lisp, and it was plenty fast, and that it would even be possible to
have co-processors on which dynamic code (not just lisp) ran at
&#34;native speed&#34; (this is what the
<a href="https://en.wikipedia.org/wiki/Symbolics#Ivory_and_Open_Genera">MacIvory</a>
did), but this is all somewhat of an aside because that&#39;s not the
world we live in.  So as much as I,
Christine, would love to have tagged architecture (co-)processors, they
probably won&#39;t happen, except there&#39;s some
<a href="https://lowrisc.org/docs/tagged-memory-v0.1/">RISC-V tagged</a>
<a href="https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_10-3_Weiser_paper.pdf">architecture</a>
things but I don&#39;t think they&#39;ve gotten very far and they seem mostly
motivated by a security model that doesn&#39;t make any sense to me.
But I&#39;d love to be wrong on this!  I would like tagged RISC-V to
succeed!  But still, there&#39;s the problem of memory management, and
I don&#39;t think anyone&#39;s been working on a hardware garbage collector
or if that would really be a better thing anyway.</p><p>The fact is, there&#39;s been a reinforcing effect over the last several
decades since the death of the lisp machine: CPUs are optimized for C,
and C is optimized for CPUs, and both of them try to optimize for each
other.  So &#34;systems programming&#34; really means &#34;something like C&#34;
because that&#39;s what our CPUs like because that&#39;s what our languages
like and these are pretty much re-inforcing.</p><p>And besides, C is basically the lingua franca of programming
languages, right?  If you want to make something widely portable,
you target the C ABI, because pretty much all programming languages
have some sort of C FFI toolkit thing or just make C bindings, and
everyone is happy.  Except, oh wait,
<a href="https://gankra.github.io/blah/c-isnt-a-language/#c-doesnt-actually-have-an-abi">C doesn&#39;t actually have an ABI</a>!
Well, okay, I guess not, but it doesn&#39;t matter because the C ABI
triples, that&#39;s what the world works with.</p><p>Well also, you gotta target the web, right?  And actually the story
there is a bit nicer because <a href="https://webassembly.org/">WebAssembly</a>
is actually kinda awesome, and the hope and dream is that all
programming languages in some way or another target WebAssembly, and
then &#34;you gotta write your thing in Javascript because it&#39;s the
language of the web!!!&#34; is no longer a thing I have to hear anymore.
(Yes, all my friends who work on Javascript, I appreciate you for
making it the one programming language which has <em>mostly</em> gotten
better over time... hopefully it
<a href="https://scribe.rip/the-tragedy-of-the-common-lisp-why-large-languages-explode-4e83096239b9">stays that way</a>,
and best of luck.)
But the point is, any interesting programming language these days
should be targeting Webassembly, and hopefully not just via
<a href="https://emscripten.org/">Emscripten</a>, but hopefully via actually
targeting Webassembly directly.</p><p>So okay, we have at least two targets for our &#34;system language&#34;: C, or
something that is C-compatible, and Webassembly.
And static type analysis in terms of preventing errors, that&#39;s also a
useful thing, I won&#39;t deny it.  (I think the division of &#34;statically
typed&#34; and &#34;dynamically typed&#34; languages is probably more of a false
one than we tend to think, but that&#39;s a future blogpost, to be
written.)  And these days, it&#39;s <em>also</em> how you get speed while also
being maximally bit-twiddly fast, because that&#39;s how our machines
(including the abstract one in Webassembly) are designed.  So okay,
grumbling about conflating two things aside, let&#39;s run with that.</p><p>So anyway, I promised to write about this &#34;Guile Steel&#34; thing I&#39;ve
been musing about, and we&#39;ve gotten this far in the article, and I
haven&#39;t yet.  So, this is, more than a concrete proposal, a call to
arms to implement just such a systems language for Guile.  I might
make a prototype at some point, but you, dear reader, are free to take
the idea of &#34;Guile Steel&#34; and run with it.  In fact, please do.</p><p>So anyway.  First, about the name.  It&#39;s probably pretty obvious based
on the name that I&#39;m suggesting this be a language for
<a href="https://www.gnu.org/software/guile/">Guile</a> Scheme.  And &#34;Guile&#34; as a
name itself is both a continuation of the kind of playfully
mischevious names in the Scheme family and its predecessors, but also
a pun on co-founder of the Scheme language, Guy L. Steele.  So &#34;Guile
Steele&#34; kinda brings that pun home, and &#34;Steel&#34; sounds low-level,
close to the metal.</p><p>But also, Guile has a lovely
<a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">compiler tower</a>.
It would be nice to put some more lovely things on it!  Why not a
systems language?</p><p>There&#39;s some precedent here.  The lovely
<a href="https://www.s48.org/">Scheme 48</a>&#39;s lowest levels of code
(including its garbage collector) are written in an interesting
language called
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.4031">PreScheme</a>
(<a href="https://thintz.com/resources/prescheme-documentation">more on PreScheme</a>),
which is something that&#39;s kind of like Scheme, but not really.
It doesn&#39;t do automatic garbage collection itself, and I think
Rust has shown that this area could be improved for a more modern
PreScheme system.
But you <em>can</em> hack on it at the REPL, and then it can compile to
C, and it also has an implementation on Common Lisp, so you can
bootstrap it a few different ways.
PreScheme uses a
<a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner type system</a>;
I suspect we can do even better with
<a href="https://www.youtube.com/watch?v=jI8gA68OXLM">a propagator approach</a>
but that&#39;s untested.
Anyway, starting by porting PreScheme from Scheme48 to Guile directly
would be a good way to get going.</p><p>Guile also has some pretty good reasons to want something like this.
For one thing, if you&#39;re a
<a href="https://www.gnu.org/software/guile/">Guile</a>
person, then by gosh you&#39;re probably
<a href="https://guix.gnu.org/">a Guix person</a>.
And Rust, it&#39;s real popular these days, and for good reasons, we&#39;re
all better of with less memory vulnerabilities in our lives, but you
know... it&#39;s kind of a pain, packaging wise, I hear?  Actually
I&#39;ve never tried packaging anything in Rust but
<a href="https://www.youtube.com/watch?v=ehghWzMXUts">Efraim certainly has</a>
and when your presentation starts with the slide &#34;Packaging Rust
crates in GNU Guix: How hard could it possibly be?&#34; I guess the
answer is going to be that it&#39;s a bit of a headache.  So maybe
it&#39;s not the end of the world, but I think it might be nice if on
that ground we had our own alternative, but that&#39;s just a minor thing.</p><p>And I don&#39;t think there&#39;s anything wrong with Rust, but I&#39;d love to
see... can we do better?  I feel like it could be hackable,
accessible, and it also could, probably, be a lot of fun?  That&#39;s a
good reason, I know I&#39;d like something like this myself, I&#39;d like to
play with it, I&#39;d like to be able to use it.</p><p>But maybe also... well, let&#39;s not beat around the bush, a whole lot
of Guile is written in C, and our dear wonderful
<a href="https://wingolog.org/">Andy Wingo</a> has done a lot of lovely things
to make us less dependent on C, some
<a href="https://wingolog.org/archives/2016/01/11/the-half-strap-self-hosting-and-guile">half-straps</a>
and some
<a href="https://wingolog.org/archives/2020/06/03/a-baseline-compiler-for-guile">baseline compilers</a>
and just rewriting a lot of stuff in Scheme and so on and so forth but
it would be nice if we had something we could officially rally around
as &#34;hey this is the thing we&#39;re going to start rewriting things in&#34;,
because you know, C really is kind of a hard world to trust, and I&#39;d
like the programming language environment I rely on to not be so
heavily built on it.</p><p>And at this point in the article, I have to say that
<a href="https://fedi.xerz.one/users/xerz">Xerz!</a> pointed out that there
is a thing called <a href="https://github.com/carp-lang/Carp">Carp</a> which
is indeed a lisp that compiles to C and you know what, I&#39;m pretty
embarassed for having not paid attention to it... I certainly saw
it linked at one point but didn&#39;t pay enough attention, and... maybe
it needs a closer look.  Heck, it&#39;s written in Haskell, which is a
pretty cool choice.</p><p>But hey, the Guile community still deserves a thing of its own, right?
What do we have that <a href="https://www.gnu.org/software/guile/manual/html_node/Compiler-Tower.html">compiler tower</a>
for if we&#39;re not going to add some cool things to it?
And... gosh, I&#39;d really like to get Guile in the browser, and there
are some various paths, and
<a href="https://archive.fosdem.org/2021/schedule/event/webassembly/">Wingo gave a fun presentation on compiling to Webassembly</a>
last year, but wouldn&#39;t it be nice if just our whole language stack
was written in something designed to compile to either something
C-like or... something?</p><p>I might do some weekend fiddling towards this direction, but sadly
this can&#39;t be my main project.  As a call to arms, maybe it inspires
someone to take it up as theirs though.  I will say that if you work
on it, I promise to spend some time using whatever you build and
trying it out and sending patches.  So that&#39;s it, that&#39;s my
stream-of-consciousness post on Guile Steel: currently an idea...
maybe eventually a reality?</p></div></div>
  </body>
</html>
