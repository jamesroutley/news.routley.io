<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.adriancourreges.com/blog/2015/06/23/supreme-commander-graphics-study/">Original</a>
    <h1>Supreme Commander Graphics Study (2015)</h1>
    
    <div id="readability-page-1" class="page"><div><p>
<img src="http://www.adriancourreges.com/img/blog/2015/supcom/supcom-logo.png"/>
</p>
<p><a href="https://en.wikipedia.org/wiki/Total_Annihilation">Total Annihilation</a> has a special place in my heart since it was the very first RTS I played;
it was with <a href="https://en.wikipedia.org/wiki/Command_%26_Conquer_%281995_video_game%29">Command &amp; Conquer</a> and <a href="https://en.wikipedia.org/wiki/StarCraft">Starcraft</a> one of the best RTS released in the late 90’s.</p>
<p>10 years later – in 2007 – its successor was released: <a href="https://en.wikipedia.org/wiki/Supreme_Commander_%28video_game%29">Supreme Commander</a>.</p>
<p>Supreme Commander turned out to be highly praised by critics and players, with nice features like the “strategic zoom” or physically realistic ballistic.</p>
<p>So let’s see how Moho, the engine powering SupCom, renders a frame of the game! </p>

<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-00-map-overview.jpg" width="200/"/></p>
<p>Before we dig into the frame rendering, it’s important to first talk about how terrains are built in SupCom and which technique is used.</p>
<p>Here is an overview of “Finn’s Revenge”, a 1 versus 1 map.</p>
<p>On the left is a top-view of the entire map like it appears in-game on the mini-map.</p>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-98.jpg"/></p>
<p>First the geometry of the terrain is calculated from an <a href="https://en.wikipedia.org/wiki/Heightmap">heightmap</a>.</p>
<table>
<tbody><tr>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-03-heightmap.jpg"/>
</p>
<p>Heightmap</p>
</div>
</td>
<td>
<img src="http://www.adriancourreges.com/img/arrow-right.png"/>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-15-wireframe.jpg"/>
</p>
<p>Tessellated Terrain</p>
</div>
</td>
</tr>
</tbody></table>

<p>So we have a mesh which represents our terrain.</p>
<div id="a_map_tessellation">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-15-wireframe.jpg"/>
</p>
<p>Wireframe Terrain</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-20-no-water-color.jpg"/>
</p>
<p>Albedo + Normal Textures</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-30-stratum1-off.jpg"/>
</p>
<p>Sea Level Color Modulation</p>
</div>
</div>
</div>

<p>Okay so having altitude-based texturing is nice, but it gets limiting quite quickly. </p>

<p>The technique used is called “<a href="https://en.wikipedia.org/wiki/Texture_splatting">Texture splatting</a>”: the game draws a series of additional albedo+normal textures.
Each step adds what’s called a “stratum” to the terrain.</p>
<div id="a_splatmap_frame">
<div>
<table>
<tbody><tr>
<td>

</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/blank.png"/>
</p>
<p>No Splatmap</p>
</div>
<p><img src="http://www.adriancourreges.com/img/arrow-down.png"/>
</p>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_stratum_albedo_0.jpg"/>
</p>
<p>Albedo</p>
</div>
<p><img src="http://www.adriancourreges.com/img/arrow-down.png"/>
</p>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_stratum_normal_0.jpg"/>
</p>
<p>Normal</p>
</div>
<p><img src="http://www.adriancourreges.com/img/arrow-down.png"/>
</p>
</td>
</tr>
</tbody></table>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-30-stratum1-off.jpg"/>
</p>
</div>
</div>




</div>

<p>So we applied strata 1, 2, 3 and 4, each one relying on 3 separate textures.
The albedo and normal textures use 3 channels (RGB) each, but the splat map uses only one channel.</p>


<p>Okay so we got more texture variations for our terrain. It looks nice from far away, but if
you zoom-in you quickly notice the lack of high-frequency details.</p>
<p>This is when decals are applied: these are like small sprites which modify locally
the albedo color and the normal of a pixel. This terrain has 861 instances of 21 unique decals.</p>
<div id="a_map_decals">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-70-no-decals.jpg"/>
</p>
<p>Decals: Before</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-78-no-props.jpg"/>
</p>
<p>Decals: After</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-79-decals-highlight.jpg"/>
</p>
<p>Decals Highlight</p>
</div>
</div>
</div>

<p>It’s much better but what about some vegetation?</p>
<div id="a_map_props">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-78-no-props.jpg"/>
</p>
<p>Props: Before</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-95-nosea.jpg"/>
</p>
<p>Props: After</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-97-props-highlight.jpg"/>
</p>
<p>Props Highlight</p>
</div>
</div>
</div>

<p>Now the final touch: the sea surface. It is a combination of several normal maps with UV scrolling
along different directions, an environment map for reflections and sprites for the waves near the shores.</p>
<div id="a_sea_surface">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-95-nosea.jpg"/>
</p>
<p>Sea Surface: Before</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a-98.jpg"/>
</p>
<p>Sea Surface: After</p>
</div>
</div>
</div>

<p>Our terrain is now ready.</p>
<p>So now that we know the theory behind the SupCom terrains, let’s move on to an actual frame of the game.</p>

<p>This is the game frame we’ll dissect:</p>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_95_final_frame.jpg"/></p>
<h3>Frustum Culling</h3>
<p>The game has in RAM the terrain mesh, created from the heightmap, it is tessellated by the CPU and the position of each vertex is known.
When the zoom level changes, the CPU re-calculates the tessellation of the terrain. </p>
<div id="a_frustum_cull">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_00_frutsumcull_0.jpg"/>
</p>
<p>Frustum Culling: Before</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_00_frutsumcull_1.jpg"/>
</p>
<p>Frustum Culling: After</p>
</div>
</div>
</div>

<h3>Normal Map</h3>
<p>First, only the normals are calculated.</p>
<table>
<tbody><tr>
<td>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_01_normal_mesh.png"/>
</p>
<p>Submesh</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_01_normal_normal5.jpg"/>
</p>
<p>Normals x5</p>
</div>
</div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_splatmap_combine.jpg"/>
</p>
<p>Splatmaps</p>
</div>
</td>
<td>
<img src="http://www.adriancourreges.com/img/arrow-right.png"/>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_01_terrain_normal.jpg"/>
</p>
<p>Normal Map</p>
</div>
</td>
</tr>
</tbody></table>

<p>This is done in a single draw call with 6 texture fetches.
You’ll notice the result is quite “yellowish”, it contrasts with the other normal maps which tend to be blue. And indeed: here the Blue channel is not used at all, only the Red and Green.</p>
<p>Stratums are done, now it’s the turn of the decals: terrain decals and building decals are added to modulate the stratum normals.</p>
<div id="b_normal_terrain_decal">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_01_terrain_normal.jpg"/>
</p>
<p>Base</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_02_terrain_decal.jpg"/>
</p>
<p>Base + Terrain Decals</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_03_terrain_build_decal.jpg"/>
</p>
<p>Base + Terrain Decals + Unit Decals</p>
</div>
</div>
</div>

<p>We still haven’t used the Blue and Alpha channels of our render target.</p>
<table>
<tbody><tr>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_04_terrain_whole_normal.jpg"/>
</p>
<p>Normal Map</p>
</div>
</td>
<td>
Bicubic interpolation stored in Blue and Alpha.
<img src="http://www.adriancourreges.com/img/arrow-right.png"/>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_04_terrain_normal_reconstruct.jpg"/>
</p>
<div><p>Red &amp; Green: Stratum/Decal Normals</p></div>
</div>
</td>
</tr>
</tbody></table>

<p>Then the game combines these two sets of normals (stratum/decal normals and terrain normals) into the final normals used to calculate the lighting.</p>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_05_terrain_normal_pp.jpg"/>
</p>
<p>Final Normal Map</p>
</div>
<p>This time there’s no compression: the normals use the 3 RGB channels, one for each component.</p>
<h3>Shadow Map</h3>
<p>The technique used to render the shadows is the <a href="http://www.cg.tuwien.ac.at/research/vr/lispsm/">“Light Space Perspective Shadow Maps”</a> or LiSPSM technique. </p>


<p>If we stop here, we would just be able to draw hard shadows. When the units are rendered, the game actually tries to smooth-out the edges of the shadows
by using some <abbr title="Percentage Closer Filtering">PCF</abbr> sampling.</p>
<p>But even with PCF, there would be no way to obtain the beautiful smooth-shadows we see on the screenshot, especially the smooth silhouettes of the buildings on the ground…
So how was this achieved?</p>
<p>Even during the final parts of the development process of the game, it seems the implementation of shadows was still an on-going effort.
This is what Jonathan Mavor was saying 11 months before the game public release:</p>
<blockquote><p>The shadows in those shots are not finished and we do have a little bit of work to do on them yet. […] </p></blockquote>
<p>Just one month after this declaration, a new ground-breaking shadow map technique was emerging: <a href="https://web.archive.org/web/20201124200859/http://www.punkuser.net/vsm/">Variance Shadow Maps</a> or VSM. It was able to render
gorgeous soft shadows very efficiently. </p>
<table>
<tbody><tr>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_06_sm_5_100.png"/>
</p>
<p>LiSPSM</p>
</div>
</td>
<td>
Gaussian Blur
<img src="http://www.adriancourreges.com/img/arrow-right.png"/>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_06_sm_9_blur.png"/>
</p>
<p>Blurred Shadow Map</p>
</div>
</td>
</tr>
</tbody></table>

<p>However in the D3D bytecode, there is no instruction about storing the depth and the squared-depth (information required by the VSM technique).
It seems to be only a partial implementation: maybe there was no time to perfect the technique during the final stages of the development, but anyway the code as-is can
already produce nice results.</p>
<p>Note though that the pseudo-VSM map is used only to produce soft-shadows on the ground.</p>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_06_sm_91_blur_pcflispsm.jpg"/>
</p>
<p>Different Shadow Map Techniques</p>
</div>
<h3>Shadowed Terrain</h3>
<p>Thanks to the normal map and the shadow map that were generated, it is possible to finally start rendering the terrain: a textured mesh with lighting and shadows.</p>
<table>
<tbody><tr>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_splatmap_combine.jpg"/>
</p>
<p>SplatMaps</p>
</div>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_water_depth.jpg"/>
</p>

</div>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_07_albedo5.jpg"/>
</p>

</div>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_06_sm_9_blur.png"/>
</p>
<p>Shadow</p>
</div>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_05_terrain_normal_pp.jpg"/>
</p>
<p>Normal</p>
</div>
</td>
</tr>
</tbody></table>
<p><img src="http://www.adriancourreges.com/img/arrow-down.png"/></p>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_07_combine.jpg"/>
</p>
<p>Lighting and Shadow</p>
</div>
<h3>Decals</h3>
<p>The albedo components of the decals are drawn, using the normal information to calculate the lighting equation.</p>
<div id="b_albedo_decals">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_07_combine.jpg"/>
</p>
<p>Base</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_08_albedo_decal_terrain.jpg"/>
</p>
<p>Base + Terrain Decals</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_08_albedo_decal_unit.jpg"/>
</p>
<p>Base + Terrain Decals + Unit Decals</p>
</div>
</div>
</div>

<h3>Water Reflection</h3>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_09_reflection_expl.png"/></p>
<p>We have the sea on the right of our scene, so if a robot is sitting in the middle of the water we should be able to see its reflection on the sea surface.</p>
<p>A classic trick exists to render the reflection of a surface: an additional pass is performed, and just before applying the camera transformation, the vertical axis is scaled by -1 so
the entire scene becomes symmetric with regards to the water surface (just like a mirror) which is exactly the transformation needed to render the reflection.
SupCom uses this technique and renders all the mirrored unit meshes into a reflection map.</p>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_09_reflection_map_pp.jpg"/>
</p>
<p>Reflection Map</p>
</div>
<h3>Mesh Rendering</h3>
<p>All the units are then rendered one by one.
For the vegetation, <a href="https://en.wikipedia.org/wiki/Geometry_instancing">geometry instancing</a> is used to render multiple trees in one draw call.
The sea is rendered using a single quad, with a pixel shader fetching several normal maps, a refraction map (the scene rendered up until now), a
reflection map (just generated above) and a skybox for additional reflection.</p>
<div id="b_all_meshes">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_08_albedo_decal_unit.jpg"/>
</p>
<p>Meshes 0%</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_10_1_meshes.jpg"/>
</p>
<p>Meshes 30%</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_10_2_meshes.jpg"/>
</p>
<p>Meshes 60%</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_10_9_meshes.jpg"/>
</p>
<p>Meshes 100%</p>
</div>
</div>
</div>

<p>Notice in the last image the small black artifacts of the sea near the screen border: it’s because the sampling of the surface of the water is disrupted to create an illusion of movement.
Sometimes the disruption brings texels from outside the viewport within the viewport: but such information does not exist, hence the black areas.</p>
<h3>Mesh Structure</h3>
<p>Each unit in SupCom is rendered in a single draw call. A model is defined by a set of textures:</p>
<ul>
<li>an albedo map</li>
<li>a normal map</li>
<li>a “specular map” which actually contains much more information than the specular. It’s an RGBA texture with:
<ul>
<li>Red: Reflection. How much the environment map is reflected.</li>
<li>Green: Specular. In regards to the sun light.</li>
<li>Blue: Brightness. Used later to control the bloom.</li>
<li>Alpha: Team Color. It modulates the unit albedo depending on the team color.</li>
</ul>
</li>
</ul>


<p><img src="http://www.adriancourreges.com/img/arrow-down.png"/></p>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_10_99_final.jpg"/></p>
<h3>Particles</h3>
<p>All the particles are then rendered and the health bars of each unit are also added.</p>
<div id="b_11_particles">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_10_9_meshes.jpg"/>
</p>
<p>Base Scene</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_11_particles.jpg"/>
</p>
<p>Base Scene + Particles</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_12_miniui.jpg"/>
</p>
<p>Base Scene + Particles + Health Bars</p>
</div>
</div>
</div>

<h3>Bloom</h3>
<p>Time to make things shine! But how do we get the “brightness information” since we’re working with <abbr title="Low Dynamic Range">LDR</abbr> buffers?</p>
<table>
<tbody><tr>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_14_bloom_alpha.png"/>
</p>
<p>Alpha Channel</p>
</div>
</td>
<td>
<img src="http://www.adriancourreges.com/img/arrow-right.png"/>
</td>
<td>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_14_bloom_blurred.jpg"/>
</p>
<p>Brightness Blurred</p>
</div>
</td>
</tr>
</tbody></table>

<p>The blurred buffer is then drawn on the top of the original scene with additive blending.</p>
<div id="b_15_bloom">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_12_miniui.jpg"/>
</p>
<p>Bloom: Before</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_15_bloom.jpg"/>
</p>
<p>Bloom: After</p>
</div>
</div>
</div>

<h3>User Interface</h3>
<p>We’re done concerning the main scene. The UI is finally rendered, and it is beautifully optimized: a <em>single draw call</em> to render the entire interface.
1158 triangles are pushed at once to the GPU.</p>
<div id="b_96_wireframe">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_95_final_frame.jpg"/>
</p>
<p>UI</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/b_96_wireframe.jpg"/>
</p>
<p>UI (Wireframe Highlight)</p>
</div>
</div>
</div>

<p>The pixel shader reads from a single 1024x1024 texture which acts like a <a href="https://en.wikipedia.org/wiki/Texture_atlas">texture atlas</a>. When another unit is selected, the UI is modified,
the texture atlas is regenerated on-the-fly to pack a new set of sprites.</p>
<p>And we’re done for the frame!</p>

<h3>Level of Detail</h3>
<p>Since SupCom supports huge variations in the zoom level, it relies heavily on <a href="https://en.wikipedia.org/wiki/Level_of_detail">level of detail</a> or LOD. </p>
<div id="c_lod">
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/c_01_hp_full.jpg"/>
</p>
<p>LOD High</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/c_01_lp_full.jpg"/>
</p>
<p>LOD Low</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/c_01_lp_wire.jpg"/>
</p>
<p>LOD Low - Wireframe</p>
</div>
</div>
<div>
<div>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/c_01_hp_wire.jpg"/>
</p>
<p>LOD High - Wireframe</p>
</div>
</div>
</div>

<p>LOD does not only concern units: shadows, decals and props stop being rendered beyond a certain distance.</p>
<h3>Fog of War</h3>
<p>Because of the <a href="https://en.wikipedia.org/wiki/Fog_of_war">fog of war</a>, each unit has a line of sight and only the area close to the units is completely visible.
Areas where no units are present are either gray (previously visited) or black (still unexplored).</p>


<h3><a name="supcomNormalExpl"></a>Normal Compression</h3>
<p><a href="#supcomNormalSkip">As promised</a>, here is a short explanation about the trick used in SupCom to compress normals. </p>
<p><img src="http://www.adriancourreges.com/img/blog/2015/supcom/shot/a_stratum_normal_0.jpg"/></p>
<p>So assuming the normal is a unit-vector, its length is one: <code>X² + Y² + Z² = 1</code>.</p>
<h3>Normal Blending</h3>
<p>Since we are talking about normals, SupCom performs some kind of <a href="https://en.wikipedia.org/wiki/Linear_interpolation">lerp</a> between normal maps, using the splatmaps as factors.
Actually there are several ways of blending two normal maps, with different results, it is not a straightforward problem like <a href="http://blog.selfshadow.com/publications/blending-in-detail/">this article</a> explains.</p>

<ul>
<li>The <a href="https://mavorsrants.blogspot.com/">blog of Jonathan Mavor</a> has a lot of technical insights and a very nice post about the <a href="https://mavorsrants.blogspot.com/2012/04/total-annihilation-graphics-engine.html">TA Graphics Engine</a>.</li>
<li>The <a href="http://web.archive.org/web/20070807085133/http://www.gamespot.com/features/totalstory/">story behind TA development</a>. Very interesting read from 1998, archived on the Wayback Machine.</li>
<li>Details about <a href="http://supcom.wikia.com/wiki/Height-_/_Texturemaps_with_image_editing_tools">SupCom map editing</a> and modding.</li>
</ul>
<p>More discussion on this very topic: <a href="http://developers.slashdot.org/story/15/06/26/1550227/reverse-engineering-a-frame-of-supreme-commander">Slashdot</a>,
<a href="https://news.ycombinator.com/item?id=9770020">Hacker News</a>,
<a href="https://www.reddit.com/r/programming/comments/3axbnb/supreme_commander_graphics_study_how_it_renders_a/">Reddit</a>.</p>
</div></div>
  </body>
</html>
