<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/David-OConnor/lin-alg">Original</a>
    <h1>Show HN: Rust Vector and Quaternion Lib</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://crates.io/crates/lin_alg" rel="nofollow"><img src="https://camo.githubusercontent.com/42a6cca8d5fab039eac8ee40bc93a0c9fb478adc50ad0daa9d9cdf9d9bd9ec74/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f6c696e5f616c672e737667" alt="Crate" data-canonical-src="https://img.shields.io/crates/v/lin_alg.svg"/></a>
<a href="https://docs.rs/lin_alg" rel="nofollow"><img src="https://camo.githubusercontent.com/fbd50da1227d5df2b6bcaa215a6bb4cac4348fa97c4c8ec07aaefd8c18e6b933/68747470733a2f2f646f63732e72732f6c696e5f616c672f62616467652e737667" alt="Docs" data-canonical-src="https://docs.rs/lin_alg/badge.svg"/></a></p>
<p dir="auto">Vector, matrix, and quaternion data structures and operations. Uses f32 or f64 based types.</p>
<p dir="auto">Example use cases:</p>
<ul dir="auto">
<li>Computer graphics</li>
<li>Biomechanics</li>
<li>Robotics and unmanned aerial vehicles.</li>
<li>Structural chemistry and biochemistry</li>
<li>Cosmology modeling</li>
<li>Various scientific and engineering applications</li>
<li>Aircraft attitude systems and autopilots</li>
</ul>
<p dir="auto">Vector and Quaternion types are <em>copy</em>.</p>
<p dir="auto">For Compatibility with no_std targets, e.g. embedded, disable default features, and enable the <code>no_std</code> feature. This  omits
<code>std::fmt::Display</code> implementations, and enables <a href="https://docs.rs/num-traits/latest/num_traits/" rel="nofollow">num_traits</a>&#39;s <code>libm</code> capabilities
for certain operations. <code>lin_alg = { version = &#34;^1.0.8&#34;, default-features = false, features = [&#34;no_std&#34;] }</code></p>
<p dir="auto">For computer-graphics functionality (e.g. specialty matrix constructors, and [de]serialization to byte arrays for passing to and from GPUs), use the <code>computer_graphics</code>
feature. For <a href="https://docs.rs/bincode/latest/bincode/" rel="nofollow">bincode</a> binary encoding and decoding, use the <code>encode</code> feature.</p>
<p dir="auto">For information on practical quaternion operations: <a href="https://www.anyleaf.org/blog/quaternions:-a-practical-guide" rel="nofollow">Quaternions: A practical guide</a>.</p>
<p dir="auto">The <code>From</code> trait is implemented for most types, for converting between <code>f32</code> and <code>f64</code> variants using the <code>into()</code> syntax.</p>
<p dir="auto">See the official documentation (Linked above) for details. Below is a brief, impractical syntax overview:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use core::f32::consts::TAU;

use lin_alg::f32::{Vec3, Quaternion};

fn main() {
    let _ = Vec3::new_zero();
    
    let a = Vec3::new(1., 1., 1.);
    let b = Vec3::new(0., -1., 10.);
    
    let mut c = a + b;
    
    let d = a.dot(b);
    
    c.normalize(); // or:
    let e = c.to_normalized();
    
    let f = a.cross(b);
    
    let g = Quaternion::from_unit_vecs(d, e);
    
    let h = g.inverse();
    
    let k = Quaternion::new_identity();
    
    let l = k.rotate_vec(c);
    
    l.magnitude();
    
    let m = Quaternion::from_axis_angle(Vec3::new(1., 0., 0.), TAU / 16.);
}
"><pre><span>use</span> core<span>::</span>f32<span>::</span>consts<span>::</span><span>TAU</span><span>;</span>

<span>use</span> lin_alg<span>::</span>f32<span>::</span><span>{</span><span>Vec3</span><span>,</span> <span>Quaternion</span><span>}</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> _ = <span>Vec3</span><span>::</span><span>new_zero</span><span>(</span><span>)</span><span>;</span>
    
    <span>let</span> a = <span>Vec3</span><span>::</span><span>new</span><span>(</span><span>1.</span><span>,</span> <span>1.</span><span>,</span> <span>1.</span><span>)</span><span>;</span>
    <span>let</span> b = <span>Vec3</span><span>::</span><span>new</span><span>(</span><span>0.</span><span>,</span> -<span>1.</span><span>,</span> <span>10.</span><span>)</span><span>;</span>
    
    <span>let</span> <span>mut</span> c = a + b<span>;</span>
    
    <span>let</span> d = a<span>.</span><span>dot</span><span>(</span>b<span>)</span><span>;</span>
    
    c<span>.</span><span>normalize</span><span>(</span><span>)</span><span>;</span> <span>// or:</span>
    <span>let</span> e = c<span>.</span><span>to_normalized</span><span>(</span><span>)</span><span>;</span>
    
    <span>let</span> f = a<span>.</span><span>cross</span><span>(</span>b<span>)</span><span>;</span>
    
    <span>let</span> g = <span>Quaternion</span><span>::</span><span>from_unit_vecs</span><span>(</span>d<span>,</span> e<span>)</span><span>;</span>
    
    <span>let</span> h = g<span>.</span><span>inverse</span><span>(</span><span>)</span><span>;</span>
    
    <span>let</span> k = <span>Quaternion</span><span>::</span><span>new_identity</span><span>(</span><span>)</span><span>;</span>
    
    <span>let</span> l = k<span>.</span><span>rotate_vec</span><span>(</span>c<span>)</span><span>;</span>
    
    l<span>.</span><span>magnitude</span><span>(</span><span>)</span><span>;</span>
    
    <span>let</span> m = <span>Quaternion</span><span>::</span><span>from_axis_angle</span><span>(</span><span>Vec3</span><span>::</span><span>new</span><span>(</span><span>1.</span><span>,</span> <span>0.</span><span>,</span> <span>0.</span><span>)</span><span>,</span> <span>TAU</span> / <span>16.</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">If using for computer graphics, this functionality may be helpful:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    let a = Vec3::new(1., 1., 1.);
    let bytes = a.to_bytes(); // Send this to the GPU. `Quaternion` and `MatN` have similar methods.

    let model_mat = Mat4::new_translation(self.position)
        * self.orientation.to_matrix()
        * Mat4::new_scaler_partial(self.scale);

    let proj_mat = Mat4::new_perspective_lh(self.fov_y, self.aspect, self.near, self.far);

    let view_mat = self.orientation.inverse().to_matrix() * Mat4::new_translation(-self.position);

    // Example of rolling a camera around the forward axis:
    let fwd = orientation.rotate_vec(FWD_VEC);
    let rotation = Quaternion::from_axis_angle(fwd, -rotate_key_amt);
    orientation = rotation * orientation;"><pre>    <span>let</span> a = <span>Vec3</span><span>::</span><span>new</span><span>(</span><span>1.</span><span>,</span> <span>1.</span><span>,</span> <span>1.</span><span>)</span><span>;</span>
    <span>let</span> bytes = a<span>.</span><span>to_bytes</span><span>(</span><span>)</span><span>;</span> <span>// Send this to the GPU. `Quaternion` and `MatN` have similar methods.</span>

    <span>let</span> model_mat = <span>Mat4</span><span>::</span><span>new_translation</span><span>(</span><span>self</span><span>.</span><span>position</span><span>)</span>
        <span>*</span> <span>self</span><span>.</span><span>orientation</span><span>.</span><span>to_matrix</span><span>(</span><span>)</span>
        <span>*</span> <span>Mat4</span><span>::</span><span>new_scaler_partial</span><span>(</span><span>self</span><span>.</span><span>scale</span><span>)</span><span>;</span>

    <span>let</span> proj_mat = <span>Mat4</span><span>::</span><span>new_perspective_lh</span><span>(</span><span>self</span><span>.</span><span>fov_y</span><span>,</span> <span>self</span><span>.</span><span>aspect</span><span>,</span> <span>self</span><span>.</span><span>near</span><span>,</span> <span>self</span><span>.</span><span>far</span><span>)</span><span>;</span>

    <span>let</span> view_mat = <span>self</span><span>.</span><span>orientation</span><span>.</span><span>inverse</span><span>(</span><span>)</span><span>.</span><span>to_matrix</span><span>(</span><span>)</span> <span>*</span> <span>Mat4</span><span>::</span><span>new_translation</span><span>(</span>-<span>self</span><span>.</span><span>position</span><span>)</span><span>;</span>

    <span>// Example of rolling a camera around the forward axis:</span>
    <span>let</span> fwd = orientation<span>.</span><span>rotate_vec</span><span>(</span><span>FWD_VEC</span><span>)</span><span>;</span>
    <span>let</span> rotation = <span>Quaternion</span><span>::</span><span>from_axis_angle</span><span>(</span>fwd<span>,</span> -rotate_key_amt<span>)</span><span>;</span>
    orientation = rotation <span>*</span> orientation<span>;</span></pre></div>
<p dir="auto">A practical geometry example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="/// Calculate the dihedral angle between 4 positions (3 bonds).
/// The `bonds` are one atom&#39;s position, substracted from the next. Order matters.
pub fn calc_dihedral_angle(bond_middle: Vec3, bond_adjacent1: Vec3, bond_adjacent2: Vec3) -&gt; f64 {
    // Project the next and previous bonds onto the plane that has this bond as its normal.
    // Re-normalize after projecting.
    let bond1_on_plane = bond_adjacent1.project_to_plane(bond_middle).to_normalized();
    let bond2_on_plane = bond_adjacent2.project_to_plane(bond_middle).to_normalized();

    // Not sure why we need to offset by 𝜏/2 here, but it seems to be the case
    let result = bond1_on_plane.dot(bond2_on_plane).acos() + TAU / 2.;

    // The dot product approach to angles between vectors only covers half of possible
    // rotations; use a determinant of the 3 vectors as matrix columns to determine if what we
    // need to modify is on the second half.
    let det = det_from_cols(bond1_on_plane, bond2_on_plane, bond_middle);

    if det &lt; 0. { result } else { TAU - result }
}"><pre><span>/// Calculate the dihedral angle between 4 positions (3 bonds).</span>
<span></span><span>/// The `bonds` are one atom&#39;s position, substracted from the next. Order matters.</span>
<span></span><span>pub</span> <span>fn</span> <span>calc_dihedral_angle</span><span>(</span><span>bond_middle</span><span>:</span> <span>Vec3</span><span>,</span> <span>bond_adjacent1</span><span>:</span> <span>Vec3</span><span>,</span> <span>bond_adjacent2</span><span>:</span> <span>Vec3</span><span>)</span> -&gt; <span>f64</span> <span>{</span>
    <span>// Project the next and previous bonds onto the plane that has this bond as its normal.</span>
    <span>// Re-normalize after projecting.</span>
    <span>let</span> bond1_on_plane = bond_adjacent1<span>.</span><span>project_to_plane</span><span>(</span>bond_middle<span>)</span><span>.</span><span>to_normalized</span><span>(</span><span>)</span><span>;</span>
    <span>let</span> bond2_on_plane = bond_adjacent2<span>.</span><span>project_to_plane</span><span>(</span>bond_middle<span>)</span><span>.</span><span>to_normalized</span><span>(</span><span>)</span><span>;</span>

    <span>// Not sure why we need to offset by 𝜏/2 here, but it seems to be the case</span>
    <span>let</span> result = bond1_on_plane<span>.</span><span>dot</span><span>(</span>bond2_on_plane<span>)</span><span>.</span><span>acos</span><span>(</span><span>)</span> + <span>TAU</span> / <span>2.</span><span>;</span>

    <span>// The dot product approach to angles between vectors only covers half of possible</span>
    <span>// rotations; use a determinant of the 3 vectors as matrix columns to determine if what we</span>
    <span>// need to modify is on the second half.</span>
    <span>let</span> det = <span>det_from_cols</span><span>(</span>bond1_on_plane<span>,</span> bond2_on_plane<span>,</span> bond_middle<span>)</span><span>;</span>

    <span>if</span> det &lt; <span>0.</span> <span>{</span> result <span>}</span> <span>else</span> <span>{</span> <span>TAU</span> - result <span>}</span>
<span>}</span></pre></div>
</article></div></div>
  </body>
</html>
