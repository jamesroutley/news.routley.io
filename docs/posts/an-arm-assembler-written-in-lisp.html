<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://forum.ulisp.com/t/an-arm-assembler-written-in-lisp/1237">Original</a>
    <h1>An ARM Assembler Written in Lisp</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>You can write machine-code functions in uLisp with the help of the ARM assembler written in Lisp, and I’ve recently updated it to make it more compact. It will now fit on a board with about 2000 objects of workspace, with room to spare to write assembler programs and run them.</p>
<p>This post describes how the latest version of the ARM assembler works. The aim is to help anyone who wants to extend the assembler to cater for ARM instructions that it doesn’t currently support. It will also be helpful if you want to write an assembler for another processor, or even design your own processor and write an assembler for it; Lisp is an excellent language to do this. For example, a printout of the whole ARM assembler fits on two A4 pages.</p>
<h3>Instruction encodings</h3>
<p>The starting point for writing an assembler is to get hold of a summary of the processor’s table of instruction encodings. For the ARM Thumb instruction set these are as follows:</p>

<p><em>ARM Thumb instruction encodings for instructions starting <span>#x0</span> to <span>#x8</span>.</em></p>

<p><em>ARM Thumb instruction encodings for instructions starting <span>#x9</span> to <span>#xF</span>.</em></p>
<p>You can see from these diagrams that the 16-bit instructions are arranged into consistent field patterns. This is true of most processor instruction sets, but some are more orderly than others (RISC-V is a nightmare!).</p>
<h4>An example - LSL</h4>
<p>As an example, consider the first instruction in the first table, LSL immediate:</p>

<p>This consists of:</p>
<ul>
<li>The four-bit value <span>#b0000</span>.</li>
<li>A one-bit <em>op</em> code, which is 0 for LSL and 1 for LSR.</li>
<li>An <em>immed5</em> value, which is a 5-bit integer from 0 to 31 giving the size of the left shift.</li>
<li>
<em>Lm</em>, which is a value from 0 to 7 representing the source register R0 to R7.</li>
<li>
<em>Ld</em>, which is a value from 0 to 7 representing the destination register R0 to R7.</li>
</ul>
<h3>Emitting bit fields</h3>
<p>The first function we need is <strong>emit</strong>, which takes a specification defining the widths of the bit fields, and a list of arguments, and packs the values of the arguments into the bit fields:</p>
<pre><code>(defun emit (bits &amp;rest args)
  (let ((word 0) (shift -28))
    (mapc #&#39;(lambda (value)
              (let ((width (logand (ash bits shift) #xf)))
                (incf shift 4)
                (unless (zerop (ash value (- width))) (error &#34;Won&#39;t fit&#34;))
                (setq word (logior (ash word width) value))))
          args)
    word))
</code></pre>
<p>The first argument, <strong>bits</strong>, is a 32-bit hexadecimal number in which each hex digit specifies the width of the next bit field. The function <strong>emit</strong> reads the hex digits in <strong>bits</strong> from left to right, packs the appropriate number of bits from each argument into <strong>word</strong>, and then returns the result.</p>
<p>For example, the bit fields for the LSL instruction could be specified by:</p>
<pre><code>#x41533000
</code></pre>
<p>To make it easier to process the bit fields the widths are left-aligned, so you should add zeros to make the <strong>bits</strong> parameter eight hex digits.</p>
<p>The remaining arguments are the values to be packed into the bit fields. If any argument won’t fit into the corresponding bit field the error <strong>Won’t fit</strong> will be displayed.</p>
<p>So for example, to emit the op code for the instruction:</p>
<pre><code>LSL r7, r4, #31
</code></pre>
<p>evaluate:</p>
<pre><code>&gt; (emit #x41533000 0 0 31 4 7)
2023
</code></pre>
<p>If you print this as a 16-bit binary number with:</p>
<pre><code>&gt; (format t &#34;~16,&#39;0b&#34; 2023)
0000011111100111
</code></pre>
<p>you can see that the values have been put into the correct fields as required.</p>
<h3>Specifying registers</h3>
<p>The next step is to be able to specify registers as r0 to r15, or their synonyms <strong>sp</strong> (for r13), <strong>lr</strong> (for r14), and <strong>pc</strong> (for r15). This is handled by the function <strong>regno</strong>:</p>
<pre><code>(defun regno (sym)
  (case sym (sp 13) (lr 14) (pc 15)
    (t (read-from-string (subseq (string sym) 1)))))
</code></pre>
<p>For example:</p>
<pre><code>&gt; (regno &#39;r12)
12
</code></pre>
<p>Finally, we can now define the LSL instruction as the convenient Lisp function <strong>$lsl</strong> as follows:</p>
<pre><code>(defun $lsl (argd argm immed5)
  (emit #x41533000 0 0 immed5 (regno argm) (regno argd))
</code></pre>
<p>This allows us to specify the instruction using syntax that’s close to ARM assembler syntax:</p>
<pre><code>&gt; ($lsl &#39;r7 &#39;r4 31)
2023
</code></pre>
<p>I’ve used the convention that functions representing ARM instructions are prefixed by a $ sign; otherwise there would be a problem with instructions that are also existing Lisp functions, such as <strong>push</strong> and <strong>pop</strong>.</p>
<h3>Handling addressing modes</h3>
<p>The final complication is that some instruction mnemonics can generate different op codes, depending on the types of their arguments.</p>
<p>For example, there’s also a variant of LSL that shifts a register Rd by the shift value specified in the register Rs:</p>

<p>Using this syntax, the following assembler instruction shifts the value in R7 by the value in R1:</p>
<pre><code>LSL r7, r1
</code></pre>
<p>The block of register-to-register instructions that include LSL is handled by the routine <strong>reg-reg</strong>:</p>
<pre><code>(defun reg-reg (op argd argm)
  (emit #xa3300000 op (regno argm) (regno argd)))
</code></pre>
<p>Finally, we need to modify <strong>$lsl</strong> to include the register-to-register variant:</p>
<pre><code>(defun $lsl (argd argm &amp;optional arg2)
  (cond
   ((numberp arg2)
    (lsl-lsr-0 0 arg2 argm argd))
   ((numberp argm)
    (lsl-lsr-0 0 argm argd argd))
   (t
    (reg-reg #b0100000010 argd argm))))
</code></pre>
<p>where <strong>lsl-lsr-0</strong> is defined as:</p>
<pre><code>(defun lsl-lsr-0 (op immed5 argm argd)
  (emit #x41533000 0 op immed5 (regno argm) (regno argd)))
</code></pre>
<p>This expanded version of <strong>$lsl</strong> also handles the two-argument case where the source and destination registers are the same in an immediate shift; for example:</p>
<pre><code>($lsl &#39;r1 31)
</code></pre>
<h3>Running the assembler</h3>
<p>To run the assembler in uLisp you use the built-in command <strong>defcode</strong>, which generates an assembler listing, and puts the machine code into RAM so you can execute it as if it’s a normal Lisp function.</p>
<h4>Greatest Common Divisor example</h4>
<p>For example, to assemble a machine-code routine <strong>gcd</strong> to calculate Greatest Common Divisor you’d evaluate:</p>
<pre><code>; Greatest Common Divisor
(defcode gcd (x y)
  swap
  ($mov &#39;r2 &#39;r1)
  ($mov &#39;r1 &#39;r0)
  again
  ($mov &#39;r0 &#39;r2)
  ($sub &#39;r2 &#39;r2 &#39;r1)
  ($blt swap)
  ($bne again)
  ($bx &#39;lr))
</code></pre>
<p>and you could then call:</p>
<pre><code>&gt; (gcd 3287 3460)
173
</code></pre>
<h3>Running the assembler in Common Lisp</h3>
<p>You can also run the ARM assembler in a standard Common Lisp implementation. The Common Lisp version of the ARM Assembler includes the following <strong>defcode</strong> macro that lets you assemble an ARM function and print the machine code, like the <strong>defcode</strong> special form built into uLisp:</p>
<pre><code>(defparameter *pc* 0)

(defmacro defcode (&amp;body body)
  (let ((*print-pretty* t) (assembler (cddr body)))
    (dotimes (pass 2)
      (setq *pc* 0)
      (mapc
       #&#39;(lambda (ins)
           (cond
            ((atom ins)
             (unless (zerop pass) (format t &#34;~4,&#39;0x      ~(~a~)~%&#34; *pc* ins))
             (set ins *pc*))
            ((listp (eval ins))
             (unless (zerop pass)
               (format t &#34;~4,&#39;0x ~4,&#39;0x ~(~a~)~%&#34; *pc* (first (eval ins)) ins)
               (format t &#34;~4,&#39;0x ~4,&#39;0x~%&#34; (+ *pc* 2) (second (eval ins))))
             (incf *pc* 4))
            (t
             (unless (zerop pass)
               (format t &#34;~4,&#39;0x ~4,&#39;0x ~(~a~)~%&#34; *pc* (eval ins) ins))
             (incf *pc* 2))))
       assembler)
      nil)))
</code></pre>
<p>Evaluating the <strong>Greatest Common Divisor example</strong> above generates the following output:</p>
<pre><code>0000      swap
0000 000A ($mov &#39;r2 &#39;r1)
0002 0001 ($mov &#39;r1 &#39;r0)
0004      again
0004 0010 ($mov &#39;r0 &#39;r2)
0006 1A52 ($sub &#39;r2 &#39;r2 &#39;r1)
0008 DBFA ($blt swap)
000A D1FB ($bne again)
000C 4770 ($bx &#39;lr)
</code></pre>
<p>In this case you obviously won’t be able to run the machine code.</p>
<h3>Resources</h3>
<p>For both versions of the assembler see: <a href="https://github.com/technoblogy/lisp-arm-assembler">https://github.com/technoblogy/lisp-arm-assembler</a>.</p>
<p>For more information see <a href="http://www.ulisp.com/show?2YRU">ARM assembler overview</a>.</p>
<p>For a list of the ARM Thumb instructions supported by the assembler see: <a href="http://www.ulisp.com/show?30B8">ARM assembler instructions</a>.</p>
<p>For ARM assembler examples see: <a href="http://www.ulisp.com/show?30BD">ARM assembler examples</a>.</p>
<h3>Update</h3>
<p>6th July 2023: Updated the <strong>defcode</strong> macro to handle forward references.</p>
      </div></div>
  </body>
</html>
