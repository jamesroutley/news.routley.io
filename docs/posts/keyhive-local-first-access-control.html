<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.inkandswitch.com/keyhive/notebook/">Original</a>
    <h1>Keyhive ‚Äì Local-first access control</h1>
    
    <div id="readability-page-1" class="page">

  <header>
    
    <h2>Local-first access control</h2>

    

    <div>
<p>üêù</p>
<p>Keyhive is a project exploring local-first access control. It aims to provide a firm basis for secure collaboration, similar to the guarantees of private chat but for any local-first application.</p>
<p>In this lab notebook, we‚Äôll share snippets of our findings as we explore the problem space and prototype potential solutions.</p>
<p>The entries start from the beginning, but you can jump to the most recent post: <a href="https://macwright.com/keyhive/notebook/05/">05 ¬∑ Syncing Keyhive</a></p>
    </div>
  </header>

<article>
  <h2><a href="https://macwright.com/keyhive/notebook/00/">00 ¬∑ Keyhive Background</a></h2>
  <p>2024 Aug 1</p>
<p>As the <a href="https://www.inkandswitch.com/local-first/">local-first</a> ecosystem matures, the contexts that local-first applications fill has also expanded. Local-first emphasizes collaboration, but the constraints on an application are different if you build an application for you and a handful of friends versus delivering a team-oriented product. Your data not being viewable or editable by everyone in the world is a basic requirement of applications ranging from planning a surprise party, corporate meeting notes, book drafts, and legal contracts.</p>
<p>Today‚Äôs most common access control patterns assume a central server. While cloud auth tools are forever developing, generally speaking existing tools for cloud auth are very mature. Doing access control without a cloud auth server requires rethinking the underlying mechanics of how auth works. Keyhive is an attempt to do secure and efficient local-first auth while retaining the user experience found in familiar applications like Google Docs, Dropbox, GitHub, and Discord. We believe that these are table stakes for the next generation of local-first applications.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/00/github-rbac.png" alt="GitHub Repo Membership Page"/>
<figcaption>
<p>A GitHub repository permissions page</p>
</figcaption>
</figure>
<p>We‚Äôve seen user-agency principals successfully applied to other contexts. <a href="https://signal.org/">Signal</a> popularized end-to-end encrypted chat while retaining much of the convenience of less-secure messaging applications. We find ourselves asking ‚Äúwhat would Signal for documents look like?‚Äù</p>

<p>Unlike a cloud auth system which can depend on the network to keep data hidden behind a web API, local-first runs a complete copy of the application at each replica. What are the correct bounds on access control when everyone has direct access to all of the content? Ultimately access control is about collaboration. Collaboration and access control can be seen as two sides of the same topic: who do you want to collaborate with, in which ways, and for how long?</p>
<p>CRDTs try to merge data in the least surprising way possible. For example, concurrent text will merge to produce the same data on all replicas, but the resulting paragraphs may not make sense next to each other. Users then fix these semantic errors manually. We believe that this is a major improvement over the user experience of something like Git, which often gets stuck and demands user intervention.</p>
<p>The equivalent situation exists for concurrent access control, but the stakes are higher. Preventing your friend from learning that you‚Äôre planning a surprise party, or opposing legal councel from altering your case prep are both important, and it should be clear how they will behave despite any underlying concurrency. The behavior of an access control system should be as clear to the end user as possible. Since there is no single source of truth about who can do what at any given time, the rules themselves need to be straightforward.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/00/history.png" alt="Ranges of authorization over time"/>
<figcaption>
<p>Ranges of authorization (and revocation) over time. Here üôã‚Äç‚ôÄÔ∏è is added, removed, and re-added later. Some of üôã‚Äç‚ôÄÔ∏è‚Äôs updates are not materialized based on where they‚Äôre ordered in the document history.</p>
</figcaption>
</figure>

<p>Often local-first applications today depend on <a href="https://en.wikipedia.org/wiki/Security_through_obscurity">‚Äúsecurity through obscurity‚Äù</a>. For example, by default you can write into any <a href="https://automerge.org/">Automerge</a> document that you know the document ID for. This style is sometimes called ‚Äú<a href="http://erights.org/talks/thesis/markm-thesis.pdf">Swiss number</a>‚Äù or ‚Äú<a href="https://en.wikipedia.org/wiki/Rumpelstiltskin">Rumpelstiltskin</a>‚Äù security. It works as long as the document ID is only ever shared with people that you want to collaborate with, your security is all-or-nothing, and you never want to later remove someone from a document. If the document ID leaks (e.g. someone posts it to Bluesky), then the document is world-writable.</p>
<p>In lieu of a widely-adopted purely local-first access control system, some teams have tried leveraging existing auth methods by routing updates through a cloud auth server (e.g. <a href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> login and auth logic in a server). Others have opted to emphasize decentralized user agency by using a blockchain to store access control policies. Both of these approaches require a network connection in order to check if an update is valid, which is not local-first. Bringing access control features to a local-first context requires rethinking how authority flows between nodes.</p>
<p>What we want is a system that retains the best of the above: the self-certification of Rumpelstiltskin, the power of auth servers, and the user agency of decentralized solutions. Following the definition of local-first, applications should accept updates after arbitrarily long periods of disconnection. Extending that requirement to access control means the ability to revoke access or have finer grained control (e.g. read vs write) requires tracking who has authorization to do what, and at which point in the document‚Äôs history.</p>
<!-- Footnotes -->
<!-- External Links -->

</article>
<article>
  <h2><a href="https://macwright.com/keyhive/notebook/01/">01 ¬∑ Welcome to the Keyhive</a></h2>
  <p>2024 Sept 5</p>
<p>Today‚Äôs cloud services have very mature access control features. These systems depend on a key architectural detail: they are able to rely on encapsulation by taking advantage of the network boundary. Since data is not available to read or write directly by the client, a privileged guard process is able to apply arbitrary access control rules. This process retrieves and/or mutates data on behalf of clients.</p>
<p>This power unfortunately comes at a price: since auth is on the hot path of every request ‚Äî and generally depends on a central single-source-of-truth auth database ‚Äî authorization at scale often bottlenecks overall application performance. And yet, an attacker that is able to bypass the auth part of the request lifecycle has unmitigated access to arbitrarily read, change, or delete the application‚Äôs data. This is to say nothing of the complexity of building, deploying, and maintaining cloud architectures to get that network boundary in the first place!</p>
<p>For local-first software to be successful in many production contexts, it needs to provide similar features without relying on a central authorization server. The local-first setting does not have the luxury of a network boundary: access control must travel with the data itself and work without a central guard.</p>
<p>There are also some tricky edge cases due to causal consistency. What should happen to honest operations that causally depend on content that‚Äôs later discovered to be malicious? What is the best strategy to handle operations from an agent that was revoked concurrently, especially given that ‚Äúback-dating‚Äù operations is always possible. If a document has exactly two admins (and many non-admin users), what should happen if the admins concurrently revoke each other (for instance, one is malicious)?</p>

<p>To address the above challenges, we‚Äôve started work on Keyhive: a project focused on local-first access control. Our goal is to design and build a production ready instance of such a system which is general enough for most local-first applications.</p>
<h2 id="audience-and-application"><a href="#audience-and-application">Audience &amp; Application</a></h2>
<p>To date, the local-first ecosystem has primarily used a purely pull-based model where users manually decide which changes to accept. This approach is often sufficient for personal projects: each user can manually decide which peers to connect to and which changes should be applied. On the other hand, many production contexts have lower trust, require higher alignment, and are ideally low touch <em>enough</em> so that it‚Äôs not up to each person in a large organization to separately and manually infer who to trust. As a rough north star, we‚Äôre keeping the following use cases in mind:</p>
<ul>
<li>Publishing (publicly visible data with restricted edits, like a blog)</li>
<li>Planning a surprise party: small groups, low risk</li>
<li>Meeting notes: small-to-medium groups, low-to-medium risk</li>
<li>Corporate legal documents: medium-to-large groups, medium-to-high risk</li>
<li>Journalists &amp; activists: small-to-medium groups, high risk</li>
</ul>
<p>Cryptography has a reputation for being slow, especially if there‚Äôs crypto-heavy code running on low-powered devices. To have a performance margin that can cover a large range of practical use cases, Keyhive aims to run efficiently over at least ten-of-thousands of documents, millions of readers, thousands of writers, and hundreds of admins/superusers.</p>
<h3 id="antigoals"><a href="#antigoals">Antigoals</a></h3>
<p>Since authorization, authentication, and identity are often conflated, it is worth highlighting that Keyhive deliberately excludes user identity (i.e. the binding of a human identity to an application‚Äôs identifier like a public key). In our initial community consultations we found that there are many different identity mechanisms that developers downstream of Keyhive would like to use. As such, we‚Äôre designing the system to be <a href="https://en.wikipedia.org/wiki/Zooko&#39;s_triangle">decentralized and secure</a>, and leave name registration/discovery and user verification (e.g. email or social) to a future layer above Keyhive.</p>
<p>The following are left out of our design goals:</p>
<ul>
<li>Constraining downstream applications to use a small predefined set of policies or roles</li>
<li>Interactive protocols (since local-first must work under network partition)</li>
<li>Reliance on a central authority</li>
<li><a href="https://en.wikipedia.org/wiki/Cryptographic_agility">Cryptographic agility</a></li>
<li><a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards">FIPS</a> (or similar) compliance</li>
</ul>
<h2 id="layers"><a href="#layers">Layers</a></h2>
<p>Most client/server backends place data at the bottom, and compute over it. In that model, auth is just another kind of computation. Leaving access control to a central process is not possible in a local-first context. In our context, the auth layer must act as a foundation.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/stack-changes.png" alt="Comparing how authorization is layered in centralized and local-first applications"/>
</figure>
<p>Static authorization typically impacts the design of all other layers of a project. As an intuition, the storage layer will need to support data that is encrypted-at-rest, and so its design has a dependency on the auth layer. This means that since the design of an authorization mechanism may impose downstream constraints, its design should consider such potential impacts on the design of the rest of the stack. As much as possible, this project attempts to minimize imposing such constraints on other layers.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/block-diagram.png" alt="Dependency Stack"/>
</figure>
<p>Keyhive (as currently designed) carves out three layers to handle this:</p>
<ol>
<li><strong>Convergent Capabilities:</strong> A new <a href="https://en.wikipedia.org/wiki/Object-capability_model">capability</a> model appropriate for CRDTs, and sits between object- and certificate-capabilities</li>
<li><strong>A Group Management CRDT:</strong> Self-certifying, concurrent group management complete with coordination-free revocation</li>
<li><strong>E2EE with Causal Keys:</strong> With <a href="https://eprint.iacr.org/2016/221.pdf">post-compromise security (PCS)</a> and symmetric key management granting access to causal predessesors.</li>
</ol>
<p>These three have a strong dependency between each other. Capabilities enable use to manage groups, and groups let us share keys for E2EE. We will go into more detail on all three in future posts, but in the meantime here is a very high level treatment:</p>
<h3 id="convergent-capabilities"><a href="#convergent-capabilities">Convergent Capabilities</a></h3>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/granovetter.png"/>
<figcaption>
<h4>Granovetter Diagram</h4>
<p>A diagram showing Alice delegating to Bob her existing access to Carol</p>
</figcaption>
</figure>
<p>Capabilities and delegation form the basic access control mechanism that are known to be <a href="https://srl.cs.jhu.edu/pubs/SRL2003-02.pdf">very expressive</a>. In short: all Automerge documents get identified by a public key, and delegate control over themselves to other public keys. This provides stateless self-certification with a cryptographic proof. Public keys in the system can represent anything: other documents, users, groups, or anything else. This is a very low-level mechanism that can be used to model high level concepts like <a href="http://wiki.erights.org/wiki/Walnut/Secure_Distributed_Computing#Powerbox_Capability_Manager">powerboxes</a>, <a href="https://en.wikipedia.org/wiki/Role-based_access_control">roles</a>, device groups, and more with very little code, all while remaining extensible to new patterns.</p>
<p><a href="https://en.wikipedia.org/wiki/Object-capability_model">Object-capabilities</a> (AKA ‚Äúocap‚Äù) are ‚Äú<a href="https://en.wikipedia.org/wiki/Fail-stop">fail-stop</a>‚Äù, meaning that they intentionally stop working if there‚Äôs a network partition to <a href="https://en.wikipedia.org/wiki/PACELC_theorem">preserve consistency over availability</a>. Since local-first operates under partition (e.g. offline), parts of the classic object-capability design are not suitable. Certificate capabilities such as <a href="https://www.rfc-editor.org/rfc/rfc2693">SPKI/SDSI</a>, <a href="https://w3c-ccg.github.io/zcap-spec/">zcap-ld</a> and <a href="https://github.com/ucan-wg">UCAN</a> are partition-tolerant, but depend on stateless certificate chains which is highly scalable but somewhat limits their flexibility. We propose a system between the two: convergent capabilities (‚Äúconcap‚Äù for short) which contain CRDT state to get the benefits of both while retaining suitability for local-first applications.</p>

<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/doc-group.png"/>
<figcaption>
<h4>An Automerge Document Agent</h4>
<p>A Keyhive document in isolation, with a simplified view of its stateful delegation graph.</p>
</figcaption>
</figure>
<p>Concurrent access control will always have some tricky situations. The big obvious ones are what to do if two admins concurrently revoke each other, or happened if operations depend on others that were revoked, and how to handle maliciously back-dated updates. There is quite a lot to discuss on this topic, so we‚Äôll leave it for a future post.</p>
<h3 id="transitive-groups"><a href="#transitive-groups">Transitive Groups</a></h3>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/device-management.png"/>
<figcaption>
<h4>Device Management</h4>
<p>A Keyhive group showing how devices can be managed behind a proxy (‚ÄòAlice‚Äô). Documents in this scenario only need to know about Alice, not every device.</p>
</figcaption>
</figure>
<p>Groups are built on top of convergent capabilities. They‚Äôre ‚Äújust‚Äù a thin design pattern, but help model things like user devices, teams, and more. By following the delegations between groups, we can discover which public keys have what kind of access to a certain document. This provides a handy abstraction over teams and user devices. By following the links, it both lets a writer know who has read access (i.e. who to share keys for the latest E2EE chunk with), and lets the <a href="#trust-minimized-sync-servers">trust-minimized sync engine</a> know which documents the current device can request from the server.</p>
<h3 id="e2ee-with-causal-keys"><a href="#e2ee-with-causal-keys">E2EE with Causal Keys</a></h3>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/causal-encryption.png"/>
<figcaption>
<h4>Causal Encryption</h4>
<p>Causal key management: a strategy for managing E2EE keys based on the causal structure of a document. Similar to a <a href="https://ieeexplore.ieee.org/document/4032481">Cryptree</a>, having the key to some encrypted chunk lets you iteratively discover the rest of the keys for that chunk‚Äôs causal history, but not its parents or siblings.</p>
</figcaption>
</figure>
<p>Data in Keyhive is encrypted-at-rest. Encrypting every Automerge operation separately would lead to very large documents that cannot be compressed. Instead we use the <a href="https://automerge.org/automerge-binary-format-spec/">Automerge Binary Format</a> to compress-then-encrypt ranges of changes. We expect these encryption boundaries to change over time as parts of the document become more stable, so we need a way to manage (and prune) a potentially large number of keys with changing envelope boundaries.</p>
<p>We achieve the above by including the keys to all of their causal predessesor chunks. This sacrifices forward secrecy (FS) ‚Äî leaking old message keys in the case of a later compromised key ‚Äî but retains secrecy of concurrent and future chunks. Of course ‚Äúleaking‚Äù <em>anything</em> sounds bad. However, unlike ephemeral messaging (e.g. <a href="https://signal.org/">Signal</a>) where not all users are nessesarily expected to have the entire chat history, CRDTs like Automerge require access to the entire causal history in order to render a view. This means that in all scenarios we need to pass around all historical keys, whether or not they‚Äôre in the same encryption envelope. We believe that this choice is appropriate for static control context on documents that require the entire history. As a nice side-effect of this choice, we also gain flexibility and simplicity.</p>
<p>In this design, keys behave a bit like pointers, so we can apply all of the standard data structure pointer indirection tricks to do smooth updates to encryption boundaries. This is fairly well-developed at this stage, so we will save a deeper exploration of this topic for a future post.</p>
<h2 id="pull-control"><a href="#pull-control">Pull Control</a></h2>
<p>E2EE raises a new issue: there is no such thing as perfect security. All encryption algorithms are deemed secure with respect to some explicitly-defined assumptions (such as the difficulty of factoring large primes or group operations). There may be mathematical breakthroughs, edge cases discovered, or new hardware that render your choice of encryption algorithm useless. Even more worse, keys can be accidentally leaked or devices stolen. While we can revoke future write access, if someone has the data and the symmetric key, then they have the ability to read that data. The best practice is to have defense in depth: don‚Äôt make ciphertexts retrievable by anyone, but only those with ‚Äúpull access‚Äù or higher. ‚ÄúPull‚Äù is weaker than the more familiar ‚Äúread‚Äù and ‚Äúwrite‚Äù access effects: it‚Äôs only the ability to retrieve bytes from the network but not decrypt or modify them. This is especially helpful for trust-minimizing sync servers, since by definition they cannot have the ability to see the plaintext if we want to claim E2EE.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/01/effects.png"/>
<figcaption>
<h4>Access Effects</h4>
<p>An example of delegation across the Keyhive access effect types</p>
</figcaption>
</figure>
<h2 id="trust-minimized-sync-servers"><a href="#trust-minimized-sync-servers">Trust Minimized Sync Servers</a></h2>
<p>If <a href="https://youtu.be/NMq0vncHJvU?si=_U53CwSnbpkyf5gB&amp;t=1016">we want to move towards an ecosystem of interchangeable relays</a>, minimizing trust on such relays is a must. Our approach (perhaps unsurprisingly) is to end-to-end encrypt the data, removing read access from sync servers altogether. Under this regime, sync engines are ‚Äúmerely‚Äù a way to move random-looking bytes between clients.</p>
<p>There is another ongoing project at the lab focused improving data synchronization for peer-to-peer and via sync servers. We‚Äôve realized that sync and secrecy strongly interact. Broadly speaking, sync protocols benefit from more metadata (to efficiently calculate deltas), but cryptographic protocols aim to minimize or eliminate metadata exposure. This tension extends across related systems, including merging E2EE <a href="https://automerge.org/automerge-binary-format-spec/">compressed chunks</a>, and determining if a peer has already received specific operations when a sync server cannot access them in plaintext.</p>
<p>Fortunately, combining these systems can sometimes result in more than the sum of their parts. For instance, convergent capabilities help facilitate the calculation of which documents are of interest to particular agent, helping the sync system know which documents to send deltas of. For these reasons, we‚Äôre treating synchronization and authorization as part of a larger, unified project, even though each will yield distinct artifacts.</p>
<h2 id="whats-next"><a href="#whats-next">What‚Äôs Next?</a></h2>
<p>Cryptographic code is notoriously difficult to debug, so we decided to start with design and move to code when we had some fairly good theories on how the basics of this system should work. Now that we‚Äôre at that point, we‚Äôve very recently begun to implement this design. We‚Äôll report on our progress in future posts, as well as dive deeper into some of the topics we touched on in the overview here.</p>
</article>
<article>
  <h2><a href="https://macwright.com/keyhive/notebook/02/">02 ¬∑ Group Key Agreement with BeeKEM</a></h2>
  <p>2025 Jan 21</p>
<p>As we‚Äôve seen in past lab notes, Keyhive provides access control for local-first applications. We support both server-based collaboration and peer-to-peer operation without a trusted server. And individuals might work offline for extended periods of time. In the context of Automerge, our goal is to control access to documents, collections of documents, and parts of documents.</p>
<p>Every document has a group of users with access to that document. That group might include other groups as members (in which case the members of those groups are also members of the document). Importantly, a document group‚Äôs membership is dynamic, with new members added and removed over time. We must be able to handle concurrent changes in a distributed context.</p>
<p>Of course, if we want to limit read access to just our group, we can‚Äôt safely share our document as plaintext via sync servers. We need a way to encrypt and decrypt our data that is accessible to only our document‚Äôs members. This means we need a way for our group to agree on the keys that will be used for encryption and decryption over time.</p>
<h2 id="continuous-group-key-agreement"><a href="#continuous-group-key-agreement">Continuous Group Key Agreement</a></h2>
<p>In the literature, this problem is known as <a href="https://eprint.iacr.org/2019/1189.pdf">Continuous Group Key Agreement (CGKA)</a>. A <strong>CGKA protocol</strong> enables a dynamic group to agree on a sequence of keys over time. CGKAs ordinarily guarantee two properties: forward secrecy (FS) and <a href="https://eprint.iacr.org/2016/221.pdf">post-compromise security (PCS)</a>. Imagine a successful attacker compromises a single key. In the simplest terms, forward secrecy means that this key will not enable access to past data. And post-compromise security means it will not enable access to future data. If you can guarantee both, then you can limit the damage from a key compromise.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/forward_secrecy_and_post-compromise_security.png" alt="Forward secrecy and post-compromise security"/>
</figure>
<p>One way to achieve <strong>forward secrecy</strong> is through ‚Äúratcheting‚Äù. With a ratchet, honest users employ a key derivation function (KDF) to deterministically transform a key in a way that is effectively impossible to reverse. A cryptographic hash function is one way to achieve this. Ratcheting with such a one-way function prevents an attacker from discovering past keys since there is no feasible way to reverse the function. But a one-way function on its own does not prevent an attacker from discovering future keys, since you can derive all future keys from a compromised key by repeatedly applying the hash function.</p>
<p>Of course, we don‚Äôt want a system that once compromised is always insecure. That‚Äôs where <strong>post-compromise security</strong> comes in. The intuitive idea is that a system with post-compromise security has some mechanism to deny access after an attack. Compromised information will no longer be enough to derive future keys. One way to achieve this is to periodically rotate information required for determining future keys in a way that is not accessible to a past attacker.</p>
<p>In practice, ratcheting protocols mix in fresh information with each ratchet so that knowledge of a key is not by itself sufficient to derive future keys. For example, Signal‚Äôs <a href="https://signal.org/docs/specifications/doubleratchet/">Double Ratchet protocol</a> includes sending a Diffie-Hellman public key with each message so that the receiver can derive a shared Diffie-Hellman secret to use as a side input to the key derivation function (KDF) that is used for ratcheting.</p>
<h3 id="treekem"><a href="#treekem">TreeKEM</a></h3>
<p>The current Message Layer Security (MLS) protocol for CGKA uses <a href="https://inria.hal.science/hal-02425247v1/file/treekem%20%281%29.pdf">TreeKEM</a>, a protocol for asynchronous, decentralized key agreement for dynamic groups. TreeKEM uses a binary tree with group members‚Äô public keys at the leaves and the current group secret encrypted at the root. All other inner nodes act like the root for their subtrees (and subtrees act like subgroups with their own shared, encrypted secrets). Members can be dynamically added and removed from the tree.</p>
<p>For post-compromise security, each member periodically rotates out its public keys on its leaf, which leads to cascading secret updates all the way to the root. Both updating and decrypting the root secret requires traversing the path from the member‚Äôs leaf to the root, performing <code>log(n)</code> operations (although there is a linear worst case under certain conditions).</p>
<p>Unfortunately, Keyhive‚Äôs requirements rule out TreeKEM as it stands. That‚Äôs because TreeKEM depends on a central server to create a total order of operations, and to pick winners among concurrent operations. Keyhive‚Äôs local-first model is peer-to-peer compatible and does not require such a central server. And for Keyhive, concurrent operations can be merged in long after they were actually performed (for example, if a member made changes while aboard a long-haul flight).</p>
<h3 id="decentralized-cgka-alternatives"><a href="#decentralized-cgka-alternatives">Decentralized CGKA alternatives</a></h3>
<p>An alternative that is more aligned with our requirements is the <a href="https://dl.acm.org/doi/pdf/10.1145/3460120.3484542">Decentralized Continuous Group Key Agreement (DCGKA) protocol</a> developed by <a href="https://mattweidner.com">Matthew Weidner</a> and <a href="https://martin.kleppmann.com">Martin Kleppmann</a>. This protocol assumes a decentralized network that does not depend on a trusted central server. However, unlike TreeKEM, it provides linear rather than logarithmic performance. As a result, they target groups on the order of 100 members as opposed to MLS‚Äôs target of 50k members. A design goal for Keyhive is to target at least thousands of members.</p>
<p>Matthew Weidner has also proposed an alternative to TreeKEM called <a href="https://mattweidner.com/assets/pdf/acs-dissertation.pdf">Causal TreeKEM</a>. Whereas TreeKEM requires a total order imposed by a central server, Causal TreeKEM only requires a causal order, which is much better suited to a decentralized network. Like TreeKEM, it has logarithmic performance (with a linear worst case) and is meant to ensure both forward secrecy and post-compromise security.</p>
<p>However, Causal TreeKEM depends on fancier crypto than we‚Äôd prefer in order to merge concurrent updates in any order. It requires a cryptographic operation to combine updates at a node that is both associative and commutative. One option here would be BLS, but this is far less common than the standard options and there is not currently a great library option for Rust (the language Keyhive is written in). And we have definitely ruled out rolling our own crypto (you probably should too).</p>
<p>For these reasons, we‚Äôve proposed our own alternative for Keyhive that we call ‚ÄúBeeKEM‚Äù. It is closely modelled on TreeKEM with insights from Causal TreeKEM. It requires no central server and only a causal order of operations. It provides logarithmic performance (with linear worst case). And like the other TreeKEM variants, it provides forward secrecy and post-compromise secrecy. Furthermore, it relies exclusively on standard crypto, such as <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie Hellman key exchange</a> and <a href="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf">BLAKE3</a> hashing.</p>
<h2 id="beekem"><a href="#beekem">BeeKEM</a></h2>
<p>In this section, we‚Äôll see how BeeKEM works in more detail.</p>
<p>In BeeKEM (as in TreeKEM), the current group secret is stored encrypted at the root node of a binary tree. We‚Äôll call this the ‚Äúroot secret‚Äù. The root secret is used for encrypting and decrypting document chunks shared with our group over the network.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/basic_beekem_tree.png" alt="Basic BeeKEM tree"/>
</figure>
<p>Each leaf of the tree corresponds to a member of the group and contains its ID and latest Diffie Hellman (DH) public key. A member‚Äôs ID is persistent over time but each member will periodically rotate its DH public key. When a member rotates its DH public key, that will cause the root secret to change as well. Thus, member key rotations help provide post-compromise security. From the point of view of an adversary, they introduce fresh randomness.</p>
<p>Each leaf has an implicit secret known only to the corresponding member (i.e. not stored in the tree). All other ‚Äúinner‚Äù nodes in the tree contain a DH public key for that node and a corresponding secret key that is stored encrypted at the node.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/beekem_inner_nodes.png" alt="BeeKEM inner nodes"/>
</figure>
<p>Each node in a binary tree has a single sibling node, as illustrated in the following diagram:</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/siblings.png" alt="Node sibling"/>
</figure>
<p>When encrypting or decrypting a new secret at a parent node, a child node performs a <strong>Diffie Hellman key exchange</strong> with its sibling. That means it will use its sibling DH public key and its own secret key to derive what we‚Äôll call a ‚Äúshared DH secret‚Äù. The shared DH secret is used to encrypt and decrypt the new secret at the parent.</p>
<p>A brief (simplified) aside on how Diffie Hellman key exchange works. Imagine Alice and Bob each have their own DH public keys (alice_pk and bob_pk) and DH secrets (alice_sk and bob_sk). If Alice combines her DH public key with Bob‚Äôs secret key, she can derive a shared DH secret. If Bob combines his DH public key with Alice‚Äôs secret key, he can derive the same shared DH secret. In this way, they can agree on a shared secret just by exchanging their public keys in the open.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/diffie_hellman_basics.png" alt="Diffie Hellman basics"/>
</figure>
<p>We use this same principle to derive a shared DH secret for any sibling pair in our tree. For example, to decrypt Alice‚Äôs parent node, Alice can use its secret <code>alice_sk</code> and its sibling‚Äôs public key <code>bob_pk</code> to derive a shared DH secret. It can then use that shared secret to decrypt the secret at the parent node.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/beekem_diffie_hellman_example.png" alt="BeeKEM Diffie Hellman example"/>
</figure>
<p>In pseudocode, this might look like:</p>
<div>
<pre><code>shared_dh_secret = DH(bob_pk, alice_sk)
parent_secret =
  encrypted_parent_secret.decrypt_with(shared_dh_secret)
</code></pre>
</div>
<p>That parent secret can in turn be used for a Diffie Hellman exchange with the parent‚Äôs sibling‚Äôs DH public key.</p>
<p>For a member to decrypt the root secret, it must start from its leaf and traverse the tree one parent at a time until it reaches the root. The sequence of nodes from leaf to root is called that leaf‚Äôs ‚Äúpath‚Äù. At each node in its path, it will derive a shared DH secret with its sibling to decrypt the secret at its parent. Once it‚Äôs decrypted the root secret, it‚Äôs done.</p>
<p>In the following diagram, the decrypting leaf‚Äôs path is marked in green. The siblings used as Diffie Hellman partners along the way are marked in purple:</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/beekem_path.png" alt="BeeKEM path"/>
</figure>
<p>There are three mutating operations that can be performed on the tree: Update Key (i.e. key rotation), Remove Member, and Add Member. Let‚Äôs look at these in more detail.</p>
<h3 id="update-key"><a href="#update-key">Update Key</a></h3>
<p>Every member must periodically update the DH public key at its leaf in order to guarantee post-compromise security. When we update our leaf DH public key, we must then update the secrets for all the nodes on our path, eventually updating the root secret for the entire group.</p>
<p>Before traversing our path, we can derive a sequence of path secrets by applying BLAKE3‚Äôs key derivation function to an initial secret once for each node on the path. As we move up each parent on our path, we will encrypt the next derived secret and store it on that parent.</p>
<p>In order to encrypt the secret for a parent, we use Diffie Hellman key exchange as described above. We then derive a new Diffie Hellman public key from the secret for the parent, and store both that new DH public key and the corresponding encrypted secret at the parent.</p>
<p>In pseudocode:</p>
<div>
<pre><code>parent_secret = derived_secrets[next_idx]
shared_dh_secret = DH(child_sibling_pk, child_sk)
encrypted_parent_secret =
  parent_secret.encrypt_with(shared_dh_secret)
parent_pk = DH_pk_from(parent_secret)
parent_node.insert(parent_pk, encrypted_parent_secret)
</code></pre>
</div>
<p>Later on, when the sibling wants to decrypt that parent secret, it can do Diffie Hellman the other way, using the encrypter node‚Äôs DH public key with the sibling node‚Äôs secret to derive the same shared DH secret that was used to encrypt the parent.</p>
<div>
<pre><code>shared_dh_secret = DH(encrypter_pk, sibling_sk)
encrypted_parent_secret = parent_node.encrypted_secret
parent_secret =
  encrypted_parent_secret.decrypt_with(shared_dh_secret)
</code></pre>
</div>
<h3 id="membership-changes"><a href="#membership-changes">Membership Changes</a></h3>
<p>In order to explain membership changes, we must introduce the concept of ‚Äúblanking‚Äù a node. Blanking a node means that we remove all key and secret information from that node. If the root node is blank, then the tree does not currently hold a shared group key. Some nodes are blanked after membership change operations, and all leaves beyond the last member leaf on the right are blank.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/blank_nodes.png" alt="Blank nodes"/>
</figure>
<p>If a tree has a blank root, then at least one member must perform an Update Key operation to restore a root secret. An update will replace all blank nodes on its update path with key information.</p>
<p>When we perform a <strong>Remove Member</strong> operation, we first blank the leaf corresponding to that member. We then blank the entire path from that leaf up to the root node.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/remove_member.png" alt="Remove member"/>
</figure>
<p>Notice that if a removed member performs an update concurrently with its removal, we need to ensure that the update does not survive (or else the member will continue to have access to the root secret). When merging concurrent removes with other operations, BeeKEM ensures that the remove paths are blanked after all other concurrent operations are merged.</p>
<p>When we perform an <strong>Add Member</strong> operation, we add the new member‚Äôs ID and public key to the next blank leaf on the right. We then blank the path from that leaf to the root.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/add_member.png" alt="Add member"/>
</figure>
<p>Notice that if two members add a member concurrently to the same tree, they will add them to the same leaf. BeeKEM resolves such conflicts on merge by sorting all concurrently added leaves and blanking their paths.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/merging_concurrent_adds.png" alt="Resolving add conflicts"/>
</figure>
<h3 id="handling-blank-nodes-on-update-and-decryption"><a href="#handling-blank-nodes-on-update-and-decryption">Handling Blank Nodes on Update and Decryption</a></h3>
<p>So far, we‚Äôve assumed that every node has a sibling with key information. That‚Äôs what allowed us to use Diffie Hellman to derive a shared DH secret. But what happens when a node‚Äôs sibling is blank?</p>
<p>In that case, we must find the blank node‚Äôs <strong>resolution</strong>. A node‚Äôs resolution is the set of its highest non-blank descendents. Here‚Äôs an example:</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/node_resolution_examples.png" alt="Node resolution example"/>
</figure>
<p>If you have a blank sibling, you must do a separate encryption of the new parent secret for every member of your sibling‚Äôs resolution. For each of those members, you use its Diffie Hellman public key with your secret to derive a shared DH secret. You then encrypt the new parent secret using that shared secret and store it for that member.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/blank_sibling.png" alt="Blank sibling"/>
</figure>
<p>This means that if the resolution of a sibling node contains 5 members, you will need to store the parent secret 5 times, each one encrypted for a separate member.</p>
<p>The worse case scenario is if the entire inner tree is blank. Encrypting a new path will no longer be a logarithmic operation since every leaf will be contained in the resolution of some blank node on your path. Instead, the cost will be linear in the number of leaves: you will have to perform a separate encryption for every other leaf somewhere on your path.</p>
<p>When decrypting a leaf with blanks on its path, you simply skip those blanks. This works because the highest blank in your path will contain its last non-blank descendent in its resolution. So when you encounter a blank on your path, you hold onto the last secret you‚Äôve seen and start skipping. When you eventually get to a non-blank node, you‚Äôll use that secret you‚Äôre holding onto to derive the shared DH secret you need to decrypt the non-blank parent.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/skipping_blanks.png" alt="Skipping blanks"/>
</figure>
<h3 id="handling-concurrent-updates-with-conflict-keys"><a href="#handling-concurrent-updates-with-conflict-keys">Handling Concurrent Updates with ‚ÄúConflict Keys‚Äù</a></h3>
<p>Keyhive assumes that concurrent operations can be merged in any causal order. Concurrent updates will always have some overlapping nodes in their paths (at least the root is shared by all paths). How does BeeKEM resolve these conflicts?</p>
<p>We must first consider our potential vulnerabilities. Imagine that an adversary has compromised a group member and their leaf secrets. They can use a compromised leaf secret to decrypt the root secret at some point in time. Recall that knowing a leaf secret means you can decrypt all of the inner node secrets along your path.</p>
<p>If an adversary knows the secret for a leaf, it‚Äôs possible they will continue to be able to decrypt the group secret even if that leaf is rotated during a future concurrent update. This depends on how we handle merging concurrent updates.</p>
<p>If we just naively pick a winner for updates to a series of overlapping nodes, then the new information added by the loser‚Äôs key rotation will no longer be necessary to decrypt the root secret. We effectively forget that information.</p>
<p>Notice that the winner used the outdated keys from the loser for its update (since the winner‚Äôs and loser‚Äôs updates were concurrent). That means an adversary with the loser‚Äôs outdated leaf keys will still be able to decrypt the winner‚Äôs nodes. Subsequent updates by other leaves that only intersect with the winner‚Äôs path will also fail to exclude our adversary.</p>
<p>In BeeKEM, when merging concurrent updates, we ensure that all updates contribute information along their entire paths. We keep conflicting information around at each node until it is overwritten by a causally subsequent operation (or blanked by a membership change).</p>
<p>If two leaves update the same node concurrently, then they would have each written a distinct Diffie Hellman public key and encrypted secret to that node. In this scenario, we call these ‚Äúconflict keys‚Äù and store them both when merging conflicts.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/03/merging_concurrent_updates.png" alt="Merging conflict keys"/>
</figure>
<p>Imagine a member subsequently updates the tree. If a node on its leaf‚Äôs path has a sibling with conflict keys, this means there is an unresolved merge at that sibling. An adversary could have access to both sides of the corresponding fork. So it wouldn‚Äôt be secure to use those conflict keys for Diffie Hellman. Instead, we take the resolution of the node, just as we did with blank nodes. We then separately encrypt the secret for every DH public key in the resolution, again just as we did with blank nodes.</p>
<p>This means that for BeeKEM we update the definition of the ‚Äúresolution of a node‚Äù to mean either (1) the single DH public key at that node <strong>if there is exactly one</strong> or (2) the set of highest non-blank, <strong>non-conflict</strong> descendents of that node.</p>
<p>If we merged in both sides of a fork, then we know we‚Äôve updated both corresponding leaves with their latest rotated DH public key. Since taking the resolution skips all conflict nodes, it ensures that we integrate the latest information when encrypting a parent node. That‚Äôs because any non-conflict nodes have successfully integrated all causally prior information from their descendents.</p>
<p>This means an adversary needs to compromise one of the latest leaf secrets to be able to decrypt an entire path to the root. Even knowing outdated leaf secrets at multiple leaves will not be enough to accomplish this. An honest user, on the other hand, will always know the latest secret for its leaf.</p>
<p>During a future update (key rotation), if you find a conflict key node on the path you‚Äôre updating, you can remove all conflict keys at that node and replace them with a single new public key and encrypted secret (as with normal parent encryption). That‚Äôs because your update operation is the causal successor of all the operations that placed those conflict keys. This means your tree contains the necessary information from all of those past updates, which is integrated into your update.</p>
<p>BeeKEM‚Äôs approach comes with two downsides. First, before conflicts are resolved by subsequent updates or blanks, we must store extra information at each conflict node. Second, conflict keys add extra encryption and decryption overhead. In the worst case, where the tree is populated with the maximum number of possible conflict keys, the space cost would be <code>n log(n)</code> (as opposed to the best case of <code>2n</code>). The time cost in the worst case would be linear (as opposed to logarithmic), as when the tree is maximally blanked. Our current set of benchmarks reflect these time costs when we intentionally exercise our worst cases.</p>
<p>BeeKEM provides Keyhive with a Continuous Group Key Agreement protocol that is well-suited to distributed local-first applications that require end-to-end encryption for groups on the order of thousands of members. It exhibits logarithmic performance in the common case with linear worst case. And it provides both forward secrecy and post-compromise security.</p>
<p>In the future, we plan to write a paper explaining this protocol and its security and performance characteristics in more detail. But hopefully this has given you a sense for how it works.</p>
<!-- Footnotes -->
<!-- External Links -->

</article>
<article>
  <h2><a href="https://macwright.com/keyhive/notebook/03/">03 ¬∑ What&#39;s In a Name?</a></h2>
  <p>2025 Feb 27</p>
<p>The Beehive project is now officially renamed <em>‚ÄúKeyhive‚Äù!</em></p>
<p>Changing names can be a painful process, and doing so as early as possible in a project‚Äôs life is helpful. As <a href="https://www.karlton.org/2017/12/naming-things-hard/">Phil Karlton famously said</a>, there‚Äôs exactly two hard problems in computer science: caching, naming, and off-by-one errors. Naming is important for orienting readers, searching the web, and avoiding ambiguity. We wanted to make sure that the name was finalized prior to open sourcing the code.</p>
<p>There is a naming philosophy that says names should be descriptive, or at least present a direct ‚Äúmental hook‚Äù that implies what the signified thing does. Additional puns and whimsey help with memorability.</p>
<p>The previous project name ‚ÄúBeehive‚Äù was intended to present a sense of safety and collaboration: bees build complex-yet-sturdy structures together while working independently, and guard their hives to make a safe space on the inside. This metaphor was also inspired by earlier conversations with <a href="https://en.wikipedia.org/wiki/Christine_Lemmer-Webber">Christine Lemmer-Webber</a> about metaphors to help explain capability systems (like Keyhive) to folks not familiar with formal concepts from the <a href="https://en.wikipedia.org/wiki/Object-capability_model">object-capabilities</a> world like <a href="https://erights.org/elib/concurrency/vat.html">Vats</a>.</p>

<p>At the time that we decided on ‚ÄúBeehive‚Äù, the team was aware of namespace conflicts in the academic distributed systems literature. Over time it‚Äôs become clear that we also have this problem with packages in more than one language ecosystem. Since we don‚Äôt want to tie the project to <a href="https://automerge.org/">Automerge</a> exclusively, prefixing the core project with <code>automerge-*</code> was not appropriate.</p>
<p>We are retaining our apian naming for other parts of the project. <a href="https://macwright.com/keyhive/notebook/#beekem">BeeKEM</a> maintains it‚Äôs pun on TreeKEM, and Beelay is the Keyhive-enabled relay.</p>
<p>Beehive is dead. Long live Keyhive!</p>
<!-- Footnotes -->
<!-- Internal Links -->
<!-- External Links -->

</article>
<article>
  <h2><a href="https://macwright.com/keyhive/notebook/04/">04 ¬∑ Opening the Pre-Alpha</a></h2>
  <p>2025 Mar 10</p>
<p>We‚Äôre excited to announce that we‚Äôre opening the <em>pre-alpha</em> code for the following libraries:</p>
<ul>
<li><a href="https://github.com/inkandswitch/keyhive/tree/main/beelay/beelay-core">beelay-core</a>: Auth-enabled sync over end-to-end encrypted data</li>
<li><a href="https://github.com/inkandswitch/keyhive/tree/main/keyhive_core">keyhive_core</a>: The core signing, encryption, and delegation system</li>
<li><a href="https://github.com/inkandswitch/keyhive/tree/main/keyhive_wasm">keyhive_wasm</a>: <a href="https://webassembly.org/">Wasm</a> wrapper around <code>keyhive_core</code>, plus TypeScript bindings</li>
</ul>
<p>‚ö†Ô∏è <strong>DO NOT use this release in production applications</strong> ‚ö†Ô∏è</p>
<p>We want to emphasize that this is an early preview release for those that are curious about the project. Expect there to be bugs, inconsistencies, and unstable APIs. This code has also not been through a security audit at time of writing.</p>
<p>If you have any questions, thoughts, or feedback, please contact the team at by filing a <a href="https://github.com/inkandswitch/keyhive/issues/new">GitHub Issue</a>, or in the <a href="https://discord.com/channels/1200006940210757672/1347253710048333884"><code>keyhive-beelay</code> channel in the Automerge Discord</a>.</p>
<!-- External Links -->
</article>
<article>
  <h2><a href="https://macwright.com/keyhive/notebook/05/">05 ¬∑ Syncing Keyhive</a></h2>
  <p>2025 Mar 13</p>

<p>The last few lab notes have focused on the cryptographic components which support a local first access control system. Those being a capability based system for managing write access to documents, and a key agreement protocol for encrypting and decrypting writes (thus implementing read control). We now have to think about how to actually transfer this data between devices.</p>
<p>Alongside the Keyhive project we have also been working on a new sync protocol for Automerge. The existing sync protocol works well for a single document but it is common for Automerge applications to have thousands of documents. Furthermore, the sync protocol requires that both ends are able to read the document whilst one of the objectives of Keyhive is for the server to only have access to the encrypted data.</p>
<p>Solving all of these problems in one go is the job of Beelay (the name is inspired by the idea of Beehive being the relay for all the bees (peers) in the Keyhive).</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>Beelay is an RPC protocol which is designed to be usable over any transport which can provide confidentiality (in practice, HTTPS, WebSockets, or raw TLS). The intended usage is to create a local Beelay instance and then connect it to other peers, Beelay will then authenticate with the other peers and synchronise everything which each side thinks the other has access to.</p>
<p>Each message is authenticated by signing it with the <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">Ed25519</a> key that the local node controls. To synchronise we first synchronise the Keyhive membership graph which each end has, this allows each end to determine what documents the other end should have access to. Then we synchronise the collection of documents to figure out which documents are out of sync, before finally synchroising each individual document.</p>
<h2 id="authentication"><a href="#authentication">Authentication</a></h2>

<h3 id="what-are-we-authenticating"><a href="#what-are-we-authenticating">What are we authenticating?</a></h3>
<p>It will be useful here to review how we intend to represent devices, people, and documents in Keyhive. In Keyhive there are two important kinds of principal: ‚Äúgroups‚Äù and ‚Äúindividuals‚Äù. An individual is identified by a single Ed25519 public key - which is immutable - whilst a group is a collection of other principals (groups or individuals) and can be updated by it‚Äôs members. One way we intend to use this is to represent a person (or more specifically their authority) as a group, with each of the persons devices being an individual member of the group. Key rotation can then be handled by adding a new individual to the group and removing the old one.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/person-group.png" alt="A diagram of a group representing a person, with three nodes representing devices called &#39;phon&#39;, &#39;laptop&#39;, and &#39;table&#39; all of which have arrows pointing to the person node"/>
</figure>
<p>Groups can contain other groups. This means that we can represent as groups, where each member of the organisation is another group representing a person (or for that matter another organisation, such as a department).</p>
<p>Another useful aspect of this structure is that documents can also be represented as groups. This allows documents to have members which can access the document. For example, a document representing this lab note might add the Ink &amp; Switch group so that all (transitive) members of the Ink &amp; Switch group can read and write to it. Documents can also add other documents which represents ‚Äúfolder‚Äù style relationships. The ‚Äúlab notes‚Äù folder document (which is also a group, because all documents are) might contain all the lab notes and have the Ink &amp; Switch as a member.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/person-doc-group.png" alt="Another diagram, this time with a node labelled &#39;Ink &amp; Switch&#39; which represents an organisation with the original &#39;person&#39; diagram being a member of that group"/>
</figure>
<p>What this all means for the sync protocol is that any given peer is represented by an ‚Äúindividual‚Äù. The task of authentication is to ensure that each end knows what Ed25519 public key the other end is using so that we can relate that individual key to the Keyhive membership graph.</p>
<h3 id="how-do-we-authenticate"><a href="#how-do-we-authenticate">How do we authenticate?</a></h3>
<p>One solution which might seem obvious here is to rely on an authenticated TLS session. While we use TLS for confidentiality, and the browser itself authenticates the server, our application <em>also</em> needs to know about the server‚Äôs public key. Unfortunately, the browser doesn‚Äôt expose this information to the application context; there is no way in the browser to obtain the connection‚Äôs TLS certificate. We don‚Äôt just need to know that a connection is secure, we need to know the public key of the other end in order to use it for access control decisions and so on.</p>
<p>Given that each peer is represented by a public key, the simplest possible authentication scheme would be to sign each message. I.e. a message might look like this:</p>
<div>
<pre><code>type Envelope = {
    message: Uint8Array,
    signature: Signature,
    sender: PublicKey,
}

type PublicKey = Uint8Array
type Signature = Uint8Array
</code></pre>
</div>
<p>To authenticate a message we check that the signature is valid over the message, then we know that the other end is the individual represented by the given public key. There are two problems with this, <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">person in the middle (PITM)</a> attacks, and <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attacks</a>.</p>
<h3 id="person-in-the-middle-attacks"><a href="#person-in-the-middle-attacks">Person in the middle attacks</a></h3>
<p>A good example of PITM attack on this protocol would be a phishing based attack. Imagine an application which allows users to input the URL of a sync server to sync from. Let‚Äôs say an attacker creates a sync server at a familiar looking URL, such as <code>wss://sync.automege.org</code> (note the misspelling) and convinces the user to enter this URL into their application. The attacker can now intercept all messages intended for the real <code>sync.automerge.org</code> server and forward them on to the sync server. This means the attacker can read all the messages and even modify messages sent back to the client.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/pitm.png" alt="A diagram with three nodes connnected in a line, the right most is labelled &#39;browser&#39;, the middle is labelled &#39;sync.automerge.org (attacker)&#39; and the rightmost is labelled &#39;sync.automerge.org&#39;"/>
</figure>
<p>The fundamental problem here is that the message is bound to the sender but not to the receiver. We can solve this by adding an ‚Äúaudience‚Äù field to the message.</p>
<div>
<pre><code>type Envelope = {
    message: Message,
    signature: Signature,
    sender: PublicKey,
}

type Message = {
    payload: Uint8Array,
    audience: PublicKey,
}
</code></pre>
</div>
<p>This doesn‚Äôt quite solve the problem above though. At this stage we only have a URL, we don‚Äôt have a public key for the server. To solve this we allow the audience field to either be a public key, or the URL we are addresssing. In this case the audience would be <code>sync.automege.org</code>. This means that when the PITM forwards the message to <code>sync.automerge.org</code> the real server can check and see that the audience doesn‚Äôt match <code>sync.automerge.org</code> and reject the message.</p>

<p>This works because the connection is being made over TLS, which binds the network transport to the hostname, ensuring that whoever is at the other end, they definitely control <code>sync.automerge.org</code>. Beelay is designed to work over arbitrary transports though, in other network setups such as P2P transports you will need to obtain the public key of the receiver out of band.</p>
<h3 id="replay-attacks"><a href="#replay-attacks">Replay attacks</a></h3>
<p>In a replay attack an attacker is somehow able to intercept messages and store them, and then later replay them to the server. To mitigate this we add a timestamp to the message and then reject messages which are older than some validity window that accounts for latency plus a <a href="https://en.wikipedia.org/wiki/Clock_skew">clock skew</a> grace period ‚Äî e.g. 5 minutes.</p>
<p>The main issue with this scheme is that the clocks of two peers might be out of sync by arbitrary amounts of time. Soft locking the sync system due to clock sync issues is not acceptable. To solve this, when a peer rejects a message due to an old timestamp, the rejecting peer sends their current timestamp along with the rejection message. This allows the sending peer to determine the drift between their local clock and the remote clock and adjust the timestamps on the messages they send, and account for it during this session.</p>
<h3 id="summary"><a href="#summary">Summary</a></h3>
<p>Altogether then, our messages look a bit like this:</p>
<div>
<pre><code>type Envelope = {
    message: Message,
    signature: Signature,
    sender: PublicKey,
}

type Message = {
    payload: Uint8Array,
    audience: PublicKey | string,
    timestamp: number,
}
</code></pre>
</div>
<p>To authenticate a message we check that the signature is valid, that the audience is either our public key or the hash of our hostname (or some other string which is bound to the recipient in some way) and that the timestamp is new enough.</p>
<h2 id="syncing-the-membership-graph"><a href="#syncing-the-membership-graph">Syncing the membership graph</a></h2>
<p>Once we are authenticated, we need to determine what each side thinks the other should have access to. This means that we need to sync the Keyhive ‚Äúmembership graph‚Äù. This is the graph of groups and individuals which represent devices, people, organisations, and documents.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/what-are-we-syncing.png" alt="An image of three large boxes labelled group, document, and document. Each box has arrows pointing to the other and also contains within it a set of smaller boxes pointing to each other labelled op"/>
</figure>
<p>The membership graph is a directed graph of ‚Äúoperations‚Äù where each operation either creates a new node, delegates access to some other node, or revokes access. Unlike Automerge documents (which are also graphs) the membership operation graph is very shallow and wide, and the linked groups and documents can have cycles. There are many approaches to this problem, but it becomes much simpler if we frame it as <em>set reconciliation</em>, where each side has an unstructured set of operations and needs to figure out what operations the other side has that it needs (i.e. the delta between the two sets). We will encounter a very similar problem later, when we sync the collection of documents. In both cases we use a construction called <a href="https://arxiv.org/html/2402.02668v2">Rateless Invertible Bloom Lookup Tables</a> (RIBLT) to solve this problem.</p>
<h3 id="riblt-set-reconciliation"><a href="#riblt-set-reconciliation">RIBLT set reconciliation</a></h3>
<p>RIBLT is described in detail in <a href="https://arxiv.org/html/2402.02668v2">this paper</a>, what I will describe here are the important properties that the scheme gives us.</p>
<p>RIBLT is a set reconciliation protocol, which means there are two peers who have some possibly overlapping set of things which they want to have the same view of. I.e. after the protocol completes each side should have the union of the things each started with.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/set-reconciliation-1.png" alt="set reconciliation"/>
</figure>
<p>RIBLT solves this problem by having each side encode it‚Äôs set of things into a set of hashes and then generate a set of special ‚Äúsymbols‚Äù which one side sends to the other.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/riblt-things-to-hashes-to-symbols.png" alt="an image of a set of boxes labeled thing1, thing2, and thing3, with each box pointing to another box labelled hash(thing1), hash(thing2), hash(thing3). A larger box surrounds the entire set of boxese pointing to a sequence of boxes labelled symbol1, symbol2, symbol3"/>
</figure>
<p>These symbols are structured in such a way that once the receiver has received enough of them they will be able to decode the symbols into the set difference.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/riblt-symbols-decoded.png" alt="an image of three boxes labeled symbol1, symbol2, symbol3 with an arrow - labelled decode - pointing to two bases labeled things we have which they dont and things they have which we dont containg a box labelled hash(thing1) and hash(thing2) respectively"/>
</figure>
<p>The details are a bit fiddly but the really important part is that the number of symbols which must be sent is proportaional to the set difference between the two peers. Specifically, the number of symbols sent ranges from 1.7x (for small sets) down to 1.35x (for large sets) the set difference.</p>
<p>For example, If we have one billion items each, but only five differing items, we can reconcile in 5 * ~1.5 = 7.5 symbols. The symbols themselves are (in our case) 32 bytes long, so we can reconcile a billion items in 240 bytes.</p>
<p>The other important part is that the result of decoding is the set of hashes - not the things themselves. In fact, we can use any fixed length array which uniquely represents the thing.</p>
<h3 id="syncing-the-membership-graph"><a href="#syncing-the-membership-graph">Syncing the Membership Graph</a></h3>
<p>So, we use RIBLT sync to synchronise the membership graph. The process is mostly driven by the client (in the peer to peer case we arbitrarily choose that the peer who initiated the connection is the client).</p>
<p>First, the client sends a request to the server to begin membership sync. The server stores a pointer to the current set of ops which it thinks the other end needs and then responds with a session ID to identify this sync session, and the first 10 symbols of the RIBLT sync.</p>
<p>The client now receives the first 10 symbols and attempts to decode them. If they are able to decode then they are done and they know the set difference, otherwise, they send a request for the next 10 symbols, using the session ID to specify which state they are syncing with.</p>
<p>Eventually the client knows the set difference in terms of hashes of operations which only the server has, and operations which only the client has. Finally, the client requests the missing operations by sending their hash, and uploads the symbols which they believe the server is missing.</p>
<figure>
<img src="https://macwright.com/keyhive/notebook/static/05/beginsync-1.png" alt="begin sync"/>
</figure>
<h2 id="document-collection-sync"><a href="#document-collection-sync">Document Collection Sync</a></h2>
<p>At this point each end has determine what documents it thinks the other should have acces to. The next step is to determine which documents are out of sync. To achieve this we use RIBLT sync again, this time instead of the set we are synchronising being the set of membership operations it is the set of (document ID, state) pairs, where <code>state</code> here is a hash of the document state.</p>
<p>There are two components to the document state which we care about for the purposes of synchronisation. One is the heads of the Automerge document - the document content is encrypted but we keep the hashes of the Automerge commit graph outside of the encryption envelope, so the sync server knows the heads.</p>
<p>The other piece of state are the BeeKEM operations for the document. Recall that BeeKEM is a continuous group key agreement (CGKA) protocol which allows peers to concurrently decide on what keys to encrypt content to. We need to have the latest CGKA ops in order to be able to decrypt the document content.</p>
<p>How do we form our RIBLT symbols then? One way would be to make each symbol <code>hash(document ID, document heads, cgka ops)</code>. Then, once we‚Äôve performed RIBLT sync we make another network call to convert each symbol into the document ID which is out of sync. However, we can do a little better than this. Recall that the RIBLT symbol is just any fixed length byte array, and document IDs are a 32 byte array. This means that instead of a hash for the symbol, we use <code>(document ID, hash(heads, cgka ops)</code>. This means that once we have decoded the symbol we already know what the document ID is for the symbol in question without doing any more round trips.</p>
<p>The process for actually running this sync then is similar to the membership sync. Using the session ID from the membership sync the client fetches new document symbols from the server until it is able to decode the first symbol it received, at which point it knows which symbols are out of sync.</p>
<h2 id="document-sync"><a href="#document-sync">Document Sync</a></h2>
<p>By this point we have a list of document IDs which are out of sync. We now have to sync the CGKA ops and encrypted commit graph for each document. For the CGKA sync we can use our old friend RIBLT sync to sync the set of CGKA ops, but for the document content we need to do something a bit different because we want to be able to take advantage of the bandwidth gains we get from compacting Automerge documents.</p>
<h3 id="cgka-ops"><a href="#cgka-ops">CGKA Ops</a></h3>
<p>The set we are synchronizing here is the set of CGKA ops for the document. We use the hash of each op to create our RIBLT symbols. As with other RIBLT syncs, the client requests symbols from the server until it is able to decode it‚Äôs first symbols at which point it knows what ops to upload and what ops to request.</p>
<h3 id="sedimentree"><a href="#sedimentree">Sedimentree</a></h3>
<p>Syncing the document content is more complicated. Initially it might seem that we could just use RIBLT sync again where the symbols to sync are the commit hashes of the commits in the Automerge commit graph. This would certainly work, however, it would use <em>a lot</em> of bandwidth. Automerge commits are frequently made for each keystroke, adding a 32 byte hash for each keystroke would be very expensive.</p>
<p>This is a specific instance of a general problem which is that naive encodings of the Automerge commit graph contain enormous amounts of metadata overhead. We have a <a href="https://automerge.org/automerge-binary-format-spec/">compact binary encoding</a> which reduces this overhead to around 10% over the underlying data. What we need is a way to use this data in the sync protocol.</p>
<p>In the current sync protocol this is not a problem, the sync server has the plaintext in memory and so it can compact the document on the fly when a new peer comes online. For Beelay this isn‚Äôt an option because the server only has the ciphertext. What to do?</p>
<p>We have come up with a simple protocol for this which we call ‚Äúsedimentree‚Äù. The idea is that every so often we compress ranges of the commit graph into chunks and we do this recursively, so that every so often smaller chunks get compressed into larger chunks. We do this in such a way that older (i.e. closer to the root of the commit graph) end up in larger and larger chunks as time goes on. This forms a tree structure, with older chunks being closer to the root of the tree - hence sedimentree, with chunks being like layers of sedimentree rock.</p>
<p>Choosing the boundaries of the chunks is a little fiddly because we need to do it in such a way that peers with different sets of changes still agree on what should go into each chunk. We do this by using the number of trailing zeros in the hash of a commit as the boundary. There are more details on this <a href="https://github.com/inkandswitch/keyhive/blob/main/design/sedimentree.md">here</a>.</p>
<p>The end result of this structure is that we can sync the document in two steps:</p>
<ul>
<li>Download a ‚Äúsummary‚Äù of the sedimentree, which contains just the boundaries of the chunks.</li>
<li>Download the chunks we don‚Äôt have, and upload the ones the other end doesn‚Äôt have</li>
</ul>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>Overall then sync looks like this:</p>
<ul>
<li>Sync membership graph
<ul>
<li>Run RIBLT set reconciliation on the membership ops</li>
<li>Download ops we are missing</li>
<li>Upload ops the remote is missing</li>
</ul>
</li>
<li>Sync collection state
<ul>
<li>Run RIBLT set reconciliation on the set of document states</li>
</ul>
</li>
<li>Sync out of sync documents, for each document which is out of date
<ul>
<li>Run RIBLT sync on the CGKA ops</li>
<li>Download CGKA ops we are missing</li>
<li>UPload CGKA ops the remote is missing</li>
<li>Run sedimentree sync on the document content</li>
</ul>
</li>
</ul>
<p>One thing which may be concerning here is the number of round trips. We should especially worry about this in the common case where only one document has changed</p>
<ul>
<li>One round trip for the membership sync</li>
<li>One round trip for collection state</li>
<li>One round trip for CGKA sync</li>
<li>Two round trips for sedimentree sync</li>
</ul>
<p>We should be able to simplify this. One the initial message when we begin membership sync we can send the clients first 5 (say) membership RIBLT symbols and first 5 collection state symbols. In the common case the server will be able to decode these symbols (because only one document has changed) and immediately determine which document has changed, then the server can send back a response with the sedimentree summary for the changed document and the first 5 symbols of the server CGKA RIBLT state. The client will in most cases be able to determine if any CGKA ops are missing and immediately download any missing document state.</p>
<p>Thus in the common case we can sync graph updates (auth, content, etc) in just two round trips.</p>
<!-- External Links -->
</article>

  <article>
    <hr/>
    <div>
  <h6>The Ink &amp; Switch Dispatch</h6>
  <p>Keep up-to-date with the lab&#39;s latest findings, appearances, and happenings by subscribing to our newsletter. For a sneak peek, <a href="https://macwright.com/newsletter">browse the archive</a>.</p>
  

</div>
  </article>

  

</div>
  </body>
</html>
