<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.unixwiz.net/techtips/reading-cdecl.html">Original</a>
    <h1>How to read C type declarations (2003)</h1>
    
    <div id="readability-page-1" class="page"><div id="pagecontent">

<p>
Even relatively new C programmers have no trouble reading simple
C declarations such as
</p>

<pre><span>int      foo[5];     </span>// <i>foo is an array of 5 ints</i>
<span>char    *foo;        </span>// <i>foo is a pointer to char</i>
<span>double   foo();      </span>// <i>foo is a function returning a double</i>
</pre>

<p>
but as the declarations get a bit more involved, it&#39;s more difficult
to know exactly what you&#39;re looking at.
</p>

<pre><span>char *(*(**foo[][8])())[]; </span>// <i>huh ?????</i>
</pre>

<p>
It turns out that the rules for reading an arbitrarily-complex C variable
declaration are easily learned by even beginning programmers (though how
to actually <i>use</i> the variable so declared may be well out of reach).
</p>

<p>
This Tech Tip shows how to do it.
</p>



<p>
In addition to one variable name, a declaration is composed of one
&#34;basic type&#34; and zero or more &#34;derived types&#34;, and it&#39;s crucial to
understand the distinction between them.
</p>

<p>
The complete list of basic types is:
</p>

<blockquote>
<table>
<tbody><tr>	<td> • <span>char</span>
	</td><td> • <span>signed char</span>
	</td><td> • <span>unsigned char</span>
	</td><td>  	</td></tr>
<tr>	<td> • <span>short</span>
	</td><td> • <span>unsigned short</span>
	</td><td>  
	</td><td>  	</td></tr>
<tr>	<td> • <span>int</span>
	</td><td> • <span>unsigned int</span>
	</td><td>  
	</td><td>  	</td></tr>
<tr>	<td> • <span>long</span>
	</td><td> • <span>unsigned long</span>
	</td><td>  
	</td><td>  	</td></tr>
<tr>	<td> • <span>float</span>
	</td><td> • <span>double</span>
	</td><td> • <span>void</span>
	</td><td>  	</td></tr>
<tr>	<td> • <span>struct <i>tag</i></span>   
	</td><td> • <span>union <i>tag</i></span>   
	</td><td> • <span>enum <i>tag</i></span>   
	</td><td>  	</td></tr>

<tr>	<td> • <span>long long</span>
	</td><td> • <span>unsigned long long </span>
	</td><td> • <span>long double</span>
	</td><td>     <i>ANSI/ISO C only</i>			</td></tr>
</tbody></table>
</blockquote>

<p>
A declaration can have exactly <b>one</b> basic type, and it&#39;s always on
the far left of the expression.
</p>

<p>
The &#34;basic types&#34; are augmented with &#34;derived types&#34;, and C has
three of them:
</p>

<dl>
<dt>
<b>*   pointer to...</b>
</dt>
<dd>This is denoted by the familiar <b>*</b> character, and it should be
self evident that a pointer always has to point <b><i>to</i></b> something.
</dd>

<dt>
<b>[]   array of...</b>
</dt>
<dd>&#34;Array of&#34; can be undimensioned -- <b>[]</b> -- or dimensioned -- <b>[10]</b> --
but the sizes don&#39;t really play significantly into reading a declaration.
We typically include the size in the description. It should be clear
that arrays have to be &#34;arrays <b><i>of</i></b>&#34; something.
</dd>

<dt>
<b>()   function returning...</b>
</dt>
<dd>
This is usually denoted by a pair of parentheses together - <b>()</b> -
though it&#39;s also possible to find a prototype parameter list inside.
Parameters lists (if present) don&#39;t really play into reading a
declaration, and we typically ignore them. We&#39;ll note that parens
used to represent &#34;function returning&#34; are different than those
used for grouping: grouping parens <i>surround</i> the variable name,
while &#34;function returning&#34; parens are always on the right.
</dd>

<dd>
Functions are meaningless unless they <i>return</i> something (and we
accommodate the <b>void</b> type by waving the hand and pretend that
it&#39;s &#34;returning&#34; void).
</dd>

</dl>

<p>
A derived type <i>always</i> modifies something that follows, whether it be
the basic type or another derived type, and to make a declaration read
properly one must always include the preposition (&#34;to&#34;, &#34;of&#34;, &#34;returning&#34;).
Saying &#34;pointer&#34; instead of &#34;pointer to&#34; will make your declarations fall
apart.
</p>

<p>
It&#39;s possible that a type expression may have no derived types (e.g.,
<span><b>&#34;int i&#34;</b></span> describes &#34;i is an int&#34;), or it can have
many. Interpreting the derived types is usually the sticking point when
reading a complex declaration, but this is resolved with operator
precedence in the next section.
</p>



<p>
Almost every C programmer is familiar with the operator precedence
tables, which give rules that say (for instance) multiply and divide
have higher precedence than (&#34;are preformed before&#34;) addition or subtraction,
and parentheses can be used to alter the grouping.
This seems natural for &#34;normal&#34; expressions, but the same rules do
indeed apply to declarations - they are <i>type</i> expressions rather
than <i>computational</i> ones.
</p>

<p>
The &#34;array of&#34; <b>[]</b> and &#34;function returning&#34; <b>()</b> type operators
have higher precedence than &#34;pointer to&#34; <b>*</b>, and this leads to some
fairly straightforward rules for decoding.
</p>

<p>
<i>Always</i> start with the variable name:
</p>

<blockquote>
<b>foo is</b> ...
</blockquote>

<p>
and <i>always</i> end with the basic type:
</p>

<blockquote>
foo is ... <b>int</b>
</blockquote>

<p>
The &#34;filling in the middle&#34; part is usually the trickier part, but it
can be summarize with this rule:
</p>

<blockquote>
&#34;go right when you can, go left when you must&#34;
</blockquote>

<p>
Working your way out from the variable name, honor the precedence rules
and consume derived-type tokens to the right as far as possible without
bumping into a grouping parenthesis. Then go left to the matching paren.
</p>



<p>
We&#39;ll start with a simple example:
</p>

<pre><span>long **foo[7];</span>
</pre>

<p>
We&#39;ll approach this systematically, focusing on just one or two small
part as we develop the description in English. As we do it, we&#39;ll
show the focus of our attention in <span>red</span>,
and <strike>strike out</strike> the parts we&#39;ve finished with.
</p>

<dl>
<dt>
<span>long</span> **<span>foo</span> [7];
</dt>
<dd>
Start with the variable name and end with the basic type:
</dd>
<dd>
<span>foo is</span> ... <span>long</span>
</dd>

<dt>
<span>long</span> ** <span>foo</span><span>[7]</span>;
</dt>

<dd>At this point, the variable name is touching two derived types:
&#34;array of 7&#34; and &#34;pointer to&#34;, and the rule is to go right when you can,
so in this case we consume the &#34;array of 7&#34;
</dd>

<dd>
<span>foo is</span>
<span>array of 7</span>
...
<span>long</span>
</dd>

<dt>
<span>long</span> *<span>*</span> <span>foo[7]</span>;
</dt>
<dd>Now we&#39;ve gone as far right as possible, so the innermost part
is only touching the &#34;pointer to&#34; - consume it.
</dd>

<dd>
<span>foo is</span>
<span>array of 7</span>
<span>pointer to</span>
...
<span>long</span>
</dd>

<dt>
<span>long</span>
<span>*</span>
<span>*foo[7]</span>;
</dt>
<dd>
The innermost part is now only touching a &#34;pointer to&#34;, so consume it also.
</dd>

<dd>
<span>foo is</span>
<span>array of 7</span>
<span>pointer to</span>
<span>pointer to</span>
<span>long</span>
</dd>
</dl>

<p>
This completes the declaration!
</p>



<p>
To really test our skills, we&#39;ll try a very complex declaration that very
well may never appear in real life (indeed: we&#39;re hard-pressed to think
of how this could actually be used). But it shows that the rules scale
to very complex declarations.
</p>

<dl>
<dt>
<span>char</span> *(*(**<span>foo</span> [][8])())[];
</dt>
<dd>
All declaration start out this way: &#34;variable name is .... basictype&#34;
</dd>
<dd>
<span>foo is</span> ... <span>char</span>
</dd>

<dt>
<span>char</span> *(*(**<span>foo</span><span>[]</span> [8])())[];
</dt>
<dd>
The innermost part touches &#34;array of&#34; and &#34;pointer to&#34; - go right.
</dd>
<dd>
<span>foo is</span>
<span>array of </span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> *(*(**<span>foo[]</span><span>[8]</span>)())[];
</dt>
<dd>
It&#39;s common in a declaration to alternate right and left, but this is not the
rule: the rule is to go as far right as we can, and here we find that the innermost
part still touches &#34;array of&#34; and &#34;pointer to&#34;. Again, go right.
</dd>
<dd>
<span>foo is</span>
<span>array of </span>
<span>array of 8</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> *(*(*<span>*</span> <span>foo[][8]</span>)())[];
</dt>
<dd>
Now we&#39;ve hit parenthesis used for grouping, and this halts our march to the right.
So we have to backtrack to collect all the parts to the left (but only as far as
the paren). This consumes the &#34;pointer to&#34;:
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> *(*(<span>*</span> <span>*foo[][8]</span>)())[];
</dt>
<dd>
Again we are backtracking to the left, so we consume the next &#34;pointer to&#34;:
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
<span>pointer to</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> *(*<span>(**foo[][8])</span><span>()</span>)[];
</dt>
<dd>
After consuming the &#34;pointer to&#34; in the previous step, this finished off the
entire parenthesized subexpression, so we &#34;consume&#34; the parens too. This
leaves the innermost part touching &#34;function returning&#34; on the right, and
&#34;pointer to&#34; on the left - go right:
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
<span>pointer to</span>
<span>function returning</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> *(<span>*</span> <span>(**foo[][8])()</span> )[];
</dt>
<dd>
Again we hit grouping parenthesis, so backtrack to the left:
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
<span>pointer to</span>
<span>function returning</span>
<span>pointer to</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> * <span>(*(**foo[][8])())</span><span>[]</span>;
</dt>
<dd>
Consuming the grouping parentheses, we then find that the innermost part is
touching &#34;array of&#34; on the right, and &#34;pointer to&#34; on the left. Go right:
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
<span>pointer to</span>
<span>function returning</span>
<span>pointer to</span>
<span>array of</span>
...
<span>char</span>
</dd>

<dt>
<span>char</span> <span>*</span> <span>(*(**foo[][8])())[]</span>;
</dt>
<dd>
Finally we&#39;re left with only &#34;pointer to&#34; on the left: consume it to
finish the declaration.
</dd>

<dd>
<span>foo is</span>
<span>array of</span>
<span>array of 8</span>
<span>pointer to</span>
<span>pointer to</span>
<span>function returning</span>
<span>pointer to</span>
<span>array of</span>
<span>pointer to</span>
<span>char</span>
</dd>
</dl>


<p>
We have no idea how this variable is useful, but at least we can
describe the type correctly.
</p>

<p>
Note that example won&#39;t compile unless it&#39;s <u>initialized</u> to provide the dimension of the innermost array,
though none of this changes the fact that nobody would ever <i>actually</i> use this for anything:
</p>

<pre>

// explicit initialization
char *(*(**foo[][8])())[] <b>= { 0 };</b>

// implicit init from function call

<b>void myfunction(</b>char *(*(**foo[][8])())[]<b>)</b>
{
	...
}
</pre>



<p>
The C standard describes an &#34;abstract declarator&#34;, which is used when a
type needs to be described but not associated with a variable name. These
occur in two places -- casts, and as arguments to <b>sizeof</b> -- and they
can look intimidating:
</p>

<blockquote>
<span>int (*(*)())()</span>
</blockquote>

<p>
To the obvious question of &#34;where does one start?&#34;, the answer is
&#34;find where the variable name would go, then treat it like a normal
declaration&#34;.  There is only one place where a variable name could
possibly go, and locating it is actually straightforward. Using the
syntax rules, we know that:
</p>

<ul>
<li>to the right of all the &#34;pointer to&#34; derived type tokens
</li><li>to the left of all &#34;array of&#34; derived type tokens
</li><li>to the left of all &#34;function returning&#34; derived type tokens
</li><li>inside all the grouping parentheses
</li></ul>

<p>
Looking at the example, we see that the rightmost &#34;pointer to&#34; sets
one boundary, and the leftmost &#34;function returning&#34; sets another one:
</p>

<blockquote>
<span>
<span>int (*(*</span><span> • ) • </span><span>())()</span>
</span>
</blockquote>

<p>
The red • indicators show the only two places that could possibly hold
the variable name, but the leftmost one is the only one that fits the
&#34;inside the grouping parens&#34; rule. This gives us our declaration as:
</p>

<blockquote>
<span>int (*(*foo)())()</span>
</blockquote>

<p>
which our &#34;normal&#34; rules describe as:
</p>

<blockquote>
<b>foo is a pointer to function returning pointer to function returning int</b>
</blockquote>



<p>
Not all combinations of derived types are allowed, and it&#39;s possible
to create a declaration that perfectly follows the syntax rules but is
nevertheless not legal in C (e.g., <i>syntactically</i> valid but
<i>semantically</i> invalid). We&#39;ll touch on them here.
</p>

<dl>
<dt>Can&#39;t have arrays of functions
</dt>
<dd>Use &#34;array of pointer to function returning...&#34; instead.
</dd>

<dt>Functions can&#39;t return functions
</dt>
<dd>Use &#34;function returning pointer to function returning...&#34; instead.
</dd>

<dt>Functions can&#39;t return arrays
</dt>
<dd>Use &#34;function returning pointer to array of...&#34; instead.
</dd>

<dt>In arrays, only the leftmost [] can be undimensioned
</dt>
<dd>C supports multi-dimensional arrays (e.g.,
<span><b>char foo[1][2][3][4]</b></span>), though in practice
this often suggests poor data structuring. Nevertheless, when there
is more than one array dimension, only the leftmost one is allowed to
be empty.
<span><b>char foo[]</b></span> and
<span><b>char foo[][5]</b></span> are legal, but
<span><b>char foo[5][]</b></span>
is not.
</dd>

<dt>&#34;void&#34; type is restricted
</dt>
<dd>
Since <b>void</b> is a special pseudo-type, a variable with this basic type is
only legal with a final derived type of &#34;pointer to&#34; or &#34;function returning&#34;.
It&#39;s not legal to have &#34;array of void&#34; or to declare a variable of just
type &#34;void&#34; without any derived types.
</dd>

<dd>
<pre><b>void *foo;</b>            // legal
<b>void foo();</b>           // legal
<b>void foo;</b>             // not legal
<b>void foo[];</b>           // not legal
</pre>
</dd>

</dl>



<p>
On the Windows platform, it&#39;s common to decorate a function declaration
with an indication of its <i>calling convention</i>. These tell the compiler
which mechanism should be used to call the function in question, and the
method used to call the function <em>must</em> be the same one which the
function expects. They look like:
</p>

<pre>extern int <b>__cdecl</b> main(int argc, char **argv);

extern BOOL <b>__stdcall</b> DrvQueryDriverInfo(DWORD dwMode, PVOID pBuffer,
                              DWORD cbBuf, PDWORD pcbNeeded);
</pre>

<p>
These decorations are very common in Win32 development, and are
straightforward enough to understand. More information can be found
in <a href="http://www.unixwiz.net/techtips/win32-callconv.html">Unixwiz.net
Tech Tip: Using Win32 calling conventions</a>
</p>

<p>
Where it gets somewhat more tricky is when the calling convention
must be incorporated into a pointer (including via a typedef), because
the tag doesn&#39;t seem to fit into the normal scheme of things. These
are often used (for instance) when dealing with the <b>LoadLibrary()</b>
and <b>GetProcAddress()</b> API calls to call a function from a freshly-loaded
DLL.
</p>

<p>
We commonly see this with typedefs:
</p>

<pre>typedef BOOL (<b>__stdcall</b> *PFNDRVQUERYDRIVERINFO)(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    );

...

/* get the function address from the DLL */
pfnDrvQueryDriverInfo = (PFNDRVRQUERYDRIVERINFO)
	GetProcAddress(hDll, &#34;DrvQueryDriverInfo&#34;)
</pre>

<p>
The calling convention is an attribute of the <i>function</i>,
not the <i>pointer</i>, so in the usual reading puts it after
the pointer but inside the grouping parenthesis:
</p>

<blockquote>
BOOL (<b>__stdcall</b> *foo)(...);
</blockquote>

<p>
is read as:
</p>

<blockquote>
foo is a pointer </blockquote>

<!--
<h1>"const" and "volatile"</h1>

These type qualifiers add a complication because they can apply to
either the basic type or the derived type.

<ul>
<li>If the qualifier is directly before or directly after the basic type,
it modifies the basic type, so these two are identical:

<pre class="codeblock">
int const ...;
const int ...;
</pre>

<li>
These qualifiers are otherwise consumed and read where they are found.
</ul>
-->



</div></div>
  </body>
</html>
