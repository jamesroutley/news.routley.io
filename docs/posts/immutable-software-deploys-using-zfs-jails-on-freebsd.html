<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://conradresearch.com/articles/immutable-software-deploy-zfs-jails">Original</a>
    <h1>Immutable Software Deploys Using ZFS Jails on FreeBSD</h1>
    
    <div id="readability-page-1" class="page"><article>

		
			<img src="https://conradresearch.com/assets/images/articles/immutable-software-deploy-zfs-jails.jpg" alt="Immutable Software Deploys Using ZFS Jails on FreeBSD"/>
		

		
	
		
		
		
	
		<time datetime="2025-11-06">November 6, 2025</time>
	
		<p>FreeBSDâ€™s native support for ZFS snapshots and jails provides a powerful foundation for immutable deployments. By creating a new jail from a ZFS snapshot for every release, we get instant rollâ€‘backs, zeroâ€‘downtime upgrades, and a clean, reproducible environment. This article walks through the (very opinionated) flow that we use. From jails setup through running <a href="https://caddyserver.com/">Caddy</a> as a healthâ€‘checked reverse proxy in front of the jails.</p>

<p>FreeBSD 14+ (or the latest stable release) offers the necessary ZFS and jail primitives. Enabling ZFS with a zpool installed allows cheap, instant cloning. The Caddy v2 binary handles TLS, reverse-proxying, and health checks.</p>

<pre><code>+--------------------+      +------------------------+      +-------------------+
|                    |      |                        |      |                   |
|   Caddy (reverse   | &lt;-&gt;  |  Immutable Jails       | &lt;-&gt;  |  Application      |
|   proxy &amp; health-  |      |  (ZFS snapshot/clone)  |      |  inside each jail |
|   check)           |      |                        |      |                   |
|                    |      |                        |      |                   |
+--------------------+      +------------------------+      +-------------------+
</code></pre>
<ul>
<li>Caddy routes to the currently healthy jail.</li>
<li>Each deployment clones a ZFS snapshot â†’ new jail.</li>
<li>After passing healthâ€‘checks, Caddy reconfigures to the new jail.</li>
</ul>

<p>Create a new loopback network interface for the jails. We&#39;ll use 172.16.0.0/12 which means jails can use any IP address within the range 172.16.0.1 â€“ 172.31.255.254. Then create a new service to manage the loopback interface via a file at &#39;/usr/local/etc/rc.d/lo1&#39; with the following content:</p>
<pre><code>#!/bin/sh
# PROVIDE: lo1
# REQUIRE: NETWORKING
# BEFORE:  jail
# KEYWORD: shutdown

. /etc/rc.subr

name=&#34;lo1&#34;
command=&#34;ifconfig&#34;

start_cmd=&#34;${command} ${name} create &amp;&amp; ${command} ${name} inet 172.16.0.1 netmask 255.240.0.0 up&#34;
stop_cmd=&#34;${command} ${name} down&#34;

run_rc_command &#34;$1&#34;
</code></pre>
<p>Then make the service start at boot and enable it:</p>
<pre><code>chmod +x /usr/local/etc/rc.d/lo1
sysrc lo1_enable=&#34;YES&#34;
service lo1 start
</code></pre>
<p>Now we can go onwards to enabling jails:</p>
<pre><code>sysrc jail_enable=&#34;YES&#34;
sysrc jail_parallel_start=&#34;YES&#34;
</code></pre>
<p>Create a /etc/jail.conf file with the below configurations so that it includes the configurations for each jail.</p>
<blockquote>
<p>NOTE: Each jail configuration should be placed in a separate file in &#39;/etc/jail.conf.d/&#39;.</p>
</blockquote>
<pre><code>.include &#34;/etc/jail.conf.d/*.conf&#34;;
</code></pre>
<p>Create a ZFS dataset mount point and paths for the jails:</p>
<pre><code>zfs create -o mountpoint=/usr/local/jails zroot/jails
</code></pre>
<p>Create child datasets for the jails:</p>
<pre><code># Contains the compressed files of the downloaded userlands.
zfs create zroot/jails/media
# Will contain the templates.
zfs create zroot/jails/templates
# Will contain the containers.
zfs create zroot/jails/containers
</code></pre>

<p>Download the base FreeBSD image and unpack it:</p>
<pre><code># Set environment variable for the FreeBSD version. Note that the cut is to remove the patch level.
export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
zfs create -p zroot/jails/templates/$FREEBSD_VERSION
fetch https://download.freebsd.org/ftp/releases/$(uname -m)/$FREEBSD_VERSION/base.txz -o /usr/local/jails/media/$FREEBSD_VERSION-base.txz
tar -xf /usr/local/jails/media/$FREEBSD_VERSION-base.txz -C /usr/local/jails/templates/$FREEBSD_VERSION --unlink
</code></pre>
<p>Copy critical files to the image template:</p>
<pre><code>cp /etc/resolv.conf /usr/local/jails/templates/$FREEBSD_VERSION/etc/resolv.conf
cp /etc/localtime /usr/local/jails/templates/$FREEBSD_VERSION/etc/localtime
</code></pre>
<p>Update the image template to the latest patch level.</p>
<pre><code>freebsd-update -b /usr/local/jails/templates/$FREEBSD_VERSION fetch install
</code></pre>
<p>Finally, create a ZFS snapshot of the base image template. From this snapshot we we&#39;ll use ZFS clones to create new jails.</p>
<pre><code>zfs snapshot zroot/jails/templates/$FREEBSD_VERSION@base
</code></pre>

<p>Check which ip addresses on the &#39;lo1&#39; loopback interface are in use so that we can assign an available ip address to the new jail.</p>
<pre><code>ifconfig lo1 | grep &#39;inet &#39; | awk &#39;{print $2}&#39;
</code></pre>
<p>Lookup the git repo commit hash for the latest commit.</p>
<pre><code>git ls-remote https://github.com/yourusername/mygitrepo.git | head
</code></pre>
<p>Clone the base image template to create a new jail. We&#39;ll be creating a new jail within our git repo path.</p>
<pre><code>export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
export JAIL_NAME=mygitrepo_gitSHA
zfs clone zroot/jails/templates/$FREEBSD_VERSION@base zroot/jails/containers/$JAIL_NAME
</code></pre>
<p>Create a config file for the jail to be located at &#39;/etc/jail.conf.d/$JAIL_NAME.conf&#39;.</p>
<pre><code>mygitrepo_gitSHA {
	# STARTUP/LOGGING
	exec.start = &#34;/bin/sh /etc/rc&#34;;
	exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
	exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

	# PERMISSIONS
	allow.raw_sockets;
	exec.clean;
	mount.devfs;

	# HOSTNAME/PATH
	host.hostname = &#34;${name}&#34;;
	path = &#34;/usr/local/jails/containers/${name}&#34;;

	# NETWORK. We&#39;re using the lo1 loopback interface that we created for jails to use.
	interface = lo1;
	ip4.addr = 172.16.0.2; # Use an available ip address within the range of the lo1 interface. You can find available ip addresses by running &#34;ifconfig lo1 | grep &#39;inet &#39; | awk &#39;{print $2}&#39;&#34;
}
</code></pre>
<p>Start the jail.</p>
<pre><code>service jail start $JAIL_NAME
</code></pre>
<p>Confirm that the jail&#39;s ipaddress is within the range of the lo1 interface:</p>
<pre><code>jexec $JAIL_NAME ifconfig lo1 | awk &#39;/inet /{print $2}&#39;
</code></pre>
<p>Confirm that the jail is up and what it&#39;s running:</p>
<pre><code>jls
jexec $JAIL_NAME ps aux
</code></pre>

<p>Here is the proof of concept Go hello world binary that we&#39;ll run as a service within the jail.</p>
<pre><code>// main.go
package main

import (
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;net/http&#34;
)

func main() {
	http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &#34;Hello World!&#34;)
	})
	http.HandleFunc(&#34;/up&#34;, func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil))
}
</code></pre>
<p>Build the binary and place it in the jail&#39;s bin directory.</p>
<pre><code>go build main.go
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/bin
cp main /usr/local/jails/containers/$JAIL_NAME/usr/local/bin/main
</code></pre>
<p>Create a service file for the binary.</p>
<pre><code>#!/bin/sh
#
# PROVIDE: main
# REQUIRE: LOGIN
# KEYWORD: shutdown

. /etc/rc.subr

name=&#34;main&#34;
rcvar=&#34;main_enable&#34;

# Path to your Go binary
command=&#34;/usr/local/bin/main&#34;
pidfile=&#34;/var/run/${name}.pid&#34;

# Redirect output to a log file
logfile=&#34;/var/log/${name}.log&#34;

# How to start the process
start_cmd=&#34;${name}_start&#34;
stop_cmd=&#34;${name}_stop&#34;

main_start() {
	echo &#34;Starting ${name}...&#34;
	daemon -p &#34;${pidfile}&#34; -f -o &#34;${logfile}&#34; &#34;${command}&#34;
}

main_stop() {
	echo &#34;Stopping ${name}...&#34;
	if [ -f &#34;${pidfile}&#34; ]; then
		kill &#34;$(cat ${pidfile})&#34; &amp;&amp; rm -f &#34;${pidfile}&#34;
	else
		echo &#34;No pidfile found; process may not be running.&#34;
	fi
}

load_rc_config $name
: ${main_enable:=&#34;NO&#34;}

run_rc_command &#34;$1&#34;
</code></pre>
<p>Copy the service file to the jail&#39;s /etc/rc.d directory and enable it.</p>
<pre><code>mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d
cp /usr/local/etc/rc.d/main /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d/main
jexec $JAIL_NAME chmod +x /usr/local/etc/rc.d/main
jexec $JAIL_NAME sysrc main_enable=YES
jexec $JAIL_NAME service main start
</code></pre>
<p>Setup log rotation so they don&#39;t fill up the disk, and do the initial rotation.</p>
<pre><code>jexec $JAIL_NAME sh -c &#34;echo &#39;/var/log/main.log  root:wheel  644  5  100  *  Z  /var/run/main.pid&#39; &gt;&gt; /etc/newsyslog.conf.d/main.conf&#34;
jexec $JAIL_NAME newsyslog -vF
</code></pre>
<p>Confirm the service is running.</p>
<pre><code>jexec $JAIL_NAME service main status
curl 172.16.0.2:8080 # Use the ip address of the jail.
</code></pre>

<p>Add a &#39;service&#39;, or similar, group to the system if it doesn&#39;t already exist. This group should have permissions to write to the pid and log files. Make sure to use the same group in the next step when we create a user.</p>
<pre><code>pw groupadd service
chown root:service /var/run
chown root:service /var/log
chmod 770 /var/run
chmod 770 /var/log
</code></pre>
<p>Add a user and assign permissions. Make sure to add the user without login capabilities and assign to the &#39;service&#39; group.</p>
<pre><code>pw useradd caddy -d /nonexistent -s /sbin/nologin -c &#34;Caddy Service Account&#34; -g service
</code></pre>
<blockquote>
<p>Note: We&#39;re running Caddy behind a Cloudflare Tunnel on port 8080. If you&#39;re not and using a port below 1024 then you&#39;ll need to setup security/portacl-rc to enable privileged port binding, and configure for user &#39;caddy&#39;. This will allow the caddy user to bind to ports below 1024.</p>
<pre><code>pkg install security/portacl-rc
sysrc portacl_users+=caddy
sysrc portacl_user_caddy_tcp=&#34;http https&#34;
sysrc portacl_user_caddy_udp=&#34;https&#34;
service portacl enable
service portacl start
</code></pre>
</blockquote>
<p>Install <a href="https://caddyserver.com/">Caddy</a>.</p>
<pre><code>cd /usr/ports/www/caddy
make install clean
</code></pre>
<p>Change the ownership of the caddy binary and required files to the caddy user.</p>
<pre><code>chown caddy:service /usr/local/bin/caddy
chmod 740 /usr/local/bin/caddy
chown -R caddy:service /var/log/caddy
chown -R caddy:service /usr/local/etc/caddy
chown -R caddy:service /var/db/caddy
</code></pre>
<p>Setup log rotation so they don&#39;t fill up the disk.</p>
<pre><code>echo &#39;/var/log/caddy.log  root:wheel  644  5  100  *  Z  /var/run/caddy.pid&#39; &gt;&gt; /etc/newsyslog.conf.d/caddy.conf
newsyslog -vF
</code></pre>
<p>Add the caddy service to the system startup and make sure it runs as the caddy user.</p>
<pre><code>sysrc -f /etc/rc.conf caddy_enable=&#34;YES&#34;
sysrc -f /etc/rc.conf caddy_user=&#34;caddy&#34;
sysrc -f /etc/rc.conf caddy_group=&#34;service&#34;
</code></pre>
<p>Caddy reads the configuration file at &#39;/usr/local/etc/caddy/Caddyfile&#39;.</p>
<blockquote>
<p>Important: We&#39;re only disabling automatic HTTPS because we&#39;re running behind a Cloudflare Tunnel. If that&#39;s not the case, you should enable automatic HTTPS by removing the &#39;auto_https off&#39; line.</p>
</blockquote>
<pre><code># /usr/local/etc/caddy/Caddyfile
{
	auto_https off # Note: Disable automatic HTTPS since we&#39;re running behind a Cloudflare Tunnel.
}

:8080 {

	# Matcher and reverse proxy for serviceA.null.live.
	@serviceA host serviceA.null.live # Change the hostname to your actual hostname.
	reverse_proxy @serviceA 172.16.0.2:8080 {
		health_uri /up
		health_interval 10s
		health_timeout 5s
	}

	# Matcher and reverse proxy for serviceB.null.live.
	@serviceB host serviceB.null.live # Change the hostname to your actual hostname.
	reverse_proxy @serviceB 172.16.0.3:8080 {
		health_uri /up
		health_interval 10s
		health_timeout 5s
	}
}
</code></pre>

<p>Create a config file for the jail to be located at &#39;/etc/jail.conf.d/$JAIL_NAME.conf&#39;.</p>
<pre><code>ifconfig lo1 | grep &#39;inet &#39; | awk &#39;{print $2}&#39;
</code></pre>
<pre><code>mygitrepo_gitSHA {
	# STARTUP/LOGGING
	exec.start = &#34;/bin/sh /etc/rc&#34;;
	exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
	exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

	# PERMISSIONS
	allow.raw_sockets;
	exec.clean;
	mount.devfs;

	# HOSTNAME/PATH
	host.hostname = &#34;${name}&#34;;
	path = &#34;/usr/local/jails/containers/${name}&#34;;

	# NETWORK. We&#39;re using the lo1 loopback interface that we created for jails to use.
	interface = lo1;
	ip4.addr = 172.16.0.3; # Use the ip address we found in the previous step.
}
</code></pre>
<p>Create a new jail. We name our jail using the format: mygitrepo_gitSHA. For the repo of the application being deployed. This makes it easy to track which version of the application is running in each jail. The last line is used to confirm the jail is running.</p>
<pre><code>git ls-remote https://github.com/yourusername/mygitrepo.git | head
export FREEBSD_VERSION=$(freebsd-version | cut -d- -f1-2)
export JAIL_NAME=mygitrepo_gitSHA
export SERVICE_NAME=conradresearchcom # Note: &#39;-&#39; are not allowed in service names.
zfs clone zroot/jails/templates/$FREEBSD_VERSION@base zroot/jails/containers/$JAIL_NAME

# Copy the binary of the application to the jail. We&#39;ll use our &#39;main&#39; demo app from previous steps.
go build main.go
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/bin
cp $SERVICE_NAME /usr/local/jails/containers/$JAIL_NAME/usr/local/bin/$SERVICE_NAME

# Copy the rc.d script to the jail.
mkdir -p /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d
cp $SERVICE_NAME /usr/local/jails/containers/$JAIL_NAME/usr/local/etc/rc.d/$SERVICE_NAME

# Start the jail.
service jail start $JAIL_NAME
jexec $JAIL_NAME chmod +x /usr/local/etc/rc.d/$SERVICE_NAME
jexec $JAIL_NAME sysrc ${SERVICE_NAME}_enable=YES
jexec $JAIL_NAME service $SERVICE_NAME start
while ! curl -s -o /dev/null -w &#34;%{http_code}&#34; http://172.16.0.3:8080/up; do sleep 1; done
</code></pre>
<p>Using your favorite text editor, update the Caddy configuration at &#39;/usr/local/etc/caddy/Caddyfile&#39; to point to the new jail via updating the jail&#39;s IP address to the new jail&#39;s IP address. Then run the following command to reload Caddy:</p>
<pre><code>service caddy reload
</code></pre>

<p>By combining <strong>ZFS snapshots</strong>, <strong>FreeBSD jails</strong>, and a <strong>Caddy</strong> reverseâ€‘proxy, you get:</p>
<ul>
<li><strong>Zeroâ€‘downtime</strong> upgrades.</li>
<li><strong>Instant rollbacks</strong>.</li>
<li>A <strong>predictable</strong> environment that can be reproduced at any time.</li>
</ul>
<p>Give it a try, tweak the scripts for your own stack, and enjoy the peace of mind that comes with immutable infrastructure.</p>
<p>Cheers ðŸ¥‚</p>


	</article></div>
  </body>
</html>
