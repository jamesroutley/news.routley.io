<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://angg.twu.net/eev-article.html">Original</a>
    <h1>Emacs and Eev, Or: How to Automate Almost Everything</h1>
    
    <div id="readability-page-1" class="page"><div><tbody><tr>
  <td>

    </td>
  <td><h3>Emacs and eev, or: How to Automate Almost Everything</h3>





<p><a href="http://angg.twu.net/">Eduardo Ochs</a>

</p>



<p><span>NOTE:</span>
   This document is <SPAN color="red">unfinished and VERY obsolete</SPAN>!

   
</p>






<blockquote>
<small><h2><a name="abstract"></a><a href="#.abstract">Abstract</a></h2>



<p>Interacting with programs with command-line interfaces always
    involves a bit of line editing, and each CLI program tends to
    implement independently its own minimalistic editing features. We
    show a way of centralizing these editing tasks by making these
    programs receive commands that are prepared, and sent from, Emacs.
    The resulting system is a kind of Emacs- and Emacs Lisp-based
    “universal scripting language” in which commands can be sent to
    both external programs and to Emacs itself either in blocks or
    step-by-step under very fine control from the user.
  </p>

  

<p>Note: this is a working draft that has many pieces missing and
     needs urgent revision on the pieces it has. Current version: (see
     top). Newer versions are being uploaded to
     <a href="http://angg.twu.net/eev-current/article/">http://angg.twu.net/eev-current/article/</a>, and two animations
     (in Flash) showing eev at work can be found at:
     <a href="http://angg.twu.net/eev-current/anim/channels.anim.html">http://angg.twu.net/eev-current/anim/channels.anim.html</a> and
     <a href="http://angg.twu.net/eev-current/anim/gdb.anim.html">http://angg.twu.net/eev-current/anim/gdb.anim.html</a>.
  </p>
  
</small>
</blockquote>


<strong>Quick index:</strong>
<ul>
<li><a name=".abstract"></a><a href="#abstract">Abstract</a>
</li><li><a name=".three-kinds-of-interfaces"></a><a href="#three-kinds-of-interfaces">1. Three kinds of interfaces</a>
</li><li><a name=".one-thing-well"></a><a href="#one-thing-well">2. “Make each program do one thing well”</a>
</li><li><a name=".making-progs-receive-cmds"></a><a href="#making-progs-receive-cmds">3. Making programs receive commands</a>
</li><li><a name=".sending-commands"></a><a href="#sending-commands">4. Sending commands</a>
</li><li><a name=".hyperlinks"></a><a href="#hyperlinks">5. Hyperlinks</a>
</li><li><a name=".shorter-hyperlinks"></a><a href="#shorter-hyperlinks">6. Shorter Hyperlinks</a>
</li><li><a name=".forward-and-back"></a><a href="#forward-and-back">7. Keys for following hyperlinks and for going back</a>
</li><li><a name=".dangerous-hyperlinks"></a><a href="#dangerous-hyperlinks">8. Dangerous hyperlinks</a>
</li><li><a name=".generating-hyperlinks"></a><a href="#generating-hyperlinks">9. Generating Hyperlinks</a>
</li><li><a name=".returning"></a><a href="#returning">10. Returning from Hyperlinks</a>
</li><li><a name=".local-copies"></a><a href="#local-copies">11. Local copies of files from the internet</a>
</li><li><a name=".glyphs"></a><a href="#glyphs">12. Glyphs</a>
</li><li><a name=".compose-pairs"></a><a href="#compose-pairs">13. Compose Pairs</a>
</li><li><a name=".delimited-regions"></a><a href="#delimited-regions">14. Delimited regions</a>
</li><li><a name=".channels"></a><a href="#channels">15. Communication channels</a>
</li><li><a name=".channels-implementation"></a><a href="#channels-implementation">15.1. The Implementation of Communication Channels</a>
</li><li><a name=".anchors"></a><a href="#anchors">16. Anchors</a>
</li><li><a name=".e-scripts"></a><a href="#e-scripts">17. E-scripts</a>
</li><li><a name=".splitting-eev.el"></a><a href="#splitting-eev.el">18. Splitting eev.el</a>
</li><li><a name=".eesteps"></a><a href="#eesteps">19. Steps</a>
</li><li><a name=".eepitch"></a><a href="#eepitch">20. Sending lines to processes running in Emacs buffers </a>
</li><li><a name=".eepitch-unprepared"></a><a href="#eepitch-unprepared">21. Using eepitch to control unprepared shells</a>
</li><li><a name=".eepitch-gud"></a><a href="#eepitch-gud">22. Controlling debuggers with eepitch</a>
</li><li><a name=".little-dbg-langs"></a><a href="#little-dbg-langs">24. Two little languages for debugging</a>
</li><li><a name=".inspecting-data"></a><a href="#inspecting-data">25. Inspecting data in running programs</a>
</li><li><a name=".eepitch-gdb"></a><a href="#eepitch-gdb">23. E-scripting GDB with eepitch</a>
</li><li><a name=".big-modular-e-scripts"></a><a href="#big-modular-e-scripts">26. Big Modular E-scripts</a>
</li><li><a name=".iskidip"></a><a href="#iskidip">27. Internet Skills for Disconnected People</a>
</li><li><a name=".availability"></a><a href="#availability">28. Availability and Resources</a>
</li><li><a name=".acknowledgments"></a><a href="#acknowledgments">Acknowledgments</a>
</li><li><a name=".references"></a><a href="#references">References</a>
</li></ul>
<h2><a name="three-kinds-of-interfaces"></a><a href="#.three-kinds-of-interfaces">1. Three kinds of interfaces</a></h2>



<p>Interactive programs in a Un*x system(1) can have basically three
kinds of interfaces: they can be mouse-oriented, like most programs
with graphical interfaces nowadays, in which commands are given by
clicking with the mouse; they can be character-oriented, like most
editors and mail readers, in which most commands are single keys or
short sequences of keys; and they can be line-oriented, as, for
example, shells are: in a shell commands are given by editing a full
line and then typing “enter” to process that line.</p>



<p>It is commonplace to classify computer users in a spectrum where
the “users” are in one extreme and the “programmers” are in the
other; the “users” tend to use only mouse-oriented and
character-oriented programs, and the “programmers” only
character-oriented and line-oriented programs.</p>



<p>In this paper we will show a way to “automate” interactions with
line-oriented programs, and, but not so well, to character-oriented
programs; more precisely, it is a way to edit commands for these
programs in a single central place --- Emacs --- and then send them to
the programs; re-sending the same commands afterwards, with or without
modifications, then becomes very easy.</p>



<p>This way (“e-scripts”) can not be used to send commands to
mouse-oriented programs --- at least not without introducing several
new tricks. But “programmers” using Un*x systems usually see most
mouse-oriented programs --- except for a few that are <i>intrinsically</i> mouse-oriented, like drawing programs --- as being just
wrappers around line-oriented programs than perform the same tasks
with different interfaces; and so, most mouse-oriented programs “do
not matter”, and our method of automating interactions using
e-scripts can be used to automate “almost everything”; hence the
title of the paper.</p>




<p>(1): Actually we are more interested in GNU systems than in
“real” Unix systems; the reasons will become clear in the section
nnn. By the way: the term “Unix” is Copyright (C) Bell Labs).</p>




<h2><a name="one-thing-well"></a><a href="#.one-thing-well">2. “Make each program do one thing well”</a></h2>



<p>One of the tenets of the Unix philosophy is that each program
should do one thing, and do it well; this is a good design rule for
Unix programs because the system makes it easy to invoke external
programs to perform tasks, and to connect programs.</p>



<p>Some of parts of a Unix system are more like “meta-programs” or
“sub-programs” than like self-contained programs that do some
clearly useful task by themselves. Shells, for example, are
meta-programs: their main function is to allow users to invoke “real
programs” and to connect these programs using pipes, redirections,
control structures (if, for, etc) and Unix “signals”. On the other
hand, libraries are sub-programs: for example, on GNU systems there&#39;s
a library called GNU readline that line-oriented programs can use to
get input; if a program, say, bc (a calculator) gets its input by
calling <code>readline(...)</code> instead of using the more basic function
<code>fgets(...)</code> then its line-oriented interface will have a little
more functionality: it will allow the user to do some minimal editing
in the current line, and also to recall, edit and issue again some of
the latest commands given.</p>




<h2><a name="making-progs-receive-cmds"></a><a href="#.making-progs-receive-cmds">3. Making programs receive commands</a></h2>



<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html">code</a>, <a href="http://angg.twu.net/eev-current/eev-mini.el.html#find-fline">miniature</a>,
      <a href="http://angg.twu.net/eev-current/INSTALL.html">INSTALL</a>, 
      <a href="http://angg.twu.net/eev-current/eev-rctool.html">eev-rctool</a>
]</i></p></small>



<p>Many line-oriented programs allow “scripting”, which means
executing commands from a file. For example, in most shells we can say
“<code>source ~/ee.sh</code>”, and the shell will then execute the commands
in the file <code>~/ee.sh</code>. There are other ways of executing commands
from a file --- like “<code>sh ~/ee.sh</code>” --- but the one with “<code>source</code>” is the one that we&#39;ll be more interested in, because it is
closer to running the commands in <code>~/ee.sh</code> one by one by hand: for
example, with “<code>source ~/ee.sh</code>” the commands that change
parameters of the shell --- like the current directory and the
environment variables --- will work in the obvious way, while with
“<code>sh ~/ee.sh</code>” they would only change the parameters of a
temporary sub-shell; the current directory and the environment
variables of the present shell would be “protected”.</p>



<p>So, it is possible to prepare commands for a shell (or for
scriptable line-oriented programs; for arbitrary line-oriented
programs see the section nnn) in several ways: by typing them at the
shell&#39;s interface --- and if the shell uses readline its interface can
be reasonably friendly --- or, alternatively, by using a text editor
to edit a file, say, <code>~/ee.sh</code>, and by then “executing” that file
with “<code>source ~/ee.sh</code>”. “<code>source ~/ee.sh</code>” is a lot of
keystrokes, but that can be shortened if we can define a shell
function: by putting

<div>
<pre>function ee () { source ~/ee.sh; }
</pre>
</div>


in the shell&#39;s initialization file (<code>~/.bashrc</code>, <code>~/.zshrc</code>,
...) we can reduce “<code>source ~/ee.sh</code>” to just “<code>ee</code>”: <code>e</code>, <code>e</code>, enter --- three keystrokes.</p>



<p>We just saw how a shell --- or, by the way, any line-oriented
program in which we can define an `ee&#39; function like we did for the
shell --- can receive commands prepared in an external editor and
stored in a certain file; let&#39;s refer to that file, <code>~/ee.sh</code>, as a
“temporary script file”. Now it remains to see how an external text
editor can “send commands to the shell”, i.e., how to make the
editor save some commands in a temporary script file in a convenient
way, that is, without using too many keystrokes...</p>




<h2><a name="sending-commands"></a><a href="#.sending-commands">4. Sending commands</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-prepared-intro.html">find-prepared-intro</a><a href="http://angg.twu.net/eev-intros/find-prepared-intro.html">)</a></code></p></small>



<p>GNU Emacs, “the extensible, self-documenting text-editor” ([S79]), does at least two things very well: one is to edit text, and so
it can be used to edit temporary scripts, and thus to send commands to
shells and to line-oriented programs with `ee&#39; functions; and the
other one is to run Lisp. Lisp is a powerful programming language, and
(at least in principle!) any action or series of actions can be
expressed as a program in Lisp; the first thing that we want to do is
a way to mark a region of a text and “send it as commands to a
shell”, by saving it in a temporary script file. We implement that in
two ways:

<div>
<pre> 1: (defun ee (s e)
 2:   &#34;Save the region in a temporary script&#34;
 3:   (interactive &#34;r&#34;)
 4:   (write-region s e &#34;~/ee.sh&#34;))
 5:
 6: (defun eev (s e)
 7:   &#34;Like `ee&#39;, but the script executes in verbose mode&#34;
 8:   (interactive &#34;r&#34;)
 9:   (write-region
10:    (concat &#34;set -v\n&#34; (buffer-substring s e)
11:            &#34;\nset+v&#34;)
12:    nil &#34;~/ee.sh&#34;))
</pre>
</div>


`<code>ee</code>&#39; (the name stands for something like `emacs-execute&#39;) just
saves the currently-marked region of text to <code>~/ee.sh</code>; `<code>eev</code>&#39;
(for something like `emacs-execute-verbose&#39;) does the same but adding
to the beginning of the temporary script a command to put the shell in
“verbose mode”, where each command is displayed before being
executed, and also adding at the end an command to leave verbose mode.</p>



<p>We can now use `<code>ee</code>&#39; and `<code>eev</code>&#39; to send a block of commands
to a shell: just select a region and then run `<code>ee</code>&#39; or `<code>eev</code>&#39;.
More precisely: mark a region, that is, put the cursor at one of the
extremities of the region, then type <code>C-SPC</code> to set Emacs&#39;s
“mark” to that position, then go to other extremity of the region
and type <code>M-x eev</code> (<code>C-SPC</code> and <code>M-x</code> are Emacs&#39;s notations
for Control-Space and Alt-x, a.k.a. “Meta-x”). After doing that, go
to a shell and make it “receive these commands”, by typing `<code>ee</code>&#39;.</p>




<h2><a name="hyperlinks"></a><a href="#.hyperlinks">5. Hyperlinks</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-links-intro.html">find-links-intro</a><a href="http://angg.twu.net/eev-intros/find-links-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html#find-fline">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini.el.html#find-fline">miniature</a>]</i></p></small>



<p>When we are using a system like *NIX, in a part of the time we are
using programs with which we are perfectly familiar, and in the rest
of the time we are using things that we don&#39;t understand completely
and that make us have to access the documentation from time to time.
In a GNU system the documentation is all on-line, and the steps needed
to access any piece of documentation can be automated. We can use
Emacs Lisp “one-liners” to create “hyperlinks” to files:</p>

<div>
<pre>A: (info &#34;(emacs)Lisp Eval&#34;)
B: (find-file &#34;~/usrc/busybox-1.00/shell/ash.c&#34;)
C: (find-file &#34;/usr/share/emacs/21.4/lisp/info.el&#34;)
</pre>
</div>




<p>These expressions, when executed --- which is done by placing the
cursor after them and then typing <code>C-x C-e</code>, or, equivalently, <code>M-x eval-last-sexp</code> --- will (A) open a page of Emacs manual (the
manual is a set of files in “Info” format), (B) open the source file
`<code>shell/ash.c</code>&#39; of a program called busybox, and (C) open the file
`<code>info.el</code>&#39; from the Emacs sources, respectively. As some of these
files and pages can be very big, these hyperlinks are not yet very
satisfactory: we want ways to not only open these files and pages but
also to “point to specific positions”, i.e., to make the cursor go
to these positions automatically. We can do that by defining some new
hyperlink functions, that are invoked like this:</p>

<div>
<pre>A&#39;: (find-node &#34;(emacs)Lisp Eval&#34; &#34;C-x C-e&#34;)
B&#39;: (find-fline &#34;~/usrc/busybox-1.00/shell/ash.c&#34;
                &#34;void\nevalpipe&#34;)
C&#39;: (find-fline &#34;/usr/share/emacs/21.4/lisp/info.el&#34;
                &#34;defun info&#34;)
</pre>
</div>




<p>The convention is that these “extended hyperlink functions” have
names like `<code>find-xxxnode</code>&#39;, `<code>find-xxxfile</code>&#39;, or `<code>find-xxxyyy</code>&#39;; as the name `<code>find-file</code>&#39; was already taken by a
standard Emacs function we had to use `<code>find-fline</code>&#39; for ours.</p>



<p>Here are the definitions of `find-node&#39; and `find-fline&#39;:</p>

<div>
<pre>14: (defun ee-goto-position (&amp;optional pos-spec)
15:   &#34;If POS-SPEC is a string search for its first
16:    occurrence in the file; if it is a number go to the
17:    POS-SPECth line; if it is nil, don&#39;t move.&#34;
18:   (cond ((null pos-spec))
19:         ((numberp pos-spec)
20:          (goto-char (point-min))
21:          (forward-line (1- pos-spec)))
22:         ((stringp pos-spec)
23:          (goto-char (point-min))
24:          (search-forward pos-spec))
25:         (t (error &#34;Invalid pos-spec: %S&#34; pos-spec))))
26:
27: (defun find-fline (fname &amp;optional pos-spec)
28:   &#34;Like (find-file FNAME), but accepts a POS-SPEC&#34;
29:   (find-file fname)
20:   (ee-goto-position pos-spec))
31:
32: (defun find-node (node &amp;optional pos-spec)
33:   &#34;Like (info NODE), but accepts a POS-SPEC&#34;
34:   (info node)
35:   (ee-goto-position pos-spec)))
</pre>
</div>




<p>Now consider what happens when we send to a shell a sequence of
commands like this one:</p>

<div>
<pre># (find-node &#34;(gawk)Fields&#34;)
seq 4 9 | gawk &#39;{print $1, $1*$1}&#39;
</pre>
</div>






<p>the shell ignores the first line because of the `<code>#</code>&#39;, that
makes the shell treat that line as a comment; but when we are editing
that in Emacs we can execute the `<code>(find-node ...)</code>&#39; with <code>C-x
C-e</code>. Hyperlinks can be mixed with shell code --- they just need to be
marked as comments.</p>



<p>Note: the actual definitions of `<code>eev</code>&#39;, `<code>ee-goto-position</code>&#39;, `<code>find-fline</code>&#39; and `<code>find-node</code>&#39; in eev&#39;s
source code are a bit more complex than the code in the listings above
(lines 6--12 in the previous section and 14--35 in the current
section). In all the (few) occasions in this paper where we will
present the source code of eev&#39;s functions what will be shown are
versions that implement only the “essence” of those functions,
stripped down of all extra functionality. The point that we wanted to
stress with those listings is how natural it is to use Emacs in a
certain way, as an editor for commands for external programs, and with
these plain-text hyperlinks that can be put almost anywhere: the
essence of that idea can be implemented in 30 lines of Lisp and one or
two lines of shell code.</p>



<p>(See also: the section about <a href="#e-scripts">e-scripts</a>).</p>





<h2><a name="shorter-hyperlinks"></a><a href="#.shorter-hyperlinks">6. Shorter Hyperlinks</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-code-c-d-intro.html">find-code-c-d-intro</a><a href="http://angg.twu.net/eev-intros/find-code-c-d-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html#code-c-d">code</a>, <a href="http://angg.twu.net/eev-current/eev-mini.el.html#code-c-d">miniature</a>]</i></p></small>



<p>The hyperlinks in lines <code>A&#39;&#39;</code>, <code>B&#39;&#39;</code> and <code>C&#39;&#39;</code>, below,</p>

<div>
<pre>A&#39;&#39;: (find-enode &#34;Lisp Eval&#34; &#34;C-x C-e&#34;)
B&#39;&#39;: (find-busyboxfile &#34;shell/ash.c&#34; &#34;void\nevalpipe&#34;)
C&#39;&#39;: (find-efile &#34;info.el&#34; &#34;defun info&#34;)
</pre>
</div>




<p>are equivalent to the ones labeled <code>A&#39;</code>, <code>B&#39;</code>, <code>C&#39;</code> in
Section 5, but are a bit shorter, and they hide details like Emacs&#39;s
path and the version of BusyBox; if we switch to newer versions of
Emacs and BusyBox we only need to change the definitions of `<code>find-busyboxfile</code>&#39; and `<code>find-efile</code>&#39; to update the hyperlinks.
Usually not many things change from one version of a package to
another, so most hyperlinks continue to work after the update.</p>



<p>Eev defines a function called `<code>code-c-d</code>&#39; that makes defining
functions like `<code>find-enode</code>&#39;, `<code>find-busyboxfile</code>&#39; and `<code>find-efile</code>&#39; much easier:</p>

<div>
<pre>(code-c-d &#34;busybox&#34; &#34;~/usrc/busybox-1.00/&#34;)
(code-c-d &#34;e&#34; &#34;/usr/share/emacs/21.4/lisp/&#34; &#34;emacs&#34;)
</pre>
</div>




<p>The arguments for `<code>code-c-d</code>&#39; are (1) a “code” (the “<code>xxx</code>” in a “<code>find-xxxfile</code>”), (2) a directory, and optionally
(3) the name of a manual in Info format. The definition of <code>code-c-d</code> is not very interesting, so we won&#39;t show it here.</p>





<h2><a name="forward-and-back"></a><a href="#.forward-and-back">7. Keys for following hyperlinks and for going back</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-eval-intro.html">find-eval-intro</a><a href="http://angg.twu.net/eev-intros/find-eval-intro.html">)</a></code></p></small>



<p>(Rewrite this; mention M-k, M-K, `to&#39; and the (disabled) stubs to
  implement a `back&#39; command)</p>



<p>It is so common to have Lisp hyperlinks that extend from some
position in a line --- usually after a comment sign --- to the end of
the line that eev implements a special key for executing these
hyperlinks: the effect of typing M-e (when eev is installed and “eev
mode” is on) is roughly the same of first going to the end of the
line and then typing C-x C-e; that is, M-e does the same as the key
sequence C-e C-x C-e(1).</p>



<p>(There are many other kinds of hyperlinks. Examples?)</p>



<p>(1) The main difference between <code>M-e</code> and <code>C-e C-x C-e</code> is
how they behave when called with numeric “prefix arguments”: for
example, <code>M-0 M-e</code> highlights temporarily the Lisp expression
instead of executing it and <code>M-4 M-e</code> executes it with some
debugging flags turned on, while <code>C-x C-e</code> when called with any
prefix argument inserts the result of the expression at the cursor
instead of just showing it at the echo area.</p>





<h2><a name="dangerous-hyperlinks"></a><a href="#.dangerous-hyperlinks">8. Dangerous hyperlinks</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html#find-sh">code</a>, <a href="http://angg.twu.net/eev-current/eev-mini.el.html#find-sh">miniature</a>]</i></p></small>



<p>Note that these “hyperlinks” can do very dangerous things. If we
start to execute blindly every Lisp expression we see just because it
can do something interesting or take us to an interesting place then
we can end up running something like:

<div>
<pre>(shell-c ommand &#34;rm -Rf ~&#34;)
</pre>
</div>


which destroy all files in our home directory; not a good idea.
Hyperlinks ought to be safer than that... </p>



<p>The modern approach to safety in hyperlinks --- the one found in
web browsers, for example --- is that following a hyperlink can
execute only a few kinds of actions, all known to be safe; the
“target” of a hyperlink is something of the form <code>http://...</code>,
<code>ftp://...</code>, <code>file://...</code>, <code>info://...</code>, <code>mailto:...</code> or
at worst like <code>javascript:...</code>; none of these kinds of actions can
even erase our files. That approach limits a lot what hyperlinks can
do, but makes it harmless to hide the hyperlink action and display
only some descriptive text.</p>



<p>Eev&#39;s approach is the opposite of that. I wrote the first functions
of eev in my first weeks after installing GNU/Linux in my home machine
and starting using GNU Emacs, in 1994; before that I was using mostly
Forth (on MS-DOS), and I hadn&#39;t had a lot of exposure to *nix systems
by then --- in particular, I had tried to understand *nix&#39;s notions of
user IDs and file ownerships and permissions, and I felt that they
were a thick layer of complexity that I wasn&#39;t being able to get
through.</p>



<p>Forth&#39;s attitude is more like ``the user knows what he&#39;s doing&#39;&#39;;
the system is kept very simple, so that understanding all the
consequences of an action is not very hard. If the user wants to
change a byte in a critical memory position and crash the machine he
can do that, and partly because of that simplicity bringing the
machine up again didn&#39;t use to take more than one minute (in the good
old days, of course). Forth people developed good backup strategies to
cope with the insecurities, and --- as strange as that might sound
nowadays, where all machines are connected and multi-user and crackers
abound --- using the system in the Forth way was productive and fun.</p>



<p>*NIX systems are not like Forth, but when I started using them I
was accustomed to this idea of achieving simplicity through the lack
of safeguards, and eev reflects that. The only thing that keeps eev&#39;s
hyperlinks reasonably safe is <i>transparency</i>: the code that a
hyperlink executes is so visible that it is hard to mistake a
dangerous Lisp expression for a “real” hyperlink. Also, all the safe
hyperlink functions implemented by eev start with `<code>find-</code>&#39;, and
all the `<code>find-</code>&#39; functions in eev are safe, except for those with
names like `<code>find-xxxsh</code>&#39; and `<code>find-xxxsh0</code>: for example,

<div>
<pre>(find-sh &#34;wget --help&#34; &#34;recursive download&#34;)
</pre>
</div>


executes “<code>wget --help</code>”, puts the output of that in an Emacs
buffer and then jumps to the first occurrence of the string “<code>recursive download</code>” there; other `<code>find-xxxsh</code>&#39; functions are
variations on that that execute some extra shell commands before
executing the first argument --- typically either switching to another
directory or loading an initialization file, like <code>~/.bashrc</code> or
<code>~/.zshrc</code>. The `<code>find-xxxsh0</code>&#39; functions are similar to their
`<code>find-xxxsh</code>&#39; counterparts, but instead of creating a buffer with
their output they just show it at Emacs&#39;s echo area and they use only
the first argument and ignore the others (the pos-spec).</p>





<h2><a name="generating-hyperlinks"></a><a href="#.generating-hyperlinks">9. Generating Hyperlinks</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-insert.el.html">code</a>]</i></p></small>



<p>Do we need to remember the names of all hyperlinks functions, like
<code>find-fline</code> and <code>find-node</code>? Do we need to type the code for
each hyperlink in full by hand? The answers are “no” and “no”.</p>



<p>Eev implements several functions that create temporary buffers
containing hyperlinks, that can then be cut and pasted to other
buffers. For example, `<code>M-h M-f</code>&#39; creates links about an Emacs Lisp
function: typing `<code>M-h M-f</code>&#39; displays a prompt in a minibuffer
asking for the name of an Elisp function; if we type, say, `<code>find-file</code>&#39; there (note: name completion with the TAB key works in
that prompt) we get a buffer like the one in figure 1.</p>

<div>
<pre> _________________________________________________________ 
|# (find-efunction-links &#39;find-file)                      |
|                                                         |
|# (where-is &#39;find-file)                                  |
|# (describe-function &#39;find-file)                         |
|# (find-efunctiondescr &#39;find-file)                       |
|# (find-efunction &#39;find-file)                            |
|# (find-efunctionpp &#39;find-file)                          |
|# (find-efunctiond &#39;find-file)                           |
|# (find-eCfunction &#39;find-file)                           |
|# (find-estring (documentation &#39;find-file))              |
|# (find-estring (documentation &#39;find-file t))            |
|                                                         |
|# (Info-goto-emacs-command-node &#39;find-file)              |
|# (find-enode &#34;Command Index&#34; &#34;* find-file:&#34;)            |
|# (find-elnode &#34;Index&#34; &#34;* find-file:&#34;)                   |
|                                                         |
|                                                         |
|                                                         |
|--:**  *Elisp hyperlinks*   All L18    (Fundamental)-----|
|_________________________________________________________|

 Figure 1: the result of typing M-h M-f find-file
</pre>
</div>





<p>The first line of that buffer is a hyperlink to that
dynamically-generated page of hyperlinks. Its function --- `<code>find-efunction-links</code>&#39; --- has a long name that is hard to remember,
but there&#39;s a shorter link that will do the same job:</p>


<a name="eek"></a>
<div>
<pre>(eek &#34;M-h M-f find-file&#34;)
</pre>
</div>




<p>The argument to `eek&#39; is a string describing a sequence of keys in
a certain verbose format, and the effect of running, say, <code>(eek
&#34;M-h M-f find-file&#34;)</code> is the same as of typing `<code>M-h M-f
find-file</code>&#39;.</p>



<p>((M-h is a prefix; <code>(eek &#34;M-h C-h&#34;)</code> shows all the sequences
with the same prefix.))</p>



<p>((Exceptions: M-h M-c, M-h M-2, M-h M-y. Show examples
of how to edit hyperlinks with M-h M-2 and M-h M-y.))</p>



<p>((Mention hyperlinks about a key sequence? <code>(eek &#34;M-h M-k C-x
C-f&#34;)</code>))</p>
 


<p>((Mention hyperlinks about a Debian package? <code>(eek &#34;M-h M-d
bash&#34;)</code>))</p>




<h2><a name="returning"></a><a href="#.returning">10. Returning from Hyperlinks</a></h2>



<p>((Mention M-k to kill the current buffer, and how Emacs asks for
confirmation when it&#39;s a file and it&#39;s modified))</p>



<p>((Mention M-K for burying the current buffer))</p>



<p>((Mention what to do in the cases where a hyperlink points to the
current buffer (section 16); there used to be an “ee-back” function
bound to M-B, but to reactivate it I would have to add back some ugly
code to `to&#39;... (by the way, that included Rubikitch&#39;s
contributions)))</p>



<p>((Web browsers have a way to “return” from hyperlinks: the
“back” button... In eev we have many kinds of hyperlinks, including
some that are unsafe and irreversible, but we have a few kinds of
“back”s that work... 1) if the hyperlink opened a new file or
buffer, then to kill the file or buffer, use M-k (an eev binding for
kill-this-buffer); note that it asks for a confirmation when the
buffer is associated to a file and it has been modified --- or we can
use bury-buffer; M-K is an eev binding for bury-buffer. ((explain how
emacs keeps a list of buffers?)) Note: if the buffer contains, say, a
manpage, or an html page rendered by w3m, which take a significant
time to generate, then M-K is better is than M-k. 2) if the hyperlink
was a `to&#39; then it jumped to another position in the same file... it
is possible to keep a list of previous positions in a buffer and to
create an `ee-back&#39; function (suggestion: bind it to M-B) but I haver
never been satisfied with the implementations that I did so we&#39;re only
keeping a hook in `to&#39; for a function that saves the current position
before the jump))</p>



<p>((dto recommended winner-undo))</p>




<h2><a name="local-copies"></a><a href="#.local-copies">11. Local copies of files from the internet</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-psne-intro.html">find-psne-intro</a><a href="http://angg.twu.net/eev-intros/find-psne-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/rcfiles/.bashrc-psne.html">code</a>,
      <a href="http://angg.twu.net/eev-current/rcfiles/.zshrc-psne.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-rctool.html#new_block_bashrc">eev-rctool</a>,
      <a href="http://lists.gnu.org/archive/html/eev/2005-06/msg00000.html">m.list</a>,
      <a href="http://article.gmane.org/gmane.emacs.eev.devel/9">gmane</a>]</i></p></small>



<p>Emacs knows how to fetch files from the internet, but for most
purposes it is better to use local copies. Suppose that the
environment variable <code>$S</code> is set to <code>~/snarf/</code>; then running
this on a shell

<div>
<pre>mkdir -p $S/http/www.gnu.org/software/emacs/
cd       $S/http/www.gnu.org/software/emacs/
wget http://www.gnu.org/software/emacs/emacs-paper.html

# (find-fline &#34;$S/http/www.gnu.org/software/emacs/emacs-paper.html&#34;)
# (find-w3m   &#34;$S/http/www.gnu.org/software/emacs/emacs-paper.html&#34;)
</pre>
</div>


creates a local copy of <code>emacs-paper.html</code> inside <code>~/snarf/http/</code>. The two last lines are hyperlinks to the local copy;
`<code>find-w3m</code>&#39; opens it “as HTML”, using a web browser called w3m
that can be run either in standalone mode or inside Emacs; `<code>find-w3m</code>&#39; uses w3m&#39;s Emacs interface, and it accepts extra arguments,
which are treated as a pos-spec-list.</p>



<p>Instead of running the `<code>mkdir</code>&#39;, `<code>cd</code>&#39; and `<code>wget</code>&#39;
lines above we can run a single command that does everything:

<div>
<pre>psne http://www.gnu.org/software/emacs/emacs-paper.html
</pre>
</div>


which also adds a line with that URL to a log file (usually <code>~/.psne.log</code>). It is more convenient to have a `<code>psne</code>&#39; that
changes the current directory of the shell than one that doesn&#39;t, and
for that it must be defined as a shell function.</p>


<a name="rcfiles"></a>



<p>Eev comes with an installer script, called <code>eev-rctool</code>, that
can help in adding the definitions for eev (like the “<code>function ee
() { source ~/ee.sh; }</code>” of section 3) to initialization files like
<code>~/.bashrc</code> (such initialization files are termed “rcfiles”).
Eev-rctool does <i>not</i> add by default the definitions for `<code>psne</code>&#39; and for <code>$S</code> to rcfiles; however, it adds commented-out
lines with instructions, which might be something like:</p>

<div>
<pre># To define $S and psne uncomment this:
#   . $EEVTMPDIR/psne.sh
# (find-eevtmpfile &#34;psne.sh&#34;)
</pre>
</div>




<p>((See: <a href="http://lists.gnu.org/archive/html/eev/2005-06/msg00000.html">http://lists.gnu.org/archive/html/eev/2005-06/msg00000.html</a>))</p>





<h2><a name="glyphs"></a><a href="#.glyphs">12. Glyphs</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-glyphs.el.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-math-glyphs.el.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini.el.html#eev-glyph-face-red">miniature</a>
      <a href="http://angg.twu.net/flipbooks/ee-glyph.html">flipbook</a>]</i></p></small>



<p>Emacs allows redefining how characters are displayed, and one of
the modules of eev --- eev-glyphs --- uses that to make some
characters stand out. Character 15, for example, is displayed on the
screen by default as &#39;<code>^O</code>&#39; (two characters, suggesting
“control-O”), sometimes in a different color from normal text(3).</p>



<p>Eev changes the appearance of char 15 to make it be displayed as a
red star. Here is how: Emacs has some structures called “faces” that
store font and color information, and `<code>eeglyphs-face-red</code>&#39; is a
face that says “use the default font and the default background
color, but a red foreground”; eev&#39;s initialization code runs this,

<div>
<pre>(eev-set-glyph 15 ?* &#39;eev-glyph-face-red)
</pre>
</div>


which sets the representation of char 15 to the “glyph” made of a
star in the face eeglyphs-face-red. </p>



<p>For this article, as red doesn&#39;t print well in black and white, we
used this instead:

<div>
<pre>(eev-set-glyph 15 342434)
</pre>
</div>


this made occurrences of char 15 appear as the character 342434, `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; (note that this is outside of the ascii range), using the default
face, i.e., the default font and color.</p>



<p>Eev also sets a few other glyphs with non-standard faces. The most
important of those are `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and &#39;<code><SPAN color="green"><i>»</i></SPAN></code>&#39;, which are set to appear
in green against the default background, with:

<div>
<pre>(eev-set-glyph 171 171 &#39;eev-glyph-face-green)
(eev-set-glyph 187 187 &#39;eev-glyph-face-green)
</pre>
</div>


There&#39;s a technical point to be raised here. Emacs can use several
“encodings” for files and buffers, and `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and `<code><SPAN color="green"><i>»</i></SPAN></code>&#39; only
have character codes 171 and 187 in a few cases, mainly in the
`raw-text&#39; encoding and in “unibyte” buffers; in most other
encodings they have other char codes, usually above 255, and when they
have these other codes Emacs considers that they are other characters
for which no special glyphs were set and shows them in the default
face. This visual distinction between the below-255 `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and `<code></code>&#39; and the other `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and `<code><SPAN color="green"><i>»</i></SPAN></code>&#39;s is deliberate --- it helps
preventing some subtle bugs involving the anchor functions of section
\ref{anchors}.</p>



<p>(3). Determined by the “face” escape-glyph-face, introduced in
GNU Emacs in late 2004.</p>




<h2><a name="compose-pairs"></a><a href="#.compose-pairs">13. Compose Pairs</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-compose.el.html">code</a>]</i></p></small>



<p>To insert a `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; in a text we type `<code>C-q C-o</code>&#39; --- <code>C-q</code>
“quotes” the next key that Emacs receives, and `<code>C-q C-o</code>&#39;
inserts a “literal C-o”, which is a char 15. Typing `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and
`<code><SPAN color="green"><i>»</i></SPAN></code>&#39;s --- and other non-standard glyphs, if we decide to define
our own --- involves using another module of eev: eev-compose.</p>



<p>Eev-compose defines a few variables that hold tables of “compose
pairs”, which map pairs of characters that are easy to type into
other, weirder characters; for example, `eev-composes-otheriso&#39; says
that the pair &#34;<code>&lt;&lt;</code>&#34; is mapped to &#34;<code><SPAN color="green"><i>«</i></SPAN></code>&#34; and that &#34;<code>&gt;&gt;</code>&#34; is
mapped to &#34;<code><SPAN color="green"><i>»</i></SPAN></code>&#34;, among others. When we are in “eev mode” the
prefix `<code>M-,</code>&#39; can be used to perform the translation: typing `<code>M-, &lt; &lt;</code>&#39; enters `<code><SPAN color="green"><i>«</i></SPAN></code>&#39;, and typing `<code>M-, &gt; &gt;</code>&#39; enters `<code><SPAN color="green"><i>»</i></SPAN></code>&#39;.</p>



<p>The variable `<code>eev-composes-accents</code>&#39; holds mappings for
accented chars, like &#34;<code>&#39;a</code>&#34; to &#34;<code>á</code>&#34; and &#34;<code>cc</code>&#34; to &#34;<code>ç</code>&#34;;
`<code>eev-composes-otheriso</code>&#39; takes care of the other mappings that
still concern characters found in the ISO8859-1 character set, like
`<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and &#39;<code><SPAN color="green"><i>»</i></SPAN></code>&#39; as above, &#34;<code>_a</code>&#34; to &#34;<code>ª</code>&#34;, &#34;<code>xx</code>&#34; to
&#34;<code>×</code>&#34;, and a few others; `<code>eev-composes-globalmath</code>&#39; and `<code>eev-composes-localmath</code>&#39; are initially empty and are meant to be used
for used-defined glyphs. The suffix `<code>math</code>&#39; in their names is a
relic: Emacs implements its own ways to enter special characters,
which support several languages and character encodings, but their
code is quite complex and they are difficult to extend; the code that
implements eev&#39;s `<code>M-,</code>&#39;, on the other hand, takes about just 10
lines of Lisp (excluding the tables of compose pairs) and it is
trivial to understand and to change its tables of pairs. `<code>M-,</code>&#39;
was created originally to enter special glyphs for editing
mathematical texts in TeX, but it turned out to be a convenient hack,
and it stuck.</p>




<h2><a name="delimited-regions"></a><a href="#.delimited-regions">14. Delimited regions</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-bounded-intro.html">find-bounded-intro</a><a href="http://angg.twu.net/eev-intros/find-bounded-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-bounded.el.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini.el.html#eeb-default">miniature</a>,
      <a href="http://angg.twu.net/eev-current/doc/shot-f3.png">shot</a>,
      <a href="http://angg.twu.net/eev-current/anim/gdb.anim.html">anim</a>]</i></p></small>



<p>Sometimes it happens that we need to run a certain (long) series of
commands over and over again, maybe with some changes from one run to
the next; then having to mark the block all the time becomes a hassle.</p>



<p>One alternative to that is using a variaton on `<code>M-x eev</code>&#39;: `<code>M-x eev-bounded</code>&#39;. It saves the region around the cursor up to certain
delimiters instead of saving what&#39;s between Emacs&#39;s “point” and
“mark”.</p>



<p>The original definition of eev-bounded was something like this:

<div>
<pre>(defun eev-bounded ()
  (interactive)
  (eev (ee-search-backwards &#34;\n#<SPAN color="red"><strong>*</strong></SPAN>\n&#34;)
       (ee-search-forward   &#34;\n#<SPAN color="red"><strong>*</strong></SPAN>\n&#34;)))
</pre>
</div>


the call to `<code>ee-search-backwards</code>&#39; searches for the first
occurrence of the string &#34;<code>\n#<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34; (newline, hash sign, control-O,
newline) before the cursor and returns the position after the &#34;<code>\n#<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34;, without moving the cursor; the call to <code>ee-search-forward</code> does something similar with a forward search. As
the arguments to `<code>eev</code>&#39; indicate the extremities of the region to
be saved into the temporary script, this saves the region between the
first &#34;<code>\n#<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34; backwards from the cursor to the first &#34;<code>\n#<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34; after the cursor.</p>



<p>The actual definition of `<code>eev-bounded</code>&#39; includes some extra
code to highlight temporarily the region that was used; see Figure
\ref{fig:F3}. Normally the highlighting lasts for less than one
second, but here we have set its duration to several seconds to
produce a more interesting screenshot.</p>

<div>
<pre> ____________________ emacs@localhost _______________________ 
|                                                _________ xterm __________ 
|#<SPAN color="red"><strong>*</strong></SPAN>                                             |/home/edrx(edrx)# ee      |
|# Global variables                             |# Global variables        |
|lua50 -e &#39;                                     |lua50 -e &#39;                |
|  print(print)                                 |  print(print)            |
|  print(_G[&#34;print&#34;])                           |  print(_G[&#34;print&#34;])      |
|  print(_G.print)                              |  print(_G.print)         |
|  print(_G)                                    |  print(_G)               |
|  print(_G._G)                                 |  print(_G._G)            |
|&#39;                                              |&#39;                         |
|#<SPAN color="red"><strong>*</strong></SPAN>                                             |function: 0x804dfc0       |
|# Capture of local variables                   |function: 0x804dfc0       |
|lua50 -e &#39;                                     |function: 0x804dfc0       |
|  foo = function ()                            |table: 0x804d420          |
|    local storage                              |table: 0x804d420          |
|    return                                     |/home/edrx(edrx)#         |
|      (function () return storage end),        |__________________________|
|      (function (x) storage = x; return x end)              |              
|  end                                                       |
|  get1, set1 = foo()                                        |
|  get2, set2 = foo()               -- Output:               |
|  print(set1(22), get1())          -- 22 22                 |
|  print(set2(33), get1(), get2())  -- 33 22 33              |
|&#39;                                                           |
|#<SPAN color="red"><strong>*</strong></SPAN>                                                          |
|                                                            |
|-:--  lua5.e   91% L325    (Fundamental)--------------------|
|____________________________________________________________|

  Figure 2: sending a delimited block with F3
  (find-fline &#34;ss-lua.png&#34;)
  (find-eevex &#34;screenshots.e&#34; &#34;fisl-screenshots&#34;)
</pre>
</div>




<p>Eev binds the key F3 to the function `<code>eeb-default</code>&#39;, which runs
the current “default bounded function” (which is set initially to
`<code>eev</code>&#39;, <i>not</i> `<code>eev-bounded</code>&#39;) on the region between the
current default delimiters, using the current default
“highlight-spec”; so, instead of typing `<code>M-x eev-bounded</code>&#39;
inside the region to save it we can just type F3.</p>



<p>All these defaults values come from a single list, which is stored
in the variable `<code>eeb-defaults</code>&#39;. The real definition of `<code>eev-bounded</code>&#39; is something like:</p>

<div>
<pre>(setq eev-bounded
  &#39;(eev ee-delimiter-hash nil t t))

(defun eev-bounded ()
  (interactive)
  (setq eeb-defaults eev-bounded)
  (eeb-default))
</pre>
</div>




<p>Note that in Emacs Lisp (and in most other Lisps) each symbol has a
value as a variable that is independent from its “value as a
function”: actually a symbol is a structure containg a name, a
“value cell”, a “function cell” and a few other fields. Our
definition of `<code>eev-bounded</code>&#39;, above, includes both a definition of
the function `<code>eev-bounded</code>&#39; and a value for the variable `<code>eev-bounded</code>&#39;.</p>



<p>Eev has an auxiliary function for defining these “bounded
functions”; running

<div>
<pre>(eeb-define &#39;eev-bounded &#39;eev &#39;ee-delimiter-hash nil t t)
</pre>
</div>


has the same effect as doing the `<code>setq</code>&#39; and the `<code>defun</code>&#39;
above.</p>



<p>As for the meaning of the entries of the list `<code>eeb-defaults</code>&#39;,
the first one (`<code>eev</code>&#39;) says which function to run; the second one
(`<code>ee-delimiter-hash</code>&#39;) says which initial delimiter to use --- in
this case it is a symbol instead of a string, and so `<code>eeb-default</code>&#39; takes the value of the variable `<code>ee-delimiter-hash</code>&#39;; the third one (nil) is like the second one, but
for the final delimiter, and when it is nil `<code>eeb-default</code>&#39;
considers that the final delimiter is equal to the initial delimiter;
the fourth entry (<code>t</code>) means to use the standard highlight-spec,
and the fifth one (<code>t</code>, again) tells `<code>eeb-default</code>&#39; to make an
adjustment to the highlighted region for purely aestethical reasons:
the saved region does not include the initial &#34;<code>\n</code>&#34; in the final
delimiter, &#34;<code>\n#<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34;, but the highlighting looks nicer if it is
included; without it the last highlighted line in Figure 2 would have
only its first character --- an apostrophe --- highlighted.</p>



<p>Eev also implements other of these “bounded” functions. For
example, running `<code>M-x eelatex</code>&#39; on a region saves it in a
temporary LaTeX file, and also saves into the temporary script file
the commands to process it with LaTeX; `<code>eelatex-bounded</code>&#39; is
defined by

<div>
<pre>(eeb-define &#39;eelatex-bounded &#39;eelatex
  &#39;ee-delimiter-percent nil t t)
</pre>
</div>


where the variable `<code>ee-delimiter-percent</code>&#39; holds the string &#34;<code>\n%<SPAN color="red"><strong>*</strong></SPAN>\n</code>&#34;; comments in LaTeX start with percent signs, not hash signs,
and it is convenient to use delimiters that are treated as comments.</p>



<p>((The block below ... tricky ... blah. How to typeset `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; in
LaTeX. Running eelatex-bounded changed the defaults stored in
eeb-defaults, but ee-once blah doesn&#39;t.))</p>

<div>
<pre>%<SPAN color="red"><strong>*</strong></SPAN>
% (eelatex-bounded)
% (ee-once (eelatex-bounded))
\def\myttbox#1{%
  \setbox0=\hbox{\texttt{a}}%
  \hbox to \wd0{\hss#1\hss}%
}
\catcode`<SPAN color="red"><strong>*</strong></SPAN>=13 \def<SPAN color="red"><strong>*</strong></SPAN>{\myttbox{$\bullet$}}
\begin{verbatim}
abcdefg
   d<SPAN color="red"><strong>*</strong></SPAN>fg
\end{verbatim}
%<SPAN color="red"><strong>*</strong></SPAN>
</pre>
</div>




<p>...for example eelatex, that saves the region (plus certain
standard header and footer lines) to a “temporary LaTeX file” and
saves into the temporary script file the commands to make `ee&#39; run
LaTeX on that and display the result. The block below is an example of
(...)</p>



<p>...The block below shows a typical application of <code>eev-bounded</code>:

<div>
<pre># (find-es &#34;lua5&#34; &#34;install-5.0.2&#34;)
# (find-es &#34;lua5&#34; &#34;install-5.0.2&#34; &#34;Edrx&#39;s changes&#34;)

# (code-c-d &#34;lua5&#34; &#34;/tmp/usrc/lua-5.0.2/&#34;)
# (find-lua5file &#34;INSTALL&#34;)
# (find-lua5file &#34;config&#34; &#34;support for dynamic loading&#34;)
# (find-lua5file &#34;config&#34;)
# (find-lua5file &#34;&#34;)
#<SPAN color="red"><strong>*</strong></SPAN>
rm   -Rv ~/usrc/lua-5.0.2/
mkdir -p ~/usrc/lua-5.0.2/
tar   -C ~/usrc/ \
   -xvzf $S/http/www.lua.org/ftp/lua-5.0.2.tar.gz
cd       ~/usrc/lua-5.0.2/
cat &gt;&gt; config &lt;&lt;&#39;---&#39;
LOADLIB= -DUSE_DLOPEN=1
DLLIB= -ldl
MYLDFLAGS= -Wl,-E
EXTRA_LIBS= -lm -ldl
---
make test  2&gt;&amp;1 | tee omt
./bin/lua -e &#39;print(loadlib)&#39;
#<SPAN color="red"><strong>*</strong></SPAN>
</pre>
</div>


it unpacks a program (the interpreter for Lua), changes its default
configuration slightly, then compiles and tests it.</p>



<p>((Comment about the size: the above code is “too small for being a
script”, and the hyperlinks are important))</p>



<p>gdb (here-documents, gcc, ee-once)</p>



<p>(alternative: here-documents, gcc, gdb, screenshot(s) for gdb)</p>




<h2><a name="channels"></a><a href="#.channels">15. Communication channels</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-channels-intro.html">find-channels-intro</a><a href="http://angg.twu.net/eev-intros/find-channels-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-steps.el.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eegchannel.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini-steps.el.html">miniature</a>,
      <a href="http://angg.twu.net/eev-current/anim/channels.anim.html">anim</a>]</i></p></small>



<p>The way that we saw to send commands to a shell is in two steps:
first we use <code>M-x eev</code> in Emacs to “send” a block of commands,
and then we run `<code>ee</code>&#39; at the shell to make it “receive” these
commands. But there is also a way to create shells that “listen” not
only to the keyboard for their input, but also to certain
“communication channels”; by making Emacs send commands through
these communication channels we can skip the step of going to the
shell and typing `<code>ee</code>&#39; --- the commands are received immediately.</p>

<div>
<pre> _________emacs@localhost____________   ___________channel A______________
|                                    | |/tmp(edrx)# # Send things to port |
|<SPAN color="red"><strong>*</strong></SPAN> (eechannel-xterm &#34;A&#34;) ;; create   | | 1234                             |
|<SPAN color="red"><strong>*</strong></SPAN> (eechannel-xterm &#34;B&#34;) ;; create   | |/tmp(edrx)# {                     |
|# Listen on port 1234               | |&gt;   echo hi                       |
|netcat -l -p 1234                   | |&gt;   sleep 1                       |
|<SPAN color="red"><strong>*</strong></SPAN>                                   | |&gt;   echo bye                      |
|<SPAN color="red"><strong>*</strong></SPAN> (eechannel &#34;A&#34;) ;; change target  | |&gt;   sleep 1                       |
|# Send things to port 1234          | |&gt; } | netcat -q 0 localhost 1234  |
|{                                   | |/tmp(edrx)#                       |
|  echo hi                           | |/tmp(edrx)#                       |
|  sleep 1                           | |__________________________________|
|  echo bye                          |  ___________channel B______________
|  sleep 1                           | |/tmp(edrx)# # Listen on port 1234 |
|} | netcat -q 0 localhost 1234      | |/tmp(edrx)# netcat -l -p 1234     |
|                                    | |hi                                |
|-:--  screenshots.e   95% L409   (Fu| |bye                               |
|_Wrote /home/edrx/.eev/eeg.A.str____| |/tmp(edrx)#                       |
                                       |                                  |
                                       |__________________________________|
 Figure 3: sending commands to two xterms using F9
 (find-eevex &#34;screenshots.e&#34; &#34;fisl-screenshots&#34;)
 (find-eevfile &#34;article/ss-f9.png&#34;)
</pre>
</div>




<p>The screenshot at Figure 3 shows this at work. The user has started
with the cursor at the second line from the top of the screen in the
Emacs window and then has typed F9 several times. Eev binds F9 to a
command that operates on the current line and then moves down to the
next line; if the current line starts with `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; then what comes
after the `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; is considered as Lisp code and executed
immediately, and the current line doesn&#39;t start with `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; then its
contents are sent through the default communication channel, or though
a dummy communication channel if no default was set.</p>



<p>The first F9 executed `<code>(eechannel-xterm &#34;A&#34;)</code>&#39;, which created
an xterm with title “<code>channel A</code>”, running a shell listening on
the communication channel “<code>A</code>”, and set the default channel to
A; the second F9 created another xterm, now listening to channel <code>B</code>, and set the default channel to <code>B</code>.</p>



<p>The next two `<code>F9</code>&#39;s sent each one one line to channel <code>B</code>.
The first line was a shell comment (“<code># Listen...</code>”); the second
one started the program <code>netcat</code>, with options to make <code>netcat</code>
“listen to the internet port 1234” and dump to standard output what
it receives.</p>



<p>The next line had just `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39;; executing the rest of it as Lisp
did nothing. The following line changed the default channel to A.</p>



<p>In the following lines there is a small shell program that outputs
“<code>hi</code>”, then waits one second, then outputs “<code>bye</code>”, then
waits for another second, then finishes; due to the “<code>|
netcat...</code>” its output is redirected to the internet port 1234, and
so we see it appearing as the output of the netcat running on channel
<code>B</code>, with all the expected delays: one second between “<code>hi</code>”
and “bye”, and one second after “<code>bye</code>”; after that last
one-second delay the netcat at channel <code>A</code> finishes receiving input
(because the program between `<code>{</code>&#39; and `<code>}</code>&#39; ends) and it
finishes its execution, closing the port 1234; the netcat at <code>B</code>
notices that the port was closed and finishes its execution too, and
both shells return to the shell prompt.</p>



<p>There are also ways to send whole blocks of lines at once through
communication channels; see Section \ref{bigmodular}.</p>




<h2><a name="channels-implementation"></a><a href="#.channels-implementation">15.1. The Implementation of Communication Channels</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-steps.el.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eegchannel.html">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini-steps.el.html">miniature</a>,
      <a href="http://angg.twu.net/eev-current/anim/channels.anim.html">anim</a>]</i></p></small>

<small>

<p><i>[2007: There&#39;s a much better explanation, with nice
ascii diagrams, at <a href="http://angg.twu.net/eev-current/anim/channels.anim.html">channels.anim</a>; it should be merged here.]</i></p></small>



<p>Communication channels are implemented using an auxiliary script
called `eegchannel&#39;, which is written in Expect ([L90] and [L95]). If we start an xterm in the default way it starts a shell (say,
<code>/bin/bash</code>) and interacts with it: the xterm sends to the shell as
characters the keystrokes that it receives from the window manager and
treats the characters that the shell sends back as being instructions
to draw characters, numbers and symbols on the screen. But when we run
`<code>(eechannel-xterm &#34;A&#34;)</code>&#39; Emacs creates an xterm that interacts
with another program --- <code>eegchannel</code> --- instead of with a shell,
and <code>eegchannel</code> in its turn runs a shell and interacts with it.</p>



<p>Eegchannel passes characters back and forth between the xterm and
the shell without changing them in any way; it mostly tries to pretend
that it is not there and that the xterm is communicating directly with
the shell. However, when eegchannel receives a certain signal it sends
to the shell a certain sequence of characters that were not sent by
the xterm; it “fakes a sequence of keystrokes”.</p>



<p>Let&#39;s see a concrete example. Suppose than Emacs was running with
process id (“pid”) 1000, and running <code>(eechannel-xterm &#34;A&#34;)</code> in
it made it create an xterm, which got pid 1001; that xterm ran
eegchannel (pid 1002), which ran /bin/bash (pid 1003). Actually Emacs
invoked xterm using this command line:</p>

<div>
<pre>xterm -n &#34;channel A&#34; -e eegchannel A /bin/bash
</pre>
</div>




<p>and xterm invoked eegchannel with “<code>eegchannel A /bin/bash</code>”;
eegchannel saw the `<code>A</code>&#39;, saved its pid (1002) to the file <code>~/.eev/eeg.A.pid</code>, and watched for <code>SIGUSR1</code> signals; every time
that it (the eegchannel) receives a <code>SIGUSR1</code> it reads the contents
of <code>~/.eev/eeg.A.str</code> and sends that as fake input to the shell
that it is controlling. So, running</p>

<div>
<pre>echo &#39;echo $[1+2]&#39; &gt; ~/.eev/eeg.A.str
kill -USR1 $(cat ~/.eev/eeg.A.pid)
</pre>
</div>




<p>in a shell sends the string “<code>echo $[1+2]</code>” (plus a newline)
“through the channel A”; what Emacs does when we type F9 on a line
that does not start with `<code><SPAN color="red"><strong>*</strong></SPAN></code>&#39; corresponds exactly to that.</p>





<h2><a name="anchors"></a><a href="#.anchors">16. Anchors</a></h2>

<small>

<p><span>Update (2013feb11):</span> see this instead: <code>(<a href="http://angg.twu.net/eev-intros/find-anchors-intro.html">find-anchors-intro</a><a href="http://angg.twu.net/eev-intros/find-anchors-intro.html">)</a></code></p></small>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html#ee-goto-anchor">code</a>]</i></p></small>



<p>The function `<code>to</code>&#39; can be used to create hyperlinks to certain
positions --- called “anchors” --- in the current file. For
example,</p>

<div>
<pre># Index:
# <SPAN color="green"><i>«</i></SPAN>.first_block<SPAN color="green"><i>»</i></SPAN>        (to &#34;first_block&#34;)
# <SPAN color="green"><i>«</i></SPAN>.second_block<SPAN color="green"><i>»</i></SPAN>       (to &#34;second_block&#34;)

#<SPAN color="red"><strong>*</strong></SPAN>
# <SPAN color="green"><i>«</i></SPAN>first_block<SPAN color="green"><i>»</i></SPAN>  (to &#34;.first_block&#34;)
echo blah
#<SPAN color="red"><strong>*</strong></SPAN>
# <SPAN color="green"><i>«</i></SPAN>second_block<SPAN color="green"><i>»</i></SPAN>  (to &#34;.second_block&#34;)
echo blah blah
#<SPAN color="red"><strong>*</strong></SPAN>
</pre>
</div>




<p>What `to&#39; does is simply to wrap its argument inside `<code><SPAN color="green"><i>«</i></SPAN></code>&#39; and
`<code><SPAN color="green"><i>»</i></SPAN></code>&#39; characters and then jump to the first occurrence of the
resulting string in the current file. In the (toy) example above, the
line that starts with “<code># <SPAN color="green"><i>«</i></SPAN>.first_block<SPAN color="green"><i>»</i></SPAN></code>” has a link that jumps
to the line that starts with “<code># <SPAN color="green"><i>«</i></SPAN>first_block<SPAN color="green"><i>»</i></SPAN></code>”, which has a
link that jumps back --- the anchors and “<code>(to ...)</code>”s act like
an index for that file.</p>



<p>The function `<code>find-anchor</code>&#39; works like a `<code>to</code>&#39; that first
opens another file. For example,</p>

<div>
<pre>(find-anchor &#34;~/.zshrc&#34; &#34;update-homepage&#34;)
</pre>
</div>




<p>does roughly the same as:</p>

<div>
<pre>(find-fline &#34;~/.zshrc&#34; &#34;<SPAN color="green"><i>«</i></SPAN>update-homepage<SPAN color="green"><i>»</i></SPAN>&#34;)
</pre>
</div>




<p>Actually `<code>find-anchor</code>&#39; consults a variable, `<code>ee-anchor-format</code>&#39;, to see in which strings to wrap the argument. Some
functions modify `<code>ee-anchor-format</code>&#39; temporarily to obtain special
effects; for example, a lot of information about the packages
installed in a Debian GNU system is kept in a text file called <code>/var/lib/dpkg/info/status</code>; <code>(find-status &#34;emacs21&#34;)</code> opens this
file and searches for the string &#34;<code>\nPackage: emacs21\n</code>&#34; there ---
that string is the header for the block with information about the
package <code>emacs21</code>, and it tells the size of the package,
description, version, whether it is installed or not, etc, in a format
that is both machine-readable and human-readable.</p>




<h2><a name="e-scripts"></a><a href="#.e-scripts">17. E-scripts</a></h2>



<p>The best short definition for eev that I&#39;ve found involves some
cheating, as it is a circular definition: “eev is a library that adds
support for e-scripts to Emacs” --- and e-scripts are files that
contain chunks meant to be processed by eev&#39;s functions. Almost any
file can contain parts “meant for eev”: for example, a <code>HOWTO</code> or
<code>README</code> file about some program will usually contain some example
shell commands, and we can mark these commands and execute them with
<code>M-x eev</code>; and if we have the habit of using eev and we are writing
code in, say, C or Lua we will often put elisp hyperlinks inside
comment blocks in our code. These two specific languages (and a few
others) have a feature that is quite convenient for eev: they have
syntactical constructs that allow comment blocks spanning several
lines --- for example, in Lua, where these comment blocks are
delimited by “<code>--((</code>” and “<code>--))</code>”s, we can have a block
like</p>

<div>
<pre>--[[
#<SPAN color="red"><strong>*</strong></SPAN>
# This file: (find-fline &#34;~/LUA/lstoindexhtml.lua&#34;)
# A test:
cd /tmp/
ls -laF | col -x \
  | lua50 ~/LUA/lstoindexhtml.lua tmp/ \
  | lua50 -e &#39;writefile(&#34;index.html&#34;, io.read(&#34;*a&#34;))&#39;
#<SPAN color="red"><strong>*</strong></SPAN>
--]]
</pre>
</div>




<p>in a Lua script, and the script will be at the same time a Lua
script and an e-script.</p>



<p>When I started using GNU and Emacs the notion of an e-script was
something quite precise to me: I was keeping notes on what I was
learning and on all that I was trying to do, and I was keeping those
notes in a format that was partly English (or Portuguese), partly
executable things --- not all of them finished, or working --- after
all, it was much more practical to write</p>

<div>
<pre>rm -Rv ~/usrc/busybox-1.00/
tar -C ~/usrc/ -xvzf \
  $S/http/www.busybox.net/downloads/busybox-1.00.tar.gz
cd ~/usrc/busybox-1.00/
cp -iv ~/BUSYBOX/myconfig .config
make menuconfig
make       2&gt;&amp;1 | tee om
</pre>
</div>




<p>than to write</p>

<div>
<pre>Unpack BusyBox&#39;s source, then run &#34;make menuconfig&#34;
and &#34;make&#34; on its main directory
</pre>
</div>




<p>because if I had the second form in my notes I would have to
translate that from English into machine commands every time... So,
those files where I was keeping my notes contained “executable
notes”, or were “scripts for Emacs”, and I was quite sure that
everyone else around were also keeping notes in executable formats,
possibly using other editors and environments (vi, maybe?) and that if
I showed these people my notes and they were about some task that they
were also struggling with then they would also show me <i>their</i>
notes... I ended up making a system that uploaded regularly all my
e-scripts (no matter how messy they were) to my home page, and writing
a text --- “The Eev Manifesto” ([O99]) --- about sharing these
executable notes.</p>



<p>Actually trying to define an e-script as being “a file containing
executable parts, that are picked up and executed interactively”
makes the concept of an e-script <i>very</i> loose.</p>



<p>Note that we <i>can</i> execute the Lua parts in the code above by
running the Lua interpreter on it, we <i>can</i> execute the elisp
one-liner with <code>M-e</code> in Emacs, and we <i>can</i> execute the shell
commands using F3 or <code>M-x eev</code>; but the code will do nothing by
itself --- it is passive.</p>



<p>A piece of code containing instructions in English on how to use it
is also an e-script, in a sense; but to execute these instructions we
need to invoke an external entity --- a human, usually ourselves ---
to interpret them. This is much more flexible, but also much more
error-prone and slow, than just pressing a simple sequence of keys
like M-e, or F9, or F3, alt-tab, e, e, enter.</p>




<h2><a name="splitting-eev.el"></a><a href="#.splitting-eev.el">18. Splitting eev.el</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev.el.html#find-man">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini.el.html#find-man">miniature</a>]</i></p></small>



<p>When I first submittted eev for inclusion in GNU Emacs, in 1999,
the people at the FSF requested some changes. One of them was to split
eev.el --- the code at that point was all in a single Emacs Lisp file,
called eev.el --- into several separate source files according to
functionality; at least the code for saving temporary scripts and the
code for hyperlinks should be kept separate.</p>



<p>It turned out that that was the wrong way of splitting eev. The
frontier between what is a hyperlink and what is a block of commands
is blurry:</p>

<div>
<pre>man foo
man -P &#39;less +/bar&#39; foo
# (eev &#34;man foo&#34;)
# (eev &#34;man -P &#39;less +/bar&#39; foo&#34;)
# (find-man &#34;foo&#34; &#34;bar&#34;)
</pre>
</div>




<p>The two `<code>man</code>&#39; commands above can be considered as hyperlinks
to a manpage, but we need to send those commands to a shell to
actually open the manpage; the option &#34;<code>-P &#39;less +/bar&#39;</code>&#34; instructs
`<code>man</code>&#39; to use the program `<code>less</code>&#39; to display the manpage, and
it tells `<code>less</code>&#39; to jump to the first occurrence of the string
“<code>bar</code>” in the text, and so it is a hyperlink to a specific
position in a manpage. Each of the two `<code>eev</code>&#39; lines, when
executed, saves one of these `<code>man</code>&#39; commands to the temporary
script file; because they contain Lisp expressions they look much more
like hyperlinks than the `<code>man</code>&#39; lines. The last line, `<code>find-man</code>&#39;, behaves much more like a “real” hyperlink: it opens the
manpage <i>inside Emacs</i> and searches for the first occurrence of
`<code>bar</code>&#39; there; but Emacs&#39;s code for displaying manpages was tricky,
and it took me a few years to figure out how to add support for
pos-spec-lists to it...</p>



<p>So, what happens is that often a new kind of hyperlink will begin
its life as a series of shell commands (another example: using `<code>gv
--page 14 file.ps</code>&#39; to open a PostScript file and then jump to a
certain page) and then it takes some time to make a nice hyperlink
function that does the same thing; and often these functions are
implemented by executing commands in external programs.</p>



<p>There&#39;s a much better way to split conceptually what eev does,
though. Most functions in eev take a region of text (for example
Emacs&#39;s own “selected region”, or the extent of Lisp expression
coming before the cursor) and “execute” that in some way; the kinds
of regions are</p>

<div>
<pre>Emacs&#39;s (selected) region   | M-x eev, M-x eelatex (sec. 4)
----------------------------+------------------------------
last-sexp (Lisp expression  | C-x C-e, M-E         (sec. 5)
at the left of the cursor)  | 
----------------------------+------------------------------
sexp-eol (go to end of      | C-e C-x C-e, M-e     (sec. 7)
line, then last-sexp)       |
----------------------------+------------------------------
bounded region              | F3, M-x eev-bounded,
                            | M-x eelatex-bounded (sec. 14)
----------------------------+------------------------------
bounded region around       | (ee-at [`` anchor] ...)
anchor                      |                     (sec. 20)
----------------------------+------------------------------
current line                | F9                  (sec. 15)
----------------------------+------------------------------
no text (instead use the    | F12                 (sec. 19)
next item in a list)        |
</pre>
</div>




<p>Actions (can be composed):
  * Saving a region or a string into a file
  * Sending a signal to a process
  * Executing as Lisp
  * Executing immediately in a shell
  * Start a debugger
</p>



<p>((Emacs terminology: commands))</p>




<h2><a name="eesteps"></a><a href="#.eesteps">19. Steps</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/eev-current/eev-steps.el.html#eesteps">code</a>,
      <a href="http://angg.twu.net/eev-current/eev-mini-steps.el.html#eesteps">miniature</a>,
      <a href="http://angg.twu.net/flipbooks/eesteps.html">flipbook</a>]</i></p></small>



<p>((Simple examples))</p>



<p>((writing demos))</p>



<p>((hyperlinks for which no short form is known))</p>



<p>((producing animations and screenshots))</p>





<h2><a name="eepitch"></a><a href="#.eepitch">20. Sending lines to processes running in Emacs buffers </a></h2>





<p>Update (oct/2011): <span>PLEASE IGNORE THIS!</span> This part of eev
has been completely rewritten - see:</p>







<p><i>(These sections - 20 to 24 - are very new (handwritten in
2007jul12, typed a few days later). They are early drafts, full of
errors, describing some code that does not yet exist (ee-tbr), etc.
Also, I don&#39;t know Rubikitch&#39;s real name, so I used a random Japanese
name...)</i></p>




<p>Emacs can run external programs interactively inside buffers; in
the screenshot in Figure 5 there&#39;s a shell running in the buffer
&#34;*shell*&#34; in the lower window. Technically, what is going on is much
more complex than what we described in the previous section. The shell
runs in a pseudo-terminal (pty), but ptys are usually associated to
rectangular grids of characters with a definite width and height,
while in an Emacs buffer the width of each line, and the total number
of lines,are only limited by memory constraints. Many interactive
programs expect their input to come through their more-or-less
minimalistic line editors, that may try to send to the terminal
commands like &#34;clear the screen&#34; or &#34;go to column x at line y&#34;; how
should these things be handled in a shell buffer? Also, the user can
move freely in a shell buffer, and edit its contents as text, but the
&#34;Return&#34; key becomes special: when it is hit in a shell buffer Emacs
takes the current line - except maybe some initial characters that are
seen as a prompt - and sends that to the shell process, as if the user
had typed exactly that; so, Emacs takes over the line editor of the
shell process completely. The translation between character sequences
going through the pty and buffer-editing functions is very tricky,
full of non-obvious design choices, and even though it has been around
for more than 20 years it still has some (inevitable) quirks.</p>



<p>I almost never used shell buffers, so I found the following idea,
by OGAMI Itto, very surprising when he sent it to the eev mailing list
in 2005.</p>






<p>The current window, above in Figure 5, is editing an e-script, and
the other window shows a shell buffer - that we will refer to as the
&#34;target buffer&#34;. When the user types a certain key - by default F8 -
the current line is sent to the target buffer, and the point is moved
down to the next line; pressing F8 n times in sequence sendsn lines,
one by one.</p>



<p>One detail: &#34;sending a line&#34; means inserting its contents - except
the newline - at the current position in the target buffer, and then
running there the action associated to the &#34;Return&#34; key. &#34;Return&#34; is
almost always a special key, bound to different actions in different
major modes, so just inserting a newline would not work - that would
not simulate what happens when a user types &#34;Return&#34;.</p>

<a name="F8-is-simpler-than-F9"></a>




<p>Note that, in a sense, the action of F8 is much more complex than
that of F9, described in the last section; but user might perceive F8
as being much simpler, as there are no external programs involved
(Expect, eegchannel, xterm), and no setup hassles - all the machinery
to make Emacs buffers invoke external processes in buffers pretending
to be terminals (&#34;comint mode&#34;) comes built-in with Emacs since the
early 1980s.</p>



<p>Ogami&#39;s idea also included three &#34;bonus features&#34;: window setup,
reconstruction of the target buffer, and star-escapes. In the default
Emacs setting some commands - M-x shell between them - might split the
current Emacs frame in two windows; none of eev&#39;s hyperlink functions
do that, and I have always felt that it is more natural to use eev with
a setting (pop-up-windows set to nil) that disables window splittings
except when explicitly requested by the user. Anyway: M-x shell
ensures that a &#34;*shell*&#34; buffer is visible in a window, and that a
shell process is running in it; this setup code for F8,</p>






<p>splits the window (if the frame has just one window), and runs
`(shell)&#39; in the other window - with the right defaults - to force
that window to display a shell buffer with a live shell process
running in it; it also sets a variable, `eepitch-target-buffer&#39;, to
that buffer, so that the next `F8&#39;s will have a definite buffer to
send lines too - as target buffers need not necessarily be shell
buffers.</p>



<p>As for the star-escapes, it&#39;s the same idea as with F9: when a line
starts with a red star glyph, running F8 on it executes everything on
it - after the red star - as Lisp, and if there are no errors the
point is moved down. So lines starting with a red star can be used to
set up an eepitch target, to switch to another target, or to do
special actions - like killing a certain target so that it will be
reconstructed anew by the next F8. Note that once that we recognize
that a region of an e-script is to be used by eepitch there is only
one key to be used to &#34;run&#34; each of its lines, both the ones with red
stars and the ones without: F8. However, as with F9, the user must
know what to expect after each step. A badly-written e-script for
eepitch may try, for example, to &#34;cd&#34; into a directory that does not
exist, and if the next line is, say, &#34;<code>tar -xvzf
$S/http/foo/bar.tgz</code>&#34; then it will try to unpack a tarball into the
wrong place, creating a big mess.</p>




<h2><a name="eepitch-unprepared"></a><a href="#.eepitch-unprepared">21. Using eepitch to control unprepared shells</a></h2>

<div>
<pre># (find-eevfile &#34;eev.el&#34; &#34;EEVDIR&#34;)
# (find-eevfile &#34;eev.el&#34;)
</pre>
</div>




<p>As we have seen in section 4, M-x eev sends the region to a
&#34;prepared shell&#34;; if the shell has the right settings for the
environment variables $EEVTMPDIR and $EE, and if it has the shell
function `ee&#39;, then running `ee&#39; in the shell &#34;sources&#34; the temporary
script - corresponding to the regin - in verbose mode. Well, if Emacs
loads eev.el and the environment variables $EEVDIR, $EEVTMPDIR and $EE
are not set, then they are set, respectively, to the directory where
eev.el was read from, to the subdirectory of it given by $EEVDIR/tmp,
and to the file $EEVTMPDIR/ee.sh. Processes started from Emacs inherit
these environment variables, so a shell buffer created by running F8
on these two lines,</p>

<div>
<pre><SPAN color="red"><strong>*</strong></SPAN> (eepitch-shell)
function ee () { set -v; . $EE; set +v; }
</pre>
</div>




<p>will be running a prepared shell. Such buffers can be used to let
users understand better how prepared shells work, and decide if they
want to patch their initialization files for the shell (see
eev-rctool) so that their shells will be &#34;prepared&#34; by default.</p>



<p><i>(Note: I haven&#39;t yet played much with this idea - discuss
running eev-rctool on such shells (and a function that creates a
buffer with an e-script for that), and loading psne.sh from an
unprepared shell).</i></p>




<h2><a name="eepitch-gud"></a><a href="#.eepitch-gud">22. Controlling debuggers with eepitch</a></h2>

<small>

<p><i>[See also: <a href="http://angg.twu.net/.emacs.html.html#eepitch-gdb">.emacs</a>,
      <a href="http://lists.gnu.org/archive/html/eev/2007-07/msg00000.html">m.list</a>,
      <a href="http://article.gmane.org/gmane.emacs.eev.devel/47">gmane</a>]</i></p></small>






<p>On *NIX it is common to keep debuggers separated into two parts: a
back-end, with a simple textual interface, and a front-end, that
controls the back-end via its textual interface but presents a better
interface, showing source files and breakpoints in a nice way, etc.
The GNU Debugger, GDB, is a back-end, and it can be used to debug and
single-step several compiled languages; the &#34;Grand Unified Debugger&#34;
mode of Emacs, a.k.a. GUD, is a front-end for GDB and other
back-ends.</p>



<p>Usually, GUD splits an Emacs frame into two windows, one for
interaction with GDB (or other back-end, but let&#39;s say just &#34;GDB&#34; for
simplicity), and another one for displaying the source file where the
execution is. Some of the output of GDB - lines meaning, e.g., &#34;we&#39;re
at the source file foo.c, at line 25&#34; - are filtered by GUD and are
not shown in the GUD buffer; and the user can press special key
sequences on source files that generate commands to GDB - like, &#34;set a
breakpoint on this line&#34;.</p>



<p>In order to control GDB with eepitch we need a window setting with
three windows, like in the screenshot in Figure 6.</p>






<p>The way to set up that does not integrate very well with the
&#34;standard&#34; eepitch at this moment, but that should come with time.</p>





<h2><a name="eepitch-gdb"></a><a href="#.eepitch-gdb">23. E-scripting GDB with eepitch</a></h2>






<p>We can use elisp hyperlinks to point to specific lines in source
files - and we can combine these hyperlinks with the code to set up
breakpoints, in two ways.</p>

<div>
<pre><SPAN color="red"><strong>*</strong></SPAN>;(find-lua51file &#34;src/lvm.c&#34; &#34;case OP_CLOSE:&#34; 1)
<SPAN color="red"><strong>*</strong></SPAN> (find-lua51file &#34;src/lvm.c&#34; &#34;case OP_CLOSE:&#34; 1 &#39;(ee-tbr))
</pre>
</div>




<p>The first line above contains an elisp hyperlink to a line in the
source of Lua. Actually, it points to the code for an opcode in Lua&#39;s
virtual machine that most people find rather mysterious. As the line
starts with `<SPAN color="red"><strong>*</strong></SPAN>;&#39;, an F8 on it executes a Lisp comment - i.e., does
nothing - and moves down; only a `M-e&#39; (or a `C-e C-x C-e&#39;) on that
line would follow the hyperlink.</p>



<p>The second line, when executed with F8, would go to that line in
the source, then run `(ee-tbr)&#39; there; ee-tbr invokes gud-tbr to set a
temporary breakpoint on that source line (i.e., one that is disabled
when the execution stops there for the first time), and then buries
the buffer - the one with &#34;lmv.c&#34; - like a `M-K&#39; would do; the effect
is that the buffer in that window - the top-left window in a situation
like in Figure 6 - does not change, it will still show the e-script.</p>



<p>A variation on this is to wrap the hyperlink in an ee-tbr:</p>

<div>
<pre><SPAN color="red"><strong>*</strong></SPAN> ;        (find-lua51file &#34;src/lvm.c&#34; &#34;case OP_CLOSE:&#34; 1)
<SPAN color="red"><strong>*</strong></SPAN> (ee-tbr &#39;(find-lua51file &#34;src/lvm.c&#34; &#34;case OP_CLOSE:&#34; 1))
</pre>
</div>




<p>When ee-tbr is called with an argument it evaluated the argument
inside a save-excursion, and sets a breakpoint there; the effect is
almost the same as the previous case, but this does not change the
order of the buffers in the buffer list.</p>



<h2><a name="little-dbg-langs"></a><a href="#.little-dbg-langs">24. Two little languages for debugging</a></h2>



<p>E-scripts for eepitch and GDB can be used to bring programs to a
certain point (and to inspect their data structures there; we will
have more to say about this in the next section). In a sense, as in
<strong>{Bentley}</strong>, these e-scripts are written in a language that
describes states of running programs - and they can be executed step
by step.</p>



<p>These e-scripts, being executable, can be used in e-mails to
communicate particular states of programs - say, where a certain bug
occurs. Unfortunately, they are too fragile and may cease working
after minimal changes in the program, and they are almost impossible
to read...</p>



<p>However, the screenshot in Figure 5 suggests another language for
communicating controlling programs with GDB: the contents of the
&#34;*gud*&#34; buffer. After removing some excess verbosity by hand we get
something that is readable enough if included in e-mails - and to
extract the original commands from that we just have to discard the
lines that don&#39;t start with &#34;(gdb)&#34;, then remove the &#34;(gdb)&#34; prompts.
As for the hyperlinks with `(ee-tbr)&#39;, they may need to be copied to
the GUD buffer, and not filtered out; we still need to experiment with
different ways to do that to be able to choose one.</p>



<h2><a name="inspecting-data"></a><a href="#.inspecting-data">25. Inspecting data in running programs</a></h2>



<p>Almost anyone who has learned a bit of Lisp should be familiar with
this kind of box diagrams. After running</p>

<div>
<pre>(setq x &#39;(5 &#34;ab&#34;))
(setq y (list x x &#39;(5 &#34;ab&#34;)))
</pre>
</div>




<p>the value of y can be represented by:</p>

<div>
<pre> ___ ___       ___ ___             ___ ___    
|___|___| --&gt; |___|___| --------&gt; |___|___| --&gt; nil
  | ___________/                    |
  |/                                |
 _v_ ___       ___ ___             _v_ ___       ___ ___       
|___|___| --&gt; |___|___| --&gt; nil   |___|___| --&gt; |___|___| --&gt; nil
  |             |                   |             |
  v             v                   v             v
  5            &#34;ab&#34;                 5            &#34;ab&#34;               
</pre>
</div>




<p>This representation is verynice - it omits lots of details that are
usually irrelevant, like the address in the memory of each cons, and
the exact names of each struct in C and their fields. But sometimes we
need to understand the implementation in C, and a more complete
diagram would be convenient. At least, we would like to know how to
get, in the C source of Emacs, from the address of the leftmost cons
in the top line to the rightmost &#34;ab&#34; in the bottom line - but how do
we express following the &#34;cdr&#34; arrows, the &#34;car&#34; arrows, and
extracting the contents of a string object in elisp, One solution is
to use GDB, and e-scripts for it:</p>






<p>A &#34;complete diagram&#34; corresponding to the one above, whatever the
format that we choose to draw it, should include some information
explaining that &#34;cdr&#34; arrows correspond to &#34;-&gt;cdr&#34;, &#34;car&#34; arrows
correspond to ..., and each string object corresponds to another kind
of box different from the cons boxes; to get to the C string stored in
an elisp string object we should examine its &#34;foo&#34; field, i.e., do a
&#34;-&gt;foo&#34;.</p>



<p>Obviously, this same idea applies also to other programs with
complex data structures - and for some programs we may even have
fancier ways to explore their data structures; for example, in a
graphic toolkit it might be possible to change the background of a
button to orange from GDB.</p>











<hr size="1"/>



<h2><a name="big-modular-e-scripts"></a><a href="#.big-modular-e-scripts">26. Big Modular E-scripts</a></h2>





<p>A shell can be run in two modes: either interactively, by expecting
lines from the user and executing them as soon as they are
received\footnote{except for multi-line commands.}, or by scripts: in
the later case the shell already has access to the commands, and
executes them in sequence as fast as possible, with no pause between
one command and the next.</p>



<p>When we are sending lines to a shell with F9 we are telling it not
only <i>what</i> to execute but also <i>when</i> to execute it; this is
somewhat similar to running a program step-by-step inside a debugger
--- but note that most shells provide no single-stepping facilities.</p>



<p>We will start with a toy example --- actually the example from
Section \ref{anchors} with five new lines added at the end --- and
then in the next section we will see a real-world example that uses
these ideas.</p>

<div>
<pre>  Figure 4: sending a block at once with eevnow-at
  (find-fline &#34;ss-modular.png&#34;)

  Figure 5: single-stepping through a C program
  (find-fline &#34;ss-gdbwide.png&#34;)
</pre>
</div>




<p>((Somewhere between a script and direct user interaction))</p>



<p>((No loops, no conditionals))</p>



<p>((Several xterms))</p>





<h2><a name="iskidip"></a><a href="#.iskidip">27. Internet Skills for Disconnected People</a></h2>



<p>Suppose that we have a person <i>P</i> who has learned how to use a
computer and now wants to learn how the internet works. That person
<i>P</i> knows a bit of programming and can use Emacs, and sure she can
use e-mail clients and web browsers by clicking around with the mouse,
but she has grown tired of just using those things as black boxes; now
she wants to experiment with setting up HTTP and mail servers, to
understand how data packets are driven around, how firewalls can block
some connections, such things.</p>



<p>The problem is that <i>P</i> has never had access to any machine
besides her own, which is connected to the internet only through a
modem; and also, she doesn&#39;t have any friends who are computer
technicians or sysadmins, because from the little contact that she&#39;s
had with these people she&#39;s got the impression that they live lifes
that are almost as grey as the ones of factory workers, and she&#39;s
afraid of them. To add up to all that, <i>P</i> has some hippie job that
makes her happy but poor, so she&#39;s not going to buy a second computer,
and the books she can borrow, for example, Richard Stevens&#39; series on
TCP/IP programming, just don&#39;t cut.</p>



<p>One of eev&#39;s intents isto make life easier for autodidacts. Can it
be used to rescue people in positions like <i>P</i>&#39;s(4)? It was
thinking on that that I created a side-project to eev called “Internet Skills for Disconnected People”: it consists of e-scripts
about running a second machine, called the “guest”, emulated inside
the “host”, and making the two talk to each other via standard
internet protocols, via emulated ethernet cards. Those e-scripts make
heavy use of the concepts in the last section ((...))</p>

<div>
<pre>  Figure 6: a call map
  (find-fline &#34;iskidip.png&#34;)
  (find-eimage0 &#34;./iskidip.png&#34;)

% (find-eevex &#34;busybox.e&#34; &#34;bb_chroot_main&#34;)
% (find-eevex &#34;busybox.e&#34; &#34;bbinitrd-qemu-main&#34;)
% (find-eevex &#34;busybox.e&#34; &#34;iso-qemu-main&#34;)
% (find-eevex &#34;busybox.e&#34; &#34;iso-qemu-main-2&#34;)
</pre>
</div>




<p>(4). by the way, I created <i>P</i> inspired on myself; my hippie job
is being a mathematician.</p>






<h2><a name="availability"></a><a href="#.availability">28. Availability and Resources</a></h2>



<p>Eev can be downloaded from the author&#39;s homepage, <a href="http://angg.twu.net/">http://angg.twu.net/</a>. That page also contains lots of examples, some
animations showing some of eev&#39;s features at work, a mailing list,
etc.</p>



<p>Eev is in the middle of the process of becoming a standard part of
GNU Emacs; I expect it to be integrated just after the release of GNU
Emacs 22.1 in mid-2007. Eev&#39;s copyright has already been transferred
to the FSF; it is distributed under the GPL license.</p>




<h2><a name="acknowledgments"></a><a href="#.acknowledgments">Acknowledgments</a></h2>



<p>I would like to thank David O&#39;Toole, Diogo Leal and Leslie Watter
for our countless hours of discussions about eev; many of the recent
features of eev --- almost half of this article --- were conceived at
our talks.</p>



<p>((Thank also the people at #emacs, for help with the code and for
  small revision tips))</p>




<h2><a name="references"></a><a href="#.references">References</a></h2>



<p>[L90] - Libes, D. - Expect: Curing Those Uncontrollable Fits of
Interaction. 1990. Available online from <a href="http://expect.nist.gov/">http://expect.nist.gov/</a>.</p>



<p>[L95] - Libes, D. - Exploring Expect. O&#39;Reilly, 1995.</p>



<p>[O99] - Ochs, E. - The Eev Manifesto (<a href="http://angg.twu.net/eev-manifesto.html">http://angg.twu.net/eev-manifesto.html</a>).</p>



<p>[S79] - Stallman, R. - EMACS: The Extensible, Customizable Display
Editor. (<a href="http://www.gnu.org/software/emacs/emacs-paper.html">http://www.gnu.org/software/emacs/emacs-paper.html</a>)</p>



  </td>
  </tr>
  </tbody></div></div>
  </body>
</html>
