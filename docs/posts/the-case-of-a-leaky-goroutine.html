<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brainbaking.com/post/2024/03/the-case-of-a-leaky-goroutine/">Original</a>
    <h1>The case of a leaky goroutine</h1>
    
    <div id="readability-page-1" class="page"><article>
	    <div>
	  		<p>In the programming language Go, it’s <em>very</em> easy to build something using high-level concurrent patterns thanks to the concept of <em>Goroutines</em> and channels used to signal between them. A Goroutine is essentially a coroutine that maps onto green threads that map onto real native threads on your OS in an <code>NxM</code> way. The simple <code>go func()</code> prepend-style syntax makes fire-and-forget Goroutines for executing small tasks in parallel trivial.</p>
<p>Or is it? If we are to believe Katherine Cox-Buday, the author of O’Reilly’s <a href="https://katherine.cox-buday.com/concurrency-in-go/">Concurrency In Go</a>, it’s not:</p>
<blockquote>
<p>Concurrency can be notoriously difficult to get right, but fortunately, the Go programming language was designed with concurrency in mind. In this practical book, you’ll learn how Go was written to help introduce and master these concepts, as well as how to use basic concurrency patterns to form large systems that are reliable and remain simple and easy to understand.</p>
</blockquote>
<p>That sounds rather optimistic, but the countless of <em>memory leaks in Go and how to avoid them</em> articles and <a href="https://github.com/uber-go/goleak">leak detection packages</a> tell us otherwise. The most common misuses or cases of “leaky” Goroutines—routines that live on forever even though we think they’re garbage collected—are neatly laid out by Uber’s Georgian-Vlad Saioc in their <a href="https://www.uber.com/en-BE/blog/leakprof-featherlight-in-production-goroutine-leak-detection/">LeakProf Goroutine Leak Detection</a> system.</p>
<p>We stumbled upon a leaky gut—erm, code gut?—two weeks ago when an Out Of Memory suddenly restarted Kubernetes pods halfway through workflow runs that of course are not quite idempotent. Not knowing where to begin, we fired up Go’s profiler <code>pprof</code> and got to work. After a day of poking around, we found our own version of a never-ending Goroutine factory. This post summarizes our findings in case they might come in handy for others or my future self.</p>
<h2 id="identifying-the-problem-profiling">Identifying the problem (Profiling)</h2>
<p>Grafana’s dashboard can monitor Goroutine memory usage and seeing it spike without going down is an obvious red flag, but doesn’t give you details just yet. For that, you can stay with the Grafana stack using <a href="https://grafana.com/docs/pyroscope/latest/">Pyroscope</a> that charts out interactive memory flame graphs based on <code>pprof</code> dumps it pulls from your container (provided the whole setup shebang is done right):</p>
<figure>
	
		
	
	<a href="https://brainbaking.com/post/2024/03/the-case-of-a-leaky-goroutine/../pyroscope.jpg">
		<img src="https://brainbaking.com/post/2024/03/the-case-of-a-leaky-goroutine/../pyroscope.jpg" loading="lazy" title="A pyroscope goroutine zoomed in view." data-pagefind-index-attrs="title"/>
	</a>
	
		<figcaption>A pyroscope goroutine zoomed in view.</figcaption>
	
</figure>

<p>The chart tells us that <code>runtime.gopark</code> is holding onto Goroutines coming from pipeline <code>func</code>s we didn’t even know existed. Lo and behold, these convert contexts into channels using generic <code>interface{}</code>s as part of the pipeline by creating a Goroutine and waiting for the channel to be done—except that it’ll never be, since the context that’s passed in isn’t a derived one like <code>.WithCancel()</code>. In other words, the context will cancel if the whole root request ends—which can be never for a background job with a background context. Whoops. We’ll get back to that.</p>
<p>You can also run Pyroscope locally using Docker, by the way: <code>docker run -it -p 4040:4040 grafana/pyroscope</code>.</p>
<p>If you don’t care about Grafana, no worries, <code>pprof</code> comes with a HTTP server or attaches itself to yours once you import <code>import _ &#34;net/http/pprof&#34;</code>. From now on, <code>/debug/pprof/</code> is an endpoint where heap/CPU/whatever can be dumped from using for instance CURL. See the <a href="https://go-language.org/go-docs/runtime/pprof/">Official pprof docs</a> and the <a href="https://go.dev/blog/pprof">Go dev blog entry on pprof</a> for more information.</p>
<p>Once you managed to get your profile dump, you can analyze it with <code>go tool pprof [profile_file]</code>. If you’ve installed <code>graphviz</code>, it’ll generate visual representation of your snapshot, as seen in the aforementioned Go dev blog entry<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. The most interesting view is of course a diff between a baseline and one after lots of leaky Goroutine work—use the <code>diff_base</code> flag for that (see the <a href="https://go.dev/blog/pgo">Go dev blot entry on pgo</a>). Profile percentages are relative to the first dump.</p>
<p>Let’s get back to that context that’s never truly cancelled. This piece of code is the perpetrator:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>ToDoneInterface</span>(<span>done</span> <span>&lt;-</span><span>chan</span> <span>struct</span>{}) <span>&lt;-</span><span>chan</span> <span>interface</span>{} {
</span></span><span><span>    <span>interfaceStream</span> <span>:=</span> <span>make</span>(<span>chan</span> <span>interface</span>{})
</span></span><span><span>    <span>go</span> <span>func</span>() {
</span></span><span><span>       <span>defer</span> <span>close</span>(<span>interfaceStream</span>)
</span></span><span><span>       <span>select</span> {
</span></span><span><span>       <span>case</span> <span>&lt;-</span><span>done</span>:
</span></span><span><span>          <span>return</span>
</span></span><span><span>       }
</span></span><span><span>    }()
</span></span><span><span>    <span>return</span> <span>interfaceStream</span>
</span></span><span><span>}
</span></span></code></pre></div><p>The <code>defer close()</code> seems to close well, but it’s on the wrong channel. The <code>select{}</code> will wait until it received a signal from <code>done</code>: that’s either when something is sent or when a <code>close()</code> has been called (a <code>nil</code> value). So, the Goroutine closes the channel <strong>after</strong> the first received <code>struct{}</code> on the passed <code>done</code> channel. If we pass the same channel multiple times—which we do—and that channel lives longer than is the case wich <code>ctx.Done()</code>—which it is—this Goroutine will leak.</p>
<p>I don’t know if that all makes sense if you’re not familiar with Go, or even if you are. I know I had to stare at the above code block for a good hour and its usage context (got it, <code>Context</code>? Go-joke!) before realizing something wasn’t as it was supposed to be here.</p>
<h2 id="reproducing-the-problem-fixing">Reproducing the problem (Fixing)</h2>
<p>There’s a neat way to detect memory leaks in tests using the package <a href="https://github.com/uber-go/goleak">goleak</a>:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>TestA</span>(<span>t</span> <span>*</span><span>testing</span>.<span>T</span>) {
</span></span><span><span>  <span>defer</span> <span>goleak</span>.<span>VerifyNone</span>(<span>t</span>)
</span></span><span><span>
</span></span><span><span>  <span>// test logic here.
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>It works by looking at what’s still on the stack after everything should be garbage-collected. We then cooked up a script that spins up a consume/produce cycle using <code>context.Background()</code> as the root context without cancellation and then with it. The Pyroscope Go API can act as a helpful shortcut to auto-feed profiles straight from your program.</p>
<p>The most systematic way to detect leaky Goroutines early must be Uber’s <a href="https://www.uber.com/en-BE/blog/leakprof-featherlight-in-production-goroutine-leak-detection/">LeakProf</a>, a separately deployed system that regularly pulls in <code>pprof</code> dumps, enriches it with stack data, closely monitors memory usage, and even automatically files a bug report in case the shit hits the fan. I don’t think we’re there yet!</p>
<p>Conclusion: the problem is often hidden in a small corner… Don’t convert channels! Stick with Go’s built-in context pattern and derive from the one passed in if needed!</p>



		    
  			<p>
		       <svg width="24" height="24">
		            <title>tags icon</title>
		            <use xlink:href="#tag"></use>
		        </svg>
			    <span>
			        
			            <a href="https://brainbaking.com/tags/go" title="Tag: go"><kbd>go</kbd></a>
			        
			    </span>
			</p>
		    
	  	</div>
	</article></div>
  </body>
</html>
