<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zackoverflow.dev/writing/flappy-bird-in-type-level-typescript/">Original</a>
    <h1>Flappy Bird implemented in TypeScript types</h1>
    
    <div id="readability-page-1" class="page"><div>
			<article>
				
                <span>10/19/2023</span>
				
				<!-- {pubDate && <time>{pubDate.toString()}</time>} -->
				
				
	
	<p>The ultimate type-level trickery</p>
	<hr/>
	<p>I wrote a 2D flappy bird game, <i>purely in Typescript types</i>:</p>
<video playsinline="" controls="" src="/video/flap.mp4"></video>
<p>Yes you heard that right, this game is written entirely in Typescript type annotations, which—if you didn’t know—are Turing complete.</p>
<p>So how the hell am I runnning it in the browser and rendering the game in Typescript types?</p>
<p>The basic rundown is that I created a type-level Typescript runtime, allowing Typescript types to be run <i>outside</i> of the Typescript compiler/language server.</p>
<p>This “runtime” is a custom VM implemented in Zig, which executes a custom bytecode format I compile Typescript code into.</p>
<p>Let me go into more detail.</p>
<p>(Run the game <a href="https://tyvm.100x.software/">here</a>)</p>

Now, the actual type-level Typescript code for the game is surprisingly simple. First, you must understand that type-level Typescript is like a purely functional programming language. A key tenet of pure and functional programming languages is that <i>state</i> is <i>immutable</i>.
<p>So instead of mutating some global game state (bird position, the pipes, etc.), we thread the game state through a series of functions which each return a <i>new</i> copy of the game state updated. Every frame, the game does something like this:</p>
<pre tabindex="0"><code><span><span>type</span><span> </span><span>newGameState</span><span> </span><span>=</span><span> </span><span>MovePipes</span><span>&lt;</span><span>ApplyGravity</span><span>&lt;</span><span>HandleJump</span><span>&lt;</span><span>gameState</span><span>&gt;&gt;&gt;</span></span>
<span></span></code></pre>
<p>I find this elegantly beautiful, it’s very clear to see the transformations that happen on the game state.</p>
<p>The next tricky part is rendering the game. We need to draw the bird, the pipes, and the background.</p>
<p>Drawing inspiration from graphics APIs, I had the idea to give the game state a <i>command buffer</i>: an array of drawing commands. A draw command looks a bit like this:</p>
<pre tabindex="0"><code><span><span>export</span><span> </span><span>type</span><span> </span><span>DrawCommand</span><span> </span><span>=</span></span>
<span><span>  </span><span>// Draw an image/sprite</span></span>
<span><span>  </span><span>|</span><span> </span><span>{</span></span>
<span><span>      </span><span>type</span><span>:</span><span> </span><span>DrawCommandKindImage</span><span>;</span></span>
<span><span>      </span><span>img</span><span>:</span><span> </span><span>string</span><span>;</span></span>
<span><span>      </span><span>x</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>y</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>width</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>height</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>    </span><span>}</span></span>
<span><span>  </span><span>// Clear the screen</span></span>
<span><span>  </span><span>|</span><span> </span><span>{</span></span>
<span><span>      </span><span>type</span><span>:</span><span> </span><span>DrawCommandKindClearCanvas</span><span>;</span></span>
<span><span>      </span><span>x</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>y</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>width</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>      </span><span>height</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>    </span><span>};</span></span>
<span></span></code></pre>
<p>Then the task of “rendering” is really just filling the command buffer with the appropriate draw commands to display our game, which can be neatly done at the end of our game state transformations:</p>
<pre tabindex="0"><code><span><span>// Returns new GameState with draw commands for this frame added</span></span>
<span><span>type</span><span> </span><span>Draw</span><span>&lt;</span><span>State</span><span> </span><span>extends</span><span> </span><span>GameState</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>State</span><span> </span><span>&amp;</span><span> </span><span>{</span></span>
<span><span>  </span><span>drawCommands</span><span>:</span><span> [</span></span>
<span><span>    </span><span>// Draw the background</span></span>
<span><span>    </span><span>{</span></span>
<span><span>      </span><span>type</span><span>:</span><span> </span><span>Image</span><span>;</span></span>
<span><span>      </span><span>imgUrl</span><span>:</span><span> </span><span>&#34;</span><span>/background.png</span><span>&#34;</span><span>;</span></span>
<span><span>      </span><span>x</span><span>:</span><span> </span><span>0</span><span>;</span></span>
<span><span>      </span><span>y</span><span>:</span><span> </span><span>0</span><span>;</span></span>
<span><span>      </span><span>width</span><span>:</span><span> </span><span>canvasWidth</span><span>;</span></span>
<span><span>      </span><span>height</span><span>:</span><span> </span><span>canvasHeight</span><span>;</span></span>
<span><span>    </span><span>},</span></span>
<span></span>
<span><span>    </span><span>// Draw the bird</span></span>
<span><span>    </span><span>{</span></span>
<span><span>      </span><span>type</span><span>:</span><span> </span><span>Image</span><span>;</span></span>
<span><span>      </span><span>imgUrl</span><span>:</span><span> </span><span>&#34;</span><span>/bird.png</span><span>&#34;</span><span>;</span></span>
<span><span>      </span><span>x</span><span>:</span><span> </span><span>birdX</span><span>;</span></span>
<span><span>      </span><span>y</span><span>:</span><span> </span><span>birdY</span><span>;</span></span>
<span><span>      </span><span>width</span><span>:</span><span> </span><span>birdW</span><span>;</span></span>
<span><span>      </span><span>height</span><span>:</span><span> </span><span>birdHeight</span><span>;</span></span>
<span><span>    </span><span>},</span></span>
<span></span>
<span><span>    </span><span>// Draw every pipe</span></span>
<span><span>    </span><span>...</span><span>DrawPipes</span><span>&lt;</span><span>State</span><span>[</span><span>&#34;</span><span>pipes</span><span>&#34;</span><span>]</span><span>&gt;</span></span>
<span><span>  ]</span><span>;</span></span>
<span><span>};</span></span>
<span></span></code></pre>
<p>Each frame, the game state is updated, the command buffer populated, and then the runtime takes these draw commands and executes them.</p>
<p>And that’s the core game loop! Obviously, I skipped over a lot of details. The rest is just mostly verbose Typescript code for checking collision of the bird on the pipes, ground etc. You can check out the full game code <a href="https://github.com/zackradisic/tyvm/blob/bf9a0683411784afd2bd19aed8b24dc401fe935e/site/public/flap.ts">here</a>.</p>

So how does this runtime work?
<p>There are two main parts:</p>
<ul>
<li>
<p>The compiler: Written in Rust, takes Typescript source code and spits out bytecode</p>
</li>
<li>
<p>The VM: Written in Zig, a custom stack-based virtual machine that runs the bytecode to evaluate types</p>
</li>
</ul>
<p>I’ve compiled the runtime to Wasm, so it takes the draw commands from the game and executes them using the web canvas API. Conceptually, the runtime could use any graphics backend like OpenGL, Vulkan, Metal, etc.</p>
<p>The VM has specialized instructions for computations that would otherwise be expensive in regular type-level Typescript. A prominent group of such expensive computations are arithmetic operations.</p>
<p>In type-level Typescript, you can “hack” arithmetic by using <a href="https://medium.com/@taitasciore/arithmetic-operations-in-the-typescript-type-system-because-why-not-cfc2253a93c9">arrays</a>, or <a href="https://softwaremill.com/implementing-advanced-type-level-arithmetic-in-typescript-part-1/">template strings</a>. Both are extremely expensive operations, especially in comparison to how trivial arithmetic is for the CPU to compute normally.</p>
<p>I decided to provide a standard library with functions that get compiled into specialized and very performant instructions in the VM:</p>
<pre tabindex="0"><code><span><span>import</span><span> </span><span>{</span></span>
<span><span>  </span><span>// Prints a value to console</span></span>
<span><span>  </span><span>Print</span><span>,</span></span>
<span><span>  </span><span>// Addition</span></span>
<span><span>  </span><span>Add</span><span>,</span></span>
<span><span>  </span><span>// Subtraction</span></span>
<span><span>  </span><span>Sub</span><span>,</span></span>
<span><span>  </span><span>// Less-than-or-equal-to operator</span></span>
<span><span>  </span><span>Lte</span><span>,</span></span>
<span><span>}</span><span> </span><span>from</span><span> </span><span>&#34;</span><span>std</span><span>&#34;</span><span>;</span></span>
<span></span>
<span><span>// Compute the Xth fibonnaci number</span></span>
<span><span>type</span><span> </span><span>Fib</span><span>&lt;</span><span>X</span><span> </span><span>extends</span><span> </span><span>number</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Lte</span><span>&lt;</span><span>X</span><span>,</span><span> </span><span>1</span><span>&gt;</span><span> </span><span>extends</span><span> </span><span>true</span></span>
<span><span>  </span><span>?</span><span> </span><span>X</span></span>
<span><span>  </span><span>:</span><span> </span><span>Add</span><span>&lt;</span><span>Fib</span><span>&lt;</span><span>Sub</span><span>&lt;</span><span>X</span><span>,</span><span> </span><span>1</span><span>&gt;&gt;,</span><span> </span><span>Fib</span><span>&lt;</span><span>Sub</span><span>&lt;</span><span>X</span><span>,</span><span> </span><span>2</span><span>&gt;&gt;&gt;;</span></span>
<span></span>
<span><span>// The &#34;main&#34; function</span></span>
<span><span>// Compute the 35th fibonacci number and print it</span></span>
<span><span>export</span><span> </span><span>type</span><span> </span><span>Main</span><span>&lt;</span><span>Args</span><span> </span><span>extends</span><span> </span><span>string</span><span>[]</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>Print</span><span>&lt;</span><span>Fib</span><span>&lt;</span><span>35</span><span>&gt;&gt;;</span></span>
<span></span></code></pre>
<p>I’m pretty excited about all the cool optimizations I can implement in the VM. I mentioned earlier that type-level Typescript is like a purely functional programming language. We can actually borrow a lot of cool optimizations from the implementation of FP languages:</p>
<ul>
<li>
<p>Performant immutable data structures: <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">hash array mapped tries</a>, <a href="https://medium.com/@abhi18av/immutable-data-structures-rrb-trees-part-1-177a986950ec">RRB trees</a></p>
</li>
<li>
<p>Specialized reference counting with reuse (<a href="https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse/">Perceus</a>)</p>
</li>
<li>
<p>Tail call optimization (I’ve already implemented this)</p>
</li>
</ul>

I’m pretty happy with the split of using Rust for the frontend, and Zig for the hardcore low-level implementation of the VM.
<p>Rust’s high-level and zero-cost abstractions make it well suited for walking ASTs and generating bytecode, with speed. Also, instead of writing another Typescript parser, I get to leverage the Typescript parser of the <a href="https://github.com/web-infra-dev/oxc/">oxc project</a>, which is the best JS/TS parser I’ve used so far<sup><a id="footnote-ref-1" href="#footnote-1">1</a></sup>.</p>

This type-level Typescript runtime started out as a type-checker for Typescript I call <code>tyvm</code>.
<p>The idea of using a VM to exponentially speed up type-checking has been <a href="https://github.com/marcj/TypeRunner/">tried before</a>.</p>
<p>I decided to try my hand at it because:</p>
<ol>
<li>
<p>I just find this stuff fun!</p>
</li>
<li>
<p>I had the idea to focus on supporting <i>only type-level</i> Typescript first.</p>
</li>
</ol>
<p>My plan was that, because of the simplicity of <i>just</i> type-level Typescript, we could nail down that aspect first, before moving onto type-checking the entirety of Typescript.</p>
<p>This would allow <code>tyvm</code> to be useful far more quickly.</p>
<p>An example is that it could be used for Typescript tooling. There are a lot of tools that convert Typescript types to <code>X</code> (where <code>X</code> is something like GraphQL, Prisma schemas, JSON types, etc.), but all of them are pretty limited by not being able to support complex Typescript types.</p>
<p>This could jumpstart my dream of making type-level Typescript a very powerful DSL for writing schemas. For example:</p>
<pre tabindex="0"><code><span><span>export</span><span> </span><span>type</span><span> </span><span>User</span><span> </span><span>=</span><span> </span><span>{</span></span>
<span><span>  </span><span>id</span><span>:</span><span> </span><span>string</span><span>;</span></span>
<span><span>  </span><span>name</span><span>:</span><span> </span><span>string</span><span>;</span></span>
<span><span>  </span><span>age</span><span>:</span><span> </span><span>number</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>export</span><span> </span><span>type</span><span> </span><span>Mutation</span><span> </span><span>=</span><span> </span><span>{</span></span>
<span><span>  </span><span>updateUser</span><span>:</span><span> </span><span>(</span><span>args</span><span>:</span><span> </span><span>{</span><span> </span><span>id</span><span>:</span><span> </span><span>User</span><span>[</span><span>&#39;</span><span>id</span><span>&#39;</span><span>]</span><span>,</span><span> </span><span>fields</span><span>:</span><span> </span><span>Partial</span><span>&lt;</span><span>Omit</span><span>&lt;</span><span>User</span><span>,</span><span> </span><span>&#39;</span><span>id</span><span>&#39;</span><span>&gt;&gt;</span><span> </span><span>})</span><span> </span><span>=&gt;</span><span> </span><span>Promise</span><span>&lt;</span><span>User</span><span>&gt;</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>When running the <code>updateUser</code> mutation, we can update any field from the <code>User</code> type (except for its ID of course). Without Typescript types, I’d have to rewrite all the field types, and that can be error prone if I change <code>User</code> but forget to update the mutation arguments.</p>
<p>To me it’s way more expressive to use Typescript’s type manipulation utilities to write schemas.</p>
<p>Check out the code for the flappy bird game and <code>tyvm</code> <a href="https://github.com/zackradisic/tyvm/">here</a>!</p>



			</article>
		</div></div>
  </body>
</html>
