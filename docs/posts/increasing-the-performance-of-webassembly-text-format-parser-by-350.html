<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gplane.win/posts/improve-wat-parser-perf.html">Original</a>
    <h1>Increasing the performance of WebAssembly Text Format parser by 350%</h1>
    
    <div id="readability-page-1" class="page"><article><p>The WAT (WebAssembly Text Format) parser in <a target="_blank" rel="noopener" href="https://github.com/g-plane/wasm-language-tools">wasm-language-tools</a> v0.5 or before was not fast enough. Recently I have rewritten the parser from scratch, and the performance has been increased by 350% in the benchmark.</p><h2 id="Use-hand-written-parser"><a href="#Use-hand-written-parser">¶</a>Use hand-written parser</h2><p>The old parser was written with <a target="_blank" rel="noopener" href="https://github.com/winnow-rs/winnow">winnow</a> which is a parser combinator library.</p><h2 id="Clone-well-known-green-tokens-and-green-nodes"><a href="#Clone-well-known-green-tokens-and-green-nodes">¶</a>Clone well-known green tokens and green nodes</h2><p>There’re many parentheses and keywords in WAT. For these tokens and nodes, they shouldn’t be created again and again when parsing.</p><h2 id="Keyword-matching"><a href="#Keyword-matching">¶</a>Keyword matching</h2><p>There’re many keywords in WAT such as <code>module</code>, <code>func</code>, <code>param</code>, <code>result</code>, etc.</p><p>Instead, we check the prefix of source code in bytes:</p><pre data-language="rust"><code><span>self</span><span>.</span>input<span>.</span><span>as_bytes</span><span>(</span><span>)</span><span>.</span><span>starts_with</span><span>(</span>keyword<span>.</span><span>as_bytes</span><span>(</span><span>)</span><span>)</span></code></pre><p>However, there may be a word like <code>function</code> that starts with <code>func</code> but it isn’t a keyword, so we must check the next character is not an identifier character.</p><h2 id="Use-get-unchecked-to-create-token"><a href="#Use-get-unchecked-to-create-token">¶</a>Use <code>get_unchecked</code> to create token</h2><p>Except strings and comments, other kinds of tokens are just ASCII strings.</p><h2 id="Use-our-own-Token-type"><a href="#Use-our-own-Token-type">¶</a>Use our own <code>Token</code> type</h2><p>The lexer will produce tokens in our own <code>Token</code> type instead of <code>rowan::GreenToken</code>,</p><p>The <code>Token</code> type is simple as below:</p><pre data-language="rust"><code><span>struct</span> <span>Token</span><span>&lt;</span><span>&#39;s</span><span>&gt;</span> <span>{</span>
    kind<span>:</span> <span>SyntaxKind</span><span>,</span>
    text<span>:</span> <span>&amp;</span><span>&#39;s</span> <span>str</span><span>,</span>
<span>}</span></code></pre><p>For convenience, I added <code>impl From&lt;Token&lt;&#39;_&gt;&gt; for rowan::NodeOrToken&lt;rowan::GreenNode, rowan::GreenToken&gt;</code>.</p><p>When creating a <code>rowan::GreenNode</code>, an iterator whose items are <code>rowan::NodeOrToken&lt;rowan::GreenNode, rowan::GreenToken&gt;</code>s is required.</p><p>At first, we may create a new <code>Vec</code> for each node. However, this will create many temporary <code>Vec</code>s because a syntax tree contains many nodes, which causes many allocations and deallocations.</p><p>Instead, inspired by <code>rowan::GreenNodeBuilder</code>, we only create a single shared <code>Vec</code> in the parser.</p><p>But, how to know which range to drain? Certainly the end of the range is the current length of the <code>Vec</code>.</p><p>This is stack-like naturally, though we don’t need to create an explicit stack,</p><p>There is nothing similar to <code>rowan::GreenNodeBuilder::start_node_at</code> in our implementation,</p><h2 id="Result"><a href="#Result">¶</a>Result</h2><p>The code snippet below is used in the benchmark:</p><pre data-language="wasm"><code><span>(</span><span>module</span>
    <span>(</span><span>func</span> <span>$f1</span> <span>(</span><span>param</span> <span>$p1</span> <span>i32</span><span>)</span> <span>(</span><span>param</span> <span>$p2</span> <span>i32</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span>
        <span>(</span><span>i32<span>.</span>add</span> <span>(</span><span>local</span>.get <span>$p1</span><span>)</span> <span>(</span><span>local</span>.get <span>$p2</span><span>)</span><span>)</span>
    <span>)</span>
    <span>(</span><span>global</span> <span>$g1</span> <span>f64</span> <span>(</span><span>f64<span>.</span>const</span> <span>0</span><span>)</span><span>)</span>
    <span>(</span><span>func</span> <span>$f2</span> <span>(</span><span>result</span> <span>f64</span><span>)</span>
        <span>(</span><span>global</span>.get <span>$g1</span><span>)</span>
    <span>)</span>
    <span>(</span><span>type</span> <span>$t</span> <span>(</span><span>func</span> <span>(</span><span>result</span> <span>f64</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>func</span> <span>$f3</span> <span>(</span><span>type</span> <span>$t</span><span>)</span>
        <span>(</span><span>call</span> <span>$f2</span><span>)</span>
    <span>)</span>
    <span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;f32.min_positive&#34;</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span> <span>(</span><span>i32</span>.reinterpret_f32 <span>(</span><span>f32<span>.</span>const</span> <span>0x1p-149</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;f32.min_normal&#34;</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span> <span>(</span><span>i32</span>.reinterpret_f32 <span>(</span><span>f32<span>.</span>const</span> <span>0x1p-126</span><span>)</span><span>)</span><span>)</span>

    <span>(</span>rec <span>(</span><span>type</span> <span>$r</span> <span>(</span>sub <span>$t</span> <span>(</span>struct <span>(</span>field <span>(</span>ref <span>$r</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>global</span>  <span>(</span><span>mut</span> <span>f32</span><span>)</span> <span>(</span><span>f32<span>.</span>const</span> <span>-13</span><span>)</span><span>)</span>
    <span>(</span>rec
        <span>(</span><span>type</span> <span>$t1</span> <span>(</span>sub <span>(</span><span>func</span> <span>(</span><span>param</span> <span>i32</span> <span>(</span>ref <span>$t3</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
        <span>(</span><span>type</span> <span>$t2</span> <span>(</span>sub <span>$t1</span> <span>(</span><span>func</span> <span>(</span><span>param</span> <span>i32</span> <span>(</span>ref <span>$t2</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
    <span>)</span>
    <span>(</span><span>global</span>  <span>(</span><span>mut</span> <span>f64</span><span>)</span> <span>(</span><span>f64<span>.</span>const</span> <span>-14</span><span>)</span><span>)</span>

    <span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;f32.max_finite&#34;</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span> <span>(</span><span>i32</span>.reinterpret_f32 <span>(</span><span>f32<span>.</span>const</span> <span>0x1.fffffep+127</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>func</span> <span>(</span><span>export</span> <span>&#34;f32.max_subnormal&#34;</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)</span> <span>(</span><span>i32</span>.reinterpret_f32 <span>(</span><span>f32<span>.</span>const</span> <span>0x1.fffffcp-127</span><span>)</span><span>)</span><span>)</span>
<span>)</span></code></pre><p>Here is the benchmark result after all optimizations:</p><pre><code>parser/old  time:   [59.473 µs 59.559 µs 59.648 µs]
            change: [-2.2351% -1.9312% -1.6268%] (p = 0.00 &lt; 0.05)

parser/new  time:   [13.004 µs 13.120 µs 13.299 µs]
            change: [-1.6774% +0.4516% +4.8905%] (p = 0.82 &gt; 0.05)</code></pre></article></div>
  </body>
</html>
