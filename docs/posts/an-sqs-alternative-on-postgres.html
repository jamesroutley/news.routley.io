<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tembo-io/pgmq">Original</a>
    <h1>Show HN: An SQS Alternative on Postgres</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A lightweight message queue. Like <a href="https://aws.amazon.com/sqs/" rel="nofollow">AWS SQS</a> and <a href="https://github.com/smrchy/rsmq">RSMQ</a> but on Postgres.</p>
<p dir="auto"><a href="https://cloud.tembo.io/sign-up" rel="nofollow"><img src="https://camo.githubusercontent.com/2605a6cbaafba0160d6043b1d7bbf897530053b78c156878fc991a421bc9e4e8/68747470733a2f2f74656d626f2e696f2f74727946726565427574746f6e2e737667" alt="Tembo Cloud Try Free" data-canonical-src="https://tembo.io/tryFreeButton.svg"/></a></p>
<p dir="auto"><a href="https://join.slack.com/t/tembocommunity/shared_invite/zt-293gc1k0k-3K8z~eKW1SEIfrqEI~5_yw" rel="nofollow"><img src="https://camo.githubusercontent.com/503899b9c81b00cb3eb72ac40b042daad8fcd5aec105d593c763646fdb04bc5b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f25343074656d626f2d636f6d6d756e6974793f6c6f676f3d736c61636b266c6162656c3d736c61636b" alt="Static Badge" data-canonical-src="https://img.shields.io/badge/%40tembo-community?logo=slack&amp;label=slack"/></a>
<a href="https://ossrank.com/p/3809" rel="nofollow"><img src="https://camo.githubusercontent.com/ada21af437440bd8ccb611d66b4671e5f16e289b37ce4de49128bf9abf64ddf3/68747470733a2f2f736869656c64732e696f2f656e64706f696e743f75726c3d68747470733a2f2f6f737372616e6b2e636f6d2f736869656c642f33383039" alt="OSSRank" data-canonical-src="https://shields.io/endpoint?url=https://ossrank.com/shield/3809"/></a>
<a href="https://pgxn.org/dist/pgmq/" rel="nofollow"><img src="https://camo.githubusercontent.com/10f6f5d6df8fa4673d210d4336688f8247718d022fcc6f9bb846639e36c26119/68747470733a2f2f62616467652e667572792e696f2f70672f70676d712e737667" alt="PGXN version" data-canonical-src="https://badge.fury.io/pg/pgmq.svg"/></a></p>
<p dir="auto"><strong>Documentation</strong>: <a href="https://tembo-io.github.io/pgmq/" rel="nofollow">https://tembo-io.github.io/pgmq/</a></p>
<p dir="auto"><strong>Source</strong>: <a href="https://github.com/tembo-io/pgmq">https://github.com/tembo-io/pgmq</a></p>

<ul dir="auto">
<li>Lightweight - No background worker or external dependencies, just Postgres functions packaged in an extension</li>
<li>Guaranteed &#34;exactly once&#34; delivery of messages to a consumer within a visibility timeout</li>
<li>API parity with <a href="https://aws.amazon.com/sqs/" rel="nofollow">AWS SQS</a> and <a href="https://github.com/smrchy/rsmq">RSMQ</a></li>
<li>Messages stay in the queue until explicitly removed</li>
<li>Messages can be archived, instead of deleted, for long-term retention and replayability</li>
</ul>

<p dir="auto">Postgres 12-16.</p>

<ul dir="auto">
<li><a href="#postgres-message-queue-pgmq">Postgres Message Queue (PGMQ)</a>
<ul dir="auto">
<li><a href="#features">Features</a></li>
<li><a href="#support">Support</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#client-libraries">Client Libraries</a></li>
<li><a href="#sql-examples">SQL Examples</a>
<ul dir="auto">
<li><a href="#creating-a-queue">Creating a queue</a></li>
<li><a href="#send-two-messages">Send two messages</a></li>
<li><a href="#read-messages">Read messages</a></li>
<li><a href="#pop-a-message">Pop a message</a></li>
<li><a href="#archive-a-message">Archive a message</a></li>
<li><a href="#delete-a-message">Delete a message</a></li>
<li><a href="#drop-a-queue">Drop a queue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configuration">Configuration</a>
<ul dir="auto">
<li><a href="#partitioned-queues">Partitioned Queues</a></li>
<li><a href="#visibility-timeout-vt">Visibility Timeout (vt)</a></li>
<li><a href="#-contributors">âœ¨ Contributors</a></li>
</ul>
</li>
</ul>

<p dir="auto">The fastest way to get started is by running the Tembo docker image, where PGMQ comes pre-installed.</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker run -d --name postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 quay.io/tembo/pgmq-pg:latest"><pre>docker run -d --name postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 quay.io/tembo/pgmq-pg:latest</pre></div>
<p dir="auto">If you&#39;d like to build from source, you can follow the instructions in <a href="https://github.com/tembo-io/pgmq/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>

<p dir="auto">To update PGMQ versions, follow the instructions in <a href="https://github.com/tembo-io/pgmq/blob/main/UPDATING.md">UPDATING.md</a>.</p>

<ul dir="auto">
<li><a href="https://github.com/tembo-io/pgmq/tree/main/pgmq-rs">Rust</a></li>
<li><a href="https://github.com/tembo-io/pgmq/tree/main/tembo-pgmq-python">Python</a></li>
</ul>
<p dir="auto">Community</p>
<ul dir="auto">
<li><a href="https://github.com/craigpastro/pgmq-go">Go</a></li>
<li><a href="https://github.com/v0idpwn/pgmq-elixir">Elixir</a></li>
<li><a href="https://github.com/v0idpwn/off_broadway_pgmq">Elixir + Broadway</a></li>
<li><a href="https://github.com/adamalexandru4/pgmq-spring">Java (Spring Boot)</a></li>
<li><a href="https://github.com/Muhammad-Magdi/pgmq-js">Javascript (NodeJs)</a></li>
<li><a href="https://github.com/brianpursley/Npgmq">.NET</a></li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="# Connect to Postgres
psql postgres://postgres:postgres@0.0.0.0:5432/postgres"><pre><span><span>#</span> Connect to Postgres</span>
psql postgres://postgres:postgres@0.0.0.0:5432/postgres</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="-- create the extension in the &#34;pgmq&#34; schema
CREATE EXTENSION pgmq;"><pre><span><span>--</span> create the extension in the &#34;pgmq&#34; schema</span>
CREATE EXTENSION pgmq;</pre></div>

<p dir="auto">Every queue is its own table in the <code>pgmq</code> schema. The table name is the queue name prefixed with <code>q_</code>.
For example, <code>pgmq.q_my_queue</code> is the table for the queue <code>my_queue</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="-- creates the queue
SELECT pgmq.create(&#39;my_queue&#39;);"><pre><span><span>--</span> creates the queue</span>
<span>SELECT</span> <span>pgmq</span>.<span>create</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>);</pre></div>
<div data-snippet-clipboard-copy-content=" create
-------------

(1 row)"><pre lang="text"><code> create
-------------

(1 row)
</code></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="-- messages are sent as JSON
SELECT * from pgmq.send(&#39;my_queue&#39;, &#39;{&#34;foo&#34;: &#34;bar1&#34;}&#39;);
SELECT * from pgmq.send(&#39;my_queue&#39;, &#39;{&#34;foo&#34;: &#34;bar2&#34;}&#39;);"><pre><span><span>--</span> messages are sent as JSON</span>
<span>SELECT</span> <span>*</span> <span>from</span> <span>pgmq</span>.<span>send</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span><span>&#39;</span>{&#34;foo&#34;: &#34;bar1&#34;}<span>&#39;</span></span>);
<span>SELECT</span> <span>*</span> <span>from</span> <span>pgmq</span>.<span>send</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span><span>&#39;</span>{&#34;foo&#34;: &#34;bar2&#34;}<span>&#39;</span></span>);</pre></div>
<p dir="auto">The message id is returned from the send function.</p>
<div data-snippet-clipboard-copy-content=" send
-----------
         1
(1 row)

 send
-----------
         2
(1 row)"><pre lang="text"><code> send
-----------
         1
(1 row)

 send
-----------
         2
(1 row)
</code></pre></div>

<p dir="auto">Read <code>2</code> message from the queue. Make them invisible for <code>30</code> seconds.
If the messages are not deleted or archived within 30 seconds, they will become visible again
and can be read by another consumer.</p>
<div dir="auto" data-snippet-clipboard-copy-content="SELECT * FROM pgmq.read(&#39;my_queue&#39;, 30, 2);"><pre><span>SELECT</span> <span>*</span> <span>FROM</span> <span>pgmq</span>.<span>read</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span>30</span>, <span>2</span>);</pre></div>
<div data-snippet-clipboard-copy-content=" msg_id | read_ct |          enqueued_at          |              vt               |     message
--------+---------+-------------------------------+-------------------------------+-----------------
      1 |       1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar1&#34;}
      2 |       1 | 2023-08-16 08:37:54.572933-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar2&#34;}"><pre lang="text"><code> msg_id | read_ct |          enqueued_at          |              vt               |     message
--------+---------+-------------------------------+-------------------------------+-----------------
      1 |       1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar1&#34;}
      2 |       1 | 2023-08-16 08:37:54.572933-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar2&#34;}
</code></pre></div>
<p dir="auto">If the queue is empty, or if all messages are currently invisible, no rows will be returned.</p>
<div dir="auto" data-snippet-clipboard-copy-content="SELECT pgmq.read(&#39;my_queue&#39;, 30, 1);"><pre><span>SELECT</span> <span>pgmq</span>.<span>read</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span>30</span>, <span>1</span>);</pre></div>
<div data-snippet-clipboard-copy-content=" msg_id | read_ct | enqueued_at | vt | message
--------+---------+-------------+----+---------"><pre lang="text"><code> msg_id | read_ct | enqueued_at | vt | message
--------+---------+-------------+----+---------
</code></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="-- Read a message and immediately delete it from the queue. Returns `None` if the queue is empty.
SELECT pgmq.pop(&#39;my_queue&#39;);"><pre><span><span>--</span> Read a message and immediately delete it from the queue. Returns `None` if the queue is empty.</span>
<span>SELECT</span> <span>pgmq</span>.<span>pop</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>);</pre></div>
<div data-snippet-clipboard-copy-content=" msg_id | read_ct |          enqueued_at          |              vt               |     message
--------+---------+-------------------------------+-------------------------------+-----------------
      1 |       1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar1&#34;}"><pre lang="text"><code> msg_id | read_ct |          enqueued_at          |              vt               |     message
--------+---------+-------------------------------+-------------------------------+-----------------
      1 |       1 | 2023-08-16 08:37:54.567283-05 | 2023-08-16 08:38:29.989841-05 | {&#34;foo&#34;: &#34;bar1&#34;}
</code></pre></div>

<p dir="auto">Archiving a message removes it from the queue and inserts it to the archive table.</p>
<div dir="auto" data-snippet-clipboard-copy-content="-- Archive message with msg_id=2.
SELECT pgmq.archive(&#39;my_queue&#39;, 2);"><pre><span><span>--</span> Archive message with msg_id=2.</span>
<span>SELECT</span> <span>pgmq</span>.<span>archive</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span>2</span>);</pre></div>
<div data-snippet-clipboard-copy-content=" archive
--------------
 t
(1 row)"><pre lang="text"><code> archive
--------------
 t
(1 row)
</code></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="-- Archive tables have the prefix `a_`:
SELECT * FROM pgmq.a_my_queue;"><pre><span><span>--</span> Archive tables have the prefix `a_`:</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> <span>pgmq</span>.<span>a_my_queue</span>;</pre></div>
<div data-snippet-clipboard-copy-content=" msg_id | read_ct |         enqueued_at          |          archived_at          |              vt               |     message
--------+---------+------------------------------+-------------------------------+-------------------------------+-----------------
      2 |       1 | 2023-04-25 00:55:40.68417-05 | 2023-04-25 00:56:35.937594-05 | 2023-04-25 00:56:20.532012-05 | {&#34;foo&#34;: &#34;bar2&#34;}"><pre lang="text"><code> msg_id | read_ct |         enqueued_at          |          archived_at          |              vt               |     message
--------+---------+------------------------------+-------------------------------+-------------------------------+-----------------
      2 |       1 | 2023-04-25 00:55:40.68417-05 | 2023-04-25 00:56:35.937594-05 | 2023-04-25 00:56:20.532012-05 | {&#34;foo&#34;: &#34;bar2&#34;}
</code></pre></div>

<p dir="auto">Send another message, so that we can delete it.</p>
<div dir="auto" data-snippet-clipboard-copy-content="SELECT pgmq.send(&#39;my_queue&#39;, &#39;{&#34;foo&#34;: &#34;bar3&#34;}&#39;);"><pre><span>SELECT</span> <span>pgmq</span>.<span>send</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span><span>&#39;</span>{&#34;foo&#34;: &#34;bar3&#34;}<span>&#39;</span></span>);</pre></div>
<div data-snippet-clipboard-copy-content=" send
-----------
        3
(1 row)"><pre lang="text"><code> send
-----------
        3
(1 row)
</code></pre></div>
<p dir="auto">Delete the message with id <code>3</code> from the queue named <code>my_queue</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="SELECT pgmq.delete(&#39;my_queue&#39;, 3);"><pre><span>SELECT</span> <span>pgmq</span>.<span>delete</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>, <span>3</span>);</pre></div>
<div data-snippet-clipboard-copy-content=" delete
-------------
 t
(1 row)"><pre lang="text"><code> delete
-------------
 t
(1 row)
</code></pre></div>

<p dir="auto">Delete the queue <code>my_queue</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="SELECT pgmq.drop_queue(&#39;my_queue&#39;);"><pre><span>SELECT</span> <span>pgmq</span>.<span>drop_queue</span>(<span><span>&#39;</span>my_queue<span>&#39;</span></span>);</pre></div>
<div data-snippet-clipboard-copy-content=" drop_queue
-----------------
 t
(1 row)"><pre lang="text"><code> drop_queue
-----------------
 t
(1 row)
</code></pre></div>


<p dir="auto">You will need to install <a href="https://github.com/pgpartman/pg_partman/">pg_partman</a> if you want to use <code>pgmq</code> partitioned queues.</p>
<p dir="auto"><code>pgmq</code> queue tables can be created as a partitioned table by using <code>pgmq.create_partitioned()</code>. <a href="https://github.com/pgpartman/pg_partman/">pg_partman</a>
handles all maintenance of queue tables. This includes creating new partitions and dropping old partitions.</p>
<p dir="auto">Partitions behavior is configured at the time queues are created, via <code>pgmq.create_partitioned()</code>. This function has three parameters:</p>
<p dir="auto"><code>queue_name: text</code>: The name of the queue. Queues are Postgres tables prepended with <code>q_</code>. For example, <code>q_my_queue</code>. The archive is instead prefixed by <code>a_</code>, for example <code>a_my_queue</code>.</p>
<p dir="auto"><code>partition_interval: text</code> - The interval at which partitions are created. This can be either any valid Postgres <code>Duration</code> supported by pg_partman, or an integer value. When it is a duration, queues are partitioned by the time at which messages are sent to the table (<code>enqueued_at</code>). A value of <code>&#39;daily&#39;</code> would create a new partition each day. When it is an integer value, queues are partitioned by the <code>msg_id</code>. A value of <code>&#39;100&#39;</code> will create a new partition every 100 messages. The value must agree with <code>retention_interval</code> (time based or numeric). The default value is <code>daily</code>.</p>
<p dir="auto"><code>retention_interval: text</code> - The interval for retaining partitions. This can be either any valid Postgres <code>Duration</code> supported by pg_partman, or an integer value. When it is a duration, partitions containing data greater than the duration will be dropped. When it is an integer value, any messages that have a <code>msg_id</code> less than <code>max(msg_id) - retention_interval</code> will be dropped. For example, if the max <code>msg_id</code> is 100 and the <code>retention_interval</code> is 60, any partitions with <code>msg_id</code> values less than 40 will be dropped. The value must agree with <code>partition_interval</code> (time based or numeric). The default is <code>&#39;5 days&#39;</code>. Note: <code>retention_interval</code> does not apply to messages that have been deleted via <code>pgmq.delete()</code> or archived with <code>pgmq.archive()</code>. <code>pgmq.delete()</code> removes messages forever and <code>pgmq.archive()</code> moves messages to the corresponding archive table forever (for example, <code>a_my_queue</code>).</p>
<p dir="auto">In order for automatic partition maintenance to take place, several settings must be added to the <code>postgresql.conf</code> file, which is typically located in the postgres <code>DATADIR</code>.
<code>pg_partman_bgw.interval</code>
in <code>postgresql.conf</code>. Below are the default configuration values set in Tembo docker images.</p>
<p dir="auto">Add the following to <code>postgresql.conf</code>. Note, changing <code>shared_preload_libraries</code> requires a restart of Postgres.</p>
<p dir="auto"><code>pg_partman_bgw.interval</code> sets the interval at which <code>pg_partman</code> conducts maintenance. This creates new partitions and dropping of partitions falling out of the <code>retention_interval</code>. By default, <code>pg_partman</code> will keep 4 partitions &#34;ahead&#34; of the currently active partition.</p>
<div data-snippet-clipboard-copy-content="shared_preload_libraries = &#39;pg_partman_bgw&#39; # requires restart of Postgres
pg_partman_bgw.interval = 60
pg_partman_bgw.role = &#39;postgres&#39;
pg_partman_bgw.dbname = &#39;postgres&#39;"><pre><code>shared_preload_libraries = &#39;pg_partman_bgw&#39; # requires restart of Postgres
pg_partman_bgw.interval = 60
pg_partman_bgw.role = &#39;postgres&#39;
pg_partman_bgw.dbname = &#39;postgres&#39;
</code></pre></div>

<p dir="auto">pgmq guarantees exactly once delivery of a message within a visibility timeout. The visibility timeout is the amount of time a message is invisible to other consumers after it has been read by a consumer. If the message is NOT deleted or archived within the visibility timeout, it will become visible again and can be read by another consumer. The visibility timeout is set when a message is read from the queue, via <code>pgmq.read()</code>. It is recommended to set a <code>vt</code> value that is greater than the expected time it takes to process a message. After the application successfully processes the message, it should call <code>pgmq.delete()</code> to completely remove the message from the queue or <code>pgmq.archive()</code> to move it to the archive table for the queue.</p>

<p dir="auto">Thanks goes to these incredible people:</p>
<a href="https://github.com/tembo-io/pgmq/graphs/contributors">
  <img src="https://camo.githubusercontent.com/edb80ae9a4639740585e6fd4f6856ed67a19b5708989b6eff212cb9b32511e5b/68747470733a2f2f636f6e747269622e726f636b732f696d6167653f7265706f3d74656d626f2d696f2f70676d71" data-canonical-src="https://contrib.rocks/image?repo=tembo-io/pgmq"/>
</a>
</article></div></div>
  </body>
</html>
