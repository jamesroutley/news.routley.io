<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pijul.org/posts/2022-01-08-beta/">Original</a>
    <h1>Pijul 1.0 Beta</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>Tuesday, January 18, 2022</p>
<p>By Pierre-Étienne Meunier</p>
<p>I’m proud of finally announcing the beta release of Pijul, after a bit more than a year of alpha.
Sorry for the long post, and Happy New Year!</p>
<h2 id="53-versions-of-libpijul-100-alpha">53 versions of Libpijul 1.0.0-alpha</h2>
<p>Pijul has come a long way since the initial alpha release, in terms of performance, stability and features. Here are the most notable achievements since the 1.0.0-alpha release in November 2021:</p>
<ul>
<li>
<p>A redesign of our backend, Sanakirja, to make it <a href="https://pijul.org/posts/2021-02-06-rethinking-sanakirja/">significantly faster</a> and more modular, which later allowed to also make read-only databases <a href="https://pijul.org/posts/2022-01-07-compressed-sanakirja">orders of magnitude smaller on disk</a>.</p>
</li>
<li>
<p>Patches operate on much more general types of files, including files encoded in <a href="https://pijul.org/posts/2021-06-28-two-changes">different encodings</a> within a single repository and <a href="https://pijul.org/posts/2021-07-11-binary-diffs">binary files</a>, using an algorithm similar to rsync.</p>
</li>
<li>
<p><a href="https://pijul.org/posts/2021-06-28-two-changes">Malleable identifiers</a> make signed patches the default, while allowing users to later change their personal details (email address, name, login…). The full story for synchronising these identifiers from multiple different source repos is not yet completely written. Testing and suggestions are welcome!</p>
</li>
<li>
<p><a href="https://pijul.org/posts/2022-01-07-monorepos">Merging unrelated repos</a> and <a href="https://pijul.org/posts/2020-12-19-partials">partial clones</a> are designed to make very large projects more manageable. I’d like to work on a number of useful derivatives of that idea in 2022 (more on that in a future post).</p>
</li>
<li>
<p><a href="https://pijul.org/posts/2022-01-07-compressed-sanakirja">Tags</a> are a compressed version of a repository at some point in time. They are an efficient way to store repositories, but do not yet contribute to making writable repos smaller (but they will!). Their main use at the moment is to make it efficient to browse a particular state of a repository.</p>
<p>This is actually a really cool feature: since the early days of patch-based version control (and for example in <a href="https://darcs.net">Darcs</a>), there has always been a trade-off between the ease of use and intuitiveness of patches and the navigability of snapshots. The current implementation of tags in Pijul are a first step towards getting rid of that trade-off.</p>
</li>
</ul>
<h2 id="stability-guarantees">Stability guarantees</h2>
<p>Releasing a beta version obviously doesn’t mean that Pijul is completely bug-free. However, there are a number of claims we can finally make, after a year of public alpha:</p>
<ul>
<li>
<p>We can now promise that the formats won’t change, at least not in a very long time. This is because all the core features we wanted for 1.0 are implemented. Incidentally, all format changes of the last six months (required to implement new features) have all been backwards-compatible.</p>
</li>
<li>
<p>Our storage backend, Sanakirja, has now been tested at massive scale, including using new datastructures unrelated to Pijul. Despite our thorough checks, we haven’t seen any serious bug in months.</p>
</li>
<li>
<p>Our algorithms for generating and applying patches have been both tested at scale with automated checks (using the <code>pijul git</code> command to import Git repositories), and manually for each change that was recorded, reviewed and applied to the Pijul repository itself. Moreover, the test suite for Libpijul (where the algorithms are) includes a number of pathological cases, and the outcome of each algorithm has been inspected manually in those tests.</p>
</li>
</ul>
<h4 id="why-was-pijul-hard-to-stabilise">Why was Pijul hard to stabilise?</h4>
<p><strong>First reason: the underlying storage layer was hard to write.</strong> Writing any efficient storage format is by definition hard. Examples include filesystems, which must avoid corruption and protect against hardware errors. Databases are even worse, since they must additionally implement all sorts of fast queries and efficient storage.</p>
<p>There are mainly two reason the basic layers of these systems were/are hard to write:</p>
<ol>
<li>Debugging is hard: corruption usually only happens when the scale of data becomes large enough to make bugs hard (often meaning “long”) to reproduce.</li>
<li>“Partially correct” versions of most apps might still be usable spite of occasional bugs. Often, restarting the application or reloading some page does the trick. In the case of storage systems, everything is stateful, and no amount of “reloading the page” can solve a corruption issue.</li>
</ol>
<p><strong>Second reason: the upper-layer algorithms need an absolutely perfect storage layer, yet are also essential to test that layer.</strong> This is a chicken-and-egg problem, since corruption in the base layer can yield arbitrary, unpredictable results anywhere, yet the base layer cannot be tested without writing and debugging these algorithms.</p>
<p><strong>Third reason: alignment between maths and UX.</strong> While the mathematics at the foundation of Pijul have the potential to deliver a simpler, more intuitive UX, users rarely want to know about the reasons for different design choices, since these reasons can sometimes be quite technical. A number of iterations have been spent on aligning the design with the feedback we’ve received.</p>
<h2 id="performance-guarantees">Performance guarantees</h2>
<p>Until quite recently, performance was not our main focus: features and stability were. These obviously had an impact on performance, since the main goal in designing the formats was to make them optimally fast and small, even if the implementation wouldn’t follow immediately.</p>
<p>Many benchmarks have been designed and suggested by <a href="https://nest.pijul.com/tankf33der/pijul-tests">@tankf33der</a>, we show some of them below. The timings shown here were recorded on an Intel Xeon E3 v5, which is a 4 physical core CPU (8 with hyperthreading) running between 2.80GHz and 3.70GHz on a 2016 laptop. RAM was never an issue. Pijul was compiled with ZStd 1.4.9, since ZStd 1.5 has important performance regressions.</p>
<h4 id="benchmark-methodology-importing-git-repositories">Benchmark methodology: importing Git repositories</h4>
<p>The <code>pijul git</code> command goes through several stages, and is essentially a breadth-first search of the commit DAG.</p>
<ol>
<li>
<p>Load the entire history graph into the main memory to find all initial commits (many smaller repos have only one initial commit).</p>
</li>
<li>
<p>Create a channel for each initial commit. Initialise a todo list with one “todo item” for each of these commit/channel pair.</p>
</li>
<li>
<p>Then, repeat the following until the todo list is empty:</p>
<ol>
<li>
<p>Pop the most urgent commit/channel pair from the todo list, calling the commit <code>c</code> and the channel <code>l</code>:</p>
</li>
<li>
<p>Check that all of <code>c</code>’s parents have been imported:</p>
<ul>
<li>If so, apply them all to channel <code>l</code> and move to the next step.</li>
<li>If not, replace <code>(c, l)</code> at the end of the todo list and continue the loop (i.e. move back to step 1 of the loop).</li>
</ul>
</li>
<li>
<p>If <code>c</code> has more than one parent, prune the channels where these parents were imported, since they are no longer in the todolist, but are still alive in the repository.</p>
</li>
<li>
<p><code>git reset</code> to <code>c</code>, <code>pijul channel switch</code> to the channel if needed, <code>pijul add</code> all the files and run <code>pijul record</code>.</p>
</li>
<li>
<p>If <code>c</code> has a single child <code>d</code>, place <code>(d, l)</code> as the most urgent item on the list.</p>
</li>
<li>
<p>Else, <code>c</code> has <code>n &gt; 1</code> children. Fork channel <code>l</code> <code>n-1</code> times, placing each of the children along with one fork at the top of the todolist.</p>
</li>
</ol>
</li>
</ol>
<h4 id="importing-vim">Importing Vim</h4>
<p>Vim is a text editor with a history of a relatively modest size for an open source project, with 15138 commits to import in order to get to the HEAD of the main branch. Note that Pijul records all commits on all forks that were later merged onto main as independent patches, and doesn’t record trivial merges (merges without conflicts nor any modification after the merge itself).</p>
<p>The following two graphs show the time taken by <code>pijul record</code> and <code>pijul apply</code> in the algorithm for <code>pijul git</code> described above, for the 15138 commits in <a href="https://github.com/b4winckler/vim">the Vim repo</a>.
Only one commit isn’t shown, it is commit <a href="https://github.com/b4winckler/vim/commit/6bb683663ad7ae9c303284c335a731a13233c6c2"><code>6bb683663ad7ae9c303284c335a731a13233c6c2</code></a> in the repository, which “changes” <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> the indentation of <a href="https://github.com/b4winckler/vim/blob/6bb683663ad7ae9c303284c335a731a13233c6c2/runtime/spell/en.spl">some huge dictionary file</a>. Its import took 5 minutes and 16 seconds.</p>
<p>Note the log scale, chosen to avoid showing only the extremely short times, which are by far the most common.</p>
<div>
<p><img src="https://pijul.org/posts/2022-01-08-beta/vim-record.svg"/></p>
<p><img src="https://pijul.org/posts/2022-01-08-beta/vim-apply.svg"/></p>
</div>
<h4 id="importing-ruby">Importing Ruby</h4>
<p>In this case, we imported 70859 commits to reach the HEAD of the main branch. Only three commits took too long to make sense in the histograms. In chronological order:</p>
<ul>
<li><a href="https://github.com/ruby/ruby/commit/a388c7dd9e15d8b25705951d8906eacf76f50d7b"><code>a388c7dd9e15d8b25705951d8906eacf76f50d7b</code></a>, alomst 25s to record, and almost 408s to apply. That commit does contain very large diffs, but the apply time is quite extreme and prompts investigation, especially since it is 16 times higher than the record time, which is the opposite of the usual case.</li>
</ul>
<!-- a388c7dd9e15d8b25705951d8906eacf76f50d7b, 8195, 0, 0.901096381, 0.161893986, 0.034011666, 0.651803385, 0.794520666, 398.90357846, 2.519571006, 0.124049895, 0.000075376, 0.002501436, 0, 0.024070176, 0.000785755, 24.852805109, 407.980072481, 3377, 2475, 278, 18113061, 4190208, 133169152, 57LCNFYUBSBRPAXM6BI3453FUPPZKZFGD3HMWUKGHTERD5W5GTQQC -->
<ul>
<li><a href="https://github.com/ruby/ruby/commit/4be11cde44351c109eaf07669046a2152f151c78"><code>4be11cde44351c109eaf07669046a2152f151c78</code></a>, almost 190 seconds to record and about 36.5s to apply. That commit also contains huge diffs (161k lines of diff, according to GitHub).</li>
</ul>
<!-- 4be11cde44351c109eaf07669046a2152f151c78, 20742, 0, 3.107136661, 0.274072763, 0.271259018, 2.355481335, 2.7817427439999998, 31.173864549, 3.644807079, 1.493695631, 0.000030875, 1.331400276, 0, 0.050627486, 0.001100133, 189.989030309, 36.549687823, 4, 3371, 349, 34188870, 4194304, 267386880, AGIUIPZNQVH4ADDCDZBXIN25T2SJ7UZ3UVY64XA7BSQSCQ6G67FQC -->
<ul>
<li><a href="https://github.com/ruby/ruby/commit/beafa477f1b48204202dfcf5f13b2b0cc216f732"><code>beafa477f1b48204202dfcf5f13b2b0cc216f732</code></a>, just over 100 seconds to record and 8s to apply. That commit also contains large diffs (49k lines of diff, according to GitHub).</li>
</ul>
<!-- beafa477f1b48204202dfcf5f13b2b0cc216f732, 29724, 0, 1.081657949, 0.05666993, 0.050088049, 0.905201276, 1.005946661, 6.484465885, 2.724227844, 0.310643264, 0.000035501, 0.71501267, 0, 0.039845397, 0.001257467, 100.37510408200001, 8.231928625, 13, 3987, 409, 44999364, 4194304, 267386880, Z7XQ2UV4OICBF3NHXYKMQCFKVODOKEOVNPMFCLBBF2CP3V5ZA6DQC -->
<div>
<p><img src="https://pijul.org/posts/2022-01-08-beta/ruby-record.svg"/></p>
<p><img src="https://pijul.org/posts/2022-01-08-beta/ruby-apply.svg"/></p>
</div>
<h4 id="importing-cpython">Importing CPython</h4>
<p>We stopped the import after 52664 commits. That repository had consistently low apply times, and a large number of high record times (913 of them, or 1.7% of the total, took more than 5s). We believe this could be explained by a different workflow that was used to produce these commits: indeed, that repository has a rather large number of things happening in parallel, resulting in frequent channel switches in our import algorithm. Since switching channels causes a number of files to be written, <code>pijul record</code> recomputes the diff of all these files. This was confirmed by the few commits we have manually inspected, where the diffs were actually really small and very similar to the result of <code>git diff</code> (the only difference being on the extra labels Pijul puts on conflict resolutions), yet many files were compared, only to find that they hadn’t changed.</p>
<p>An example of a commit that took a long time (48.7s) was <a href="https://github.com/python/cpython/commit/fef67eefd3f91ae562c4fdd4a0051da28f7919dc"><code>fef67eefd3f91ae562c4fdd4a0051da28f7919dc</code></a>, which apparently changed no file at all, causing Pijul to diff all 3706 files of the entire repository.</p>
<p>This also warrants further manual inspection, but doesn’t seem to penalise real-world workflows driven by humans. If this hits you, please <a href="https://nest.pijul.com/pijul/pijul/discussions/new">open a discussion on the Nest</a> describing the exact performance problem you’re facing, along with steps to reproduce.</p>
<div>
<p><img src="https://pijul.org/posts/2022-01-08-beta/cpython-record.svg"/></p>
<p><img src="https://pijul.org/posts/2022-01-08-beta/cpython-apply.svg"/></p>
</div>
<h4 id="conclusion">Conclusion</h4>
<p>We believe the data shows Pijul to be usable even on large histories. Monorepos for large corporations are another story, but raw import speed is probably not the relevant metric in that case: partial clones, commutation and multi-root repos can probably solve many scalability problems.</p>
<p>Of course, these benchmarks show that there is still space for optimising and parallelising our algorithms. Anyone interested in helping is welcome, one good first step is joining <a href="https://pijul.zulipchat.com">our Zulip</a>.</p>
<h2 id="hosting-repositories">Hosting repositories</h2>
<p>Our hosting platform, <a href="https://nest.pijul.com">the Nest</a> is now <strong>much more robust</strong> than it was a year ago, thanks to all the improvements in Libpijul, in addition to standard and nonstandard <strong>distributed computing</strong> tricks, including:</p>
<ul>
<li>
<p>a replicated database (the “standard” part), which uses a combination of the improvements in the streaming replication features in <a href="https://www.postgresql.org/">PostgreSQL</a>, together with <a href="https://etcd.io">Etcd</a>, which is meant as a configuration tool, but can also just be used for its implementation of the Raft protocol to run leader elections, and finally <a href="https://nest.pijul.com/pmeunier/postrep">some glue between these</a> which for some reason took forever to debug.</p>
</li>
<li>
<p>replicated repositories using the CRDT nature of Pijul. This was prompted by <a href="https://pijul.org/posts/2021-06-03-on-fires">one of the two fires I went through in 2021</a> (the other one was in my apartment and had no impact on Pijul). This was particularly hard to implement, since the testing cycle involves many tests on local machines, followed by multiple careful redeployments in production.</p>
</li>
</ul>
<p>The monitoring tools have shown for some months now that the replication happens consistently, with no major bug in the repository replication.</p>
<p>However, <strong>improving the Nest was not the priority until very recently</strong>, explaining the unpolished feel and the many bugs: indeed, many “non-core” features haven’t been given all the care they deserve, yet they are often the first thing users see or experience. Now that Libpijul is finally getting stable, this situation is ready to change. If you experience any issue, please <a href="mailto:contact@pijul.org">contact us</a>.</p>
<p>The Nest was initially an ambitious bet to try and grow a community around our tool, which I saw as necessary to get as much feedback as possible from actual users working on non-test projects. Dogfooding Pijul has also probably been the most useful test we could dream of. Another goal of the Nest was to allow users with widely different technical backgrounds to start experimenting with Pijul without having to setup their own server. While the Nest’s features are quite limited, especially in comparison with all the cool UIs that have been written for Git, I believe it reached its goal, as evidenced by the impressive number of <a href="https://nest.pijul.com/pijul/pijul/discussions">productive discussions opened on Pijul itself</a>, and by the <a href="https://nest.pijul.com/explore">repositories created by users</a>.</p>
<h2 id="whats-next">What’s next?</h2>
<p>Here are the next few steps for Pijul itself:</p>
<ul>
<li>
<p>Converting Pijul repositories to Git, or at least do something to make it easy to switch back and forth. This is significantly more involved than a Git/SVN gateway, since Git and Pijul work in fundamentally different ways, whereas SVN’s data model of SVN can be seen as a special case of Git’s (SVN has a DAG of commits that is a line graph).</p>
<p>Indeed, in our case, converting from Git to Pijul is easy, and so is converting from Pijul to Git. However, making these two conversions work together is tricky, since commits cannot be produced from patches independently from other patches applied to the repository.</p>
<p>One issue if Pijul fails to recognise a commit <code>a</code> as coming from a patch <code>b</code> already applied to the repository, is that Pijul could import <code>a</code> a second time, creating a patch <code>c</code> with the same content as <code>b</code>, but with a different hash. The problem is that applying <code>b</code> and <code>c</code> in the same repo could create lots of unintelligible conflicts.</p>
<p>There could be nice algorithmic solutions to that problem. If you’re interested in helping, please join <a href="https://pijul.zulipchat.com">our Zulip</a>.</p>
</li>
<li>
<p>Some users working on large binary files (video game projects, for example) have asked for file locking. Pijul already has specific features for these files to:</p>
<ol>
<li>diff them efficiently, with the constraint that the diff has to be consistent with our apply algorithm, preventing the use of more specialised diffs.</li>
<li>avoid downloading them needlessly.</li>
</ol>
<p>Since files are actually modelled in Pijul, locking is quite easy to implement. Again, anyone needing mentoring to work on that feature is welcome to join <a href="https://pijul.zulipchat.com">our Zulip</a>.</p>
</li>
<li>
<p>Symbolic links aren’t properly handled yet, but shouldn’t be too hard to add. One reason they haven’t been implemented yet is that conflicts involving them could be handled in a non-naïve way to make them intuitive.</p>
</li>
<li>
<p>As the Nest improves, we’ll soon be able to restart our CI and offer private repositories and a more professional service and support. If you’re interested in custom setups of the Nest, please <a href="mailto:contact@pijul.org">contact us</a>.</p>
</li>
</ul>
<p>I’m also thinking about other research projects based on this new stable version of Pijul, I’ll make sure to post about them when I have some code to show.</p>

</div></div>
  </body>
</html>
