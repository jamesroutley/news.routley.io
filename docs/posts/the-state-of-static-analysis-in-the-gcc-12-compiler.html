<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2022/04/12/state-static-analysis-gcc-12-compiler">Original</a>
    <h1>The state of static analysis in the GCC 12 compiler</h1>
    
    <div id="readability-page-1" class="page"><div>
			<div>
									
								<div>
					            <p>Building a static analyzer into the <a href="https://developers.redhat.com/topics/c">C compiler</a> offers several advantages over having a separate tool, because the analyzer can track what the compiler and assembler are doing intimately. As a Red Hat employee, I work on <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>. Our static analyzer is still experimental but is making big strides in interesting areas, including a <em>taint mode</em> and an understanding of assembly-language code.</p>

<p><img alt="GNU logo" data-entity-type="file" data-entity-uuid="5e685b01-e95c-4d6a-8a56-73faef67510e" src="https://developers.redhat.com/sites/default/files/inline-images/gnu-logo.png" width="145" height="140" loading="lazy"/></p>









<p>My work on adding static analysis has spanned the past three releases of GCC (versions 10, 11, and 12). The static analysis is enabled through the <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-fanalyzer">-fanalyzer</a> option, and works together with several other options. This article describes what we&#39;ve accomplished on static analysis in the upcoming major release of GCC, <a href="https://gcc.gnu.org/gcc-12/changes.html">GCC 12</a>, which is in feature-freeze and which I hope will be released in April of 2022.</p>

<h2>Uncovering uninitialized values</h2>

<p>It&#39;s far too easy for C programmers to mess up by forgetting to initialize a value, whether on the stack or on the heap. C++ ameliorates this risk to some extent with constructors, but in both C and C++ there are plenty of ways to try to use uninitialized memory.</p>

<p>For GCC 12, I&#39;ve implemented a new <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-use-of-uninitialized-value">-Wanalyzer-use-of-uninitialized-value</a> warning. This option is similar to the existing <a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wuninitialized">-Wuninitialized</a> and <a href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wmaybe-uninitialized">-Wmaybe-uninitialized</a> warnings in GCC, but is based on the analyzer&#39;s interprocedural, path-sensitive exploration of the code. The upgraded version should therefore be able to detect more problems, return fewer false positives, and provide more details about how a problem can arise. I <a href="https://gcc.gnu.org/PR95006">reworked how the analyzer simulates the contents of memory</a> so that it can answer the question &#34;Is this initialized?&#34; at the per-bit level.</p>

<p>Consider the sample code at <a href="https://cwe.mitre.org/data/definitions/457.html#Demonstrative_Examples">CWE-457: Use of Uninitialized Variable</a>. For examples 2 and 3 on that page, the analyzer now emits the following:</p>

<pre><code>uninit-CWE-457-examples.c: In function &#39;example_2_bad_code&#39;:
uninit-CWE-457-examples.c:56:3: warning: use of uninitialized value &#39;bN&#39; [CWE-457] [-Wanalyzer-use-of-uninitialized-value]
   56 |   repaint(aN, bN);
      |   ^~~~~~~~~~~~~~~
  &#39;example_2_bad_code&#39;: events 1-4
    |
    |   34 |   int aN, bN;
    |      |           ^~
    |      |           |
    |      |           (1) region created on stack here
    |   35 |   switch (ctl) {
    |      |   ~~~~~~
    |      |   |
    |      |   (2) following &#39;default:&#39; branch...
    |......
    |   51 |   default:
    |      |   ~~~~~~~
    |      |   |
    |      |   (3) ...to here
    |......
    |   56 |   repaint(aN, bN);
    |      |   ~~~~~~~~~~~~~~~
    |      |   |
    |      |   (4) use of uninitialized value &#39;bN&#39; here
    |
uninit-CWE-457-examples.c: In function &#39;example_3_bad_code&#39;:
uninit-CWE-457-examples.c:95:3: warning: use of uninitialized value &#39;test_string&#39; [CWE-457] [-Wanalyzer-use-of-uninitialized-value]
   95 |   printf(&#34;%s&#34;, test_string);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~
  &#39;example_3_bad_code&#39;: events 1-4
    |
    |   90 |   char *test_string;
    |      |         ^~~~~~~~~~~
    |      |         |
    |      |         (1) region created on stack here
    |   91 |   if (i != err_val)
    |      |      ~
    |      |      |
    |      |      (2) following &#39;false&#39; branch (when &#39;i == err_val&#39;)...
    |......
    |   95 |   printf(&#34;%s&#34;, test_string);
    |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~
    |      |   |
    |      |   (3) ...to here
    |      |   (4) use of uninitialized value &#39;test_string&#39; here
    |</code></pre>

<p>In both cases, the output shows the execution path through the code that leads to the attempted use of an uninitialized value.</p>

<p>The analyzer also treats heap-allocated buffers as uninitialized, as in the following message:</p>

<pre><code>malloc-1.c:461:5: warning: use of uninitialized value &#39;*p&#39; [CWE-457] [-Wanalyzer-use-of-uninitialized-value]
  461 |   i = *p;
      |   ~~^~~~
  &#39;test_40&#39;: events 1-2
    |
    |  460 |   int *p = (int*)malloc(sizeof(int));
    |      |                  ^~~~~~~~~~~~~~~~~~~
    |      |                  |
    |      |                  (1) region created on heap here
    |  461 |   i = *p;
    |      |   ~~~~~~
    |      |     |
    |      |     (2) use of uninitialized value &#39;*p&#39; here
    |</code></pre>

<p>In GCC 12, other developers have also added an <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-ftrivial-auto-var-init">-ftrivial-auto-var-init</a> option that can mitigate against many uses of uninitialized variables. The analyzer still warns about the use of uninitialized memory if you use this option, because <code>-ftrivial-auto-var-init</code> is merely intended for the detection and mitigation of problems. It&#39;s good to have <code>-ftrivial-auto-var-init</code> as an extra layer of defense, but a prudent developer should still fix their code.</p>

<h2>A taint mode for C</h2>

<p>Some other languages, such as Perl, can track input and flag any variable that should not be trusted because it was read from an outside source such as a web form. Flagging variables in this manner is called <em>tainting</em>. After a program runs the variable through a check, the variable can be untainted, a process called <em>sanitization</em>.</p>

<p>Our GCC analyzer&#39;s taint mode is activated by <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-fanalyzer-checker">-fanalyzer-checker=taint</a> (which should be specified in addition to <code>-fanalyzer</code>). Taint mode attempts to track attacker-controlled values entering the program and to warn if they are used without sanitization.</p>

<p>The initial version of taint mode in GCC 10 was very much an experiment. The only source of tainting was buffers populated by <code>fread</code> calls, the only warning was <a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-array-index">-Wanalyzer-tainted-array-index</a>, and the state tracking tended to explode, causing the analyzer to give up.</p>

<p>For GCC 12, taint mode is closer to being useful, but is still experimental.</p>

<p>To expand the sources of tainted data, I&#39;ve added a new <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-tainted_005fargs-function-attribute">__attribute__ ((tainted_args))</a> attribute to the C and C++ front ends. The idea behind this change is to make it easy to annotate the attack surface of the program. The attribute can be used on functions, causing the analyzer&#39;s taint mode to treat all parameters and buffers pointed to by parameters of such functions as potentially under attacker control.</p>

<p>The <code>tainted_args</code> attribute can also be used on fields in structs that are function pointer callbacks. When taint mode sees a function being used as an initializer for such a field, the static analyzer flags all arguments to that function as tainted. As an example, such flagging could help an operating system kernel mark the <code>ioctl</code> callback field of a <code>struct device</code>, so that all <code>ioctl</code> handlers can be treated as attacker-facing.</p>

<p>I&#39;ve added four new taint-based warnings:</p>

<ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-allocation-size">-Wanalyzer-tainted-allocation-size</a> to be used, for example, for attacker-controlled <code>malloc</code> and <code>alloca</code></li>
	<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-divisor">-Wanalyzer-tainted-divisor</a> for detecting where an attacker can inject a divide-by-zero error</li>
	<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-offset">-Wanalyzer-tainted-offset</a> for attacker-controlled pointer offsets</li>
	<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-size">-Wanalyzer-tainted-size</a> for attacker-controlled values being used as a size parameter to calls to <code>memset</code> or to functions marked with <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html">__attribute__ ((access, ....))</a></li>
</ul><p>I&#39;ve improved the state-tracking problems mentioned earlier, but unfortunately the analyzer can still run into difficulty. So taint checking <a href="https://gcc.gnu.org/PR103533">must still be turned on explicitly</a>, and I still regard it as much more experimental than the rest of the analyzer.</p>

<h2>Scaling up the analyzer</h2>

<p>The <a href="https://developers.redhat.com/blog/2020/03/26/static-analysis-in-gcc-10">GCC 10 release</a> of <code>-fanalyzer</code> was very much just for early adopters. I made at least two major mistakes in how I tracked the program state along an execution path, requiring a <a href="https://developers.redhat.com/blog/2021/01/28/static-analysis-updates-in-gcc-11">big rewrite in GCC 11</a>.</p>

<p>I&#39;m hearing anecdotally of more people trying out <code>-fanalyzer</code> on their C code and finding real bugs in their programs—but also false positives. Static analysis is not perfect, but I&#39;m working on making it more useful.</p>

<p>For GCC 12, I&#39;ve been focusing on two things: getting <code>-fanalyzer</code> to run on the <a href="https://developers.redhat.com/topics/linux">Linux</a> kernel, and trying to drive down the number of false positives.</p>

<h3>The Linux kernel</h3>

<p>As a <a href="https://developers.redhat.com/products/gcc-clang-llvm-go-rust/overview">compiler</a> developer, I like to think the single most important package in a Linux distribution is the compiler, but I suspect most people would pick the kernel. In addition to actually letting you use your computer, the kernel makes a great test case for the analyzer, seeing as it&#39;s big and complicated.</p>

<p>Simply getting the kernel to build with <code>-fanalyzer</code> (and with <a href="https://developers.redhat.com/products/rhel">Red Hat Enterprise Linux</a>&#39;s kernel configuration and compilation flags) shook out various bugs in the analyzer, and working through the warnings revealed more. For example, I found that I had misunderstood how GCC represents <code>switch</code> statements internally, so I had to <a href="https://gcc.gnu.org/pipermail/gcc-patches/2021-August/577984.html">rewrite how the analyzer handles them</a>.</p>

<p>One issue I ran into is that the kernel makes heavy use of inline assembly. For example, I was seeing false positives from <code>-Wanalyzer-null-dereference</code> on code like the following (simplified from <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/staging/wfx/sta.c">drivers/staging/wfx/sta.c</a>):</p>

<pre><code>struct ieee80211_vif *test (struct wfx_vif *wvif) {
   if (wdev_to_wvif(wvif-&gt;wdev, 1))            /* (1) */
     return wdev_to_wvif(wvif-&gt;wdev, 1)-&gt;vif;  /* (2) */
   else
     return NULL;
}</code></pre>

<p>The analyzer was considering the execution path where the evaluation of <code>wdev_to_wvif(wvif-&gt;wdev, 1)</code> at (1) returns non-NULL, but at (2) returns NULL, which then gets dereferenced.</p>

<p>This programming flow is non-trivial to figure out, but the analyzer was almost managing it. The analyzer saw:</p>

<pre><code>/* Simplified from drivers/staging/wfx/wfx.h */

static inline struct wfx_vif *wdev_to_wvif(struct wfx_dev *wdev, int vif_id) {
  vif_id = array_index_nospec(vif_id, ARRAY_SIZE(wdev-&gt;vif));
  if (!wdev-&gt;vif[vif_id]) {
    return NULL;
  }
  return (struct wfx_vif *)wdev-&gt;vif[vif_id]-&gt;drv_priv;
}</code></pre>

<p>which uses the <code>array_index_nospec</code> macro:</p>

<pre><code>/* Simplified from include/linux/nospec.h */

#define array_index_nospec(index, size)                                 \
({                                                                      \
        typeof(index) _i = (index);                                     \
        typeof(size) _s = (size);                                       \
        unsigned long _mask = array_index_mask_nospec(_i, _s);          \
        /* snip */                                                      \
        (typeof(_i)) (_i &amp; _mask);                                      \
})</code></pre>

<p>The <code>array_index_mask_nospec</code> macro uses inline assembly, and the analyzer was assuming an arbitrary result for the mask each time:</p>

<pre><code>/* Copied from arch/x86/include/asm/barrier.h */

static inline unsigned long array_index_mask_nospec(unsigned long index,
                unsigned long size)
{
        unsigned long mask;

        asm volatile (&#34;cmp %1,%2; sbb %0,%0;&#34;
                        :&#34;=r&#34; (mask)
                        :&#34;g&#34;(size),&#34;r&#34; (index)
                        :&#34;cc&#34;);
        return mask;
}</code></pre>

<p>So for GCC 12, I&#39;ve implemented <a href="https://gcc.gnu.org/git/?p=gcc.git;a=commitdiff;h=ded2c2c068f6f2825474758cb03a05070a5837e8">enough support for inline assembly</a> for the analyzer to handle cases like this. I don&#39;t attempt to actually parse and interpret the assembly code; I just needed to add enough heuristics to recognize that the result of the inline assembler isn&#39;t going to change between the two calls to <code>array_index_mask_nospec</code>. With this enhancement, the analyzer is able to figure out that the result from <code>wdev_to_wvif</code> is the same both times, fixing the false positive the analyzer had previously returned.</p>

<p>Finally, I need to consider the speed (or lack thereof) of the analyzer. I noticed <a href="https://gcc.gnu.org/PR104954">one particular kernel source file</a> that the analyzer seemed to get stuck on; one I ended up killing the compilation after 15 hours. That perverse behavior involved a debug build of the compiler. With a release build, I got the run down to four minutes, and optimizations to the analyzer have reduced the run to 17 seconds, where the non-analyzer part of compiling that file takes 19 seconds. My goal for <code>-fanalyzer</code> is for it to &#34;merely&#34; double your compile time, so I declared victory at that point for that file. Unfortunately, the analyzer can still take ages to finish on other files.</p>

<h3>Fixing false positives</h3>

<p>For a static analyzer to be useful, it shouldn&#39;t spam the developer with so many messages about things that aren&#39;t real problems that they stop paying attention. The tool needs to be tested on real-world code, written in a variety of styles. Thanks to open source, there&#39;s no shortage of code to try the analyzer on.</p>

<p>As part of our Red Hat Enterprise Linux production pipeline, Red Hat uses various static analysis tools on our source packages. We tried adding <code>-fanalyzer</code> to that bank of tests, marking it as &#34;experimental.&#34; I&#39;ve been working through the results of these runs for pre-releases of <a href="https://www.redhat.com/en/blog/whats-new-rhel-90-beta">Red Hat Enterprise Linux 9</a>, looking through the most frequent false positives and trying to fix them.</p>

<p>For example, when building <a href="https://github.com/xianyi/OpenBLAS/">OpenBLAS</a>, I saw thousands of warnings from <code>-Wanalyzer-malloc-leak</code>. In each case, it was flagging code of the following form:</p>

<pre><code>   if( LAPACKE_lsame( vect, &#39;b&#39; ) || LAPACKE_lsame( vect, &#39;p&#39; ) ) {
            pt_t = (lapack_complex_float*)
                LAPACKE_malloc( sizeof(lapack_complex_float) *
                                ldpt_t * MAX(1,n) );
      ...snip...
   }

   /* [...snip lots of code...] */

   if( LAPACKE_lsame( vect, &#39;b&#39; ) || LAPACKE_lsame( vect, &#39;p&#39; ) ) {
            LAPACKE_free( pt_t );
   }</code></pre>

<p>The relevant line is where the code uses a dynamically allocated buffer guarded by a condition:</p>

<pre><code>  LAPACKE_lsame( vect, &#39;b&#39; ) || LAPACKE_lsame( vect, &#39;p&#39; )</code></pre>

<p><code>LAPACKE_lsame</code> is a case-insensitive comparison, so, in theory, there are only two possible paths through the code: One invoking a <code>malloc</code>/<code>free</code> pair, and the other skipping both <code>malloc</code> and <code>free</code>. However, the definition of <code>LAPACKE_lsame</code> is in its own source file. The static analyzer doesn&#39;t yet work well with LTO and therefore can&#39;t peer inside <code>LAPACKE_lsame</code> while evaluating its invocation. So the analyzer considers four execution paths through this code: the two valid ones, and two impossible ones. In particular, the false positive from <code>-Wanalyzer-malloc-leak</code> arises from the impossible execution path in which the guard condition first evaluates to true for the <code>malloc</code> branch, but then evaluates to false for the <code>free</code> branch.</p>

<p>GCC supports marking function declarations with <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute">__attribute__((const))</a>. For GCC 12, I&#39;ve added smarts for this attribute to the analyzer, so that it will understand that such functions return the same value when given the same inputs (<a href="https://gcc.gnu.org/PR104434">PR104434</a>), and have no side effects (<a href="https://gcc.gnu.org/PR104576">PR104576</a>).</p>

<p>Marking <code>LAPACKE_lsame</code> with <code>__attribute__((const))</code> lets the analyzer figure out that the condition is the same both times, which fixes the false positives. OpenBLAS <a href="https://github.com/xianyi/OpenBLAS/issues/3543">has now made this change</a> upstream.</p>

<h2>Toward support for C++</h2>

<p>Unfortunately, I can&#39;t recommend running <code>-fanalyzer</code> on C++ code yet. We&#39;re slowly getting better: For <a href="https://summerofcode.withgoogle.com/archive/2021/organizations">Google Summer of Code (GSoC) 2021</a>, I mentored a student named <a href="https://github.com/Arsenic-ATG">Ankur Saini</a> who <a href="https://gist.github.com/Arsenic-ATG/8f4ac194f460dd9b2c78cf51af39afef">generalized the analyzer&#39;s interprocedural path exploration logic</a>. Thanks to his work, in GCC 12 the analyzer is now able to track calls through function pointers and thus handle virtual function calls.</p>

<p>That said, there are still enough C++ features (e.g., exception handling) missing from the analyzer&#39;s implementation that the results won&#39;t be useful on any real-world C++ project. So please still use <code>-fanalyzer</code> only for C code in GCC 12.</p>

<h2>Understanding the realloc function</h2>

<p>The analyzer now handles <code>realloc</code> calls by splitting the execution path into three parts, representing three possible outcomes for the call:</p>

<ul><li>Failure, returning <code>NULL</code></li>
	<li>Success, growing the buffer in place without moving it</li>
	<li>Success, by allocating a new buffer, copying the content of the old buffer to it, and freeing the old buffer</li>
</ul><p>This enhancement should help catch the <code>PTR = realloc (PTR, sz)</code> anti-pattern (which leaks memory on failure). The analyzer should also recognize when a buffer gets moved on reallocation but the code tries to use a pointer that&#39;s still pointing to the old location of the buffer.</p>

<h2>Trying it out</h2>

<p>There are lots of other improvements to the analyzer in GCC 12 that I haven&#39;t covered in this article. GCC 12 will be the system compiler in the soon-to-be-released <a href="https://www.redhat.com/en/blog/fedora-36-beta-now-available">Fedora 36</a>.</p>

<p>For simple code examples, you can play around with the new GCC online at the <a href="https://godbolt.org/">Compiler Explorer site</a>. Select GCC &#34;trunk&#34; and add <code>-fanalyzer</code> to the compiler options to run static analysis.</p>

<p>GCC 12 can also help prevent a particularly tricky kind of security exploit called a <em>Trojan source attack.</em> For more on how this works, check out <a href="https://developers.redhat.com/articles/2022/01/12/prevent-trojan-source-attacks-gcc-12">my article on the subject</a> from Red Hat Developer.</p>

<p>Finally, if this whetted your appetite for looking at the insides of the toolchain in more detail, GCC is participating in <a href="https://summerofcode.withgoogle.com/">GSoC 2022</a>, so you might want to look at <a href="https://gcc.gnu.org/wiki/SummerOfCode#Selected_Project_Ideas">GCC&#39;s GSoC project ideas</a>. I&#39;m hoping to mentor a new GCC contributor this summer for the analyzer, but there are plenty of other interesting aspects of the compiler to work on.</p>

<p>Have fun!</p>
      
					
																<p><i>Last updated:
							April 13, 2022</i>
										
				</p></div>
			</div>
		</div></div>
  </body>
</html>
