<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoghq.com/blog/engineering/introducing-husky/">Original</a>
    <h1>Husky, Datadog&#39;s Third-Generation Event Store</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is the story of “Husky”, a new event storage system we built at Datadog.</p><p>Building a new storage system is a fun and exciting undertaking—and one that shouldn’t be taken lightly. Most importantly, it does not happen in a vacuum. To understand the trade-offs that a new system makes, you need to understand the context: what came before it, and why we decided to build something new.</p><h2 id="from-metrics-to-logs"><a href="#from-metrics-to-logs">From Metrics to Logs</a></h2><p>A few years ago, <a href="https://www.datadoghq.com/about/latest-news/press-releases/log-management-general-availability/">Datadog announced the general availability of its Log Management product</a>. This was a significant addition to our platform. Before that, the company’s most widely known product was Infrastructure Monitoring (colloquially known as “Metrics”). Metrics systems are based on the idea of storing pre-aggregated timeseries data as tuples of <code>&lt;timeseries_id, timestamp, float64&gt;.</code></p><p>However, these metrics systems are not suitable for storing log data because they achieve efficiency by pre-aggregating many similar events into a single aggregated datapoint. For example, to get web hit rates, it’s a lot more effective (cost- and energy-wise) to capture the count per second on the web server than to read the click stream to derive the same information.</p><p>This optimization is highly desirable to produce compressed timeseries for a metrics system, but disastrous for a logs product. At a granularity of one second, a million “events” that occur within the same second can be compressed into a single 16-byte tuple of <code>&lt;timestamp, float64&gt;</code>. In addition, most modern metrics databases leverage delta-of-delta encoding, such that the actual storage cost of each 16-byte tuple is less than two bytes in most cases.</p><p>In exchange for the efficiency, metrics systems have limits on their capacity for storing context in the form of tags. You can filter and group metrics data in powerful ways, but there is a trade-off between unbounded tag cardinality and the time a query takes to return.</p><p>Hence, the practical recommendation to tag metrics by long-lived dimensions, such as <code>datacenter</code>, <code>service</code> or <code>pod_name</code>, while <a href="https://www.datadoghq.com/blog/metrics-without-limits/">pre-aggregating</a> short-lived, fast-churning dimensions such as <code>transaction_id</code>, or <code>packet_id</code>.</p><p>On the other hand, a logging product has some very different requirements:</p><ol><li>Log sizes tend to be measured in kilobytes, not bytes. This has a dramatic effect on what’s needed to store and query those logs efficiently.</li><li>A logging product that can’t support high cardinality data, like stack traces and UUIDs, isn’t very useful.</li></ol><p>In other words, the appeal of metrics is in the ability to very efficiently compute timeseries, with enough context, out of lots of events. The appeal of logs is in the ability to retain lots of granular events with all their context—and to produce arbitrary dimensional aggregates at query time.</p><h2 id="the-initial-version-of-datadog-logs"><a href="#the-initial-version-of-datadog-logs">The initial version of Datadog Logs</a></h2><p>This is what Datadog’s first Logs system looked like.</p><div><figure><picture><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=847 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=847&amp;dpr=2 2x" media="(min-width: 1200px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=698 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=698&amp;dpr=2 2x" media="(min-width: 992px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=720 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=720&amp;dpr=2 2x" media="(min-width: 759px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=600 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=600&amp;dpr=2 2x" media="(min-width: 630px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=500 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=500&amp;dpr=2 2x" media="(min-width: 530px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=420px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=420&amp;dpr=2 2x" media="(min-width: 361px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=360px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=360&amp;dpr=2 2x" media="(min-width: 0px)"/><img loading="lazy" srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch1.png?auto=format&amp;fit=max&amp;w=847" alt="Architecture diagram displaying two Kafka clusters, each pointing to a separate search cluster consisting of three tenants."/></picture><figcaption>Datadog&#39;s first Logs system.</figcaption></figure></div><p>It worked quite well in the beginning, but it didn’t take long for the cracks to show. The primary problem was that within a multi-tenant cluster, a single misbehaving node could end up disrupting the experience of all tenants—and in the worst case, make the entire cluster unavailable.</p><p>Whenever this occurred, mitigating the issue was difficult. Scaling up or scaling out an overloaded cluster often made things worse instead of better. The nodes that were already overwhelmed by writes or reads would suddenly start streaming data to each other, in addition to all the work that they were already trying to perform.</p><h2 id="building-our-own-clustering"><a href="#building-our-own-clustering">Building our own clustering</a></h2><p>The second iteration of our Logs system decoupled storage from clustering. We would handle all of the clustering separately, allowing us to tightly integrate the new clustering system with the rest of our multi-tenant technology. We retained the same single-node storage engine, and focused on getting fine-grained control over data distribution and topology changes. The new setup looked something like this:</p><div><figure><picture><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=847 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=847&amp;dpr=2 2x" media="(min-width: 1200px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=698 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=698&amp;dpr=2 2x" media="(min-width: 992px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=720 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=720&amp;dpr=2 2x" media="(min-width: 759px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=600 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=600&amp;dpr=2 2x" media="(min-width: 630px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=500 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=500&amp;dpr=2 2x" media="(min-width: 530px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=420px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=420&amp;dpr=2 2x" media="(min-width: 361px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=360px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=360&amp;dpr=2 2x" media="(min-width: 0px)"/><img loading="lazy" srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch2.png?auto=format&amp;fit=max&amp;w=847" alt="Architecture diagram displaying two Kafka clusters, each pointing to a separate shard router. Each shard router points to separate shards. Each shard is consumed by two storage node replicas. A custom query engine points to these replicas."/></picture><figcaption>Datadog&#39;s second-gen log system. Expand to view full detail.</figcaption></figure></div><p>There are a few key differences between this diagram and the previous one:</p><ul><li>None of the individual nodes know about each other. Each one behaves as if it’s a “cluster” of one. This means that a single misbehaving or unhealthy node can only ever disrupt as many tenants as we’ve assigned to the shard it owns, and there is no way for it to cause cascading failures to the rest of the “cluster”.</li><li>We introduced a new service called “Shard Router” that reads from Kafka and writes <strong>back to</strong> a new Kafka cluster, but this time with the data organized into “shards” (groups of partitions). Tenants are automatically split into an appropriate number of shards based on their data volume over the last five minutes.</li><li>Two storage node replicas consume each shard, consuming only events from their shards’ relevant partitions.</li><li>We added a custom query engine that knows which shards each tenant’s data is spread across—and whose responsibility it is to query all of the relevant shards/replicas, merge the partial aggregates, and generate the final query result.</li></ul><h2 id="platform-hypergrowth"><a href="#platform-hypergrowth">Platform hypergrowth</a></h2><p>The migration to this new architecture represented a marked reliability improvement, meaning than our on-call rotations became a lot more bearable, and engineers got more sleep. Just in time for the scope of our platform (internally called “Event Platform”) to grow at an even faster clip!</p><p>Other teams launched new products like <a href="https://docs.datadoghq.com/network_monitoring/performance/">Network Performance Monitoring (NPM)</a>, <a href="https://www.datadoghq.com/product/real-user-monitoring/">Real User Monitoring (RUM)</a>, and <a href="https://www.datadoghq.com/product/code-profiling/">Datadog Continuous Profiler</a>. Many of these new products had similar storage requirements as the Log Management product: they needed to store and index multi-kilobyte timeseries “events”. Recognizing that the events generated by these new products looked almost exactly like structured logs, we expanded the scope of our platform and started storing those events too.</p><p>As new products started to grow on the back of the event platform, cracks started to appear again. For example, a single tenant bursting and emitting a huge number of events in a short period of time could lead to query degradation for all other tenants colocated on the same shard.</p><p>In addition to these reliability concerns, product teams started asking us for new pieces of functionality that were difficult for us to support with that architecture:</p><ul><li>Some logging customers had critical data that they only occasionally needed to query, but wanted to be retained (and immediately queryable) for much longer than was cost-effective with our existing architecture.</li><li>Customers and product teams were asking for the ability to query and aggregate on any field in their events without specifying which fields were indexed ahead of time.</li><li>Product teams wanted us to support array functions, windowing functions, and storing <a href="https://www.datadoghq.com/blog/engineering/computing-accurate-percentiles-with-ddsketch/">DDSketches</a> in the storage engine directly, so they could send us pre-aggregated sketches and then re-aggregate them at query time.</li></ul><p>And that was just the tip of the iceberg! Two things became clear to us:</p><ol><li>We needed a completely new architecture that separated compute from storage to scale the ingestion, storage, and query paths independently, as well as to give more flexibility for controlling isolation, performance, and quality of service in our highly multi-tenant environments.</li><li>We needed to own the storage engine from top to bottom to control our destiny and deliver the functionality that our product teams were asking for.</li></ol><h2 id="designing-something-new"><a href="#designing-something-new">Designing something new</a></h2><p>With a fresh persective and new requirements, we took a step back and rethought our storage stack from the ground up. We were inspired by recent advances in the field (e.g. <a href="https://event.cwi.nl/lsde/papers/p215-dageville-snowflake.pdf">Snowflake</a> and <a href="http://www.vldb.org/pvldb/vol12/p2022-chattopadhyay.pdf">Procella</a>) that separated storage from compute to great effect, and we decided to take a similar approach. We believed it would give us the highest amount of flexibility for building a system that was resilient and performant in the face of unpredictable and aggressive multi-tenant workloads. We also decided that our new system should be a vectorized column store (albeit one with a lot of optimizations for needle-in-the-haystack-searches) because our platform was beginning to look a lot more like a real-time data lake.</p><h3 id="introducing-husky"><a href="#introducing-husky">Introducing Husky</a></h3><p>We started building a new storage system, affectionately known as “Husky”. When we’re feeling fancy, we describe Husky as an “unbundled, distributed, schemaless, vectorized column store with hybrid analytics/search capabilities, designed from the ground up around commodity object storage”. Of course, a picture is worth a thousand words, so here is a simplified architecture diagram of Husky:</p><div><figure><picture><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=847 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=847&amp;dpr=2 2x" media="(min-width: 1200px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=698 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=698&amp;dpr=2 2x" media="(min-width: 992px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=720 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=720&amp;dpr=2 2x" media="(min-width: 759px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=600 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=600&amp;dpr=2 2x" media="(min-width: 630px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=500 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=500&amp;dpr=2 2x" media="(min-width: 530px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=420px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=420&amp;dpr=2 2x" media="(min-width: 361px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=360px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=360&amp;dpr=2 2x" media="(min-width: 0px)"/><img loading="lazy" srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/arch3.png?auto=format&amp;fit=max&amp;w=847" alt="Architecture diagram of Husky."/></picture><figcaption>Datadog&#39;s third-gen storage system, Husky. Expand to view full detail.</figcaption></figure></div><h3 id="roles"><a href="#roles">Roles</a></h3><p>Let’s try and break this down, because a lot has changed from our previous diagrams. The “storage system” that used to live in each individual storage node has now been blown apart into three different roles: Writers, Readers, and Compactors<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>Writers read from Kafka, (briefly) buffer events in memory, upload events to blob storage in our custom file format, and then commit the presence of these new files to our metadata store. This is how data gets into Husky’s storage system. These nodes are completely stateless and can autoscale. Critically, we never communicate with the Writer nodes at query time. This dramatically reduces the ability of queries to impair ingestion, or vice versa.</p><p>Compactors scan the metadata store for small files generated by the Writers and previous compactions, and compact them into larger files. These nodes serve the exact same role as the compaction system in an LSM-tree database—but instead of compacting data on a local disk, they run as a distributed, autoscaling service. They upload the compacted files to blob storage, and then “commit” this outcome in the metadata store. The metadata store then deletes the old input files and creates the new output file(s) in an atomic transaction, so queries never get an inconsistent view of the data.</p><p>The Reader (leaf) nodes run queries over individual files in blob storage and return partial aggregates, which are re-aggregated by the distributed query engine. These nodes are (almost<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>) stateless and can be scaled up or down without issues.</p><h3 id="metadata"><a href="#metadata">Metadata</a></h3><p>The Writers, Compactors, and Readers coordinate a shared view of the world via our metadata store. Husky’s metadata store has multiple responsibilities, but its most important one is to serve as the strongly consistent source of truth for the set of files currently visible to each customer. We’ll delve into the details of our metadata store more in future blog posts, but it is a thin abstraction around <a href="https://www.foundationdb.org/">FoundationDB</a>, which we selected because it was one of the few open source OLTP database systems that met our requirements of:</p><ul><li>Distributed and horizontally scalable by default.</li><li>Strictly serializable and interactive transactions with no fine print.<ul><li>FoundationDB’s exhaustive <a href="https://apple.github.io/foundationdb/testing.html">simulation testing</a> virtually guarantees that you’ll never observe a violation of its <a href="https://apple.github.io/foundationdb/consistency.html">strictly serializable transaction isolation model</a>. This makes many hard distributed systems problems much easier to grapple with.</li></ul></li><li>Highly resilient when faced with extremely aggressive workloads, as evidenced by production use at Apple and by our own internal testing.</li></ul><h3 id="storage"><a href="#storage">Storage</a></h3><p>The concepts of shards and replicas have mostly disappeared from the system. In addition, we make no distinction between “historical” data and “fresh” data anywhere in the architecture. The abstractions of “metadata store” and “blob storage” are the only stateful components left, and we’ve pushed the tough scalability, replication, and durability problems of “store and don’t lose these bytes” to battle-tested systems like FoundationDB and S3. This allows us to focus on the problem we’re actually trying to solve: how to ingest, index, and query huge volumes of data in a highly multi-tenant environment. For example, sometimes we have to search PiBs of events just to answer a single query!</p><p>The fact that we were able to offload both raw data storage and metadata storage to battle-tested systems is arguably the only reason we were able to build and launch to production a new system as fast as we did, but even then, it still took us over a year and a half between writing our first line of code to fully migrating a product to Husky.</p><h3 id="isolation"><a href="#isolation">Isolation</a></h3><p>Another critical difference with this new architecture is that there is no relationship between a customer’s data volumes and how much hardware we can throw at their queries. Even if a customer’s data volumes are tiny, we can allow a query targeting one year of data to temporarily “burst” into a huge number of Reader nodes if we have spare capacity. This allows us to leverage our scale to smooth out individual tenant variation in query intensity to provide all customers with a better experience. Similarly, customers can send us huge volumes of data, but if they don’t need low latency queries, then we can limit how much compute their queries can use. This is the technical underpinning of our <a href="https://www.datadoghq.com/blog/online-archives-datadog/">Online Archives</a> logging tier.</p><p>Husky also allows us to isolate queries independently from how we isolate ingestion and storage. In the diagram above, both Reader pools 1 and 2 have access to both metadata stores and blob stores. This allows us to isolate the queries however we want. We can run all queries in a single giant pool of machines, or we can partition them by product, or even something as granular as a single tenant. Husky’s architecture gives us the flexibility to isolate the query path based on our reliability, cost, and product goals instead of being constrained by the decisions we made at ingestion time.</p><p>The most immediately obvious reliability benefit that arises out of this approach (and one that was infeasible before) is that we can isolate queries generated by automated monitoring from those generated by humans. We feel much better about the reliability of our system knowing that a human-generated query can never impair our ability to evaluate customers’ automated monitors and vice versa.</p><h2 id="migration-impact"><a href="#migration-impact">Migration impact</a></h2><p>Of course, that all sounds great on paper, but how about in practice? At Datadog, the holy grail for all migrations is improved reliability, performance, and efficiency, in that order.</p><h3 id="reliability"><a href="#reliability">Reliability</a></h3><p>Reliability can be tricky to measure. We try to be objective by comparing ingestion and query SLOs, but even SLOs have limits. For example, a system promising three 9s availability is allowed almost nine hours of downtime per year, but users will have strong opinions about how those hours are spread out! So far we’re optimistic about the reliability of Husky compared to that of the systems it replaced:</p><ul><li>Our rate of incident has not increased, despite being a newer system.</li><li>Organic growth and sudden, large bursts of incoming events have been handled by autoscaling without human intervention.</li><li>We have spent almost no time debugging tenant- or node-level query performance.</li></ul><h3 id="performance"><a href="#performance">Performance</a></h3><p>Performance is the most difficult to measure. Benchmarking our complex and variable workload is really hard. Before we migrate a workload, we dual-write all data to both the old system and Husky, and then we shadow 100 percent of the query load for months to compare correctness and performance before we “flip the switch.” The post-migration experience generally looks like this:</p><div><figure><picture><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=847 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=847&amp;dpr=2 2x" media="(min-width: 1200px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=698 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=698&amp;dpr=2 2x" media="(min-width: 992px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=720 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=720&amp;dpr=2 2x" media="(min-width: 759px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=600 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=600&amp;dpr=2 2x" media="(min-width: 630px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=500 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=500&amp;dpr=2 2x" media="(min-width: 530px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=420px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=420&amp;dpr=2 2x" media="(min-width: 361px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=360px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=360&amp;dpr=2 2x" media="(min-width: 0px)"/><img loading="lazy" srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/max-p99-chart.png?auto=format&amp;fit=max&amp;w=847" alt="Charts showing max latency for all queries, p99 latency for all queries."/></picture></figure></div><p>In these charts, Husky’s latency (purple) is compared to that of our old system (blue). The p95/p99/max latencies are dramatically lower on Husky.</p><div><figure><picture><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=847 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=847&amp;dpr=2 2x" media="(min-width: 1200px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=698 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=698&amp;dpr=2 2x" media="(min-width: 992px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=720 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=720&amp;dpr=2 2x" media="(min-width: 759px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=600 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=600&amp;dpr=2 2x" media="(min-width: 630px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=500 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=500&amp;dpr=2 2x" media="(min-width: 530px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=420px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=420&amp;dpr=2 2x" media="(min-width: 361px)"/><source srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=360px 1x,
                    https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=360&amp;dpr=2 2x" media="(min-width: 0px)"/><img loading="lazy" srcset="https://imgix.datadoghq.com/img/blog/engineering/introducing-husky/median-chart.png?auto=format&amp;fit=max&amp;w=847" alt="Chart showing median latency for all queries."/></picture></figure></div><p>The median latency of Husky is slightly higher than the previous system, mostly due to the much higher “latency floor” of remote storage versus local SSDs.</p><p>We ultimately decided that a few hundred milliseconds increase in the median latency was the right decision for our customers to save seconds, tens of seconds, and hundreds of seconds of p95/p99/max latency, respectively.</p><h3 id="efficiency"><a href="#efficiency">Efficiency</a></h3><p>The Husky migration dramatically improved our overall efficiency, which allowed us to invest time in even better query performance and new query functionality. In addition, the flexibility in how we allocate costs enabled us to launch entirely new products like <a href="https://www.datadoghq.com/blog/online-archives-datadog/">Online Archives</a>.</p><h2 id="looking-forward"><a href="#looking-forward">Looking forward</a></h2><p>We’ve nearly reached the end, and some of you may be disappointed that we haven’t discussed the details of Husky’s storage engine at all! Luckily this is just the first post in a multi-part series on the details of Husky’s storage system. We promise that we’ll get a lot more into the weeds and implementation details in subsequent posts, but we wanted to start things off by sharing why we built Husky before explaining how!</p><p>Finally, if you’d like to work with us at Datadog, please apply for a job!</p></div></div>
  </body>
</html>
