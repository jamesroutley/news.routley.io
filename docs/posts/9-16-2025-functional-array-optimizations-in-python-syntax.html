<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/saulshanabrook/saulshanabrook/discussions/45">Original</a>
    <h1>9/16/2025 Functional Array Optimizations in Python Syntax</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="8908715" data-target-translation-type="discussion">
        <tr>
    <td>
        <p dir="auto">I looked today at the sMMM e-graph array optimization I first started in <a data-error-text="Failed to load title" data-id="8850593" data-permission-text="Title is private" data-url="https://github.com/saulshanabrook/saulshanabrook/discussions/44" data-hovercard-type="discussion" data-hovercard-url="/saulshanabrook/saulshanabrook/discussions/44/hovercard" href="https://github.com/saulshanabrook/saulshanabrook/discussions/44">#44</a></p>
<div dir="auto" data-snippet-clipboard-copy-content="from collections.abc import Callable

import numpy as np


def sum_over(arr: np.ndarray, body: Callable[[int, np.ndarray], float]) -&gt; float:
    n = arr.shape[-1]
    return float(sum((float(body(k, arr[..., k])) for k in range(n)), 0.0))


# ---------------- ΣMMM (scalar) ----------------
# Q = sum_{i,j,k} A[i,k] * B[k,j]
# A ∈ R^{I×K}, B ∈ R^{K×J}


def sMMM_triple_struct(A: np.ndarray, B: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Mirrors the IR:

      (sum k Ak (var A)
        (sum i Aik (var Ak)
          (sum j Bkj (get B k)
            Aik * Bkj)))
    &#34;&#34;&#34;
    return sum_over(
        A,
        lambda k, Ak: sum_over(
            Ak,
            lambda i, Aik: sum_over(
                B[k, ...],
                lambda j, Bkj: float(Aik) * float(Bkj),
            ),
        ),
    )


def sMMM_factored_struct(A: np.ndarray, B: np.ndarray) -&gt; float:
    &#34;&#34;&#34;
    Mirrors the equality-saturated IR:

      (sum k Ak (var A)
        (* (sum i Aik (var Ak) Aik)
           (sum j Bkj (get B k) Bkj)))
    &#34;&#34;&#34;
    return sum_over(
        A,
        lambda k, Ak: (
            sum_over(Ak, lambda i, Aik: float(Aik))
            *
            # .
            sum_over(B[k], lambda j, Bkj: float(Bkj))
        ),
    )



# --------- (optional) quick check ----------
if __name__ == &#34;__main__&#34;:
    rng = np.random.default_rng(0)
    I, K, J = 4, 5, 3
    A = rng.integers(-2, 3, size=(I, K)).astype(float)
    B = rng.integers(-2, 3, size=(K, J)).astype(float)

    q1 = sMMM_triple_struct(A, B)
    q2 = sMMM_factored_struct(A, B)
    q_ref = float((A @ B).sum())  # same as np.einsum(&#39;ik,kj-&gt;&#39;, A, B)

    assert np.isclose(q1, q_ref)
    assert np.isclose(q2, q_ref)
    print(q1, q2, q_ref)"><pre><span>from</span> <span>collections</span>.<span>abc</span> <span>import</span> <span>Callable</span>

<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>


<span>def</span> <span>sum_over</span>(<span>arr</span>: <span>np</span>.<span>ndarray</span>, <span>body</span>: <span>Callable</span>[[<span>int</span>, <span>np</span>.<span>ndarray</span>], <span>float</span>]) <span>-&gt;</span> <span>float</span>:
    <span>n</span> <span>=</span> <span>arr</span>.<span>shape</span>[<span>-</span><span>1</span>]
    <span>return</span> <span>float</span>(<span>sum</span>((<span>float</span>(<span>body</span>(<span>k</span>, <span>arr</span>[..., <span>k</span>])) <span>for</span> <span>k</span> <span>in</span> <span>range</span>(<span>n</span>)), <span>0.0</span>))


<span># ---------------- ΣMMM (scalar) ----------------</span>
<span># Q = sum_{i,j,k} A[i,k] * B[k,j]</span>
<span># A ∈ R^{I×K}, B ∈ R^{K×J}</span>


<span>def</span> <span>sMMM_triple_struct</span>(<span>A</span>: <span>np</span>.<span>ndarray</span>, <span>B</span>: <span>np</span>.<span>ndarray</span>) <span>-&gt;</span> <span>float</span>:
    <span>&#34;&#34;&#34;</span>
<span>    Mirrors the IR:</span>
<span></span>
<span>      (sum k Ak (var A)</span>
<span>        (sum i Aik (var Ak)</span>
<span>          (sum j Bkj (get B k)</span>
<span>            Aik * Bkj)))</span>
<span>    &#34;&#34;&#34;</span>
    <span>return</span> <span>sum_over</span>(
        <span>A</span>,
        <span>lambda</span> <span>k</span>, <span>Ak</span>: <span>sum_over</span>(
            <span>Ak</span>,
            <span>lambda</span> <span>i</span>, <span>Aik</span>: <span>sum_over</span>(
                <span>B</span>[<span>k</span>, ...],
                <span>lambda</span> <span>j</span>, <span>Bkj</span>: <span>float</span>(<span>Aik</span>) <span>*</span> <span>float</span>(<span>Bkj</span>),
            ),
        ),
    )


<span>def</span> <span>sMMM_factored_struct</span>(<span>A</span>: <span>np</span>.<span>ndarray</span>, <span>B</span>: <span>np</span>.<span>ndarray</span>) <span>-&gt;</span> <span>float</span>:
    <span>&#34;&#34;&#34;</span>
<span>    Mirrors the equality-saturated IR:</span>
<span></span>
<span>      (sum k Ak (var A)</span>
<span>        (* (sum i Aik (var Ak) Aik)</span>
<span>           (sum j Bkj (get B k) Bkj)))</span>
<span>    &#34;&#34;&#34;</span>
    <span>return</span> <span>sum_over</span>(
        <span>A</span>,
        <span>lambda</span> <span>k</span>, <span>Ak</span>: (
            <span>sum_over</span>(<span>Ak</span>, <span>lambda</span> <span>i</span>, <span>Aik</span>: <span>float</span>(<span>Aik</span>))
            <span>*</span>
            <span># .</span>
            <span>sum_over</span>(<span>B</span>[<span>k</span>], <span>lambda</span> <span>j</span>, <span>Bkj</span>: <span>float</span>(<span>Bkj</span>))
        ),
    )



<span># --------- (optional) quick check ----------</span>
<span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span>:
    <span>rng</span> <span>=</span> <span>np</span>.<span>random</span>.<span>default_rng</span>(<span>0</span>)
    <span>I</span>, <span>K</span>, <span>J</span> <span>=</span> <span>4</span>, <span>5</span>, <span>3</span>
    <span>A</span> <span>=</span> <span>rng</span>.<span>integers</span>(<span>-</span><span>2</span>, <span>3</span>, <span>size</span><span>=</span>(<span>I</span>, <span>K</span>)).<span>astype</span>(<span>float</span>)
    <span>B</span> <span>=</span> <span>rng</span>.<span>integers</span>(<span>-</span><span>2</span>, <span>3</span>, <span>size</span><span>=</span>(<span>K</span>, <span>J</span>)).<span>astype</span>(<span>float</span>)

    <span>q1</span> <span>=</span> <span>sMMM_triple_struct</span>(<span>A</span>, <span>B</span>)
    <span>q2</span> <span>=</span> <span>sMMM_factored_struct</span>(<span>A</span>, <span>B</span>)
    <span>q_ref</span> <span>=</span> <span>float</span>((<span>A</span> @ <span>B</span>).<span>sum</span>())  <span># same as np.einsum(&#39;ik,kj-&gt;&#39;, A, B)</span>

    <span>assert</span> <span>np</span>.<span>isclose</span>(<span>q1</span>, <span>q_ref</span>)
    <span>assert</span> <span>np</span>.<span>isclose</span>(<span>q2</span>, <span>q_ref</span>)
    <span>print</span>(<span>q1</span>, <span>q2</span>, <span>q_ref</span>)</pre></div>
<p dir="auto">We can see here that the core rewrite being implementing is lifting a multiplication out of a loop like:</p>
<blockquote>
<p dir="auto">Rewrite <code>sum_over(x, lambda a, b: c * d(a, b)))</code> to <code>c * sum_over(x, lambda a, b: d(a, b)))</code></p>
</blockquote>
<p dir="auto">This shows up in the &#34;Optimizing Tensor Programs on Flexible Storage&#34; paper as well:</p>
<a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/1186124/490288380-86d61b5d-9a25-4371-8374-28641a7c59b5.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgyMjAzNDEsIm5iZiI6MTc1ODIyMDA0MSwicGF0aCI6Ii8xMTg2MTI0LzQ5MDI4ODM4MC04NmQ2MWI1ZC05YTI1LTQzNzEtODM3NC0yODY0MWE3YzU5YjUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDkxOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTA5MThUMTgyNzIxWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9MjI4MWJhOWMwYTg0MDMwYWQ3ZDMwNWI4NGQ0NmY2ZmYzM2MyMTRhZjI2Nzk5MDI4NmY2ZjliNDdjNDg1YTQ0OSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.bD8HJlaB78d-ApbWmhAkpFYwg0OdrhUSKFtsJODw3NM"><img width="742" height="670" alt="Screenshot 2025-09-16 at 4 20 53 PM" src="https://private-user-images.githubusercontent.com/1186124/490288380-86d61b5d-9a25-4371-8374-28641a7c59b5.png?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTgyMjAzNDEsIm5iZiI6MTc1ODIyMDA0MSwicGF0aCI6Ii8xMTg2MTI0LzQ5MDI4ODM4MC04NmQ2MWI1ZC05YTI1LTQzNzEtODM3NC0yODY0MWE3YzU5YjUucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDkxOCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTA5MThUMTgyNzIxWiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9MjI4MWJhOWMwYTg0MDMwYWQ3ZDMwNWI4NGQ0NmY2ZmYzM2MyMTRhZjI2Nzk5MDI4NmY2ZjliNDdjNDg1YTQ0OSZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.bD8HJlaB78d-ApbWmhAkpFYwg0OdrhUSKFtsJODw3NM"/></a>
<p dir="auto">The question then might be, how would we represent functions in egglog in such a way that we could write this rewrite and then extract out the optimized function?</p>
<p dir="auto">Next I might look at some more examples, in particular the <code>BATAX</code> one which their model errored out on. This might be a good chance to explore that as well. That one errored out because of associativity blow up. It could also be nice to try to address this through a multiset operation…</p>
<p dir="auto">So the paper could also be focused on these array operations, and then implementing them with a couple different new techniques.</p>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
