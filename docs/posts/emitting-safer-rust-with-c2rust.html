<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://immunant.com/blog/2023/03/lifting/">Original</a>
    <h1>Emitting Safer Rust with C2Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>In this post, we will discuss recent results from Immunant and Galois in extending C2Rust to emit memory-safe Rust in certain cases. With this work we aim to shift a meaningful part of the translation burden from the human to the machine. Up until now, C2Rust has only been able to translate C to unsafe Rust that is no safer than the original input C code. Although this provides a starting point for manual refactoring into idiomatic and safe Rust, this work had to be done by the human. By using a combination of static and dynamic analysis, the current in-development version of C2Rust can now perform some of the lifting to safe Rust automatically. This post describes how this analysis works and how we are using it to make it easier to translate unsafe C programs into memory-safe Rust.</p>
<p>Rust is definitely a batteries-included language, but suppose for the sake of exposition that it did not include the ability to sort an array of integers. Further, imagine that we decided to address this shortcoming by migrating an existing C implementation such as the one below:</p>
<pre><code>void insertion_sort(int const n, int * const p) {
  for (int i = 1; i &lt; n; i++) {
    int const tmp = p[i];
    int j = i;
    while (j &gt; 0 &amp;&amp; p[j-1] &gt; tmp) {
      p[j] = p[j-1];
      j--;
    }
    p[j] = tmp;
  }
}

</code></pre>
<p>If we feed this to C2Rust (try it yourself on <a href="https://immunant.com/blog/2023/03/lifting/c2rust.com">c2rust.com</a>), we get this Rust out the other end:</p>
<pre><code>pub unsafe extern &#34;C&#34; fn insertion_sort(
        n: libc::c_int, p: *mut libc::c_int) {
    let mut i: libc::c_int = 1 as libc::c_int;
    while i &lt; n {
        let tmp: libc::c_int = *p.offset(i as isize);
        let mut j: libc::c_int = i;
        while j &gt; 0 as libc::c_int &amp;&amp;
                  *p.offset((j - 1 as libc::c_int) as isize) &gt; tmp {
            *p.offset(j as isize) =
                *p.offset((j - 1 as libc::c_int) as isize);
            j -= 1
        }
        *p.offset(j as isize) = tmp;
        i += 1
    };
}

</code></pre>
<p>This code could be rewritten to use fewer casts, but that’s a topic for another post; our goal here is to reduce unsafety by avoiding the use of raw pointers since they permit out of bounds accesses. If we change insertion_sort’s second formal parameter p, we’ll have to change the actual argument passed to insertion_sort at all call sites. Say we have a call in main:</p>
<pre><code>unsafe fn main_0() -&gt; libc::c_int {
    let mut arr1: [libc::c_int; 3] = [1, 3, 2];
    insertion_sort(
        3 as libc::c_int, arr1.as_mut_ptr());
    // …
}
</code></pre>
<p>We need to understand how the pointer to arr1 flows from main_0 to insertion_sort. This is trivial in our simple example, but in the general case, no algorithm exists that always gives the correct answer to aliasing questions such as “can a pointer X be used to access allocation Y”? The problem, in a nutshell, is that most programs are sufficiently complex that we cannot analyze all the states they could possibly be in. We can build analyses that reason over all possible program states (also known as static program analyses) but they often fall back to conservatively correct answers such as “maybe” where a definite “yes/no” answer is required.
For this reason, and to facilitate experimentation, we augment what we can learn from relatively simple types of static analysis with dynamic observations collected during program execution. Fuzz testing tools similarly eschew complicated static analyses and opt instead to detect access violations at runtime by feeding a large number of random inputs to programs. Our thinking is that we can similarly learn enough about how programs use pointers to discover how to express the same computation in the Rust type system. This won’t work all of the time, but that’s okay as long as it works sufficiently often to save programmers a meaningful amount of time. Just like a fuzzer, we instrument the generated Rust code and run it on some example inputs. We use the information we generate to build a pointer derivation graph or PDG.</p>

    <p><img src="https://immunant.com/images/blog/2023/03/pdg.png" alt="Pointer derivation graph for array of integers"/></p><p>The pointer derivation graph is a summary of observations that we’ll use to transform our program. (If we had a static analysis available that gave us the same information, we could have used that; alas, interprocedural points-to analysis is a dragon we’d rather not slay.) Now that we have a PDG for the pointer argument p, we can compute what permissions are needed at each point in the program where p is defined and used. The five permissions we care about are</p>
<ul>
<li>WRITE: when the program writes to the pointee</li>
<li>UNIQUE: when the pointer is the only way to access a given memory location</li>
<li>FREE: when the pointer will eventually be passed to free<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></li>
<li>OFFSET_ADD: when we’ll add an offset to the pointer, e.g. to access an array element</li>
<li>OFFSET_SUB: when we may subtract an offset from the pointer</li>
</ul>
<p>The permissions needed by a pointer map to Rust types according to the following (non-exhaustive<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>) table:</p>
<table>
<thead>
<tr>
<th>Write</th>
<th>Unique</th>
<th>Free</th>
<th>Offset</th>
<th>Resulting ptr type</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&amp;T</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>&amp;mut T</td>
</tr>
<tr>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>&amp;Cell<!-- raw HTML omitted --><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></td>
</tr>
<tr>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td>Box<!-- raw HTML omitted --></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td>&amp;[T]</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td></td>
<td>x</td>
<td>&amp;mut [T]</td>
</tr>
<tr>
<td></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>Box&lt;[T]&gt;</td>
</tr>
</tbody>
</table>
<p>Let’s use this table and the PDG to rewrite the array of integers to insertion sort:</p>

    <p><img src="https://immunant.com/images/blog/2023/03/permissions.png" alt="Pointer derivation graph for array of integers"/></p><p>The parameter p needs the OFFSET<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> permission because it is used as the base pointer in array indexing operations and the WRITE permission because one of these operations is a store. The last row permissions table gives us the safe type for data needing WRITE and OFFSET operations, which is <code>&amp;mut [T]</code>, meaning that <code>&amp;mut [libc::c_int]</code> is the appropriate concrete type for p. Once we update the type of the formal parameter p, we can propagate the change throughout the function body. We replace all uses of offset with proper array indexing operations, which in turn requires us to cast the index to a usize instead of a isize. We are not yet able to mechanically perform these rewriting operations but once we get there, the result should look like this:</p>
<pre><code>pub fn insertion_sort(n: libc::c_int, p: &amp;mut [libc::c_int]) {
    let mut i: libc::c_int = 1 as libc::c_int;
    while i &lt; n {
        let tmp: libc::c_int = p[i as usize];
        let mut j: libc::c_int = i;
        while j &gt; 0 as libc::c_int &amp;&amp;
                  p[(j - 1 as libc::c_int) as usize] &gt; tmp {
            p[j as usize] =
                p[(j - 1 as libc::c_int) as usize];
            j -= 1
        }
        p[j as usize] = tmp;
        i += 1
    }
}

unsafe fn main_0() -&gt; libc::c_int {
    let mut arr1: [libc::c_int; 3] = [1, 3, 2];
    insertion_sort(3 as libc::c_int, &amp;mut arr1); // propagate type change to
                                                 // caller
    // …
}
</code></pre>
<p>At the time of writing, we are implementing the ability to apply rewrites automatically. We are using (fragments of) the <a href="https://www.lighttpd.net/">lighttpd</a> web server as a model organism. While all code is available on the C2Rust GitHub <a href="https://github.com/immunant/c2rust">repository</a>, much work remains before we have a version that is suitable for anything beyond internal dogfooding. Expect a follow-up blog post covering how to try out lifting to safer Rust on your own code sometime in the second half of 2023.</p>
<p>The million-dollar question is how close to idiomatic Rust code we can get with the current approach. As previously mentioned, the limits of static analysis are well known. We don’t have the resources to build the best possible static analysis, so we very quickly run up against the practical limits of what we can do in a fully automatic and correctness-preserving manner. (We use a liberal notion of correctness which allows us to convert a well-defined C program into Rust that panics, this will allow us to add bounds checking and use RefCell among other things). The results obtained via dynamic analysis can be used as an oracle to speculate on properties that are not available via static analysis. Whenever possible, we will perform speculative rewrites such that the code will panic in case of misspeculation. Programmer can remove asserts inserted to guard against misspeculation to confirm that a property will always hold. This too will be covered in a future post. In the meanwhile, you can always reach us in the C2Rust <a href="https://discord.com/invite/ANSrTuu">discord channel</a> and on the GitHub <a href="https://github.com/immunant/c2rust">repository</a>. We look forward to hearing from you!</p>
<p><em>This research was developed with funding from the Defense Advanced Research Projects Agency (DARPA). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the Department of Defense or the U.S. Government.</em></p>
<p><em>Distribution Statement “A” (Approved for Public Release, Distribution Unlimited)</em></p>


            </div></div>
  </body>
</html>
