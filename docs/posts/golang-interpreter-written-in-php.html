<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tuqqu/go-php">Original</a>
    <h1>Golang Interpreter Written in PHP</h1>
    
    <div id="readability-page-1" class="page"><article><p><a href="https://leetcode.com/problems/valid-parentheses/">Valid parantheses challenge<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>// identify opening brackets</span></span>
<span data-line=""><span>// let opening = &#39;[{(&#39;</span></span>
<span data-line=""><span>// save them in an ordered list</span></span>
<span data-line=""><span>// identify closing brackets</span></span>
<span data-line=""><span>// let = &#39;)}]&#39;</span></span>
<span data-line=""><span>// As closing brackets come up, check if the last item in the opening brackets list matches</span></span>
<span data-line=""><span>// if it doesn&#39;t (provided we add opening brackets to list before closing brackets), return false</span></span>
<span data-line=""><span>// if it does, remove that opening from the list, we&#39;re good.</span></span>
<span data-line=""><span>// so for like, &#39;[[}]&#39;, if we do that process, we 1) add a [ to openings, add another [ to openings, check if } is the last item in openings,</span></span>
<span data-line=""><span>// And find it ISN&#39;T, so we exit. Nice.</span></span>
<span data-line=""><span>// Let&#39;s try {[]{}}. We add { to the openings array, [ too, then check if ] type bracket is the --</span></span>
<span data-line=""><span>// Okay so little detail here, we need a mapping of openings &#39;]&#39;:&#39;[&#39;, etc. We use that to check, I didn&#39;t mention that.</span></span>
<span data-line=""><span>// So given that, we check if &#39;]&#39;&#39;s mapping is the last item int he opening list, and we find it is, we can maybe pop it off</span></span>
<span data-line=""><span>// For brevity, next character we have &#39;{&#39;, that&#39;s an opening, so we add it to openings, then we have &#39;}&#39;, we check the mapping of &#39;}&#39;, which is &#39;{&#39; against</span></span>
<span data-line=""><span>// The last opening,</span></span>
<span data-line=""><span>// It&#39;s be 33% of the alloted time, I think we&#39;re good</span></span>
<span data-line=""><span>// And we find that they correspond, same shit, we remove that last opening from the list. We should be left with an opening list of just { now, which gets resolved with the last process.</span></span>
<span data-line=""><span>// Okay I feel great about that.</span></span>
<span data-line=""><span>// I am gonna go back and just reread the problem and see if I have all the requirements correct.</span></span>
<span data-line=""><span>// Okay sweet, looks like s consists only of paren characters, no characters etc.</span></span>
<span data-line=""><span>// I think I addressed it, but the trickiest rule is that &#34;open brackets must be closed in the correct order&#34;</span></span>
<span data-line=""><span>// Yeah, I think that&#39;s working. Let me just spam some edge cases over the next minute before I get started</span></span>
<span data-line=""><span>// &#34;[[[[[[[[[]]]]]]]]]&#34;, &#34;}&#34;</span></span>
<span data-line=""><span>// Ooh there&#39;s one - what if we START with an open bracket?</span></span>
<span data-line=""><span>// So like, yeah, I just need to make sure I handle that -</span></span>
<span data-line=""><span>// If I try to check the &#34;openings&#34; and it&#39;s empty, we&#39;re done - I have to return false</span></span>
<span data-line=""><span>// Okay that was fruitful. Let me try a few more &#39;]}]&#39; isn&#39;t really different</span></span>
<span data-line=""><span>// &#39;{[{[&#39; okay so this has no closings. I ALSO need to make sure THIS returns false,</span></span>
<span data-line=""><span>// And I think I truly may have missed this case</span></span>
<span data-line=""><span>// I guess it was implied that I have a hanging return true at the end, but what I really have to do is check to make sure that the &#34;openings&#34; array gets completely emptied</span></span>
<span data-line=""><span>// And only return true if it does.</span></span>
<span data-line=""><span>// Okay crap, 50% done with time. Let&#39;s give this a shot</span></span>
<span data-line=""><span>  // One more weird case - what about an empty string? I don&#39;t have to worry about it because the string has at least one character</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// oh my godddddd</span></span>
<span data-line=""><span>// okay ten minutes to go. I got this.</span></span></code></pre></figure>

<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> isValid</span><span>(</span><span>str</span><span>){</span></span>
<span data-line=""><span>  if</span><span> (str.</span><span>length</span><span> &lt;</span><span> 1</span><span>){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>&#34;based on my understanding of requirements, this should not have happened: case A&#34;</span><span>)</span></span>
<span data-line=""><span>     return</span><span> false</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  let</span><span> openChars </span><span>=</span><span> &#39;[{(&#39;</span></span>
<span data-line=""><span>  let</span><span> closeChars </span><span>=</span><span> &#39;]})&#39;</span></span>
<span data-line=""><span>  let</span><span> openings </span><span>=</span><span> []</span></span>
<span data-line=""><span>  let</span><span> key </span><span>=</span><span> {</span></span>
<span data-line=""><span>    &#39;}&#39;</span><span>: </span><span>&#39;{&#39;</span><span>,</span></span>
<span data-line=""><span>    &#39;]&#39;</span><span>: </span><span>&#39;[&#39;</span><span>,</span></span>
<span data-line=""><span>    &#39;)&#39;</span><span>: </span><span>&#39;(&#39;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> str){</span></span>
<span data-line=""><span>    if</span><span> (openChars.</span><span>includes</span><span>(char) ){</span></span>
<span data-line=""><span>      openings.</span><span>push</span><span>(char)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (closeChars.</span><span>includes</span><span>(char)){</span></span>
<span data-line=""><span>      let</span><span> lastOpen </span><span>=</span><span> openings[openings.</span><span>length</span><span> -</span><span> 1</span><span>]</span></span>
<span data-line=""><span>      if</span><span> (lastOpen </span><span>!==</span><span> key[char]) </span><span>return</span><span> false</span></span>
<span data-line=""><span>      openings.</span><span>pop</span><span>() </span><span>// lastOpen DOES === the current char, so we can get rid of that opener and continue</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(openings)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  if</span><span> (openings.</span><span>length</span><span>){</span></span>
<span data-line=""><span>      return</span><span> false</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> true</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>

<p>I finished with 2.5 minutes to go and got a function that worked first try, which I feel really good about! I think that spending 15 minutes to calmly work through edge cases worked really really well. Normally I just start coding as think, and maybe this is more efficient in some ways —</p>
<p>I guess to be fair, I DID code some things as I went, which I think is a good idea.</p>
<p>Something I didn’t do is have a section in my leetcode that was actionable notes, which might have helped with organization.</p>
<p>I also think I did a good job of going with an available working solution instead of an eloquent solution. 30 minutes <em>really</em> isn’t much time.</p>

<p>I asked Claude how I could have improved things, and he suggested using Sets instead of strings, and using Maps instead of normal js objects. Those make sense and would be a great way to flex my understanding of these data sets (dishonestly, as I don’t use these too often at the moment), but don’t really seem that important.</p>
<p>What I did like was checking for even or odd numbered inputs for early returns.</p>
<p>He also suggested checking for closing brackets first…dont’ totally understand this approach:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> s){</span></span>
<span data-line=""><span>	if</span><span> (bracketMap.</span><span>has</span><span>(char)){</span></span>
<span data-line=""><span>		if</span><span> (openings.</span><span>pop</span><span>() </span><span>!==</span><span> bracketMap.</span><span>get</span><span>(char)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""><span>	} </span><span>else</span><span> {</span></span>
<span data-line=""><span>		openings.</span><span>push</span><span>(char);</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>This switch statement suggestion is really interesting though:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>for</span><span> (</span><span>let</span><span> char </span><span>of</span><span> s){</span></span>
<span data-line=""><span>	switch</span><span>(char)</span></span>
<span data-line=""><span>		{ </span><span>case</span><span> &#39;(&#39;</span><span>: </span><span>case</span><span> &#39;{&#39;</span><span>: </span><span>case</span><span> &#39;[&#39;</span><span>:</span></span>
<span data-line=""><span>			openings.</span><span>push</span><span>(char);</span></span>
<span data-line=""><span>			break</span><span>;</span></span>
<span data-line=""><span>		case</span><span> &#39;)&#39;</span><span>: </span><span>case</span><span> &#39;}&#39;</span><span>: </span><span>case</span><span> &#39;]&#39;</span><span>:</span></span>
<span data-line=""><span>			if</span><span> (openings.</span><span>pop</span><span>() </span><span>!==</span><span> bracketMap.</span><span>get</span><span>(char)) </span><span>return</span><span> false</span><span>;</span></span>
<span data-line=""><span>			break</span><span>;</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>

<p><a href="https://www.linkedin.com/in/paul-winkler-27995a2/">Paul Winkler<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, a colleague of mine, noticed that I failed to handle an edge case that I <em>did notice</em> in my pseudocode, which was:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>// Ooh there&#39;s one - what if we START with an open bracket?</span></span></code></pre></figure>
<p>Although the initial code passes leetcode’s submission tests, I don’t seem to be handling this. Leetcode is pretty stringent, so I wondered how this could be. I checked the submission criteria:</p>
<pre><code>1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.
</code></pre>
<p>And found that a case of <code>}</code> would definitely fail criteria item #3, but maybe this is not a case that is run by leetcode. In fact, I think it <em>must</em> not be a case run by leetcode, since if it was I think this case might get an <code>Out of bounds</code> error on the second line here:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="JavaScript" data-theme="github-light github-dark"><code data-language="JavaScript" data-theme="github-light github-dark"><span data-line=""><span>    if (closeChars.includes(char)){</span></span>
<span data-line=""><span>     let lastOpen = openings[openings.length - 1]</span></span>
<span data-line=""><span>      if (lastOpen !== key[char]) return false</span></span>
<span data-line=""><span>      openings.pop() // lastOpen DOES === the current char, so we can get rid of that opener and continue</span></span>
<span data-line=""><span>      console.log(openings)</span></span>
<span data-line=""><span>    }</span></span></code></pre></figure>
<p>But then I went and tested this case <code>]</code> as well as <code>[]]</code> just to be safe, and my function evaluated these as <code>false</code> after all. So, edge case handled…just not intentionally. My ego is a little bruised, since it seems I got a bit lucky, but that tracks a bit better with how leetcode is supposed to go.</p>
<p>First off, it turns out that getting the length of an empty array <em>doesn’t</em> through an error in JavaScript.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/b2729b1e2c7205f6f6371fdb65f77b0f.png" alt="image"/></p>
<p>But it <em>does</em> mean that if there are no openings left, <code>lastOpen</code> is <code>undefined</code> and we’ll return <code>false</code> because there is no corresponding open tag to our closing tag! This applies even if we <em>only</em> have a single closing tag as our input string.</p>
<p>In summary, I lucked out, and that’s why this is the only leetcode that I have been able to approach blind and finish in 30 minutes. Luckily, because it was only the second one ever tried, the result was that I gained a huge amount of unearned confidence!</p>
<p>That confidence formed a sort of force field, protecting me from the grueling leetcode studying that followed, ultimately leaving me vulnerable, optimistic, and perfectly situated to fail my technical interview with Figma! So it goes.</p>

<p>Remembered a little bit of this, mostly just that I had an object mapping closing to opening parens. And that I didn’t need an object doing the opposite.</p>
<p><strong>Time:</strong> 9 minutes</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="var" data-theme="github-light github-dark"><code data-language="var" data-theme="github-light github-dark"><span data-line=""> </span>
<span data-line=""><span>    let anOpener = false</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let thang = {</span></span>
<span data-line=""><span>        &#34;}&#34;: &#34;{&#34;,</span></span>
<span data-line=""><span>        &#34;)&#34;: &#34;(&#34;,</span></span>
<span data-line=""><span>        &#34;]&#34;: &#34;[&#34;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let opens = &#34;{[(&#34;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let openers = []</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for (const p of s){</span></span>
<span data-line=""><span>        if (opens.includes(p)){</span></span>
<span data-line=""><span>            anOpener = true</span></span>
<span data-line=""><span>            openers.push(p)</span></span>
<span data-line=""><span>        } else {</span></span>
<span data-line=""><span>            // closer territory</span></span>
<span data-line=""><span>            let partner = thang[p]</span></span>
<span data-line=""><span>            // check the last opener to see if it is the same as the closer</span></span>
<span data-line=""><span>            if (openers[openers.length - 1] === partner){</span></span>
<span data-line=""><span>                openers.pop()</span></span>
<span data-line=""><span>            } else {</span></span>
<span data-line=""><span>                return false</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if (!openers.length &amp;&amp; anOpener) return true</span></span>
<span data-line=""><span>    return false</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>My initial small mistake is that I thought I might need 2 for loops.</p>
<p>Above, I talk about handling edge cases by luck. This came back to bite me - by running my code, I got hit by a single edge case I didn’t see coming, and it took me two tries to handle it.</p>
<p>My first attempt was naive - I quickly created the <code>anOpener</code> variable to check that there was at least <em>one</em> opener, a misguided attempt that <em>did</em> solve the case where I only got <code>}</code>, thinking of that as somehow unique. But the problem here isn’t that there’s just <em>one</em> closer and no openers, it’s more broadly how the closer shows up with no corresponding opener, which should always result in failure.</p>
<p>So here’s a slightly simplified version:</p>
<pre><code>var isValid = function(s) {

    let thang = {
        &#34;}&#34;: &#34;{&#34;,
        &#34;)&#34;: &#34;(&#34;,
        &#34;]&#34;: &#34;[&#34;
    }

    let opens = &#34;{[(&#34;

    let openers = []

    for (const p of s){
        if (opens.includes(p)){
            anOpener = true
            openers.push(p)
        } else {
            // closer territory
            let partner = thang[p]
            // check the last opener to see if it is the same as the closer
            if (openers[openers.length - 1] === partner){
                openers.pop()
            } else {
                return false
            }
        }

    }

    if (!openers.length) return true
    return false
};
</code></pre></article></div>
  </body>
</html>
