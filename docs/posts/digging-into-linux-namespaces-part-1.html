<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/digging-into-linux-namespaces-part-1.html">Original</a>
    <h1>Digging into Linux namespaces – part 1</h1>
    
    <div id="readability-page-1" class="page"><div>

        <!--/.well -->

        <div>
<section id="content">
<article>
<header>

</header>
<div>
  

  <p>Process isolation is a key component for containers. One of the key underlying mechanisms are <em>namespaces</em>. We will explore what they are, and how they work, to build our own isolated container and better understand each piece.</p>

  <div id="what-are-namespaces">
<h2>What are namespaces?</h2>
<p>Namespaces are a Linux kernel feature released in kernel version 2.6.24
in 2008. They provide processes with <strong>their own system view</strong>, thus
<strong>isolating independent processes from each other</strong>. In other words,
<strong>namespaces define the set of resources that a process can use</strong> (<em>You
cannot interact with something that you cannot see</em>). At a high level,
they allow fine-grain partitioning of global operating system resources
such as mounting points, network stack and inter-process communication
utilities. A powerful side of namespaces is that they limit access to
system resources without the running process being aware of the
limitations. In typical Linux fashion they are represented as files
under the <tt><span>/proc/&lt;pid&gt;/ns</span></tt> directory.</p>
<div><pre><span></span><span>cryptonite@cryptonite:~ $</span> <span>echo</span> <span>$$</span>
<span>4622</span>
<span>cryptonite@cryptonite:~ $</span> ls /proc/<span>$$</span>/ns -al
<span>total 0</span>
<span>dr-x--x--x 2 cryptonite cryptonite 0 Jun 29 15:00 .</span>
<span>dr-xr-xr-x 9 cryptonite cryptonite 0 Jun 29 13:13 ..</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 cgroup -&gt; &#39;cgroup:[4026531835]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 ipc -&gt; &#39;ipc:[4026531839]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 mnt -&gt; &#39;mnt:[4026531840]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 net -&gt; &#39;net:[4026532008]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 pid -&gt; &#39;pid:[4026531836]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 pid_for_children -&gt; &#39;pid:[4026531836]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 time -&gt; &#39;time:[4026531834]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 time_for_children -&gt; &#39;time:[4026531834]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 user -&gt; &#39;user:[4026531837]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:00 uts -&gt; &#39;uts:[4026531838]&#39;</span>
</pre></div>
<p>When we spawn a new process all the namespaces are inherited from its
parent.</p>
<div><pre><span></span><span>#</span> inception
<span>cryptonite@cryptonite:~ $</span> /bin/zsh
<span>#</span> father PID verification
<span>╭─cryptonite@cryptonite ~</span>
<span>╰─$ ps -efj  | grep $$</span>
<span>crypton+   13560    4622   13560    4622  1 15:07 pts/1    00:00:02 /bin/zsh</span>
<span>╭─cryptonite@cryptonite ~</span>
<span>╰─$ ls /proc/$$/ns -al</span>
<span>total 0</span>
<span>dr-x--x--x 2 cryptonite cryptonite 0 Jun 29 15:10 .</span>
<span>dr-xr-xr-x 9 cryptonite cryptonite 0 Jun 29 15:07 ..</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 cgroup -&gt; &#39;cgroup:[4026531835]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 ipc -&gt; &#39;ipc:[4026531839]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 mnt -&gt; &#39;mnt:[4026531840]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 net -&gt; &#39;net:[4026532008]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 pid -&gt; &#39;pid:[4026531836]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 pid_for_children -&gt; &#39;pid:[4026531836]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 time -&gt; &#39;time:[4026531834]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 time_for_children -&gt; &#39;time:[4026531834]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 user -&gt; &#39;user:[4026531837]&#39;</span>
<span>lrwxrwxrwx 1 cryptonite cryptonite 0 Jun 29 15:10 uts -&gt; &#39;uts:[4026531838]&#39;</span>
</pre></div>
<p>Namespaces are created with the <em>clone</em> syscall with one of the
following arguments:</p>
<ul>
<li><tt>CLONE_NEWNS</tt> - create new mount namespace;</li>
<li><tt>CLONE_NEWUTS</tt> - create new UTS namespace;</li>
<li><tt>CLONE_NEWIPC</tt> - create new IPC namespace;</li>
<li><tt>CLONE_NEWPID</tt> - create new PID namespace;</li>
<li><tt>CLONE_NEWNET</tt> - create new NET namespace;</li>
<li><tt>CLONE_NEWUSER</tt> - create new USR namespace;</li>
<li><tt>CLONE_NEWCGROUP</tt> - create a new cgroup namespace.</li>
</ul>
<p>Namespaces can also be created using the <em>unshare</em> syscall. The
difference between <em>clone</em> and <em>unshare</em> is that <em>clone</em> spawns a new
process inside a new set of namespaces, and <em>unshare</em> moves the current
process inside a new set of namespaces (unshares the current ones).</p>
</div>
<div id="why-use-namespaces">
<h2>Why use namespaces?</h2>
<p>If we <strong>imagine namespaces as boxes for processes</strong> containing some
abstracted global system resources, one good thing with these boxes is
that you can <strong>add and remove stuff from one box and it will not affect
the content of the other boxes</strong>. Or, if a process A in a box (set of
namespaces) goes crazy and decides to delete the whole filesystem or the
network stack in that box, it will not affect the abstraction of these
resources provided for another process B placed in a different box.
Moreover, namespaces can provide even fine-grained isolation, allowing
process A and B to share some system resources (e.g. sharing a mount
point or a network stack). Namespaces are often used when untrusted
code has to be executed on a given machine without compromising the host
OS. Programming contest platforms like <em>Hackerrank</em>, <em>Codeforces</em>,
<em>Rootme</em> use namespaced environments in order to safely execute and
verify contestants&#39; code without putting their servers at risk. PaaS
(platform as a service) providers like <em>Google Cloud Engine</em> use namespaced
environments to run multiple user services (e.g. web servers, databases)
on the same hardware without the possibility of interference of these
services. So namespaces can also be seen as useful for <strong>efficient
resource sharing</strong>. Other cloud technologies like Docker or LXC also use
namespaces as means for process isolation. These technologies put
operating system processes in isolated environments called
<em>containers</em>. Running processes in Docker containers, for example, is
like running them in virtual machines. The difference between containers
and VMs is that containers share and use directly the host OS kernel,
thus making them significantly lighter than virtual machines as there is
no hardware emulation. This increase of overall performance is mainly
due to the usage of namespaces which are directly integrated in the
Linux kernel. However, there are some
<a href="https://github.com/firecracker-microvm/firecracker">implementations</a>
of VMs which are extremely light.</p>
</div>
<div id="types-of-namespaces">
<h2>Types of namespaces</h2>
<p>In the current stable Linux Kernel version 5.7 there are seven different
namespaces:</p>
<ul>
<li><strong>PID namespace</strong>: isolation of the system process tree;</li>
<li><strong>NET namespace</strong>: isolation of the host network stack;</li>
<li><strong>MNT namespace</strong>: isolation of host filesystem mount points;</li>
<li><strong>UTS namespace</strong>: isolation of hostname;</li>
<li><strong>IPC namespace</strong>: isolation for interprocess communication utilities (shared segments, semaphores);</li>
<li><strong>USER namespace</strong>: isolation of system users IDs;</li>
<li><strong>CGROUP namespace</strong>: isolation of the virtual cgroup filesystem of the host.</li>
</ul>
<p>The namespaces are per-process attributes. <strong>Each process can perceive
at most one namespace</strong>. In other words, at any given moment, any
process P belongs to exactly one instance of each namespace. For example
when a given process wants to update the route table on the system, the
Kernel shows it the copy of the route table of the namespace to which it
belongs at that moment. If a process asks for its ID in the system, the
Kernel will respond with the ID of the process in its current namespace
(in case of nested namespace). We are going to look in detail at each
namespace in order to understand what are the operating system
mechanisms behind them. Understanding that will help us find what is
under the hood of today’s <em>containerized</em> technologies.</p>
<div id="pid-namespace">
<h3>PID namespace</h3>
<p>Historically, the Linux kernel has maintained a single process tree. The
tree data structure contains a reference to every process currently
running in a parent-child hierarchy. It also enumerates all running
processes in the OS. This structure is maintained in the so called
<em>procfs</em> filesystem which is a property of the live system (i.e. it’s
present only when the OS is running). This structure allows processes
with sufficient privileges to attach to other processes, inspect,
communicate and/or kill them. It also contains information about the
root directory of a process, its current working directory, the open
file descriptors, virtual memory addresses, the available mounting
points, etc.</p>
<div><pre><span></span><span>#</span> an example of the procfs structure
<span>cryptonite@cryptonite:~ $</span>ls /proc/1/
<span>   arch_status     coredump_filter      gid_map     mounts          pagemap         setgroups   task</span>
<span>   attr            cpu_resctrl_groups   io          mountstats      patch_state     smaps       timens_offsets</span>
<span>   cgroup          environ              map_files   numa_maps       root            stat        uid_map</span>
<span>   clear_refs      exe                  maps        oom_adj         sched           statm</span>
<span>...</span>
<span>#</span> an example of the process tree structure
<span>cryptonite@cryptonite:~ $</span>pstree <span>|</span> head -n <span>20</span>
<span>systemd-+-ModemManager---2*[{ModemManager}]</span>
<span>        |-NetworkManager---2*[{NetworkManager}]</span>
<span>        |-accounts-daemon---2*[{accounts-daemon}]</span>
<span>        |-acpid</span>
<span>        |-avahi-daemon---avahi-daemon</span>
<span>        |-bluetoothd</span>
<span>        |-boltd---2*[{boltd}]</span>
<span>        |-colord---2*[{colord}]</span>
<span>        |-containerd---17*[{containerd}]</span>
</pre></div>
<p>On system boot, the first process started on most of the modern Linux OS
is systemd (system daemon), which is situated on the root node of the
tree. Its parent is <strong>PID=0 which is a non-existing process in the OS</strong>.
This process is after that responsible for starting the other
services/daemons, which are represented as its childs and are necessary
for the normal functioning of the OS. These processes will have PIDs &gt; 1
and the PIDs in the tree structure are unique.</p>
<p>With the introduction of the <em>Process namespace (or PID namespace)</em> it
became possible to make nested process trees. It allows processes other
than systemd (PID=1) to perceive themselves as the root process by
moving on the top of a subtree, thus obtaining PID=1 in that subtree.
All processes in the same subtree will also obtain IDs relative to the
process namespace. This also means that some processes may end up having
multiple IDs depending on the number of process namespaces that they are
in. Yet, in each namespace, at most one process can have a given PID (the
unique value of a node in the process tree becomes a per-namespace
property). This comes from the fact that relations between the processes
in the root process namespace stay intact. Or said with other words, a
process in a new PID namespace is still attached to its parent, thus
being part of its parent PID namespace. These relations between all
processes can be seen in the root process namespace, but in a nested
process namespace they are not visible. That means that a process in a
nested process namespace can’t interact with its parent or any other
process in an upper process namespace. That’s due to the fact that, being
on the top of a new PID namespace, the process perceives its PID as 1, and
there is no other process before the process with PID=1.</p>
<p><img alt="" src="https://blog.quarkslab.com/resources/2021-10-27-namespaces/jcPTsBS.png"/></p><center><i>Diagram by <a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces">Mahmud Ridwan from Toptal</a></i></center></div>
<div id="net-namespace">
<h3>NET namespace</h3>
<p>A network namespace limits the view of a process of the host network. It
allows a process to have its own separation from the host network stack
(set of network interfaces, routing rules, set of netfilter hooks).
Let’s inspect that:</p>
<div><pre><span></span><span>#</span> root net namespace
<span>cryptonite@cryptonite:~ $</span>ip link  <span># network interfaces</span>
<span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span>
<span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span>
<span>2: enp0s31f6: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000</span>
<span>    link/ether 8c:16:45:54:8b:65 brd ff:ff:ff:ff:ff:ff</span>
<span>.....</span>
<span>cryptonite@cryptonite:~ $</span>ip route <span># routing rules</span>
<span>default via 192.168.2.1 dev wlp3s0 proto dhcp metric 600</span>
<span>10.0.0.0/16 via 10.0.1.230 dev tun0 proto static metric 50</span>
<span>....</span>
<span>cryptonite@cryptonite:~ $</span>sudo iptables --list-rules <span># firewall rules</span>
<span>-P INPUT ACCEPT</span>
<span>-P FORWARD DROP</span>
<span>-P OUTPUT ACCEPT</span>
<span>-N DOCKER</span>
<span>.....</span>
</pre></div>
<p>Let’s now create a fresh new network namespace and inspect the network
stack.</p>
<div><pre><span></span><span>cryptonite@cryptonite:~ $</span>sudo unshare --net /bin/bash
<span>root@cryptonite:/home/cryptonite#</span> ip link
<span>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span>
<span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span>
<span>root@cryptonite:/home/cryptonite#</span> ip route
<span>Error: ipv4: FIB table does not exist.</span>
<span>Dump terminated</span>
<span>root@cryptonite:/home/cryptonite#</span> iptables --list-rules
<span>-P INPUT ACCEPT</span>
<span>-P FORWARD ACCEPT</span>
<span>-P OUTPUT ACCEPT</span>
</pre></div>
<p>We can see that the entire network stack of the process has changed.
There is only the loopback interface which is also down. Said with other
words, this process is unreachable via the network. But that’s a problem,
isn’t it? Why do we need a virtually isolated network stack if we can’t
communicate through it? Here is an illustration of the situation:</p>
<p><img alt="" src="https://blog.quarkslab.com/resources/2021-10-27-namespaces/r5PvRzu.png"/></p><p>As normally we want to be able to communicate in some way with a given
process, we have to provide a way to connect different net namespaces.</p>
<div id="connecting-a-pair-of-namespaces">
<h4>Connecting a pair of namespaces</h4>
<p>In order to make a process inside a new network namespace reachable from
another network namespace, a pair of virtual interfaces is needed. These
two virtual interfaces come with a virtual cable - what comes at one of
the ends goes to the other (like a Linux pipe). So if we want to connect
a namespace (let’s say N1) and another one (let’s say N2) we have to put
one of the virtual interfaces in the network stack of N1 and the other
in the network stack of N2.</p>
<p><img alt="" src="https://blog.quarkslab.com/resources/2021-10-27-namespaces/2Bu1BeZ.png"/></p><center><i>Diagram by <a href="https://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces">Mahmud Ridwan from Toptal</a></i></center></div>
<div id="connecting-multiple-namespaces-creating-a-lan">
<h4>Connecting multiple namespaces (creating a LAN)</h4>
<p>To create a virtual LAN another Linux virtualization utility will be
used - the bridge. The Linux bridge behaves like a real level 2
(Ethernet) network switch - it forwards packets between interfaces that
are connected to it using a MAC association table. Let’s create our
virtual LAN.</p>
<div><pre><span></span><span>#</span> all previous configurations were deleted
<span>#</span> creating a pair of namespaces
<span>cryptonite@cryptonite:~ $</span>sudo ip netns add netns_0
<span>cryptonite@cryptonite:~ $</span>sudo ip netns add netns_1
<span>cryptonite@cryptonite:~ $</span>tree /var/run/netns/
<span>/var/run/netns/</span>
<span>├── netns_0</span>
<span>└── netns_1</span>
<span>...</span>
<span>cryptonite@cryptonite:~ $</span>sudo ip link add veth0 <span>type</span> veth peer name ceth0
<span>cryptonite@cryptonite:~ $</span>sudo ip link add veth1 <span>type</span> veth peer name ceth1
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> veth1 up
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> veth0 up
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> ceth0 netns netns_0
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> ceth1 netns netns_1
<span>#</span> setup the first connected interface -&gt; <span>net_namespace</span><span>=</span>netns_0
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_0 ip link <span>set</span> lo up
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_0 ip link <span>set</span> ceth0 up
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_0 ip addr add <span>192</span>.168.1.20/24 dev ceth0

<span>#</span> setup the second connected interface -&gt; netns_1
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_1 ip link <span>set</span> lo up
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_1 ip link <span>set</span> ceth1 up
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_1 ip addr add <span>192</span>.168.1.21/24 dev ceth1

<span>#</span> create the bridge
<span>cryptonite@cryptonite:~ $</span>sudo ip link add name br0 <span>type</span> bridge
<span>#</span> <span>set</span> an ip on the bridge and turn it up
<span>#</span> so that processes can reach the LAN through it
<span>cryptonite@cryptonite:~ $</span>ip addr add <span>192</span>.168.1.11/24 brd + dev br0
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> br0 up
<span>#</span> connect the ends of the network namespaces in the
<span>#</span> root namespace to the bridge
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> veth0 master br0
<span>cryptonite@cryptonite:~ $</span>sudo ip link <span>set</span> veth1 master br0
<span>#</span> check <span>if</span> the bridge is the master of the two veths
<span>cryptonite@cryptonite:~ $</span>bridge link show br0
<span>10: veth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master br0 state forwarding priority 32 cost 2</span>
<span>12: veth1@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master br0 state forwarding priority 32 cost 2</span>

<span>#</span> allow forwarding by the bridge in the root net namespace
<span>#</span> in order to <span>enable</span> the interface to forward between the namespaces
<span>#</span> depending on the different iptables policy this step may be skipped
<span>cryptonite@cryptonite:~ $</span>iptables -A FORWARD -i br0 -j ACCEPT

<span>#</span> check the network connection netns_test1 -&gt; netns_test0
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_test1 ping  <span>192</span>.168.1.20
<span>PING 192.168.1.20 (192.168.1.20) 56(84) bytes of data.</span>
<span>64 bytes from 192.168.1.20: icmp_seq=1 ttl=64 time=0.046 ms</span>
<span>...</span>

<span>#</span> connectivity check root_namespace -&gt; netns_0
<span>cryptonite@cryptonite:~ $</span>ip route
<span>...</span>
<span>192.168.1.0/24 dev br0 proto kernel scope link src 192.168.1.11</span>
<span>...</span>
<span>cryptonite@cryptonite:~ $</span>ping <span>192</span>.168.1.20
<span>PING 192.168.1.20 (192.168.1.20) 56(84) bytes of data.</span>
<span>64 bytes from 192.168.1.20: icmp_seq=1 ttl=64 time=0.150 ms</span>
<span>...</span>

<span>#</span> check the network connection netns_test0 -&gt; netns_test1
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_test0 ping <span>192</span>.168.1.21
<span>PING 192.168.1.21 (192.168.1.21) 56(84) bytes of data.</span>
<span>64 bytes from 192.168.1.21: icmp_seq=1 ttl=64 time=0.040 ms</span>
<span>...</span>
</pre></div>
<p>It works! A really important thing is that the virtual interface has to
have permissions to forward packets on the current network stack. To
avoid messing up with the iptables rules, one can repeat this procedure
in a separated network namespace where the rules table will be empty by
default. Let’s now connect the LAN to the Internet!</p>
</div>
<div id="reaching-the-outside-world">
<h4>Reaching the outside world</h4>
<p>We have assigned IP to our bridge and we can ping it from the network
namespaces.</p>
<div><pre><span></span><span>#</span> try to reach the internet
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_1 ping <span>8</span>.8.8.8
<span>ping: connect: Network is unreachable</span>
<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_1 ip route
<span>192.168.1.0/24 dev veth1 proto kernel scope link src 192.168.1.21</span>

<span>#</span> no route <span>for</span> the host interface -&gt; bridge is on Level <span>2</span> <span>=</span>&gt;
<span>#</span> no ARP resolution and inter-networking
<span>#</span> We  can make the bridge the default gateway <span>for</span> both namespaces
<span>#</span> and <span>let</span> it forward all traffic to the upper network namespace
<span>cryptonite@cryptonite:~ $</span>sudo ip -all netns <span>exec</span> ip route add default via <span>192</span>.168.1.11

<span>#</span> Did everything go smoothly?
<span>cryptonite@cryptonite:~ $</span>sudo ip -all netns <span>exec</span> ip route
<span>netns: netns_1</span>
<span>default via 192.168.1.11 dev ceth1</span>
<span>192.168.1.0/24 dev ceth1 proto kernel scope link src 192.168.1.21</span>

<span>netns: netns_0</span>
<span>default via 192.168.1.11 dev ceth0</span>
<span>192.168.1.0/24 dev ceth0 proto kernel scope link src 192.168.1.20</span>

<span>#</span> let<span>&#39;</span>s try again
<span>cryptonite@cryptonite:~ $</span>ip netns <span>exec</span> netns_0 ping <span>8</span>.8.8.8
<span>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span>
<span>^C</span>
<span>--- 8.8.8.8 ping statistics ---</span>
<span>2 packets transmitted, 0 received, 100% packet loss, ...</span>

<span>#</span> One last thing -&gt; the outside world doesn<span>&#39;</span>t know about our LAN nor <span>do</span> the host so we have to add one last rule
<span>cryptonite@cryptonite:~ $</span>iptables -t nat -A POSTROUTING -s <span>192</span>.168.1.0/24 -j MASQUERADE

<span>cryptonite@cryptonite:~ $</span>sudo ip netns <span>exec</span> netns_0 ping <span>8</span>.8.8.8
<span>PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</span>
<span>64 bytes from 8.8.8.8: icmp_seq=1 ttl=61 time=11.5 ms</span>
<span>64 bytes from 8.8.8.8: icmp_seq=2 ttl=61 time=12.5 ms</span>
<span>...</span>
</pre></div>
<p>Note that the <tt>iptables</tt> rules of the host have to be well configured,
because a bad configuration can lead to bad things. In addition, without
masquerading, the packets would leave the host with its internal IP address
which is only known from this host, the gateway on the host’s LAN has no
idea how to join the local bridge network.</p>
<p><strong>To sum up about the network namespace</strong>:</p>
<ul>
<li>Processes within a given network namespace get their own private network stack, including network interfaces, routing tables, iptables rules, sockets (ss, netstat);</li>
<li>The connection between network namespaces can be done using two virtual interfaces;</li>
<li>Communication between isolated network stacks in the same namespace is done using a bridge;</li>
<li>The NET namespace can be used to simulate a “box” of Linux processes where only a few of them would be able to reach the outside world (by removing the host’s default gateway from the routing rules of some NET namespaces).</li>
</ul>
</div>
</div>
</div>
<div id="take-a-breath">
<h2>Take a breath</h2>
<p>So far, we have covered several namespaces. In the next article, we will see others:</p>
<ul>
<li>USER: to map UID/GID and hence have different root users depending on the current namespace.</li>
<li>MNT: to create per process filesystems.</li>
<li>UTS: to isolate the system hostname.</li>
<li>IPC: which provides isolation for semaphores, message queues, shared memory, etc.</li>
<li>CGROUP: by which you can control hardware resources per process.</li>
</ul>
<p>Then, you&#39;ll know (almost) everything about namespaces thus will be able to create your own container, or rather a fully isolated environment for a given process.</p>
</div>
<div id="greetings">
<h2>Greetings</h2>
<p>I would like to thank some key members of the team for discussions
(erynian, mahé, Lo and pappy), proofreading (Francisco), and last but
not least, pappy for pushing me beyond my comfort zone and helping me to
grow.</p>
</div>


</div><!-- /.entry-content -->

                </article>
                </section>
        </div><!--/span-->

      </div></div>
  </body>
</html>
