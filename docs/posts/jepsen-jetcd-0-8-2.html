<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jepsen.io/analyses/jetcd-0.8.2">Original</a>
    <h1>Jepsen: Jetcd 0.8.2</h1>
    
    <div id="readability-page-1" class="page"><p><a href="https://github.com/etcd-io/jetcd">Jetcd</a> is the official Java client library for the <a href="https://etcd.io">etcd</a> coordination service. We show that jetcd contains an improper retry mechanism which allows transactions to execute multiple times, or to appear to fail but actually succeed. To users, these behaviors may appear as lost update, circular information flow, and aborted read. These issues have been outstanding for three and a half years. No patch is available, but disabling the retry mechanism is straightforward. This work was performed independently by Jepsen without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</p><article>
  <div>

<p><a href="https://etcd.io">Etcd</a> is a coordination service designed to offer <a href="https://jepsen.io/consistency/models/strict-serializable">Strict Serializable</a> reads, writes, and micro-transactions over a small, in-memory key-value store. In 2022, Jepsen re-tested etcd as a part of a private engagement covering an assortment of databases. We reported several issues to the etcd team during that engagement. Some of those issues remained unresolved, and the etcd team periodically speculated as to possible causes, asking for Jepsen’s assistance.</p>
<p>In July 2024, Jepsen performed an independent investigation<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> to identify the cause of some of these issues, and traced them to a bug in <a href="https://github.com/etcd-io/jetcd">jetcd</a>, the official etcd client library for the Java programming language. In short: jetcd incorrectly retries non-idempotent requests which may have actually succeeded, leading to a variety of serious invariant violations. We present those behaviors here.</p>

<p>We expanded upon the <a href="https://jepsen.io/analyses/etcd-3.4.3#test-design">test harness</a> written for etcd 3.4.3 in 2020. Our <a href="https://github.com/jepsen-io/etcd/tree/fbe693e00ada458c292d58c3a81d2a28834f62b1">workloads and faults</a> were essentially unchanged from that analysis. We focused on the list-append and wr-register workloads, which consist respectively of transactions reading and appending unique values to lists of integers, and transactions which read and write integer registers. Our sole fault was process crashes, induced by <code>kill -9</code>.</p>
<p>This work focused on the jetcd client library, not etcd itself. We evaluated jetcd 0.5.0, 0.6.0, and 0.8.2. Jepsen provides built-in support for <a href="https://github.com/jepsen-io/jepsen/blob/20924ace7b125256599a7d49a8a75296b40bcca3/jepsen/src/jepsen/db.clj#L88-L99">capturing packets from database nodes</a> using <code>tcpdump</code>. We used <a href="https://www.wireshark.org/">Wireshark</a>, a network protocol analyzer, to trace exactly what messages the client sent over the wire. Wireshark includes HTTP2 and Protocol Buffer analyzers which understand etcd’s wire protocol. The Protocol Buffers specification files are <a href="https://github.com/etcd-io/etcd/tree/4488f2c9b6aa4f3f97cd231f3378e53f777d3212/api">available from etcd</a>.</p>

<p>When an application makes a single call to (e.g.) <code>Txn.commit()</code>, jetcd may <a href="https://github.com/etcd-io/jetcd/blob/639bb27d21faf02727575a949df7c4d843dbba46/jetcd-core/src/main/java/io/etcd/jetcd/support/Errors.java#L29-L32">automatically retry</a>, sending multiple copies of the network request. This is fine when the client can prove the first request could never execute, or that the request is idempotent. However, jetcd retries requests in unsafe contexts, like non-idempotent transactions which <em>have</em> been sent over the wire. This manifests as several kinds of safety violations when processes crash or the network loses messages.</p>
<h2 data-number="3.1" id="lost-update"> Lost Update</h2>
<p>Consider this <a href="https://s3.amazonaws.com/jepsen.io/analyses/jetcd-0.8.2/wr-retry-lost-update.zip">this wr-register test run</a>, which contains the following three transactions executed around the time one of the etcd servers crashed. First, transaction <span><em>T</em><sub>0</sub></span> set key <code>3731</code> to <code>11</code>. Then transactions <span><em>T</em><sub>1</sub></span> and <span><em>T</em><sub>2</sub></span> both read value <code>11</code>, and overwrote it with values <code>20</code> and <code>17</code>, respectively:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>T0: [[<span>:w</span> <span>3731</span> <span>11</span>] [<span>:w</span> <span>3732</span> <span>17</span>]]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>T1: [[<span>:r</span> <span>3731</span> <span>11</span>] [<span>:w</span> <span>3731</span> <span>20</span>] [<span>:w</span> <span>3733</span> <span>5</span>]]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>T2: [[<span>:r</span> <span>3731</span> <span>11</span>] [<span>:w</span> <span>3731</span> <span>17</span>] [<span>:r</span> <span>3732</span> <span>19</span>]]</span></code></pre></div>
<p>Writes in this workload are always unique: no other transaction wrote <code>11</code> to key <code>3731</code>. From the client’s perspective, this behavior is indistinguishable from <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">lost update</a>:<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> <span><em>T</em><sub>1</sub></span> and <span><em>T</em><sub>2</sub></span> both read the version of key <code>3731</code> that <span><em>T</em><sub>0</sub></span> wrote, and overwrote it. Since neither observed the other’s write, one of their updates has effectively been silently discarded.</p>
<p>Packet capture reveals that <span><em>T</em><sub>0</sub></span>’s single call to <code>Txn.commit()</code> caused two separate network requests: one 29.10 seconds into the test, and a second at 31.94 seconds. The client submitted these on separate TCP connections, and constructed different HTTP2 headers for them, but their payloads were identical. Each set key <code>3731</code>’s value to <code>11</code> (and key <code>3732</code>’s value to <code>17</code>).</p>
<p>Because jetcd secretly submitted <span><em>T</em><sub>0</sub></span> twice, transactions <span><em>T</em><sub>1</sub></span> and <span><em>T</em><sub>2</sub></span> actually interacted with two different versions of key <code>3731</code>. The first copy of <span><em>T</em><sub>0</sub></span> produced version 6 of key <code>3731</code> at revision 54505. Transaction <span><em>T</em><sub>1</sub></span> read and overwrote that version at revision 54507. Two seconds later jetcd submitted a second copy of <span><em>T</em><sub>0</sub></span>, which blindly overwrote key <code>3731</code> with value <code>11</code> again—this time producing version 19, at revision 55104. Then <span><em>T</em><sub>2</sub></span> read and overwrote this second version of value <code>11</code> with value <code>17</code>.</p>
<p>Lost update is prohibited by Read Committed, Snapshot Isolation, and Serializable. It should not happen in etcd, which is intended to offer at least Serializable consistency.</p>
<h2 data-number="3.2" id="circular-information-flow"> Circular Information Flow</h2>
<p>Client retries can also cause circular information flow. Take for example <a href="https://s3.amazonaws.com/jepsen.io/analyses/jetcd-0.8.2/retry-g1c.zip">this wr-register run</a>, which contains the following cycle:</p>

<p>Each of these transactions appears to read the other’s writes. The top set key <code>3115</code> to <code>11</code>, which was read by the middle transaction. That transaction set key <code>3114</code> to <code>9</code>, which wass read by the bottom transaction. The bottom transaction set key <code>3107</code> to <code>28</code>, which was read by the top transaction. This is <a href="https://pmg.csail.mit.edu/papers/icde00.pdf">Adya’s G1c</a>: circular information flow. G1c should be impossible in any Read Committed system, not to mention a Serializable one. This too is a serious violation of etcd’s guarantees.</p>
<p>This cycle occured because the client secretly submitted the middle transaction <em>twice</em>. The first execution succeeded, allowing the bottom transaction to observe its effects. However, the client opted to submit it <em>again</em>, three and a half seconds later. This second execution observed the effects of the top transaction, tying the causal loop.</p>
<p>Transactions can even observe their own effects from the future. In <a href="https://s3.amazonaws.com/jepsen.io/analyses/jetcd-0.8.2/retry-retrocausal.zip">this test run</a>, a single transaction observed a write it hadn’t performed yet:</p>

<p>Again, packet capture shows that the client submitted this transaction twice, roughly three seconds apart. It executed both times, and the second execution observed the state from the first.</p>
<h2 data-number="3.3" id="aborted-reads"> Aborted Reads</h2>
<p>One might be inclined to add <a href="https://github.com/etcd-io/etcd/issues/14890#issuecomment-2247177272">guard expressions</a> to prevent transactions from executing more than once. Our list-append workload does just that: it performs a read-only transaction to establish current values, then performs a write transaction which commits only if the versions of any objects read are unchanged. This allows another anomaly: <a href="https://pmg.csail.mit.edu/papers/icde00.pdf">aborted read</a>. For example, <a href="https://s3.amazonaws.com/jepsen.io/analyses/jetcd-0.8.2/retry-g1a.zip">this list-append runs</a> contains dozens of transactions like these:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>T0: [[<span>:r</span> <span>4511</span> <span>nil</span>] [<span>:append</span> <span>4513</span> <span>13</span>] ...]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>T1: [[<span>:r</span> <span>4513</span> [<span>3</span> <span>5</span> <span>9</span> <span>13</span>]]]</span></code></pre></div>
<p>Transaction <span><em>T</em><sub>0</sub></span> aborted: its append of <code>13</code> should never have been visible to anyone. However, <span><em>T</em><sub>1</sub></span> committed and observed value <code>13</code>. Since writes are unique, <span><em>T</em><sub>1</sub></span> must have observed the specific version of key <code>4513</code> written by <span><em>T</em><sub>0</sub></span>: an aborted read.</p>
<p>The values returned from <span><em>T</em><sub>0</sub></span>’s call to <code>Txn.commit()</code> indicate that its write transaction executed at revision 38343, and definitively failed: jetcd’s <code>TxnResponse.isSucceeded()</code> returned <code>false</code>. But this cannot be the whole story, because <span><em>T</em><sub>1</sub></span> ostensibly executed earlier, at revision 34777, and observed key <code>4513</code>’s value as <code>[3 5 9 13]</code>. How is this possible? Because jetcd secretly issued <span><em>T</em><sub>0</sub></span> twice. The client did not receive an acknowledgement from the first attempt, and the second returned a failure. Jetcd returned that failure to the caller—unsafely representing an indefinite failure as if it were definite.</p>
<p>Aborted reads are prohibited under a broad range of consistency models from Read Committed to Strict Serializable; this behavior is a serious violation of etcd’s intended guarantees.</p>

<p>These problems affect jetcd 0.6.0 (released 2021-12-15) through 0.8.2 (the most recent version, released 2024-05-30). Users of these versions may observe apparent instances of aborted read, circular information flow, lost update, and other anomalies when processes crash or the network loses messages. Transactions may appear to fail but actually succeed. Transactions may be applied multiple times. Relying on <a href="https://github.com/etcd-io/etcd/issues/14890#issuecomment-2247177272">conditional writes</a> is not sufficient to obtain Serializability: aborted read occurs even when every write is guarded by a version check. These behaviors are not difficult to observe: we can reliably reproduce them in under a minute.</p>
<p>Jepsen reported these problems to both etcd and jetcd in 2022: <a href="https://github.com/etcd-io/jetcd/issues/1072">jetcd-1072</a>, <a href="https://github.com/etcd-io/etcd/issues/14092">etcd-14092</a>, and <a href="https://github.com/etcd-io/etcd/issues/14890">etcd-14890</a>. The etcd maintainers suggested a number of possible explanations, including that these were not actually anomalies, that they represented a bug in Jepsen, or that they were caused by a bug in jetcd. No one followed up on the jetcd issue, and it was automatically closed as stale.</p>
<p>As always, we caution that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove jetcd’s correctness</p>
<h2 data-number="4.1" id="recommendations"> Recommendations</h2>
<p>One can disable jetcd’s retry mechanism by creating clients with <code>ClientBuilder.retryMaxAttempts(0)</code>. This appears to resolve the issues discussed in this report. We recommend jetcd users disable retries until a patch is available and tested.</p>
<p>Unsafe retries are a recurring cause of safety errors. For instance, TiDB 2.1.7 <a href="https://jepsen.io/analyses/tidb-2.1.7">exhibited read skew and lost update</a> thanks to an automatic retry mechanism. MongoDB 4.2.6’s retry system <a href="https://jepsen.io/analyses/mongodb-4.2.6">allowed retrocausal transactions</a> which read their own future effects. Retrying is safe when a client can prove that the operation cannot have taken place (e.g. because DNS resolution failed or the node receiving the message refused to execute it). It is also safe when the operation is idempotent (e.g. adding an element to a grow-only set, or committing only if a unique ID for that operation has not already been applied). For this reason, distributed systems engineers should take particular care to separate <em>definite</em> failures (operations which definitely did not happen) from <em>indefinite</em> failures (operations which may or may not have happened). Engineers should also be careful when classifying operations as idempotent. It is easy to assume that <code>set(x, 5)</code> is idempotent because applying it twice in a row still produces the state <code>x = 5</code>. However, this operation is not longer idempotent if its executions are interleaved with other writes—then, it leads to lost update.</p>
<p>In general, clients are a part of distributed systems. From the perspective of an application, the client and servers together <em>are</em> the system. Safety errors in the client library can be indistinguishable from those in servers. It is therefore especially important that distributed systems maintainers test and resolve issues in not only servers but clients as well.</p>
<p>Since jetcd is “<a href="https://github.com/etcd-io/jetcd">the official [J]ava client for etcd v3</a>”, it is particularly worrying that it has contained a serious safety bug for three and a half years, and that these issues went unresolved for so long. We recommend that the etcd and jetcd teams find a way to jointly investigate and resolve critical safety issues in official client libraries.</p>
<h2 data-number="4.2" id="future-work"> Future Work</h2>
<p>This analysis focuses on jetcd, rather than etcd itself. Other issues in etcd may remain. For example, etcd currently experiences a broad array of crashes when nodes encounter filesystem corruption or the loss of un-fsynced writes. Further research on etcd safety would likely prove fruitful.</p>
<p><em>Jepsen wishes to thank C Scotta Andreas, Tim Kordas, Ben Linsay, Nathan Taylor, and James Turnbull for their review of early drafts. This work was performed independently by Jepsen without compensation, and conducted in accordance with the <a href="https://jepsen.io/analyses/ethics">Jepsen ethics policy</a>.</em></p>

  </div>
</article></div>
  </body>
</html>
