<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/carlosefr/spinner-mouse">Original</a>
    <h1>Spinner-mouse: Arduino-based USB rotary controller for Arkanoid, Tempest, etc.</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">If you ever tried to play the arcade version of <a href="https://en.wikipedia.org/wiki/Arkanoid" rel="nofollow">Arkanoid</a> on an emulator, you may have found the game impossibly hard. And by that I mean <em>impossible</em>. That&#39;s because the game was designed to be played with a rotary controller (called a &#34;spinner&#34; or &#34;dial&#34;), not a joystick. With a spinner, you&#39;re directly moving the paddle – spaceship – not pushing it.</p>
<p dir="auto">In most arcade emulators – <a href="https://github.com/libretro/fbneo">lr-fbneo</a> and <a href="https://github.com/libretro/mame2003-plus-libretro">lr-mame2003-plus</a> are my current choices – you can use a mouse instead. As the MS-DOS version of Arkanoid could also be played with a mouse, that makes it a perfectly cromulent thing to do. But a mouse forces you to play sitting at a desk, which I&#39;d rather avoid.</p>
<p dir="auto">The <a href="https://en.wikipedia.org/wiki/Nintendo_Entertainment_System" rel="nofollow">NES</a> version of Arkanoid shipped with <a href="https://www.nesdev.org/wiki/Arkanoid_controller" rel="nofollow">its own spinner controller</a> commonly called the &#34;Vaus&#34; controller, and its simple (and cheap) design inspired me to build my own version that presents itself as an USB mouse – something that any Arduino-like board based on the <a href="https://www.microchip.com/en-us/product/atmega32u4" rel="nofollow">ATmega32U4</a> microcontroller <a href="https://www.arduino.cc/reference/en/language/functions/usb/mouse/" rel="nofollow">can easily do</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/pictures/controller.jpg"><img src="https://lippingoff.netlify.app/carlosefr/spinner-mouse/raw/main/pictures/controller.jpg" title="The spinner controller, front view (left) and inside view (right)." width="600"/></a></p>
<p dir="auto">And if I could use it to play some other <a href="https://wiki.arcadecontrols.com/index.php/Spinner_Turn_Count" rel="nofollow">spinner-based games</a>, the better. So I added an extra button, and the option to connect a pedal that I had lying around from my MIDI keyboard (for up to three buttons total).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/pictures/controller_with_pedal.jpg"><img src="https://lippingoff.netlify.app/carlosefr/spinner-mouse/raw/main/pictures/controller_with_pedal.jpg" title="The spinner controller with an M-Audio SP-1 pedal connected to it." width="600"/></a></p>


<p dir="auto">The main input is a smooth <strong>incremental rotary encoder</strong> commonly used for volume control in audio amplifiers. It costs a fraction of the kind of encoders arcade cabinet enthusiasts would use, which made me fear it might not have enough resolution, but it turned out just fine. This <a href="https://eu.mouser.com/datasheet/2/54/pec16-245034.pdf" rel="nofollow">specific encoder</a> has two pulse pins with 24 steps per turn for a final resolution of 96 steps with <a href="https://en.wikipedia.org/wiki/Incremental_encoder" rel="nofollow">quadrature encoding</a>.</p>
<p dir="auto">The <strong>primary button</strong> (yellow) is an arcade-style microswitch and the <strong>secondary button</strong> (red) is a generic doorbell push-button. Both are wired to connect to ground when pressed (active-low), in order to use the ATmega&#39;s internal pull-up resistors and minimize the number of external components, and are debounced in hardware using 100nF capacitors across their pins, to minimize code complexity.</p>
<p dir="auto">The (optional) <strong>pedal</strong> is of the type commonly used as a sustain pedal with music keyboards. Internally, it&#39;s just a spring-loaded push-button configured in either a normally-open or normally-closed way. It connects using an <strong>audio jack</strong> which includes a normally-closed sense switch that opens on insertion. As before, both of these switches use the ATmega&#39;s internal pull-up resistors and get debounced using 100nF capacitors.</p>
<p dir="auto">An external (blue) <strong>LED</strong> provides some minimal feedback about the controller&#39;s operation. As blue LEDs are usually pretty powerful, and harsh, sources of light, it is dimmed to a reasonable level using PWM.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/pictures/circuits.png"><img src="https://lippingoff.netlify.app/carlosefr/spinner-mouse/raw/main/pictures/circuits.png" title="The different types of circuits used, for button inputs and the LED output." width="600"/></a></p>

<p dir="auto">Having the mouse move one pixel for each encoder pulse is generally too slow, so there&#39;s a <strong>multi-turn potentiometer</strong> to adjust the speed without having to reflash the firmware. There&#39;s also a <strong>2-way DIP-switch</strong> block to disable mouse events while testing, and switch between X-axis and Y-axis motion. Both of these adjustments can be done through holes drilled in the back of the case. I didn&#39;t bother adding debouncing capacitors for these switches.</p>


<p dir="auto">By default, the primary button maps to the <strong>left mouse button</strong>, while the secondary button maps to the <strong>right mouse button</strong>. When a pedal is connected, mappings are shifted so the pedal becomes the left mouse button, the primary button becomes the right mouse button, and the secondary button becomes the <strong>middle mouse button</strong>.</p>
<p dir="auto">The firmware can handle the pedal being connected/disconnected at any time. It also autodetects if the pedal switch is normally-closed or normally-open (the pedal I have can be configured either way).</p>

<p dir="auto">By default the rotary input moves the mouse pointer as fast as configured using the internal multi-turn potentiometer – from 1 to 50 steps at a time. If the primary button is kept pressed when connecting the controller, it enters <strong>slow mode</strong> and will always move at 20% of the configured speed. This is useful for emulators such as MAME that have their own sensitivity adjustments.</p>
<p dir="auto">You may be wondering why slow mode is 20% of the configured speed and not the maximum precision of 96 steps per turn (1 mouse step per encoder pulse): it allows for better use of MAME&#39;s dial sensitivity range, which only goes up to 255%.</p>

<p dir="auto">Besides providing some debug output when buttons are pressed and so on, it&#39;s also possible to switch controller modes by writing to the serial port. Specifically:</p>
<ul dir="auto">
<li><code>s</code> switches to slow mode;</li>
<li><code>n</code> switches to normal mode (whatever&#39;s set through the multi-turn potentiometer);</li>
<li><code>r</code> switches to the default mode (slow/normal depending on whether the primary button was kept pressed at connect time);</li>
<li><code>c</code> shows the current mode.</li>
</ul>
<p dir="auto">See the <code>retropie</code> directory in this repo for the <a href="https://retropie.org.uk/docs/Runcommand/#runcommand-scripts" rel="nofollow">runcommand scripts</a> that I&#39;m using with <a href="https://retropie.org.uk" rel="nofollow">RetroPie</a> to dynamically switch modes depending on the emulator being started.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Sensitivity Settings (in Emulators)</h3><a id="user-content-sensitivity-settings-in-emulators" aria-label="Permalink: Sensitivity Settings (in Emulators)" href="#sensitivity-settings-in-emulators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In my case I have the multi-turn potentiometer set for a speed of 22 by default, which I find confortable for Arkanoid running under <a href="https://github.com/libretro/fbneo">lr-fbneo</a>. I prefer to run other games under <a href="https://github.com/libretro/mame2003-plus-libretro">lr-mame2003-plus</a> to be able to adjust the sensitivity (the controller must be in slow mode for best results, see above).</p>
<p dir="auto">As different games used spinners with <a href="https://wiki.arcadecontrols.com/index.php/Spinner_Turn_Count" rel="nofollow">different resolutions</a>, the specific sensitivity settings for each game will also be different. Even games where the original spinner had a much higher resolution seem to work fine (e.g. Arkanoid&#39;s spinner had a resolution of 486 steps per turn).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/pictures/mame_analog_controls.png"><img src="https://lippingoff.netlify.app/carlosefr/spinner-mouse/raw/main/pictures/mame_analog_controls.png" title="MAME&#39;s analog controls menu." width="450"/></a></p>

<p dir="auto">The following two lists include the components that I used for my build, with links to the specific parts I bought. Since I ordered most of them from a nearby portuguese store, most of the linked pages are in portuguese, but should still be useful to figure out what to buy elsewhere if you wish to build your own.</p>
<p dir="auto">The first list is the minimum needed to support games that only use one button (e.g. <a href="https://en.wikipedia.org/wiki/Arkanoid" rel="nofollow">Arkanoid</a>, <a href="https://en.wikipedia.org/wiki/Super_Sprint" rel="nofollow">Super Sprint/Championship Sprint</a>, <a href="https://en.wikipedia.org/wiki/Hot_Rod_(video_game)" rel="nofollow">Hot Rod</a>) as well as games that use two buttons (e.g. <a href="https://en.wikipedia.org/wiki/Tempest_(video_game)" rel="nofollow">Tempest</a>, <a href="https://en.wikipedia.org/wiki/Badlands_(1989_video_game)" rel="nofollow">Badlands</a>). That should cover most cases.</p>
<p dir="auto">If you&#39;d rather use a pedal on racing games, or play a game that needs the third button (e.g. <a href="https://en.wikipedia.org/wiki/APB_(1987_video_game)" rel="nofollow">APB</a>), then you&#39;ll also need the additional components in the second list.</p>
<ul dir="auto">
<li>1x <a href="https://www.amazon.es/dp/B0CNR1X3YY" rel="nofollow">ATmega32U4 USB-C module</a> (5V/16MHz)</li>
<li>1x <a href="https://www.amazon.es/dp/B0BC8Y3BM2" rel="nofollow">right-angle USB-C to USB-A cable</a></li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=010-0452" rel="nofollow">incremental rotary encoder</a> (24 pulse / 360°, smooth rotation) + <a href="https://mauser.pt/catalog/product_info.php?products_id=010-1271" rel="nofollow">knob</a> (31x17mm)</li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=010-1065" rel="nofollow">arcade push-button</a> (32x30mm, microswitch)</li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=010-0586" rel="nofollow">small push-button</a> (12.7mm, SPST-NO)</li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=010-1162" rel="nofollow">miniature push-button</a> (6mm, SPST-NO, through-hole)</li>
<li>1x 3.5mm LED</li>
<li>1x 1KΩ resistor (to current-limit the LED)</li>
<li>2x 10nF poliester capacitor (to debounce the rotary encoder pulse pins)</li>
<li>2x 100nF poliester capacitor (to debounce the arcade and small push-buttons)</li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=005-4003" rel="nofollow">10KΩ multi-turn potentiometer</a></li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=010-0138" rel="nofollow">2-way DIP-switch</a></li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=096-3386" rel="nofollow">prototyping circuit board</a> (72x47mm, perforated)</li>
<li>1x <a href="https://www.retex.es/en/product/betabox/" rel="nofollow">project case</a> (145x80x34mm, ABS plastic)</li>
</ul>
<p dir="auto">The miniature push-button is not needed if you choose another ATmega32U4-based module board with a built-in reset switch.</p>
<ul dir="auto">
<li>1x <a href="https://m-audio.com/products/view/sp-1" rel="nofollow">music keyboard sustain pedal</a> (momentary switch)</li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=019-0790" rel="nofollow">male 3.5mm to female 6.3mm jack adapter cable</a></li>
<li>1x <a href="https://mauser.pt/catalog/product_info.php?products_id=011-1072" rel="nofollow">female 3.5mm jack with sense switch</a> (mono, panel-mount)</li>
<li>2x 100nF poliester capacitor (to debounce the pedal and jack sense switch)</li>
</ul>

<p dir="auto">The artwork was printed with a normal inkjet printer on matte photographic paper. It looks pretty good up close and, so far, seems durable enough. The <a href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/artwork/cover.pxd">source file</a> is in <a href="https://www.pixelmator.com/pro/" rel="nofollow">Pixelmator Pro</a> format.</p>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://lippingoff.netlify.app/carlosefr/spinner-mouse/blob/main/pictures/controller_in_use.jpg"><img src="https://lippingoff.netlify.app/carlosefr/spinner-mouse/raw/main/pictures/controller_in_use.jpg" title="The spinner controller in use with Arkanoid (center) and Tempest (right)." width="700"/></a></p>
<p dir="auto">Having an adequate game controller can be crucial for these old games – it can be the difference between frustration and fun.</p>
<p dir="auto">At first I built this controller just for Arkanoid, until I figured that I could use another button for the &#34;superzapper&#34; in <a href="https://en.wikipedia.org/wiki/Tempest_(video_game)" rel="nofollow">Tempest</a>. The pedal was added because driving, accelerating, and using the siren in <a href="https://en.wikipedia.org/wiki/APB_(1987_video_game)" rel="nofollow">APB</a> felt awkward. Shifting the accelerator away from my hands was enough to make that game fun for me (abeit still hard).</p>
<p dir="auto"><em>-- Carlos Rodrigues, 2024</em></p>
</article></div></div>
  </body>
</html>
