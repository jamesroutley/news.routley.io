<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.regehr.org/archives/1307">Original</a>
    <h1>The Strict Aliasing Situation Is Pretty Bad (2016)</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ll start with a quick review of the strict aliasing rules in C and C++ and then present some less well-known material.</p>
<h2>Strict Aliasing</h2>
<p>Compiler optimizations are often shot down by the potential for pointers to be aliases. For example, although we might naively expect a compiler to optimize this function to return zero, that cannot happen because x and y might refer to the same location:</p>
<SPAN size="-1">
<pre title="">int foo(int *x, int *y) {
  *x = 0;
  *y = 1;
  return *x;
}
</pre>
</SPAN>
<p>Generated code typically looks like this:</p>
<pre>foo:    movl    $0, (%rdi)
        movl    $1, (%rsi)
        movl    (%rdi), %eax
        ret
</pre>
<p>Failure to optimize is particularly frustrating when we know for sure that x and y are not aliases. The “restrict” keyword in C was introduced to help solve this sort of problem but we’re not going to talk about that today. Rather, we’re going to talk about an orthogonal solution, the aliasing rules in C and C++ that permit the compiler to assume that an object will not be aliased by a pointer to a different type. Often this is called “strict aliasing” although that term does not appear in the standards. Consider, for example, this variant of the program above:</p>
<SPAN size="-1">
<pre title="">int foo(int *x, long *y) {
  *x = 0;
  *y = 1;
  return *x;
}
</pre>
</SPAN>
<p>Since a pointer-to-int and a pointer-to-long may be assumed to not alias each other, the function can be compiled to return zero:</p>
<pre>foo2:   movl    $0, (%rdi)
        xorl    %eax, %eax
        movq    $1, (%rsi)
        ret
</pre>
<p>As we see here, the aliasing rules give C and C++ compilers leverage that they can use to generate better code. On the other hand, since C is a low-level language and C++ can be used as a low-level language, both permit casting between pointer types, which can end up creating aliases that violate the compiler’s assumptions. For example, we might naively write code like this to access the representation of a floating point value:</p>
<SPAN size="-1">
<pre title="">unsigned long bogus_conversion(double d) {
  unsigned long *lp = (unsigned long *)&amp;d;
  return *lp;
}
</pre>
</SPAN>
<p>This function is undefined under the aliasing rules and while it happens to be <a href="https://goo.gl/a6M2NV">compiled into the same code that would be emitted without the strict aliasing rules</a>, it is easy to write incorrect code that looks like it is getting broken by the optimizer:</p>
<SPAN size="-1">
<pre title="">#include &lt;stdio.h&gt;

long foo(int *x, long *y) {
  *x = 0;
  *y = 1;
  return *x;
}

int main(void) {
  long l;
  printf(&#34;%ld\n&#34;, foo((int *)&amp;l, &amp;l));
}
</pre>
</SPAN>
<pre>$ gcc-5 strict.c ; ./a.out
1
$ gcc-5 -O2 strict.c ; ./a.out
0
$ clang strict.c ; ./a.out
1
$ clang -O2 strict.c ; ./a.out
0
</pre>
<p>An exception to the strict aliasing rules is made for pointers to character types, so it is always OK to inspect an object’s representation via an array of chars. This is necessary to make memcpy-like functions work properly.</p>
<p>So far, this is very well known. Now let’s look at a few consequences of strict aliasing that are perhaps not as widely known.</p>
<h2>Physical Subtyping is Broken</h2>
<p>An <a href="http://research.cs.wisc.edu/wpis/papers/fse99.pdf">old paper that I like</a> uses the term “physical subtyping” to refer to the struct-based implementation of inheritance in C. Searching for “<a href="https://www.google.com/search?ie=UTF-8&amp;q=%22object%20oriented%20c%22&amp;oq=%22object%20oriented%20c%22">object oriented C</a>” returns quite a few links. Additionally, many large C systems (the Linux kernel for example) implement OO-like idioms. Any time this kind of code casts between pointer types and dereferences the resulting pointers, it violates the aliasing rules. Many aliasing rule violations can be found in <a href="https://www.cs.rit.edu/~ats/books/ooc.pdf">this book about object oriented C</a>. Some build systems, such as Linux’s, invoke GCC with its -fno-strict-aliasing flag to avoid problems.</p>
<p><b>Update based on some comments from Josh Haberman and Sam Tobin-Hochstadt:</b> It looks like the specific case where the struct representing the derived type includes its parent as its first member should not trigger UB. The language in this part of the standard is very hard to parse out.</p>
<p>This program <a href="https://www.cl.cam.ac.uk/~pes20/cerberus/">from the Cerberus project</a> illustrates the problem with changing the type of a pointer to struct:</p>
<SPAN size="-1">
<pre title="">#include &lt;stdio.h&gt;

typedef struct { int i1; } s1;
typedef struct { int i2; } s2;

void f(s1 *s1p, s2 *s2p) {
  s1p-&gt;i1 = 2;
  s2p-&gt;i2 = 3;
  printf(&#34;%i\n&#34;, s1p-&gt;i1);
}

int main() {
  s1 s = {.i1 = 1};
  f(&amp;s, (s2 *)&amp;s);
}
</pre>
</SPAN>
<pre>$ gcc-5 effective.c ; ./a.out
3
$ gcc-5 -O2 effective.c ; ./a.out
2
$ clang-3.8 effective.c ; ./a.out
3
$ clang-3.8 -O2 effective.c ; ./a.out
3
</pre>
<h2>Chunking Optimizations Are Broken</h2>
<p>Code that processes bytes one at a time tends to be slow. While an optimizing compiler can sometimes make a naive character-processing loop much faster, in practice we often need to help the compiler out by explicitly processing word-sized chunks of bytes at a time. Since the data reinterpretation is generally done by casting to a non-character-typed pointer, the resulting accesses are undefined. Search the web for “fast memcpy” or “fast memset”: many of the hits will return erroneous code. <a href="http://codereview.stackexchange.com/questions/41094/memcpy-implementation">Example 1</a>, <a href="http://www.programering.com/a/MTMxEjMwATM.html">example 2</a>, <a href="http://www.xs-labs.com/en/blog/2013/08/06/optimising-memset/">example 3</a>. Although I have no evidence that it is being miscompiled, <a href="https://github.com/openssl/openssl/blob/master/crypto/aes/aes_ige.c#L69">OpenSSL’s AES implementation uses chunking</a> and is undefined.</p>
<p>One way to get chunking optimizations without UB is to use GCC’s may_alias attribute, as <a href="http://git.musl-libc.org/cgit/musl/tree/src/string/memset.c#n33">seen here in Musl</a>. This isn’t supported even by Clang, as far as I know.</p>
<h2>Offset Overlap is Bad</h2>
<p>Here is a devilish little program <a href="https://gcc.gnu.org/ml/gcc/2015-03/msg00083.html">by Richard Biener and Robbert Krebbers</a> that I found via the Cerberus report:</p>
<SPAN size="-1">
<pre title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct X {
  int i;
  int j;
};

int foo(struct X *p, struct X *q) {
  q-&gt;j = 1;
  p-&gt;i = 0;
  return q-&gt;j;
}

int main() {
  unsigned char *p = malloc(3 * sizeof(int));
  printf(&#34;%i\n&#34;, foo((struct X *)(p + sizeof(int)),
                     (struct X *)p));
}
</pre>
</SPAN>
<p>It is ill-formed according to LLVM and GCC:</p>
<pre>$ clang-3.8 krebbers.c ; ./a.out
0
$ clang-3.8 -O2 krebbers.c ; ./a.out
1
$ gcc-5 krebbers.c ; ./a.out
0
$ gcc-5 -O2 krebbers.c ; ./a.out
1
</pre>
<h2>int8_t and uint8_t Are Not Necessarily Character Types</h2>
<p><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66110">This bug</a> (and some linked discussions) indicate that compiler developers don’t necessarily consider int8_t and uint8_t to be character types for aliasing purposes. Wholesale replacement of character types with standard integer types — <a href="https://matt.sh/howto-c">as advocated here</a>, for example — would almost certainly lead to interesting strict aliasing violations when the resulting code was run through a compiler that doesn’t think int8_t and uint8_t are character types. Happily, no compiler has done this yet (that I know of).</p>
<h2>Summary</h2>
<p>A lot of C code is broken under strict aliasing. Separate compilation is probably what protects us from broader compiler exploitation of the brokenness, but it is a very poor kind of protection. Static and dynamic checking tools are needed. If I were writing correctness-oriented C that relied on these casts I wouldn’t even consider building it without -fno-strict-aliasing.</p>
<p>Pascal Cuoq provided feedback on a draft of this piece.</p>
</div></div>
  </body>
</html>
