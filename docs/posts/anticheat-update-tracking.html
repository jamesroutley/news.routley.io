<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://not-matthias.github.io/posts/anticheat-update-tracking/">Original</a>
    <h1>Anticheat Update Tracking</h1>
    
    <div id="readability-page-1" class="page"><section><p>A few years ago when I was into reverse engineering and binary analysis (and game modding), I did a lot of research into anticheats work. I was curious about tracking their updates, since that would allow me to:</p><ul><li>Know when a new version is released</li><li>Understand what changes were made</li><li>Use older versions for research purposes</li></ul><p>So I ended up researching different ways on how to track updates of various anticheats. Some of them are already very well documented, while others haven&#39;t been explored much. This post will summarize my findings and outline how they work.</p><p>EasyAntiCheat is widely recognized as one of the most advanced anticheats, and is used in many popular games like Rust, Fortnite, Apex Legends, and more.</p><p>Prior to the acquisition by Epic Games, EAC was using their own CDN to distribute updates: <code>https://download.eac-cdn.com/api/v1/games/{game_id}/client/{system}/download/?uuid=1239688</code>.</p><ul><li><code>game_id</code>: unique identifier for each game (e.g. 154 for Apex Legends)</li><li><code>system</code>: target platform/system (e.g. <code>wow64_win64</code>, <code>mac64</code>, <code>linux32_64</code>).</li></ul><p>After the acquisition, they switched to the EpicGames CDN, which has a slightly different URL structure: <code>https://modules-cdn.eac-prod.on.epicgames.com/modules/{product_id}/{deployment_id}/{system}</code>. The parameters to this URL are completely different:</p><ul><li><code>product_id</code>: unique identifier for each game (e.g. <code>429c2212ad284866aee071454c2125b5</code> for Rust)</li><li><code>deployment_id</code>: unique identifier for each deployment (e.g. <code>76796531e86443548754600511f42e9e</code> for Rust). This doesn&#39;t change when an update is released and is used to identify different game versions.</li><li><code>system</code>: same as in the old CDN</li></ul><p>After downloading the module for a game, we&#39;ll have a file which contains data with a very high entropy which is the first indication that it is encrypted or compressed:</p><pre><code><span>$ bat encrypted.bin | ent
</span><span>Entropy = 7.989390 bits per byte.
</span></code></pre><p>Looking at the data, we also can&#39;t really identify any patterns or strings. However, across versions the header seems to always stay the same (<code>a7 ed</code>): Very interesting ğŸ¤”</p><pre><code><span>$ hexyl encrypted.bin | head
</span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
</span><span>â”‚00000000â”‚ a7 ed 96 0c 0f 0f 12 19 â”Š 1c 1b 1e 20 22 26 2a e5 â”‚Ã—Ã—Ã—_â€¢â€¢â€¢â€¢â”Šâ€¢â€¢â€¢ &#34;&amp;*Ã—â”‚
</span><span>â”‚00000010â”‚ e8 33 36 39 3c 3f 42 85 â”Š 88 4b 4e 51 54 57 5a 5d â”‚Ã—369&lt;?BÃ—â”ŠÃ—KNQTWZ]â”‚
</span><span>â”‚00000020â”‚ 60 63 66 69 6c 6f 72 75 â”Š 78 7b 7e 81 84 87 8a 8d â”‚`cfiloruâ”Šx{~Ã—Ã—Ã—Ã—Ã—â”‚
</span><span>â”‚00000030â”‚ 90 93 96 99 9c 9f a2 a5 â”Š a8 ab ae 31 34 b7 ba cb â”‚Ã—Ã—Ã—Ã—Ã—Ã—Ã—Ã—â”ŠÃ—Ã—Ã—14Ã—Ã—Ã—â”‚
</span><span>â”‚00000040â”‚ ed 9c 8e d7 80 8c a8 c3 â”Š b1 94 2b fa d2 5c a6 be â”‚Ã—Ã—Ã—Ã—Ã—Ã—Ã—Ã—â”ŠÃ—Ã—+Ã—Ã—\Ã—Ã—â”‚
</span><span>â”‚00000050â”‚ cc 86 86 db dd d5 db d8 â”Š d6 98 91 d5 e3 f3 f7 00 â”‚Ã—Ã—Ã—Ã—Ã—Ã—Ã—Ã—â”ŠÃ—Ã—Ã—Ã—Ã—Ã—Ã—â‹„â”‚
</span><span>â”‚00000060â”‚ b4 a5 ed ae be 16 15 c3 â”Š c1 12 cc a5 d7 e9 bd da â”‚Ã—Ã—Ã—Ã—Ã—â€¢â€¢Ã—â”ŠÃ—â€¢Ã—Ã—Ã—Ã—Ã—Ã—â”‚
</span><span>â”‚00000070â”‚ 2c 26 1f ec 97 79 79 93 â”Š 8c 6b 6e 71 74 77 7a cd â”‚,&amp;â€¢Ã—Ã—yyÃ—â”ŠÃ—knqtwzÃ—â”‚
</span><span>â”‚00000080â”‚ 15 c8 86 d5 d9 93 95 c9 â”Š 4d 6e 58 09 a4 a7 aa ad â”‚â€¢Ã—Ã—Ã—Ã—Ã—Ã—Ã—â”ŠMnX_Ã—Ã—Ã—Ã—â”‚
</span></code></pre><p>A few years ago, I spent a <del>night</del> early morning with a friend to find the decryption algorithm. We searched for anything that closely resembled such an algorithm, eventually found it, made a quick POC and got it working ğŸ”¥. Here&#39;s what the code looks like:</p><pre data-lang="cpp"><code data-lang="cpp"><span><span>void</span> <span><span><span>decode</span></span></span><span><span><span>(</span></span></span><span><span><span>char</span> <span>*</span><span>memory_block</span><span>,</span> <span>int</span> <span>total_size</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
</span></span></span><span><span><span>    <span>char</span><span>*</span> buffer <span>=</span> <span><span>(</span><span>char</span><span>*</span><span>)</span></span>memory_block<span>;</span>
</span></span></span><span><span><span>    <span>int</span> file_size <span>=</span> total_size<span>;</span>
</span></span></span><span><span><span>    <span>if</span> <span><span>(</span>file_size <span>&gt;=</span> <span>2</span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        buffer<span><span>[</span>file_size <span>-</span> <span>1</span><span>]</span></span> <span>+=</span> <span>3</span> <span>-</span> <span>3</span> <span>*</span> file_size<span>;</span>
</span></span></span></span><span><span><span><span>        <span>int</span> current_index <span>=</span> file_size <span>-</span> <span>2</span><span>;</span>
</span></span></span></span><span><span><span><span>        <span>if</span> <span><span>(</span>file_size <span>!=</span> <span>2</span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>            <span>do</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>                buffer<span><span>[</span>current_index<span>]</span></span> <span>+=</span> <span>-</span><span>3</span> <span>*</span> current_index <span>-</span> buffer<span><span>[</span>current_index <span>+</span> <span>1</span><span>]</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>                <span>--</span>current_index<span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>}</span></span> <span>while</span> <span><span>(</span>current_index<span>)</span></span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>}</span></span>
</span></span></span></span><span><span><span><span>        buffer<span><span>[</span><span>0</span><span>]</span></span> <span>-=</span> buffer<span><span>[</span><span>1</span><span>]</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    <span>}</span></span>
</span></span></span><span><span><span></span></span><span><span><span>}</span></span></span>
</span></code></pre><p>After decrypting the binary blob, we&#39;ll finally have a PE image (<code>EasyAnticheat.packed.dll</code>):</p><pre><code><span>$ hexyl EasyAnticheat.packed.dll | head
</span><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
</span><span>â”‚00000000â”‚ 4d 5a 90 00 03 00 00 00 â”Š 04 00 00 00 ff ff 00 00 â”‚MZÃ—.â€¢...â”Šâ€¢...Ã—Ã—..â”‚
</span><span>â”‚00000010â”‚ b8 00 00 00 00 00 00 00 â”Š 40 00 00 00 00 00 00 00 â”‚Ã—.......â”Š@.......â”‚
</span><span>â”‚00000020â”‚ 00 00 00 00 00 00 00 00 â”Š 00 00 00 00 00 00 00 00 â”‚........â”Š........â”‚
</span><span>â”‚00000030â”‚ 00 00 00 00 00 00 00 00 â”Š 00 00 00 00 80 00 00 00 â”‚........â”Š....Ã—...â”‚
</span><span>â”‚00000040â”‚ 0e 1f ba 0e 00 b4 09 cd â”Š 21 b8 01 4c cd 21 54 68 â”‚â€¢â€¢Ã—â€¢.Ã—_Ã—â”Š!Ã—â€¢LÃ—!Thâ”‚
</span><span>â”‚00000050â”‚ 69 73 20 70 72 6f 67 72 â”Š 61 6d 20 63 61 6e 6e 6f â”‚is progrâ”Šam cannoâ”‚
</span><span>â”‚00000060â”‚ 74 20 62 65 20 72 75 6e â”Š 20 69 6e 20 44 4f 53 20 â”‚t be runâ”Š in DOS â”‚
</span><span>â”‚00000070â”‚ 6d 6f 64 65 2e 0d 0d 0a â”Š 24 00 00 00 00 00 00 00 â”‚mode.___â”Š$.......â”‚
</span><span>â”‚00000080â”‚ 50 45 00 00 4c 01 03 00 â”Š 34 81 52 68 00 00 00 00 â”‚PE..Lâ€¢â€¢.â”Š4Ã—Rh....â”‚
</span></code></pre><p>Unfortunately, we&#39;re not yet done. According to <a href="https://github.com/horsicq/Detect-It-Easy">Detect it Easy</a>, the binary is protected with VMProtect, which means we can&#39;t just read the <code>.text</code> or <code>.data</code> section. However, to further analyze the binary and extract the driver and usermode module we&#39;ll have to find a way to unpack it.</p><img alt="Detect it Easy screenshot" aspect-ratio="1133 / 1133" decoding="async" loading="lazy" src="https://not-matthias.github.io/processed_images/eac_die.37a42aa7b7658bc0.webp"/><p>There are many ways to unpack binaries, with the most popular being <strong>emulation</strong> and <strong>native execution</strong>. Both methods just execute the entrypoint until the sections are unpacked. In our case, the easiest way to unpack the downloaded binary is to load it with <code>LoadLibraryA</code>:</p><pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>windows<span>::</span></span><span><span>{</span>
</span></span><span><span>    <span>core<span>::</span></span><span>PCSTR</span><span>,</span>
</span></span><span><span>    <span>Win32<span>::</span></span><span><span>{</span><span>Foundation<span>::</span></span><span>HINSTANCE</span><span>,</span> <span>System<span>::</span></span><span>LibraryLoader<span>::</span></span>LoadLibraryA</span><span><span>}</span></span><span>,</span>
</span></span><span><span></span><span><span>}</span></span><span>;</span>
</span><span><span>use</span> <span>pelite<span>::</span></span><span>pe32<span>::</span></span>PeView<span>;</span>
</span><span><span>use</span> <span>std<span>::</span></span><span>path<span>::</span></span>PathBuf<span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>  <span>let</span> file <span>=</span> <span>PCSTR</span><span><span>::</span></span>from_raw<span><span>(</span><span><span>&#34;</span>temp.dll<span>\0</span><span>&#34;</span></span><span>.</span><span>as_ptr</span><span><span>(</span></span><span><span>)</span></span> <span>as</span> <span>_</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>  <span>let</span> <span>Ok</span><span><span>(</span>module</span><span><span>)</span></span> <span>=</span> <span>unsafe</span> <span><span>{</span> LoadLibraryA<span><span>(</span>file</span><span><span>)</span></span> </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>    <span>eprintln!</span><span><span>(</span></span><span><span><span>&#34;</span>Failed to load library: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> error<span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    <span>return</span><span>;</span>
</span></span></span></span><span><span><span><span>  </span><span><span>}</span></span><span>;</span>
</span></span></span><span><span><span>  <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Loaded module: {:x?}<span>&#34;</span></span></span><span><span>,</span> module<span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  <span>let</span> pe <span>=</span> <span>unsafe</span> <span><span>{</span> <span>pelite<span>::</span></span><span>PeView<span>::</span></span>module<span><span>(</span>module<span>.</span><span>0</span> <span>as</span> <span>*const</span> <span>u8</span></span><span><span>)</span></span> </span><span><span>}</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre><p>After analyzing this unpacked library, you&#39;ll eventually figure out that the <code>.data</code> section has a high entropy and is quite large. You might even recognize the encrypted PE headers from earlier: <code>a7 ed</code>. This is exactly where the driver and their internal module are stored.</p><p>The embedded files use the same encryption algorithm, so we can search for the encrypted PE header (<code>MZ</code> or <code>0x4D5A</code>). After looking at the data in IDA, I managed to find a pattern which we can use to extract the embedded files. The encrypted modules are always stored in the following order:</p><pre><code><span>&lt;encrypted_module&gt;  (encrypted data)
</span><span>&lt;size&gt;              (padded to 16 bytes)
</span></code></pre><p>This is somewhat equivalent to the following structure, where len always contains the size of the buffer:</p><pre data-lang="rust"><code data-lang="rust"><span><span><span>struct</span> </span><span><span>EncryptedModule</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>buffer</span><span>:</span> [<span>u8</span>],
</span></span></span><span><span><span>    <span>len</span><span>:</span> <span>u64</span>,
</span></span></span><span><span><span>    <span>padding</span><span>:</span> <span>u64</span>    </span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre><p>By knowing that the encrypted module has a high entropy, which means that it&#39;s very unlikely that there will be patterns in the data, we can simply search for at least 8 bytes of zero padding which is always present after the size.</p><pre data-lang="rust"><code data-lang="rust"><span><span>let</span> section <span>=</span> pe<span>.</span><span>section_by_name</span><span><span>(</span><span><span>&#34;</span>.data<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span><span><span>let</span> <span><span>(</span>driver_start<span>,</span> driver_end</span><span><span>)</span></span> <span>=</span> section<span>.</span><span>find_padding_at</span><span><span>(</span><span>0</span></span><span><span>)</span></span><span>;</span>
</span><span><span>let</span> encrypted_driver <span>=</span> section<span><span>[</span>driver_start<span>..</span>driver_end<span>]</span></span><span>;</span>
</span><span><span>let</span> driver_module <span>=</span> <span>decrypt</span><span><span>(</span>encrypted_driver</span><span><span>)</span></span><span>;</span>
</span><span><span>assert_eq!</span><span><span>(</span>driver_module<span><span>[</span><span>..</span><span>2</span><span>]</span></span><span>,</span> <span>&amp;</span><span><span>[</span><span>0x4D</span><span>,</span> <span>0x5A</span><span>]</span></span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span><span>let</span> <span><span>(</span>internal_start<span>,</span> internal_end</span><span><span>)</span></span> <span>=</span> section<span>.</span><span>find_padding_at</span><span><span>(</span>driver_end</span><span><span>)</span></span><span>;</span>
</span><span><span>let</span> encrypted_internal <span>=</span> section<span><span>[</span>internal_start<span>..</span>internal_end<span>]</span></span><span>;</span>
</span><span><span>let</span> internal_module <span>=</span> <span>decrypt</span><span><span>(</span>encrypted_internal</span><span><span>)</span></span><span>;</span>
</span><span><span>assert_eq!</span><span><span>(</span>internal_module<span><span>[</span><span>..</span><span>2</span><span>]</span></span><span>,</span> <span>&amp;</span><span><span>[</span><span>0x4D</span><span>,</span> <span>0x5A</span><span>]</span></span></span><span><span>)</span></span><span>;</span>
</span></code></pre><p>Battleye, another popular anticheat from Germany, is known for its bandaid fixes and <a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/667333-bannleeye-banning-arbitrary-players-using.html">lack of security</a>. They put a lot of focus on detecting popular cheat providers, by detecting them via static signatures. It is used in games like Arma, DayZ, Escape from Tarkov, and most recently Grand Theft Auto V.</p><p>Their CDN seems to be built in-house and follows a very simple structure:</p><ol><li>Fetch the latest version (which is just a unix timestamp like <code>1746714230</code>)</li><li>Download the module using the version number from the actual CDN</li></ol><p>Here are the required URLs:</p><ul><li>Version URL: <code>https://cdn.battleye.com/{game}/ver</code></li><li>Download URL: <code>https://cdn.battleye.com/{game}/{version}</code></li><li>Possible values for the games include: <code>eft</code>, <code>unturned</code>, <code>ark</code>, <code>r6s/win-x64</code>, <code>dayz/win-x64</code>.</li></ul><p>The downloaded binary contains other bytes before the actual module, which have to be filtered out. The easiest way to do it is to search for the PE header and delete everything before. In this case, the PE module is located at offset 0x200:</p><pre><code><span>$ binwalk 1732793154
</span><span>---------------------------------------------------------------------------------
</span><span>DECIMAL        HEXADECIMAL         DESCRIPTION
</span><span>---------------------------------------------------------------------------------
</span><span>512            0x200               Windows PE binary, machine type: Intel x86-64
</span><span>---------------------------------------------------------------------------------
</span></code></pre><p>The downloaded file is <code>BEService.exe</code>, which also embeds their kernel driver which is extracted when the service is started. You can use the same techniques as with EAC to extract it, so I won&#39;t go into further details.</p><small> While writing this blog post, I realized that some old download URLs of mine still worked. So it seems like the CDN is keeping not only the latest but also previous builds. Since the epoch timestamp only counts the seconds since 1970, it should only take a few days to enumerate all possible IDs. I&#39;ve thrown together a quick POC, and unfortunately it seems like they are deleted old version :( </small><p><a href="https://www.ea.com/security/news/eaac-deep-dive">EA-AC</a> (not to confuse with EAC) is a relatively new anticheat that was launched in 2022. It is used in games like FIFA or Battlefield, which all use the same installer. The direct download link to their installer can be found on the <a href="https://help.ea.com/en/help/pc/ea-anticheat/#install">help.ea.com</a> page which links to the following URL: <code>https://cdn.eaanticheat.ac.ea.com/EAAntiCheat.Installer.exe</code>.</p><p>Instead of having to run the installer, we can simply usage <code>7z</code> to extract the contents. However, they are not shipping the driver with the installer anymore, so you need to dump it while running the game or reverse engineer the download.</p><pre><code><span>$ 7z l  EAAntiCheat.Installer.exe
</span><span>   Date      Time    Attr         Size   Compressed  Name
</span><span>------------------- ----- ------------ ------------  ------------------------
</span><span>2025-06-14 08:03:50 .....     44388600     26865015  ProgramFiles/EAAntiCheat.GameService.dll
</span><span>2025-06-14 08:03:36 .....    116300024    108845059  ProgramFiles/EAAntiCheat.GameService.exe
</span><span>2025-06-14 08:04:12 .....        26872        14232  ProgramFiles/preloader_s.dll
</span><span>2025-06-14 08:03:50 .....     37148408     20349480  Title/EAAntiCheat.GameServiceLauncher.dll
</span><span>2025-06-14 08:03:50 .....     15922936     13955947  Title/EAAntiCheat.GameServiceLauncher.exe
</span><span>2025-06-14 08:04:12 .....        27384        14245  Title/preloader_l.dll
</span><span>------------------- ----- ------------ ------------  ------------------------
</span><span>2025-06-14 08:04:12          213814224    170043978  6 files
</span></code></pre><p><a href="https://en.wikipedia.org/wiki/Riot_Vanguard">Vanguard</a> is the anticheat used in Valorant and League of Legends, developed by Riot Games.</p><p>Despite their advanced security features, is is relatively easy to track the updates. They provide a public API to fetch the latest config which includes the version and URL for the anticheats modules:</p><pre><code><span>{
</span><span>  &#34;anticheat.vanguard.backgroundInstall&#34;: false,
</span><span>  &#34;anticheat.vanguard.enabled&#34;: true,
</span><span>  &#34;anticheat.vanguard.enforceExactVersionMatching&#34;: false,
</span><span>  &#34;anticheat.vanguard.steppingStones&#34;: [
</span><span>    &#34;1.16.15.9&#34;
</span><span>  ],
</span><span>  &#34;anticheat.vanguard.url&#34;: &#34;https://riot-client.secure.dyn.riotcdn.net/channels/public/rccontent/vanguard/{version}/setup.exe&#34;,
</span><span>  &#34;anticheat.vanguard.version&#34;: &#34;1.17.6.2&#34;,
</span><span>  ...
</span><span>}
</span></code></pre><p>After downloading the files from the CDN and extracting them (again either via <code>7z</code> or by running the installer), we&#39;ll have the following files. This already includes the driver and usermode components, so we don&#39;t even have to extract anything.</p><pre><code><span>$ 7z l setup.exe
</span><span>Date      Time    Attr         Size   Compressed  Name
</span><span>------------------- ----- ------------ ------------  ------------------------
</span><span>2025-05-05 20:43:53 ....A        21651         6298  vgc.ico
</span><span>2025-05-05 20:54:45 ....A      4494048     55866276  installer.exe
</span><span>2025-05-05 20:57:34 ....A      4285400               log-uploader.exe
</span><span>2025-05-05 20:55:20 ....A     40075376               vgc.exe
</span><span>2025-05-05 14:18:24 .....     26955888               vgk.sys
</span><span>2025-05-05 20:55:53 ....A     10524776               vgm.exe
</span><span>2025-05-05 20:56:48 ....A      3239456               vgrl.dll
</span><span>2025-05-05 20:57:10 ....A      4143376               vgtray.exe
</span><span>------------------- ----- ------------ ------------  ------------------------
</span><span>2025-05-05 20:57:34           93739971     55872574  8 files
</span></code></pre><p>It&#39;s surprising to see the differences in CDNs for different anticheats. You might think, why don&#39;t all anticheats have a <em>state-of-the-art military-grade quantum-proof AI encrypted CDNâ„¢</em>: Turns out it doesn&#39;t matter if people can extract all of the anticheat modules or figure out when the anticheat updates.</p><p>At best, it makes it a little bit more inconvenient or time consuming for researchers (which is pretty much the whole purpose of an anticheat). The main purpose is to protect the games and this is done by protecting the modules that do the detections rather than the CDN.</p><hr/><p>I worked on this project a few years ago, even gave a talk at a local meetup about the architecture, but never got around to publish a blog post about the internals. I really enjoyed working on this project, trying out new tech stack and learning about devops, deployment, object storage (MinIO) and a lot more. While some of the information likely is not unknown anymore, I still hope you learned something.</p><h2 id="equ8">EQU8</h2><p><strong>EDIT: Turns out the CDN doesn&#39;t work anymore, but I wanted to include it for the sake of completeness</strong></p><p>EQU8 is an anticheat developed primarily for the game Splitgate. It isn&#39;t as advanced as the previously mentioned anticheats, but still provides <em>some</em> level of protection against cheaters.</p><p>The download URL is as follows: <code>https://download2.equ8.com/v1/a1/{id}/updates.json</code>, where <code>{id}</code> is a unique identifier for the game (e.g. 36 for Splitgate)</p><p>This response can be parsed with the following structures:</p><pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>allow</span><span><span><span>(</span></span></span><span><span>unused</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Deserialize</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>Component</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>name</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>server_path</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>install_path</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>rule</span><span>:</span> String,
</span></span></span><span><span><span>    <span>pub</span> <span>size</span><span>:</span> <span>i64</span>,
</span></span></span><span><span><span>    <span>pub</span> <span>hash</span><span>:</span> String,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Deserialize</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>UpdateComponents</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>components</span><span>:</span> <span><span>Vec</span><span>&lt;</span>Component<span>&gt;</span></span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Deserialize</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>GameUpdate</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>pub</span> <span>update</span><span>:</span> UpdateComponents,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre><p>We can then search for the <code>anticheat.x64.equ8.exe</code> file which is the main executable and download it.</p><h2 id="faceit">FACEIT</h2><p>FACEIT is the anticheat of private leagues for games such as CSGO or League of Legends. They are one of the top anticheats in this space due to their invasive checks and little public information about their detections.</p><p>You can find the download link on their <a href="https://www.faceit.com/en/anti-cheat">anticheat page</a> which links to here: https://anticheat-client.faceit-cdn.net/FACEITInstaller_64.exe It only includes the frontend iirc, and I didn&#39;t spend much more time on it.</p><h2 id="esea">ESEA</h2><p>This anticheat requires you to have an account, and last time I checked their download page had a CAPTCHA, making it a little bit more inconvenient to track updates. Anyways, here&#39;s the download link: https://play.esea.net/index.php?s=downloads&amp;d=download&amp;id=1</p></section></div>
  </body>
</html>
