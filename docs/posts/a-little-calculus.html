<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://papl.cs.brown.edu/2018/func-as-data.html#%28part._.A_.Little_.Calculus%29">Original</a>
    <h1>A Little Calculus</h1>
    
    <div id="readability-page-1" class="page"><div><div><h3>13<tt> </tt><a name="(part._func-as-data)"></a>Functions as Data</h3><p>It’s interesting to consider how expressive the little programming
we’ve learned so far can be. To illustrate this, we’ll work through a
few exercises of interesting concepts we can express using just
functions as values. We’ll write two quite different things, then show
how they converge nicely.</p><h4>13.1<tt> </tt><a name="(part._.A_.Little_.Calculus)"></a>A Little Calculus</h4><p>If you’ve studied the differential calculus, you’ve come across
curious sytactic statements such as this:
</p><p type="math/tex">\begin{equation*}{\frac{d}{dx}} x^2 = 2x\end{equation*}</p><p>Let’s unpack what this means: the \(d/dx\), the \(x^2\), and the \(2x\).</p><p>First, let’s take on the two expressions; we’ll discuss one, and the
discussion will cover the other as well. The correct response to
“what does \(x^2\) mean?” is, of course, an error: it doesn’t mean
anything, because \(x\) is an unbound identifier.</p><p>So what is it <span>intended</span> to mean? The intent, clearly, is to
represent the function that squares its input, just as \(2x\) is meant
to be the function that doubles its input. We have nicer ways of
writing those:
</p><div><pre><p>fun square(x :: Number) -&gt; Number: x * x end
fun double(x :: Number) -&gt; Number: 2 * x end</p></pre></div><p>and what we’re really trying to say is that the \(d/dx\) (whatever
that is) of <span>square</span> is <span>double</span>.<span><span><span>We’re
assuming functions of arity one in the variable that is changing.</span></span></span></p><p>So now let’s unpack \(d/dx\), starting with its type. As the above
example illustrates, \(d/dx\) is really a <span>function from
functions to functions</span>. That is, we can write its type as follows:
</p><div><pre><p>d-dx :: ((Number -&gt; Number) -&gt; (Number -&gt; Number))</p></pre></div><p>(This type might explain why your calculus course never explained this
operation this way—<wbr/>though it’s not clear that obscuring its true
meaning is any better for your understanding.)</p><p>Let us now implement <span>d-dx</span>. We’ll implement <span>numerical</span>
differentiation, though in principle we could also implement
<span>symbolic </span> differentiation—<wbr/>using rules you learned, e.g.,
given a polynomial, multiply by the exponent and reduce the exponent
by one—<wbr/>with a representation of expressions
(<a href="https://papl.cs.brown.edu/2018/first-interp.html#%28part._dt-for-arith%29" data-pltdoc="x">Representing Arithmetic</a>).</p><p>In general, numeric differentiation of a function at a point yields
the value of the derivative at that point. We have a handy formula for
it: the derivative of \(f\) at \(x\) is
</p><p type="math/tex">\begin{equation*}\frac{f(x + \epsilon) - f(x)}{\epsilon}\end{equation*}</p><p>as \(\epsilon\) goes to zero in the limit. For now we’ll give the
infinitesimal a small but fixed value, and later
[<a href="#%28part._d-dx-streams%29" data-pltdoc="x">Combining Forces: Streams of Derivatives</a>] see how we can improve on this.</p><pre><p>epsilon = 0.001</p></pre><p>Let’s now try to translate the above formula into Pyret:
</p><div><pre><p>fun d-dx(f :: (Number -&gt; Number)) -&gt; (Number -&gt; Number):
  (f(x + epsilon) - f(x)) / epsilon
end</p></pre></div><blockquote><p>Do Now!</p><div><blockquote><p>What’s the problem with the above definition?</p></blockquote></div></blockquote><p>If you didn’t notice, Pyret will soon tell you: <span>x</span> isn’t
bound. Indeed, what is <span>x</span>? It’s the point at which we’re trying
to compute the numeric derivative. That is, <span>d-dx</span> needs to
return not a number but a <span>function</span> (as the type indicates) that
will consume this <span>x</span>:
</p><div><pre><p>fun d-dx(f :: (Number -&gt; Number)) -&gt; (Number -&gt; Number):
  lam(x :: Number) -&gt; Number:
    (f(x + epsilon) - f(x)) / epsilon
  end
end</p></pre></div><p>Sure enough, this definition now works. We can, for instance, test it
as follows (note the use of <span>num-floor</span> to avoid numeric precision
issues from making our tests appear to fail):
</p><div><pre><p>d-dx-square = d-dx(square)

check:
  ins = [list: 0, 1, 10, 100]
  for map(n from ins):
    num-floor(d-dx-square(n))
  end
  is
  for map(n from ins):
    num-floor(double(n))
  end
end</p></pre></div><p>Now we can return to the original example that launched this
investigation: what the sloppy and mysterious notation of math is
really trying to say is,
</p><div><pre><p>d-dx(lam(x): x * x end) = lam(x): 2 * x end</p></pre></div><p type="math/tex">\begin{equation*}{\frac{d}{dx}} [x \rightarrow x^2] = [x \rightarrow 2x]\end{equation*}</p><p>Pity math textbooks for not wanting to tell us the truth!</p><h4>13.2<tt> </tt><a name="(part._lam-shorthand)"></a>A Helpful Shorthand for Anonymous Functions</h4><p>Pyret offers a shorter syntax for writing anonymous functions. Though,
stylistically, we generally avoid it so that our programs don’t become
a jumble of special characters, sometimes it’s particularly
convenient, as we will see below. This syntax is
</p><p>where <span>a</span> is zero or more arguments and <span>b</span> is the body. For
instance, we can write <span>lam(x): x * x end</span> as
</p><p>where we can see the benefit of brevity. In particular, note that
there is no need for <span>end</span>, because the braces take the place of
showing where the expression begins and ends. Similarly, we could have
written <span>d-dx</span> as
</p><div><pre><p>fun d-dx-short(f):
  {(x): (f(x + epsilon) - f(x)) / epsilon}
end</p></pre></div><p>but many readers would say this makes the function harder to read,
because the prominent <span>lam</span> makes clear that <span>d-dx</span> returns
an (anonymous) function, whereas this syntax obscures it. Therefore,
we will usually only use this shorthand syntax for “one-liners”.</p><h4>13.3<tt> </tt><a name="(part._streams-from-funs)"></a>Streams From Functions</h4><p>People typically think of a function as serving one purpose: to
parameterize an expression. While that is both true and the most
common use of a function, it does not justify having a function of no
arguments, because that clearly parameterizes over nothing at all. Yet
functions of no argument also have a use, because functions actually
serve two purposes: to parameterize, <span>and to suspend evaluation
of the body until the function is applied</span>. In fact, these two uses
are orthogonal, in that one can employ one feature without the
other. In <a href="https://papl.cs.brown.edu/2018/Interpreting_Functions.html#%28part._let-desugar%29" data-pltdoc="x">Sugaring Over Anonymity</a> we see one direction of this:
parameterized functions that are used immediately, so that we employ
only abstraction and not delay. Below, we will see the other: delay
without abstraction.</p><p>Let’s consider the humble list. A list can be only finitely
long. However, there are many lists (or <span>sequences</span>) in nature
that have no natural upper bound: from mathematical objects (the
sequence of natural numbers) to natural ones (the sequence of hits to
a Web site). Rather than try to squeeze these unbounded lists into
bounded ones, let’s look at how we might represent and program over
these unbounded lists.</p><p>First, let’s write a program to compute the sequence of natural
numbers:
</p><div><pre><p>fun nats-from(n):
  link(n, nats-from(n + 1))
end</p></pre></div><blockquote><p>Do Now!</p><div><blockquote><p>Does this program have a problem?</p></blockquote></div></blockquote><p>While this represents our intent, it doesn’t work: running it—<wbr/>e.g.,
<span>nats-from(0)</span>—<wbr/>creates an infinite loop evaluating
<span>nats-from</span> for every subsequent natural number. In other words,
we want to write something very like the above, but that doesn’t recur
<span>until we want it to, i.e., on demand</span>. In other words, we want
the rest of the list to be <span>lazy</span>.</p><p>This is where our insight into functions comes in. A function, as we
have just noted, delays evaluation of its body until it is
applied. Therefore, a function would, in principle, defer the
invocation of <span>nats-from(n + 1)</span> until it’s needed.</p><p>Except, this creates a type problem: the second argument to
<span>link</span> needs to be a list, and cannot be a function. Indeed,
because it must be a list, and every value that has been constructed
must be finite, every list is finite and eventually terminates in
<span>empty</span>. Therefore, we need a new data structure to represent the
links in these <span>lazy lists</span> (also known as <span>streams</span>):
</p><p><a name="(elem._stream-type-def)"></a>&lt;<span>stream-type-def</span>&gt; ::=</p><div><table><tbody><tr><td><p><span>  </span><span>data Stream&lt;T&gt;:</span></p></td></tr><tr><td><p><span>  </span><span>  </span><span>| lz-link(h :: T, t :: ( -&gt; Stream&lt;T&gt;))</span></p></td></tr><tr><td><p><span>  </span><span>end</span></p></td></tr></tbody></table></div><p>where the annotation <span>( -&gt; Stream&lt;T&gt;)</span> means a function from no
arguments (hence the lack of anything before <span>-&gt;</span>),
also known as a <span>thunk</span>. Note that the way we have
defined streams they <span>must</span> be infinite, since we have provided
no way to terminate them.</p><p>Let’s construct the simplest example we can, a stream of constant
values:
</p><div><pre><p>ones = lz-link(1, lam(): ones end)</p></pre></div><p>Pyret will actually complain about this definition. Note that
the list equivalent of this also will not work:
</p><p>because <span>ones</span> is not defined at the point of
definition, so when Pyret evaluates <span>link(1, ones)</span>, it complains
that <span>ones</span> is not defined. However, it is being overly
conservative with our former definition: the use of <span>ones</span> is
“under a <span>lam</span>”, and hence won’t be needed until after the
definition of <span>ones</span> is done, at which point <span>ones</span>
<span>will</span> be defined. We can indicate this to Pyret by using the
keyword <span>rec</span>:
</p><div><pre><p>rec ones = lz-link(1, lam(): ones end)</p></pre></div><p>To understand more about recursive definitions, see
<a href="https://papl.cs.brown.edu/2018/State__Change__and_More_Equality.html#%28part._rec-for-recursive%29" data-pltdoc="x">Recursive Functions</a>. Note that in Pyret, every <span>fun</span>
<span>implicitly</span> has a <span>rec</span> beneath it, which is why we can
create recursive functions with aplomb.</p><blockquote><p>Exercise</p><div><blockquote><p>Earlier we said that we can’t write
</p><p>What if we tried to write
</p><p>instead? Does this work and, if so, what value is <span>ones</span> bound
to? If it doesn’t work, does it fail to work for the same reason as
the definition without the <span>rec</span>?</p></blockquote></div></blockquote><div><pre><p>rec ones = lz-link(1, {(): ones})</p></pre></div><p>Notice that <span>{(): …}</span> defines an anonymous function of <span>no</span>
arguments. You can’t leave out the <span>()</span>! If you do, Pyret will
get confused about what your program means.</p><p>Because functions are automatically recursive, when we write a
function to create a stream, we don’t need to use <span>rec</span>. Consider
this example:
</p><div><pre><p>fun nats-from(n :: Number):
  lz-link(n, {(): nats-from(n + 1)})
end</p></pre></div><p>with which we can define the natural numbers:
</p><p>Note that the definition of <span>nats</span> is not recursive itself—<wbr/>the
recursion is inside <span>nats-from</span>—<wbr/>so we don’t need to use
<span>rec</span> to define <span>nats</span>.</p><blockquote><p>Do Now!</p><div><blockquote><p>Earlier, we said that every list is finite and hence eventually
terminates. How does this remark apply to streams, such as the
definition of <span>ones</span> or <span>nats</span> above?</p></blockquote></div></blockquote><p>The description of <span>ones</span> is still a finite one; it simply
represents the <span>potential</span> for an infinite number of values. Note
that:
</p><div><ol><li><p>A similar reasoning doesn’t apply to lists because the rest of
the list has already been constructed; in contrast, placing a function
there creates the potential for a potentially unbounded amount of
computation to still be forthcoming.</p></li><li><p>That said, even with streams, in any given computation, we will
create only a finite prefix of the stream. However, we don’t have to
prematurely decide how many; each client and use is welcome to extract
less or more, as needed.</p></li></ol></div><p>Now we’ve created multiple streams, but we still don’t have an easy
way to “see” one. First we’ll define the traditional list-like
selectors. Getting the first element works exactly as with lists:
</p><div><pre><p>fun lz-first&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; T: s.h end</p></pre></div><p>In contrast, when trying to access the rest of the stream, all we get
out of the data structure is a thunk. To access the actual rest, we
need to <span>force</span> the thunk, which of course means applying it to no
arguments:
</p><div><pre><p>fun lz-rest&lt;T&gt;(s :: Stream&lt;T&gt;) -&gt; Stream&lt;T&gt;: s.t() end</p></pre></div><p>This is useful for examining individual values of the
stream. It is also useful to extract a finite prefix of
it (of a given size) as a (regular) list, which would be especially
handy for testing. Let’s write that function:
</p><div><pre><p>fun take&lt;T&gt;(n :: Number, s :: Stream&lt;T&gt;) -&gt; List&lt;T&gt;:
  if n == 0:
    empty
  else:
    link(lz-first(s), take(n - 1, lz-rest(s)))
  end
end</p></pre></div><p>If you pay close attention, you’ll find that this body is not defined
by cases <span>over the structure of the (stream) input</span>—<wbr/>instead,
it’s defined by the cases of the definition of a natural number (zero
or a successor). We’ll return to this below (<a href="#%28elem._lz-map2-def%29" data-pltdoc="x">&lt;<span>lz-map2-def</span>&gt;</a>).</p><p>Now that we have this, we can use it for testing. Note that usually we
use our data to test our functions; here, we’re using this function to
<span>test our data</span>:
</p><div><pre><p>check:
  take(10, ones) is map(lam(_): 1 end, range(0, 10))
  take(10, nats) is range(0, 10)
  take(10, nats-from(1)) is map((_ + 1), range(0, 10))
end</p></pre></div><p><span><span><span>The notation <span>(_ + 1)</span> defines a Pyret function of
one argument that adds <span>1</span> to the given argument.</span></span></span></p><p>Let’s define one more function: the equivalent of <span>map</span> over
streams. For reasons that will soon become obvious, we’ll define a
version that takes two lists and applies the first argument to them
pointwise:
</p><p><a name="(elem._lz-map2-def)"></a>&lt;<span>lz-map2-def</span>&gt; ::=</p><div><table><tbody><tr><td><p><span>  </span><span>fun lz-map2&lt;A, B, C&gt;(</span></p></td></tr><tr><td><p><span>  </span><span>    </span><span>f :: (A, B -&gt; C),</span></p></td></tr><tr><td><p><span>  </span><span>    </span><span>s1 :: Stream&lt;A&gt;,</span></p></td></tr><tr><td><p><span>  </span><span>    </span><span>s2 :: Stream&lt;B&gt;):</span></p></td></tr><tr><td><p><span>  </span><span>  </span><span>lz-link(</span></p></td></tr><tr><td><p><span>  </span><span>    </span><span>f(lz-first(s1), lz-first(s2)),</span></p></td></tr><tr><td><p><span>  </span><span>    </span><span>{(): lz-map2(f, lz-rest(s1), lz-rest(s2))})</span></p></td></tr><tr><td><p><span>  </span><span>end</span></p></td></tr></tbody></table></div><p>Now we can see our earlier remark about the structure of the function
driven home especially clearly. Whereas a traditional <span>map</span> over
lists would have two cases, here we have only one case because the
data definition (<a href="#%28elem._stream-type-def%29" data-pltdoc="x">&lt;<span>stream-type-def</span>&gt;</a>) has only one case!
What is the consequence of this? In a traditional <span>map</span>, one case
looks like the above, but the other case corresponds to the <span>empty</span>
input, for which it produces the same output. Here, because the stream
never terminates, mapping over it doesn’t either, and the structure of
the function reflects this.<span><span><span>This raises a much subtler
problem: if the function’s body doesn’t have base- and
inductive-cases, how can we perform an inductive proof over it? The
short answer is we can’t: we must instead use
<a href="https://papl.cs.brown.edu/2018/glossary.html#%28elem._glossary-coinduction%29" data-pltdoc="x">☛ <span>coinduction</span></a>.</span></span></span></p><p>Why did I define <span>lz-map2</span> instead of <span>lz-map</span>? Because it
enables us to write the following:
</p><div><pre><p>rec fibs =
  lz-link(0,
    {(): lz-link(1,
          {(): lz-map2({(a :: Number, b :: Number): a + b},
                fibs,
            lz-rest(fibs))})})</p></pre></div><p>from which, of course, we can extract as many Fibonacci numbers as we
want!
</p><div><pre><p>check:
  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
end</p></pre></div><blockquote><p>Exercise</p><div><blockquote><p>Define the equivalent of <span>map</span>, <span>filter</span>, and <span>fold</span>
for streams.</p></blockquote></div></blockquote><p>Streams and, more generally, infinite data structures that unfold on
demand are extremely valuable in programming. Consider, for instance,
the possible moves in a game. In some games, this can be infinite;
even if it is finite, for interesting games the combinatorics mean
that the tree is too large to feasibly store in memory. Therefore, the
programmer of the computer’s intelligence must unfold the game tree
<span>on demand</span>.  Programming it by using the encoding we have
described above means the program describes the <span>entire</span> tree,
lazily, and the tree unfolds automatically on demand, relieving the
programmer of the burden of implementing such a strategy.</p><p>In some languages, such as Haskell, lazy evaluation is built in
<span>by default</span>. In such a language, there is no need to use
thunks. However, lazy evaluation places other burdens on the language
[REF].</p><h4>13.4<tt> </tt><a name="(part._d-dx-streams)"></a>Combining Forces: Streams of Derivatives</h4><p>When we defined <span>d-dx</span>, we set <span>epsilon</span> to an arbitrary, high
value. We could instead think of <span>epsilon</span> as itself a stream that
produces successively finer values; then, for instance, when the
difference in the value of the derivative becomes small enough, we can
decide we have a sufficient approximation to the derivative.</p><p>The first step is, therefore, to make <span>epsilon</span> some kind of
parameter rather than a global constant. That leaves open what kind of
parameter it should be (number or stream?) as well as when it should
be supplied.</p><p>It makes most sense to consume this parameter after we have decided
what function we want to differentiate and at what value we want its
derivative; after all, the stream of <span>epsilon</span> values may depend
on both. Thus, we get:
</p><div><pre><p>fun d-dx(f :: (Number -&gt; Number)) -&gt;
    (Number -&gt; (Number -&gt; Number)):
  lam(x :: Number) -&gt; (Number -&gt; Number):
    lam(epsilon :: Number) -&gt; Number:
      (f(x + epsilon) - f(x)) / epsilon
    end
  end
end</p></pre></div><p>with which we can return to our <span>square</span> example:
</p><div><pre><p>d-dx-square = d-dx(square)</p></pre></div><p>Note that at this point we have simply redefined <span>d-dx</span> without
any reference to streams: we have merely made a constant into a
parameter.</p><p>Now let’s define the stream of negative powers of ten:
</p><div><pre><p>tenths = block:
  fun by-ten(d):
    new-denom = d / 10
    lz-link(new-denom, lam(): by-ten(new-denom) end)
  end
  by-ten(1)
end</p></pre></div><p>so that
</p><div><pre><p>check:
  take(3, tenths) is [list: 1/10, 1/100, 1/1000]
end</p></pre></div><p>For concreteness, let’s pick an abscissa at which to compute the
numeric derivative of <span>square</span>—<wbr/>say <span>10</span>:
</p><div><pre><p>d-dx-square-at-10 = d-dx-square(10)</p></pre></div><p>Recall, from the types, that this is now a function of type
<span>(Number -&gt; Number)</span>: given a value for <span>epsilon</span>, it computes
the derivative using that value.  We know, analytically, that the
value of this derivative should be <span>20</span>. We can now (lazily) map
<span>tenths</span> to provide increasingly better approximations for
<span>epsilon</span> and see what happens:
</p><div><pre><p>lz-map(d-dx-square-at-10, tenths)</p></pre></div><p>Sure enough, the values we obtain are <span>20.1</span>, <span>20.01</span>,
<span>20.001</span>, and so on: progressively better numerical
approximations to <span>20</span>.</p><blockquote><p>Exercise</p><div><blockquote><p>Extend the above program to take a tolerance, and draw as many values
from the <span>epsilon</span> stream as necessary until the difference
between successive approximations of the derivative fall within this
tolerance.</p></blockquote></div></blockquote></div></div></div>
  </body>
</html>
