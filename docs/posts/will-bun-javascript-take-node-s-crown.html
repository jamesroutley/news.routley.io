<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://semaphoreci.com/blog/javascript-bun">Original</a>
    <h1>Will Bun JavaScript Take Node&#39;s Crown</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">

		
<p><em>Huge thanks to Jarred Sumner for reviewing this post. It wouldnâ€™t have been possible without his help.</em></p>



<p>Bun is a new and ambitious JavaScript toolset and runtime. Early adopters have been reporting that Bun JavaScript is incredibly fast. So fast that it has been touted by some as a Node.js killer. Curious, I decided to check out Bun for myself and benchmark it against the competition.</p>



<p>Is it as fast as people are saying? How stable is it? Is it really better than Node? And can I use it with <a href="https://semaphoreci.com/continuous-integration" target="_blank" rel="noreferrer noopener">continuous integration</a>?</p>



<h2 id="what-is-bun">What is Bun?</h2>



<p>Bun is the newest addition to the JavaScript family. It has been making waves that rival those made by <a href="https://deno.land/" target="_blank" rel="noreferrer noopener">Deno</a> when it came out in 2018. Bun sits in the space between Node and Deno. Bun, like Deno, supports TypeScript out of the box and offers developer-friendly features such as top-level awaits and built-in Web APIs. But, unlike Deno, Bun is intended to be a drop-in replacement for Node, Webpack, Babel, Yarn, and PostCSS â€” all in one neat package.</p>



<p>â€‹</p>



<figure><img loading="lazy" width="80" height="70" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/bun.jpg" alt=""/><figcaption>Plus, it has a really cute mascot</figcaption></figure>



<p>â€‹</p>



<p>Bun is released with an MIT and LGPL2 License (due to JavaScriptCore) and, at the time of writing, is on version v0.1.4.</p>



<h2 id="how-does-bun-compare-to-deno-and-node">How does bun compare to Deno and Node?</h2>



<p>While Bun is inspired by Node and Deno, it is also clearly attempting to improve development experience and productivity by providing a batteries-included toolset.</p>



<p>Bun JavaScript takes features from Deno, like shipping as a single binary and having native TypeScript support.</p>



<figure><table><thead><tr><th>Feature</th><th>Bun</th><th>Deno</th></tr></thead><tbody><tr><td>TypeScript/TSX/JSX support</td><td>Yes</td><td>Yes</td></tr><tr><td>Single executable</td><td>Yes</td><td>Yes</td></tr><tr><td>Built-in test runner</td><td>Yes (in development)</td><td>Yes</td></tr><tr><td>Built-in Web APIs (fetch, WebSocket, etc.)</td><td>Yes</td><td>Yes</td></tr><tr><td>Top-level awaits</td><td>Yes</td><td>Yes</td></tr><tr><td>npm compatibility</td><td>Yes</td><td>No</td></tr><tr><td>No compatibility</td><td>Yes</td><td>Partial</td></tr><tr><td>tsconfig.json support</td><td>Yes</td><td>No</td></tr><tr><td>WebAssembly support</td><td>Yes</td><td>Yes</td></tr><tr><td>Built-in linter &amp; formatter</td><td>No</td><td>Yes</td></tr><tr><td>Permission system</td><td>No</td><td>Yes</td></tr><tr><td>Package manifest format</td><td>package.json</td><td>N/A</td></tr><tr><td>Module support</td><td>ES Modules, CommonJS</td><td>ES Modules</td></tr><tr><td>License</td><td>MIT, LGPL2</td><td>MIT</td></tr><tr><td>JS Engine</td><td>JavaScriptCore</td><td>V8</td></tr><tr><td>Language</td><td>Zig, C++</td><td>Rust, Tokio</td></tr></tbody></table></figure>



<p>Compared to Node, Bun offers more features while striving to still be compatible:</p>



<figure><table><thead><tr><th>Feature</th><th>Bun</th><th>Node</th></tr></thead><tbody><tr><td>npm compatibility</td><td>Yes</td><td>Yes</td></tr><tr><td>Node compatibility</td><td>Yes (beta)</td><td>Yes</td></tr><tr><td>Single binary</td><td>Yes</td><td>No</td></tr><tr><td>Built-in bundler &amp; transpiler</td><td>Yes</td><td>No</td></tr><tr><td>Native TypeScript support</td><td>Yes</td><td>No</td></tr><tr><td>Package manifest format</td><td>package.json</td><td>package.json</td></tr><tr><td>Lockfile format</td><td>Binary</td><td>JSON</td></tr><tr><td>Native live-reload</td><td>Yes</td><td>No</td></tr><tr><td>Built-in <code>.env</code>, <code>.toml</code> support</td><td>Yes</td><td>No</td></tr><tr><td>Top-level Awaits</td><td>Yes</td><td>Only on ES Modules</td></tr><tr><td>JS Engine</td><td>JavaScriptCore</td><td>V8</td></tr><tr><td>Languages</td><td>Zig, C++</td><td>C, C++</td></tr><tr><td>License</td><td>MIT, LGPL2</td><td>MIT, BSD</td></tr></tbody></table></figure>



<p>Being in the beta stage, however, means that Bun <a href="https://github.com/oven-sh/bun/issues/798" target="_blank" rel="noreferrer noopener">still has some quirks</a>:</p>



<ul><li>Documentation is limited, but <a href="https://discord.com/invite/CXdq2DP29u" target="_blank" rel="noreferrer noopener">Bunâ€™s Discord</a> is very active and a great source of knowledge.</li><li>No native Windows support (works with WSL, though).</li><li>Bun can get stuck while installing packages, fetch is not reliable, and, although it never happened to me, Bun can occasionally segfault.</li><li>Bun is not 100% compatible with Node yet. Not every npm package works. Express, for instance, is not yet functional.</li><li>Publishing to the npm registry does not work.</li><li>Various breaking changes will occur before the APIs and the CLI are stable.</li></ul>



<p>Bun has a few distinct quality-of-life characteristics of its own:</p>



<ul><li>Fast built-in sqlite3 module (MySQL and PostgreSQL are also planned).</li><li>Out-of-the-box <code>.env</code>, <code>.toml</code>, and CSS support (no extra loaders required).</li><li>Built-in framework support and optimizations for React and Next.js</li><li>Built-in Foreign Functions Interface (FFI) for low-level calls to ABI-supporting languages such as C, Rust, or Kotlin.</li><li>Option to copy errors as Markdown (for rapid sharing).</li></ul>



<h2 id="is-it-really-that-fast">Is it really that fast?</h2>



<p>Bun was born out of <a href="https://thenewstack.io/meet-bun-a-javascript-runtime-for-the-whole-dev-lifecycle/" target="_blank" rel="noreferrer noopener">Jarred Sumnerâ€™s frustration with the speed</a>, or lack thereof, of a language: <em>â€œIâ€™ve been so frustrated by how slow everything in JavaScript is. I know JavaScript can be a lot fasterâ€</em>. As a former frontend developer at Stripe, Jarred knows how a fast iteration cycle is essential for productivity.</p>



<p>Developer experience matters. As a result, Bunâ€™s speed is not limited to serving requests faster than other runtimes, but also means that it is faster at installing packages, running tests, bundling, and transpiling.</p>



<p>Letâ€™s run a few tests to see how Bun actually performs.</p>



<h2 id="benchmarking-bun">Benchmarking Bun</h2>



<p>Bunâ€™s homepage reports 3 and 4 times improved performance when compared against Deno and Node. Those are impressive numbers that I want to check for myself, so letâ€™s run a few benchmarks across different categories:</p>



<ul><li>Bun vs. npm as a package manager.</li><li>Bun vs. npm as a script runner.</li><li>Bun vs. npm for CI/CD workflows.</li><li>Bun vs. Node vs. Deno for copying large files.</li><li>Bun vs. Node vs. Deno for serving HTTP requests.</li></ul>



<p>In this instance, weâ€™re going to benchmark:</p>



<ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noreferrer noopener">Node.js</a> v16.16.0</li><li><a href="https://www.npmjs.com/" target="_blank" rel="noreferrer noopener">npm</a> v8.11.0</li><li><a href="https://deno.land/" target="_blank" rel="noreferrer noopener">Deno</a> v1.23.4</li><li><a href="https://bun.sh/" target="_blank" rel="noreferrer noopener">Bun</a> v0.1.4</li></ul>



<p>These are the tools I used for benchmarking:</p>



<ul><li><a href="https://github.com/hatoo/oha" target="_blank" rel="noreferrer noopener">oha</a>: v0.5.3</li><li><a href="https://github.com/sharkdp/hyperfine" target="_blank" rel="noreferrer noopener">hyperfine</a>: v1.14.0</li><li><a href="https://semaphoreci.com/" target="_blank" rel="noreferrer noopener">Semaphore CI/CD</a>: running tests on <a href="https://docs.semaphoreci.com/ci-cd-environment/machine-types/" target="_blank" rel="noreferrer noopener">e1-standard-2</a> and Ubuntu 20.04.</li><li>MacBook Pro M1 2020, MacOS 12.4</li></ul>



<p>You can see the scripts used for each case here: </p>






<p>Iâ€™ll try to compare Bun, Deno, and Node directly when possible. However, Deno was never intended as a drop-in replacement for Node, so it wonâ€™t be able to participate in all tests.</p>



<h2 id="managing-packages-with-bun">Managing packages with Bun</h2>



<p>In this first test, weâ€™ll compare how Bun JavaScript fares against npm for creating new projects. As you can see below, npm takes 49 seconds to create an empty React App.</p>



<pre><code lang="bash">$ timeÂ npx create-react-app myapp</code></pre>



<p>Bun ships with the <code>bun create</code> command capable of doing the same:</p>



<pre><code lang="bash">$ timeÂ bun create react myapp
[package.json] Detected ReactÂ -Â addedÂ &#34;react-refresh&#34;
â€‹
bun install v0.1.4
ğŸ” Resolving [1/4]
[29.00ms]Â git
+Â react-refresh@0.10.0
+Â typescript@4.7.4
+Â react@18.2.0
+Â react-dom@18.2.0
+Â web-vitals@2.1.4
â€‹
8Â packages installed [2.39s]
â€‹
2.48s userÂ 0.30s systemÂ 66% cpuÂ 4.160 total</code></pre>



<p>It takes Bun less than a second to complete the setup. Thatâ€™s quite an improvement. But is this a valid comparison? Upon further inspection, we find that:</p>



<ul><li>npm installed 1,392 packages and the <code>node_modules</code> size is 250 MB.</li><li>Bun only installed 8 packages, with a total size of 72 MB.</li></ul>



<p>Weâ€™re comparing apples to oranges here because Bunâ€™s starter React template is slimmer. Surprisingly, itâ€™s still quite usable for development. I can run <code>bun dev</code> to start hacking away immediately. Bun will also auto-reload on every change.</p>



<p>Yet, Bunâ€™s starter React cannot create a production build. For that, weâ€™ll need to add <a href="https://www.npmjs.com/package/react-scripts" target="_blank" rel="noreferrer noopener">react-scripts</a> with:</p>



<pre><code lang="bash">$ bunÂ add react-scriptsÂ -d</code></pre>



<p>The new dependency installs 1,133 more packages, taking <code>node_modules</code> to a total of 298 MB. Now weâ€™re in a better position for the comparison.</p>



<p>After creating the new app 10 times with each tool, we have some numbers to compare.</p>



<figure><table><thead><tr><th>Package Manager</th><th>Create React App (10 runs)</th></tr></thead><tbody><tr><td>npm</td><td>17.937 Â± 28.813</td></tr><tr><td>Bun</td><td>3.210 Â± 5.430</td></tr></tbody></table></figure>



<p>All tests were done with npm and bun caches warm, which explains why npm did much better the second time.</p>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/create-react.jpg" alt="A bar graphics comparing mean duration for bun and node."/><figcaption>Bun is 6 times faster than npm for creating a complete React project.</figcaption></figure>



<p>â€‹</p>



<p>In this test Bun JavaScript looks pretty good: <strong>it is at least 6 times faster than npm</strong>. From time to time, however, Bun would lock up (a known issue). Also, npm would slow down considerably from time to time. I could not determine the cause for this.</p>



<h3 id="adding-and-removing-packages-with-bun-and-npm">Adding and removing packages with Bun and npm</h3>



<p>Next, letâ€™s test how long it takes npm and Bun to add and remove packages. Iâ€™ll use an npm-created React App as the testing ground.</p>



<p>After removing and re-adding <a href="https://webpack.js.org/" target="_blank" rel="noreferrer noopener">webpack</a> 10 times with each tool, I got the following results:</p>



<figure><table><thead><tr><th>Tool</th><th>Add Webpack (10 runs)</th><th>Remove We pack (10 runs)</th></tr></thead><tbody><tr><td>npm</td><td>1900 ms</td><td>4200 ms</td></tr><tr><td>Bun</td><td>100 ms</td><td>200 ms</td></tr></tbody></table></figure>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/add-remove.jpg" alt="Bar graphics comparing Add and Remove durations for Bun and Node."/><figcaption>Bun is 20 times faster than npm.Â </figcaption></figure>



<p>â€‹</p>



<p>The only catch is that Bunâ€™s package management is not 100% compatible with npm:</p>



<ul><li>Bun uses a binary lockfile instead of <code>package-lock.json</code>. But it can print out a Yarn-compatible JSON lockfile with <code>bun install -y</code>.</li><li>Bun does not install peer dependencies by default like npm. So you might end up with a different set of packages than expected in your <code>node_modules</code> folder.</li></ul>



<h3 id="bun-as-a-task-runner">Bun as a task runner</h3>



<p>Unfortunately, Bunâ€™s runtime component has not implemented enough Node APIs to do complex things such as building React projects or running end-to-end tests. Still, there is one area in which Bun can help us right now: as a replacement for npm run.</p>



<p>The problem with npm is that it takes around 150 to 200ms to even start. It may not sound like a big deal, but when youâ€™re running scripts frequently, you can <em>feel</em> that quarter of a second eating away at your productivity little by little.</p>



<p>Bun does not have this start-up problem, so bun run test should be at least a few milliseconds faster than npm run test. We can confirm by running the same set of scripts 50 times and averaging the results:</p>



<figure><table><thead><tr><th>Command</th><th>Mean elapsed time (50 runs)</th></tr></thead><tbody><tr><td><code>npm run test</code></td><td>1.208 Â± 0.011</td></tr><tr><td><code>bun run test</code></td><td>1.046 Â± 0.030</td></tr></tbody></table></figure>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/unit-tests.jpg" alt="Bar graph comparing Bun and Node at Jest-based unit testing"/><figcaption>The difference is due to npm start-up time. The tests themselves are executed with Node on both cases.</figcaption></figure>



<p>â€‹</p>



<h3 id="copying-large-files">Copying large files</h3>



<p>In this test, I want to compare how each runtime handles copying large files, which is one area in which a lot of optimization effort was spent.</p>



<figure><div>
<blockquote data-width="550" data-dnt="true"><p lang="en" dir="ltr">what&#39;s the fastest way to copy 1 GB of node_modules on macOS?</p>â€” Jarred Sumner (@jarredsumner) <a href="https://twitter.com/jarredsumner/status/1458044627513085959?ref_src=twsrc%5Etfw">November 9, 2021</a></blockquote>
</div></figure>



<p>I copied the same randomly-generated 1GB file with Bun, Deno, Node, and cp for the test. After 20 runs with each tool, the results were:</p>



<figure><table><thead><tr><th>Tool</th><th>Mean [s] (20 runs)</th><th>Min [s]</th><th>Max [s]</th><th>Relative</th></tr></thead><tbody><tr><td>Bun</td><td>1.222 Â± 0.158</td><td>1.027</td><td>1.556</td><td>1.00</td></tr><tr><td>Deno</td><td>1.276 Â± 0.132</td><td>1.102</td><td>1.614</td><td>1.04 Â± 0.17</td></tr><tr><td>cp</td><td>1.802 Â± 0.714</td><td>0.451</td><td>3.304</td><td>1.47 Â± 0.61</td></tr><tr><td>Node</td><td>4.003 Â± 0.145</td><td>3.860</td><td>4.590</td><td>3.27 Â± 0.44</td></tr></tbody></table></figure>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/copy.jpg" alt="Bar graph comparing file copy speed for Bun, Deno, cp and Node."/><figcaption>Bun and Deno take the lead when copying large files.</figcaption></figure>



<p>â€‹</p>



<p>It seems Bun and Deno perform equally well, and both win over <code>cp</code> by almost 50%. Node is left far behind as it takes more than 3 times longer to complete the same task.</p>



<h3 id="http-showdown-bun-vs-deno-vs-node">HTTP Showdown: Bun vs Deno vs Node</h3>



<p>Bunâ€™s JavaScriptruntime does include a working HTTP server, which presents a benchmarking opportunity to compare with Node and Deno. For the test, Iâ€™ll use <a href="https://github.com/oven-sh/bun/tree/e55d6eed2bf9a5db30250fdd8b9be063dc949054/bench/react-hello-world" target="_blank" rel="noreferrer noopener">Bunâ€™s example scripts</a> to drive the tests. Iâ€™ll generate and measure traffic with <a href="https://github.com/hatoo/oha" target="_blank" rel="noreferrer noopener">oha</a>.</p>



<p>The benchmark runs 2 million requests with a concurrency of 50. For all cases, the HTTP keepalive was enabled.</p>



<figure><table><thead><tr><th>Runtime</th><th>RPS</th><th>Total time (2M requests)</th></tr></thead><tbody><tr><td>Bun</td><td>70966</td><td>28.18 seconds</td></tr><tr><td>Deno</td><td>40404</td><td>49.50 seconds</td></tr><tr><td>Node</td><td>33814</td><td>59.14 seconds</td></tr></tbody></table></figure>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/rps.jpg" alt="Bar graph comparing requests per second for Bun, Node and Deno."/><figcaption>Bun is twice as fast as Node and 1.7 times faster than Deno for serving HTTP requests on my dev machine.</figcaption></figure>



<p>â€‹</p>



<p>Deno performed 19% better than Node, but Bun blew away the competition by performing twice as fast.</p>



<h2 id="speeding-up-ci-cd-with-bun">Speeding up CI/CD with Bun</h2>



<p>Weâ€™ve confirmed that Bun can give you an edge on your development machine, but does it make sense to use it to accelerate CI/CD? This is a crucial aspect because the speed of your <a href="https://semaphoreci.com/blog/2017/03/02/what-is-proper-continuous-integration.html" target="_blank" rel="noreferrer noopener">continuous integration pipeline</a> is a deciding factor for a fast development cycle.</p>



<p>Iâ€™ve configured two branches on <a href="https://github.com/semaphoreci-demos/semaphore-demo-javascript" target="_blank" rel="noreferrer noopener">Semaphoreâ€™s JavaScript demo project</a>:</p>



<ul><li>master runs all scripts with npm as originally designed.</li><li>The bun branch replaces npm with Bun. To be clear, weâ€™re only using Bun as a task runner, not as a runtime. <strong>The test and build steps are still being executed by Node in both cases</strong>.</li></ul>



<p>Does Bun speed up CI/CD pipelines? After running both branches every ten minutes for five hours and picking 33 samples, the results are:</p>



<figure><table><thead><tr><th>Runtime</th><th>Average pipeline run (33 runs)</th></tr></thead><tbody><tr><td>npm</td><td>3 minutes 46 seconds</td></tr><tr><td>Bun</td><td>3 minutes</td></tr></tbody></table></figure>



<p>â€‹</p>



<figure><img loading="lazy" width="600" height="390" src="https://wpblog.semaphoreci.com/wp-content/uploads/2022/08/ci-duration.jpg" alt="Bar graph comparing pipeline durations for Bun- and Node-based workflows."/><figcaption>Replacing npm with Bun speeds up my pipeline by 20%.</figcaption></figure>



<p>â€‹</p>



<p>While experimenting with driving CI/CD with Bun, I learned a few things:</p>



<ul><li>Instead of <a href="https://docs.semaphoreci.com/essentials/caching-dependencies-and-directories/" target="_blank" rel="noreferrer noopener">caching</a> the <code>node_modules</code> folder, itâ€™s faster to save and restore Bunâ€™s global cache located at <code>$HOME/.bun/install/cache</code>.</li><li>Bun ships with an experimental test runner, which is supposed to be much faster than Jest. Unfortunately, I wasnâ€™t able to make it work. Weâ€™ll have to wait until the bun is out of the oven to try it (pun intended).</li><li>Thereâ€™s a lot of potential for improvement. Once Bun runtime can replace Node, CI/CD speed might increase dramatically.</li></ul>



<h2 id="conclusion">Conclusion</h2>



<p>Not only is Bun fast, it <em>feels</em> fast. It feels like you can do anything in under a second.</p>



<p>Will Bun replace Node? Itâ€™s too early to say. When Deno came out, it certainly didnâ€™t kill Node â€” but I donâ€™t think that was the intention, as it was never meant as a Node replacement. But Bun JavaScript aims for compatibility, so it has a better chance. And, as weâ€™ve seen, even at this early stage it can be a very powerful tool.</p>



<p><em>Again, huge thanks to <a href="https://twitter.com/jarredsumner" target="_blank" rel="noreferrer noopener">Jarred Sumner</a> for his help on editing this article. Bun is a seriously cool project, so <a href="https://github.com/oven-sh/bun" target="_blank" rel="noreferrer noopener">check it out on GitHub</a> and collaborate if you can.</em></p>


	</div></div>
  </body>
</html>
