<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://john-millikin.com/vu128-efficient-variable-length-integers">Original</a>
    <h1>vu128: Efficient variable-length integers</h1>
    
    <div id="readability-page-1" class="page"><div><h2 slot="title">Why variable-length integers?</h2><p>The basic goal of a variable-length integer encoding is to allow small numbers to be encoded in fewer bytes than larger numbers. Among other uses, they&#39;re popular for <abbr title="tag-length-value">TLV</abbr> formats such as <a href="https://protobuf.dev/">Protocol Buffers</a>, which contain lots of small numbers (tags) and have a design goal of space efficiency. The two encodings with near-universal adoption are <abbr title="variable-length quantity">VLQ</abbr> and <abbr title="little-endian base 128">LEB128</abbr>, which are the big- and little-endian dialects of an encoding originally developed in the early 1980s<blog-footnote-ref>[<a href="#fn:0">0</a>]</blog-footnote-ref>.</p><p>Due to various stupid decisions I find myself immersed in designing a new TLV format similar to Protocol Buffers, and therefore I needed to choose a variable-length integer encoding. Initially my plan was to use LEB128, but all the implementations I could find were far more complex than I wanted to deal with. I threw together a quick hack that used a length-prefix byte and figured I&#39;d come back to the problem later.</p><p>It is now later, and to prepare for writing a new LEB128 library I first wrote a benchmark to figure out what sort of performance could be expected. Surprisingly, the quick hack solution was not only simpler, it is <i>much</i> faster, with even the <a href="https://github.com/rust-lang/rust/pull/69050#issuecomment-585508353">carefully-optimized</a> code in <a href="https://github.com/rust-lang/rust/blob/1.78.0/compiler/rustc_serialize/src/leb128.rs"><tt>rustc_serialize/leb128.rs</tt></a> running at about 20% of the performance of my naive implementation.</p><img src="https://john-millikin.com/by-sha256/0b0f7a62d98db9a6afada66bcbc023533d24b3cdb6925222beadca206850dad9/benchmark-results.svg"/><p>After some head-scratching, my conclusion is that the LEB128 bitstream format is simply a poor fit for today&#39;s deeply pipelined processor architectures. In LEB128, each byte of input needs to have its <abbr title="most significant bit">MSB</abbr> tested to determine whether the value has terminated. A simpler format with a bit-packed length prefix byte will naturally perform better, because bitmasks are cheap and branches are expensive.</p><p>An afternoon of web searching has failed to uncover a prior name for this particular encoding, so I&#39;m going to name it <tt>vu128</tt> and describe it below. If any reader knows of prior art, please send it my way.</p></div><div><h2 slot="title">The vu128 format</h2><p>A vu128 containing an N-octet unsigned integer is composed of up to N+1 octets. If the integer is less than <tt>0xF0</tt>, it is stored in a single octet. Otherwise, the first octet is <tt>0xF0 | ((number of non-zero octets) - 1)</tt>, and the non-zero octets of the integer are appended in little-endian order. Integer lengths up to 128 bits are supported.</p><table><tbody><tr><th>Value (<tt>u64</tt>)</th><th>Encoded as</th></tr><tr><td><tt>0</tt></td><td><tt>[0x00]</tt></td></tr><tr><td><tt>239</tt></td><td><tt>[0xEF]</tt></td></tr><tr><td><tt>240</tt></td><td><tt>[0xF0 0xF0]</tt></td></tr><tr><td><tt>255</tt></td><td><tt>[0xF0 0xFF]</tt></td></tr><tr><td><tt>0xABCDEF</tt></td><td><tt>[0xF2 0xEF 0xCD 0xAB]</tt></td></tr><tr><td><tt>0x0123456789ABCDEF</tt></td><td><tt>[0xF7 0xEF 0xCD 0xAB 0x89 0x67 0x45 0x23 0x01]</tt></td></tr></tbody></table><p>Signed integers are stored in the &#34;zigzag&#34; encoding used by Protocol Buffers. This ensures that small-magnitude integers of either sign are encoded in a compact layout.</p><table><tbody><tr><th>Value (<tt>i64</tt>)</th><th>Encoded as</th></tr><tr><td><tt>0</tt></td><td><tt>[0x00]</tt></td></tr><tr><td><tt>-1</tt></td><td><tt>[0x01]</tt></td></tr><tr><td><tt>1</tt></td><td><tt>[0x02]</tt></td></tr><tr><td><tt>-2</tt></td><td><tt>[0x03]</tt></td></tr><tr><td><tt>2</tt></td><td><tt>[0x04]</tt></td></tr></tbody></table><p>IEEE-754 floating-point values are stored in big-endian order due to their internal layout.</p><table><tbody><tr><th>Value (<tt>f64</tt>)</th><th>Encoded as</th></tr><tr><td><tt>0.0</tt></td><td><tt>[0x00]</tt></td></tr><tr><td><tt>-0.0</tt></td><td><tt>[0x80]</tt></td></tr><tr><td><tt>1.0</tt></td><td><tt>[0xF1, 0x3F, 0xF0]</tt></td></tr><tr><td><tt>2.0</tt></td><td><tt>[0x40]</tt></td></tr><tr><td><tt>2.5</tt></td><td><tt>[0xF1, 0x40, 0x04]</tt></td></tr></tbody></table></div><div><h2 slot="title">Rust implementation</h2><p>A straightforward implementation using basic bit operations, with no SIMD or exotic control flow. On my desktop (AMD Ryzen 7 3700X) this code runs somewhere between 2x and 5x faster than the LEB128 code used by the Rust compiler.</p><p>This decoder will accept over-long encoding, and will also truncate values that are too large to fit in the given integer type. The low-level Protobuf routines behave similarly, but such behavior may or may not be appropriate depending on the use case. Adding checks for such conditions, if necessary, is left as an exercise to the reader.</p><blog-section><h3 slot="title">Unsigned integers</h3><blog-code syntax="rust"><pre>// Copyright (c) John Millikin &lt;john@john-millikin.com&gt;
// SPDX-License-Identifier: 0BSD

macro_rules! encode_uNN {
	($name:ident, $t:ident, $max_len:literal, $len_mask:literal) =&gt; {
		#[inline]
		pub fn $name(buf: &amp;mut [u8; $max_len], x: $t) -&gt; usize {
			if x &lt; 0xF0 {
				buf[0] = x as u8;
				return 1;
			}
			unsafe {
				(buf as *mut [u8; $max_len])
					.cast::&lt;u8&gt;().add(1).cast::&lt;$t&gt;()
					.write_unaligned(x.to_le());
			}
			let len = ((x.leading_zeros() &gt;&gt; 3) as u8) ^ $len_mask;
			buf[0] = 0xF0 | len;
			usize::from(len + 2)
		}
	};
}

macro_rules! decode_uNN {
	($name:ident, $t:ident, $max_len:literal, $len_mask:literal) =&gt; {
		#[inline]
		pub fn $name(buf: &amp;[u8; $max_len]) -&gt; ($t, usize) {
			if buf[0] &lt; 0xF0 {
				return ($t::from(buf[0]), 1);
			}
			let x = $t::from_le(unsafe {
				(buf as *const [u8; $max_len])
					.cast::&lt;u8&gt;().add(1).cast::&lt;$t&gt;()
					.read_unaligned()
			});
			let len = buf[0] &amp; 0x0F;
			let mask = $t::MAX &gt;&gt; ((len &amp; $len_mask) ^ $len_mask);
			(x &amp; mask, usize::from(len + 2))
		}
	};
}

encode_uNN!(encode_u16, u16, 3, 0x01);
encode_uNN!(encode_u32, u32, 5, 0x03);
encode_uNN!(encode_u64, u64, 9, 0x07);
encode_uNN!(encode_u128, u128, 17, 0x0F);

decode_uNN!(decode_u16, u16, 3, 0x01);
decode_uNN!(decode_u32, u32, 5, 0x03);
decode_uNN!(decode_u64, u64, 9, 0x07);
decode_uNN!(decode_u128, u128, 17, 0x0F);

#[inline]
pub fn encode_u8(buf: &amp;mut [u8; 2], x: u8) -&gt; usize {
	if x &lt; 0xF0 {
		buf[0] = x;
		return 1;
	}
	buf[0] = 0xF0;
	buf[1] = x;
	2
}

#[inline]
pub fn decode_u8(buf: &amp;[u8; 2]) -&gt; (u8, usize) {
	if buf[0] &lt; 0xF0 {
		return (buf[0], 1);
	}
	(buf[1], 2)
}
</pre></blog-code><p>Assembly for the encoder and decoder functions, generated by <tt>rustc</tt> v1.78:</p><blog-code syntax="asm"><pre>encode_u32:
        cmp     esi, 240
        jae     .LBB1_1
        mov     eax, 1
        mov     byte ptr [rdi], sil
        ret
.LBB1_1:
        mov     dword ptr [rdi + 1], esi
        lzcnt   esi, esi
        shr     esi, 3
        mov     al, 5
        sub     al, sil
        xor     sil, -13
        movzx   eax, al
        mov     byte ptr [rdi], sil
        ret

decode_u32:
        movzx   eax, byte ptr [rdi]
        cmp     eax, 240
        jae     .LBB0_1
        mov     edx, 1
        ret
.LBB0_1:
        mov     ecx, eax
        not     cl
        and     cl, 3
        mov     edx, 32
        sub     edx, ecx
        bzhi    ecx, dword ptr [rdi + 1], edx
        and     al, 15
        add     al, 2
        movzx   edx, al
        mov     eax, ecx
        ret
</pre></blog-code></blog-section><blog-section><h3 slot="title">Signed integers (zigzag)</h3><blog-code syntax="rust"><pre>macro_rules! encode_iNN {
	(
		$name:ident,
		$encode_fn:ident,
		$iNN:ident,
		$uNN:ident,
		$max_len:literal,
		$zigzag_shift:literal
	) =&gt; {
		#[inline]
		pub fn $name(buf: &amp;mut [u8; $max_len], x: $iNN) -&gt; usize {
			let zigzag = ((x &gt;&gt; $zigzag_shift) as $uNN) ^ ((x &lt;&lt; 1) as $uNN);
			$encode_fn(buf, zigzag)
		}
	};
}

macro_rules! decode_iNN {
	(
		$name:ident,
		$decode_fn:ident,
		$iNN:ident,
		$uNN:ident,
		$max_len:literal
	) =&gt; {
		#[inline]
		pub fn $name(buf: &amp;[u8; $max_len]) -&gt; ($iNN, usize) {
			let (zz, len) = $decode_fn(buf);
			let x = ((zz &gt;&gt; 1) as $iNN) ^ (-((zz &amp; 1) as $iNN));
			(x, len)
		}
	};
}

encode_iNN!(encode_i8, encode_u8, i8, u8, 2, 7);
encode_iNN!(encode_i16, encode_u16, i16, u16, 3, 15);
encode_iNN!(encode_i32, encode_u32, i32, u32, 5, 31);
encode_iNN!(encode_i64, encode_u64, i64, u64, 9, 63);
encode_iNN!(encode_i128, encode_u128, i128, u128, 17, 127);

decode_iNN!(decode_i8, decode_u8, i8, u8, 2);
decode_iNN!(decode_i16, decode_u16, i16, u16, 3);
decode_iNN!(decode_i32, decode_u32, i32, u32, 5);
decode_iNN!(decode_i64, decode_u64, i64, u64, 9);
decode_iNN!(decode_i128, decode_u128, i128, u128, 17);
</pre></blog-code></blog-section><blog-section><h3 slot="title">Floating-point</h3><blog-code syntax="rust"><pre>#[inline]
pub fn encode_f32(buf: &amp;mut [u8; 5], x: f32) -&gt; usize {
	encode_u32(buf, x.to_bits().swap_bytes())
}

#[inline]
pub fn encode_f64(buf: &amp;mut [u8; 9], x: f64) -&gt; usize {
	encode_u64(buf, x.to_bits().swap_bytes())
}

#[inline]
pub fn decode_f32(buf: &amp;[u8; 5]) -&gt; (f32, usize) {
	let (swapped, len) = decode_u32(buf);
	(f32::from_bits(swapped.swap_bytes()), len)
}

#[inline]
pub fn decode_f64(buf: &amp;[u8; 9]) -&gt; (f64, usize) {
	let (swapped, len) = decode_u64(buf);
	(f64::from_bits(swapped.swap_bytes()), len)
}</pre></blog-code></blog-section></div></div>
  </body>
</html>
