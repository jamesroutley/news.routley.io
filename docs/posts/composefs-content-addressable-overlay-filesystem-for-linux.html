<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/containers/composefs">Original</a>
    <h1>Composefs: Content-Addressable Overlay Filesystem for Linux</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Composefs is a native Linux file system designed to help sharing
filesystem contents, as well as ensuring said content is not
modified. The initial target usecase are container images and ostree
commits.</p>
<p dir="auto">The basic idea is to have a single binary file that contains all the
metadata of the filesystem, including the filenames, the permissions,
the timestamps, etc. However, it doesn&#39;t contain the actual contents,
but rather filenames to the real files that contain the contents. This
is somewhat similar to overlayfs, which also doesn&#39;t store the file.</p>
<p dir="auto">You pass the filename of the blob as well as the base directory for the
content files when you mount the filesystem like this:</p>
<div data-snippet-clipboard-copy-content="# mount /path/to/blob -t composefs -o basedir=/path/to/content /mnt"><pre><code># mount /path/to/blob -t composefs -o basedir=/path/to/content /mnt
</code></pre></div>
<p dir="auto">This by itself doesn&#39;t seem very useful. You could use a single
squashfs image, or regular directory with the files instead. However,
the advantage comes if you want to store many such images. By storing
the files content-addressed (e.g. using the hash of the content to name
the file) shared files need only be stored once, yet can appear in
multiple mounts. Since these are normal files they will also only be
stored once in the page cache, meaning that the duplication is avoided
both on disk and in ram.</p>
<p dir="auto">Composefs also supports
<a href="https://www.kernel.org/doc/html/latest/filesystems/fsverity.html" rel="nofollow">fs-verity</a>
validation of the content files.  When using this, the digest of the
content files is stored in the image, and composefs will validate that
the content file it uses has a matching enabled fs-verity digest. This
means that the backing content cannot be changed in any way (by
mistake or by malice) without this being detected when the file is
used.</p>
<p dir="auto">You can also use fs-verity on the image file itself, and pass the
expected fs-verity digest as a mount option, which composefs will
validate. In this case we have full trust of both data and metadata of
the mounted file. This solves a weakness that fs-verity has when used
on on its own, in that it can only verify file data, not
metadata.</p>
<h2 dir="auto"><a id="user-content-usecase-container-images" aria-hidden="true" href="#usecase-container-images"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usecase: container images</h2>
<p dir="auto">When pulling a container image to the local storage we normally just
untar each layer by itself. Instead we can store the file content
in a content-addressed fashion, and then generate a composefs file
for the layer (or perhaps the combined layers).</p>
<p dir="auto">This allows sharing of content files between images, even if the
metadata (like the timestamps or file ownership) vary between images.</p>
<p dir="auto">Together with something like
<a href="https://github.com/containers/storage/pull/775" data-hovercard-type="pull_request" data-hovercard-url="/containers/storage/pull/775/hovercard">zstd:chunked</a> this
will speed up pulling container images and make them available for
usage, without the need to even create these files if already present!</p>
<h2 dir="auto"><a id="user-content-usecase-ostree" aria-hidden="true" href="#usecase-ostree"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usecase: OSTree</h2>
<p dir="auto">OSTree already uses a content-address object store. However, normally
this has to be checked out into a regular directory (using hardlinks
into the object store for regular files). This directory is then
bind-mounted as the rootfs when the system boots.</p>
<p dir="auto">OSTree already supports enabling fs-verity on the files in the store,
but nothing can protect against changes to the checkout directories. A
malicious user can add, remove or replace files there. We want to use
composefs to avoid this.</p>
<p dir="auto">Instead of checking out to a directory we generate a composefs image
pointing into the object store and mount that as the root fs. We can
then enable fs-verity of the composefs image and embed the digest of
that in the kernel commandline which specifies the rootfs. Since
composefs generation is reproducible, we can even verify that the
composefs image we generated is correct by comparing its digest to one
in the ostree metadata that was generated when the ostree image was built.</p>
<h2 dir="auto"><a id="user-content-user-space-tools" aria-hidden="true" href="#user-space-tools"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>user space tools</h2>
<p dir="auto">The directory <code>tools/</code> contains some user space tools to create the binary blob to pass to the client.  They are all experimental and lack documentation.</p>
<ul dir="auto">
<li><code>mkcomposefs</code>: Creates a composefs image given a directory pathname. Can also compute digests and create a content store directory.</li>
<li><code>writer-json</code>: convert from a <a href="https://github.com/google/crfs">CRFS</a> metadata file to the binary blob.</li>
<li><code>dump</code>: prints the content of the binary blob.</li>
<li><code>ostree-convert-commit.py</code>: converts an OSTree commit into a CRFS config file that writer-json can use.</li>
</ul>
<h2 dir="auto"><a id="user-content-kernel-module" aria-hidden="true" href="#kernel-module"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>kernel module</h2>
<p dir="auto">How to build:</p>
<div data-snippet-clipboard-copy-content="# make -C $KERNEL_SOURCE modules M=$PWD &amp;&amp;  make -C $KERNEL_SOURCE modules_install M=$PWD
# insmod /lib/modules/$(uname -r)/extra/composefs.ko"><pre><code># make -C $KERNEL_SOURCE modules M=$PWD &amp;&amp;  make -C $KERNEL_SOURCE modules_install M=$PWD
# insmod /lib/modules/$(uname -r)/extra/composefs.ko
</code></pre></div>
<p dir="auto">Once it is loaded, it can be used as:</p>
<div data-snippet-clipboard-copy-content="# mount /path/to/blob -t composefs -o basedir=$BASE_DIR  /mnt"><pre><code># mount /path/to/blob -t composefs -o basedir=$BASE_DIR  /mnt
</code></pre></div>
<p dir="auto">Mount options:</p>
<ul dir="auto">
<li><code>basedir</code>: is the directory to use as a base when resolving relative content paths.</li>
<li><code>verity_check=0,1,2</code>: When to verify backing file fs-verity: 0 == never, 1 == if specified in image, 2 == always and require it in image.</li>
<li><code>digest</code>: A fs-verity sha256 digest that the image file must match. If set, <code>verity_check</code> defaults to 2.</li>
</ul>
<h2 dir="auto"><a id="user-content-selinux-issues" aria-hidden="true" href="#selinux-issues"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>SELinux issues</h2>
<p dir="auto">Composefs support xattrs natively, and selinux normally uses xattrs to
store selinux file contexts. However, this only works if the local
policy allows a particular filesystem type to use xattrs for selinux,
and the default is to not allow it. So, until the default selinux
contexts supports composefs, you need to manually install a local
policy for this.</p>
<p dir="auto">To enable composefs selinux support, run:</p>
<div data-snippet-clipboard-copy-content="# semodule -i composefs.cil"><pre><code># semodule -i composefs.cil
</code></pre></div>
<p dir="auto">And, to later revert it, run:</p>

</article>
          </div></div>
  </body>
</html>
