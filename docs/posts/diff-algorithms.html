<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flo.znkr.io/diff/">Original</a>
    <h1>Diff Algorithms</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>For software engineers, diffs are a ubiquitous method for representing changes: We use diffs to
compare different versions of the same file (e.g., during code review or when trying to understand
the history of a file), to visualize the difference of a failing test compared with its
expectation, or to apply changes to source files automatically.</p>
<p>Every project I worked on professionally or privately eventually needed a diff to visualize a change
or to apply a patch. However, I have never been satisfied with any of the freely available diff
libraries. This was never really a problem professionally, but for private projects, I have copied
and modified my own library from project to project until I mentioned this to a colleague who set me
on the path to publish my Go library (a port of a previous C++ library I used to copy and modify).
<em>Boy, did I underestimate how close my library was to publishability!</em></p>
<p>Anyway, I did it and I learned a whole lot about diff algorithms. You can find my library at
<a href="https://znkr.io/diff">znkr.io/diff</a> and what I learned in this article. I am not finished learning
yet, so I plan to update this article as my understanding continues to evolve.</p>
<h2 id="existing-diff-libraries">Existing Diff Libraries<a href="#existing-diff-libraries"></a></h2>
<p>Let me start by explaining why I am dissatisfied with existing diff libraries. There are a number of
attributes that are important to me. Not all of these attributes are important for every use case,
but a diff library that I can use for all of my use cases needs to fulfill all of them.</p>
<p>Usually, the input to a diff algorithm is text, and most diff libraries only support that. However,
I occasionally have use cases where I need to compare things that are not text. So any diff library
that only supports text doesn&#39;t meet my needs; instead, I need support for <strong>arbitrary sequences</strong>.</p>
<p>The resulting diff output is intended to be readable by humans. Quite often, especially for text, a
good way to present a diff is in the <strong>unified format</strong>. However, it&#39;s not always the best
presentation. A diff library should make it easy to output a diff in unified format, but it should
also provide a way to customize the presentation by providing a <strong>structured result</strong>.</p>
<p>Besides the presentation, the content of a diff should make it easy for humans to understand the
diff. This is a somewhat subjective criterion, but there are a number of failure cases that are
easily avoided, and there&#39;s some research into <strong>diff readability</strong> to set a benchmark. On the other
hand, diffs should be <strong>minimal</strong> in that they should be as small as possible.</p>
<p>Last but not least, it&#39;s important that a diff library has a <strong>simple API</strong> and provides good
<strong>performance</strong> in both runtime and memory usage, even in worst-case
scenarios<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p>
<p>With that, we can evaluate existing diff libraries. For Go, I went through a number of libraries
and summarized them.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Input</th>
<th>Output</th>
<th>API</th>
<th>Performance<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></th>
<th>Diff</th>
<th>Diff</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/sergi/go-diff">diffmatchpatch</a></td>
<td>❌<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></td>
<td>❌<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></td>
<td>🤔<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></td>
<td>➖➖</td>
<td>➖</td>
<td>➖</td>
</tr>
<tr>
<td><a href="https://github.com/rogpeppe/go-internal/tree/master/diff">go-internal</a></td>
<td>❌<sup id="fnref1:3"><a href="#fn:3" role="doc-noteref">3</a></sup></td>
<td>❌<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></td>
<td>😁</td>
<td>➕➕</td>
<td>➕➕</td>
<td>➕</td>
</tr>
<tr>
<td><a href="https://github.com/kylelemons/godebug/tree/master/diff">godebug</a></td>
<td>❌<sup id="fnref2:3"><a href="#fn:3" role="doc-noteref">3</a></sup></td>
<td>✅</td>
<td>😁</td>
<td>➖➖➖ /🧨<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></td>
<td>➕</td>
<td>➕➕</td>
</tr>
<tr>
<td><a href="https://github.com/mb0/diff">mb0</a></td>
<td>✅</td>
<td>❌<sup id="fnref1:4"><a href="#fn:4" role="doc-noteref">4</a></sup></td>
<td>😐<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></td>
<td>➖➖</td>
<td>➕</td>
<td>➕➕</td>
</tr>
<tr>
<td><a href="https://github.com/aymanbagabas/go-udiff">udiff</a></td>
<td>❌<sup id="fnref3:3"><a href="#fn:3" role="doc-noteref">3</a></sup></td>
<td>✅</td>
<td>😁</td>
<td>➕<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></td>
<td>➖</td>
<td>➖➖<sup id="fnref1:9"><a href="#fn:9" role="doc-noteref">9</a></sup></td>
</tr>
</tbody>
</table>
<div><p>Beware</p><p>The way I assigned ➕ and ➖ in this table doesn&#39;t follow any scientific methodology
it&#39;s merely based on running a few benchmarks and comparing a few results by hand. If you&#39;re looking
for a diff library to fulfill your needs, I would like to encourage you to do your own comparisons.
You can find the code I used for these comparisons in <a href="https://github.com/znkr/diff/tree/main/internal/benchmarks">on
github</a>.</p>
</div>
<h2 id="challenges">Challenges<a href="#challenges"></a></h2>
<p>The results suggest that it&#39;s far from trivial to implement a good diff library, and the one I had
started out with wasn&#39;t much better. To understand why the existing libraries are as they are,
we need to take a peek into the implementation.</p>
<h3 id="complexity">Complexity<a href="#complexity"></a></h3>
<p>With the exception of go-internal, all libraries use <a href="http://www.xmailserver.org/diff2.pdf">Myers&#39;
Algorithm</a> to compute the diff. This is a standard algorithm
that returns a minimal diff and has been in use for this purpose for decades. The algorithm has a
runtime complexity of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <mi>N</mi>
      <mi>D</mi>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(ND)</annotation>
  </semantics>
</math>
 where 
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics>
    <mrow>
      <mi>N</mi>
    </mrow>
    <annotation encoding="application/x-tex">N</annotation>
  </semantics>
</math>
 is the number of input elements and 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>D</mi>
    </mrow>
    <annotation encoding="application/x-tex">D</annotation>
  </semantics>
</math>
 is the
edit distance between the two inputs. This means that the algorithm is very fast for inputs that are
similar, which is quite common. However, it&#39;s essentially quadratic in the worst case. That is, for
inputs that are very different, the complexity approaches 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <msup>
        <mi>N</mi>
        <mn>2</mn>
      </msup>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N^2)</annotation>
  </semantics>
</math>
. Furthermore, the
algorithm comes in two variants with a space complexity of either 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <msup>
        <mi>N</mi>
        <mn>2</mn>
      </msup>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N^2)</annotation>
  </semantics>
</math>
 or

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <mi>N</mi>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N)</annotation>
  </semantics>
</math>
. Only godebug uses the variant with quadratic memory growth.</p>
<p>This means that <strong>it&#39;s relatively easy to write a well-performing diffing algorithm for small or
similar inputs, but it takes a very long time to complete for larger, less similar inputs</strong>. A
consequence of this is that we can&#39;t trust simple benchmarks; instead, we need to test the
worst-case scenario<sup id="fnref1:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p>
<p>As always in cases like this, we can improve the performance by approximating an optimal solution.
There are a number of heuristics that reduce the time complexity by trading off diff minimality. For
example, diffmatchpatch uses a deadline to stop the search for an optimal diff, and udiff uses a
an extremely aggressive heuristic.</p>
<p>Instead of improving Myers&#39; runtime with heuristics, it&#39;s also often possible to find a diff using
only heuristics. go-internal uses <a href="https://bramcohen.livejournal.com/73318.html">patience diff</a>. The
heuristic is good enough that it alone almost always results in a good diff with a runtime
complexity of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <mi>N</mi>
      <mspace width="0.17em"></mspace>
      <mi lspace="0.11111em">log</mi>
      <mspace width="0.17em"></mspace>
      <mi>N</mi>
      <mo stretchy="false" form="postfix">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N \, \log \, N)</annotation>
  </semantics>
</math>
<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>. An additional advantage of
this algorithm is that it produces more readable diffs. However, patience diff can fail with very
large diffs, and it can only be implemented efficiently using a hash table, which restricts the
possible applications.</p>
<div><p>Histogram Diff</p><p>Besides patience diff, there&#39;s another interesting heuristic called histogram
diff. I still have to implement it and understand it better before writing about it here, though.</p>
</div>
<h3 id="readability">Readability<a href="#readability"></a></h3>
<p>Diff algorithms usually find a minimal diff or an approximation of one. However, except for trivial
cases, there are always multiple minimal diffs. For example, this simple diff</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_01.diff">example_01.diff</a>
</caption>
<tbody><tr data-op="match" data-x-lineno="1" data-y-lineno="1">
                <td>1</td>
                <td>1</td>
                <td> </td>
                <td><code>a
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>b
</code></td>
            </tr><tr data-op="delete" data-x-lineno="2">
                <td>2</td>
                <td></td>
                <td>-</td>
                <td><code>c
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="3">
                <td>3</td>
                <td>3</td>
                <td> </td>
                <td><code>d
</code></td>
            </tr></tbody>
</table>
<p>is as minimal as</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_02.diff">example_02.diff</a>
</caption>
<tbody><tr data-op="match" data-x-lineno="1" data-y-lineno="1">
                <td>1</td>
                <td>1</td>
                <td> </td>
                <td><code>a
</code></td>
            </tr><tr data-op="delete" data-x-lineno="2">
                <td>2</td>
                <td></td>
                <td>-</td>
                <td><code>c
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>b
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="3">
                <td>3</td>
                <td>3</td>
                <td> </td>
                <td><code>d
</code></td>
            </tr></tbody>
</table>
<p>Not all of the minimal or near-minimal diffs have the same readability for humans. For
example<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup>,</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_03.diff">example_03.diff</a>
</caption>
<tbody><tr data-op="insert" data-y-lineno="1">
                <td></td>
                <td>1</td>
                <td>+</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>{
</code></td>
            </tr><tr data-op="insert" data-y-lineno="3">
                <td></td>
                <td>3</td>
                <td>+</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="4">
                <td></td>
                <td>4</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="insert" data-y-lineno="5">
                <td></td>
                <td>5</td>
                <td>+</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="6">
                <td></td>
                <td>6</td>
                <td>+</td>
                <td><code>}
</code></td>
            </tr><tr data-op="insert" data-y-lineno="7">
                <td></td>
                <td>7</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="1" data-y-lineno="8">
                <td>1</td>
                <td>8</td>
                <td> </td>
                <td><code>void Chunk_copy(Chunk *src, size_t src_start, Chunk *dst, size_t dst_start, size_t n)
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="9">
                <td>2</td>
                <td>9</td>
                <td> </td>
                <td><code>{
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="10">
                <td>3</td>
                <td>10</td>
                <td> </td>
                <td><code>    if (!Chunk_bounds_check(src, src_start, n)) return;
</code></td>
            </tr><tr data-op="match" data-x-lineno="4" data-y-lineno="11">
                <td>4</td>
                <td>11</td>
                <td> </td>
                <td><code>    if (!Chunk_bounds_check(dst, dst_start, n)) return;
</code></td>
            </tr><tr data-op="match" data-x-lineno="5" data-y-lineno="12">
                <td>5</td>
                <td>12</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="6" data-y-lineno="13">
                <td>6</td>
                <td>13</td>
                <td> </td>
                <td><code>    memcpy(dst-&gt;data + dst_start, src-&gt;data + src_start, n);
</code></td>
            </tr><tr data-op="match" data-x-lineno="7" data-y-lineno="14">
                <td>7</td>
                <td>14</td>
                <td> </td>
                <td><code>}
</code></td>
            </tr><tr data-op="delete" data-x-lineno="8">
                <td>8</td>
                <td></td>
                <td>-</td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="9">
                <td>9</td>
                <td></td>
                <td>-</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="delete" data-x-lineno="10">
                <td>10</td>
                <td></td>
                <td>-</td>
                <td><code>{
</code></td>
            </tr><tr data-op="delete" data-x-lineno="11">
                <td>11</td>
                <td></td>
                <td>-</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="delete" data-x-lineno="12">
                <td>12</td>
                <td></td>
                <td>-</td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="13">
                <td>13</td>
                <td></td>
                <td>-</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="delete" data-x-lineno="14">
                <td>14</td>
                <td></td>
                <td>-</td>
                <td><code>}
</code></td>
            </tr></tbody>
</table>
<p>is much more readable than the equally minimal and correct</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_04.diff">example_04.diff</a>
</caption>
<tbody><tr data-op="delete" data-x-lineno="1">
                <td>1</td>
                <td></td>
                <td>-</td>
                <td><code>void Chunk_copy(Chunk *src, size_t src_start, Chunk *dst, size_t dst_start, size_t n)
</code></td>
            </tr><tr data-op="insert" data-y-lineno="1">
                <td></td>
                <td>1</td>
                <td>+</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="2">
                <td>2</td>
                <td>2</td>
                <td> </td>
                <td><code>{
</code></td>
            </tr><tr data-op="delete" data-x-lineno="3">
                <td>3</td>
                <td></td>
                <td>-</td>
                <td><code>    if (!Chunk_bounds_check(src, src_start, n)) return;
</code></td>
            </tr><tr data-op="delete" data-x-lineno="4">
                <td>4</td>
                <td></td>
                <td>-</td>
                <td><code>    if (!Chunk_bounds_check(dst, dst_start, n)) return;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="3">
                <td></td>
                <td>3</td>
                <td>+</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="match" data-x-lineno="5" data-y-lineno="4">
                <td>5</td>
                <td>4</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="6">
                <td>6</td>
                <td></td>
                <td>-</td>
                <td><code>    memcpy(dst-&gt;data + dst_start, src-&gt;data + src_start, n);
</code></td>
            </tr><tr data-op="insert" data-y-lineno="5">
                <td></td>
                <td>5</td>
                <td>+</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="match" data-x-lineno="7" data-y-lineno="6">
                <td>7</td>
                <td>6</td>
                <td> </td>
                <td><code>}
</code></td>
            </tr><tr data-op="match" data-x-lineno="8" data-y-lineno="7">
                <td>8</td>
                <td>7</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="9">
                <td>9</td>
                <td></td>
                <td>-</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="insert" data-y-lineno="8">
                <td></td>
                <td>8</td>
                <td>+</td>
                <td><code>void Chunk_copy(Chunk *src, size_t src_start, Chunk *dst, size_t dst_start, size_t n)
</code></td>
            </tr><tr data-op="match" data-x-lineno="10" data-y-lineno="9">
                <td>10</td>
                <td>9</td>
                <td> </td>
                <td><code>{
</code></td>
            </tr><tr data-op="delete" data-x-lineno="11">
                <td>11</td>
                <td></td>
                <td>-</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="10">
                <td></td>
                <td>10</td>
                <td>+</td>
                <td><code>    if (!Chunk_bounds_check(src, src_start, n)) return;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="11">
                <td></td>
                <td>11</td>
                <td>+</td>
                <td><code>    if (!Chunk_bounds_check(dst, dst_start, n)) return;
</code></td>
            </tr><tr data-op="match" data-x-lineno="12" data-y-lineno="12">
                <td>12</td>
                <td>12</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="13">
                <td>13</td>
                <td></td>
                <td>-</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="13">
                <td></td>
                <td>13</td>
                <td>+</td>
                <td><code>    memcpy(dst-&gt;data + dst_start, src-&gt;data + src_start, n);
</code></td>
            </tr><tr data-op="match" data-x-lineno="14" data-y-lineno="14">
                <td>14</td>
                <td>14</td>
                <td> </td>
                <td><code>}
</code></td>
            </tr><tr data-op="match" data-x-lineno="15" data-y-lineno="15">
                <td>15</td>
                <td>15</td>
                <td> </td>
                <td><code></code></td>
            </tr></tbody>
</table>
<p>Furthermore, if we relax minimality to accept approximations, the number of possible results
increases significantly.</p>
<p>For good diff readability, we have to select one solution from the many possible ones that is
readable for humans. Many people believe that the diff readability is determined by the algorithm.
However, that&#39;s only partially correct, because <strong>different <em>implementations</em> of the same algorithm
can produce vastly different results</strong>.</p>
<p>There&#39;s also been a lot of progress in the past years to improve diff readability. Perhaps the best
work about diff readability is <a href="https://github.com/mhagger/diff-slider-tools">diff-slider-tools</a> by
<a href="https://github.com/mhagger">Michael Haggerty</a>. He implemented a heuristic that&#39;s applied in a
post-processing step to improve the readability.</p>
<p>In fact, <code>example_03.diff</code> above was generated using this heuristic. The diff without the heuristic,
as generated by my implementation of Myers&#39; linear-space variant, looks like this:</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_03_no_indent_heuristic.diff">example_03_no_indent_heuristic.diff</a>
</caption>
<tbody><tr data-op="insert" data-y-lineno="1">
                <td></td>
                <td>1</td>
                <td>+</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>{
</code></td>
            </tr><tr data-op="insert" data-y-lineno="3">
                <td></td>
                <td>3</td>
                <td>+</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="4">
                <td></td>
                <td>4</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="insert" data-y-lineno="5">
                <td></td>
                <td>5</td>
                <td>+</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="insert" data-y-lineno="6">
                <td></td>
                <td>6</td>
                <td>+</td>
                <td><code>}
</code></td>
            </tr><tr data-op="insert" data-y-lineno="7">
                <td></td>
                <td>7</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="1" data-y-lineno="8">
                <td>1</td>
                <td>8</td>
                <td> </td>
                <td><code>void Chunk_copy(Chunk *src, size_t src_start, Chunk *dst, size_t dst_start, size_t n)
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="9">
                <td>2</td>
                <td>9</td>
                <td> </td>
                <td><code>{
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="10">
                <td>3</td>
                <td>10</td>
                <td> </td>
                <td><code>    if (!Chunk_bounds_check(src, src_start, n)) return;
</code></td>
            </tr><tr data-op="match" data-x-lineno="4" data-y-lineno="11">
                <td>4</td>
                <td>11</td>
                <td> </td>
                <td><code>    if (!Chunk_bounds_check(dst, dst_start, n)) return;
</code></td>
            </tr><tr data-op="match" data-x-lineno="5" data-y-lineno="12">
                <td>5</td>
                <td>12</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="6" data-y-lineno="13">
                <td>6</td>
                <td>13</td>
                <td> </td>
                <td><code>    memcpy(dst-&gt;data + dst_start, src-&gt;data + src_start, n);
</code></td>
            </tr><tr data-op="delete" data-x-lineno="7">
                <td>7</td>
                <td></td>
                <td>-</td>
                <td><code>}
</code></td>
            </tr><tr data-op="delete" data-x-lineno="8">
                <td>8</td>
                <td></td>
                <td>-</td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="9">
                <td>9</td>
                <td></td>
                <td>-</td>
                <td><code>int Chunk_bounds_check(Chunk *chunk, size_t start, size_t n)
</code></td>
            </tr><tr data-op="delete" data-x-lineno="10">
                <td>10</td>
                <td></td>
                <td>-</td>
                <td><code>{
</code></td>
            </tr><tr data-op="delete" data-x-lineno="11">
                <td>11</td>
                <td></td>
                <td>-</td>
                <td><code>    if (chunk == NULL) return 0;
</code></td>
            </tr><tr data-op="delete" data-x-lineno="12">
                <td>12</td>
                <td></td>
                <td>-</td>
                <td><code>
</code></td>
            </tr><tr data-op="delete" data-x-lineno="13">
                <td>13</td>
                <td></td>
                <td>-</td>
                <td><code>    return start &lt;= chunk-&gt;length &amp;&amp; n &lt;= chunk-&gt;length - start;
</code></td>
            </tr><tr data-op="match" data-x-lineno="14" data-y-lineno="14">
                <td>14</td>
                <td>14</td>
                <td> </td>
                <td><code>}
</code></td>
            </tr></tbody>
</table>
<p>Notice that the deletion starts at the end of the preceding function and leaves a small
remainder of the function being deleted? Michael&#39;s heuristic fixes this problem and results in the
very readable <code>example_03.diff</code>.</p>
<div><p>It&#39;s not the algorithm</p><p><code>example_04.diff</code> was found using a different implementation of Myers&#39;
linear-space variant. That is, both <code>example_03.diff</code> and <code>example_04.diff</code> used the same algorithm!
The differences stem from the implementation of that algorithm and from post-processing.</p>
</div>
<h2 id="a-new-diffing-library-for-go">A New Diffing Library for Go<a href="#a-new-diffing-library-for-go"></a></h2>
<p>I created <a href="https://znkr.io/diff">znkr.io/diff</a> to address these challenges in a way that works for
all my use cases. Let&#39;s reiterate what I want from a diffing library:</p>
<ul>
<li>The input can be text and arbitrary slices</li>
<li>The output should be possible in unified format and as a structured result</li>
<li>The API should be simple</li>
<li>The diffs should be minimal or near-minimal</li>
<li>The runtime and memory performance should be excellent</li>
</ul>
<p>This is a lot more than what any of the existing libraries provide. When I copied and modified my
old diffing library, I could adapt it to the use cases at hand. But a general-purpose diffing
library needs to be general enough to cover the vast majority of use cases. At the same time, it
needs to be extensible to make sure new features can be implemented without cluttering the API over
time.</p>
<p>Unfortunately, excellent performance and minimal results are somewhat in opposition to one another
and I ended up providing three different modes of operation: Default (balanced between performance
and minimality), Fast (sacrifice minimal results for faster speed), Optimal (minimal result whatever
the cost).</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Input</th>
<th>Output</th>
<th>API</th>
<th>Performance<sup id="fnref2:2"><a href="#fn:2" role="doc-noteref">2</a></sup></th>
<th>Diff</th>
<th>Diff</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td>✅</td>
<td>✅</td>
<td>😁</td>
<td>➕➕</td>
<td>➕➕</td>
<td>➕➕</td>
</tr>
<tr>
<td>Fast</td>
<td>✅</td>
<td>✅</td>
<td>😁</td>
<td>➕➕➕</td>
<td>➕➕</td>
<td>➕</td>
</tr>
<tr>
<td>Optimal</td>
<td>✅</td>
<td>✅</td>
<td>😁</td>
<td>➕</td>
<td>➕➕</td>
<td>➕➕</td>
</tr>
</tbody>
</table>
<div><p>Text Only</p><p>This table only applies to text (same as the table above), non-text inputs can have
a different performance (if they are not <code>comparable</code>) or readability.</p>
</div>
<h3 id="api">API<a href="#api"></a></h3>
<p>To design this API, I started with the data structures that I wanted to use as a user of the API and
worked backwards from there. At a very high level, there are two structured representations of a
diff that have been useful to me: a flat sequence of all deletions, insertions, and matching
elements (called <em>edits</em>) and a nested sequence of consecutive changes (called <em>hunks</em>).</p>
<ul>
<li>Edits are what I use to represent edits in this article; they contain the full content of both
inputs and how one is transformed into the other.</li>
<li>Hunks are a great representation for unit tests, because they are empty if both inputs are
identical and they make it possible to visualize just the changes even if the inputs are large.</li>
</ul>
<h4 id="arbitrary-slices">Arbitrary Slices<a href="#arbitrary-slices"></a></h4>
<p>I started with the design for the most general case, arbitrary slices. The Go representation for
diffing slices I liked the most is this one (see also
<a href="https://pkg.go.dev/znkr.io/diff">znkr.io/diff</a>):</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/diff.go">diff.go</a>
</caption>
<tbody>
    <tr>
        <td>5</td>
        <td><code><span>// Op describes an edit operation.</span>
</code></td>
    </tr>
    <tr>
        <td>6</td>
        <td><code><span>type</span> Op int
</code></td>
    </tr>
    <tr>
        <td>7</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>8</td>
        <td><code><span>const</span> (
</code></td>
    </tr>
    <tr>
        <td>9</td>
        <td><code>	Match  Op = <span>iota</span> <span>// Two slice elements match</span>
</code></td>
    </tr>
    <tr>
        <td>10</td>
        <td><code>	Delete           <span>// A deletion from an element on the left slice</span>
</code></td>
    </tr>
    <tr>
        <td>11</td>
        <td><code>	Insert           <span>// An insertion of an element from the right side</span>
</code></td>
    </tr>
    <tr>
        <td>12</td>
        <td><code>)
</code></td>
    </tr>
    <tr>
        <td>13</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>14</td>
        <td><code><span>// Edit describes a single edit of a diff.</span>
</code></td>
    </tr>
    <tr>
        <td>15</td>
        <td><code><span>// - For Match, both X and Y contain the matching element.</span>
</code></td>
    </tr>
    <tr>
        <td>16</td>
        <td><code><span>// - For Delete, X contains the deleted element and Y is unset (zero value).</span>
</code></td>
    </tr>
    <tr>
        <td>17</td>
        <td><code><span>// - For Insert, Y contains the inserted element and X is unset (zero value).</span>
</code></td>
    </tr>
    <tr>
        <td>18</td>
        <td><code><span>type</span> Edit[T any] <span>struct</span> {
</code></td>
    </tr>
    <tr>
        <td>19</td>
        <td><code>	Op   Op
</code></td>
    </tr>
    <tr>
        <td>20</td>
        <td><code>	X, Y T
</code></td>
    </tr>
    <tr>
        <td>21</td>
        <td><code>}
</code></td>
    </tr>
    <tr>
        <td>22</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>23</td>
        <td><code><span>// Hunk describes a sequence of consecutive edits.</span>
</code></td>
    </tr>
    <tr>
        <td>24</td>
        <td><code><span>type</span> Hunk[T any] <span>struct</span> {
</code></td>
    </tr>
    <tr>
        <td>25</td>
        <td><code>	PosX, EndX int       <span>// Start and end position in x.</span>
</code></td>
    </tr>
    <tr>
        <td>26</td>
        <td><code>	PosY, EndY int       <span>// Start and end position in y.</span>
</code></td>
    </tr>
    <tr>
        <td>27</td>
        <td><code>	Edits      []Edit[T] <span>// Edits to transform x[PosX:EndX] to y[PosY:EndY]</span>
</code></td>
    </tr>
    <tr>
        <td>28</td>
        <td><code>}
</code></td>
    </tr></tbody>
</table>
<p>The alternatives I have seen are variations and combinations of two themes. Either using slices to
represent edit operations in <code>Hunk</code></p>
<pre><code>type Hunk[T any] struct {
	Delete []T
	Insert []T
	Match  []T
}
</code></pre>
<p>Or using indices instead of elements</p>
<pre><code>type Edit struct {
	Op         Op
	PosX, PosY []int
}
</code></pre>
<p>All of these representations work, but I found that the representations above served my use cases
best. One little quirk is that <code>Edit</code> always contains both elements. This is often unnecessary, but
there are use cases where this is very important because the elements themselves might not be equal
(e.g., if they are pointers that are compared with a custom function).</p>
<p>Once the data structures were established, it was quite obvious that the simplest way to fill them
with diff data was to write two functions <a href="https://pkg.go.dev/znkr.io/diff#Edits"><code>diff.Edits</code></a> and
<a href="https://pkg.go.dev/znkr.io/diff#Hunks"><code>diff.Hunks</code></a> to return the diffs. I made them extensible by
using <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">functional options</a>.</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/diff.go">diff.go</a>
</caption>
<tbody>
    <tr>
        <td>30</td>
        <td><code><span>// Edits compares the contents of x and y and returns the changes necessary to convert from one to</span>
</code></td>
    </tr>
    <tr>
        <td>31</td>
        <td><code><span>// the other.</span>
</code></td>
    </tr>
    <tr>
        <td>32</td>
        <td><code><span>//
</span></code></td>
    </tr>
    <tr>
        <td>33</td>
        <td><code><span>// Edits returns one edit for every element in the input slices. If x and y are identical, the</span>
</code></td>
    </tr>
    <tr>
        <td>34</td>
        <td><code><span>// output will consist of a match edit for every input element.</span>
</code></td>
    </tr>
    <tr>
        <td>35</td>
        <td><code><span>func</span> Edits[T comparable](x, y []T, opts ...Option) []Edit[T]
</code></td>
    </tr>
    <tr>
        <td>36</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>37</td>
        <td><code><span>// Hunks compares the contents of x and y and returns the changes necessary to convert from one to</span>
</code></td>
    </tr>
    <tr>
        <td>38</td>
        <td><code><span>// the other.</span>
</code></td>
    </tr>
    <tr>
        <td>39</td>
        <td><code><span>//
</span></code></td>
    </tr>
    <tr>
        <td>40</td>
        <td><code><span>// The output is a sequence of hunks. A hunk represents a contiguous block of changes (insertions</span>
</code></td>
    </tr>
    <tr>
        <td>41</td>
        <td><code><span>// and deletions) along with some surrounding context.</span>
</code></td>
    </tr>
    <tr>
        <td>42</td>
        <td><code><span>func</span> Hunks[T comparable](x, y []T, opts ...Option) []Hunk[T]
</code></td>
    </tr></tbody>
</table>
<p>The options allow for future extensibility and allow changing the behavior of these functions. For
example, the option <a href="https://pkg.go.dev/znkr.io/diff#Context"><code>diff.Context(5)</code></a> configures <code>Hunks</code>
to provide 5 elements of surrounding context.</p>
<p>However, the current API still doesn&#39;t allow <em>arbitrary slices</em>; it only allows slices of
<code>comparable</code> types. To fix this, I needed two other functions that provide a function to compare
two elements. The Go standard library uses the <code>Func</code> suffix for functions like this, so I followed
the lead:</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/diff.go">diff.go</a>
</caption>
<tbody>
    <tr>
        <td>44</td>
        <td><code><span>// EditsFunc compares the contents of x and y using the provided equality comparison and returns the</span>
</code></td>
    </tr>
    <tr>
        <td>45</td>
        <td><code><span>// changes necessary to convert from one to the other.</span>
</code></td>
    </tr>
    <tr>
        <td>46</td>
        <td><code><span>func</span> EditsFunc[T any](x, y []T, eq <span>func</span>(a, b T) bool, opts ...Option) []Edit[T]
</code></td>
    </tr>
    <tr>
        <td>47</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>48</td>
        <td><code><span>// HunksFunc compares the contents of x and y using the provided equality comparison and returns the</span>
</code></td>
    </tr>
    <tr>
        <td>49</td>
        <td><code><span>// changes necessary to convert from one to the other.</span>
</code></td>
    </tr>
    <tr>
        <td>50</td>
        <td><code><span>func</span> HunksFunc[T any](x, y []T, eq <span>func</span>(a, b T) bool, opts ...Option) []Hunk[T]
</code></td>
    </tr></tbody>
</table>
<h4 id="text">Text<a href="#text"></a></h4>
<p>While this API works well to produce a structured result for arbitrary slices, it doesn&#39;t provide
output in unified format for text inputs. My first approach was to provide a helper function that
returns a diff in unified format: <code>diff.ToUnified(hunks []Hunk[string]) string</code>. However, this would
make getting a unified diff more complicated. Besides requiring two function calls, it would be
necessary to split the input into lines. This, in turn, can be done in different ways, e.g., by
stripping or keeping the line breaks, which opens the door to mistakes. It&#39;s much better to provide
a simple function for the entire use case.</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/textdiff.go">textdiff.go</a>
</caption>
<tbody>
    <tr>
        <td>7</td>
        <td><code><span>// Unified compares the lines in x and y and returns the changes necessary to convert from one to</span>
</code></td>
    </tr>
    <tr>
        <td>8</td>
        <td><code><span>// the other in unified format.</span>
</code></td>
    </tr>
    <tr>
        <td>9</td>
        <td><code><span>func</span> Unified[T string | []byte](x, y T, opts ...diff.Option) T
</code></td>
    </tr></tbody>
</table>
<p>I also moved this function to the <a href="https://pkg.go.dev/znkr.io/diff/textdiff"><code>textdiff</code></a> package to
highlight the difference in expected input.</p>
<p>Now, I also happen to have use cases where I need structured results for text diffs. It would be
very annoying if I had to split those into lines manually. Besides, I can make a few more
assumptions about text that allow for a slight simplification of the data structures:</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/textdiff.go">textdiff.go</a>
</caption>
<tbody>
    <tr>
        <td>11</td>
        <td><code><span>// Edit describes a single edit of a line-by-line diff.</span>
</code></td>
    </tr>
    <tr>
        <td>12</td>
        <td><code><span>type</span> Edit[T string | []byte] <span>struct</span> {
</code></td>
    </tr>
    <tr>
        <td>13</td>
        <td><code>	Op   diff.Op <span>// Edit operation</span>
</code></td>
    </tr>
    <tr>
        <td>14</td>
        <td><code>	Line T       <span>// Line, including newline character (if any)</span>
</code></td>
    </tr>
    <tr>
        <td>15</td>
        <td><code>}
</code></td>
    </tr>
    <tr>
        <td>16</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>17</td>
        <td><code><span>// Hunk describes a sequence of consecutive edits.</span>
</code></td>
    </tr>
    <tr>
        <td>18</td>
        <td><code><span>type</span> Hunk[T string | []byte] <span>struct</span> {
</code></td>
    </tr>
    <tr>
        <td>19</td>
        <td><code>	PosX, EndX int       <span>// Start and end line in x (zero-based).</span>
</code></td>
    </tr>
    <tr>
        <td>20</td>
        <td><code>	PosY, EndY int       <span>// Start and end line in y (zero-based).</span>
</code></td>
    </tr>
    <tr>
        <td>21</td>
        <td><code>	Edits      []Edit[T] <span>// Edits to transform x lines PosX..EndX to y lines PosY..EndY</span>
</code></td>
    </tr>
    <tr>
        <td>22</td>
        <td><code>}
</code></td>
    </tr>
    <tr>
        <td>23</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>24</td>
        <td><code><span>// Edits compares the lines in x and y and returns the changes necessary to convert from one to the</span>
</code></td>
    </tr>
    <tr>
        <td>25</td>
        <td><code><span>// other.</span>
</code></td>
    </tr>
    <tr>
        <td>26</td>
        <td><code><span>func</span> Edits[T string | []byte](x, y T, opts ...diff.Option) []Edit[T]
</code></td>
    </tr>
    <tr>
        <td>27</td>
        <td><code>
</code></td>
    </tr>
    <tr>
        <td>28</td>
        <td><code><span>// Hunks compares the lines in x and y and returns the changes necessary to convert from one to the</span>
</code></td>
    </tr>
    <tr>
        <td>29</td>
        <td><code><span>// other.</span>
</code></td>
    </tr>
    <tr>
        <td>30</td>
        <td><code><span>func</span> Hunks[T string | []byte](x, y T, opts ...diff.Option) []Hunk[T]
</code></td>
    </tr></tbody>
</table>
<h4 id="conclusion">Conclusion<a href="#conclusion"></a></h4>
<p>For the full API and examples for how to use it, please see the package documentation for
<a href="https://pkg.go.dev/znkr.io/diff">znkr.io/diff</a> and
<a href="https://pkg.go.dev/znkr.io/diff/textdiff">znkr.io/diff/textdiff</a>. I am certain that there are use
cases not covered by this API, but I feel confident that it can evolve to cover these use cases in
the future. For now, all my needs are fulfilled, but if you run into a situation that can&#39;t be
solved by this API or requires some contortions, please <a href="https://github.com/znkr/diff/issues/new">tell me about
it</a>.</p>
<h3 id="implementation">Implementation<a href="#implementation"></a></h3>
<p>To implement this API, we need to implement a diff algorithm. There are a couple of standard diff
algorithms that we can choose from. The choice of the algorithm as well as how it&#39;s implemented
matters for the readability of the result as well as the performance.</p>
<p>A good starting point for this project was Myers&#39; algorithm, simply because it&#39;s the fastest
algorithm that can cover the whole API. In particular, the <code>...Func</code> variants for <code>any</code> types
instead of <code>comparable</code> can&#39;t make use of a hash map. Patience and Histogram require the use of a
hash map for an efficient implementation, so Myers&#39; really is the only choice. Another advantage of
Myers&#39; compared to Patience and Histogram is that it will return optimal results.</p>
<p>On the flip side, in the <a href="#existing-diff-libraries">comparison above</a>, it came out as relatively
slow compared to the patience diff algorithm and didn&#39;t produce the most readable results. It turns
out, however, that this can be mitigated and almost completely overcome for <code>comparable</code> types using
a combination of preprocessing, heuristics, and post-processing.</p>
<p>I am not going to cover the diff algorithm in detail here. There are a number of excellent articles
on the web that describe it<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup>, but I recommend reading the
paper<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>: All articles I have seen try to keep a distance from the theory that
makes this algorithm work, but that&#39;s not really helpful if you want to understand how and why this
algorithm works.</p>
<h4 id="preprocessing">Preprocessing<a href="#preprocessing"></a></h4>
<p>The most impactful way to improve the performance of Myers&#39; algorithm is to reduce the problem size.
The simplest thing to do is to strip any common prefix and suffix. This is always possible and helps
a little. However, it can also reduce diff readability, because it will consume matching elements
eagerly.</p>
<p>For example, let&#39;s say we have this change:</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_05.diff">example_05.diff</a>
</caption>
<tbody><tr data-op="match" data-x-lineno="1" data-y-lineno="1">
                <td>1</td>
                <td>1</td>
                <td> </td>
                <td><code>package array
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="2">
                <td>2</td>
                <td>2</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="3">
                <td>3</td>
                <td>3</td>
                <td> </td>
                <td><code>var m = []struct{
</code></td>
            </tr><tr data-op="match" data-x-lineno="4" data-y-lineno="4">
                <td>4</td>
                <td>4</td>
                <td> </td>
                <td><code>    name  string
</code></td>
            </tr><tr data-op="match" data-x-lineno="5" data-y-lineno="5">
                <td>5</td>
                <td>5</td>
                <td> </td>
                <td><code>    year  int
</code></td>
            </tr><tr data-op="match" data-x-lineno="6" data-y-lineno="6">
                <td>6</td>
                <td>6</td>
                <td> </td>
                <td><code>}{
</code></td>
            </tr><tr data-op="match" data-x-lineno="7" data-y-lineno="7">
                <td>7</td>
                <td>7</td>
                <td> </td>
                <td><code>    {
</code></td>
            </tr><tr data-op="match" data-x-lineno="8" data-y-lineno="8">
                <td>8</td>
                <td>8</td>
                <td> </td>
                <td><code>        name: &#34;Freak Out!&#34;,
</code></td>
            </tr><tr data-op="match" data-x-lineno="9" data-y-lineno="9">
                <td>9</td>
                <td>9</td>
                <td> </td>
                <td><code>        year: 1966,
</code></td>
            </tr><tr data-op="match" data-x-lineno="10" data-y-lineno="10">
                <td>10</td>
                <td>10</td>
                <td> </td>
                <td><code>    },
</code></td>
            </tr><tr data-op="insert" data-y-lineno="11">
                <td></td>
                <td>11</td>
                <td>+</td>
                <td><code>    {
</code></td>
            </tr><tr data-op="insert" data-y-lineno="12">
                <td></td>
                <td>12</td>
                <td>+</td>
                <td><code>        name: &#34;Absolutely Free&#34;,
</code></td>
            </tr><tr data-op="insert" data-y-lineno="13">
                <td></td>
                <td>13</td>
                <td>+</td>
                <td><code>        year: 1967,
</code></td>
            </tr><tr data-op="insert" data-y-lineno="14">
                <td></td>
                <td>14</td>
                <td>+</td>
                <td><code>    },
</code></td>
            </tr><tr data-op="match" data-x-lineno="11" data-y-lineno="15">
                <td>11</td>
                <td>15</td>
                <td> </td>
                <td><code>    {
</code></td>
            </tr><tr data-op="match" data-x-lineno="12" data-y-lineno="16">
                <td>12</td>
                <td>16</td>
                <td> </td>
                <td><code>        name: &#34;We&#39;re Only in It for the Money&#34;,
</code></td>
            </tr><tr data-op="match" data-x-lineno="13" data-y-lineno="17">
                <td>13</td>
                <td>17</td>
                <td> </td>
                <td><code>        year: 1967,
</code></td>
            </tr><tr data-op="match" data-x-lineno="14" data-y-lineno="18">
                <td>14</td>
                <td>18</td>
                <td> </td>
                <td><code>    },
</code></td>
            </tr><tr data-op="match" data-x-lineno="15" data-y-lineno="19">
                <td>15</td>
                <td>19</td>
                <td> </td>
                <td><code>}</code></td>
            </tr></tbody>
</table>
<p>If we eagerly consume the common prefix first and then the common suffix, the first 11 lines are
all identical and the so are the last 4. This in turn would result in a different diff:</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_05_strip_common_prefix_and_suffix.diff">example_05_strip_common_prefix_and_suffix.diff</a>
</caption>
<tbody><tr data-op="match" data-x-lineno="1" data-y-lineno="1">
                <td>1</td>
                <td>1</td>
                <td> </td>
                <td><code>package array
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="2">
                <td>2</td>
                <td>2</td>
                <td> </td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="3">
                <td>3</td>
                <td>3</td>
                <td> </td>
                <td><code>var m = []struct{
</code></td>
            </tr><tr data-op="match" data-x-lineno="4" data-y-lineno="4">
                <td>4</td>
                <td>4</td>
                <td> </td>
                <td><code>    name  string
</code></td>
            </tr><tr data-op="match" data-x-lineno="5" data-y-lineno="5">
                <td>5</td>
                <td>5</td>
                <td> </td>
                <td><code>    year  int
</code></td>
            </tr><tr data-op="match" data-x-lineno="6" data-y-lineno="6">
                <td>6</td>
                <td>6</td>
                <td> </td>
                <td><code>}{
</code></td>
            </tr><tr data-op="match" data-x-lineno="7" data-y-lineno="7">
                <td>7</td>
                <td>7</td>
                <td> </td>
                <td><code>    {
</code></td>
            </tr><tr data-op="match" data-x-lineno="8" data-y-lineno="8">
                <td>8</td>
                <td>8</td>
                <td> </td>
                <td><code>        name: &#34;Freak Out!&#34;,
</code></td>
            </tr><tr data-op="match" data-x-lineno="9" data-y-lineno="9">
                <td>9</td>
                <td>9</td>
                <td> </td>
                <td><code>        year: 1966,
</code></td>
            </tr><tr data-op="match" data-x-lineno="10" data-y-lineno="10">
                <td>10</td>
                <td>10</td>
                <td> </td>
                <td><code>    },
</code></td>
            </tr><tr data-op="match" data-x-lineno="11" data-y-lineno="11">
                <td>11</td>
                <td>11</td>
                <td> </td>
                <td><code>    {
</code></td>
            </tr><tr data-op="insert" data-y-lineno="12">
                <td></td>
                <td>12</td>
                <td>+</td>
                <td><code>        name: &#34;Absolutely Free&#34;,
</code></td>
            </tr><tr data-op="insert" data-y-lineno="13">
                <td></td>
                <td>13</td>
                <td>+</td>
                <td><code>        year: 1967,
</code></td>
            </tr><tr data-op="insert" data-y-lineno="14">
                <td></td>
                <td>14</td>
                <td>+</td>
                <td><code>    },
</code></td>
            </tr><tr data-op="insert" data-y-lineno="15">
                <td></td>
                <td>15</td>
                <td>+</td>
                <td><code>    {
</code></td>
            </tr><tr data-op="match" data-x-lineno="12" data-y-lineno="16">
                <td>12</td>
                <td>16</td>
                <td> </td>
                <td><code>        name: &#34;We&#39;re Only in It for the Money&#34;,
</code></td>
            </tr><tr data-op="match" data-x-lineno="13" data-y-lineno="17">
                <td>13</td>
                <td>17</td>
                <td> </td>
                <td><code>        year: 1967,
</code></td>
            </tr><tr data-op="match" data-x-lineno="14" data-y-lineno="18">
                <td>14</td>
                <td>18</td>
                <td> </td>
                <td><code>    },
</code></td>
            </tr><tr data-op="match" data-x-lineno="15" data-y-lineno="19">
                <td>15</td>
                <td>19</td>
                <td> </td>
                <td><code>}</code></td>
            </tr></tbody>
</table>
<p>Fortunately, this is easy to fix in post processing.</p>
<p>Much more impactful, but only efficiently possible for <code>comparable</code> types, is to remove all elements
that are unique to either the left side or the right side, as those must always be deletions or
insertions. Non-<code>comparable</code> types can&#39;t be keys in a hash map in Go, which is necessary for
checking uniqueness. This preprocessing step <a href="https://github.com/znkr/diff/commit/37b4470eeb45867adcae1581907770041326e1b5">reduced the runtime by up to
99%</a> for a few
real-world worst-case diffs.</p>
<p>In contrast to the suffix and prefix removal, stripping unique elements doesn&#39;t have any readability
impact.</p>
<h4 id="heuristics">Heuristics<a href="#heuristics"></a></h4>
<p>Another very impactful way to improve the performance is <em>Anchoring</em>. It is based on <a href="https://bramcohen.livejournal.com/73318.html">patience
diff</a>. The word patience is a bit misleading, because
it&#39;s too easily associated with having to wait and it doesn&#39;t describe the heuristic very well
either. It works by finding elements that are occur exactly once on both the left and the right
side. When we matching up these unique pairs we create a segmentation of the input into smaller
parts that can be analyzed individually. Even better, we&#39;re very likely to find matching lines atop
and below such a pair of unique elements. This allows us to shrink the segments by stripping common
prefixes and suffixes. This heuristic <a href="https://github.com/znkr/diff/commit/feb7bda337f269935d80ee18e703e0940f406873">reduced the runtime by up to
95%</a>. Unfortunately,
finding unique elements and matching them up requires a hash map again which means that it can only
be used for <code>comparable</code> types.</p>
<p>There are two more heuristics that are I implemented. They help for non-<code>comparable</code> types and as a
backstop when the other heuristics don&#39;t work. Their main purpose is to avoid runaway quadratic
growth. The <em>Good Diagonal</em> heuristic stops searching for a better solution if we found a solution
that&#39;s good enough and the <em>Too Expensive</em> heuristic shortcuts the search if it becomes too
expensive which reduces the worst-case complexity from 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <msup>
        <mi>N</mi>
        <mn>2</mn>
      </msup>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N^2)</annotation>
  </semantics>
</math>
 to

<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics>
    <mrow>
      <mi>𝒪︀</mi>
      <mo form="prefix" stretchy="false">(</mo>
      <msup>
        <mi>N</mi>
        <mn>1.5</mn>
      </msup>
      <mspace width="0.17em"></mspace>
      <mi lspace="0.11111em">log</mi>
      <mspace width="0.17em"></mspace>
      <mi>N</mi>
      <mo form="postfix" stretchy="false">)</mo>
    </mrow>
    <annotation encoding="application/x-tex">\mathcal{O}(N^1.5 \, \log \, N)</annotation>
  </semantics>
</math>
.</p>
<p>However, heuristics like this trade diff minimality for performance, this is not always desirable.
Sometimes, a minimal diff is exactly what&#39;s required.
<a href="https://pkg.go.dev/znkr.io/diff#Optimal"><code>diff.Optimal</code></a> disables these heuristics to always find a
minimal diff irrespective of the costs.</p>
<h4 id="post-processing">Post-processing<a href="#post-processing"></a></h4>
<p>We established before that a diff algorithm finds one of many possible solutions. Given such a
solution we can discover more solutions by it locally and then selecting the best solution according
to some metric. This is exactly how <a href="https://github.com/mhagger">Michael Haggerty&#39;s</a> indentation
heuristic works for text.</p>
<p>For any given diff, we can often slide the edits up or down in a way that doesn&#39;t change the meaning
of a diff. For example,</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_06.diff">example_06.diff</a>
</caption>
<tbody><tr data-op="match" data-x-lineno="1" data-y-lineno="1">
                <td>1</td>
                <td>1</td>
                <td> </td>
                <td><code>[&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;].map do |i|
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>  i
</code></td>
            </tr><tr data-op="insert" data-y-lineno="3">
                <td></td>
                <td>3</td>
                <td>+</td>
                <td><code>end
</code></td>
            </tr><tr data-op="insert" data-y-lineno="4">
                <td></td>
                <td>4</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="insert" data-y-lineno="5">
                <td></td>
                <td>5</td>
                <td>+</td>
                <td><code>[&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;].map do |i|
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="6">
                <td>2</td>
                <td>6</td>
                <td> </td>
                <td><code>  i.upcase
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="7">
                <td>3</td>
                <td>7</td>
                <td> </td>
                <td><code>end
</code></td>
            </tr></tbody>
</table>
<p>has the same meaning as</p>
<table>
<caption>
    <a href="https://github.com/znkr/flo.znkr.io/tree/main/site/diff/example_06_indent_heuristic.diff">example_06_indent_heuristic.diff</a>
</caption>
<tbody><tr data-op="insert" data-y-lineno="1">
                <td></td>
                <td>1</td>
                <td>+</td>
                <td><code>[&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;].map do |i|
</code></td>
            </tr><tr data-op="insert" data-y-lineno="2">
                <td></td>
                <td>2</td>
                <td>+</td>
                <td><code>  i
</code></td>
            </tr><tr data-op="insert" data-y-lineno="3">
                <td></td>
                <td>3</td>
                <td>+</td>
                <td><code>end
</code></td>
            </tr><tr data-op="insert" data-y-lineno="4">
                <td></td>
                <td>4</td>
                <td>+</td>
                <td><code>
</code></td>
            </tr><tr data-op="match" data-x-lineno="1" data-y-lineno="5">
                <td>1</td>
                <td>5</td>
                <td> </td>
                <td><code>[&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;].map do |i|
</code></td>
            </tr><tr data-op="match" data-x-lineno="2" data-y-lineno="6">
                <td>2</td>
                <td>6</td>
                <td> </td>
                <td><code>  i.upcase
</code></td>
            </tr><tr data-op="match" data-x-lineno="3" data-y-lineno="7">
                <td>3</td>
                <td>7</td>
                <td> </td>
                <td><code>end</code></td>
            </tr></tbody>
</table>
<p>We call edits that can be slid up or down <em>sliders</em>. The question is, how do we select the best
slide? Michael collected human ratings for different sliders of the same diff and used them to
develop a heuristic to match these ratings:
<a href="https://github.com/mhagger/diff-slider-tools">diff-slider-tools</a>.</p>
<p>However, this heuristic only works for text and is tuned towards code instead of prose. I decided to
make it optional. It can be enabled with the
<a href="https://pkg.go.dev/znkr.io/diff/textdiff#IndentHeuristic"><code>textdiff.IndentHeuristic</code></a> option.</p>
<h4 id="diff-representation">Diff Representation<a href="#diff-representation"></a></h4>
<p>The representation used during the execution of the diff algorithm has a surprising impact on the
algorithm performance and result readability. This is not at all obvious, and so it took me a while
to figure out that the best approach is akin to a side-by-side view of a diff: You use two <code>[]bool</code>
slices to represent the left side and the right side respectively: <code>true</code> in the left side slice
represents a deletion and on the right side an insertion. <code>false</code> is a matching element.</p>
<p>This representation has four big advantages: It can be preallocated, the order in which edits are
discovered doesn&#39;t matter, it&#39;s easy to mutate during post-processing, and it&#39;s easy to generate
other representations from it.</p>
<h2 id="open-questions">Open Questions<a href="#open-questions"></a></h2>
<ul>
<li>What exactly is the reason that two different algorithms produce different results? - I looked
into this question a little, but I haven&#39;t found a conclusive answer yet.</li>
</ul>
<h2 id="conclusion-1">Conclusion<a href="#conclusion-1"></a></h2>
<p>Diff algorithms are relatively complicated by themselves, but they pale in comparison  to what&#39;s
necessary to provide a high-quality diff library. This article tries to explain what went into
my new diff library, but there&#39;s still more that I haven&#39;t implemented yet.</p>


        </div></div>
  </body>
</html>
