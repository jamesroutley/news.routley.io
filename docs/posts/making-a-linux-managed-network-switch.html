<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.brixit.nl/making-a-linux-managed-network-switch/">Original</a>
    <h1>Making a Linux-managed network switch</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
                
    <div>
        <article>
            

            
                <figure>
                    <img srcset="/image/w300//static/files/blog.brixit.nl/1720007444/20240703_0031.jpg 300w,
                         /image/w600//static/files/blog.brixit.nl/1720007444/20240703_0031.jpg 600w,
                         /image/w1000//static/files/blog.brixit.nl/1720007444/20240703_0031.jpg 1000w,
                         /image/w2000//static/files/blog.brixit.nl/1720007444/20240703_0031.jpg 2000w" sizes="(max-width: 1000px) 400px, 700px" src="https://jesusgollonet.com/image/w2000//static/files/blog.brixit.nl/1720007444/20240703_0031.jpg" loading="lazy" alt="Making a Linux-managed network switch"/>
                </figure>
            
            <section>
                <div>
                    <p>Network switches are simple devices, packets go in, packets go out. Luckily people have figured out how to make it complicated instead and invented managed switches.</p>

<p>Usually this is done by adding a web-interface for configuring the settings and see things like port status. If you have more expensive switches then you&#39;d even get access to some alternate interfaces like telnet and serial console ports.</p>

<p>There is a whole second category of managed switches though that people don&#39;t initially think of. These are the network switches that are inside consumer routers. These routers are little Linux devices that have a switch chip inside of them, one or more ports are internally connected to the CPU and the rest are on the outside as physical ports.</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1719959978/RB2011UiAS-160620170256_160656.png"/><figcaption>Mikrotik RB2011 block diagram from mikrotik.com</figcaption></figure>

<p>Here is an example of such a device that actually has this documented. I always thought that the configuration of these switch connected ports was just a nice abstraction by the webinterface but I was suprised to learn that with the DSA and switchdev subsystem in Linux these ports are actually fully functioning &#34;local&#34; network ports. Due to this practically only being available inside integrated routers It&#39;s pretty hard to play around with unfortunately.</p>

<p>What is shown as a single line on this diagram is actually the connection of the SoC of the router and the switch over the SGMII bus (or maybe RGMII in this case) and a management bus that&#39;s either SMI or MDIO. Network switches have a lot of these fun acronyms that even with the full name written out make little sense unless you know how all of this  fits together.</p>

<p>Controlling your standard off-the-shelf switch using this system simply isn&#39;t possible because the required connections of  the switch chip aren&#39;t exposed for this. So there&#39;s only one option left...</p>

<h2>Making my own gigabit network switch</h2>

<p>Making my own network switch can&#39;t be <i>that</i> hard right? Those things are available for the price of a cup of coffee and are most likely highly integrated to reach that price point. Since I don&#39;t see any homemade switches around on the internet I guess the chips for those must be pretty hard to get...</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1719960715/image.png"/></figure>

<p>Nope, very easy to get. There&#39;s even a datasheet available for these. So I created a new KiCad project and started creating some footprints and symbols.</p>

<p>I&#39;m glad there&#39;s any amount of datasheet available for this chip since that&#39;s not usually the case for Realtek devices, but it&#39;s still pretty minimal. I resorted to finding any devices that has schematics available for similar Realtek chips to find out how to integrate it and looking at a lot of documentation for how to implement ethernet in a design at all.</p>

<p>The implementation for the chip initially looked very complicated, there&#39;s about 7 different power nets it requires and there are several pretty badly documented communication interfaces. After going through other implementations it seem like the easiest way to power it is just connect all the nets with overlapping voltage ranges together and you&#39;re left with only needing a 3.3V and 1.1V regulator.</p>

<p>The extra communication busses are for all the extra ports I don&#39;t seem to need. The switch chip I selected is the RTL8367S which is a very widely used 5-port gigabit switch chip, but it&#39;s actually not a 5-port chip. It&#39;s a 7 port switch chip where 5 ports have an integrated PHY and two are for CPU connections.</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1719961532/image.png"/><figcaption>CPU connection block diagram from the RTL8367S datasheet</figcaption></figure>

<p>My plan is different though, while there are these CPU ports available there is actually nothing in the Linux switchdev subsystem that requires the CPU connection to be to those ports. Instead I&#39;ll be connecting to port 0 on the switch with a network cable and as far  as the switchdev driver knows there&#39;s no ethernet PHY in between.</p>

<p>The next hurdle is the configuration of the switch chip, there&#39;s several configuration systems available and the datasheet does not really describe what is the minimum required setup to actually get it to function as a regular dumb switch. To sum up the configuration options of the chip:</p>

<ul><li>There&#39;s 8 pins on the chip that are read when it&#39;s starting up. These pins are shared with the led pins for the ports so that makes designing pretty annoying. Switching the setting from pull-up to pull-down also requires the led to be connected in the different orientation.</li>
<li>There&#39;s an i2c bus that can be connected to an eeprom chip. The pins for this are shared with the SMI bus that I require to make this chip talk to Linux though. There is pin configuration to select from one of two eeprom size ranges but does not further specify what this setting actually changes.</li>
<li>There&#39;s a SPI bus that supports connecting a NOR flash chip to it. This can store either configuration registers or firmware for the embedded 8051 core depending on the configuration of the bootup pins. The SPI bus pins are also shared with one of the CPU network ports.</li>
<li>There is a serial port available but from what I guess it probably does nothing at all unless there&#39;s firmware loaded in the 8051.</li>
</ul>

<p>My solution to figuring out is to just order a board and solder connections differently until it works. I&#39;ve added a footprint for a flash chip that I ended up not needing and for all the configuration pins I added solder jumpers. I left out all the leds since making that configurable would be pretty hard.</p>

<p>The next step is figuring out how to do ethernet properly. There has been a lot of documentation written about this and they all make it sound like gigabit ethernet requires perfect precision engineering, impedance managed boards and a blessing from the ethernet gods themselves to work. This does not seem to match up with the reality that these switches are very very cheaply constructed and seem to work just fine. So I decided to open up a switch to check how many of these coupling capacitors and impedance matching planes are actually used in a real design. The answer seems to be that it doesn&#39;t matter that much.</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1719962591/image.png"/></figure>

<p>This is the design I have ended up with now but it is not what is on my test PCB. I got it almost right the first time though :D</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1719962813/image.png"/></figure>

<p>The important parts seem to be matching the pair skew but matching the length of the 4 network pairs is completely useless, this is mainly because network cables don&#39;t have the same twisting rate for the 4 pairs and so the length of these are already significantly different inside the cable.</p>

<p>The pairs between the transformer and the RJ45 jack has it&#39;s own ground plane that&#39;s coupled to the main ground through a capacitor. The pairs after the transformer are  just on the main board ground fill.</p>

<p>What I did wrong on my initial board revision was forgetting the capacitor that connects the center taps of the transformer on the switch side to ground making the signals on that side referenced to board ground. This makes ethernet very much not work anymore so I had to manually cut tiny traces on the board to disconnect that short to ground. In my test setup the capacitor just doesn&#39;t exist and all the center taps float. This seems to work just fine but the final design does have that capacitor added.</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1720003020/fixed.JPG"/><figcaption>Cut ground traces on the ethernet transformer</figcaption></figure>

<p>The end result is this slightly weird gigabit switch. It has 4 ports facing one direction and one facing backwards and it is powered over a 2.54mm pinheader. I have also added a footprint for a USB Type-C connector to have an easy way to power it without bringing out the DuPont wires.</p>

<figure><img src="https://jesusgollonet.com/image/w1000//static/files/blog.brixit.nl/1720007603/IMG_20240626_221246.jpg"/></figure>

<h2>Connecting it to Linux</h2>

<p>For my test setup I&#39;ve picked the PINE64 A64-lts board since it has the connectors roughly in the spots where I want them. It not being an x86 platform is also pretty important because configuration requires a device tree change, can&#39;t do that on a platform that doesn&#39;t use device trees.</p>

<p>The first required thing was rebuilding the kernel for the board since most kernels simply don&#39;t have these kernel modules enabled. For this I enabled these options:</p>

<ul><li><code>CONFIG_NET_DSA</code> for the Distributed Switch Architecture system</li>
<li><code>CONFIG_NET_DSA_TAG_RTL8_4</code> for having port tagging for this Realtek switch chip</li>
<li><code>CONFIG_NET_SWITCHDEV</code> the driver system for network switches</li>
<li><code>CONFIG_NET_DSA_REALTEK</code>, <code>CONFIG_NET_DSA_REALTEK_SMI</code>, <code>CONFIG_NET_DSA_REALTEK_RTL8365MB</code> for the actual switch chip driver</li>
</ul>

<p>Then the more complicated part was figuring out how to actually get this all loaded. In theory it is possible to create a device tree overlay for this and get it loaded by U-Boot. I decided to not do that and patch the device tree for the A64-lts board instead since I&#39;m rebuilding the kernel anyway. The device tree change I ended up with is this:</p>

<pre><code>diff --git a/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-lts.dts b/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-lts.dts
index 596a25907..10c1a5187 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-lts.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-a64-pine64-lts.dts
@@ -18,8 +18,78 @@ led {
 			gpios = &lt;&amp;r_pio 0 7 GPIO_ACTIVE_LOW&gt;; /* PL7 */
 		};
 	};
+
+switch {
+	compatible = &#34;realtek,rtl8365rb&#34;;
+	mdc-gpios = &lt;&amp;pio 2 5 GPIO_ACTIVE_HIGH&gt;; // PC5
+	mdio-gpios = &lt;&amp;pio 2 7 GPIO_ACTIVE_HIGH&gt;; // PC7
+	reset-gpios = &lt;&amp;pio 8 5 GPIO_ACTIVE_LOW&gt;; // PH5
+	realtek,disable-leds;
+
+	mdio {
+		compatible = &#34;realtek,smi-mdio&#34;;
+		#address-cells = &lt;1&gt;;
+		#size-cells = &lt;0&gt;;
+
+		ethphy0: ethernet-phy@0 {
+			reg = &lt;0&gt;;
+		};
+
+		ethphy1: ethernet-phy@1 {
+			reg = &lt;1&gt;;
+		};
+
+		ethphy2: ethernet-phy@2 {
+			reg = &lt;2&gt;;
+		};
+
+		ethphy3: ethernet-phy@3 {
+			reg = &lt;3&gt;;
+		};
+
+		ethphy4: ethernet-phy@4 {
+			reg = &lt;4&gt;;
+		};
+	};
+
+	ports {
+		#address-cells = &lt;1&gt;;
+		#size-cells = &lt;0&gt;;
+
+		port@0 {
+			reg = &lt;0&gt;;
+			label = &#34;cpu&#34;;
+			ethernet = &lt;&amp;emac&gt;;
+		};
+
+		port@1 {
+			reg = &lt;1&gt;;
+			label = &#34;lan1&#34;;
+			phy-handle = &lt;&amp;ethphy1&gt;;
+		};
+
+		port@2 {
+			reg = &lt;2&gt;;
+			label = &#34;lan2&#34;;
+			phy-handle = &lt;&amp;ethphy2&gt;;
+		};
+
+		port@3 {
+			reg = &lt;3&gt;;
+			label = &#34;lan3&#34;;
+			phy-handle = &lt;&amp;ethphy3&gt;;
+		};
+
+		port@4 {
+			reg = &lt;4&gt;;
+			label = &#34;lan4&#34;;
+			phy-handle = &lt;&amp;ethphy4&gt;;
+		};
+	};
+};
 };
 </code></pre>

<p>It loads the driver for the switch with the <code>realtek,rtl8365rb</code>, this driver supports a whole range of Realtek switch chips including the RTL8367S I&#39;ve used in this design. I&#39;ve removed the CPU ports from the documentation example and just added the definitions of the 5 regular switch ports.</p>

<p>The important part is in <code>port@0</code>, this is the port that is facing backwards on my switch and is connected to the A64-lts, I&#39;ve linked it up to <code>&amp;emac</code> which is a reference to the ethernet port of the computer.  The rest of the ports are  linked up to their respective PHYs in the switch chip. </p>

<p>In the top of the code there&#39;s also 3 GPIOs defined, these link up to SDA/SCL and Reset on the switch PCB to make the communication work. After booting up the system the result is this:</p>

<pre><code>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1508 qdisc noop state DOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
3 lan1@eth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
4 lan2@eth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
5 lan3@eth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
6 lan4@eth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff</code></pre>

<p>I have the <code>eth0</code> device here like normal and then I have the 4 interfaces for the ports on the switch I defined in the device tree. To make it actually do something the interfaces actually need to be brought online first:</p>

<pre><code>$ ip link set eth0 up
$ ip link set lan1 up
$ ip link set lan2 up
$ ip link set lan3 up
$ ip link set lan4 up
$ ip link
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1508 qdisc mq state UP qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
3: lan1@eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
4: lan2@eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
5: lan3@eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff
6: lan4@eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN qlen 1000
    link/ether 02:ba:6f:0c:21:c4 brd ff:ff:ff:ff:ff:ff</code></pre>

<p>Now the switch is up you can see I have a cable plugged into the third port. This system hooks into a lot of the Linux networking so it Just Works(tm) with a lot of tooling. Some examples:</p>

<ul><li>Add a few of the lan ports into a standard Linux bridge and the switchdev system will bridge those ports together in the switch chip so Linux doesn&#39;t have to forward that traffic.</li>
<li>Thinks like <code>ethtool lan3</code> just work to get information about the link. and with <code>ethtool -S lan3</code> all the standard status return info which includes packets that have been fully handled by the switch.</li>
</ul>

<h2>Limitations</h2>

<p>There&#39;s a few things that makes this not very nice to work with. First of all the requirement of either building a custom network switch or tearing open an existing one and finding the right connections. </p>

<p>It&#39;s not really possible  to use this system on regular computers/servers since you need device trees to configure the kernel for this and most computers don&#39;t have kernel-controlled GPIO pins available to hook up a switch.</p>

<p>As far as I can find there&#39;s also no way to use this with a network port on the computer side that&#39;s not fixed, USB network interfaces don&#39;t have a device tree node handle to refer to to set the conduit port.</p>

<p>There is a chance some of these limitations are possible to work around, maybe there&#39;s some weird USB device that exposes pins on the GPIO subsystem, maybe there&#39;s a way to load switchdev without being on an ARM device but that would certainly take a bit more documentation...</p>


                </div>
            </section>
        </article>
    </div>

            </div></div>
  </body>
</html>
