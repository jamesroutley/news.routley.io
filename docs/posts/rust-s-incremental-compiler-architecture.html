<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/997784/">Original</a>
    <h1>Rust&#39;s Incremental Compiler Architecture</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
The traditional structure of a compiler forms a pipeline — parsing,
type-checking, optimization, and code-generation, usually in that order. But
modern programming languages have requirements that are ill-suited to such a
design. Increasingly, compilers are moving toward other designs in
order to support incremental compilation and low-latency responses for uses
like integration into IDEs. Rust has, for the last eight years, been pursuing a
particularly unusual design; in that time
compile times have
<a href="https://perf.rust-lang.org/dashboard.html">
substantially improved</a>, but there&#39;s still more work to be done.
</p>

<p>
In a traditional compiler, normally each step of the pipeline needs to complete before
the next is started. For example, optimization must complete before the
compiler can begin emitting machine code. There are ways to improve this —
working on translation units in parallel, caching some kinds of analysis, etc. — but, at a
certain point, the architectures of the compilers themselves make it difficult to
make the code support incremental compilation.
</p>

<p>
Language design can influence how much of a problem this is in practice. For
example, while the GCC developers did
<a href="https://gcc.gnu.org/wiki/IncrementalCompiler">
look into</a> making the compiler incremental, the fact that C defines each file
as a stand-alone translation unit makes it easier to add incrementalism at the
level of the build system. Many modern languages don&#39;t observe the same
separation between files, however. In Rust, an entire crate is a single
translation unit; cargo, Rust&#39;s build system, handles only recompiling changed
crates, but adding incrementalism within a crate requires special support from
the compiler.
</p>

<p>
So, in response to wishes for faster compile times,
Rust has been exploring an alternative to the
traditional structure of a compiler by switching to a query-based model:
instead of having a fixed pipeline, the compiler has a set of queries
for different properties of the program.
Each query can either retrieve the answer from a persistent compilation
database, or, if the answer has not yet
been cached, calculate it from scratch by making other queries and combining
their results. For example, the compiler uses the
<a href="https://github.com/rust-lang/rust/blob/a00df61387e5389d6fe23e38e657f90d672668b1/compiler/rustc_hir_analysis/src/collect/type_of.rs#L387">
<tt>type_of()</tt></a> query to infer the types of local bindings. The query takes
the ID of a local definition, and then calls other queries to determine whether
it is an <tt>impl Trait</tt> type, what the abstract syntax tree of the
definition is, what the types of the variables it refers to are, and so on.
</p>

<p>
Suppose that the programmer changes the type of a constant in their crate. When
they run the compiler, it will evaluate a top-level query to produce an output
binary. That query will in turn query for the final versions of each function in
the crate (after type-checking and optimization). Most of those will not have
changed, so the answers are provided from the on-disk compilation database. The
queries for functions that depend on the changed constant, however, will get
re-run — and will, themselves, call other queries until the whole process ends
up at the query corresponding to the parsed representation of the
single changed definition. Only the minimum
amount of analysis and compilation needed to accommodate that change is performed.
</p>

<p>
This approach is reminiscent of a build system — and that&#39;s deliberate. Build
systems, while not always perfect, usually do a good job of tracking the
dependencies between components and correctly caching partial results. A
compiler that has the architecture of a build system can take advantage of the
research that has been done on build systems to do the same.
</p>

<h4>Rust&#39;s approach</h4>

<p>
The Rust project began the process of rewriting its compiler to
<a href="https://blog.rust-lang.org/2016/09/08/incremental.html">
support
incremental compilation</a>
in 2016. While that redesign is not yet fully complete, large portions of
the compiler now use a query-based approach. LWN
<a href="https://lwn.net/Articles/995125/">
recently covered</a> Sparrow Li&#39;s
talk that discussed what remains to be done.
</p>

<p>
The Rust compiler organizes queries using a structure called
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html">
<tt>TyCtxt</tt></a>. When the compiler starts up, the various modules all
register functions called &#34;providers&#34; that implement each query. Then,
depending on how the compiler was invoked, it parses the code (because the
parser has not yet been integrated into the query system) and runs a set of top-level queries to
compile an artifact, format the code, produce warnings, or whatever else was
requested.
</p>

<p>
Providers need to be
<a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>, since
the compiler may not always need to run them, so the programmer
can&#39;t depend on any side effects. This also has the effect of forcing those
parts of the compiler that have been converted to the query system to avoid
global state. The results of queries could in theory be any type, but in
practice the compiler requires that they be values that can be cheaply copied, in order
to simplify the ownership of cached values. Not every query is saved
to disk, but most queries return types that can be serialized and hashed, so
that they can be.
</p>

<p>
There are some important differences in structure between Rust&#39;s queries and
static build systems like
<a href="https://www.gnu.org/software/make/">
Make</a>, not just in the form that their results take.
In Rust&#39;s implementation, the relationship
between queries is implicit. Queries are always invoked via a <tt>TyCtxt</tt>;
that structure can track the dependencies between queries by seeing which
queries are invoked while another is executing. Also, unlike some build systems,
the compiler tracks the <em>order</em> in which dependencies are invoked. This
is important because the results of one query can change which other queries get
executed — therefore, the order impacts the calculation of which queries need to
be rerun when doing incremental compilation. For example, this query depends on
different things depending on the result of <tt>subquery1()</tt>:
</p>

<pre>    fn example_query&lt;&#39;tcx&gt;(tcx: TyCtxt&lt;&#39;tcx&gt;) -&gt; SomeType {
        if tcx.subquery1() {
            tcx.subquery2()
        } else {
            tcx.subquery3()
        }
    }
</pre>

<p>
During the initial run of the compiler, when there are no saved results, the
program collects the graph of which queries refer to each other. When the
compiler is rerun, it checks that graph to see which queries need to be rerun
because of changed inputs. As an additional optimization, if the inputs to a
query have changed, but the result of the query has not, the compiler can detect
that and cut off the process of recalculating queries early.
</p>

<p>
The process of figuring out whether an intermediate result has changed
is complicated by the fact that any information
about the incremental build needs to be shared between runs of the compiler by
saving it to disk. The compiler uses a lot of internal ID numbers to organize
different components that differ from run to run, and serializing
every intermediate result in the compiler would be expensive. So actually
saving the results of cached queries is more complex.
</p>

<p>
In order to work around the problem of changing internal IDs, structures that
are saved to disk are given &#34;stable&#34; forms of each ID. For example, function and
type definitions are identified by path (e.g.
<tt>std::collections::HashMap</tt>) instead of by internal ID. In order to avoid
the overhead of deserializing intermediate results to detect changes,
the compiler calculates and stores hashes for each item. Hashes are much more
compact, and don&#39;t require complex deserialization, so this is a substantial
performance improvement. The downside is that computing so many hashes actually
causes significant overhead. The compiler&#39;s
<a href="https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation-in-detail.html">
internal documentation</a> calls it
&#34;<q>the main reason why incremental compilation can be slower than
non-incremental compilation.</q>&#34;
</p>

<p>
These performance improvements introduce their own complications, of course. For
example, if a result is never loaded from disk, the compiler won&#39;t necessarily
be able to include it in the incremental-compilation database for the
<em>next</em> run of the program. So, after generating results, the compiler
does another pass through the query graph to fetch and update the results that
it skipped earlier, in order to make sure that the size of the cache doesn&#39;t
unnecessarily shrink. This increases the compiler&#39;s overall runtime — but what
users usually care about is the time it takes to produce warnings and errors,
not how long it takes the compiler to do cleanup before exiting.
There are various other optimizations and tweaks applied
to the largest queries to make the overall system more performant. The Rust
Compiler Development Guide&#39;s
<a href="https://rustc-dev-guide.rust-lang.org/query.html">
section on the query system</a> has more details.
</p>

<p>
Overall, the query-based approach introduces a lot of complexity compared to a
simple pipeline-based approach. But any large, performance-sensitive codebase
accumulates complexity over time — and having a single, well-understood system
for incremental compilation may well win out over gradually introducing ad-hoc
improvements to a pipeline-based system. In any case, Rust&#39;s incremental
compilation has been stable enough to become the default for development builds.
Release builds still avoid incremental compilation by default, however, out of
an abundance of caution. Whether
the query-based compiler design will ultimately be adopted by other languages
remains to be seen.
</p></div></div>
  </body>
</html>
