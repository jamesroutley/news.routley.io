<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://xeiaso.net/blog/2025/yoke-k8s/">Original</a>
    <h1>Yoke: Infrastructure as code, but actually</h1>
    
    <div id="readability-page-1" class="page"><div>
            <article>
    
    
    <p>
        Published on <time datetime="2025-03-02">03/02/2025</time>, 3827 words, 14 minutes to read
    </p>

    
        <p>Infrastructure as code, but actually</p>
    

    
        
            
    

    

        
    

    
        <figure><picture><source type="image/avif" srcset="https://cdn.xeiaso.net/file/christine-static/hero/santa-cruz-seals.avif"/><source type="image/webp" srcset="https://cdn.xeiaso.net/file/christine-static/hero/santa-cruz-seals.webp"/><img alt="An image of A group of seals swimming in the ocean near Santa Cruz, California" loading="lazy" src="https://cdn.xeiaso.net/file/christine-static/hero/santa-cruz-seals.jpg"/></picture></figure>
        <small>A group of seals swimming in the ocean near Santa Cruz, California - Photo by Xe Iaso, Canon EOS R6 mk II, Helios 44-2 58mm f/2</small>
    

    <p>One of the biggest memes in site reliability is &#34;infrastructure as code&#34;. This is usually very well-intentioned, but there&#39;s one small problem:</p>
<pre><code><span><span>data <span>&#34;aws_route53_zone&#34;</span></span> <span>&#34;cetacean_club&#34;</span> <span>{</span>
</span><span>  <span>name</span> <span>=</span> <span>&#34;cetacean.club.&#34;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>resource <span>&#34;aws_route53_record&#34;</span></span> <span>&#34;A&#34;</span> <span>{</span>
</span><span>  <span>zone_id</span> <span>=</span> data.aws_route53_zone.cetacean_club.zone_id
</span><span>  <span>name</span>    <span>=</span> <span>&#34;ingressd.<span><span>$</span><span>{</span><span>data</span><span>.</span><span>aws_route53_zone</span><span>.</span>cetacean_club<span>.</span>name<span>}</span></span>&#34;</span>
</span><span>  <span>type</span>    <span>=</span> <span>&#34;A&#34;</span>
</span><span>  <span>ttl</span>     <span>=</span> <span>&#34;300&#34;</span>
</span><span>  <span>records</span> <span>=</span> <span>[</span>resource.vultr_instance.my_instance.main_ip<span>]</span>
</span><span><span>}</span>
</span></code></pre>
<p>This is not code. This is configuration. Sure you manage the configuration with the same tools you use to manage code, you can lint it like it is code, but it&#39;s not code. It&#39;s a fairly limited DSL that makes it easy to get infrastructure up and running. Let&#39;s say you create a new server and you want to add it to DNS. You have to declare the instance, then declare the DNS record using data from the instance.</p>
<div><p><img alt="Cadey is coffee" loading="lazy" src="https://stickers.xeiaso.net/sticker/cadey/coffee"/></p><div><p><span><a href="https://xeiaso.net/characters#cadey">Cadey</a></span><span></span></p><p>If you really do think that Terraform is code, then go try and make multiple
DNS records for each random instance ID based on a dynamic number of
instances. Correct me if I&#39;m wrong, but I don&#39;t think you can do that in
Terraform.</p></div></div>
<p>What if things were a bit more flexible? What if you could make a common &#34;dns_for_instance&#34; method and then use that everywhere?</p>
<p>This is the basic idea behind <a href="https://www.pulumi.com/">Pulumi</a>. Instead of managing your infrastructure using configuration files, you manage it in code. You can create helper functions that can be shared between projects and you can use the full power of whatever programming language you want to manage your infrastructure.</p>
<p>However, Pulumi has a few downsides:</p>
<ul>
<li>You have to install the language runtimes and dependencies for the language you&#39;re using</li>
<li>The code has to run on the server that&#39;s managing the infrastructure</li>
</ul>
<p>This sounds reasonable at first, but then you come to the shocking realization that code that runs on the host machine can do literally anything it wants. This means that if a dependency gets popped, your infrastructure is now compromised and likely has cryptocurrency miners running on it.</p>
<p>This is where <a href="https://yokecd.github.io/docs/">Yoke</a> comes in.</p>
<h2>Yoke: infrastructure as code, but actually</h2>
<p><a href="https://yokecd.github.io/docs/">Yoke</a> is a project that takes this basic idea to the next level. With Yoke, you write your infrastructure definitions in Go or Rust, compile it to WebAssembly, and then you take input and output Kubernetes manifests that get applied to the cluster.</p>
<div><div><p><img alt="Aoi is wut" loading="lazy" src="https://stickers.xeiaso.net/sticker/aoi/wut"/></p><div><p><span><a href="https://xeiaso.net/characters#aoi">Aoi</a></span><span></span></p><p>Wait, there&#39;s something here that I&#39;m not getting. Why are you compiling the code to WebAssembly instead of just running it directly on the server?</p></div></div><div><p><img alt="Numa is hacker" loading="lazy" src="https://stickers.xeiaso.net/sticker/numa/hacker"/></p><div><p><span><a href="https://xeiaso.net/characters#numa">Numa</a></span><span></span></p><div><p>Well, everything&#39;s a tradeoff. Let&#39;s imagine a world where you run the code on the server directly.</p><p>If you&#39;re using a language like Python, you need to have the Python runtime and any dependencies installed. This means you have to incur the famous wrath of pip (pip hell is a real place and you will go there without notice). If you&#39;re using a language like Go, you need to have either the Go compiler toolchain installed or prebuild binaries for every permutation of CPU architecture and OS that you want to run your infrastructure on. This doesn&#39;t scale well.</p><p>One of the main advantages of using WebAssembly here is that you can compile your code once and then run it anywhere that has a WebAssembly runtime, such as with the <code>yoke</code> CLI or with <a href="https://yokecd.github.io/docs/airtrafficcontroller/atc/">Air Traffic Controller</a>. This means that you can do your infrastructure applies on Windows, Linux, macOS, or even in a VM on your aarch64 MacBook without having to notice or care.</p><p>One of the main downsides of an approach like this is that WebAssembly binaries are not easy for users to introspect, meaning that you have to execute the code to see what it does. WebAssembly is a hard layer of sandboxing and Yoke doesn&#39;t expose any system calls to the host, but again this is a tradeoff between modeling infrastructure as actual code and the ability to introspect the shipped binaries.</p><p>Imagine if someone published a malicious dependency that somehow percolated into your infrastructure code. If you&#39;re running the code directly on your laptop or a server, there&#39;s basically no real way to easily sandbox that code; meaning that it can just steal your Bitcoin wallet, exfiltrate your SSH keys, or do literally whatever it wants. Modern operating systems are general-purpose and will do <em>exactly</em> what they are told. If you&#39;re running the code in a WebAssembly sandbox, you can be sure that it can&#39;t do anything malicious to your system because it literally does not have access to anything outside of the sandbox.</p><p>I guess an attacker could make a dependency that percolates up and causes a yoke flight to create a cryptocurrency miner in your cluster or something, but in the process it&#39;d probably break a lot of other things and it&#39;d be a pretty obvious attack.</p><p>I think that the tradeoff is worth it, even though it may limit the ability to share flights between users.</p></div></div></div></div>
<p>Think about Yoke flights as functions. They take in input and output Kubernetes resources. One of the big advantages of using WebAssembly here is that you can use the same Kubernetes manifest types that Kubernetes itself uses. This means you don&#39;t have to write your own types and you can reuse code aggressively. Here&#39;s an example bit of code that creates a Kubernetes <a href="https://kubernetes.io/docs/concepts/security/service-accounts/">ServiceAccount</a>:</p>
<div><p><img alt="Cadey is enby" loading="lazy" src="https://stickers.xeiaso.net/sticker/cadey/enby"/></p><div><p><span><a href="https://xeiaso.net/characters#cadey">Cadey</a></span><span></span></p><div><p>In this article, KubernetesTerms will be in JavaClassNameCase. If you&#39;re not sure what one of them is, search this in <a href="https://ddg.gg">DuckDuckGo</a>:</p><pre><code><span>site:kubernetes.io KubernetesTerm
</span></code></pre><p>Other things like the App CustomResourceDefinition are specific to my setup and you won&#39;t find them in the Kubernetes documentation.</p></div></div></div>
<pre><code><span><span>func</span> <span>createServiceAccount</span><span>(</span>app v1<span>.</span>App<span>)</span> <span>*</span>corev1<span>.</span>ServiceAccount <span>{</span>
</span><span>	<span>return</span> <span>&amp;</span>corev1<span>.</span>ServiceAccount<span>{</span>
</span><span>		TypeMeta<span>:</span> metav1<span>.</span>TypeMeta<span>{</span>
</span><span>			APIVersion<span>:</span> corev1<span>.</span>SchemeGroupVersion<span>.</span><span>Identifier</span><span>(</span><span>)</span><span>,</span>
</span><span>			Kind<span>:</span>       <span>&#34;ServiceAccount&#34;</span><span>,</span>
</span><span>		<span>}</span><span>,</span>
</span><span>		ObjectMeta<span>:</span> metav1<span>.</span>ObjectMeta<span>{</span>
</span><span>			Name<span>:</span>      app<span>.</span>Name<span>,</span>
</span><span>			Namespace<span>:</span> app<span>.</span>Namespace<span>,</span>
</span><span>			Labels<span>:</span>    app<span>.</span>Labels<span>,</span>
</span><span>		<span>}</span><span>,</span>
</span><span>    AutomountServiceAccountToken<span>:</span> ptr<span>.</span><span>To</span><span>(</span><span>true</span><span>)</span><span>,</span>
</span><span>	<span>}</span>
</span><span><span>}</span>
</span></code></pre>
<p>This is roughly the same thing as the following Helm template:</p>
<pre><code><span><span>{</span><span>{</span><span>-</span> if .Values.serviceAccount.create <span>-</span><span>}</span><span>}</span>
</span><span><span>apiVersion</span><span>:</span> v1
</span><span><span>kind</span><span>:</span> ServiceAccount
</span><span><span>metadata</span><span>:</span>
</span><span>  <span>name</span><span>:</span> <span>{</span><span>{</span> include &#34;simpleapp.serviceAccountName&#34; . <span>}</span><span>}</span>
</span><span>  <span>labels</span><span>:</span>
</span><span>    <span>{</span><span>{</span><span>-</span> include &#34;simpleapp.labels&#34; . <span>|</span> nindent 4 <span>}</span><span>}</span>
</span><span>  <span>{</span><span>{</span><span>-</span> with .Values.serviceAccount.annotations <span>}</span><span>}</span>
</span><span>  <span>annotations</span><span>:</span>
</span><span>    <span>{</span><span>{</span><span>-</span> toYaml . <span>|</span> nindent 4 <span>}</span><span>}</span>
</span><span>  <span>{</span><span>{</span><span>-</span> end <span>}</span><span>}</span>
</span><span><span>automountServiceAccountToken</span><span>:</span> <span>{</span><span>{</span> .Values.serviceAccount.automount <span>}</span><span>}</span>
</span><span><span>{</span><span>{</span><span>-</span> end <span>}</span><span>}</span>
</span></code></pre>
<p>Note the differences here:</p>
<ul>
<li>The Go code takes in variables and replaces values directly in the structs</li>
<li>The Helm template uses <a href="https://pkg.go.dev/text/template">text/template</a> to replace values in the YAML, and in order to make the YAML valid, you have to pass values to the <code>nindent</code> function to make sure that the YAML is properly indented</li>
<li>The Go code is type-checked by the Go compiler</li>
<li>The Helm template is not type-checked by anything until it is applied to the cluster, at which point it may be too late</li>
</ul>
<p>Admittedly, this is a super contrived simple example, but you can see how this can get way out of hand super quickly. The Go code looks terrible in comparison because all of the type names are verbose, but it is completely type-checked and you can be sure that it will work when you run it because the compiler will reject obviously invalid code.</p>
<div><p><img alt="Cadey is coffee" loading="lazy" src="https://stickers.xeiaso.net/sticker/cadey/coffee"/></p><div><p><span><a href="https://xeiaso.net/characters#cadey">Cadey</a></span><span></span></p><p>Note that type-checked is different than semantically correct. The Go compiler
can make sure that you are putting a string where the type wants a string, but
it can&#39;t stop you if you make something semantically invalid. For example, you
could create a ServiceAccount with the same name as another ServiceAccount in
the same namespace, which would cause a conflict when you try to apply the
manifest to the cluster.</p></div></div>
<p>Yoke is cool and all, but at a high level it&#39;s really just a slightly inconvenient way to write manifests in ways that make Helm look easier at first glance. However, they didn&#39;t stop there. They introduced a feature that honestly made me throw out Helm entirely: <a href="https://yokecd.github.io/docs/airtrafficcontroller/atc/">Air Traffic Control</a>.</p>
<h2>Air Traffic Control</h2>
<p>Air Traffic Control is a Kubernetes operator that has you define your infrastructure as CustomResourceDefinitions. The data in the CustomResource is passed into the Flight you associate with it, and the Flight generates the manifests that get applied to the cluster.</p>
<p>This is the part that really transformed Yoke from &#34;this is neat but I don&#39;t know where I&#39;d use it&#34; to &#34;this is the single thing that will make Yoke indispensable in my workflow&#34;.</p>
<p>The key difference between Air Traffic Control and other tools like Helm is that Helm largely operates on the side of your Kubernetes cluster. You run Helm to generate manifests that get applied to the cluster, but there&#39;s no real introspection into what Helm has done from inside the cluster. Sure, there are things like <a href="https://docs.k3s.io/helm">k3s&#39; HelmChart</a> resource that let you define Helm charts declaratively, but that&#39;s really not the same as having things be a native part of the cluster.</p>
<p>The big thing that this fixes is editor support for understanding your CustomResources (which function similar to Helm <code>values.yaml</code> files in practice). With the Kubernetes extensions I&#39;m using in my copy of VSCode, it&#39;s automatically imported the OpenAPI spec for the CustomResource types so I can get my editor&#39;s syntax highlighting, documentation, and autocompletion for free.</p>
<div><p><img alt="Mara is hacker" loading="lazy" src="https://stickers.xeiaso.net/sticker/mara/hacker"/></p><div><p><span><a href="https://xeiaso.net/characters#mara">Mara</a></span><span></span></p><p>-Wpedantic: this is possible with Helm using a plugin like <a href="https://marketplace.visualstudio.com/items?itemName=Tim-Koehler.helm-intellisense">Helm
Intellisense</a>
and <a href="https://austindewey.com/2020/06/13/helm-tricks-input-validation-with-values-schema-json/">defining a values json
schema</a>,
but the process requires manual intervention and upkeep. Air Traffic Control
does this automatically for you the moment you define your
CustomResourceDefinition.</p></div></div>
<p>To really understand where and when this can be useful, let&#39;s talk about how I&#39;ve been using Air Traffic Control to make deploying stuff to my clusters easier than it has ever been to deploy things at any job I&#39;ve ever had.</p>
<h3>My App CustomResourceDefinition</h3>
<p>When I deploy my own apps to Kubernetes, I generally follow a few common &#34;shapes&#34; for how they should be run:</p>
<ul>
<li>An internal web app that&#39;s exposed to the cluster with a Service</li>
<li>An external web app that&#39;s exposed to the internet with an Ingress</li>
<li>A worker app that doesn&#39;t need to be exposed</li>
<li>A web app that&#39;s exposed as a tor hidden service</li>
</ul>
<p>There&#39;s also a few common bits of configuration that I usually need:</p>
<ul>
<li>Persistent storage via a PersistentVolumeClaim (usually pointing to <a href="https://longhorn.io/">Longhorn</a> or <a href="https://tigrisdata.com">Tigris</a>)</li>
<li>The number of pod replicas</li>
<li>If the app should auto-update or not</li>
<li>The port the app listens on</li>
<li>If the app should run as root</li>
<li>The healthcheck route for the app</li>
<li>The log level for the app</li>
<li>Arbitrary environment variables for the app</li>
<li>Any Kubernetes role permissions for the app</li>
<li>Secrets from <a href="https://1password.com/">1Password</a> via <a href="https://github.com/1Password/onepassword-operator">the 1Password operator</a></li>
</ul>
<p>I&#39;ve been working on a <a href="https://github.com/Xe/x/tree/master/kube/helm/simpleapp"><code>simpleapp</code></a> chart to encode a lot of these common patterns, but it&#39;s been fairly annoying to use because I end up fighting Helm&#39;s templating system more than I end up using it to my advantage.</p>
<p>At some level, I&#39;m really just doing a pure transformation of data from one format (a brief set of configuration flags) to another (a set of Kubernetes manifests). This is where I felt like Yoke could really help.</p>
<p>So I did that. Here&#39;s an example from the manifest that powers <a href="https://stickers.xeiaso.net">the sticker server</a>:</p>
<pre><code><span><span>apiVersion</span><span>:</span> x.within.website/v1
</span><span><span>kind</span><span>:</span> App
</span><span><span>metadata</span><span>:</span>
</span><span>  <span>name</span><span>:</span> stickers
</span><span>
</span><span><span>spec</span><span>:</span>
</span><span>  <span>image</span><span>:</span> ghcr.io/xe/x/stickers<span>:</span>latest
</span><span>  <span>autoUpdate</span><span>:</span> <span>true</span>
</span><span>
</span><span>  <span>healthcheck</span><span>:</span>
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>
</span><span>  <span>ingress</span><span>:</span>
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>host</span><span>:</span> stickers.xeiaso.net
</span><span>
</span><span>  <span>secrets</span><span>:</span>
</span><span>    <span>-</span> <span>name</span><span>:</span> tigris<span>-</span>creds
</span><span>      <span>itemPath</span><span>:</span> <span>&#34;vaults/lc5zo4zjz3if3mkeuhufjmgmui/items/kvc2jqoyriem75ny4mvm6keguy&#34;</span>
</span><span>      <span>environment</span><span>:</span> <span>true</span>
</span></code></pre>
<p>That&#39;s it. Everything else is just ambiently created and deployed with Yoke. Here&#39;s all the resources this creates:</p>
<ul>
<li>The OnePasswordItem for the <code>tigris-creds</code> secret</li>
<li>The <code>tigris-creds</code> secret containing <a href="https://tigrisdata.com">Tigris</a> credentials to presign sticker URLs</li>
<li>The Deployment for the sticker server, listening on port 3000 (unless you override it with the <code>spec.port</code> field)</li>
<li>The Service for the sticker server, forwarding traffic from Service port 80 to the Deployment&#39;s port 3000</li>
<li>An Ingress pointing to port 80 on the Service, with the hostname <code>stickers.xeiaso.net</code></li>
<li>A <a href="https://cert-manager.io/">cert-manager</a> Certificate for <code>stickers.xeiaso.net</code> that gets automatically renewed</li>
<li>DNS records for <code>stickers.xeiaso.net</code> pointing to the Ingress</li>
</ul>
<p>This is a huge improvement over the previous state of things. I got to remove over 150 lines of YAML (that let&#39;s be real, I copy-pasted from another manifest in the same repo) and replaced it with a single deterministic program that just does what I want.</p>
<p>Most of the features of the App CustomResource are off by default, but here&#39;s an example showing everything off at once:</p>
<details><summary>Click to expand</summary><pre><code><span><span>apiVersion</span><span>:</span> x.within.website/v1
</span><span><span>kind</span><span>:</span> App
</span><span><span>metadata</span><span>:</span>
</span><span>  <span>name</span><span>:</span> maximum<span>-</span>settings
</span><span>
</span><span><span>spec</span><span>:</span>
</span><span>  <span>autoUpdate</span><span>:</span> <span>true</span> 
</span><span>  <span>image</span><span>:</span> ghcr.io/xe/x/stickers<span>:</span>latest 
</span><span>  <span>logLevel</span><span>:</span> info 
</span><span>  <span>replicas</span><span>:</span> <span>3</span> 
</span><span>  <span>port</span><span>:</span> <span>3000</span> 
</span><span>  <span>runAsRoot</span><span>:</span> <span>false</span> 
</span><span>
</span><span>  <span>env</span><span>:</span> 
</span><span>    <span>-</span> <span>name</span><span>:</span> FOO
</span><span>      <span>value</span><span>:</span> bar
</span><span>    <span>-</span> <span>name</span><span>:</span> BAZ
</span><span>      <span>value</span><span>:</span> qux
</span><span>
</span><span>  <span>healthcheck</span><span>:</span> 
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>path</span><span>:</span> /
</span><span>    <span>port</span><span>:</span> <span>3000</span>
</span><span>
</span><span>  <span>ingress</span><span>:</span> 
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>host</span><span>:</span> maximum<span>-</span>settings.xeiaso.net 
</span><span>    <span>clusterIssuer</span><span>:</span> letsencrypt<span>-</span>prod 
</span><span>    <span>className</span><span>:</span> nginx 
</span><span>
</span><span>  <span>onion</span><span>:</span> 
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>nonAnonymous</span><span>:</span> <span>true</span> 
</span><span>    <span>haproxy</span><span>:</span> <span>true</span> 
</span><span>    <span>proofOfWorkDefense</span><span>:</span> <span>false</span> 
</span><span>
</span><span>  <span>storage</span><span>:</span> 
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>path</span><span>:</span> /data 
</span><span>    <span>size</span><span>:</span> 10Gi 
</span><span>    <span>storageClass</span><span>:</span> longhorn 
</span><span>
</span><span>  <span>role</span><span>:</span> 
</span><span>    <span>enabled</span><span>:</span> <span>true</span>
</span><span>    <span>rules</span><span>:</span> 
</span><span>      <span>-</span> <span>apiGroups</span><span>:</span> <span>[</span><span>&#34;&#34;</span><span>]</span>
</span><span>        <span>resources</span><span>:</span> <span>[</span><span>&#34;pods&#34;</span><span>]</span>
</span><span>        <span>verbs</span><span>:</span> <span>[</span><span>&#34;get&#34;</span><span>,</span> <span>&#34;list&#34;</span><span>,</span> <span>&#34;watch&#34;</span><span>]</span>
</span><span>
</span><span>  <span>secrets</span><span>:</span> 
</span><span>    <span>-</span> <span>name</span><span>:</span> tigris<span>-</span>creds
</span><span>      <span>itemPath</span><span>:</span> <span>&#34;vaults/Kubernetes/items/stickers tigris creds&#34;</span>
</span><span>      <span>environment</span><span>:</span> <span>true</span> 
</span><span>    <span>-</span> <span>name</span><span>:</span> another<span>-</span>secret
</span><span>      <span>itemPath</span><span>:</span> <span>&#34;vaults/Kubernetes/items/another secret&#34;</span>
</span><span>      <span>folder</span><span>:</span> <span>true</span> 
</span></code></pre></details>
</article>
        </div><div>
            <p>Copyright 2012-2025 Xe Iaso. Any and all opinions listed here are my own and
                not representative of any of my employers, past, future, and/or present.</p>
            
            <p>Served by xesite v4 (/app/xesite) with site version 
                        <a href="https://github.com/Xe/site/commit/4e8bec8af8f2e0958e2f0350a557fc2db7aa803e">4e8bec8a</a>
                    , source code available <a href="https://github.com/Xe/site">here</a>.</p>
        </div></div>
  </body>
</html>
