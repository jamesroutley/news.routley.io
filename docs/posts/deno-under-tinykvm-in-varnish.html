<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://info.varnish-software.com/blog/tinykvm-in-varnish-and-some-deno">Original</a>
    <h1>Deno Under TinyKVM in Varnish</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <div>
          
          
          <p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>A little bit about compute in Varnish Cache and some Deno JS benchmarks</p>

<!--more--><p>The <em>wait_for_requests_paused()</em> inside the while loop will receive requests as they come. If the program crashes at any point it will be forcibly reset back to the state at the time of pausing. Alternatively, you can configure programs to be reset back to the paused state after every request. So-called ephemeral VMs — as they are unable to persist anything. In effect it becomes per-request isolation.</p>

<p>Above: A JSON minification program using simdjson. A static buffer is used in order to keep memory usage for non-ephemeral in check. When the program is ephemeral there is no need to track memory usage, because it will get completely reset after the request completes. In other words, as long as the program is able to deliver a response, it’s fine, as it will start over in a pristine condition on the next request. Programs that rely on GC can be faster with ephemeral compared to non-ephemeral because the potentially time-consuming GC is never allowed to run.</p>
<h2>A program example</h2>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=730&amp;height=1233&amp;name=TinyKVM%20Blog%20Image%201.png" width="730" height="1233" loading="lazy" alt="TinyKVM Blog Image 1" srcset="https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=365&amp;height=617&amp;name=TinyKVM%20Blog%20Image%201.png 365w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=730&amp;height=1233&amp;name=TinyKVM%20Blog%20Image%201.png 730w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=1095&amp;height=1850&amp;name=TinyKVM%20Blog%20Image%201.png 1095w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=1460&amp;height=2466&amp;name=TinyKVM%20Blog%20Image%201.png 1460w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=1825&amp;height=3083&amp;name=TinyKVM%20Blog%20Image%201.png 1825w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%201.png?width=2190&amp;height=3699&amp;name=TinyKVM%20Blog%20Image%201.png 2190w" sizes="(max-width: 730px) 100vw, 730px"/></p>
<p><span><em>I shamelessly used my own GBC emulator.</em></span></p>
<p>One of the TinyKVM example programs embeds a GBC emulator I wrote in 2017, which is presented as a webpage lightly strewn with some inline CSS wizardry by my friend Kyle. I once embedded it in IncludeOS, added PS/2 keyboard support and sent it to the Qemu advent calendar. It got accepted! The ROM it was using was a city builder homebrew game called <a href="https://github.com/AntonioND/ucity" rel="noopener">µCity Advance made by Antonio Niño Díaz</a>, which I had his permission to use!</p>
<p>I made this just for fun, of course. It provides co-operative gameplay where you fight for the controls. Good luck!</p>
<h2>Shared mutable storage</h2>
<p>I want to explain a little bit about how the co-operative GBC gameplay makes progress despite being served by separate request VMs with no knowledge of each other.The program uses something I just call storage, and it is a fork of the main VM that the program gets initialized in. During startup you set everything up, then a bunch of light-weight forks are created off of the main VM, which are henceforth referred to as request VMs. These request VMs are then prepared to handle requests, as they are all pre-initialized. What remains behind is the main VM, which can now be used for something else: Shared mutable storage. So, storage is a special instance of the program. And to make use of storage you can (among other things) call allowed functions to pass data in and out. Since the storage VM shares the constant parts of the program with your request VMs, every static (and static-PIE) link-time symbol has the same address. Because of this, calling a function in storage is as simple as passing an existing function as argument: <em>storage_call(my_function, …)</em> will then call <em>my_function</em> in storage, as long as storage allows it. Or you can use shared memory.</p>
<p>In the example GBC program we call a function in the storage VM from a client request with the gamepad inputs, which then contributes to the next frame. The data we return from storage is an encoded PNG of the current frame.</p>
<ol>
<li>A request VM calls a storage function</li>
<li>Is it time to simulate the next frame? Otherwise deliver old frame</li>
<li>Check if the frame has already been predicted, and if so, return prediction</li>
<li>If the frame wasn’t predicted, generate a new frame and return that</li>
<li>Schedule a predicted frame during downtime</li>
</ol>
<p>The last point is the important one: We can schedule something to happen in-between storage requests. A function call which storage will schedule outside of request VM accesses. This reduces latency because most of the work is in encoding the PNG. You can find <a href="https://github.com/varnish/tinykvm_examples/tree/main/cpp/gbc" rel="noopener">the source code here</a>.</p>
<h2>Languages with some API support</h2>
<p>I’ve made APIs for these languages so far, with varying degrees of completeness:</p>
<ul>
<li>C</li>
<li>C++</li>
<li>Go</li>
<li>JavaScript v8 w/JIT</li>
<li>JavaScript Deno w/JIT</li>
<li>Kotlin</li>
<li>Nelua</li>
<li>Nim</li>
<li>Rust</li>
<li>Zig</li>
</ul>
<p>Have a look at the program examples repository. C/C++ has the most complete API with languages that understand C headers coming in very close, like Zig. Zig is really up there, but I do think that people who write Zig would appreciate a more Zig-idiomatic API despite it understanding C headers. Right? I asked for an opinion on my Rust API and it got slaughtered. It’s clearly more C-like than I had realized. People have also asked for Python examples, and I will not work on that until after loading dynamically linked executables is supported. It’s coming, though!</p>
<h2>The Deno JavaScript run-time</h2>
<p><em>I invited Laurence Rowe to write this bit. He does an excellent job running realistic benchmarks, comparing them to existing solutions.</em></p>
<h2>A gzip benchmark and hugepages in Deno</h2>
<p>I’m happy that per-request isolation is performing well. I like doing benchmarks now and then, and I also recently did a quick gzip benchmark against the internal <em>zlib</em> in Varnish:</p>
<p><img src="https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=600&amp;height=371&amp;name=TinyKVM%20Blog%20Image%202.png" width="600" height="371" loading="lazy" alt="TinyKVM Blog Image 2" srcset="https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=300&amp;height=186&amp;name=TinyKVM%20Blog%20Image%202.png 300w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=600&amp;height=371&amp;name=TinyKVM%20Blog%20Image%202.png 600w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=900&amp;height=557&amp;name=TinyKVM%20Blog%20Image%202.png 900w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=1200&amp;height=742&amp;name=TinyKVM%20Blog%20Image%202.png 1200w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=1500&amp;height=928&amp;name=TinyKVM%20Blog%20Image%202.png 1500w, https://info.varnish-software.com/hs-fs/hubfs/TinyKVM%20Blog%20Image%202.png?width=1800&amp;height=1113&amp;name=TinyKVM%20Blog%20Image%202.png 1800w" sizes="(max-width: 600px) 100vw, 600px"/></p>
<p><em><span>libdeflate is indeed as fast as they claim</span></em></p>
<p><em>Zlib-ng</em> provides at least a 33% performance boost over the <em>zlib</em> embedded in Varnish for these relatively small payloads. <em>libdeflate</em> claims to be significantly faster than alternatives, and really delivers on that promise.</p>

<p>This is a benchmark of per-request isolation of a small Deno JS program first without hugepages and then with them enabled. Not for the whole main memory, and not for all of the working memory in request VMs. Just enough pages each to cover read-only segments in the main VM and the hot path in request VMs. One could speculate that hugepages reduces the number of IPIs required per request in addition to the reduced pagetable walking. Either way, it’s a 12% performance boost from a run-time setting, as <em>the program is unmodified</em>. I think that’s a source of my continued bewilderment when doing all this: We’re gaining a lot of performance without recompiling programs just by enabling a setting in TinyKVM.</p>
<h2>Conclusion</h2>
<p>We can see that TinyKVM provides high performance sandboxing, not just in raw compute but also in per-request isolation:</p>

<p>It can perform per-request isolation of a tiny program in on average 14us in a HTTP benchmark on my machine. That’s 14 micros <em>end-to-end</em>!</p>
<hr/>
<p>Authored by <a href="https://github.com/lrowe" rel="noopener">Laurence Rowe</a> and Alf-André Walla. Blog originally posted <a href="https://fwsgonzo.medium.com/tinykvm-in-varnish-and-some-deno-0a6abf90a5a1" rel="noopener">here.</a></p></span></p>

          
        </div>
      </article>

      
    </div></div>
  </body>
</html>
