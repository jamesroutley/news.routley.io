<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/pixiefail-nine-vulnerabilities-in-tianocores-edk-ii-ipv6-network-stack.html">Original</a>
    <h1>PixieFail: Nine Vulnerabilities UEFI Implementations</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>This blog post provides details about nine vulnerabilities affecting the IPv6 network protocol stack of EDK II, TianoCore&#39;s open source reference implementation of UEFI.</p>

  <h2>Introduction</h2>
<p>In this blog post we describe <a href="https://www.youtube.com/watch?v=PVyS9JwtFoQ">PixieFAIL</a>, nine vulnerabilities that affect EDK II, the de-facto open source reference implementation of the UEFI specification and possibly all implementations derived from it. The vulnerabilities are present in the network stack of EDK II and can be exploited during the network boot process.</p>
<p>Network boot is a standard feature on enterprise computers and servers. Using network boot to load an OS image from the network at boot time is popular in data centers and high-performance computing (HPC) environments, since server farms and HPC clusters may have hundreds or thousands of compute nodes that need to be provisioned with the same operating system and software configuration, and downloading and running the OS from a central set of servers (Boot servers) could greatly simplify management. In order to provide this network booting feature, UEFI implements a full IP stack at the <a href="https://uefi.org/specs/PI/1.8/V2_Overview.html">DXE phase</a>, opening the door to attacks from the local network during this early stage of the boot process. </p>
<p>The <a href="https://en.wikipedia.org/wiki/Preboot_Execution_Environment">Preboot Execution Environment</a>(PXE) is the specification for a standardized client-server solution to allow computers to boot over the network, colloquially referred to as <em>netboot</em> or <strong><em>Pixie boot</em></strong>. It was originally introduced by Intel in 1998 and later incorporated into the UEFI specification. Besides IPv4, PXE originally relied on a handful of simple protocols to achieve network booting: DHCP, UDP, and TFTP. These were considered relatively simple protocols that could be implemented with a sufficiently small footprint to fit in Option ROM or Network Interface Card (NIC) firmware. Since the release of version 2.2 of the UEFI specification in 2010, IPv6-based PXE has been part of the UEFI specification as well. In the case of IPv6, besides the core protocol, other protocols such as ICMPv6, Neighbor Discovery (ND), Multicast Listener Discovery (MLD), UDP, TCP, DHCPv6, DNS, and TFTP are implemented, which increased the overall attack surface.</p>
<p>EDK II is an open source implementation of the UEFI specification developed and maintained by <a href="https://www.tianocore.org/">Tianocore</a>, a community of developers from software vendors that also leverage the project for their own UEFI implementations. In a <a href="https://blog.quarkslab.com/for-science-using-an-unimpressive-bug-in-edk-ii-to-do-some-fun-exploitation.html">prior blog post</a> <em>Gwaby</em> explored the attack surface and <em>exploitability of EDK II</em> and showed that even a bug that provides just minimal capability could be used to achieve arbitrary code execution if the context is right. UEFI vulnerabilities that could be triggered remotely seemed like an interesting context for exploitation, and eventually persistence, but where would we look for those?</p>
<p>The EDK II UEFI reference implementation <a href="https://github.com/tianocore/tianocore.github.io/wiki/PXE">provides both IPv4- and IPv6-based PXE</a>. In the <a href="https://uefi.org/sites/default/files/resources/UEFI_Spec_2_10_Aug29.pdf">latest available specification (UEFI 2.10)</a> as of this writing, IPv6-based PXE is described in section &#34;<em>24.3.18 - Netboot6</em>&#34;.</p>
<p>We performed a cursory inspection of <code>NetworkPkg</code>, Tianocore&#39;s EDK II PXE implementation, and identified nine vulnerabilities that can be exploited by unauthenticated remote attackers on the same local network, and in some cases, by attackers on remote networks. The impact of these vulnerabilities includes denial of service, information leakage, remote code execution, DNS cache poisoning, and network session hijacking.</p>
<h2>Affected vendors</h2>
<ul>
<li>Tianocore <a href="https://github.com/tianocore/edk2">EDK II UEFI implementation</a> <ul>
<li><code>NetworkPkg</code> PXE stack.</li>
</ul>
</li>
</ul>
<p>Other vendors that use EDK II&#39;s <code>NetworkPkg</code> module (non-exhaustive list):</p>
<ul>
<li>
<p>Arm Ltd.: <a href="https://gitlab.arm.com/arm-reference-solutions/edk2">Arm reference solutions</a></p>
</li>
<li>
<p>Insyde Software: <a href="https://www.insyde.com/products">Insyde H20 UEFI BIOS</a></p>
</li>
<li>
<p>American Megatrends Inc. (AMI): <a href="https://github.com/opencomputeproject/OSF-Aptio-OpenEdition">Aptio OpenEdition</a></p>
</li>
<li>
<p>Phoenix Technologies Inc.: <a href="https://www.phoenix.com/phoenix-securecore/">SecureCore</a></p>
</li>
<li>
<p>Microsoft Corporation: <a href="https://github.com/microsoft/mu_basecore">Project Mu</a></p>
</li>
</ul>
<p>CERT/CC published <a href="https://www.kb.cert.org/vuls/id/132380">Vulnerability Note VU#132380</a> with a more comprehensive list of affected vendors, and guidance to deploy fixes and mitigations.</p>
<p>Proof of concept scripts to detect the presence of vulnerabilities 1 to 7 are available <a href="https://github.com/quarkslab/pixiefail">here</a>.</p>
<h2>Technical details</h2>
<h3>Preboot Execution Environment (PXE)</h3>
<p>In order to boot from the network, a client system must be able to locate, download, and execute code that sets up, configures, and runs the operating system. This is usually done in several stages, starting with a minimal program that is downloaded from a network server using a simple protocol, such as TFTP, which then downloads and runs a second booting stage or the full operating system image. </p>
<p>To locate this minimal program, called Network Bootstrap Program (NBP), the PXE client relies on a DHCP server to both obtain the configuration parameters to configure its network interface with a valid IP address and to receive a list of Boot Servers to query for the NBP file. Since the DHCP server must provide such a list and other special parameters, the PXE client has to send some mandatory <a href="https://datatracker.ietf.org/doc/html/rfc4578">PXE-releated DHCP Options</a>, consequently, the DHCP server must be &#34;PXE enabled&#34;, i.e. configured appropriately to recognize PXE client options and to reply with the proper DHCP server options. To facilitate network booting without having to modify the configuration of operational DHCP servers servicing all types of clients, not just PXE clients, the specification splits the regular DHCP server functionality from the PXE-related functionality into two separate services, the DHCP service, and the proxy DHCP service, running on different ports on the same or separate machines. </p>
<p>The PXE client selects a Boot Server and communicates with it using the DHCP protocol to obtain the filename and file service (TFTP) parameters necessary to download the NBP. Finally, the NBP is downloaded, verified (in the case of Secure Boot), and executed. Once the next booting stage or the fully-fledged operating system image is downloaded and setup, execution control is transferred to it. A more detailed description of the PXE boot process is provided <a href="https://github.com/tianocore/tianocore.github.io/wiki/PXE">here</a>.</p>
<p>PXE over IPv6 is based on a combination of the DHCPv6 and TFTP protocols, which in turn implies the usage of IPv6 and UDP at layers 3 and 4, respectively. Because a DHCP server may provide a list of Boot Servers by hostname, it is also necessary to have a working implementation of the DNS protocol. </p>
<p>The following picture from the UEFI 2.10 specification summarizes the PXE boot process over IPv6:</p>
<center>
  <img src="https://blog.quarkslab.com/resources/2023-09-27_vulnerabilities-in-tianocore-edk2-ipv6-stack/pxe-ipv6-flow.png" width="60%"/>
</center>
<h3>CVE-2023-45229: Integer underflow when processing IA_NA/IA_TA options in a DHCPv6 Advertise message</h3>
<p>When trying to boot using PXE over IPv6, the EDK II firmware starts by sending DHCPv6 <code>Solicit</code> messages. DHCPv6 servers answer with an <code>Advertise</code> message.
<code>Advertise</code> messages are handled in EDK II by the <code>Dhcp6HandleAdvertiseMsg</code> function in <code>NetworkPkg/Dhcp6Dxe/Dhcp6Io.c</code>, which calls <code>Dhcp6SeekStsOption</code> in order to search for <code>Status</code> codes in the received message. A <code>Status</code> code may appear as an option in the DHCPv6 message, or as an option inside another option, such as the <code>IA_NA</code> or <code>IA_TA</code> options.</p>
<p>When seeking for <code>Status</code> codes encapsulated in <code>IA_NA</code> or <code>IA_TA</code> options, the vulnerable function <code>Dhcp6SeekStsOption</code> in <code>NetworkPkg/Dhcp6Dxe/Dhcp6Io.c</code> does the following:</p>
<div><pre><span></span><code><span>EFI_STATUS</span><span></span>
<span>Dhcp6SeekStsOption</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span>     </span><span>DHCP6_INSTANCE</span><span>    </span><span>*</span><span>Instance</span><span>,</span><span></span>
<span>  </span><span>IN</span><span>     </span><span>EFI_DHCP6_PACKET</span><span>  </span><span>*</span><span>Packet</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span>    </span><span>UINT8</span><span>             </span><span>**</span><span>Option</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>[...]</span><span></span>
<span>    </span><span>//</span>
<span>    </span><span>// Seek in encapsulated options, IA_NA and IA_TA.</span>
<span>    </span><span>//</span>
<span>    </span><span>*</span><span>Option</span><span> </span><span>=</span><span> </span><span>Dhcp6SeekIaOption</span><span> </span><span>(</span><span></span>
<span>                  </span><span>Packet</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Option</span><span>,</span><span></span>
<span>                  </span><span>Packet</span><span>-&gt;</span><span>Length</span><span> </span><span>-</span><span> </span><span>sizeof</span><span> </span><span>(</span><span>EFI_DHCP6_HEADER</span><span>),</span><span></span>
<span>                  </span><span>&amp;</span><span>Instance</span><span>-&gt;</span><span>Config</span><span>-&gt;</span><span>IaDescriptor</span><span></span>
<span>                  </span><span>);</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>*</span><span>Option</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>EFI_SUCCESS</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>[...]</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>Instance</span><span>-&gt;</span><span>Config</span><span>-&gt;</span><span>IaDescriptor</span><span>.</span><span>Type</span><span> </span><span>==</span><span> </span><span>Dhcp6OptIana</span><span>)</span><span> </span><span>{</span><span></span>
<span>[</span><span>1</span><span>]</span><span>     </span><span>IaInnerOpt</span><span> </span><span>=</span><span> </span><span>*</span><span>Option</span><span> </span><span>+</span><span> </span><span>16</span><span>;</span><span></span>
<span>[</span><span>2</span><span>]</span><span>     </span><span>IaInnerLen</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT16</span><span>)(</span><span>NTOHS</span><span> </span><span>(</span><span>ReadUnaligned16</span><span> </span><span>((</span><span>UINT16</span><span> </span><span>*</span><span>)(</span><span>*</span><span>Option</span><span> </span><span>+</span><span> </span><span>2</span><span>)))</span><span> </span><span>-</span><span> </span><span>12</span><span>);</span><span></span>
<span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>[</span><span>3</span><span>]</span><span>     </span><span>IaInnerOpt</span><span> </span><span>=</span><span> </span><span>*</span><span>Option</span><span> </span><span>+</span><span> </span><span>8</span><span>;</span><span></span>
<span>[</span><span>4</span><span>]</span><span>     </span><span>IaInnerLen</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT16</span><span>)(</span><span>NTOHS</span><span> </span><span>(</span><span>ReadUnaligned16</span><span> </span><span>((</span><span>UINT16</span><span> </span><span>*</span><span>)(</span><span>*</span><span>Option</span><span> </span><span>+</span><span> </span><span>2</span><span>)))</span><span> </span><span>-</span><span> </span><span>4</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>

<span>[</span><span>5</span><span>]</span><span> </span><span>*</span><span>Option</span><span> </span><span>=</span><span> </span><span>Dhcp6SeekOption</span><span> </span><span>(</span><span>IaInnerOpt</span><span>,</span><span> </span><span>IaInnerLen</span><span>,</span><span> </span><span>Dhcp6OptStatusCode</span><span>);</span><span></span>

<span>[...]</span><span></span>
</code></pre></div>

<p>Basically, the <code>IA_NA</code> and <code>IA_TA</code> options in an <code>Advertise</code> message are trusted without doing basic sanity checks, e.g.:</p>
<ul>
<li>
<p>in the case of <code>IA_NA</code> options:</p>
<ul>
<li>that the option is at least 16 bytes in length before setting <code>IaInnerOpt</code> to <code>*Option + 16</code>, at [1].</li>
<li>that the value of the <code>optlen</code> field of the option is at least 12, before subtracting 12 from it, at [2].</li>
</ul>
</li>
<li>
<p>in the case of <code>IA_TA</code> options:</p>
<ul>
<li>that the option is at least 8 bytes in length before setting <code>IaInnerOpt</code> to <code>*Option + 8</code>, at [3].</li>
<li>that the value of the <code>optlen</code> field of the option is at least 4, before subtracting 4 from it, at [4].</li>
</ul>
</li>
</ul>
<p>The lack of checking for sane values in the <code>optlen</code> field of these options allows to trigger an integer underflow, by setting the <code>optlen</code> field to a value &lt; 12 (in the case of <code>IA_NA</code>) or &lt; 4 (in the case of <code>IA_TA</code>).</p>
<p>As an example, if we send a DHCPv6 <code>Advertise</code> message containing an <code>IA_NA</code> option with its <code>optlen</code> field set to 11, when the code above calls <code>Dhcp6SeekOption</code> at [5] to scan forward for status options, the <code>IaInnerLen</code> parameter will be set to 0xFFFF (11 - 12), and as a result function <code>Dhcp6SeekOption</code> will attempt to read memory well past the end of the received packet.</p>
<h3>CVE-2023-45230: Buffer overflow in the DHCPv6 client via a long Server ID option</h3>
<p>After doing the initial <code>Solicit</code>/<code>Advertise</code> exchange, a DHCPv6 client needs to send a <code>Request</code> message. This is done via the <code>Dhcp6SendRequestMsg</code> function in <code>NetworkPkg/Dhcp6Dxe/Dhcp6Io.c</code>.</p>
<p>This <code>Request</code> message needs to keep a few DHCPv6 options sent during the <code>Solicit</code> message, such as <code>OPTION_ORO</code> (0x6), <code>OPTION_CLIENT_ARCH_TYPE</code> (0x3D), <code>OPTION_NII</code> (0x3E), and <code>OPTION_VENDOR_CLASS</code> (0x10). These options are kept in <code>Instance-&gt;Config-&gt;OptionList</code>. Their lengths are added up ([1]), in order to calculate the size of the buffer needed to store the <code>Request</code> packet. Notice that the total size of the allocation is <code>DHCP6_BASE_PACKET_SIZE</code> (1024, defined in <code>NetworkPkg/Dhcp6Dxe/Dhcp6Impl.h</code>) plus the sum of the lengths of the options mentioned before ([2]). In our tests <code>UserLen</code> typically ends up having the value 67, so the total size of the allocation is 1091 bytes.</p>
<div><pre><span></span><code><span>EFI_STATUS</span><span></span>
<span>Dhcp6SendRequestMsg</span><span> </span><span>(</span><span></span>
<span>    </span><span>IN</span><span> </span><span>DHCP6_INSTANCE</span><span>  </span><span>*</span><span>Instance</span><span></span>
<span>    </span><span>)</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>    </span><span>//</span>
<span>    </span><span>// Calculate the added length of customized option list.</span>
<span>    </span><span>//</span>
<span>    </span><span>UserLen</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>    </span><span>for</span><span> </span><span>(</span><span>Index</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>Index</span><span> </span><span>&lt;</span><span> </span><span>Instance</span><span>-&gt;</span><span>Config</span><span>-&gt;</span><span>OptionCount</span><span>;</span><span> </span><span>Index</span><span>++</span><span>)</span><span> </span><span>{</span><span></span>
<span>[</span><span>1</span><span>]</span><span>     </span><span>UserLen</span><span> </span><span>+=</span><span> </span><span>(</span><span>NTOHS</span><span> </span><span>(</span><span>Instance</span><span>-&gt;</span><span>Config</span><span>-&gt;</span><span>OptionList</span><span>[</span><span>Index</span><span>]</span><span>-&gt;</span><span>OpLen</span><span>)</span><span> </span><span>+</span><span> </span><span>4</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>//</span>
<span>    </span><span>// Create the Dhcp6 packet and initialize common fields.</span>
<span>    </span><span>//</span>
<span>[</span><span>2</span><span>]</span><span> </span><span>Packet</span><span> </span><span>=</span><span> </span><span>AllocateZeroPool</span><span> </span><span>(</span><span>DHCP6_BASE_PACKET_SIZE</span><span> </span><span>+</span><span> </span><span>UserLen</span><span>);</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>Packet</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>EFI_OUT_OF_RESOURCES</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>Packet</span><span>-&gt;</span><span>Size</span><span>                       </span><span>=</span><span> </span><span>DHCP6_BASE_PACKET_SIZE</span><span> </span><span>+</span><span> </span><span>UserLen</span><span>;</span><span></span>
<span>    </span><span>[...]</span><span></span>
</code></pre></div>

<p>The <code>Request</code> message also needs to retain the <em>Server ID</em> (0x2) option that was previously sent by the DHCPv6 server in the <code>Advertise</code> message. It is retrieved this way:</p>
<div><pre><span></span><code><span>    </span><span>[...]</span><span></span>
<span>    </span><span>//</span>
<span>    </span><span>// Get the server Id from the selected advertisement message.</span>
<span>    </span><span>//</span>
<span>    </span><span>Option</span><span> </span><span>=</span><span> </span><span>Dhcp6SeekOption</span><span> </span><span>(</span><span></span>
<span>             </span><span>Instance</span><span>-&gt;</span><span>AdSelect</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Option</span><span>,</span><span></span>
<span>             </span><span>Instance</span><span>-&gt;</span><span>AdSelect</span><span>-&gt;</span><span>Length</span><span> </span><span>-</span><span> </span><span>4</span><span>,</span><span></span>
<span>             </span><span>Dhcp6OptServerId</span><span></span>
<span>             </span><span>);</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>Option</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>EFI_DEVICE_ERROR</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>ServerId</span><span> </span><span>=</span><span> </span><span>(</span><span>EFI_DHCP6_DUID</span><span> </span><span>*</span><span>)(</span><span>Option</span><span> </span><span>+</span><span> </span><span>2</span><span>);</span><span></span>
<span>    </span><span>[...]</span><span></span>
</code></pre></div>

<p>Then, the <code>Request</code> packet is built by assembling all the needed options, one after the other: first the Client ID, then the Elapsed Time, then the Server ID, and so on.
Notice that when appending the Server ID option (which is fully controlled by the DHCPv6 server), its <code>Length</code> field is fully trusted, without any sanity checks. Therefore, a Server ID option with an overly large <code>Length</code> field can overflow the <code>Packet-&gt;Dhcp6.Option</code> buffer with fully controlled data (overflow data comes from the <code>DUID</code> field of the Server ID option).</p>
<div><pre><span></span><code><span>  </span><span>[...]</span><span></span>
<span>  </span><span>//</span>
<span>  </span><span>// Assembly Dhcp6 options for request message.</span>
<span>  </span><span>//</span>
<span>  </span><span>Cursor</span><span> </span><span>=</span><span> </span><span>Packet</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Option</span><span>;</span><span></span>

<span>  </span><span>Length</span><span> </span><span>=</span><span> </span><span>HTONS</span><span> </span><span>(</span><span>ClientId</span><span>-&gt;</span><span>Length</span><span>);</span><span></span>
<span>  </span><span>Cursor</span><span> </span><span>=</span><span> </span><span>Dhcp6AppendOption</span><span> </span><span>(</span><span></span>
<span>             </span><span>Cursor</span><span>,</span><span></span>
<span>             </span><span>HTONS</span><span> </span><span>(</span><span>Dhcp6OptClientId</span><span>),</span><span></span>
<span>             </span><span>Length</span><span>,</span><span></span>
<span>             </span><span>ClientId</span><span>-&gt;</span><span>Duid</span><span></span>
<span>             </span><span>);</span><span></span>

<span>  </span><span>Cursor</span><span> </span><span>=</span><span> </span><span>Dhcp6AppendETOption</span><span> </span><span>(</span><span></span>
<span>             </span><span>Cursor</span><span>,</span><span></span>
<span>             </span><span>Instance</span><span>,</span><span></span>
<span>             </span><span>&amp;</span><span>Elapsed</span><span></span>
<span>             </span><span>);</span><span></span>

<span>  </span><span>Cursor</span><span> </span><span>=</span><span> </span><span>Dhcp6AppendOption</span><span> </span><span>(</span><span></span>
<span>             </span><span>Cursor</span><span>,</span><span></span>
<span>             </span><span>HTONS</span><span> </span><span>(</span><span>Dhcp6OptServerId</span><span>),</span><span></span>
<span>             </span><span>ServerId</span><span>-&gt;</span><span>Length</span><span>,</span><span></span>
<span>             </span><span>ServerId</span><span>-&gt;</span><span>Duid</span><span></span>
<span>             </span><span>);</span><span></span>
</code></pre></div>

<p>The very same bug seems to be present in functions <code>Dhcp6SendDeclineMsg</code>, <code>Dhcp6SendReleaseMsg</code>, and <code>Dhcp6SendRenewRebindMsg</code> (<code>NetworkPkg/Dhcp6Dxe/Dhcp6Io.c</code>).</p>
<h3>CVE-2023-45231: Out of Bounds read when handling a ND Redirect message with truncated options</h3>
<p>Function <code>Ip6ProcessRedirect</code> in <code>NetworkPkg/Ip6Dxe/Ip6Nd.c</code> handles Neighbor Discovery (ND) protocol&#39;s <code>Redirect</code> messages.
This function calls <code>Ip6IsNDOptionValid</code> (<code>NetworkPkg/Ip6Dxe/Ip6Option.c</code>) to verify that all the options included in the <code>Redirect</code> message are valid.</p>
<div><pre><span></span><code><span>EFI_STATUS</span><span></span>
<span>Ip6ProcessRedirect</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>IP6_SERVICE</span><span>     </span><span>*</span><span>IpSb</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>EFI_IP6_HEADER</span><span>  </span><span>*</span><span>Head</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>NET_BUF</span><span>         </span><span>*</span><span>Packet</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>    </span><span>// All included options have a length that is greater than zero.</span>
<span>    </span><span>//</span>
<span>    </span><span>OptionLen</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT16</span><span>)(</span><span>Head</span><span>-&gt;</span><span>PayloadLength</span><span> </span><span>-</span><span> </span><span>IP6_REDITECT_LENGTH</span><span>);</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>OptionLen</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>Option</span><span> </span><span>=</span><span> </span><span>NetbufGetByte</span><span> </span><span>(</span><span>Packet</span><span>,</span><span> </span><span>IP6_REDITECT_LENGTH</span><span>,</span><span> </span><span>NULL</span><span>);</span><span></span>
<span>        </span><span>ASSERT</span><span> </span><span>(</span><span>Option</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>);</span><span></span>

<span>        </span><span>if</span><span> </span><span>(</span><span>!</span><span>Ip6IsNDOptionValid</span><span> </span><span>(</span><span>Option</span><span>,</span><span> </span><span>OptionLen</span><span>))</span><span> </span><span>{</span><span></span>
<span>            </span><span>goto</span><span> </span><span>Exit</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>[...]</span><span></span>
</code></pre></div>

<p>If the options section of an incoming ND <code>Redirect</code> message is made of one single option, which is truncated and composed of only the Option Code (i.e. 1 single byte), <code>Ip6IsNDOptionValid</code> returns TRUE. This happens because <code>Ip6IsNDOptionValid</code> is called with parameter <code>OptionLen</code> == 1, and <code>sizeof(IP6_OPTION_HEADER)</code> is 2, therefore the <code>while</code> loop in charge of traversing the list of options ([1]) is never entered, and we just reach the <code>return TRUE</code> at the end ([2]), meaning that the truncated option is considered as valid, even though it is not.</p>
<div><pre><span></span><code><span>BOOLEAN</span><span></span>
<span>Ip6IsNDOptionValid</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>   </span><span>*</span><span>Option</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT16</span><span>  </span><span>OptionLen</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>Offset</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>

<span>    </span><span>//</span>
<span>    </span><span>// RFC 4861 states that Neighbor Discovery packet can contain zero or more</span>
<span>    </span><span>// options. Start processing the options if at least Type + Length fields</span>
<span>    </span><span>// fit within the input buffer.</span>
<span>    </span><span>//</span>
<span>[</span><span>1</span><span>]</span><span> </span><span>while</span><span> </span><span>(</span><span>Offset</span><span> </span><span>+</span><span> </span><span>sizeof</span><span> </span><span>(</span><span>IP6_OPTION_HEADER</span><span>)</span><span> </span><span>-</span><span> </span><span>1</span><span> </span><span>&lt;</span><span> </span><span>OptionLen</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>    </span><span>}</span><span></span>

<span>[</span><span>2</span><span>]</span><span> </span><span>return</span><span> </span><span>TRUE</span><span>;</span><span></span>
<span>}</span><span></span>
</code></pre></div>

<p>After that, back in <code>Ip6ProcessRedirect</code>, options are actually processed. If our options section of the packet is composed of a single byte (i.e. a truncated option composed of just the option code), the <code>Length</code> variable takes value 1 at [3], so it enters the <code>while</code> block at [4], and at [5] or [6] (depending on the option code we specified in the truncated option), one byte is read past the end of the packet, which is the missing length field of our truncated option.</p>
<div><pre><span></span><code><span>  </span><span>// Check the options. The only interested option here is the target-link layer</span>
<span>  </span><span>// address option.</span>
<span>  </span><span>//</span>
<span>[</span><span>3</span><span>]</span><span> </span><span>Length</span><span>          </span><span>=</span><span> </span><span>Packet</span><span>-&gt;</span><span>TotalSize</span><span> </span><span>-</span><span> </span><span>40</span><span>;</span><span></span>
<span>    </span><span>Option</span><span>          </span><span>=</span><span> </span><span>(</span><span>UINT8</span><span> </span><span>*</span><span>)(</span><span>IcmpDest</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span><span></span>
<span>    </span><span>LinkLayerOption</span><span> </span><span>=</span><span> </span><span>NULL</span><span>;</span><span></span>
<span>[</span><span>4</span><span>]</span><span> </span><span>while</span><span> </span><span>(</span><span>Length</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>switch</span><span> </span><span>(</span><span>*</span><span>Option</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>case</span><span> </span><span>Ip6OptionEtherTarget</span><span>:</span><span></span>

<span>            </span><span>LinkLayerOption</span><span> </span><span>=</span><span> </span><span>(</span><span>IP6_ETHER_ADDR_OPTION</span><span> </span><span>*</span><span>)</span><span>Option</span><span>;</span><span></span>
<span>[</span><span>5</span><span>]</span><span>         </span><span>OptLen</span><span>          </span><span>=</span><span> </span><span>LinkLayerOption</span><span>-&gt;</span><span>Length</span><span>;</span><span></span>
<span>            </span><span>if</span><span> </span><span>(</span><span>OptLen</span><span> </span><span>!=</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span></span>
<span>                </span><span>//</span>
<span>                </span><span>// For Ethernet, the length must be 1.</span>
<span>                </span><span>//</span>
<span>                </span><span>goto</span><span> </span><span>Exit</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>

<span>            </span><span>break</span><span>;</span><span></span>

<span>        </span><span>default</span><span>:</span><span></span>

<span>[</span><span>6</span><span>]</span><span>         </span><span>OptLen</span><span> </span><span>=</span><span> </span><span>*</span><span>(</span><span>Option</span><span> </span><span>+</span><span> </span><span>1</span><span>);</span><span></span>
<span>            </span><span>if</span><span> </span><span>(</span><span>OptLen</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span>
<span>                </span><span>//</span>
<span>                </span><span>// A length of 0 is invalid.</span>
<span>                </span><span>//</span>
<span>                </span><span>goto</span><span> </span><span>Exit</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>

<span>            </span><span>break</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>Length</span><span> </span><span>-=</span><span> </span><span>8</span><span> </span><span>*</span><span> </span><span>OptLen</span><span>;</span><span></span>
<span>    </span><span>Option</span><span> </span><span>+=</span><span> </span><span>8</span><span> </span><span>*</span><span> </span><span>OptLen</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
</code></pre></div>

<h3>CVE-2023-45232: Infinite loop when parsing unknown options in the Destination Options header</h3>
<p>The function <code>Ip6IsExtsValid</code> in <code>NetworkPkg/Ip6Dxe/Ip6Option.c</code> validates the extension headers that can be found in an incoming IPv6 packet. When dealing with a <em>Destination Options</em> extension header, function <code>Ip6IsOptionValid</code> is called at [1] to validate whatever options are embedded in said <em>Destination Options</em> header:</p>
<div><pre><span></span><code><span>BOOLEAN</span><span></span>
<span>Ip6IsExtsValid</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>IP6_SERVICE</span><span>  </span><span>*</span><span>IpSb</span><span>           </span><span>OPTIONAL</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>NET_BUF</span><span>      </span><span>*</span><span>Packet</span><span>         </span><span>OPTIONAL</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>*</span><span>NextHeader</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>*</span><span>ExtHdrs</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT32</span><span>       </span><span>ExtHdrsLen</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>BOOLEAN</span><span>      </span><span>Rcvd</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>UINT32</span><span>      </span><span>*</span><span>FormerHeader</span><span>   </span><span>OPTIONAL</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>UINT8</span><span>       </span><span>**</span><span>LastHeader</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>UINT32</span><span>      </span><span>*</span><span>RealExtsLen</span><span>    </span><span>OPTIONAL</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>UINT32</span><span>      </span><span>*</span><span>UnFragmentLen</span><span>  </span><span>OPTIONAL</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>BOOLEAN</span><span>     </span><span>*</span><span>Fragmented</span><span>     </span><span>OPTIONAL</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>  </span><span>[...]</span><span></span>
<span>  </span><span>while</span><span> </span><span>(</span><span>Offset</span><span> </span><span>&lt;=</span><span> </span><span>ExtHdrsLen</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>switch</span><span> </span><span>(</span><span>*</span><span>NextHeader</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>    </span><span>case</span><span> </span><span>IP6_DESTINATION</span><span>:</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>        </span><span>Offset</span><span>++</span><span>;</span><span></span>
<span>        </span><span>Option</span><span>    </span><span>=</span><span> </span><span>ExtHdrs</span><span> </span><span>+</span><span> </span><span>Offset</span><span>;</span><span></span>
<span>        </span><span>OptionLen</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT8</span><span>)((</span><span>*</span><span>Option</span><span> </span><span>+</span><span> </span><span>1</span><span>)</span><span> </span><span>*</span><span> </span><span>8</span><span> </span><span>-</span><span> </span><span>2</span><span>);</span><span></span>
<span>        </span><span>Option</span><span>++</span><span>;</span><span></span>
<span>        </span><span>Offset</span><span>++</span><span>;</span><span></span>

<span>[</span><span>1</span><span>]</span><span>     </span><span>if</span><span> </span><span>((</span><span>IpSb</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>(</span><span>Packet</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>Ip6IsOptionValid</span><span> </span><span>(</span><span>IpSb</span><span>,</span><span> </span><span>Packet</span><span>,</span><span> </span><span>Option</span><span>,</span><span> </span><span>OptionLen</span><span>,</span><span> </span><span>Offset</span><span>))</span><span> </span><span>{</span><span></span>
<span>          </span><span>return</span><span> </span><span>FALSE</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>
<span>        </span><span>[...]</span><span></span>
</code></pre></div>

<p>The function <code>Ip6IsOptionValid</code> handles different option types. If it&#39;s not one of <code>Pad1</code>, <code>PadN</code>, or <code>RouterAlert</code>, the switch case falls into the <code>default</code> clause at [3]. In that case, the option code is masked with <code>Ip6OptionMask</code> (0xC0) at [4], and if the result of the AND operation is <code>Ip6OptionSkip</code> (0x00), then the <code>Offset</code> variable is updated by adding the value of the <code>Length</code> field of the option at [5]. Notice that it doesn&#39;t check if the <code>Length</code> field of the option is 0, in which case the <code>Offset</code> value is never modified, and thus an infinite loop ensues, since execution can never break out of the <code>while</code> loop at [2].</p>
<div><pre><span></span><code><span>Ip6IsOptionValid</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>IP6_SERVICE</span><span>  </span><span>*</span><span>IpSb</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>NET_BUF</span><span>      </span><span>*</span><span>Packet</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>*</span><span>Option</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>OptionLen</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT32</span><span>       </span><span>Pointer</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>[</span><span>2</span><span>]</span><span>   </span><span>while</span><span> </span><span>(</span><span>Offset</span><span> </span><span>&lt;</span><span> </span><span>OptionLen</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>OptionType</span><span> </span><span>=</span><span> </span><span>*</span><span>(</span><span>Option</span><span> </span><span>+</span><span> </span><span>Offset</span><span>);</span><span></span>

<span>        </span><span>switch</span><span> </span><span>(</span><span>OptionType</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>case</span><span> </span><span>Ip6OptionPad1</span><span>:</span><span></span>
<span>            </span><span>[...]</span><span></span>
<span>            </span><span>break</span><span>;</span><span></span>
<span>        </span><span>case</span><span> </span><span>Ip6OptionPadN</span><span>:</span><span></span>
<span>            </span><span>[...]</span><span></span>
<span>            </span><span>break</span><span>;</span><span></span>
<span>        </span><span>case</span><span> </span><span>Ip6OptionRouterAlert</span><span>:</span><span></span>
<span>            </span><span>[...]</span><span></span>
<span>            </span><span>break</span><span>;</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>[</span><span>3</span><span>]</span><span>     </span><span>default</span><span>:</span><span></span>
<span>            </span><span>//</span>
<span>            </span><span>// The highest-order two bits specify the action must be taken if</span>
<span>            </span><span>// the processing IPv6 node does not recognize the option type.</span>
<span>            </span><span>//</span>
<span>[</span><span>4</span><span>]</span><span>         </span><span>switch</span><span> </span><span>(</span><span>OptionType</span><span> </span><span>&amp;</span><span> </span><span>Ip6OptionMask</span><span>)</span><span> </span><span>{</span><span></span>
<span>            </span><span>case</span><span> </span><span>Ip6OptionSkip</span><span>:</span><span></span>
<span>[</span><span>5</span><span>]</span><span>             </span><span>Offset</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT8</span><span>)(</span><span>Offset</span><span> </span><span>+</span><span> </span><span>*</span><span>(</span><span>Option</span><span> </span><span>+</span><span> </span><span>Offset</span><span> </span><span>+</span><span> </span><span>1</span><span>));</span><span></span>
<span>                </span><span>break</span><span>;</span><span></span>
<span>            </span><span>[...]</span><span></span>
</code></pre></div>

<p>As a result of this infinite loop, the affected computer never finishes booting up.</p>
<h3>CVE-2023-45233: Infinite loop when parsing a PadN option in the Destination Options header</h3>
<p>As mentioned in the previous bug, function <code>Ip6IsOptionValid</code> in <code>NetworkPkg/Ip6Dxe/Ip6Option.c</code> is called to validate whatever options are embedded in a <em>Destination Options</em> header within an IPv6 packet. The function <code>Ip6IsOptionValid</code> handles different option types. One of those supported types is <code>PadN</code> ([2]). In that case, the <code>Offset</code> variable is updated by adding the value of the <code>Length</code> field of the <code>PadN</code> option, plus 2 ([3]). If the <code>Length</code> field of the option is 0xFE, then 0x100 (0xFE + 2) will be added to <code>Offset</code>. But the result of that addition is truncated to a <code>UINT8</code> (the type of the <code>Offset</code> variable), which means that when adding 0x100 to <code>Offset</code> it will remain unmodified, and thus an infinite loop ensues, since execution can never break out of the <code>while</code> loop at [1].</p>
<div><pre><span></span><code><span>Ip6IsOptionValid</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>IP6_SERVICE</span><span>  </span><span>*</span><span>IpSb</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>NET_BUF</span><span>      </span><span>*</span><span>Packet</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>*</span><span>Option</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT8</span><span>        </span><span>OptionLen</span><span>,</span><span></span>
<span>  </span><span>IN</span><span> </span><span>UINT32</span><span>       </span><span>Pointer</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>UINT8</span><span>  </span><span>Offset</span><span>;</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>[</span><span>1</span><span>]</span><span>  </span><span>while</span><span> </span><span>(</span><span>Offset</span><span> </span><span>&lt;</span><span> </span><span>OptionLen</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>OptionType</span><span> </span><span>=</span><span> </span><span>*</span><span>(</span><span>Option</span><span> </span><span>+</span><span> </span><span>Offset</span><span>);</span><span></span>

<span>        </span><span>switch</span><span> </span><span>(</span><span>OptionType</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>[</span><span>2</span><span>]</span><span>     </span><span>case</span><span> </span><span>Ip6OptionPadN</span><span>:</span><span></span>
<span>            </span><span>//</span>
<span>            </span><span>// It is a PadN option</span>
<span>            </span><span>//</span>
<span>[</span><span>3</span><span>]</span><span>         </span><span>Offset</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT8</span><span>)(</span><span>Offset</span><span> </span><span>+</span><span> </span><span>*</span><span>(</span><span>Option</span><span> </span><span>+</span><span> </span><span>Offset</span><span> </span><span>+</span><span> </span><span>1</span><span>)</span><span> </span><span>+</span><span> </span><span>2</span><span>);</span><span></span>
<span>            </span><span>break</span><span>;</span><span></span>
</code></pre></div>

<p>As a consequence of this infinite loop, the affected computer never finishes booting up.</p>
<h3>CVE-2023-45234: Buffer overflow when processing DNS Servers option in a DHCPv6 Advertise message</h3>
<p>The function <code>PxeBcHandleDhcp6Offer</code> in <code>NetworkPkg/UefiPxeBcDxe/PxeBcDhcp6.c</code> handles DHCPv6 offers made by DHCPv6 servers in response to EDK II <code>Solicit</code> messages.
The function allocates a pool buffer with the size given by the <code>OPTION_DNS_SERVERS</code> (0x17) option length at [1], which is controlled by the DHCPv6 server, then at [2] it calls <code>CopyMem</code> with a fixed size: <code>sizeof (EFI_IPv6_ADDRESS)</code>, which is 0x10. This means that if the length of the <code>OPTION_DNS_SERVERS</code> option included in the server response is shorter than 0x10, then that leads to a buffer overflow.</p>
<div><pre><span></span><code><span>PxeBcHandleDhcp6Offer</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>PXEBC_PRIVATE_DATA</span><span>  </span><span>*</span><span>Private</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>    </span><span>[...]</span><span></span>
<span>    </span><span>// First try to cache DNS server address if DHCP6 offer provides.</span>
<span>    </span><span>//</span>
<span>    </span><span>if</span><span> </span><span>(</span><span>Cache6</span><span>-&gt;</span><span>OptList</span><span>[</span><span>PXEBC_DHCP6_IDX_DNS_SERVER</span><span>]</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>[</span><span>1</span><span>]</span><span>     </span><span>Private</span><span>-&gt;</span><span>DnsServer</span><span> </span><span>=</span><span> </span><span>AllocateZeroPool</span><span> </span><span>(</span><span>NTOHS</span><span> </span><span>(</span><span>Cache6</span><span>-&gt;</span><span>OptList</span><span>[</span><span>PXEBC_DHCP6_IDX_DNS_SERVER</span><span>]</span><span>-&gt;</span><span>OpLen</span><span>));</span><span></span>
<span>        </span><span>if</span><span> </span><span>(</span><span>Private</span><span>-&gt;</span><span>DnsServer</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>            </span><span>return</span><span> </span><span>EFI_OUT_OF_RESOURCES</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>

<span>[</span><span>2</span><span>]</span><span>     </span><span>CopyMem</span><span> </span><span>(</span><span>Private</span><span>-&gt;</span><span>DnsServer</span><span>,</span><span> </span><span>Cache6</span><span>-&gt;</span><span>OptList</span><span>[</span><span>PXEBC_DHCP6_IDX_DNS_SERVER</span><span>]</span><span>-&gt;</span><span>Data</span><span>,</span><span> </span><span>sizeof</span><span> </span><span>(</span><span>EFI_IPv6_ADDRESS</span><span>));</span><span></span>
<span>  </span><span>}</span><span></span>
</code></pre></div>

<h3>CVE-2023-45235: Buffer overflow when handling Server ID option from a DHCPv6 proxy Advertise message</h3>
<p>The function <code>PxeBcRequestBootService</code> in <code>NetworkPkg/UefiPxeBcDxe/PxeBcDhcp6.c</code> builds and sends a request to retrieve the boot file, and parses the reply.</p>
<div><pre><span></span><code><span>EFI_STATUS</span><span></span>
<span>PxeBcRequestBootService</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>PXEBC_PRIVATE_DATA</span><span>  </span><span>*</span><span>Private</span><span>,</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>UINT32</span><span>              </span><span>Index</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>[...]</span><span></span>
<span>    </span><span>EFI_PXE_BASE_CODE_DHCPV6_PACKET</span><span>  </span><span>*</span><span>Discover</span><span>;</span><span></span>
<span>[...]</span><span></span>

<span>[</span><span>1</span><span>]</span><span> </span><span>Discover</span><span> </span><span>=</span><span> </span><span>AllocateZeroPool</span><span> </span><span>(</span><span>sizeof</span><span> </span><span>(</span><span>EFI_PXE_BASE_CODE_DHCPV6_PACKET</span><span>));</span><span></span>
<span>    </span><span>if</span><span> </span><span>(</span><span>Discover</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>EFI_OUT_OF_RESOURCES</span><span>;</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>//</span>
<span>    </span><span>// Build the request packet by the cached request packet before.</span>
<span>    </span><span>//</span>
<span>    </span><span>Discover</span><span>-&gt;</span><span>TransactionId</span><span> </span><span>=</span><span> </span><span>IndexOffer</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Header</span><span>.</span><span>TransactionId</span><span>;</span><span></span>
<span>    </span><span>Discover</span><span>-&gt;</span><span>MessageType</span><span>   </span><span>=</span><span> </span><span>Request</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Header</span><span>.</span><span>MessageType</span><span>;</span><span></span>
<span>    </span><span>RequestOpt</span><span>              </span><span>=</span><span> </span><span>Request</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Option</span><span>;</span><span></span>
<span>    </span><span>DiscoverOpt</span><span>             </span><span>=</span><span> </span><span>Discover</span><span>-&gt;</span><span>DhcpOptions</span><span>;</span><span></span>
<span>    </span><span>DiscoverLen</span><span>             </span><span>=</span><span> </span><span>sizeof</span><span> </span><span>(</span><span>EFI_DHCP6_HEADER</span><span>);</span><span></span>
<span>    </span><span>RequestLen</span><span>              </span><span>=</span><span> </span><span>DiscoverLen</span><span>;</span><span></span>

<span>    </span><span>//</span>
<span>    </span><span>// Find Server ID Option from ProxyOffer.</span>
<span>    </span><span>//</span>
<span>[</span><span>2</span><span>]</span><span> </span><span>if</span><span> </span><span>(</span><span>Private</span><span>-&gt;</span><span>OfferBuffer</span><span>[</span><span>Index</span><span>].</span><span>Dhcp6</span><span>.</span><span>OfferType</span><span> </span><span>==</span><span> </span><span>PxeOfferTypeProxyBinl</span><span>)</span><span> </span><span>{</span><span></span>
<span>[</span><span>3</span><span>]</span><span>     </span><span>Option</span><span> </span><span>=</span><span> </span><span>PxeBcDhcp6SeekOption</span><span> </span><span>(</span><span></span>
<span>                   </span><span>IndexOffer</span><span>-&gt;</span><span>Dhcp6</span><span>.</span><span>Option</span><span>,</span><span></span>
<span>                   </span><span>IndexOffer</span><span>-&gt;</span><span>Length</span><span> </span><span>-</span><span> </span><span>4</span><span>,</span><span></span>
<span>                   </span><span>DHCP6_OPT_SERVER_ID</span><span></span>
<span>                   </span><span>);</span><span></span>
<span>        </span><span>if</span><span> </span><span>(</span><span>Option</span><span> </span><span>==</span><span> </span><span>NULL</span><span>)</span><span> </span><span>{</span><span></span>
<span>          </span><span>return</span><span> </span><span>EFI_NOT_FOUND</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>

<span>      </span><span>//</span>
<span>      </span><span>// Add Server ID Option.</span>
<span>      </span><span>//</span>
<span>      </span><span>OpLen</span><span> </span><span>=</span><span> </span><span>NTOHS</span><span> </span><span>(((</span><span>EFI_DHCP6_PACKET_OPTION</span><span> </span><span>*</span><span>)</span><span>Option</span><span>)</span><span>-&gt;</span><span>OpLen</span><span>);</span><span></span>
<span>[</span><span>4</span><span>]</span><span>   </span><span>CopyMem</span><span> </span><span>(</span><span>DiscoverOpt</span><span>,</span><span> </span><span>Option</span><span>,</span><span> </span><span>OpLen</span><span> </span><span>+</span><span> </span><span>4</span><span>);</span><span></span>
<span>      </span><span>DiscoverOpt</span><span> </span><span>+=</span><span> </span><span>(</span><span>OpLen</span><span> </span><span>+</span><span> </span><span>4</span><span>);</span><span></span>
<span>      </span><span>DiscoverLen</span><span> </span><span>+=</span><span> </span><span>(</span><span>OpLen</span><span> </span><span>+</span><span> </span><span>4</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
</code></pre></div>

<p>At [1] the function allocates a buffer in the pool to hold an <code>EFI_PXE_BASE_CODE_DHCPV6_PACKET</code> structure, which is defined this way in <code>MdePkg/Include/Protocol/PxeBaseCode.h</code>:</p>
<div><pre><span></span><code><span>///</span>
<span>/// DHCPV6 Packet structure.</span>
<span>///</span>
<span>typedef</span><span> </span><span>struct</span><span> </span><span>{</span><span></span>
<span>  </span><span>UINT32</span><span>    </span><span>MessageType</span><span>   </span><span>:</span><span> </span><span>8</span><span>;</span><span></span>
<span>  </span><span>UINT32</span><span>    </span><span>TransactionId</span><span> </span><span>:</span><span> </span><span>24</span><span>;</span><span></span>
<span>  </span><span>UINT8</span><span>     </span><span>DhcpOptions</span><span>[</span><span>1024</span><span>];</span><span></span>
<span>}</span><span> </span><span>EFI_PXE_BASE_CODE_DHCPV6_PACKET</span><span>;</span><span></span>
</code></pre></div>

<p>If the DHCPv6 offer it has received is a proxy one ([2]), then the function searches for the <em>Server ID</em> option contained within said DHCPv6 offer ([3]), and proceeds to copy it to <code>Discover-&gt;DhcpOptions</code> (the buffer that was previously allocated in the pool at [1]), blindly trusting the option length as the size of the copy, which is fully controlled by the DHCPv6 server ([4]).</p>
<p>As a result, if the <em>Server ID</em> option of the DHCPv6 proxy offer is longer than 1024 bytes (the size of the <code>DhcpOptions</code> member of the <code>EFI_PXE_BASE_CODE_DHCPV6_PACKET</code> struct), it results in a pool buffer overflow.</p>
<h3>CVE-2023-45236: Predictable TCP Initial Sequence Numbers</h3>
<p>Predictable TCP Initial Sequence Numbers (ISNs) are known to be a security issue since 1985 (see <a href="http://nil.lcs.mit.edu/rtm/papers/117.pdf">Morris1985</a> and <a href="https://www.cs.columbia.edu/~smb/papers/acsac-ipext.pdf">Belovin1989</a>) and a practical attack that exploits it was described in 1995 by Laurent Joncheray (<a href="https://www.usenix.org/legacy/publications/library/proceedings/security95/full_papers/joncheray.pdf">Joncheray1995</a>). A real world instance of an attack that exploited weak TCP ISNs to inject data in a TCP session to compromise a system was disclosed in 1995 (<a href="https://www.win.tue.nl/~aeb/linux/hh/shimomura-25jan95.txt">Shimomura1995</a>).</p>
<p>Given these and other findings, <a href="https://www.rfc-editor.org/rfc/rfc1948">RFC1948</a> proposed an algorithm to generate TCP ISNs in a way that prevents the described attack. In 2012 <a href="https://www.rfc-editor.org/rfc/rfc6528">RFC6528</a> officially updated the TCP protocol specification and the new TCP ISN algorithm achieved the status of Proposed Standard. In August 2022, <a href="https://datatracker.ietf.org/doc/html/rfc9293">RFC 9293</a> a revision of the core TCP specification was published as the new Internet Standard, and the aforementioned algorithm was recommended for the generation of TCP ISNs.</p>
<p>The TCP implementation in Tianocore&#39;s EDK II IP stack generates trivially predictable TCP Initial Sequence Numbers and it is therefore vulnerable to TCP session hijack attacks.</p>
<p>The ISN for a new TCP instance is populated in <code>TcpInitTcbLocal</code> by calling <code>TcpGetIss()</code> as shown below
in file <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/TcpDxe/TcpMisc.c#L69">TcpMisc.c</a></p>
<div><pre><span></span><code><span>TcpInitTcbLocal</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>OUT</span><span> </span><span>TCP_CB</span><span>  </span><span>*</span><span>Tcb</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>  </span><span>//</span>
<span>  </span><span>// Compute the checksum of the fixed parts of pseudo header</span>
<span>  </span><span>//</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>Tcb</span><span>-&gt;</span><span>Sk</span><span>-&gt;</span><span>IpVersion</span><span> </span><span>==</span><span> </span><span>IP_VERSION_4</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>Tcb</span><span>-&gt;</span><span>HeadSum</span><span> </span><span>=</span><span> </span><span>NetPseudoHeadChecksum</span><span> </span><span>(</span><span></span>
<span>                     </span><span>Tcb</span><span>-&gt;</span><span>LocalEnd</span><span>.</span><span>Ip</span><span>.</span><span>Addr</span><span>[</span><span>0</span><span>],</span><span></span>
<span>                     </span><span>Tcb</span><span>-&gt;</span><span>RemoteEnd</span><span>.</span><span>Ip</span><span>.</span><span>Addr</span><span>[</span><span>0</span><span>],</span><span></span>
<span>                     </span><span>0x06</span><span>,</span><span></span>
<span>                     </span><span>0</span><span></span>
<span>                     </span><span>);</span><span></span>
<span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>Tcb</span><span>-&gt;</span><span>HeadSum</span><span> </span><span>=</span><span> </span><span>NetIp6PseudoHeadChecksum</span><span> </span><span>(</span><span></span>
<span>                     </span><span>&amp;</span><span>Tcb</span><span>-&gt;</span><span>LocalEnd</span><span>.</span><span>Ip</span><span>.</span><span>v6</span><span>,</span><span></span>
<span>                     </span><span>&amp;</span><span>Tcb</span><span>-&gt;</span><span>RemoteEnd</span><span>.</span><span>Ip</span><span>.</span><span>v6</span><span>,</span><span></span>
<span>                     </span><span>0x06</span><span>,</span><span></span>
<span>                     </span><span>0</span><span></span>
<span>                     </span><span>);</span><span></span>
<span>  </span><span>}</span><span></span>

<span>&gt;</span><span> </span><span>Tcb</span><span>-&gt;</span><span>Iss</span><span>    </span><span>=</span><span> </span><span>TcpGetIss</span><span> </span><span>();</span><span> </span><span>/** new ISN is populated **/</span><span></span>
<span>  </span><span>Tcb</span><span>-&gt;</span><span>SndUna</span><span> </span><span>=</span><span> </span><span>Tcb</span><span>-&gt;</span><span>Iss</span><span>;</span><span></span>
<span>  </span><span>Tcb</span><span>-&gt;</span><span>SndNxt</span><span> </span><span>=</span><span> </span><span>Tcb</span><span>-&gt;</span><span>Iss</span><span>;</span><span></span>

<span>  </span><span>Tcb</span><span>-&gt;</span><span>SndWl2</span><span> </span><span>=</span><span> </span><span>Tcb</span><span>-&gt;</span><span>Iss</span><span>;</span><span></span>
<span>  </span><span>Tcb</span><span>-&gt;</span><span>SndWnd</span><span> </span><span>=</span><span> </span><span>536</span><span>;</span><span></span>
</code></pre></div>

<p>The function <code>TcpGetIss</code> simply increments a global counter using a fixed increment as seen <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/TcpDxe/TcpMisc.c#L514">below</a>:</p>
<div><pre><span></span><code><span>TCP_SEQNO</span><span></span>
<span>TcpGetIss</span><span> </span><span>(</span><span></span>
<span>  </span><span>VOID</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>  </span><span>mTcpGlobalIss</span><span> </span><span>+=</span><span> </span><span>TCP_ISS_INCREMENT_1</span><span>;</span><span></span>
<span>  </span><span>return</span><span> </span><span>mTcpGlobalIss</span><span>;</span><span></span>
<span>}</span><span></span>
</code></pre></div>

<p>The global variable <code>mTcpGlobalIss</code> is initialized to a fixed value in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/TcpDxe/TcpMisc.c#L23">line 23 of TcpMisc.c</a></p>
<div><pre><span></span><code><span>TCP_SEQNO</span><span>  </span><span>mTcpGlobalIss</span><span> </span><span>=</span><span> </span><span>TCP_BASE_ISS</span><span>;</span><span></span>
</code></pre></div>

<p>The global variable is also updated with a fixed increment by the timer in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/TcpDxe/TcpTimer.c#L486">TcpTimer.c</a></p>
<div><pre><span></span><code><span>VOID</span><span></span>
<span>EFIAPI</span><span></span>
<span>TcpTickingDpc</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span> </span><span>VOID</span><span>  </span><span>*</span><span>Context</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>  </span><span>LIST_ENTRY</span><span>  </span><span>*</span><span>Entry</span><span>;</span><span></span>
<span>  </span><span>LIST_ENTRY</span><span>  </span><span>*</span><span>Next</span><span>;</span><span></span>
<span>  </span><span>TCP_CB</span><span>      </span><span>*</span><span>Tcb</span><span>;</span><span></span>
<span>  </span><span>INT16</span><span>       </span><span>Index</span><span>;</span><span></span>

<span>  </span><span>mTcpTick</span><span>++</span><span>;</span><span></span>
<span>  </span><span>mTcpGlobalIss</span><span> </span><span>+=</span><span> </span><span>TCP_ISS_INCREMENT_2</span><span>;</span><span></span>
</code></pre></div>

<p>The values <code>TCP_BASE_ISS</code>, <code>TCP_ISS_INCREMENT_1</code> and <code>TCP_ISS_INCREMENT_2</code> are defined in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/TcpDxe/TcpMain.h#L52">TcpMain.h</a>:</p>
<div><pre><span></span><code><span>///</span>
<span>/// The implementation selects the initial send sequence number and the unit to</span>
<span>/// be added when it is increased.</span>
<span>///</span>
<span>#define TCP_BASE_ISS         0x4d7e980b</span>
<span>#define TCP_ISS_INCREMENT_1  2048</span>
<span>#define TCP_ISS_INCREMENT_2  100</span>
</code></pre></div>

<p>Therefore Tianocore&#39;s EDK II TCP implementation generates ISNs using fixed increments from a fixed base value and thus is susceptible to TCP session injection and session hijack attacks.</p>
<h3>CVE-2023-45237: Use of a Weak PseudoRandom Number Generator</h3>
<p>The EDK II IP stack uses a pseudorandom number generator which is defined in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/Include/Library/NetLib.h#L542"><code>Network/Include/Library/NetLIb.h</code></a> as:</p>
<div><pre><span></span><code><span>#define NET_RANDOM(Seed)  ((UINT32) ((UINT32) (Seed) * 1103515245UL + 12345) % 4294967295UL)</span>
</code></pre></div>

<p>Throughout the NetworkPkg stack the above macro is used with <code>Seed</code> usually taking the value from the <code>NetRandomInitSeed()</code> function defined in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/Library/DxeNetLib/DxeNetLib.c#L898">NetworkPkg/Library/DxeNetLib/DxeNetLib.c</a> as follows:</p>
<div><pre><span></span><code><span>UINT32</span><span></span>
<span>EFIAPI</span><span></span>
<span>NetRandomInitSeed</span><span> </span><span>(</span><span></span>
<span>  </span><span>VOID</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span>  </span><span>EFI_TIME</span><span>  </span><span>Time</span><span>;</span><span></span>
<span>  </span><span>UINT32</span><span>    </span><span>Seed</span><span>;</span><span></span>
<span>  </span><span>UINT64</span><span>    </span><span>MonotonicCount</span><span>;</span><span></span>

<span>  </span><span>gRT</span><span>-&gt;</span><span>GetTime</span><span> </span><span>(</span><span>&amp;</span><span>Time</span><span>,</span><span> </span><span>NULL</span><span>);</span><span></span>
<span>  </span><span>Seed</span><span>  </span><span>=</span><span> </span><span>(</span><span>Time</span><span>.</span><span>Hour</span><span> </span><span>&lt;&lt;</span><span> </span><span>24</span><span> </span><span>|</span><span> </span><span>Time</span><span>.</span><span>Day</span><span> </span><span>&lt;&lt;</span><span> </span><span>16</span><span> </span><span>|</span><span> </span><span>Time</span><span>.</span><span>Minute</span><span> </span><span>&lt;&lt;</span><span> </span><span>8</span><span> </span><span>|</span><span> </span><span>Time</span><span>.</span><span>Second</span><span>);</span><span></span>
<span>  </span><span>Seed</span><span> </span><span>^=</span><span> </span><span>Time</span><span>.</span><span>Nanosecond</span><span>;</span><span></span>
<span>  </span><span>Seed</span><span> </span><span>^=</span><span> </span><span>Time</span><span>.</span><span>Year</span><span> </span><span>&lt;&lt;</span><span> </span><span>7</span><span>;</span><span></span>

<span>  </span><span>gBS</span><span>-&gt;</span><span>GetNextMonotonicCount</span><span> </span><span>(</span><span>&amp;</span><span>MonotonicCount</span><span>);</span><span></span>
<span>  </span><span>Seed</span><span> </span><span>+=</span><span> </span><span>(</span><span>UINT32</span><span>)</span><span>MonotonicCount</span><span>;</span><span></span>

<span>  </span><span>return</span><span> </span><span>Seed</span><span>;</span><span></span>
<span>}</span><span></span>
</code></pre></div>

<p>The above function outputs an integer value based on the platform&#39;s clock time at which the function is called and the platform&#39;s monotonic counter. The C language idiom <code>NET_RANDOM (NetRandomInitSeed()</code> is used in several <code>NetworkPkg</code> functions to generate supposedly random unique numeric identifiers for various network protocol fields. Generating numbers in such a way does not produce random numbers with a uniform distribution, instead, it produces easily predictable numbers and a biased distribution. Furthermore, the use of the same idiom in different network layers to assign allegedly random values to protocols&#39; fields or objects makes it possible for an external observer to recover the internal state of the generator by obtaining samples of the numbers used in any such network layer.</p>
<p>The idiom is used to generate DNS query IDs in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/DnsDxe/DnsImpl.c#L1980"><code>ConstructDNSQuery</code></a>:</p>
<div><pre><span></span><code><span>ConstructDNSQuery</span><span> </span><span>(</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>DNS_INSTANCE</span><span>  </span><span>*</span><span>Instance</span><span>,</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>CHAR8</span><span>         </span><span>*</span><span>QueryName</span><span>,</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>UINT16</span><span>        </span><span>Type</span><span>,</span><span></span>
<span>  </span><span>IN</span><span>  </span><span>UINT16</span><span>        </span><span>Class</span><span>,</span><span></span>
<span>  </span><span>OUT</span><span> </span><span>NET_BUF</span><span>       </span><span>**</span><span>Packet</span><span></span>
<span>  </span><span>)</span><span></span>
<span>{</span><span></span>
<span> </span><span>...</span><span></span>
<span>  </span><span>//</span>
<span>  </span><span>// Fill header</span>
<span>  </span><span>//</span>
<span>  </span><span>DnsHeader</span><span>                    </span><span>=</span><span> </span><span>(</span><span>DNS_HEADER</span><span> </span><span>*</span><span>)</span><span>Frag</span><span>.</span><span>Bulk</span><span>;</span><span></span>
<span>  </span><span>DnsHeader</span><span>-&gt;</span><span>Identification</span><span>    </span><span>=</span><span> </span><span>(</span><span>UINT16</span><span>)</span><span>NET_RANDOM</span><span> </span><span>(</span><span>NetRandomInitSeed</span><span> </span><span>());</span><span></span>
<span>  </span><span>DnsHeader</span><span>-&gt;</span><span>Flags</span><span>.</span><span>Uint16</span><span>      </span><span>=</span><span> </span><span>0x0000</span><span>;</span><span></span>
<span>  </span><span>DnsHeader</span><span>-&gt;</span><span>Flags</span><span>.</span><span>Bits</span><span>.</span><span>RD</span><span>     </span><span>=</span><span> </span><span>1</span><span>;</span><span></span>
<span>  </span><span>DnsHeader</span><span>-&gt;</span><span>Flags</span><span>.</span><span>Bits</span><span>.</span><span>OpCode</span><span> </span><span>=</span><span> </span><span>DNS_FLAGS_OPCODE_STANDARD</span><span>;</span><span></span>
<span>  </span><span>DnsHeader</span><span>-&gt;</span><span>Flags</span><span>.</span><span>Bits</span><span>.</span><span>QR</span><span>     </span><span>=</span><span> </span><span>DNS_FLAGS_QR_QUERY</span><span>;</span><span></span>
<span>  </span><span>...</span><span></span>
</code></pre></div>

<p>It is also used to initialize the value of the IPv4 IP ID field in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/Ip4Dxe/Ip4Driver.c#L656"><code>Ip4DriverBindingStart()</code></a>:</p>
<div><pre><span></span><code><span>//</span>
<span>  </span><span>// Initialize the IP4 ID</span>
<span>  </span><span>//</span>
<span>  </span><span>mIp4Id</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT16</span><span>)</span><span>NET_RANDOM</span><span> </span><span>(</span><span>NetRandomInitSeed</span><span> </span><span>());</span><span></span>
</code></pre></div>

<p>which is simply incremented for each outgoing IPv4 datagram in <a href="https://github.com/tianocore/edk2/blob/master/NetworkPkg/Ip4Dxe/Ip4Output.c#L258"><code>Ip4Output()</code></a></p>
<div><pre><span></span><code><span>  </span><span>// Before IPsec process, prepared the IP head.</span>
<span>  </span><span>// If Ip4Output is transmitting RawData, don&#39;t update IPv4 header.</span>
<span>  </span><span>//</span>
<span>  </span><span>HeadLen</span><span> </span><span>=</span><span> </span><span>sizeof</span><span> </span><span>(</span><span>IP4_HEAD</span><span>)</span><span> </span><span>+</span><span> </span><span>((</span><span>OptLen</span><span> </span><span>+</span><span> </span><span>3</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>~</span><span>0x03</span><span>));</span><span></span>

<span>  </span><span>if</span><span> </span><span>((</span><span>IpInstance</span><span> </span><span>!=</span><span> </span><span>NULL</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>IpInstance</span><span>-&gt;</span><span>ConfigData</span><span>.</span><span>RawData</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>RawData</span><span> </span><span>=</span><span> </span><span>TRUE</span><span>;</span><span></span>
<span>  </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>    </span><span>Head</span><span>-&gt;</span><span>HeadLen</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT8</span><span>)(</span><span>HeadLen</span><span> </span><span>&gt;&gt;</span><span> </span><span>2</span><span>);</span><span></span>
<span>    </span><span>Head</span><span>-&gt;</span><span>Id</span><span>      </span><span>=</span><span> </span><span>mIp4Id</span><span>++</span><span>;</span><span></span>
<span>    </span><span>Head</span><span>-&gt;</span><span>Ver</span><span>     </span><span>=</span><span> </span><span>4</span><span>;</span><span></span>
<span>    </span><span>RawData</span><span>       </span><span>=</span><span> </span><span>FALSE</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
</code></pre></div>

<p>The same idiom is used to initialize the fragment ID for IPv6 fragmentation Extension Headers, to generate DHCP transaction IDs on both Dhcp4 and Dhcp6 code, to obtain ephemeral port numbers for UDP and TCP, and in other parts of the stack.</p>
<p>The security and privacy vulnerabilities arising from the use of a weak pseudorandom number generator in various Internet Protocols are described in <a href="https://datatracker.ietf.org/doc/rfc9414/">RFC 9414</a> and a number of algorithms to address those issues are suggested in <a href="https://datatracker.ietf.org/doc/rfc9414/">RFC 9415</a>. In this particular case, the use of a weak PRNG could facilitate DNS and DHCP poisoning attacks, information leakage, denial of service, and data insertion attacks at the IPv4 and IPv6 layer (due also to the use of a per datagram unit increment of the corresponding ID fields).</p>
<p>At the root of this issue is the use of a <em>Linear Congruential Generator</em> to generate a sequence of pseudorandom <em>security-sensitive</em> numbers. The unsuitability of LCGs for security-sensitive purposes (where the numbers generated should not be guessable) has been known for decades, for example in <a href="https://www.enseignement.polytechnique.fr/profs/informatique/Francois.Morain/Master1/Crypto/projects/Stern87.pdf">Stern 1987</a>.</p>
<h3>Acknowledgements</h3>
<p>We would like to thank our colleagues at Quarkslab for providing feedback and reviewing and editing this blog post.
We would also like to thank Vijay Sarvepalli of CERT/CC, the team members of CERT-FR, and all the PSIRT and product security coordinators from the multiple vendors that participated in the disclosure process.</p>
<h3>Disclosure timeline</h3>
<p>Below we include a timeline of all the relevant events during the coordinated vulnerability disclosure process with the intent of providing transparency to the whole process and our actions. The timeline also serves as a detailed example of the complexity of reporting vulnerabilities and coordinating the development and release of security fixes in a complex multi-vendor firmware supply chain.</p>
<ul>
<li><strong>2023-08-03</strong> Quarkslab sent to CERT/CC a report describing the vulnerabilities and providing proof-of-concept programs to reproduce the first 7 of them. A case was opened in CERT&#39;s vulnerability coordination portal. Disclosure deadline is set to November 2nd, 2023.</li>
<li><strong>2023-08-03</strong> <strong>CERT/CC made the report in the vulnerability reporting portal available to vendors and set the target disclosure date to November 2nd, 2023</strong>.</li>
<li><strong>2023-08-04</strong> Quarkslab opened 9 issues in Google&#39;s ChromeOS issue tracker because EDK2 is included as a package in the ChromeOS source code tree.</li>
<li><strong>2023-08-05</strong> Google indicated that EDK2 is not used in production Chromebooks and therefore they are not affected by the vulnerabilities.</li>
<li><strong>2023-08-08</strong> Tianocore opened an issue in their issue tracker.</li>
<li><strong>2023-08-08</strong> Insyde Software requested clarifications about the disclosure date. Quarkslab indicated disclosure is set to November 2nd, 2023, 90 days since the initial report.</li>
<li><strong>2023-08-17</strong> Quarkslab posted on the vulnerability coordination portal a request for a status update and asked if the vulnerabilities have been triaged, if any vendors have confirmed being vulnerable, if there were any estimated dates for fixes, if CVEs have been assigned, and indicated that it did not have access to Tianocore&#39;s bug tracking system to see progress on the treatment of the issues.</li>
<li><strong>2023-
08-18</strong> AMI informed that Tianocore&#39;s PSIRT lead had retired and explained that once a new one was assigned, a volunteer would pick up the issue. Indicated that November 2nd, 2023 was too optimistic for a deadline and asked if Quarkslab had plans for public disclosure.</li>
<li><strong>2023-08-18</strong> Quarkslab replied that disclosure was potentially planned in talk at an upcoming security conference and that in any case, results of the associated research project had to be published in 2023.</li>
<li><strong>2023-08-18</strong> AMI informed that Tianocore was considering acknowledging vulnerability finders in their public advisories and that to improve responsiveness anyone could contribute fixes.</li>
<li><strong>2023-08-20</strong> Quarkslab encouraged Tianocore&#39;s adoption of the policy of acknowledging bug finders as other vendors do and asked if it was suggested that to improve responsiveness Quarkslab should contribute the fixes. Indicated that the suggestion would be considered but since vendors in the Tianocore consortium had 100x to 1000x more engineering capacity and based their commercial UEFI implementations on EDK2, it would be more reasonable for them to develop the fixes and not rely on external contributors.</li>
<li><strong>2023-08-28</strong> AMI wrote that often researchers are well positioned to implement fixes, informed that it opened 9 issues in Tianocore bug tracker to follow each vulnerability individually, and asked if Quarkslab felt it could remediate any.  </li>
<li><strong>2023-08-28</strong> Quarkslab replied that the maintainers and developers of EDK2 would be in the best position to develop and test fixes, as they are already familiar with the code and do not have to incur in any setup cost to do it. Quarkslab would rather like that the organizations supporting Tianocore dedicated their vast resources to implement fixes in a timely manner. In Quarkslab&#39;s opinion, fixes for vulnerabilities 1 to 7 should be easy to produce quickly, while vulnerabilities 8 and 9 would take more time as they require implementation and use of a new PRNG (possibly using building blocks that already exist in EDK2) in the PXE stack. However, given that these issues have been known and documented for over a quarter of a century, they should be considered public knowledge in any open source network stack.</li>
<li><strong>2023-09-06</strong> Insyde Software asked Quarkslab if the publication date could be postponed by 30 days, as the issues had to be addressed by 4 sets of PSIRT teams (Tianocore, IFVs, ODMs, OEMs). </li>
<li><strong>2023-09-06</strong> Quarkslab agreed to re-schedule disclosure to December 1st, 2023 and said that so far only Insyde Software indicated it was affected and addressing the vulnerabilities.</li>
<li><strong>2023-09-09</strong> Phoenix Technologies indicated that several members of Tianocore&#39;s open-source community were working on patches, and the first 7 vulnerabilities would have patches shortly and the other two would take a bit longer. CVEs would be assigned soon. </li>
<li><strong>2023-09-10</strong> Phoenix Technologies shared the CVEs assigned by Tianocore.</li>
<li><strong>2023-09-11</strong> A Tianocore core developer indicated that he was working on making fixes unit-testable.</li>
<li><strong>2023-09-14</strong> <strong>CERT/CC updated the target disclosure date to December 1st, 2023</strong>.</li>
<li><strong>2023-10-06</strong> AMI indicated that non-validated patches were available on Tianocore&#39;s bug tracker.</li>
<li><strong>2023-10-12</strong> Google indicated that it removed the unused EDK2 package from their source code repos. The 9 issues were closed.</li>
<li><strong>2023-10-23</strong> Microsoft asked if it was possible to postpose the Dec. 1, 2023 disclosure date as they would need more time to deploy a complete fix on their cloud infrastructure and depended on some partners for it. Also asked if Quarkslab was to publish the details in a blog post.</li>
<li><strong>2023-10-23</strong> Quarkslab agreed to reschedule disclosure to December 7th, 2023 but reminded that, as stated in August, needed to publish the research work within 2023. It also indicated that since vendors were already progressing towards releasing fixes, it did not think reasonable to delay disclosure much longer, and confirmed that details about the vulnerabilities would be published in a blog post.</li>
<li><strong>2023-10-25</strong> Microsoft said that postponing disclosure one week was immaterial as it would not allow sufficient time to roll out comprehensive fixes to customers. Asked for the specific technical content of the blog post to be published, expressing concerns that exploit code would be included and asked if it was possible not to do so. Indicated that they had confirmed with Tianocore that patches were not finalized yet and were unlikely to be available before the December disclosure date and that they disagreed with Quarkslab&#39;s assumption that &#34;vendors were progressing towards releasing fixes&#34;. Microsoft asked to hold off disclosure until May 2024.</li>
<li><strong>2023-10-25</strong> A Tianocore core developer requested more time to get products patched and clarified that there were no validated patches on the open source side yet, a first draft had been submitted for review and the expectation was they&#39;d become available in November to Tianocore&#39;s infosec community. Patches would then have to be integrated, tested and deployed to customer devices which usually takes months. The core developer referenced a <a href="https://uefi.org/sites/default/files/resources/What%20is%20UEFI-Aug31-2023-Final.pdf">UEFI Forum paper</a> which describes the complex supply chain challenges of the UEFI ecosystem, and indicated that &#34;any public announcement before middle of 2024 would cause significant negative impact.&#34;</li>
<li><strong>2023-10-25</strong> Phoenix Technologies expressed strong support for Tianocore&#39;s and Microsoft&#39;s position and indicated that the ongoing case was mentioned in a podcast (without providing any technical details) to exemplify the difficulties of producing patches and why embargo lengths must be flexible. </li>
<li><strong>2023-10-27</strong> CERT/CC asked Tianocore and vendors to continue working with supply-chain channels and partners towards the disclosure date as it may be difficult for Quarkslab to postpone it since it was also working with other stakeholders.</li>
<li><strong>2023-11-01</strong> A Tianocore core developer indicated that some patches were being unit tested and submitted for validation.</li>
<li><strong>2023-11-07</strong> AMI told Quarkslab that Tianocore considered CVE-2023-45236 and CVE-2023-45237 weaknesses rather than vulnerabilities primarily due to lack of &#34;proven, computationally feasible exploitability&#34; and asked to provide a PoC if it existed.</li>
<li><strong>2023-11-08</strong> Dell asked for confirmation that Quarkslab planned to  disclose the vulnerabilities in a blog post.</li>
<li><strong>2023-11-11</strong> Microsoft asked Quarkslab to share a technical draft of the contents that would be published in the blog, reiterated its concerns that it would contain explicit details regarding exploit code and asked for the exploit code not to be added.</li>
<li><strong>2023-11-13</strong> Dell agreed with Microsoft&#39;s position that delaying disclosure one week did not make a difference, and said that a later disclosure (May 2024) would be more suitable. </li>
<li><strong>2023-11-13</strong> A Tianocore core developer indicated that patches for the vulnerabilities 1 to 7 were available in a private Pull Request on Tianocore&#39;s GitHub repository.</li>
<li><strong>2023-11-13</strong> Microsoft stated that 4 vendors had expressed concerns about the December 12th, 2023 disclosure date and asked CERT/CC to relay their message to Quarkslab.</li>
<li><strong>2023-11-14</strong> Quarkslab responded to AMI&#39;s message communicating Tianocore&#39;s assessment of <strong>CVE-2023-45236</strong> and <strong>CVE-2023-45237</strong> as weaknesses rather than vulnerabilities. Quarkslab expressed disagreement with such an assessment stating that <strong>CVE-2023-45236</strong> (TCP ISNs with the same algorithm as EDK2) had been <a href="https://www.win.tue.nl/~aeb/linux/hh/shimomura-25jan95.txt">exploited in the wild</a> in 1995 and merited a <a href="https://insights.sei.cmu.edu/documents/502/1995_019_001_496168.pdf">security advisory published by CERT</a>, mitigations were proposed in <a href="https://datatracker.ietf.org/doc/html/rfc1948">RFC 1948</a> in 1996, Microsoft considered it a <a href="https://learn.microsoft.com/en-us/security-updates/securitybulletins/1999/ms99-046"><strong>Critical</strong> vulnerability</a> in 1999, motivated another <a href="https://vuls.cert.org/confluence/pages/viewpage.action?pageId=96665752">CERT Advisory</a> in 2001 and was <a href="https://nvd.nist.gov/vuln/detail/cve-2011-3188">fixed again in the Linux kernel</a> in 2011. Over almost 3 decades every major operating system vendor considered it a vulnerability and fixed it as such and therefore Quarkslab did not believe producing an actual exploit was necessary to prove &#34;computationally feasible exploitability&#34;. 
With regards to <strong>CVE-2023-45237</strong> (Use of weak PRNG to generate numeric IDs in the network stack) the same long history of vulnerability disclosures and fixes could be pointed out in several components that suffered from the problem, the most known being predictable DNS query IDs, <a href="https://www.openbsd.org/advisories/sni_12_resolverid.txt">first reported and fixed in 1997</a> and multiple times afterwards, including the fixes issued in 2008 for almost every DNS resolver and DNS server on the planet (for example in <a href="https://learn.microsoft.com/en-us/security-updates/securitybulletins/2008/ms08-020">MS08-20</a>). Quarkslab&#39;s vulnerability report pointed at <a href="https://www.rfc-editor.org/info/rfc9414">RFC 9414</a> which details the long history of problems associated to generation of numeric IDs in network protocols. At the core of these issues is the use of a <em>Linear Congruential Generator</em> to generate a sequence of pseudorandom numbers. EDK2 uses the same LCG as glibc 2.26 (the exact same parameters). The unsuitability of LCGs for security-sensitive purposes (where the numbers generated should not be guessable) have been known for decades, for example in <a href="https://www.enseignement.polytechnique.fr/profs/informatique/Francois.Morain/Master1/Crypto/projects/Stern87.pdf">Stern 1987</a>, therefore Quarkslab did not consider necessary to produce an exploit to prove exploitability.</li>
<li><strong>2023-11-14</strong> Quarkslab replied to the prior requests and commentary from various vendors as follows:<ul>
<li>Stated that the blog post about the issues would contain the technical report submitted to the disclosure coordination forum and a detailed timeline of the relevant events in the disclosure process. It would include proof-of-concept code to trigger vulnerabilities 1 to 7 but NOT exploit code. Reiterated that the purpose of reporting the vulnerabilities was to help vendors identify and fix them, not to debate about the editorial policies for Quarkslab research work. Nonetheless it was willing to discuss that, as well as the quality and lack of technical information in the security advisories and bulletins published by vendors, at an appropriate venue or in a different context.</li>
<li>Indicated that the Quarkslab&#39;s statement of October 23rd (&#34;vendors were progressing towards releasing fixes&#34;) was based not on opinion but the factual evidence of vendor posts on the vulnerability coordination portal.</li>
<li>Strongly disagreed with the opinion expressed by a vendor that &#34;any public announcement before middle of 2024 would cause significant negative impact&#34; and argued that what had significant negative impact was the risk those vulnerabilities were posing to the uninformed users and organizations that run EDK2-derived firmware implementations with the vulnerable NetworkPkg component, and that informing them of their exposure and giving them the necessary information to either fix the vulnerabilities (ideally with official patches), to mitigate them, or to be able to detect active attacks was actually the opposite of having &#34;significant negative impact&#34;.</li>
<li>Indicated that 3 months after the initial report date not a single vendor had committed to an estimated release date for fixes. The original 90-day embargo period was extended to 120 days upon request from a vendor (Insyde Software) and at the time (2 months prior) no vendor objected the new deadline. Yet only 2 weeks ago one vendor proposed to postpone the disclosure deadline for 6 months with no actual concrete release date or timeline for fixes.</li>
<li>Commented that the referenced UEFI Forum paper provides a good description of the complexity of the UEFI firmware supply chain but it argued for a 300-day embargo period by presenting an exceptional case as if it was the general one, and assuming that the existing series of interlocked, extremely waterfall-oriented, software development lifecycles of all stakeholders should explain the need of such period. Quarkslab noted that in August 2023 the US Cybersecurity &amp; Infrastructure Security Agency (CISA) published <a href="https://www.cisa.gov/news-events/news/call-action-bolster-uefi-cybersecurity-now">A Call to Action: Bolster UEFI Cybersecurity Now</a> calling for UEFI vulnerability response, including timely and effective update mechanisms.</li>
<li>Summarized its position with the following: Quarkslab was being asked to extend the embargo period from 120 days (which had already been extended from the original 90) to about 10 months counting from initial report date, without any firm commitment from any vendor to an actual release date and an opaque timeline. Delaying disclosure implies keeping Quarkslab&#39;s partners and customers at risk and in the dark about the vulnerabilities, which in turn put the company in a very uncomfortable position where malicious activities or cyberattacks could happen during that extended time frame. Because of the above, a priori was not inclined to extend our embargo period but since Quarkslab is a company incorporated in France, it decided to consult with CERT-FR (the national CERT of France operated by ANSSI, the French cybersecurity agency) to determine how to proceed. Precise status updates and firm commitment to a release date from affected vendors would be useful to inform any decision.</li>
</ul>
</li>
<li><strong>2023-11-23</strong> Quarkslab contacted CERT-FR and provided the technical report of the vulnerabilities and a summary of the coordinated vulnerability disclosure timeline so far.</li>
<li><strong>2023-11-27</strong> CERT-FR acknowledged the report and summary timeline and requested further discussion in a conference call.</li>
<li><strong>2023-11-27</strong> Quarkslab informed all stakeholder that it was discussing with CERT-FR and in the meantime postponed disclosure to December 12th, 2023. Reiterated that status updates and firm commitment to a release date from affected vendors would be useful to inform any decision.</li>
<li><strong>2023-11-27</strong> <strong>CERT/CC updated the target disclosure date to December 12th, 2023</strong>.</li>
<li><strong>2023-12-06</strong> Quarkslab indicated that at a week before the disclosure date it still did not have any status update from any vendor nor commitments to any release date for fixes.</li>
<li><strong>2023-12-06</strong> Insyde Software submitted a status update and flagged it as public.</li>
<li><strong>2023-12-06</strong> AMI updated their status and indicated the PSIRT activities including advertisement and remediation have been on-going with customers. An advisory would be issued on December 12th, 2023.</li>
<li><strong>2023-12-06</strong> Microsoft updated the status and indicated internal discussions regarding fix commitment timelines were still ongoing.</li>
<li><strong>2023-12-09</strong> Quarkslab indicated that it was still coordinating with CERT-FR and CERT/CC and decided to postpone disclosure one week, to December 19th, 2023 to have a bit more time to prepare and converge on dissemination plans. </li>
<li><strong>2023-12-09</strong> <strong>CERT/CC updated the target disclosure date to December 19th, 2023</strong>.</li>
<li><strong>2023-12-12</strong> Microsoft asked Quarkslab to confirm that it would publish in the blog post the same report as provided in the forum. Asked to for a preview of Quarkslab post.</li>
<li><strong>2023-12-12</strong> Quarkslab replied that it already confirmed that the publication will be the same as the report provided to vendors in the vulnerability coordination portal and that it would include a detailed timeline of the relevant communications towards coordinated disclosure. Reiterated that Quarkslab participation in the portal was to coordinate with vendors the release of patches not to discuss the contents of Quarkslab&#39;s publications. Asked for Microsoft&#39;s estimated date to release fixes, affected products or services, and whether Azure would be exposed.</li>
<li><strong>2023-12-14</strong> CERT-FR asked Quarkslab to clarify circumstances in which the vulnerabilities could be exploited from remote networks.</li>
<li><strong>2023-12-15</strong> Quarkslab described scenarios in which some vulnerabilities could be exploited from remote networks.</li>
<li><strong>2023-12-15</strong> Quarkslab wrote that it discussed the disclosure date with CERT-FR and CERT/CC and CERT-FR indicated they&#39;d like to have additional time to coordinate dissemination of the information to their stakeholders and to other national CERTs. All parties agreed that it would be useful to postpone publication past the end of the year, as many organizations impose a &#34;freeze&#34; on any changes to their data centers and compute infrastructure during the end-of-year period. In view of that it was decided to postpone disclosure to January 15th, 2024. However, if an attack leveraging any of the reported vulnerabilities was discovered in the wild or public disclosure of any of them was observed before the embargo date, Quarkslab would immediately publish the technical report describing the vulnerabilities.</li>
<li><strong>2023-12-15</strong> <strong>CERT/CC updated the target disclosure date to January 15th, 2024</strong>.</li>
<li><strong>2023-12-27</strong> CERT-FR asked CERT/CC and Quarkslab if they agreed that CERT-FR would send an early warning to national CERTs before January 15th, 2024.</li>
<li><strong>2023-12-27</strong> Quarkslab agreed to sending an early warning on January 11th, 2024 or any earlier date of CERT-FR&#39;s choosing.</li>
<li><strong>2023-12-27</strong> CERT/CC agreed to an early warning on January 11th, 2024 as well.</li>
<li><strong>2023-01-08</strong> CERT-FR requested an estimated release date for fixes from several vendors.</li>
<li><strong>2023-01-08</strong> Insyde Software informed that it had already deployed fixes to their downstream supply chain.</li>
<li><strong>2024-01-08</strong> <strong>CERT/CC updated the target disclosure date to January 16th, 2024</strong> as January 15th is a non-working day in the USA.</li>
<li><strong>2024-01-09</strong> AMI informed that it already communicated remediation information to its customers.</li>
<li><strong>2024-01-09</strong> Phoenix Technologies informed that it updated its status to vulnerable and was delivering fixes to partner OEMs.</li>
<li><strong>2024-01-16</strong> Quarkslab blog post published.</li>
</ul>

<hr/><p>

If you would like to learn more about our security audits and explore how we can help you, <a href="https://content.quarkslab.com/talk-to-our-experts-blog">get in touch with us</a>!

</p></div></div>
  </body>
</html>
