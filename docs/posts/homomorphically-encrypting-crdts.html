<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/homomorphically-encrypted-crdts/">Original</a>
    <h1>Homomorphically Encrypting CRDTs</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-onuac4el=""> 



<p>Here’s a problem with local-first software.</p>
<p>You want to work on a document together with a friend who lives far away from you.
That sounds like local-first’s bread and butter: store the document as a CRDT, then use some sort of sync server to merge updates and relay them between you and your friend.</p>
<p>But there’s a catch: the contents of that document are secret.
So secret, in fact, that <em>you don’t even want the app developer to know what they are</em>.</p>
<p>One way to solve this is end-to-end encryption.
You and your friend agree on a secret key, known only to each other.
You each use that key to encrypt your changes before sending them, decrypt them upon receipt, and no one in the middle is able to listen in.
Because the document is a CRDT, you can each still get the latest document without the sync server merging the updates.</p>
<p>That is indeed a solution, and modern browser APIs make it fairly simple to implement a basic version of it. <a href="https://plus.excalidraw.com/blog/end-to-end-encryption" data-astro-cid-bi7aps5f="">Excalidraw’s writeup of their implementation</a><a data-tooltip="" href="https://plus.excalidraw.com/blog/end-to-end-encryption" data-astro-cid-bi7aps5f=""> <img src="https://excalidraw.nyc3.cdn.digitaloceanspaces.com/lp-cms/media/Excalidraw blog - End-to-End Encryption in the Browser-1.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Excalidraw Blog | End-to-End Encryption in the Browser</span> <span data-astro-cid-bi7aps5f="">Excalidraw introduces browser-based end-to-end encryption using Web Cryptography APIs for secure, private drawing storage.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://plus.excalidraw.com/favicon.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">plus.excalidraw.com/blog/end-to-end-encryption</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> is only about 750 words — including code samples!<sup><a href="#user-content-fn-e2ee" id="user-content-fnref-e2ee" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup></p>
<p>Unfortunately, we’ve introduced a new problem.</p>
<p>You and your friend live far away from each other, so you tend to work while they’re sleeping and vice versa.
That was fine when the sync server could merge your changes and send you the latest document when you opened it.</p>
<p>Now, however, the server can no longer understand the changes you send.
We’re faced with a tradeoff:</p>
<ul>
<li>Require both you and your friend to be online at the same time.</li>
<li>Have the sync server merely relay updates between you and your friend without merging.
Although this allows you to work asynchronously, it prevents the server from compressing any of the updates.
If you or your friend are offline for an extended period of time, you might need to download a <em>ton</em> of uncompressed data when you return.</li>
</ul>
<p>Enter <strong>homomorphic encryption</strong>: a special form of encryption that allows a computer to <em>run programs on encrypted data without decrypting it</em>.
Using a homomorphically encrypted CRDT, a sync server could merge your friend’s and your changes into one document without ever knowing what the document contains.<sup><a href="#user-content-fn-otherways" id="user-content-fnref-otherways" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup></p>
<p>In this article, we’ll explore how homomorphic encryption works and build a homomorphically encrypted last write wins register CRDT.
We’ll also learn about some fundamental limitations of homomorphic encryption, and how they affect local-first software specifically.</p>
<p>I try to assume as little knowledge as possible about both encryption and CRDTs.
If you want to brush up before continuing on, my <a href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f="">Interactive Intro to CRDTs</a><a data-tooltip="" href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/og/an-interactive-intro-to-crdts.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">An Interactive Intro to CRDTs | jakelazaroff.com</span> <span data-astro-cid-bi7aps5f="">CRDTs don&#39;t have to be all academic papers and math jargon. Learn what CRDTs are and how they work through interactive visualizations and code samples.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/an-interactive-intro-to-crdts/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> and Jeremy Kun’s <a href="https://www.jeremykun.com/2024/05/04/fhe-overview/" data-astro-cid-bi7aps5f="">A High-Level Technical Overview of Fully Homomorphic Encryption</a><a data-tooltip="" href="https://www.jeremykun.com/2024/05/04/fhe-overview/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">A High-Level Technical Overview of Fully Homomorphic Encryption</span> <span data-astro-cid-bi7aps5f="">About two years ago, I switched teams at Google to focus on fully homomorphic encryption (abbreviated FHE, or sometimes HE). Since then I’ve got to work on a lot of interesting projects, learning along the way about post-quantum cryptography, compiler design, and the ins and outs of fully homomorphic encryption.
If you’ve heard about FHE and you’re a software person, you’ve probably heard two things: it lets you run programs directly on encrypted data without ever decrypting it; and it’s still too slow to be useful for anything.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.jeremykun.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.jeremykun.com/2024/05/04/fhe-overview/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> are good places to start.</p>
<p>(Obligatory disclaimer: I am not a cryptographer!
While I’m reasonably confident that my code and advice here is generally sound, cryptography is a field in which subtle bugs and exploits can look fine to the untrained eye.
Before using anything here in an environment you’d describe with the word “production”, consult someone who works on this professionally.)</p>
<h2 id="homomorphic-hello-world">Homomorphic Hello World</h2>
<p>First, let’s look at a small code sample that uses homomorphic encryption.</p>
<p>Writing the encryption code itself from scratch would take much more code than can fit in this article.
Instead, we’ll use <a href="https://github.com/zama-ai/tfhe-rs" data-astro-cid-bi7aps5f="">THFE-rs</a><a data-tooltip="" href="https://github.com/zama-ai/tfhe-rs" data-astro-cid-bi7aps5f=""> <img src="https://opengraph.githubassets.com/0076171220c59d2546a04eccf3e34abc6618c1b595c0711a3ea1f2f2d96312ad/zama-ai/tfhe-rs" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">GitHub - zama-ai/tfhe-rs: TFHE-rs: A Pure Rust implementation of the TFHE Scheme for Boolean and Integer Arithmetics Over Encrypted Data.</span> <span data-astro-cid-bi7aps5f="">TFHE-rs: A Pure Rust implementation of the TFHE Scheme for Boolean and Integer Arithmetics Over Encrypted Data. - zama-ai/tfhe-rs</span> <span data-astro-cid-bi7aps5f=""> <img src="https://github.githubassets.com/favicons/favicon.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">github.com/zama-ai/tfhe-rs</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, a homomorphic encryption library written in Rust.</p>
<p>The flow goes something like this:</p>
<ol>
<li>A client generates a key pair consisting of a client key and a server key.</li>
<li>The client encrypts their data using the client key and sends both the encrypted data and server key to the server.</li>
<li>The server uses the server key to perform some computation on the encrypted data and sends the result back to the client.</li>
<li>The client decrypts the result with the client key.</li>
</ol>
<p>Here’s what this looks like in code.
We’ll take two numbers — <code>clear_a</code> and <code>clear_b</code> — and add them together.
Rather than actually sending anything over a network, we’ll just use a function called <code>server_compute</code> to play the part of the server.</p>
<pre data-language="rust"><code is:raw=""><span>use</span> <span>tfhe<span>::</span>prelude<span>::</span></span><span>*</span><span>;</span>
<span>use</span> <span>tfhe<span>::</span></span><span>{</span>generate_keys<span>,</span> set_server_key<span>,</span> <span>ConfigBuilder</span><span>,</span> <span>FheUint32</span><span>,</span> <span>ServerKey</span><span>}</span><span>;</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> config <span>=</span> <span>ConfigBuilder</span><span>::</span><span>default</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

    <span>// generate client and server keys</span>
    <span>let</span> <span>(</span>client_key<span>,</span> server_key<span>)</span> <span>=</span> <span>generate_keys</span><span>(</span>config<span>)</span><span>;</span>

    <span>// generate plaintext</span>
    <span>let</span> clear_a<span>:</span> <span>u32</span> <span>=</span> <span>27</span><span>;</span>
    <span>let</span> clear_b<span>:</span> <span>u32</span> <span>=</span> <span>128</span><span>;</span>

    <span>// encrypt plaintext and &#34;send to server&#34;</span>
    <span>let</span> result <span>=</span> <span>server_compute</span><span>(</span>
        server_key<span>,</span>
        <span>FheUint32</span><span>::</span><span>encrypt</span><span>(</span>clear_a<span>,</span> <span>&amp;</span>client_key<span>)</span><span>,</span>
        <span>FheUint32</span><span>::</span><span>encrypt</span><span>(</span>clear_b<span>,</span> <span>&amp;</span>client_key<span>)</span><span>,</span>
    <span>)</span><span>;</span>

    <span>// decrypt the result</span>
    <span>let</span> decrypted_result<span>:</span> <span>u32</span> <span>=</span> result<span>.</span><span>decrypt</span><span>(</span><span>&amp;</span>client_key<span>)</span><span>;</span>

    <span>// assert that the result is what we expect</span>
    <span>assert_eq!</span><span>(</span>decrypted_result<span>,</span> clear_a <span>+</span> clear_b<span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>server_compute</span><span>(</span>key<span>:</span> <span>ServerKey</span><span>,</span> cipher_a<span>:</span> <span>FheUint32</span><span>,</span> cipher_b<span>:</span> <span>FheUint32</span><span>)</span> <span>-&gt;</span> <span>FheUint32</span> <span>{</span>
    <span>set_server_key</span><span>(</span>key<span>)</span><span>;</span>
    <span>return</span> cipher_a <span>+</span> cipher_b<span>;</span>
<span>}</span>
</code></pre>
<p>Get the keys, encrypt two numbers, add their ciphertexts together, decrypt the result.
Not too bad, right?</p>
<p>The simplicity is deceptive!
Rust supports operator overloading, so when we run <code>cipher_a + cipher_b</code> and both of the operands are <code>FheUint32</code>, what’s <em>really</em> happening is that TFHE-rs runs a bunch of cryptography code.</p>
<p>Before we build our homomorphically encrypted CRDT, let’s peek at what TFHE-rs is doing under the hood.</p>
<h2 id="under-the-hood">Under the Hood</h2>
<p>To start, what does it even mean to “run programs on encrypted data”?</p>
<p>In short, it means you can use encrypted data in certain math operations, and when you decrypt the data you get the result you would have gotten if you had performed the same operations with the plaintext data.
That requires an encryption scheme in which at least one of the following is true (I’ll use the notation <code>E(a)</code> to indicate the encrypted version of the plaintext <code>a</code>):</p>
<ul>
<li><code>E(a) + E(b) = E(a + b)</code>: adding the encrypted values of the plaintext numbers <code>a</code> and <code>b</code> results in the encrypted sum of the plaintext sum <code>a + b</code>.</li>
<li><code>E(a) × E(b) = E(a × b)</code>: multiplying the encrypted values of the plaintext numbers <code>a</code> and <code>b</code> results in the encrypted product of the plaintext product <code>a × b</code>.</li>
</ul>
<p>What this means is that <strong>if you add or multiply two homomorphically encrypted values, then decrypt them, <em>you get the respective sum or product of the original plaintext values</em></strong>.</p>
<p>Here’s an extremely simple example that you should absolutely never use anywhere.
First, let’s pick a number as a key.
We “encrypt” numbers by multiplying them by the key, and “decrypt” numbers by dividing them.</p>
<p>Let’s say our key is 7 and our “plaintext” numbers are 5 and 6.
We can multiply each number by our key 6 to get “encrypted” numbers of 35 and 42.
Even if someone has access to our encrypted numbers, they can’t figure out what our original plaintext numbers were without the key.</p>
<p>What they <em>can</em> do is add the encrypted numbers together.
If they give us back the sum, 77, we can divide it by our key 7 to get 11 — <em>the same result we’d get by directly adding our original numbers</em>.
Try it out by changing the numbers in the playground below:</p>
<homomorphic-addition-demo></homomorphic-addition-demo>
<p>Because it satisfies the first criterion — <code>E(a) + E(b) = E(a + b)</code> — we can say that our toy encryption scheme is homomorphic over addition.
Encryption that supports only one operation is called <em>partially homomorphic encryption</em>.
All in all, there are four different levels:</p>
<ul>
<li><strong>Partially homomorphic encryption</strong> allows only one of the two operations: <em>either</em> addition <em>or</em> multiplication, but not both.</li>
<li><strong>Somewhat homomorphic encryption</strong> and <strong>leveled homomorphic encryption</strong> allow both operations, but limit the amount of times they can be used.</li>
<li><strong>Fully homomorphic encryption</strong> allows an unlimited amount of both operations.</li>
</ul>
<p>Partially homomorphic encryption is relatively easy to implement, but has limited uses.
The word “relatively” is doing some heavy lifting here — you or I probably couldn’t come up with a partially homomorphic encryption scheme — but it’s simple enough that there are algorithms such as RSA that are accidentally homomorphic over one operation.</p>
<p>Supporting <em>more than one</em> operation is significantly more useful, but each calculation adds “noise” to the result.
Too much noise makes it impossible to decrypt.
There are two broad strategies for reducing noise: limiting the number or “depth” of operations (<em>somewhat</em> and <em>leveled</em> homomorphic encryption), and “bootstrapping”, which reduces the level of noise mid-computation (<em>fully</em> homomorphic encryption).</p>
<p>Why does it matter whether we can perform <em>both</em> addition and multiplication?</p>
<p>When we talk about doing math on encrypted data, we’re really talking about the underlying bits: the 1s and 0s that make it up.
To add and multiply the bits, we use the logical operations “exclusive or” (XOR) and “binary and” (AND), respectively.</p>
<p>Click on the switches in the playground below to toggle between 1 and 0.
You can see that the AND output is the product of its two inputs, and the XOR output is roughly the sum of its two inputs.<sup><a href="#user-content-fn-addition" id="user-content-fnref-addition" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup></p>
<logic-gates height="180"><switch-gate id="one-and-left" x="40" y="10"></switch-gate><switch-gate id="one-and-right" x="85" y="10"></switch-gate><and-gate id="one-and" x="55" y="70" left="#one-and-left" right="#one-and-right"></and-gate><output-gate x="63" y="140" center="#one-and"></output-gate><switch-gate id="one-xor-left" x="190" y="10"></switch-gate><switch-gate id="one-xor-right" x="235" y="10"></switch-gate><xor-gate id="one-xor" x="205" y="70" left="#one-xor-left" right="#one-xor-right"></xor-gate><output-gate x="213" y="140" center="#one-xor"></output-gate></logic-gates>
<p>This is called a <em>Boolean circuit</em> — essentially, a function that takes 1s and 0s as input and returns 1s and 0s as output.
In this context, the logical operations are called <em>logic gates</em>.</p>
<p>We can create new logic gates by combining ones we have.
Here’s how to create “inclusive or” (OR) and inverter (NOT) operations using only XOR and AND.</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 310"><rect x="1" y="71" width="143" height="230" stroke="currentColor" fill="none" rx="4" ry="4"></rect><foreignObject x="0" y="0" width="150" height="300"></foreignObject><rect x="156" y="71" width="143" height="230" stroke="currentColor" fill="none" rx="4" ry="4"></rect><foreignObject x="150" y="0" width="150" height="300"></foreignObject></svg>
<p>Once we’ve built a gate, we can then use it to build <em>yet other</em> gates.
Here’s how to make an “exclusive nor” (XNOR) using XOR and our newly-constructed NOT gate:</p>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 260"><rect x="61" y="1" width="143" height="250" stroke="currentColor" fill="none" rx="4" ry="4"></rect><foreignObject x="0" y="0" width="210" height="300"></foreignObject></svg>
<p>It turns out that combining just XOR and AND like this is enough to perform <em>any computation</em>!
All other logical operations can be created by combining only XOR and AND, which means that adding and multiplying the encrypted data is sufficient to simulate arbitrary Boolean logic.</p>
<p>Here’s a circuit that implements the “greater than” operator on two-bit numbers (between 0 and 3).
Using only AND, XOR and the other gates we’ve built with them, it returns 1 if the first number is greater than the second, and 0 otherwise.</p>
<p>Type in the square boxes at the top to enter the input numbers.
The two rounded boxes below each square input box are the <em>binary representation</em> of that number.</p>
<p>Don’t forget this circuit — it’ll come in handy later!</p>
<logic-gates height="365"><text-gate id="four-left" x="60"></text-gate><text-gate id="four-right" x="160"></text-gate><value-gate x="60" y="30" id="four-left-ms" center="#four-left" value-prop="leftValue"></value-gate><value-gate x="98" y="30" id="four-left-ls" center="#four-left" value-prop="rightValue"></value-gate><value-gate x="160" y="30" id="four-right-ms" center="#four-right" value-prop="leftValue"></value-gate><value-gate x="198" y="30" id="four-right-ls" center="#four-right" value-prop="rightValue"></value-gate><xnor-gate id="four-msbeq-1" x="25" y="110" left="#four-left-ms" right="#four-right-ms"></xnor-gate><not-gate id="four-msbgt-1" x="105" y="90" center="#four-right-ms"></not-gate><and-gate id="four-msbgt-2" x="105" y="150" left="#four-left-ms" right="#four-msbgt-1"></and-gate><not-gate id="four-lsbgt-1" x="200" y="90" center="#four-right-ls"></not-gate><and-gate id="four-lsbgt-2" x="200" y="150" left="#four-left-ls" right="#four-lsbgt-1"></and-gate><and-gate id="four-gt-1" x="140" y="220" left="#four-msbeq-1" right="#four-lsbgt-2"></and-gate><or-gate id="four-gt-2" x="112" y="280" left="#four-msbgt-2" right="#four-gt-1"></or-gate><output-gate x="120" y="330" center="#four-gt-2"></output-gate></logic-gates>
<p>In these examples, we’ve been looking at circuits that use plaintext 1s and 0s as their inputs and outputs.
With homomorphic encryption, the circuits operate on <em>encrypted data</em>.
Performing an AND on two encrypted bits returns another encrypted bit — and we can’t find out what it is unless we have the key.</p>
<p>So that’s how homomorphic encryption works in a nutshell.
You express your program as a Boolean circuit, and then simulate the circuit using the encrypted data as input.
The output of the circuit will be the encrypted result, which the client can then decrypt.</p>
<p>Crucially, <em>none of this reveals any sort of relationship between the plaintext values</em>.
For example, even if <code>E(a) + E(b)</code> were positive, <code>E(a + b)</code> might be negative.
Adding and multiplying ciphertext corresponds to the same operations on the underlying plaintext, but there’s no correlation between any of the ciphertext results and the underlying plaintext results — you need to decrypt the result to figure out what happened.</p>
<h2 id="a-fully-homomorphic-crdt">A Fully Homomorphic CRDT</h2>
<p>Now that we have a high level understanding of homomorphic encryption, let’s build a homomorphically-encrypted last write wins register.</p>
<p>A last write wins register holds a single value and two additional bits of metadata: a “clock” that gets incremented by one whenever the value is set, and an ID indicating the peer who last wrote to it.
Like all CRDTs, it also has a merge function that describes how it should be combined with another of the same type.</p>
<p>The last write wins register merge algorithm works like this:</p>
<ul>
<li>If the received clock is less than the local clock, the register doesn’t change its state.</li>
<li>If the received clock is greater than the local clock, the register overwrites its local value with the received value. It also stores the received clock and peer ID.</li>
<li>Ties are broken by comparing the local peer ID to the peer ID in the received state.</li>
</ul>
<p>Here’s a playground in which you can see how this algorithm works:</p>
<lwwregister-demo></lwwregister-demo>
<p>Try playing around with the latency and the network toggle.
See how updates are accepted only if the sending peer’s clock is higher than the receiving peer’s clock. If the clocks are tied, the update from the right peer will win out, since the peer ID <code>bob</code> is lexicographically greater than <code>alice</code>.</p>
<p>Okay, let’s look at some code.
First, here’s what an <em>unencrypted</em> last write wins register might look like in Rust:</p>
<pre data-language="rust"><code is:raw=""><span>const</span> <span>DATA_SIZE</span><span>:</span> <span>usize</span> <span>=</span> <span>16</span><span>;</span>

<span>pub</span> <span>struct</span> <span>Register</span> <span>{</span>
    <span>pub</span> peer<span>:</span> <span>u64</span><span>,</span>
    <span>pub</span> clock<span>:</span> <span>u64</span><span>,</span>
    <span>pub</span> value<span>:</span> <span>[</span><span>u8</span><span>;</span> <span>DATA_SIZE</span><span>]</span><span>,</span>
<span>}</span>

<span>impl</span> <span>Register</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>new</span><span>(</span>peer<span>:</span> <span>u64</span><span>)</span> <span>-&gt;</span> <span>Register</span> <span>{</span>
        <span>Register</span> <span>{</span>
            peer<span>,</span>
            clock<span>:</span> <span>0</span><span>,</span>
            value<span>:</span> <span>[</span><span>0</span><span>;</span> <span>DATA_SIZE</span><span>]</span><span>,</span>
        <span>}</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>set</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> peer<span>:</span> <span>u64</span><span>,</span> value<span>:</span> <span>[</span><span>u8</span><span>;</span> <span>DATA_SIZE</span><span>]</span><span>)</span> <span>{</span>
        <span>self</span><span>.</span>peer <span>=</span> peer<span>;</span>
        <span>self</span><span>.</span>clock <span>+=</span> <span>1</span><span>;</span>
        <span>self</span><span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>set_string</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> peer<span>:</span> <span>u64</span><span>,</span> value<span>:</span> <span>&amp;</span><span>str</span><span>)</span> <span>{</span>
        <span>let</span> bytes <span>=</span> value<span>.</span><span>as_bytes</span><span>(</span><span>)</span><span>;</span>
        <span>let</span> len <span>=</span> bytes<span>.</span><span>len</span><span>(</span><span>)</span><span>.</span><span>min</span><span>(</span><span>DATA_SIZE</span><span>)</span><span>;</span>

        <span>let</span> <span>mut</span> data <span>=</span> <span>[</span><span>0</span><span>;</span> <span>DATA_SIZE</span><span>]</span><span>;</span>
        data<span>[</span><span>..</span>len<span>]</span><span>.</span><span>copy_from_slice</span><span>(</span><span>&amp;</span>bytes<span>[</span><span>..</span>len<span>]</span><span>)</span><span>;</span>

        <span>self</span><span>.</span><span>set</span><span>(</span>id<span>,</span> data<span>)</span><span>;</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>merge</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> other<span>:</span> <span>&amp;</span><span>Register</span><span>)</span> <span>{</span>
        <span>if</span> <span>self</span><span>.</span>clock <span>&gt;</span> other<span>.</span>clock <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span><span>;</span>

        <span>if</span> <span>self</span><span>.</span>clock <span>==</span> other<span>.</span>clock <span>&amp;&amp;</span> <span>self</span><span>.</span>peer <span>&gt;</span> other<span>.</span>peer <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>

        <span>self</span><span>.</span>peer <span>=</span> other<span>.</span>peer<span>;</span>
        <span>self</span><span>.</span>clock <span>=</span> other<span>.</span>clock<span>;</span>
        <span>self</span><span>.</span>value <span>=</span> other<span>.</span>value<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>It has a peer ID, a clock and a value.
To merge with another register, it just takes the peer ID, clock and value from the register with the higher clock.
In case of a tie, it uses the peer ID as a tiebreaker.</p>
<p>Because Rust is a low-level language, we need separate functions to convert types such as strings into the raw bytes to store as the value.
We also store the value in an array with a statically-known size — although as we’ll see, that’s less of a Rust limitation than it is a fundamental constraint of homomorphic encryption.</p>
<p>Here’s the skeleton of an <code>EncryptedRegister</code> struct:</p>
<pre data-language="rust"><code is:raw=""><span>use</span> <span>core<span>::</span></span>array<span>;</span>
<span>use</span> <span>tfhe<span>::</span>prelude<span>::</span></span><span>*</span><span>;</span>
<span>use</span> <span>tfhe<span>::</span></span><span>{</span><span>ClientKey</span><span>,</span> <span>FheUint64</span><span>,</span> <span>FheUint8</span><span>}</span><span>;</span>

<span>use</span> <span>crate</span><span>::</span><span>Register</span><span>;</span>

<span>const</span> <span>DATA_SIZE</span><span>:</span> <span>usize</span> <span>=</span> <span>16</span><span>;</span>

<span>pub</span> <span>struct</span> <span>EncryptedRegister</span> <span>{</span>
    peer<span>:</span> <span>FheUint64</span><span>,</span>
    clock<span>:</span> <span>FheUint64</span><span>,</span>
    value<span>:</span> <span>[</span><span>FheUint8</span><span>;</span> <span>DATA_SIZE</span><span>]</span><span>,</span>
<span>}</span>

<span>impl</span> <span>EncryptedRegister</span> <span>{</span>
    <span>pub</span> <span>fn</span> <span>encrypt</span><span>(</span>clear<span>:</span> <span>&amp;</span><span>Register</span><span>,</span> key<span>:</span> <span>&amp;</span><span>ClientKey</span><span>)</span> <span>-&gt;</span> <span>EncryptedRegister</span> <span>{</span>
        <span>EncryptedRegister</span> <span>{</span>
            peer<span>:</span> <span>FheUint64</span><span>::</span><span>encrypt</span><span>(</span>clear<span>.</span>peer<span>,</span> key<span>)</span><span>,</span>
            clock<span>:</span> <span>FheUint64</span><span>::</span><span>encrypt</span><span>(</span>clear<span>.</span>clock<span>,</span> key<span>)</span><span>,</span>
            value<span>:</span> <span>array<span>::</span></span><span>from_fn</span><span>(</span><span><span>|</span>i<span>|</span></span> <span>FheUint8</span><span>::</span><span>encrypt</span><span>(</span>clear<span>.</span>value<span>[</span>i<span>]</span><span>,</span> key<span>)</span><span>)</span><span>,</span>
        <span>}</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>decrypt</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> key<span>:</span> <span>&amp;</span><span>ClientKey</span><span>)</span> <span>-&gt;</span> <span>Register</span> <span>{</span>
        <span>Register</span> <span>{</span>
            peer<span>:</span> <span>FheUint64</span><span>::</span><span>decrypt</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>peer<span>,</span> key<span>)</span><span>,</span>
            clock<span>:</span> <span>FheUint64</span><span>::</span><span>decrypt</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>clock<span>,</span> key<span>)</span><span>,</span>
            value<span>:</span> <span>array<span>::</span></span><span>from_fn</span><span>(</span><span><span>|</span>i<span>|</span></span> <span>FheUint8</span><span>::</span><span>decrypt</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>value<span>[</span>i<span>]</span><span>,</span> key<span>)</span><span>)</span><span>,</span>
        <span>}</span>
    <span>}</span>

    <span>pub</span> <span>fn</span> <span>merge</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> other<span>:</span> <span>EncryptedRegister</span><span>)</span> <span>{</span>
        <span>// ...</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>Pretty similar to the unencrypted <code>Register</code> struct!
<code>FheUint64</code> has replaced <code>u64</code>, and <code>value</code> is now an array of <code>FheUint8</code> rather than <code>u8</code>.
These are TFHE-rs types that encrypt the corresponding Rust types.
But other than that, the struct is the same.</p>
<p>The implementation has two new methods:</p>
<ul>
<li><code>encrypt</code>, which takes a normal <code>Register</code> and a client key, encrypts all the fields and returns an <code>EncryptedRegister</code>.</li>
<li><code>decrypt</code>, which takes a client key, decrypts all the fields and returns a normal <code>Register</code>.</li>
</ul>
<p>We’ve also omitted the <code>set</code> and <code>set_string</code> methods.
Since <code>EncryptedRegister</code> runs on the server, the value will never be set manually.
The only thing it needs to do is merge an incoming register with the register it has in memory.</p>
<p>Okay, so what does the <code>merge</code> method look like?</p>
<p>As we saw before, TFHE-rs overloads operators like <code>+</code> to make working with encrypted values more convenient.
For operators that don’t support overloading such as <code>&lt;</code>, TFHE-rs has methods like <code>gt</code>.</p>
<p>Given that, you might think we could write the <code>merge</code> method like this:</p>
<pre data-language="rust"><code is:raw=""><span>impl</span> <span>EncryptedRegister</span> <span>{</span>
  <span>// ...</span>

  <span>pub</span> <span>fn</span> <span>merge</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> other<span>:</span> <span>EncryptedRegister</span><span>)</span> <span>{</span>
    <span>if</span> <span>self</span><span>.</span>clock<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span> <span>{</span>
      <span>return</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>self</span><span>.</span>clock<span>.</span><span>eq</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span> <span>&amp;&amp;</span> <span>self</span><span>.</span>id<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>id<span>)</span> <span>{</span>
      <span>return</span><span>;</span>
    <span>}</span>

    <span>self</span><span>.</span>id <span>=</span> other<span>.</span>id<span>;</span>
    <span>self</span><span>.</span>clock <span>=</span> other<span>.</span>clock<span>;</span>
    <span>self</span><span>.</span>value <span>=</span> other<span>.</span>value<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<p>This will <em>definitely not work</em>!</p>
<p>Remember that we can’t retrieve any information by operating on the encrypted data — <em>including information about the results of intermediate steps</em>.</p>
<p>To more clearly show the problem with this strategy, we can add some logging:</p>
<pre data-language="rust"><code is:raw=""><span>impl</span> <span>EncryptedRegister</span> <span>{</span>
  <span>// ...</span>

  <span>pub</span> <span>fn</span> <span>merge</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> other<span>:</span> <span>EncryptedRegister</span><span>)</span> <span>{</span>
    <span>if</span> <span>self</span><span>.</span>clock<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span> <span>{</span>
      <span>println!</span><span>(</span><span>&#34;local clock is greater than other clock!&#34;</span><span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>self</span><span>.</span>clock<span>.</span><span>eq</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span> <span>&amp;&amp;</span> <span>self</span><span>.</span>peer<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>peer<span>)</span> <span>{</span>
      <span>println!</span><span>(</span><span>&#34;clocks are equal but local peer is greater than other peer!&#34;</span><span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>

    <span>println!</span><span>(</span><span>&#34;overwriting local data with remote data!&#34;</span><span>)</span><span>;</span>
    <span>self</span><span>.</span>peer <span>=</span> other<span>.</span>peer<span>;</span>
    <span>self</span><span>.</span>clock <span>=</span> other<span>.</span>clock<span>;</span>
    <span>self</span><span>.</span>value <span>=</span> other<span>.</span>value<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<p>Although we still couldn’t decrypt the encrypted data, this (fake) implementation would reveal the result of the merge!
We’d know which branches our code took, and therefore learn which decrypted clock was higher and which encrypted data was written to the register.</p>
<p>Instead, our merge function must <em>eagerly</em> evaluate all branches in our code.
It also means that all loops must run for a statically-known number of iterations.
More generally, <strong>our code must always execute as though operating on the worst case input</strong>, because altering behavior based on the input would leak information about it.</p>
<p>Here’s the <em>real</em> code for our merge function:</p>
<pre data-language="rust"><code is:raw="">  <span>pub</span> <span>fn</span> <span>merge</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> other<span>:</span> <span>&amp;</span><span>EncryptedRegister</span><span>)</span> <span>{</span>
    <span>let</span> higher_clock <span>=</span> <span>self</span><span>.</span>clock<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>

    <span>let</span> equal_clock <span>=</span> <span>self</span><span>.</span>clock<span>.</span><span>eq</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>
    <span>let</span> higher_peer <span>=</span> <span>self</span><span>.</span>peer<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>peer<span>)</span><span>;</span>

    <span>let</span> keep_self <span>=</span> higher_clock <span>|</span> <span>(</span>equal_clock <span>&amp;</span> higher_peer<span>)</span><span>;</span>

    <span>self</span><span>.</span>peer <span>=</span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>peer<span>,</span> <span>&amp;</span>other<span>.</span>peer<span>)</span><span>;</span>
    <span>self</span><span>.</span>clock <span>=</span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>clock<span>,</span> <span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>
    <span>self</span><span>.</span>value <span>=</span> <span>array<span>::</span></span><span>from_fn</span><span>(</span><span><span>|</span>i<span>|</span></span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>value<span>[</span>i<span>]</span><span>,</span> <span>&amp;</span>other<span>.</span>value<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<p>Superficially, it looks fairly similar, but there are a couple of important differences.
Let’s take it line by line.</p>
<p>First, we determine whether the local clock is higher than the other clock:</p>
<pre data-language="rust"><code is:raw=""><span>let</span> higher_clock <span>=</span> <span>self</span><span>.</span>clock<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>
</code></pre>
<p>If we think back to the logic gates, we can imagine what’s going on under the hood here, right?
We built this exact circuit!
Ours only operated on two-bit numbers, but the idea was the same: accept two numbers and return a 0 or 1 indicating whether the first number is higher than the second.</p>
<p>(In our circuit, the result was a <em>plaintext</em> 0 or 1 — but remember, homomorphic encryption operates with <em>encrypted</em> values!
The <code>gt</code> method actually returns an <code>FheBool</code>: an <em>encrypted bool</em> which indicates whether the local clock is higher than the other one.)</p>
<p>If we had the client key, we could decrypt that variable and find out its true value.
We can’t do that, but we can still <em>combine it with other encrypted values</em> to write our merge algorithm.</p>
<p>Here are the conditions to break a tie between the clocks:</p>
<pre data-language="rust"><code is:raw=""><span>let</span> equal_clock <span>=</span> <span>self</span><span>.</span>clock<span>.</span><span>eq</span><span>(</span><span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>
<span>let</span> higher_peer <span>=</span> <span>self</span><span>.</span>peer<span>.</span><span>gt</span><span>(</span><span>&amp;</span>other<span>.</span>peer<span>)</span><span>;</span>
</code></pre>
<p>Two more <code>FheBool</code>s indicating whether the clocks are equal and if the local peer ID is higher.</p>
<p>Next, we combine them:</p>
<pre data-language="rust"><code is:raw=""><span>let</span> keep_self <span>=</span> higher_clock <span>|</span> <span>(</span>equal_clock <span>&amp;</span> higher_peer<span>)</span><span>;</span>
</code></pre>
<p>This combines all those <code>FheBool</code>s to determine whether to keep the local data or overwrite it with the merged data.<sup><a href="#user-content-fn-astute" id="user-content-fnref-astute" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">4</a></sup></p>
<p>Those <code>|</code> and <code>&amp;</code> operators are bitwise AND and bitwise OR, which work exactly like the AND and OR logic gates we made earlier.
They’re similar to the logical AND and OR we’re used to — <code>&amp;&amp;</code> and <code>||</code>, but with one big difference: bitwise operators are <em>eager</em>.
Whereas logical AND and OR might skip the second expression depending on the first, bitwise operators will <em>always</em> evaluate both sides.</p>
<p>Now that we’ve determined the register values to keep — even if we can’t tell which ones — we need to write the data to the register.
Here’s the secret sauce:</p>
<pre data-language="rust"><code is:raw=""><span>self</span><span>.</span>peer <span>=</span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>peer<span>,</span> <span>&amp;</span>other<span>.</span>peer<span>)</span><span>;</span>
<span>self</span><span>.</span>clock <span>=</span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>clock<span>,</span> <span>&amp;</span>other<span>.</span>clock<span>)</span><span>;</span>
<span>self</span><span>.</span>value <span>=</span> <span>array<span>::</span></span><span>from_fn</span><span>(</span><span><span>|</span>i<span>|</span></span> keep_self<span>.</span><span>select</span><span>(</span><span>&amp;</span><span>self</span><span>.</span>value<span>[</span>i<span>]</span><span>,</span> <span>&amp;</span>other<span>.</span>value<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<p>Rather than <code>if</code> or <code>match</code> expressions, we use <code>FheBool</code>’s <code>select</code> method.
It returns the first argument if the underlying <code>FheBool</code> value is <code>true</code>, or the second argument if the underlying value is <code>false</code>.</p>
<p>This is important: <em>the return value is different from both arguments</em>.
While decrypting the return value would reveal the same plaintext as one of the arguments, in ciphertext all three are distinct.
This means that we can’t tell which values we’ve set on the register by the end of the merge.</p>
<p>When the merge is done, every piece of ciphertext has changed — the peer ID, the clock and the register value.
The plaintext values might have updated (or might not have!) but there’s no way to tell by looking at the ciphertext.</p>
<p>Problem solved, right?
We can now have the server merge our CRDT without knowing what it contains?
Weeeellllllll…</p>
<h2 id="fundamental-limitations">Fundamental Limitations</h2>
<p>Homomorphic encryption has constraints that sharply limit its effectiveness with regard to local-first software.</p>
<p>For starters: encryption keys.
In both the simple adding example and the last-write wins register, we generated a key that would be passed to the server.
That only needs to happen once, but the difference between the size of our key and the size of our data can be surprising.</p>
<p>Our register took up only 32 bytes of data — 8 bytes each for the peer and clock, and 16 bytes for the value.
Meanwhile, TFHE-rs generated a <em>123 megabyte</em> server key.
We can compress the key down to about 27 megabytes, but still: that’s almost 850,000 times more key than data!</p>
<p>The payload here is particularly small, but a disparity of that size isn’t unheard of.
In his <a href="https://www.jeremykun.com/2024/05/04/fhe-overview/" data-astro-cid-bi7aps5f="">overview of fully homomorphic encryption</a><a data-tooltip="" href="https://www.jeremykun.com/2024/05/04/fhe-overview/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">A High-Level Technical Overview of Fully Homomorphic Encryption</span> <span data-astro-cid-bi7aps5f="">About two years ago, I switched teams at Google to focus on fully homomorphic encryption (abbreviated FHE, or sometimes HE). Since then I’ve got to work on a lot of interesting projects, learning along the way about post-quantum cryptography, compiler design, and the ins and outs of fully homomorphic encryption.
If you’ve heard about FHE and you’re a software person, you’ve probably heard two things: it lets you run programs directly on encrypted data without ever decrypting it; and it’s still too slow to be useful for anything.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.jeremykun.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.jeremykun.com/2024/05/04/fhe-overview/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, Jeremy Kun cites examples in which ciphertexts of dozens or hundreds of <em>kilobytes</em> require keys on the order of <em>gigabytes</em>.</p>
<p>Runtime performance is also — to put it lightly — lacking.
I benchmarked the unencrypted and encrypted versions of the last write wins register on an M4 MacBook Pro.
The unencrypted one averaged a merge time of 0.52 nanoseconds.</p>
<p>The encrypted one?
<em>1.06 seconds</em>.
That’s not a typo: the homomorphically encrypted merge is <em>two billion times slower</em>.<sup><a href="#user-content-fn-gpu" id="user-content-fnref-gpu" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">5</a></sup></p>
<p>Not great!</p>
<p>That’s not all.
We said before that our code must execute as though operating on the worst case input.
Even if the performance issues improve by many orders of magnitude, the “worst case” requirement will still impose constraints on the CRDT algorithm itself.</p>
<p>Consider a fully homomorphically encrypted last-write wins <em>map</em> CRDT.
Most maps store keys sparsely, so the map only grows in size as keys are added.</p>
<p>Here’s a playground that simulates encrypting a sparse map.<sup><a href="#user-content-fn-pretend" id="user-content-fnref-pretend" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">6</a></sup>
When you modify the plaintext map on the left, the encrypted map on the right updates.
Can you see a security issue?</p>
<encrypted-map-demo></encrypted-map-demo>
<p>Imagine you only had access to the map on the right.
You could still see data being added and removed!
Furthermore, this map lazily encrypts only the data that changes, which would allow you to see exactly which key changed (if any).</p>
<p>A homomorphically encrypted map CRDT couldn’t do that.
Since it must assume a worst-case input, it must store the keys <em>densely</em>: limiting the size to a fixed number of keys and reserving all the space up front.
Merging two identical maps would be exactly as computationally intensive as merging two maps in which <em>every</em> key was updated.<sup><a href="#user-content-fn-op" id="user-content-fnref-op" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">7</a></sup></p>
<p>The playground below simulates a homomorphically encrypted map.
While you can add and remove keys to the plaintext map on the left, the encrypted map on the right behaves as though every key is filled.
And no matter how you modify the plaintext map, <em>everything</em> in the encrypted map changes:</p>
<encrypted-map-demo dense="true" keys="4"></encrypted-map-demo>
<p>From the outside, there’s no way to tell what changed in the map: we see the exact same number of keys, and every value has changed.
To calculate the new map, the server must go through and merge <em>every single key</em>.
After that, it needs to transfer the full map to each peer — because remember, as far as it knows, the entire map is different.</p>
<p>These are fundamental limitations of homomorphic encryption!
The requirement that homomorphically encrypted code performs as though operating on the worst-case input dramatically increases both the space and time required to update.</p>
<h2 id="parting-thoughts">Parting Thoughts</h2>
<p>I started this article thinking that local-first software and homomorphic encryption would be natural bedfellows.</p>
<p>But honestly, I came away… a little less enamored.
The fundamental limitations of homomorphic encryption mean that it will always operate under a set of worst-case assumptions.
Homomorphically encrypted CRDTs aren’t intractable, but they are severely limited by these intrinsic constraints.</p>
<p>So the question remains: how can we secure local-first apps without severely degrading usability?</p>
<p>Luckily, I’m not the only one thinking about this problem!</p>
<ul>
<li>There are <a href="https://dicg-workshop.github.io/2022/papers/jannes.pdf" data-astro-cid-bi7aps5f="">a bunch of</a><a data-tooltip="" href="https://dicg-workshop.github.io/2022/papers/jannes.pdf" data-astro-cid-bi7aps5f="">    <span data-astro-cid-bi7aps5f=""> <img src="https://dicg-workshop.github.io/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">dicg-workshop.github.io/2022/papers/jannes.pdf</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <a href="https://repositorio.inesctec.pt/server/api/core/bitstreams/9d417c53-456f-4227-9440-fffb9650e3dd/content" data-astro-cid-bi7aps5f="">research papers</a><a data-tooltip="" href="https://repositorio.inesctec.pt/server/api/core/bitstreams/9d417c53-456f-4227-9440-fffb9650e3dd/content" data-astro-cid-bi7aps5f="">    <span data-astro-cid-bi7aps5f=""> <img src="https://repositorio.inesctec.pt/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">repositorio.inesctec.pt/server/api/core/bitstreams/9d417c53-456f-4227-9440-fffb9650e3dd/content</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> <a href="https://eprint.iacr.org/2023/584.pdf" data-astro-cid-bi7aps5f="">on secure CRDTs</a><a data-tooltip="" href="https://eprint.iacr.org/2023/584.pdf" data-astro-cid-bi7aps5f="">    <span data-astro-cid-bi7aps5f=""> <img src="https://eprint.iacr.org/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">eprint.iacr.org/2023/584.pdf</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</li>
<li>Martin Kleppman has written spoken about <a href="https://martin.kleppmann.com/2019/05/15/encrypted-crdts.html" data-astro-cid-bi7aps5f="">combining secure group messaging protocols with CRDTs</a><a data-tooltip="" href="https://martin.kleppmann.com/2019/05/15/encrypted-crdts.html" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Adapting secure group messaging for encrypted CRDTs — Martin Kleppmann’s talks</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://martin.kleppmann.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">martin.kleppmann.com/2019/05/15/encrypted-crdts.html</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>.</li>
<li>Last (but certainly not least), local-first pioneers Ink &amp; Switch have been working on a project called <a href="https://www.inkandswitch.com/keyhive/" data-astro-cid-bi7aps5f="">Keyhive</a><a data-tooltip="" href="https://www.inkandswitch.com/keyhive/" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">Keyhive is a project exploring local-first access control. It aims to provide a firm basis for secure collaboration, similar to the guarantees of private chat but for any local-first application.</span> <span data-astro-cid-bi7aps5f="">Keyhive: Local-first access control</span> <span data-astro-cid-bi7aps5f=""> <img src="https://www.inkandswitch.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">www.inkandswitch.com/keyhive/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> that explores how to add access control to local-first data.<sup><a href="#user-content-fn-meri" id="user-content-fnref-meri" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">8</a></sup></li>
<li>Probably many other projects I’ve missed!</li>
</ul>
<p>CRDTs are a relatively young technology — the paper formalizing them was published in 2011 — so there’s still a lot of unexplored solution space.
We may not have solved this problem yet, but I’m confident that we’re closing in on it!</p>

<section data-footnotes=""><h2 id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-e2ee">
<p>More comprehensive solutions might try to implement things like <a href="https://en.wikipedia.org/wiki/Forward_secrecy" data-astro-cid-bi7aps5f="">forward secrecy</a><a data-tooltip="" href="https://en.wikipedia.org/wiki/Forward_secrecy" data-astro-cid-bi7aps5f=""> <img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/KDF_chain.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">Forward secrecy - Wikipedia</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://en.wikipedia.org/static/favicon/wikipedia.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/Forward_secrecy</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>, which is absolutely not easy.
But the basic version is still better than nothing. <a href="#user-content-fnref-e2ee" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-otherways">
<p>Homomorphic encryption isn’t the only way to solve this problem.
You might instead just ignore it, and have the server store every version of your encrypted document — wasteful, but it’d work!
You could also use a CRDT implementation that only requires <em>changes</em> to be sent to the server, rather than the full document. <a href="#user-content-fnref-otherways" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-addition">
<p>You might notice that when both XOR inputs are 1, the result is 0.
You might also remember from math class that the result of 1 + 1 is, uh, not 0.
So how can XOR represent addition?</p>
<p>Remember that we’re operating on binary numbers — all we have is 0 and 1!
Adding to 1 in binary is like adding to 9 in decimal: since we’re out of digits, we instead roll that place back to 0 and <em>carry the 1 to the next place</em>, giving us 10.
The XOR gate represents the <em>sum digit</em> of that Boolean addition.
To fully represent the result, <a href="https://en.wikipedia.org/wiki/XOR_gate#Addition" data-astro-cid-bi7aps5f="">we’d need to use the AND gate as well to represent the <em>carry digit</em></a><a data-tooltip="" href="https://en.wikipedia.org/wiki/XOR_gate#Addition" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">XOR gate - Wikipedia</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://en.wikipedia.org/static/favicon/wikipedia.ico#Addition" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">en.wikipedia.org/wiki/XOR_gate#Addition</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a>. <a href="#user-content-fnref-addition" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-astute">
<p><em>Truly</em> eagle-eyed readers will notice that this is <em>also</em> the same circuit we used to determine whether one two-bit number was greater than another.
At a high level, the logic there was “most significant bit is greater” OR (“most significant bits are equal” AND “least significant bit is greater”).
Here, the logic is “clock is greater” OR (“clocks are equal” AND “peer ID is greater”). <a href="#user-content-fnref-astute" data-footnote-backref="" aria-label="Back to reference 4" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-gpu">
<p>Granted, I was only able to run it on the CPU — TFHE-rs only supports GPU acceleration on Linux — but even if I could run it on the GPU, <a href="https://docs.zama.ai/tfhe-rs/get-started/summary" data-astro-cid-bi7aps5f="">TFHE-rs’s benchmarks</a><a data-tooltip="" href="https://docs.zama.ai/tfhe-rs/get-started/summary" data-astro-cid-bi7aps5f="">  <span data-astro-cid-bi7aps5f="">TFHE-rs</span>  <span data-astro-cid-bi7aps5f=""> <img src="https://docs.zama.ai/~gitbook/image?url=https%3A%2F%2F572209210-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fcollections%252FprREL84Xd1lx94uAslRx%252Ficon%252F3R1LaM67E4BE3WhJZF5p%252FLogo%2520-%2520Square.png%3Falt%3Dmedia%26token%3Db39ed5d3-5537-4c62-9389-5b23f830072b&amp;width=48&amp;height=48&amp;sign=c9d8fc58&amp;sv=2" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">docs.zama.ai/tfhe-rs/get-started/summary</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> indicate that it would only speed things up by a factor of 3–5.
Even at the high end of that range, the encrypted merge would <em>still</em> be 400 million times slower than the unencrypted one. <a href="#user-content-fnref-gpu" data-footnote-backref="" aria-label="Back to reference 5" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-pretend">
<p>When I say “simulates encrypting”, I mean “displays a bunch of random hex digits”.
Please humor me! <a href="#user-content-fnref-pretend" data-footnote-backref="" aria-label="Back to reference 6" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-op">
<p>Note that this all assumes a <em>state-based</em> CRDT.
An <em>operation-based</em> CRDT — where the important operation is appending to a log of events rather than merging — might have a totally different set of tradeoffs. <a href="#user-content-fnref-op" data-footnote-backref="" aria-label="Back to reference 7" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-meri">
<p>Meri Leeworthy published a great <a href="https://meri.garden/a-deep-dive-explainer-on-beekem-protocol/" data-astro-cid-bi7aps5f="">deep-dive explainer on KeyHive’s key encapsulation mechanism</a><a data-tooltip="" href="https://meri.garden/a-deep-dive-explainer-on-beekem-protocol/" data-astro-cid-bi7aps5f=""> <img src="https://static.meri.garden/mesh-gradient.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">A deep-dive explainer on Ink and Switch&#39;s BeeKEM protocol</span> <span data-astro-cid-bi7aps5f="">I&#39;m a programmer, designer, writer and artist. I try to make tools for community autonomy, creativity, and resistance.</span> <span data-astro-cid-bi7aps5f=""> <img src="https://meri.garden/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/> <span data-astro-cid-bi7aps5f="">meri.garden/a-deep-dive-explainer-on-beekem-protocol/</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"> <use href="/icons.svg#share"></use> </svg> </span> </a> which is absolutely worth a read! <a href="#user-content-fnref-meri" data-footnote-backref="" aria-label="Back to reference 8" class="data-footnote-backref" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
</ol>
</section> </div></div>
  </body>
</html>
