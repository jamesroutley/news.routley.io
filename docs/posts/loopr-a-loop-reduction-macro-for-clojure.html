<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aphyr.com/posts/360-loopr-a-loop-reduction-macro-for-clojure">Original</a>
    <h1>Loopr: A Loop/Reduction Macro for Clojure</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>I write a lot of reductions: loops that combine every element from a collection in some way. For example, summing a vector of integers:</p>
<pre><code><span></span><span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[</span><span>sum</span> <span>x</span><span>]</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>))</span> <span>0</span> <span>[</span><span>1</span> <span>2</span> <span>3</span><span>])</span>
<span>; =&gt; 6</span>
</code></pre>
<p>If you’re not familiar with Clojure’s <code>reduce</code>, it takes a reducing function <code>f</code>, an initial accumulator <code>init</code>, and a collection <code>xs</code>. It then invokes <code>(f init x0)</code> where <code>x0</code> is the first element in <code>xs</code>. <code>f</code> returns a new accumulator value <code>acc1</code>, which is then passed to <code>(f acc1 x1)</code> to produce a new accumulator <code>acc2</code>, and so on until every <code>x</code> in <code>xs</code> is folded into the accumulator. That accumulator is the return value of <code>reduce</code>.</p>
<p>In writing reductions, there are some problems that I run into over and over. For example, what if you want to find the mean of some numbers in a single pass? You need <em>two</em> accumulator variables–a sum and a count. The usual answer to this is to make the accumulator a vector tuple. Destructuring bind makes this… not totally awful, but a little awkward:</p>
<pre><code><span></span><span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[[</span><span>sum</span> <span>count</span><span>]</span> <span>x</span><span>]</span>
          <span>[(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>)])</span>
        <span>[</span><span>0</span> <span>0</span><span>]</span>
        <span>[</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>])</span>
<span>; =&gt; [28 7]</span>
</code></pre>
<p>Ah, right. We need to <em>divide</em> <code>sum</code> by <code>count</code> to get the actual mean. Fine, we’ll wrap that in a <code>let</code> binding:</p>
<pre><code><span></span><span>(</span><span>let </span><span>[[</span><span>sum</span> <span>count</span><span>]</span> <span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[[</span><span>sum</span> <span>count</span><span>]</span> <span>x</span><span>]</span>
                            <span>[(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>)])</span>
                          <span>[</span><span>0</span> <span>0</span><span>]</span>
                          <span>[</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>])]</span>
  <span>(</span><span>/ </span><span>sum</span> <span>count</span><span>))</span>
<span>; =&gt; 4</span>
</code></pre>
<p>This is awkward for a few reasons. One is that we’ve chewed up a fair bit of indentation, and indentation is a precious commodity if you’re an 80-column masochist like me. Another is that we’ve got the accumulator structure specified in four different places: the <code>let</code> binding’s left hand side, the <code>fn</code> arguments, the <code>fn</code> return value(s), and the initial value. When the reducing function is large and complex, these expressions can drift far apart from one another. They may not even fit on a single screen–start juggling a half-dozen variables and it’s easy for <code>init</code> to get out of sync with the <code>fn</code> args. Not the end of the world, but a little frustrating. Then there’s the runtime overhead. Creating and tearing apart all those vectors comes with significant performance cost.</p>
<p>We could write this as a <code>loop</code>:</p>
<pre><code><span></span><span>(</span><span>loop </span><span>[</span><span>sum</span>   <span>0</span>
       <span>count </span><span>0</span> 
       <span>xs</span>    <span>[</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>]]</span>
  <span>(</span><span>if </span><span>(</span><span>seq </span><span>xs</span><span>)</span>
    <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>(</span><span>first </span><span>xs</span><span>))</span> <span>(</span><span>inc </span><span>count</span><span>)</span> <span>(</span><span>next </span><span>xs</span><span>))</span>
    <span>(</span><span>/ </span><span>sum</span> <span>count</span><span>)))</span>
<span>; =&gt; 4</span>
</code></pre>
<p>No let binding, significantly less indentation. Brings the initial values for accumulators directly next to their names, which is nice. No vector destructuring overhead.</p>
<p>On the flip side, we now burn a lot of time in seq machinery: <code>next</code> allocates a seq wrapper for every single step. Clojure’s <code>reduce</code> traverses the internal structure of vectors without these wrappers, and is significantly more efficient. We also have this extra boilerplate for sequence traversal, and the traversal logic is mixed together with the reduction accumulator. When we used <code>reduce</code>, that traversal was implicit.</p>
<h2><a href="#enter-loopr" id="enter-loopr">Enter Loopr</a></h2>
<p>Check this out:</p>
<pre><code><span></span><span>(</span><span>require</span> <span>&#39;</span><span>[</span><span>dom-top.core</span> <span>:refer</span> <span>[</span><span>loopr</span><span>]])</span>
<span>(</span><span>loopr</span> <span>[</span><span>sum</span>   <span>0</span>
        <span>count </span><span>0</span><span>]</span>
       <span>[</span><span>x</span> <span>[</span><span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span><span>]]</span>
       <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>))</span>
       <span>(</span><span>/ </span><span>sum</span> <span>count</span><span>))</span>
<span>; =&gt; 4</span>
</code></pre>
<p><a href="https://github.com/aphyr/dom-top/blob/04d0a688262a3671880e83ce0f35882bd8fa2ff9/src/dom_top/core.clj#L665"><code>loopr</code> is a hybrid of loop and reduce</a>. Like loop, it starts with a binding vector of accumulator variables and initial values. Then it takes a binding vector of <em>iteration</em> variables: for each <code>x</code> in the vector <code>[1 2 3 4 5 6 7]</code>, it evaluates the third form–the body of the loop. Just like Clojure’s <code>loop</code>, that body should <code>recur</code> with new values for each accumulator. The fourth argument to <code>loopr</code> is a <em>final</em> form, and is evaluated with the final values of the accumulators bound. That’s the return value for the loop.</p>
<p>Like <code>loop</code>, it keeps initial values close to their names, and needs no destructuring of accumulators. Like <code>reduce</code>, it leaves iteration implicit–closer to a <code>for</code> loop. It avoids the need for wrapping the <code>reduce</code> return value in another destructuring <code>let</code>, and requires much less indentation.</p>
<p>Did I mention it’s faster than both the <code>reduce</code> and <code>loop</code> shown here?</p>
<pre><code><span></span><span>(</span><span>def </span><span>bigvec</span>   <span>(</span><span>-&gt;&gt;</span> <span>(</span><span>range </span><span>10000</span><span>)</span> <span>vec</span><span>))</span>
<span>(</span><span>def </span><span>bigarray</span> <span>(</span><span>-&gt;&gt;</span> <span>(</span><span>range </span><span>10000</span><span>)</span> <span>long-array</span><span>))</span>
<span>(</span><span>def </span><span>bigseq</span>   <span>(</span><span>-&gt;&gt;</span> <span>(</span><span>range </span><span>10000</span><span>)</span> <span>(</span><span>map </span><span>identity</span><span>)))</span>

<span>(</span><span>quick-bench</span>   
  <span>(</span><span>loop </span><span>[</span><span>sum</span>   <span>0</span>
         <span>count </span><span>0</span>
         <span>xs</span>    <span>bigvec</span><span>]</span>
    <span>(</span><span>if-not </span><span>(</span><span>seq </span><span>xs</span><span>)</span>
      <span>[</span><span>sum</span> <span>count</span><span>]</span>
      <span>(</span><span>let </span><span>[[</span><span>x</span> <span>&amp;</span> <span>xs</span><span>]</span> <span>xs</span><span>]</span> 
        <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>)</span> <span>xs</span><span>)))))</span>
<span>; Evaluation count : 456 in 6 samples of 76 calls.</span>
<span>;              Execution time mean : 1.366176 ms</span>
<span>;     Execution time std-deviation : 23.450717 µs</span>
<span>;    Execution time lower quantile : 1.334857 ms ( 2.5%)</span>
<span>;    Execution time upper quantile : 1.392398 ms (97.5%)</span>
<span>;                    Overhead used : 20.320257 ns</span>

<span>(</span><span>quick-bench</span>
  <span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[[</span><span>sum</span> <span>count</span><span>]</span> <span>x</span><span>]</span>
            <span>[(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>)])</span>
          <span>[</span><span>0</span> <span>0</span><span>]</span>
          <span>bigvec</span><span>))</span>
<span>; Evaluation count : 588 in 6 samples of 98 calls.</span>
<span>;              Execution time mean : 1.284103 ms</span>
<span>;     Execution time std-deviation : 118.742660 µs</span>
<span>;    Execution time lower quantile : 1.106587 ms ( 2.5%)</span>
<span>;    Execution time upper quantile : 1.354247 ms (97.5%)</span>
<span>;                    Overhead used : 20.320257 ns</span>

<span>(</span><span>quick-bench</span>
  <span>(</span><span>loopr</span> <span>[</span><span>sum</span> <span>0</span>, <span>count </span><span>0</span><span>]</span>
         <span>[</span><span>x</span> <span>bigvec</span><span>]</span>
         <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>)</span> <span>(</span><span>inc </span><span>count</span><span>))))</span>
<span>; Evaluation count : 792 in 6 samples of 132 calls.</span>
<span>;              Execution time mean : 793.698823 µs</span>
<span>;     Execution time std-deviation : 52.061355 µs</span>
<span>;    Execution time lower quantile : 763.412280 µs ( 2.5%)</span>
<span>;    Execution time upper quantile : 883.322045 µs (97.5%)</span>
<span>;                    Overhead used : 20.320257 ns</span>
</code></pre>
<p>How so fast? <code>loopr</code> <a href="https://github.com/aphyr/dom-top/blob/04d0a688262a3671880e83ce0f35882bd8fa2ff9/src/dom_top/core.clj#L449-L639">macroexpands into</a> <code>loop</code> over a mutable iterator, loop with <code>aget</code> for arrays, or <code>reduce</code>, depending on some heuristics about which tactic is likely to be fastest for your structure. It speeds up multi-accumulator <code>reduce</code> by squirreling away extra accumulators in stateful volatiles.</p>
<h2><a href="#multidimensional-reductions" id="multidimensional-reductions">Multidimensional Reductions</a></h2>
<p>Another problem I hit all the time: reducing over <em>nested</em> collections. Say we’ve got a bunch of people, each one with some pets:</p>
<pre><code><span></span><span>(</span><span>def </span><span>people</span> <span>[{</span><span>:name</span> <span>&#34;zhao&#34;</span>
              <span>:pets</span> <span>[</span><span>&#34;miette&#34;</span> <span>&#34;biscuit&#34;</span><span>]}</span>
             <span>{</span><span>:name</span> <span>&#34;chloe&#34;</span>
              <span>:pets</span> <span>[</span><span>&#34;arthur meowington the third&#34;</span> <span>&#34;miette&#34;</span><span>]}])</span>
</code></pre>
<p>And I wanted to, say, find the set of all pet names. With nested collections, we need a new reduce for each level of nesting.</p>
<pre><code><span></span><span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[</span><span>pet-names</span> <span>person</span><span>]</span>
          <span>(</span><span>reduce </span><span>(</span><span>fn </span><span>[</span><span>pet-names</span> <span>pet</span><span>]</span>
                    <span>(</span><span>conj </span><span>pet-names</span> <span>pet</span><span>))</span>
                  <span>pet-names</span>
                  <span>(</span><span>:pets</span> <span>person</span><span>)))</span>
        <span>#</span><span>{}</span>
        <span>people</span><span>)</span>
<span>; =&gt; #{&#34;biscuit&#34; &#34;miette&#34; &#34;arthur meowington the third&#34;}</span>
</code></pre>
<p>(I know you could write this with a single level of <code>reduce</code> via <code>into</code> or <code>set/union</code>, but we’re using this to illustrate a pattern that’s necessary for more complex reductions, especially those in 3 or 4 dimensions.)</p>
<p>Two problems here. One is that those <code>reduce</code>s chew up indentation real quick. Another is that we wind up specifying <code>pet-names</code> over and over again–threading it in and out of the inner reduce. Reduce is kind of backwards too–the things it starts with, the initial value and the collection, come last. The whole thing reads a bit inside-out.</p>
<p>What about <code>loop</code>? Any better?</p>
<pre><code><span></span><span>(</span><span>loop </span><span>[</span><span>pet-names</span>    <span>#</span><span>{}</span>
       <span>people</span>       <span>people</span><span>]</span>
  <span>(</span><span>if-not </span><span>(</span><span>seq </span><span>people</span><span>)</span>
    <span>pet-names</span>
    <span>(</span><span>let </span><span>[[</span><span>person</span> <span>&amp;</span> <span>people</span><span>]</span> <span>people</span>
          <span>pet-names</span> <span>(</span><span>loop </span><span>[</span><span>pet-names</span> <span>pet-names</span>
                           <span>pets</span>      <span>(</span><span>:pets</span> <span>person</span><span>)]</span>
                      <span>(</span><span>if-not </span><span>(</span><span>seq </span><span>pets</span><span>)</span>
                        <span>pet-names</span>
                        <span>(</span><span>let </span><span>[</span><span>pet</span> <span>(</span><span>first </span><span>pets</span><span>)]</span>
                          <span>(</span><span>recur</span> <span>(</span><span>conj </span><span>pet-names</span> <span>pet</span><span>)</span>
                                 <span>(</span><span>next </span><span>pets</span><span>)))))]</span>
      <span>(</span><span>recur</span> <span>pet-names</span> <span>people</span><span>))))</span>
<span>; =&gt; #{&#34;biscuit&#34; &#34;miette&#34; &#34;arthur meowington the third&#34;}</span>
</code></pre>
<p>Ooof. Again we’re threading accumulators in and out of nested structures, and the loop bodies are interwoven with iteration machinery We could fold this all into a single loop, in theory…</p>
<pre><code><span></span><span>(</span><span>loop </span><span>[</span><span>pet-names</span>    <span>#</span><span>{}</span>
       <span>people</span>       <span>people</span>
       <span>pets</span>         <span>(</span><span>:pets</span> <span>(</span><span>first </span><span>people</span><span>))]</span>
  <span>(</span><span>if-not </span><span>(</span><span>seq </span><span>people</span><span>)</span>
    <span>pet-names</span> <span>; Done with outer loop</span>
    <span>(</span><span>if-not </span><span>(</span><span>seq </span><span>pets</span><span>)</span>
      <span>; Done with this person, move on to next</span>
      <span>(</span><span>recur</span> <span>pet-names</span> <span>(</span><span>next </span><span>people</span><span>)</span> <span>(</span><span>:pets</span> <span>(</span><span>first </span><span>(</span><span>next </span><span>people</span><span>))))</span>
      <span>(</span><span>let </span><span>[[</span><span>pet</span> <span>&amp;</span> <span>pets</span><span>]</span> <span>pets</span><span>]</span>
        <span>(</span><span>recur</span> <span>(</span><span>conj </span><span>pet-names</span> <span>pet</span><span>)</span> <span>people</span> <span>pets</span><span>)))))</span>
</code></pre>
<p>It <em>is</em> shorter, but there are so many ways to get this subtly wrong. I made at least four mistakes writing this loop, and it’s not even that complicated! More complex multi-dimensional iteration is (at least for my brain) playing on nightmare mode.</p>
<p>We do have a lovely, simple macro for nested iteration in Clojure: <code>for</code>.</p>
<pre><code><span></span><span>(</span><span>for </span><span>[</span><span>person</span> <span>people</span>
      <span>pet</span>    <span>(</span><span>:pets</span> <span>person</span><span>)]</span>
  <span>pet</span><span>)</span>
<span>; =&gt; (&#34;miette&#34; &#34;biscuit&#34; &#34;arthur meowington the third&#34; &#34;miette&#34;)</span>
</code></pre>
<p>Problem is <code>for</code> returns a sequence of results, one for each iteration–and there’s no ability to carry accumulators. It’s more like <code>map</code> than <code>reduce</code>. That’s why <code>loopr</code> can take multiple iteration bindings. Just like <code>for</code> it traverses the first binding, then the second, then the third, and so on. Each binding pair has access to the currently bound values of the previous iterators.</p>
<pre><code><span></span><span>(</span><span>loopr</span> <span>[</span><span>pet-names</span> <span>#</span><span>{}]</span>
       <span>[</span><span>person</span> <span>people</span>
        <span>pet</span>    <span>(</span><span>:pets</span> <span>person</span><span>)]</span>
       <span>(</span><span>recur</span> <span>(</span><span>conj </span><span>pet-names</span> <span>pet</span><span>)))</span>
</code></pre>
<p>Without an explicit final expression <code>loopr</code> returns its sole accumulator (or a vector of accumulators, if more than one is given). We get a clear separation of accumulators, iterators, and the loop body. No nesting, much less indentation. It performs identically to the nested <code>reduce</code>, because it actually macroexpands to a very similar nested <code>reduce</code>. Both are about 40% faster than the nested <code>loop</code> with seqs.</p>
<h2><a href="#early-return" id="early-return">Early Return</a></h2>
<p>In <code>reduce</code> we use <code>(reduced x)</code> to return a value immediately; in <code>loop</code> you omit <code>recur</code>. The same works in <code>loopr</code>. Here, we find the first odd number in a collection, returning its index in the collection and the odd value.</p>
<pre><code><span></span><span>(</span><span>loopr</span> <span>[</span><span>i</span> <span>0</span><span>]</span>
       <span>[</span><span>x</span> <span>[</span><span>0</span> <span>3</span> <span>4</span> <span>5</span><span>]]</span>
       <span>(</span><span>if </span><span>(</span><span>odd?</span> <span>x</span><span>)</span>
         <span>{</span><span>:index</span> <span>i</span>, <span>:number</span> <span>x</span><span>}</span>
         <span>(</span><span>recur</span> <span>(</span><span>inc </span><span>i</span><span>))))</span>
<span>; =&gt; {:index 1, :number 3}</span>
</code></pre>
<p>With zero accumulators, loopr still iterates. This can be helpful for side effects or search. Here’s how to find a key in a map by that key’s corresponding value. Note that iterator bindings support the usual destructuring syntax–we can iterate over a map as <code>[key value]</code> pairs.</p>
<pre><code><span></span><span>(</span><span>loopr</span> <span>[]</span>
       <span>[[</span><span>k</span> <span>v</span><span>]</span> <span>{</span><span>:x</span> <span>1</span>, <span>:y</span> <span>2</span><span>}]</span>
       <span>(</span><span>if </span><span>(</span><span>= </span><span>v</span> <span>2</span><span>)</span>
         <span>k</span>
         <span>(</span><span>recur</span><span>))</span>
       <span>:not-found</span><span>)</span>
<span>; =&gt; :y</span>
</code></pre>
<p>If we don’t return early, <code>loopr</code> returns the final form: <code>:not-found</code>.</p>
<h2><a href="#arrays" id="arrays">Arrays</a></h2>
<p>Sometimes you write an algorithm which reduces over vectors or other collections as a prototype, then start using arrays for speed. <code>loopr</code> can compile the same reduction to a <code>loop</code> using integer indices and <code>aget</code> operations. Just tell it you’d like to iterate <code>:via :array</code>.</p>
<pre><code><span></span><span>(</span><span>def </span><span>ary</span> <span>(</span><span>long-array</span> <span>(</span><span>range </span><span>10000</span><span>)))</span>
<span>(</span><span>loopr</span> <span>[</span><span>sum</span> <span>0</span><span>]</span>
       <span>[</span><span>x</span> <span>ary</span> <span>:via</span> <span>:array</span><span>]</span>
       <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>)))</span>
<span>; =&gt; 49995000</span>
</code></pre>
<p>This is on par with <code>(reduce + ary)</code> for single-dimensional reductions. For multi-dimensional arrays <code>loopr</code> is ~65% faster on my machine, though you do have to explicitly type-hint. Faster still with multiple accumulators, of course.</p>
<pre><code><span></span><span>(</span><span>def </span><span>matrix</span> <span>(</span><span>to-array-2d </span><span>(</span><span>repeat </span><span>1000</span> <span>(</span><span>range </span><span>1000</span><span>))))</span>
<span>(</span><span>loopr</span> <span>[</span><span>sum</span> <span>0</span><span>]</span>
       <span>[</span><span>row</span>                     <span>matrix</span> <span>:via</span> <span>:array</span>
        <span>x</span>   <span>^</span><span>&#34;[Ljava.lang.Long;&#34;</span> <span>row</span>    <span>:via</span> <span>:array</span><span>]</span>
       <span>(</span><span>recur</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>)))</span>
<span>; =&gt; 499500000</span>
</code></pre>
<p>You can control the iteration tactic for each collection separately, by the way. Here’s the average of the numbers in a vector of vectors, where we traverse the outermost vector using a <code>reduce</code>, and the inner vectors using a mutable iterator.</p>
<pre><code><span></span><span>(</span><span>loopr</span> <span>[</span><span>count </span><span>0</span>
        <span>sum</span>   <span>0</span><span>]</span>
       <span>[</span><span>row</span> <span>[[</span><span>1</span> <span>2</span> <span>3</span><span>]</span> <span>[</span><span>4</span> <span>5</span> <span>6</span><span>]</span> <span>[</span><span>7</span> <span>8</span> <span>9</span><span>]]</span> <span>:via</span> <span>:reduce</span>
        <span>x</span>   <span>row</span>                       <span>:via</span> <span>:iterator</span><span>]</span>
       <span>(</span><span>recur</span> <span>(</span><span>inc </span><span>count</span><span>)</span> <span>(</span><span>+ </span><span>sum</span> <span>x</span><span>))</span>
       <span>(</span><span>/ </span><span>sum</span> <span>count</span><span>))</span>
<span>; =&gt; 5</span>
</code></pre>
<h2><a href="#in-summary" id="in-summary">In Summary</a></h2>
<p>I’m always hesitant to introduce nontrivial macros. That said, in the last five months I’ve written a lot of code with and without <code>loopr</code>, and I’ve found it frequently useful. It’s often clearer <em>and</em> more efficient than the code I was already writing, and it makes refactoring complex reductions less difficult. If you’d like to give it a shot, you’ll find it in <a href="https://github.com/aphyr/dom-top">dom-top</a>, which is a small control flow library. You’ll find tons of examples and Criterium benchmarks in <a href="https://github.com/aphyr/dom-top/blob/master/test/dom_top/core_test.clj#L205-L613">the test suite</a>. I hope <code>loopr</code> helps you too.</p>

    </div></div>
  </body>
</html>
