<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.romaglushko.com/blog/whats-aouth2/">Original</a>
    <h1>What&#39;s OAuth2, anyway?</h1>
    
    <div id="readability-page-1" class="page"><div><p>Have you ever logged into a website using your Google or Facebook account?
Or connected an app to access your GitHub data? If so, you’ve already used OAuth2, whether you knew it or not.</p>
<p>OAuth2 is the world’s most popular, extensible authorization framework.
It allows you to integrate a couple of systems together by delegating access to your data from one service to another.
But here is the thing - most people don’t really understand how OAuth2 really works.</p>
<p>Personally, I’ve implemented several applications that were using OAuth2.
The process was so straightforward that I had no need to stop and think about the protocol itself along the way.
That’s by design. OAuth2 is built to be super simple to implement client applications, not to wrestle with complex authentication requirements.</p>
<p>But if we pause and dig deeper, there’s a lot to learn from the software engineering point of view.</p>
<p>In this article, we will uncover the “whys” behind the OAuth2 protocol design and
break down the most common authentication grants.</p>
<h2 id="background">Background<a aria-hidden="true" tabindex="-1" href="#background"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>It’s helpful to start with the historical context of the problem that OAuth2 was created to solve
and consider alternatives we’d have without it.</p>
<p>Imagine we want to build a user-friendly deployment platform like Fly.io or Vercel.
Right away, we hit the key problem: how can our customers import their code into our platform?</p>
<p>These days, almost everyone uses Git.
We could try building a Git hosting functionality directly into the platform,
but that’s a huge piece of work, while our primary business goal is resource management, autoscaling, load balancing, etc.
On top of that, most of our customers are probably already using one of the existing popular Git hosting services like GitHub, GitLab, or Bitbucket.
Unfortunately, we don’t have any way to convince these platforms to integrate with us.</p>
<p>So, what’s our options? How could we possibly get access to our customers’ Git repositories hosted elsewhere?</p>
<h3 id="user-credentials-sharing">User Credentials Sharing<a aria-hidden="true" tabindex="-1" href="#user-credentials-sharing"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>Our customers log into their Git hosting services using their credentials.
Why can’t they just share their credentials to us?</p>
<p>We could store their credentials securely and then, when needed, log in to the Git service on their behalf,
use their session cookies, and fetch the required Git repositories.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/plain-owner-credentials-sharing.png" alt="Plain User Credentials Sharing" title="Plain User Credentials Sharing" loading="lazy"/>
</p><p>Plain User Credentials Sharing (sounds great, huh?)</p>
<p>At first glance, this sounds like a straightforward idea to let our platform work with customer data, even when they are not around.</p>
<p>But then we realize, it’s riddled with problems:</p>
<ul>
<li><strong>No access control</strong>. The platform gets full access to everything that our customers can do without a way to limit or control that, even if we only need to access their repositories.</li>
<li><strong>No session control</strong>. It’s hard to distinguish between sessions created by the users and those initialized by the platform. If the login process is the same for both, it’s hard to implement more advanced login security measures like MFA.</li>
<li><strong>Hard to revoke</strong>. Once shared, the credentials can be cached and leaked in unexpected ways even if you removed them from the platform UI. The only way to fully revoke access is to change your password.</li>
<li><strong>Brittle</strong>. If you change your password, this would effectively break the platform’s access to your data.</li>
<li><strong>Security risks</strong>. The platform must store the credentials securely, which is a significant responsibility. If the shared credentials are managed in a sloppy way, they may be breached and expose the whole customer account.</li>
</ul>
<p>It’s a problem that one and the same set of credentials with broad, top level permissions are used for two vastly different purposes.
What could we do about that?</p>
<h3 id="personal-access-tokens">Personal Access Tokens<a aria-hidden="true" tabindex="-1" href="#personal-access-tokens"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>Apparently, if we want to do any better, we need to keep the main credentials private.
Instead, we could introduce an alternative type of credentials just for using in integrations.</p>
<p>Let’s call these Personal Access Tokens (PATs). Think of them as a static secret string with a relatively long lifespan.
Technically, each PAT could have a custom set of permissions assigned to it, limiting what the platform can do with the associated data.</p>
<p>Whenever a customer wants to integrate Git repositories with a new service, like our deployment platform, they would generate a new personal access token with the necessary permissions  and share it with the service.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/personal-access-token-sharing.png" alt="Personal Access Tokens Sharing" title="Personal Access Tokens Sharing" loading="lazy"/>
</p><p>Personal Access Tokens Sharing</p>
<p>This approach is a great improvement over sharing the plain credentials, since it addresses its major problems.
However, there are still a couple of things to keep in mind:</p>
<ul>
<li>Keeping track of expiration dates and replacing stale tokens gets tedious very quickly if you need to manage more than a handful of tokens.</li>
<li>To minimize the management burden, token lifetime could be extended (we are talking about months or even years). Unfortunately, in that case, a token gets compromised, malicious actors will have plenty of time to exploit it.</li>
</ul>
<p>But do customers really need to manage their tokens for every service and integration they use?
Could we simplify this further, so customers will have to do as little as possible to enable new integrations and the whole token management process is automated by the party that needs it?</p>

<p>That’s exactly why we need something like the OAuth framework.</p>
<h2 id="whats-oauth2">What’s OAuth2?<a aria-hidden="true" tabindex="-1" href="#whats-oauth2"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc6749" target="_blank" rel="noopener noreferrer">OAuth2</a> is a framework that defines how access or permissions are requested or delegated from one
an authoritative entity (like the user) to third-party applications.</p>

<p>The core idea behind OAuth2 is to give users the power to decide what applications (beyond those that are natively supported by the resource server)
can access their data. It ensures that the access is controlled and convenient, allowing these applications use your data whenever they need to, even when you’re not around, to extend the base functionality of the resource server.
Let’s break it down a bit.</p>
<p>Without mechanisms like OAuth2, the resource server essentially controls which applications can access with your data.
I imagine this happens through partnerships, where two companies collaborate to integrate their services into each other’s offerings (often in a very custom, non-standardized way).</p>
<p>This approach is centralized because:</p>
<ul>
<li>Only allowed partner’s applications are at play</li>
<li>Everything else is effectively blocked.</li>
</ul>
<p>OAuth2 introduces a middle ground, allowing the third-party applications to use the resource server, as long as users are willing to
grant permissions to their data or functionality. In this model, the resource server decides nothing for end users (unless it’s blocking malicious applications to protect users from abuse).</p>
<p>This creates a powerful form of decentralization that:</p>
<ul>
<li>Let resource owner extend the resource server’s functionality in a few clicks</li>
<li>Help to build an ecosystem of tools and applications around the resource server</li>
</ul>
<h2 id="roles">Roles<a aria-hidden="true" tabindex="-1" href="#roles"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>OAuth2 defines three main roles to organize the delegation process:</p>
<ul>
<li><strong>Resource Server</strong>. This is a service that the client application needs to access, either on user or their own behalf. For example, in our case, it’s the Git hosting provider like GitHub.</li>
<li><strong>Resource Owner</strong> (the user if it’s a person). The entity that holds permissions to the resource server and can grant access to the client application.</li>
<li><strong>Authorization Server</strong>. This service issues resource access tokens for the client application in exchange for various forms of authorization or grants.</li>
<li><strong>Client Application</strong> (a.k.a. the client, OAuth application). An application or service that accesses the protected resource server, typically on behalf of the resource owner.</li>
</ul>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-roles.png" alt="OAuth2 Roles and High-Level Interactions Between Them" title="OAuth2 Roles and High-Level Interactions Between Them" loading="lazy"/>
</p><p>OAuth2 Roles and High-Level Interactions Between Them</p>
<h3 id="general-workflow">General Workflow<a aria-hidden="true" tabindex="-1" href="#general-workflow"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>OAuth2 introduces the Authorization Server, acts as a middleman between
the Resource Owner (who has the authority) and the Client Application (that needs some of that authority).
The Authorization Server is trusted by the target Resource Server (which provides some functionality based on the authority).</p>
<p><a href="#clients">The Client Application</a> asks the Resource Owner for a certain set of permissions to access the Resource Server.</p>

<p>The Resource Owner reviews the permission request and gives a consent to grant the access to the Client Application via the Authorization Server.</p>

<p>Depending on <a href="#oauth2-flows">the authorization flow</a>, the Client Application receives an authorization grant in some form and uses it to trade for an access token (or a pair of tokens)
from the Authorization Server.</p>
<p>Finally, the Client Application uses the access token to access the Resource Server on behalf of the Resource Owner.</p>
<p>The Resource Server knows how to validate <a href="#access-tokens">the access tokens</a> issued by the Authorization Server, typically through an internal request to the Authorization Server.</p>
<h2 id="clients">Clients<a aria-hidden="true" tabindex="-1" href="#clients"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>The journey into the OAuth2 world begins with Client Applications.
There are two types of Client Applications, categorized by their abilities to keep secrets:</p>
<ul>
<li><strong>Public applications</strong> like in-browser JS applications, desktop or native mobile apps. Any secrets embedded in this type of application can be reverse-engineered and extracted, even if you try to obfuscate their distributions or encrypt them.</li>
<li><strong>Private (or confidential) applications</strong>, which are typically any web applications with frontend and, most importantly, backend parts. The backend is capable of securely storing secrets and establishing protected communication with the Authorization Server.</li>
</ul>
<p>OAuth2 assumes there are much more Client Applications than Authorization and Resource Servers,
so it aims to simplify the Client Application side as much as possible.
This not only reduces the work to do to implement a Client Application, but also limits opportunity for implementing insecure Clients.</p>
<p>The heavy lifting of keeping the OAuth2 workflow secure is handled by <a href="#authz-server">the Authorization Servers</a>.</p>
<h3 id="client-registration">Client Registration<a aria-hidden="true" tabindex="-1" href="#client-registration"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>To plug our Client Applications into the OAuth2 workflow, they first need to be registered with the Authorization Server.</p>
<p>The OAuth2 doesn’t make any assumptions how the registration process should work,
but it’s typically a part of the OAuth2 provider website’s settings e.g. functionality to create and manage OAuth apps.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/gitlab-oauth-app-registration-form.png" alt="The Gitlab OAuth Client Registration" title="The Gitlab OAuth Client Registration" loading="lazy"/>
</p><p>The Gitlab OAuth Client Registration</p>
<p>The registration form usually includes:</p>
<ul>
<li>Redirect URL(s) - A list of allowed URLs for redirects in interactive authorization flows, such as the <a href="#authorization-code">authorization code</a> or <a href="#implicit">implicit</a> flows.</li>
<li><a href="#scopes">Scopes</a> - A list of delegated access to the Resource Server’s functionality e.g. read Git repositories, create issues, etc.</li>
<li>Miscellaneous information like application name, icon, privacy and terms of service URLs, etc.</li>
</ul>
<p>There are other, less popular client registration approaches. For example, I’ve seen:</p>
<ul>
<li>Registration via internal admin requests to the Authorization Server like <a href="https://github.com/ory/hydra/tree/master" target="_blank" rel="noopener noreferrer">ORY Hydra</a>.</li>
<li>Declarative registration by creating Kubernetes Custom Resources in the cluster using <a href="https://github.com/ory/hydra-maester" target="_blank" rel="noopener noreferrer">ORY Hydra Maester</a>.</li>
</ul>

<h3 id="client-credentials">Client Credentials<a aria-hidden="true" tabindex="-1" href="#client-credentials"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>At the end of registration, you typically receive the client credentials:</p>
<ul>
<li><strong>Client ID</strong> (a.k.a App ID) - a public, non-secret identifier of your Client Application.</li>
<li><strong>Client Secret</strong> - a secret password that the Client Application keeps privately.</li>
</ul>
<p>The client credentials are used to:</p>
<ul>
<li>authenticate the Client Application requests to the Authorization Server</li>
<li>bind <a href="#oauth2-flows">a specific authorization flow</a> to the Client Application that has started it. This ensures it’s not possible to finish that flow with completely different Client Application</li>
<li>add another layer of protection to <a href="#authorization-code">authorization flows</a> and <a href="#access-tokens">the obtained refresh tokens</a>, because you cannot leverage them unless you have the right client credentials</li>
</ul>
<p>The Client Application sends the credentials as <a href="https://datatracker.ietf.org/doc/html/rfc7617" target="_blank" rel="noopener noreferrer">the Basic HTTP Authorization header</a>.</p>

<p>The client ID is tied to authorization grants and refresh tokens, so it’s essential to keep it unchanged.
Changing it would invalidate all authorizations (e.g. <a href="#refresh-tokens">refresh tokens</a>) that you’ve already obtained.</p>
<p>On the other hand, the client secret can, and should be, rotated periodically.
Changing the secret would have an effect of “rotation” of all refresh tokens received by the Client Application
even though the tokens would not be affected.
This is because if the client credentials were leaked along with some refresh tokens,
malicious actors would not be able to obtain new access tokens using the old client secret after the client secret rotation.</p>
<p>This significantly simplifies the process of secret rotation as you need to rotate only one secret
instead of rotating thousands of refresh tokens for each end user that has ever authorized your Client Application.</p>

<h2 id="authz-servers">AuthZ Servers<a aria-hidden="true" tabindex="-1" href="#authz-servers"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>The Authorization Server handles the delegation process via <a href="#oauth2-flows">multiple authorization flows</a> (including potentially <a href="#more-flows">non-standard flows</a>) uniformly and as a result, it issues <a href="#access-tokens">a special access token (or a pair of tokens)</a>.
In order to do that, the Authorization Server needs to provide at least the following endpoints required by the OAuth2 protocol:</p>
<ul>
<li><strong>Authorization endpoint</strong> that starts the interactive <a href="#authorization-code">authorization code</a> or <a href="#implicit">implicit</a> flows</li>
<li><strong>Token endpoint</strong> that generates <a href="#access-tokens">access and refresh tokens</a> and used in pretty much all other authorization flows</li>
<li><strong>Device endpoint</strong> if you want to support <a href="#device-flow">the device flow</a></li>
</ul>
<p>In practice, you may want to also have a bunch of others that are not defined in OAuth2 directly:</p>
<ul>
<li><strong>Access token introspection endpoint</strong> (it has its own <a href="https://www.rfc-editor.org/rfc/rfc7662.html" target="_blank" rel="noopener noreferrer">RFC</a>) that returns metadata information associated with the given access token. It can be used by resource servers to validate incoming access tokens.</li>
<li><strong>Authorization grant revocation endpoint</strong> that allows it to revoke the whole authorization grant.</li>
<li><strong>Token revocation endpoint</strong> that allows to revoke the issued access and refresh tokens.</li>
<li>and a bulk of other endpoints that were introduced in the all follow-up RFCs and drafts if you need that.</li>
</ul>
<h3 id="endpoint-discovery">Endpoint Discovery<a aria-hidden="true" tabindex="-1" href="#endpoint-discovery"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>Historically, the Authorization Server OAuth2 endpoints were not fixed nor was there a way to discover them.
The endpoints were extracted by the provider documentation and hardcoded in the OAuth2 libraries or Client Application
(here is <a href="https://github.com/markbates/goth/blob/master/providers/github/github.go#L29-L34" target="_blank" rel="noopener noreferrer">an example</a> from the goth library).</p>

<h3 id="security">Security<a aria-hidden="true" tabindex="-1" href="#security"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>The Authorization Server is represented as a separate component conceptually, but the protocol has no requirements on how it should be implemented under the hood.
It could be either a separate microservice, or it can be a part of the Resource Server.</p>
<p>One important assumption that OAuth2 protocol makes implicitly is that one authorization server can potentially handle authorizations for multiple Resource Servers.
This means that among all OAuth2 components, the Authorization Servers are the rarest to implement.
That’s why they are responsible for handling <a href="https://datatracker.ietf.org/doc/html/rfc6819" target="_blank" rel="noopener noreferrer">a lot of security nuances</a> around the Authorization Server implementations.
Your OAuth2 is essentially as secure as your Authorization Server.</p>
<h2 id="access-tokens">Access Tokens<a aria-hidden="true" tabindex="-1" href="#access-tokens"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>The Authorization Server generates access tokens as a result of the successful authorization flow.</p>
<p>The access tokens are a special credential that serves as an alternative method of authentication for the Resource Server.
They can be also seen as an abstraction around the exact authorization flow.
There could be multiple authorization flows supported by the Authorization Server, but they all will result in access tokens that have the same format.
This makes them easier to validate for the Resource Server that doesn’t need to know too much information about how the specific token was obtained.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-access-tokens.png" alt="Access Tokens unifies the authorization flows" title="Access Tokens unifies the authorization flows" loading="lazy"/>
</p><p>Access Tokens unifies the authorization flows</p>
<h3 id="access-token-scopes">Access Token Scopes<a aria-hidden="true" tabindex="-1" href="#access-token-scopes"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>The concept of access token is also important because we can generate multiple access tokens with different reduced subset of <a href="#scopes">the originally requested scopes</a>.
If there was no access tokens as a separate credential and we were using <a href="#authorization-code">the authorization code</a>,
let’s say, for that purpose, it would have all permission scopes requested by the client application at the point of passing authorization flow.</p>
<h3 id="token-types">Token Types<a aria-hidden="true" tabindex="-1" href="#token-types"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>OAuth2 doesn’t define how the access tokens should look like.
They are opaque strings to the Client Applications and likely Resource Servers too.</p>
<p>Apart from that, when an access token is generated, the Authorization Server indicates what type of token was issued.</p>
<h4 id="bearer-tokens">Bearer Tokens<a aria-hidden="true" tabindex="-1" href="#bearer-tokens"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>The most common access token type is called <a href="https://datatracker.ietf.org/doc/html/rfc6750" target="_blank" rel="noopener noreferrer">the Bearer token</a>.</p>

<p>In the wild, Authorization Servers may issue bearer tokens as:</p>
<ul>
<li>a unique random string. The string should be non-guessable and not possible to generate outside the Authorization Server.</li>
<li>or as a self-contained JWT token that includes the signed meta information.</li>
</ul>

<p>Other types of tokens are theoretically possible, but I have never seen them in the wild.</p>

<h3 id="token-lifetime">Token Lifetime<a aria-hidden="true" tabindex="-1" href="#token-lifetime"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>OAuth2 requires Authorization Servers to generate access tokens only.
If so, the generated token is considered as a long-lived and that’s not great for two reasons:</p>
<ul>
<li>The access tokens are linked to the client application, but they are usually passed to the resource server without any additional proof of token possession. Hence, if they are leaked, the malicious actors would have enough time to exploit them.</li>
<li>The access token is linked to the original access scopes and there is no way to generate a new access token with a subset of scopes without going through the whole authorization flow again.</li>
</ul>
<p>To address these concerns, it’s the best practice to keep access tokens short-lived.
Along with that, you can generate a separate, long-lived token that generates you fresh access tokens as needed.
This type of token is called <a href="#refresh-tokens">refresh token</a>.</p>

<h2 id="scopes">Scopes<a aria-hidden="true" tabindex="-1" href="#scopes"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>Authorization scopes are a set of functionalities that the Resource Owner delegates to the Client Application,
allowing the Client to access resources as thought it were the original owner.</p>

<p>The scopes are simply a space-separated list of strings, where each string specifies a particular access type.
The scope format is not defined in the OAuth2 protocol, but they are normally structured like this: <code>{resource}_{access level}</code>.</p>
<p>For example,</p>
<ul>
<li><code>user_read</code> may allow the Client to read the current user (e.g. Resource Owner) profile information</li>
<li><code>repo_write</code> may allow the Client Application to commit to the repositories to which the Resource Owner has access to.</li>
</ul>
<p>As you can see, the scopes are fairly coarse-grained, they don’t grant access to specific resources,
but rather work on the resource types and access levels (e.g. read/write/admin).</p>
<p>Scopes are additive, meaning when multiple scopes are requested, they are combined to broaden the Client Application’s or access token’s permissions.</p>
<h2 id="oauth2-flows">OAuth2 Flows<a aria-hidden="true" tabindex="-1" href="#oauth2-flows"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>Authorization flows, also known as authorization grants, are how permissions are delegated to the Client Applications.
Regardless of the flow you use, the end result is <a href="#access-tokens">a set of access tokens</a> that enable the Client Application to directly access the Resource Server.</p>
<p>The main differences between flows are:</p>
<ul>
<li>whenever it’s interactive or non</li>
<li>the number of participants involved (2- or 3-leg flows)</li>
<li>whenever it’s secure to use it by (<a href="#clients">public or confidential</a>) clients</li>
</ul>


<p>We’ll start by reviewing the most canonical and secure OAuth2 flow called the authorization code flow.</p>
<p>This flow is interactive and works for Client Applications that can keep secrets and perform browser redirects, typical for web services with a backend.</p>
<p>The flow consists of two stages:</p>
<ul>
<li><a href="#authorization-request">The authorization request</a>, a redirect to the Authorization Server</li>
<li><a href="#code-exchange">The authorization code exchange</a>. Occurs at the client’s callback URL</li>
</ul>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-authorization-code-flow.png" alt="OAuth2 Authorization Code Flow" title="OAuth2 Authorization Code Flow" loading="lazy"/>
</p><p>OAuth2 Authorization Code Flow</p>
<p>The whole authorization code flow can be divided into two main parts:</p>
<ul>
<li>The interactions that happen indirectly between the Authorization Server and the Client Application using the browser as a mediator. These actions are performed via the frontend channel and can be potentially intercepted or manipulated along the way (e.g. a malicious browser extension may try to sniff the code parameters).</li>
<li>The interactions occur directly between Authorization Server and the client via trusted backend channel.</li>
</ul>
<p>The authorization code flow is designed so that it’s not possible to get access delegation by using only information transmitted via the frontend channel.</p>
<h4 id="authorization-request">Authorization Request<a aria-hidden="true" tabindex="-1" href="#authorization-request"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>In order to start the OAuth2 flow, the client application needs to request the authorization with the needed scopes from the Resource Owner.
This happens by redirecting the resource owner to the authorization server’s <code>authorize</code> endpoint.</p>
<p>The authorization URL usually contains the following URL parameters:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://auth.example.com/authorize?response_type=</span><span data-highlighted-chars="">code</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>client_id=</span><span>Iv23lilfdg920cAzhcxA</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>scope=</span><span>read_user%20write_repo%20read_repo</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr-XAbzFLG937m5_u12DkEjQvfj4UsOkVg0uVHZMVcXWcWFr6iQ7XLFopkw==</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://auth.example.com/authorize?response_type=</span><span data-highlighted-chars="">code</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>client_id=</span><span>Iv23lilfdg920cAzhcxA</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>scope=</span><span>read_user%20write_repo%20read_repo</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr-XAbzFLG937m5_u12DkEjQvfj4UsOkVg0uVHZMVcXWcWFr6iQ7XLFopkw==</span></span></code></pre></div>
<ul>
<li>The <code>response_type</code> is what defines what kind of interactive flow we are going to perform. It’s always <code>code</code> for the authorization code flow (or <code>token</code> for <a href="#implicit">the implicit flow</a>).</li>
<li>The <code>client_id</code> is required as the authorization code is strictly assigned to the client application that has initialized the flow (to prohibit finishing the flow from another Client Application).</li>
<li>The <code>redirect_uri</code> is the URL of the client application callback page where the authorization code will be passed after
the authorization consent. This URL must be specified in <a href="#client-registration">the client registration settings</a>.</li>
</ul>

<p>The Resource Owner browser should already have a user session (e.g. session cookie) with the Authorization Server (or login otherwise),
so the redirect can leverage that to seamlessly show the authorization consent screen.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-authorization-consent-screen.png" alt="Authorization Consent Screen" title="Authorization Consent Screen" loading="lazy"/>
</p><p>The Example of the Authorization Consent Screen</p>
<p>Let’s note that the client application communicates with the Authorization Server indirectly via HTTP redirects
and the Resource Owner browser. This way the Client Application doesn’t have to know about the Resource Owner credentials or session
which is itself the key problem the OAuth2 protocol was born to solve.</p>
<p>Because of that, the authorization consent page should not have any client-specific CORS configuration.
This remains true for all OAuth2 flows.</p>
<h4 id="code-exchange">Code Exchange<a aria-hidden="true" tabindex="-1" href="#code-exchange"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>Once the Resource Owner approves the delegation of access to the Client Application, the Authorization Server redirects
the Resource Owner back to the Client Application callback URL specified during the authorization request.</p>
<p>The client callback redirect looks like this:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://www.clientapp.com/callback/?code=AUTHORIZATION_CODE</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://www.clientapp.com/callback/?code=AUTHORIZATION_CODE</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre></div>
<ul>
<li>the <code>code</code> parameter is called the authorization code (it gives this flow its name).</li>
<li>the <code>state</code> is returned back if it was specified originally to let the Client Application verify the integrity of the flow.</li>
</ul>

<p>The authorization code is a one-time-use token that represents the specific Resource Owner’s consent to give to the specific Client Application.
It is tied to the client ID that has obtained it, so it’s not possible to exchange it from another Client Application.
So even if the code was leaked somehow, you would need to have valid client credentials to turn it into access tokens.</p>
<p>Finally, to finish the flow, we need to exchange the authorization code for the access tokens.
This is done via the OAuth2 token endpoint:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span></span>
<span data-line=""><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span></span>
<span data-line=""><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span></code></pre></div>
<ul>
<li>The <code>grant_type</code> defines what kind of flow or grant we want to use to trade for access tokens. It’s a universal endpoint used in the other flows too, but in the case of this flow, it’s always going to be <code>authorization_code</code>.</li>
<li>The <code>code</code> is mandatory to provide in the authorization code exchange.</li>
<li>The <code>redirect_uri</code> is an additional security measure to use when multiple redirect URLs are allowlisted to prevent <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.5.1" target="_blank" rel="noopener noreferrer">authorization code injections</a>.</li>
</ul>

<p>In response, if everything went fine, you would get response like this:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="json" data-theme="dark"><code data-language="json" data-theme="dark"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>token_type</span><span>&#34;</span><span>:</span><span>&#34;</span><span>bearer</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>access_token</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>gho_16C7e42F292c6912E7710c838347Ae178B4a</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>scope</span><span>&#34;</span><span>:</span><span>&#34;</span><span>read_user write_repo read_repo</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>expires_in</span><span>&#34;</span><span>:</span><span> </span><span>3600</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>refresh_token</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>ghr_16C7e42F292c6912E7710c838347Ae178</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>}</span></span></code></pre><pre data-language="json" data-theme="light"><code data-language="json" data-theme="light"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;token_type&#34;</span><span>:</span><span>&#34;bearer&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;access_token&#34;</span><span>: </span><span>&#34;gho_16C7e42F292c6912E7710c838347Ae178B4a&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;scope&#34;</span><span>:</span><span>&#34;read_user write_repo read_repo&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;expires_in&#34;</span><span>: </span><span>3600</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;refresh_token&#34;</span><span>: </span><span>&#34;ghr_16C7e42F292c6912E7710c838347Ae178&#34;</span><span>,</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>That’s all. Now you need to persist the access and refresh tokens and use them to access the Resource Server.</p>
<h4 id="pkce">PKCE<a aria-hidden="true" tabindex="-1" href="#pkce"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>The analysis of real-world attacks on the authorization flows has shown that it can be further secured.
Specifically, malicious actors can intercept the authorization code or try to inject it into the callback URL to do token exchange via unauthorized workflows.
These attack vectors are the most probable in public applications like native applications.</p>
<p>To mitigate this, the OAuth2 protocol has extended the authorization code flow with the <a href="https://datatracker.ietf.org/doc/html/rfc7636" target="_blank" rel="noopener noreferrer">Proof Key for Code Exchange (PKCE)</a> extension (pronounced as “pixy”).</p>
<p>PKCE is a simple way to prove that the authorization code was obtained via the legitimate authorization request.
The beauty of PKCE is that it just slightly extends the authorization &amp; token requests without major changes to the flow.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-authorization-code-pkce-flow.png" alt="OAuth2 Authorize Code with PKCE" title="OAuth2 Authorize Code with PKCE" loading="lazy"/>
</p><p>OAuth2 Authorize Code with PKCE</p>
<ul>
<li>The Client Applications generate a random string called the <code>code_verifier</code> and then hash it with a cryptographically secure algorithm as SHA256. The hashed value is called the <code>code_challenge</code>.</li>
<li>The Client Application keeps the original <code>code_verifier</code> privately and shares the <code>code_challenge</code> and the hash code (e.g. <code>code_challenge_method</code>) as query params in the authorization request.</li>
<li>The Authorization Server remembers the <code>code_challenge</code> and the <code>code_challenge_method</code>. No other changes are needed to the existing Authorization Server responses.</li>
<li>Then, the client sends the <code>code_verifier</code> during token exchange. The Authorization Server computes the hash of that value and compares it with the <code>code_challenge</code> passed during the authorization request.</li>
</ul>
<p>PKCE supports two hashing methods:</p>
<ul>
<li><code>S256</code> - the SHA256 hashing algorithm</li>
</ul>
<div data-rehype-pretty-code-fragment=""><pre data-language="plain" data-theme="dark"><code data-language="plain" data-theme="dark"><span data-line=""><span>code_challenge = base64(SHA256(ASCII(code_verifier)))</span></span></code></pre><pre data-language="plain" data-theme="light"><code data-language="plain" data-theme="light"><span data-line=""><span>code_challenge = base64(SHA256(ASCII(code_verifier)))</span></span></code></pre></div>
<ul>
<li><code>plain</code> - the plain text method. It’s basically just <code>code_challenge = code_verifier</code>. The <code>plain</code> method should be avoided as it doesn’t really introduce any challenges. It can only protect you from attacks where nefarious actors can intercept the Authorization Server responses.</li>
</ul>
<p>The PKCE extension allows the public clients to finally leverage the authorization code flow securely.
However, the Authorization Server must be ready to support PKCE for public clients which boils down to not requiring these clients to provide any client secrets.</p>
<h3 id="refresh-tokens">Refresh Tokens<a aria-hidden="true" tabindex="-1" href="#refresh-tokens"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>The refresh token is an optional but highly recommended additional token that <a href="#code-exchange">the OAuth2 token endpoint</a> can return to you.
Unlike <a href="#access-tokens">the access token</a>, the refresh token is meant to be a long-lived token (either no expiration time or an extended period of time like half a year)
that is sent to the authorization server only.</p>
<p>Essentially, the refresh token is an “internal” authorization grant because it implies the authorization that the resource owner has given to the Client Application.</p>
<p>The refresh token is important for two reasons:</p>
<ul>
<li>it allows to keep access tokens short-lived, so minimize the attack surface if they are leaked</li>
<li>it allows to the generation of access tokens with the reduced access scope that is more limited than the scopes granted to the Client Application during authorization. This enables the clients to implement the least privilege principle on their side.</li>
</ul>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-refresh-token-flow.png" alt="OAuth2 Refresh Token Flow" title="OAuth2 Refresh Token Flow" loading="lazy"/>
</p><p>OAuth2 Refresh Token Flow</p>
<p>In order to refresh your access token, you send a request to the OAuth2 token endpoint with the <code>grant_type</code> set to <code>refresh_token</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=refresh_token&amp;refresh_token=ghr_16C7e42F292c6912E7710c838347Ae178</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=refresh_token&amp;refresh_token=ghr_16C7e42F292c6912E7710c838347Ae178</span></span></code></pre></div>
<p>The refresh token is linked to the specific client credentials, so it’s not possible to leverage it with an unauthorized client.</p>
<p>The refresh token request generally returns the same response as we have seen in the <a href="#code-exchange">authorization code exchange</a>.
It contains the new active access token, its expiration time and the actual access scopes.
In some cases (GitHub and GitLab do this, for instance), the refresh token request may actually also refresh your previous refresh token, so if the token response
contains the <code>refresh_token</code> field and it’s different from your current refresh token, it means that this is your new refresh token to persist and use going forward.</p>
<p>The refresh token request generally invalidates all previous access tokens (and refresh tokens).</p>

<h3 id="implicit">Implicit<a aria-hidden="true" tabindex="-1" href="#implicit"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>We have said that <a href="#authorization-code">the authorization code flow</a> is designed to make it impossible to
get Resource Owner delegation by using only information passed via the frontend channel (e.g. the authorization code and client ID).
In order to achieve this, that flow requires the Client Application to have a secure backend channel.
But what if the application is public and doesn’t have a place to put a secret, so it remains a secret?</p>
<p>The original OAuth2 specification introduced a simplified version of the authorization code flow
that makes a significant security trade-off in order to support public applications, first of all, in-browser JS applications
like browser extensions or single page applications (SPAs) without backends. It’s called the implicit flow.</p>
<p>The implicit flow is also an interactive, redirect-based flow, but there is no explicit code exchange via the backend channel.
Instead, it happens implicitly and the Client Application just receives the access token in the callback URL.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-implicit-flow.png" alt="OAuth2 Implicit Flow" title="OAuth2 Implicit Flow" loading="lazy"/>
</p><p>OAuth2 Implicit Flow</p>
<p>The authorization request looks close to what we have seen in the authorization code but
this time we have to specify <code>response_type</code> as <code>token</code>:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://auth.example.com/authorize?response_type=</span><span data-highlighted-chars="">token</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>client_id=</span><span>Iv23lilfdg920cAzhcxA</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>scope=</span><span>read_user%20write_repo%20read_repo</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://auth.example.com/authorize?response_type=</span><span data-highlighted-chars="">token</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>client_id=</span><span>Iv23lilfdg920cAzhcxA</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>redirect_uri=</span><span>https://www.clientapp.com/callback/</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>scope=</span><span>read_user%20write_repo%20read_repo</span></span>
<span data-line=""><span>    </span><span>&amp;</span><span>state=</span><span>wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre></div>
<p>In JS applications, there are a few ways you can do this request:</p>
<ul>
<li>Do a full-page redirect to the Authorization Server</li>
<li>Open a separate popup window and do the redirect there and then close it when the callback URL is hit.</li>
</ul>

<p>If you specify the authorization <code>state</code> parameter, the best place to temporarily persist it will be <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener noreferrer">window.sessionStorage</a>.</p>
<p>Once the Resource Owner approves the delegation, the Authorization Server redirects them back to the client callback URL which would look like this:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://www.clientapp.com/callback/#access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&amp;state=wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>HTTP/1.1 302 Found</span></span>
<span data-line=""><span>Location</span><span>:</span><span> </span><span>https://www.clientapp.com/callback/#access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&amp;state=wSDOBWf0PAC9C7AENIRoCfHnDDSbr</span></span></code></pre></div>
<p>The <code>access_token</code> is returned right away in the callback URL along with other parameters. This is a simple GET request,
so the sensitive access token is a part of the URL and can be potentially intercepted by other browser extensions, malicious scripts injected via XSS attacks, etc.
Additionally, the whole callback URL is cached in the browser history along with the access token.
That’s the main reason why the implicit flow is considered insecure.</p>
<p>All parameters are returned as URL fragments which means they are intended to be used by browser client applications only (e.g. not shared with any backend servers).</p>
<p>Since in-browser applications cannot keep secrets, the returned access token is super short-lived (like 1-2 hours).
For the same reason, OAuth2 requires no refresh tokens in the implicit flow.</p>
<p>Finally, the Client Application can use the retrieved access token to access the Resource Server in the same way we have seen in the authorization code flow.
There is one specific though. The Resource Server should be ready to accept these in-browser application requests
by having CORS policies configured.</p>
<p>Looking back, there are basically two pieces of information that help to identify validity of the client in the implicit flow:</p>
<ul>
<li>Client ID</li>
<li>Redirect URL</li>
</ul>
<p>There is no client secret or any other sensitive information to put into the public client application.</p>

<h3 id="client-credentials-1">Client Credentials<a aria-hidden="true" tabindex="-1" href="#client-credentials-1"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>Let’s continue our what-if thought process. What if there is no resource owner and the Client Application wants to act on its own behalf?</p>
<p>This is a common situation when you have a dozen of internal services that have to communicate with each other and you want to secure that communication somehow
to create a zero-trust environment.</p>
<p>In this case, there is no Resource Owner involved, so there is no need for the whole frontend channel to be involved.
All we need is to make the Authorization Server accept the client credentials as a valid reason to issue the access tokens.
Therefore, this flow is called the client credentials flow.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-client-credentials-flow.png" alt="OAuth2 Client Credentials Flow" title="OAuth2 Client Credentials Flow" loading="lazy"/>
</p><p>OAuth2 Client Credentials Flow</p>
<p>The client credentials flow is a non-interactive flow that enables confidential trusted Client Applications
to access the Resource Server (or other internal Client Application).
So the only request we need here is to the token endpoint:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=client_credentials&amp;scope=read_user%20write_repo%20read_repo</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=client_credentials&amp;scope=read_user%20write_repo%20read_repo</span></span></code></pre></div>
<ul>
<li>The <code>grant_type</code> is set to <code>client_credentials</code> to indicate that validity of the client credentials is the reason to give us an access token.</li>
<li>The <code>scopes</code> are optional but recommended to achieve the least privileged access.</li>
</ul>
<p>That’s it. The response is the same as in other flows.
There is no big reason to issue refresh tokens here, because the client credentials act as one, so it’s generally omitted.</p>
<p>Another thing is the access scope. Since the Client Application acts on its own behalf,
it may not be limited to the resources available to a specific Resource Owner.
There has to be a way for the Resource Server to differentiate this level of access versus regular resource owner delegation.
I have seen two ways of doing this:</p>
<ul>
<li>use a separate set of scopes to mark such an internal, wide access</li>
<li>add a custom claim to the JWT access token and account for it during access token validation</li>
</ul>
<h3 id="resource-owner-credentials">Resource Owner Credentials<a aria-hidden="true" tabindex="-1" href="#resource-owner-credentials"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>The most paradoxical flow out of all OAuth2 standard flows is the resource owner credentials (ROC) flow.
It’s paradoxical because it was discouraged from use since day one of the OAuth2 protocol, everyone says it’s a very bad idea to use it, yet still it made it into the specification.
Why did that happen?</p>
<p>Theoretically, there might be situations where you absolutely have to use your username and password all around to access some resources.
Without the ROC flow, you would be even less secure than if you used it.
This is because the flow limits the credential exposure over the network which reduces the chance of credential leakage. Also, it allows you to limit the access scope (rather than giving the client absolutely all access you have).</p>
<p>In this flow, the Resource Owner passes their credentials (e.g. username and password) directly to the Client Application.
Then the application uses the credentials as an authorization grant to issue a pair of access and refresh tokens.
The resource credentials are then discarded and the client uses the tokens solely to access the protected resources going forward.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-resource-owner-credentials-flow.png" alt="OAuth2 Resource Owner Credentials Flow" title="OAuth2 Resource Owner Credentials Flow" loading="lazy"/>
</p><p>OAuth2 Resource Owner Credentials Flow</p>
<p>This is a backend channel only flow, so the Client Application exclusively communicates with the token endpoint of the
Authorization Server:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=password&amp;username=dwight.shrut&amp;password=bearbeetsbattlestargalactica&amp;scope=org_admin</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Authorization</span><span>:</span><span> </span><span>Basic {{ base64(client_id:client_secret) }}</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=password&amp;username=dwight.shrut&amp;password=bearbeetsbattlestargalactica&amp;scope=org_admin</span></span></code></pre></div>
<ul>
<li>The <code>grant_type</code> has to be <code>password</code> to indicate the ROC flow</li>
<li>The credentials e.g. username and password are passed as a part of the token request</li>
<li>it’s possible to pass the <code>scope</code> param to reduce the delegated access level. Otherwise, it would be the full access that the Resource Owner has (whatever that means for the given Resource Server).</li>
</ul>
<p>In which cases this flow could make some sense?</p>
<ul>
<li>You should have a high degree of trust to share your main credentials with the Client Application. Ideally, it should be something you control (e.g. the first-party client).</li>
<li>Your Client Application is highly privileged. For example, it does some actions on behalf of your tenant or organization admins. This is <a href="https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth-ropc" target="_blank" rel="noopener noreferrer">how Microsoft Entra supports it</a>. At the same time, personal accounts could not use this flow (e.g. partially because there are other protections in order to login like MFA).</li>
</ul>

<h3 id="device-code">Device Code<a aria-hidden="true" tabindex="-1" href="#device-code"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>Apparently, the primary target of the original OAuth2 specification was the browser application use case,
but after OAuth2 gained popularity, it has found its way into other contexts. For example, not every environment has an ability to open a browser and do the redirect-based flows
like authorization code. A few examples:</p>
<ul>
<li>When you have got a new TV and you want to watch Netflix on it, you need to authorize that device to access your account and subscription.</li>
<li>When you want to analyze your Snowflake data in a cloud-hosted, containerized Jupyter notebook, there might be no easy way to open a browser (it’s a headless linux under the hood).</li>
<li>When you try to connect to your game portal from a console that may have a browser, but only limited input capabilities (e.g. no full-fledged keyboard)</li>
</ul>
<p>Thankfully, there is an extension to the original OAuth2 specification that codifies so-called the device authorization flow.</p>
<p>The device authorization (or device code) flow is a special kind of interactive flow that doesn’t assume any direct interactions between the Client Application residing on the device
and the Resource Owner’s browser.</p>
<p>Instead, the Client Application instructs how the resource owner can authorize it via browser indirectly by showing the verification URL to visit, QR code to scan or just a call to open the provider’s mobile application.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-device-code-flow.png" alt="OAuth2 Device Code Flow" title="OAuth2 Device Code Flow" loading="lazy"/>
</p><p>OAuth2 Device Code Flow</p>
<h4 id="device-authorization-request">Device Authorization Request<a aria-hidden="true" tabindex="-1" href="#device-authorization-request"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>In order to implement the device authorization flow, they introduced a new endpoint for kicking off the flow called the device authorization endpoint (because it has a completely different semantic than the standard, browser-based <code>authorize</code> endpoint):</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /device_authorization </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>client_id=Iv23lilfdg920cAzhcxA&amp;scope=read_user%20write_repo%20read_repo</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /device_authorization </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>client_id=Iv23lilfdg920cAzhcxA&amp;scope=read_user%20write_repo%20read_repo</span></span></code></pre></div>
<ul>
<li>The <code>client_id</code> is required to identify the Client Application.</li>
<li>There is no client secret because the device client is close to the public clients in terms of the ability to keep secrets e.g. any built-in secrets can be extracted.</li>
</ul>
<p>The device authorization endpoint returns something like this:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="json" data-theme="dark"><code data-language="json" data-theme="dark"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>device_code</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>GmRhmhcxhwAzkoEqiMEgDnyEysNkuNhszIySk9eS</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>user_code</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>WDJB-MJHT</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>verification_uri</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>https://auth.example.com/login/device</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>expires_in</span><span>&#34;</span><span>:</span><span> </span><span>1800</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>interval</span><span>&#34;</span><span>:</span><span> </span><span>5</span></span>
<span data-line=""><span>}</span></span></code></pre><pre data-language="json" data-theme="light"><code data-language="json" data-theme="light"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;device_code&#34;</span><span>: </span><span>&#34;GmRhmhcxhwAzkoEqiMEgDnyEysNkuNhszIySk9eS&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;user_code&#34;</span><span>: </span><span>&#34;WDJB-MJHT&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;verification_uri&#34;</span><span>: </span><span>&#34;https://auth.example.com/login/device&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;expires_in&#34;</span><span>: </span><span>1800</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;interval&#34;</span><span>: </span><span>5</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<ul>
<li>The <code>verification_uri</code> is where the end user should go to type in the <code>user_code</code>. The URL should be short enough to type in manually. Alternatively, the Authorization Server may give another URL to transform into a QR code, for example. That URL generally contains the user code as a query param.</li>
<li>The <code>device_code</code> is what the device client application keeps secretly in memory and then uses as a grant during polling the token endpoint.</li>
</ul>
<p>The device code serves as a proof of starting the authorization flow. If there was no device code and the device client had only client ID as the client identifier,
attackers may figure out that ID and then try to send the token requests to get the access &amp; refresh tokens before the real device that has requested it.</p>
<p>The resource owner has to trigger (or retrigger if the previous request has timed out) the authorization flow, but at the same time,
we pass no information about that user during initializing the authorization request. The authorization server can only match the resource owner with the corresponding client ID after typing in the user code on the verification page.
To be fair, we pass no Resource Owner identifier directly in other interactive flows, too,
but the authorization redirect leverages browser cookies there, so the Authorization Server can identify the end user right off the bat.</p>

<p>Then, the user code is shown somehow to the Resource Owner.
Generally, it’s just printed on the device screen, so the user can type it from there.</p>
<h4 id="access-token-polling">Access Token Polling<a aria-hidden="true" tabindex="-1" href="#access-token-polling"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h4>
<p>The device authorization is a time-bound process (the lifetime is specified as <code>expires_in</code> field in the response).
The authorization lifetime is typically around 15 minutes.</p>
<p>Because there is no way for the Authorization Server to tell the device client when the authorization is granted (that role is played by the callback URL in the other interactive flows)
and it’s a big assumption that the device can accept inbound requests, the protocol only assumes that the device is connected to the internet and can do outbound requests.</p>
<p>With these assumptions, the device can poll the token endpoint every so often until the authorization is granted, the authorization request is expired or denied.
The default polling interval is 5 seconds.</p>
<p>The polling happens against the token endpoint:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=urn:ietf:params:oauth:grant-type:device_code&amp;device_code=GmRhmhcxhwAzkoEqiMEgDnyEysNkuNhszIySk9eS&amp;client_id=Iv23lilfdg920cAzhcxA</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=urn:ietf:params:oauth:grant-type:device_code&amp;device_code=GmRhmhcxhwAzkoEqiMEgDnyEysNkuNhszIySk9eS&amp;client_id=Iv23lilfdg920cAzhcxA</span></span></code></pre></div>
<ul>
<li>The <code>grant_type</code> usually has to indicate what flow we are trying to complete. In this case, the flow code is unusual which means that the flow name is <a href="#more-grants">not standard (or custom)</a>.</li>
<li>The <code>device_code</code> is also sent to verify the device that is trying to obtain tokens.</li>
</ul>
<p>The specification doesn’t require client authentication when accessing the token endpoint, but it’s possible and some providers
use that (e.g. <a href="https://developers.google.com/identity/protocols/oauth2/limited-input-device" target="_blank" rel="noopener noreferrer">Google’s Device Authorization flow implementation</a>).
In that case, it’s still true that you cannot persist the client secret on the end device
and should probably have a backend service somewhere to poll the token endpoint for the device.</p>
<p>It’s very likely that the device client would need to poll the token endpoint a couple of times before the end user actually authorizes it.
In this case, the token endpoint should return a special error indicating that the authorization is not yet granted:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="json" data-theme="dark"><code data-language="json" data-theme="dark"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>error</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>authorization_pending</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>error_description</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>The authorization request is still pending as the end user hasn&#39;t yet authorized the device.</span><span>&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre><pre data-language="json" data-theme="light"><code data-language="json" data-theme="light"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;error&#34;</span><span>: </span><span>&#34;authorization_pending&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;error_description&#34;</span><span>: </span><span>&#34;The authorization request is still pending as the end user hasn&#39;t yet authorized the device.&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>If the client polls it too eagerly, another special error is returned that says to expand the polling interval by 5 seconds:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="json" data-theme="dark"><code data-language="json" data-theme="dark"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>error</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>slow_down</span><span>&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;</span><span>error_description</span><span>&#34;</span><span>:</span><span> </span><span>&#34;</span><span>The client should wait before polling the token endpoint again.</span><span>&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre><pre data-language="json" data-theme="light"><code data-language="json" data-theme="light"><span data-line=""><span>{</span></span>
<span data-line=""><span>  </span><span>&#34;error&#34;</span><span>: </span><span>&#34;slow_down&#34;</span><span>,</span></span>
<span data-line=""><span>  </span><span>&#34;error_description&#34;</span><span>: </span><span>&#34;The client should wait before polling the token endpoint again.&#34;</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>When the authorization is finally granted, the token endpoint should return the regular token response we have seen in <a href="#code-exchange">the authorization code flow</a>.</p>
<h3 id="more-grants">More Grants<a aria-hidden="true" tabindex="-1" href="#more-grants"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>What else can we trade for access &amp; refresh tokens? The OAuth2 specification defines a way to extend the standard grant types
with a custom one. This is called an extension or third-party assertion grant.</p>
<p>The assertion grant is a backend channel only flow where the Client Application sends the Authorization Server
a special third-party assertion that proves the client’s rights to access the protected Resource Server.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-assertion-flow.png" alt="OAuth2 Assertion Flow" title="OAuth2 Assertion Flow" loading="lazy"/>
</p><p>OAuth2 Assertion Flow</p>
<p>As with any other backend channel only flow, this one only uses the token endpoint:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="http" data-theme="dark"><code data-language="http" data-theme="dark"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=urn:roma-glushko:oauth:jwt&amp;assertion=eyJhbGci[..omitted for brevity..]I6IkpXVCJ9.eyJzdWIiOi[..omitted for brevity..]MDIyfQ.SflK[..omitted for brevity..]adQssw5c</span></span></code></pre><pre data-language="http" data-theme="light"><code data-language="http" data-theme="light"><span data-line=""><span>POST</span><span> /token </span><span>HTTP</span><span>/</span><span>1.1</span></span>
<span data-line=""><span>Host</span><span>:</span><span> </span><span>auth.example.com</span></span>
<span data-line=""><span>Accept</span><span>:</span><span> </span><span>application/json</span></span>
<span data-line=""><span>Content-Type</span><span>:</span><span> </span><span>application/x-www-form-urlencoded</span></span>
<span data-line=""> </span>
<span data-line=""><span>grant_type=urn:roma-glushko:oauth:jwt&amp;assertion=eyJhbGci[..omitted for brevity..]I6IkpXVCJ9.eyJzdWIiOi[..omitted for brevity..]MDIyfQ.SflK[..omitted for brevity..]adQssw5c</span></span></code></pre></div>
<p>The grant type in this case is a unique string in a form of URN that includes the organization name and other grant type information. For example:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="plain" data-theme="dark"><code data-language="plain" data-theme="dark"><span data-line=""><span>urn:organization:oauth:grant-type:custom-name</span></span></code></pre><pre data-language="plain" data-theme="light"><code data-language="plain" data-theme="light"><span data-line=""><span>urn:organization:oauth:grant-type:custom-name</span></span></code></pre></div>
<p>It’s only important that the target Authorization Server recognizes it and knows how to validate it.</p>
<p>The assertion is usually a self-contained secure token that is cryptographically signed by the assertion provider.
Practically, there are two types of assertions you can see in the wild:</p>
<ul>
<li>JWT assertions (e.g. defined as <a href="https://www.rfc-editor.org/rfc/rfc7523" target="_blank" rel="noopener noreferrer">urn:ietf:params:oauth:grant-type:jwt-bearer</a>)</li>
<li>SAML assertions (e.g. defined as <a href="https://www.rfc-editor.org/rfc/rfc7522" target="_blank" rel="noopener noreferrer">urn:ietf:params:oauth:grant-type:saml2-bearer</a>)</li>
<li>custom assertions like <a href="https://developer.atlassian.com/cloud/bitbucket/oauth-2/" target="_blank" rel="noopener noreferrer">urn:bitbucket:oauth2:jwt</a> that are likely to be JWT-based too.</li>
</ul>
<p>The client authentication may be optional in this case (if so, the refresh token may not be issued as that grant requires client authentication).</p>
<h3 id="which-flow-to-choose">Which Flow to Choose?<a aria-hidden="true" tabindex="-1" href="#which-flow-to-choose"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h3>
<p>After we have reviewed all main OAuth2 flows, which one should you choose for your specific application?</p>
<p>I have tried to come up with the following decision tree that asks the main questions to help you.</p>
<p><img src="https://jamiepalatnik.com/blog/whats-oauth2-anyway/oauth2-what-flow-to-choose.png" alt="What Flow Should I use?" title="What Flow Should I use?" loading="lazy"/>
</p><p>What Flow Should I use?</p>
<ul>
<li>Always try to use the authorization code flow with PKCE if possible, no matter if it’s a public or confidential client application. This may not be possible because your provider may not support it yet.</li>
<li>If PKCE is not supported, then the authorization code is only good for private clients unless the dynamic client registration is supported. For public clients, you should go with the implicit flow and dive into the number of recommendations and considerations to implement as securely as possible.</li>
<li>If your client application cannot open a browser with the resource owner session or is limited in terms of input capabilities, and your users don’t really trust it, then go with the device code flow.</li>
<li>Before falling back to the resource owner credentials flow, try to see if API keys can help you achieve the same goal.</li>
</ul>
<h2 id="conclusions">Conclusions<a aria-hidden="true" tabindex="-1" href="#conclusions"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<p>Thinking about why OAuth2 protocol has been designed the way it is, turned out to be a great exercise
in threat modeling with immediate, straightforward and practical approaches to mitigate these threats.
They can be reused to solve similar security concerns in other contexts outside of OAuth protocol,
so you can benefit from a deep understanding of the protocol even if you are not a security expert who has to know the ins and outs of OAuth2.</p>
<p>Apart from that, OAuth2 is such a vast area that we have been able to only answer the fundamental why questions and
review the most popular delegation grants in this article.</p>
<p>A lot of interesting OAuth2 extensions are just briefly referenced, but you would not see them that often in the wild yet,
so that was acceptable to leave them out for now.</p>
<p>If you would like to see follow-up articles on OAuth2 protocol and its extensions, please let me know.</p>
<h2 id="references">References<a aria-hidden="true" tabindex="-1" href="#references"><span></span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6749" target="_blank" rel="noopener noreferrer">[RFC-6749] The OAuth 2.0 Authorization Framework</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6750" target="_blank" rel="noopener noreferrer">[RFC-6750] The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7523" target="_blank" rel="noopener noreferrer">[RFC-7523] JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7662.html" target="_blank" rel="noopener noreferrer">[RFC-7662] OAuth 2.0 Token Introspection</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc7636" target="_blank" rel="noopener noreferrer">[RFC-7663] Proof Key for Code Exchange by OAuth Public Clients</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8252" target="_blank" rel="noopener noreferrer">[RFC-8252] OAuth 2.0 for Native Apps</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8628" target="_blank" rel="noopener noreferrer">[RFC-8628] OAuth 2.0 Device Authorization Grant</a></li>
<li><a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps" target="_blank" rel="noopener noreferrer">[GitHub] OAuth Authorization</a></li>
<li><a href="https://docs.gitlab.com/ee/api/oauth2.html" target="_blank" rel="noopener noreferrer">[GitLab] OAuth 2.0 identity provider API</a></li>
<li><a href="https://confluence.atlassian.com/bitbucketserver/bitbucket-oauth-2-0-provider-api-1108483661.html" target="_blank" rel="noopener noreferrer">[Bitbucket] OAuth 2.0 Enterprise Provider API</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12" target="_blank" rel="noopener noreferrer">[OAuth.net] OAuth 2.1 Draft</a></li>
<li><a href="https://www.manning.com/books/oauth-2-in-action" target="_blank" rel="noopener noreferrer">[Manning] OAuth 2.0 in Action</a></li>
<li><a href="https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-implicit-grant-flow" target="_blank" rel="noopener noreferrer">[Microsoft] Identity platform and OAuth 2.0 implicit grant flow</a></li>
</ul></div></div>
  </body>
</html>
