<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://snarky.ca/why-you-should-use-python-m-pip/">Original</a>
    <h1>Use `Python -m Pip`</h1>
    
    <div id="readability-page-1" class="page"><div>
                    <p>Fellow core developer and Canadian, <a href="https://twitter.com/mariatta">Mariatta</a>, asked on Twitter about <code>python -m pip</code> and who told her about that idiom along with asking for a reference explaining it:</p><figure><blockquote><p lang="en" dir="ltr">I learned sometime ago that we should be doing</p>â€” Mariatta ðŸ¤¦ (@mariatta) <a href="https://twitter.com/mariatta/status/1189243515739561985?ref_src=twsrc%5Etfw">October 29, 2019</a></blockquote>

</figure><p>Now I&#39;m not sure if it was specifically me that told Mariatta about <code>python -m pip</code>, but the chances are reasonable that it was me as I have been asking for it to <a href="https://github.com/pypa/warehouse/issues/1563">become the instructions provided on PyPI on how to install a package</a> since 2016. So this blog post is meant to explain what <code>python -m pip</code> is and why you should be using it when you run <code>pip</code>.</p><p>To begin with, <code>python -m pip</code> executes <code>pip</code> using the Python interpreter you specified as <code>python</code>. So <code>/usr/bin/python3.7 -m pip</code> means you are executing <code>pip</code> for your interpreter located at <code>/usr/bin/python3.7</code>. You can read the <a href="https://docs.python.org/3/using/cmdline.html#cmdoption-m">docs on <code>-m</code></a> if you&#39;re unfamiliar with the flag and how it works (it&#39;s very handy).</p><p>So you might be saying, &#34;OK, but can&#39;t I just run pip by executing the <code>pip</code> command?&#34; And the answer is &#34;yes, but with a lot less control&#34;, and I will explain what I mean by &#34;less control&#34; with an example.</p><p>Let&#39;s say I have two versions of Python installed, like Python 3.7 and 3.8 (and this is very common for people thanks to Python coming installed on macOS and Linux, let alone you may have installed Python 3.8 to play with it while having previously installed Python 3.7). Now, if you were to type <code>pip</code> in your terminal, which Python interpreter would it install for?</p><p>Without more details the answer is you don&#39;t know. First you would have to know what my <code>PATH</code> is set to, e.g. is <code>/usr/bin</code> before or after <code>/usr/local/bin</code> (which are common locations for Python to be installed into, and typically <code>/usr/local/</code> comes first). OK, so as long as you remember where you installed Python 3.7 and 3.8 and that it was different directories you will know which version of <code>pip</code> comes first on <code>PATH</code>. But let&#39;s say you installed both manually; maybe your OS came with Python 3.7.3 and you installed Python 3.7.5. In that case both versions of Â Python are installed in <code>/usr/local/bin</code>. Can you now tell me what interpreter <code>pip</code> is tied to?</p><p>The answer is you still don&#39;t know. Unless you know when you installed each version and thus what the <em>last</em> copy of pip was written to <code>/usr/local/bin/pip</code> you don&#39;t know what interpreter pip will be using for the <code>pip</code> command. Now you may be saying, &#34;I always install the latest versions, so that would mean Python 3.8.0 was installed last since it&#39;s newer than 3.7.5&#34;. OK, but what happens when Python 3.7.6 comes out? Your <code>pip</code> command would have gone from using Python 3.8 to Python 3.7.</p><p>But when you use <code>python -m pip</code> with <code>python</code> being the specific interpreter you want to use, all of the above ambiguity is gone. If I say <code>python3.8 -m pip</code> then I know pip will be using and installing for my Python 3.8 interpreter (same goes for if I had said <code>python3.7</code>).</p><p>And if you&#39;re on Windows there is an added benefit to using <code>python -m pip</code> as it lets pip update itself. Basically because <code>pip.exe</code> is considered running when you do <code>pip install --upgrade pip</code>, Windows won&#39;t let you overwrite <code>pip.exe</code>. But if you do <code>python -m pip install --upgrade pip</code> you avoid that issue as it&#39;s <code>python.exe</code> that&#39;s running, not <code>pip.exe</code>.</p><h2 id="what-about-when-i-am-in-an-activated-environment">What about when I am in an activated environment?</h2><p>Usually when I explain this to a group of people inevitably someone will say &#34;I always use a virtual environment and so this doesn&#39;t apply to me&#34;. So first, great job on always using an environment (I will argue why this is a best practice later on this blog post)! But I would honestly still argue for using <code>python -m pip</code> even when it strictly isn&#39;t necessary.</p><p>First, if you&#39;re on Windows you will want to still use <code>python -m pip</code> just so you can update pip in your environment.</p><p>Second, even if you&#39;re on another OS I would say you should use <code>python -m pip</code> as it works regardless of the situation. Not only does it prevent you from making a mistake if you happen to forget to active your environment, but it also means anyone watching you will learn the best practice as well. And personally I don&#39;t think saving 10 keystrokes for a command you are probably not executing constantly warrants taking a shortcut from a universal best practice. It also prevents you from accidentally scripting some automation that will do the wrong thing if you forget to activate your environment.</p><p>Personally, any tool that I use whose execution relies on which interpreter it is run with I always use <code>-m</code>, activated environment or not, in order to be very purposefully and explicit in what Python interpreter I want to be used/affected.</p><p>While we&#39;re on the subject of how to avoid messing up your Python installation, I want to make the point that you should <strong>never</strong> install stuff into your global Python interpreter when you develop locally (containers are a different matter)! If it&#39;s your system install of Python then you may actually break your system if you install an incompatible version of a library that your OS relies on.</p><p>But even if you install your own copy of Python I still strongly advise against installing directly into it when developing locally. You will end up mixing various packages between your projects which could clash with each other, you won&#39;t have a clear idea of what each of your projects truly depends on, etc. It is much better to use environments to isolate your individual projects and tools from each other. And in the Python community there are two types of environments: virtual environments and conda environments. There&#39;s even a way to install Python tools in an isolated fashion.</p><p>For installing a tool in isolation, I would Â use <a href="https://pipxproject.github.io/pipx/">pipx</a>. Each tool will get their own virtual environment so they won&#39;t clash with each other. That way if you want to have a single installation of e.g. <a href="https://black.readthedocs.io/">Black</a> you can do so without accidentally breaking your single installation of <a href="http://mypy-lang.org/">mypy</a>.</p><h2 id="if-you-need-an-environment-for-your-project-and-you-don-t-use-conda-">If you need an environment for your project (and you don&#39;t use conda)</h2><p>When you need to create an environment for a project I personally always reach for <a href="https://docs.python.org/3/library/venv.html#module-venv">venv</a> and virtual environments. It&#39;s included in Python&#39;s stdlib so it&#39;s always available via <code>python -m venv</code> (as long as you are not on Debian/Ubuntu, otherwise you may have to install the <code>python3-venv</code> apt package). A bit of history: I actually removed the old <code>pyvenv</code> command that Python used to install for creating virtual environments with venv for the exact reasons why you should use <code>python -m pip</code> over <code>pip</code>; from the command alone you can&#39;t know which interpreter you were creating a virtual environment for via the old <code>pyvenv</code> command. And remember you don&#39;t <em>have</em> to activate the environment to use the interpreter contained within it; <code>.venv/bin/python</code> works just as well as activating the environment and typing <code>python</code>.</p><p>Now some people still prefer <a href="https://virtualenv.pypa.io">virtualenv</a> as it&#39;s available on Python 2 and has some other extra features. Personally, I don&#39;t need the extra features and having venv integrated means I don&#39;t have to use pipx to install virtualenv on every machine. But if venv doesn&#39;t meet your needs and you want a virtual environment then see if virtualenv does what you need.</p><h2 id="if-you-are-a-conda-user">If you are a conda user</h2><p>If you are a <a href="https://conda.io">conda</a> user, then you can use <a href="https://conda.io/projects/conda/en/latest/user-guide/concepts/environments.html">conda environments</a> for the same effect as virtual environments as provided by venv. I&#39;m not going to go into whether you should use conda for your situation over venv, but if you find yourself using conda then do know you can (and should) create conda environments for your work instead of installing everything into your base environment and having a clear understanding of what your project depends on (and this is also a good reason to use <a href="https://conda.io/en/latest/miniconda.html">miniconda</a> over anaconda as the former is less than a tenth of the install size of the latter).</p><h2 id="there-s-always-containers">There&#39;s always containers</h2><p>Working in a container is another option as you can skip environments at that point since the whole &#34;machine&#34; is the environment. As long as you are not installing into the system Python of the container you should be free to do a global install to keep your container simple and straight-forward.</p><p><strong>DO NOT install into your global Python interpreter! ALWAYS try to use an environment when developing locally!</strong></p><p>I cannot count the number of times I had to help someone who thought <code>pip</code> was installing into one Python interpreter and in fact it was the other. And that immeasurable count also applies to when people have broken their system or wondered why they couldn&#39;t install something that conflicted with some other thing they installed previously for some other project, etc. due to not bothering to set up an environment on their local machine.</p><p>So for your sanity and mine, use <code>python -m pip</code> and always try to use an environment.</p>
                </div></div>
  </body>
</html>
