<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ochagavia.nl/blog/crafting-container-images-without-dockerfiles/">Original</a>
    <h1>Crafting container images without Dockerfiles</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Last month I have been developing a Rust tool to create container images from <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/concepts/environments.html">Conda
environments</a>,
without going through Docker. It was a wild trip down the rabbit hole of OCI images, so I thought
I’d share part of the adventure here. Enjoy!</p>
<h2 id="but-why">But why?</h2>
<p>If you are used to building container images, you might be asking yourself why on earth someone
would want to deviate from the well-trodden path of Dockerfiles. In fact, I was asking myself that
question when I first talked to my client, the nice folks at <a href="https://prefix.dev">prefix.dev</a>. They
are building tools for fast software package management and a package registry in the
<a href="http://github.com/mamba-org/mamba">mamba</a> and <a href="https://github.com/conda-forge">conda-forge</a>
ecosystem, so I expected they would have some advanced use case that required a creative solution
(spoiler: they did).</p>
<p>Assuming your use case is <a href="https://boringtechnology.club/">compelling enough</a> to deal with the
complexity of a custom solution, here are some benefits to crafting container images without
Dockerfiles:</p>
<ol>
<li>You can create the image’s layers in parallel, whereas a Dockerfile creates them sequentially.</li>
<li>You can use your own caching rules, treating each layer as a fully independent build artifact,
whereas a Dockerfile assumes that layers depend on previous layers (and rebuilds them when
previous layers have changed).</li>
<li>You can do all processing in memory, without ever touching the file system, and without resorting
to an external process.</li>
</ol>
<p>There are probably more factors to mention, but the ones above make clear that there are interesting
performance benefits to be reaped. For a package registry, it means being able to generate a
ready-to-use image in a few seconds, containing all specific packages a particular user needs.</p>
<h2 id="where-to-start">Where to start?</h2>
<p>Fly.io has a very interesting blog post titled <a href="https://fly.io/blog/docker-without-docker/">Docker Without
Docker</a>. In the first sentence, they say: <em>Even though
most of our users deliver software to us as Docker containers, we don’t use Docker to run them</em>. And
they go on to describe how they transform the images they receive into something that can run on a
<a href="https://firecracker-microvm.github.io/">Firecracker microVM</a>. If they can decompose and manipulate
existing images, why shouldn’t I be able to compose them from scratch?</p>
<p>Docker has been around <a href="https://en.wikipedia.org/wiki/Docker_(software)">for almost 10 years now</a>,
since its initial release in March 2013, and in the meantime a bunch of standards have emerged to
specify what a container image is, how a registry should behave, and more. This effort has been
driven by the <a href="https://opencontainers.org/">Open Container Initiative</a> (OCI for short) and is one of
the reasons why you can <code>docker pull</code> and <code>docker push</code> to any compliant artifact registry, instead
of only the one at <a href="https://docker.io">docker.io</a>.</p>
<p>When I started working on this project I knew Docker from the perspective of a casual user, but had
never ventured to create images without a Dockerfile. From Fly.io’s blog I knew that container
images are <em>“just a stack of tarballs”</em>, so that provided a bunch of goals to aim for:</p>
<ol>
<li>Inspect an existing container image, look at the different tarballs that compose it, get a
feeling for how it is all tied together.</li>
<li>Based on that knowledge, write the necessary code to generate a compliant image as a tar file.</li>
<li>Figure out later how to push the image to a registry without going through the intermediate step
of wrapping it as a tar file.</li>
</ol>
<p>Let us dive into the first two.</p>
<h2 id="playing-with-oci-images-in-your-file-system">Playing with OCI images in your file system</h2>
<p>My first experiment was exporting an image from Docker, using <code>docker save --output img.tar &lt;tag&gt;</code>.
It provided a few valuable insights, but was quite confusing, because the contents of the tarball
where different from what I expected after reading the <a href="https://github.com/opencontainers/image-spec/blob/main/spec.md">OCI Image
Spec</a>. I quickly discovered that
Docker uses a legacy export format, and has no support for exporting in the OCI archive format
(there is an <a href="https://github.com/moby/moby/issues/25779">issue</a> from 2016, though). Luckily, Podman
can export OCI tarballs using <code>podman save --output img.tar --format=oci-archive &lt;tag&gt;</code>. With that I
was ready to go!</p>
<p>It would be too long to describe here all things I tried out, so for the purposes of this post let
us pick <code>alpine:3.17.1</code> as a lightweight docker image to play with. If you want to follow along, you
can run <code>podman pull alpine:3.17.1</code> and <code>podman save --output alpine.tar --format=oci-archive
 alpine:3.17.1</code> to get an OCI image at <code>alpine.tar</code>. After unpacking it, we find 5 files in it (I
have abreviated the SHA256 hashes):</p>
<ul>
<li>
<p><code>oci-layout</code> - The <a href="https://github.com/opencontainers/image-spec/blob/main/image-layout.md">image
layout</a>, which contains
just version information:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{<span>&#34;imageLayoutVersion&#34;</span>: <span>&#34;1.0.0&#34;</span>}
</span></span></code></pre></div></li>
<li>
<p><code>index.json</code> - The <a href="https://github.com/opencontainers/image-spec/blob/main/image-index.md">image
index</a>, specifying the
image’s reference name and pointing to the image manifest at blob <code>e04ef1925f7c...</code>:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;schemaVersion&#34;</span>: <span>2</span>,
</span></span><span><span>  <span>&#34;manifests&#34;</span>: [
</span></span><span><span>      {
</span></span><span><span>          <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span><span>          <span>&#34;digest&#34;</span>: <span>&#34;sha256:e04ef1925f7cedc3e7ae845580825e06e177733603b9d106f7272831b0e3bdf0&#34;</span>,
</span></span><span><span>          <span>&#34;size&#34;</span>: <span>405</span>,
</span></span><span><span>          <span>&#34;annotations&#34;</span>: {
</span></span><span><span>              <span>&#34;org.opencontainers.image.ref.name&#34;</span>: <span>&#34;docker.io/library/alpine:latest&#34;</span>
</span></span><span><span>          }
</span></span><span><span>      }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div></li>
<li>
<p><code>blobs/sha256/e04ef1925f7c...</code> - The <a href="https://github.com/opencontainers/image-spec/blob/main/manifest.md">image
manifest</a>, pointing to the
image configuration at blob <code>4409d8934467...</code>, and listing the image’s layers as an array of blob
hashes:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;schemaVersion&#34;</span>: <span>2</span>,
</span></span><span><span>  <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span><span>  <span>&#34;config&#34;</span>: {
</span></span><span><span>      <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span><span>      <span>&#34;digest&#34;</span>: <span>&#34;sha256:4409d8934467ec11801a2c1b880489f6fd74d56dd24efaedbe389b918ccd9a44&#34;</span>,
</span></span><span><span>      <span>&#34;size&#34;</span>: <span>585</span>
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;layers&#34;</span>: [
</span></span><span><span>      {
</span></span><span><span>          <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
</span></span><span><span>          <span>&#34;digest&#34;</span>: <span>&#34;sha256:1dad7324dd8c159c64d20e09b1e0cc87710d3e6f818dacfaff9fd99ae730a6b4&#34;</span>,
</span></span><span><span>          <span>&#34;size&#34;</span>: <span>3493000</span>
</span></span><span><span>      }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div></li>
<li>
<p><code>blobs/sha256/4409d8934467...</code> - The <a href="https://github.com/opencontainers/image-spec/blob/main/config.md">image
configuration</a>, specifying
things like the environment variables that are available, the command that should be run upon
startup (in this case <code>/bin/sh</code>), the hashes of the uncompressed tar archive corresponding to each
layer (called <em>diff_ids</em>), and history metadata:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.656498283Z&#34;</span>,
</span></span><span><span>  <span>&#34;architecture&#34;</span>: <span>&#34;amd64&#34;</span>,
</span></span><span><span>  <span>&#34;os&#34;</span>: <span>&#34;linux&#34;</span>,
</span></span><span><span>  <span>&#34;config&#34;</span>: {
</span></span><span><span>      <span>&#34;Env&#34;</span>: [
</span></span><span><span>          <span>&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;</span>
</span></span><span><span>      ],
</span></span><span><span>      <span>&#34;Cmd&#34;</span>: [
</span></span><span><span>          <span>&#34;/bin/sh&#34;</span>
</span></span><span><span>      ]
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;rootfs&#34;</span>: {
</span></span><span><span>      <span>&#34;type&#34;</span>: <span>&#34;layers&#34;</span>,
</span></span><span><span>      <span>&#34;diff_ids&#34;</span>: [
</span></span><span><span>          <span>&#34;sha256:8e012198eea15b2554b07014081c85fec4967a1b9cc4b65bd9a4bce3ae1c0c88&#34;</span>
</span></span><span><span>      ]
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;history&#34;</span>: [
</span></span><span><span>      {
</span></span><span><span>          <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.497231175Z&#34;</span>,
</span></span><span><span>          <span>&#34;created_by&#34;</span>: <span>&#34;/bin/sh -c #(nop) ADD file:e4d600fc4c9c293efe360be7b30ee96579925d1b4634c94332e2ec73f7d8eca1 in / &#34;</span>
</span></span><span><span>      },
</span></span><span><span>      {
</span></span><span><span>          <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.656498283Z&#34;</span>,
</span></span><span><span>          <span>&#34;created_by&#34;</span>: <span>&#34;/bin/sh -c #(nop)  CMD [\&#34;/bin/sh\&#34;]&#34;</span>,
</span></span><span><span>          <span>&#34;empty_layer&#34;</span>: <span>true</span>
</span></span><span><span>      }
</span></span><span><span>  ]
</span></span><span><span>}
</span></span></code></pre></div></li>
<li>
<p><code>blobs/sha256/1dad7324dd8c...</code>: the only layer of the image, in <code>.tar.gzip</code> format. If we extract
it, we find the typical filesystem structure we know from Linux distributions (note: Windows will
complain about problems creating symlinks, because for some reason it <a href="https://security.stackexchange.com/q/10194/61635">requires admin privileges
by default</a>).</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span># Output of `ls .` after extracting and unpacking the tar archive</span>
</span></span><span><span>&gt; ls .
</span></span><span><span>bin
</span></span><span><span>dev
</span></span><span><span>etc
</span></span><span><span>home
</span></span><span><span>lib
</span></span><span><span>media
</span></span><span><span>mnt
</span></span><span><span>opt
</span></span><span><span>proc
</span></span><span><span>root
</span></span><span><span>run
</span></span><span><span>sbin
</span></span><span><span>srv
</span></span><span><span>sys
</span></span><span><span>tmp
</span></span><span><span>usr
</span></span><span><span>var
</span></span></code></pre></div></li>
</ul>
<p>It is also important to note a few things that are not apparent just from the text above:</p>
<ul>
<li>Blobs are named according to the SHA256 of their contents. We can check that ourselves using
<code>Get-FileHash .\blobs\sha256\e04ef1925f7c...</code> on PowerShell (or if you are using a different shell
you can try <code>sha256sum &lt;path/to/file&gt;</code>). This makes blobs content-addressable, so they are trivial
to deduplicate and share.</li>
<li>According to the specification, JSON content should be serialized as <a href="https://wiki.laptop.org/go/Canonical_JSON">Canonical
JSON</a>, which among other things disallows superfluous
whitespace. This ensures that two JSON documents that have the same meaning are also represented
in the exact same way, and have the same hash. The contents of the files pasted above have been
pretty printed so you could read them (instead of seeing an endless horizontal line of JSON
tokens).</li>
</ul>
<h2 id="creating-a-modified-version-of-the-alpine-image">Creating a modified version of the Alpine image</h2>
<p>Let us make a trivial modification to the image, one which you can easily replicate at home without
setting up special tooling. We will modify the startup command from <code>/bin/sh</code> to <code>ls /</code>, which is
not that big of a change, but is enough to check that it works (and a pain to do manually, but at
least proves the point that there is nothing magical going on).</p>
<p>Since the image configuration specifies the command to be used at image startup, we need to go to
the <code>4409d8934467...</code> blob and set the entry under <code>config.Cmd</code> to <code>[&#34;/bin/ls&#34;,&#34;/&#34;]</code>. The result
looks as follows (pretty printed here for convenience):</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>    <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.656498283Z&#34;</span>,
</span></span><span><span>    <span>&#34;architecture&#34;</span>: <span>&#34;amd64&#34;</span>,
</span></span><span><span>    <span>&#34;os&#34;</span>: <span>&#34;linux&#34;</span>,
</span></span><span><span>    <span>&#34;config&#34;</span>: {
</span></span><span><span>        <span>&#34;Env&#34;</span>: [
</span></span><span><span>            <span>&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;</span>
</span></span><span><span>        ],
</span></span><span><span>        <span>&#34;Cmd&#34;</span>: [
</span></span><span><span>            <span>&#34;/bin/ls&#34;</span>,
</span></span><span><span>            <span>&#34;/&#34;</span>
</span></span><span><span>        ]
</span></span><span><span>    },
</span></span><span><span>    <span>&#34;rootfs&#34;</span>: {
</span></span><span><span>        <span>&#34;type&#34;</span>: <span>&#34;layers&#34;</span>,
</span></span><span><span>        <span>&#34;diff_ids&#34;</span>: [
</span></span><span><span>            <span>&#34;sha256:8e012198eea15b2554b07014081c85fec4967a1b9cc4b65bd9a4bce3ae1c0c88&#34;</span>
</span></span><span><span>        ]
</span></span><span><span>    },
</span></span><span><span>    <span>&#34;history&#34;</span>: [
</span></span><span><span>        {
</span></span><span><span>            <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.497231175Z&#34;</span>,
</span></span><span><span>            <span>&#34;created_by&#34;</span>: <span>&#34;/bin/sh -c #(nop) ADD file:e4d600fc4c9c293efe360be7b30ee96579925d1b4634c94332e2ec73f7d8eca1 in / &#34;</span>
</span></span><span><span>        },
</span></span><span><span>        {
</span></span><span><span>            <span>&#34;created&#34;</span>: <span>&#34;2023-01-09T17:05:20.656498283Z&#34;</span>,
</span></span><span><span>            <span>&#34;created_by&#34;</span>: <span>&#34;/bin/sh -c #(nop)  CMD [\&#34;/bin/sh\&#34;]&#34;</span>,
</span></span><span><span>            <span>&#34;empty_layer&#34;</span>: <span>true</span>
</span></span><span><span>        }
</span></span><span><span>    ]
</span></span><span><span>}
</span></span></code></pre></div><p>Note that, after making a change to the blob, its SHA256 hash changes, and is now
<code>dfe435ac7823c29ba7749794fbff255b196266e74a267a0514d0b8ef71feb984</code>. We need to update the name of
the blob in the filesystem, according to the specification.</p>
<p>Remember also that the image manifest (at <code>e04ef1925f7c...</code>), references the image configuration
using the old hash, so we need to update it to use the new one. For that purpose, we set
<code>config.digest</code> to <code>sha256:dfe435ac782...</code> and <code>config.size</code> to <code>589</code> (the file’s length also
changed). The result is shown below (pretty printed):</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>    <span>&#34;schemaVersion&#34;</span>: <span>2</span>,
</span></span><span><span>    <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span><span>    <span>&#34;config&#34;</span>: {
</span></span><span><span>        <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span><span>        <span>&#34;digest&#34;</span>: <span>&#34;sha256:dfe435ac7823c29ba7749794fbff255b196266e74a267a0514d0b8ef71feb984&#34;</span>,
</span></span><span><span>        <span>&#34;size&#34;</span>: <span>589</span>
</span></span><span><span>    },
</span></span><span><span>    <span>&#34;layers&#34;</span>: [
</span></span><span><span>        {
</span></span><span><span>            <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
</span></span><span><span>            <span>&#34;digest&#34;</span>: <span>&#34;sha256:1dad7324dd8c159c64d20e09b1e0cc87710d3e6f818dacfaff9fd99ae730a6b4&#34;</span>,
</span></span><span><span>            <span>&#34;size&#34;</span>: <span>3493000</span>
</span></span><span><span>        }
</span></span><span><span>    ]
</span></span><span><span>}
</span></span></code></pre></div><p>Are we done yet? No, sorry. The image manifest is also a blob, and its hash has changed to
<code>7a7085a0abba577ab26640eda0bfdacbef3fa1267241f82ecd4d7a8446c70469</code>, so we need to rename it. Also,
the image index references the image manifest using the old hash, so we need to update that as well.
Don’t despair, this is the last file we will touch, I promise. The field to set is
<code>manifests[0].digest</code> to <code>sha256:7a7085a0abba...</code>, and the resulting file looks as follows (pretty
printed):</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>    <span>&#34;schemaVersion&#34;</span>: <span>2</span>,
</span></span><span><span>    <span>&#34;manifests&#34;</span>: [
</span></span><span><span>        {
</span></span><span><span>            <span>&#34;mediaType&#34;</span>: <span>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span><span>            <span>&#34;digest&#34;</span>: <span>&#34;sha256:7a7085a0abba577ab26640eda0bfdacbef3fa1267241f82ecd4d7a8446c70469&#34;</span>,
</span></span><span><span>            <span>&#34;size&#34;</span>: <span>405</span>,
</span></span><span><span>            <span>&#34;annotations&#34;</span>: {
</span></span><span><span>                <span>&#34;org.opencontainers.image.ref.name&#34;</span>: <span>&#34;localhost/my-alpine&#34;</span>
</span></span><span><span>            }
</span></span><span><span>        }
</span></span><span><span>    ]
</span></span><span><span>}
</span></span></code></pre></div><p>You might have noticed that I changed the image reference name to <code>localhost/my-alpine</code>. It felt
wrong to keep the original name after our changes and it will make sure the alpine image in your
machine does not get replaced by our hacked up one.</p>
<p>After all this we can repack the whole thing in a tarball, making sure <code>blobs</code>, <code>index.json</code> and
<code>oci-layout</code> end up in its root directory. If you name it <code>my-alpine.tar</code>, you can load it in podman
using <code>podman load -i my-alpine.tar</code>. Do you see the output <code>Loaded image:
 localhost/my-alpine:latest</code>? Then congratulations for getting it right in one go! I messed up at
least once while writing this post, and ended up seeing something like:</p>
<pre tabindex="0"><code>Error: unable to load image: payload does not match any of the supported image formats:
 * oci: initializing source oci:/var/tmp/libpod-images-load.tar2632613858:: open /var/tmp/libpod-images-load.tar2632613858/index.json: not a directory
 * oci-archive: writing blob: blob size mismatch
 * docker-archive: loading tar component manifest.json: file does not exist
 * dir: open /var/tmp/libpod-images-load.tar2632613858/manifest.json: not a directory
</code></pre><p>Now comes the moment of truth! The <code>my-alpine</code> image is loaded into Podman and we are ready to run
it! Here is the output in all its glory, as you would expect from <code>ls /</code>:</p>
<pre tabindex="0"><code>&gt; podman run --rm my-alpine
bin
dev
etc
home
lib
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
</code></pre><h2 id="what-about-adding-layers">What about adding layers?</h2>
<p>You might reasonably say that the change we made is not that interesting, as we only touched the
image configuration. Couldn’t we add a new layer, for instance? Definitely! However, since this is
already getting too long so I will summarize the necessary steps here and leave the experimentation
as an exercise for the reader.</p>
<p>Imagine you want to add a file to your container image at <code>/some-file</code>, containing the string <code>Hello
 world!</code>. You could add that as a layer through the following steps (assuming you already have a
directory containing Alpine’s OCI image):</p>
<ol>
<li>Create <code>some-file</code> anywhere in your system (not inside the OCI image’s directory)</li>
<li>Wrap the file in a tarball, so <code>some-file</code> is visible from the archive’s root directory</li>
<li>Calculate the tarball’s SHA256 hash, append it to the image configuration’s <code>rootfs.diff_ids</code> array,
starting with <code>sha256:</code> as in the previous layer</li>
<li>Compress the tarball using gzip</li>
<li>Calculate the compressed tarball’s SHA256 hash and byte length, add it to the image manifest’s
<code>layers</code> array in a similar way to the previous layer</li>
<li>Change the compressed tarball’s name to its hash and put it inside the OCI image’s <code>blobs/sha256</code>
dir</li>
<li>Recalculate the image configuration’s hash and update its name. Do the same with the image
manifest. Update the image index to reference the image manifest by its new name</li>
<li>Re-pack the OCI image’s root directory as a tar archive and load it into Podman</li>
</ol>
<p>If you already modified the Alpine image to do <code>ls /</code> upon startup, you can easily check the
presence of your new layer by running <code>podman run --rm my-alpine</code>. Does <code>some-file</code> appear among the
files? I hope so!</p>
<p>In case you are using the original Alpine image and don’t want to go through the gruelling process
of modifying the startup command by hand, don’t despair! You can of course create a good old
Dockerfile to do it for you, so you can check if the file you added is indeed at the root of the
container’s filesystem:</p>
<div><pre tabindex="0"><code data-lang="Dockerfile"><span><span><span>FROM</span><span> my-alpine</span><span>
</span></span></span><span><span><span></span><span>CMD</span> [<span>&#34;ls&#34;</span>, <span>&#34;/&#34;</span>]<span>
</span></span></span></code></pre></div><h2 id="automating-it-all">Automating it all</h2>
<p>So far, the most important lesson of this article is that it is a true pain to deal with OCI images
manually (the cascading changes in SHA256 hashes are particularly annoying). The second most
important lesson is that peeking under the hood of container images will not void your warranty, and
is a great way to get a better idea of what an OCI image actually is.</p>
<p>Fortunately, manually dealing with images was only necessary to get comfortable with the concepts,
and after that I automated everything using Rust. In case you want to try it yourself, here are some
crates that come in handy:</p>
<ul>
<li><a href="https://crates.io/crates/tar">tar</a> (reading and writing tar archives)</li>
<li><a href="https://crates.io/crates/flate2">flate2</a> (reading and writing gzip)</li>
<li><a href="https://crates.io/crates/sha2">sha2</a> (creating SHA256 hashes)</li>
<li><a href="https://crates.io/crates/hex">hex</a> (creating hex strings from byte sequences, necessary for
turning the SHA256 hashes into strings)</li>
<li><a href="https://crates.io/crates/oci-spec">oci-spec</a> (parsing and creating OCI image index, manifest and
configuration files)</li>
<li><a href="https://crates.io/crates/ocipkg">ocipkg</a> (does a bunch of things, but the most interesting part
for me is that it reads and writes OCI images from tar files)</li>
<li><a href="https://crates.io/crates/oci-distribution">oci-distribution</a> (interacting with an artifact
registry; may not support all operations you need, in which case you can have a look at the <a href="https://github.com/opencontainers/distribution-spec/blob/main/spec.md">OCI
distribution</a> spec and
write your own client)</li>
</ul>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>There is much more to say, but I doubt at this point there are any readers left. If you are one of
them, and feel like the rabbit hole didn’t go deep enough, here are some additional facts from the
final code I wrote that might peek your interest:</p>
<ul>
<li>Instead of creating images as tar files, we are pushing them directly to an artifact registry. The
API is such that you can upload the layer blobs you want, and upload the image configuration and
manifest later.</li>
<li>When creating derived images, we do not need to access the contents of the base image’s layers,
only their hashes. When pushing to the registry, you can reference layers from other images by
their hash, without having to upload them (using the <em>mount</em> API call mentioned in the spec).</li>
<li>You can pretty easily run a local image registry (e.g. at port 5000) through <code>docker run --rm -p
 5000:5000 registry</code> (see <a href="https://hub.docker.com/_/registry">here</a> for more details)</li>
<li>We encountered nasty bugs, such as <a href="https://github.com/termoshtt/ocipkg/issues/89">this one</a>,
which were puzzling at the moment and interesting to track down. Originally I wanted to devote a
subsection of this article to that bug, as a sort of hunting trophy, but I have omitted it in the
end for the sake brevity.</li>
</ul>
<p>That’s all, folks! And if you have any comments, suggestions, ideas, etc. you want to share, feel
free to contact me (details are in the <a href="https://ochagavia.nl/hire_me/">Hire me</a> page) or to
<a href="https://news.ycombinator.com/item?id=34678121">discuss</a> on HN.</p>

</div></div>
  </body>
</html>
