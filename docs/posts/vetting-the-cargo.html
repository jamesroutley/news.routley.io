<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/897435/3f00904f520a1956/">Original</a>
    <h1>Vetting the Cargo</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
Modern language environments make it easy to discover and incorporate
externally written libraries into a program.  These same mechanisms can
also make it easy to inadvertently incorporate security vulnerabilities or
overtly malicious code, which is rather less gratifying.  The stream of
resulting vulnerabilities seems like it will 
never end, and it afflicts <a href="https://lwn.net/Articles/894808/">relatively safe
languages like Rust</a> just as much as any other language.  In an effort
to avoid the embarrassment that comes with shipping vulnerabilities (or
worse) by way of its dependencies, the Mozilla project has come up with <a href="https://lwn.net/Articles/897437/">a new supply-chain management tool</a> known as
&#34;</p><tt>cargo vet</tt><p>&#34;.
</p><h4>The problem</h4>
<p>
The appeal of modern environments is easy enough to understand.  A
developer working on a function may suddenly discover the need to, say,
<a href="https://lwn.net/Articles/681410/">left-pad a string with blanks</a>.  Rather than
go though the pain of 
implementing this challenging functionality, our developer can simply find
an appropriate module in the language-specific repository, add it to the
project manifest, and use it with no further thought.  This allows our
developer to take advantage of the work done by others and focus on their
core task, which is probably something vital like getting popup windows
past ad blockers.
</p><p>
There is an obvious problem with this approach: our developer knows
nothing about what is inside this newly added module — or in any of the
other modules that this one might quietly pull in as dependencies.  This is
true when the module is first imported, and becomes even more so as those
dependencies are updated, perhaps by somebody other than the original
author.  It is <a href="https://lwn.net/Articles/773121/">a recipe for security
problems</a>.
</p><p>
The Mozilla project has been trying to increase the safety of the Firefox
browser for years in numerous ways; one of those is rewriting much of the
browser in the Rust language — which, itself, has its origins at Mozilla.
At this point, though, much of the code shipped with Firefox originates
outside the project; from the announcement:
</p><blockquote>
	Firefox’s Rust integration makes it very easy for our engineers to
	pull in off-the-shelf code from crates.io rather than writing it
	from scratch. This is a great thing for productivity, but also
	increases our attack surface. Our dependency tree has steadily
	grown to almost four hundred third-party crates, and we have thus
	far lacked a mechanism to efficiently audit this code and ensure
	that we do so systematically.
</blockquote>
<p>
Nearly four-hundred third-party crates does indeed seem like a significant
attack surface.  A bug in any one of them could lead to the shipping of a
vulnerable browser, and the consequence of a crate containing malware could
be quite a bit worse.  It is, indeed, good that the project is thinking
about how to address this threat.
</p><h4>Tracking code audits</h4>
<p>
There are many ways to improve confidence in the security of a chunk of
code.  Writing that code in a memory-safe language is one such way; in a
Rust program without <tt>unsafe</tt> blocks, there are whole classes of
problems that simply cannot exist.  But more than that is required and, in
the end, there is no substitute for simply looking at the code and
understanding what it does.  If a program like Firefox is built only from
code that has been diligently audited, the confidence in its security will
be higher.
</p><p>
The <a href="https://mozilla.github.io/cargo-vet/"><tt>cargo vet</tt></a>
mechanism, built into Rust&#39;s <a href="https://doc.rust-lang.org/cargo/">Cargo</a> dependency manager and
build
system, is meant to help with the task.  It can&#39;t do the tedious and
demanding work of actually auditing code, but it can help to keep track of
which code has been audited and ensure that unaudited code does not find
its way into a production build.
</p><p>
The initial <tt>cargo vet</tt> setup creates a new directory, called
<tt>supply-chain</tt>, in the source directory; this new directory contains
a couple of files called <tt>audits.toml</tt> and <tt>config.toml</tt>.
The setup also looks at all of the project&#39;s dependencies (which are
already tracked by <tt>cargo</tt> in the <tt>Cargo.lock</tt> file) and
marks them all as being unaudited.
</p><p>
A developer can mark a module as being audited (after, presumably, having
actually audited it) by adding a block to <tt>audits.toml</tt> like the
following:
</p><pre>    [[audits.left-pad]]
    version = &#34;1.0&#34;
    who = &#34;Alice TheAuditor &lt;NothingGetsPastMe@example.com&gt;&#34;
    criteria = &#34;safe-to-deploy&#34;
</pre>
<p>
This entry says that version 1.0 (and only that version) of the <tt>left-pad</tt>
crate was audited and deemed to be &#34;safe to deploy&#34; in a production build.
There are two &#34;audit criteria&#34; defined by <tt>cargo vet</tt>, the other
being &#34;<tt>safe-to-run</tt>&#34;; others can be added as need be.  There are
ways of indicating that a range of versions has been audited, or that the
patch from one version to the next has been.  It is also possible to put in a
<tt>violation</tt> line with a version range; that indicates that those
versions have failed the audit and should not be used.  Other examples of
<tt>audits.toml</tt> entries can be found on <a href="https://mozilla.github.io/cargo-vet/recording-audits.html">this
page</a>.
</p><p>
Once these audits are in place, <tt>cargo vet</tt> can be run to ensure
that all code in the build has been audited.  If some dependencies have
been updated, the tool will indicate that they require auditing and cause
the build to fail.  It can also fetch the source for the dependencies in
question from crates.io (rather than, say, the project page on a public
forge site) to ensure that the code being audited is the same as the code
being deployed.
</p><p>
The <tt>cargo vet</tt> tool, in other words, can help a project keep track
of the vetting of its dependencies, and it can help prevent the shipping of
unaudited code to users.  But it doesn&#39;t change the fact that auditing all
of that 
code is a lot of work in the first place.  A lot of that work could perhaps
be saved, though,  if projects could collaborate and share the audits that
they have done. 

</p><h4>Bringing in the community</h4>
<p>
One other key objective driving <tt>cargo vet</tt> is to spread the work of
auditing around the community.  Since a project&#39;s <tt>audits.toml</tt> file
will be a part of its source repository, it will be available to anybody
else who can see that repository; that is the whole world for most
open-source code.  In other words, the results of a project&#39;s auditing work
will normally be available for the rest of the world to see — and make
use of.
After all, if one project has audited a dependency and found
nothing amiss, and if that project&#39;s judgment is to be trusted, then there
is little reason for any other project to repeat that work.
</p><p>
To take advantage of another project&#39;s auditing work,
<tt>cargo vet</tt> can be <a href="https://mozilla.github.io/cargo-vet/importing-audits.html">told to
import its <tt>audits.toml</tt> file</a> and accept the audit results found
therein.  Needless 
to say, a certain degree of trust should exist before delegating one&#39;s
auditing tasks to others on the Internet.  There is currently no mechanism
for discovery of available audits, and no way (in <tt>cargo vet</tt> at
least) to verify that the person listed in the
<tt>audits.toml</tt> file actually claims to have done an audit — anybody
who can write the file can add any text they want.  If the use of this
mechanism takes off, though,
such features can be added in the future.
</p><p>
The overall goal of this work is to take away excuses for not properly
auditing dependencies:
</p><blockquote>
	Each new participant automatically contributes its audits back to
	the commons, making it progressively less work for everyone to
	secure their dependencies. We’ve learned many times that the best
	way to move an ecosystem towards more-secure practices is to take
	something that was hard and make it easy, and that’s what we’re
	doing here.
</blockquote>
<p>
The hope is that, as the amount of audited code increases, the use of
<tt>cargo vet</tt> will grow as well.  The infrastructure may be a good
start but, as the announcement notes, there is a remaining problem that
could be hard to overcome: &#34;<q>there is no way to independently verify that
an audit was performed faithfully and adequately</q>&#34;.  Creating a system
of sharing audits across the community looks like a difficult task in the
absence of some sort of reputation system that lets users decide which
audits they should actually trust.
</p><p>
This project is quite new, though, so it is not surprising that some gaps
remain.  There can be no doubt that <tt>cargo vet</tt> is trying to address
a pressing and urgent problem, so it is good to see this work being done.
If this approach pans out, the use of random modules by unknown authors
from a central software repository might just become a slightly more
rational thing to do.<br clear="all"/></p>
               </div></div>
  </body>
</html>
