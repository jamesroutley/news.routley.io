<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raphlinus.github.io/gpu/2023/06/12/shader-converter.html">Original</a>
    <h1>A note on Metal shader converter</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>At WWDC, Apple introduced <a href="https://developer.apple.com/metal/shader-converter/">Metal shader converter</a>, a tool for converting shaders from DXIL (the main compilation target of HLSL in DirectX12) to Metal. While it is no doubt useful for reducing the cost of porting games from DirectX to Metal, I feel it does not move us any closer to a world of robust GPU infrastructure, and in many ways just adds more underspecified layers of complexity.</p>

<p>The specific feature I’m salty about is atomic barriers that allow for some sharing of work between threadgroups. These barriers are present in HLSL, and in fact have been since 2009, when <a href="https://en.wikipedia.org/wiki/Direct3D#Direct3D_11">Direct3D 11</a> and Shader Model 5 were first introduced. This barrier is not supported in Metal, and of the major GPU APIs, Metal is the only one that doesn’t support it. That holds back WebGPU’s performance (see <a href="https://github.com/gpuweb/gpuweb/discussions/3935">gpuweb#3935</a> for discussion), as WebGPU must be portable across the major APIs.</p>

<p>I’ve discussed the value of this barrier in my blog post <a href="https://raphlinus.github.io/gpu/2021/11/17/prefix-sum-portable.html">Prefix sum on portable compute shaders</a>, but I’ll briefly recap. Among other things, it enables a single-pass implementation of prefix sum, using a technique such as decoupled look-back or the <a href="https://dl.acm.org/doi/10.1145/2980983.2908089">SAM prefix sum</a> algorithm. A single-pass implementation can achieve the same throughput as memcpy, while a more traditional tree-reduction approach can at best achieve 2/3 that throughput, as it has to read the entire input in two separate dispatches. Further, tree reduction can actually be more complex to implement in practice, as the number of dispatches varies with the input size (it is typically <code>2 * ceil(log(n) / log(threadgroup size))</code>). Prefix sum, in turn, is an important primitive for advanced compute workloads. There are a number of instances of it in the <a href="https://github.com/linebender/vello">Vello</a> pipeline, and it’s also commonly used in stream compaction, decoding of variable length data streams, and compression.</p>

<p>I believe there are other important techniques that are similarly unlocked by the availability of these primitives. For example, Nanite’s advanced compute pipelines schedule work through job queues, and in general it is not possible to reliably coordinate work between different threadgroups (even within the same dispatch) without such a barrier.</p>

<h2 id="complexity-and-reasoning">Complexity and reasoning</h2>

<p>The GPU ecosystem exists at the knife edge of being strangled by complexity. A big part of the problem is that features tend to inhabit a quantum superposition of existing and not existing. Typically there is an anemic core, surrounded by a cloud of optional features. The Vulkan ecosystem is notorious for this: the <a href="https://vulkan.gpuinfo.org/listfeaturesextensions.php">extension list at vulkan.gpuinfo.org</a> currently lists 146 extensions.</p>

<p>The widespread use of shader translation makes the situation even worse. When writing HLSL that will be translated into other shader languages, it’s no longer sufficient to consider <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/d3d11-graphics-reference-sm5">Shader Model 5</a> to be a baseline, but rather the developer needs to keep in mind all the features that don’t translate to other languages. In some cases, the semantics change subtly (the rules for the various flavors “count leading zeros” when the input is 0 vary), and in other cases, like these device scoped barriers.</p>

<p>A separate category is things technically forbidden by the spec, but expected to work in practice. A good example here is the mixing of atomic and non-atomic memory operations (see <a href="https://github.com/gpuweb/gpuweb/issues/2229">gpuweb#2229</a>). The spirv-cross shader translation tool casts non-atomic pointers to atomic pointers to support this common pattern, which is technically undefined behavior in C++, but in practice lots of people would be unhappy if the Metal shader compiler did anything other than the reasonable thing. Since Metal’s semantics are based on C++, I’d personally love to see this resolved by adopting <a href="https://en.cppreference.com/w/cpp/atomic/atomic_ref">std::atomic_ref</a> from C++20 (Metal is still based on C++14). I’ll also note that the official Metal shader compiler tool generates <a href="https://gist.github.com/raphlinus/a8e0a3a3683127149b746eb37822bdc8">reasonable IR</a> for this pattern. It’s concerning that using open source tools such as spirv-cross triggers technical undefined behavior, but it’s probably not a big problem in practice.</p>

<p>I understand the incentives, but overall I find it disappointing that Metal chases shiny new features like ray-tracing, while failing to provide a solid, spec-compliant foundation for GPU compute.</p>

<h2 id="onward">Onward</h2>

<p>The Metal announcements from WWDC move us no closer to a world of robust GPU infrastructure. But there is much we can still do.</p>

<p>For one, there <em>is</em> a GPU infrastructure stack that is based on careful specification and conformance testing, and has two high quality, open source implementations enabling deployment to almost all reasonably current GPU hardware. I speak of course of WebGPU. It’s lacking the shiny features – raytracing, bindless, and cooperative matrix operations (marketed as “tensor cores” and quite important for maximum performance in AI workloads) – but what is there should work.</p>

<p>For two, we can cheer on the work of Asahi Linux. They have recently announced <a href="https://asahilinux.org/2023/06/opengl-3-1-on-asahi-linux/">OpenGL 3.1 support</a> on Apple Silicon, and an intent to implement Vulkan. That work may be highly challenging, as obviously that implies implementing barriers which the Apple GPU engineers haven’t been able to manage. But they have done consistently impressive work so far, and I certainly hope they succeed. If nothing else, their work will result in much better public documentation of the hardware’s capabilities and limitations.</p>

<p>I have a recommendations for Apple as well. I hope that they document which HLSL features are expected to work and which are not. Currently in their documentation (which is admittedly beta), it just says “Some features not supported,” which I personally find not very useful. I would also like to give them credit for clarifying the <a href="https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf">Metal Shading Language Specification</a> with respect to the scope of the <code>mem_device</code> flag to <code>threadgroup_barrier</code>. It now says, “The flag ensures the GPU correctly orders the memory operations to device memory for threads in the threadgroup,” which to a very careful reader does indicate threadgroup scope and no guarantee at device scope. Previously it <a href="https://github.com/gpuweb/gpuweb/pull/2297">said</a> “Ensure correct ordering of memory operations to device memory,” which could easily be misinterpreted as providing a device scope guarantee.</p>

<p>I am optimistic in the long term about having really good, portable infrastructure for GPU compute, but it is clear that we have a long way to go.</p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
