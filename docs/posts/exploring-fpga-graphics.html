<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://projectf.io/posts/fpga-graphics/">Original</a>
    <h1>Exploring FPGA Graphics</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Welcome to <em>Exploring FPGA Graphics</em>. In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs. We’ll learn how screens work, play Pong, create starfields and sprites, paint Michelangelo’s David, draw lines and triangles, and animate characters and shapes. Along the way, you’ll experience a range of designs and techniques, from memory and finite state machines to crossing clock domains and translating C algorithms into Verilog. This post was last updated in June 2022.</p>
<p><strong>This post was completely revised in March 2022.</strong></p>
<p><em>Get in touch: <a href="https://github.com/projf/projf-explore/issues">GitHub Issues</a>, <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a>, <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://twitter.com/WillFlux">@WillFlux</a> (Twitter)</em></p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/banner.png" alt="" title=""/></p>
<h3 id="series-outline">Series Outline</h3>
<ul>
<li>Beginning FPGA Graphics (this post) - video signals and basic graphics</li>
<li><a href="https://projectf.io/posts/racing-the-beam/">Racing the Beam</a> - simple demos with minimal logic</li>
<li><a href="https://projectf.io/posts/fpga-pong/">FPGA Pong</a> - recreate the classic arcade on an FPGA</li>
<li><a href="https://projectf.io/posts/display-signals/">Display Signals</a> - revisit display signals and meet colour palettes</li>
<li><a href="https://projectf.io/posts/hardware-sprites/">Hardware Sprites</a> - fast, colourful graphics for games</li>
<li><a href="https://projectf.io/posts/framebuffers/">Framebuffers</a> - bitmap graphics featuring Michelangelo’s David</li>
<li><a href="https://projectf.io/posts/lines-and-triangles/">Lines and Triangles</a> - drawing lines and triangles</li>
<li><a href="https://projectf.io/posts/fpga-shapes/">2D Shapes</a> - filled shapes and simple pictures</li>
<li><a href="https://projectf.io/posts/animated-shapes/">Animated Shapes</a> - animation and double-buffering</li>
</ul>
<blockquote>
<p><strong>Sponsor My Work</strong></p>
</blockquote>
<h3 id="requirements">Requirements</h3>
<p>For this series, you need an FPGA board with video output. We’ll be working at 640x480, so almost any video output will work. It helps to be comfortable with programming your FPGA board and reasonably familiar with Verilog. If you don’t have a dev board, not to worry, you can use the Verilator simulator.</p>
<p>We’ll demonstrate the designs with two boards and one simulator:</p>
<ul>
<li><strong><a href="https://docs.icebreaker-fpga.org/hardware/icebreaker/">iCEBreaker</a></strong> (Lattice iCE40) with <strong><a href="https://docs.icebreaker-fpga.org/hardware/pmod/dvi/">12-Bit DVI Pmod</a></strong></li>
<li><strong><a href="https://digilent.com/reference/programmable-logic/arty-a7/reference-manual">Digilent Arty A7-35T</a></strong> (Xilinx Artix-7) with <strong><a href="https://digilent.com/reference/pmod/pmodvga/reference-manual">Pmod VGA</a></strong></li>
<li><strong><a href="https://projectf.io/posts/verilog-sim-verilator-sdl/">Verilator Simulation with SDL</a></strong> - free hardware sim that runs on your PC</li>
</ul>
<p><img src="https://projectf.io/img/posts/fpga-graphics/arty-icebreaker.jpg" alt="iCEBreaker and Arty Dev Boards" title="iCEBreaker with DVI Pmod, Arty with Pmod VGA"/></p>
<h3 id="source">Source</h3>
<p>The SystemVerilog designs featured in this series are available from the <strong><a href="https://github.com/projf/projf-explore/tree/main/graphics">projf-explore</a></strong> git repo under the open-source MIT licence: build on them to your heart’s content. The rest of the blog content is subject to standard copyright restrictions: don’t republish it without permission.</p>
<blockquote>
<p><strong>SystemVerilog</strong></p>
</blockquote>
<h2 id="space-and-time">Space and Time</h2>
<p>A screen is a miniature universe with its own space and time.</p>
<p>Seem from afar, a screen shows a smooth two-dimensional image. Up close, it breaks up into many individual blocks of colour: red, green, and blue. We hide this complexity behind the abstract idea of a <strong>pixel</strong>: the smallest part of the screen we can control. A typical HD screen is 1920 by 1080: two million pixels in total. Even a 640x480 display has more than 300,000 pixels.</p>
<p>A screen creates the illusion of movement by refreshing many times every second. At 60 Hz, a 1920x1080 screen draws 124 million pixels every second! The need to quickly handle so much data is a big part of the challenge of working with graphics at a hardware level.</p>
<p>Display connectors and cabling vary, but VGA, HDMI, and DisplayPort have a similar data design. There are three channels for colour, usually red, green, and blue, and horizontal and vertical sync signals. There may also be audio and configuration data, but that’s not important right now.</p>
<p>The red, green, and blue channels carry the colour of each pixel in turn. A screen begins a new line when it receives a <strong>horizontal sync</strong> and a new frame on a <strong>vertical sync</strong>. The sync signals are part of <strong>blanking</strong> intervals.</p>
<p>Blanking intervals allow time for the electron gun in cathode ray tubes (CRTs) to move to the following line (horizontal retrace) or top of the screen (vertical retrace). Modern digital displays have retained the blanking intervals and repurposed them to transmit audio and other data.</p>
<p>Check out Tim Hunkin’s <a href="https://www.youtube.com/watch?v=dEW8QoJ-5Co">Secret Life of the Television</a> (1987) to see a CRT television cut in half and its inner workings revealed.</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/raster-scan.png" alt="Raster scan on a CRT Monitor" title="CRT raster scan by Ian Harvey in the public domain from https://commons.wikimedia.org/wiki/File:Raster-scan.svg"/></p>
<h2 id="display-timings">Display Timings</h2>
<p>A screen mode is defined by its <strong>display timings</strong>. Standard timings are set by <a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">VESA</a> and the <a href="https://en.wikipedia.org/wiki/Consumer_Technology_Association">CTA</a>.</p>
<p>In this series, we’ll use <strong>640x480 at 60Hz</strong>. Almost all displays support 640x480, and its low resource requirements make it possible to work with even the smallest FPGAs.</p>
<p>Display timings for 640x480 at 60Hz in units of pixels:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Horizontal</th>
<th>Vertical</th>
</tr>
</thead>
<tbody>
<tr>
<td>Active Pixels</td>
<td>640</td>
<td>480</td>
</tr>
<tr>
<td>Front Porch</td>
<td>16</td>
<td>10</td>
</tr>
<tr>
<td>Sync Width</td>
<td>96</td>
<td>2</td>
</tr>
<tr>
<td>Back Porch</td>
<td>48</td>
<td>33</td>
</tr>
<tr>
<td>Total Blanking</td>
<td>160</td>
<td>45</td>
</tr>
<tr>
<td>Total Pixels</td>
<td>800</td>
<td>525</td>
</tr>
<tr>
<td>Sync Polarity</td>
<td>negative</td>
<td>negative</td>
</tr>
</tbody>
</table>
<p><em>For other screen modes, see <a href="https://projectf.io/posts/video-timings-vga-720p-1080p/">Video Timings: VGA, SVGA, 720p, 1080p</a>.</em></p>
<p>The blanking interval has three parts: <strong>front porch</strong>, <strong>sync</strong>, and <strong>back porch</strong>. The front porch occurs before the sync signal, the back porch after.</p>
<p>If your screen showed all parts of the signal, it would look something like this:</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/display-timings.png" alt="Display Timings Visualized" title="Sitting on the back porch."/></p>
<p>Including blanking, we have a total of 800x525 pixels.</p>
<p>The refresh rate is 60 Hz, so the total number of pixels per second is:</p>
<p><code>800 x 525 x 60 = 25,200,000</code></p>
<p>Therefore, we want a <strong>pixel clock</strong> of 25.2 MHz.</p>
<h2 id="driving-a-display">Driving a Display</h2>
<p>Having selected our display timings, we’re ready to create a video signal. There are four stages:</p>
<ol>
<li>Pixel Clock</li>
<li>Display Signals</li>
<li>Drawing Graphics</li>
<li>Video Output (VGA, HDMI, DisplayPort)</li>
</ol>
<p><img src="https://projectf.io/img/posts/fpga-graphics/driving-a-display.png" alt="Driving a Display" title="Board oscillator in... video out"/></p>
<h2 id="pixel-clock">Pixel Clock</h2>
<p>We know we want a frequency of 25.2 MHz, but how to reach it?</p>
<p>FPGAs include <strong><a href="https://en.wikipedia.org/wiki/Phase-locked_loop">phase-locked loops</a></strong> (PLLs) to generate custom clock frequencies. Alas, there isn’t a standard way to configure a PLL; we need a vendor-specific design.</p>
<p>I have provided implementations for the Arty (Xilinx 7 Series) and iCEBreaker (iCE40):</p>
<ul>
<li>Arty (XC7): <strong><a href="https://github.com/projf/projf-explore/blob/main/lib/clock/xc7/clock_480p.sv">xc7/clock_480p.sv</a></strong></li>
<li>iCEBreaker (iCE40): <strong><a href="https://github.com/projf/projf-explore/blob/main/lib/clock/ice40/clock_480p.sv">ice40/clock_480p.sv</a></strong></li>
</ul>
<p><em>NB. The iCEBreaker can’t generate 25.2 MHz but runs fine at 25.125 MHz.</em></p>
<p>For other FPGA architectures, you’ll need to consult your vendor documentation. If you can’t reach 25.2 MHz exactly, 25 MHz or thereabouts should be fine.</p>
<blockquote>
<p><strong>CAUTION: CRT Monitors</strong></p>
</blockquote>
<h2 id="display-signals">Display Signals</h2>
<p>Next, we can generate sync signals from our pixel clock and display timings. We also want to report the current screen position to know <em>when</em> to draw things.</p>
<p>We do both of these things with a simple display module <strong>[<a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/simple_480p.sv">simple_480p.sv</a>]</strong>:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>module</span> simple_480p (
</span></span><span><span>    <span>input</span>  <span>wire</span> <span>logic</span> clk_pix,   <span>// pixel clock
</span></span></span><span><span><span></span>    <span>input</span>  <span>wire</span> <span>logic</span> rst_pix,   <span>// reset in pixel clock domain
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>9</span><span>:</span><span>0</span>] sx,  <span>// horizontal screen position
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>9</span><span>:</span><span>0</span>] sy,  <span>// vertical screen position
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> hsync,     <span>// horizontal sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> vsync,     <span>// vertical sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> de         <span>// data enable (low in blanking interval)
</span></span></span><span><span><span></span>    );
</span></span><span><span>
</span></span><span><span>    <span>// horizontal timings
</span></span></span><span><span><span></span>    <span>parameter</span> HA_END <span>=</span> <span>639</span>;           <span>// end of active pixels
</span></span></span><span><span><span></span>    <span>parameter</span> HS_STA <span>=</span> HA_END <span>+</span> <span>16</span>;   <span>// sync starts after front porch
</span></span></span><span><span><span></span>    <span>parameter</span> HS_END <span>=</span> HS_STA <span>+</span> <span>96</span>;   <span>// sync ends
</span></span></span><span><span><span></span>    <span>parameter</span> LINE   <span>=</span> <span>799</span>;           <span>// last pixel on line (after back porch)
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// vertical timings
</span></span></span><span><span><span></span>    <span>parameter</span> VA_END <span>=</span> <span>479</span>;           <span>// end of active pixels
</span></span></span><span><span><span></span>    <span>parameter</span> VS_STA <span>=</span> VA_END <span>+</span> <span>10</span>;   <span>// sync starts after front porch
</span></span></span><span><span><span></span>    <span>parameter</span> VS_END <span>=</span> VS_STA <span>+</span> <span>2</span>;    <span>// sync ends
</span></span></span><span><span><span></span>    <span>parameter</span> SCREEN <span>=</span> <span>524</span>;           <span>// last line on screen (after back porch)
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        hsync <span>=</span> <span>~</span>(sx <span>&gt;=</span> HS_STA <span>&amp;&amp;</span> sx <span>&lt;</span> HS_END);  <span>// invert: negative polarity
</span></span></span><span><span><span></span>        vsync <span>=</span> <span>~</span>(sy <span>&gt;=</span> VS_STA <span>&amp;&amp;</span> sy <span>&lt;</span> VS_END);  <span>// invert: negative polarity
</span></span></span><span><span><span></span>        de <span>=</span> (sx <span>&lt;=</span> HA_END <span>&amp;&amp;</span> sy <span>&lt;=</span> VA_END);
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// calculate horizontal and vertical screen position
</span></span></span><span><span><span></span>    <span>always_ff</span> @(<span>posedge</span> clk_pix) <span>begin</span>
</span></span><span><span>        <span>if</span> (sx <span>==</span> LINE) <span>begin</span>  <span>// last pixel on line?
</span></span></span><span><span><span></span>            sx <span>&lt;=</span> <span>0</span>;
</span></span><span><span>            sy <span>&lt;=</span> (sy <span>==</span> SCREEN) <span>?</span> <span>0</span> <span>:</span> sy <span>+</span> <span>1</span>;  <span>// last line on screen?
</span></span></span><span><span><span></span>        <span>end</span> <span>else</span> <span>begin</span>
</span></span><span><span>            sx <span>&lt;=</span> sx <span>+</span> <span>1</span>;
</span></span><span><span>        <span>end</span>
</span></span><span><span>        <span>if</span> (rst_pix) <span>begin</span>
</span></span><span><span>            sx <span>&lt;=</span> <span>0</span>;
</span></span><span><span>            sy <span>&lt;=</span> <span>0</span>;
</span></span><span><span>        <span>end</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><p><em>ProTip: The last assignment wins in Verilog, so the reset overrides existing values for <code>sx</code> and <code>sy</code>.</em></p>
<p><strong>sx</strong> and <strong>sy</strong> store the horizontal and vertical screen position. Counting starts at zero, so the maximum values are 799 for <code>sx</code> and 524 for <code>sy</code>, requiring 10 bits to hold the coordinates (2<sup>10</sup> = 1024).</p>
<p>For simplicity, we put blanking <em>after</em> the visible pixels; that way, <code>(0,0)</code> is the top-left visible pixel and <code>(639,479)</code> the bottom right.</p>
<p>The following diagram shows the display signals to scale with two 64x64 pixel squares drawn:</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/simple-display-signals.png" alt="Simple Display Signals" title=""/></p>
<p><strong>de</strong> is <em>data enable</em>, which is low during the blanking interval (grey area of above diagram) and tells us when it’s safe to draw.</p>
<p>From the display timings, we know our sync polarity is negative for both <strong>hsync</strong> and <strong>vsync</strong>. Negative polarity means that a <em>low voltage</em> indicates a sync.</p>
<p>The following simulation shows the vertical sync starting at line 489. The vertical sync is low for two lines, as expected from the display timings. Note the horizontal sync at the end of each line.</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/hsync-vsync-vga.png" alt="Sync Signal Simulation" title="Simulating VGA horizontal &amp; vertical sync signals"/></p>
<h3 id="test-benches">Test Benches</h3>
<p>If you’re using Vivado, try exercising the designs with these test benches:</p>
<ul>
<li><strong><a href="https://github.com/projf/projf-explore/tree/main/lib/clock/xc7/clock_tb.sv">Clock Test Bench</a></strong></li>
<li><strong><a href="https://github.com/projf/projf-explore/tree/main/graphics/fpga-graphics/xc7/simple_480p_tb.sv">Simple Display Test Bench</a></strong></li>
</ul>
<p>Some things to check:</p>
<ul>
<li>What is the pixel clock period?</li>
<li>How long does the pixel clock take to lock?</li>
<li>Does a frame last exactly 1/60th of a second?</li>
<li>How much time does a single line last?</li>
<li>What is the maximum values of <code>sx</code> and <code>sy</code> when <code>de</code> is low?</li>
</ul>
<p><em>You can find instructions for running the Vivado simulations in the source <a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/README.md">README</a>.</em></p>
<h2 id="drawing-graphics">Drawing Graphics</h2>
<p>For our first design, we’re going to draw a square like this:</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/square.png" alt="Square" title="All persons should report on board as the vessel is about to proceed to sea."/></p>
<p>We use the screen coordinates <code>(sx,sy)</code> to define a square in the centre of the screen:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>logic</span> square;
</span></span><span><span><span>always_comb</span> <span>begin</span>
</span></span><span><span>    square <span>=</span> (sx <span>&gt;</span> <span>220</span> <span>&amp;&amp;</span> sx <span>&lt;</span> <span>420</span>) <span>&amp;&amp;</span> (sy <span>&gt;</span> <span>140</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>340</span>);
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h3 id="12-bit-colour">12-bit Colour</h3>
<p>The VGA and DVI Pmods output 12-bit colour with three 4-bit channels: red, green, and blue.</p>
<p>We can represent a specific colour using a <a href="https://en.wikipedia.org/wiki/Web_colors#Hex_triplet">hex triplet</a>:</p>
<ul>
<li><code>#F00</code> - bright red</li>
<li><code>#FA0</code> - orange</li>
<li><code>#0E3</code> - bright green</li>
<li><code>#137</code> - dark blue</li>
<li><code>#FFF</code> - white</li>
</ul>
<p>In Verilog, hex literals use the letter <code>h</code>, so we can set our colours as follows:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span><span>always_comb</span> <span>begin</span>
</span></span><span><span>    paint_r <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h1</span>;
</span></span><span><span>    paint_g <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h3</span>;
</span></span><span><span>    paint_b <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h7</span>;
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>We generate a separate signal for each colour channel, ready for video output.</p>
<h2 id="video-output">Video Output</h2>
<p>Video output works differently for each board and simulation, so we’ll cover them in turn.</p>
<h3 id="arty-vga">Arty VGA</h3>
<p>VGA output is straightforward. We register each signal to improve timing and avoid skew:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>// VGA Pmod output
</span></span></span><span><span><span></span><span>always_ff</span> @(<span>posedge</span> clk_pix) <span>begin</span>
</span></span><span><span>    vga_hsync <span>&lt;=</span> hsync;
</span></span><span><span>    vga_vsync <span>&lt;=</span> vsync;
</span></span><span><span>    <span>if</span> (de) <span>begin</span>
</span></span><span><span>        vga_r <span>&lt;=</span> paint_r;
</span></span><span><span>        vga_g <span>&lt;=</span> paint_g;
</span></span><span><span>        vga_b <span>&lt;=</span> paint_b;
</span></span><span><span>    <span>end</span> <span>else</span> <span>begin</span>  <span>// VGA colour should be black in blanking interval
</span></span></span><span><span><span></span>        vga_r <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>        vga_g <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>        vga_b <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>The VGA Pmod handles the conversion of digital colour signals into analogue voltages. You need to ensure the colour is black during blanking; otherwise, you’ll see corrupted output on some screens.</p>
<h3 id="icebreaker-dvi">iCEBreaker DVI</h3>
<p>The <a href="https://www.ti.com/product/TFP410">TFP410</a> chip on the DVI Pmod takes our colour and sync signals and encodes them into DVI using <a href="https://en.wikipedia.org/wiki/Transition-minimized_differential_signaling">Transition-minimized differential signalling</a> (TMDS).</p>
<p>We use the <strong>SB_IO</strong> primitive to produce high-quality output from the iCE40 FPGA. It’s not necessary to understand how SB_IO works for this series; use this snippet in your designs, and all will be well:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>// DVI Pmod output
</span></span></span><span><span><span></span>SB_IO #(
</span></span><span><span>    .PIN_TYPE(<span>6</span><span>&#39;b010100</span>)  <span>// PIN_OUTPUT_REGISTERED
</span></span></span><span><span><span></span>) dvi_signal_io [<span>14</span><span>:</span><span>0</span>] (
</span></span><span><span>    .PACKAGE_PIN({dvi_hsync, dvi_vsync, dvi_de, dvi_r, dvi_g, dvi_b}),
</span></span><span><span>    .OUTPUT_CLK(clk_pix),
</span></span><span><span>    .D_OUT_0({hsync, vsync, de, paint_r, paint_g, paint_b}),
</span></span><span><span>    .D_OUT_1()
</span></span><span><span>);
</span></span><span><span>
</span></span><span><span><span>// DVI Pmod clock output: 180° out of phase with other DVI signals
</span></span></span><span><span><span></span>SB_IO #(
</span></span><span><span>    .PIN_TYPE(<span>6</span><span>&#39;b010000</span>)  <span>// PIN_OUTPUT_DDR
</span></span></span><span><span><span></span>) dvi_clk_io (
</span></span><span><span>    .PACKAGE_PIN(dvi_clk),
</span></span><span><span>    .OUTPUT_CLK(clk_pix),
</span></span><span><span>    .D_OUT_0(<span>1</span><span>&#39;b0</span>),
</span></span><span><span>    .D_OUT_1(<span>1</span><span>&#39;b1</span>)
</span></span><span><span>);
</span></span></code></pre></div><blockquote>
<p><strong>Lattice SB_IO</strong></p>
</blockquote>
<h3 id="verilator-sim">Verilator Sim</h3>
<p>The simulation output is similar to the Arty VGA, but it expects eight bits per colour channel:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>// SDL output (8 bits per colour channel)
</span></span></span><span><span><span></span><span>always_ff</span> @(<span>posedge</span> clk_pix) <span>begin</span>
</span></span><span><span>    sdl_sx <span>&lt;=</span> sx;
</span></span><span><span>    sdl_sy <span>&lt;=</span> sy;
</span></span><span><span>    sdl_de <span>&lt;=</span> de;
</span></span><span><span>    sdl_r <span>&lt;=</span> {<span>2</span>{paint_r}};  <span>// double signal width from 4 to 8 bits
</span></span></span><span><span><span></span>    sdl_g <span>&lt;=</span> {<span>2</span>{paint_g}};
</span></span><span><span>    sdl_b <span>&lt;=</span> {<span>2</span>{paint_b}};
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h2 id="square-one">Square One</h2>
<p>Bringing the four stages together we have a complete top module:</p>
<ul>
<li>Arty (XC7): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/xc7/top_square.sv">xc7/top_square.sv</a></strong></li>
<li>iCEBreaker (iCE40): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/ice40/top_square.sv">ice40/top_square.sv</a></strong></li>
<li>Verilator Sim: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/sim/top_square.sv">sim/top_square.sv</a></strong></li>
</ul>
<p>All of these top modules are listed in full, below. See if you can match each of the four stages of <a href="#driving-a-display">driving a display</a> with the Verilog for your top module.</p>
<h3 id="arty-vga-square">Arty VGA Square</h3>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>module</span> top_square (
</span></span><span><span>    <span>input</span>  <span>wire</span> <span>logic</span> clk_100m,     <span>// 100 MHz clock
</span></span></span><span><span><span></span>    <span>input</span>  <span>wire</span> <span>logic</span> btn_rst_n,    <span>// reset button
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> vga_hsync,    <span>// VGA horizontal sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> vga_vsync,    <span>// VGA vertical sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] vga_r,  <span>// 4-bit VGA red
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] vga_g,  <span>// 4-bit VGA green
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] vga_b   <span>// 4-bit VGA blue
</span></span></span><span><span><span></span>    );
</span></span><span><span>
</span></span><span><span>    <span>// generate pixel clock
</span></span></span><span><span><span></span>    <span>logic</span> clk_pix;
</span></span><span><span>    <span>logic</span> clk_pix_locked;
</span></span><span><span>    clock_480p clock_pix_inst (
</span></span><span><span>       .clk_100m,
</span></span><span><span>       .rst(<span>!</span>btn_rst_n),  <span>// reset button is active low
</span></span></span><span><span><span></span>       .clk_pix,
</span></span><span><span>       .clk_pix_5x(),  <span>// not used for VGA output
</span></span></span><span><span><span></span>       .clk_pix_locked
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// display sync signals and coordinates
</span></span></span><span><span><span></span>    <span>localparam</span> CORDW <span>=</span> <span>10</span>;  <span>// screen coordinate width in bits
</span></span></span><span><span><span></span>    <span>logic</span> [CORDW<span>-</span><span>1</span><span>:</span><span>0</span>] sx, sy;
</span></span><span><span>    <span>logic</span> hsync, vsync, de;
</span></span><span><span>    simple_480p display_inst (
</span></span><span><span>        .clk_pix,
</span></span><span><span>        .rst_pix(<span>!</span>clk_pix_locked),  <span>// wait for clock lock
</span></span></span><span><span><span></span>        .sx,
</span></span><span><span>        .sy,
</span></span><span><span>        .hsync,
</span></span><span><span>        .vsync,
</span></span><span><span>        .de
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// define a square with screen coordinates
</span></span></span><span><span><span></span>    <span>logic</span> square;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        square <span>=</span> (sx <span>&gt;</span> <span>220</span> <span>&amp;&amp;</span> sx <span>&lt;</span> <span>420</span>) <span>&amp;&amp;</span> (sy <span>&gt;</span> <span>140</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>340</span>);
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// paint colours: white inside square, blue outside
</span></span></span><span><span><span></span>    <span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        paint_r <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h1</span>;
</span></span><span><span>        paint_g <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h3</span>;
</span></span><span><span>        paint_b <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h7</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// VGA Pmod output
</span></span></span><span><span><span></span>    <span>always_ff</span> @(<span>posedge</span> clk_pix) <span>begin</span>
</span></span><span><span>        vga_hsync <span>&lt;=</span> hsync;
</span></span><span><span>        vga_vsync <span>&lt;=</span> vsync;
</span></span><span><span>        <span>if</span> (de) <span>begin</span>
</span></span><span><span>            vga_r <span>&lt;=</span> paint_r;
</span></span><span><span>            vga_g <span>&lt;=</span> paint_g;
</span></span><span><span>            vga_b <span>&lt;=</span> paint_b;
</span></span><span><span>        <span>end</span> <span>else</span> <span>begin</span>  <span>// VGA colour should be black in blanking interval
</span></span></span><span><span><span></span>            vga_r <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>            vga_g <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>            vga_b <span>&lt;=</span> <span>4&#39;h0</span>;
</span></span><span><span>        <span>end</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><h3 id="icebreaker-dvi-square">iCEBreaker DVI Square</h3>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>module</span> top_square (
</span></span><span><span>    <span>input</span>  <span>wire</span> <span>logic</span> clk_12m,      <span>// 12 MHz clock
</span></span></span><span><span><span></span>    <span>input</span>  <span>wire</span> <span>logic</span> btn_rst,      <span>// reset button
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> dvi_clk,      <span>// DVI pixel clock
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> dvi_hsync,    <span>// DVI horizontal sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> dvi_vsync,    <span>// DVI vertical sync
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> dvi_de,       <span>// DVI data enable
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] dvi_r,  <span>// 4-bit DVI red
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] dvi_g,  <span>// 4-bit DVI green
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>3</span><span>:</span><span>0</span>] dvi_b   <span>// 4-bit DVI blue
</span></span></span><span><span><span></span>    );
</span></span><span><span>
</span></span><span><span>    <span>// generate pixel clock
</span></span></span><span><span><span></span>    <span>logic</span> clk_pix;
</span></span><span><span>    <span>logic</span> clk_pix_locked;
</span></span><span><span>    clock_480p clock_pix_inst (
</span></span><span><span>       .clk_12m,
</span></span><span><span>       .rst(btn_rst),
</span></span><span><span>       .clk_pix,
</span></span><span><span>       .clk_pix_locked
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// display sync signals and coordinates
</span></span></span><span><span><span></span>    <span>localparam</span> CORDW <span>=</span> <span>10</span>;  <span>// screen coordinate width in bits
</span></span></span><span><span><span></span>    <span>logic</span> [CORDW<span>-</span><span>1</span><span>:</span><span>0</span>] sx, sy;
</span></span><span><span>    <span>logic</span> hsync, vsync, de;
</span></span><span><span>    simple_480p display_inst (
</span></span><span><span>        .clk_pix,
</span></span><span><span>        .rst_pix(<span>!</span>clk_pix_locked),  <span>// wait for clock lock
</span></span></span><span><span><span></span>        .sx,
</span></span><span><span>        .sy,
</span></span><span><span>        .hsync,
</span></span><span><span>        .vsync,
</span></span><span><span>        .de
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// define a square with screen coordinates
</span></span></span><span><span><span></span>    <span>logic</span> square;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        square <span>=</span> (sx <span>&gt;</span> <span>220</span> <span>&amp;&amp;</span> sx <span>&lt;</span> <span>420</span>) <span>&amp;&amp;</span> (sy <span>&gt;</span> <span>140</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>340</span>);
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// paint colours: white inside square, blue outside
</span></span></span><span><span><span></span>    <span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        paint_r <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h1</span>;
</span></span><span><span>        paint_g <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h3</span>;
</span></span><span><span>        paint_b <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h7</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// DVI Pmod output
</span></span></span><span><span><span></span>    SB_IO #(
</span></span><span><span>        .PIN_TYPE(<span>6</span><span>&#39;b010100</span>)  <span>// PIN_OUTPUT_REGISTERED
</span></span></span><span><span><span></span>    ) dvi_signal_io [<span>14</span><span>:</span><span>0</span>] (
</span></span><span><span>        .PACKAGE_PIN({dvi_hsync, dvi_vsync, dvi_de, dvi_r, dvi_g, dvi_b}),
</span></span><span><span>        .OUTPUT_CLK(clk_pix),
</span></span><span><span>        .D_OUT_0({hsync, vsync, de, paint_r, paint_g, paint_b}),
</span></span><span><span>        .D_OUT_1()
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// DVI Pmod clock output: 180° out of phase with other DVI signals
</span></span></span><span><span><span></span>    SB_IO #(
</span></span><span><span>        .PIN_TYPE(<span>6</span><span>&#39;b010000</span>)  <span>// PIN_OUTPUT_DDR
</span></span></span><span><span><span></span>    ) dvi_clk_io (
</span></span><span><span>        .PACKAGE_PIN(dvi_clk),
</span></span><span><span>        .OUTPUT_CLK(clk_pix),
</span></span><span><span>        .D_OUT_0(<span>1</span><span>&#39;b0</span>),
</span></span><span><span>        .D_OUT_1(<span>1</span><span>&#39;b1</span>)
</span></span><span><span>    );
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><h3 id="verilator-sim-1">Verilator Sim</h3>
<p>The Verilator simulation works a little differently; we output the coordinates <code>sdl_sx</code>, and <code>sdl_sy</code>, as well as the colour information.</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>module</span> top_square #(<span>parameter</span> CORDW<span>=</span><span>10</span>) (  <span>// coordinate width
</span></span></span><span><span><span></span>    <span>input</span>  <span>wire</span> <span>logic</span> clk_pix,             <span>// pixel clock
</span></span></span><span><span><span></span>    <span>input</span>  <span>wire</span> <span>logic</span> sim_rst,             <span>// sim reset
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [CORDW<span>-</span><span>1</span><span>:</span><span>0</span>] sdl_sx,  <span>// horizontal SDL position
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [CORDW<span>-</span><span>1</span><span>:</span><span>0</span>] sdl_sy,  <span>// vertical SDL position
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> sdl_de,              <span>// data enable (low in blanking interval)
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>7</span><span>:</span><span>0</span>] sdl_r,         <span>// 8-bit red
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>7</span><span>:</span><span>0</span>] sdl_g,         <span>// 8-bit green
</span></span></span><span><span><span></span>    <span>output</span>      <span>logic</span> [<span>7</span><span>:</span><span>0</span>] sdl_b          <span>// 8-bit blue
</span></span></span><span><span><span></span>    );
</span></span><span><span>
</span></span><span><span>    <span>// display sync signals and coordinates
</span></span></span><span><span><span></span>    <span>logic</span> [CORDW<span>-</span><span>1</span><span>:</span><span>0</span>] sx, sy;
</span></span><span><span>    <span>logic</span> de;
</span></span><span><span>    simple_480p display_inst (
</span></span><span><span>        .clk_pix,
</span></span><span><span>        .rst_pix(sim_rst),
</span></span><span><span>        .sx,
</span></span><span><span>        .sy,
</span></span><span><span>        .hsync(),
</span></span><span><span>        .vsync(),
</span></span><span><span>        .de
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>// define a square with screen coordinates
</span></span></span><span><span><span></span>    <span>logic</span> square;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        square <span>=</span> (sx <span>&gt;</span> <span>220</span> <span>&amp;&amp;</span> sx <span>&lt;</span> <span>420</span>) <span>&amp;&amp;</span> (sy <span>&gt;</span> <span>140</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>340</span>);
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// paint colours: white inside square, blue outside
</span></span></span><span><span><span></span>    <span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span>    <span>always_comb</span> <span>begin</span>
</span></span><span><span>        paint_r <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h1</span>;
</span></span><span><span>        paint_g <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h3</span>;
</span></span><span><span>        paint_b <span>=</span> (square) <span>?</span> <span>4&#39;hF</span> <span>:</span> <span>4&#39;h7</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span>
</span></span><span><span>    <span>// SDL output (8 bits per colour channel)
</span></span></span><span><span><span></span>    <span>always_ff</span> @(<span>posedge</span> clk_pix) <span>begin</span>
</span></span><span><span>        sdl_sx <span>&lt;=</span> sx;
</span></span><span><span>        sdl_sy <span>&lt;=</span> sy;
</span></span><span><span>        sdl_de <span>&lt;=</span> de;
</span></span><span><span>        sdl_r <span>&lt;=</span> {<span>2</span>{paint_r}};  <span>// double signal width from 4 to 8 bits
</span></span></span><span><span><span></span>        sdl_g <span>&lt;=</span> {<span>2</span>{paint_g}};
</span></span><span><span>        sdl_b <span>&lt;=</span> {<span>2</span>{paint_b}};
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>endmodule</span>
</span></span></code></pre></div><p><em>NB. The Verilator simulation receives its pixel clock from the C++ wrapper, so there’s no pixel clock generation in this version.</em></p>
<h2 id="constraints">Constraints</h2>
<p>Before building the design, we need board constraints. The constraints map the pins on the FPGA to the signals in our design. For example, we need to know which FPGA pin connects to the reset button and which to the vertical sync.</p>
<p>Take a look at the constraints for your board:</p>
<ul>
<li>Arty Constraints: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/xc7/arty.xdc">arty.xdc</a></strong></li>
<li>iCEBreaker Constraints: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/ice40/icebreaker.pcf">icebreaker.pcf</a></strong></li>
</ul>
<p>The Verilator sim doesn’t require constraints.</p>
<h2 id="building">Building</h2>
<p>Each part of this series includes a <a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/README.md">README</a> and <a href="https://github.com/projf/projf-explore/tree/main/graphics/fpga-graphics/sim">Sim README</a> with build instructions. I have provided basic instructions here to get you started. If you need help with your board or tools, I recommend the <a href="https://forum.digilentinc.com/">Digilent Forum</a> for Arty and <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a> for iCEBreaker.</p>
<h3 id="arty">Arty</h3>
<p>We build Arty designs using Xilinx Vivado. To create a Vivado project, clone the <a href="https://github.com/projf/projf-explore">projf-explore repo</a> from GitHub. Then, start Vivado and run the following in the Tcl Console:</p>
<div><pre tabindex="0"><code data-lang="tcl"><span><span>cd projf-explore<span>/</span>graphics<span>/</span>fpga-graphics<span>/</span>xc7<span>/</span>vivado
</span></span><span><span>source .<span>/</span>create_project.tcl
</span></span></code></pre></div><p>This creates a Vivado project with all four designs from this post.</p>
<h3 id="icebreaker">iCEBreaker</h3>
<p>We build iCEBreaker designs with the open-source toolchain of <a href="http://yosyshq.net/yosys/">Yosys</a>, <a href="https://github.com/YosysHQ/nextpnr">nextpnr</a>, and <a href="http://bygone.clairexen.net/icestorm/">IceStorm Tools</a>. If you don’t already have these tools see the <a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/README.md">README</a>.</p>
<p>To build and program the <em>square</em> design; clone the <a href="https://github.com/projf/projf-explore">projf-explore repo</a>, then in a shell:</p>
<div><pre tabindex="0"><code data-lang="shell"><span><span>cd projf-explore/graphics/fpga-graphics/ice40
</span></span><span><span>make square
</span></span><span><span>iceprog square.bin
</span></span></code></pre></div><p><em>If you have problems building the iCE40 designs, make sure you’re using Yosys 0.10 or later.</em></p>
<h3 id="verilator-simulation">Verilator Simulation</h3>
<p>If this is the first time you’ve used Verilator and SDL, you need to <a href="https://github.com/projf/projf-explore/tree/main/graphics/fpga-graphics/sim#installing-dependencies">install dependencies</a>.</p>
<p>Make sure you’re in the sim directory <code>projf-explore/graphics/fpga-graphics/sim</code>.</p>
<p>Build a specific simulation (square, flag_ethiopia, flag_sweden, or colour):</p>
<p>Or build all simulations:</p>
<p>Run the simulation executables from <code>obj_dir</code>:</p>
<p>See also <a href="https://projectf.io/posts/verilog-sim-verilator-sdl/">Verilog Simulation with Verilator and SDL</a> and the <a href="https://github.com/projf/projf-explore/tree/main/graphics/fpga-graphics/sim">Simulation README</a>.</p>
<h2 id="flags">Flags</h2>
<p>Our first design is not only a square but also the <a href="https://en.wikipedia.org/wiki/International_maritime_signal_flags">naval signal flag</a> for the letter ‘P’ (blue Peter).</p>
<p>I have created designs for two more flags: Ethiopia and Sweden. Take a look at these examples, then have a go at drawing a flag yourself.</p>
<h3 id="flag-of-ethiopia">Flag of Ethiopia</h3>
<p>The traditional <a href="https://en.wikipedia.org/wiki/Flag_of_Ethiopia">flag of Ethiopia</a> is a tricolour of green, yellow, and red.</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/flag_ethiopia.png" alt="Traditional Flag of Ethiopia" title=""/></p>
<p>We only need the horizontal screen coordinate, <code>sy</code>, to define this flag:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span><span>always_comb</span> <span>begin</span>
</span></span><span><span>    <span>if</span> (sy <span>&lt;</span> <span>160</span>) <span>begin</span>  <span>// top of flag is green
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;h9</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h3</span>;
</span></span><span><span>    <span>end</span> <span>else</span> <span>if</span> (sy <span>&lt;</span> <span>320</span>) <span>begin</span>  <span>// middle of flag is yellow
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;hF</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;hE</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h1</span>;
</span></span><span><span>    <span>end</span> <span>else</span> <span>begin</span>  <span>// bottom of flag is red
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;hE</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;h1</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h2</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>You can find the full flag design in git:</p>
<ul>
<li>Arty (XC7): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/xc7/top_flag_ethiopia.sv">xc7/top_flag_ethiopia.sv</a></strong></li>
<li>iCEBreaker (iCE40): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/ice40/top_flag_ethiopia.sv">ice40/top_flag_ethiopia.sv</a></strong></li>
<li>Verilator Sim: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/sim/top_flag_ethiopia.sv">sim/top_flag_ethiopia.sv</a></strong></li>
</ul>
<h3 id="flag-of-sweden">Flag of Sweden</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Flag_of_Sweden">flag of Sweden</a> consists of a yellow Nordic cross on a blue background.</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/flag_sweden.png" alt="Flag of Sweden" title=""/></p>
<p>The official flag has a ratio of 8:5, which equates to 640x400 on our screen:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span><span>always_comb</span> <span>begin</span>
</span></span><span><span>    <span>if</span> (sy <span>&gt;=</span> <span>400</span>) <span>begin</span>  <span>// black outside the flag area
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>    <span>end</span> <span>else</span> <span>if</span> (sy <span>&gt;</span> <span>160</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>240</span>) <span>begin</span>  <span>// yellow cross horizontal
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;hF</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;hC</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>    <span>end</span> <span>else</span> <span>if</span> (sx <span>&gt;</span> <span>200</span> <span>&amp;&amp;</span> sx <span>&lt;</span> <span>280</span>) <span>begin</span>  <span>// yellow cross vertical
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;hF</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;hC</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>    <span>end</span> <span>else</span> <span>begin</span>  <span>// blue flag background
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;h6</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;hA</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>You can find the full flag design in git:</p>
<ul>
<li>Arty (XC7): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/xc7/top_flag_sweden.sv">xc7/top_flag_sweden.sv</a></strong></li>
<li>iCEBreaker (iCE40): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/ice40/top_flag_sweden.sv">ice40/top_flag_sweden.sv</a></strong></li>
<li>Verilator Sim: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/sim/top_flag_sweden.sv">sim/top_flag_sweden.sv</a></strong></li>
</ul>
<h2 id="colour-test">Colour Test</h2>
<p>No introduction to graphics hardware would be complete without a colour gradient. 12-bit graphics can handle 4,096 colours; this demo shows 256 of them.</p>
<p><img src="https://projectf.io/img/posts/fpga-graphics/colour.jpeg" alt="Colour Gradient Test" title="256 fresh colours"/></p>
<p>For this example, I’ve kept the blue level contant while varying the red and green:</p>
<div><pre tabindex="0"><code data-lang="verilog"><span><span><span>logic</span> [<span>3</span><span>:</span><span>0</span>] paint_r, paint_g, paint_b;
</span></span><span><span><span>always_comb</span> <span>begin</span>
</span></span><span><span>    <span>if</span> (sx <span>&lt;</span> <span>256</span> <span>&amp;&amp;</span> sy <span>&lt;</span> <span>256</span>) <span>begin</span>  <span>// colour square in top-left 256x256 pixels
</span></span></span><span><span><span></span>        paint_r <span>=</span> sx[<span>7</span><span>:</span><span>4</span>];  <span>// 16 horizontal pixels of each red level
</span></span></span><span><span><span></span>        paint_g <span>=</span> sy[<span>7</span><span>:</span><span>4</span>];  <span>// 16 vertical pixels of each green level
</span></span></span><span><span><span></span>        paint_b <span>=</span> <span>4&#39;h4</span>;     <span>// constant blue level
</span></span></span><span><span><span></span>    <span>end</span> <span>else</span> <span>begin</span>  <span>// otherwise black
</span></span></span><span><span><span></span>        paint_r <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_g <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>        paint_b <span>=</span> <span>4&#39;h0</span>;
</span></span><span><span>    <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>We select bits <code>[7:4]</code> from <code>sx</code> and <code>sy</code>, so the colour level changes every 16 pixels.</p>
<p>You can find the full design in git:</p>
<ul>
<li>Arty (XC7): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/xc7/top_colour.sv">xc7/top_colour.sv</a></strong></li>
<li>iCEBreaker (iCE40): <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/ice40/top_colour.sv">ice40/top_colour.sv</a></strong></li>
<li>Verilator Sim: <strong><a href="https://github.com/projf/projf-explore/blob/main/graphics/fpga-graphics/sim/top_colour.sv">sim/top_colour.sv</a></strong></li>
</ul>
<h2 id="next-time">Next Time</h2>
<p>I hope you enjoyed this introduction to FPGA Graphics. Next time, we’ll be <em><a href="https://projectf.io/posts/racing-the-beam/">Racing the Beam</a></em> to create simple demos with our new graphics skills.</p>
<h2 id="whats-possible">What’s Possible?</h2>
<p>Here are some projects to inspire you:</p>
<ul>
<li><a href="https://bikerglen.com/blog/driving-a-32x32-rgb-led-matrix-with-a-beaglebone-black-and-an-fpga/">Driving a 32×32 RGB LED Matrix</a> by Glen Akins</li>
<li><a href="https://github.com/dan-rodrigues/icestation-32">icestation-32: open-source FPGA game console</a> by Dan Rodrigues</li>
<li><a href="https://github.com/mattvenn/vga-clock">VGA Clock</a> by Matt Venn</li>
<li><a href="https://tomverbeure.github.io/rtl/2018/11/26/Racing-the-Beam-Ray-Tracer.html">Racing the Beam Ray Tracer</a> by Tom Verbeure</li>
<li><a href="https://github.com/ultraembedded/FPGAmp">FPGA Media Player</a> by ultraembedded</li>
</ul>
<p><em>Get in touch: <a href="https://github.com/projf/projf-explore/issues">GitHub Issues</a>, <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a>, <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://twitter.com/WillFlux">@WillFlux</a> (Twitter)</em></p>

      
    </div></div>
  </body>
</html>
