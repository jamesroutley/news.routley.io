<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stoppels.ch/2022/11/27/io-is-no-longer-the-bottleneck.html">Original</a>
    <h1>I/O is no longer the bottleneck? (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
<section>

<p><em>Nov 27th, 2022</em></p>
<p>Recently Ben Hoyt <a href="https://benhoyt.com/writings/io-is-no-longer-the-bottleneck/">published a blog post</a> claiming that contrary to popular belief, I/O is not the bottleneck in typical programming interview problems such as counting word frequencies from a stream. Sequential read speed has come a long way, while CPU speed has stagnated.</p>
<p>Sequential reads are indeed incredibly fast. Using the same method as linked in Ben Hoyt&#39;s post, I&#39;m getting <strong>1.6 GB/s</strong> sequential reads on a cold cache, and <strong>12.8 GB/s</strong> on a warm cache (best of five).</p>
<p>But it should be possible to count word frequencies at a speed of 1.6 GB/s even on a single thread, right?</p>
<p><em>(For the impatient: code is <a href="https://github.com/haampie/wc-avx2">available on GitHub</a>.)</em></p>
<h2>The optimized C implementation</h2>
<p>Ben Hoyt&#39;s blog refers to an <a href="https://benhoyt.com/writings/count-words/">earlier post</a> which includes a faster C version of the word frequency counter. I compiled <code>optimized.c</code> with GCC 12, using <code>-O3 -march=native</code> flags, and ran it on the 425MB input file (100 copies of the King James Version of the Bible).</p>

<p>The result was surprisingly bad:</p>

<pre>$ time ./optimized &lt; bible-100.txt &gt; /dev/null

real    0m1.525s
user    0m1.477s
sys     0m0.048s
</pre>

<p>That is only <strong>278 MB/s</strong> on warm cache.</p>

<h3>Vectorization</h3>
<p>Looking at the code I realized one of the hot loops had many branches, including an early exit, which prevents the compiler from vectorizing:</p>

<pre>for (; i &lt; num_process; i++) {
    char c = buf[i];
    if (c &lt;= &#39; &#39;) {
        break;
    }
    <strong>if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {
        c += (&#39;a&#39; - &#39;A&#39;);
        buf[i] = c;
    }</strong>
    hash *= FNV_PRIME;
    hash ^= (uint64_t)c;
}
</pre>

<p>My initial attempt to improve performance was to move this lowercase logic out of the loop, like so:</p>

<pre>for (int i = 0; i &lt; BUF_SIZE; ++i) {
    buf[i] = buf[i] &gt;= &#39;A&#39; &amp;&amp; buf[i] &lt;= &#39;Z&#39; ?  buf[i] - &#39;A&#39; + &#39;a&#39; : buf[i];
}
</pre>

<p>This simple change improved performance to <strong>330 MB/s</strong> (using clang for better vectorization). Funnily enough, just adding these 3 lines before the loop, without deleting the original code gives comparable speed; strictly more work, but branch prediction does its job. Still, it&#39;s about a factor 5 away from cold cache sequential read speed.</p>

<h2>Trying a simpler problem</h2>
<p>At this point I thought it was unlikely I could squeeze a lot of performance out of the word frequency counter. Sure, there are cache misses in the hash map, so maybe it could be optimized for better cache locality of common words. Or potentially short words can benefit from perfect hashing on the stack. But what will that give? Another 20%?</p>
<p>Instead, let&#39;s look at an informative baseline. Just count words without keeping track of frequencies; no tedious hash maps.</p>

<p>In fact there&#39;s a program for that: <code>wc -w</code>. Such a single-purpose tool must be fast, right?</p>

<pre>$ time wc -w &lt; bible-100.txt &gt; /dev/null 

real    0m1.758s
user    0m1.718s
sys     0m0.040s
</pre>

<p>Unexpectedly the performance is terrible... <strong>245.2 MB/s</strong>. Why? Well, the man page says it&#39;s doing a different thing. The Ben Hoyt code only splits on <code>&#39; &#39;</code> whitespace, whereas <code>wc</code> uses <code>&#39; &#39;</code>, <code>&#39;\n&#39;</code>, <code>&#39;\t&#39;</code>, ... and even locale specific characters.</p>

<h3>How fast can word count be?</h3>
<p>If the premise is that disk speed has caught up in the last decade, we should really be using new CPU features from that period. And that basically means: vectorize all the things. AVX2 is almost a decade old already. AVX-512 was available for the common people in 2017, but I&#39;m on znver2, so I&#39;ll stick to AVX2.</p>
<p>Unfortunately, the compiler has a hard time autovectorizing word count. Maybe that proves the point of Ben Hoyt: disks got orders of magnitude faster &#34;for free&#34;, but modern compilers don&#39;t magically generate machine code orders of magnitude faster. It&#39;s just difficult to translate branchy scalar programs into vectorized machine code.</p>

<h3>Masks</h3>
<p>Part of word count can trivially be auto-vectorized: suppose for simplicity we have a register size of 128 bits, in which we can store 16 consecutive characters. It&#39;s easy to locate the whitespace by broadcasting it into a register ahead of time, and then doing a single <code>VPCMPEQB</code> comparsion operation:</p>
<pre>       | 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 |
input: | h o w   m a n y   w o r d s   a | r e   h e r e ?
 mask: | 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 |
</pre>

<p>But after getting a mask in a vector register, how do you go about and count words? The only thing
I could think of is using a <strong>Move Byte Mask</strong> trick I&#39;ve seen in <a href="https://github.com/jart/cosmopolitan/blob/b850b14300f112c238debf441746ef9ff93e8dba/libc/intrin/strlen.c#L32-L42">Cosmopolitan libc&#39;s <code> strlen</code> implementation</a>. The relevant instruction <code>PMOVMSKB</code> moves the long bit mask into a 32 bit <code>int</code>, and then you do your usual bit tricks.</p>

<h3>Bit tricks</h3>
<p>What are the usual bit tricks? One great candidate is <strong>Find First Set</strong> or <code>ffs</code> in short â€” this is a great name given how tedious it is to get bit tricks right. This instruction can be used to iterate over set bits, like so:</p>

<pre>#include &lt;stdio.h&gt;

int main() {
    int mask = 0b0100000100001000;
    int prev = 0;
    while (mask) {
        int curr = <strong>__builtin_ffs(mask);</strong>
        if (curr &gt; prev + 1)
            printf(&#34;Word start at %d\n&#34;, curr);
        prev = curr;
        if (curr == 32) <span>// don&#39;t ask, sigh.</span>
            break;
        <strong>mask = (mask &gt;&gt; curr) &lt;&lt; curr;</strong>
    }
}
</pre>
<p>It outputs the following, corresponding to the mask example above:</p>
<pre>Word start at 4
Word start at 9
Word start at 15
</pre>
<h3>Putting it together</h3>
<p>I ended up writing this code explicitly using <code>immintrin.h</code> which is an absolutely dreadful experience. Next time I&#39;ll use a high-level API (in the past I&#39;ve had a lot of fun vectorizing things interactively in the Julia REPL with <a href="https://github.com/JuliaSIMD/VectorizationBase.jl">VectorizationBase.jl</a>). But at least I felt like I had some control over the generated machine code.</p>
<p>Using AVX2 with 256-bit registers, you need to align your data on 32 bits, which I did (of course not without messing it up first). I reserved 6 of the registers to hold all broadcasted whitespace characters. Then I explicitly unrolled the vectorized loop 4 times, so in every iteration we process 128 bytes of data.</p>
<p>It took an awful lot of time to fix the off-by-one bugs, but in the end I managed to get a working program, tested against a non-zero amount of text files on my computer:</p>
<pre>$ ./wc-avx2 &lt; bible-100.txt 
82113300
$ wc -w &lt; bible-100.txt 
82113300
</pre>
<p>So, how fast?!</p>
<pre>$ time ./wc-avx2 &lt; bible-100.txt 
82113300

real    0m0.227s
user    0m0.186s
sys     0m0.041s
</pre>
<p>That comes down to <strong>1.45 GB/s</strong> (on a warm cache).</p>
<p>Sigh. So hand-optimized, single-threaded word count is only getting about 11% of the sequential disk read speed. And on a cold cache?</p>
<pre>$ sysctl -w vm.drop_caches=3
$ time ./wc-avx2 &lt; bible-100.txt
82113300

real    0m0.395s
user    0m0.196s
sys     0m0.117s
</pre>
<p>Still more time in <em>user</em> than <em>sys</em> :(. So yeah, maybe the disk speed has caught up statement is indeed true.</p>
<h3>Get the code</h3>
<p>I&#39;ve put my <a href="https://github.com/haampie/wc-avx2">code up on GitHub</a>. If you know better bit-tricks, feel free to submit a pull request.</p>
</section>
</div></div>
  </body>
</html>
