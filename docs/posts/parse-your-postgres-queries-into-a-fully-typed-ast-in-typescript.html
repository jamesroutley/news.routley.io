<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/pg-nano/pg-parser">Original</a>
    <h1>Show HN: Parse your Postgres queries into a fully-typed AST in TypeScript</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A fork of <a href="https://github.com/launchql/libpg-query-node">libpg-query</a> with best-in-class type definitions and AST utilities.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { parseQuery } from &#34;@pg-nano/pg-parser&#34;

const ast = await parseQuery(&#34;SELECT 1; SELECT 2&#34;)
//    ^? ParseResult

ast.version // =&gt; 160001
ast.stmts // =&gt; [{ stmt: SelectStmt, stmt_len: 8 }, { stmt: SelectStmt, stmt_location: 9 }]"><pre><span>import</span> <span>{</span> <span>parseQuery</span> <span>}</span> <span>from</span> <span>&#34;@pg-nano/pg-parser&#34;</span>

<span>const</span> <span>ast</span> <span>=</span> <span>await</span> <span>parseQuery</span><span>(</span><span>&#34;SELECT 1; SELECT 2&#34;</span><span>)</span>
<span>//    ^? ParseResult</span>

<span>ast</span><span>.</span><span>version</span> <span>// =&gt; 160001</span>
<span>ast</span><span>.</span><span>stmts</span> <span>// =&gt; [{ stmt: SelectStmt, stmt_len: 8 }, { stmt: SelectStmt, stmt_location: 9 }]</span></pre></div>

<div data-snippet-clipboard-copy-content="pnpm add @pg-nano/pg-parser"><pre><code>pnpm add @pg-nano/pg-parser
</code></pre></div>
<p dir="auto">The major and minor version of this package is meant to be aligned with the supported PostgreSQL major and minor version. Older and newer versions may be compatible, but this is not guaranteed.</p>
<p dir="auto">Upon install, the pre-compiled binary for your operating system and architecture will be pulled from GitHub Releases.</p>

<p dir="auto">This package exports the following functions:</p>
<ul dir="auto">
<li><code>parseQuery</code> (for async parsing a SQL string of one or more statements)</li>
<li><code>parseQuerySync</code></li>
<li><code>parsePlPgSQL</code> (for async parsing a plpgsql string)</li>
<li><code>parsePlPgSQLSync</code></li>
<li><code>fingerprint</code> (for generating a unique string for a SQL string)</li>
<li><code>fingerprintSync</code></li>
<li><code>splitWithScannerSync</code> (for splitting a SQL string into one or more statements)</li>
<li><code>walk</code> (for traversing the AST)</li>
<li><code>select</code> (for type-safe, deep field access through dot-notation)</li>
<li><code>$</code> (for type-safe node proxy and type guards)</li>
</ul>
<p dir="auto"><strong>Note:</strong> There is no <code>deparse</code> function (for turning an AST back into a string) included, as this isn&#39;t needed for my use case.</p>

<p dir="auto">I&#39;ve added a <code>walk</code> function for easy AST traversal. You can pass a callback or a visitor object. You can return false to not walk into the children of the current node.</p>
<p dir="auto">Each node passed to your visitor is wrapped in a <code>NodePath</code> instance, which tracks the parent node and provides type guards (e.g. <code>isSelectStmt</code>) for type narrowing. You can access the underlying node with <code>path.node</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { parseQuerySync, walk, NodeTag } from &#34;@pg-nano/pg-parser&#34;

walk(parseQuerySync(sql), (path) =&gt; {
  path.tag // string
  path.node // the node object
  path.parent // the parent node

  if (path.isSelectStmt()) {
    // The visitor pattern is also supported.
    walk(path.node.targetList, {
      ColumnRef(path) {
        const id = path.node.fields
          .map((f) =&gt; (NodeTag.isString(f) ? f.String.sval : &#34;*&#34;))
          .join(&#34;.&#34;)

        console.log(id)
      },
    })

    // don&#39;t walk into the children
    return false
  }
})"><pre><span>import</span> <span>{</span> <span>parseQuerySync</span><span>,</span> <span>walk</span><span>,</span> <span>NodeTag</span> <span>}</span> <span>from</span> <span>&#34;@pg-nano/pg-parser&#34;</span>

<span>walk</span><span>(</span><span>parseQuerySync</span><span>(</span><span>sql</span><span>)</span><span>,</span> <span>(</span><span>path</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>path</span><span>.</span><span>tag</span> <span>// string</span>
  <span>path</span><span>.</span><span>node</span> <span>// the node object</span>
  <span>path</span><span>.</span><span>parent</span> <span>// the parent node</span>

  <span>if</span> <span>(</span><span>path</span><span>.</span><span>isSelectStmt</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>// The visitor pattern is also supported.</span>
    <span>walk</span><span>(</span><span>path</span><span>.</span><span>node</span><span>.</span><span>targetList</span><span>,</span> <span>{</span>
      <span>ColumnRef</span><span>(</span><span>path</span><span>)</span> <span>{</span>
        <span>const</span> <span>id</span> <span>=</span> <span>path</span><span>.</span><span>node</span><span>.</span><span>fields</span>
          <span>.</span><span>map</span><span>(</span><span>(</span><span>f</span><span>)</span> <span>=&gt;</span> <span>(</span><span>NodeTag</span><span>.</span><span>isString</span><span>(</span><span>f</span><span>)</span> ? <span>f</span><span>.</span><span>String</span><span>.</span><span>sval</span> : <span>&#34;*&#34;</span><span>)</span><span>)</span>
          <span>.</span><span>join</span><span>(</span><span>&#34;.&#34;</span><span>)</span>

        <span>console</span><span>.</span><span>log</span><span>(</span><span>id</span><span>)</span>
      <span>}</span><span>,</span>
    <span>}</span><span>)</span>

    <span>// don&#39;t walk into the children</span>
    <span>return</span> <span>false</span>
  <span>}</span>
<span>}</span><span>)</span></pre></div>
<p dir="auto">I&#39;ve also added a <code>select</code> function for type-safe, deep field access through dot-notation. You must not include the node types in the field path.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { select, Expr } from &#34;@pg-nano/pg-parser&#34;

/**
 * Given an expression node of many possible types,
 * check for a `typeName` field.
 */
const typeName = select(expr as Expr, &#39;typeName&#39;)
//    ^? TypeName | undefined"><pre><span>import</span> <span>{</span> <span>select</span><span>,</span> <span>Expr</span> <span>}</span> <span>from</span> <span>&#34;@pg-nano/pg-parser&#34;</span>

<span>/**</span>
<span> * Given an expression node of many possible types,</span>
<span> * check for a `typeName` field.</span>
<span> */</span>
<span>const</span> <span>typeName</span> <span>=</span> <span>select</span><span>(</span><span>expr</span> <span>as</span> <span>Expr</span><span>,</span> <span>&#39;typeName&#39;</span><span>)</span>
<span>//    ^? TypeName | undefined</span></pre></div>
<p dir="auto">Similar to <code>select</code>, you may like the <code>$</code> function for field access. It returns a proxy that makes field access less verbose. It also comes with type guards for all nodes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { $, walk } from &#34;@pg-nano/pg-parser&#34;

walk(ast, {
  SelectStmt(path) {
    for (const target of path.node.targetList) {
      const { name, val } = $(target)

      if ($.isColumnRef(val)) {
        console.log(
          name,
          $(val).fields.map(field =&gt; {
            return $.isA_Star(field) ? &#34;*&#34; : field.String.sval
          }).join(&#34;.&#34;),
        )
      }
    }
  }
})"><pre><span>import</span> <span>{</span> <span>$</span><span>,</span> <span>walk</span> <span>}</span> <span>from</span> <span>&#34;@pg-nano/pg-parser&#34;</span>

<span>walk</span><span>(</span><span>ast</span><span>,</span> <span>{</span>
  <span>SelectStmt</span><span>(</span><span>path</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>target</span> <span>of</span> <span>path</span><span>.</span><span>node</span><span>.</span><span>targetList</span><span>)</span> <span>{</span>
      <span>const</span> <span>{</span> name<span>,</span> val <span>}</span> <span>=</span> <span>$</span><span>(</span><span>target</span><span>)</span>

      <span>if</span> <span>(</span><span>$</span><span>.</span><span>isColumnRef</span><span>(</span><span>val</span><span>)</span><span>)</span> <span>{</span>
        <span>console</span><span>.</span><span>log</span><span>(</span>
          <span>name</span><span>,</span>
          <span>$</span><span>(</span><span>val</span><span>)</span><span>.</span><span>fields</span><span>.</span><span>map</span><span>(</span><span>field</span> <span>=&gt;</span> <span>{</span>
            <span>return</span> <span>$</span><span>.</span><span>isA_Star</span><span>(</span><span>field</span><span>)</span> ? <span>&#34;*&#34;</span> : <span>field</span><span>.</span><span>String</span><span>.</span><span>sval</span>
          <span>}</span><span>)</span><span>.</span><span>join</span><span>(</span><span>&#34;.&#34;</span><span>)</span><span>,</span>
        <span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span></pre></div>

<p dir="auto">Every possible type that could be returned from libpg_query is defined in <a href="https://github.com/pg-nano/pg-parser/blob/16-latest/src/lib/ast.ts">ast.ts</a>. If a type is missing, it&#39;s probably because libpg_query didn&#39;t tell us about it (otherwise, please <a href="https://github.com/pg-nano/pg-parser/issues">file an issue</a>).</p>
<p dir="auto">The type definitions are generated from the <a href="https://github.com/pganalyze/libpg_query/tree/16-latest/srcdata">srcdata</a> of <code>libpg_query</code> (the C library this package binds to). If you&#39;re interested in how they&#39;re generated, see <a href="https://github.com/pg-nano/pg-parser/blob/16-latest/scripts/generateTypes.ts">scripts/generateTypes.ts</a> and <a href="https://github.com/pg-nano/pg-parser/blob/16-latest/scripts/inferFieldMetadata.ts">scripts/inferFieldMetadata.ts</a>. For some cases, type definitions are manually specified in <a href="https://github.com/pg-nano/pg-parser/blob/16-latest/scripts/typeMappings.ts">scripts/typeMappings.ts</a>.</p>

<ul dir="auto">
<li>Uses <code>prebuild-install</code> to avoid bundling every platform&#39;s binaries into the package.</li>
<li>Added <code>splitWithScannerSync</code> for SQL statement splitting.</li>
<li><a href="https://github.com/pg-nano/pg-parser/blob/16-latest/scripts/generateTests.ts">Generated</a> unit tests (see <a href="https://github.com/pg-nano/pg-parser/tree/16-latest/test/postgres_regress/__snapshots__">snapshots</a> of every SQL case supported by <code>libpg_query</code>).</li>
</ul>

<p dir="auto">To generate the type definitions, you can use this command:</p>

<p dir="auto">To compile the TypeScript bindings and the C++ addon (and recompile them on file changes), you can use this command:</p>

<p dir="auto">Otherwise, <code>pnpm build</code> will compile just once.</p>
<p dir="auto">If you&#39;re editing C++ code, you&#39;ll want to have <a href="https://github.com/nickdiego/compiledb">compiledb</a> installed and the <a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd" rel="nofollow">clangd extension</a> in VSCode. This enables the <code>clangd</code> language server for features like autocomplete, static analysis, and code navigation.</p>

<p dir="auto"><strong><g-emoji alias="warning">⚠️</g-emoji> Windows support:</strong> The <code>binding.gyp</code> file is currently broken for Windows builds. Any help would be appreciated!</p>

<p dir="auto">MIT</p>
</article></div></div>
  </body>
</html>
