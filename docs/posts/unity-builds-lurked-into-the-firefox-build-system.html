<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serge-sans-paille.github.io/pythran-stories/how-unity-builds-lurked-into-the-firefox-build-system.html">Original</a>
    <h1>Unity builds lurked into the Firefox Build System</h1>
    
    <div id="readability-page-1" class="page"><div id="unity-build">
<h2>Unity Build</h2>
<p><a href="https://en.wikipedia.org/wiki/Unity_build">Unity builds</a>, a.k.a. unified build or jumbo builds, is a technique that consists in
concatenating several C or C++ files in one before invoking the compiler. This generally
leads to faster compilation time in part because it aggregates the cost of parsing the
same headers over and over.</p>
<p>It is one of the many approach one can use to reduce C++ software compilation
time, alongside precompiled headers and C++20 modules.</p>
<p>It is not an obscure technique: it&#39;s officially supported by CMake through
<tt>CMAKE_UNITY_BUILD</tt> (see
<a href="https://cmake.org/cmake/help/latest/variable/CMAKE_UNITY_BUILD.html">https://cmake.org/cmake/help/latest/variable/CMAKE_UNITY_BUILD.html</a>).</p>
<p>At some point, the Chromium project supported doing jumbo builds:
<a href="https://chromium.googlesource.com/chromium/src.git/+/65.0.3283.0/docs/jumbo.md">https://chromium.googlesource.com/chromium/src.git/+/65.0.3283.0/docs/jumbo.md</a>,
even if it got rid of it afterward
<a href="https://groups.google.com/a/chromium.org/g/chromium-dev/c/DP9TQszzQLI">https://groups.google.com/a/chromium.org/g/chromium-dev/c/DP9TQszzQLI</a></p>
<p>It is also supported by the internal build system used at Mozilla. And the
speedup is there, a unified build (the default) runs twice as fast as an hybrid
build (<tt><span>--disable-unified-build</span></tt>) on my setup. As a side effect, in pre-LTO
area, this also led to better performance as it makes more information available
to the compiler.</p>
<p>Wait, did I write <em>hybrid build</em> and not <em>regular build</em>? As it turns out, under
<tt><span>--disable-unified-build</span></tt> some parts of Firefox are still built in unified
mode, because they <strong>require it</strong>, probably for historical reason.</p>
<p>It&#39;s great to be able to do a unified build. It&#39;s not great to have a codebase
that does not compile unless you have a unity build: static analyzers are not
used to work on non-self contained sources (see <a href="https://github.com/clangd/clangd/issues/45">https://github.com/clangd/clangd/issues/45</a>), unity build implies a slight overhead during
incremental builds. What makes it worse is that developer start to rely on
unified build and get lazy in the way they develop.</p>
</div><div id="jumbo-build-creeps">
<h2>Jumbo Build Creeps</h2>
<p>In the following we assume <tt>a.cpp</tt> and <tt>b.cpp</tt> are jumbo built as</p>
<div><pre><span></span><span>// jumbo.cpp</span>
<span>#include</span><span> </span><span>&#34;a.cpp&#34;</span>
<span>#include</span><span> </span><span>&#34;b.cpp&#34;</span>
</pre></div>
<p>Let&#39;s have fun while collecting some of the cases found in the Firefox codebase
while removing the unify build requirement.</p>
<div id="skipping-includes">
<h3>Skipping includes</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>void</span><span> </span><span>foo</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>// b.cpp</span>
<span>void</span><span> </span><span>bar</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>
</pre></div>
<p>Indeed, why including a header when another compilation unit that comes <em>before</em> you in
the unified build is including it?</p>
</div>
<div id="accessing-static-functions">
<h3>Accessing static functions</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>static</span><span> </span><span>void</span><span> </span><span>foo</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>// b.cpp</span>
<span>void</span><span> </span><span>bar</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>foo</span><span>();</span>
<span>}</span>
</pre></div>
<p>Isn&#39;t that a good property to be able to access a function that&#39;s meant to be
private?</p>
</div>
<div id="trying-to-be-smart-with-macro">
<h3>Trying to be smart with macro</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>#define FOO 1</span>

<span>// b.cpp</span>
<span>#ifdef FOO</span>
<span>  </span><span>#define BAR</span>
<span>#endif</span>
</pre></div>
<p>Defining a macro in one compilation unit and have it affect another compilation
unit has been a real nightmare.</p>
</div>
<div id="static-templates">
<h3>Static templates</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>template</span><span> </span><span>&lt;</span><span>typename</span><span> </span><span>T</span><span>&gt;</span>
<span>void</span><span> </span><span>foo</span><span>(</span><span>T</span><span> </span><span>const</span><span>&amp;</span><span> </span><span>arg</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>arg</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>void</span><span> </span><span>bar</span><span>(</span><span>int</span><span> </span><span>i</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>foo</span><span>(</span><span>i</span><span>);</span>
<span>}</span>
</pre></div>
<p>Isn&#39;t it great when you don&#39;t need to put your template definition in the
header? Static visibility for templates <tt><span>:-)</span></tt>.</p>
</div>
<div id="template-specialization">
<h3>Template specialization</h3>
<div><pre><span></span><span>// foobar.h</span>
<span>#ifndef FOOBAR_H</span>
<span>#define FOOBAR_H</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>template</span><span> </span><span>&lt;</span><span>typename</span><span> </span><span>T</span><span>&gt;</span>
<span>void</span><span> </span><span>foobar</span><span>(</span><span>T</span><span> </span><span>arg</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>arg</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>
<span>#endif</span>

<span>// a.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>template</span><span> </span><span>&lt;&gt;</span>
<span>void</span><span> </span><span>foobar</span><span>&lt;</span><span>int</span><span>&gt;</span><span>(</span><span>int</span><span> </span><span>arg</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>std</span><span>::</span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;int: &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>arg</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>void</span><span> </span><span>bar</span><span>(</span><span>int</span><span> </span><span>i</span><span>)</span><span> </span><span>{</span>
<span>  </span><span>foobar</span><span>(</span><span>i</span><span>);</span>
<span>}</span>
</pre></div>
<p>This one is terrible, because it doesn&#39;t give any compile time error, but a
runtime error <tt><span>:-/</span></tt>.</p>
</div>
<div id="leaking-using-namespace">
<h3>Leaking using namespace</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>using</span><span> </span><span>namespace</span><span> </span><span>std</span><span>;</span>

<span>void</span><span> </span><span>foo</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>void</span><span> </span><span>bar</span><span>()</span><span> </span><span>{</span>
<span>  </span><span>cout</span><span> </span><span>&lt;&lt;</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>std</span><span>::</span><span>endl</span><span>;</span>
<span>}</span>
</pre></div>
<p>You can use symbols from namespace used from other compilation unit. That&#39;s
exactly the same problem as leaking macro or static definitions: it breaks the
compilation unit scope.</p>
</div>

<div id="putting-constant-initializer-in-implementation">
<h3>Putting constant initializer in implementation</h3>
<div><pre><span></span><span>// foobar.h</span>
<span>#ifndef FOOBAR_H</span>
<span>#define FOOBAR_H</span>
<span>struct</span><span> </span><span>foo</span><span> </span><span>{</span>
<span>static</span><span> </span><span>const</span><span> </span><span>int</span><span> </span><span>VALUE</span><span>;</span>
<span>};</span>
<span>#endif</span>

<span>// a.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>const</span><span> </span><span>int</span><span> </span><span>foo</span><span>::</span><span>VALUE</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>static_assert</span><span>(</span><span>foo</span><span>::</span><span>VALUE</span><span> </span><span>==</span><span> </span><span>1</span><span>,</span><span> </span><span>&#34;ok&#34;</span><span>);</span>
</pre></div>
<p>The constant expression lacks its initializer.</p>
</div>
<div id="error-about-functions-without-a-valid-declarations-get-silented">
<h3>Error about functions without a valid declarations get silented</h3>
<div><pre><span></span><span>// foobar.h</span>
<span>#ifndef FOOBAR_H</span>
<span>#define FOOBAR_H</span>
<span>void</span><span> </span><span>foo</span><span>(</span><span>int</span><span> </span><span>*</span><span> </span><span>ptr</span><span>);</span>
<span>#endif</span>

<span>// a.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>void</span><span> </span><span>foo</span><span>(</span><span>const</span><span> </span><span>int</span><span> </span><span>*</span><span> </span><span>ptr</span><span>)</span><span> </span><span>{</span>
<span>}</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&#34;foobar.h&#34;</span>
<span>void</span><span> </span><span>bar</span><span>(</span><span>const</span><span> </span><span>int</span><span> </span><span>*</span><span> </span><span>ptr</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>return</span><span> </span><span>foo</span><span>(</span><span>ptr</span><span>);</span>
<span>}</span>
</pre></div>
<p>Invalid forward declaration but who cares, when the definition can be found and
the compiler doesn&#39;t warn about unused forward declaration?</p>
</div>
<div id="unexpected-aspect-less-warnings">
<h3>Unexpected aspect: less warnings</h3>
<div><pre><span></span><span>// a.cpp</span>
<span>static</span><span> </span><span>int</span><span> </span><span>foo</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span>

<span>// b.cpp</span>
<span>#include</span><span> </span><span>&#34;a.cpp&#34;</span>
</pre></div>
<p>Compiling <tt>a.cpp</tt> yields an unused warning, but not compiling <tt>b.cpp</tt>. So
hybrid builds relying on <tt>#including</tt> multiple sources actually decrease the
warning level.</p>
</div>

</div><div id="about-the-firefox-codebase">
<h2>About the Firefox codebase</h2>
<p>The removal of <tt>REQUIRES_UNIFIED_BUILD</tt> across the Firefox codebase was
tracked under <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1626530">https://bugzilla.mozilla.org/show_bug.cgi?id=1626530</a>. Since I
focused on this, I&#39;ve landed more than 150 commits, modifying more than 800
sources files. And it&#39;s now done, no more hard requirement of unified build,
back to a normal situation.</p>
<p>Was it worth the effort? Yes: it prevents bad coding practices, and static
analysis is now more useful compared to what it could do with unified builds.</p>
<p>And we&#39;re sure we won&#39;t regress as our CI now builds in both unified and non-unified mode!</p>
<div id="acknowledgments">
<h3>Acknowledgments</h3>
<p>Thanks to Paul Adenot for proof-reading this blog post and to Andi-Bogdan
Postelnicu for reviewing most of the commits mentioned above.</p>
</div>
</div></div>
  </body>
</html>
