<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/golang/go/issues/73608">Original</a>
    <h1>Proposal: Add bare metal support to Go</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <h3 dir="auto">Proposal Details</h3>
<p dir="auto">I propose the addition of a new <code>GOOS</code> target, such as <code>GOOS=none</code>, to allow Go runtime execution under specific application defined exit functions, rather than arbitrary OS syscalls, enabling freestanding execution without direct OS support.</p>
<p dir="auto">This is currently implemented in the <a href="https://github.com/usbarmory/tamago"><code>GOOS=tamago</code></a> project, but for reasons laid out in the <em>Proposal Background</em> section it is proposed for upstream inclusion.</p>
<p dir="auto">Go applications built with <code>GOOS=none</code> would run on bare metal, without any underlying OS. All required support is provided by the Go runtime and external driver packages, also written in Go.</p>
<h4 dir="auto">Go runtime changes</h4>
<p dir="auto">A working example of all proposed changes can be found in the <a href="https://github.com/golang/go/compare/go1.24.0..usbarmory:tamago1.24.0"><code>GOOS=tamago</code> implementation</a>.</p>
<p dir="auto">Board support packages or applications would be required (only under <code>GOOS=none</code>) to define the following functions to support the runtime.</p>
<p dir="auto">If the use of <code>go:linkname</code> is undesirable different strategies are possible, right now linkname is used as convenient way to have externally defined functions being directly invoked in the runtime early on.</p>
<ul dir="auto">
<li><code>cpuinit</code> (<a href="https://github.com/usbarmory/tamago/blob/master/arm/init.s">example</a>): pre-runtime CPU initialization</li>
</ul>
<div data-snippet-clipboard-copy-content="// cpuinit handles pre-runtime CPU initialization
TEXT cpuinit(SB),NOSPLIT|NOFRAME,$0"><pre><code>// cpuinit handles pre-runtime CPU initialization
TEXT cpuinit(SB),NOSPLIT|NOFRAME,$0
</code></pre></div>
<p dir="auto">The function is required to be defined in assembly as pre-runtime there is lack for support of native Go statements.</p>
<ul dir="auto">
<li><code>runtime.hwinit</code> (<a href="https://github.com/usbarmory/tamago/blob/ddfbc731f2109decd29bc848b7e13aaa19a4c59d/board/cloud_hypervisor/vm/vm.go#L83">example</a>): early runtime hardware initialization</li>
</ul>
<div data-snippet-clipboard-copy-content="// Init takes care of the lower level initialization triggered early in runtime
// setup.
//
//go:linkname Init runtime.hwinit
func Init()"><pre><code>// Init takes care of the lower level initialization triggered early in runtime
// setup.
//
//go:linkname Init runtime.hwinit
func Init()
</code></pre></div>
<ul dir="auto">
<li><code>runtime.printk</code> (<a href="https://github.com/usbarmory/tamago/blob/ddfbc731f2109decd29bc848b7e13aaa19a4c59d/board/firecracker/microvm/console.go#L17">example</a>): standard output (e.g. serial console)</li>
</ul>
<div data-snippet-clipboard-copy-content="// printk emits a single 8-bit character to standard output
//
//go:linkname printk runtime.printk
func printk(c byte)"><pre><code>// printk emits a single 8-bit character to standard output
//
//go:linkname printk runtime.printk
func printk(c byte)
</code></pre></div>
<ul dir="auto">
<li><code>runtime.initRNG</code> and <code>runtime.getRandomData</code> (<a href="https://github.com/usbarmory/tamago/blob/master/amd64/rng.go">examples</a>): random number generation initialization and retrieval</li>
</ul>
<div data-snippet-clipboard-copy-content="// initRNG initializes random number generation
//
//go:linkname initRNG runtime.initRNG
func initRNG()

// getRandomData generates len(b) random bytes and writes them into b
//
//go:linkname getRandomData runtime.getRandomData
func getRandomData(b []byte) "><pre><code>// initRNG initializes random number generation
//
//go:linkname initRNG runtime.initRNG
func initRNG()

// getRandomData generates len(b) random bytes and writes them into b
//
//go:linkname getRandomData runtime.getRandomData
func getRandomData(b []byte) 
</code></pre></div>
<ul dir="auto">
<li><code>runtime.nanotime1</code> (<a href="https://github.com/usbarmory/tamago/blob/ddfbc731f2109decd29bc848b7e13aaa19a4c59d/board/qemu/microvm/microvm.go#L86">example</a>): system time in nanoseconds</li>
</ul>
<div data-snippet-clipboard-copy-content="// nanotime1 returns the system time in nanoseconds
//
//go:linkname nanotime1 runtime.nanotime1
func nanotime1() int64"><pre><code>// nanotime1 returns the system time in nanoseconds
//
//go:linkname nanotime1 runtime.nanotime1
func nanotime1() int64
</code></pre></div>
<ul dir="auto">
<li><code>runtime.ramStart</code> (<a href="https://github.com/usbarmory/tamago/blob/master/amd64/mem.go">example</a>), <code>runtime.ramSize</code> (<a href="https://github.com/usbarmory/tamago/blob/master/board/cloud_hypervisor/vm/mem.go">example</a>) and <code>runtime.ramStackOffset</code> (<a href="https://github.com/usbarmory/tamago/blob/ddfbc731f2109decd29bc848b7e13aaa19a4c59d/amd64/amd64.go#L32">example</a>): RAM layout</li>
</ul>
<div data-snippet-clipboard-copy-content="//go:linkname ramStart runtime.ramStart
var ramStart uint

//go:linkname ramSize runtime.ramSize
var ramSize uint

//go:linkname ramStackOffset runtime.ramStackOffset
var ramStackOffset uint"><pre><code>//go:linkname ramStart runtime.ramStart
var ramStart uint

//go:linkname ramSize runtime.ramSize
var ramSize uint

//go:linkname ramStackOffset runtime.ramStackOffset
var ramStackOffset uint
</code></pre></div>
<p dir="auto">Board support packages or applications can optionally define the following:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>runtime.Bloc</code> (<a href="https://github.com/usbarmory/tamago/blob/master/user/linux/runtime.go">example</a>): heap memory start address override</p>
</li>
<li>
<p dir="auto"><code>runtime.Exit</code> (<a href="https://github.com/usbarmory/tamago/blob/development/amd64/amd64.go">example</a>): runtime termination</p>
</li>
<li>
<p dir="auto"><code>runtime.Idle</code> (<a href="https://github.com/usbarmory/tamago/blob/development/amd64/amd64.go">example</a>): CPU idle time management</p>
</li>
<li>
<p dir="auto">Network I/O through Go own net package requires the application to set an external <code>Socket</code> function (<a href="https://github.com/usbarmory/tamago-go/blob/latest/src/net/net_tamago.go">example</a>, <a href="https://github.com/usbarmory/virtio-net">driver example</a>):</p>
</li>
</ul>
<div data-snippet-clipboard-copy-content="// SocketFunc must be set externally by the application on GOOS=tamago to
// provide the network socket implementation. The returned interface must match
// the requested socket and be either net.Conn, net.PacketConn or net.Listen.
var SocketFunc func(ctx context.Context, net string, family, sotype int, laddr, raddr Addr) (interface{}, error)"><pre><code>// SocketFunc must be set externally by the application on GOOS=tamago to
// provide the network socket implementation. The returned interface must match
// the requested socket and be either net.Conn, net.PacketConn or net.Listen.
var SocketFunc func(ctx context.Context, net string, family, sotype int, laddr, raddr Addr) (interface{}, error)
</code></pre></div>
<p dir="auto">The Go runtime would implement the following, or similar, functions to aid <a href="https://github.com/usbarmory/tamago/wiki/Internals#interrupts">interrupt handling</a>:</p>
<ul dir="auto">
<li><code>runtime.GetG</code> (<a href="https://github.com/usbarmory/tamago-go/blob/5c4fec31ec47505b849b2d2abd4b13a84c9d1065/src/runtime/sys_tamago_amd64.s#L145">example</a>), <code>runtime.WakeG</code> (<a href="https://github.com/usbarmory/tamago-go/blob/e944e99653b23cfa0c3aa0bf7365a71f627033db/src/runtime/sys_tamago_amd64.s#L188">example</a>), <code>runtime.Wake</code> (<a href="https://github.com/usbarmory/tamago-go/blob/5c4fec31ec47505b849b2d2abd4b13a84c9d1065/src/runtime/sys_tamago_amd64.s#L247">example</a>): asynchronous goroutine wake-up</li>
</ul>
<div data-snippet-clipboard-copy-content="// GetG returns the pointer to the current G and its P.
func GetG() (gp uint64, pp uint64)

// WakeG modifies a goroutine cached timer for time.Sleep (g.timer) to fire as
// soon as possible.
//
// The function is meant to be invoked within Go assembly and its arguments
// must be passed through registers rather than on the frame pointer, see
// definition in sys_tamago_$GOARCH.s for details.
func WakeG()

// Wake modifies a goroutine cached timer for time.Sleep (g.timer) to fire as
// soon as possible.
func Wake(gp uint)"><pre><code>// GetG returns the pointer to the current G and its P.
func GetG() (gp uint64, pp uint64)

// WakeG modifies a goroutine cached timer for time.Sleep (g.timer) to fire as
// soon as possible.
//
// The function is meant to be invoked within Go assembly and its arguments
// must be passed through registers rather than on the frame pointer, see
// definition in sys_tamago_$GOARCH.s for details.
func WakeG()

// Wake modifies a goroutine cached timer for time.Sleep (g.timer) to fire as
// soon as possible.
func Wake(gp uint)
</code></pre></div>
<h4 dir="auto">Compilation</h4>
<p dir="auto">The compilation of such targets would remain identical to standard Go binaries, while the loading strategy might differ depending on the hardware but anyway be handled in a manner completely external to the Go distribution, using standard flags as required, examples:</p>
<div data-snippet-clipboard-copy-content="# Example for Cloud Hypervisory, QEMU and Firecracker KVMs
GOOS=tamago GOARCH=amd64 ${TAMAGO} build -ldflags &#34;-T 0x10010000 -R 0x1000&#34; main.go

# Example for USB armory Mk II
GOOS=tamago GOARM=7 GOARCH=arm ${TAMAGO} build -ldflags &#34;-T 0x80010000 -R 0x1000&#34; main.go

# Example for QEMU RISC-V sifive_u
GOOS=tamago GOARCH=riscv64 ${TAMAGO} build -ldflags &#34;-T 0x80010000 -R 0x1000&#34; main.go

# Example for Linux userspace
GOOS=tamago ${TAMAGO} build main.go"><pre><code># Example for Cloud Hypervisory, QEMU and Firecracker KVMs
GOOS=tamago GOARCH=amd64 ${TAMAGO} build -ldflags &#34;-T 0x10010000 -R 0x1000&#34; main.go

# Example for USB armory Mk II
GOOS=tamago GOARM=7 GOARCH=arm ${TAMAGO} build -ldflags &#34;-T 0x80010000 -R 0x1000&#34; main.go

# Example for QEMU RISC-V sifive_u
GOOS=tamago GOARCH=riscv64 ${TAMAGO} build -ldflags &#34;-T 0x80010000 -R 0x1000&#34; main.go

# Example for Linux userspace
GOOS=tamago ${TAMAGO} build main.go
</code></pre></div>
<h3 dir="auto">Proposal Background</h3>
<p dir="auto">This proposal follows updates on the <a href="https://github.com/usbarmory/tamago">TamaGo</a> project, which brings bare metal execution for Go on AMD64, ARM and RISCV64 targets.</p>
<p dir="auto">While similar proposals (see <a href="https://github.com/golang/go/issues/37503" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/37503/hovercard">#37503</a> and <a href="https://github.com/golang/go/issues/46802" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/46802/hovercard">#46802</a>) have been already attempted without success, this last effort is motivated by considerable advancements and changes in our effort.</p>
<p dir="auto">Notable changes:</p>
<ol dir="auto">
<li>
<p dir="auto">There is now fully tested Go standard library support, integrated with vanilla <a href="https://github.com/usbarmory/tamago/wiki/Compatibility">distribution tests</a>. The <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/testing/testing_tamago.go">testing environment</a> for <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/testing/testing_tamago_amd64.s">AMD64</a>, <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/testing/testing_tamago_arm.s">ARM</a> and <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/testing/testing_tamago_riscv64.s">RISCV64</a> architectures runs under Linux natively or using <a href="https://www.qemu.org/docs/master/user/main.html" rel="nofollow">qemu-user-static</a> via <a href="https://docs.kernel.org/admin-guide/binfmt-misc.html" rel="nofollow">binfmt_misc</a>.</p>
</li>
<li>
<p dir="auto">The <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/net/net_tamago.go">tamago networking code</a> allows <a href="https://github.com/usbarmory/tamago-go/blob/717b5d0a53f94b4f67e0d7230a4350e35d53615f/src/net/net_tamago.go#L21">external definition of a single socket function</a> to <a href="https://github.com/usbarmory/virtio-net/blob/dee249bb70edf57b31385b93dce577b615a95b36/runtime.go#L23">attach gVisor</a> or any other fake networking stack if desired, this could benefit other Go architectures and allow replacement of existing <a href="https://github.com/golang/go/blob/go1.24.0/src/net/net_fake.go">fake networking for js/wasip1</a>.</p>
</li>
<li>
<p dir="auto">Because of what implemented to support 1. and 2. <code>GOOS=tamago</code> allows the execution of unmodified Go applications as softly isolated <a href="https://github.com/usbarmory/tamago/wiki#userspace-targets">userspace code</a> with OS resources, such as networking and filesystems, isolated from the actual user OS.</p>
</li>
<li>
<p dir="auto">TamaGo now no longer focuses only on ARM embedded systems, but it extends to AMD64 KVM execution such as <a href="https://github.com/usbarmory/tamago/wiki#supported-amd64-targets">microVMs</a>.</p>
</li>
<li>
<p dir="auto">The overall Go distribution changes are free from hardware dependent code (e.g. peripheral drivers) and changes are unified across different architectures, see for instance the identical implementation for entry points of <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/runtime/rt0_tamago_amd64.s">amd64</a>, <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/runtime/rt0_tamago_arm.s">arm</a>, <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/runtime/rt0_tamago_riscv64.s">riscv64</a> architectures.</p>
</li>
</ol>
<p dir="auto">In summary <code>GOOS=tamago</code> has been transformed to a generic implementation that allows execution without relying on operating system calls but rather with a <a href="https://github.com/usbarmory/tamago/wiki/Internals#go-runtime-changes">unified &#34;outside world&#34; exit interface</a>, whether implemented for <a href="https://github.com/usbarmory/tamago-go/blob/tamago1.24.0/src/testing/testing_tamago.go">testing</a>, <a href="https://github.com/usbarmory/tamago?tab=readme-ov-file#userspace-targets">userspace execution</a>, <a href="https://github.com/usbarmory/tamago?tab=readme-ov-file#supported-arm-targets">real hardware</a> or <a href="https://github.com/usbarmory/tamago?tab=readme-ov-file#supported-amd64-targets">paravirtualization</a>.</p>
<p dir="auto">On ARM we implemented <a href="https://github.com/usbarmory/armory-boot">bootloaders</a>, <a href="https://github.com/usbarmory/GoTEE">Trusted Execution Environments</a> and full secure <a href="https://github.com/transparency-dev/armored-witness">OS and applets</a> with this framework.</p>
<p dir="auto">Thanks to a recent <a href="https://github.com/usbarmory/tamago/tree/master/amd64">amd64 port</a>, we enabled Pure Go KVMs under <a href="https://github.com/usbarmory/tamago/tree/master/board/cloud_hypervisor/vm">Cloud Hypervisor</a>, <a href="https://github.com/usbarmory/tamago/tree/master/board/firecracker/microvm">Firecracker</a> and <a href="https://github.com/usbarmory/tamago/tree/master/board/qemu/microvm">QEMU</a>.</p>
<p dir="auto">This also allowed us to implemented <a href="https://github.com/usbarmory/go-boot/">execution under UEFI</a> which enabled 100% Go EFI applications and bootloaders such as <a href="https://github.com/usbarmory/go-boot/">go-boot</a> (which currently booted Linux on the Thinkpad I am writing from).</p>
<p dir="auto">We think adopting these compact Go distribution changes would allow not only preservation of this ecosystem but expansion and innovation of the Go language as a whole, taking it to surprising, unxpected, yet ideal, environments.</p>
<p dir="auto">The cost of maintaining the patch is, in our opinion, reasonable and if anything beneficial in improving the Go abstraction across architectures and OS specific components.</p>
<p dir="auto">The only component that is somewhat low-level and sensitive in terms of maintenance between major Go releases is our asynchronous <a href="https://github.com/usbarmory/tamago-go/blob/e944e99653b23cfa0c3aa0bf7365a71f627033db/src/runtime/sys_tamago_amd64.s#L188">goroutine waking function</a>, which is used to serve external interrupt requests.</p>
<p dir="auto">However such function can be re-implemented in a manner consistent with existing OS signaling or, simply with the awareness and inclusion of <code>GOOS=none</code>, hooked to a much simpler standardized interface within the timer</p>
      </div>
</div></div>
  </body>
</html>
