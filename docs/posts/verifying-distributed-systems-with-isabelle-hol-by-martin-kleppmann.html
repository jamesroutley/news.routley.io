<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lawrencecpaulson.github.io/2022/10/12/verifying-distributed-systems-isabelle.html">Original</a>
    <h1>Verifying Distributed Systems with Isabelle/HOL, by Martin Kleppmann</h1>
    
    <div id="readability-page-1" class="page"><section>

      <h2>Verifying distributed systems with Isabelle/HOL, by Martin Kleppmann</h2>
<p>12 Oct 2022</p>

<span>[
  
    
    <a href="https://lawrencecpaulson.github.io/tag/general"><code><nobr>general</nobr></code> </a>
  
    
    <a href="https://lawrencecpaulson.github.io/tag/verification"><code><nobr>verification</nobr></code> </a>
  
]</span>

<p>We use distributed systems every day in the form of internet services. These systems are very useful, but also challenging to implement because networks are unpredictable. Whenever you send a message over the network, it is likely to arrive quite quickly, but it’s possible that it might be delayed for a long time, or never arrive, or arrive several times.
When you send a request to another process and don’t receive a response, you have no idea what happened: was the request lost, or has the other process crashed, or was the response lost? Or maybe nothing was lost at all, but a message has simply been delayed and may yet arrive. There is no way of knowing what happened, because unreliable message-passing is the only way how processes can communicate.</p>

<p>Distributed algorithms work with this model of unreliable communication and build stronger guarantees on top of it. Examples of such stronger guarantees include database transactions and replication (maintaining copies of some data on multiple machines so that the data is not lost if one machine fails).</p>

<p>Unfortunately, distributed algorithms are notoriously difficult to reason about, because they must uphold their guarantees regardless of the order in which messages are delivered, and even when some messages are lost or some processes crash. Many algorithms are very subtle, and informal reasoning is not sufficient for ensuring that they are correct. Moreover, the number of possible permutations and interleavings of concurrent activities quickly becomes too great for model-checkers to test exhaustively. For this reason, formal proofs of correctness are valuable for distributed algorithms.</p>

<h2 id="modelling-a-distributed-system-in-isabellehol">Modelling a distributed system in Isabelle/HOL</h2>

<p>In this blog post we will explore how to use the Isabelle/HOL proof assistant to formally verify a number of distributed algorithms. Isabelle/HOL does not have any built-in support for distributed computing, but fortunately it is quite straightforward to model a distributed system using structures that Isabelle/HOL provides: functions, lists, and sets.</p>

<p>First, we asssume each process (or <em>node</em>) in the system has a unique identifier, which could simply be an integer or a string. Depending on the algorithm, the set of process IDs in the system may be fixed and known, or unknown and unbounded (the latter is appropriate for systems where processes can join and leave over time).</p>

<p>The execution of the algorithm then proceeds in discrete time steps. In each time step, an event occurs at one of the processes, and this event could be one of three things: receiving a message sent by another process, receiving user input, or the elapsing of a timeout.</p>

<figure><pre><code data-lang="ml"><span>datatype</span> <span>(</span><span>&#39;proc</span><span>,</span> <span>&#39;msg</span><span>,</span> <span>&#39;val</span><span>)</span> <span>event</span>
  <span>=</span> <span>Receive</span> <span>(</span><span>msg_sender</span><span>:</span> <span>&#39;proc</span><span>)</span> <span>(</span><span>recv_msg</span><span>:</span> <span>&#39;msg</span><span>)</span>
  <span>|</span> <span>Request</span> <span>&#39;val</span>
  <span>|</span> <span>Timeout</span></code></pre></figure>

<p>Triggered by one of these events, the process executes a function that may update its own state, and may send messages to other processes. A message sent in one time step may be received at any future time step, or may never be received at all.</p>

<p>Each process has a local state that is not shared with any other process. This state has a fixed initial value at the beginning of the execution, and is updated only when that process executes a step. One process cannot read the state of another process, but we can describe the state of the entire system as the collection of all the processes’ individual states:</p>

<p><img src="https://lawrencecpaulson.github.io/images/2022-10-time-steps.png" width="550" height="275" alt="Illustration of several processes executing steps, one at a time"/></p>

<h2 id="why-a-linear-sequence-of-time-steps-is-sufficient">Why a linear sequence of time steps is sufficient</h2>

<p>Even though in reality processes may run in parallel, we do not need to model this parallelism since the only communication between processes is by sending and receiving messages, and we can assume that a process finishes processing one event before starting to process the next event. Every parallel execution is therefore equivalent to some linear sequence of execution steps. Other formalisations of distributed systems, such as the <a href="https://lamport.azurewebsites.net/tla/tla.html">TLA+ language</a>, also use such a linear sequence of steps.</p>

<p>We do not make any assumptions about which time step is executed by which process. It is possible that the processes fairly take turns to run, but it is equally possible for one process to execute a million steps while another process does nothing at all. By avoiding assumptions about process activity we ensure that the algorithm works correctly regardless of the timing in the system. For example, a process that is temporarily disconnected from the network is modelled simply by a process that does not experience any receive-message events, even while the other processes continue sending and receiving messages.</p>

<p>In this model, a process crash is represented simply by a process that executes no more steps after some point in time; there is no need for a crash to be explicitly represented. If we want to allow processes to recover from a crash, we can add a fourth type of event that models a process restarting after a crash. When executing such a crash-recovery event, a process deletes any parts of its local state that are stored in volatile memory, but preserves those parts of its state that are in stable storage (on disk) and hence survive the crash.</p>

<p>When reasoning about safety properties of algorithms, it is best not to assume anything about which process executes in which time step, since that ensures the algorithm can tolerate arbitrary message delays. If we wanted to reason about liveness (for example, that an algorithm eventually terminates), we would have to make some fairness assumptions, e.g. that every non-crashed process eventually executes a step. However, in our proofs so far we have only focussed on safety properties.</p>

<p><img src="https://lawrencecpaulson.github.io/images/2022-10-system-model.png" width="550" height="412" alt="System model: linear sequence of time steps; at each step, one process handles an event"/></p>

<p>We can now express a distributed algorithm as the <em>step function</em>, which takes three arguments: the ID of the process executing the current time step, the current local state of that process, and the event that has occurred (message receipt, user input, timeout, or crash recovery). The return value consists of the new state for that process, and a set of messages to send to other processes (each message tagged with the ID of the recipient process).</p>

<figure><pre><code data-lang="isabelle">type_synonym (&#39;proc, &#39;state, &#39;msg, &#39;val) step_func =
  ‹&#39;proc ⇒ &#39;state ⇒ (&#39;proc, &#39;msg, &#39;val) event ⇒
  (&#39;state × (&#39;proc × &#39;msg) set)›</code></pre></figure>

<p>The current state of a process at one time step equals the new state after the previous step by the same process (or the initial state if there is no previous step). Assuming the step function is deterministic, we can now encode any execution of the system as a list of (processID, event) pairs indicating the series of events that occurred, and at which process they happened. The final state of the system is obtained by calling the step function one event at a time.</p>

<h2 id="defining-what-may-happen">Defining what may happen</h2>

<p>To prove a distributed algorithm correct, we need to show that it produces a correct result in every possible execution, i.e. for every possible list of (processID, event) pairs. But which executions are possible? There is only really one thing we can safely assume: if a message is received by a process, then that message must have been sent to that process. In other words, we assume the network does not fabricate messages out of thin air, and one process cannot impersonate another process. (In a public network where an attacker can inject fake packets, we would have to cryptographically authenticate the messages to ensure this property, but let’s leave that out of scope for now.)</p>

<p>Therefore, the only assumption we will make is that if a message is received in some time step, then it must have been sent in a previous time step. However, we will allow messages to be lost, reordered, or received multiple times. Let’s encode this assumption in Isabelle/HOL.</p>

<p>First, we define a function that tells us whether a single event is possible: <code>(valid_event evt proc msgs)</code> returns <code>true</code> if event <code>evt</code> is allowed to occur at process <code>proc</code> in a system in which <code>msgs</code> is the set of all messages that have been sent so far. <code>msgs</code> is a set of (sender, recipient, message) triples. We define that a <code>Receive</code> event is allowed to occur iff the received message is in <code>msgs</code>, and <code>Request</code> or <code>Timeout</code> events are allowed to happen anytime.</p>

<figure><pre><code data-lang="isabelle">fun valid_event :: ‹(&#39;proc, &#39;msg, &#39;val) event ⇒ &#39;proc ⇒
                    (&#39;proc × &#39;proc × &#39;msg) set ⇒ bool›
where
  ‹valid_event (Receive sender msg) recpt msgs =
    ((sender, recpt, msg) ∈ msgs)› |
  ‹valid_event (Request _) _ _ = True› |
  ‹valid_event Timeout _ _ = True›</code></pre></figure>

<p>Next, we define the set of all possible event sequences. For this we use an inductive predicate in Isabelle: <code>(execute step init procs events msgs states)</code> returns true if <code>events</code> is a valid sequence of events in an execution of the algorithm where <code>step</code> is the step function, <code>init</code> is the initial state of each process, and <code>proc</code> is the set of all processes in the system (which might be infinite if we want to allow any number of processes). The last two arguments keep track of the execution state: <code>msgs</code> is the set of all messages sent so far, and <code>states</code> is a map from process ID to the state of that process.</p>

<figure><pre><code data-lang="isabelle">inductive execute ::
  ‹(&#39;proc, &#39;state, &#39;msg, &#39;val) step_func ⇒ (&#39;proc ⇒ &#39;state) ⇒
   &#39;proc set ⇒ (&#39;proc × (&#39;proc, &#39;msg, &#39;val) event) list ⇒
   (&#39;proc × &#39;proc × &#39;msg) set ⇒ (&#39;proc ⇒ &#39;state) ⇒ bool›
where
  ‹execute step init procs [] {} init› |
  ‹⟦execute step init procs events msgs states;
    proc ∈ procs;
    valid_event event proc msgs;
    step proc (states proc) event = (new_state, sent);
    events&#39; = events @ [(proc, event)];
    msgs&#39; = msgs ∪ {m. ∃(recpt, msg) ∈ sent.
                       m = (proc, recpt, msg)};
    states&#39; = states (proc := new_state)
   ⟧ ⟹ execute step init procs events&#39; msgs&#39; states&#39;›</code></pre></figure>

<p>This definition states that the empty list of events is valid when the system is in the initial state and no messages have been sent. Moreover, if <code>events</code> is a valid sequence of events so far, and <code>event</code> is allowed in the current state, then we can invoke the step function, add any messages it sends to <code>msgs</code>, update the state of the appropriate process, and the result is another valid sequence of events.</p>

<p>And that’s all we need to model the distributed system!</p>

<h2 id="proving-an-algorithm-correct">Proving an algorithm correct</h2>

<p>Now we can take some algorithm (defined by its step function and initial state) and prove that for all possible lists of events, some property <em>P</em> holds. Since we do not fix a maximum number of time steps, there is an infinite number of possible lists of events. But that’s not a problem, since we can use induction over lists to prove <em>P</em>.</p>

<p><img src="https://lawrencecpaulson.github.io/images/2022-10-induction.png" width="550" height="292" alt="The Isabelle/HOL induction principle over lists"/></p>

<p>We use the <code>List.rev_induct</code> induction rule in Isabelle/HOL. It requires showing that:</p>

<ol>
  <li>the property <em>P</em> is true for the empty list (i.e. for a system in the initial state, which has not executed any time steps); and</li>
  <li>if the property <em>P</em> is true for some execution, and we add one more time step to the end of the execution, then <em>P</em> still holds after that time step.</li>
</ol>

<p>In other words, we prove that <em>P</em> is an invariant over all possible states of the whole system. In Isabelle, that proof looks roughly like this (where <code>step</code>, <code>init</code>, and <code>procs</code> are appropriately defined):</p>

<figure><pre><code data-lang="isabelle">theorem prove_invariant:
  assumes ‹execute step init procs events msgs states›
  shows ‹some_invariant states›
using assms proof (induction events arbitrary: msgs states
                   rule: List.rev_induct)
  case Nil
  then show ‹some_invariant states› sorry
next
  case (snoc event events)
  then show ?case sorry
qed</code></pre></figure>

<p>The real challenge in verifying distributed algorithms is to come up with the right invariant that is both true and also implies the properties you want your algorithm to have. Unfortunately, designing this invariant has to be done manually. However, once you have a candidate invariant, Isabelle is very helpful for checking whether it is correct and whether it is strong enough to meet your goals.</p>

<p>For more detail on how to prove the correctness of a simple consensus algorithm in this model, I recorded a <a href="https://www.youtube.com/watch?v=Uav5jWHNghY">2-hour video lecture</a> that runs through a demo from first principles (no prior Isabelle experience required). The <a href="https://gist.github.com/ept/b6872fc541a68a321a26198b53b3896b">Isabelle code of demo</a> is also available.</p>

<iframe width="550" height="315" src="https://www.youtube-nocookie.com/embed/7w4KC6i9Yac" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>If you want to work on this kind of thing, I will soon be looking for a PhD student to work with me on formalising distributed algorithms in Isabelle, based at <a href="https://www.in.tum.de/en/in/cover-page/">TU Munich</a>. If this sounds like something you want to do, please <a href="https://martin.kleppmann.com/contact.html">get in touch</a>!</p>

<p><em>This is a guest post by <a href="https://martin.kleppmann.com/">Martin Kleppmann</a>. Please let me know if you are interested in contributing a post of your own.</em></p>






      


    </section></div>
  </body>
</html>
