<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.matheusmoreira.com/articles/managing-dotfiles-with-make">Original</a>
    <h1>Managing Dotfiles with Make</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        
        <p>
          Make is an old tool, an assembly language of sorts for build systems.
          Many have tried to replace it. Many have tried to reinvent it. Most
          people prefer to avoid it if at all possible. So why use it to manage
          dotfiles of all things?
        </p>
        <p>
          There&#39;s at least one good reason to do this: make is ubiquitous.
          Pretty much every machine that has ever compiled software will have a
          copy of this thing. Using make as a dotfile management tool eliminates
          the need to install yet another infrequently used program.
        </p>
        <p>
          Another reason to use it is this turned out to be a surprisingly easy
          task.
        </p>
        <h2>File system structure</h2>
        <p>
          Make works best when everything is as simple as possible. It doesn&#39;t
          provide much functionality: the few path manipulation functions it
          includes are of the string matching and substitution variety.
        </p>
        <p>
          The easiest way to achieve that simplicity is to mirror the structure
          of the home directory. Like this:
        </p>
        <ul>
          <li>
            <code>~/.files</code>
            <ul>
              <li>
                <code>~</code>
                <ul>
                  <li><code>.bash_profile</code></li>
                  <li><code>.bashrc</code></li>
                  <li><code>.vimrc</code></li>
                  <li><code>...</code></li>
                </ul>
              </li>
              <li><code>GNUmakefile</code></li>
            </ul>
          </li>
        </ul>
        <p>
          The <code>~</code> directory represents the current user&#39;s home
          directory. Configuration files in <code>$HOME</code> will be symbolic
          links to their corresponding files in the <code>~</code> directory of
          the repository. Make&#39;s job is to automatically create those symbolic
          links.
        </p>
        <pre><code><span>cd</span> ~/.files/
<span>make</span>
</code></pre>
        <p>Simplicity is good.</p>
        <h2>Writing the makefile</h2>
        <p>
          All link targets are rooted in the repository&#39;s
          <code>~</code> directory, so the first thing that must be done is find
          the repository itself.
        </p>
        <p>
          Make always knows the location of the makefile. Since it is located in
          the root of the <code>.files</code> repository, it&#39;s possible to find
          the repository itself through it.
        </p>
        <pre><code>makefile <span>:=</span> <span>$</span><span>(</span><span>abspath</span> <span>$</span><span>(</span><span>lastword</span> <span>$</span><span>(</span>MAKEFILE_LIST<span>)</span><span>)</span><span>)</span>
dotfiles <span>:=</span> <span>$</span><span>(</span><span>abspath</span> <span>$</span><span>(</span><span>dir</span> <span>$</span><span>(</span>makefile<span>)</span><span>)</span><span>)</span>
</code></pre>
        <p>
          A reference to the home directory is already available in make via the
          <code>$HOME</code> environment variable and <code>~</code> also works
          according to
          <a href="https://www.gnu.org/software/make/manual/html_node/Wildcards.html#index-_007e-_0028tilde_0029">the documentation</a>. An equally easy way to refer to the dotfiles repository&#39;s
          <code>~</code> directory would be nice.
        </p>
        <pre><code>~ <span>:=</span> <span>$</span><span>(</span><span>abspath</span> <span>$</span><span>(</span>dotfiles<span>)</span>/~<span>)</span>
</code></pre>
        <p>
          Now it is possible to write <code>~</code> and <code>$(~)</code>
          for the user&#39;s home directory and for the repository&#39;s
          <code>~</code> directory respectively.
        </p>
        <h3>The symbolic linking rule</h3>
        <p>
          Combining these variables and the fact the repository structure
          mirrors the structure of the home directory, it becomes trivial to
          write the rule:
        </p>
        <pre><code><span>force</span><span>:</span>

<span>~/%</span> <span>:</span> <span>$</span><span>(</span>~<span>)</span>/% force
	mkdir -p <span>$(@D)</span>
	ln -snf <span>$@</span> <span>$&lt;</span>
<span>endef</span>
</code></pre>
        <p>
          <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">Automatic variables</a>
          are used in the recipe for maximum brevity.
          <code>$@</code> and <code>$&lt;</code> refer to the link target and link
          name. <code>$(@D)</code> refers to the directory of the new link,
          ensuring the whole tree exists before attempting to create it.
        </p>
        <h3>Generalizing and metaprogramming</h3>
        <p>
          GNU Make is surprisingly lisp-like in its metaprogrammability. It&#39;s
          possible to generate and evaluate code at runtime. So why not
          generalize the previous rule into a function that defines symbolic
          linking rules for any pair of directories with matching structure?
        </p>
        <pre><code><span>force</span><span>:</span>

<span>define</span> rule.template
<span><span>$</span>(1)/%</span> <span>:</span> <span>$</span><span>(</span>2<span>)</span>/% force
	mkdir -p <span>$$(@D)</span>
	ln -snf <span>$$@</span> <span>$$&lt;</span>
<span>endef</span>

rule.<span>define</span> <span>=</span> <span>$</span><span>(</span><span>eval</span> <span>$</span><span>(</span><span>call</span> rule.template,<span>$</span><span>(</span>1<span>)</span>,<span>$</span><span>(</span>2<span>)</span><span>)</span><span>)</span>
</code></pre>
        <p>
          The <code>rule.define</code> function will generate and evaluate the
          original rule definition. It&#39;s really easy to use:
        </p>
        <pre><code><span>$</span><span>(</span><span>call</span> rule.<span>define</span>,~,<span>$</span><span>(</span>~<span>)</span><span>)</span>
</code></pre>
        <p>Nice.</p>
        <h3>Phony targets for usability</h3>
        <p>
          By this point, the makefile already works with any dotfile inside the
          repository.
        </p>
        <pre><code><span>make</span> ~/.bash_profile ~/.bashrc
</code></pre>
        <p>
          Typing out all the file names is annoying though. Phony targets can be
          used to group them:
        </p>
        <pre><code>all <span>+=</span> bash
<span>bash</span> <span>:</span> ~/.bash_profile ~/.bashrc

<span>all</span> <span>:</span> <span>$</span><span>(</span>all<span>)</span>
<span>.PHONY</span><span>:</span> all <span>$</span><span>(</span>all<span>)</span>
.DEFAULT_GOAL <span>:=</span> all
</code></pre>
        <p>
          This sets up a phony target for <code>bash</code>, maintains a list of
          all phony targets and ensures they are declared as such, creates an
          <code>all</code> phony target that links everything and sets it as the
          default goal.
        </p>
        <p>Now adding phony targets is easy:</p>
        <pre><code>all <span>+=</span> git
<span>git</span> <span>:</span> ~/.gitconfig</code></pre>
      </article>
    </div></div>
  </body>
</html>
