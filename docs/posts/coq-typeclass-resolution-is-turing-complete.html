<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thaliaarchi.github.io/coq-turing-typeclass/">Original</a>
    <h1>Coq typeclass resolution is Turing-complete</h1>
    
    <div id="readability-page-1" class="page"><div id="page">



<div id="main">

<div>
<p><span title="keyword">Require</span> <span title="keyword">Import</span> <span title="var">List</span>. <span title="keyword">Import</span> <span title="var">ListNotations</span>.</p></div>

<div>



<p>

    by Thalia Archibald, 15 Apr 2023

</p><p>

    The Coq theorem prover has a powerful means of abstraction, typeclasses. To
    resolve a typeclass instance, the typechecker performs an unrestricted
    search for an instance satisfying those constraints. The steps in this
    search resemble the trace of a program execution, and, crucially, it is
    possible to express unsatisfiable constraints, which cause an infinite
    search. This indicates it should be Turing-complete! Let&#39;s prove it!
</p>

<h2>Background on typeclasses</h2>


<p>

    A typeclass is essentially an interface associated with a type.

</p><p>

    Typeclasses were first introduced in Haskell and have since been adopted by
    many other languages, including in Rust as traits. With its richer dependent
    types, Coq further extends typeclasses to allow for values in constraints.
    This allows for computation to be mixed with the search for an instance.

</p><p>

    For a more in-depth tutorial on typeclasses, see the
    <a href="https://softwarefoundations.cis.upenn.edu/qc-current/Typeclasses.html">
    Typeclasses</a> chapter in the fantastic Software Foundations series. The
    section on non-termination and the advice from experts are particularly
    relevant to this.
</p>

<h2>Smallfuck</h2>


<p>

    To prove Turing-completeness, it is sufficient to implement a
    Turing-complete language.

</p><p>

    I model the semantics of <a href="https://esolangs.org/wiki/Smallfuck">
    Smallfuck</a>, a subset of Brainfuck, using typeclass instances. Smallfuck
    has a tape of bits and can move the cell pointer left or right, flip the
    current cell, and loop. I/O and a more complex cell type are not needed to
    demonstrate Turing-completeness, but you could see how that would be
    modelled in my <a href="https://github.com/thaliaarchi/bfcoq">bfcoq</a>
    project.
</p>

 <p><span><span title="var">prog</span></span> represents a Smallfuck program:

</p>

<ul>
<li> <span><span title="var">PRight</span></span> (<span>&gt;</span>) moves the tape right

</li>
<li> <span><span title="var">PLeft</span></span> (<span>&lt;</span>) moves the tape left

</li>
<li> <span><span title="var">PFlip</span></span> (<span>*</span>) flips the current cell

</li>
<li> <span><span title="var">PLoop</span></span> (<span>[…]</span>) repeats while the current cell is 1

</li>
<li> <span><span title="var">PEnd</span></span> is a no-op used at the end of a loop or program

</li>
</ul>
</div>


<p><span><span title="var">tape</span></span> is an infinite tape, where <span><span title="var">cell</span></span> is the current cell and <span><span title="var">ltape</span></span> and
    <span><span title="var">rtape</span></span> are the cells to the left and right, respectively.
</p>


<p>
Let&#39;s define a shorthand for booleans.
</p>


<div>
<h2>Big-step semantics</h2>


<p>

    To execute a Smallfuck program, we map an initial tape to a final tape. I
    model this as a typeclass <span><span title="var">Exec</span></span>, that takes a program <span><span title="var">p</span></span> and initial and
    final tapes <span><span title="var">t</span></span> and <span><span title="var">t&#39;</span></span>. It has a function <span><span title="var">exec</span></span> that returns <span><span title="var">t&#39;</span></span>, so it
    can be used.

</p><p>

    Notice that it is parameterized over <i>values</i> <span><span title="var">p</span></span>, <span><span title="var">t</span></span>, and <span><span title="var">t&#39;</span></span>, not types.
    Other languages only allow types as generic parameters, but Coq generalizes
    it to any dependently-typed term, values and types.
</p></div>


<div><p>
I then define instances of <span><span title="var">Exec</span></span> for each operation in big-step semantics
    style. These define the transformations to be performed in each case, and
    can be seen as a pattern matching at the instance level.

</p>

    <p><span><span title="var">PEnd</span></span> is the simplest to model; it takes a tape <span><span title="var">t</span></span> and maps it to
    itself (does nothing). Syntactically, this defines an instance named
    <span><span title="var">Exec_End</span></span>, that satisfies <span><span title="var">Exec</span></span> for the program <span><span title="var">PEnd</span></span> and some tape <span><span title="var">t</span></span>
    for both the initial and final tape.
</p></div>


<div>
<p><span><span title="var">PFlip</span></span> negates the current cell.

</p><p>

    Intuitively, this definition states that if the remainder of the program can
    be executed, then we can also execute <span><span title="var">PFlip</span></span>. That is, if it can resolve an
    instance for the program starting after applying the flip, then it will
    supply an instance for the flip. This order is backwards, because it applies
    the operations post-order in a depth-first search.

</p><p>

    The parameter <span>`{<span title="var">Exec</span></span> <span><span title="var">p</span></span> <span><span title="var">t</span></span> <span><span title="var">t&#39;</span>}</span> is a class constraint, which implicitly
    supplies evidence that <span><span title="var">p</span></span> <span><span title="var">t</span></span> <span><span title="var">t&#39;</span></span> has an instance of <span><span title="var">Exec</span></span>. It is equivalent
    to <span>{<span title="var">E</span></span> <span>:</span> <span><span title="var">Exec</span></span> <span><span title="var">p</span></span> <span><span title="var">t</span></span> <span><span title="var">t&#39;</span>}</span>, but where the name is not used.
</p></div>


<div>
<p><span><span title="var">PRight</span></span> has two cases: When the tape has at least one cell to the left,
    shift that cell to the current and the old current to the right. When the
    left tape is empty, use <span>0</span> as the new current cell.

</p><p>

    Here, we destructure <span><span title="var">Tape</span></span>, so we can cover the cases of <span>[]</span> and
    <span><span title="var">_</span></span> <span>::</span> <span><span title="var">_</span></span>.
</p></div>


<p>
Likewise for <span><span title="var">PLeft</span></span>.
</p>


<div><p>
Finally, <span><span title="var">PLoop</span></span> has two cases: When the current cell is <span>0</span>, skip the body
    and execute the next operation. When the current cell is <span>1</span>, execute the
    body, then repeat the loop.

</p>

    <p><span><span title="var">Exec_Loop_1</span></span> requires two instances, for executing the body once and for
    executing the loop again.
</p></div>


<p>
For comparison, this closely resembles a typical relational definition in
    Coq, where <span><span title="var">Exec</span></span> becomes the type signature and each instance becomes a
    variant. However, a relation cannot solve for the final tape, like the next
    section shows with typeclasses.
</p>


<div>
<h2>Execution</h2>


<p>

    Now let&#39;s execute programs by typechecking! First, enable typeclass
    debugging, so we can inspect the search path.
</p></div>


<p>
As expected, this typechecks, because <span>&gt;</span> shifts the tape <span>1(1)01</span> right to
    <span>11(0)1</span>:
</p>


<p>
However, give it an impossible result and it cannot find an instance:
</p>


<p>
More usefully, we can generalize it to any tape <span><span title="var">t</span></span> and let it infer the
    final tape after execution:
</p>


<p>
We can execute loops too, like <span>&gt;*&gt;*[*&lt;]</span>:
</p>


<div><p>
Non-terminating programs like <span>[]</span> and <span>&gt;*[&gt;*]</span> work too. For the latter, it
    cannot resolve an instance for any initial tape.

</p><p>

    Each iteration of the loop generates for a fresh intermediate value for the
    tape, which ensures a revisited state will not resolve to the same
    instance. When no instance can ever satisfy it, which happens for
    non-terminating programs, the typechecker will infinitely expand the
    constraints and diverge.
</p></div>


<p>
And finally, a program that writes “Hallo, Welt!” in binary to the tape,
    <span>&gt;*&gt;&gt;&gt;*&gt;&gt;&gt;&gt;&gt;*&gt;*&gt;&gt;&gt;&gt;&gt;*&gt;&gt;*&gt;*&gt;&gt;*&gt;*&gt;&gt;&gt;&gt;*&gt;*&gt;&gt;*&gt;*&gt;&gt;&gt;&gt;*&gt;*&gt;&gt;*&gt;*&gt;*&gt;*&gt;&gt;&gt;*&gt;&gt;*&gt;*&gt;&gt;&gt;</span>
    <span>&gt;&gt;*&gt;&gt;&gt;&gt;&gt;&gt;&gt;*&gt;&gt;*&gt;&gt;*&gt;*&gt;*&gt;&gt;*&gt;*&gt;&gt;&gt;*&gt;&gt;*&gt;&gt;*&gt;*&gt;&gt;*&gt;*&gt;&gt;&gt;&gt;*&gt;*&gt;*&gt;&gt;*&gt;&gt;&gt;&gt;&gt;*&gt;&gt;&gt;&gt;&gt;*&gt;</span>:
</p>




<hr/><p>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</p></div>

</div></div>
  </body>
</html>
