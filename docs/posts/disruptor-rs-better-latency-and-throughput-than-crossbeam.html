<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/nicholassm/disruptor-rs">Original</a>
    <h1>Disruptor-rs: better latency and throughput than crossbeam</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/05a6856d8fed3c2822bd7f44b63cd77538dafd8262dda04d3ea45ece8b53a131/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f646973727570746f72"><img src="https://camo.githubusercontent.com/05a6856d8fed3c2822bd7f44b63cd77538dafd8262dda04d3ea45ece8b53a131/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f646973727570746f72" alt="Crates.io" data-canonical-src="https://img.shields.io/crates/v/disruptor"/></a>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3ce91432a392db91a0062e515331056315bc4cc64498dfb36efa94d2848b1558/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f642f646973727570746f72"><img src="https://camo.githubusercontent.com/3ce91432a392db91a0062e515331056315bc4cc64498dfb36efa94d2848b1558/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f642f646973727570746f72" alt="Crates.io" data-canonical-src="https://img.shields.io/crates/d/disruptor"/></a>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/nicholassm/disruptor-rs/actions/workflows/build_and_test.yml/badge.svg"><img src="https://github.com/nicholassm/disruptor-rs/actions/workflows/build_and_test.yml/badge.svg" alt="Build"/></a>
<a href="https://codecov.io/gh/nicholassm/disruptor-rs" rel="nofollow"><img src="https://camo.githubusercontent.com/cafcaf0cbed3d6076b0788f10e99bb37178bba7ddc1204e0145467878521345d/68747470733a2f2f636f6465636f762e696f2f67682f6e6963686f6c6173736d2f646973727570746f722d72732f67726170682f62616467652e7376673f746f6b656e3d565730334b30414d4930" alt="codecov" data-canonical-src="https://codecov.io/gh/nicholassm/disruptor-rs/graph/badge.svg?token=VW03K0AMI0"/></a></p>

<p dir="auto">This library is a low latency, inter-thread communication library written in Rust.</p>
<p dir="auto">It&#39;s heavily inspired by the brilliant
<a href="https://github.com/LMAX-Exchange/disruptor">Disruptor library from LMAX</a>.</p>

<p dir="auto">Add the following to your <code>Cargo.toml</code> file:</p>

<p dir="auto">To read details of how to use the library, check out the documentation on <a href="https://docs.rs/disruptor" rel="nofollow">docs.rs/disruptor</a>.</p>
<p dir="auto">Here&#39;s a minimal example demonstrating both single and batch publication. Note, batch publication should be used whenever possible for best latency and throughput (see benchmarks below).</p>
<div dir="auto" data-snippet-clipboard-copy-content="use disruptor::*;

// The event on the ring buffer.
struct Event {
    price: f64
}

fn main() {
    // Factory closure for initializing events in the Ring Buffer.
    let factory = || { Event { price: 0.0 }};

    // Closure for processing events.
    let processor = |e: &amp;Event, sequence: Sequence, end_of_batch: bool| {
        // Your processing logic here.
    };

    let size = 64;
    let mut producer = disruptor::build_single_producer(size, factory, BusySpin)
        .handle_events_with(processor)
        .build();

    // Publish single events into the Disruptor via the `Producer` handle.
    for i in 0..10 {
        producer.publish(|e| {
            e.price = i as f64;
        });
    }

    // Publish a batch of events into the Disruptor.
    producer.publish_batch(5, |iter| {
        for e in iter { // `iter` is guaranteed to yield 5 events.
            e.price = 42.0;
        }
    });
}// At this point, the Producer instance goes out of scope and when the
 // processor is done handling all events then the Disruptor is dropped
 // as well."><pre><span>use</span> disruptor<span>::</span><span>*</span><span>;</span>

<span>// The event on the ring buffer.</span>
<span>struct</span> <span>Event</span> <span>{</span>
    <span>price</span><span>:</span> <span>f64</span>
<span>}</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>// Factory closure for initializing events in the Ring Buffer.</span>
    <span>let</span> factory = || <span>{</span> <span>Event</span> <span>{</span> <span>price</span><span>:</span> <span>0.0</span> <span>}</span><span>}</span><span>;</span>

    <span>// Closure for processing events.</span>
    <span>let</span> processor = |<span>e</span><span>:</span> <span>&amp;</span><span>Event</span><span>,</span> <span>sequence</span><span>:</span> <span>Sequence</span><span>,</span> <span>end_of_batch</span><span>:</span> <span>bool</span>| <span>{</span>
        <span>// Your processing logic here.</span>
    <span>}</span><span>;</span>

    <span>let</span> size = <span>64</span><span>;</span>
    <span>let</span> <span>mut</span> producer = disruptor<span>::</span><span>build_single_producer</span><span>(</span>size<span>,</span> factory<span>,</span> <span>BusySpin</span><span>)</span>
        <span>.</span><span>handle_events_with</span><span>(</span>processor<span>)</span>
        <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

    <span>// Publish single events into the Disruptor via the `Producer` handle.</span>
    <span>for</span> i <span>in</span> <span>0</span>..<span>10</span> <span>{</span>
        producer<span>.</span><span>publish</span><span>(</span>|e| <span>{</span>
            e<span>.</span><span>price</span> = i <span>as</span> <span>f64</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// Publish a batch of events into the Disruptor.</span>
    producer<span>.</span><span>publish_batch</span><span>(</span><span>5</span><span>,</span> |iter| <span>{</span>
        <span>for</span> e <span>in</span> iter <span>{</span> <span>// `iter` is guaranteed to yield 5 events.</span>
            e<span>.</span><span>price</span> = <span>42.0</span><span>;</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>// At this point, the Producer instance goes out of scope and when the</span>
 <span>// processor is done handling all events then the Disruptor is dropped</span>
 <span>// as well.</span></pre></div>
<p dir="auto">The library also supports pinning threads on cores to avoid latency induced by context switching.
A more advanced usage demonstrating this and with multiple producers and multiple interdependent consumers could look like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use disruptor::*;
use std::thread;

struct Event {
    price: f64
}

fn main() {
    let factory = || { Event { price: 0.0 }};

    // Closure for processing events.
    let h1 = |e: &amp;Event, sequence: Sequence, end_of_batch: bool| {
        // Processing logic here.
    };
    let h2 = |e: &amp;Event, sequence: Sequence, end_of_batch: bool| {
        // Some processing logic here.
    };
    let h3 = |e: &amp;Event, sequence: Sequence, end_of_batch: bool| {
        // More processing logic here.
    };

    let mut producer1 = disruptor::build_multi_producer(64, factory, BusySpin)
        // `h2` handles events concurrently with `h1`.
        .pined_at_core(1).handle_events_with(h1)
        .pined_at_core(2).handle_events_with(h2)
            .and_then()
            // `h3` handles events after `h1` and `h2`.
            .pined_at_core(3).handle_events_with(h3)
        .build();

    // Create another producer.
    let mut producer2 = producer1.clone();

    // Publish into the Disruptor.
    thread::scope(|s| {
        s.spawn(move || {
            for i in 0..10 {
                producer1.publish(|e| {
                    e.price = i as f64;
                });
            }
        });
        s.spawn(move || {
            for i in 10..20 {
                producer2.publish(|e| {
                    e.price = i as f64;
                });
            }
        });
    });
}// At this point, the Producers instances go out of scope and when the
 // processors are done handling all events then the Disruptor is dropped
 // as well."><pre><span>use</span> disruptor<span>::</span><span>*</span><span>;</span>
<span>use</span> std<span>::</span>thread<span>;</span>

<span>struct</span> <span>Event</span> <span>{</span>
    <span>price</span><span>:</span> <span>f64</span>
<span>}</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> factory = || <span>{</span> <span>Event</span> <span>{</span> <span>price</span><span>:</span> <span>0.0</span> <span>}</span><span>}</span><span>;</span>

    <span>// Closure for processing events.</span>
    <span>let</span> h1 = |<span>e</span><span>:</span> <span>&amp;</span><span>Event</span><span>,</span> <span>sequence</span><span>:</span> <span>Sequence</span><span>,</span> <span>end_of_batch</span><span>:</span> <span>bool</span>| <span>{</span>
        <span>// Processing logic here.</span>
    <span>}</span><span>;</span>
    <span>let</span> h2 = |<span>e</span><span>:</span> <span>&amp;</span><span>Event</span><span>,</span> <span>sequence</span><span>:</span> <span>Sequence</span><span>,</span> <span>end_of_batch</span><span>:</span> <span>bool</span>| <span>{</span>
        <span>// Some processing logic here.</span>
    <span>}</span><span>;</span>
    <span>let</span> h3 = |<span>e</span><span>:</span> <span>&amp;</span><span>Event</span><span>,</span> <span>sequence</span><span>:</span> <span>Sequence</span><span>,</span> <span>end_of_batch</span><span>:</span> <span>bool</span>| <span>{</span>
        <span>// More processing logic here.</span>
    <span>}</span><span>;</span>

    <span>let</span> <span>mut</span> producer1 = disruptor<span>::</span><span>build_multi_producer</span><span>(</span><span>64</span><span>,</span> factory<span>,</span> <span>BusySpin</span><span>)</span>
        <span>// `h2` handles events concurrently with `h1`.</span>
        <span>.</span><span>pined_at_core</span><span>(</span><span>1</span><span>)</span><span>.</span><span>handle_events_with</span><span>(</span>h1<span>)</span>
        <span>.</span><span>pined_at_core</span><span>(</span><span>2</span><span>)</span><span>.</span><span>handle_events_with</span><span>(</span>h2<span>)</span>
            <span>.</span><span>and_then</span><span>(</span><span>)</span>
            <span>// `h3` handles events after `h1` and `h2`.</span>
            <span>.</span><span>pined_at_core</span><span>(</span><span>3</span><span>)</span><span>.</span><span>handle_events_with</span><span>(</span>h3<span>)</span>
        <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

    <span>// Create another producer.</span>
    <span>let</span> <span>mut</span> producer2 = producer1<span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>

    <span>// Publish into the Disruptor.</span>
    thread<span>::</span><span>scope</span><span>(</span>|s| <span>{</span>
        s<span>.</span><span>spawn</span><span>(</span><span>move</span> || <span>{</span>
            <span>for</span> i <span>in</span> <span>0</span>..<span>10</span> <span>{</span>
                producer1<span>.</span><span>publish</span><span>(</span>|e| <span>{</span>
                    e<span>.</span><span>price</span> = i <span>as</span> <span>f64</span><span>;</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        s<span>.</span><span>spawn</span><span>(</span><span>move</span> || <span>{</span>
            <span>for</span> i <span>in</span> <span>10</span>..<span>20</span> <span>{</span>
                producer2<span>.</span><span>publish</span><span>(</span>|e| <span>{</span>
                    e<span>.</span><span>price</span> = i <span>as</span> <span>f64</span><span>;</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>// At this point, the Producers instances go out of scope and when the</span>
 <span>// processors are done handling all events then the Disruptor is dropped</span>
 <span>// as well.</span></pre></div>
<p dir="auto">If you need to store some state in the processor thread which is neither <code>Send</code> nor <code>Sync</code>, e.g. a <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>, then you can create a closure for initializing that state and pass it along with the processing closure when you build the Disruptor. The Disruptor will then pass a mutable reference to your state on each event. As an example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use std::{cell::RefCell, rc::Rc};
use disruptor::*;

struct Event {
    price: f64
}

#[derive(Default)]
struct State {
    data: Rc&lt;RefCell&lt;i32&gt;&gt;
}

fn main() {
    let factory = || { Event { price: 0.0 }};
    let initial_state = || { State::default() };

    // Closure for processing events *with* state.
    let processor = |s: &amp;mut State, e: &amp;Event, _: Sequence, _: bool| {
        // Mutate your custom state:
        *s.data.borrow_mut() += 1;
    };

    let size = 64;
    let mut producer = disruptor::build_single_producer(size, factory, BusySpin)
        .handle_events_and_state_with(processor, initial_state)
        .build();

    for i in 0..10 {
        producer.publish(|e| {
            e.price = i as f64;
        });
    }
}"><pre><span>use</span> std<span>::</span><span>{</span>cell<span>::</span><span>RefCell</span><span>,</span> rc<span>::</span><span>Rc</span><span>}</span><span>;</span>
<span>use</span> disruptor<span>::</span><span>*</span><span>;</span>

<span>struct</span> <span>Event</span> <span>{</span>
    <span>price</span><span>:</span> <span>f64</span>
<span>}</span>

<span>#<span>[</span>derive<span>(</span><span>Default</span><span>)</span><span>]</span></span>
<span>struct</span> <span>State</span> <span>{</span>
    <span>data</span><span>:</span> <span>Rc</span><span>&lt;</span><span>RefCell</span><span>&lt;</span><span>i32</span><span>&gt;</span><span>&gt;</span>
<span>}</span>

<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> factory = || <span>{</span> <span>Event</span> <span>{</span> <span>price</span><span>:</span> <span>0.0</span> <span>}</span><span>}</span><span>;</span>
    <span>let</span> initial_state = || <span>{</span> <span>State</span><span>::</span><span>default</span><span>(</span><span>)</span> <span>}</span><span>;</span>

    <span>// Closure for processing events *with* state.</span>
    <span>let</span> processor = |<span>s</span><span>:</span> <span>&amp;</span><span>mut</span> <span>State</span><span>,</span> <span>e</span><span>:</span> <span>&amp;</span><span>Event</span><span>,</span> _<span>:</span> <span>Sequence</span><span>,</span> _<span>:</span> <span>bool</span>| <span>{</span>
        <span>// Mutate your custom state:</span>
        <span>*</span>s<span>.</span><span>data</span><span>.</span><span>borrow_mut</span><span>(</span><span>)</span> += <span>1</span><span>;</span>
    <span>}</span><span>;</span>

    <span>let</span> size = <span>64</span><span>;</span>
    <span>let</span> <span>mut</span> producer = disruptor<span>::</span><span>build_single_producer</span><span>(</span>size<span>,</span> factory<span>,</span> <span>BusySpin</span><span>)</span>
        <span>.</span><span>handle_events_and_state_with</span><span>(</span>processor<span>,</span> initial_state<span>)</span>
        <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

    <span>for</span> i <span>in</span> <span>0</span>..<span>10</span> <span>{</span>
        producer<span>.</span><span>publish</span><span>(</span>|e| <span>{</span>
            e<span>.</span><span>price</span> = i <span>as</span> <span>f64</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></pre></div>

<ul>
<li> Single Producer Single Consumer (SPSC).</li>
<li> Multi Producer Single Consumer (MPSC).</li>
<li> Multi Producer Multi Consumer (MPMC) with consumer interdependencies.</li>
<li> Busy-spin wait strategies.</li>
<li> Batch publication of events.</li>
<li> Batch consumption of events.</li>
<li> Thread affinity can be set for the event processor thread(s).</li>
<li> Set thread name of each event processor thread.</li>
</ul>

<p dir="auto">Everything in the library is about low-latency and this heavily influences all choices made in this library.
As an example, you cannot allocate an event and <em>move</em> that into the ringbuffer. Instead, events are allocated on startup to ensure they are co-located in memory to increase cache coherency.
However, you can still allocate a struct on the heap and move ownership to a field in the event on the Ringbuffer.
As long as you realize that this can add latency, because the struct is allocated by one thread and dropped by another.
Hence, there&#39;s synchronization happening in the allocator.</p>
<p dir="auto">There&#39;s also no use of dynamic dispatch - everything is monomorphed.</p>

<p dir="auto">The SPSC and MPSC Disruptor variants have been benchmarked and compared to Crossbeam. See the code in the <code>benches/spsc.rs</code> and <code>benches/mpsc.rs</code> files.</p>
<p dir="auto">The results below of the SPSC benchmark are gathered from running the benchmarks on a 2016 Macbook Pro running a 2,6 GHz Quad-Core Intel Core i7. So on a modern Intel Xeon the numbers should be even better. Furthermore, it&#39;s not possible to isolate cores on Mac and pin threads which would produce even more stable results. This is future work.</p>
<p dir="auto">If you have any suggestions to improving the benchmarks, please feel free to open an issue.</p>
<p dir="auto">To provide a somewhat realistic benchmark not only burst of different sizes are considered but also variable pauses between bursts: 0 ms, 1 ms and 10 ms.</p>
<p dir="auto">The latencies below are the mean latency per element with 95% confidence interval (standard <code>criterion</code> settings). Capturing all latencies and calculating misc. percentiles (and in particular the max latency) is future work. However, I expect the below measurements to be representative for the actual performance you can achieve in a real application.</p>

<p dir="auto"><em>Latency:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>65 ns</td>
<td>32 ns</td>
<td>51%</td>
</tr>
<tr>
<td>10</td>
<td>68 ns</td>
<td>9 ns</td>
<td>87%</td>
</tr>
<tr>
<td>100</td>
<td>29 ns</td>
<td>8 ns</td>
<td>72%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><em>Throughput:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>15.2M / s</td>
<td>31.7M / s</td>
<td>109%</td>
</tr>
<tr>
<td>10</td>
<td>14.5M / s</td>
<td>117.3M / s</td>
<td>709%</td>
</tr>
<tr>
<td>100</td>
<td>34.3M / s</td>
<td>119.7M / s</td>
<td>249%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div dir="auto"><h2 tabindex="-1" dir="auto">1 ms Pause Between Bursts</h2><a id="user-content-1-ms-pause-between-bursts" aria-label="Permalink: 1 ms Pause Between Bursts" href="#1-ms-pause-between-bursts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Latency:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>63 ns</td>
<td>33 ns</td>
<td>48%</td>
</tr>
<tr>
<td>10</td>
<td>67 ns</td>
<td>8 ns</td>
<td>88%</td>
</tr>
<tr>
<td>100</td>
<td>30 ns</td>
<td>9 ns</td>
<td>70%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><em>Throughput:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>15.9M / s</td>
<td>30.7M / s</td>
<td>93%</td>
</tr>
<tr>
<td>10</td>
<td>14.9M / s</td>
<td>117.7M / s</td>
<td>690%</td>
</tr>
<tr>
<td>100</td>
<td>33.8M / s</td>
<td>105.0M / s</td>
<td>211%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div dir="auto"><h2 tabindex="-1" dir="auto">10 ms Pause Between Bursts</h2><a id="user-content-10-ms-pause-between-bursts" aria-label="Permalink: 10 ms Pause Between Bursts" href="#10-ms-pause-between-bursts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Latency:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>51 ns</td>
<td>32 ns</td>
<td>37%</td>
</tr>
<tr>
<td>10</td>
<td>67 ns</td>
<td>9 ns</td>
<td>87%</td>
</tr>
<tr>
<td>100</td>
<td>30 ns</td>
<td>10 ns</td>
<td>67%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><em>Throughput:</em></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Burst Size</th>
<th>Crossbeam</th>
<th>Disruptor</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>19.5M / s</td>
<td>31.6M / s</td>
<td>62%</td>
</tr>
<tr>
<td>10</td>
<td>14.9M / s</td>
<td>114.5M / s</td>
<td>668%</td>
</tr>
<tr>
<td>100</td>
<td>33.6M / s</td>
<td>105.0M / s</td>
<td>213%</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto">There&#39;s clearly a difference between the Disruptor and the Crossbeam libs. However, this is not because the Crossbeam library is not a great piece of software. It is. The Disruptor trades CPU and memory resources for lower latency and higher throughput and that is why it&#39;s able to achieve these results. The Disruptor also excels if you can publish batches of events as
demonstrated in the benchmarks with bursts of 10 and 100 events.</p>
<p dir="auto">Both libraries greatly improves as the burst size goes up but the Disruptor&#39;s performance is more resilient to the pauses between bursts which is one of the design goals.</p>

<p dir="auto">There are multiple other Rust projects that mimic the LMAX Disruptor library:</p>
<ol dir="auto">
<li><a href="https://github.com/polyfractal/Turbine">Turbine</a></li>
<li><a href="https://github.com/sklose/disrustor">Disrustor</a></li>
</ol>
<p dir="auto">A key feature that this library supports is multiple producers from different threads that neither of the above libraries support (at the time of writing).</p>

<p dir="auto">You are welcome to create a Pull-Request or open an issue with suggestions for improvements.</p>
<p dir="auto">Changes are accepted solely at my discretion and I will focus on whether the changes are a good fit for the purpose and design of this crate.</p>

<p dir="auto">Empty! All the items have been implemented.</p>
</article></div></div>
  </body>
</html>
