<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ansiwave/nimwave">Original</a>
    <h1>Show HN: Nimwave â€“ build TUIs for the terminal, web, and desktop</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto">With NIMWAVE, you can build TUI programs for the terminal, the desktop (via OpenGL/GLFW) and the web (via web assembly). Pedantic nerds love to point out that TUI stands for <em>text</em> user interface, not terminal. NIMWAVE is what happens when one of those nerds writes a library. Let&#39;s decouple TUIs from the terminal by running them where the normies are.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/ansiwave/nimwave/blob/master/nimwave.png"><img src="https://github.com/ansiwave/nimwave/raw/master/nimwave.png"/></a>
</p>
<h2 dir="auto"><a id="user-content-getting-started" aria-hidden="true" href="#getting-started"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Getting Started</h2>
<p dir="auto">The best way to begin is to clone <a href="https://github.com/ansiwave/nimwave_starter">the starter project</a> and run the commands in its README.</p>
<p dir="auto">For a much more involved example project, see <a href="https://github.com/ansiwave/ansiwave">ANSIWAVE BBS</a>, along with its <a href="https://github.com/ansiwave/ansiweb">web</a> and <a href="https://github.com/ansiwave/ansigui">desktop</a> versions. It is the project that NIMWAVE was extracted from.</p>
<h2 dir="auto"><a id="user-content-documentation" aria-hidden="true" href="#documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Documentation</h2>
<p dir="auto">NIMWAVE provides a convenient way to define your UI using Nim&#39;s <code>json</code> module. Here&#39;s a simple example that renders a few lines of text surrounded by a box:</p>
<div data-snippet-clipboard-copy-content="nimwave.render(ctx, %* {
  &#34;type&#34;: &#34;nimwave.vbox&#34;,
  &#34;border&#34;: &#34;single&#34;,
  &#34;children&#34;: [
    &#34;Hello, world!&#34;,
    &#34;Nim rocks&#34;,
  ],
})"><pre>nimwave.<span>render</span>(ctx, %* {
  <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.vbox&#34;</span>,
  <span>&#34;border&#34;</span><span>:</span> <span>&#34;single&#34;</span>,
  <span>&#34;children&#34;</span><span>:</span> [
    <span>&#34;Hello, world!&#34;</span>,
    <span>&#34;Nim rocks&#34;</span>,
  ],
})</pre></div>
<h3 dir="auto"><a id="user-content-custom-components" aria-hidden="true" href="#custom-components"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Custom components</h3>
<p dir="auto">The <code>nimwave.vbox</code> is a built-in component. You can easily define your own components as well. For example, let&#39;s move that into a custom component:</p>
<div data-snippet-clipboard-copy-content="proc renderLines(ctx: var nimwave.Context[State], node: JsonNode) =
  nimwave.render(ctx, %* {
    &#34;type&#34;: &#34;nimwave.vbox&#34;,
    &#34;border&#34;: &#34;single&#34;,
    &#34;children&#34;: node[&#34;text&#34;],
  })

ctx.components[&#34;lines&#34;] = renderLines

nimwave.render(ctx, %* {
  &#34;type&#34;: &#34;lines&#34;,
  &#34;text&#34;: [
    &#34;Hello, world!&#34;,
    &#34;Nim rocks&#34;,
  ],
})"><pre><span>proc</span> <span>renderLines</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) <span>=</span>
  nimwave.<span>render</span>(ctx, %* {
    <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.vbox&#34;</span>,
    <span>&#34;border&#34;</span><span>:</span> <span>&#34;single&#34;</span>,
    <span>&#34;children&#34;</span><span>:</span> node[<span>&#34;text&#34;</span>],
  })

ctx.components[<span>&#34;lines&#34;</span>] <span>=</span> renderLines

nimwave.<span>render</span>(ctx, %* {
  <span>&#34;type&#34;</span><span>:</span> <span>&#34;lines&#34;</span>,
  <span>&#34;text&#34;</span><span>:</span> [
    <span>&#34;Hello, world!&#34;</span>,
    <span>&#34;Nim rocks&#34;</span>,
  ],
})</pre></div>
<p dir="auto">This is a somewhat pointless example since we&#39;re just wrapping the vbox in a component, but you get the idea. All you need to do is make a proc with the right signature, add it to <code>ctx.components</code>, and immediately start using it.</p>
<h3 dir="auto"><a id="user-content-resizing-components" aria-hidden="true" href="#resizing-components"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Resizing components</h3>
<p dir="auto">By default, a component will receive a size from its parent component. This size can be found from <code>iw.width(ctx.tb)</code> and <code>iw.height(ctx.tb)</code>. Any component can change its own size using <code>nimwave.slice</code> like this:</p>
<div data-snippet-clipboard-copy-content="proc renderLines(ctx: var nimwave.Context[State], node: JsonNode) =
  ctx = nimwave.slice(ctx, 0, 0, iw.width(ctx.tb), node[&#34;text&#34;].elems.len+2)
  nimwave.render(ctx, %* {
    &#34;type&#34;: &#34;nimwave.vbox&#34;,
    &#34;border&#34;: &#34;single&#34;,
    &#34;children&#34;: node[&#34;text&#34;],
  })"><pre><span>proc</span> <span>renderLines</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) <span>=</span>
  ctx = nimwave.<span>slice</span>(ctx, <span>0</span>, <span>0</span>, iw.<span>width</span>(ctx.tb), node[<span>&#34;text&#34;</span>]<span>.</span>elems.<span>len</span>+<span>2</span>)
  nimwave.<span>render</span>(ctx, %* {
    <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.vbox&#34;</span>,
    <span>&#34;border&#34;</span><span>:</span> <span>&#34;single&#34;</span>,
    <span>&#34;children&#34;</span><span>:</span> node[<span>&#34;text&#34;</span>],
  })</pre></div>
<p dir="auto">Here, the component is retaining the width given to it by the parent, but it is resizing its height to be the number of lines of text plus 2 (for the border).</p>
<h3 dir="auto"><a id="user-content-adding-styling" aria-hidden="true" href="#adding-styling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Adding styling</h3>
<p dir="auto">All low level render operations are dona via <a href="https://github.com/ansiwave/illwave">illwave</a>. You can manipulate individual cells in the <code>TerminalBuffer</code> like this:</p>
<div data-snippet-clipboard-copy-content="# change the foreground/background color
ctx.tb[0, 0].fg = iw.fgBlue
ctx.tb[0, 0].bg = iw.bgYellow

# change the character
ctx.tb[0, 0].ch = &#34;Z&#34;.toRunes[0]"><pre><span><span># </span><span>change the foreground/background color</span></span>
ctx.tb[<span>0</span>, <span>0</span>].fg = iw.fgBlue
ctx.tb[<span>0</span>, <span>0</span>].bg = iw.bgYellow

<span><span># </span><span>change the character</span></span>
ctx.tb[<span>0</span>, <span>0</span>].ch = <span>&#34;Z&#34;</span><span>.</span>toRunes[<span>0</span>]</pre></div>
<p dir="auto">The coordinates here are relative, so <code>0, 0</code> will be the top left corner of the component you are in, not the top left corner of the entire terminal.</p>
<p dir="auto">Also, all strings passed to <code>nimwave.render</code> may include ANSI escape codes directly:</p>
<div data-snippet-clipboard-copy-content="nimwave.render(ctx, %* {
  &#34;type&#34;: &#34;nimwave.hbox&#34;,
  &#34;children&#34;: [&#34;\e[32;43mHello, world!\e[0m&#34;],
})"><pre>nimwave.<span>render</span>(ctx, %* {
  <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.hbox&#34;</span>,
  <span>&#34;children&#34;</span><span>:</span> [<span>&#34;<span>\e</span>[32;43mHello, world!<span>\e</span>[0m&#34;</span>],
})</pre></div>
<h3 dir="auto"><a id="user-content-stateful-components" aria-hidden="true" href="#stateful-components"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Stateful components</h3>
<p dir="auto">Some components require local state. For example, let&#39;s make a button that increments a number every time it is clicked. Although not ideal, an easy way we could do this is with global state:</p>
<div data-snippet-clipboard-copy-content="var count = 0

proc renderCounter(ctx: var nimwave.Context[State], node: JsonNode) =
  ctx = nimwave.slice(ctx, 0, 0, 15, 3)

  proc renderCountBtn(ctx: var nimwave.Context[State], node: JsonNode) =
    const text = &#34;Count&#34;
    ctx = nimwave.slice(ctx, 0, 0, text.runeLen+2, iw.height(ctx.tb))
    if (mouse.action == iw.MouseButtonAction.mbaPressed and iw.contains(ctx.tb, mouse)) or key == iw.Key.Enter:
      count += 1
    nimwave.render(ctx, %* {
      &#34;type&#34;: &#34;nimwave.hbox&#34;,
      &#34;border&#34;: &#34;single&#34;,
      &#34;children&#34;: [text],
    })

  ctx.components[&#34;count-btn&#34;] = renderCountBtn

  nimwave.render(ctx, %* {
    &#34;type&#34;: &#34;nimwave.hbox&#34;,
    &#34;children&#34;: [
      {&#34;type&#34;: &#34;nimwave.vbox&#34;, &#34;border&#34;: &#34;none&#34;, &#34;children&#34;: [$count]},
      {&#34;type&#34;: &#34;count-btn&#34;},
    ]
  })

ctx.components[&#34;counter&#34;] = renderCounter

nimwave.render(ctx, %* {&#34;type&#34;: &#34;counter&#34;})"><pre><span>var</span> count = <span>0</span>

<span>proc</span> <span>renderCounter</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) <span>=</span>
  ctx = nimwave.<span>slice</span>(ctx, <span>0</span>, <span>0</span>, <span>15</span>, <span>3</span>)

  <span>proc</span> <span>renderCountBtn</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) <span>=</span>
    <span>const</span> text = <span>&#34;Count&#34;</span>
    ctx = nimwave.<span>slice</span>(ctx, <span>0</span>, <span>0</span>, text.runeLen+<span>2</span>, iw.<span>height</span>(ctx.tb))
    <span>if</span> (mouse.action == iw.<span>MouseButtonAction</span>.mbaPressed <span>and</span> iw.<span>contains</span>(ctx.tb, mouse)) <span>or</span> key == iw.<span>Key</span>.<span>Enter</span>:
      count += <span>1</span>
    nimwave.<span>render</span>(ctx, %* {
      <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.hbox&#34;</span>,
      <span>&#34;border&#34;</span><span>:</span> <span>&#34;single&#34;</span>,
      <span>&#34;children&#34;</span><span>:</span> [text],
    })

  ctx.components[<span>&#34;count-btn&#34;</span>] <span>=</span> renderCountBtn

  nimwave.<span>render</span>(ctx, %* {
    <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.hbox&#34;</span>,
    <span>&#34;children&#34;</span><span>:</span> [
      {<span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.vbox&#34;</span>, <span>&#34;border&#34;</span><span>:</span> <span>&#34;none&#34;</span>, <span>&#34;children&#34;</span><span>:</span> [<span>$</span>count]},
      {<span>&#34;type&#34;</span><span>:</span> <span>&#34;count-btn&#34;</span>},
    ]
  })

ctx.components[<span>&#34;counter&#34;</span>] <span>=</span> renderCounter

nimwave.<span>render</span>(ctx, %* {<span>&#34;type&#34;</span><span>:</span> <span>&#34;counter&#34;</span>})</pre></div>
<p dir="auto">As you can see, new components can be created on the fly from inside other components. Local components like <code>count-btn</code> are only usable where they are added; elsewhere in the program, they will not be available.</p>
<p dir="auto">While the above component will work, it will not be reusable because the state is global. If we try to render it in two different places, both will use the same count.</p>
<p dir="auto">NIMWAVE solves this by allowing you to create stateful components, which are functions that return functions:</p>
<div data-snippet-clipboard-copy-content="proc mountCounter(ctx: var nimwave.Context[State], node: JsonNode): nimwave.RenderProc[State] =
  var count = 0
  return
    proc (ctx: var nimwave.Context[State], node: JsonNode) =
      ctx = nimwave.slice(ctx, 0, 0, 15, 3)

      proc renderCountBtn(ctx: var nimwave.Context[State], node: JsonNode) =
        const text = &#34;Count&#34;
        ctx = nimwave.slice(ctx, 0, 0, text.runeLen+2, iw.height(ctx.tb))
        if (mouse.action == iw.MouseButtonAction.mbaPressed and iw.contains(ctx.tb, mouse)) or key == iw.Key.Enter:
          count += 1
        nimwave.render(ctx, %* {
          &#34;type&#34;: &#34;nimwave.hbox&#34;,
          &#34;border&#34;: &#34;single&#34;,
          &#34;children&#34;: [text],
        })

      ctx.components[&#34;count-btn&#34;] = renderCountBtn

      nimwave.render(ctx, %* {
        &#34;type&#34;: &#34;nimwave.hbox&#34;,
        &#34;children&#34;: [
          {&#34;type&#34;: &#34;nimwave.vbox&#34;, &#34;border&#34;: &#34;none&#34;, &#34;children&#34;: [$count]},
          {&#34;type&#34;: &#34;count-btn&#34;},
        ]
      })

ctx.statefulComponents[&#34;counter&#34;] = mountCounter

nimwave.render(ctx, %* {&#34;type&#34;: &#34;counter&#34;, &#34;id&#34;: &#34;counter&#34;}) # id required!"><pre><span>proc</span> <span>mountCounter</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>)<span>:</span> nimwave.<span>RenderProc</span>[State] <span>=</span>
  <span>var</span> count = <span>0</span>
  <span>return</span>
    <span>proc</span> (ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) =
      ctx = nimwave.<span>slice</span>(ctx, <span>0</span>, <span>0</span>, <span>15</span>, <span>3</span>)

      <span>proc</span> <span>renderCountBtn</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>], node: <span>JsonNode</span>) <span>=</span>
        <span>const</span> text = <span>&#34;Count&#34;</span>
        ctx = nimwave.<span>slice</span>(ctx, <span>0</span>, <span>0</span>, text.runeLen+<span>2</span>, iw.<span>height</span>(ctx.tb))
        <span>if</span> (mouse.action == iw.<span>MouseButtonAction</span>.mbaPressed <span>and</span> iw.<span>contains</span>(ctx.tb, mouse)) <span>or</span> key == iw.<span>Key</span>.<span>Enter</span>:
          count += <span>1</span>
        nimwave.<span>render</span>(ctx, %* {
          <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.hbox&#34;</span>,
          <span>&#34;border&#34;</span><span>:</span> <span>&#34;single&#34;</span>,
          <span>&#34;children&#34;</span><span>:</span> [text],
        })

      ctx.components[<span>&#34;count-btn&#34;</span>] <span>=</span> renderCountBtn

      nimwave.<span>render</span>(ctx, %* {
        <span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.hbox&#34;</span>,
        <span>&#34;children&#34;</span><span>:</span> [
          {<span>&#34;type&#34;</span><span>:</span> <span>&#34;nimwave.vbox&#34;</span>, <span>&#34;border&#34;</span><span>:</span> <span>&#34;none&#34;</span>, <span>&#34;children&#34;</span><span>:</span> [<span>$</span>count]},
          {<span>&#34;type&#34;</span><span>:</span> <span>&#34;count-btn&#34;</span>},
        ]
      })

ctx.statefulComponents[<span>&#34;counter&#34;</span>] <span>=</span> mountCounter

nimwave.<span>render</span>(ctx, %* {<span>&#34;type&#34;</span><span>:</span> <span>&#34;counter&#34;</span>, <span>&#34;id&#34;</span><span>:</span> <span>&#34;counter&#34;</span>}) <span><span># </span><span>id required!</span></span></pre></div>
<p dir="auto">The outer function runs once when it first mounts in the UI. This is where you can define the local state. It then returns a function which runs every time it renders, and it will have access to that state.</p>
<p dir="auto">As you can see from the final line, stateful components require a unique <code>id</code> attribute to be included, so NIMWAVE has a stable way to refer to it. This needs to be unique when combined with all ids from parent components, so if one of its parents has an id of <code>main-page</code>, the full internal id is <code>@[&#34;main-page&#34;, &#34;counter&#34;]</code>. This makes it easier to avoid id clashes.</p>
<h3 dir="auto"><a id="user-content-storing-state-in-the-context" aria-hidden="true" href="#storing-state-in-the-context"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Storing state in the Context</h3>
<p dir="auto">Another place to store state is inside the <code>Context</code> object. This object is passed to every component, so this is a nice way to pass state that should be accessible everywhere. The starter project defines it like this:</p>
<div data-snippet-clipboard-copy-content="type
  State = object
    focusIndex*: int
    focusAreas*: ref seq[iw.TerminalBuffer]

var ctx = nimwave.initContext[State]()"><pre><span>type</span>
  <span>State</span> = <span>object</span>
    focusIndex*: <span>int</span>
    focusAreas*: <span>ref</span> <span>seq</span>[iw.<span>TerminalBuffer</span>]

<span>var</span> ctx = nimwave.<span>initContext</span>[<span>State</span>]()</pre></div>
<p dir="auto">This object is completely up to you to define, and it will be accessible to you from <code>ctx.data</code>. In this case, it contains state for a simple focus system. The starter project defines this function:</p>
<div data-snippet-clipboard-copy-content="proc addFocusArea(ctx: var nimwave.Context[State]): bool =
  result = ctx.data.focusIndex == ctx.data.focusAreas[].len
  ctx.data.focusAreas[].add(ctx.tb)"><pre><span>proc</span> <span>addFocusArea</span>(ctx: <span>var</span> nimwave.<span>Context</span>[<span>State</span>])<span>:</span> <span>bool</span> <span>=</span>
  result = ctx.data.focusIndex == ctx.data.focusAreas[].<span>len</span>
  ctx.data.focusAreas[].<span>add</span>(ctx.tb)</pre></div>
<p dir="auto">Inside components that should be focusable, you&#39;ll find <code>let focused = addFocusArea(ctx)</code> which adds the component&#39;s <code>TerminalBuffer</code> to the <code>focusAreas</code> and returns true if its length equals the <code>focusIndex</code>.</p>
<p dir="auto">This is just one way to implement a focus system. Notice that this object is using both a value type and a ref type. Always consider what kind of behavior you want; value types will be copied from component to component, so if they are modified from inside a component, the change will only be visible to its own children. Use a ref type if you want all components to see/modify the same data.</p>
</article>
          </div></div>
  </body>
</html>
