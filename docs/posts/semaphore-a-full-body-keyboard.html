<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/everythingishacked/Semaphore">Original</a>
    <h1>Semaphore: A Full-Body Keyboard</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I am running some disk-related experiments and want to control <em>exactly</em> what’s using the disk. So, I attached a new disk, created, and mounted a new ext4 filesystem on it.</p>

<p>Sweet! Let’s confirm that nothing is touching this pristine disk.</p>

<div><div><pre><code>-&gt; % sar -d --dev=sdd 1
[...]
Average:          DEV       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util
Average:          sdd      0.86      0.00    294.29      0.00    343.33      0.03     26.00      1.54
</code></pre></div></div>
<p>(See <a href="#explanation-of-sar">notes</a> for an explanation of <code>sar</code> and its output.)</p>

<p>Uh oh. Something <em>is</em> writing to the disk! What is it?</p>

<p>To trace all requests writing to the disk, we can subscribe to the <code>block:block_rq_issue</code> tracepoint using <code>bpftrace</code>, which is a front-end for eBPF. This method even allows us to see requests made by the kernel itself. To me, this is surprisingly powerful. Until fairly recently, I did not realize how deeply one can inspect the kernel.</p>

<p>The trace tells you which command initiated the request, so we can use that to figure out what’s writing to the disk!</p>

<p>If you’re interested in the details of how this works, see my <a href="https://gist.github.com/dmazin/fc8921400eb7ded1770acdc6734fb9da">shell script to trace block requests</a>.</p>

<p>And… we have a culprit!</p>

<div><div><pre><code>Attaching 1 probe...
comm: ext4lazyinit, dev: 8388656, rwbs: W, bytes: 524288
comm: ext4lazyinit, dev: 8388656, rwbs: W, bytes: 524288
comm: ext4lazyinit, dev: 8388656, rwbs: W, bytes: 524288
[...]
</code></pre></div></div>

<p>What is this ext4lazyinit?
From the mkfs.ext4 man page:</p>
<blockquote>
  <p><em>[…] the inode table will not be fully initialized by mke2fs. This speeds up file system initialization noticeably, but it requires the kernel to finish initializing the file system in the background when the file system is first mounted.</em></p>
</blockquote>

<p><a href="https://www.thomas-krenn.com/en/wiki/Ext4_Filesystem#Lazy_Initialization">This helpful wiki</a> points out that you should be careful to wait for this to finish before running any benchmarks. This is good advice, worth remembering: in a professional setting, benchmarking is common after setting up a new disk/filesystem.</p>

<p>I’ll have to wait for this to finish. Meanwhile, it’s empowering to take a mystery (“I expected there to be nothing touching my new disk. What is touching my disk?”) to a solid answer.</p>

<h3 id="notes">Notes</h3>
<h4 id="explanation-of-sar">explanation of sar</h4>
<p>Here I’m using <code>sar</code>, a disk monitoring utility that I use when I want to print average stats over a given period. The <code>-d</code> option prints disk statistics, <code>--dev=sdd</code> analyzes <code>/dev/sdd</code>, and <code>1</code> outputs every second.</p>

<p>The <code>wkB/s</code> (average kilobytes per second written) should be 0, but it’s not!</p>

    
  </div></div>
  </body>
</html>
