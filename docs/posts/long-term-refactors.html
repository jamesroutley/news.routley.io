<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://max.engineer/long-term-refactors">Original</a>
    <h1>Long Term Refactors</h1>
    
    <div id="readability-page-1" class="page"><div>
      
<p>Big (or<span></span> <span>“</span>Long Term”) refactors are hard to pull off in a busy company. To succeed, we must:</p>
<ul>
<li>Convince business that it’s worth the delay.</li>
<li>Decide what features will have to wait.</li>
<li>Produce regular status updates and ETAs.</li>
<li>Justify the refactor as we go. Is it the right approach?</li>
<li>Keep ourselves from burning out.</li>
<li>Allow time for the team to digest and review the huge diff.</li>
<li>Fix a bombardment of <span>QA</span> issues.</li>
</ul>
<p>And we better do this all quickly, because god forbid original and refactored code coexist!</p>
<p>Is this really the only way? Feature freeze, a rush, a buggy rollout, and likely burnout?</p>
<h2 id="the-other-way">The Other Way</h2>
<p>I have a theory that long refactors get a bad rap because most of them take far longer than we expect. The length leads to stress, an awkward codebase, a confused team, and often no end in sight. Instead, what if we <em>prepared</em> an intentional long term refactor? A few years ago, I began trying this method, and it has led to some surprisingly successful results:</p>
<ul>
<li>We didn’t need to negotiate business timelines.</li>
<li>We didn’t need to compete against business priorities.</li>
<li>The team quickly understood and even took ownership of the refactor over time.</li>
<li>There was no increase in stress and risk of burnout.</li>
<li>PRs were easy to review, no huge diffs.</li>
<li>The refactor was consistently and collaboratively re-evaluated by the entire team.</li>
<li>We never wasted time refactoring code that didn’t need it.</li>
<li>Our feature development remained unblocked.</li>
<li>The team expanded their architectural knowledge.</li>
<li>The new engineers had a great source of first tasks.</li>
<li>We rolled out the refactor gradually, making it easier to <span>QA</span>, and reducing bugs.</li>
</ul>
<p>Long-term refactors involve the whole team from the beginning, which is one of their most powerful aspects. So far, I’ve participated in ~10 big refactors using this method across 2 companies with at least 3 different teams, and I’ve yet to see it go wrong. Here was our approach.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>To start, you should have the following:</p>
<ol type="1">
<li>An experienced software engineer with a vision for the refactor.</li>
<li>A team of software engineers at various levels of expertise.</li>
<li>An internal knowledge base. (Any of Github Wiki, Notion, Confluence, Markdown files, etc)</li>
<li>Less than ~5-10 long term refactors already in progress, depending on their scope.</li>
</ol>
<h2 id="process">Process</h2>
<p>Almost every big refactor I’ve encountered follows a semi-consistent pattern. What makes a refactor big is the sheer number of times you must apply the pattern. In an ideal world, this labor is divided. Unfortunately, the refactor often requires case-by-case decision making. My proposed process is centered around explaining the refactoring idea to your colleagues, so that they can also make decisions.</p>
<p><span>NOTE</span>: The process is for the<span></span> <span>“</span>experienced engineer” from prerequisite #1.</p>
<ol type="1">
<li><strong>Identify code that should be refactored.</strong></li>
<li><strong>Identify the refactoring pattern.</strong></li>
<li><strong>Implement an example of the refactor.</strong></li>
<li><strong>Prepare the codebase for the refactor.</strong></li>
<li><strong>Name your refactor.</strong></li>
<li><strong>Write up refactoring instructions.</strong></li>
<li><strong>Add this refactor to the list of long term refactors.</strong></li>
<li><strong>Introduce this refactor to your team.</strong></li>
<li><strong>Assign refactoring tasks.</strong></li>
<li><strong>Stay aware of long term refactors.</strong></li>
<li><strong>Complete the refactor.</strong></li>
</ol>
<p>Having followed this process carefully, I’ve seen something awesome happen. The team got into the habit of self-assigning refactors as needed. When they had questions, they’d initiate discussions and meetings. This got everyone on the same page around decisions that might’ve been controversial if made alone. With each completed refactor task, we’d all gain new examples to draw from in upcoming tasks.</p>
<p>Compare that to working on your own for weeks or months, and blindsiding your team with a huge diff.</p>
<h2 id="drawbacks">Drawbacks</h2>
<p>Here are some that I can think of.</p>
<ul>
<li>Albeit rare, some big refactors don’t have a common pattern. It’s possible that you’re actually dealing with multiple refactors that shouldn’t be under the same umbrella. Try to split them instead.</li>
<li>You need patience to get through these refactors. They can span a year, two years, who knows. During that time, the old and the new code will coexist, and might cause some confusion if the list from step 7 is not on everyone’s mind. I personally haven’t encountered this drawback in practice, because the process constantly keeps everyone on the same page. Due to organization and communication, nobody is confused about where we’re coming from, and where we are headed.</li>
<li>Certain parts of the code may never get refactored. There’s probably a good reason why. It could be that this part is easy to maintain as is, and doesn’t need to change. Or perhaps this code is on its way out. Think of it as a win — you saved time and didn’t introduce bugs unnecessarily.</li>
<li>If you like doing everything alone, this ain’t it. This approach is designed to get everyone on the same page. You will have to agree on solutions and articulate your reasoning. If you don’t like doing that, you won’t like long term refactors.</li>
</ul>
<p>Try it, let me know how it goes!</p>
      </div></div>
  </body>
</html>
