<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.datadoodad.com/recurse%20center/RC39-5/">Original</a>
    <h1>RC39ish. Building a DNS Resolver in C, Part 2: Fun with inet_pton()</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-07-08T00:00:00-07:00">July 8, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p>In the <a href="https://www.datadoodad.com/recurse%20center/RC38/">last installment of Building a DNS Resolver in C</a>, I talked about writing a component of a conversion function that will eventually translate a valid IPv4 address (e.g., one of those 31.13.70.36 things) to a single 32-bit integer – the reason being that this 32-bit integer format is the format that we need to send out when we make our DNS query using <code>sendto()</code>. It was only a component, however, since the <code>btoi()</code> function we wrote just does the part where it takes a 32-character string of 0s and 1s and converts it to its 32-bit unsigned integer equivalent. So its usage would look something like this:</p>

<div><div><pre><code><span>printf</span><span>(</span><span>&#34;Bitstring %s (length %d) -&gt; %u</span><span>\n</span><span>&#34;</span><span>,</span> <span>binstr</span><span>,</span> <span>i</span><span>,</span> <span>btoi</span><span>(</span><span>binstr</span><span>,</span> <span>i</span><span>));</span>
</code></pre></div></div>

<div><div><pre><code>Bistring 00011111000011010100011000100100 (length 32) -&gt; 520963620
</code></pre></div></div>

<p>To perform the entire conversion starting with an IPv4 address, there are still a few things that need to happen, namely parsing the IP address, converting each one-byte number to an 8-bit bytestring, and concatenating the result (which is what finally gets passed to <code>btoi()</code>).</p>

<p>I still intend to do this, but I wanted to explore C’s <code>inet_pton()</code> function (part of the <code>arpa/inet.h</code> library), which basically just does this all for you. Here’s a few things I learned from playing with it.</p>



<p>P-to-N means presentation-to-network. I.e., human readable to computer readable. I.e., a human friendly IPv4 address like 31.13.70.36 to some big, inscrutable number like 520963620.</p>

<p>The function signature looks like this:</p>

<div><div><pre><code><span>int</span> <span>inet_pton</span><span>(</span><span>int</span> <span>af</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>restrict</span> <span>src</span><span>,</span> <span>void</span> <span>*</span><span>restrict</span> <span>dst</span><span>);</span>
</code></pre></div></div>

<p>Parameters:</p>
<ul>
  <li><code>af</code>: address family – either AF_INET for IPv4 addresses or AF_INET6 for IPv6 addresses. I’ll be keeping it simple here with IPv4 addresses</li>
  <li><code>src</code>: the input string (something like <code>31.13.70.36</code> for an IPv4 address)</li>
  <li><code>dst</code>: the destination address where the 32-bit integer conversion of the thing in <code>src</code> will go. That means that this destination address must be 4 bytes in size.</li>
</ul>

<p>Returns:</p>
<ul>
  <li>1 if successful, else 0</li>
</ul>

<p>It is my understanding that most of the time when doing networking things in C one will avail oneself of some handy structs like these:</p>

<div><div><pre><code><span>struct</span> <span>sockaddr_in</span> <span>{</span>
    <span>short</span> <span>int</span>          <span>sin_family</span><span>;</span>
    <span>unsigned</span> <span>short</span> <span>int</span> <span>sin_port</span><span>;</span>
    <span>struct</span> <span>in_addr</span>     <span>sin_addr</span><span>;</span>
    <span>unsigned</span> <span>char</span>      <span>sin_zero</span><span>[</span><span>8</span><span>];</span>
<span>};</span>

<span>struct</span> <span>in_addr</span> <span>{</span>
    <span>uint32_t</span> <span>s_addr</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p><code>sockaddr_in</code> stores the address family (<code>AF_INET</code> or <code>AF_NET6</code> – type <code>int</code>), the port we want to use (also type <code>int</code>), and the address we want to do stuff with. This last part is type <code>struct in_addr</code>, which we can see has a single 32-integer member called <code>s_addr</code>. This is what interests us here, since, normally when converting an IPv4 address to 32-bit integer using <code>inet_pton()</code>, you’d store the result in the 32-bit home designated by <code>sockaddr_in.sin_addr</code>. Something like this:</p>

<div><div><pre><code><span>struct</span> <span>sockaddr_in</span> <span>my_sock</span><span>;</span>

<span>inet_pton</span><span>(</span><span>AF_INET</span><span>,</span> <span>&#34;8.8.8.8&#34;</span><span>,</span> <span>&amp;</span><span>(</span><span>my_sock</span><span>.</span><span>sin_addr</span><span>));</span>
</code></pre></div></div>



<p>I’m trying to keep things simple, so I’m just sending the result of <code>inet_pton()</code> to a regular old 32-bit int, like so:</p>

<div><div><pre><code><span>uint32_t</span> <span>s_addr</span><span>;</span>

<span>inet_pton</span><span>(</span><span>AF_INET</span><span>,</span> <span>&#34;8.8.8.8&#34;</span><span>,</span> <span>&amp;</span><span>s_addr</span><span>);</span>
</code></pre></div></div>

<p>Same thing, just without the extra struct-bulk.</p>

<p>So that’s it, right?? Let’s go!</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
</span>
<span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>uint32_t</span> <span>s_addr</span><span>;</span> <span>// 4-bytes to hold address</span>
    <span>char</span> <span>buf</span><span>[</span><span>16</span><span>];</span>    <span>// Buffer to hold max IPv4 addr plus null string terminator</span>
    <span>char</span> <span>c</span><span>;</span>
    <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>

    <span>while</span> <span>((</span><span>c</span> <span>=</span> <span>getchar</span><span>())</span> <span>!=</span> <span>EOF</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
            <span>buf</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
            <span>if</span> <span>(</span><span>inet_pton</span><span>(</span><span>AF_INET</span><span>,</span> <span>buf</span><span>,</span> <span>&amp;</span><span>s_addr</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                <span>printf</span><span>(</span><span>&#34;--&gt; %u</span><span>\n</span><span>&#34;</span><span>,</span> <span>s_addr</span><span>);</span>
            <span>}</span>
            <span>s_addr</span> <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(;</span> <span>i</span><span>&gt;</span><span>0</span><span>;</span> <span>--</span><span>i</span><span>)</span>
                <span>buf</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>if</span> <span>(</span><span>i</span> <span>&lt;</span> <span>15</span><span>)</span>
                <span>buf</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>c</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>8.8.8.8
--&gt; 134744072

31.13.70.36
--&gt; 608570655

172.217.14.78
--&gt; 1309596076
</code></pre></div></div>

<p>This little REPL has a 16-character buffer (that the maximum length of an IPv4 address plus a null terminator), to which it adds characters building the address string. When it sees a linebreak, it passes this <code>buf</code> string to <code>inet_pton()</code> and lets it rip! Looks good, right? All finished, right??</p>



<p>Meanwhile, I thought it’d be fun to just whip up a quick Python script that effectively does what <code>inet_pton()</code> does:</p>

<div><div><pre><code><span>def</span> <span>inet_pton</span><span>(</span><span>ip</span><span>):</span>
    <span># split `ip` at dot, convert each int to 8-bit bytestring, and concatenate
</span>    <span>binstr</span> <span>=</span> <span>&#34;0b&#34;</span> <span>+</span> <span>&#34;&#34;</span><span>.</span><span>join</span><span>([</span><span>&#34;{:08b}&#34;</span><span>.</span><span>format</span><span>(</span><span>int</span><span>(</span><span>int8</span><span>))</span> <span>for</span> <span>int8</span> <span>in</span> <span>ip</span><span>.</span><span>split</span><span>(</span><span>&#39;.&#39;</span><span>)])</span>
    <span># convert 32-bit bytestring to int
</span>    <span>int32</span> <span>=</span> <span>int</span><span>(</span><span>binstr</span><span>,</span> <span>2</span><span>)</span>

    <span>return</span> <span>binstr</span><span>,</span> <span>int32</span>

<span>def</span> <span>display_pton</span><span>(</span><span>ip</span><span>=</span><span>&#34;8.8.8.8&#34;</span><span>):</span>
    <span>&#39;&#39;&#39;
    Pretty-print results of inet_pton()
    &#39;&#39;&#39;</span>
    <span>binstr</span><span>,</span> <span>int32</span> <span>=</span> <span>inet_pton</span><span>(</span><span>ip</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;{:&lt;15} -&gt; {} ({})&#34;</span><span>.</span><span>format</span><span>(</span><span>ip</span><span>,</span> <span>binstr</span><span>,</span> <span>int32</span><span>))</span>
</code></pre></div></div>

<p>That first part of <code>inet_pton()</code> is not super readable, but basically it is:</p>
<ul>
  <li>splitting the <code>ip</code> argument at the dots (<code>1.23.4.56</code> -&gt; <code>[&#39;1&#39;, &#39;23&#39;, &#39;4&#39;, &#39;56&#39;]</code></li>
  <li>using a list comprehension to reformat each element as an 8-bit string (<code>[&#39;00000001&#39;, &#39;00010111&#39;, &#39;00000100&#39;, &#39;00111000&#39;]</code>)</li>
  <li>joining the result and concatenating to “0b” (<code>&#39;0b00000001000101110000010000111000</code>) – this is the first thing this function will return</li>
  <li>and turning that thing into an integer (<code>18285624</code>) – the second thing this function will return</li>
</ul>

<p>So you can do something like</p>

<div><div><pre><code><span>display_pton</span><span>(</span><span>&#34;8.8.8.8&#34;</span><span>)</span>
<span>display_pton</span><span>(</span><span>&#34;31.13.70.36&#34;</span><span>)</span>
<span>display_pton</span><span>(</span><span>&#34;172.217.14.78&#34;</span><span>)</span>
</code></pre></div></div>

<p>and see a result like</p>

<div><div><pre><code>8.8.8.8         -&gt; 0b00001000000010000000100000001000 (134744072)
31.13.70.36     -&gt; 0b00011111000011010100011000100100 (520963620)
172.217.14.78   -&gt; 0b10101100110110010000111001001110 (2899906126)
</code></pre></div></div>

<p>Hey, wait a second. . . the result for 8.8.8.8 is the same as the C version of <code>inet_pton()</code>, but the other two IPs are yielding different results. What gives?</p>



<figure>
<img src="https://www.datadoodad.com/assets/images/RC39-5_eggs.png" alt="eggs"/>
<figcaption>Big-endian and . . . middle-endian? Get it together, DALL-E</figcaption>
</figure>

<p>This one really threw me off for a bit. I thought for certain I must have some bug or maybe there was some garbage leftover at the <code>s_addr</code> address in my C code that was messing up the calculation or <em>something</em>.</p>

<p>Eventually I thought to convert the integer results of both my Python and C versions back to binary:</p>

<div><div><pre><code><span>print</span><span>(</span><span>&#34;Python result: {} -&gt; {}&#34;</span><span>.</span><span>format</span><span>(</span><span>520963620</span><span>,</span> <span>bin</span><span>(</span><span>520963620</span><span>)))</span>
<span>print</span><span>(</span><span>&#34;C result:      {} -&gt; {}&#34;</span><span>.</span><span>format</span><span>(</span><span>608570655</span><span>,</span> <span>bin</span><span>(</span><span>608570655</span><span>)))</span>
</code></pre></div></div>

<div><div><pre><code>Python result: 520963620 -&gt; 0b11111000011010100011000100100
C result:      608570655 -&gt; 0b100100010001100000110100011111
</code></pre></div></div>

<p>After staring at these for a while, I realized that, once you account for a few missing leading zeroes, the same bytes are occuring in each, but just in opposite orders!</p>

<div><div><pre><code>python version: 00011111 00001101 01000110 00100100
                    A        B        C        D

c version:      00100100 01000110 00001101 00011111
                    D        C        B        A
</code></pre></div></div>

<p>Okay, interesting! Suddenly I’m remembering seeing, and skipping over, stuff about byte order, which has to be the issue here. Only problem is, who’s in the right? C or Python?</p>

<p>I thought my Python script had to be the culprit since it was the one I was responsible for. I figured that I must have put the bytes in the wrong order is all. They have to go in Network Byte Order! Which is (some googling revealed) Most Significant Byte first. Obviously!</p>

<p>But that’s . . . what I did, wasn’t it? In the example above (31.13.70.36), the first element (31) became the first – which is to say left-most, which is to say most significant – byte in my 32-bit string, right? So that means <code>inet_ptoi()</code> has it twisted.</p>

<p>After some further perusing of <a href="https://beej.us/guide/bgnet/html/split/man-pages.html#structsockaddrman">Beej’s guide</a>, I discovered the problem. Networks like stuff in, you guessed it, Network Byte Order. That’s big-endian style. But computers are divided on the subject, apparently. Intel machines like lil’ endian, and non-intel machines like big-endian, and, well, I’m on an intel Mac. So it seems that what’s happening here is <code>inet_pton()</code> is doing its job of taking an IPv4 address and converting it to a 4-byte integer; it’s just that my computer is storing those four bytes in its own, slightly eccentric way, which is not the way that networks do it.</p>

<p>However, there’s a handy suite of functions that will happily do this conversion back and forth:</p>
<ul>
  <li><code>htons()</code> - host to network short</li>
  <li><code>htonl()</code> - host to network long</li>
  <li><code>ntohs()</code> - network to host short</li>
  <li><code>ntohl()</code> - network to host long</li>
</ul>

<p>We need to go from host to network, and we want the long here, since we’re working with 4-byte integers. Here’s the revised code:</p>

<div><div><pre><code><span>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
</span>
<span>int</span> <span>main</span><span>()</span>
<span>{</span>
    <span>uint32_t</span> <span>s_addr</span><span>;</span> <span>// 4-bytes to hold address</span>
    <span>char</span> <span>buf</span><span>[</span><span>16</span><span>];</span>    <span>// Buffer to hold max IPv4 addr plus null string terminator</span>
    <span>char</span> <span>c</span><span>;</span>
    <span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>

    <span>while</span> <span>((</span><span>c</span> <span>=</span> <span>getchar</span><span>())</span> <span>!=</span> <span>EOF</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>c</span> <span>==</span> <span>&#39;\n&#39;</span><span>)</span> <span>{</span>
            <span>buf</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
            <span>if</span> <span>(</span><span>inet_pton</span><span>(</span><span>AF_INET</span><span>,</span> <span>buf</span><span>,</span> <span>&amp;</span><span>s_addr</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                <span>printf</span><span>(</span><span>&#34;--&gt; Host Byte Order:    %u</span><span>\n</span><span>&#34;</span><span>,</span> <span>s_addr</span><span>);</span>
                <span>printf</span><span>(</span><span>&#34;--&gt; Network Byte Order: %u</span><span>\n\n</span><span>&#34;</span><span>,</span> <span>htonl</span><span>(</span><span>s_addr</span><span>));</span>
            <span>}</span>
            <span>s_addr</span> <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(;</span> <span>i</span><span>&gt;</span><span>0</span><span>;</span> <span>--</span><span>i</span><span>)</span>
                <span>buf</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>if</span> <span>(</span><span>i</span> <span>&lt;</span> <span>15</span><span>)</span>
                <span>buf</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>c</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>And here’s a sample REPL session so we can see it working:</p>

<div><div><pre><code>8.8.8.8
--&gt; Host Byte Order:    134744072
--&gt; Network Byte Order: 134744072

31.13.70.36
--&gt; Host Byte Order:    608570655
--&gt; Network Byte Order: 520963620

172.217.14.78
--&gt; Host Byte Order:    1309596076
--&gt; Network Byte Order: 2899906126
</code></pre></div></div>

<p>Of course the reason “8.8.8.8” had been working before was that it’s palindromic! So, big-endian, little-endian – it’s all the same. But for the rest, we can now clearly see the discrepancy.</p>


          

        
            
            
            
            
            
        

        
      </section>

      

      

      
  

    </div></div>
  </body>
</html>
