<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.youtube.com/watch?v=DxL2HoqLbyA">Original</a>
    <h1>Entropy: A little understood concept in physics [video]</h1>
    
    <div id="readability-page-1" class="page"><div><blockquote><p>Design guidelines for thin Python wrappers to C++ libraries</p></blockquote><h2 id="background">Background</h2><p>I recently ended up writing and rewriting a series of libraries to essentially
get them to a point where I could write bindings to them. In doing so, some
thoughts on design have evolved into this post.</p><h3 id="false-starts">False starts</h3><p>Originally, I had the library and bindings in one repository, which was easier
to hack on, and had fewer moving parts. I rashly assumed that using branches
would provide a modicum of reproducibility. As I quickly found though, this got
out of hand when the code needed to be refactored to suit the bindings and
wasn’t always backported to <code>main</code> in a timely fashion</p><h2 id="setup-preliminaries">Setup Preliminaries</h2><p>We will be as general in our suggestions as is humanely possible, but when we
need to reach for specific examples, they will be in context of the <code>potlib</code>
project (<a href="https://github.com/TheochemUI/potlib">library</a>, <a href="https://github.com/TheochemUI/pypotlib">bindings</a>), which is small and innocuous enough to grok
hopefully.</p><h3 id="tools">Tools</h3><p>For most new projects, I use <code>pybind11</code> <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> with <code>meson</code>.</p><ul><li><code>pdm</code> is used for dependencies / scripting / environments</li><li><code>mesonpy</code> is the backend</li><li><code>cibuildwheel</code> is used for actually getting the wheels for <code>pypi</code><ul><li>This is a bit of a nightmare, need to use <a href="https://repology.org/project/eigen/versions">repology</a> and fiddle around with
figuring out which version of each OS is used by each specification</li><li>Any kind of system based package management was exceedingly slow, so
sticking to <code>pip</code> and <code>meson</code> managed dependencies is the safest bet</li></ul></li></ul><h2 id="library-layout">Library Layout</h2><p>Taking <code>potlib</code> as a concrete example, my current favored layout looks like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span> 1</span><span>CppCore
</span></span><span><span> 2</span><span>├── examples
</span></span><span><span> 3</span><span>│   ├── calling_cuh2.cc
</span></span><span><span> 4</span><span>│   └── calling_ljpot.cc
</span></span><span><span> 5</span><span>├── gtests
</span></span><span><span> 6</span><span>│   └── CuH2PotTest.cc
</span></span><span><span> 7</span><span>├── meson.build
</span></span><span><span> 8</span><span>└── src
</span></span><span><span> 9</span><span>    ├── base_types.cc
</span></span><span><span>10</span><span>    ├── base_types.hpp
</span></span><span><span>11</span><span>    ├── CuH2
</span></span><span><span>12</span><span>    ├── helpers.cc
</span></span><span><span>13</span><span>    ├── helpers.hpp
</span></span><span><span>14</span><span>    ├── LennardJones
</span></span><span><span>15</span><span>    ├── Potential.cc
</span></span><span><span>16</span><span>    ├── Potential.hpp
</span></span><span><span>17</span><span>    └── pot_types.hpp
</span></span></code></pre></div><h3 id="linking-to-the-library">Linking to the library</h3><p><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git submodules</a> are generally the first thing to reach for when working with
repositories which depend on each other, but I found <code>meson</code> <a href="https://mesonbuild.com/Subprojects.html">subprojects</a> to be
less finicky if the library and bindings are all compatible with <code>meson</code>. The
documentation omits setting up a <code>.wrap</code> file for a project, so consider the
following (from <code>pypotlib</code>):</p><div><pre tabindex="0"><code data-lang="toml"><span><span>1</span><span><span>[</span><span>wrap-git</span><span>]</span>
</span></span><span><span>2</span><span><span>directory</span><span>=</span><span>potlib</span>
</span></span><span><span>3</span><span><span>url</span><span>=</span><span>https</span><span>://</span><span>github</span><span>.</span><span>com</span><span>/</span><span>TheochemUI</span><span>/</span><span>potlib</span><span>.</span><span>git</span>
</span></span><span><span>4</span><span><span>revision</span><span>=</span><span>5</span><span>d029b9</span>
</span></span><span><span>5</span><span>
</span></span><span><span>6</span><span><span>[</span><span>provide</span><span>]</span>
</span></span><span><span>7</span><span><span>potlib</span><span>=</span><span>git</span>
</span></span></code></pre></div><p>Which can be placed in <code>subprojects/potlib.wrap</code> of the bindings repo and should be committed.</p><h4 id="miscellaneous-meson-points">Miscellaneous <code>meson</code> points</h4><p>Personally I gravitate towards having a few standard default variables defined at the top level:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span>_args</span><span> </span><span>=</span><span> </span><span>[]</span><span> </span><span># Extra arguments</span><span>
</span></span></span><span><span>2</span><span><span></span><span>_deps</span><span> </span><span>=</span><span> </span><span>[]</span><span> </span><span># Dependencies</span><span>
</span></span></span><span><span>3</span><span><span></span><span>_linkto</span><span> </span><span>=</span><span> </span><span>[]</span><span> </span><span># All the sub-libraries</span><span>
</span></span></span><span><span>4</span><span><span></span><span>_incdirs</span><span> </span><span>=</span><span> </span><span>[]</span><span> </span><span># All the includes</span><span>
</span></span></span></code></pre></div><p>Along with the <code>clang</code> and <code>gcc</code> on Unix related dependencies:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span># Dependencies</span><span>
</span></span></span><span><span>2</span><span><span></span><span># libm for Unix systems</span><span>
</span></span></span><span><span>3</span><span><span></span><span>m_dep</span><span> </span><span>=</span><span> </span><span>cppc</span><span>.</span><span>find_library</span><span>(</span><span>&#39;m&#39;</span><span>,</span><span> </span><span>required</span><span>:</span><span> </span><span>false</span><span>)</span><span>
</span></span></span><span><span>4</span><span><span></span><span>_deps</span><span> </span><span>+=</span><span> </span><span>m_dep</span><span>
</span></span></span><span><span>5</span><span><span></span><span># For clang</span><span>
</span></span></span><span><span>6</span><span><span></span><span>_deps</span><span> </span><span>+=</span><span> </span><span>[</span><span>declare_dependency</span><span>(</span><span>link_args</span><span>:</span><span> </span><span>&#39;-lstdc++&#39;</span><span>)]</span><span>
</span></span></span></code></pre></div><p>This makes it easier to pull variables from subprojects in a seamless manner:
Linking to the library itself is best done by declaring a dependency <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span># ---------------------- Library Dependencies</span><span>
</span></span></span><span><span>2</span><span><span></span><span>potlib_proj</span><span> </span><span>=</span><span> </span><span>subproject</span><span>(</span><span>&#39;potlib&#39;</span><span>,</span><span> </span><span>version</span><span>:</span><span> </span><span>&#39;0.1&#39;</span><span>)</span><span>
</span></span></span><span><span>3</span><span><span></span><span># optionally use:</span><span>
</span></span></span><span><span>4</span><span><span>                        </span><span># default_options: [&#39;default_library=static&#39;])</span><span>
</span></span></span><span><span>5</span><span><span></span><span>potlib_dep</span><span> </span><span>=</span><span> </span><span>declare_dependency</span><span>(</span><span>link_with</span><span>:</span><span> </span><span>potlib_proj</span><span>.</span><span>get_variable</span><span>(</span><span>&#39;_linkto&#39;</span><span>),</span><span>
</span></span></span><span><span>6</span><span><span>                               </span><span>dependencies</span><span>:</span><span> </span><span>potlib_proj</span><span>.</span><span>get_variable</span><span>(</span><span>&#39;_deps&#39;</span><span>))</span><span>
</span></span></span><span><span>7</span><span><span></span><span>_deps</span><span> </span><span>+=</span><span> </span><span>[</span><span> </span><span>potlib_dep</span><span> </span><span>]</span><span>
</span></span></span></code></pre></div><p>Setting up targets is then also pretty straightforward:</p><div><pre tabindex="0"><code data-lang="meson"><span><span>1</span><span><span>blahlib</span><span> </span><span>=</span><span> </span><span>library</span><span>(</span><span>&#39;blah&#39;</span><span>,</span><span>
</span></span></span><span><span>2</span><span><span>                 </span><span>src_files</span><span>,</span><span>
</span></span></span><span><span>3</span><span><span>                 </span><span>dependencies</span><span>:</span><span> </span><span>_deps</span><span>,</span><span>
</span></span></span><span><span>4</span><span><span>                 </span><span>cpp_args</span><span>:</span><span> </span><span>_args</span><span>,</span><span>
</span></span></span><span><span>5</span><span><span>                 </span><span>link_with</span><span>:</span><span> </span><span>_linkto</span><span>,</span><span>
</span></span></span><span><span>6</span><span><span>                 </span><span>install</span><span>:</span><span> </span><span>true</span><span>)</span><span>
</span></span></span></code></pre></div><h2 id="binding-conventions">Binding Conventions</h2><ul><li>Always use <code>clang-format</code>.</li><li>All strings must be explicitly identified <code>&#34;&#34;s</code><ul><li><strong><strong>not for doc-strings</strong></strong> in <code>pybind11</code></li></ul></li></ul><h3 id="general">General</h3><ul><li>Always use <code>namespace py = pybind11;</code></li><li>For <code>Blah.cpp</code> the binding will be <code>pybinds/py_blah.cc</code></li><li>Most header content must be in <code>pybinds/py_wrapper.hpp</code><ul><li>The exceptions are base classes like <code>py_potential.hpp</code> since these need to be imported by child files like <code>potentials/py_morse.cc</code></li><li>If a header is supplied, then the corresponding <code>.cc</code> should <strong>only</strong> reference the header, which in turn should declare other dependencies.<ul><li>This only applies to files at the same tree/folder level</li></ul></li></ul></li><li>Every method must have:<ul><li>arguments defined</li><li>documentation string</li></ul></li></ul><p>Example:</p><div><pre tabindex="0"><code data-lang="c++"><span><span>1</span><span><span>.</span><span>def</span><span>(</span><span>&#34;setCell&#34;</span><span>,</span> <span>&amp;</span><span>Matter</span><span>::</span><span>setCell</span><span>,</span> <span>&#34;Sets the cell dimensions&#34;</span><span>s</span><span>,</span> <span>py</span><span>::</span><span>arg</span><span>(</span><span>&#34;AtomMatrix newCell&#34;</span><span>))</span>
</span></span></code></pre></div><h3 id="naming">Naming</h3><p>Naming is hard. To simplify long filenames and deep hierarchies, the following conventions are established:</p><ul><li>Within <code>objectivefunctions</code>, <code>ObjectiveFunction</code> can be replaced by <code>objfunc</code><ul><li>So <code>MatterObjectiveFunction</code> is bound in <code>py_matterobjfunc.cc</code></li></ul></li></ul><h3 id="class-boilerplate">Class boilerplate</h3><div><pre tabindex="0"><code data-lang="c++"><span><span> 1</span><span><span>void</span> <span>py_objectName</span><span>(</span><span>py</span><span>::</span><span>module_</span> <span>&amp;</span><span>m</span><span>)</span> <span>{</span>
</span></span><span><span> 2</span><span>    <span>py</span><span>::</span><span>class_</span><span>&lt;</span><span>ObjectName</span><span>&gt;</span><span>(</span><span>m</span><span>,</span> <span>&#34;ObjectName&#34;</span><span>,</span> <span>py</span><span>::</span><span>dynamic_attr</span><span>())</span> <span>// dynamic incurs a penalty
</span></span></span><span><span> 3</span><span><span></span>    <span>/*
</span></span></span><span><span> 4</span><span><span>    ** Constructors
</span></span></span><span><span> 5</span><span><span>    */</span>
</span></span><span><span> 6</span><span>
</span></span><span><span> 7</span><span>    <span>/*
</span></span></span><span><span> 8</span><span><span>    ** Operators
</span></span></span><span><span> 9</span><span><span>    */</span>
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span>    <span>/*
</span></span></span><span><span>12</span><span><span>    ** Methods
</span></span></span><span><span>13</span><span><span>    */</span>
</span></span><span><span>14</span><span>
</span></span><span><span>15</span><span>    <span>/*
</span></span></span><span><span>16</span><span><span>    ** Parameters
</span></span></span><span><span>17</span><span><span>    */</span>
</span></span><span><span>18</span><span>
</span></span><span><span>19</span><span>    <span>/*
</span></span></span><span><span>20</span><span><span>    ** Python helpers
</span></span></span><span><span>21</span><span><span>    */</span>
</span></span><span><span>22</span><span>
</span></span><span><span>23</span><span>    <span>.</span><span>def</span><span>(</span><span>&#34;__repr__&#34;</span><span>,</span> <span>[](</span><span>const</span> <span>ObjectName</span> <span>&amp;</span><span>a</span><span>)</span> <span>{</span> <span>return</span> <span>&#34;&lt;ObjectName object&gt;&#34;</span><span>;</span> <span>});</span>
</span></span><span><span>24</span><span><span>}</span>
</span></span></code></pre></div><h3 id="function-arguments">Function arguments</h3><ul><li>First one must be <code>py::arg()</code></li><li>Subsequent arguments may be <code>&#34;&#34;_a</code></li><li>When there is a non-obvious type used in the arguments, document it<ul><li>e.g. <code>AtomMatrix</code> and <code>VectorXd</code></li><li>Use <code>_</code> for spaces, e.g. <code>AtomMatrix_pos</code> for arguments <code>(AtomMatrix pos)</code></li></ul></li><li>When using overloads, always note the actual arguments as comments</li></ul><div><pre tabindex="0"><code data-lang="cpp"><span><span>1</span><span><span>py</span><span>::</span><span>overload_cast</span><span>&lt;</span><span>long</span> <span>/*nAtoms*/</span><span>,</span>
</span></span><span><span>2</span><span>                  <span>AtomMatrix</span> <span>/*positions*/</span><span>,</span>
</span></span><span><span>3</span><span>                  <span>VectorXi</span> <span>/*atomicNrs*/</span><span>,</span>
</span></span><span><span>4</span><span>                  <span>double</span> <span>*</span> <span>/*energy*/</span><span>,</span>
</span></span><span><span>5</span><span>                  <span>Matrix3d</span> <span>/*box*/</span><span>,</span>
</span></span><span><span>6</span><span>                  <span>int</span> <span>/*nImages*/</span>
</span></span><span><span>7</span><span>                  <span>&gt;</span><span>(</span><span>&amp;</span><span>Potential</span><span>::</span><span>force</span><span>),</span>
</span></span></code></pre></div><h2 id="structuring-bindings">Structuring Bindings</h2><p>Although a single file can be used for the <code>pybind11</code> bindings, I prefer a more
structured approach, consider the layout below:</p><div><pre tabindex="0"><code data-lang="bash"><span><span> 1</span><span>├── pyb11_srcs
</span></span><span><span> 2</span><span>│   ├── CuH2
</span></span><span><span> 3</span><span>│   │   ├── py_cuh2pot.cc
</span></span><span><span> 4</span><span>│   │   └── py_cuh2pot.hpp
</span></span><span><span> 5</span><span>│   ├── LennardJones
</span></span><span><span> 6</span><span>│   │   ├── py_ljpot.cc
</span></span><span><span> 7</span><span>│   │   └── py_ljpot.hpp
</span></span><span><span> 8</span><span>│   ├── py_potential.cc
</span></span><span><span> 9</span><span>│   ├── py_potential.hpp
</span></span><span><span>10</span><span>│   ├── py_pottypes.cc
</span></span><span><span>11</span><span>│   ├── py_wrapper.cc
</span></span><span><span>12</span><span>│   └── py_wrapper.hpp
</span></span></code></pre></div><p>Which mirrors the library design.</p><ul><li>Add to <code>py_wrapper.hpp</code></li></ul><div><pre tabindex="0"><code data-lang="c++"><span><span>1</span><span><span>PYBIND11_MODULE</span><span>(</span><span>eonclient</span><span>,</span> <span>m</span><span>)</span> <span>{</span>
</span></span><span><span>2</span><span>    <span>...</span>
</span></span><span><span>3</span><span>    <span>py_newthing</span><span>(</span><span>m</span><span>);</span>
</span></span><span><span>4</span><span><span>}</span>
</span></span></code></pre></div><ul><li>Make <code>py_newthing.cc</code></li></ul><div><pre tabindex="0"><code data-lang="c++"><span><span>1</span><span><span>// clang-format off
</span></span></span><span><span>2</span><span><span></span><span>#include</span> <span>&#34;py_wrapper.hpp&#34;</span><span>
</span></span></span><span><span>3</span><span><span></span><span>// Binding code (unless in py_wrapper)
</span></span></span><span><span>4</span><span><span></span><span>#include</span> <span>&#34;../newthing.h&#34;</span><span>
</span></span></span><span><span>5</span><span><span></span><span>// clang-format on
</span></span></span><span><span>6</span><span><span></span>
</span></span><span><span>7</span><span><span>void</span> <span>py_newthing</span><span>(</span><span>py</span><span>::</span><span>module_</span> <span>&amp;</span><span>m</span><span>)</span> <span>{</span>
</span></span><span><span>8</span><span>    <span>/* Wrapping details here */</span>
</span></span><span><span>9</span><span>    <span>}</span>
</span></span></code></pre></div><p>For a concrete example consider this <a href="https://github.com/TheochemUI/pypotlib/commit/99b944cf41544e87e2e2170a25eff5e2860b20b7">pypotlib commit</a>.</p><h2 id="conclusions">Conclusions</h2><p>So far this covered creating a single compiled extension for thin bindings to an
existing <code>c++</code> library. Using PRs and submodules turned out to be insufficient
to maintain code quality and I ended up shifting to a subproject based workflow.
Most of these evolved during my work on <a href="https://pypi.org/project/pypotlib/">pypotlib</a>, and a newer version of <code>eON</code>,
the long timescale dynamics code, which isn’t (as of April 2024) public
yet<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. A follow up post will cover adding pure python code which
can be used for generating a more pythonic interface and also the requirements
for distribution via PyPI.</p></div></div>
  </body>
</html>
