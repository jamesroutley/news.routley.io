<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.apple.com/videos/play/wwdc2023/10268">Original</a>
    <h1>Mergeable libraries [video]</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-06-01T00:00:00-07:00">June 1, 2023</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          3 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        

        
        <p><i>Daily dispatches from my 12 weeks at the Recurse Center in Summer 2023
</i></p>
        
        <p><a href="https://www.datadoodad.com/recurse%20center/RC10/">A few days ago</a> I posted the following schematic for a full adder, which I derived algebraically with a fellow recurser:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC10_adder-schematic.jpg" alt="Adder Schematic"/></p>

<p>The HDL for that looks like this:</p>

<div><div><pre><code>CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:A
    // Sum bit logic
    Xor(a=a, b=b, out=aXorb);
    Xor(a=aXorb, b=c, out=sum);

    // Carry bit logic
    Or(a=a, b=b, out=aOrb);
    And(a=c, b=aOrb, out=cAndaOrb);
    And(a=a, b=b, out=aAndb);
    Or(a=cAndaOrb, b=aAndb, out=carry);
}
</code></pre></div></div>

<p>But when my friend posted his HDL solution, it looked slightly different.</p>

<div><div><pre><code>CHIP FullAdder {
    IN a, b, c;  // 1-bit inputs
    OUT sum,     // Right bit of a + b + c
        carry;   // Left bit of a + b + c

    PARTS:A
    Xor(a=a, b=b, out=aXorb);
    Xor(a=aXorb, b=c, out=sum);
    And(a=c, b=aXorb, out=cAndaXorb);
    And(a=a, b=b, out=aAndb);
    Or(a=cAndaXorb, b=aAndb, out=carry);
}
</code></pre></div></div>

<p>That’s one fewer gate! Given that an <code>OR</code> gate consists of three <code>NAND</code> gates, in theory this solution is less expensive by three <code>NAND</code> gates, which, for a 16-bit adder, would amount to a savings of 48 <code>NAND</code> gates. Not too shabby.</p>

<p>Drawn out as a schematic, it looks like this:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder-schematic-simple.jpg" alt="Adder Schematic"/></p>

<p>So what’s going on here? Where did that savings come from?</p>

<p>If we look again at the truth tables for the sum and carry bits, we’ll notice that they have something in common, namely \(a \land b \land c\). This is easiest to see with venn diagrams:</p>

<table>
  <thead>
    <tr>
      <th>Sum bit</th>
      <th>Carry bit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><img src="https://www.datadoodad.com/assets/images/RC10_sum-bit.png" alt="Sum bit logic"/></td>
      <td><img src="https://www.datadoodad.com/assets/images/RC10_carry-bit.png" alt="Carry bit logic"/></td>
    </tr>
  </tbody>
</table>

<p>Let’s revisit this logic.</p>

<p>Notice that the first selection I make for the carry bit at the bottom left is \(a \land b\).</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_1.png" alt="a and b"/></p>

<p>That means all I’m missing are these two yellow areas to get the full logic I need:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_2.png" alt="a and b with remaining target areas for carry bit"/></p>

<p>To account for the above yellow areas, I <code>OR</code>ed the first selection (\(a \land b\)) with \((a \lor b) \land c\).</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_3.png" alt="full carry bit logic"/></p>

<p>What you’ll notice now is that I’m essentially double-dipping on the middle section, \(a \land b \land c\), since I’ve selected it twice. I’m not sure that this is a problem in and of itself, however it turns out that elsewhere in the circuit we are actually already creating the missing pieces.</p>

<p>Here’s why. When we’re dealing with the logic for the sum bit, we end up with the following after \(a \oplus b\):</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_4.png" alt="a xor b"/></p>

<p>And if we <code>AND</code> the above with <code>c</code>, we end up with the little slices that we need:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_5.png" alt="a xor b or c"/></p>

<p>Just to be precise, I’ve labeled the above as \((a \oplus b) \lor c\), however the green areas are \((a \oplus b) \land c\).</p>

<p>In any case, now that we have these green intersections, we can add them to the the red intersection with which we began to complete the carry bit logic like so:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder_6.png" alt="revised carry bit logic"/></p>

<p>That’s how my friend’s revised solution resolves a redundancy in my 6-gate circuit and does the same with 5 gates.</p>

<p>To my credit, when I drew out the 6-gate solution with <code>NAND</code>s, it initially required 20 gates, which I reduced to 14 just from looking for redundacies (things like negated negations, etc.). Here’s my 14-gate <code>NAND</code> adder logic:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder-schematic-nand-corrected.jpg" alt="Adder Schematic"/></p>

<p>As far as I can tell, my friend’s 5-gate solution only requires one fewer <code>NAND</code> gate:</p>

<p><img src="https://www.datadoodad.com/assets/images/RC13_adder-schematic-nand-improved.jpg" alt="Adder Schematic"/></p>

<p>But an improvement is an improvement, so I’ll take it!</p>



<p>Today was impossible stuff day, but unfortunately I didn’t really get to the impossible stuff I had planned. Won’t make that same mistake next time though.</p>

<ul>
  <li>made it to checkins</li>
  <li>did a mock technical interview which turned out to go well in spite of feeling like my brain was freezing up at the beginning. It’s definitely hard to think and problem-solve out loud and under the spotlight, but that’s the nature of the beast, I suppose. Anyway, to the extent that technical interviews seemed impossible to me, seems like perhaps I made some progress on an impossible thing after all.</li>
  <li>made some progress on SICP</li>
  <li>finished ALU simulator featured in <a href="https://www.datadoodad.com/recurse%20center/RC12/">yesterday’s blog</a>, which I didn’t finish and post until today (time warp)</li>
</ul>


          

        

        
      </section>

      

      

      
  <nav>
    
      <a href="https://www.datadoodad.com/recurse%20center/RC12/" title="RC12. Building an ALU
">Previous</a>
    
    
      <a href="https://www.datadoodad.com/recurse%20center/RC14/" title="RC14. Quantifying my first 25% of RC
">Next</a>
    
  </nav>

    </div></div>
  </body>
</html>
