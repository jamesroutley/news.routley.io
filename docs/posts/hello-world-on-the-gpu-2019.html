<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acko.net/blog/hello-world-on-the-gpu/">Original</a>
    <h1>Hello World on the GPU (2019)</h1>
    
    <div id="readability-page-1" class="page"><article>

  
    <img src="https://acko.net/files/hello-gpu/cover.jpg" alt="Hello World on the GPU"/>
  

  
  
    <div><div>

<h2>An Easy Tutorial</h2>

<p>Graphics programming can be intimidating. It involves a fair amount of math, some low-level code, and it&#39;s often hard to debug. Nevertheless I&#39;d like to show you how to do a simple &#34;Hello World&#34; on the GPU. You will see that there is in fact nothing to be afraid of.</p>

<p>Most environments offer you a <code>printf</code>-equivalent and a <code>string</code> type, but that&#39;s not how we do things in GPU land. We like the raw stuff, and we work with pixels themselves. So we&#39;re going to draw our text to the console directly. I&#39;ll show you the general high level flow, and then wrap up some of the details.</p>

<p><img src="https://acko.net/files/hello-gpu/window.png" alt="a window saying hello world"/></p>

</div></div>

<div><div>

<p>First, we&#39;re going to define our alphabet.</p>

<pre><code>let alphabet = allocate_values(
  &amp;[&#39;H&#39;, &#39;E&#39;, &#39;L&#39;, &#39;O&#39;, &#39;W&#39;, &#39;R&#39;, &#39;D&#39;, &#39;ðŸŒŽ&#39;],
  AlphabetFormat::Letter);</code></pre>




<p>Next we define our message by encoding it from this alphabet.</p>

<pre><code>let message = allocate_indices(
//  H  E  L  L  O  W  O  R  L  D
  &amp;[0, 1, 2, 2, 3, 4, 3, 5, 2, 6, 7],
  IndexFormat::Uint8);</code></pre>




<p>We&#39;ll also need to assemble this alphabet soup into positioned text. Don&#39;t worry, I precalculated the horizontal X offsets:</p>

<pre><code>let xs = allocate_values(
  &amp;[0.0, 49.0, 130.0, 195.0, 216.0, 238.0, 328.0, 433.0, 496.0, 537.0, 561.0, 667.0],
  AlphabetFormat::Float);</code></pre>




<p>The font is loaded as <code>glyphs</code>, a map of glyph images:</p>

<pre><code>let glyphs = console.load_glyphs(&#34;helvetica.ttf&#34;);</code></pre>



</div></div>

<div><div>

<p>We now have everything we need to print it pixel-by-pixel to the top of the console, which we call &#39;rasterizing&#39;:</p>

<pre><code>fn hello_world(
  line: Line,
  message: Vec&lt;Index&gt;,
  alphabet: Vec&lt;Letter&gt;,
  xs: Vec&lt;Float&gt;,
  args: Vec&lt;Argument&gt;,
) {
  // Get glyph library
  let glyphs = args[0];

  // Loop over all the indices in the message
  for i in 0..message.len() {

    // Retrieve the x position for this index.
    let x = xs[i];

    // Retrieve the letter in the alphabet
    let letter = alphabet[message[i]];
    
    // Retrieve the glyph image for this letter
    let glyph  = glyphs[letter];

    // Rasterize it to the line
    rasterize(line, x, glyph.image, glyph.width, glyph.height);
  }
}</code></pre>




<p><code>rasterize()</code> is provided for you, but if you&#39;re curious, this is what it looks like on the inside:</p>

<pre><code>fn rasterize(
  line: Line,
  offset: Float,
  image: Frame,
  width: Int,
  height: Int
) {

  // Iterate over rows and columns
  for y in 0..height {
    for x in 0..width {

      // Get target position
      let tx = x + offset;
      let ty = y;

      // Get image pixel color
      let source = get(image, x, y);

      // Get current target pixel color
      let destination = get(line, tx, ty);

      // Blend source color with destination color
      let blended = blend(source, destination);

      // Save new color to target
      set(target, tx, ty, blended);
    }
  }
};</code></pre>




<p>It&#39;s just like blending pixels in Photoshop, with a simple nested rows-and-columns loop.</p>

</div></div>

<div><div>

<p>Okay so I did gloss over an important detail.</p>

<p>The thing is, you can&#39;t just call <code>hello_world(...)</code> to run your code. I know it looks like a regular function, just like <code>rasterize()</code>, but it turns out you can only call built-in functions directly. If you want to call one of your own functions, you need to do a little bit extra, because the calling convention is slightly different. I&#39;ll just go over the required steps so you can follow along.</p>

</div></div>

<div><div>

<p>First you need to actually access the console you want to print to.</p>

<p>So you create a console instance:</p>

<pre data-sins="1"><code>let instance = Console::Instance::new();</code></pre>




<p>and get an adapter from it:</p>

<pre data-sins="2"><code>let adapter =
  instance.get_adapter(
    &amp;AdapterDescriptor {
      font_preference: FontPreference::Smooth,
    });</code></pre>




<p>so you can get an actual console:</p>

<pre data-sins="3"><code>let console =
  adapter.create_console(
    &amp;ConsoleDescriptor {
      extensions: Extensions {
        subpixel_antialiasing: true,
      },
    });</code></pre>



</div></div>

<div><div>

<p>But this console doesn&#39;t actually do anything yet. You need to create an interactive window to put it in:</p>

<pre data-sins="4"><code>let events_loop = EventsLoop::new();

let window = WindowBuilder::new()
  .with_dimensions(LogicalSize {
    width: 1280.0, height: 720.0
  })
  .with_title(&#34;Console&#34;)
  .build(&amp;events_loop).unwrap();</code></pre>




<p>and then make a surface to draw to:</p>

<pre data-sins="1"><code>let surface = instance.create_surface();</code></pre>




</div></div>

<div><div>


<p>Now if you want to print more than one line of text, you need to set up a line feed:</p>

<pre data-sins="3"><code>let descriptor =
  LineFeedDescriptor {
    usage: LineUsageFlags::OUTPUT_ATTACHMENT,
    format: TextFormat::UTF8,
    width: 120,
    height: 50,
  };

let line_feed = console.create_line_feed(&amp;surface, &amp;descriptor);

let next_line = line_feed.get_next_line();</code></pre>




</div></div>

<div><div>


<p>And if you want emoji, which we do, you need a separate emoji buffer too:</p>

<pre data-sins="4"><code>let images =
  console.create_emoji(
    EmojiDescriptor {
      size: Extent2d {
        width: 256,
        height: 256,
      },
      array_size: 1024,
      dimension: ImageDimension::D2,
      format: ImageFormat::RGBA8,
      usage: ImageUsageFlags::OUTPUT_ATTACHMENT,
    });

let emoji_buffer = images.create_default_view();</code></pre>




<p>Okay, we&#39;re all set!</p>


</div></div>

<div><div>

<p>Now we just need to encode the call, using a call encoder:</p>

<pre data-sins="1"><code>let encoder = console.create_call_encoder();</code></pre>




<p>We begin by describing the special first argument (<code>line</code>), a combo of <code>next_line</code> and the <code>emoji_buffer</code>. We also have to provide some additional flags and parameters:</p>

<pre data-sins="5"><code>let call =
  encoder.encode_function_call(
    FunctionCallDescriptor {
      console_attachments: &amp;[
        ConsoleAttachmentDescriptor {
          attachment: &amp;next_line,
          load_op: LoadOp::Clear,
          store_op: StoreOp::Store,
          clear_letter: &#39; &#39;,
        }
      ],
      emoji_attachment: Some(
        ConsoleEmojiAttachmentDescriptor {
          attachment: &amp;emoji_buffer,
          load_op: LoadOp::Clear,
          store_op: StoreOp::Store,
          clear_color: &#34;rgba(0, 0, 0, 0)&#34;,
        })
    });</code></pre>




<p>The <code>message</code> of type <code>Vec&lt;Index&gt;</code> is added using a built-in convention for indices:</p>

<pre><code>call.set_index_buffer(message);</code></pre>




<p>The <code>alphabet: Vec&lt;Letter&gt;</code> and the <code>xs: Vec&lt;Float&gt;</code> can also be directly passed in, because they are accessed 1-to-1 using our indices, as numbered arguments:</p>

<pre data-sins="1"><code>call.set_alphabet_buffers(&amp;[
  (&amp;alphabet, 0), (&amp;xs, 1)
]);</code></pre>




<p>However, the glyph images are a bit trickier, as they are a custom keyword argument.</p>

<p>To make this work, we need to create an argument group layout, which describes how we&#39;ll pass the arguments to sample our glyph images:</p>

<pre data-sins="5"><code>let argument_group_layout =
  console.create_argument_group_layout(
    &amp;ArgumentGroupLayoutDescriptor {
      bindings: &amp;[
        ArgumentGroupLayoutBinding {
            binding: 0,
            visibility: Visibility::PIXEL,
            ty: BindingType::SampledText,
        },
        ArgumentGroupLayoutBinding {
            binding: 1,
            visibility: Visibility::PIXEL,
            ty: BindingType::Sampler,
        },
      ]
    });</code></pre>




<p>We then put it into a larger function call layout, in case we have multiple groups of keyword arguments:</p>

<pre data-sins="2"><code>let function_call_layout =
  console.create_function_call_layout(
    FunctionCallLayoutDescriptor {
      argument_group_layouts: &amp;[argument_group_layout],
    });</code></pre>




<p>We also need to create bindings to match this layout, to actually bind our argument values:</p>

<pre data-sins="8"><code>let glyph_view = glyphs.create_default_view();

let sampler = console.create_sampler(
  &amp;TextSamplerDescriptor {
    address_mode: AddressMode::ClampToEdge,
    text_filter: FilterMode::TypeHinted,
    hint_clamp: 100.0,
    max_anisotropy: 4,
    compare_function: CompareFunction::Always,
    border_color: BorderColor::TransparentBlack,
  });

let argument_group =
  console.create_argument_group(
    &amp;BindGroupDescriptor {
      layout: argument_group_layout,
      bindings: &amp;[
        Binding {
          binding: 0,
          resource: BindingResource::ImageView(&amp;glyph_view),
        },
        Binding {
          binding: 1,
          resource: BindingResource::Sampler(&amp;sampler),
        },
      ]
    });</code></pre>




<p>And add it to our call:</p>

<pre><code>call.set_argument_group(0, argument_group);</code></pre>



</div></div>

<div><div>

<p>Alright! We&#39;re pretty much ready to make the call now. Just one more thing. The function call descriptor.</p>

<p>We need to pass the raw code for <code>hello_world</code> as a string to <code>console.create_code_module</code>, and annotate it with a few extra bits of information:</p>

<pre data-sins="15"><code>let function_call =
  console.create_function_call(
    &amp;FunctionCallDescriptor {
      layout: &amp;function_call_layout,
      call_stage: CallStageDescriptor {
        module: console.create_code_module(&amp;hello_world),
        entry_point: &#34;hello_world&#34;,
      },
      rasterization_state: RasterizationStateDescriptor {
        emoji_alignment: Alignment::Middle,
        emoji_bias: 0,
        emoji_scale: 1.5,
      },
      text_topology: Topology::Letters,
      console_states: &amp;[
        ConsoleStateDescriptor {
          format: TextFormat::UTF8,
          color: BlendDescriptor {
            src_factor: BlendFactor::SrcAlpha,
            dst_factor: BlendFactor::OneMinusSrcAlpha,
            operation: BlendOperation::Add,
          },
          alpha: BlendDescriptor {
            src_factor: BlendFactor::OneMinusDstAlpha,
            dst_factor: BlendFactor::One,
            operation: BlendOperation::Add,
          },
          write_mask: ColorWriteFlags::ALL,
        },
      ],
      emoji_state: Some(EmojiStateDescriptor {
        format: ImageFormat::RGBA8,
        emoji_enabled: true,
        emoji_variant: CompareFunction::LessEqual,
      }),
      index_format: IndexFormat::Uint8,
      alphabet_buffers: &amp;[
        AlphabetBufferDescriptor {
          stride: 1,
          step_mode: InputStepMode::Letter,
          attributes: AlphabetAttributeDescriptor {
            attribute_index: 0,
            format: AlphabetFormat::Letter,
            offset: 0,
          },
        },
        AlphabetBufferDescriptor {
          stride: 1,
          step_mode: InputStepMode::Letter,
          attributes: AlphabetAttributeDescriptor {
            attribute_index: 1,
            format: AlphabetFormat::Number,
            offset: 0,
          },
        },
      ],
      sample_count: 1,
    });</code></pre>




<p>Which we add to the call:</p>

<pre><code>call.set_function_call(&amp;function_call);</code></pre>




<p>Well, you actually have to do this first, but it was easier to explain it last.</p>

</div></div>

<div><div>

<p>Now all that&#39;s left is to submit the encoded command to the console queue, and we&#39;re already done:</p>

<pre data-sins="2"><code>console
  .get_queue()
  .submit(&amp;[encoder.finish()]);</code></pre>



</div></div>

<div><div>

<p><img src="https://acko.net/files/hello-gpu/window2.png" alt="a black window"/></p>

<p>Hm.</p>

<p>Damn, and I was going to show you how to make a matrix letter effect as an encore. You can pass a <code>letter_shader</code> to <code>rasterizeWithLetterFX(...)</code>. It&#39;s easy, takes a couple hundred lines tops, all you have to do is call a function on a GPU.</p>

<p><em>(All code in this post is real, but certain names and places have been changed to protect the innocent. If you&#39;d like to avoid tedious bureaucracy in your code, why not read about how <a href="https://acko.net/blog/the-incremental-machine">the web people are</a> <a href="https://acko.net/blog/model-view-catharsis">trying to tame similar lions</a>?)</em></p>



</div></div>








  

  
</article></div>
  </body>
</html>
