<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fuckingapproachableswiftconcurrency.com/en/">Original</a>
    <h1>Approachable Swift Concurrency</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
  
</section>
<section id="async-await">
  <div>
<h2><a href="#async-await">Async Code: async/await</a></h2>
<p>Most of what apps do is wait. Fetch data from a server - wait for the response. Read a file from disk - wait for the bytes. Query a database - wait for the results.</p>
<p>Before Swift&#39;s concurrency system, you&#39;d express this waiting with callbacks, delegates, or <a href="https://developer.apple.com/documentation/combine">Combine</a>. They work, but nested callbacks get hard to follow, and Combine has a steep learning curve.</p>
<p><code>async/await</code> gives Swift a new way to handle waiting. Instead of callbacks, you write code that looks sequential - it pauses, waits, and resumes. Under the hood, Swift&#39;s runtime manages these pauses efficiently. But making your app actually stay responsive while waiting depends on <em>where</em> code runs, which we&#39;ll cover later.</p>
<p>An <strong>async function</strong> is one that might need to pause. You mark it with <code>async</code>, and when you call it, you use <code>await</code> to say &#34;pause here until this finishes&#34;:</p>
<pre><code><span>func</span> <span>fetchUser</span><span>(</span>id<span>:</span> <span>Int</span><span>)</span> <span>async</span> <span>throws</span> <span>-&gt;</span> <span>User</span> <span>{</span>
    <span>let</span> url <span>=</span> <span>URL</span><span>(</span>string<span>:</span> <span><span>&#34;https://api.example.com/users/</span><span>\(</span><span>id</span><span>)</span><span>&#34;</span></span><span>)</span><span>!</span>
    <span>let</span> <span>(</span>data<span>,</span> <span>_</span><span>)</span> <span>=</span> <span>try</span> <span>await</span> <span>URLSession</span><span>.</span>shared<span>.</span><span>data</span><span>(</span>from<span>:</span> url<span>)</span>  
    <span>return</span> <span>try</span> <span>JSONDecoder</span><span>(</span><span>)</span><span>.</span><span>decode</span><span>(</span><span>User</span><span>.</span><span>self</span><span>,</span> from<span>:</span> data<span>)</span>
<span>}</span>


<span>let</span> user <span>=</span> <span>try</span> <span>await</span> <span>fetchUser</span><span>(</span>id<span>:</span> <span>123</span><span>)</span>
</code></pre>
<p>Your code pauses at each <code>await</code> - this is called <strong>suspension</strong>. When the work finishes, your code resumes right where it left off. Suspension gives Swift the opportunity to do other work while waiting.</p>
<h3>Waiting for <em>them</em></h3>
<p>What if you need to fetch several things? You could await them one by one:</p>
<pre><code><span>let</span> avatar <span>=</span> <span>try</span> <span>await</span> <span>fetchImage</span><span>(</span><span><span>&#34;avatar.jpg&#34;</span></span><span>)</span>
<span>let</span> banner <span>=</span> <span>try</span> <span>await</span> <span>fetchImage</span><span>(</span><span><span>&#34;banner.jpg&#34;</span></span><span>)</span>
<span>let</span> bio <span>=</span> <span>try</span> <span>await</span> <span>fetchBio</span><span>(</span><span>)</span></code></pre>
<p>But that&#39;s slow - each waits for the previous one to finish. Use <code>async let</code> to run them in parallel:</p>
<pre><code><span>func</span> <span>loadProfile</span><span>(</span><span>)</span> <span>async</span> <span>throws</span> <span>-&gt;</span> <span>Profile</span> <span>{</span>
    <span>async</span> <span>let</span> avatar <span>=</span> <span>fetchImage</span><span>(</span><span><span>&#34;avatar.jpg&#34;</span></span><span>)</span>
    <span>async</span> <span>let</span> banner <span>=</span> <span>fetchImage</span><span>(</span><span><span>&#34;banner.jpg&#34;</span></span><span>)</span>
    <span>async</span> <span>let</span> bio <span>=</span> <span>fetchBio</span><span>(</span><span>)</span>

    
    <span>return</span> <span>Profile</span><span>(</span>
        avatar<span>:</span> <span>try</span> <span>await</span> avatar<span>,</span>
        banner<span>:</span> <span>try</span> <span>await</span> banner<span>,</span>
        bio<span>:</span> <span>try</span> <span>await</span> bio
    <span>)</span>
<span>}</span></code></pre>
<p>Each <code>async let</code> starts immediately. The <code>await</code> collects the results.</p>
<div>
<h4>await needs async</h4>
<p>You can only use <code>await</code> inside an <code>async</code> function.</p>
</div>
  </div>
</section>
<section id="tasks">
  <div>
<h2><a href="#tasks">Managing Work: Tasks</a></h2>
<p>A <strong><a href="https://developer.apple.com/documentation/swift/task">Task</a></strong> is a unit of async work you can manage. You&#39;ve written async functions, but a Task is what actually runs them. It&#39;s how you start async code from synchronous code, and it gives you control over that work: wait for its result, cancel it, or let it run in the background.</p>
<p>Let&#39;s say you&#39;re building a profile screen. Load the avatar when the view appears using the <a href="https://developer.apple.com/documentation/swiftui/view/task(priority:_:)"><code>.task</code></a> modifier, which cancels automatically when the view disappears:</p>
<pre><code><span>struct</span> <span>ProfileView</span><span>:</span> <span>View</span> <span>{</span>
    <span>@State</span> <span>private</span> <span>var</span> avatar<span>:</span> <span>Image</span><span>?</span>

    <span>var</span> body<span>:</span> <span>some</span> <span>View</span> <span>{</span>
        avatar
            <span>.</span>task <span>{</span> avatar <span>=</span> <span>await</span> <span>downloadAvatar</span><span>(</span><span>)</span> <span>}</span>
    <span>}</span>
<span>}</span></code></pre>
<p>If users can switch between profiles, use <code>.task(id:)</code> to reload when the selection changes:</p>
<pre><code><span>struct</span> <span>ProfileView</span><span>:</span> <span>View</span> <span>{</span>
    <span>var</span> userID<span>:</span> <span>String</span>
    <span>@State</span> <span>private</span> <span>var</span> avatar<span>:</span> <span>Image</span><span>?</span>

    <span>var</span> body<span>:</span> <span>some</span> <span>View</span> <span>{</span>
        avatar
            <span>.</span><span>task</span><span>(</span>id<span>:</span> userID<span>)</span> <span>{</span> avatar <span>=</span> <span>await</span> <span>downloadAvatar</span><span>(</span><span>for</span><span>:</span> userID<span>)</span> <span>}</span>
    <span>}</span>
<span>}</span></code></pre>
<p>When the user taps &#34;Save&#34;, create a Task manually:</p>
<pre><code><span>Button</span><span>(</span><span><span>&#34;Save&#34;</span></span><span>)</span> <span>{</span>
    <span>Task</span> <span>{</span> <span>await</span> <span>saveProfile</span><span>(</span><span>)</span> <span>}</span>
<span>}</span></code></pre>
<p>What if you need to load the avatar, bio, and stats all at once? Use a <a href="https://developer.apple.com/documentation/swift/taskgroup"><code>TaskGroup</code></a> to fetch them in parallel:</p>
<pre><code><span>try</span> <span>await</span> <span>withThrowingTaskGroup</span><span>(</span>of<span>:</span> <span>Void</span><span>.</span><span>self</span><span>)</span> <span>{</span> group <span>in</span>
    group<span>.</span>addTask <span>{</span> avatar <span>=</span> <span>try</span> <span>await</span> <span>downloadAvatar</span><span>(</span><span>for</span><span>:</span> userID<span>)</span> <span>}</span>
    group<span>.</span>addTask <span>{</span> bio <span>=</span> <span>try</span> <span>await</span> <span>fetchBio</span><span>(</span><span>for</span><span>:</span> userID<span>)</span> <span>}</span>
    group<span>.</span>addTask <span>{</span> stats <span>=</span> <span>try</span> <span>await</span> <span>fetchStats</span><span>(</span><span>for</span><span>:</span> userID<span>)</span> <span>}</span>
    <span>try</span> <span>await</span> group<span>.</span><span>waitForAll</span><span>(</span><span>)</span>
<span>}</span></code></pre>
<p>Tasks inside a group are <strong>child tasks</strong>, linked to the parent. A few things to know:</p>
<ul>
<li><strong>Cancellation propagates</strong>: cancel the parent, and all children get cancelled too</li>
<li><strong>Errors</strong>: a thrown error cancels siblings and rethrows, but only when you consume results with <code>next()</code>, <code>waitForAll()</code>, or iteration</li>
<li><strong>Completion order</strong>: results arrive as tasks finish, not the order you added them</li>
<li><strong>Waits for all</strong>: the group doesn&#39;t return until every child completes or is cancelled</li>
</ul>
<p>This is <strong><a href="https://developer.apple.com/videos/play/wwdc2021/10134/">structured concurrency</a></strong>: work organized in a tree that&#39;s easy to reason about and clean up.</p>
  </div>
</section>
<section id="execution">
  <div>
<h2><a href="#execution">Where Things Run: From Threads to Isolation Domains</a></h2>
<p>So far we&#39;ve talked about <em>when</em> code runs (async/await) and <em>how to organize</em> it (Tasks). Now: <strong>where does it run, and how do we keep it safe?</strong></p>
<div>
<h4>Most apps just wait</h4>
<p>Most app code is <strong>I/O-bound</strong>. You fetch data from a network, <em>await</em> a response, decode it, and display it. If you have multiple I/O operations to coordinate, you resort to <em>tasks</em> and <em>task groups</em>. The actual CPU work is minimal. The main thread can handle this fine because <code>await</code> suspends without blocking.</p>
<p>But sooner or later, you&#39;ll have <strong>CPU-bound work</strong>: parsing a giant JSON file, processing images, running complex calculations. This work doesn&#39;t wait for anything external. It just needs CPU cycles. If you run it on the main thread, your UI freezes. This is where &#34;where does code run&#34; actually matters.</p>
</div>
<h3>The Old World: Many Options, No Safety</h3>
<p>Before Swift&#39;s concurrency system, you had several ways to manage execution:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>What it does</th>
<th>Tradeoffs</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.apple.com/documentation/foundation/thread">Thread</a></td>
<td>Direct thread control</td>
<td>Low-level, error-prone, rarely needed</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/documentation/dispatch">GCD</a></td>
<td>Dispatch queues with closures</td>
<td>Simple but no cancellation, easy to cause thread explosion</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/documentation/foundation/operationqueue">OperationQueue</a></td>
<td>Task dependencies, cancellation, KVO</td>
<td>More control but verbose and heavyweight</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/documentation/combine">Combine</a></td>
<td>Reactive streams</td>
<td>Great for event streams, steep learning curve</td>
</tr>
</tbody>
</table>
<p>All of these worked, but safety was entirely on you. The compiler couldn&#39;t help if you forgot to dispatch to main, or if two queues accessed the same data simultaneously.</p>
<h3>The Problem: Data Races</h3>
<p>A <a href="https://developer.apple.com/documentation/xcode/data-race">data race</a> happens when two threads access the same memory at the same time, and at least one is writing:</p>
<pre><code><span>var</span> count <span>=</span> <span>0</span>

<span>DispatchQueue</span><span>.</span><span>global</span><span>(</span><span>)</span><span>.</span><span>async</span> <span>{</span> count <span>+=</span> <span>1</span> <span>}</span>
<span>DispatchQueue</span><span>.</span><span>global</span><span>(</span><span>)</span><span>.</span><span>async</span> <span>{</span> count <span>+=</span> <span>1</span> <span>}</span>

</code></pre>
<p>Data races are undefined behavior. They can crash, corrupt memory, or silently produce wrong results. Your app works fine in testing, then crashes randomly in production. Traditional tools like locks and semaphores help, but they&#39;re manual and error-prone.</p>
<div>
<h4>Concurrency amplifies the problem</h4>
<p>The more concurrent your app is, the more likely data races become. A simple iOS app might get away with sloppy thread safety. A web server handling thousands of simultaneous requests will crash constantly. This is why Swift&#39;s compile-time safety matters most in high-concurrency environments.</p>
</div>
<h3>The Shift: From Threads to Isolation</h3>
<p>Swift&#39;s concurrency model asks a different question. Instead of &#34;which thread should this run on?&#34;, it asks: <strong>&#34;who is allowed to access this data?&#34;</strong></p>
<p>This is <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/#Isolation">isolation</a>. Rather than manually dispatching work to threads, you declare boundaries around data. The compiler enforces these boundaries at build time, not runtime.</p>
<div>
<h4>Under the hood</h4>
<p>Swift Concurrency is built on top of <a href="https://github.com/swiftlang/swift-corelibs-libdispatch">libdispatch</a> (the same runtime as GCD). The difference is the compile-time layer: actors and isolation are enforced by the compiler, while the runtime handles scheduling on a <a href="https://developer.apple.com/videos/play/wwdc2021/10254/">cooperative thread pool</a> limited to your CPU&#39;s core count.</p>
</div>
<h3>The Three Isolation Domains</h3>
<p><strong>1. MainActor</strong></p>
<p><a href="https://developer.apple.com/documentation/swift/mainactor"><code>@MainActor</code></a> is a <a href="https://developer.apple.com/documentation/swift/globalactor">global actor</a> that represents the main thread&#39;s isolation domain. It&#39;s special because UI frameworks (UIKit, AppKit, SwiftUI) require main thread access.</p>
<pre><code><span>@MainActor</span>
<span>class</span> <span>ViewModel</span> <span>{</span>
    <span>var</span> items<span>:</span> <span>[</span><span>Item</span><span>]</span> <span>=</span> <span>[</span><span>]</span>  
<span>}</span></code></pre>
<p>When you mark something <code>@MainActor</code>, you&#39;re not saying &#34;dispatch this to the main thread.&#34; You&#39;re saying &#34;this belongs to the main actor&#39;s isolation domain.&#34; The compiler enforces that anything accessing it must either be on MainActor or <code>await</code> to cross the boundary.</p>
<div>
<h4>When in doubt, use @MainActor</h4>
<p>For most apps, marking your ViewModels with <code>@MainActor</code> is the right choice. Performance concerns are usually overblown. Start here, optimize only if you measure actual problems.</p>
</div>
<p><strong>2. Actors</strong></p>
<p>An <a href="https://developer.apple.com/documentation/swift/actor">actor</a> protects its own mutable state. It guarantees that only one piece of code can access its data at a time:</p>
<pre><code><span>actor</span> <span>BankAccount</span> <span>{</span>
    <span>var</span> balance<span>:</span> <span>Double</span> <span>=</span> <span>0</span>

    <span>func</span> <span>deposit</span><span>(</span><span>_</span> amount<span>:</span> <span>Double</span><span>)</span> <span>{</span>
        balance <span>+=</span> amount  
    <span>}</span>
<span>}</span>


<span>await</span> account<span>.</span><span>deposit</span><span>(</span><span>100</span><span>)</span></code></pre>
<p><strong>Actors are not threads.</strong> An actor is an isolation boundary. The Swift runtime decides which thread actually executes actor code. You don&#39;t control that, and you don&#39;t need to.</p>
<p><strong>3. Nonisolated</strong></p>
<p>Code marked <a href="https://developer.apple.com/documentation/swift/nonisolated"><code>nonisolated</code></a> opts out of actor isolation. It can be called from anywhere without <code>await</code>, but it cannot access the actor&#39;s protected state:</p>
<pre><code><span>actor</span> <span>BankAccount</span> <span>{</span>
    <span>var</span> balance<span>:</span> <span>Double</span> <span>=</span> <span>0</span>

    <span>nonisolated</span> <span>func</span> <span>bankName</span><span>(</span><span>)</span> <span>-&gt;</span> <span>String</span> <span>{</span>
        <span><span>&#34;Acme Bank&#34;</span></span>  
    <span>}</span>
<span>}</span>

<span>let</span> name <span>=</span> account<span>.</span><span>bankName</span><span>(</span><span>)</span>  </code></pre>
<div>
<h4>Approachable Concurrency: Less Friction</h4>
<p><a href="https://www.swift.org/blog/swift-6.2-released/#approachable-concurrency">Approachable Concurrency</a> simplifies the mental model with two Xcode build settings:</p>
<ul>
<li><strong><code>SWIFT_DEFAULT_ACTOR_ISOLATION</code></strong> = <code>MainActor</code>: Everything runs on MainActor unless you say otherwise</li>
<li><strong><code>SWIFT_APPROACHABLE_CONCURRENCY</code></strong> = <code>YES</code>: <code>nonisolated</code> async functions stay on the caller&#39;s actor instead of jumping to a background thread</li>
</ul>
<p>New Xcode 26 projects have both enabled by default. When you need CPU-intensive work off the main thread, use <code>@concurrent</code>.</p>
<pre><code>// Runs on MainActor (the default)
func updateUI() async { }

// Runs on background thread (opt-in)
@concurrent func processLargeFile() async { }</code></pre>
</div>
<div>
<h4>The Office Building</h4>
<p>Think of your app as an office building. Each <strong>isolation domain</strong> is a private office with a lock on the door. Only one person can be inside at a time, working with the documents in that office.</p>
<ul>
<li><strong><code>MainActor</code></strong> is the front desk - where all customer interactions happen. There&#39;s only one, and it handles everything the user sees.</li>
<li><strong><code>actor</code></strong> types are department offices - Accounting, Legal, HR. Each protects its own sensitive documents.</li>
<li><strong><code>nonisolated</code></strong> code is the hallway - shared space anyone can walk through, but no private documents live there.</li>
</ul>
<p>You can&#39;t just barge into someone&#39;s office. You knock (<code>await</code>) and wait for them to let you in.</p>
</div>
  </div>
</section>
<section id="sendable">
  <div>
<h2><a href="#sendable">What Can Cross Isolation Domains: Sendable</a></h2>
<p>Isolation domains protect data, but eventually you need to pass data between them. When you do, Swift checks if it&#39;s safe.</p>
<p>Think about it: if you pass a reference to a mutable class from one actor to another, both actors could modify it simultaneously. That&#39;s exactly the data race we&#39;re trying to prevent. So Swift needs to know: can this data be safely shared?</p>
<p>The answer is the <a href="https://developer.apple.com/documentation/swift/sendable"><code>Sendable</code></a> protocol. It&#39;s a marker that tells the compiler &#34;this type is safe to pass across isolation boundaries&#34;:</p>
<ul>
<li><strong>Sendable</strong> types can cross safely (value types, immutable data, actors)</li>
<li><strong>Non-Sendable</strong> types can&#39;t (classes with mutable state)</li>
</ul>
<pre><code>
<span>struct</span> <span>User</span><span>:</span> <span>Sendable</span> <span>{</span>
    <span>let</span> id<span>:</span> <span>Int</span>
    <span>let</span> name<span>:</span> <span>String</span>
<span>}</span>


<span>class</span> <span>Counter</span> <span>{</span>
    <span>var</span> count <span>=</span> <span>0</span>  
<span>}</span></code></pre>
<h3>Making Types Sendable</h3>
<p>Swift automatically infers <code>Sendable</code> for many types:</p>
<ul>
<li><strong>Structs and enums</strong> with only <code>Sendable</code> properties are implicitly <code>Sendable</code></li>
<li><strong>Actors</strong> are always <code>Sendable</code> because they protect their own state</li>
<li><strong><code>@MainActor</code> types</strong> are <code>Sendable</code> because MainActor serializes access</li>
</ul>
<p>For classes, it&#39;s harder. A class can conform to <code>Sendable</code> only if it&#39;s <code>final</code> and all its stored properties are immutable:</p>
<pre><code><span>final</span> <span>class</span> <span>APIConfig</span><span>:</span> <span>Sendable</span> <span>{</span>
    <span>let</span> baseURL<span>:</span> <span>URL</span>      
    <span>let</span> timeout<span>:</span> <span>Double</span>   
<span>}</span></code></pre>
<p>If you have a class that&#39;s thread-safe through other means (locks, atomics), you can use <a href="https://developer.apple.com/documentation/swift/uncheckedsendable"><code>@unchecked Sendable</code></a> to tell the compiler &#34;trust me&#34;:</p>
<pre><code><span>final</span> <span>class</span> <span>ThreadSafeCache</span><span>:</span> <span>@unchecked</span> <span>Sendable</span> <span>{</span>
    <span>private</span> <span>let</span> lock <span>=</span> <span>NSLock</span><span>(</span><span>)</span>
    <span>private</span> <span>var</span> storage<span>:</span> <span>[</span><span>String</span><span>:</span> <span>Data</span><span>]</span> <span>=</span> <span>[</span><span>:</span><span>]</span>
<span>}</span></code></pre>
<div>
<h4>@unchecked Sendable is a promise</h4>
<p>The compiler won&#39;t verify thread safety. If you&#39;re wrong, you&#39;ll get data races. Use sparingly.</p>
</div>
<div>
<h4>Approachable Concurrency: Less Friction</h4>
<p>With <a href="https://www.swift.org/blog/swift-6.2-released/#approachable-concurrency">Approachable Concurrency</a>, Sendable errors become much rarer:</p>
<ul>
<li>If code doesn&#39;t cross isolation boundaries, you don&#39;t need Sendable</li>
<li>Async functions stay on the caller&#39;s actor instead of hopping to a background thread</li>
<li>The compiler is smarter about detecting when values are used safely</li>
</ul>
<p>Enable it by setting <code>SWIFT_DEFAULT_ACTOR_ISOLATION</code> to <code>MainActor</code> and <code>SWIFT_APPROACHABLE_CONCURRENCY</code> to <code>YES</code>. New Xcode 26 projects have both enabled by default. When you do need parallelism, mark functions <code>@concurrent</code> and then think about Sendable.</p>
</div>
<div>
<h4>Photocopies vs. Original Documents</h4>
<p>Back to the office building. When you need to share information between departments:</p>
<ul>
<li><strong>Photocopies are safe</strong> - If Legal makes a copy of a document and sends it to Accounting, both have their own copy. They can scribble on them, modify them, whatever. No conflict.</li>
<li><strong>Original signed contracts must stay put</strong> - If two departments could both modify the original, chaos ensues. Who has the real version?</li>
</ul>
<p><code>Sendable</code> types are like photocopies: safe to share because each place gets its own independent copy (value types) or because they&#39;re immutable (nobody can modify them). Non-<code>Sendable</code> types are like original contracts: passing them around creates the potential for conflicting modifications.</p>
</div>
  </div>
</section>
<section id="isolation-inheritance">
  <div>
<h2><a href="#isolation-inheritance">How Isolation Is Inherited</a></h2>
<p>You&#39;ve seen that isolation domains protect data, and Sendable controls what crosses between them. But how does code end up in an isolation domain in the first place?</p>
<p>When you call a function or create a closure, isolation flows through your code. With <a href="https://www.swift.org/blog/swift-6.2-released/#approachable-concurrency">Approachable Concurrency</a>, your app starts on <a href="https://developer.apple.com/documentation/swift/mainactor"><code>MainActor</code></a>, and that isolation propagates to the code you call, unless something explicitly changes it. Understanding this flow helps you predict where code runs and why the compiler sometimes complains.</p>
<h3>Function Calls</h3>
<p>When you call a function, its isolation determines where it runs:</p>
<pre><code><span>@MainActor</span> <span>func</span> <span>updateUI</span><span>(</span><span>)</span> <span>{</span> <span>}</span>      
<span>func</span> <span>helper</span><span>(</span><span>)</span> <span>{</span> <span>}</span>                    
<span>@concurrent</span> <span>func</span> <span>crunch</span><span>(</span><span>)</span> <span>async</span> <span>{</span> <span>}</span>  </code></pre>
<p>With <a href="https://www.swift.org/blog/swift-6.2-released/#approachable-concurrency">Approachable Concurrency</a>, most of your code inherits <code>MainActor</code> isolation. The function runs where the caller runs, unless it explicitly opts out.</p>
<h3>Closures</h3>
<p>Closures inherit isolation from the context where they&#39;re defined:</p>
<pre><code><span>@MainActor</span>
<span>class</span> <span>ViewModel</span> <span>{</span>
    <span>func</span> <span>setup</span><span>(</span><span>)</span> <span>{</span>
        <span>let</span> closure <span>=</span> <span>{</span>
            
            <span>self</span><span>.</span><span>updateUI</span><span>(</span><span>)</span>  
        <span>}</span>
        <span>closure</span><span>(</span><span>)</span>
    <span>}</span>
<span>}</span></code></pre>
<p>This is why SwiftUI&#39;s <code>Button</code> action closures can safely update <code>@State</code>: they inherit MainActor isolation from the view.</p>
<h3>Tasks</h3>
<p>A <code>Task { }</code> inherits actor isolation from where it&#39;s created:</p>
<pre><code><span>@MainActor</span>
<span>class</span> <span>ViewModel</span> <span>{</span>
    <span>func</span> <span>doWork</span><span>(</span><span>)</span> <span>{</span>
        <span>Task</span> <span>{</span>
            
            <span>self</span><span>.</span><span>updateUI</span><span>(</span><span>)</span>  
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre>
<p>This is usually what you want. The task runs on the same actor as the code that created it.</p>
<h3>Breaking Inheritance: Task.detached</h3>
<p>Sometimes you want a task that doesn&#39;t inherit any context:</p>
<pre><code><span>@MainActor</span>
<span>class</span> <span>ViewModel</span> <span>{</span>
    <span>func</span> <span>doHeavyWork</span><span>(</span><span>)</span> <span>{</span>
        <span>Task</span><span>.</span>detached <span>{</span>
            
            <span>let</span> result <span>=</span> <span>await</span> <span>self</span><span>.</span><span>expensiveCalculation</span><span>(</span><span>)</span>
            <span>await</span> <span>MainActor</span><span>.</span>run <span>{</span>
                <span>self</span><span>.</span>data <span>=</span> result  
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre>
<div>
<h4>Task.detached is usually wrong</h4>
<p>The Swift team recommends <a href="https://forums.swift.org/t/revisiting-when-to-use-task-detached/57929">Task.detached as a last resort</a>. It doesn&#39;t inherit priority, task-local values, or actor context. Most of the time, regular <code>Task</code> is what you want. If you need CPU-intensive work off the main actor, mark the function <code>@concurrent</code> instead.</p>
</div>
<div>
<h4>Walking Through the Building</h4>
<p>When you&#39;re in the front desk office (MainActor), and you call someone to help you, they come to <em>your</em> office. They inherit your location. If you create a task (&#34;go do this for me&#34;), that assistant starts in your office too.</p>
<p>The only way someone ends up in a different office is if they explicitly go there: &#34;I need to work in Accounting for this&#34; (<code>actor</code>), or &#34;I&#39;ll handle this in the back office&#34; (<code>@concurrent</code>).</p>
</div>
  </div>
</section>
<section id="putting-it-together">
  <div>
<h2><a href="#putting-it-together">Putting It All Together</a></h2>
<p>Let&#39;s step back and see how all the pieces fit.</p>
<p>Swift Concurrency can feel like a lot of concepts: <code>async/await</code>, <code>Task</code>, actors, <code>MainActor</code>, <code>Sendable</code>, isolation domains. But there&#39;s really just one idea at the center of it all: <strong>isolation is inherited by default</strong>.</p>
<p>With <a href="https://www.swift.org/blog/swift-6.2-released/#approachable-concurrency">Approachable Concurrency</a> enabled, your app starts on <a href="https://developer.apple.com/documentation/swift/mainactor"><code>MainActor</code></a>. That&#39;s your starting point. From there:</p>
<ul>
<li>Every function you call <strong>inherits</strong> that isolation</li>
<li>Every closure you create <strong>captures</strong> that isolation</li>
<li>Every <a href="https://developer.apple.com/documentation/swift/task"><code>Task { }</code></a> you spawn <strong>inherits</strong> that isolation</li>
</ul>
<p>You don&#39;t have to annotate anything. You don&#39;t have to think about threads. Your code runs on <code>MainActor</code>, and the isolation just propagates through your program automatically.</p>
<p>When you need to break out of that inheritance, you do it explicitly:</p>
<ul>
<li><strong><code>@concurrent</code></strong> says &#34;run this on a background thread&#34;</li>
<li><strong><code>actor</code></strong> says &#34;this type has its own isolation domain&#34;</li>
<li><strong><code>Task.detached { }</code></strong> says &#34;start fresh, inherit nothing&#34;</li>
</ul>
<p>And when you pass data between isolation domains, Swift checks that it&#39;s safe. That&#39;s what <a href="https://developer.apple.com/documentation/swift/sendable"><code>Sendable</code></a> is for: marking types that can safely cross boundaries.</p>
<p>That&#39;s it. That&#39;s the whole model:</p>
<ol>
<li><strong>Isolation propagates</strong> from <code>MainActor</code> through your code</li>
<li><strong>You opt out explicitly</strong> when you need background work or separate state</li>
<li><strong>Sendable guards the boundaries</strong> when data crosses between domains</li>
</ol>
<p>When the compiler complains, it&#39;s telling you one of these rules was violated. Trace the inheritance: where did the isolation come from? Where is the code trying to run? What data is crossing a boundary? The answer is usually obvious once you ask the right question.</p>
<h3>Where to Go From Here</h3>
<p>The good news: you don&#39;t need to master everything at once.</p>
<p><strong>Most apps only need the basics.</strong> Mark your ViewModels with <code>@MainActor</code>, use <code>async/await</code> for network calls, and create <code>Task { }</code> when you need to kick off async work from a button tap. That&#39;s it. That handles 80% of real-world apps. The compiler will tell you if you need more.</p>
<p><strong>When you need parallel work</strong>, reach for <code>async let</code> to fetch multiple things at once, or <a href="https://developer.apple.com/documentation/swift/taskgroup"><code>TaskGroup</code></a> when the number of tasks is dynamic. Learn to handle cancellation gracefully. This covers apps with complex data loading or real-time features.</p>
<p><strong>Advanced patterns come later</strong>, if ever. Custom actors for shared mutable state, <code>@concurrent</code> for CPU-intensive processing, deep <code>Sendable</code> understanding. This is framework code, server-side Swift, complex desktop apps. Most developers never need this level.</p>
<div>
<h4>Start simple</h4>
<p>Don&#39;t optimize for problems you don&#39;t have. Start with the basics, ship your app, and add complexity only when you hit real problems. The compiler will guide you.</p>
</div>
  </div>
</section>
<section id="mistakes">
  <div>
<h2><a href="#mistakes">Watch Out: Common Mistakes</a></h2>
<h3>Thinking async = background</h3>
<pre><code>
<span>@MainActor</span>
<span>func</span> <span>slowFunction</span><span>(</span><span>)</span> <span>async</span> <span>{</span>
    <span>let</span> result <span>=</span> <span>expensiveCalculation</span><span>(</span><span>)</span>  
    data <span>=</span> result
<span>}</span></code></pre>
<p><code>async</code> means &#34;can pause.&#34; The actual work still runs wherever it runs. Use <code>@concurrent</code> (Swift 6.2) or <code>Task.detached</code> for CPU-heavy work.</p>
<h3>Creating too many actors</h3>
<pre><code>
<span>actor</span> <span>NetworkManager</span> <span>{</span> <span>}</span>
<span>actor</span> <span>CacheManager</span> <span>{</span> <span>}</span>
<span>actor</span> <span>DataManager</span> <span>{</span> <span>}</span>


<span>@MainActor</span>
<span>class</span> <span>AppState</span> <span>{</span> <span>}</span></code></pre>
<p>You need a custom actor only when you have shared mutable state that can&#39;t live on <code>MainActor</code>. <a href="https://www.massicotte.org/actors/">Matt Massicotte&#39;s rule</a>: introduce an actor only when (1) you have non-<code>Sendable</code> state, (2) operations on that state must be atomic, and (3) those operations can&#39;t run on an existing actor. If you can&#39;t justify it, use <code>@MainActor</code> instead.</p>
<h3>Making everything Sendable</h3>
<p>Not everything needs to cross boundaries. If you&#39;re adding <code>@unchecked Sendable</code> everywhere, step back and ask if the data actually needs to move between isolation domains.</p>
<h3>Using MainActor.run when you don&#39;t need it</h3>
<pre><code>
<span>Task</span> <span>{</span>
    <span>let</span> data <span>=</span> <span>await</span> <span>fetchData</span><span>(</span><span>)</span>
    <span>await</span> <span>MainActor</span><span>.</span>run <span>{</span>
        <span>self</span><span>.</span>data <span>=</span> data
    <span>}</span>
<span>}</span>


<span>@MainActor</span>
<span>func</span> <span>loadData</span><span>(</span><span>)</span> <span>async</span> <span>{</span>
    <span>self</span><span>.</span>data <span>=</span> <span>await</span> <span>fetchData</span><span>(</span><span>)</span>
<span>}</span></code></pre>
<p><code>MainActor.run</code> is rarely the right solution. If you need MainActor isolation, annotate the function with <code>@MainActor</code> instead. It&#39;s clearer and the compiler can help you more. See <a href="https://www.massicotte.org/problematic-patterns/">Matt&#39;s take on this</a>.</p>
<h3>Blocking the cooperative thread pool</h3>
<pre><code>
<span>func</span> <span>badIdea</span><span>(</span><span>)</span> <span>async</span> <span>{</span>
    <span>let</span> semaphore <span>=</span> <span>DispatchSemaphore</span><span>(</span>value<span>:</span> <span>0</span><span>)</span>
    <span>Task</span> <span>{</span>
        <span>await</span> <span>doWork</span><span>(</span><span>)</span>
        semaphore<span>.</span><span>signal</span><span>(</span><span>)</span>
    <span>}</span>
    semaphore<span>.</span><span>wait</span><span>(</span><span>)</span>  
<span>}</span></code></pre>
<p>Swift&#39;s cooperative thread pool has limited threads. Blocking one with <code>DispatchSemaphore</code>, <code>DispatchGroup.wait()</code>, or similar calls can cause deadlocks. If you need to bridge sync and async code, use <code>async let</code> or restructure to stay fully async.</p>
<h3>Creating unnecessary Tasks</h3>
<pre><code>
<span>func</span> <span>fetchAll</span><span>(</span><span>)</span> <span>async</span> <span>{</span>
    <span>Task</span> <span>{</span> <span>await</span> <span>fetchUsers</span><span>(</span><span>)</span> <span>}</span>
    <span>Task</span> <span>{</span> <span>await</span> <span>fetchPosts</span><span>(</span><span>)</span> <span>}</span>
<span>}</span>


<span>func</span> <span>fetchAll</span><span>(</span><span>)</span> <span>async</span> <span>{</span>
    <span>async</span> <span>let</span> users <span>=</span> <span>fetchUsers</span><span>(</span><span>)</span>
    <span>async</span> <span>let</span> posts <span>=</span> <span>fetchPosts</span><span>(</span><span>)</span>
    <span>await</span> <span>(</span>users<span>,</span> posts<span>)</span>
<span>}</span></code></pre>
<p>If you&#39;re already in an async context, prefer structured concurrency (<code>async let</code>, <code>TaskGroup</code>) over creating unstructured <code>Task</code>s. Structured concurrency handles cancellation automatically and makes the code easier to reason about.</p>
  </div>
</section>
<section id="glossary">
  <div>
<h2><a href="#glossary">Cheat Sheet: Quick Reference</a></h2>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async</code></td>
<td>Function can pause</td>
</tr>
<tr>
<td><code>await</code></td>
<td>Pause here until done</td>
</tr>
<tr>
<td><code>Task { }</code></td>
<td>Start async work, inherits context</td>
</tr>
<tr>
<td><code>Task.detached { }</code></td>
<td>Start async work, no inherited context</td>
</tr>
<tr>
<td><code>@MainActor</code></td>
<td>Runs on main thread</td>
</tr>
<tr>
<td><code>actor</code></td>
<td>Type with isolated mutable state</td>
</tr>
<tr>
<td><code>nonisolated</code></td>
<td>Opts out of actor isolation</td>
</tr>
<tr>
<td><code>Sendable</code></td>
<td>Safe to pass between isolation domains</td>
</tr>
<tr>
<td><code>@concurrent</code></td>
<td>Always run on background (Swift 6.2+)</td>
</tr>
<tr>
<td><code>async let</code></td>
<td>Start parallel work</td>
</tr>
<tr>
<td><code>TaskGroup</code></td>
<td>Dynamic parallel work</td>
</tr>
</tbody>
</table>
<h2>Further Reading</h2>


<div>
<h4>Tools</h4>
<ul>
<li><a href="https://tuist.dev?utm_source=fuckingapproachableswiftconcurrency&amp;utm_medium=website&amp;utm_campaign=tools">Tuist</a> - Ship faster with larger teams and codebases</li>
</ul>
</div>
  </div>
</section>

  </div></div>
  </body>
</html>
