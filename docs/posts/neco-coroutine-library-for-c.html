<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tidwall/neco">Original</a>
    <h1>Show HN: Neco â€“ Coroutine Library for C</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
<themed-picture data-catalyst-inline="true"><picture>
  <source media="(prefers-color-scheme: dark)" srcset="/tidwall/neco/raw/main/docs/assets/logo-dark.png"/>
  <source media="(prefers-color-scheme: light)" srcset="/tidwall/neco/raw/main/docs/assets/logo-light.png"/>
  <img alt="Neco" src="https://github.com/tidwall/neco/raw/main/docs/assets/logo-light.png" width="260"/>
</picture></themed-picture>
</p>
<p dir="auto">
<a href="https://github.com/tidwall/neco/blob/main/docs/API.md"><img src="https://camo.githubusercontent.com/0ad5ca9889ded41b2370176cfa9f5ade089432a14807e95d5936ab903e58c79a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6170692d7265666572656e63652d626c75652e7376673f7374796c653d666c61742d737175617265" alt="API Reference" data-canonical-src="https://img.shields.io/badge/api-reference-blue.svg?style=flat-square"/></a>
</p>
<p dir="auto">Neco is a C library that provides concurrency using coroutines.
It&#39;s small &amp; fast, and intended to make concurrent I/O &amp; network programming
easy.</p>

<ul dir="auto">
<li><a href="https://github.com/tidwall/neco/blob/main/docs/API.md#basic-operations">Coroutines</a>: starting, sleeping, suspending, resuming, yielding, and joining.</li>
<li><a href="https://github.com/tidwall/neco/blob/main/docs/API.md#channels">Synchronization</a>: channels, generators, mutexes, condition variables, and waitgroups.</li>
<li>Support for <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#deadlines-and-cancelation">deadlines and cancelation</a>.</li>
<li><a href="https://github.com/tidwall/neco/blob/main/docs/API.md#posix-wrappers">Posix friendly</a> interface using file descriptors.</li>
<li>Addtional APIs for <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#networking-utilities">networking</a>,
<a href="https://github.com/tidwall/neco/blob/main/docs/API.md#signals">signals</a>, <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#random-number-generator">random data</a>, <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#streams-and-buffered-io">streams</a>, and <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#streams-and-buffered-io">buffered I/O</a>.</li>
<li>Lightweight runtime with a fair and deterministic <a href="#the-scheduler">scheduler</a>.</li>
<li><a href="#fast-context-switching">Fast</a> user-space context switching. Uses assembly in most cases.</li>
<li>Stackful coroutines that are nestable, with their life times fully managed by the scheduler.</li>
<li>Cross-platform. Linux, Mac, FreeBSD. <em>(Also WebAssembly and Windows with <a href="#platform-notes">some limitations</a>)</em>.</li>
<li>Single file amalgamation. No dependencies.</li>
<li><a href="https://github.com/tidwall/neco/blob/main/tests/README.md">Test suite</a> with 100% coverage using sanitizers and <a href="https://valgrind.org" rel="nofollow">Valgrind</a>.</li>
</ul>
<p dir="auto">For a deeper dive, check out the <a href="https://github.com/tidwall/neco/blob/main/docs/API.md">API reference</a>.</p>
<p dir="auto">It may also be worthwhile to see the <a href="https://github.com/tidwall/bluebox">Bluebox</a> project for a
more complete example of using Neco, including benchmarks.</p>

<ul dir="auto">
<li>Give C programs fast single-threaded concurrency.</li>
<li>To use a concurrency model that resembles the simplicity of pthreads or Go.</li>
<li>Provide an API for concurrent networking and I/O.</li>
<li>Make it easy to interop with existing Posix functions.</li>
</ul>
<p dir="auto">It&#39;s a non-goal for Neco to provide a scalable multithreaded runtime, where the
coroutine scheduler is shared among multiple cpu cores. Or to use other
concurrency models like async/await.</p>

<p dir="auto">Just drop the &#34;neco.c&#34; and &#34;neco.h&#34; files into your project. Uses standard C11 so most modern C compilers should work.</p>

<div dir="auto"><h2 tabindex="-1" dir="auto">Example 1 (Start a coroutine)</h2><a id="user-content-example-1-start-a-coroutine" aria-label="Permalink: Example 1 (Start a coroutine)" href="#example-1-start-a-coroutine"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A coroutine is started with the <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_start"><code>neco_start()</code></a> function.</p>
<p dir="auto">When <code>neco_start()</code> is called for the first time it will initialize a Neco runtime and scheduler for the current thread, and then blocks until the coroutine and all child coroutines have terminated.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &#34;neco.h&#34;

void coroutine(int argc, void *argv[]) {
    printf(&#34;main coroutine started\n&#34;);
}

int main(int argc, char *argv[]) {
    neco_start(coroutine, 0);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>printf</span>(<span>&#34;main coroutine started\n&#34;</span>);
}

<span>int</span> <span>main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>neco_start</span>(<span>coroutine</span>, <span>0</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 2 (Use neco_main instead of main)</h2><a id="user-content-example-2-use-neco_main-instead-of-main" aria-label="Permalink: Example 2 (Use neco_main instead of main)" href="#example-2-use-neco_main-instead-of-main"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Optionally, <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_main"><code>neco_main()</code></a> can be used in place of the standard <code>main()</code>.
This is for when the entirety of your program is intended to be run from only coroutines.
It <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_main">adjusts the behavior</a> of the program slightly to make development and error checking easier.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &#34;neco.h&#34;

int neco_main(int argc, char *argv[]) {
    printf(&#34;main coroutine started\n&#34;);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>printf</span>(<span>&#34;main coroutine started\n&#34;</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 3 (Multiple coroutines)</h2><a id="user-content-example-3-multiple-coroutines" aria-label="Permalink: Example 3 (Multiple coroutines)" href="#example-3-multiple-coroutines"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Here we&#39;ll start two coroutines that continuously prints &#34;tick&#34; every one second and &#34;tock&#34; every two.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &#34;neco.h&#34;

void ticker(int argc, void *argv[]) {
    while (1) {
        neco_sleep(NECO_SECOND);
        printf(&#34;tick\n&#34;);
    }
}

void tocker(int argc, void *argv[]) {
    while (1) {
        neco_sleep(NECO_SECOND*2);
        printf(&#34;tock\n&#34;);
    }
}

int neco_main(int argc, char *argv[]) {
    neco_start(ticker, 0);
    neco_start(tocker, 0);
    
    // Keep the program alive for an hour.
    neco_sleep(NECO_HOUR);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>ticker</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>while</span> (<span>1</span>) {
        <span>neco_sleep</span>(<span>NECO_SECOND</span>);
        <span>printf</span>(<span>&#34;tick\n&#34;</span>);
    }
}

<span>void</span> <span>tocker</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>while</span> (<span>1</span>) {
        <span>neco_sleep</span>(<span>NECO_SECOND</span><span>*</span><span>2</span>);
        <span>printf</span>(<span>&#34;tock\n&#34;</span>);
    }
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>neco_start</span>(<span>ticker</span>, <span>0</span>);
    <span>neco_start</span>(<span>tocker</span>, <span>0</span>);
    
    <span>// Keep the program alive for an hour.</span>
    <span>neco_sleep</span>(<span>NECO_HOUR</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 4 (Coroutine arguments)</h2><a id="user-content-example-4-coroutine-arguments" aria-label="Permalink: Example 4 (Coroutine arguments)" href="#example-4-coroutine-arguments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A coroutine is like its own little program that accepts any number of arguments.</p>
<div dir="auto" data-snippet-clipboard-copy-content="void coroutine(int argc, void *argv[])"><pre><span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[])</pre></div>
<p dir="auto">The arguments are a series of pointers passed to the coroutine.
All arguments are guaranteed to be in scope when the coroutine starts and until the first <code>neco_</code> function is called. This allows you an opportunity to validate and/or copy them.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

void coroutine(int argc, void *argv[]) {

    // All arguments are currently in scope and should be copied before first
    // neco_*() function is called in this coroutine.

    int arg0 = *(int*)argv[0];
    int arg1 = *(int*)argv[1];
    int arg2 = *(int*)argv[2];
    char *arg3 = argv[3];
    char *arg4 = argv[4];

    printf(&#34;arg0=%d, arg1=%d, arg2=%d, arg3=%s, arg4=%s\n&#34;, 
        arg0, arg1, arg2, arg3, arg4);

    neco_sleep(NECO_SECOND/2);

    // The arguments are no longer in scope and it&#39;s unsafe to use the argv
    // variable any further.

    printf(&#34;second done\n&#34;);
    
}

int neco_main(int argc, char *argv[]) {

    int arg0 = 0;
    int *arg1 = malloc(sizeof(int));
    *arg1 = 1;

    neco_start(coroutine, 5, &amp;arg0, arg1, &amp;(int){2}, NULL, &#34;hello world&#34;);
    free(arg2);

    neco_sleep(NECO_SECOND);
    printf(&#34;first done\n&#34;);

    return 0;
}"><pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;assert.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {

    <span>// All arguments are currently in scope and should be copied before first</span>
    <span>// neco_*() function is called in this coroutine.</span>

    <span>int</span> <span>arg0</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>0</span>];
    <span>int</span> <span>arg1</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>1</span>];
    <span>int</span> <span>arg2</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>2</span>];
    <span>char</span> <span>*</span><span>arg3</span> <span>=</span> <span>argv</span>[<span>3</span>];
    <span>char</span> <span>*</span><span>arg4</span> <span>=</span> <span>argv</span>[<span>4</span>];

    <span>printf</span>(<span>&#34;arg0=%d, arg1=%d, arg2=%d, arg3=%s, arg4=%s\n&#34;</span>, 
        <span>arg0</span>, <span>arg1</span>, <span>arg2</span>, <span>arg3</span>, <span>arg4</span>);

    <span>neco_sleep</span>(<span>NECO_SECOND</span>/<span>2</span>);

    <span>// The arguments are no longer in scope and it&#39;s unsafe to use the argv</span>
    <span>// variable any further.</span>

    <span>printf</span>(<span>&#34;second done\n&#34;</span>);
    
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {

    <span>int</span> <span>arg0</span> <span>=</span> <span>0</span>;
    <span>int</span> <span>*</span><span>arg1</span> <span>=</span> <span>malloc</span>(<span>sizeof</span>(<span>int</span>));
    <span>*</span><span>arg1</span> <span>=</span> <span>1</span>;

    <span>neco_start</span>(<span>coroutine</span>, <span>5</span>, <span>&amp;</span><span>arg0</span>, <span>arg1</span>, <span>&amp;</span>(<span>int</span>){<span>2</span>}, <span>NULL</span>, <span>&#34;hello world&#34;</span>);
    <span>free</span>(<span>arg2</span>);

    <span>neco_sleep</span>(<span>NECO_SECOND</span>);
    <span>printf</span>(<span>&#34;first done\n&#34;</span>);

    <span>return</span> <span>0</span>;
}</pre></div>

<p dir="auto">A <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#channels">channel</a> is a mechanism for communicating between two or more coroutines.</p>
<p dir="auto">Here we&#39;ll create a second coroutine that sends the message &#39;ping&#39; to the first coroutine.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

void coroutine(int argc, void *argv[]) {
    neco_chan *messages = argv[0];
    
    // Send a message of the &#39;messages&#39; channel. 
    char *msg = &#34;ping&#34;;
    neco_chan_send(messages, &amp;msg);

    // This coroutine no longer needs the channel.
    neco_chan_release(messages);
}

int neco_main(int argc, char *argv[]) {

    // Create a new channel that is used to send &#39;char*&#39; string messages.
    neco_chan *messages;
    neco_chan_make(&amp;messages, sizeof(char*), 0);

    // Start a coroutine that sends messages over the channel. 
    // It&#39;s a good idea to use neco_chan_retain on a channel before using it
    // in a new coroutine. This will avoid potential use-after-free bugs.
    neco_chan_retain(messages);
    neco_start(coroutine, 1, messages);

    // Receive the next incoming message. Here weâ€™ll receive the &#34;ping&#34;
    // message we sent above and print it out.
    char *msg = NULL;
    neco_chan_recv(messages, &amp;msg);
    printf(&#34;%s\n&#34;, msg);
    
    // This coroutine no longer needs the channel.
    neco_chan_release(messages);

    return 0;
}"><pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>neco_chan</span> <span>*</span><span>messages</span> <span>=</span> <span>argv</span>[<span>0</span>];
    
    <span>// Send a message of the &#39;messages&#39; channel. </span>
    <span>char</span> <span>*</span><span>msg</span> <span>=</span> <span>&#34;ping&#34;</span>;
    <span>neco_chan_send</span>(<span>messages</span>, <span>&amp;</span><span>msg</span>);

    <span>// This coroutine no longer needs the channel.</span>
    <span>neco_chan_release</span>(<span>messages</span>);
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {

    <span>// Create a new channel that is used to send &#39;char*&#39; string messages.</span>
    <span>neco_chan</span> <span>*</span><span>messages</span>;
    <span>neco_chan_make</span>(<span>&amp;</span><span>messages</span>, <span>sizeof</span>(<span>char</span><span>*</span>), <span>0</span>);

    <span>// Start a coroutine that sends messages over the channel. </span>
    <span>// It&#39;s a good idea to use neco_chan_retain on a channel before using it</span>
    <span>// in a new coroutine. This will avoid potential use-after-free bugs.</span>
    <span>neco_chan_retain</span>(<span>messages</span>);
    <span>neco_start</span>(<span>coroutine</span>, <span>1</span>, <span>messages</span>);

    <span>// Receive the next incoming message. Here weâ€™ll receive the &#34;ping&#34;</span>
    <span>// message we sent above and print it out.</span>
    <span>char</span> <span>*</span><span>msg</span> <span>=</span> <span>NULL</span>;
    <span>neco_chan_recv</span>(<span>messages</span>, <span>&amp;</span><span>msg</span>);
    <span>printf</span>(<span>&#34;%s\n&#34;</span>, <span>msg</span>);
    
    <span>// This coroutine no longer needs the channel.</span>
    <span>neco_chan_release</span>(<span>messages</span>);

    <span>return</span> <span>0</span>;
}</pre></div>

<p dir="auto">A <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#generators">generator</a> is like channel but is stricly bound to a coroutine and is intended to treat the coroutine like an iterator.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

void coroutine(int argc, void *argv[]) {
    // Yield each int to the caller, one at a time.
    for (int i = 0; i &lt; 10; i++) {
        neco_gen_yield(&amp;i);
    }
}

int neco_main(int argc, char *argv[]) {
    
    // Create a new generator coroutine that is used to send ints.
    neco_gen *gen;
    neco_gen_start(&amp;gen, sizeof(int), coroutine, 0);

    // Iterate over each int until the generator is closed.
    int i;
    while (neco_gen_next(gen, &amp;i) != NECO_CLOSED) {
        printf(&#34;%d\n&#34;, i); 
    }

    // This coroutine no longer needs the generator.
    neco_gen_release(gen);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>// Yield each int to the caller, one at a time.</span>
    <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
        <span>neco_gen_yield</span>(<span>&amp;</span><span>i</span>);
    }
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    
    <span>// Create a new generator coroutine that is used to send ints.</span>
    <span>neco_gen</span> <span>*</span><span>gen</span>;
    <span>neco_gen_start</span>(<span>&amp;</span><span>gen</span>, <span>sizeof</span>(<span>int</span>), <span>coroutine</span>, <span>0</span>);

    <span>// Iterate over each int until the generator is closed.</span>
    <span>int</span> <span>i</span>;
    <span>while</span> (<span>neco_gen_next</span>(<span>gen</span>, <span>&amp;</span><span>i</span>) <span>!=</span> <span>NECO_CLOSED</span>) {
        <span>printf</span>(<span>&#34;%d\n&#34;</span>, <span>i</span>); 
    }

    <span>// This coroutine no longer needs the generator.</span>
    <span>neco_gen_release</span>(<span>gen</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 7 (Connect to server)</h2><a id="user-content-example-7-connect-to-server" aria-label="Permalink: Example 7 (Connect to server)" href="#example-7-connect-to-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Neco provides <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_dial"><code>neco_dial()</code></a> for easily connecting
to server.</p>
<p dir="auto">Here we&#39;ll performing a (very simple) HTTP request which prints the homepage of
the <a href="http://example.com" rel="nofollow">http://example.com</a> website.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

int neco_main(int argc, char *argv[]) {
    int fd = neco_dial(&#34;tcp&#34;, &#34;example.com:80&#34;);
    if (fd &lt; 0) {
        printf(&#34;neco_dial: %s\n&#34;, neco_strerror(fd));
        return 0;
    }
    char req[] = &#34;GET / HTTP/1.1\r\n&#34;
                 &#34;Host: example.com\r\n&#34;
                 &#34;Connection: close\r\n&#34;
                 &#34;\r\n&#34;;
    neco_write(fd, req, sizeof(req));
    while (1) {
        char buf[256];
        int n = neco_read(fd, buf, sizeof(buf));
        if (n &lt;= 0) {
            break;
        }
        printf(&#34;%.*s&#34;, n, buf);
    }
    close(fd);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>fd</span> <span>=</span> <span>neco_dial</span>(<span>&#34;tcp&#34;</span>, <span>&#34;example.com:80&#34;</span>);
    <span>if</span> (<span>fd</span> <span>&lt;</span> <span>0</span>) {
        <span>printf</span>(<span>&#34;neco_dial: %s\n&#34;</span>, <span>neco_strerror</span>(<span>fd</span>));
        <span>return</span> <span>0</span>;
    }
    <span>char</span> <span>req</span>[] <span>=</span> <span>&#34;GET / HTTP/1.1\r\n&#34;</span>
                 <span>&#34;Host: example.com\r\n&#34;</span>
                 <span>&#34;Connection: close\r\n&#34;</span>
                 <span>&#34;\r\n&#34;</span>;
    <span>neco_write</span>(<span>fd</span>, <span>req</span>, <span>sizeof</span>(<span>req</span>));
    <span>while</span> (<span>1</span>) {
        <span>char</span> <span>buf</span>[<span>256</span>];
        <span>int</span> <span>n</span> <span>=</span> <span>neco_read</span>(<span>fd</span>, <span>buf</span>, <span>sizeof</span>(<span>buf</span>));
        <span>if</span> (<span>n</span> &lt;= <span>0</span>) {
            <span>break</span>;
        }
        <span>printf</span>(<span>&#34;%.*s&#34;</span>, <span>n</span>, <span>buf</span>);
    }
    <span>close</span>(<span>fd</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 8 (Create a server)</h2><a id="user-content-example-8-create-a-server" aria-label="Permalink: Example 8 (Create a server)" href="#example-8-create-a-server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Use <a href="https://github.com/tidwall/neco/blob/main/docs/API.md"><code>neco_serve()</code></a> to quickly bind and listen on an address.</p>
<p dir="auto">Here we&#39;ll run a tiny webserver at <a href="http://127.0.0.1:8080" rel="nofollow">http://127.0.0.1:8080</a></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &#34;../neco.h&#34;

void request(int argc, void *argv[]) {
    int fd = *(int*)argv[0];
    char req[256];
    int n = neco_read(fd, req, sizeof(req));
    if (n &gt; 0) {
        char res[] = &#34;HTTP/1.0 200 OK\r\n&#34;
                     &#34;Content-Type: text/html\r\n&#34;
                     &#34;Content-Length: 21\r\n&#34;
                     &#34;\r\n&#34;
                     &#34;&lt;h1&gt;Hello Neco!&lt;/h1&gt;\n&#34;;
        neco_write(fd, res, sizeof(res));
    }
    close(fd);
}

int neco_main(int argc, char *argv[]) {
    int servfd = neco_serve(&#34;tcp&#34;, &#34;127.0.0.1:8080&#34;);
    if (servfd &lt; 0) {
        printf(&#34;neco_serve: %s\n&#34;, neco_strerror(servfd));
        return 0;
    }
    printf(&#34;Serving at http://127.0.0.1:8080\n&#34;);
    while (1) {
        int fd = neco_accept(servfd, 0, 0);
        if (servfd &lt; 0) {
            printf(&#34;neco_accept: %s\n&#34;, neco_strerror(fd));
            continue;
        }
        neco_start(request, 1, &amp;fd);
    }
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;../neco.h&#34;</span>

<span>void</span> <span>request</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>fd</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>0</span>];
    <span>char</span> <span>req</span>[<span>256</span>];
    <span>int</span> <span>n</span> <span>=</span> <span>neco_read</span>(<span>fd</span>, <span>req</span>, <span>sizeof</span>(<span>req</span>));
    <span>if</span> (<span>n</span> <span>&gt;</span> <span>0</span>) {
        <span>char</span> <span>res</span>[] <span>=</span> <span>&#34;HTTP/1.0 200 OK\r\n&#34;</span>
                     <span>&#34;Content-Type: text/html\r\n&#34;</span>
                     <span>&#34;Content-Length: 21\r\n&#34;</span>
                     <span>&#34;\r\n&#34;</span>
                     <span>&#34;&lt;h1&gt;Hello Neco!&lt;/h1&gt;\n&#34;</span>;
        <span>neco_write</span>(<span>fd</span>, <span>res</span>, <span>sizeof</span>(<span>res</span>));
    }
    <span>close</span>(<span>fd</span>);
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>servfd</span> <span>=</span> <span>neco_serve</span>(<span>&#34;tcp&#34;</span>, <span>&#34;127.0.0.1:8080&#34;</span>);
    <span>if</span> (<span>servfd</span> <span>&lt;</span> <span>0</span>) {
        <span>printf</span>(<span>&#34;neco_serve: %s\n&#34;</span>, <span>neco_strerror</span>(<span>servfd</span>));
        <span>return</span> <span>0</span>;
    }
    <span>printf</span>(<span>&#34;Serving at http://127.0.0.1:8080\n&#34;</span>);
    <span>while</span> (<span>1</span>) {
        <span>int</span> <span>fd</span> <span>=</span> <span>neco_accept</span>(<span>servfd</span>, <span>0</span>, <span>0</span>);
        <span>if</span> (<span>servfd</span> <span>&lt;</span> <span>0</span>) {
            <span>printf</span>(<span>&#34;neco_accept: %s\n&#34;</span>, <span>neco_strerror</span>(<span>fd</span>));
            <span>continue</span>;
        }
        <span>neco_start</span>(<span>request</span>, <span>1</span>, <span>&amp;</span><span>fd</span>);
    }
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 9 (Echo server and client)</h2><a id="user-content-example-9-echo-server-and-client" aria-label="Permalink: Example 9 (Echo server and client)" href="#example-9-echo-server-and-client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Run server with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cc neco.c echo-server.c &amp;&amp; ./a.out"><pre>cc neco.c echo-server.c <span>&amp;&amp;</span> ./a.out</pre></div>
<p dir="auto">Run client with:</p>
<div dir="auto" data-snippet-clipboard-copy-content="cc neco.c echo-client.c &amp;&amp; ./a.out"><pre>cc neco.c echo-client.c <span>&amp;&amp;</span> ./a.out</pre></div>
<p dir="auto"><strong>echo-server.c</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

void client(int argc, void *argv[]) {
    int conn = *(int*)argv[0];
    printf(&#34;client connected\n&#34;);
    char buf[64];
    while (1) {
        ssize_t n = neco_read(conn, buf, sizeof(buf));
        if (n &lt;= 0) {
            break;
        }
        printf(&#34;%.*s&#34;, (int)n, buf);
    }
    printf(&#34;client disconnected\n&#34;);
    close(conn);
}

int neco_main(int argc, char *argv[]) {
    int ln = neco_serve(&#34;tcp&#34;, &#34;localhost:19203&#34;);
    if (ln == -1) {
        perror(&#34;neco_serve&#34;);
        exit(1);
    }
    printf(&#34;listening at localhost:19203\n&#34;);
    while (1) {
        int conn = neco_accept(ln, 0, 0);
        if (conn &gt; 0) {
            neco_start(client, 1, &amp;conn);
        }
    }
    close(ln);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>client</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>conn</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>0</span>];
    <span>printf</span>(<span>&#34;client connected\n&#34;</span>);
    <span>char</span> <span>buf</span>[<span>64</span>];
    <span>while</span> (<span>1</span>) {
        <span>ssize_t</span> <span>n</span> <span>=</span> <span>neco_read</span>(<span>conn</span>, <span>buf</span>, <span>sizeof</span>(<span>buf</span>));
        <span>if</span> (<span>n</span> &lt;= <span>0</span>) {
            <span>break</span>;
        }
        <span>printf</span>(<span>&#34;%.*s&#34;</span>, (<span>int</span>)<span>n</span>, <span>buf</span>);
    }
    <span>printf</span>(<span>&#34;client disconnected\n&#34;</span>);
    <span>close</span>(<span>conn</span>);
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>ln</span> <span>=</span> <span>neco_serve</span>(<span>&#34;tcp&#34;</span>, <span>&#34;localhost:19203&#34;</span>);
    <span>if</span> (<span>ln</span> <span>==</span> <span>-1</span>) {
        <span>perror</span>(<span>&#34;neco_serve&#34;</span>);
        <span>exit</span>(<span>1</span>);
    }
    <span>printf</span>(<span>&#34;listening at localhost:19203\n&#34;</span>);
    <span>while</span> (<span>1</span>) {
        <span>int</span> <span>conn</span> <span>=</span> <span>neco_accept</span>(<span>ln</span>, <span>0</span>, <span>0</span>);
        <span>if</span> (<span>conn</span> <span>&gt;</span> <span>0</span>) {
            <span>neco_start</span>(<span>client</span>, <span>1</span>, <span>&amp;</span><span>conn</span>);
        }
    }
    <span>close</span>(<span>ln</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<p dir="auto"><strong>echo-client.c</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

int neco_main(int argc, char *argv[]) {
    int fd = neco_dial(&#34;tcp&#34;, &#34;localhost:19203&#34;);
    if (fd == -1) {
        perror(&#34;neco_listen&#34;);
        exit(1);
    }
    printf(&#34;connected\n&#34;);
    char buf[64];
    while (1) {
        printf(&#34;&gt; &#34;);
        fflush(stdout);
        ssize_t nbytes = neco_read(STDIN_FILENO, buf, sizeof(buf));
        if (nbytes &lt; 0) {
            break;
        }
        ssize_t ret = neco_write(fd, buf, nbytes);
        if (ret &lt; 0) {
            break;
        }
    }
    printf(&#34;disconnected\n&#34;);
    close(fd);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdlib.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>int</span> <span>fd</span> <span>=</span> <span>neco_dial</span>(<span>&#34;tcp&#34;</span>, <span>&#34;localhost:19203&#34;</span>);
    <span>if</span> (<span>fd</span> <span>==</span> <span>-1</span>) {
        <span>perror</span>(<span>&#34;neco_listen&#34;</span>);
        <span>exit</span>(<span>1</span>);
    }
    <span>printf</span>(<span>&#34;connected\n&#34;</span>);
    <span>char</span> <span>buf</span>[<span>64</span>];
    <span>while</span> (<span>1</span>) {
        <span>printf</span>(<span>&#34;&gt; &#34;</span>);
        <span>fflush</span>(<span>stdout</span>);
        <span>ssize_t</span> <span>nbytes</span> <span>=</span> <span>neco_read</span>(<span>STDIN_FILENO</span>, <span>buf</span>, <span>sizeof</span>(<span>buf</span>));
        <span>if</span> (<span>nbytes</span> <span>&lt;</span> <span>0</span>) {
            <span>break</span>;
        }
        <span>ssize_t</span> <span>ret</span> <span>=</span> <span>neco_write</span>(<span>fd</span>, <span>buf</span>, <span>nbytes</span>);
        <span>if</span> (<span>ret</span> <span>&lt;</span> <span>0</span>) {
            <span>break</span>;
        }
    }
    <span>printf</span>(<span>&#34;disconnected\n&#34;</span>);
    <span>close</span>(<span>fd</span>);
    <span>return</span> <span>0</span>;
}</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Example 10 (Suspending and resuming a coroutine)</h2><a id="user-content-example-10-suspending-and-resuming-a-coroutine" aria-label="Permalink: Example 10 (Suspending and resuming a coroutine)" href="#example-10-suspending-and-resuming-a-coroutine"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Any coroutines can suspended itself indefinetly and then be resumed by other
coroutines by using <a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_suspend"><code>neco_suspend()</code></a> and
<a href="https://github.com/tidwall/neco/blob/main/docs/API.md#neco_resume"><code>neco_resume()</code></a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &#34;neco.h&#34;

void coroutine(int argc, void *argv[]) {
    printf(&#34;Suspending coroutine\n&#34;);
    neco_suspend();
    printf(&#34;Coroutine resumed\n&#34;);
}

int neco_main(int argc, char *argv[]) {
    neco_start(coroutine, 0);
    
    for (int i = 0; i &lt; 3; i++) {
        printf(&#34;%d\n&#34;, i+1);
        neco_sleep(NECO_SECOND);
    }

    // Resume the suspended. The neco_lastid() returns the identifier for the
    // last coroutine started by the current coroutine.
    neco_resume(neco_lastid());
    return 0;
}
// Output:
// Suspending coroutine
// 1
// 2
// 3
// Coroutine resumed"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coroutine</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>printf</span>(<span>&#34;Suspending coroutine\n&#34;</span>);
    <span>neco_suspend</span>();
    <span>printf</span>(<span>&#34;Coroutine resumed\n&#34;</span>);
}

<span>int</span> <span>neco_main</span>(<span>int</span> <span>argc</span>, <span>char</span> <span>*</span><span>argv</span>[]) {
    <span>neco_start</span>(<span>coroutine</span>, <span>0</span>);
    
    <span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>3</span>; <span>i</span><span>++</span>) {
        <span>printf</span>(<span>&#34;%d\n&#34;</span>, <span>i</span><span>+</span><span>1</span>);
        <span>neco_sleep</span>(<span>NECO_SECOND</span>);
    }

    <span>// Resume the suspended. The neco_lastid() returns the identifier for the</span>
    <span>// last coroutine started by the current coroutine.</span>
    <span>neco_resume</span>(<span>neco_lastid</span>());
    <span>return</span> <span>0</span>;
}
<span>// Output:</span>
<span>// Suspending coroutine</span>
<span>// 1</span>
<span>// 2</span>
<span>// 3</span>
<span>// Coroutine resumed</span></pre></div>

<p dir="auto">You can find more <a href="https://github.com/tidwall/neco/blob/main/examples">examples here</a>.</p>

<p dir="auto">Linux, Mac, and FreeBSD supports all features.</p>
<p dir="auto">Windows and WebAssembly support the core coroutine features, but have some key
limitiations, mostly with working with file descriptors and networking.
This is primarly because the Neco event queue works with epoll and kqueue,
which are only available on Linux and Mac/BSD respectively. This means that the
<code>neco_wait()</code> (which allows for a coroutine to wait for a file descriptor to be
readable or writeable) is not currently available on those platforms.</p>
<p dir="auto">Other limitations include:</p>
<ul dir="auto">
<li>Windows only supports amd64.</li>
<li>Windows and WebAssembly use smaller default stacks of 1MB.</li>
<li>Windows and WebAssembly do not support guards or gaps.</li>
<li>Windows and WebAssembly do not support NECO_CSPRNG (Cryptographically secure
pseudorandom number generator)</li>
<li>Windows does not support stack unwinding.</li>
</ul>
<p dir="auto">Other than that, Neco works great on those platforms.</p>
<p dir="auto">Any contributions towards making Windows and WebAssembly feature complete are
welcome.</p>

<p dir="auto">Neco uses <a href="https://github.com/tidwall/sco">sco</a>, which is a fair and
deterministic scheduler. This means that no coroutine takes priority over
another and that all concurrent operations will reproduce in an expected order.</p>

<p dir="auto">The coroutine context switching is powered by
<a href="https://github.com/tidwall/llco">llco</a> and uses assembly code in most
cases. On my lab machine (AMD Ryzen 9 5950X) a context switch takes about 11
nanoseconds.</p>

<p dir="auto">There can be no more than one scheduler per thread.</p>
<p dir="auto">When the first coroutine is started using <code>neco_start()</code>, a new Neco
runtime is initialized in the current thread, and each runtime has its own
scheduler.</p>
<p dir="auto">Communicating between coroutines that are running in different threads will
require I/O mechanisms that do not block the current schedulers, such as
<code>pipe()</code>, <code>eventfd()</code> or atomics.</p>
<p dir="auto"><em>Pthread utilties such as <code>pthread_mutex_t</code> and <code>pthread_cond_t</code> do not work very well in coroutines.</em></p>
<p dir="auto">For example, here we&#39;ll create two threads, running their own Neco schedulers.
Each using pipes to communicate with the other.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &#34;neco.h&#34;

void coro1(int argc, void *argv[]) {
    // This coroutine is running in a different scheduler than coro2.
    int rd = *(int*)argv[0];
    int wr = *(int*)argv[1];
    int val;
    neco_read(rd, &amp;val, sizeof(int));
    printf(&#34;coro1: %d\n&#34;, val);
    neco_write(wr, &amp;(int){ 2 }, sizeof(int));
}

void coro2(int argc, void *argv[]) {
    // This coroutine is running in a different scheduler than coro1.
    int rd = *(int*)argv[0];
    int wr = *(int*)argv[1];
    int val;
    neco_write(wr, &amp;(int){ 1 }, sizeof(int));
    neco_read(rd, &amp;val, sizeof(int));
    printf(&#34;coro2: %d\n&#34;, val);
}

void *runtime1(void *arg) {
    int *pipefds = arg;
    neco_start(coro1, 2, &amp;pipefds[0], &amp;pipefds[3]);
    return 0;
}

void *runtime2(void *arg) {
    int *pipefds = arg;
    neco_start(coro2, 2, &amp;pipefds[2], &amp;pipefds[1]);
    return 0;
}

int main() {
    int pipefds[4];
    pipe(&amp;pipefds[0]);
    pipe(&amp;pipefds[2]);
    pthread_t th1, th2;
    pthread_create(&amp;th1, 0, runtime1, pipefds);
    pthread_create(&amp;th2, 0, runtime2, pipefds);
    pthread_join(th1, 0);
    pthread_join(th2, 0);
    return 0;
}"><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;unistd.h&gt;</span>
<span>#include</span> <span>&lt;pthread.h&gt;</span>
<span>#include</span> <span>&#34;neco.h&#34;</span>

<span>void</span> <span>coro1</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>// This coroutine is running in a different scheduler than coro2.</span>
    <span>int</span> <span>rd</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>0</span>];
    <span>int</span> <span>wr</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>1</span>];
    <span>int</span> <span>val</span>;
    <span>neco_read</span>(<span>rd</span>, <span>&amp;</span><span>val</span>, <span>sizeof</span>(<span>int</span>));
    <span>printf</span>(<span>&#34;coro1: %d\n&#34;</span>, <span>val</span>);
    <span>neco_write</span>(<span>wr</span>, <span>&amp;</span>(<span>int</span>){ <span>2</span> }, <span>sizeof</span>(<span>int</span>));
}

<span>void</span> <span>coro2</span>(<span>int</span> <span>argc</span>, <span>void</span> <span>*</span><span>argv</span>[]) {
    <span>// This coroutine is running in a different scheduler than coro1.</span>
    <span>int</span> <span>rd</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>0</span>];
    <span>int</span> <span>wr</span> <span>=</span> <span>*</span>(<span>int</span><span>*</span>)<span>argv</span>[<span>1</span>];
    <span>int</span> <span>val</span>;
    <span>neco_write</span>(<span>wr</span>, <span>&amp;</span>(<span>int</span>){ <span>1</span> }, <span>sizeof</span>(<span>int</span>));
    <span>neco_read</span>(<span>rd</span>, <span>&amp;</span><span>val</span>, <span>sizeof</span>(<span>int</span>));
    <span>printf</span>(<span>&#34;coro2: %d\n&#34;</span>, <span>val</span>);
}

<span>void</span> <span>*</span><span>runtime1</span>(<span>void</span> <span>*</span><span>arg</span>) {
    <span>int</span> <span>*</span><span>pipefds</span> <span>=</span> <span>arg</span>;
    <span>neco_start</span>(<span>coro1</span>, <span>2</span>, <span>&amp;</span><span>pipefds</span>[<span>0</span>], <span>&amp;</span><span>pipefds</span>[<span>3</span>]);
    <span>return</span> <span>0</span>;
}

<span>void</span> <span>*</span><span>runtime2</span>(<span>void</span> <span>*</span><span>arg</span>) {
    <span>int</span> <span>*</span><span>pipefds</span> <span>=</span> <span>arg</span>;
    <span>neco_start</span>(<span>coro2</span>, <span>2</span>, <span>&amp;</span><span>pipefds</span>[<span>2</span>], <span>&amp;</span><span>pipefds</span>[<span>1</span>]);
    <span>return</span> <span>0</span>;
}

<span>int</span> <span>main</span>() {
    <span>int</span> <span>pipefds</span>[<span>4</span>];
    <span>pipe</span>(<span>&amp;</span><span>pipefds</span>[<span>0</span>]);
    <span>pipe</span>(<span>&amp;</span><span>pipefds</span>[<span>2</span>]);
    <span>pthread_t</span> <span>th1</span>, <span>th2</span>;
    <span>pthread_create</span>(<span>&amp;</span><span>th1</span>, <span>0</span>, <span>runtime1</span>, <span>pipefds</span>);
    <span>pthread_create</span>(<span>&amp;</span><span>th2</span>, <span>0</span>, <span>runtime2</span>, <span>pipefds</span>);
    <span>pthread_join</span>(<span>th1</span>, <span>0</span>);
    <span>pthread_join</span>(<span>th2</span>, <span>0</span>);
    <span>return</span> <span>0</span>;
}</pre></div>

<p dir="auto">Source code is available under the MIT <a href="https://github.com/tidwall/neco/blob/main/LICENSE">License</a>.</p>
</article></div></div>
  </body>
</html>
