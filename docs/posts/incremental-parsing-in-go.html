<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dev-nonsense.com/posts/incremental-parsing-in-go/">Original</a>
    <h1>Incremental Parsing in Go</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>This post is an attempt to explain the incremental parsing algorithm <a href="https://aretext.org">aretext</a> uses for syntax highlighting.</p><p>Like the rest of aretext, parsers are implemented in Go for portability and performance. Most people do not consider Go a functional programming language; nonetheless, aretext’s parsers rely on functional programming patterns. In this post, we’ll see how to implement these patterns in pure Go to build parsers that are fast and expressive.</p><h2 id="problem">Problem</h2><p>Syntax highlighting is a special case of parsing. The input is a text file containing source code, and the output is a sequence of tokens. Some tokens have special meaning such as “number”, “string”, or “comment” – these get displayed in a different color. Each programming language needs its own parser, and parsers can be a pain to write.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p><p>Parsers also needs to be <em>fast</em>. When the user edits a JSON document with 100K lines, syntax highlighting should update instantly. This requires parsing <em>incrementally</em>, reusing cached results as the user edits the document.</p><h2 id="example">Example</h2><p>Before explaining the incremental parsing algorithm, let’s look at a simple example. In git commit messages, any line that starts with a “#” is a comment. The screencast below shows how git commit comments are highlighted in aretext:</p><asciinema-player src="/cast/aretext-git-commit-syntax.cast" speed="1" poster="npt:0:07"></asciinema-player><p>This is the <a href="https://github.com/aretext/aretext/blob/77b790d3b024d01602c017ce9652bed2dc5af21f/syntax/languages/gitcommit.go">parser code for git commit messages</a>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// GitCommitParseFunc parses a git commit.
</span></span></span><span><span><span></span><span>func</span> <span>GitCommitParseFunc</span><span>()</span> <span>parser</span><span>.</span><span>Func</span> <span>{</span>
</span></span><span><span>	<span>parseCommentLine</span> <span>:=</span> <span>consumeString</span><span>(</span><span>&#34;#&#34;</span><span>).</span>
</span></span><span><span>		<span>ThenMaybe</span><span>(</span><span>consumeToNextLineFeed</span><span>).</span>
</span></span><span><span>		<span>Map</span><span>(</span><span>recognizeToken</span><span>(</span><span>parser</span><span>.</span><span>TokenRoleComment</span><span>))</span>
</span></span><span><span>	<span>return</span> <span>parseCommentLine</span><span>.</span><span>Or</span><span>(</span><span>consumeToNextLineFeed</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Each invocation of this function consumes one line. If the line starts with a “#”, the parser recognizes the line as a comment token. Otherwise, it consumes the rest of the line without recognizing any tokens.</p><p>With this single function, aretext can incrementally parse comments in git commit messages. If the user edits the message, aretext will re-run this function on <em>part</em> of the message, reusing cached results from the previous parse. The rest of this post explains the magic that makes this work!</p><h2 id="parser-func-and-result">Parser func and result</h2><p>A <a href="https://github.com/aretext/aretext/blob/77b790d3b024d01602c017ce9652bed2dc5af21f/syntax/parser/parser.go#L9-L26"><code>parser.Func</code></a> is responsible for parsing part of a document. It is defined as:</p><pre tabindex="0"><code>type Func func(TrackingRuneIter, State) Result
</code></pre><p>It accepts a <code>TrackingRuneIter</code> used to read the document and returns a <code>parser.Result</code>. (The <code>State</code> argument is used by some parsers<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> to maintain arbitrary state across executions.) The return type <a href="https://github.com/aretext/aretext/blob/77b790d3b024d01602c017ce9652bed2dc5af21f/syntax/parser/parser.go#L28-L33"><code>parser.Result</code></a> is defined as:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Result represents the result of a single execution of a parse function.
</span></span></span><span><span><span></span><span>type</span> <span>Result</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>NumConsumed</span>    <span>uint64</span>
</span></span><span><span>	<span>ComputedTokens</span> <span>[]</span><span>ComputedToken</span>
</span></span><span><span>	<span>NextState</span>      <span>State</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In the rest of this post, I’ll refer to <code>parser.Func</code> as a “parse func” and <code>parser.Result</code> as a “parse result”.</p><p>A <em>failed</em> parse consumes zero runes; a <em>successful</em> parse consumes at least one rune. A successful parse may also produce <em>tokens</em>.</p><p>Here’s an example of a parse func that consumes a single “x” and produces a “keyword” token.</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>parseSingleXRune</span><span>(</span><span>iter</span> <span>parser</span><span>.</span><span>TrackingRuneIter</span><span>,</span> <span>state</span> <span>parser</span><span>.</span><span>State</span><span>)</span> <span>parser</span><span>.</span><span>Result</span> <span>{</span>
</span></span><span><span>	<span>r</span><span>,</span> <span>err</span> <span>:=</span> <span>iter</span><span>.</span><span>NextRune</span><span>()</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>||</span> <span>r</span> <span>!=</span> <span>&#39;x&#39;</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>parser</span><span>.</span><span>FailedResult</span>
</span></span><span><span>	<span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>parser</span><span>.</span><span>Result</span><span>{</span>
</span></span><span><span>			<span>NumConsumed</span><span>:</span> <span>1</span><span>,</span>
</span></span><span><span>			<span>ComputedTokens</span><span>:</span> <span>[]</span><span>parser</span><span>.</span><span>ComputedToken</span><span>{</span>
</span></span><span><span>				<span>{</span><span>Offset</span><span>:</span> <span>0</span><span>,</span> <span>Length</span><span>:</span> <span>1</span><span>,</span> <span>Role</span><span>:</span> <span>parser</span><span>.</span><span>TokenRoleKeyword</span><span>},</span>
</span></span><span><span>			<span>},</span>
</span></span><span><span>			<span>NextState</span><span>:</span> <span>state</span><span>,</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The parse func reads the next rune from <code>iter</code>. If the rune is ‘x’, it returns a successful result with a keyword token; otherwise, it returns <code>parser.FailedResult</code> (which has <code>NumConsumed == 0</code>).</p><p>Since parse funcs are implemented in Go, they can parse arbitrarily complex languages, including context-sensitive languages like YAML and Markdown.</p><p>To parse a document, aretext invokes a parse func repeatedly. Each invocation uses an iterator starting immediately after the last rune consumed by the previous invocation. If the parse fails, aretext skips ahead one rune and tries again. Every parse func <em>must</em> produce the same output for a given input so results can safely cached and reused.</p><p>You might be thinking that <code>parseSingleXRune</code> looks imperative and verbose. Do we really need to write all that code just to parse an ‘x’? The answer is: no. We’ll see later that new parsers are usually composed from simpler parse funcs.</p><h2 id="tracking-rune-iterator">Tracking rune iterator</h2><p><code>parser.TrackingRuneIter</code> allows the parse func to read input one rune at a time. Internally, it records <em>how many runes were read</em>. This is important for incremental parsing: we can safely reuse a parse result only if we prove that the parse func did NOT read input edited by the user.</p><p>Copying a <code>TrackingRuneIter</code> produces a new iterator with its own position in the document. This allows parsers to “look ahead” using a copy of an iterator. For example, a parser might read a quote rune (&#34;), then look ahead for the closing quote of a string token. If it fails to find a closing quote, it can backtrack by using the original iterator. All copies of a <code>TrackingRuneIter</code> update a shared <code>maxRead</code> variable, so we can later determine the runes read by the original iterator and all of its copies.</p><p>Since <code>TrackingRuneIter</code> is a Go struct with few fields (a pointer in the document and a count of runes read), the Go runtime can allocate copies on the stack, avoiding the overhead of heap allocation and garbage collection. This is critical for performance.</p><h2 id="reusing-parse-results">Reusing parse results</h2><p>Executing a parse func repeatedly on a document produces a sequence of parse results. Suppose the user then inserts or deletes text at a position in the document. Which parse results could be reused and which would need to be recomputed?</p><p>Remember that parse funcs are deterministic: given the same input, they return the same output. Given a <code>TrackingRuneIter</code>’s initial position and <code>maxRead</code> count, aretext can determine exactly which runes a parser read to produce a given result. Let’s call these runes the “read region” of a result.</p><p>For a given edit and parse result, there are three possible cases:</p><ol><li><strong>The edit occurred <em>within</em> the read region</strong>: The parse func may receive different input, so all bets are off. We need to rerun the parse func to produce a new, possibly different result.</li><li><strong>The edit occurred <em>after</em> the read region</strong>: The parse func will receive the same input and produce the same output, so we can reuse the result.</li><li><strong>The edit occurred <em>before</em> the read region</strong>: The parse func will receive the same input and produce the same output. Each result contains only rune <em>counts</em>; absolute positions are calculated by summing the counts of preceding results. The edit changes the rune counts of preceding results, effectively “shifting” the result by the number of inserted/deleted runes.</li></ol><p>The above observations lead to a relatively straightforward incremental parsing algorithm:</p><pre tabindex="0"><code>while there is input left to consume:
    check if we can reuse a prior result at the current position
        if yes =&gt; reuse it
        else =&gt; recompute it by executing the parse func
    advance the position by number of runes consumed
</code></pre><p>Interested readers can compare the above pseudocode to the <a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/parser/parser.go#L123-L143">full Go implementation in syntax/parser/parser.go</a>.</p><p>In practice, an efficient implementation of this algorithm requires organizing results into a tree (called a <a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/parser/computation.go#L12-L24"><code>computation</code></a> in the aretext code). The leaves of the tree represent results, and the inner nodes represent groups of results. This allows us to quickly find and reuse entire <em>sub-trees</em> for parts of the document unaffected by the edit. We construct a new tree from these sub-trees, rotating nodes as necessary to keep the new tree balanced.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p><h2 id="parser-combinators">Parser combinators</h2><p>We now turn to ergonomics. Writing imperative code for every parse func would be slow and error-prone – better to write a few primitive parse func implementations, then <em>combine</em> them to create new parsers.</p><p>In functional programming, a “parser combinator” is a function that transforms a parser function into another parser function. We can implement parser combinators in Go as methods on a function receiver. Examples of combinators include <a href="https://github.com/aretext/aretext/blob/0fe11493e86a1efa7922fd516f30eb664e3578ca/syntax/parser/combinators.go#L35"><code>Then</code></a>, <a href="https://github.com/aretext/aretext/blob/0fe11493e86a1efa7922fd516f30eb664e3578ca/syntax/parser/combinators.go#L7"><code>Map</code></a>, and <a href="https://github.com/aretext/aretext/blob/0fe11493e86a1efa7922fd516f30eb664e3578ca/syntax/parser/combinators.go#L130"><code>Or</code></a>.</p><p>The <code>Or</code> combinator transforms two parse funcs and returns a new parse func. The combined parse func tries the first parse func, and if that fails, it tries the second parse func. This allows us to decompose a complicated parser into simple parts, then combine them with <code>Or</code>. The <a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/golang.go#L9-L22">parser for Go</a> exemplifies this pattern:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>GolangParseFunc</span><span>()</span> <span>parser</span><span>.</span><span>Func</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>golangLineCommentParseFunc</span><span>().</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangGeneralCommentParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangIdentifierOrKeywordParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangOperatorParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangRuneLiteralParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangRawStringLiteralParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangInterpretedStringLiteralParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangFloatLiteralParseFunc</span><span>()).</span>
</span></span><span><span>		<span>Or</span><span>(</span><span>golangIntegerLiteralParseFunc</span><span>())</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The <a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/parser/combinators.go#L128-L138"><code>Or</code> combinator</a> is implemented in just 10 lines of Go code:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Or produces a parse func that returns the result of `f` if it succeeds,
</span></span></span><span><span><span>// or the result of `nextFn` if `f` fails.
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>f</span> <span>Func</span><span>)</span> <span>Or</span><span>(</span><span>nextFn</span> <span>Func</span><span>)</span> <span>Func</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>func</span><span>(</span><span>iter</span> <span>TrackingRuneIter</span><span>,</span> <span>state</span> <span>State</span><span>)</span> <span>Result</span> <span>{</span>
</span></span><span><span>		<span>result</span> <span>:=</span> <span>f</span><span>(</span><span>iter</span><span>,</span> <span>state</span><span>)</span>
</span></span><span><span>		<span>if</span> <span>result</span><span>.</span><span>IsSuccess</span><span>()</span> <span>{</span>
</span></span><span><span>			<span>return</span> <span>result</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>		<span>return</span> <span>nextFn</span><span>(</span><span>iter</span><span>,</span> <span>state</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Notice that this relies on the ability to copy <code>TrackingRuneIter</code> efficiently. Passing <code>iter</code> to <code>f()</code> creates a copy of the iterator; if <code>f</code> fails, we backtrack by passing the original, unmodified, <code>iter</code> to <code>nextFn()</code>.</p><p>Parser combinators allow us to write succinct parser implementations. Even complicated parsers like YAML and Markdown can be implemented in relatively few lines of Go code. The table below shows the number of lines of code (excluding helpers) in aretext for several languages:</p><table><thead><tr><th>Language</th><th>Lines of Code</th></tr></thead><tbody><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/json.go">JSON</a></td><td>77</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/python.go">Python</a></td><td>142</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/golang.go">Go</a></td><td>169</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/c.go">C</a></td><td>190</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/rust.go">Rust</a></td><td>246</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/yaml.go">YAML</a></td><td>394</td></tr><tr><td><a href="https://github.com/aretext/aretext/blob/7d67b93cdb6d50eea2f8072506f0619134e60778/syntax/languages/markdown.go">Markdown</a></td><td>847</td></tr></tbody></table><h2 id="tradeoffs">Tradeoffs</h2><p>Like any solution, aretext’s syntax highlighting implementation makes tradeoffs.</p><h3 id="cost-of-developing-new-parsers">Cost of developing new parsers</h3><p>Supporting a new language requires writing Go code. I can usually implement simple languages in a day, but more complicated ones like YAML can take weeks. I’ve now implemented parsers for every language I use regularly, so I don’t view this as a serious problem.</p><p>I considered integrating <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>, an incremental parsing library with parsers for many existing languages. However, running JavaScript to generate parsers and linking to a C library would have greatly complicated the build process. Today, aretext can be built on almost any platform using a single <code>go install</code> command. I’ve had users install aretext on ARM laptops, FreeBSD servers, Chromebooks, and Android phones. To maintain portability, I wanted a pure Go implementation.</p><p>In the future, I may explore writing a code-generator to automatically translate a <a href="https://macromates.com/manual/en/language_grammars">TextMate grammar</a> (used by VSCode and other editors) to an aretext parse func. That could make it easier to create, or at least bootstrap, parsers for new languages.</p><h3 id="tokens-vs-syntax-tree">Tokens vs syntax tree</h3><p>The parsers produce a sequence to tokens, not a full syntax tree. Writing a tokenizer is much easier than parsing full syntax trees. However tokenizers can sometimes produce misleading highlights. For example, consider this Go function:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>F</span><span>(</span><span>len</span> <span>string</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>len</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here, “len” is the name of a variable with type <code>string</code>. However, “len” is also the name of a <a href="https://pkg.go.dev/builtin#len">built-in function</a>, so aretext highlights it. Without constructing the full syntax tree, it is difficult to differentiate an identifier representing a variable from reference to a built-in function. We’re also unable to perform other syntactical analysis like identifying blocks for code-folding.</p><p>In practice, this is rarely a problem. Most other editors don’t construct the full syntax tree, and most developers don’t declare variables that shadow built-in functions.</p><h3 id="extensibility-vs-performance">Extensibility vs performance</h3><p>Other editors like vim and VSCode allow users to define new syntax languages at runtime. Typically this involves writing grammar rules in a file, which the editor loads to construct a parser. This is not possible in aretext, since the parsers are implemented in Go. On the other hand, aretext’s parsers are likely faster since they are compiled to machine code.</p><h2 id="conclusion">Conclusion</h2><p>Syntax highlighting in aretext is ergonomic and efficient. Parser combinators allow complex parsers to be composed from simpler ones, and incremental parsing ensures excellent performance even for documents with hundreds of thousands of lines. Today, aretext provides syntax highlighting for thirteen languages, all using parsers implemented in pure Go!</p></div></div>
  </body>
</html>
