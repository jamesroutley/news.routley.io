<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jxnl.co/writing/2024/05/22/systematically-improving-your-rag/">Original</a>
    <h1>Systematically Improving Your RAG</h1>
    
    <div id="readability-page-1" class="page"><div data-md-component="container"> <main data-md-component="main"> <div>   <div data-md-component="content">  <article> <a href="https://github.com/jxnl/blog/edit/main/docs/writing/posts/improving-rag.md" title="Edit this page"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"></path></svg> </a> <a href="https://github.com/jxnl/blog/raw/main/docs/writing/posts/improving-rag.md" title="View source of this page"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0 8a5 5 0 0 1-5-5 5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5m0-12.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5Z"></path></svg> </a>  <div> <p>RAG Course</p> <p>I&#39;m building a RAG Course right now, if you&#39;re interested in the course please fill out this <a href="https://q7gjsgfstrp.typeform.com/ragcourse">form</a></p> </div> <p>These are notes generated after a call I had with Hamel on a &#39;system&#39; to improve a RAG system. I&#39;ve also written some other work like <a href="https://jxnl.co/writing/2023/09/17/rag-is-more-than-embeddings/">Rag is not Embeddings</a> and how to build a <a href="https://jxnl.co/writing/2024/01/07/inverted-thinking-rag/">Terrible RAG System</a> and how <a href="https://jxnl.co/writing/2024/02/28/levels-of-complexity-rag-applications/">complexity</a> can be broken down into smaller pieces.</p> <p>By the end of this post, you&#39;ll have a clear understanding of my systematic approach to improving RAG applications for the companies I work with. We&#39;ll cover key areas such as:</p> <ul> <li>Create synthetic questions and answers to quickly evaluate your system&#39;s precision and recall</li> <li>Make sure to combine full-text search and vector search for optimal retrieval </li> <li>Implementing the right user feedback mechanisms to capture specifically what you&#39;re interested in studying</li> <li>Use clustering to find segments of queries that have issues, broken down into topics and capabilities</li> <li>Build specific systems to improve capabilities</li> <li>Continuously monitoring, evaluating as real-world data grows</li> </ul> <p>Through this step-by-step runbook, you&#39;ll gain practical knowledge on how to incrementally enhance the performance and utility of your RAG applications, unlocking their full potential to deliver exceptional user experiences and drive business value. Let&#39;s dive in and explore how to systematically improve your RAG systems together!</p> <!-- more --> <h2 id="start-with-synthetic-data">Start with Synthetic Data<a href="#start-with-synthetic-data" title="Permanent link">¶</a></h2> <p>I think the biggest mistake around improving the system is that most people are spending too much time on the actual synthesis without actually understanding whether or not the data is being retrieved correctly. To avoid this:</p> <ul> <li>Create synthetic questions for each text chunk in your database</li> <li>Use these questions to test your retrieval system </li> <li>Calculate precision and recall scores to establish a baseline</li> <li>Identify areas for improvement based on the baseline scores</li> </ul> <p>What we should be finding with synthetic data is that synthetic data should just be around 97% recall precision. And synthetic data might just look like something very simple to begin with. </p> <p>We might just say, for every text chunk, I want it to synthetically generate a set of questions that this text chunk answers. For those questions, can we retrieve those text chunks? And you might think the answer is always going to be yes. But I found in practice that when I was doing tests against essays, full text search and embeddings basically performed the same, except full text search was about 10 times faster.</p> <p>Whereas when I did the same experiment on pulling issues from a repository, it was the case that full text search got around 55% recall, and then embedding search got around 65% recall. And just knowing how challenging these questions are on the baseline is super important to figure out what kind of experimentation you need to perform better. This will give you a baseline to work with and help you identify areas for improvement.</p>  <p>Ensuring relevant metadata (e.g., date ranges, file names, ownership) is extracted and searchable is crucial for improving search results. </p> <ul> <li>Extract relevant metadata from your documents</li> <li>Include metadata in your search indexes</li> <li>Use query understanding to extract metadata from user queries</li> <li>Expand search queries with relevant metadata to improve results</li> </ul> <p>For example, if someone asks, &#34;What is the latest x, y, and z?&#34; Text search will never get that answer. Semantic search will never get that answer.</p> <p>You need to perform query understanding to extract date ranges. There will be some prompt engineering that needs to happen. That&#39;s the metadata, and being aware that there will be questions that people aren&#39;t answering because those filters can never be caught by full text search and semantic search.</p> <p>And what this looks like in practice is if you ask the question, what are recent developments in the field, the search query is now expanded out to more terms. There&#39;s a date range where the language model has reasoned about what recent looks like for the research, and it&#39;s also decided that you should only be searching specific sources. If you don&#39;t do this, then you may not get trusted sources. You may be unable to figure out what recent means.</p> <p>You&#39;ll need to do some query understanding to extract date ranges and include metadata in your search.</p> <h2 id="use-both-full-text-search-and-vector-search">Use Both Full-Text Search and Vector Search<a href="#use-both-full-text-search-and-vector-search" title="Permanent link">¶</a></h2> <p>Utilize both full-text search and vector search (embeddings) for retrieving relevant documents. Ideally, you should use a single database system to avoid synchronization issues.</p> <ul> <li>Implement both full-text search and vector search</li> <li>Test the performance of each method on your specific use case</li> <li>Consider using a single database system to store both types of data</li> <li>Evaluate the trade-offs between speed and recall for your application</li> </ul> <p>In my experience, full-text search can be faster, but vector search can provide better recall.</p> <p>What ended up being very complicated was if you have a single knowledge base, maybe that complexity is fine, because you have more configuration of each one.</p> <p>But one of my clients who was doing construction data, they had to create separate indices per project, and now they just had this exploding array of different data sources that get in or out of sync. Like, maybe the database has an outage, and now the data is not in the database, but it&#39;s in another system. So if the embedding gets pulled up, then text is missing.</p> <p>And this complex configuration becomes a huge pain. And so, for example, some tools are able to do all 3 in a single object. And so even if you had a lot of partitioned data sources, you can do full text search, embedding search, and write SQL against a single data object. And that has been really helpful, especially when you think about these examples where you want to find the latest. Now you can just do a full text search query and then order by date and have a between clause.</p> <p>Test both and see what works best for your use case.</p> <h2 id="implement-clear-user-feedback-mechanisms">Implement Clear User Feedback Mechanisms<a href="#implement-clear-user-feedback-mechanisms" title="Permanent link">¶</a></h2> <p>Implementing clear user feedback systems (e.g., thumbs up/down) is essential for gathering data on your system&#39;s performance and identifying areas for improvement.</p> <ul> <li>Add user feedback mechanisms to your application</li> <li>Make sure the copy for these mechanisms clearly describes what you&#39;re measuring</li> <li>Ask specific questions like &#34;Did we answer the question correctly?&#34; instead of general ones like &#34;How did we do?&#34; </li> <li>Use the feedback data to identify areas for improvement and prioritize fixes</li> </ul> <p>I find that it&#39;s important to build out these feedback mechanisms as soon as possible. And making sure that the copy of these feedback mechanisms explicitly describe what you&#39;re worried about.</p> <p>Sometimes, we&#39;ll get a thumbs down even if the answer is correct, but they didn&#39;t like the tone. Or the answer was correct, but the latency was too high. Or it took too many hops.</p> <p>This means we couldn&#39;t actually produce an evaluation dataset just by figuring out what was a thumbs up and a thumbs down. It was a lot of confounding variables. We had to change the copy to just &#34;Did we answer the question correctly? Yes or no.&#34; We need to recognize that improvements in tone and improvements in latency will come eventually. But we needed the user feedback to build us that evaluation dataset.</p> <p>Make sure the copy for these feedback mechanisms explicitly describes what you&#39;re worried about. This will help you isolate the specific issues users are facing.</p> <h2 id="cluster-and-model-topics">Cluster and Model Topics<a href="#cluster-and-model-topics" title="Permanent link">¶</a></h2> <p>Analyze user queries and feedback to identify topic clusters, capabilities, and areas of user dissatisfaction. This will help you prioritize improvements.</p> <p>Why should we do this? Let me give you an example. I once worked with a company that provided a technical documentation search system. By clustering user queries, we identified two main issues:</p> <ol> <li> <p>Topic Clusters: A significant portion of user queries were related to a specific product feature that had recently been updated. However, our system was not retrieving the most up-to-date documentation for this feature, leading to confusion and frustration among users.</p> </li> <li> <p>Capability Gaps: Another cluster of queries revealed that users were frequently asking for troubleshooting steps and error code explanations. While our system could retrieve relevant documentation, it struggled to provide direct, actionable answers to these types of questions.</p> </li> </ol> <p>Based on these insights, we prioritized updating the product feature documentation and implementing a feature to extract step-by-step instructions and error code explanations. These targeted improvements led to higher user satisfaction and reduced support requests.</p> <p>Look for patterns like:</p> <ul> <li> <p>Topic clusters: Are users asking about specific topics more than others? This could indicate a need for more content in those areas or better retrieval of existing content.</p> </li> <li> <p>Capabilities: Are there types of questions your system categorically cannot answer? This could indicate a need for new features or capabilities, such as direct answer extraction, multi-document summarization, or domain-specific reasoning.</p> </li> </ul> <p>By continuously analyzing topic clusters and capability gaps, you can identify high-impact areas for improvement and allocate your resources more effectively. This data-driven approach to prioritization ensures that you&#39;re always working on the most critical issues affecting your users.</p> <p>Once you have this in place, once you have these topics and these clusters, you can talk to domain experts for a couple of weeks to figure out what these categories are explicitly. Then, you can build out systems to tag that as data comes in.</p> <p>In the same way that when you open up ChatGPT and make a conversation, it creates an automatic title in the corner. You can now do that for every question. As part of that capability, you can add the classification, such as what are the topics and what are the capabilities. Capabilities could include ownership and responsibility, fetching tables, fetching images, fetching documents only, no synthesis, compare and contrast, deadlines, and so on.</p> <p>You can then put this information into a tool like Amplitude or Sentry. This will give you a running stream of the types of queries people are asking, which can help you understand how to prioritize these capabilities and topics.</p> <h2 id="continuously-monitor-and-experiment">Continuously Monitor and Experiment<a href="#continuously-monitor-and-experiment" title="Permanent link">¶</a></h2> <p>Continuously monitor your system&#39;s performance and run experiments to test improvements.</p> <ul> <li>Set up monitoring and logging to track system performance over time</li> <li>Regularly review the data to identify trends and issues</li> <li>Design and run experiments to test potential improvements</li> <li>Measure the impact of changes on precision, recall, and other relevant metrics</li> <li>Implement changes that show significant improvements</li> </ul> <p>This could include tweaking search parameters, adding metadata, or trying different embedding models. Measure the impact on precision and recall to see if the changes are worthwhile.</p> <p>Once you now have these questions in place, you have your synthetic data set and a bunch of user data with ratings. This is where the real work begins when it comes to systematically improving your RAG.</p> <p>The system will be running many clusters of topic modeling around the questions, modeling that against the thumbs up and thumbs down ratings to figure out what clusters are underperforming. It will then determine the count and probability of user dissatisfaction for each cluster.</p> <p>The system will be doing this on a regular cadence, figuring out for what volume of questions and user satisfaction levels it should focus on improving these specific use cases.</p> <p>What might happen is you onboard a new organization, and all of a sudden, those distributions shift because their use cases are different. That&#39;s when you can go in and say, &#34;We onboarded these new clients, and they very much care about deadlines. We knew we decided not to service deadlines, but now we know this is a priority, as it went from 2% of questions asking about deadlines to 80%.&#34; You can then determine what kind of education or improvements can be done around that.</p> <h2 id="balance-latency-and-performance">Balance Latency and Performance<a href="#balance-latency-and-performance" title="Permanent link">¶</a></h2> <p>Finally, make informed decisions about trade-offs between system latency and search performance based on your specific use case and user requirements.</p> <ul> <li>Understand the latency and performance requirements for your application</li> <li>Measure the impact of different configurations on latency and performance</li> <li>Make trade-offs based on what&#39;s most important for your users</li> <li>Consider different requirements for different use cases (e.g., medical diagnosis vs. general search)</li> </ul> <p>Here, this is where having the synthetic questions that test against will effectively answer that question. Because what we&#39;ll do is we&#39;ll run the query with and without this parent document retriever, and we will have a recall with and without that feature and the latency improvement of that feature.</p> <p>And so now we&#39;ll be able to say, okay. Well, recall doubles. The latency increases by 20%, then a conversation can happen. Or, is that worth the investment? But if latency goes up double and the recall goes up 1%, again, it depends on, okay.</p> <p>Well, if this is a medical diagnostic, maybe I do care that the 1% is included because the stakes are so high. But if it&#39;s for a doc page, maybe the increased latency will reduce in churn.</p> <p>If you can improve recall by 1%, and the results are too complex, it&#39;s not worth deploying it in the future as well.</p> <p>For example, if you&#39;re building a medical diagnostic tool, a slight increase in latency might be worth it for better recall. But if you&#39;re building a general-purpose search tool, faster results might be more important.</p> <h2 id="wrapping-up">Wrapping Up<a href="#wrapping-up" title="Permanent link">¶</a></h2> <p>This is was written based off of a 30 conversation with a client, so I know I&#39;m skipping over many details and implementation details. Leave a comment and let me know and we can get into specifics.</p>    <!-- Synchronize Giscus theme with palette -->  </article> </div>   </div>  </main>  </div></div>
  </body>
</html>
