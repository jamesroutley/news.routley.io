<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ptrchm.com/posts/base32-explained/">Original</a>
    <h1>How does Base32 (or any Base2^n) work exactly?</h1>
    
    <div id="readability-page-1" class="page"><div id="root">
    


    <main>
      
  <article itemscope="" itemtype="http://schema.org/BlogPosting">
    

    

    <div itemprop="articleBody">
      <p>Base64 is one of those things I’ve used countless times, without ever fully understanding what it does. For my <a href="https://ntietz.com/posts/based-uuid">UUID shortener</a>, I chose to implement Base32 — a more readable and URL-friendly alternative to Base64. I didn’t want to rely on any third-party libraries for the encoding part. This meant going back to basics and learning what actually happens when you encode data to a Base2ⁿ format.</p>
<p>This post is my attempt to explain and visualize how Base32 encoding works at the bit level and how it relates to other Base2ⁿ formats, like Base64.</p>
<p>We’ll implement a Base32 encoder from scratch. I’ll be using Ruby for the example code, but the principles should be easily translated to any programming language.</p>
<p>If you want to jump straight to the code, here’s the <a href="https://gist.github.com/pch/585f0c949acf2e10454f702c23cd63d2">result</a>.</p>


<h2 id="whats-base2ⁿ-encoding">What’s Base2ⁿ encoding?</h2>
<p>Just as Base10 (decimal) uses 10 digits to represent numbers, Base2ⁿ encoding is simply another way to represent numbers (or bytes), using 2ⁿ digits instead: Base2 (binary), Base16 (hexadecimal), Base32, Base64, etc. The more digits we have, the more compact the representation is going to be.</p>
<p>For example, let’s look at different representations of the same 128-bit number (UUID):</p>
<div><pre tabindex="0"><code data-lang="plain">3d89a119-b3f8-4107-8f29-3daf5b964e50   # standard UUID string
0x3d89a119b3f841078f293daf5b964e50     # hex
81797519916847327862337238645062651472 # decimal
1xh6ghkczr843rya9xnxdsckjg             # base32 (Crockford&#39;s variant)

# and binary:
111101100010011010000100011001101100111111100001000001000001111000111100101001001111011010111101011011100101100100111001010000
</code></pre></div><p>The number of available digits determines how many bits can be represented by a single character. For example: with binary we can encode 1 bit of data into each character (2^1 = 2 character combinations of 1 bit). Similarly, in Base16 (hex) we can encode 4 bits of data into a single character (2^4 = 16 character combinations of 4 bits).</p>
<h2 id="pushing-bits-how-to-convert-a-number-to-base8">Pushing bits: how to convert a number to Base8</h2>
<p>With that in mind, let’s start with a simple example: converting the number <strong>249</strong> into Base8 (octal). There are several ways to achieve that, but to illustrate the general method for Base2ⁿ encoding, we’ll use bitwise operations.</p>
<p>Here’s what the number 249 looks like in binary (an 8-bit representation):</p>
<p>Base8 uses 8 digits (0-7), so we can encode 3 bits of data into a single character (2^3 = 8 character combinations of 3 bits).</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>digits</span> <span>=</span> <span>[</span><span>&#39;0&#39;</span><span>,</span> <span>&#39;1&#39;</span><span>,</span> <span>&#39;2&#39;</span><span>,</span> <span>&#39;3&#39;</span><span>,</span> <span>&#39;4&#39;</span><span>,</span> <span>&#39;5&#39;</span><span>,</span> <span>&#39;6&#39;</span><span>,</span> <span>&#39;7&#39;</span><span>]</span>
</code></pre></div><p>The number 249 translates to 371 in octal. Here’s how the binary representation looks like, in groups of 3 bits:</p>
<div><pre tabindex="0"><code data-lang="plain">011 111 001
└─┘ └─┘ └─┘
 3   7   1
</code></pre></div><p>The method is pretty simple: looking at the binary representation, we’ll split the value into groups of 3 bits each. Each group represents a character/digit in our target system (its index in the <code>digits</code> array, to be more specific).</p>
<p>Starting from the lower-order bits (right-hand), we’ll use a bit mask to extract 3 bits at a time:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>7</span>   <span># decimal (max. index in the digits array)</span>
<span>0x7</span> <span># hex</span>
<span>111</span> <span># binary (3 bits, our chunk size)</span>
</code></pre></div><p>Let’s extract the first 3 bits. We’ll do this by masking every bit except the first 3 lower (right-hand) bits:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>number</span> <span>=</span> <span>249</span>
<span>digit</span>  <span>=</span> <span>number</span> <span>&amp;</span> <span>0x7</span> <span>#=&gt; 1 (001)</span>
</code></pre></div><p>This gives us the first digit in the result: <code>1</code>.</p>
<p>The bitwise <code>AND</code> operation looks like this:</p>
<div><pre tabindex="0"><code data-lang="plain">  011 111 001
&amp; 000 000 111
= 000 000 001
</code></pre></div><p>Now we have to shift to the next 3 bits. We’ll push the rightmost bits the right, removing them from the number:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>number</span> <span>=</span> <span>number</span> <span>&gt;&gt;</span> <span>3</span> <span>#=&gt; 252 (000 001 111)</span>
</code></pre></div><p>The bitwise operation looks like this:</p>
<div>
  <div>
    

  <pre><code>&gt;&gt; 011 111 001</code></pre>


  <pre><code>&gt;&gt;  011 111 00</code></pre>


  <pre><code>&gt;&gt;   011 111 0</code></pre>


  <pre><code>&gt;&gt;    011 111</code></pre>



  </div>
</div>

<p>Now, we can extract the next 3 bits:</p>
<div><pre tabindex="0"><code data-lang="plain">  000 011 111
&amp; 000 000 111
= 000 000 111
</code></pre></div><p>This gives us the next digit: <code>7</code> (<code>0b111</code>).</p>
<p>We keep doing this as long as <code>number &gt; 0</code>, so in this case, just one more time. Shift to the last 3 bits:</p>
<div>
  <div>
    

  <pre><code>&gt;&gt;     011 111</code></pre>


  <pre><code>&gt;&gt;      011 11</code></pre>


  <pre><code>&gt;&gt;       011 1</code></pre>


  <pre><code>&gt;&gt;        011</code></pre>



  </div>
</div>

<p>And extract the last 3 bits:</p>
<div><pre tabindex="0"><code data-lang="plain">  000 000 011
&amp; 000 000 111
= 000 000 011
</code></pre></div><p><code>0b011</code> is <code>3</code> in our target system, so putting it all together, we get our final result: <code>371</code>.</p>
<p>Here’s the code representing the whole sequence:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>digits</span> <span>=</span> <span>[</span><span>&#39;0&#39;</span><span>,</span> <span>&#39;1&#39;</span><span>,</span> <span>&#39;2&#39;</span><span>,</span> <span>&#39;3&#39;</span><span>,</span> <span>&#39;4&#39;</span><span>,</span> <span>&#39;5&#39;</span><span>,</span> <span>&#39;6&#39;</span><span>,</span> <span>&#39;7&#39;</span><span>]</span>
<span>result</span> <span>=</span> <span>[]</span>
<span>number</span> <span>=</span> <span>249</span>

<span>while</span> <span>number</span> <span>&gt;</span> <span>0</span>
  <span>digit</span> <span>=</span> <span>digits</span><span>[</span><span>number</span> <span>&amp;</span> <span>0x7</span><span>]</span>
  <span>result</span><span>.</span><span>push</span><span>(</span><span>digit</span><span>)</span>
  <span>number</span> <span>=</span> <span>number</span> <span>&gt;&gt;</span> <span>3</span>
<span>end</span>

<span>puts</span> <span>result</span><span>.</span><span>reverse</span><span>.</span><span>join</span> <span>#=&gt; 371</span>
</code></pre></div><p>The method will be virtually the same for any Base2ⁿ encoding. For Base8, the <code>digits</code> array is not strictly necessary, but for larger bases, such as Base16 or Base32, we’ll need to define a list of characters that represent the additional digits.</p>
<p>Now, let’s change the code to encode the number 249 into Base16 (4 bits per character). To do this, we’ll define the 16 characters and modify the bit mask to extract 4 bits at a time:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>digits</span> <span>=</span> <span>[</span><span>&#39;0&#39;</span><span>,</span> <span>&#39;1&#39;</span><span>,</span> <span>&#39;2&#39;</span><span>,</span> <span>&#39;3&#39;</span><span>,</span> <span>&#39;4&#39;</span><span>,</span> <span>&#39;5&#39;</span><span>,</span> <span>&#39;6&#39;</span><span>,</span> <span>&#39;7&#39;</span><span>,</span> <span>&#39;8&#39;</span><span>,</span> <span>&#39;9&#39;</span><span>,</span> <span>&#39;a&#39;</span><span>,</span> <span>&#39;b&#39;</span><span>,</span> <span>&#39;c&#39;</span><span>,</span> <span>&#39;d&#39;</span><span>,</span> <span>&#39;e&#39;</span><span>,</span> <span>&#39;f&#39;</span><span>]</span>
<span>result</span> <span>=</span> <span>[]</span>
<span>number</span> <span>=</span> <span>249</span>

<span>while</span> <span>number</span> <span>&gt;</span> <span>0</span>
  <span>digit</span> <span>=</span> <span>digits</span><span>[</span><span>number</span> <span>&amp;</span> <span>0xf</span><span>]</span> <span># 0xf = 0b1111</span>
  <span>result</span><span>.</span><span>push</span><span>(</span><span>digit</span><span>)</span>
  <span>number</span> <span>=</span> <span>number</span> <span>&gt;&gt;</span> <span>4</span>
<span>end</span>

<span>puts</span> <span>result</span><span>.</span><span>reverse</span><span>.</span><span>join</span> <span>#=&gt; f9</span>
</code></pre></div><p>In the same manner, you can extend the code to support any Base2ⁿ encoding: simply add more characters to the alphabet, calculate the bit mask and the number of bits to shift in each iteration, based on the number of characters in the alphabet. We’ll explore this process in more detail in the next section.</p>
<div>
  <h4>🚨 An important caveat</h4>
  <p>The method described above is used to encode <strong>numbers</strong>. We’re treating the input as one chunk of fixed-size data, encoding bits from <strong>right to left</strong> (least significant first). However, the standard Base32 and Base64 algorithms that operate on arbitrary data will split the input into smaller chunks, starting from <strong>left to right</strong> (most significant first).</p>
<p>For example, in the <a href="https://ntietz.com/posts/based-uuid">BasedUUID gem</a>, I treat the UUID as a 128-bit number, encoding it from right to left. This method is also used by <a href="https://github.com/ulid/spec">ULID</a> and <a href="https://github.com/jetpack-io/typeid">TypeID</a>. Keep in mind that this approach will <strong>not</strong> yield the same result as encoding the string or raw byte representation of the UUID.</p>

</div>

<h2 id="base32-implementation-rfc-4648">Base32 implementation (RFC 4648)</h2>
<h3 id="encoding-arbitrary-data">Encoding arbitrary data</h3>
<p>In Base32, each character can encode 5 bits of data (2^5 = 32 character combinations of 5 bits). The <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> defines the following set of characters:</p>
<div><pre tabindex="0"><code data-lang="plain">Value Encoding  Value Encoding  Value Encoding  Value Encoding
    0 A             9 J            18 S            27 3
    1 B            10 K            19 T            28 4
    2 C            11 L            20 U            29 5
    3 D            12 M            21 V            30 6
    4 E            13 N            22 W            31 7
    5 F            14 O            23 X
    6 G            15 P            24 Y         (pad) =
    7 H            16 Q            25 Z
    8 I            17 R            26 2
</code></pre></div><p>There are other variants of the encoding, like <a href="https://www.crockford.com/base32.html">Crockford’s Base32</a>, and the alphabet can be customized to fit specific needs<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. However, for this article, we’ll stick to the RFC 4648 version.</p>
<p>Encoding arbitrary data to Base32 is going to be slightly different than what I described earlier. We need to split the input string into chunks (5 bytes each), starting from the left (most significant first).</p>
<p>Let’s follow the RFC algorithm step by step to encode an example string: <code>foobar</code>, which should be encoded to <code>MZXW6YTBOI======</code>.</p>
<p>Here’s a visualization of what we’re going to do:</p>
<div>
  <div>
    

  <pre><code>1. Groups of 8 bits

01100110 01101111 01101111 01100010 01100001
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘
  102      111      111      098      097
  f        o        o        b        a</code></pre>


  <pre><code>1. Groups of 8 bits

01100110 01101111 01101111 01100010 01100001</code></pre>


  <pre><code>2. Join into a single number

01100110 01101111 01101111 01100010 01100001</code></pre>


  <pre><code>2. Join into a single number

0110011001101111011011110110001001100001</code></pre>


  <pre><code>3. Split into groups of 5 bits

0110011001101111011011110110001001100001</code></pre>


  <pre><code>3. Split into groups of 5 bits

01100 11001 10111 10110 11110 11000 10011 00001</code></pre>


  <pre><code>4. Each group is mapped to a char in the ALPHABET

01100 11001 10111 10110 11110 11000 10011 00001</code></pre>


  <pre><code>4. Each group is mapped to a char in the ALPHABET

01100 11001 10111 10110 11110 11000 10011 00001
└───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘
 12    25    23    22    30    24    19    1
 M     Z     X     W     6     Y     T     B</code></pre>


  <pre><code>4. Each group is mapped to a char in the ALPHABET




 M     Z     X     W     6     Y     T     B</code></pre>


  <pre><code>4. Each group is mapped to a char in the ALPHABET




 MZXW6YTB</code></pre>


  </div>
</div>

<p>First, we’ll convert the string to an array of bytes. Then we’ll split the array into groups of 5 bytes. Since each byte is 8 bits, this means each group will be 40 bits (8 bits per byte * 5 bytes).</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>bytes</span> <span>=</span> <span>&#39;foobar&#39;</span><span>.</span><span>bytes</span> <span>#=&gt; [102, 111, 111, 98, 97, 114]</span>
<span>chunks</span> <span>=</span> <span>bytes</span><span>.</span><span>each_slice</span><span>(</span><span>5</span><span>)</span><span>.</span><span>to_a</span>

<span># =&gt; [[102, 111, 111, 98, 97], [114]]</span>
</code></pre></div><p>The last group contains only 1 byte, so it’s not divisible by 5. We’ll deal with this problem later. For now, let’s focus on the first chunk:</p>
<div><pre tabindex="0"><code data-lang="plain">102 111 111 098 097
└─┘ └─┘ └─┘ └─┘ └─┘
 f   o   o   b   a
</code></pre></div><p>And the binary representation:</p>
<div><pre tabindex="0"><code data-lang="plain">01100110 01101111 01101111 01100010 01100001
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘
  102      111      111      098      097
  f        o        o        b        a
</code></pre></div><p>First, we’ll combine these bytes into a single 40-bit number:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>chunk</span> <span>=</span> <span>[</span><span>102</span><span>,</span> <span>111</span><span>,</span> <span>111</span><span>,</span> <span>98</span><span>,</span> <span>97</span><span>]</span>
<span>buf</span> <span>=</span> <span>0</span>
<span>chunk</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
  <span>buf</span> <span>=</span> <span>(</span><span>buf</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>+</span> <span>byte</span>
<span>end</span>

<span>buf</span> <span>#=&gt; 439956234849 (01100 11001 10111 10110 11110 11000 10011 00001)</span>
</code></pre></div><p>Here’s the binary version of the loop above:</p>
<div><pre tabindex="0"><code data-lang="plain">1100110 &lt;&lt; 8
110011000000000 + 1101111 = 110011001101111

110011001101111 &lt;&lt; 8
11001100110111100000000 + 1101111 = 11001100110111111011111

11001100110111101101111 &lt;&lt; 8
1100110011011110110111100000000 + 1100010 = 1100110011011110110111101100010

1100110011011110110111101100010 &lt;&lt; 8
110011001101111011011110110001000000000 + 1100001 = 110011001101111011011110110001001100001
</code></pre></div><p>The result is a 40-bit number. We’ll divide this number into eight 5-bit groups, with each 5-bit group being encoded into a single character:</p>
<div><pre tabindex="0"><code data-lang="plain">01100 11001 10111 10110 11110 11000 10011 00001
└───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘
 12    25    23    22    30    24    19    1    # index in the ALPHABET array
 M     Z     X     W     6     Y     T     B    # the character it represents
</code></pre></div><p>Here’s the code to extract those 5-bit groups and encode them into 8 characters:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>ALPHABET</span> <span>=</span> <span>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#34;</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>)</span>
<span>encoded</span> <span>=</span> <span>Array</span><span>.</span><span>new</span><span>(</span><span>8</span><span>)</span>
<span>j</span> <span>=</span> <span>encoded</span><span>.</span><span>length</span> <span>-</span> <span>1</span>

<span>encoded</span><span>.</span><span>length</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
  <span>encoded</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>ALPHABET</span><span>[</span><span>(</span><span>buf</span> <span>&gt;&gt;</span> <span>5</span> <span>*</span> <span>i</span><span>)</span> <span>&amp;</span> <span>0x1f</span><span>]</span>
  <span>j</span> <span>-=</span> <span>1</span>
<span>end</span>

<span>encoded</span><span>.</span><span>join</span> <span>#=&gt; MZXW6YTB</span>
</code></pre></div><p>This operation is very similar to what we did in our Base8 example. We use the <code>0x1f</code> bit mask to extract 5 bits at a time. After each extraction, we shift the number right by 5 bits to access the next 5 bits. The extracted 5 bits act as an index to find the corresponding character in the <code>ALPHABET</code> array.</p>
<p>Now we have our first chunk encoded to Base32, but it’s time to deal with the tricky part.</p>
<p>The RFC says that if the last group contains less than 40 bits, it must be padded with zeros until the total number of bits becomes divisible by 5. Each group of 5 bytes should yield 8 encoded characters. If the last chunk produces fewer than 8 characters, we’ll pad the remaining space with <code>=</code>.</p>
<p>In our example, the last chunk contains only 1 byte (8 bits), so we’ll pad it with 2 bits to reach 10 bits, the smallest number divisible by 5.</p>
<p>Two calculations are necessary here:</p>
<ol>
<li>Determining how many characters the last chunk will produce.</li>
<li>Calculating the number of bits needed to pad the chunk to make the total divisible by 5.</li>
</ol>
<p>For the first part, we’ll use this formula:</p>
<div><pre tabindex="0"><code data-lang="plain">40 bits = 8 characters
8 bits  = x characters

x = 8 * 8 / 40 = 1.6
</code></pre></div><p>Rounding up, we know this chunk should yield 2 characters</p>
<p>Now, for the padding calculation:</p>
<div><pre tabindex="0"><code data-lang="plain">padding = 5 - (chunk.size * 8) % 5
</code></pre></div><p>In our case, the last chunk is a single byte (<code>114</code>, <code>01110010</code>, representing the letter <code>r</code>). We’ll pad it with 2 bits at the end:</p>
<div>
  <div>
    

  <pre><code>  01110010 &lt;&lt; 2</code></pre>


  <pre><code> 011100100 &lt;&lt; 2</code></pre>


  <pre><code>0111001000 &lt;&lt; 2</code></pre>



  </div>
</div>

<p>This gives us 10 bits that will be encoded to 2 characters.</p>
<div><pre tabindex="0"><code data-lang="plain">01110 01000
└───┘ └───┘
 14    8    # index in the ALPHABET array
 O     I    # the character it represents
</code></pre></div><p>Translated to code, here’s the whole encoding sequence:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>chunk</span> <span>=</span> <span>[</span><span>114</span><span>]</span> <span># the last chunk, the letter &#34;r&#34;</span>
<span>bits_in_chunk</span> <span>=</span> <span>chunk</span><span>.</span><span>length</span> <span>*</span> <span>8</span>
<span>number_of_characters</span> <span>=</span> <span>(</span><span>bits_in_chunk</span> <span>/</span> <span>5</span><span>.</span><span>to_f</span><span>)</span><span>.</span><span>ceil</span>     <span># how many encoded characters this chunk will produce</span>
<span>padding</span> <span>=</span> <span>bits_in_chunk</span> <span>&lt;</span> <span>40</span> <span>?</span> <span>5</span> <span>-</span> <span>bits_in_chunk</span> <span>%</span> <span>5</span> <span>:</span> <span>0</span> <span># how many bits we need to pad to make the number of bits divisible by 5</span>

<span>buf</span> <span>=</span> <span>0</span>
<span>chunk</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
  <span>buf</span> <span>=</span> <span>(</span><span>buf</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>+</span> <span>byte</span> <span># combine the bytes into a single number</span>
<span>end</span>
<span>buf</span> <span>&lt;&lt;=</span> <span>padding</span> <span># add missing bits to the right</span>

<span>encoded</span> <span>=</span> <span>Array</span><span>.</span><span>new</span><span>(</span><span>8</span><span>)</span> <span># an array to hold 8 encoded characters</span>
<span>j</span> <span>=</span> <span>number_of_characters</span> <span>-</span> <span>1</span>

<span># encode 2 characters</span>
<span>number_of_characters</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
  <span>encoded</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>ALPHABET</span><span>[</span><span>(</span><span>buf</span> <span>&gt;&gt;</span> <span>5</span> <span>*</span> <span>i</span><span>)</span> <span>&amp;</span> <span>0x1f</span><span>]</span> <span># extract 5 bits at a time</span>
  <span>j</span> <span>-=</span> <span>1</span>
<span>end</span>

<span># pad the result with 6 &#39;=&#39;</span>
<span>(</span><span>8</span> <span>-</span> <span>number_of_characters</span><span>)</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
  <span>encoded</span><span>[</span><span>number_of_characters</span> <span>+</span> <span>i</span><span>]</span> <span>=</span> <span>&#34;=&#34;</span>
<span>end</span>

<span>encoded</span><span>.</span><span>join</span> <span>#=&gt; OI======</span>
</code></pre></div><p>We’re now done with the encoding part. At this point, our code should cover all the test vectors described by the RFC:</p>
<div><pre tabindex="0"><code data-lang="plain">BASE32(&#34;&#34;)       = &#34;&#34;
BASE32(&#34;f&#34;)      = &#34;MY======&#34;
BASE32(&#34;fo&#34;)     = &#34;MZXQ====&#34;
BASE32(&#34;foo&#34;)    = &#34;MZXW6===&#34;
BASE32(&#34;foob&#34;)   = &#34;MZXW6YQ=&#34;
BASE32(&#34;fooba&#34;)  = &#34;MZXW6YTB&#34;
BASE32(&#34;foobar&#34;) = &#34;MZXW6YTBOI======&#34;
</code></pre></div><h3 id="decoding">Decoding</h3>
<p>Now, let’s reverse the process. At the bit level, the process of turning <code>MZXW6YTBOI======</code> back to <code>foobar</code> will look like this:</p>
<div>
  <div>
    
  <pre><code>1. Groups of 5 bits

01100 11001 10111 10110 11110 10110 10011 00001
└───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘
 12    25    23    22    30    22    19     1</code></pre>


  <pre><code>1. Groups of 5 bits

01100 11001 10111 10110 11110 10110 10011 00001</code></pre>


  <pre><code>2. Join into a single number

01100 11001 10111 10110 11110 10110 10011 00001</code></pre>


  <pre><code>2. Join into a single number

0110011001101111011011110101101001100001</code></pre>


  <pre><code>3. Split into groups of 8 bits

0110011001101111011011110101101001100001</code></pre>


  <pre><code>3. Split into groups of 8 bits

01100110 01101111 01101111 01100010 01100001</code></pre>


  <pre><code>4. Map each byte to a character

01100110 01101111 01101111 01100010 01100001</code></pre>


  <pre><code>4. Map each byte to a character

01100110 01101111 01101111 01100010 01100001
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘
  102      111      111      098      097
   f        o        o        b        a</code></pre>


  <pre><code>4. Map each byte to a character




   f        o        o        b        a</code></pre>


  <pre><code>4. Map each byte to a character




   fooba</code></pre>



  </div>
</div>

<p>Step by step, to decode a Base32 string, we have to do the following:</p>
<ol>
<li>Remove the <code>=</code> padding characters from the input string.</li>
<li>Split the string into an array of characters.</li>
<li>Turn each character into its index in the <code>ALPHABET</code> array.</li>
<li>Divide the array to chunks of 8 bytes (40 bits = 8 * 5 encoded bits).</li>
<li>Calculate the number of original bytes the given chunk represents (when the last chunk has less than 40 bits).</li>
<li>Calculate the bit padding applied when encoding.</li>
<li>Combine the bytes into a single number and strip the padding.</li>
<li>Decode the number by extracting 1 byte (8 bits) at a time.</li>
</ol>
<p>So, starting with the string <code>MZXW6YTBOI======</code>:</p>
<div><pre tabindex="0"><code data-lang="plain">1. MZXW6YTBOI
2. [&#34;M&#34;, &#34;Z&#34;, &#34;X&#34;, &#34;W&#34;, &#34;6&#34;, &#34;Y&#34;, &#34;T&#34;, &#34;B&#34;, &#34;O&#34;, &#34;I&#34;]
3. [12, 25, 23, 22, 30, 24, 19, 1, 14, 8]
4. [[12, 25, 23, 22, 30, 24, 19, 1], [14, 8]]
</code></pre></div><p>The first chunk of the array has exactly 8 elements. We’ll combine the values into a single 40-bit number:</p>
<div><pre tabindex="0"><code data-lang="plain">01100 11001 10111 10110 11110 10110 10011 00001
└───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘ └───┘
 12    25    23    22    30    22    19     1
</code></pre></div><div><pre tabindex="0"><code data-lang="plain">01100 &lt;&lt; 5 = 0110000000
0110000000 + 11001 = 0110011001

0110011001 &lt;&lt; 5
011001100100000 + 10111 = 011001100101111

011001100101111 &lt;&lt; 5
01100110010111100000 + 10110 = 01100110010111110110

01100110010111110110 &lt;&lt; 5
0110011001011111011000000 + 11110 = 0110011001011111011001110

0110011001011111011001110 &lt;&lt; 5
011001100101111101100111000000 + 11000 = 011001100101111101100111011000

011001100101111101100111011000 &lt;&lt; 5
01100110010111110110011101100000000 + 10011 = 01100110010111110110011101100010011

01100110010111110110011101100010011 &lt;&lt; 5
0110011001011111011001110110001001100000 + 00001 = 0110011001011111011001110110001001100001
</code></pre></div><p>We should end up with the exact same number that we initially encoded. To decode it, we’ll group the bits into 8-bit segments (bytes) and extract them one by one:</p>
<div><pre tabindex="0"><code data-lang="plain">01100110 01101111 01101111 01100010 01100001
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘
  102      111      111      098      097
   f        o        o        b        a
</code></pre></div><p>To extract 8 bits at a time, we’ll use the <code>0xff</code> (<code>11111111</code>) bit mask:</p>
<div><pre tabindex="0"><code data-lang="plain">  01100110 01101111 01101111 01100010 01100001
&amp; 00000000 00000000 00000000 00000000 11111111
= 00000000 00000000 00000000 00000000 01100001
                                      └──────┘
                                         97
</code></pre></div><p>For the second chunk (<code>OI</code>, representing 2 bytes), we have to do some extra work. We need to calculate</p>
<ol>
<li>The number of bytes this chunk represents in the original <code>foobar</code> string.</li>
<li>The number of bits that were added as padding during the encoding process.</li>
</ol>
<p>The whole decoding sequence:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>str</span> <span>=</span> <span>&#34;MZXW6YTBOI&#34;</span>
<span>str</span> <span>=</span> <span>str</span><span>.</span><span>delete</span><span>(</span><span>&#34;=&#34;</span><span>)</span>
<span>bytes</span> <span>=</span> <span>str</span><span>.</span><span>each_char</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>char</span><span>|</span> <span>ALPHABET</span><span>.</span><span>index</span><span>(</span><span>char</span><span>)</span> <span>}</span>

<span>bytes</span><span>.</span><span>each_slice</span><span>(</span><span>8</span><span>)</span><span>.</span><span>map</span> <span>do</span> <span>|</span><span>chunk</span><span>|</span>
  <span>number_of_original_bytes</span> <span>=</span> <span>(</span><span>chunk</span><span>.</span><span>length</span> <span>*</span> <span>5</span><span>.</span><span>0</span> <span>/</span> <span>8</span><span>.</span><span>0</span><span>)</span><span>.</span><span>floor</span>
  <span>padding</span> <span>=</span> <span>chunk</span><span>.</span><span>length</span> <span>&lt;</span> <span>8</span> <span>?</span> <span>5</span> <span>-</span> <span>(</span><span>number_of_original_bytes</span> <span>*</span> <span>8</span><span>)</span> <span>%</span> <span>5</span> <span>:</span> <span>0</span>

  <span>buf</span> <span>=</span> <span>0</span>
  <span>chunk</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>byte</span><span>|</span>
    <span>buf</span> <span>=</span> <span>(</span><span>buf</span> <span>&lt;&lt;</span> <span>5</span><span>)</span> <span>+</span> <span>byte</span> <span># each byte in the chunk represents 5 bits</span>
  <span>end</span>
  <span>buf</span> <span>&gt;&gt;=</span> <span>padding</span> <span># remove the padding (in this case, the last 2 bits)</span>

  <span>decoded</span> <span>=</span> <span>Array</span><span>.</span><span>new</span><span>(</span><span>number_of_original_bytes</span><span>)</span>
  <span>j</span> <span>=</span> <span>decoded</span><span>.</span><span>length</span> <span>-</span> <span>1</span>

  <span>number_of_original_bytes</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>i</span><span>|</span>
    <span># extract 8 bits at a time and convert to a character</span>
    <span>decoded</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>((</span><span>buf</span> <span>&gt;&gt;</span> <span>8</span> <span>*</span> <span>j</span><span>)</span> <span>&amp;</span> <span>0xff</span><span>)</span><span>.</span><span>chr</span>
    <span>j</span> <span>-=</span> <span>1</span>
  <span>end</span>

  <span>decoded</span>
<span>end</span><span>.</span><span>join</span> <span>#=&gt; foobar</span>
</code></pre></div><p>At this point, we should have a working Base32 encoder and decoder.</p>
<h3 id="towards-a-more-generic-approach">Towards a more generic approach</h3>
<p>Now let’s wrap the code into a class. We’ll also replace the hardcoded values with constants to make it a little more descriptive and universal:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>Base32</span>
  <span>ALPHABET</span> <span>=</span> <span>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&#34;</span><span>.</span><span>split</span><span>(</span><span>&#34;&#34;</span><span>)</span>
  <span>PADDING_CHAR</span> <span>=</span> <span>&#34;=&#34;</span>

  <span>BITS_PER_BYTE</span>  <span>=</span> <span>8</span>  <span># 1 byte = 8 bits</span>
  <span>BITS_PER_CHAR</span>  <span>=</span> <span>Math</span><span>.</span><span>log2</span><span>(</span><span>ALPHABET</span><span>.</span><span>length</span><span>)</span><span>.</span><span>round</span> <span># 5 = 32 chars = 2^5 - number of bits encoded into a single character in the ALPHABET</span>
  <span>BITS_PER_CHUNK</span> <span>=</span> <span>BITS_PER_CHAR</span><span>.</span><span>lcm</span><span>(</span><span>BITS_PER_BYTE</span><span>)</span> <span># 40 (least common mutliple of 5 and 8)</span>

  <span>CHARS_PER_CHUNK</span> <span>=</span> <span>BITS_PER_CHUNK</span> <span>/</span> <span>BITS_PER_CHAR</span>  <span># 8</span>
  <span>CHUNK_LENGTH</span>    <span>=</span> <span>BITS_PER_CHUNK</span> <span>/</span> <span>BITS_PER_BYTE</span>  <span># 5</span>

  <span>ENCODING_MASK</span> <span>=</span> <span>ALPHABET</span><span>.</span><span>length</span> <span>-</span> <span>1</span> <span># 0x1f</span>
  <span>DECODING_MASK</span> <span>=</span> <span>0xff</span>

  <span>def</span> <span>self</span><span>.</span><span>encode</span><span>(</span><span>str</span><span>)</span>
    <span># ...</span>
  <span>end</span>

  <span>def</span> <span>self</span><span>.</span><span>decode</span><span>(</span><span>str</span><span>)</span>
    <span># ...</span>
  <span>end</span>
<span>end</span>
</code></pre></div><p>The result may be slightly more difficult to follow, but the point of this change should be clear in the next section<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>The complete implementation <a href="https://gist.github.com/pch/585f0c949acf2e10454f702c23cd63d2">can be found here</a>.</p>
<div>
  <h4>The pitfalls of Base32</h4>
  <p>Compared to Base64, Base32 offers a lot more flexibility and there are multiple variations of the encoding. The alphabet is fully customizable: you can change the order in the alphabet, replace certain characters to avoid accidental profanity or skip characters that look similar, like in the <a href="https://www.crockford.com/base32.html">Crockford’s variant</a>. But this is a choice you’ll only get to make once and you can’t easily change the alphabet later.</p>
<p>This flexibility makes Base32 tied to the specific implementation. The lack of a universal standard is an important reason why it’s not nearly as popular as Base64.</p>

</div>

<h2 id="base64-and-beyond">Base64 and beyond</h2>
<p>Now that we know how to implement Base32, let’s try to use the same method to implement our own Base64 encoder<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>.</p>
<p>Base64 encodes 6 bits of data into a single character (2^6 = 64 character combinations of 6 bits). This means that our chunk has to be the least common multiple of 8 and 6, that is 24 (8 bits per byte, 6 bits per character).</p>
<p>Our existing code should be able handle it out of the box. The only required change is to replace the <code>ALPHABET</code> array:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>ALPHABET</span> <span>=</span> <span>&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#34;</span><span>.</span><span>split</span>
</code></pre></div><p>The rest of the code will be identical. Every other value will be calculated automatically based on the length of the <code>ALPHABET</code>:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>BITS_PER_CHARACTER</span> <span>=</span> <span>6</span>
<span>BITS_PER_CHUNK</span>     <span>=</span> <span>24</span>
<span>CHARS_PER_CHUNK</span>    <span>=</span> <span>4</span>
<span>CHUNK_LENGTH</span>       <span>=</span> <span>3</span>
<span>ENCODING_MASK</span>      <span>=</span> <span>0x3f</span> <span># mask to extract 6 bits at a time</span>
</code></pre></div><p>In theory, the method I described could be used to implement any Base2ⁿ encoding. However, considering that the ASCII character set includes only 95 printable characters, Base64 is the highest Base2ⁿ encoding you’ll see in everyday use.</p>
<hr/>
<p>With all that said, implementing a Base2ⁿ encoder is a problem you’ll hardly ever have to deal with in the real world. But I hope the examples in this post helped you understand what exactly happens behind the scenes when you use Base64 or Base32.</p>
<p>If you have any comments, questions or suggestions, don’t hesitate to reach out to me via email.</p>


    </div>

    
  </article>

  
  
  

    </main>

    

  </div></div>
  </body>
</html>
