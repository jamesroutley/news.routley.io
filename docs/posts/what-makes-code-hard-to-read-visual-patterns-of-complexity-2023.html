<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://seeinglogic.com/posts/visual-readability-patterns/">Original</a>
    <h1>What Makes Code Hard to Read: Visual Patterns of Complexity (2023)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Not long ago, I was auditing a codebase for work (looking for bugs) when I realized that despite the quality of the code, I was becoming mentally fatigued extremely quickly and had a hard time working on it for long stretches of time…</p><p>I ended up figuring out what made this codebase so difficult to stick with, but it didn’t turn out to be what I expected (<a href="https://seeinglogic.com/posts/cyclomatic-complexity-illustrated/">Cyclomatic Complexity</a>). After doing a little reflection and research, it ended up being something more related to readability–something I didn’t have a lot of data on, but was curious to learn if there was objective terminology or common metrics.</p><p>So today we’re jumping into the results of that investigation, which means instead of visualizing code, we’re talking about <strong>visual patterns</strong> of code, specifically the ones that make my brain hurt!</p><p>Be warned! Tis a murky and ill-defined realm… some of the data points include popular metrics, academic papers, and practical opinions (including my own), but by the end of the search we’ll distill it down to <a href="#8-patterns-for-improving-code-readability">8 visually-observable properties</a> that can help programmers of any language improve the readability of code.</p><h2>Code readability metrics and alternate complexity metrics<span><a href="#code-readability-metrics-and-alternate-complexity-metrics" aria-label="Anchor">#</a></span></h2><p>Let me be upfront: there is no commonly-used and accepted metric for code readability.</p><p>All I could find was 1) academic papers that didn’t seem to be used by the real world and 2) opinions… when I was looking for something more tangible.</p><p>Since I wasn’t looking to invent my own metric, my goal was to collect a set of visual patterns that anyone could use in a discussion about what makes code easier to read.</p><p>For example, take the examples below where the primary difference is just the shape or pattern of logic. Is any one of them the <em>easiest</em> to read? Or are some of them objectively <em>worse</em> to read?</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/6-oddness.png" alt="Six ways to write a simple getOddness function"/></figure><p>The differences between some of the examples above are a matter of preference, but it is interesting to look for patterns that point out the “bad” ones… especially if those are easy to spot visually, with no special tools required!</p><p>My first thought for finding such patterns was to look at complexity metrics, but interestingly there’s not a huge number of well-known software complexity metrics or academic readability ideas that fit what I was looking for, specifically measures that:</p><ol><li>Work on source code snippets or a single function</li><li>Don’t focus on “core complexity”: certain measurements like cyclomatic complexity are to some degree inseparable from the algorithm being implemented</li><li>Don’t focus on superficial style factors: length of variable names, whitespace usage, choices of indentation or brackets/parens placement, etc.</li></ol><p>But the good news was that there was two metrics that seem to be in use that did fit the criteria, so that’s where the journey begins.</p><h2>Halstead Complexity Metrics<span><a href="#halstead-complexity-metrics" aria-label="Anchor">#</a></span></h2><p>In the late 70’s, a fellow named Maurice Halstead came up with a set of metrics in an attempt to build empirical measures of source code.
This means they are translatable across languages and platforms, which is really nice for our purpose because they focus on how something is written rather than the complexity of underlying algorithms being described.</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/halstead-and-book.png" alt="Maurice Halstead and his seminal work"/></figure><p>The root of his metrics was four measurements based around counting <a href="https://en.wikipedia.org/wiki/Operator_%28computer_programming%29" target="_blank">operators</a> and <a href="https://en.wikipedia.org/wiki/Operand" target="_blank">operands</a>:</p><ul><li>Number of <em>distinct</em> <em>operators</em> (<code>n1</code>)</li><li>Number of <em>distinct</em> <strong>operands</strong> (<code>n2</code>)</li><li>Number of <strong>total</strong> <em>operators</em> (<code>N1</code>)</li><li>Number of <strong>total</strong> <strong>operands</strong> (<code>N2</code>)</li></ul><p>Halstead’s focus was building a system of related metrics such as program “length”, “volume”, and “difficulty” with a series of equations describing the relationships between them… ambitiously culminating in a numerical value that would estimate the number of bugs contained in the implementation!</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/halstead-equations.png" alt="Halstead Complexity Metrics Equations"/></figure><p>These metrics definitely are debatable (they were made in the 70’s…), but they give us numbers that are a starting point for at least comparison, and the reasoning seems to make sense</p><p>Intuitively, the more operators in play, the more one has to reason about potential interactions.
Similarly, a larger number of operands means understanding possibilities of dataflow become more complex.</p><h3>Halstead Complexity Javascript Example<span><a href="#halstead-complexity-javascript-example" aria-label="Anchor">#</a></span></h3><p>If we go back to our early example we can make two variations that attempt to be on separate ends of the spectrum in terms of operands and operators, and we can see how that affects two of the Halstead metrics, <em>Volume</em> and <em>Difficulty</em>.</p><div><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>getOddnessA</span><span>(</span><span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>n</span> <span>%</span> <span>2</span><span>)</span>
</span></span><span><span>        <span>return</span> <span>&#39;Odd&#39;</span><span>;</span>
</span></span><span><span>    <span>return</span> <span>&#39;Even&#39;</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// Halstead metrics from: https://ftaproject.dev/playground
</span></span></span><span><span><span>// operators: 4 unique, 7 total
</span></span></span><span><span><span>// operands:  5 unique, 6 total
</span></span></span><span><span><span>// &#34;Volume&#34;      33.30
</span></span></span><span><span><span>// &#34;Difficulty&#34;  2.50
</span></span></span><span><span><span></span>
</span></span><span><span><span>function</span> <span>getOddnessB</span><span>(</span><span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>const</span> <span>evenOdd</span> <span>=</span> <span>[</span><span>&#39;Odd&#39;</span><span>,</span> <span>&#39;Even&#39;</span><span>];</span>
</span></span><span><span>    <span>const</span> <span>index</span> <span>=</span> <span>Number</span><span>(</span><span>n</span> <span>%</span> <span>2</span> <span>===</span> <span>0</span><span>);</span>
</span></span><span><span>    <span>return</span> <span>evenOdd</span><span>[</span><span>index</span><span>];</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// operators: 7 unique, 10 total
</span></span></span><span><span><span>// operands:  9 unique, 12 total
</span></span></span><span><span><span>// &#34;Volume&#34;      71.35
</span></span></span><span><span><span>// &#34;Difficulty&#34;  3.75
</span></span></span></code></pre></div></div><p>You can tell just by looking that the first one has fewer operators and operands and is a bit easier to read, and the Halstead Volume and Difficulty numbers confirm this. That’s kinda nice!</p><p>The big downside here is that it’s not well-defined what exactly counts as an <strong>operator</strong> or <strong>operand</strong> for all languages, so it’s best to just use a specific tool or implementation for measurement and stick with it. I used <a href="https://ftaproject.dev/playground" target="_blank">this site</a> for the measurements reported above, whereas the picture below shows my estimation of trying to color code operators/operands to show visually that fewer colors is simpler:</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/halstead-colors.png" alt="Pictures of operands and operators colored for getOddnessA and B"/></figure><h3>Halstead Complexity Takeaways<span><a href="#halstead-complexity-takeaways" aria-label="Anchor">#</a></span></h3><p>From a practical standpoint, these metrics suggest a couple of useful patterns to me:</p><ul><li>Smaller functions with fewer variables are generally easier to read, and redundant variables are only for when you hate the people that read your code</li><li>Prefer to <em>not</em> use language-specific operators or syntactic sugars, since additional constructs are a tax on the reader. Try reading someone else’s Perl or Ruby if this doesn’t resonate with you.</li><li>Chaining together <code>map</code>/<code>reduce</code>/<code>filter</code> and other functional programming constructs (lambdas, iterators, comprehensions) may be concise, but long/multiple chains hurt readability<ul><li>This seems more common in Javascript and Rust, or when a Python programmer gets fascinated with itertools</li></ul></li></ul><p>As mentioned, the Halstead metrics have been debated fiercely in <a href="https://arxiv.org/pdf/1408.4523.pdf" target="_blank">academic</a> and <a href="https://nvlpubs.nist.gov/nistpubs/TechnicalNotes/NIST.TN.1990.pdf" target="_blank">other</a> circles, but we don’t need to wait for <em>science</em>.</p><p>Pfft, we can take the ideas and run!</p><h2>“Cognitive Complexity”<span><a href="#cognitive-complexity" aria-label="Anchor">#</a></span></h2><p>A more recent metric developed in an effort to more accurately capture the difficulty of reading is a measure called “<a href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" target="_blank">Cognitive Complexity</a>” developed by SonarSource, a company that makes static analysis products.</p><p>Some people find the name of the metric misleading, feeling that it makes the measure sound more scientific or objective, rather than naming it something that sounds like a heuristic developed from experience.</p><p>Being a practitioner who really only cares about effectiveness, I’ll take good metrics with bad names over bad metrics, and I have respect for heuristics as long as they work!</p><p>The authors break down Cognitive Complexity into three ideas:</p><ol><li>Shorthand constructs that combine statements decreases difficulty</li><li>Each break from linear flow increases difficulty</li><li>Nested control flow increases difficulty</li></ol><p>Seems straightforward and reasonable, but the whitepaper goes into <em>much</em> more depth than just three points, so let’s get into the meat of this to see what a group of static analysis developers believe hurt readability.</p><h3>Shorthand Constructs<span><a href="#shorthand-constructs" aria-label="Anchor">#</a></span></h3><p>For the first principle, their whitepaper uses the following two snippets, arguing that the first increases difficulty for the reader while the second doesn’t:</p><div><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>// 1
</span></span></span><span><span><span></span><span>MyObj</span> <span>myObj</span> <span>=</span> <span>null</span><span>;</span>
</span></span><span><span><span>if</span> <span>(</span><span>a</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>myObj</span> <span>=</span> <span>a</span><span>.</span><span>myObj</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// 2
</span></span></span><span><span><span></span><span>MyObj</span> <span>myObj</span> <span>=</span> <span>a</span><span>?</span><span>.</span><span>myObj</span><span>;</span>
</span></span></code></pre></div></div><p>The second is shorter and takes less time to read, but I’d argue that in the second construct there’s a better chance that the programmer forgets to properly handle all of the possibilities… case in point, these code snippets aren’t actually equivalent!</p><p>In the first case <code>myObj</code> will either be <code>a.myObj</code> or <code>null</code> and in the second it will be <code>a.myObj</code> or <code>undefined</code>!</p><p>This may seem like splitting hairs, but if I’ve got my bug-hunting hat on, I look for the small unexpected behaviors like this to see if I can leverage them into something useful!</p><p>Even using languages with solid type-checking like TypeScript or Rust, they only reduce the chance you <em>omit</em> handling such a case, but it doesn’t mean that you handle it <em>correctly</em> in all cases.</p><p>Without the assistance of type checking, like in vanilla JavaScript, the chances of that corner case not being handled are much higher.
So while I won’t argue that shorthand constructs are simpler to write and easier to read, there’s still some tradeoff in terms of conciseness and density.</p><h3>Linear Flow Breaks<span><a href="#linear-flow-breaks" aria-label="Anchor">#</a></span></h3><p>One thing that seems obvious is that “linear” code with no conditionals is easier to scan than code with conditionals, and is a big focus for Cognitive Complexity.</p><p>Naturally they assess additional difficulty for any conditionals, loops, or <code>goto</code>s, but they also get a bit fancier and include conditional macros, try/except blocks, sequences of logical operators, and recursion.</p><p>I totally agree that each of these things generally affect readability, but I think there are four fine points worth talking about.</p><p>Point 1. They count <code>switch</code> statements as a single group, but they penalize each additional <code>else-if</code> in a chain because each <code>else-if</code> <strong>can</strong> make more than one comparison, even the one in question doesn’t.</p><p>Don’t get me wrong, I think switches look better than if-else chains, but they aren’t innocent either; switch case fall-throughs definitely increase reading difficulty and missing <code>break</code>s have caused needless headaches for many programmers, myself included!</p><div><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// Switches are preferred by this metric
</span></span></span><span><span><span></span><span>function</span> <span>getSign1</span><span>(</span><span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>switch</span> <span>(</span><span>math</span><span>.</span><span>sign</span><span>(</span><span>n</span><span>))</span> <span>{</span>
</span></span><span><span>        <span>case</span> <span>-</span><span>1</span>:
</span></span><span><span>            <span>return</span> <span>&#39;negative&#39;</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>1</span>:
</span></span><span><span>            <span>return</span> <span>&#39;positive&#39;</span><span>;</span>
</span></span><span><span>        <span>default</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>&#39;other&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// It&#39;s true that else-if doesn&#39;t look as nice when each case returns
</span></span></span><span><span><span></span><span>function</span> <span>getSign2() {</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>math</span><span>.</span><span>sign</span><span>(</span><span>n</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>&#39;negative&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>math</span><span>.</span><span>sign</span><span>(</span><span>n</span><span>)</span> <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>&#39;positive&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>&#39;other&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// but if the switch uses &#34;break&#34;, the advantage decreases...
</span></span></span><span><span><span></span><span>function</span> <span>getSign3</span><span>(</span><span>n</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>let</span> <span>sign</span> <span>=</span> <span>&#39;&#39;</span><span>;</span>
</span></span><span><span>    <span>switch</span> <span>(</span><span>math</span><span>.</span><span>sign</span><span>(</span><span>n</span><span>))</span> <span>{</span>
</span></span><span><span>        <span>case</span> <span>-</span><span>1</span>:
</span></span><span><span>            <span>sign</span> <span>=</span> <span>&#39;negative&#39;</span><span>;</span>
</span></span><span><span>            <span>break</span><span>;</span>
</span></span><span><span>        <span>case</span> <span>1</span>:
</span></span><span><span>            <span>sign</span> <span>=</span> <span>&#39;positive&#39;</span><span>;</span>
</span></span><span><span>            <span>break</span><span>;</span>
</span></span><span><span>        <span>default</span><span>:</span>
</span></span><span><span>            <span>sign</span> <span>=</span> <span>&#39;other&#39;</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>sign</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></div><p>Point 2. They count sequences of logical operators in a conditional, meaning that any length chain <code>&amp;&amp;</code> and <code>||</code> would count as one, but mixing them would count as increased difficulty.</p><p>This actually feels pretty right on, and I think this addresses how some conditionals are more difficult to read without being much longer:</p><div><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// this conditional only adds 1 point
</span></span></span><span><span><span></span><span>if</span> <span>(</span><span>debug</span> <span>||</span> <span>verbose</span> <span>||</span> <span>consoleMode</span><span>)</span> <span>{</span> <span>...</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>// this conditional adds 2, and not because of the indent
</span></span></span><span><span><span></span><span>if</span> <span>(</span><span>debug</span> <span>||</span>
</span></span><span><span>    <span>(</span><span>verbose</span> <span>&amp;&amp;</span> <span>consoleMode</span><span>))</span> <span>{</span> <span>...</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>// this conditional adds 3:
</span></span></span><span><span><span></span><span>if</span> <span>(</span><span>debug</span> <span>||</span> 
</span></span><span><span>    <span>!</span><span>(</span><span>verbose</span> <span>&amp;&amp;</span> <span>consoleMode</span><span>))</span> <span>{</span> <span>...</span> <span>}</span>
</span></span></code></pre></div></div><p>Point 3. Exception handling–something I think is commonly overlooked but can really be hard on a reader if not handled well.</p><p>In Cognitive Complexity, try/catch blocks increase the difficulty score, but multiple <code>catch</code> blocks aren’t considered harder than just one, and <code>try</code> and <code>finally</code> blocks are ignored.</p><p>I don’t want to get caught up on every point, but one important thing I think this leaves out is the readability cost of throwing exceptions.
When exception handling crosses function boundaries, it essentially interleaves the complexity of the involved functions.</p><div><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>divideBy7</span><span>(</span><span>n</span><span>)</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>throw</span> <span>Error</span><span>(</span><span>`divideBy7 expects positive numbers, got </span><span>${</span><span>n</span><span>}</span><span>`</span><span>);</span>
</span></span><span><span>        <span>// aggressive exception throwing hurts readability because
</span></span></span><span><span><span></span>        <span>// now the reader has to search and find where this might be caught
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>    <span>return</span> <span>parseInt</span><span>(</span><span>n</span> <span>/</span> <span>7</span><span>)</span>
</span></span></code></pre></div></div><p>Point 4. is that this metric counts any <em>goto</em> (aka “jump-to-label”) as always increasing difficulty; seems reasonable, right?</p><p>But there is one particular goto structure (usually “goto out” or “goto done”, etc) that <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources" target="_blank">some experts</a> seem to agree can be helpful for concisely dealing with cleanup handling on error conditions.</p><p>Conversely, if a <em>goto</em> crosses a loop boundary in an unexpected way (e.g. something not achievable with a plain <code>continue</code> or <code>break</code>), it forces the reader to re-create and understand this new and unexpected control flow… and that is always taxing to read, even if the structure and intent is logical.</p><p>My opinion is that a <em>goto</em> can be as harmless as any other conditional in some cases, but in other cases they are much worse than adding an extra <code>if</code> statement.</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/one-goto.png" alt="xkcd 292: GOTO"/><figcaption><a href="https://xkcd.com/292/" target="_blank">https://xkcd.com/292/</a></figcaption></figure><h3>Nested Conditionals/Loops<span><a href="#nested-conditionalsloops" aria-label="Anchor">#</a></span></h3><p>Since conditionals are harder to read, nested conditionals are worse, right?</p><p>The authors of this metric definitely believe so, doubling down and adding an additional point of difficult for each level of nesting (in addition to points for conditionals, loops, etc), as they show with a Java example:</p><div><div><pre tabindex="0"><code data-lang="java"><span><span><span>void</span> <span>myMethod</span> <span>()</span> <span>{</span>
</span></span><span><span>    <span>try</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>condition1</span><span>)</span> <span>{</span> <span>// +1
</span></span></span><span><span><span></span>            <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>10</span><span>;</span> <span>i</span><span>++)</span> <span>{</span> <span>// +2 (nesting=1)
</span></span></span><span><span><span></span>                <span>while</span> <span>(</span><span>condition2</span><span>)</span> <span>{</span> <span>…</span> <span>}</span> <span>// +3 (nesting=2)
</span></span></span><span><span><span></span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span> <span>catch</span> <span>(</span><span>ExcepType1</span> <span>|</span> <span>ExcepType2</span> <span>e</span><span>)</span> <span>{</span> <span>// +1
</span></span></span><span><span><span></span>        <span>if</span> <span>(</span><span>condition2</span><span>)</span> <span>{</span> <span>…</span> <span>}</span> <span>// +2 (nesting=1)
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// Cognitive  complexity 9
</span></span></span></code></pre></div></div><p>This is actually a common idea, one I agree with and have heard other practitioners call it things like the “Level of Indentation” or “Bumpy Road” metric.
Hard to disagree with the premise that nested conditional logic is harder to read, especially if the level of nesting goes beyond 2:</p><div><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>function</span> <span>logIntegerDivA</span><span>(</span><span>x</span>: <span>number</span><span>,</span> <span>y</span>: <span>number</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>debug</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>x</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>if</span> <span>(</span><span>y</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>console</span><span>.</span><span>log</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>x</span><span>/</span><span>y</span><span>));</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// vs
</span></span></span><span><span><span></span><span>function</span> <span>logIntegerDivB</span><span>(</span><span>x</span>: <span>number</span><span>,</span> <span>y</span>: <span>number</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>debug</span> <span>===</span> <span>false</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>return</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>if</span> <span>((</span><span>x</span> <span>==</span> <span>0</span><span>)</span> <span>||</span> <span>(</span><span>y</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
</span></span><span><span>        <span>return</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>console</span><span>.</span><span>log</span><span>(</span><span>Math</span><span>.</span><span>floor</span><span>(</span><span>x</span><span>/</span><span>y</span><span>));</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></div><p>We can talk about how many points different constructs are warranted, but our goal is to improve code, not come up with our own metric so we can sell a static analysis tool.</p><p>To wrap this part up, we see that Cognitive Complexity raises a lot of great discussion points on what affects readability and could be an effective heuristic, but it has its flaws.</p><p>For example, one interesting omission is that it doesn’t directly account for the length of a function… because all else being equal, long functions are generally more effort to read than short ones.</p><p>And since the company that invented it doesn’t advertise an open-source reference implementation for common languages, it’s best to take the ideas that we find helpful and continue on.</p><h2>Function shape, patterns, and variables<span><a href="#function-shape-patterns-and-variables" aria-label="Anchor">#</a></span></h2><p>A common theme when talking about visual patterns of code is to reference the “shape” of a function (referring to more than just indentation) and how it uses variables.</p><p>While there are a number of academic papers around variable use and understanding, “shape” and “pattern” aren’t well-defined terms, so I couldn’t find any that effectively captured more than one piece of what I find to be three important factors for readability:</p><ol><li>Good names are vitally important, and variable shadowing is terrible</li><li>Prefer shorter variable liveness durations</li><li>Familiar variable usage patterns are easier to understand than novel ones</li></ol><h3>Distinct and Descriptive Names<span><a href="#distinct-and-descriptive-names" aria-label="Anchor">#</a></span></h3><p>I hesitate to include the first one, because it’s obvious that descriptive names help someone understand what code is supposed to do, and duplicative or cryptic names do the opposite.</p><p>But there’s actually two facets of this idea that I feel are more related to “shape” or usage than meets the eye:</p><ol><li><a href="https://wiki.sei.cmu.edu/confluence/display/java/DCL51-J.+Do+not+shadow+or+obscure+identifiers+in+subscopes" target="_blank">Variable shadowing</a> is dangerous; any place where the reader has to think about scope rules in order to deconflict which version of a variable is being used <a href="https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes" target="_blank">should be changed</a></li><li>Prefer <a href="https://wiki.sei.cmu.edu/confluence/display/c/DCL02-C.+Use+visually+distinct+identifiers" target="_blank">visually distinct names</a> (e.g. have you ever mistaken <code>i</code> for <code>j</code> or <code>item</code> for <code>items</code>?)<ul><li>I once audited a codebase where one module’s author had used three variations of same variable name in a single function, (e.g. <code>node</code>, <code>_node</code>, and <code>thisNode</code>)… unsurprisingly this component was rife with bugs that had security impacts on the larger system</li></ul></li></ol><h3>Shorter-lived Variables<span><a href="#shorter-lived-variables" aria-label="Anchor">#</a></span></h3><p>The second idea refers to “<a href="https://en.wikipedia.org/wiki/Live-variable_analysis" target="_blank">live variable analysis</a>”, which looks at the span between where a variable is first written and the last place it could possibly be used.
This topic seems to be reserved for compiler classes, but it’s an intuitive thing: long liveness durations force the reader to do keep more possible variables and variables in their head.</p><div><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// this version declares variables at the top,
</span></span></span><span><span><span></span><span>function</span> <span>fibonacciA</span><span>(</span><span>n</span>: <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
</span></span><span><span>  <span>let</span> <span>fibN</span> <span>=</span> <span>n</span><span>;</span>
</span></span><span><span>  <span>let</span> <span>fibNMinus1</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>let</span> <span>fibNMinus2</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  <span>// live: n, fibN, fibNMinus1, fibNMinus2
</span></span></span><span><span><span></span>  <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>// live: n, fibN, fibNMinus1, fibNMinus2
</span></span></span><span><span><span></span>  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fibN</span> <span>=</span> <span>fibNMinus1</span> <span>+</span> <span>fibNMinus2</span><span>;</span>
</span></span><span><span>    <span>fibNMinus2</span> <span>=</span> <span>fibNMinus1</span><span>;</span>
</span></span><span><span>    <span>fibNMinus1</span> <span>=</span> <span>fibN</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>// live: fibN
</span></span></span><span><span><span></span>  <span>return</span> <span>fibN</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// this reduces the live range of the three local variables
</span></span></span><span><span><span></span><span>function</span> <span>fibonacciA</span><span>(</span><span>n</span>: <span>number</span><span>)</span><span>:</span> <span>number</span> <span>{</span>
</span></span><span><span>  <span>// live: n
</span></span></span><span><span><span></span>  <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>n</span> <span>===</span> <span>1</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>// these three only become live right before their use
</span></span></span><span><span><span></span>  <span>let</span> <span>fibN</span> <span>=</span> <span>n</span><span>;</span>
</span></span><span><span>  <span>let</span> <span>fibNMinus1</span> <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>let</span> <span>fibNMinus2</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>fibN</span> <span>=</span> <span>fibNMinus1</span> <span>+</span> <span>fibNMinus2</span><span>;</span>
</span></span><span><span>    <span>fibNMinus2</span> <span>=</span> <span>fibNMinus1</span><span>;</span>
</span></span><span><span>    <span>fibNMinus1</span> <span>=</span> <span>fibN</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>fibN</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></div><p>For this, don’t be concerned about the exact definition, because while it’s partly about the difficulty of mental dataflow, it’s also about locality and how far away the various uses of a variable are from each other.</p><p>The picture below shows a span of uses which approximates the liveness analysis and shows the difference even for a fairly small and contrived example.</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/live-analysis.png" alt="Side-by-side of the examples above with horizontal colored bars showing the span between initialization and last use of each variable"/></figure><p>The worst case is a variable whose liveness spans multiple functions and is written in multiple places… those are tough situations to manage without error, so carefully consider whether there’s a better way.</p><p>Often an object may be more appropriate than passing long-lived variables between functions, especially with multiple variables whose liveness durations are basically the same.
If an object doesn’t make sense, minimize the amount of functions and lines a reader has to read in order to understand what the value could be.</p><p>Functional programming paradigms often push programmers towards keeping variable liveness short, even to the point of skipping the use of variables altogether.
While there is a lot of elegant code that shows this working, you can definitely take things too far in this direction…</p><p>For long function chains or callbacks that stack up, breaking up the chain into smaller groups and using a well-named variable or helper function can go a long way in reducing the cognitive load for readers.</p><div><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// which is easier and faster to read?
</span></span></span><span><span><span></span><span>function</span> <span>funcA</span><span>(</span><span>graph</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>return</span> <span>graph</span><span>.</span><span>nodes</span><span>(</span><span>`node[name = </span><span>${</span><span>name</span><span>}</span><span>]`</span><span>)</span>
</span></span><span><span>    <span>.</span><span>connected</span><span>()</span>
</span></span><span><span>    <span>.</span><span>nodes</span><span>()</span>
</span></span><span><span>    <span>.</span><span>not</span><span>(</span><span>&#39;.hidden&#39;</span><span>)</span>
</span></span><span><span>    <span>.</span><span>data</span><span>(</span><span>&#39;name&#39;</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span><span>// or:
</span></span></span><span><span><span></span><span>function</span> <span>funcB</span><span>(</span><span>graph</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>const</span> <span>targetNode</span> <span>=</span> <span>graph</span><span>.</span><span>nodes</span><span>(</span><span>`node[name = </span><span>${</span><span>name</span><span>}</span><span>]`</span><span>)</span>
</span></span><span><span>  <span>const</span> <span>neighborNodes</span> <span>=</span> <span>targetNode</span><span>.</span><span>connected</span><span>().</span><span>nodes</span><span>();</span>
</span></span><span><span>  <span>const</span> <span>visibleNames</span> <span>=</span> <span>neighborNodes</span><span>.</span><span>not</span><span>(</span><span>&#39;.hidden&#39;</span><span>).</span><span>data</span><span>(</span><span>&#39;name&#39;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>  <span>return</span> <span>visibleNames</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></div><p>Is the second one marginally less efficient?</p><p>Yes.</p><p>Does it actually matter? No. Unless you’ve run a performance tool that tells you <em>those specific lines</em> are the problem.</p><p>As others have written, <a href="https://jvns.ca/blog/2014/05/12/computers-are-fast/" target="_blank">computers are fast</a> and <a href="https://wiki.c2.com/?PrematureOptimization" target="_blank">premature optimization is a bad thing</a>.</p><h3>Reuse of Familiar Code Patterns<span><a href="#reuse-of-familiar-code-patterns" aria-label="Anchor">#</a></span></h3><p>The third and final idea on variables is on reusing familiar code/variable shapes: basically suggesting you leverage familiarity and follow the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank">Principle of Least Surprise</a> when writing code.</p><p>Reusing code patterns wherever possible (without copy-pasting) helps because readers don’t have to think as hard about patterns they recognize, and you can call out departures from otherwise familiar structures with edifying variable names or comments.</p><p>A common example would be to stay consistent in your choice of how to write conditionals (e.g. pick one of the 6 <code>getOddness</code> shape variations from the <a href="https://seeinglogic.com/posts/visual-readability-patterns/#alternate-complexity-metrics">top of this post</a> and only use that shape in a particular codebase).
Taking this idea to its logical conclusion is basically just encouraging the use of templated or generic functions so that a reader doesn’t have to recognize that a pattern is being repeated across functions.</p><h2>8 Patterns for Improving Code Readability<span><a href="#8-patterns-for-improving-code-readability" aria-label="Anchor">#</a></span></h2><p>Combining the points discussed so far and merging/removing duplicates where possible, we end up with a list of 8 factors:</p><ol><li><strong>Line/Operator/Operand count</strong>: Make smaller functions with fewer variables and operators, they are easier to read</li><li><strong>Novelty</strong>: Avoid novelty in function shapes, operators, or syntactic sugars; prefer reusing common patterns in a codebase</li><li><strong>Grouping</strong>: Split series of long function chains, iterators, or comprehensions into logical groupings via helper functions or intermediate variables</li><li><strong>Conditional simplicity</strong>: Keep conditional tests as short as possible and prefer sequences of the same logical operator over mixing operators within a conditional</li><li><strong>Gotos</strong>: Never use <code>goto</code>s unless you are following <a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources" target="_blank">this one pattern</a>, and even then only when the alternatives are worse</li><li><strong>Nesting</strong>: Minimize nested logic (aka avoid large variations in indentation). If deep nesting is required, isolate it in a function instead of deeply nesting inside a larger function</li><li><strong>Variable distinction</strong>: Always use descriptive and visually distinct variable names; avoid variable shadowing</li><li><strong>Variable liveness</strong>: Prefer shorter liveness durations for variables, especially with regard to function boundaries</li></ol><p>Each of these applies across languages and code format/styles, and can give objective measures to use in discussions about readability.</p><h2>Conclusion<span><a href="#conclusion" aria-label="Anchor">#</a></span></h2><p>We’ve covered a lot of ideas from a wide variety of sources, but in the end we collected a set of visually observable patterns that can help determine why certain code is harder to read.</p><figure><img loading="lazy" src="https://seeinglogic.com/posts/visual-readability-patterns/wtfs-per-minute.jpg" alt="WTFs per minute is the only real measure of code quality"/></figure><p>To bring closure to the story at the beginning of this post, the codebase that was breaking my brain had several anti-patterns, specifically related to items 1, 2, 3, 6, and 8 in the list above.</p><p>It had long functions, used a wide mix of language constructs, and contained many function chains which should’ve been put in helper functions. As a side effect, the code’s many large functions ended up with a lot of nested complexity and long-lived variables too.</p><p>Despite the high quality of the code and the authors, we found more than one critical bug, including one that was pretty easy to see… but it had been missed, in my opinion because it was in the middle of a long and complex function that was difficult to reason about.</p><p>Since all of the patterns in this post focused on snippets and single functions, maybe in the future we’ll talk about interprocedural issues. If you want to hear more about complexity issues, find me on your <a href="https://twitter.com/seeinglogic" target="_blank">social</a> of <a href="https://infosec.exchange/@seeinglogic" target="_blank">choice</a> and let me know, or reshare this post!</p><p>Til then, I’m just going to end with what a mentor once told me early in my career: “the person who is most likely to read your code a month from now is you.”</p><h2>Selected References<span><a href="#selected-references" aria-label="Anchor">#</a></span></h2><ul><li><a href="https://iopscience.iop.org/article/10.1088/1757-899X/1076/1/012046/pdf" target="_blank">Comparing Halstead metrics of the same algorithm in Python, C++, JavaScript and Java</a></li><li><a href="https://ftaproject.dev/playground" target="_blank">Typescript Playground for Halstead Metrics and Cyclomatic Complexity</a></li><li><a href="https://radon.readthedocs.io/en/latest/intro.html" target="_blank">Radon: a Python package for complexity metrics</a></li><li><a href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" target="_blank">Cognitive complexity whitepaper</a></li><li><a href="https://peps.python.org/pep-0020/" target="_blank">The Zen of Python</a></li><li><a href="https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources" target="_blank">Carnegie Mellon Software Engineering Institute: gotos are ok in this one case</a></li></ul></div></div>
  </body>
</html>
