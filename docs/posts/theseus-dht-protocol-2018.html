<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wootfish.github.io/theseus.dht/">Original</a>
    <h1>Theseus DHT Protocol (2018)</h1>
    
    <div id="readability-page-1" class="page"><section>
      

<p>The Theseus DHT protocol lets you create distributed hash tables (DHTs) with unusually strong security properties.</p>

<p>Anyone can store data in the DHT and receive an estimate of how long that data will be stored. Once stored, data is very hard to remove or modify. Small data is stored longer; this makes the DHT well-suited for exchanging things like lists of peers, signed cryptographic hashes, compressed text, and so on.</p>

<p>Theseus DHT’s routing is based on Kademlia, which is a simple, well-analyzed, and very efficient DHT protocol. Unfortunately, Kademlia suffers from several significant security setbacks. It is very vulnerable to Sybil attacks, which can result in the modification or erasure of any data in the network. It also uses no message encryption whatsoever. <a href="https://wootfish.github.io/sohliloquies/2017/12/14/net-neutrality-and-theseus-dht.html">Once upon a time, these may not have seemed like serious issues, but times are changing</a>.</p>

<p>Theseus DHT addresses these and other concerns, offering robustness in the face of Sybil attacks through <a href="https://wootfish.github.io/sohliloquies/2017/02/26/resisting-sybil-attacks-in-distributed_25.html">a combination of novel strategies</a>. It also adds new desirable features like strong encryption, optional authentication, optional perfect forward secrecy, resistance to man-in-the-middle attacks, and more. It runs over TCP, allowing it to be used with anonymity layers like Tor. The protocol’s design permits easy mathematical analysis, allowing for rigorous proofs of its (considerable) resilience against Sybil attacks – a property which increases in degree as the network itself grows.</p>

<p>To a passive observer, all Theseus DHT protocol traffic is indistinguishable from random noise. Not only that, but even message sizes can be made to follow arbitrary patterns or no pattern at all. All this is meant to make the protocol very hard to fingerprint. Any node which is able to get a trusted introduction to the network also enjoys considerable protection against active interference from malicious third parties (e.g. man-in-the-middle attacks). All cryptography is handled through the Noise Protocol Framework, which is <a href="http://noiseprotocol.org/noise.html">exceptionally well-designed and well-documented</a>. The protocol runs over TCP – this means (among other things) that it can be used in conjunction with Tor.</p>

<p>The Theseus DHT is being developed as a component of the overall Theseus project. Since the DHT’s resistance to Sybil attacks increases as the network grows, the DHT is being developed as a stand-alone library. That way, it can also be used in any other application where a simple, secure distributed hash table is desired.</p>

<p>The Theseus DHT is designed to be very good at bootstrapping overlay networks, and to be easily extensible. For these reasons, building custom peer-to-peer applications on top of the Theseus DHT is trivial. A peer’s presence on the DHT does not by itself indicate which DHT-based application they’re using (unless they choose to disclose that). This is a nice privacy property to have. On top of that, the more users the DHT gets, the more resilient and reliable it is for everyone.</p>



<ul>
  <li><a href="#specification">Specification</a>
    <ul>
      <li><a href="#brief-summary">Brief Summary</a></li>
      <li><a href="#rpc-format">KRPC Format</a></li>
      <li><a href="#rpcs">RPCs</a>
        <ul>
          <li><a href="#find"><code>find</code></a></li>
          <li><a href="#get"><code>get</code></a></li>
          <li><a href="#put"><code>put</code></a></li>
          <li><a href="#info"><code>info</code></a></li>
          <li><a href="#hs_suggest"><code>hs_suggest</code></a></li>
          <li><a href="#hs_request"><code>hs_request</code></a></li>
        </ul>
      </li>
      <li><a href="#errors">Errors</a></li>
      <li><a href="#data-formats">Data Formats</a></li>
      <li><a href="#required-keys">Required Keys</a></li>
      <li><a href="#routing">Routing</a></li>
      <li><a href="#address-selection">Address Selection</a></li>
      <li><a href="#data-tags">Data Tags</a></li>
      <li><a href="#storage-durations">Storage Durations</a></li>
      <li><a href="#encryption">Encryption</a>
        <ul>
          <li><a href="#high-level-overview">High-Level Overview</a></li>
          <li><a href="#initial-handshake">Initial Handshake</a></li>
          <li><a href="#subsequent-handshakes">Subsequent Handshakes</a></li>
          <li><a href="#message-sizes">Message Sizes</a></li>
          <li><a href="#plaintext-format">Plaintext Format</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#brief-discussion">Brief Discussion</a>
    <ul>
      <li><a href="#peers-and-nodes">Peers and Nodes</a></li>
      <li><a href="#sybil-resistance">Sybil Resistance</a>
        <ul>
          <li><a href="#pending-improvements">Pending Improvements</a></li>
        </ul>
      </li>
      <li><a href="#mathematical-analysis">Mathematical Analysis</a></li>
      <li><a href="#using-tcp">Using TCP</a></li>
      <li><a href="#implementation-status">Implementation Status</a></li>
      <li><a href="#choice-of-ciphersuite">Choice of Ciphersuite</a></li>
      <li><a href="#modifying-the-protocol">Modifying the Protocol</a></li>
    </ul>
  </li>
  <li><a href="#contact-info">Contact Info</a></li>
  <li><a href="#further-reading">Further Reading</a></li>
</ul>



<p>Release date: 4/20/2018</p>

<p>Revision date: 10/8/2018</p>

<p>Revision number: 2</p>

<h2 id="brief-summary">Brief Summary</h2>

<p>The Theseus DHT protocol runs over TCP. All traffic is encrypted. The core of the protocol is a set of RPCs exchanged over a protocol called KRPC (which is also used in the Mainline DHT implementation of Kademlia).</p>

<p>Peers possess a set of 20-byte, pseudorandom “node IDs”. Peers keep routing tables which are maintained as in Kademlia; these track peers whose node IDs are close to any local node IDs by the XOR metric. Routing queries are supported via RPC. A peer may have as many node IDs as they like, though they’ll have to track data stored at any of them.</p>

<p>Node IDs are generated by running a timestamp and a random bytestring through a state-of-the-art memory-hard cryptographic hash function, Argon2id. The result is trimmed and used. The node ID is always distributed along with its preimage, so that remote peers may verify that the two match. The timestamp is used to enforce an expiration date on node IDs. These measures <a href="#sybil-resistance">form the core of the network’s Sybil resistance</a>.</p>

<p>Data is stored at addresses chosen from the same 160-bit space as node IDs. Any raw binary data may be submitted. <a href="#data-tags">‘Tags’</a> certifying some property about this data may be requested. Data is stored by sending it in an RPC message. Typically data is stored at the <code>k</code> closest peers to an address, where <code>k</code> is as in the Kademlia routing table. The value returned from this RPC will be an estimate of how long that data will be stored at the remote host. Note that it is not necessary for every one of these hosts to be honest: all we need is for one of them to be.</p>

<p>The storage duration for data depends on <a href="#storage-durations">many factors</a>.</p>

<p><em>All</em> protocol traffic is <a href="#encryption">indistinguishable from random noise</a>. Length-prefixing schemes are used on both protocol ciphertexts and plaintexts, and messages may be padded to any degree. This allows arbitrary message chunking, which is essential for <a href="#traffic-obfuscation">traffic obfuscation</a>.</p>

<h2 id="krpc-format">KRPC Format</h2>

<p>From <a href="http://www.bittorrent.org/beps/bep_0005.html">BEP-5</a>:</p>

<blockquote>
  <p>The KRPC protocol is a simple RPC mechanism consisting of bencoded dictionaries sent over UDP. A single query packet is sent out and a single packet is sent in response. There is no retry. There are three message types: query, response, and error.</p>
</blockquote>

<blockquote>
  <p>A KRPC message is a single dictionary with three keys common to every message and additional keys depending on the type of message. Every message has a key “t” with a string value representing a transaction ID. This transaction ID is generated by the querying node and is echoed in the response, so responses may be correlated with multiple queries to the same node. The transaction ID should be encoded as a short string of binary numbers, typically 2 characters are enough as they cover 2^16 outstanding queries. Every message also has a key “y” with a single character value describing the type of message. The value of the “y” key is one of “q” for query, “r” for response, or “e” for error.</p>
</blockquote>

<blockquote>
  <p>Queries, or KRPC message dictionaries with a “y” value of “q”, contain two additional keys; “q” and “a”. Key “q” has a string value containing the method name of the query. Key “a” has a dictionary value containing named arguments to the query.</p>
</blockquote>

<blockquote>
  <p>Responses, or KRPC message dictionaries with a “y” value of “r”, contain one additional key “r”. The value of “r” is a dictionary containing named return values. Response messages are sent upon successful completion of a query.</p>
</blockquote>

<blockquote>
  <p>Errors, or KRPC message dictionaries with a “y” value of “e”, contain one additional key “e”. The value of “e” is a list. The first element is an integer representing the error code. The second element is a string containing the error message. Errors are sent when a query cannot be fulfilled.</p>
</blockquote>

<p>We <a href="#errors">define a number of errors below</a>. We specify six KRPC queries: <code>find</code>, <code>get</code>, <code>put</code>, <code>info</code>, <code>hs_suggest</code>, and <code>hs_request</code>. Applications based on Theseus may add their own queries in addition to these.</p>

<h2 id="rpcs">RPCs</h2>

<h3 id="find">find</h3>

<p>This mirrors Kademlia’s <code>find_node</code> query. Takes a target DHT address as an argument. The queried node returns the closest nodes to that target in its routing table. The precise number of contacts may depend on the state of the queried peer’s routing table, but under ideal circumstances it should equal the routing table’s value of K.</p>

<p>Arguments: <code>{&#34;addr&#34;: &lt;20-byte address&gt;}</code></p>

<p>Response: <code>{&#34;nodes&#34;: &lt;compact node info&gt;}</code></p>

<h3 id="get">get</h3>

<p>Try to retrieve data from a node. Takes a DHT address as an argument. If the queried peer has no data to return, it instead offers routing info using the same return signature as <code>find_node</code>. If the address is omitted, all <code>addr: data</code> pairs stored at the node should be returned.</p>

<p>The <code>tags</code> optional argument, if provided, should map to a list of strings. Data without the specified tags listed will not be returned. If <code>tags</code> is omitted or left empty, then only untagged data will be returned.</p>

<p>The response format for untagged data is simply a list of data items, encoded as bytestrings.</p>

<p>For tagged data, it’s a list of (n+1)-tuples, where n is the number of tags requested. Tag values are returned alphabetized by tag name.</p>

<p>Arguments: <code>{&#34;addr&#34;: &lt;20-byte address&gt;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;, ...]}</code></p>

<p>Response:</p>

<p><code>&lt;datum&gt;</code> denotes <code>[&lt;bytes&gt;, &lt;tag&gt;, &lt;tag&gt;, ...]</code> if tags were requested, <code>&lt;bytes&gt;</code> otherwise.</p>

<ul>
  <li><code>addr</code> given: <code>{&#34;data&#34;: {&lt;20-byte address&gt;: [&lt;datum&gt;, &lt;datum&gt;, ...], ...}}</code></li>
  <li><code>addr</code> omitted: <code>{&#34;data&#34;: [&lt;datum&gt;, &lt;datum&gt;, ...]}</code></li>
  <li>No data at address: <code>{&#34;nodes&#34;: [&lt;compact node info&gt;, ...]}</code></li>
</ul>

<h3 id="put">put</h3>

<p>Store some data in the DHT. Takes an address as an argument. There are several optional arguments. The response should specify the amount of time, in seconds, for which the remote peer intends to store this data.</p>

<p>The <code>sybil</code> optional argument, if included, should map to 0 or 1 depending on whether the querying peer believes a Sybil attack targeting this address is taking place. This is essentially a hint to the queried peer that they should attempt to verify this claim and <a href="#sybil-resistance">take appropriate action</a>.</p>

<p>The <code>tags</code> optional argument should map to a list of desired tags for the submitted data. Only <a href="#data-tags">a couple tags are currently supported</a>. If unsupported tags are requested, the query should not fail: instead, the queried peer should just populate the corresponding value fields with empty bytestrings.</p>

<p>The <code>t</code> optional argument allows the querier to request a storage duration for their data. This may or may not be honored, at the query recipient’s discretion. The recommended behavior is to set data storage durations as the minimum of this key’s value (if given) and some internally-computed default duration.</p>

<p>Arguments: <code>{&#34;addr&#34;: &#34;&lt;20-byte address&gt;&#34;, &#34;data&#34;: &lt;bytes&gt;, &#34;tags&#34;: [&#34;tag1&#34;, &#34;tag2&#34;], &#34;sybil&#34;: &lt;bool&gt;}</code></p>

<p>Response: <code>{&#34;t&#34;: 99999}</code></p>

<h3 id="info">info</h3>

<p>Used for metadata exchange between peers. Both arguments are technically optional. If neither is provided, the query should be treated as a no-op and the response should be an empty dictionary.</p>

<p>The <code>info</code> optional argument allows the querier to advertise local info keys. This is primarily useful at the start of a connection or when a peer wants to announce a change in local info.</p>

<p>The <code>keys</code> optional argument, if included, should be a list of info keys the querying peer wants to request from the remote peer.</p>

<p>If <code>keys</code> is provided, the return value should include an <code>info</code> key which follows the same format as the <code>info</code> query argument.</p>

<p>Applications using the Theseus DHT should also feel free to add their own metadata keys, and are encouraged to use a uniform and distinctive prefix for these keys to avoid naming conflicts. For instance, Theseus-specific parameters like Bloom filters for search will be prefixed <code>theseus_</code>.</p>

<p>Arguments: <code>{&#34;info&#34;: {&#34;key1&#34;: &lt;data&gt;, &#34;key2&#34;: &lt;data&gt;, ...}, &#34;keys&#34;: [&#34;key3&#34;, &#34;key4&#34;, ...]}</code></p>

<p>Response: <code>{&#34;info&#34;: {&#34;key3&#34;: &lt;data&gt;, &#34;key4&#34;: &lt;data&gt;, ...}}</code></p>

<h3 id="hs_suggest">hs_suggest</h3>

<p>Messages of this type are purely informational and may be exchanged any number of times between handshakes. Their purpose is to communicate re-handshake parameters that the sending party would find acceptable.</p>

<p>The following parameters need to be established:</p>

<p>The <code>initiator</code> argument should map to 1 if the querier wishes to play the role of initiator in the new handshake, and 0 if they wish to be the responder.</p>

<p>The <code>handshake</code> argument specifies the full Noise protocol name for the new handshake to be performed. Rules for handshake parameters are outlined in <a href="#encryption">the section on encryption</a>.</p>

<p>If the Noise handshake pattern is <code>KNpsk0</code> or <code>KKpsk0</code>, then the <code>initiator_s</code> argument should be present and should map to a static public key to be used by the initiator.</p>

<p>If the Noise handshake pattern is <code>NKpsk0</code> or <code>KKpsk0</code>, then the <code>responder_s</code> argument should be present and should map to a static public key to be used by the responder.</p>

<p>Arguments: <code>{&#34;initiator&#34;: 1, &#34;handshake&#34;: &#34;Noise_KK_25519_ChaChaPoly_BLAKE2b&#34;, &#34;initiator_s&#34;: &#34;&lt;32-byte Curve25519 public key&gt;&#34;, &#34;responder_s&#34;: &#34;&lt;32-byte Curve25519 public key&gt;&#34;}</code></p>

<p>Response: <code>{}</code></p>

<h3 id="hs_request">hs_request</h3>

<p>Messages of this type specify concrete re-handshake parameters. If the remote peer finds these parameters unacceptable, it may reply with an error code. A non-error response indicates that the remote node accepts the re-handshake parameters.</p>

<p>After sending a non-error response, the responder should immediately enter the new handshake. Likewise for the receiver, who should immediately enter the handshake after receiving such a response.</p>

<p>The arguments <code>initiator</code>, <code>handshake</code>, <code>initiator_s</code>, and <code>responder_s</code> are all specified as in <code>hs_suggest</code>.</p>

<p>The argument <code>psk</code> should be included in both the query and response. In each case it should map to a bytestring of arbitrary contents. It is strongly suggested that these contents be a random string of length equal to the output size of the hash function specified in the <code>handshake</code> argument.</p>

<p>The values of both the query and response’s <code>psk</code> arguments are to be hashed using the <code>handshake</code> argument’s specified hash function. Their hashes are then to be XORed and the resulting value used as a PSK for the new handshake (applied via the psk0 Noise protocol modifier).</p>

<p>Arguments: <code>{&#34;initiator&#34;: 1, &#34;handshake&#34;: &#34;Noise_KK_25519_ChaChaPoly_BLAKE2b&#34;, &#34;initiator_s&#34;: &#34;&lt;32-byte Curve25519 public key&gt;&#34;, &#34;responder_s&#34;: &#34;&lt;32-byte Curve25519 public key&gt;&#34;, &#34;psk&#34;: &#34;&lt;bytestring&gt;&#34;}</code></p>

<p>Response: <code>{&#34;psk&#34;: &#34;&lt;bytestring&gt;&#34;}</code></p>

<h2 id="errors">Errors</h2>

<p>Errors at the KRPC level are prefixed 1xx. Errors at the Theseus DHT protocol level are prefixed 2xx. Errors of any other type are prefixed 3xx.</p>

<p>So far, the following error codes are defined:</p>

<ul>
  <li><code>1xx</code> level:
    <ul>
      <li><code>100: Generic KRPC error</code></li>
      <li><code>101: Invalid KRPC message</code></li>
      <li><code>102: Internal error (KRPC)</code></li>
      <li><code>103: Method not recognized</code></li>
    </ul>
  </li>
  <li><code>2xx</code> level:
    <ul>
      <li><code>200: Generic DHT protocol error</code></li>
      <li><code>201: Invalid DHT protocol message</code></li>
      <li><code>202: Internal error (DHT)</code></li>
      <li><code>203: Tag not recognized</code></li>
    </ul>
  </li>
  <li><code>3xx</code> level:
    <ul>
      <li><code>300: Generic error</code></li>
      <li><code>301: Rate-limiting active</code></li>
    </ul>
  </li>
</ul>

<h2 id="data-formats">Data Formats</h2>

<ul>
  <li><code>&lt;20-byte address&gt;</code>: A bytestring containing a DHT address in network byte order.</li>
  <li><code>&lt;bytes&gt;</code>: A bencoded bytestring.</li>
  <li><code>&lt;tag&gt;</code>: Same as <code>&lt;bytes&gt;</code>.</li>
  <li><code>&lt;contact info&gt;</code>: Info about a node and the peer providing it, as a bytestring. Formed by concatenating the following:
    <ul>
      <li>Node ID (20 bytes)</li>
      <li>ID preimage (10 bytes)</li>
      <li>IP address (4 bytes)</li>
      <li>Port (2 bytes)</li>
      <li>Curve25519 public ‘node key’ (32 bytes)</li>
    </ul>
  </li>
  <li><code>&lt;compact node info&gt;</code>: A bytestring containing the concatenation of any number of <code>&lt;contact info&gt;</code> entities.</li>
  <li><code>&lt;data&gt;</code>: Arbitrary native bencoded data structure.</li>
  <li><code>&lt;bool&gt;</code>: 0 or 1.</li>
  <li><code>&lt;32-byte Curve25519 public key&gt;</code>: As returned by <a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/x25519/#cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey"><code>cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey.public\_bytes()</code></a>.</li>
</ul>

<h2 id="required-keys">Required Keys</h2>

<p>Peers must provide at least the following info keys:</p>

<ul>
  <li><code>peer_key</code>: A Curve25519 public key used as a static key when responding to incoming Noise connections.</li>
  <li><code>ids</code>: A list of node IDs, with preimages.</li>
</ul>

<p>An <code>extensions</code> info key is suggested for DHT-integrated applications that want to advertise extra functionality to their peers. This key should map to a list of short bytestrings enumerating the extensions in use. The namespace for extension names is of course shared between all applications on the DHT, so anyone making use of this feature are strongly encouraged to names that are not likely to give rise to collisions. For instance, when Theseus proper is built upon the Theseus DHT, its peers will advertise <code>&#34;extensions&#34;: [&#34;theseus&#34;]</code>. Since the namespace for query names is also shared, it is encouraged, wherever reasonable, to prefix query names with a uniform extension name.</p>

<h2 id="routing">Routing</h2>

<p>A modified Kademlia-style routing table is used. This consists of “buckets” covering ranges whose union is the full address space, from 0 to 2<sup>160</sup>. Each bucket may contain up to <code>k</code> nodes.</p>

<p>When a new contact is discovered and inserted into the table, the bucket its ID falls into is identified. If this bucket has room, the node is inserted into the table. Otherwise, if one of the local peer’s own node IDs falls into the bucket range, then the bucket is split. This replaces it with two new, smaller buckets which bisect the original bucket’s range. The old bucket’s contacts are moved into the new buckets, and then the insert is reattempted.</p>

<p>The Kademlia paper suggests implementing this structure as a binary tree.</p>

<p>We’ll provisionally set <code>k=16</code> for now, pending full mathematical analysis. Peers are free to use higher values of k locally if they so desire.</p>

<p>Routing queries should return up to <code>k</code> of the closest</p>

<h2 id="address-selection">Address Selection</h2>

<p>The proper operation of the DHT relies on addresses being uniformly distributed and nodes being unable to choose their own addresses. To achieve this, we allow nodes to choose their <em>ID preimage</em>, and derive their actual node IDs from a cryptographic hash of this preimage. The node ID and ID preimage must always be transmitted together so remote peers can verify that they match.</p>

<p>The hash function used is Argon2id. This is a state-of-the-art memory-hard hash function usually used for hashing passwords. It is designed to make parallelized brute-force search of the input space as difficult as possible. The work parameters we will use are memlimit=2<sup>28</sup> and opslimit=3 (these are the values of the PyNaCl library constants MEMLIMIT_MODERATE and OPSLIMIT_MODERATE, respectively).</p>

<p>The preimage format is UNIX time in network byte order followed by 6 bytes from a CSPRNG.</p>

<p>The rationale behind this design is discussed <a href="https://wootfish.github.io/sohliloquies/2017/02/26/resisting-sybil-attacks-in-distributed_25.html">here</a>.</p>



<p>Tags are specified via a <code>tags</code> argument within individual RPCs. Nodes should implement all specified tags. If a node receives a request to populate tags it doesn’t recognize, the node should respond with error 203 <a href="#errors">as specified below</a>.</p>

<p>The only specified tags at this time are <code>ip</code> and <code>port</code>. They should be populated with the observed IP or observed port of a remote peer. Remember that if NAT is in use, it may cause these fields to take unexpected values.</p>

<h2 id="storage-durations">Storage Durations</h2>

<p>This is mostly left up to individual nodes to determine. In general, a node should try to hold on to any data it receives for as long as it can. Nodes should also try to report their intended storage durations as accurately as possible, ideally to within the second. It would make sense to implement a scheme where a node has a hard memory cap and it dynamically reduces storage times based on how close the node is to hitting this cap. A more detailed discussion of this topic is forthcoming.</p>

<h2 id="encryption">Encryption</h2>

<h3 id="high-level-overview">High-Level Overview</h3>

<p>Encryption of Theseus protocol messages is handled through the Noise Protocol Framework. The authoritative documentation for Noise can be found <a href="https://noiseprotocol.org/noise.html">here</a>, and the Python library we use is <a href="https://github.com/plizonczyk/noiseprotocol">here</a>.</p>

<p>All traffic is encrypted, and all encrypted messages are indistinguishable from random noise. Messages may be chunked to arbitrary sizes, and plaintexts may optionally be padded before encryption, further reducing fingerprintability.</p>

<h3 id="initial-handshake">Initial Handshake</h3>

<p>In order to avoid any fingerprintable protocol preamble, we will specify a default handshake pattern and ciphersuite: <code>Noise_NK_25519_ChaChaPoly_BLAKE2b</code>. The <code>NK</code> pattern here provides for an exchange of ephemeral public keys to establish an encrypted channel, and for authentication of the responder (using their node key). The initial ephemeral key must be encoded with <a href="https://elligator.cr.yp.to/">Elligator</a> to keep it from being trivially fingerprintable.</p>

<h3 id="subsequent-handshakes">Subsequent Handshakes</h3>

<p>After the initial handshake and establishment of the encrypted channel, additional handshakes may be performed. These are negotiated through RPC queries and responses. Once the peers agree on parameters like the handshake pattern and the public keys to be used for authentication, they may discard their current <code>CipherState</code> objects and, within the same TCP connection, start from scratch executing a new handshake. In order for the new handshake’s session to inherit the security properties of the old session, a PSK must be negotiated within the old session and included in the new handshake via the <code>psk0</code> modifier.</p>

<p>The handshake patterns which may be used are <code>NNpsk0</code>, <code>KNpsk0</code>, <code>NKpsk0</code>, <code>KKpsk0</code>.</p>

<p>The pattern may use any supported curve, cipher, or hash function. Wherever possible, the default choices of <code>Curve25519</code>, <code>ChaChaPoly</code>, and <code>BLAKE2b</code> should be favored. These defaults may change, though this will probably only happen if cryptographic weaknesses in any of them are discovered.</p>

<p>If for some reason two peers don’t want to use a PSK, i.e. if they want to restart their Noise session from scratch, then rather than re-hanshaking they should just close and re-open their connection.</p>

<h3 id="message-sizes">Message Sizes</h3>

<p>Every encrypted Theseus protocol message is preceded by an encrypted declaration of the protocol message’s size. Whenever a plaintext is ready to send, the plaintext bytestring’s length is calculated, encoded as a big-endian 32-bit integer, and encrypted, yielding a 20-byte ciphertext (4 message bytes + 16 AE tag bytes). This encrypted length announcement is sent, then the plaintext is encrypted and sent.</p>

<p>The process for receiving higher-level protocol messages is therefore essentially this:</p>

<ol>
  <li>Read bytes off the wire until we’ve received 20 bytes total.</li>
  <li>Decrypt these 20 bytes of ciphertext and treat the resulting 4-byte plaintext as an unsigned, big-endian 32-bit integer N.</li>
  <li>Read bytes off the wire until we’ve received N + 16 more bytes total.</li>
  <li>Decrypt these N + 16 bytes. The resulting N plaintext bytes are the protocol message.</li>
  <li>Repeat.</li>
</ol>

<p>This scheme allows the size of every ciphertext to be known in advance, which in turn allows arbitrary message chunking without risk of any ambiguity around message boundaries. Individual packets sent across the wire can therefore be arbitrarily sized, meaning the protocol can assume essentially any traffic pattern.</p>

<p>It’s probably worth noting that this scheme creates a theoretical limit on the size of Theseus protocol messages: 2<sup>32</sup> - 1 = 4,294,967,295 bytes. That’s 4 GiB, so any application running up against this limit has probably made some big mistakes along the way, to the point where the size limit is the least of their concerns.</p>

<p>In environments which aren’t likely to have 4 GiB of RAM to spare at any given moment, applications are encouraged to set smaller internal limits on message size – maybe 2<sup>20</sup> bytes or so. This suggestion, while much smaller, is still conservatively large as a sort of future-proofing. Theseus DHT protocol traffic will probably never even come close to this limit. Individual Noise protocol messages are capped at 65535=2<sup>16</sup>-1 bytes of ciphertext, so protocol messages exceeding 65535 - 16 = 65519 bytes of plaintext will of course need to be sent in chunks.</p>

<p>It goes without saying that in cases where performance is critical, message chunking will only slow down the transfer of data between two peers, increasing the time required to perform tasks like lookups or information retrieval. Thus this feature is likely only of interest to the extremely privacy-conscious. In some ways (though notably <em>not</em> where anonymity is concerned) the trade-off resembles that made by a person who decides to route all their web traffic through Tor. The critical thing here is that even if most users choose not to make this trade-off, <em>they still get to make the choice</em>. In stark contrast with most modern systems, here the decision of how far a user wants to go to protect their privacy is theirs to make.</p>

<h3 id="plaintext-format">Plaintext Format</h3>

<p>Each message contains an RPC embedded in a netstring. Anything after the end of the netstring is discarded. Thus any message may contain an arbitrary amount of padding, or no padding at all. Empty plaintexts with nothing but padding should be silently discarded and should not be considered errors.</p>



<p>Release date: 4/20/2018</p>

<p>Revision date: 5/15/2018</p>

<p>Revision number: 1</p>

<h2 id="peers-and-nodes">Peers and Nodes</h2>

<p>Just to clarify: Users on the DHT run an individual peer. This peer has a routing table and a number of node IDs. Each node ID represents a specific node being hosted by the peer. When a peer’s contact info is returned in a routing query, only the peer’s closest node’s ID is included.</p>

<h2 id="sybil-resistance">Sybil Resistance</h2>

<p>Carrying out a Sybil attack aimed at censoring or modifying data at a specific key requires the ability to deploy at least <code>k</code> nodes near a target address. This requires finding hash preimages for at least <code>k</code> node IDs which all share a given prefix. The best known strategy for finding these nodes given a strong hash function is brute-force search, which Argon2id is specifically designed to render extremely computationally expensive.</p>

<p>Putting expiration dates on node IDs prevents malicious peers from squatting indefinitely on significant node IDs once appropriate preimages for them are found.</p>

<p>Brute-force search can also be used to just deploy a tremendous number of nodes across the entire network, if the attacker just uses every hash they generate. These node IDs are guaranteed to be evenly distributed across the address space, allowing us to mathematically estimate the impact of an adversary based on how fast they can produce new node IDs.</p>

<p><a href="https://www.cl.cam.ac.uk/~lw525/publications/security.pdf">Real-World Sybil Attacks in BitTorrent Mainline DHT</a> offers a taxonomy in which the targeted attack described above is termed a “vertical Sybil attack” and the broader, generalized attack is termed a “horizontal Sybil attack”.</p>

<p>The size of the entire DHT peer network can be straightforwardly estimated. Prior research on this subject can be found here: <a href="https://www.cs.helsinki.fi/u/lxwang/publications/P2P2013_13.pdf">Measuring Large-Scale Distributed Systems: Case of BitTorrent Mainline DHT</a>. An accurate estimate of network size opens the door to all sorts of interesting <a href="#mathematical-analysis">mathematical analysis</a> on network properties.</p>

<p>Carrying out a horizontal Sybil attack requires a huge increase in the number of nodes in the network. Carrying out a vertical Sybil attack requires a huge increase in the node density at a specific address. Both of these produce easily-identified signatures which allow the network to identify and take steps to mitigate in-progress Sybil attacks.</p>

<p>Reasonable countermeasures against Sybil attacks would include increasing storage duration for all data, increasing the storage radius for data (e.g. dynamically scaling from storing data at the <code>k</code> closest nodes to an address to the <code>2k</code> closest nodes.</p>

<h2 id="ipv6">IPv6</h2>

<p>Currently all traffic takes place over IPv4. This is just because it makes my life simpler as a developer – for now. But there is a good reason to want IPv6 support: Most routers perform NAT on IPv4 traffic, whereas performing NAT on IPv6 is less common (which makes sense, since IPv4’s dependence on NAT is one of the problems IPv6 was designed to solve). This general lack of NAT means that IPv6 is much more attractive in a peer-to-peer context, since it allows hosts positioned behind routers (as virtually all personal computers are) to communicate without the need for complications like hole-punching. Thus IPv6 support is a major priority, albeit a deferred one (for now).</p>

<h3 id="pending-improvements">Pending Improvements</h3>

<p>Presently it is possible for attackers to “steal” observed IDs. It is not hard to imagine a situation where an attacker with significant network presence could listen for IDs close to an address it wants to attack, then start announcing the observed node ID as its own. The peers closest to the address should have already seen an advertisement from the peer who originally generated the ID, and should thus reject the attacker’s advertisement of the same ID (and in fact should probably blacklist the attacking peer). However, peers further away from the address could end up attributing this node ID to the attacker if they 1) have room in the relevant routing table bucket and 2) haven’t already seen the node ID.</p>

<p>This could result in routing lookups which pass through the further peers leading to the attacker. It is difficult to model precisely how serious of a problem this is, but it should be mitigated nevertheless. It is perhaps worth noting that the attack is trivial to detect (as a lookup would almost certainly end up seeing the stolen ID attributed to both sets of contact info) but that detecting the attacker is much more difficult. Thus detecting the attack is not sufficient to curb its effectiveness.</p>

<p>This problem has a solution, which is simple in principle but challenging to design properly. The core idea is to include a peer’s contact info in the calculation of their node IDs. This idea somewhat resembles a drafted extension to Kademlia: <a href="http://bittorrent.org/beps/bep_0042.html">BEP-42</a>.</p>

<p>I see at least four difficulties with this solution in our case.</p>

<p>First: I want to leave the door open to running Theseus peers as Tor onion services. Doing so properly is a nuanced problem. My goal here is to avoid adopting a solution exclusively geared towards peers who know and are comfortable disclosing their public IP. Such a solution would complicate the process of adding support for peers who have more extreme threat models. This is the main reason I’m describing a draft version of this solution here, rather than codifying it in the spec.</p>

<p>Second: I also want to leave the door open to IPv6. The reasons for this are discussed <a href="#ipv6">above</a>. The difficulties posed by making this scheme compatible with IPv6 addresses resemble those to do with supporting Tor onion services.</p>

<p>Third: These different identifiers – IPv4 address, IPv6 address, Tor onion service descriptors – contain differing amounts of entropy. My early writings on Sybil attack prevention discussed the idea of limiting node ID entropy as a way of bounding the worst-case impact of a Sybil attack. Lately I’ve soured on this idea somewhat, since if we’re dynamically detecting and compensating for Sybil attacks then we probably don’t need that bound after all and in fact we probably care more about address uniqueness than anything else. All the same, it is important from a theory perspective to carefully consider and account for the implications here regarding ID entropy.</p>

<p>Fourth: If we limit ourselves to the IPv4 case momentarily, we still have the problem that peers might not know their public IPs. This would for instance commonly be the case for anyone initiating a connecting from behind NAT. The solution is to allow peers to discover their own IP as reported by remote peers. The most straightforward and elegant way I see of adding this would be to do the following:</p>

<ul>
  <li>Add a <code>tags</code> key to <code>put</code> responses, keying a dictionary which maps tag names to the values assigned for them. This key would only be required if the <code>put</code> request also had a <code>tags</code> key. This would allow the querying peer to see what values the remote peer associates with the given tags.</li>
  <li>Add an optional ‘duration’ key (or perhaps some smaller name, like ‘ttl’) to <code>put</code> queries. This would specify a desired storage duration for the data the query is requesting storage of. The remote peer would store the data for whichever is smaller between their default storage duration and the requested duration. Crucially, requesting a storage time of 0 would prevent data from being stored in the first place, but would still cause the remote peer to return a <code>tags</code> key if the original query had one.</li>
</ul>

<p>We could also add a dedicated RPC, but that seems like an uglier solution to me. Both these modifications strike me as reasonable features to have regardless. It just so happens that together they also provide a mechanism for users to discover their own IPs without polluting the network or introducing new queries.</p>

<p>This subject will be addressed further after I have explored the topics of Tor integration and IPv6 support more thoroughly.</p>

<h2 id="mathematical-analysis">Mathematical Analysis</h2>

<p><code>TODO: Lay out in-depth mathematical analysis based on points outlined above. (I have lots of analog notes on this. A detailed write-up is forthcoming.)</code></p>

<h2 id="using-tcp">Using TCP</h2>

<p>The choice to use TCP rather than UDP is a significant one and is not taken lightly. The essential motivation is that it simplifies the cryptography. For an idea of why, see <a href="https://noiseprotocol.org/noise.html#out-of-order-transport-messages">here</a>. Note in particular that including plaintext nonce values with messages would break our requirement that <em>all</em> protocol traffic be indistinguishable from random noise. Persistent connections also provide a convenient abstraction within which to perform multiple consecutive handshakes.</p>

<p>One complication: A TCP connection to a specific port will originate from an arbitrary ‘ephemeral’ port on the part of the connector. UDP can operate this way but doesn’t have to, because it’s connectionless. Thus protocols like Kademlia which operate over UDP can and do use their packets’ source port to advertise the port they’re listening for messages on – a trick we can’t use if our connections have to originate from ephemeral ports. Compensating for this requires provisions at the protocol level for communicating the port we’re listening for connections on. This is why <code>listen_port</code> is a required datum in the <code>info</code> query.</p>

<p>A big issue here that we’ll want to spend some time looking hard at once the reference implementation is otherwise mature and stable: NAT traversal. We may be able to work out a scheme for reachable nodes to perform some sort of hole punching to help NATed hosts to reach each other.</p>

<p>If hole punching doesn’t pan out, another interesting possibility (which was touched on briefly in some of the Theseus blog posts back on Sohliloquies) would be to see if the network can support an onion routing overlay, and if so, whether it’d be viable for NATed hosts to make themselves available as “hidden services” served from other, publicly accessible hosts. This would also have other benefits for users willing or needing to trade performance for privacy – but that’s a story for another day.</p>

<h2 id="implementation-status">Implementation Status</h2>

<p>The Twisted implementation is coming along well but is not yet complete. Some outstanding TODOs (see also <a href="https://riskmusings.substack.com/theseus.dht/todo.html">TODO.md</a>:</p>

<ul>
  <li>The NoiseWrapper protocol wrapper works, but implementing <code>hs_request</code> will require extending its functionality somewhat.</li>
  <li>Speaking of Noise, traffic obfuscation during the Noise handshake is not nearly as strong as once the handshake is complete. Still working on a fix for this.</li>
  <li>We also need to set up intermittent automatic routing lookups to keep the local routing table fresh.</li>
  <li>We do not yet have Elligator support. We’ll either need to get this added into the Noise library or else shim it in at the protocol level.</li>
  <li>We have some unit tests, but the code coverage stats have a lot of room to improve.</li>
</ul>

<p>Proposed Roadmap (subject to change):</p>

<ol>
  <li><del>Finish writing up mathematical analysis of network dynamics and Sybil thresholds.</del> (formal analysis complete, writeup pending)</li>
  <li><del>Add ID check logic for node IDs received from remote peers.</del></li>
  <li><del>Add logic for inserting remote node IDs into the local routing table (tho maybe only after their ID checks pass)</del>
    <ul>
      <li>One thing to be mindful of here: If we wait for ID checks to succeed before inserting into the routing table, this leaves a decently sized window where multiple peers could try to claim the same node ID.</li>
      <li>In situations like this, it is <em>critical</em> that precedence goes to whoever claimed the ID first.</li>
      <li>The reasons why will be discussed in the formal analysis of the network.</li>
    </ul>
  </li>
  <li><del>Implement <code>find</code> RPC.</del></li>
  <li><del>At this point the routing functionality will be complete! Seems like a good time to make a big push on writing unit tests.</del></li>
  <li><del>Implement node lookup logic.</del></li>
  <li>Implement data store.
    <ul>
      <li>At this point, full end-to-end demos of DHT storage and retrieval (under non-adversarial conditions) are possible.</li>
    </ul>
  </li>
  <li>Implement network size estimation.</li>
  <li>Add ‘paranoid/non-paranoid’ option to lookup logic, and have non-paranoid lookups automatically become paranoid if they detect anomalous peer density at the target address.</li>
  <li>Implement Sybil attack. Run live attacks on a test peer swarm, and collect data on how effective the defenses are. Validate that the data agrees with the results obtained from formalisms and simulations.</li>
  <li>Triage and implement other outstanding functionality like custom message sizing, handshake renegotiation, and Elligator support.</li>
</ol>

<p>Some good starting points for anyone interested in helping out:</p>

<ul>
  <li>If you’re into cryptography, maybe look into what it would take to get Elligator support. It might make sense for this to end up being a pull request to the Noise library we use, rather than something that gets taken care of in the Noise wrapper here.</li>
  <li>Hacking AddrLookups into a network size estimation tool would be a fun project. Bit more of a research angle on this one, since there have been a few differing methodologies proposed.</li>
  <li>More unit tests are always needed. Code coverage hasn’t been over 90% in ages and it’d be good to get it back up.
    <ul>
      <li>In particular, end-to-end tests of peer interactions through mocked network interfaces would be <em>super</em> valuable.</li>
    </ul>
  </li>
</ul>

<h2 id="choice-of-ciphersuite">Choice of Ciphersuite</h2>

<p>The default algorithm choices specified above were selected to provide as conservative and robust of a default configuration as possible. The only arguable exception is Curve25519, which, while still a fairly conservative choice, is still less so than Curve448. The deciding factor in this case was that the crypto libraries we’re using provide good implementations of Curve25519, whereas Curve448 support comes from some native Python which is pretty much guaranteed not to be as well hardened against say side-channel or timing attacks. I’m totally willing to revisit this if we can get nice Curve448 bindings, maybe via OpenSSL or something.</p>

<p>Argon2id was chosen over my earlier favored algorithm, bcrypt, due to its state-of-the-art design and memory-hardness. Bcrypt is a great piece of work which has stood the test of time exceptionally well, but by nature of being CPU-hard rather than memory-hard it is less costly to mount massively parallel attacks on bcrypt using e.g. FPGAs. The memory overhead required for background verification of Argon2id hashes on a user’s machine is also likely to be less impactful on performance than the CPU overhead required to verify bcrypt hashes of comparable hardness.</p>

<p>BLAKE2b is favored over SHA512 because it is faster, based on a more modern and robust construction (no length-extension attacks!), and doesn’t suffer from any ominous reduced-round preimage resistance breaks like the SHA-2 family has. SHA512 still seems secure enough for the time being, of course, but if I had to bet on which algorithm I think’ll be looking better 5 or 10 years from now, I’d bet on BLAKE2b.</p>

<h2 id="modifying-the-protocol">Modifying the Protocol</h2>

<p>For now, let’s just use GitHub issues for discussing potential protocol modifications. We’ll probably want to come up with something better down the road, but we can worry about that then.</p>

<p>If you want to develop a protocol extension that doesn’t impact core functionality, you don’t need any sign-off from me or anyone to do that. Still, I’d like to hear from you! Drop me a line.</p>



<p>If you want to get in touch with me (Eli), you can reach me a couple different ways:</p>
<ul>
  <li><a href="#https://twitter.com/elisohl">Twitter</a>: my DMs are open.</li>
  <li>Email: my first and last name, with no punctuation, at gmail.</li>
  <li>Signal: Send a Twitter DM or email asking for my personal number. Sorry, but I don’t have a dedicated phone number to share publicly.</li>
  <li>Github: I try to keep a close eye on this repo, so opening an issue or pull request would also work to get my attention.</li>
</ul>

<p>All else being equal, reaching out over Twitter DMs or here on Github are probably the most reliable ways of reaching me.</p>



<p>The blog posts listed here are not necessarily up to date, but they reflect my thinking on these topics across the last couple years, and may be helpful to people looking for additional information or context for any of the ideas discussed above.</p>

<p>This is only a small selection of blog posts I’ve written on aspects of Theseus’s design. If you’re interested, most of the other posts can be found in links at the tops of the ones listed here.</p>

<p>On encryption:</p>
<ul>
  <li><a href="https://wootfish.github.io/sohliloquies/2017/06/11/transient-public-keys-for-resisting.html">Resisting Man-in-the-Middle Attacks in P2P Networks</a></li>
  <li><a href="https://wootfish.github.io/sohliloquies/2017/06/10/message-encryption-in-theseus.html">Message Encryption in Theseus</a></li>
</ul>

<p>On Sybil attacks:</p>
<ul>
  <li><a href="https://wootfish.github.io/sohliloquies/2017/02/26/resisting-sybil-attacks-in-distributed_25.html">Resisting Sybil Attacks in Distributed Hash Tables</a></li>
</ul>

<p>For posterity, the (obsolete!) version 0.1 protocol spec:</p>
<ul>
  <li><a href="https://wootfish.github.io/sohliloquies/2017/04/21/theseus-protocol-v01-overview.html">Theseus Protocol v0.1 Overview</a></li>
</ul>


      
    </section></div>
  </body>
</html>
