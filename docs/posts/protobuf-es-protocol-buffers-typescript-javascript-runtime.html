<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buf.build/blog/protobuf-es-the-protocol-buffers-typescript-javascript-runtime-we-all-deserve">Original</a>
    <h1>Protobuf-ES: Protocol Buffers TypeScript/JavaScript runtime</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><p>Today we&#39;re excited to announce the release of <a href="https://github.com/bufbuild/protobuf-es">Protobuf-ES</a>, an implementation
of Protocol Buffers for TypeScript and JavaScript with full support for the
<a href="https://262.ecma-international.org/13.0/">ECMAScript standard</a>.</p><p><strong>Protobuf-ES</strong> was built with JavaScript developers in mind.  Its intent is to not only fix the areas that are sorely
inadequate in current implementations, but to also include important features that are currently lacking such as:</p><ul><li><a href="#ecmascript-module-support">ECMAScript module support</a></li><li><a href="#usage-of-standard-javascript-apis">Usage of standard JavaScript APIs</a></li><li><a href="#descriptor-and-reflection-support">Descriptor and Reflection support</a></li><li><a href="#idiomatic-generated-code">Idiomatic generated code</a></li><li><a href="#first-class-typescript-support">First-class TypeScript support</a></li><li><a href="#compatibility">Conformance test compatibility</a></li></ul><p>JavaScript is everywhere.  It is used in basically every web application and is now becoming almost
ubiquitous in backend, mobile, and even desktop applications.  It has
been the <a href="https://octoverse.github.com/#top-languages-over-the-years">top language on Github</a>
for the last 8 years.  Atwood&#39;s Law is more relevant than ever:  any application that <em>can</em> be written in JavaScript,
<em>will</em> eventually be written in JavaScript.</p><p>Currently, the predominant technologies to facilitate this growth are <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>
and <a href="https://www.json.org/json-en.html">JSON</a>.  While these technologies may seem easy to use, over time
they can present a host of problems.  They require heavy maintenance, offer no protection against breaking changes,
and tend to waste countless engineering hours with manual implementation of data structures — all difficulties that
belie their perceived simplicity.</p><p>At Buf, we believe there is a simple solution to the problems that REST and JSON present and that solution is
Protocol Buffers.  Protocol Buffers (or Protobuf for short) provide a schema-driven approach to services.  So rather than
freeform APIs with varying standards, inconsistent naming conventions, and no ability to handle breaking changes, Protobuf
provides a pre-defined schema for your APIs.  This has numerous benefits, such as:</p><ul><li>Enhancing developer experience as well as developer productivity through capabilities such as auto-generated boilerplate code.</li><li>Opening up the door to tooling, which can provide abilities such as autocomplete and go-to-definition when coding your APIs.</li><li>Support for breaking changes, allowing clients and servers alike to make changes without fear of unknown breakages.</li><li>Consistency across API boundaries enforced by linters and formatters.</li></ul><p>But, for this to come to fruition, Protobuf needs to be just as easy to use from the frontend
as it is from the backend. Browser-to-server communication with Protobuf needs to be seamless, not just server-to-server.</p><p>The problem, though, is that browser-to-server communication is <em>not</em> seamless.  The current state of Protobuf in JavaScript
is <em>not</em> easy to use.  The constant churn, lack of attention and support, and poor standards aren&#39;t really allowing
this particular area of Protocol Buffers to flourish.  With all the importance and dominance of JavaScript in the
application space, it would be remiss of us to promote Protocol Buffers as a panacea until these problems are addressed.</p><p>That&#39;s why we created <strong>Protobuf-ES</strong>.  We believe it is the solid foundation that help move the industry forward.</p><h2 id="features-and-improvements">Features and Improvements<a href="#features-and-improvements" aria-label="features and improvements permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p><strong>Protobuf-ES</strong> addresses various issues that exist today in the Protocol Buffers for JavaScript ecosystem.  At the
same time, it adds necessary features that will help make Protobuf the obvious choice when developing JavaScript applications.</p><h3 id="ecmascript-module-support">ECMAScript module support<a href="#ecmascript-module-support" aria-label="ecmascript module support permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p><strong>Protobuf-ES</strong> provides full support for ECMAScript module syntax.  Aside from adhering to widely-accepted
specifications, this also provides the benefit of promoting tree-shaking, which is essentially dead-code elimination.
Tree-shaking is made possible due to the static nature of ES import syntax.  This results in
<a href="https://github.com/bufbuild/protobuf-es/tree/main/packages/protobuf-bench">much smaller bundle sizes</a> when using
<strong>Protobuf-ES</strong>.</p><h3 id="usage-of-standard-javascript-apis">Usage of standard JavaScript APIs<a href="#usage-of-standard-javascript-apis" aria-label="usage of standard javascript apis permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p><strong>Protobuf-ES</strong> makes use of standard APIs and objects, such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder">TextEncoder</a> and
<a href="https://tc39.es/ecma262/#sec-typedarray-objects">Typed Arrays</a>.  It doesn&#39;t rely on esoteric, internal
APIs under the hood.  Instead, it utilizes code that the community is familiar with, not code that is homegrown and optimized for certain environments.</p><p>The benefits of the above can be illustrated by a real world example we encountered.  For the
<a href="https://buf.build/product/bsr/">Buf Schema Registry</a>, we use <a href="https://github.com/facebook/react">React</a> as our web framework and <a href="https://connect.build/">Connect</a> as our RPC layer.  Prior to <strong>Protobuf-ES</strong>, we used the <a href="https://github.com/protocolbuffers/protobuf-javascript">official Protobuf code generator for JavaScript</a>.</p><p>As we were debugging a performance issue one day, we took a look at our bundle (the JavaScript files that make up our web application).
In doing so, we noticed that the Protobuf implementation and the generated code dominated the bundle size with a whopping <strong>62%</strong> share:</p><p><span>
      <a href="https://buf.build/static/0ff0c8e3925f135bb43519b775fd2d4e/5c5b6/pre-migration.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="pre-migration" title="pre-migration" src="https://buf.build/static/0ff0c8e3925f135bb43519b775fd2d4e/d0c0e/pre-migration.png" srcset="/static/0ff0c8e3925f135bb43519b775fd2d4e/652c7/pre-migration.png 179w,/static/0ff0c8e3925f135bb43519b775fd2d4e/39185/pre-migration.png 358w,/static/0ff0c8e3925f135bb43519b775fd2d4e/d0c0e/pre-migration.png 715w,/static/0ff0c8e3925f135bb43519b775fd2d4e/e24fe/pre-migration.png 1073w,/static/0ff0c8e3925f135bb43519b775fd2d4e/5c5b6/pre-migration.png 1265w" sizes="(max-width: 715px) 100vw, 715px" loading="lazy" decoding="async"/>
  </a>
    </span></p><p>That is a fantastically bad ratio for a technology used everywhere in mobile and web applications -- two areas highly
concerned with speed and bandwidth.  More specifically, this affects our users because large bundle sizes mean that
our customer-facing application takes longer to load. <a href="https://www.thinkwithgoogle.com/marketing-strategies/app-and-mobile/mobile-page-speed-new-industry-benchmarks/">Research suggests</a>
that the probability of a mobile site visitor bouncing increases by <strong>123%</strong> if
the page load time goes from one second to 10 seconds.</p><p>After some digging, we realized the reason for the large bundle sizes is largely attributed to two things:</p><ul><li>The Protobuf runtime library <a href="https://github.com/protocolbuffers/protobuf/issues/4274">does not use the standard module system</a>,
which hampers tree-shaking by <a href="https://webpack.js.org/guides/tree-shaking/">modern bundlers</a>.</li><li>The generated code relies on Google&#39;s <a href="https://developers.google.com/closure/library">Closure Library</a>
instead of built-in APIs.</li></ul><p>Compare that with the bundle allocation after we migrated our stack to <strong>Protobuf-ES</strong>.  If we generate JavaScript and
TypeScript declaration files (the default), not only does the overall bundle size drop by more than half, the
generated code and runtime libraries shrink to a much-more-reasonable <strong>15%</strong>.</p><p><span>
      <a href="https://buf.build/static/2f06f35d1fa812867e51748a0ea74def/60a1a/post-migration-with-dts.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="post-migration-with-dts" title="post-migration-with-dts" src="https://buf.build/static/2f06f35d1fa812867e51748a0ea74def/d0c0e/post-migration-with-dts.png" srcset="/static/2f06f35d1fa812867e51748a0ea74def/652c7/post-migration-with-dts.png 179w,/static/2f06f35d1fa812867e51748a0ea74def/39185/post-migration-with-dts.png 358w,/static/2f06f35d1fa812867e51748a0ea74def/d0c0e/post-migration-with-dts.png 715w,/static/2f06f35d1fa812867e51748a0ea74def/e24fe/post-migration-with-dts.png 1073w,/static/2f06f35d1fa812867e51748a0ea74def/60a1a/post-migration-with-dts.png 1321w" sizes="(max-width: 715px) 100vw, 715px" loading="lazy" decoding="async"/>
  </a>
    </span></p><h3 id="descriptor-and-reflection-support">Descriptor and Reflection support<a href="#descriptor-and-reflection-support" aria-label="descriptor and reflection support permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p><strong>Protobuf-ES</strong> offers a reduced set of descriptors that provide just enough information for tasks such as
<a href="https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#registries">creating types at run time from a set of descriptors</a> produced by a Protobuf compiler.</p><p>During development of <a href="https://buf.build/blog/buf-studio">Buf Studio</a>, we wanted to serialize and deserialize messages,
but only have an <a href="https://docs.buf.build/reference/images">image</a> available
at run time, and no generated code.  This type of approach requires Protobuf descriptors and reflection.  Some
Protobuf implementations provide facilities for this situation such as <a href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/DynamicMessage">Java</a>
and <a href="https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb">Go</a>,
but the JavaScript implementation does not. In fact, it <a href="https://github.com/protocolbuffers/protobuf-javascript/issues/99">does not support descriptors at all</a>.  There is also <a href="https://github.com/protocolbuffers/protobuf/issues/1711">no support for reflection</a>, and
<a href="https://github.com/protocolbuffers/protobuf-javascript/issues/89">no way to get package and type metadata</a>.</p><h3 id="idiomatic-generated-code">Idiomatic generated code<a href="#idiomatic-generated-code" aria-label="idiomatic generated code permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p><strong>Protobuf-ES</strong> generates idiomatic code with
<a href="https://github.com/bufbuild/protobuf-es/blob/main/docs/runtime_api.md#message-class">initializers and plain properties</a>,
adopting the best features from the community generators. This means no more clunky getters and setters.   You can now
use things like the spread operator and make use of the same JavaScript semantics you&#39;ve grown used to.</p><p>  For example, given a Protobuf file such as:</p><pre><code>syntax=&#34;proto3&#34;;
package docs;

message Example {
  string foo = 1;
  bool bar = 2;
  Example baz = 3;
  repeated string names = 4;
  map&lt;string, string&gt; statuses = 5;
}
</code></pre><p>  you can use direct property access:</p><pre><code>msg.foo = &#34;Hello&#34;;
msg.bar = true;
msg.baz.foo = &#34;World&#34;;
</code></pre><p>  and you won&#39;t get confusing methods like <code>getNamesList</code>, <code>setNamesList</code>, <code>getStatusMap</code>, and <code>clearStatusMap</code>.  You
won&#39;t have to access nested messages by doing things like <code>msg.getBaz().getNamesList()</code>.  You will work with the same
familiar syntax:</p><pre><code>msg.names = [];

const names = foo.names;

msg.statuses = {
   &#34;bar&#34;: &#34;created&#34;
};
</code></pre><p>  and you can initialize your objects conveniently using the <code>new</code> operator or passing an initializer object to constructors:</p><pre><code>// Using new
const message = new Example();

// Using an object in the constructor
new Example({
  foo: &#34;Hello&#34;,
  bar: true,
  baz: {  // you can simply pass an initializer object for this message field
      foo: &#34;world&#34;,
  },
 });
</code></pre><p>All of this might seem like a small issue at face value, but over time and as your codebase grows, all of these deviations
add up and can become a real hassle.  For example, compare this with some of the problems in current JavaScript Protobuf
code generators:</p><p><strong>Atypical Getters and Setters</strong></p><p>The generated JavaScript code creates <code>get</code> and <code>set</code> methods for all your properties but it does so in a manner that
JavaScript developers will <strong>not</strong> find intuitive.   The access methods
<a href="https://github.com/protocolbuffers/protobuf-javascript/issues/93">do not follow ES6 class semantics</a>, <code>repeated</code> field
accessors are <a href="https://github.com/protocolbuffers/protobuf-javascript/issues/42">curiously named with <code>List</code> appended to them</a>,
<a href="https://github.com/protocolbuffers/protobuf/issues/4356"><code>map</code> fields have no setters generated</a>, <a href="https://github.com/protocolbuffers/protobuf-javascript/issues/17">CamelCase generation
is inconsistent</a>, and
<a href="https://github.com/protocolbuffers/protobuf-javascript/issues/79">accessing inner messages is cumbersome</a>.</p><p><strong>Missing Initializers</strong></p><p>Initializing values in your generated objects can be a chore, especially if you have large messages.  You <a href="https://github.com/protocolbuffers/protobuf/issues/5783">cannot pass
objects to constructors</a>, so creating messages can be confusing
and error-prone.  Further, even when helpful enhancements are added such as method chaining, they are
<a href="https://github.com/protocolbuffers/protobuf/issues/6860#issuecomment-568600937">scarcely documented or mentioned</a>.</p><p><strong>Confusing Methods</strong></p><p>The <code>toObject</code> method is an exposed method that, on the surface, seems like it converts your generated code to a JSON object.
However, it was <a href="https://github.com/protocolbuffers/protobuf-javascript/issues/95#issuecomment-1128003168">never really intended for that</a>
and to make matters worse, it comes with numerous problems as evidenced by these issues on both the
<a href="https://github.com/protocolbuffers/protobuf/issues?q=2056+6357">Protocol Buffers repo</a>
and the new <a href="https://github.com/protocolbuffers/protobuf-javascript/issues?q=11+14+30+33+37+96">Protobuf JavaScript repo</a>.</p><p>In sum, the generated code is unlikely to mesh well with the typical
paradigms used in the business and presentation logic of a JavaScript application.
This hurts developer productivity.</p><h3 id="first-class-typescript-support">First-Class TypeScript support<a href="#first-class-typescript-support" aria-label="first class typescript support permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>As you might suspect, <a href="https://www.typescriptlang.org/">TypeScript</a> is an excellent match for Protocol Buffers.  It
provides beneficial type-safety to the otherwise dynamically-typed language.  As a result, <strong>Protobuf-ES</strong> supports
TypeScript as a first-class citizen right alongside vanilla JavaScript.  You have the option to generate TypeScript
files as well as TypeScript declaration files (<code>.d.ts</code>).</p><p>Compare this with the current code
generator, which <a href="https://github.com/protocolbuffers/protobuf/pull/9412/#issuecomment-1013300071">does not support it</a>.  Further, the Protobuf
JavaScript repo has <a href="https://github.com/protocolbuffers/protobuf-javascript/issues?q=69+98">no concrete plans to provide support</a>.
That means you need to find a 3rd party plugin to generate type declaration files
(for example <a href="https://www.npmjs.com/package/ts-protoc-gen"><code>ts-protoc-gen</code></a>).  In addition to this being yet
another tool and yet another configuration, it always leaves a lingering doubt that the types you now rely on are really in
sync with the code generator.</p><p>In addition to the above, there is a whole list of other issues in the current ecosystem that <strong>Protobuf-ES</strong> solves or that we
pledge to improve, such as:</p><ul><li><a href="https://github.com/protocolbuffers/protobuf/issues/2556">confusing plugin options</a></li><li><a href="https://github.com/protocolbuffers/protobuf/issues/8389">bad IDE integration</a></li><li><a href="https://github.com/protocolbuffers/protobuf/issues/4271">global scope pollution</a></li><li><a href="https://github.com/protocolbuffers/protobuf/issues/5162">no wrapper unboxing</a></li><li>the <a href="https://github.com/protocolbuffers/protobuf-javascript/issues?q=28+95">lack of JSON support</a></li><li>the problematic representation of <a href="https://github.com/protocolbuffers/protobuf/issues?q=4338+5674+3666+7244+4895">64-bit integral types</a></li><li><a href="https://github.com/protocolbuffers/protobuf/pull/9874">poor communication and cooperation with the community</a></li></ul><h2 id="compatibility">Compatibility<a href="#compatibility" aria-label="compatibility permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>So, why should you trust this library?  We&#39;ve already talked about what sets it apart from the rest, but what about compatibility
with other Protocol Buffer implementations?  We&#39;re glad you asked.  We ensure compatibility with other implementations through the <a href="https://github.com/bufbuild/protobuf-es/tree/main/packages/protobuf-conformance">conformance test suite</a> which runs Google&#39;s
<a href="https://github.com/protocolbuffers/protobuf/tree/main/conformance">conformance tests</a> to guarantee the completeness and
correctness of our generated code.</p><h2 id="alternatives">Alternatives<a href="#alternatives" aria-label="alternatives permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>Granted, some amazing alternatives have sprung up from the community, all of which we evaluated before deciding to write our own.  However, none of them checks all the boxes for us:</p><table><thead><tr><th>Feature / Generator</th><th><a href="https://github.com/protobufjs/protobuf.js">protobuf.js</a></th><th><a href="https://github.com/stephenh/ts-proto">ts-proto</a></th><th><a href="https://github.com/timostamm/protobuf-ts">protobuf-ts</a></th><th><a href="https://github.com/thesayyn/protoc-gen-ts">protoc-gen-ts</a></th><th><a href="https://github.com/bufbuild/protobuf-es">Protobuf-ES</a></th></tr></thead><tbody><tr><td><a href="https://docs.buf.build/reference/images#plugins">Standard plugin</a></td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/protocolbuffers/protobuf/tree/main/conformance#protocol-buffers---googles-data-interchange-format">Conformance tests</a></td><td>❌</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>Fully tree-shakeable</td><td>❌</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>Actively maintained</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Vanilla JavaScript support</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>Fast code generation</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td></tr></tbody></table><p><a href="https://github.com/stephenh/ts-proto">ts-proto</a> and <a href="https://github.com/timostamm/protobuf-ts">protobuf-ts</a>
are close, but they try to solve code generation for Protobuf types <em>and</em> code
generation for Remote Procedure Calls (RPC) at once, adding options like
<a href="https://github.com/thesayyn/protoc-gen-ts/pull/102"><code>--ts_opt=target=web</code></a>, or
<a href="https://github.com/stephenh/ts-proto/blob/main/NESTJS.markdown#supported-options"><code>--ts_proto_opt=nestJs=true</code></a>.</p><p>This approach works out to some degree, but only until the number of options
becomes detrimental to the developer experience. Ultimately, this approach leads
to an isolated, tightly-coupled solution that tries to do everything at once.  This
makes for a frustrating developer experience.  <strong>Protobuf-ES</strong> improves on this
through a plugin ecosystem that allows decoupling of the base type generator
and the RPC generators.  This plugin framework allows you to easily write your own JavaScript plugins, providing the ability to generate
TypeScript, JavaScript, and declaration files.  It also provides the option to solely generate TypeScript files and
transpile the rest.  Check out the <a href="https://github.com/bufbuild/protobuf-es/blob/main/docs/writing_plugins.md">plugin docs</a> for more information.</p><h3 id="whats-next">What&#39;s next?<a href="#whats-next" aria-label="whats next permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h3><p>As mentioned above, <strong>Protobuf-ES</strong> is a foundational piece, but one which we intend to build soundly upon.  We take
breaking changes and developer relations very seriously, so rest assured this will be our
focus for years to come.</p><p>We have many enhancements in store, so if there&#39;s something you&#39;d like to see, reach out on our
<a href="https://join.slack.com/t/bufbuild/shared_invite/zt-f5k547ki-VDs_iC4TblNCu7ubhRD17w">Slack</a> or on <a href="https://github.com/bufbuild/protobuf-es/issues">Github</a>.</p><p>After all, doesn&#39;t JavaScript demand a well-defined, well-maintained solution?</p></div></div></div></div></div></div>
  </body>
</html>
