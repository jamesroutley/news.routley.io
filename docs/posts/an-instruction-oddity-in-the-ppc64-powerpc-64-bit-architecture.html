<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/PowerPCInstructionOddity">Original</a>
    <h1>An instruction oddity in the ppc64 (PowerPC 64-bit) architecture</h1>
    
    <div id="readability-page-1" class="page"><div><h2>An instruction oddity in the ppc64 (PowerPC 64-bit) architecture</h2>

	<p><small>January 20, 2023</small></p>
</div><div><p>Over on the Fediverse, <a href="https://mastodon.social/@cks/109717006467114169">I reported my discovery of a ppc64 oddity</a>:</p>

<blockquote><p>TIL that the ppc64 (PowerPC 64-bit) architecture overloads &#39;or
r1,r1,r1&#39; (and the same using all r6 or r2) to change the (hardware)
priority of your thread. This came up in a Go code generation issue,
and Raymond Chen mentioned it in passing in 2018.</p>

<p><a href="https://github.com/golang/go/issues/57741">&lt;Go issue 57741&gt;</a> </p>
</blockquote>

<p>(<a href="https://mastodon.social/@cks/109717211018601975">Also</a>.)</p>

<p>As Raymond Chen notes, &#39;or rd, ra, ra&#39; has the effect of &#39;move ra
to rd&#39;. Moving a register to itself is a NOP, but several Power
versions (the Go code&#39;s comment says Power8, 9, and 10) overload
this particular version of a NOP (and some others) to signal that
the priority of your hardware thread should be changed by the CPU;
in the specific case of &#39;or r1, r1, r1&#39; it drops you to low priority.
That leaves us with the mystery of why such an instruction would
be used by a compiler, instead of the official NOP (per Raymond
Chen, this is &#39;or r0, r0, 0&#39;).</p>

<p>The answer is kind of interesting and shows how intricate things can get
in modern code. Go, like a lot of modern languages, wants to support
stack tracebacks from right within its compiled code, without the aid
of an external debugger. In order to do that, the Go runtime needs to
be able to unwind the stack. Unwinding the stack is a very intricate
thing on modern CPUs, and you can&#39;t necessarily do it past arbitrary
code. Go has a special annotation for &#39;you can&#39;t unwind past here&#39;,
which is automatically applied when the Go toolchain detects that some
code (including assembly code) is manipulating the stack pointer in a
way that it doesn&#39;t understand:</p>

<blockquote><p>SPWRITE indicates a function that writes an arbitrary value to SP (any
write other than adding or subtracting a constant amount).</p>
</blockquote>

<p>As covered in <a href="https://go-review.googlesource.com/c/go/+/425396/2/src/runtime/asm_ppc64x.s">the specific ppc64 diff in the change that introduced
this issue</a>,
Go wanted to artificially mark a particular runtime function this
way (see <a href="https://go-review.googlesource.com/c/go/+/425396">CL 425396</a>
and <a href="https://github.com/golang/go/issues/54332">Go issue #54332</a>
for more). To do this it needed to touch the stack pointer in a
harmless way, which would trigger the toolchain&#39;s weirdness detector.
On ppc64, the stack pointer is in r1. So the obvious and natural
thing to do is to move r1 to itself, which encodes as &#39;or r1, r1,
r1&#39;, and which then triggers this special architectural behavior
of lowering the priority of that hardware thread. Oops.</p>

<p>(<a href="https://go-review.googlesource.com/c/go/+/461597/4/src/runtime/asm_ppc64x.s">The fix changes this to another operation that is apparently
harmless due to how the Go ABI works on ppc64</a>.
Based on <a href="https://go.googlesource.com/go/+/refs/heads/master/src/cmd/compile/abi-internal.md#ppc64-architecture">the ppc64 architecture section of the Go internal ABI</a>,
Go seems to define r0 as always zero.)</p>

<p>I don&#39;t know why PowerPC decided to make r1 (the stack pointer) the
register used to signal lowering hardware thread priority, instead
of some other register. It&#39;s possible r1 was chosen specifically
because very few people were expected to write an or-NOP using the
stack pointer instead of some other register.</p>

<p>(The whole issue is a useful reminder that modern architectures can
have some odd corners and weird cases.)</p>
</div></div>
  </body>
</html>
