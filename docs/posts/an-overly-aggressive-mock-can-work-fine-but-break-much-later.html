<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nedbatchelder.com/blog/202511/why_your_mock_breaks_later.html">Original</a>
    <h1>An overly aggressive mock can work fine, but break much later</h1>
    
    <div id="readability-page-1" class="page"><div><article id="e20251116T075548"><header><p><a href="https://nedbatchelder.com/blog/archive/date1116.html">Sunday 16</a> <a href="https://nedbatchelder.com/blog/archive/year2025.html#month202511">November 2025</a></p><p>An overly aggressive mock can work fine, but then break much later. Why?</p></header><p>In <a href="https://nedbatchelder.com/blog/201908/why_your_mock_doesnt_work.html">Why your mock doesn’t work</a> I explained this rule of
mocking:</p><blockquote><p>Mock where the object is used, <strong>not</strong> where it’s
defined.</p></blockquote><p>That blog post explained why that rule was important: often a mock doesn’t
work at all if you do it wrong.  But in some cases, the mock will work even if
you don’t follow this rule, and then it can break much later. Why?</p><p>Let’s say you have code like this:</p><blockquote><pre></pre></blockquote><p>You write a simple test:</p><blockquote><pre><div><p><span>def</span><span> </span><span>test_add_two_settings</span><span>():</span></p></div></pre></blockquote><p>As the comment in the test points out, the test will only pass if you create
the correct settings.json file in your home directory. This is bad: you don’t
want to require finicky environments for your tests to pass.</p><p>The thing we want to avoid is opening a real file, so it’s a natural impulse
to mock out <code>open()</code>:</p><blockquote><pre></pre></blockquote><p>Nice, the test works without needing to create a file in our home
directory!</p><p>One day your test suite <a rel="external noopener" href="https://github.com/coveragepy/coveragepy/issues/2083">fails with an error</a> like:</p><blockquote><pre></pre></blockquote><p>What happened!? Coverage.py code runs during your tests, invoked by the
Python interpreter.  The mock in the test changed the builtin <code>open</code>, so
any use of it anywhere during the test is affected. In some cases, coverage.py
needs to read your source code to record the execution properly.  When that
happens, coverage.py unknowingly uses the mocked <code>open</code>, and bad things
happen.</p><p>When you use a mock, patch it where it’s used, not where it’s defined.  In
this case, the patch would be:</p><blockquote><pre><div><p><span>@patch</span><span>(</span><span>&#34;myproduct.user.open&#34;</span><span>)</span></p></div></pre></blockquote><p>With a mock like this, the coverage.py code would be unaffected.</p><p>Keep in mind: it’s not just coverage.py that could trip over this mock. There
could be other libraries used by your code, or you might use <code>open</code>
yourself in another part of your product.  Mocking the definition means
<em>anything</em> using the object will be affected.  Your intent is to only
mock in one place, so target that place.</p><p>I decided to add some code to coverage.py to defend against this kind of
over-mocking.  There is <a rel="external noopener" href="https://github.com/search?type=code&amp;q=patch+builtins.open+language%3APython+path%3A%22test%22">a lot of over-mocking out
there</a>, and this problem only shows up in coverage.py with Python 3.14. It’s
not happening to many people yet, but it will happen more and more as people
start testing with 3.14. I didn’t want to have to answer this question many
times, and I didn’t want to force people to fix their mocks.</p><p>From a certain perspective, I shouldn’t have to do this. They are in the
wrong, not me.  But this will reduce the overall friction in the universe. And
<a rel="external noopener" href="https://github.com/coveragepy/coveragepy/commit/961fc5b4a1c40bec6e0d1908b6fb43b84a5d8c6b#diff-7a060a25115604cc3bc99075e1366afb84075101dcb0aef22d80f8f67c0c4593R30">the fix</a> was really simple:</p><blockquote><pre><p><span>open</span> <span>=</span> <span>open</span><br/></p></pre></blockquote><p>This is a top-level statement in my module, so it runs when the module is
imported, long before any tests are run.  The assignment to <code>open</code> will
create a global in my module, using the current value of <code>open</code>, the one
found in the builtins. This saves the original <code>open</code> for use in my module
later, isolated from how builtins might be changed later.</p><p>This is an ad-hoc fix: it only defends one builtin. Mocking other builtins
could still break coverage.py.  But <code>open</code> is a common one, and this will
keep things working smoothly for those cases. And there’s precedent: I’ve
already been using a more involved technique to <a rel="external noopener" href="https://github.com/coveragepy/coveragepy/commit/3b8f4a0b86f8796f1e7925b9c6593a9d5198b437">defend
against mocking of the <code>os</code> module</a> for ten years.</p><p>No blog post about mocking is complete without encouraging a number of other
best practices, some of which could get you out of the mocking mess:</p><ul><li>Use <code>autospec=True</code> to make your mocks strictly behave like the
original object: see <a href="https://nedbatchelder.com/blog/202202/why_your_mock_still_doesnt_work.html">Why your mock still doesn’t work</a>.</li><li>Make assertions about how your mock was called to be sure everything is
connected up properly.</li><li>Use verified fakes instead of auto-generated mocks: <a rel="external noopener" href="https://pythonspeed.com/articles/verified-fakes/">Fast
tests for slow services: why you should use verified fakes</a>.</li><li>Separate your code so that computing functions like our
<code>add_two_settings</code> don’t also do I/O. This makes the functions easier to
test in the first place. Take a look at <a rel="external noopener" href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">Function Core,
Imperative Shell</a>.</li><li>Dependency injection lets you explicitly pass test-specific objects where
they are needed instead of relying on implicit access to a mock.</li></ul></article></div></div>
  </body>
</html>
