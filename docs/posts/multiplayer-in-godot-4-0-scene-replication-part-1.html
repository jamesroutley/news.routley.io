<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://godotengine.org/article/multiplayer-changes-godot-4-0-report-4">Original</a>
    <h1>Multiplayer in Godot 4.0: Scene Replication (Part 1)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    <div>
            <figure>
        <img src="https://godotengine.org/storage/app/uploads/public/61a/27f/881/61a27f8816a4e934017559.png" title="Godot Replication" width="400" height="400" alt="Godot Replication "/>
        <figcaption>
          <strong>Godot Replication</strong>
          <span></span>
        </figcaption>
      </figure>

      

      <p>Howdy Godotters!</p>
<p>It&#39;s finally time for the long-awaited post about the new multiplayer replication system that is being developed for Godot 4.0.
Below, we will introduce the concepts around which it was designed, the currently implemented prototype, and planned changes to make it more powerful and user-friendly.</p>
<h2>Design goals</h2>
<p>Making multiplayer games has historically been a complex task, requiring ad-hoc optimizations and game-specific solutions. Still, two main concepts are almost ubiquitous in multiplayer games: some form of <strong>messaging</strong>, and some form of <strong>state replication</strong> (synchronization and reconciliation).</p>
<p>While Godot does provide a system for messaging (i.e. <abbr title="Remote Procedure Calls">RPC</abbr>), it does not provide a common system for replication.</p>
<p>In this sense, we had quite a few <a href="https://chat.godotengine.org/">#networking meetings</a> in August 2021 to design a replication API that could be used for the common cases, while being extensible via plugins or custom code.</p>
<p>The design goals that emerged for such an API where:</p>
<ul>
<li>Provide an out-of-the-box solution for scene state replication across the network.</li>
<li>Allow for (almost) no-code prototyping.</li>
<li>Be extensible with game-specific behaviours (custom reconciliation, interpolation, interest management, etc).</li>
<li>Allow ex-post (incremental) optimizations of network code.</li>
<li>Be easy to use for game developers, of course :)</li>
</ul>
<h3>Glossary</h3>
<ul>
<li><code>State</code>: The informations (properties) about an Object relevant to the multiplayer game.</li>
<li><code>Spawn</code>: Creating, or requesting remotely to create a new Object.</li>
<li><code>Sync</code>: Updating, or requesting remotely to update the state of an Object.</li>
</ul>
<h3>Security</h3>
<p>When dealing with computer networks, it&#39;s important to understand the security implication of transfering data across machines.
For instance, Godot does not allow <a href="https://docs.godotengine.org/en/stable/classes/class_multiplayerapi.html#class-multiplayerapi-property-allow-object-decoding">decoding objects</a> by default, since they could carry scripts with them or force the receiving end to execute specific code during initialization. This is a security vulnerability, as arbitrary code execution of this kind would allow for servers to access or manipulate any file on the client&#39;s filesystem that the game process has access to.</p>
<p>In a similar way, the replication API will let you specify which scenes can be spawned by a remote peer. Tthe final implementation will also allow for fine-grained control over which node can be spawned at each specific path.</p>
<h3>Optimizations</h3>
<p>Optimizations, and bandwidth optimizations in particular, are crucial to an effective networking protocol.</p>
<ul>
<li>Synchronizing multiple properties is very useful in the prototyping stage, but bad in terms of potential optimizations.</li>
<li>A very quick way to optimize the network code later on is to replicate a single property that returns a tightly packed representation of the object state based on your game&#39;s unique characteristics.
When done properly, this is also going to be the most optimized state possible that no tool can produce for you.</li>
<li>The replication API will still try to squeeze the state size as much as possible with the information in its hands.</li>
</ul>
<h2>Initial prototype</h2>
<p>With this in mind, an initial prototype was developed and has been merged in Godot&#39;s <code>master</code> branch.
Please note that <strong>the final implementation will be substantially different</strong> in terms of exposed low-level API. Nonetheless, it will retain the same concepts and functionalities while adding more as we gather more feedback (jump to the next section for more information).</p>
<p>The initial prototype requires some wiring via GDScript, but <strong>the final version will use visual configuration nodes</strong> for better usability.</p>
<p>Without further ado, let&#39;s create our player:</p>
<pre><code># player.gd
extends CharacterBody2D

# The player name.
var player_name: String

func _ready():
    print(&#34;Player spawned. Name: %s, position: %s&#34; % [player_name, position])

func _notification(what):
    if what == NOTIFICATION_PREDELETE:
        print(&#34;Player deleted. Name: %s&#34; % player_name)</code></pre>
<p>Now let&#39;s create our main scene, which configures the replication, and starts the networking:</p>
<pre><code># main.gd
extends Node

# The player scene (which we want to configure for replication).
const Player = preload(&#34;res://player.tscn&#34;)

func _ready():
    # Get the UID of the scene we want replicated.
    var id = ResourceLoader.get_resource_uid(Player.resource_path)
    # Configure the scene to be controlled by the server,
    # and which properties will be replicated during spawn.
    multiplayer.replicator.spawn_config(id, MultiplayerReplicator.REPLICATION_MODE_SERVER,
        [&amp;&#34;player_name&#34;, &amp;&#34;position&#34;])
    # Configure the variables to be synchronized periodically
    # (every 16 milliseconds = 62.5 Hz).
    multiplayer.replicator.sync_config(id, 16, [&amp;&#34;position&#34;])

    # Start the server if Godot is passed the &#34;--server&#34; argument,
    # and start a client otherwise.
    if &#34;--server&#34; in OS.get_cmdline_args():
        start_network(true)
    else:
        start_network(false)

func start_network(server: bool):
    var peer = ENetMultiplayerPeer.new()
    if server:
        # Listen to peer connections, and create new player for them
        multiplayer.peer_connected.connect(self.create_player)
        # Listen to peer disconnections, and destroy their players
        multiplayer.peer_disconnected.connect(self.destroy_player)
        peer.create_server(4242)
    else:
        peer.create_client(&#34;localhost&#34;, 4242)

    multiplayer.set_multiplayer_peer(peer)

func create_player(id):
    # Instantiate a new player for this client.
    var p = Player.instantiate()
    # Sets the player name (only sent during spawn).
    p.player_name = &#34;Player %d&#34; % id
    # Set a random position (sent on every replicator update).
    p.position = Vector2(randi() % 500, randi() % 500)
    # Add it to the &#34;Players&#34; node.
    # We give the new Node a name for easy retrieval, but that&#39;s not necessary.
    p.name = str(id)
    $Players.add_child(p)

func destroy_player(id):
    # Delete this peer&#39;s node.
    $Players.get_node(str(id)).queue_free()</code></pre>
<p>With this configuration, each new client that connects will cause the server to instantiate a new player for it.</p>
<p>Note that the client code doesn&#39;t &#34;instantiates&#34; the scene explicitly. However, since the scene is marked for replication, when the server adds the scene to the SceneTree, it automatically sends that information remotely. Each connected client will then instantiate the scene automatically, adding it to the proper path and setting the values configured via <code>multiplayer.replicator.spawn_config</code> (<code>position</code> and <code>player_name</code> in this example).</p>
<p>Additinally, the server automatically keeps track of replicated nodes to send them to newly connected peers, i.e. supporting clients that join mid-game.</p>
<p>The RPC system will also work appropriately for the nodes spawned this way, so you can easily integrate state synchronization with messaging.</p>
<p>At the specified interval (16 milliseconds in the above example), the properties passed to <code>multiplayer.replicator.sync_config</code> will also be synchronized from the server to the client.</p>
<p>You can decide to synchronize multiple properties via <code>sync_config</code>, but keep in mind that will result in a larger sync state. If the sync state becomes too large, this can potentially introduce latency or packet loss.</p>
<pre><code>multiplayer.replicator.sync_config(id, 16, [&amp;&#34;position&#34;, &amp;&#34;health&#34;, &amp;&#34;mana&#34;])</code></pre>
<p>In those cases, a good way to optimize the state is to use a dedicated &#34;sync_state&#34; property with your own optimized representation:</p>
<pre><code>multiplayer.replicator.sync_config(id, 16, [&amp;&#34;sync_state&#34;])</code></pre>
<p>And then in your player script:</p>
<pre><code># player.gd

# In this example, health and mana must be set between 0 and 255
# to be encoded as 8-bit integers.
var health := 100
var mana := 100

# Optimized state representation using bit-packing.
var sync_state:
    get:
        var buf = PackedByteArray()
        buf.resize(6)
        buf.encode_half(0, position.x)
        buf.encode_half(2, position.y)
        buf.encode_u8(4, health)
        buf.encode_u8(5, mana)
        return buf

    set(value):
        assert(typeof(value) == TYPE_RAW_ARRAY and value.size() == 6,
            &#34;Invalid `sync_state` array type or size (must be TYPE_RAW_ARRAY of size 6).&#34;)
        position = Vector2(value.decode_half(0), value.decode_half(2))
        health = value.decode_u8(4)
        mana = value.decode_u8(5)</code></pre>
<p>In the same way, properties of child nodes could be set, and custom interpolation techniques implemented.</p>
<h2>Future work</h2>
<p>As explained, this is an early prototype. A <a href="https://github.com/godotengine/godot-proposals/issues/3459">more complete proposal</a> has been created to gather feedback as we work towards a final implementation in the coming months. This includes <strong>visual configuration</strong>, child node properties support, fine grained spawn control and more.</p>
<p>The coming months will be prety dense of announcements. As always, stay tuned for more!</p>
<h2>References</h2>
<ul>
<li><a href="https://github.com/godotengine/godot/pull/51097">Spawn/Despawn pull request</a></li>
<li><a href="https://github.com/godotengine/godot/pull/51534">Spawn/Despawn initial state pull request</a></li>
<li><a href="https://github.com/godotengine/godot/pull/51788">State synchronization pull request</a></li>
<li><a href="https://github.com/godotengine/godot-proposals/issues/3459">Last replication proposal</a> (ongoing).</li>
</ul>
    </div>
  </article>
</div></div>
  </body>
</html>
