<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.exhypothesi.com/clocks-and-causality/">Original</a>
    <h1>Clocks and Causality â€“ Ordering Events in Distributed Systems</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!--kg-card-begin: html--><p><a href="https://twitter.com/intent/tweet?text=Logical+Clocks&amp;url=https%3A%2F%2Fwww.exhypothesi.com%2Fclocks-and-causality%2F&amp;hashtags=exhypothesi&amp;via=neuroboom&amp;ref=exhypothesi.com">Share this article</a></p><!--kg-card-end: html--><h2 id="introduction">Introduction</h2><p>System events could be arranged in an order based on the <em>time</em> they occurred. Clocks keep time and produce timestamps. Conventional clocks (such as time-of-day clocks) use a common reference to learn time. That reference could be internal hardware or a common service that serves time using protocols like NTP. However, because of clock drifts and/or assumptions around network time delays, timestamps from conventional clocks are not always mutually comparable, and therefore events cannot be reliably ordered using timestamps from conventional clocks.</p><p>A logical clock is a custom clock that is designed to produce timestamps that can be reliably compared. (We will see shortly that timestamps from logical clocks take a different form than the timestamps from time-of-day clocks). If multiple nodes in a distributed system can rely on a centralized logical clock, then most issues discussed in this article become irrelevant. However, a centralized clock by definition is neither fault-tolerant nor can offer performance beyond a limit. In this article, therefore, we are primarily interested in <em>distributed</em> logical clocks spread across multiple nodes.</p><p>For a distributed logical clock to function, we expect each of the participating nodes to have its own clock that cooperates with clocks on other nodes in order to produce the next timestamp. When dealing with distributed logical clocks, we are primarily interested in the time of occurrence of system events on any node so that we could order such events across nodes according to their timestamps.</p><!--kg-card-begin: html--><p>Events cannot obviously consider the effects of future events. However, because events may occur faster than the notification of such events between nodes, events may be unaware of some <a href="#future-and-past" aria-describedby="footnote-label" id="future-and-past-ref">past</a> events. Events that occur without the knowledge of each other are called concurrent events. Events, at best, can be ordered according to their originating timestamps in <a href="#real-time" aria-describedby="footnote-label" id="real-time-ref">real-time</a> only when there are no concurrent <a href="#events" aria-describedby="footnote-label" id="events-ref">events</a>. That is, none of the logical clocks discussed in this article help with ordering events in real-time in the presence of concurrent events. That said, not all clocks can order events even in the absence of concurrent events. This article discusses why such clocks are still useful.</p><!--kg-card-end: html--><p>The article will also demonstrate that in non-real-time (i.e., after the fact), we can arrange events in a total order using some clocks. <em>Total order</em> means if each of the nodes have a collection of events, then all nodes can individually arrive at the same order of events. Total order respects happened-before (and causality) relationships. The Event Ordering section at the end of this article discusses total order in detail.</p><h2 id="clock-designs">Clock Designs</h2><p>The various logical clock designs we will study in this article essentially implement a variation of the following solution:</p><p>Each timestamp produced by a logical clock consists of two components:</p><ol><li>an id for the current event, and</li><li>the ids of some or all events the node is aware of thus far (aka history).</li></ol><p>Tracking all historical events in a timestamp is space consuming. Richness in the timestamp therefore needs to be purchased with space or time complexity. And different designs make different choices in this area. However, a common compaction scheme used by different clock designs is to track history with the use of <em>numbers</em> for event ids. Under this compaction scheme, an event with timestamp [ 5 ] not only represents that the event id is the number 5, but that the node generating that event has knowledge of the existence of (some) event [ 4 ] (because there could be multiple [ 4 ] events) and possibly all events prior to and equal to [ 4 ], depending on the clock.</p><p>Note that causality and history (i.e., happened-before events) are related concepts, but not identical. If the knowledge from event A is <em>used</em> to produce event B, then A <em>caused</em> B. If B merely happened before C, but event C <em>did not use</em> the knowledge from event B, then B and C are not causally related, just temporally so. Most applications, for simplicity, use temporal relationship as a proxy for causality.</p><!--kg-card-begin: html--><p>Let us look at various logical <a href="#guide" aria-describedby="footnote-label" id="guide-ref">clock designs</a>.</p><!--kg-card-end: html--><h3 id="lamport-clock">Lamport Clock</h3><!--kg-card-begin: html--><p>Timestamps produced by a Lamport clock take the least amount of space, O(1) in terms of the number of <a href="#node" aria-describedby="footnote-label" id="node-ref">nodes</a> in the <a href="#complexity" aria-describedby="footnote-label" id="complexity-ref">system</a>, compared to other clock designs. A Lamport timestamp captures the event id and some history of events the node is aware of at the time the event is generated, all using a single unique number. When a node generated event id [ 5 ], the node claims to have knowledge of some event that is numbered [ 4 ] and no knowledge of any other event that is numbered [ 5 ] or above.</p><!--kg-card-end: html--><!--kg-card-begin: html--><p>Lamport timestamps do not capture which node generated the event. Therefore, there might be events with the same timestamps from different nodes circulating in the system. Consequently, looking at the timestamps of two events, say [ 4 ] and [ 5 ], one cannot answer whether event [ 5 ] is aware of that particular event [ 4 ] or a different event [ 4 ]. Overall, given that event [ 4 ] has knowledge of some event [ 3 ], and [ 3 ] of some [ 2 ], and so on, it is understood that event [ 5 ] has knowledge of the <a href="#knowledge" aria-describedby="footnote-label" id="knowledge-ref">existence</a> of some events [ 4 ] through [ 1 ].</p><!--kg-card-end: html--><p>A Lamport clock can be implemented as follows:</p><!--kg-card-begin: html--><ol>
    <li>Timestamps are sequential numbers associated with events.</li>
    <li>Each node maintains its own sequence starting with number 0.</li>
<li>When an event is generated, the node increments its number by one and associates that number with the event.</li>
<li>When a node learns an event from another node, the node ensures its number to be the highest of its own number and the event number it learned from the other node.
<ul><li>In this article, we consider a learning event as any other event, and have the node increment its number by one.</li>
    <li>Some applications do not timestamp learning events.</li></ul></li></ol><!--kg-card-end: html--><p>Overall, Lamport timestamps are strictly increasing numbers in any given node, and at least monotonically increasing across nodes. See Figure 1 for an illustration. Arrows are pointed at effects by causes.</p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/1.png" alt="" loading="lazy" width="2000" height="912" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/1.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/1.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/1.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/1.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 1: Lamport Clock in action across three nodes. Dots are events. Numbers in square brackets are Lamport timestamps.</figcaption></figure><p>Why are Lamport timestamps useful? Lamport timestamps can be used to arrange events in a historical (i.e., happened-before) order <em>after the fact</em>. Specifically,</p><ol><li>Events across nodes can be ordered in a way that also honors local order: Because each timestamp produced by a node is a strictly increasing number, when events are ordered based on timestamps, all local events of a node will retain their order of generation even when events from other nodes are in the mix.</li><li>Events can be arranged based on history (aka happened-before): While there are duplicate event timestamps across nodes, when events are arranged in an increasing order based on timestamps, an event with the knowledge of another event will always follow it in the order (because the event id reflects a higher number than the ids of the events it is aware of).</li><li>Events can be causal ordered: Causes are by definition known events; therefore, causal ordering follows from 2 above.</li></ol><p>Lamport clocks have three deficiencies:</p><ul><li>A total order of events is not deterministically possible with Lamport timestamps. Events have duplicate timestamps, e.g., multiple events with id [ 4 ], and those events cannot be ordered in any deterministic way.</li><li>While events can be arranged in a way that honors historical and causal ordering, you can only do so after the fact, but not in real-time. A node may know about or have generated event [ 5 ] first and then learned about event [ 4 ] some time later. As a result, if order preservation while processing non-concurrent events in real-time is important, Lamport clock is not adequate.</li><li>Relatedly, it is not evident from Lamport timestamps if an event definitely occurred after another event or if the two events are concurrent. For example, in Figure 1, it is not clear if event [ 5 ] is an effect of event [ 4 ] produced on node B or event [ 4 ] produced on node C.</li></ul><h3 id="lamport-origin-clock">Lamport Origin Clock</h3><!--kg-card-begin: html--><p>A variant of Lamport Clock, hereafter referred to as Lamport Origin <a href="#naming" aria-describedby="footnote-label" id="naming-ref">Clock</a>, can produce a timestamp that is a doublet consisting of [node id, Lamport timestamp]. Lamport origin timestamp can be used to arrange events after the fact in a predictable order using originating node id as the second sort property. This removes the first deficiency of Lamport clocks discussed above, but it does not remove the other deficiencies of not knowing the order in real-time even for non-concurrent events.</p><!--kg-card-end: html--><p>Figure 2 is an update of Figure 1 with origin information included in the timestamp.<br/></p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/2.png" alt="" loading="lazy" width="2000" height="904" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/2.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/2.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/2.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/2.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 2: Lamport Origin Clock in action across three nodes. Dots are events. The data in square brackets are Lamport origin timestamps.</figcaption></figure><p>Lamport origin timestamp can also be used as a unique identifier for events because the Â combination of node id and Lamport timestamp is unique across events from any node. The space complexity is still O(1).</p><p>We will look at one last variation of Lamport clock after we review vector clocks.</p><h3 id="vector-clock-and-dotted-vector-clock">Vector Clock and Dotted Vector Clock</h3><p>Timestamps produced by a vector clock take the most amount of space compared to other well-known clock designs. The space complexity is O(n). A vector timestamp tracks the id of a node and the last known event id from that node. Therefore, if there are n nodes in the system, the timestamp would be an n-tuple.</p><p>The number compaction scheme applies here too, but in a slightly richer way than in Lamport clocks. Here, if node A knows of event [ 5 ] from node B, then node A knows of the existence of events [ 1 ] through [ 5 ] from node B.</p><p>Let us learn the characteristics of a vector timestamp from an example. See Figure 3 for a companion illustration.</p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/3.png" alt="" loading="lazy" width="2000" height="903" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/3.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/3.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/3.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/3.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 3: Vector Clock in action across three nodes. Dots are events. The data in square brackets are vector timestamps.</figcaption></figure><p>If say <em>[3, 4, 0]</em> is a vector timestamp associated with an event on node B, then the timestamp is conveying:</p><ul><li>There are overall three nodes in this distributed system because the timestamp is a triplet.</li><li>This event is the fourth event generated by node B, as indicated by the number 4 in the triplet.</li><li>At the time when node B generated this event, it is aware of the existence of the first three events generated by node A and none of the events from node C.</li><li>It precedes events like [4, 5, 2] because event [4, 5, 2] would have been aware of the existence of all events implied in [3, 4, 0].</li><li>It is concurrent with event [0, 2, 2] because event [ 2 ] on node C happened without the knowledge of event [ 4 ] (or [ 3 ]) on node B (and vice versa). See comparison algorithm below.</li></ul><p>Vector timestamps can be compared as follows. Compare each entry from one n-tuple timestamp with the corresponding entry in another n-tuple timestamp.</p><ul><li>If all entries are identical, then the timestamps are the same, e.g., [3, 4, 0] against [3, 4, 0].</li><li>If some entries are less or equal, and some entries are greater, the timestamps are concurrent, e.g., [<strong>3</strong>, <strong>4</strong>, 0] and [0, 2, <strong>2</strong>]. The greater entries are in bold.</li><li>If one or more entries are less and none are greater, the timestamp with lower entry values precedes the other timestamp, e.g., [3, 4, 0] precedes [4, 5, 2].</li></ul><p>The comparison time complexity is O(n) as there are n entries to compare before deciding the ordinality of two events. Comparisons can be reduced to O(1) if the last event is separately tracked in the vector timestamp. Since vector timestamps keep track of the history of events from every node (via compaction), timestamp T1 will have been issued before another timestamp T2 if the last event of T1 is part of T2. No other checks need to be made to determine the order. Generally speaking, the algorithm is to check if the last event of one timestamp is part of another. If neither, then the timestamps are concurrent.</p><p><em>Dotted Vector Clock</em> takes advantage of this optimization. The term <em>dot</em> refers to the last occurring event. Dotted vector clock tracks the latest event as a dot (in bold) separately, like so: [3, 3, 0]<strong>[B, 4]</strong>. Here, event [ 4 ] on node B is the latest event. In a conventional vector timestamp format [3, 3, 0][B, 4] would be equivalent to [3, 4, 0].</p><p>Given two dotted timestamps, [3, 3, 0][B, 4] and [3, 5, 2][A, 4], it is easy to observe [B, 4] dot from the first timestamp is encapsulated within the second timestamp by checking against the entry for the B node in the tuple, which is 5, and therefore infer that the first timestamp precedes the second timestamp without any further checks. It might be necessary to check the dot from one timestamp with the dot from another timestamp, in case the timestamps are the same.</p><p>Figure 4 is an update of Figure 3 with vector timestamps represented in dotted form.</p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/4.png" alt="" loading="lazy" width="2000" height="901" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/4.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/4.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/4.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/4.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 4: Dotted Vector Clock in action across three nodes. Dots are events. The data within square brackets associated with each event are vector timestamps in dotted form.</figcaption></figure><p>A vector clock can be implemented as follows:</p><!--kg-card-begin: html--><ol><li>Each node maintains its own sequence starting with number 0.</li>
<li>Nodes never mix sequence numbers from other nodes, unlike Lamport timestamps. Nodes maintain sequence numbers associated with each node in that nodeâ€™s portion of the n-tuple.</li>
<li>When an event is generated, the node increments its number by one and associates that number with the event.</li>
<li>When an event from another node is observed, the node keeps track of the latest event from that node in the portion of the n-tuple that is designated for that node. That is, there is one entry per node.
<ul><li>In this article, we consider a learning event as any other event, and have the learning node increment its own number by one.</li></ul></li>
<li>In the case of a dotted vector clock, instead of performing the steps in 3 or 4, the last event either generated by the node or as observed from another node is captured in a dot. A dot is a doublet [node id, number]. node id is the generator of the last event. number is the latest sequence observed from that node. The previous dot is enrolled into the n-tuple by incrementing the number associated with the node indicated in the dot.</li></ol><!--kg-card-end: html--><p>Why are vector timestamps useful? Since they carry a superset of information compared to Lamport origin timestamps, they have the same advantages as Lamport origin timestamps and more:</p><ol><li>Events across nodes can be ordered in a way that also honors local order. Events can also be ordered based on history (and therefore implicitly based on causality). Ordering of non-concurrent events can happen in real-time, unlike the two Lamport clock variants we discussed above, because knowledge of the existence of preceding events is encoded in a vector timestamp.</li><li>Events can be uniquely identified across nodes.</li><li>Vector timestamps can be used to designate an event to have succeeded multiple concurrent events; essentially, a merge of different branches of concurrent events stemming from another event. For example, the event [3, 5, 2] on node B could be considered the effect of two concurrent events: [3, 4, 0] on node B and [0, 2, 2] on node C. Encoding this information is not possible with Lamport clock variants because they use a single number across nodes. This attribute of vector clocks is useful in scenarios where a merge of data from different branches is made and the event timestamp should signify the merge of multiple branches of data.</li></ol><p>Note, however, that vector timestamps do not explicitly capture causality. They capture history. Lamport causal clock discussed below captures causality explicitly and has almost the same properties as vector clock.</p><h3 id="version-vector-and-dotted-version-vector">Version Vector and Dotted Version Vector</h3><p>A version vector is not a clock in its own right, but a use case of vector clocks. However, I discuss this topic in this article because version vectors are incorrectly used interchangeably with vector clocks by some articles.</p><!--kg-card-begin: html--><p>Version vectors are a clever use of vector <a href="#version-vector" aria-describedby="footnote-label" id="version-vector-ref">clocks</a>, and are typically employed by multi-leader storage nodes to track versions of stored data (and not events). Storage nodes use version vectors as follows:</p><!--kg-card-end: html--><ol><li>A vector clock is maintained by storage nodes as before, but timestamps are issued only when data is modified (which results in a new version of data). Specifically, timestamps are used to denote versions of data. Hence the word <em>version</em> in its name.</li><li>Each data item that needs to be tracked for changes will have its own vector clock.</li><li>The number of nodes in the timestamp tuple reflect the number of leader storage nodes that make changes to data. For example, if there are three leaders, the timestamp would be a triple, with each segment reflecting changes made by each of the leaders. The implication is that clients that <em>contribute</em> to data changes are not tracked in the timestamp tuple (because there could be a large number of clients). The space complexity of version vectors is therefore O(n), where n is the number of leader storage nodes.</li><li>Clients follow the read, update, and write pattern: a client reads data from a storage node along with the vector timestamp (aka version) of the data read; the client updates data and sends the update to the storage node along with the timestamp it read.</li><li>If the storage nodeâ€™s current timestamp matches the timestamp sent by the client, that is if there are no changes to data since the client last read, the storage node simply increments the timestamp/version of the updated data and stores it.</li><li>If the nodeâ€™s current timestamp is different from what the client sent, then there are concurrent changes made to data. The storage node increments the timestamp, like in case 4, and associates that timestamp with the data version. However, the node preserves the previous version of data (and its timestamp) and awaits manual resolution of data divergence. When the conflict is manually resolved, a single future timestamp is associated with the converged data.</li><li>When data changes on a storage node are replicated to other storage nodes, the receiving nodes either accept the changes and converge data or keep track of changes separately depending on whether the changes received are succeeding changes or concurrent changes, just like in points (5) and (6) above.</li></ol><p>If a vector clock used in the version vector is dotted, then the version vector is considered a dotted version vector.</p><p>Let us now revert to our clocks discussion.</p><h3 id="lamport-causal-clock">Lamport Causal Clock</h3><p>The space complexity of a vector timestamp is O(n). To reduce the space complexity, some applications use Lamport timestamps or Lamport origin timestamps, which both have a space complexity of O(1). However, as we observed above, Lamport timestamp variants have inferior functionality compared to vector timestamps. To recall, one drawback of Lamport timestamps is that we cannot deduce if an event definitely occurred after another event or if they are definitely concurrent. Vector timestamps can.</p><p>To address this deficiency while still keeping the space complexity of timestamps to O(1) (although with a few more constant number of bits added), some applications add the causal event timestamp to the Lamport origin timestamp.</p><p>This variant of Lamport clock, hereafter referred to as Lamport Causal Clock, has a few characteristics, which we will study using the example of an event with timestamp [A, 7, [B, 6] ]:</p><ul><li>It is event [ 7 ] generated by node A. [ 7 ] and [A, 7] would be its conventional Lamport timestamp and Lamport origin timestamp respectively.</li><li>It is <em>caused</em> by event [ 6 ] generated on node B.</li></ul><p>Figure 5 illustrates events with causal information included in the timestamp.</p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/5.png" alt="" loading="lazy" width="2000" height="1559" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/5.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/5.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/5.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/5.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 5: Lamport Causal Clock in action across three nodes. Dots are events. The data within square brackets are Lamport causal timestamps. One possible total order of events is illustrated at the bottom. The blue arrows are used to show the flow from T2 to T1 based on cause-effect relationships..</figcaption></figure><p>Unlike any other clocks we have seen so far, Lamport causal clock explicitly captures the causal event. Recall that vector clocks capture history, not causality specifically. We will see how this knowledge can be used to order events in the next section on Event Ordering.</p><p>To compare two Lamport causal timestamps, say T1 and T2, when there are m events total, the following procedure can be used.</p><ol><li>If T1 and T2 are the same, then the corresponding events are the same. Comparison stops here. Otherwise, proceed.</li><li>Identify the timestamp with the highest Lamport timestamp, e.g., the first timestamp amongst [A, 7, [B, 6] ] and [B, 2, [B, 1] ] because [ 7 ] is higher than Â [ 2 ]. (Recall that Lamport timestamps synchronize sequences between nodes). Let us call the higher of the two events T2 and the other event T1. It is evident that T2 occurred either later than T1 or concurrently with T1.</li><li>Order the known events from the beginning until T2. Recall that we can use Lamport origin timestamps to order known events after the fact. The time complexity of this step itself is O(m log m), (a typical sort algorithm based on event numbers and node ids). This step may not be needed if you can trivially recall events needed for step 4 and 5 below. </li><li>Track back from T2 towards the beginning following the causal events. For example the causal event for T2 is [B, 6]. Its causal event can be found in the timestamp associated with it in the ordered list, and so on.</li><li>Repeat step 4 until either T1 is found or an event with a lower Lamport timestamp than T1 (or the beginning) is found. This has O(m) time complexity. If skip lists are used, then the time complexity could be reduced to O(log m).</li><li>If T1 is found, then T1 is in the causal chain of T2. Therefore T2 succeeds T1. In Figure 5, the blue arrows indicate the flow of events from effects to causes, forming a path from T2 to T1.</li><li>If T1 is not found in the causal chain, but a lower Lamport origin timestamp than T1 is found or the beginning is reached, then T1 is concurrent with T2.</li></ol><p>As you can observe, the vector clock functionality can be achieved with a Lamport causal clock and with less space complexity, O(1) vs O(n). However, dotted vector timestamps allow you to compare two events in O(1) time complexity compared to O(log m) with Lamport causal timestamps, after events are either ordered or can be trivially recalled. Otherwise the time complexity will go up to O(m log m) primarily due to step 3 above.</p><h2 id="event-ordering">Event Ordering</h2><p>We have passingly observed how timestamps from various logical clocks can be used to order system events. Let us explicitly study one desirable order for many applications: Total Order.</p><h3 id="total-order-to">Total Order (TO)</h3><p>For an event order to be considered a TO, two conditions have to be met:</p><ol><li>Causes must precede effects. That is, events that cause other events should precede in the order. (Recall that some systems use temporally preceding events as causes, which is fine).</li><li>Concurrent events must be ordered the same way by different nodes when those events are learned.</li></ol><p>Why is the first condition important? Since we generally create systems that can deal with events in real-time, we prefer an order that honors temporal and causal relationships. The first rule essentially ensures events that are meant to be processed sequentially are not scattered arbitrarily in the final order.</p><p>Why is the second condition important? Readers familiar with graph models will have known topological sorting. Topological sorting is the sorting of vertices of a directed acyclic graph where vertex u appears before vertex v in the final order if there is an edge from u to v. Depending on the graph, there could be multiple orders that honor topological sorting rules, and this is the crux of the issue that the second condition observes.</p><p>In our case, there are edges from causes to effects, and topological sorting will order events where causes appear before effects (condition 1 above). The problem is that the presence of concurrent events will result in multiple ordering possibilities. Our goal is to have a predictable order that each node can arrive at while processing events. The second condition is essentially a stipulation to guarantee that predictability.</p><p><strong>One way</strong> to achieve TO is as follows:</p><!--kg-card-begin: html--><ul>
    <li>Assume the first event is a null event, and use the null event as the cause for events with no <a href="#multiple-causes" aria-describedby="footnote-label" id="multiple-causes-ref">causes</a>.</li>
    <li>Causes precede effects. That is, effects should follow causes in the order.</li>
<li>When multiple events have the same cause, position those events after the cause using Lamport timestamp in the decreasing order, where (latter) events with higher numbers are positioned first. A variant of this is to position earlier events first.</li>
<li>If there are two events with the same event number, arrange events in the increasing order of the event origins (i.e., node ids).</li>
</ul>

<!--kg-card-end: html--><p>See Figure 6 for an example. I refer to the TO ordering resulting from the above rules as <strong>CTO</strong>, for easier reference.</p><figure><img src="https://www.exhypothesi.com/content/images/2022/11/6.png" alt="" loading="lazy" width="2000" height="1487" srcset="https://www.exhypothesi.com/content/images/size/w600/2022/11/6.png 600w, https://www.exhypothesi.com/content/images/size/w1000/2022/11/6.png 1000w, https://www.exhypothesi.com/content/images/size/w1600/2022/11/6.png 1600w, https://www.exhypothesi.com/content/images/size/w2400/2022/11/6.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 6: Lamport Causal Clock in action across three nodes. Dots are events. The data within square brackets are Lamport causal timestamps. Events when arranged in CTO are listed at the bottom.</figcaption></figure><p>The idea behind CTO is that if events are replayed as defined here, then causes are processed before effects (which is the natural order) and when there are competing effects to causes, a sub-algorithm is chosen based on the situation, as explained next.</p><p>When competing effects are from multiple nodes, then effects are arranged using the node ordering (i.e., based on node id). Because of choosing node id arbitrarily to break the tie, this ordering is sometimes referred to as <em>arbitrary total order</em>. When competing effects are from the same node, the recent effects are given precedence for arriving at the total order. A variation of this is when the oldest among the competing effects are given precedence instead of the recent ones. Which variation is useful depends on whether the most recent competing effect should <em>override</em> prior effects or <em>add</em> to the outcome.</p><p>It turns out that either of these CTO variations can be produced by performing a preorder depth-first traversal of a mythical tree of events where every root of a subtree is the cause and children are the effects. That tree is referred to in literature as <a href="https://doi.org/10.1145/1832772.1832777?ref=exhypothesi.com">Causal Tree</a>. A causal tree of events from Figure 6 are illustrated in Figure 7.</p><!--kg-card-begin: markdown--><p><img src="https://www.exhypothesi.com/content/images/2022/11/7-1.png" alt="Figure 6"/></p><figcaption><p>Figure 7: Causal Tree of events illustrated in Figure 6.</p></figcaption><!--kg-card-end: markdown--><p>Why is CTO style of TO important? Some collaborative-editing applications rely on this event order for arriving at the same text when multiple users are simultaneously producing events that mutate the text (an offline-supported Google docs of sort).</p><p>We could arrive at other forms of TO besides CTO. For example, the ordering performed in step 3 in the timestamp comparison algorithm for Lamport causal clock described above results in a TO. Why? The ordering is based on Lamport timestamps. And as we noted in the Lamport clock section, we could arrive at a causal order using Lamport timestamps after the fact. This meets condition 1 for TO. When we have concurrent events, we used node ids to break the ties when running the comparison algorithm. And node ids based sorting is deterministic, meeting condition 2 for TO. (We could also arrive at this particular TO using vector timestamps instead of Lamport causal timestamps because the extra knowledge of causality embedded in Lamport causal clock is ignored in this TO). Let us refer to this TO as <strong>NCTO</strong>, for reference.</p><h3 id="clocks-and-event-ordering">Clocks and Event Ordering</h3><p>Event orderings that can be produced under various clock designs. Some characteristics of the produced event orders are stated below.</p><ul><li>None of the clocks discussed in this article can be used to achieve total order <em>in real-time</em> because of the presence of concurrent events. However, some clocks can achieve total order in real-time when there are no ongoing concurrent events.</li><li>Lamport Clock (LC) <em>cannot</em> be used to achieve total order in real-time even amongst non-concurrent events. However, after the fact, events when arranged in ascending order of event numbers, the resulting order conforms to historical (and therefore causal) order, but not total order. That is, the order is indeterministic because of the presence of duplicate event numbers (i.e., no criteria can be applied to consider one duplicate before other). One other limitation is that the order cannot indicate whether two events are concurrent events or one is an effect of another.</li><li>Lamport Origin Clock (LOC) <em>cannot</em> be used to achieve total order in real time even amongst non-concurrent events and the relationship between two events cannot be determined, which are the same limitations as LC. However, after the fact, events can be arranged in total order (that agrees with historical and causal order). The node id can be used as a second sort property to deal with duplicate event numbers.</li><li>Both LC and LOC are not preferable options for some event-replay dependent applications because ordering is only possible after the fact.</li><li>Vector Clock (VC) can be used to achieve total order after the fact, or in real-time barring concurrent events. Such an order would be in NCTO form.</li><li>Lamport Causal Clock (LCC), like VC, can be used to achieve total order after the fact, or in real-time barring concurrent events. And the ordering could be in NCTO form or in CTO because LCC tracks causal events. But producing a total order with LCC is slower in practice compared to with VC. LCC is space efficient, however.</li></ul><p>Given m events, LC and LOC can be used to order with a time complexity of O(m log m), as any two events can be compared to determine which events come first, and the problem therefore reduces to sorting <em>m</em> elements. VC can also be used to order events with a time complexity of O(m log m) because each timestamp consists of the entire history, thereby, again, reducing the problem to sorting <em>m</em> elements. The assumption is that a dotted vector clock is used, so that comparing two timestamps will be O(1) in terms of the number of nodes.</p><p>LCC can be used to order events with a time complexity of O(m log m) similar to timestamps from other clock designs. But skip lists should be maintained to achieve that complexity. With a naive implementation, the time complexity will be O(m<sup>2</sup>). The increase in complexity compared to other timestamps is because two timestamps produced by LCC cannot just be mutually compared to infer the order; historical events should also be consulted that requires a traversal back. In other words, comparing any two LCC timestamps without skip lists has a time complexity of O(m).</p><h2 id="conclusion">Conclusion</h2><p>Conventional clocks have safety issues. Centralized clocks have liveness and performance issues. Logical clocks solve those issues, and are therefore used by many distributed systems, especially storage systems. Multi-leader storage systems use logical clocks for conflict resolution. Leaderless storage systems use them for repairs and anti-entropy mechanisms. Conflict-free replicated data types (CRDTs), which are cooperating data structures that can mutate data while being disconnected from each other, use logical clocks as their foundation to preemptively deal with conflicts.</p><p>Given the foundational role logical clocks play in the design of distributed systems, it is only fitting to learn about them. This article discussed the internals of various logical clock designs and the tradeoffs we have to make in choosing one design over the other.</p><hr/><!--kg-card-begin: html--><!--kg-card-end: html-->
        </div></div>
  </body>
</html>
