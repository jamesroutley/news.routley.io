<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/skip-the-api/">Original</a>
    <h1>Skip the API, ship your database</h1>
    
    <div id="readability-page-1" class="page"><article>
         <dl>
             <dt>Author</dt>
             <dd>
                 <img alt="Ben Johnson" src="https://fly.io/static/images/ben.webp"/>
               <dl>
                 <dt>Name</dt>
                 <dd>
                   Ben Johnson
                 </dd>
                   <dt>Twitter</dt>
                   <dd>
                     <a href="https://twitter.com/benbjohnson" target="_blank">
                       @benbjohnson
                     </a>
                   </dd>
               </dl>
             </dd>
         </dl>

         <section>
             <img src="https://fly.io/blog/skip-the-api/assets/skip-the-api-cover.webp" alt="A child is peeking over at the answers on another child&#39;s test."/>
           
<p>My favorite part about building tools is discovering their unintended uses. It’s like starting to write a murder mystery book but you have no idea who the killer is!</p>

<p>History is filled with examples of these accidental discoveries: WD-40 was originally <a href="https://en.wikipedia.org/wiki/WD-40#History">used to protect ICBMs from rust</a> and now it fixes your squeaky doorknob. Bubble wrap was <a href="https://en.wikipedia.org/wiki/Bubble_Wrap_(brand)#History">originally sold as wallpaper</a> and now it protects your Amazon packages.</p>

<p>When we started writing <a href="https://fly.io/docs/litefs/">LiteFS</a>, a distributed SQLite database, we thought it would be used to distribute data geographically so users in, say, Bucharest see response times as fast as users in San Jose. And for the most part, that’s what LiteFS users are doing.</p>

<p>But we discovered another unexpected use: replacing the API layer between services with SQLite databases.</p>
<h2 id="how-it-started"><a href="#how-it-started" aria-label="Anchor"></a>How it started</h2>
<p>In the early days of LiteFS development, we wanted to find a real-world test bed for our tool so we could smoke out any bugs that we didn’t find during automated tests. Part of  our existing infrastructure is a program called <em>Corrosion</em> that gossips state between all our servers. Corrosion tracks VM statuses, health checks, and a plethora of other information for each server and communicates this info with other servers so they can make intelligent decisions about request routing and VM placement. Corrosion keeps a fast, local copy of all this data in a SQLite database.</p>

<p>So we set up a Corrosion instance that also ran on top of LiteFS. This helped root out some bugs but we also found another use for it: making Corrosion accessible to our internal services.</p>

<p><img src="https://fly.io/blog/skip-the-api/assets/corrosion.png"/></p>
<h2 id="shipping-the-kitchen-sink"><a href="#shipping-the-kitchen-sink" aria-label="Anchor"></a>Shipping the kitchen sink</h2>
<p>The typical approach to making data available between services is to spend weeks designing an API and then building a service around it. Your API design needs to take into account the different use cases of each consuming service so that it can deliver the data it needs efficiently. You don’t want your clients making a dozen API calls for every request!</p>

<p><img src="https://fly.io/blog/skip-the-api/assets/architecture.png"/></p>

<p>A different approach is to skip the API design entirely and just ship the entire database to your client. You don’t need to consider the consuming service’s access patterns as they can use vanilla SQL to query and join whatever data their heart desires. That’s what we did using LiteFS.</p>

<p>While we could have set up each downstream service as a Corrosion node, gossip protocols can be chatty and we really just needed a one-way stream of updates. Setting up a read-only LiteFS instance for a new service is simple—it just needs the hostname of the upstream primary node to connect to:</p>
<div>
  <pre><code>lease:
  type: &#34;static&#34;
  candidate: false
  advertise-url: &#34;http://corrosion-bridge:20202
</code></pre>
</div>

<p>And voila! You have a full, read-only copy of the database on your app.</p>
<h2 id="moving-compute-to-the-client"><a href="#moving-compute-to-the-client" aria-label="Anchor"></a>Moving compute to the client</h2>
<p>API design is notoriously difficult as it’s hard to know what your consuming services will need. Query languages such as <a href="https://graphql.org/">GraphQL</a> have even been invented for this specific problem!</p>

<p>However, GraphQL has its own limitations. It’s good for fetching raw data but it lacks built-in <a href="https://www.sqlite.org/lang_aggfunc.html">aggregation</a> &amp; advanced querying capabilities like <a href="https://www.sqlite.org/windowfunctions.html">windowing</a>. GraphQL is typically layered on top of an existing relational database that uses SQL. So why not just use SQL?</p>

<p>Additionally, performing queries on your service means that you need to handle multiple tenants competing for compute resources. Managing these tenants involves rate limiting and query timeouts so that no one client consumes all the resources.</p>

<p>By pushing a read-only copy of the database to clients,  these restrictions aren’t a concern anymore. A tenant can use 100% of its CPU for hours if it wants to. It won’t adversely affect any other tenant because the query is running on its own hardware.</p>
<h2 id="so-whats-the-downside"><a href="#so-whats-the-downside" aria-label="Anchor"></a>So what’s the downside?</h2>
<p>There’s always trade-offs with any technology and shipping read-only replicas is no different. One obvious limitation of read-only replicas is that they’re read-only. If your clients need to update data, they’ll still need an API for those mutations.</p>

<p>A less obvious downside is that the contract for a database can be less strict than an API. One benefit to an API layer is that you can change the underlying database structure but still massage data to look the same to clients. When you’re shipping the raw database, that becomes more difficult. Fortunately, many database changes, such as adding columns to a table, are backwards compatible so clients don’t need to change their code. Database views are also a great way to reshape data so it stays consistent—even when the underlying tables change.</p>

<p>Finally, shipping a database limits your ability to restrict access to data. If you have a multi-tenant database, you can’t ship that database without the client seeing all the data. One workaround for this is to use a database per tenant. SQLite databases are lightweight since they are just files on disk. This also has the added benefit of preventing queries in your application from accidentally fetching data across tenants.</p>
<h2 id="where-do-we-take-this-next"><a href="#where-do-we-take-this-next" aria-label="Anchor"></a>Where do we take this next?</h2>
<p>While this approach has worked well for some internal tooling, how does this look in the broader world of software? APIs are likely stick around for the foreseeable future so providing read-only database replicas make sense for specific use cases where those APIs aren’t a great fit.</p>

<p>Imagine being able to query all your Stripe data or your GitHub data from a local database. You could join that data on to your own dataset and perform fast queries on your own hardware.</p>

<p>While companies such as Stripe or GitHub likely colocate their tenant data into one database, many companies run an event bus using tools like Kafka which could allow them to generate per-tenant SQLite databases to then stream to customers.</p>

<p>Pushing queries out to the end user has huge benefits for both the data provider &amp; the data consumer in terms of flexibility and power.</p>

           
         </section>
         <dl>
             <dt>
               Previous post  ↓
             </dt>
             <dd>
               <a href="https://fly.io/blog/sentry-partnership/">
                 Automated Sentry Error Tracking
               </a>
             </dd>
         </dl>
       </article></div>
  </body>
</html>
