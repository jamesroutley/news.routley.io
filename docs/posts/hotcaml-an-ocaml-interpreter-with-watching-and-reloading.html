<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/let-def/hotcaml">Original</a>
    <h1>Hotcaml: An OCaml interpreter with watching and reloading</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto">Hotcaml is an OCaml interpreter that starts from a source file and loads it dependencies.
When one of the source file changes and passes the typechecker, it is reloaded, as well as all its reverse dependencies.</p>
<p dir="auto">To get started, clone the repository and type <code>make</code>. Two frontends are built: <code>hotcaml.exe</code> and <code>hotcaml_lwt.exe</code>.</p>
<h2 dir="auto"><a id="user-content-starting-hotcaml" aria-hidden="true" href="#starting-hotcaml"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Starting hotcaml</h2>
<p dir="auto">An <code>hotcaml</code> invocation takes three kinds of arguments:
<code>hotcaml [ -package pkg ]* [ -I path ]* entrypoint.ml*</code></p>
<p dir="auto">The <code>pkg</code> &#39;s should be valid <code>findlib</code> package names. They will be loaded in order during startup.</p>
<p dir="auto">The <code>path</code>&#39;s are paths that will be looked up for dependencies.</p>
<p dir="auto">Finally, the entrypoints are the actual code that we want to interpret.</p>
<p dir="auto">Each entrypoint is loaded and interpreted in order. Dependencies of an entrypoint are looked up in the <code>path</code>&#39;s and then in the loaded packages.</p>
<p dir="auto">Once execution of the entrypoints is done, the interpreter will watch the disk for changes. If one of the source file change, it is reloaded and interpretation resumes from this module, followed by all its reverse dependencies.</p>
<p dir="auto">If one of the dependency does not typecheck, reloading is postponed until all errors are solved.</p>
<h2 dir="auto"><a id="user-content-synchronous-and-asynchronous-frontends" aria-hidden="true" href="#synchronous-and-asynchronous-frontends"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Synchronous and asynchronous frontends</h2>
<p dir="auto">Contrary to the normal execution of an OCaml program, modules can be loaded and unloaded, multiples times, during the execution.</p>
<p dir="auto">The synchronous <code>hotcaml</code> only look for changes after execution is done. This is not really convenient for interactive programs, where we might want to reload during execution rather than after.</p>
<p dir="auto"><code>hotcaml_lwt</code> provides an asynchronous frontend: lwt threads continue to execute after loading, and modules can be reloaded concurrentlly.</p>
<h2 dir="auto"><a id="user-content-observing-reload-process" aria-hidden="true" href="#observing-reload-process"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Observing reload process</h2>
<p dir="auto">The <code>Hotlink</code> module can be used to customize behavior of hot-loaded programs.</p>
<p dir="auto"><code>Hotlink.is_hot_loaded () : bool</code> is true only when called from a module that has been hot-loaded.</p>
<p dir="auto"><code>Hotlink.is_hot_unloaded () : bool</code> is true only when called from a module that was hot-loaded and has now been unloaded.</p>
<p dir="auto"><code>Hotlink.on_unload : (unit -&gt; unit) -&gt; unit</code> allows to register a callback that will be invoked when an hot-loaded module is unloaded.</p>
<p dir="auto"><code>Hotlink.on_unload_or_at_exit : (unit -&gt; unit) -&gt; unit</code> calls the callback either during unloading or when exiting the program.</p>
<h3 dir="auto"><a id="user-content-cold-execution" aria-hidden="true" href="#cold-execution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Cold execution</h3>
<p dir="auto">In a normal, &#34;cold&#34; execution, the <code>Hotlink</code> module exhibits a compatible, reasonable, behavior:</p>
<ul dir="auto">
<li><code>Hotlink.is_hot_loaded</code> and <code>Hotlink.is_hot_unloaded</code>  are always <code>false</code></li>
<li><code>Hotlink.on_unload</code> does nothing</li>
<li><code>Hotlink.on_unload_or_at_exit</code> behaves like <code>at_exit</code></li>
</ul>
<p dir="auto">This allows to have modules that are compatible with both classical OCaml and with hotcaml, and adjust their behavior based on the situation.</p>
</article>
        </div></div>
  </body>
</html>
