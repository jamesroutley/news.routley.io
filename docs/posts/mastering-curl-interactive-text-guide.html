<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antonz.org/mastering-curl/">Original</a>
    <h1>Mastering curl: interactive text guide</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><div><header></header><p>I recently watched the 3.5-hour workshop <a href="https://www.youtube.com/watch?v=V5vZWHP-RqU">Mastering the curl command line</a> by <a href="https://daniel.haxx.se/">Daniel Stenberg</a>, the author of curl. The video was awesome and I learned a ton of things, so I wanted a (shortened) text version for future reference. Here it is.</p><p>I&#39;ve also included some interactive examples, so you can try out different curl commands as you read.</p><p><a href="#the-curl-project">project</a> •
<a href="#command-line-options">options</a> •
<a href="#urls">urls</a> •
<a href="#curl-basics">basics</a> •
<a href="#http">http</a> •
<a href="#future">future</a></p><h2 id="the-curl-project">The curl project</h2><p>Curl started in 1996 (back then it was called <code>httpget</code>). It was created by Rafael Sagula, who later transferred the project to Daniel. Daniel renamed the project to <code>curl</code> in 1998. In 2000, he extracted the networking functionality into the <code>libcurl</code> library, and <code>curl</code> itself became a command-line wrapper around it.</p><p>Curl stands for &#34;client for URLs&#34;. It&#39;s a tool for client-side <em>internet transfers</em> with URLs. An internet transfer is an <em>upload</em> or <em>download</em> using a specific protocol (curl supports quite a few), where the endpoint is identified by a URL.</p><p>Curl is <a href="https://github.com/curl/curl">open sourced</a> under the (slightly modified) MIT License. It accepts contributions from anyone, no paperwork required. There are about 15 people who can accept PRs. The lead (and only full-time) developer is Daniel.</p><p>Curl supports a crazy number of protocols, from HTTP, FTP and TELNET to IMAP, LDAP and GOPHER. It runs on 92 operating systems and has over 20 billion installations worldwide.</p><p>Curl + libcurl is about 160K lines of code. Curl is released every 8 weeks and has about 250 releases as of August 2023.</p><div><div><figure><img alt="Release cycle" src="https://antonz.org/mastering-curl/release-cycle.jpg"/><figcaption>After the release, there is a 10-day cool-down, followed by a 21-day feature window, followed by a 25-day feature freeze.</figcaption></figure></div></div><p>Curl has an extensive <a href="https://curl.se/docs/manpage.html">reference documentation</a>. To see the short version, try this:</p><pre tabindex="0"><code>curl --help
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To see the full version, try <code>curl --manual</code> (be careful, it&#39;s <em>huge</em>).</p><p>There is also a book named <a href="https://curl.se/book.html">Everything curl</a> available online, and <a href="https://curl.se/support.html">commercial support</a> provided by the company Daniel works for.</p><h2 id="command-line-options">Command line options</h2><p>Curl performs internet transfers, where it acts as a client, uploading or downloading data from a remote server. The data can be anything: text, images, audio, video, and so on.</p><p>Curl supports both unauthenticated protocols (such as HTTP or FTP) and their authenticated counterparts (such as HTTPS or FTPS). Data transferred over an unauthenticated protocol can be intercepted and tampered with, so it&#39;s better to always use authenticated ones. Curl can disable server verification with an <code>--insecure</code> flag, but you better not do this in production.</p><p>Curl currently has about 250 options, and the number is growing at a rate of ≈10/year.</p><p>There are short command line options (single dash):</p><pre tabindex="0"><code>curl -V
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>And long options (double dash):</p><pre tabindex="0"><code>curl --version
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>All options are available in &#34;long&#34; format, but only some of them have &#34;short&#34; counterparts.</p><div><div><figure><img alt="Command-line options" src="https://antonz.org/mastering-curl/cli-options.jpg"/><figcaption>The number of options keeps growing.</figcaption></figure></div></div><p>Some options are of boolean type. You can turn such options on:</p><pre tabindex="0"><code>curl --silent http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or off:</p><pre tabindex="0"><code>curl --no-silent http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Some options accept arguments:</p><pre tabindex="0"><code>curl --output /tmp/uuid.json http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Arguments that contain spaces should be enclosed in quotes:</p><pre tabindex="0"><code>curl -o /dev/null --write-out &#34;type: %{content_type}&#34; http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h2 id="urls">URLs</h2><p>Curl supports URLs (URIs, really) similar to how <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a> defines them:</p><pre tabindex="0"><code>scheme://user:password@host:port/path?query#fragment
</code></pre><ul><li><code>scheme</code> defines a protocol (like <code>https</code> or <code>ftp</code>). If omitted, curl will try to guess one.</li><li><code>user</code> and <code>password</code> are authentication credentials (passing credentials in URLs is generally not used anymore for the security reasons).</li><li><code>host</code> is the hostname, domain name or IP address of the server.</li><li><code>port</code> is the port number. If omitted, curl will use the default port associated with the scheme (such as 80 for <code>http</code> or 443 for <code>https</code>).</li><li><code>path</code> is the path to the resource on the server.</li><li><code>query</code> is usually a sequence of <code>name=value</code> pairs separated by <code>&amp;</code>.</li></ul><p>For curl, anything starting with <code>-</code> or <code>--</code> is an option, and everything else is a URL.</p><h3 id="query">Query</h3><p>If you pass a lot of URL parameters, the query part can become quite long. The <code>--url-query</code> option allows you to specify query parts separately:</p><pre tabindex="0"><code>curl http://httpbin/get --url-query &#34;name=Alice&#34; --url-query &#34;age=25&#34;
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="multiple-urls">Multiple URLs</h3><p>Curl accepts any number of URLs, each of which requires a destination — stdout or a file. For example, this command saves the first UUID to <code>/tmp/uuid1.json</code> and the second UUID to <code>tmp/uuid2.json</code>:</p><pre tabindex="0"><code>curl
  -o /tmp/uuid1.json http://httpbin/uuid
  -o /tmp/uuid2.json http://httpbin/uuid

&amp;&amp; cat /tmp/uuid1.json
&amp;&amp; cat /tmp/uuid2.json
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(Here and beyond, I will sometimes show multiline commands for illustrative purposes. In reality curl expects a single line or line breaks with <code>\</code>)</em></p><p>The <code>-O</code> derives the filename from the URL:</p><pre tabindex="0"><code>curl --output-dir /tmp
  -O http://httpbin/anything/one
  -O http://httpbin/anything/two

&amp;&amp; ls /tmp
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To write both responses to the same file, you can use redirection:</p><pre tabindex="0"><code>curl http://httpbin/uuid http://httpbin/uuid &gt; /tmp/uuid.json

&amp;&amp; cat /tmp/uuid.json
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="url-globbing">URL globbing</h3><p>Curl automatically expands glob expressions in URLs into multiple specific URLs.</p><p>For example, this command requests three different paths (<code>al</code>, <code>bt</code>, <code>gm</code>), each with two different parameters (<code>num=1</code> and <code>num=2</code>), for a total of six URLs:</p><pre tabindex="0"><code>curl --output-dir /tmp -o &#34;out_#1_#2.txt&#34;
  http://httpbin/anything/{al,bt,gm}?num=[1-2]

&amp;&amp; ls /tmp
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>You can disable globbing with the <code>--globoff</code> option if <code>[]{}</code> characters are valid in your URLs. Then curl will treat them literally.</p><div><div><figure><img alt="Parallel transfers" src="https://antonz.org/mastering-curl/parallel-transfers.jpg"/><figcaption>Use <code>--parallel</code> (<code>-Z</code>) to tell curl process URLs concurrently.</figcaption></figure></div></div><h3 id="config-file">Config file</h3><p>As the number of options increases, the curl command becomes harder to decipher. To make it more readable, you can prepare a config file that lists one option per line (<code>--</code> is optional):</p><pre tabindex="0"><code>output-dir /tmp
show-error
silent
</code></pre><p>By default, curl reads the config from <code>$HOME/.curlrc</code>, but you can change this with the <code>--config</code> (<code>-K</code>) option:</p><pre tabindex="0"><code>curl --config /sandbox/.curlrc http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="progress-meters">Progress meters</h3><p>Curl has two progress meters. The default is verbose:</p><pre tabindex="0"><code>curl --no-silent http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>(I have a <code>silent</code> option in my config file, so I have to turn it off explicitly; by default, it&#39;s not set, so <code>--no-silent</code> is not needed)</p><p>The other is compact:</p><pre tabindex="0"><code>curl --no-silent --progress-bar http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>The <code>--silent</code> option turns the meter off completely:</p><pre tabindex="0"><code>curl --silent http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="state-reset">State reset</h3><p>When you set options, they apply to all URLs curl processes. For example, here both headers are sent to both URLs:</p><pre tabindex="0"><code>curl
  -H &#34;x-num: one&#34; http://httpbin/headers?1
  -H &#34;x-num: two&#34; http://httpbin/headers?2
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Sometimes that&#39;s not what you want. To reset the state between URL calls, use the <code>--next</code> option:</p><pre tabindex="0"><code>curl
  -H &#34;x-num: one&#34; http://httpbin/headers?1
  --next
  -H &#34;x-num: two&#34; http://httpbin/headers?2
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h2 id="curl-basics">Curl basics</h2><p>Now that we understand how curl handles URLs and options, let&#39;s talk about specific features.</p><h3 id="version">Version</h3><p><code>--version</code> (<code>-V</code>) knows everything about the installed version of curl:</p><pre tabindex="0"><code>curl -V
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>It lists (line by line) ➊ versions of curl itself and its dependencies, ➋ the release date, ➌ available protocols, and ➍ enabled features.</p><h3 id="verbose">Verbose</h3><p><code>--verbose</code> (<code>-v</code>) makes curl verbose, which is useful for debugging:</p><pre tabindex="0"><code>curl -v http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>If <code>--verbose</code> is not enough, try <code>--trace</code> (the single <code>-</code> sends the trace output to stdout):</p><pre tabindex="0"><code>curl --trace - http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or <code>--trace-ascii</code>:</p><pre tabindex="0"><code>curl --trace-ascii - http://httpbin/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Use <code>--write-out</code> (<code>-w</code>) to extract specific information about the response. It supports over <a href="https://everything.curl.dev/usingcurl/verbose/writeout">50 variables</a>. For example, here we extract the status code and response content type:</p><pre tabindex="0"><code>curl
  -w &#34;\nstatus: %{response_code}\ntype: %{content_type}&#34;
  http://httpbin/status/429
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or some response headers:</p><pre tabindex="0"><code>curl
  -w &#34;\ndate: %header{date}\nlength: %header{content-length}&#34;
  http://httpbin/status/429
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="downloads">Downloads</h3><p><code>--remote-name</code> (<code>-O</code>) tells curl to save the output to a file specified by the URL (specifically, by the part after the last <code>/</code>). It&#39;s often used together with <code>--output-dir</code>, which tells curl where exactly to save the file:</p><pre tabindex="0"><code>curl --output-dir /tmp -O http://httpbin/uuid

&amp;&amp; cat /tmp/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>If the directory does not exist, <code>--output-dir</code> won&#39;t create it for you. Use <code>--create-dirs</code> for this:</p><pre tabindex="0"><code>curl --output-dir /tmp/some/place --create-dirs
  -O http://httpbin/uuid

&amp;&amp; cat /tmp/some/place/uuid
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>You can use <code>--max-filesize</code> (in bytes) to limit the allowed response size, but often it isn&#39;t known in advance, so it may not work.</p><h3 id="retry">Retry</h3><p>Sometimes the remote host is temporarily unavailable. To deal with these situations, curl provides the <code>--retry [num]</code> option. If a request fails, curl will try it again, but no more than <code>num</code> times:</p><pre tabindex="0"><code>curl -i --retry 3 http://httpbin/unstable
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(this URL fails 50% of the time)</em></p><p>You can set the maximum time curl will spend retrying with <code>--retry-max-time</code> (in seconds) or the delay between retries with <code>--retry-delay</code> (also in seconds):</p><pre tabindex="0"><code>curl -i --retry 3 http://httpbin/unstable
  --retry-max-time 2
  --retry-delay 1
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>For curl, &#34;request failed&#34; means one of the following HTTP codes: 408, 429, 500, 502, 503 or 504. If the request fails with a &#34;connection refused&#34; error, curl will not retry. But you can change this with <code>--retry-connrefused</code>, or even enable retries for all kinds of problems with <code>--retry-all-errors</code>.</p><h3 id="uploads">Uploads</h3><p>Curl is often used to download data from the server, but you can also upload it. Use the <code>--upload-file</code> (<code>-T</code>) option:</p><pre tabindex="0"><code>echo hello &gt; /tmp/hello.txt &amp;&amp;

curl -T /tmp/hello.txt http://httpbin/put
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>For HTTP uploads, curl uses the <code>PUT</code> method.</p><h3 id="transfer-controls">Transfer controls</h3><p>To stop slow transfers, set the minimum allowed download speed (in bytes per second) with <code>--speed-limit</code>. By default, curl checks the speed in 30 seconds intervals, but you can change this with <code>--speed-time</code>.</p><p>For example, allow no less than 10 bytes/sec during a 3-second interval:</p><pre tabindex="0"><code>curl -v --speed-limit 10 --speed-time 3 http://httpbin/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To limit bandwidth usage, set <code>--limit-rate</code>. It accepts anything from bytes to petabytes:</p><pre tabindex="0"><code>curl --limit-rate 3 http://httpbin/get
curl --limit-rate 3k http://httpbin/get
curl --limit-rate 3m http://httpbin/get
curl --limit-rate 3g http://httpbin/get
curl --limit-rate 3t http://httpbin/get
curl --limit-rate 3p http://httpbin/get
</code></pre><p>Another thing to limit is the number of concurrent requests (e.g. if you download a lot of files). Use <code>--rate</code> for this. It accepts seconds, minutes, hours or days:</p><pre tabindex="0"><code>curl --rate 3/s http://httpbin/anything/[1-9].txt
curl --rate 3/m http://httpbin/anything/[1-9].txt
curl --rate 3/h http://httpbin/anything/[1-9].txt
curl --rate 3/d http://httpbin/anything/[1-9].txt
</code></pre><h3 id="name-resolving">Name resolving</h3><p>By default, curl uses your DNS server to resolve hostnames to IP addresses. But you can force it to resolve to a specific IP with <code>--resolve</code>:</p><pre tabindex="0"><code>curl --resolve httpbingo.org:8080:127.0.0.1
  http://httpbingo.org:8080/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(this one fails because no one is listening on 127.0.0.1)</em></p><p>Or you can even map a <code>hostname:port</code> pair to another <code>hostname:port</code> pair with <code>--connect-to</code>:</p><pre tabindex="0"><code>curl --connect-to httpbingo.org:8080:httpbin:80
  http://httpbingo.org:8080/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(this one works fine)</em></p><div><div><figure><img alt="Connection-level settings" src="https://antonz.org/mastering-curl/connections.jpg"/><figcaption>There are also some network connection-level settings.</figcaption></figure></div></div><h3 id="timeouts">Timeouts</h3><p>To limit the maximum amount of time curl will spend interacting with a single URL, use <code>--max-time</code> (in fractional seconds):</p><pre tabindex="0"><code>curl --max-time 0.5 http:/httpbin/delay/1
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(this one fails)</em></p><p>Instead of limiting the total time, you can use <code>--connect-timeout</code> to limit only the time it takes to establish a network connection:</p><pre tabindex="0"><code>curl --connect-timeout 0.5 http:/httpbin/delay/1
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(this one works fine)</em></p><h3 id="credentials">Credentials</h3><p>You almost never want to pass the username and password in the curl command itself. One way to avoid this is to use the <code>.netrc</code> file. It specifies hostnames and credentials for accessing them:</p><pre tabindex="0"><code>machine httpbin
login alice
password cheese

machine example.com
login bob
password nuggets
</code></pre><p>Pass the <code>--netrc</code> option to use the <code>$HOME/.netrc</code> file, or <code>--netrc-file</code> to use a specific one:</p><pre tabindex="0"><code>echo -e &#34;machine httpbin\nlogin alice\npassword cheese&#34; &gt; /tmp/netrc &amp;&amp;

curl --netrc-file /tmp/netrc
  http://httpbin/basic-auth/alice/cheese
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="exit-status">Exit status</h3><p>When curl exits, it returns a numeric value to the shell. For success, it&#39;s 0, and for errors, there are about <a href="https://everything.curl.dev/usingcurl/returns">100 different values</a>.</p><p>For example, here is an exit status 7 (failed to connect to host):</p><pre tabindex="0"><code>curl http://httpbin:1313/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>You can access the exit status through the <code>$?</code> shell variable.</p><h2 id="http">HTTP</h2><p>Curl is mostly used to work with HTTP, so let&#39;s talk about it.</p><p>HTTP/1.x is a plain-text protocol that describes the communication between the client and the server. The client sends messages like this:</p><pre tabindex="0"><code>POST /anything/chat HTTP/1.1
host: httpbingo.org
content-type: application/json
user-agent: curl/7.87.0

{
    &#34;message&#34;: &#34;Hello!&#34;
}
</code></pre><ul><li>The first line is a <em>request line</em>. The <em>method</em> (<code>POST</code>) defines the operation the client wants to perform. The <em>path</em> (<code>/anything/chat</code>) is the URL of the requested resource (without the protocol, domain and port). The <em>version</em> (<code>HTTP/1.1</code>) indicates the version of the HTTP protocol.</li><li>Next lines (until the empty line) are <em>headers</em>. Each header is a key-value pair that tells the server some useful information about the request. In our case it&#39;s the hostname of the server (<code>httpbingo.org</code>), the type of the content (<code>application/json</code>) and the client&#39;s self-identification (<code>user-agent</code>).</li><li>Finally, there is the actual data that the client sends to the server.</li></ul><p>Client receives messages like this in response:</p><pre tabindex="0"><code>HTTP/1.1 200 OK
date: Mon, 28 Aug 2023 07:51:49 GMT
content-type: application/json

{
    &#34;message&#34;: &#34;Hi!&#34;
}
</code></pre><ul><li>The first line is a <em>status line</em>. The <em>version</em> (<code>HTTP/1.1</code>) indicates the version of the HTTP protocol. The <em>status code</em> (<code>200</code>) tells whether the request was successful or not, and why (there are many status codes for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">different situations</a>). The <em>status message</em> is a human-readable description of the status code (HTTP/2 does not have it).</li><li>Next lines (until the empty line) are <em>headers</em>. Similar to request headers, these provide useful information about the response to the client.</li><li>Finally, there is the actual data that the server sends to the client.</li></ul><p>The HTTP protocol is stateless, so any state must be contained within the request itself, either in the headers or in the body.</p><div><div><figure><img alt="HTTP/2" src="https://antonz.org/mastering-curl/http2.jpg"/><figcaption>HTTP/2, the successor to HTTP/1.1, is a binary protocol. However, curl displays HTTP/2 messages in plain text (just like HTTP/1.1), so we can safely ignore this fact for our purposes.</figcaption></figure></div></div><h3 id="http-method">HTTP method</h3><p>Curl supports all HTTP methods (sometimes called <em>verbs</em>).</p><p>GET (the default one, requires no options):</p><pre tabindex="0"><code>curl http://httpbin/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>HEAD (<code>-I</code>/<code>--head</code>, returns headers only):</p><pre tabindex="0"><code>curl -I http://httpbin/head
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>POST (<code>-d</code>/<code>--data</code> for data or <code>-F</code>/<code>--form</code> for HTTP form):</p><pre tabindex="0"><code>curl -d &#34;name=alice&#34; http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or any other method with <code>--request</code> (<code>-X</code>):</p><pre tabindex="0"><code>curl -X PATCH -d &#34;name=alice&#34; http://httpbin/patch
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="response-code">Response code</h3><p>Typically, status codes 2xx (specifically 200) are considered &#34;success&#34;, while 4xx are treated as client-side errors and 5xx as server-side errors. But curl doesn&#39;t care about codes: to it, every HTTP response is a success:</p><pre tabindex="0"><code>curl http://httpbin/status/503 &amp;&amp; echo OK
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To make curl treat 4xx and 5xx codes as errors, use <code>--fail</code> (<code>-f</code>):</p><pre tabindex="0"><code>curl -f http://httpbin/status/503 &amp;&amp; echo OK
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To print the response code, use <code>--write-out</code> with the <code>response_code</code> variable:</p><pre tabindex="0"><code>curl -w &#34;%{response_code}&#34; http://httpbin/status/200
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To display response headers, use <code>--head</code> (<code>-i</code>):</p><pre tabindex="0"><code>curl -i http://httpbin/status/200
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or save them to a file using <code>--dump-header</code> (<code>-D</code>):</p><pre tabindex="0"><code>curl -D /tmp/headers http://httpbin/status/200

&amp;&amp; cat /tmp/headers
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="response-body">Response body</h3><p>Response body, sometimes called <em>payload</em>, is what curl outputs by default:</p><pre tabindex="0"><code>curl http://httpbin/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>You can ask the server to compress the data with <code>--compressed</code>, but curl will still show it as uncompressed:</p><pre tabindex="0"><code>curl --compressed http://httpbin/get
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><em>(note how the Accept-Encoding request header has changed)</em></p><h3 id="ranges">Ranges</h3><p>To ask the server for a piece of data instead of the whole thing, use the <code>--range</code> (<code>r</code>) option. This will cause curl to request the specified <a href="https://curl.se/docs/manpage.html#-r">byte range</a>.</p><p>For example, here we request 50 bytes starting with the 100th byte:</p><pre tabindex="0"><code>curl --range 100-150 http://httpbin/range/1024
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Note that the server may ignore the ask and return the entire response.</p><p>If you are downloading data from a server, you can also use <code>--continue-at</code> (<code>-C</code>) to continue the previous transfer at the specified offset:</p><pre tabindex="0"><code>curl --continue-at 1000 http://httpbin/range/1024
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="http-versions">HTTP versions</h3><p>By default, curl uses HTTP/1.1 for the <code>http</code> scheme and HTTP/2 for <code>https</code>. You can change this with flags:</p><pre tabindex="0"><code>--http0.9
--http1.0
--http1.1
--http2
--http3
</code></pre><p>To find out which version the server supports, use the <code>http_version</code> response variable:</p><pre tabindex="0"><code>curl -w &#34;%{http_version}&#34; http://httpbin/status/200
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="conditional-requests">Conditional requests</h3><p>Conditional requests are useful when you want to avoid downloading already downloaded data (assuming it is not stale). Curl supports two different conditions: file timestamp and etag.</p><p>Timestamp conditions use <code>--time-cond</code> (<code>-z</code>).</p><p>Download the data only if the remote resource is newer (condition holds):</p><pre tabindex="0"><code>curl --time-cond &#34;Aug 30, 2023&#34; http://httpbin/etag/etag
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Or older (condition fails):</p><pre tabindex="0"><code>curl -i --time-cond &#34;-Aug 30, 2023&#34; http://httpbin/etag/etag
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Etag conditions are a bit more involved. An <em>etag</em> is a value returned by the server that uniquely identifies the current version of the requested resource. It is often a hash of the data.</p><p>To checks an etag, curl must first to save it with <code>--etag-save</code>:</p><pre tabindex="0"><code>curl --etag-save /tmp/etags http://httpbin/etag/etag
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>And use <code>--etag-compare</code> in subsequent requests:</p><pre tabindex="0"><code>curl --etag-save /tmp/etags -o /dev/null http://httpbin/etag/etag &amp;&amp;

curl -i --etag-compare /tmp/etags http://httpbin/etag/etag
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Timestamp conditions rely on the Last-Modified response header, so if the server does not provide it, the resource will always be considered newer. The same goes for etag conditions and the Etag response header.</p><h3 id="http-post">HTTP POST</h3><p>POST sends data to the server. By default, it&#39;s a set of key-value pairs encoded in a single string with a <code>application/x-www-form-urlencoded</code> Content-Type header.</p><p>You can use <code>--data</code> (<code>-d</code>) to specify individual key-value pairs (or the entire string):</p><pre tabindex="0"><code>curl -d name=alice -d age=25 http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To send data from a file, use <code>@</code> with a file path. Use <code>--header</code> (<code>-H</code>) to change the Content-Type header with according to the file contents:</p><pre tabindex="0"><code>echo &#34;Alice, age 25&#34; &gt; /tmp/data.txt &amp;&amp;

curl -d @/tmp/data.txt -H &#34;content-type: text/plain&#34;
  http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p><code>--data-raw</code> posts data similar to <code>--data</code>, but without the special interpretation of the <code>@</code> character.</p><p>To post JSON data, use <code>--json</code>. It automatically sets the Content-Type and Accept headers accordingly:</p><pre tabindex="0"><code>curl --json &#39;{&#34;name&#34;: &#34;alice&#34;}&#39; http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><div><div><figure><img alt="JSON requests" src="https://antonz.org/mastering-curl/json.jpg"/><figcaption>Use <code>jo</code> and <code>jq</code> to simplify working with JSON.</figcaption></figure></div></div><p>To URL-encode data (escape all symbols not allowed in URLs), use <code>--data-urlencode</code>:</p><pre tabindex="0"><code>curl --data-urlencode &#34;Name: Alice Barton&#34; http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="multipart-formpost">Multipart formpost</h3><p>POST can send data as a sequence of &#34;parts&#34; with a <code>multipart/form-data</code> content type. It&#39;s often used for HTML forms that contain both text fields and files.</p><p>Each part has a name, headers, and data. Parts are separated by a &#34;mime boundary&#34;:</p><pre tabindex="0"><code>--------------------------d74496d66958873e
Content-Disposition: form-data; name=&#34;person&#34;

anonymous
--------------------------d74496d66958873e
Content-Disposition: form-data; name=&#34;secret&#34;; filename=&#34;file.txt&#34;
Content-Type: text/plain

contents of the file
--------------------------d74496d66958873e--
</code></pre><p>To construct multipart requests with curl, use <code>--form</code> (<code>F</code>). Each of these options adds a part to the request:</p><pre tabindex="0"><code>touch /tmp/alice.png &amp;&amp;

curl -F name=Alice -F age=25 -F photo=@/tmp/alice.png
  http://httpbin/post
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="redirects">Redirects</h3><p>A <em>redirect</em> is when the server, instead of returning the requested resource, tells the client that the resource is located elsewhere (as indicated by the Location header). A redirect always has a 3xx response code.</p><p>Curl does not follow redirects by default, it returns the response as is:</p><pre tabindex="0"><code>curl -i http://httpbin/redirect/1
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To make curl follow redirects, use <code>--follow</code> (<code>-L</code>):</p><pre tabindex="0"><code>curl -L http://httpbin/redirect/1
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>To protect against endless loop redirects, use <code>--max-redirs</code>:</p><pre tabindex="0"><code>curl -L --max-redirs 3 http://httpbin/redirect/10
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="http-put">HTTP PUT</h3><p>The PUT method is often used to send files to the server. Use <code>--upload-file</code> (<code>-T</code>) for this:</p><pre tabindex="0"><code>echo hello &gt; /tmp/hello.txt &amp;&amp;

curl -T /tmp/hello.txt http://httpbin/put
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Sometimes PUT is used for requests in REST APIs. For these, use <code>--request</code> (<code>-X</code>) to set the method and <code>--data</code> (<code>-d</code>) to send the data:</p><pre tabindex="0"><code>curl -X PUT -H &#34;content-type: application/json&#34;
  -d &#39;{&#34;name&#34;: &#34;alice&#34;}&#39;
  http://httpbin/put
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="cookies">Cookies</h3><p>The HTTP protocol is stateless. Cookies are an ingenious way around this:</p><ol><li>The server wants to associate some state with the client session.</li><li>The server returns that state in the Set-Cookie response header.</li><li>The client recognizes the cookies and sends them back with each request in the Cookie request header.</li></ol><p>Each cookie has an expiration date — either explicit one or &#34;end of session&#34; one (for browser clients, this is often when the user closes the browser).</p><p>Curl ignores cookies by default. To enable them, use the <code>--cookie</code> (<code>-b</code>) option. To make curl persist cookies between calls, use <code>--cookie-jar</code> (<code>-c</code>).</p><div><div><figure><img alt="Cookies" src="https://antonz.org/mastering-curl/cookies.jpg"/><figcaption>Although their reputation has been tarnished by the ubiquitous &#34;cookie banners&#34;, cookies remain one of the finest examples of feature naming.</figcaption></figure></div></div><p>Here the server sets the cookie <code>sessionid</code> to <code>123456</code> and curl stores it in the cookie jar <code>/tmp/cookies</code>:</p><pre tabindex="0"><code>curl -b &#34;&#34; -c /tmp/cookies
  http://httpbin/cookies/set?sessionid=123456

&amp;&amp; cat /tmp/cookies
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Subsequent curl calls with <code>-b /tmp/cookies</code> will send the <code>sessionid</code> cookie back to the server.</p><p>Curl automatically discards cookies from the cookie jar when they expire (this requires an explicit expiration date set by the server). To discard session-based cookies, use <code>--junk-session-cookies</code> (<code>-j</code>):</p><pre tabindex="0"><code>curl -j -b /tmp/cookies http://httpbin/get
</code></pre><h3 id="alternative-services">Alternative services</h3><p>The Alt-Svc HTTP response header indicates that there is another network location (an <em>alternative service</em>) that the client can use for future requests.</p><p>To enable alternative services, use <code>--alt-svc</code>. This tells curl to store the services in the specified file and consider them for future requests.</p><pre tabindex="0"><code>curl --alt-svc /tmp/altsvc -o /dev/null
  http://httpbin/get

&amp;&amp; cat /tmp/altsvc
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h3 id="http-strict-transport-security">HTTP Strict Transport Security</h3><p>The HTTP Strict-Transport-Security response header (also known as HSTS) informs the client that the server should only be accessed via HTTPS, and that any future attempts to access it via HTTP should automatically be converted to HTTPS.</p><p>To make curl respect HSTS, use <code>--hsts</code>. This tells curl to store HSTS-enabled servers in the specified file and automatically convert http → https when accessing them.</p><pre tabindex="0"><code>curl --hsts /tmp/hsts -o /dev/null
  http://httpbin/get

&amp;&amp; cat /tmp/hsts
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><h2 id="other-topics">Other topics</h2><p>Since the article is getting huge, I&#39;m going to skip some parts of the video:</p><p>Curl supports protocols like SCP, SFTP, email (IMAP/POP3/SMTP), MQTT, TELNET, DICT, and WebSocket (experimental). Daniel goes over them in the video (FTP in detail, the rest very briefly).</p><p>Curl fully supports TLS (Transport Layer Security, the underlying protocol for HTTPS). You can set a specific minimal allowed TLS version, read certificates from a file, or use client certificates for mutual authentication.</p><p>Curl supports proxies (applications that act as intermediaries between the client and the server). There are HTTP and SOCKS proxies, and of course curl supports both, with or without authentication.</p><p>See the video at <a href="https://youtu.be/V5vZWHP-RqU?t=5809">1:36:09 – 2:20:40</a> and <a href="https://youtu.be/V5vZWHP-RqU?t=12281">3:24:41 - 3:32:40</a> if you are interested.</p><h2 id="future">Future</h2><p>Curl is 25 years old in 2023. It has been growing and improving all these years, and the rate of development is only increasing. The Internet is constantly changing, with new protocols and ways of doing transfers popping up all the time. Curl needs to keep up, so it will continue to grow and add exciting new features!</p><p>There are two great resources if you want to dig deeper:</p><ul><li><a href="https://curl.se/docs/manpage.html">man curl</a></li><li><a href="https://everything.curl.dev/">Everything curl</a></li></ul><p>Here are some final words of wisdom for you:</p><pre tabindex="0"><code>curl http://httpbin/status/418
</code></pre><codapi-snippet sandbox="curl" editor="basic"></codapi-snippet><p>Thank you for reading, and huge thanks to <a href="https://mastodon.social/@bagder">Daniel</a> for his great workshop and the curl tool itself!</p><p><em><a href="https://antonz.org/subscribe/"><i></i> <strong>Subscribe</strong></a>
to keep up with new posts.</em></p></div></div></article></div></div></div>
  </body>
</html>
