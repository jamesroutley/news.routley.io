<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shady-gang.github.io/vcc/">Original</a>
    <h1>Vcc – The Vulkan Clang Compiler</h1>
    
    <div id="readability-page-1" class="page"><article><h2 id="intro">
  Intro
  <a href="#intro">#</a>
</h2>
<p>Vcc - the Vulkan Clang Compiler, is a proof-of-concept C and C++ compiler for Vulkan leveraging Clang as a front-end, and <a href="https://github.com/Hugobros3/shady">Shady</a> our own research IR and compiler. Unlike other shading languages, Vcc aims to stick closely to standard C/C++ languages and merely adds a few new intrinsics to cover GPU features. Vcc is similar to CUDA or Metal in this regard, and aims to bring the advantages of standard host languages to Vulkan shaders<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p>
<p><img src="https://shady-gang.github.io/vcc/vcc.png" alt=""/></p>
<h2 id="key-features">
  Key Features
  <a href="#key-features">#</a>
</h2>
<p>Vcc supports advanced C/C++ features usually left out of shading languages such as HLSL or GLSL, in particular raising the bar when it comes to pointer support and control-flow:</p>
<ul>
<li>Unrestricted pointers
<ul>
<li>Arithmetic is legal, they can be bitcasted to and from integers</li>
</ul>
</li>
<li>Generic pointers
<ul>
<li>Generic pointers do not have an address space in their type, rather they carry the address space as a tag in the upper bits.</li>
</ul>
</li>
<li>True function calls
<ul>
<li>Including recursion, a stack is implemented to handle this in the general case</li>
</ul>
</li>
<li>Function pointers
<ul>
<li>Lets you write code in a functional style on the GPU without limitations</li>
</ul>
</li>
<li>Arbitrary <code>goto</code> statements - code does not need to be strictly structured !</li>
</ul>
<p>Many of these capabilities are present in compute APIs, but are not supported in most graphics APIs such as DirectX or Vulkan. We aim to address this gap by proving these features can and should implemented. <a href="https://shady-gang.github.io/vcc/why">More on why we think that’s important</a></p>
<h2 id="status-and-caveats">
  Status and Caveats
  <a href="#status-and-caveats">#</a>
</h2>
<p>Vcc is still a work-in-progress. While we do commit to making all the previously mentioned features work reliably, and generally attempt to bring the entirety of C and C++ to the GPU without sub-setting, there are still limitations:</p>
<ul>
<li>Certain functions, such as <code>malloc</code>/<code>free</code> require communicating with the host kernel which we currently do not implement.</li>
<li>Non header-only libraries, including parts of the C and C++ standard libraries, will not work on the GPU without additional work, because of the way Vcc works.
<ul>
<li>While addressable, this would massively increase the scope of the project.</li>
<li>For now it’s best to think of Vcc as only supporting a <code>-ffreestanding</code> dialect of C/C++</li>
</ul>
</li>
<li>C++ exceptions and their corresponding LLVM instructions (<code>landingpad</code> etc) are not supported.</li>
<li>Function and data pointers are not portable between host and device. Taking addresses and passing them across in either direction is UB - since Vulkan lacks a unified addressing extension this is a limitation we cannot address at this time.</li>
</ul>
<h2 id="sample-code">
  Sample code
  <a href="#sample-code">#</a>
</h2>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;shady.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>descriptor_set</span>(<span>0</span>) <span>descriptor_binding</span>(<span>1</span>) uniform sampler2D texSampler;
</span></span><span><span>
</span></span><span><span><span>location</span>(<span>0</span>) input vec3 fragColor;
</span></span><span><span><span>location</span>(<span>1</span>) input vec2 fragTexCoord;
</span></span><span><span>
</span></span><span><span><span>location</span>(<span>0</span>) output vec4 outColor;
</span></span><span><span>
</span></span><span><span>fragment_shader <span>void</span> <span>main</span>() {
</span></span><span><span>    outColor <span>=</span> <span>texture2D</span>(texSampler, fragTexCoord) <span>*</span> (vec4) { fragColor.x <span>*</span> <span>2.5f</span>, fragColor.y <span>*</span> <span>2.5f</span>, fragColor.z <span>*</span> <span>2.5f</span>, <span>1.0f</span> };
</span></span><span><span>}
</span></span></code></pre></div>
</article></div>
  </body>
</html>
