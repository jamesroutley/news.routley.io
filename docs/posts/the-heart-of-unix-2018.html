<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ericnormand.me/article/the-heart-of-unix">Original</a>
    <h1>The Heart of Unix (2018)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Despite all of its warts, I like working in Linux. I&#39;ve used it for 15
years and I&#39;ve never been as productive in another environment. Most
people claim that it&#39;s the configurability of Linux that keep the users
coming. That may have attracted me at first, but <strong>what attracts me now
is its programmability.</strong></p>
<p>Let me be very clear. I&#39;m not saying that Linux is great because I can
patch the source code to grep and recompile it. In all my years of Unix,
I&#39;ve never done anything like that. And I&#39;m not saying that Linux is a
great workstation for programmers because it helps you program better.
Those are topics for another essay.</p>
<h3>Unix is a programmable environment</h3>
<p>I <em>am</em> saying that Unix is a programmable environment. When you interact
with the shell, <strong>you are writing programs to be interpreted</strong>. You can
easily extend the Unix system by writing a shell script, copying it to a
directory in your <code>PATH</code>, and making it executable. Boom. You&#39;ve got a
new program.</p>
<p>What&#39;s more, that program, if it follows certain simple conventions, is
now able to work with other programs. Those conventions are simple, and
they are summed up well by Doug McIlroy, the inventor of Unix pipes:</p>
<blockquote>
<p>This is the Unix philosophy: Write programs that do one thing and do
it well. Write programs to work together. Write programs to handle
text streams, because that is a universal interface.</p>
</blockquote>
<p>If your program <em>reads text lines from standard in and writes text lines
on standard out</em>, it is likely to do well on Unix.</p>
<h3>Programs on your path are like pure functions in the higher-level language called the shell</h3>
<p>Not all programs are so pure. But the vast majority of the programs that
are so typically Unixy are. <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>wc</code>, <code>pr</code>, etc.</p>
<h3>Unix is a multi-lingual environment</h3>
<p>I must have compilers or interpreters for 30 languages on my machine.
Maybe more. All of these languages are invited to the party. They can
all call each other (through the shell). And of course their
<code>stdin</code>/<code>stdouts</code> can be piped together.</p>
<p>You really can use the best tool for the job. I&#39;ve got Bash scripts, awk
scripts, Python scripts, some Perl scripts. What I program in at the
moment depends on my mood and practical considerations. It is a little
crazy that <strong>I don&#39;t have to think about what language something is
written in when I&#39;m at the terminal</strong>.</p>
<h3>Unix provides a universal interface with a universal data structure</h3>
<p>It needs to be stated that there is a reason all of these languages can
work together. There is a standard data structure that programs are
invited to use: text streams. That means sequences of characters. Text
streams are cool because they&#39;re simple and flexible. <strong>You can impose a
structure on top of the flat sequence.</strong> For instance, you can break it
into a sequence of sequences of characters by splitting it on a certain
character (like new-line). Then you can split those sequences into
columns. In short, text is flexible.</p>
<h3>Unix is homoiconic</h3>
<p>There&#39;s another property that I think is rarely talked about in the
context of Unix. In Lisp, we often are proud that code is data. You can
manipulate code with the same functions that you manipulate other data
structures. This meta-circularity gives you a lot of power.</p>
<p>But this is the same in Unix. <strong>Your programs are text files</strong> and so
can be <code>grep</code>&#39;d and <code>wc</code>&#39;d and anything else if you want to. You can
open up a pipe to Perl and feed it commands, if you like. And this feeds
right back into Unix being programmable.</p>
<h3>Functional + universal data structure + homoiconic = power</h3>
<p>All of this adds up to synergy. When you write a program that follows
the Unix conventions of <code>stdin</code>/<code>stdout</code> with text streams, <strong>it can
work with thousands of programs that are already on your computer</strong>.
What&#39;s more, your program has to do less work itself, because so much of
the hard work can be done better by other programs.</p>
<h3>On the file system, hierarchical names point to data objects</h3>
<p>And this synergy extends well beyond just using text streams. I have
this tendency to look to databases as storage solutions for my personal
projects. They have some nice properties, like ACID and SQL.But by using
a database, I&#39;m missing out on joining the Unix ecosystem. <strong>If I use
the file system to store my data---meaning text files in directories---I
can use all of Unix to help me out.</strong> I can use <code>find</code>, <code>grep</code>, <code>head</code>,
<code>tail</code>, etc., just because I chose to use the measly file system instead
of some fancy database.</p>
<h3>Blog example</h3>
<p>A good example of the synergy I&#39;m talking about is the blog you are
reading now. Here&#39;s how my blog works:</p>
<p>I store everything on the file system. I have an <code>src/</code> directory with
<code>drafts/</code> <code>posts/</code> <code>pages/</code> and <code>links/</code>. I wrote a Python script
(currently at 183 well-commented lines) that reads <code>src/</code> and spits out
the final product to <code>build/</code>. The Python uses a few libraries, but the
meat of it is done by calling other programs. The rendering of Markdown
to HTML is done by <a href="http://johnmacfarlane.net/pandoc/"><code>pandoc</code></a>, which
happens to be written in Haskell. I also do a call out to the shell to
copy a directory (<code>cp -rp</code>) because I was too lazy to figure out how to
do it in pure Python.</p>
<p>I sync <code>build/</code> to Amazon S3 with a Ruby program called <code>s3sync</code>. I edit
my entries in Emacs. If I need to delete a post, I run <code>rm</code>. If I need
to list my posts, I run <code>ls</code>. If I&#39;d like to change the name of a post,
I use <code>mv</code>.</p>
<p>It may not be the best interface for writing a blog. But notice all of
the stuff I didn&#39;t have to write to get started. I&#39;m already writing
posts and publishing them. <strong>Compare that to the reams of PHP and
Javascript it takes to get the same functionality in Wordpress.</strong> That&#39;s
the power of small tools working together.</p>
<h3>Unix is old</h3>
<p>Now that I&#39;ve expressed how great Unix is, allow me to speak about its
numerous shortcomings. I can&#39;t say for sure, but I would guess that most
of the shortcomings are due to the long history of <strong>Unix starting on
underpowered machines</strong>.</p>
<p>For instance, the fact that your programs have to be manually stored to
disk using file system operations so that your dynamic shell language
can have access to them seems awfully quaint. But when Unix was
developed, disk space, RAM, and computation were expensive. Everything
was expensive. So the strategy was to <strong>cache your compiler output to
disk</strong> so you wouldn&#39;t have to do a costly compile step each time you
ran a program.</p>
<p>If I want to write a new program, even a short one, I have to open up a
text file in Emacs (make sure it&#39;s in the path!), write the program,
save it, switch to the terminal, and <code>chmod +x</code> it. Compare that to
Clojure, where you constantly define and redefine functions at the REPL.
Or, if you like, a Smalltalk system where you can open up the editing
menu of <em>anything you can see</em> and change the code which will then be
paged out to disk at a convenient time. Unix clearly has room to grow in
that respect.</p>
<h3>The file system</h3>
<p>The file system is archaic, too. It&#39;s reliable, but a little
feature-poor. It&#39;s one of the reasons I think first about a database
before remembering the synergy available with the file system. It
doesn&#39;t provide any kind of ACID properties. The metadata available is
laughable (permissions, owner/group, date, and filesize?). <strong>A more
modern file system would give a little more oomph</strong> to compete with
other forms of storage.</p>
<h3>The terminal</h3>
<p><strong>The terminal is just old.</strong> It&#39;s all text. The editing is
sub-primitive. The help it gives you is the bare minimum. One of its
biggest shortcomings is how opaque it is. It doesn&#39;t do much to help you
learn commands. It&#39;s not very good with huge dumps on <code>stdout</code>.
Multiline commands? Supported with <code>\</code>. I think we can do better.</p>
<h3>Text streams</h3>
<p>The world of computers has grown up a lot since the early days of Unix.
There has been a Cambrian explosion in the number of file formats. Lots
of them are binary formats. Lots are structured text, like XML or JSON.
Unix can handle those kinds of files, but <strong>it has failed to find a
lever to help the Unix user master them with the same synergy you see
with flat text files</strong>.</p>
<h3>Wrong turns</h3>
<p>Uni
x has a long history. Some of that history was kind, some was unkind.
Most of the development of Unix was just practical people doing their
best with the tools they had.</p>
<p>What&#39;s unfortunate is that we now have better tools and we see what
could be done, but to do it would break backwards compatibility. And so
we continue with sub-optimal tools.</p>
<h3>Layering instead of evolving</h3>
<p>One thing I think is unfortunate in the world of Unix today is layering.
<strong>Modern Linux distributions are midden piles of configuration daemons
to manage permissions daemons to give your configuration GUI access to
the configuration daemons.</strong> Or we find ourselves installing a database
to manage a few kilobytes of metadata.</p>
<p>The problem is Unix has not evolved in those areas. The permission
system has changed very little. Modern distributions want to provide a
modern and unintrusive interface to protected resources, so they add a
layer of indirection onto the primitive permissions model instead of
evolving the permission system itself. The Unix permissions system is
solid and has worked for years. Maybe it should stay. But instead of
giving us small programs that do one thing well to let us become masters
of the permissions system, <strong>we get obtuse, opaque daemons</strong> that also
need to be learned.</p>
<p>The file system, though much improved in terms of capacity, stability,
and reliability, still has the same basic features: hierarchical
directories containing files, accessed by name. If you want something
more, you have to add a layer like BerkeleyDB or SQLite. These tools are
great, but I&#39;d like to see a more Unixy solution that allows for the
synergy you get from existing programs made to run with files on the
disk.</p>
<h3>Megacommands</h3>
<p><a href="https://gist.github.com/1091803">Command bloat</a> <a href="https://gist.github.com/665971">is
terrible</a>. Rob Pike and Brian Kernighan
have <a href="http://harmful.cat-v.org/cat-v/">written about this</a>. I&#39;ll merely
refer you to their <a href="https://ericnormand.me/files/papers/unix_prog_design.pdf">excellent
paper</a>. The gist is that having n
commands gives yo
u O(n^2^) ways of combining them. <strong>Having fewer,
bigger, &#34;more powerful&#34; programs does not give you this exponential and
synergistic advantage.</strong></p>
<p>If you look at it the right way, all of these little programs that do
one thing are like functions in the higher-level language that is Unix.
We see that languages like Perl and Python have huge numbers of
libraries for doing all sorts of tasks. Those libraries are only
accessible through the programming language they were developed for.
This is a missed opportunity for the languages to interoperate
synergistically with the rest of the Unix ecosystem.</p>
<h3>The road ahead</h3>
<p>I&#39;ve given a bit of a taste of some of the non-Unixy directions we&#39;re
going in. Now I&#39;d like to end with some right directions.</p>
<p>I mentioned before that saving a compiled binary to disk is done to
cache what used to be an expensive operation. With modern hardware, a
short utility C program could be read in, parsed, compiled, and run very
quickly. Probably with no noticeable delay. It&#39;s something to consider
when thinking about the division between static programs and dynamic
scripting languages and the role of the compiler.</p>
<h3>Talking to Unix</h3>
<p>Foreign Function Interfaces between programming languages are considered
very difficult to work with because of the semantics mismatch between
any two languages. But Unix provides a universal interface for programs
to <strong>interoperate without the need for FFI</strong>. I hope to see more &#34;sugar&#34;
in languages to take advantage of calling out to other programs for
help. <a href="http://stackoverflow.com/questions/799968/whats-the-difference-between-perls-backticks-system-and-exec">Perl&#39;s
backticks</a>
comes to mind.</p>
<p>You might say that this is expensive. Well, yes and no. Yes, there is
much more overhead in reading in who-knows-how-many files to execute
some script on disk than in just calling some library function. I argue,
though, that <strong>the time difference is becoming small enough not to
matter</strong>; and the operating system should evolve to make it more
practical.</p>
<h3>Evolving</h3>
<p><code>stdin</code>/<code>stdout</code></p>
<p>Stdin/stdout with text streams is the closest thing we have to a
universal, language-agnostic interface. It defines a minimal
&#34;constitution&#34; with which programs can interact. <strong>Can this interface be
improved on without destroying it?</strong> I wouldn&#39;t doubt it. There are lots
of &#34;data flow&#34; patterns besides input and output. Pub/sub, broadcast,
dispatch, etc., should be explored.</p>
<h3>Text streams, evolved</h3>
<p>Unix was designed for flat text and the existing Unix tools operate on
text. We need new tools to <strong>bring structured text and binary into the
Unix world</strong> to join the party. I don&#39;t think this would be hard. I&#39;ve
written programs that read in JSON and write it out with one JSON object
per line. That lets you grep it to find the one you want, or <code>wc -l</code> it
to count the objects.</p>
<p>Another thing I&#39;ve been working on is defining a dispatch mechanism for
common operations on files of different types. Take, for instance,
metadata that is stored in a file. An HTML file has a title, sometimes
it has an author (in a meta tag), etc. A JPEG file has metadata in the
EXIF data. <strong>Is there some way we can unify the access of that
metadata?</strong> I think there is and I&#39;m working on it. The same command
would dispatch differently based on mime-type.</p>
<h3>21st Century Terminal</h3>
<p>How can we improve the terminal? I think it&#39;s a hard problem but not
impossible. Part of the issue with the terminal is that as X Windows
developed, people started using menus to run monolithic programs instead
of piping things with the shell. So the usefulness of the terminal will
be improved, without changing the terminal itself, by <strong>breaking those
monolithic programs up into composable programs</strong>. For instance, a
program which displays all of the thumbnails of the files listed on
<code>stdin</code> would be much more useful to me than a mouse-oriented file
browser.</p>
<p>The terminal is about text. I don&#39;t think that could or should change.
But does it have to be only about text?
<a href="http://acko.net/blog/on-termkit">Explorations</a> are underway.</p>
<h3>The Shell</h3>
<p>The last improvement I want to touch on is the shell language itself.
Bash is ugly. There. I said it. A lot of good work has been done in
programming language design and I&#39;d like to see some of it make its way
to the shell. <strong>What if we take the idea of Unix programs as pure
functions over streams of data a little further?</strong> What about
higher-order functions? Or function transformations? Combinators? <strong>What
if we borrow from object-oriented languages?</strong> Can we have message
passing? What about type-based dispatching?</p>
<h3>Conclusions</h3>
<p>Unix has always been practical and it has proven itself over the years.
It&#39;s 40 years old and it&#39;s still being used. Furthermore, Unix is the
closest thing to a personal computing experience^1 that is practical
today.</p>
<p>People tend to <a href="https://ericnormand.me/files/papers/LispGoodNewsBadNews.pdf">contrast Unix</a>
with systems like the Lisp Machine and Smalltalk. But I see <strong>more
similarities than differences</strong>: <em>Code as data.</em> <em>Everything is
programmable.</em> <em>Dynamic language prompt.</em> <em>Universal data structure.</em> <em>A
propensity for &#34;dialects&#34; or &#34;distributions&#34;.</em> <em>Garbage collection.</em>^2
Unix just made a lot of compromises to make it practical on the limited
hardware that was available.</p>
<p>Unfortunately, those compromises have stuck. A lot of work went into
workarounds and a lot of software has been built on top of those design
decisions. The question is: <strong>where to go from here?</strong></p>
<p>My own personal choice is to go <strong>back to the roots</strong>. Often, when we
want to make a change, we must look to what has worked in the past. What
has brought us this far? What were the things that made Unix special?
Unix was built by individuals all adding their own practical knowledge
and hard work into one cohesive system. Their individual work was
multiplied by the synergy of a common interface. If we want to evolve
Unix (and I do), that common interface---the heart of Unix---is the
place to start.</p>
<hr/>
<ol>
<li>
<p>When I say &#34;personal computer&#34;, I&#39;m referring to <a href="http://www.mprove.de/diplom/gui/kay72.html">Alan Kay&#39;s
vision</a>:</p>
<blockquote>
<p>What then is a personal computer? One would hope that it would be
both a medium for containing and expressing arbitrary symbolic
notions, and also a collection of useful tools for manipulating
these structures, with ways to add new tools to the repertoire.</p>
</blockquote>
</li>
<li>
<p>Unix has a limited form of garbage collection. Short-running
programs (like those executed at the terminal) need not concern
themselves with freeing allocated memory since the OS will free
everything when they exit.</p>
</li>
</ol></div></div>
  </body>
</html>
