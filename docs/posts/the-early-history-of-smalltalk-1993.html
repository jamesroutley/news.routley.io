<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/">Original</a>
    <h1>The Early History of Smalltalk (1993)</h1>
    
    <div id="readability-page-1" class="page">
	<p><a href="https://raw.githubusercontent.com/worrydream/EarlyHistoryOfSmalltalk/master/SmalltalkHistoryHOPL-scanned-2015-07-16.pdf">original pdf</a> / <a href="https://github.com/worrydream/EarlyHistoryOfSmalltalk">make corrections</a></p>
	
	<p>
	<i>Alan C. Kay</i></p>

        <p>
	  Permission to copy without fee all or part of this material is
	  granted provided that the copies are not made or distributed for
	  direct commercial advantage, the ACM copyright notice and the
	  title of the publication and its date appear, and  notice is given
	  that copying is by permission of the Association for Computing
	  Machinery.  To copy otherwise, or to republish, requires a fee
	  and/or specific permission.</p>

	<h2>Abstract</h2>

		<p>
		Most ideas come from previous ideas.  The sixties, particularly in the ARPA
		community, gave rise to a host of notions about &#34;human-computer symbiosis&#34;
		through interactive time-shared computers, graphics screens and pointing 
		devices. Advanced computer languages were invented to simulate complex systems
		such as oil refineries and semi-intelligent behavior.  The soon-to-follow paradigm
		shift of modern personal computing, overlapping window interfaces, and 
		object-oriented design came from seeing the work of the sixties as something
		more than a &#34;better old thing.&#34;  That is, more than a better way: to do mainframe
		computing; for end-users to invoke functionality; to make data structures more
		abstract.  Instead the promise of exponential growth in computing/$/volume
		demanded that the sixties be regarded as &#34;<i>almost</i> a new thing&#34; and to find out
		what the actual &#34;new things&#34; might be.  For example, one would compute with a
		handheld &#34;Dynabook&#34; in a way that would not be possible on a shared mainframe;
		millions of potential users meant that the user interface would have to
		become a learning environment along the lines of Montessori and Bruner; and
		needs for large scope, reduction in complexity, and end-user literacy would 
		require that data and control structures be done away with in favor of a more
		biological scheme of protected universal cells interacting only through messages
		that could mimic any desired behavior.
		</p>
		<p>
		Early Smalltalk was the first complete realization of these new points of view
		as parented by its many predecessors in hardware, language and user interface
		design.  It became the exemplar of the new computing, in part, because we were
		actually trying for a qualitative shift in belief structures—a new Kuhnian paradigm
		in the same spirit as the invention of the printing press—and thus took 
		highly extreme positions which almost forced these new styles to be invented.
		</p>
	
	<h2>Table of Contents</h2>

          <ul>
            <li>Introduction <a href="#p2">2</a></li>

	    <li>I. 1960-66—Early OOP and other formative ideas of the sixties
              <a href="#p4">4</a>
              <ul>
		<li>B220 File System</li>
		<li>SketchPad &amp; Simula</li>
              </ul>
            </li>

	    <li>II 1967-69—The FLEX Machine, an OOP-based personal computer
              <a href="#p6">6</a>
              <ul>
                <li>Doug Englebart and NLS</li>
		<li>Plasma Panel, GRAIL, LOGO, Dynabook</li>
              </ul>
            </li>

	    <li>III. 1970-72—Xerox PARC <a href="#p12">12</a>
              <ul>
                <li>KiddiKomp</li>
		<li>miniCOM</li>
		<li>Smalltalk-71</li>
		<li>Overlapping Windows</li>
		<li>Font Editing, Painting, Animation, Music</li>
		<li>Byte Codes</li>
		<li>Iconic Programming</li>
              </ul>
            </li>

	    <li>IV. 1972-76—Xerox PARC: The first real Smalltalk (-72)
              <a href="#p17">17</a>
              <ul>
	        <li>The two bets: birth of Smalltalk and Interim Dynabook</li>
	        <li>Smalltalk-72 Principles</li>
	        <li>The Smalltalk User Interface</li>
	        <li>Development of the Smalltalk Applications &amp; System</li>
	        <li>Evolution of Smalltalk: ST-74, ooze storage management</li>
	        <li><a href="#smalltalkAndChildren">Smalltalk and Children</a>
              </li></ul>
            </li>

	    <li>V. 1976-80—The first modern Smalltalk (-76) <a href="#p29">29</a>
              <ul>
		<li>&#34;Let&#39;s burn our disk packs&#34;</li>
		<li>The Notetaker</li>
		<li>Smalltalk-76</li>
		<li>Inheritance</li>
		<li>More Troubles With Xerox</li>
		<li>ThingLab</li>
		<li>Apple Demo</li>
              </ul>
            </li>

	    <li>VI. 1980-83—The release version of Smalltalk (-80) <a href="#p38">38</a>
              <ul>
	        <li>Transformations</li>
	        <li><a href="#coda">Coda</a></li>
              </ul>
            </li>

	    <li>References Cited in Text <a href="#p41">41</a></li>
	    <li>Appendix I: KiddiKomp Memo <a href="#p45">45</a></li>
	    <li>Appendix II: Smalltalk-72 Interpreter Design <a href="#p47">47</a></li>
	    <li>Appendix III: Acknowledgments <a href="#p50">50</a></li>
	    <li>Appendix IV: Event Driven Loop Example <a href="#p53">53</a></li>
	    <li>Appendix V: Smalltalk-76 Internal Structures <a href="#p54">54</a></li>

          </ul>

          <div>
	    <p> —To Dan Ingalls, Adele Goldberg and the rest of Xerox PARC LRG gang </p>
	    <p> —To Dave Evens, Bob Barton, Marvin Minsky, and Seymour Papert </p>
	    <p> —To SKETCHPAD, JOSS, LISP, and SIMULA, the 4 great programming conceptions of the sixties </p>
          </div>


	<h2><a name="p2">Introduction</a></h2>

		<p>
		I&#39;m writing this introduction in an airplane at 35,000 feet.  On my lap is a five pound
		notebook computer—1992&#39;s &#34;Interim Dynabook&#34;—by the end of the year it sold for under $700.  It
		has a flat, crisp, high-resolution bitmap screen, overlapping windows, icons, a pointing device,
		considerable storage and computing capacity, and its best software is object-oriented.  It has
		advanced networking built-in and there are already options for wireless networking.
		Smalltalk runs on this system, and is one of the main systems I use for my current work with
		children.  In some ways this is more than a Dynabook (quantitatively), and some ways not
		quite there yet (qualitatively).  All in all, pretty much what was in mind during the late sixties.
		</p>
		<p> Smalltalk was part of this larger pursuit of ARPA, and later of Xerox PARC, that I called <i>personal
		computing.</i>  There were so many people involved in each stage from the research communities
		that the accurate allocation of credit for ideas is intractably difficult.  Instead, as Bob Barton
		liked to quote Goethe, we should &#34;share in the excitement of discovery without vain attempts
		to claim priority.&#34;
		</p>
		<p>
		I will try to show where most of the influences came from and how they were transformed 
		in the magnetic field formed by the new personal computing metaphor.  It was the <i>attitudes</i> as 
		well as the great ideas of the pioneers that helped Smalltalk get invented.  Many of the people I
		admired most at this time—such as Ivan Sutherland, Marvin Minsky, Seymour Papert, Gordon
		Moore, Bob Barton, Dave Evans, Butler Lampson, Jerome Bruner, and others—seemed to have
		a splendid sense that their creations, though wonderful by relative standards, were not near to
		the absolute thresholds that had to be crossed.  Small minds try to form religions, the great ones
		just want better routes up the mountain.  Where Newton said he saw further by standing on the 
		shoulders of giants, computer scientists all too often stand on each other&#39;s toes.  Myopia is
		still a problem where there are giants&#39; shoulders to stand on—&#34;outsight&#34; is better than
		insight—but it can be minimized by using glasses whose lenses are highly sensitive to 
		esthetics and criticism.
		</p>
		<p>
		Programming languages can be categorized in a number of ways: imperative, applicative, 
		logic-based, problem-oriented, etc.  But they all seem to be either an &#34;agglutination of features&#34;
		or a &#34;crystallization of style.&#34;  COBOL, PL/1, Ada, etc., belong to the first kind; LISP, APL—
		and Smalltalk—are the second kind.  It is probably not an accident that the agglutinative languages
		all seem to have been instigated by committees, and the crystallization languages by a single person.
		</p>
		<p>
		Smalltalk&#39;s design—and existence—is due to the insight that everything we can describe can be
		represented by the recursive composition of a single kind of behavioral building block that hides its
		combination of state and process inside itself and can be dealt with only through the exchange of
		messages.  Philosophically, Smalltalk&#39;s objects have much in common with the monads of Leibniz and
		the notions of 20th century physics and biology.  Its way of making objects is quite Platonic in that
		some of them act as idealizations of concepts—<i>Ideas</i>—from which <i>manifestations</i> can be created.  That
		the Ideas are themselves manifestations (of the Idea-Idea) and that the Idea-Idea is <i>a-kind-of</i>
		Manifestation-Idea—which is a-kind-of itself, so that the system is completely self-describing—
		would have been appreciated by Plato as an extremely practical joke [Plato].
		</p>
		<p>
		In computer terms, Smalltalk is a recursion on the notion of computer itself.  Instead of dividing
		&#34;computer stuff&#34; into things each less strong than the whole—like data structures, procedures, and
		functions which are the usual paraphernalia of programming languages—each Smalltalk object is a
		recursion on the entire possibilities of the computer.  Thus its semantics are a bit like having thousands
		and thousands of computers all hooked together by a very fast network.  Questions of concrete representation
		can thus be postponed almost indefinitely because we are mainly concerned that the computers
		behave appropriately, and are interested in particular strategies only if the results are off or
		come back too slowly.
		</p>
		<p>
		Though it has noble ancestors indeed, Smalltalk&#39;s contribution is a new design paradigm—which I
		called <i>object-oriented</i>—for attacking large problems of the professional programmer, and making
		small ones possible for the novice user.  Object-oriented design is a successful attempt to qualitatively
		improve the efficiency of modeling the ever more complex dynamic systems and user relationships
		made possible by the silicon explosion.
		</p>
		<p>
		&#34;We would know what they thought</p>
		<p>
		&#34;Memory and imagination are but two</p>
		<p>
		In this history I will try to be true to Hamming&#39;s request as moderated by Hobbes&#39; observation.  I
		have had difficulty in previous attempts to write about Smalltalk because my emotional involvement
		has always been centered on personal computing as an amplifier for human reach—rather than 
		programming system design—and we haven&#39;t got there yet.  Though I was the instigator and original
		designer of Smalltalk, it has always belonged more to the people who make it work and got it out the
		door, especially Dan Ingalls and Adele Goldberg.  Each of the LRGers contributed in deep and remarkable
		ways to  the project, and I wish there was enough space to do them all justice.  But I think all of
		us would agree that for most of the development of Smalltalk, Dan was the central figure.
		Programming is at heart a practical art in which real things are built, and a real implementation thus
		has to exist.  In fact many if not most languages are in use today not because they have any real merits
		but because of their existence on one or more machines, their ability to be bootstrapped, etc.  But Dan
		was far more than a great implementer, he also became more and more of the designer, not just of the
		language but also of the user interface as Smalltalk moved into the practical world.
		</p>
		<p>
		Here, I will try to center focus on the events leading up to Smalltalk-72 and its transition to its
		modern form as Smalltalk-76.  Most of the ideas occurred here, and many of the earliest stages of OOP
		are poorly documented in references almost impossible to find.
		</p>
		<p>
		This history is too long, but I was amazed at how many people and systems that had an influence
		appear only as shadows or not at all.  I am sorry not to be able to say more about Bob Balzer, Bob 
		Barton, Danny Bobrow, Steve Carr, Wes Clark, Barbara Deutsch, Peter Deutsch, Bill Duvall, Bob
		Flegal, Laura Gould, Bruce Horn, Butler Lampson, Dave Liddle, William Newman, Bill Paxton,
		Trygve Reenskaug, Dave Robson, Doug Ross, Paul Rovner, Bob Sproull, Dan Swinehart, Bert
		Sutherland, Bob Taylor, Warren Teitelman, Bonnie Tennenbaum, Chuck Thacker, and John Warnock.
		Worse, I have omitted to mention many systems whose design I detested, but that generated considerable
		useful ideas and attitudes in reaction.  In other words &#34;histories&#34; should not be believed very
		seriously but considered as &#34;FEEBLE GESTURES OFF&#34; done long after the actors have departed the stage.
		</p>
		<p>
		Thanks to the numerous reviewers for enduring the many drafts they had to comment on.  Special
		thanks to Mike Mahoney for helping so gently that I heeded his suggestions and so well that they
		greatly improved this essay—and to Jean Sammet, an old old friend, who quite literally frightened
		me into finishing it—I did not want to find out what would happen if I were late.   Sherri McLoughlin
		and Kim Rose were of great help in getting all the materials together.
		</p>

	<h2><a name="p4">I. 1960-66—Early OOP and other formative ideas of the sixties</a></h2>

		<p>
		Though OOP came from many motivations, two were central.  The large scale one was to find a better
		module scheme for complex systems involving hiding of details, and the small scale one was to
		find a more flexible version of assignment, and then to try to eliminate it altogether.  As with most
		new ideas, it originally happened in isolated fits and starts.
		</p>
		<p>
		New ideas go through stages of acceptance, both from within and without.  From within, the
		sequence moves from &#34;barely seeing&#34; a pattern several times, then noting it but not perceiving its
		&#34;cosmic&#34; significance, then using it operationally in several areas, then comes a &#34;grand rotation&#34; in
		which the pattern becomes the center of a new way of thinking, and finally, it turns into the same
		kind of inflexible religion that it originally broke away from.  From without, as Schopenhauer noted,
		the new idea is first denounced as the work of the insane, in a few years it is considered obvious and
		mundane, and finally the original denouncers will claim to have invented it.
		</p>


		<p>
		True to the stages, I &#34;barely saw&#34; the idea several times ca. 1961 while a programmer in the Air 
		<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/b220.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/b220.jpg" alt="b220 file format"/></a>
		Force.  The first was on the Burroughs 220 in the form of a style for
		transporting files from one Air Training Command installation to
		another.  There were no standard operating systems or file formats
		back then, so some (to this day unknown) designer decided to
		finesse the problem by taking each file and dividing it into three
		parts.  The third part was all of the actual data records of arbitrary
		size and format.  The second part contained the B220 procedures
		that knew how to get at records and fields to copy and update the
		third part.  And the first part was an array or relative pointers 
		into entry points of the procedures in the second part (the initial pointers
		were in a standard order representing standard meanings).
		Needless to say, this was a great idea, and was used in many subsequent systems until the enforced
		use of COBOL drove it out of existence.
		</p>
		<p>
		The second barely-seeing of the idea came just a little later when ATC decided to replace the 220
		with a B5000.  I didn&#39;t have the perspective to really appreciate it at the time, but I did take note of its
		segmented storage system, its efficiency of HLL compilation and byte-coded execution, its automatic
		mechanisms for subroutine calling and multiprocess switching, its pure code for sharing, its protection
		mechanisms, etc.  And, I saw that the access to its Program Reference Table corresponded to the
		220 file system scheme of providing a procedural interface to a module.  However, my big hit from
		this machine at this time was not the OOP idea, but some insights into HLL translation and evaluation.
		[Barton, 1961] [Burroughs, 1961]
		</p>
		<p>
		After the Air Force, I worked my way through the rest of college by programming mostly retrieval
		<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/mooreslaw.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/mooreslaw.jpg" alt="Moore&#39;s Law graph"/></a>
		systems for large collections of weather data for the National 
		Center for Atmospheric Research.  I got interested in simulation
		in general—particularly of one machine by another—but aside
		from doing a one-dimensional version of a bit-field block transfer
		(bitblt) on a CDC 6600 to simulate word sizes of various
		machines, most of my attention was distracted by school, or I 
		should say the theatre at school.  While in Chippewa Falls helping
		to debug the 6600, I read an article by Gordon Moore which
		predicted that integrated silicon on chips was going to exponentially
		improve in density and cost over many years [Moore 65].
		At the time in 1965, standing next to the room-sized freon-cooled
		10 MIP 6600, his astounding predictions had little projection
		into my horizons.
		</p>
		
		<h3>Sketchpad and Simula</h3>
	
		<p>Through a series of flukes, I wound up in graduate school at the University of Utah in the Fall of
		1966, &#34;knowing nothing.&#34;  That is to say, I had never heard of ARPA or its projects, or that Utah&#39;s main
		goal in this community was to solve the &#34;hidden line&#34; problem in 3D graphics, until I actually
		walked into Dave Evans&#39; office looking for a job and a desk.  On Dave&#39;s desk was a foot-high stack of
		brown covered documents, one of which he handed to me: &#34;Take this and read it.&#34;
		</p>
		<p>
		Every newcomer got one.  The title was &#34;Sketchpad: A man-machine graphical communication 
		system&#34; [Sutherland, 1963].  What it could do was quite remarkable, and completely foreign to any use of
		a computer I had ever encountered.  The three big ideas that were easiest to grapple with were: it was
		the invention of modern interactive computer graphics; things were described by making a &#34;master
		drawing&#34; that could produce &#34;instance drawings&#34;; control and dynamics were supplied by
		&#34;constraints,&#34; also in graphical form, that could be applied to the masters to shape an inter-related parts.
		Its data structures were hard to understand—the only vaguely familiar construct was the embedding
		of pointers to procedures and using a process called reverse indexing to jump through them to 
		routines, like the 220 file system [Ross, 1961].  It was the first to have clipping and zooming 
		windows—one &#34;sketched&#34; on a virtual sheet about 1/3 mile square!
		</p>

                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/sketchpad.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/sketchpad.jpg" alt="Sketchpad"/></a>

		<p>
		Head whirling, I found my desk.  On it was a pile of tapes and listings, and a note: &#34;This is the
		Algol for the 1108.  It doesn&#39;t work.  Please make it work.&#34;  The latest graduate student gets the latest
		dirty task.
		</p>
		<p>
		The documentation was incomprehensible.  Supposedly, this was the Case-Western Reserve 1107
		Algol—but it had been doctored to make a language called Simula; the documentation read like
		Norwegian transliterated into English, which in fact it was.  There were uses of words like <i>activity</i> and
		<i>process</i> that didn&#39;t seem to coincide with normal English usage.
		</p>
		<p>
		Finally, another graduate student and I unrolled the program listing 80 feet down the hall and
		crawled over it yelling discoveries to each other.  The weirdest part  was the storage allocator, which
		did not obey a stack discipline as was usual for Algol.  A few days later, that provided the clue.  What
		Simula was allocating were structures very much like the instances of Sketchpad.  There were descriptions
		that acted like masters and they could create instances, each of which was an independent entity.
		What Sketchpad called masters and instances, Simula called activities and processes.  Moreover,
		Simula was a procedural language for controlling Sketchpad-like objects, thus having considerably
		more flexibility than constraints (though at some cost in elegance) [Nygaard, 1966, Nygaard, 1983].
		</p>
		<p>
		This was the big hit, and I&#39;ve not been the same since.  I think the reason the hit had such impact
		was that I had seen the idea enough times in enough different forms that the final recognition was in
		such general terms to have the quality of an epiphany.  My math major had centered on abstract algebras
		with their few operations generally applying to many structures.  My biology major had focused
		on both cell metabolism and larger scale morphogenesis with its notions of simple mechanisms 
		controlling complex processes and one kind of building block able to differentiate into all needed building
		blocks.  The 220 file system, the B5000, Sketchpad, and finally Simula, all used the same idea
		for different purposes.  Bob Barton, the main designer of the B5000 and a professor at Utah had said in
		one of his talks a few days earlier: &#34;The basic principle of recursive design is to make the parts have
		the same power as the whole.&#34;  For the first time I thought of the whole as the entire computer and
		wondered why anyone would want to divide it up into weaker things called data structures and
		procedures.  Why not divide it up into little computers, as time sharing was starting to?  But not in
		dozens.  Why not thousands of them, each simulating a useful structure?
		</p>
		<p>
		I recalled the monads of Leibniz, the &#34;dividing nature at its joints&#34; discourse of Plato, and other
		attempts to parse complexity.  Of course, philosophy is about opinion and engineering is about deeds,
		with science the happy medium somewhere in between.  It is not too much of an exaggeration to say
		that most of my ideas from then on took their roots from Simula—but not as an attempt to improve
		it.  It was the promise of an entirely new way to structure computations that took my fancy.  As it
		turned out, it would take quite a few years to understand how to use the insights and to devise
		efficient mechanisms to execute them.
		</p>

	<h2><a name="p6">II. 1967-69—The FLEX Machine, a first attempt at an OOP-based personal computer</a></h2>

		<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/linc.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/linc.jpg" alt="Wes Clark and the LINC, ca 1962"/></a>

		<p>
		Dave Evans was not a great believer in graduate school
		as an institution.  As with many of the ARPA &#34;contractors&#34;
		he wanted his students to be doing &#34;real things&#34;; they
		should move through graduate school as quickly as possible;
		and their theses should advance the state of the art.
		Dave would often get consulting jobs for his students, and
		in early 1967, he introduced me to Ed Cheadle, a friendly
		hardware genius at a local aerospace company who was
		working on a &#34;little machine.&#34;  It was not the first personal
		computer—that was the LINC of Wes Clark—but Ed wanted
		it for noncomputer professionals, in particular, he wanted
		to program it in a higher level language, like BASIC.  I
		said; &#34;What about JOSS?  It&#39;s nicer.&#34;  He said: &#34;Sure, whatever
		you think,&#34; and that was the start of a very pleasant
		collaboration we called the FLEX machine.  As we got deeper into the design, we realized that we wanted
		to dynamically <i>simulate</i> and <i>extend,</i> neither of which JOSS (or any existing language that I knew of)
		was particularly good at.  The machine was too small for Simula, so that was out.  The beauty of JOSS
		was the extreme attention of its design to the end-user—in this respect, it has not been
		surpassed [Joss 1964, Joss 1978].  JOSS was too slow for serious computing (but cf. Lampson 65), did not
		have real procedures, variable scope, and so forth.  A language that looked a little like JOSS but had
		considerably more potential power was Wirth&#39;s EULER [Wirth 1966].  This was a generalization of Algol
		along lines first set forth by van Wijngaarden [van Wijngaarden 1963] in which types were discarded,
		different features consolidated, procedures were made into first class objects, and so forth.  Actually
		kind of LISPlike, but without the deeper insights of LISP.
		</p>
		<p>
		But EULER was enough of &#34;an almost new thing&#34; to suggest that the same techniques be applied to
		simplify Simula.  The EULER compiler was a part of its formal definition and made a simple conversion
		into B5000-like byte-codes.  This was appealing because it suggested that Ed&#39;s little machine could
		run byte-codes emulated in the longish slow microcode that was then possible.  The EULER compiler
		however, was tortuously rendered in an &#34;extended precedence&#34; grammar that actually required
		concessions in the language syntax (e.g. &#34;,&#34; could only be used in one role because the precedence
		scheme had no state space).  I initially adopted a bottom-up Floyd-Evans parser (adapted from Jerry 
		Feldman&#39;s original compiler-compiler [Feldman 1977]) and later went to various top-down schemes,
		several of them related to Shorre&#39;s META II [Shorre 1963] that eventually put the translater in the name
		space of the language.
		</p>
		<p>
		The semantics of what was now called the FLEX language needed to be influenced more by Simula
		than by Algol or EULER.  But it was not completely clear how.  Nor was it clear how the users should
		interact with the system.  Ed had a display (for graphing, etc.) even on his first machine, and the LINC
		had a &#34;glass teletype,&#34; but a Sketchpad-like system seemed far beyond the scope that we could
		accomplish with the maximum of 16k 16-bit words that our cost budget allowed.
		</p>

		<h3>Doug Engelbart and NLS</h3>

		<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/nls.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/nls.jpg" alt="four pictures"/></a>

		<p>
		This was in early 1967, and while we were pondering
		the FLEX machine, Utah was visited by Doug Engelbart.  A
		prophet of Biblical dimensions, he was very much one of
		the fathers of what on the FLEX machine I had started to
		call &#34;personal computing.&#34;  He actually traveled with his
		own 16mm projector with a remote control for starting
		and stopping it to show what was going on (people were
		not used to seeing and following cursors back then).  His
		notion on the ARPA dream was that the destiny of oNLine
		Systems (NLS) was the &#34;augmentation of human 
		intellect&#34; via an interactive vehicle navigating through
		&#34;thought vectors in concept space.&#34;  What his system
		could do then—even by today&#39;s standards—was incredible.
		Not just hypertext, but graphics, multiple panes, efficient
		navigation and command input, interactive collaborative
		work, etc.  An entire conceptual world and world
		view [Engelbart 68].  The impact of this vision was to produce
		in the minds of those who were &#34;eager to be 
		augmented&#34; a compelling metaphor of what interactive computing should be like, and I immediately adopted
		many of the ideas for the FLEX machine.
		</p>
		<p>
		In the midst of the ARPA context of human-computer
		symbiosis and in the presence of Ed&#39;s &#34;little machine&#34;,
		Gordon Moore&#39;s &#34;Law&#34; again came to mind, this time
		with great impact.  For the first time I made the leap of
		putting the room-sized interactive TX-2 or even a 10 MIP
		6600 on a desk.  I was almost frightened by the implications;
		computing as we knew it couldn&#39;t survive—the 
		actual meaning of the word changed—it must have been
		the same kind of disorientation people had after reading
		Copernicus and first looked up from a different Earth to a
		different Heaven.
		</p>
		<p>
		Instead of at most a few thousand <i>institutional</i> mainframes
		in the world—even today in 1992 it is estimated
		that there are only 4000 IBM mainframes in the entire world—and
		at most a few thousand users trained for
		each application, there would be millions of <i>personal</i> 
		machines and users, mostly outside of direct institutional
		control.  Where would the applications and training come
		from?  Why should we expect an applications programmer
		to anticipate the specific needs of a particular one of
		the millions of potential users?  An <i>extensional</i> system
		seemed to be called for in which the end-users would do
		most of the tailoring (and even some of the direct 
		construction) of their tools.  ARPA had already figured this out
		in the context of their early successes in time-sharing.
		Their larger metaphor of human-computer symbiosis
		helped the community avoid making a religion of their subgoals and kept them focused on the
		abstract holy grail of &#34;augmentation.&#34;
		</p>
		<p>
		One of the interesting features of NLS was that its user interface was parametric and could be 
		supplied by the end user in the form of a &#34;grammar of interaction&#34; given in their compiler-compiler
		TreeMeta.  This was similar to William Newman&#39;s early &#34;Reaction Handler&#34; [Newman 66] work in
		specifying interfaces by having the end-user or developer construct through tablet and stylus an
		iconic regular expression grammar with action procedures at the states (NLS allowed embeddings via
		its context free rules).  This was attractive in many ways, particularly William&#39;s scheme, but to me
		there was a monstrous bug in this approach.  Namely, these grammars forced the user to be in a 
		system state which required getting out of before any new kind of interaction could be done.  In hierarchical
		menus or &#34;screens&#34;  one would have to backtrack to a master state in order to go somewhere
		else.  What seemed to be required were states in which there was a transition arrow to every other
		state—not a fruitful concept in formal grammar theory.  In other words, a much &#34;flatter&#34; interface
		seemed called for—but could such a thing be made interesting and rich enough to be useful?
		</p>
		<p>
		Again, the scope of the FLEX machine was too small for a miniNLS, and we were forced to find
		alternate designs that would incorporate some of the power of the new ideas, and in some cases to
		improve them.  I decided that Sketchpad&#39;s notion of a general window that viewed a larger virtual
		world was a better idea than restricted horizontal panes and with Ed came up with a clipping
		algorithm very similar to that under development at the same time by Sutherland and his students at
		Harvard for the 3D &#34;virtual reality&#34; helmet project [Sutherland 1968].
		</p>
		<p>
		Object references were handled on the FLEX machine as a generalization of B5000 descriptors.
		Instead of a few formats for referencing numbers, arrays, and procedures, a FLEX descriptor
		contained two pointers: the first to the &#34;master&#34; of the object, and the second to the object instances (later
		we realized that we should put the master pointer in the instance to save space).  A different method
		was taken for handling generalized assignment.  The B5000 used l-values and r-values [Strachey*]
		which worked for some cases but couldn&#39;t handle more complex objects.  For example: <i>a[55] := 0</i>, if <i>a</i> was a 
		sparse array whose default element was 0 would still generate an element in the array because
		:= is an &#34;operator&#34; and <i>a[55]</i> is dereferenced into an l-value before anyone gets to see that the r-value
		is the default element, regardless of whether <i>a</i> is an array or a procedure fronting for an array.  What
		is needed is something like: <i>a(55, &#39;:=&#39;, 0),</i> which <u>can</u> look at all relevant operands before any store is
		made.  In other words, := is not an operator, but a kind of index that can select a behavior from a
		complex object.  It took me a remarkably long time to see this, partly I think because one has to invert
		the traditional notion of operators and functions, etc., to see that objects need to privately own all of
		their behaviors: <i>that objects are a kind of mapping whose values are its behaviors</i>.  A book on logic by


		Carnap [Ca *] helped by showing that &#34;intensional&#34; definitions covered the same territory as the
		more traditional extensional technique and were often more intuitive and convenient.
		</p>
		<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/flex.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/flex.jpg" alt="Flex machine diagrams"/></a>

		<p>
		As in Simula, a coroutining control structure [Conway, 1963] was used as a way to suspend and
		resume objects.  Persistent objects like files and documents were treated as suspended processes and
		were organized according to their Algol-like static variable scopes.  These were shown on the screen
		and could be opened by pointing at them.  Coroutining was also used as a control structure for looping.
		A single operator <b>while</b> was used to test the generators which returned <b>false</b> when unable to
		furnish a new value.  Booleans were used to link multiple generators.  So a &#34;for-type&#34; loop would be
		written as:
		</p>
		<pre>while i &lt;= 1 to 30 by 2 ^ j &lt;= 2 to k by 3 do j&lt;-j * i;</pre>
		<p>
		where the <b>... to ... by ...</b> was a kind of coroutine object.  Many of these ideas were reimplemented in a 
		stronger style in Smalltalk later on.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/flexstatement.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/flexstatement.jpg" alt="FLEX when statement [Ka 69]"/></a>
		<p>
		Another control structure of interest in FLEX was a kind of
		event-driven &#34;soft interrupt&#34; called <b>when</b>.  Its boolean
		expression was compiled into a &#34;tournament sort&#34; tree that
		cached all possible intermediate results.  The relevant variables
		were threaded through all of the sorting trees in all of
		the <b>when</b>s so that any change only had to compute through
		the necessary parts of the booleans.  The efficiency was very
		high and was similar to the techniques now used for
		spreadsheets.  This was an embarrassment of riches with
		difficulties often encountered in event-driven systems.
		Namely, it was a complex task to control the <i>context</i> of just when the <b>when</b>s should be sensitive.  Part
		of the boolean expression had to be used to check the contexts, where I felt that somehow the
		structure of the program should be able to set and unset the event drivers.  This turned out to beyond the
		scope of the FLEX system and needed to wait for a better architecture.
		</p>
		<p>
		Still, quite a few of the original FLEX ideas in their proto-object form did turn out to be small
		enough to be feasible on the machine.  I was writing the first compiler when something unusual
		happened: the Utah graduate students got invited to the ARPA contractors meeting held that year at Alta,
		Utah. Towards the end of the three days, Bob Taylor, who had succeeded Ivan Sutherland as head of
		ARPA-IPTO, asked the graduate students (sitting in a ring around the outside of the 20 or so contractors)
		if they had any comments.  John Warnock raised his hand and pointed out that since the ARPA
		grad students would all soon be colleagues (and since we did all the real work anyway), ARPA should
		have a contractors-type meeting each year for the grad students.  Taylor thought this was a great idea
		and set it up for the next summer.
		</p>
		<p>
		Another ski-lodge meeting happened in Park City later that spring.  The general topic was education
		and it was the first time I heard Marvin Minsky speak.  He put forth a terrific diatribe against
		traditional education methods, and from him I heard the ideas of Piaget and Papert for the first time.
		Marvin&#39;s talk was about how we think about complex situations and why schools are really bad
		places to learn these skills.  He didn&#39;t have to make any claims about computers+kids to make his
		point.  It was clear that education and learning had to be rethought in the light of 20th century 
		cognitive psychology and how good thinkers really think.  Computing enters as a new representation system
		with new and useful metaphors for dealing with complexity, especially of systems [Minsky 70].
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/plasma.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/plasma.jpg" alt="The First Plasma Panel"/></a>
		<p>
		For the summer 1968 ARPA grad students meeting at Allerton House in Illinois, I boiled  all the mechanisms in the FLEX machine down into one 2&#39;x3&#39; chart.  This included
		all the &#34;object structures&#34;, the compiler, the byte-code
		interpreter, i/o handlers, and a simple display editor
		for text and graphics.  The grad students were a 
		distinguished group that did indeed become colleagues in
		subsequent years.  My FLEX machine talk was a success,
		but the big whammy for me came during a tour to U of Illinois
		where I saw a 1&#34; square lump of glass and neon gas in which individual spots would light up on 
		command—it was the first flat-panel display.  I spent the rest
		of the conference calculating just when the silicon of the 
		FLEX machine could be put on the back of the display.  According to Gordon Moore&#39;s &#34;Law&#34;, the
		answer seemed to be sometime in the late seventies or early eighties.  A long time off—it seemed too 
		long to worry much about it then.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/dynabookmodel.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/dynabookmodel.jpg" alt="Grail, Seymour Papert and LOGO Turtle, The Dynabook Model"/></a>
		<p>
		But later that year at RAND I saw a truly beautiful system.
		This was GRAIL, the graphical followon to JOSS.  The
		first tablet (the famous RAND tablet) was invented by
		Tom Ellis [Davis 1964] in order to capture human 
		gestures, and Gave Groner wrote a program to efficiently
		recognize and respond to them [Groner 1966].  Though
		everything was fastened with bubble gum and the 
		system crashed often, I have never forgotten my first interactions
		with this system.  It was direct manipulation, it
		was analogical, it was modeless, it was beautiful.  I realized
		that the FLEX interface was all wrong, but how could
		something like GRAIL be stuffed into such a tiny machine
		since it required <u>all</u> of a stand-alone 360/44 to run in?
		</p>
		<p>
		A month later, I finally visited Seymour Papert, Wally
		Feurzig, Cynthia Solomon and some of the other
		original researchers who had built LOGO and were using it
		with children in the Lexington schools.  Here were children
		doing real programming with a specially designed
		language and environment.  As with Simula leading to
		OOP, this encounter finally hit me with what the destiny
		of personal computing <i>really</i> was going to be.  Not a 
		personal dynamic <i>vehicle,</i> as in Engelbart&#39;s metaphor
		opposed to the IBM &#34;railroads&#34;, but something much
		more profound: a personal dynamic <i>medium.</i>  With a 
		vehicle one could wait until high school and give &#34;drivers
		ed&#34;, but if it was a medium, it had to extend into
		the world of childhood.
		</p>
		<p>
		Now the collision of the FLEX machine, the flat-screen
		display, GRAIL, Barton&#39;s &#34;communications&#34; talk,
		McLuhan, and Papert&#39;s work with children all came 
		together to form an image of what a personal computer
		really should be.  I remembered Aldus Manutius who 40 
		years after the printing press put the book into its 
		modern dimensions by making it fit into saddlebags.  It had
		to be no larger than a notebook, and needed an interface
		as friendly as JOSS&#39;, GRAIL&#39;s, and LOGO&#39;s, but with the
		reach of Simula and FLEX.  A clear romantic vision has a marvelous ability to focus thought and will.
		Now it was easy to know what to do next.  I built a cardboard model of it to see what if would look
		and feel like, and poured in lead pellets to see how light it would have to be (less than two pounds).  I
		put a keyboard on it as well as a stylus because, even if hand printing and writing were recognized
		perfectly (and there was no reason to expect that it would be), there still needed to be a balance
		between
		the low speed tactile degrees of freedom offered by the stylus and the more limited but faster
		keyboard.  Since ARPA was starting to experiment with packet radio, I expected that the Dynabook
		when it arrived a decade or so hence, would have a wireless networking system.
		</p>
		<p>
		Early next year (1969) there was a conference on Extensible Languages in which almost every
		famous name in the field attended.  The debate was great and weighty—it was a religious war of
		unimplemented poorly thought out ideas.  As Alan Perlis, one of the great men in Computer Science, 
		put it with characteristic wit:
		</p>
			<blockquote>
			It has been such a long time since I have seen so many familiar faces
			shouting among so many familiar ideas.  Discovery of something new in
			programming languages, like any discovery, has somewhat the same
			sequence of emotions as falling in love.  A sharp elation followed by
			euphoria, a feeling of uniqueness, and ultimately the wandering eye
			(the urge to generalize) [ACM 69].
			</blockquote>
		<p>
		But it was all talk—no one had <u>done</u> anything yet.  In the midst of all this, Ned Irons got up and
		presented IMP, a system that had already been working for several years that was more elegant than
		most of the nonworking proposals.  The basic idea of IMP was that you could use any phrase in the
		grammar as a procedure heading and write a semantic definition in terms of the language as
		extended so far [Irons 1970].
		</p>
		<p>
		I had already made the first version of the FLEX machine syntax driven, but where the meaning of a 
		phrase was defined in the more usual way as the kind of code that was emitted.  This separated the
		compiler-extensor part of the system from the end-user.  In Irons&#39; approach, <i>every</i> procedure in the
		system defined its own syntax in a natural and useful manner.  I incorporated these ideas into the
		second versions of the FLEX machine and started to experiment with the idea of a direct interpreter rather
		than a syntax directed compiler.  Somewhere in all of this, I realized that the bridge to an object-based
		system could be in terms of each object as a syntax directed interpreter of messages sent to it.  In one
		fell swoop this would unify object-oriented semantics with the ideal of a completely extensible language.
		The mental image was one of separate computers sending requests to other computers that
		had to be accepted and understood by the receivers before anything could happen.  In today&#39;s terms
		every object would be a <i>server</i> offering <i>services</i> whose deployment and discretion depended entirely
		on the server&#39;s notion of relationship with the servee.  As Liebniz said: &#34;To get everything out of 
		nothing, you only need to find one principle.&#34;  This was not well thought out enough to do the FLEX
		machine any good, but formed a good point of departure for my thesis [Kay 69], which as Ivan 
		Sutherland liked to say was &#34;anything you can get three people to sign.&#34;
		</p>
		<p>
		After three people signed it (Ivan was one of them), I went to the Stanford AI project and spent
		much more time thinking about notebook KiddyKomputers than AI.  But there were two AI designs
		that were very intriguing.  The first was Carl Hewitt&#39;s PLANNER, a programmable logic system that
		formed the deductive basis of Winograd&#39;s SHRDLU [Sussman 69, Hewitt 69]  I designed several
		languages based on a combination of the pattern matching schemes of FLEX and PLANNER [Kay 70].  The
		second design was Pat Winston&#39;s concept formation system, a scheme for building semantic 
		networks and comparing them to form analogies and learning processes [Winston 70].  It was kind of
		&#34;object-oriented&#34;.  One of its many good ideas was that the arcs of each net which served as attributes
		in AOV triples should themselves be modeled as nets.  Thus, for example a first order arc called LEFT-OF
		could be asked a higher order question such as &#34;What is your converse?&#34; and its net could answer:
		RIGHT-OF.  This point of view later formed the basis for Minsky&#39;s frame systems [Minsky 75].  A few
		years later I wished I had paid more attention to this idea.
		</p>
		<p>
		That fall, I heard a wonderful talk by Butler Lampson about CAL-TSS, a capability-based operating
		system that seemed very &#34;object-oriented&#34; [Lampson 69].  Unforgeable pointers (ala B5000) were
		extended by bit-masks that restricted access to the object&#39;s internal operations.  This confirmed my
		&#34;objects as server&#34; metaphor.  There was also a very nice approach to exception handling which
		reminded me of the way failure was often handled in pattern matching systems.  The only problem—
		which the CAL designers did not see as a problem at all—was that only certain (usually large and
		slow) things were &#34;objects&#34;.  Fast things and small things, etc., weren&#39;t.  This needed to be fixed.
		</p>
		<p>
		The biggest hit for me while at SAIL in late &#39;69 was to <i>really understand</i> LISP.  Of course, every 
		student knew about <i>car, cdr</i>, and <i>cons</i>, but Utah was impoverished in that no one there used LISP and
		hence, no one had penetrated the mysteries of <i>eval</i> and <i>apply</i>.  I could hardly believe how beautiful
		and wonderful the <i>idea</i> of LISP was [McCarthy 1960].  I say it this way because LISP had not only been
		around enough to get some honest barnacles, but worse, there were deep flaws in its logical 
		foundations.  By this, I mean that the pure language was supposed to be based on functions, but its most
		important components—such as lambda expressions, quotes, and conds—were not functions at all,
		and instead were called special forms.  Landin and others had been able to get quotes and conds in
		terms of lambda by tricks that were variously clever and useful, but the flaw remained in the jewel.  
		In the practical language things were better.  There were not just EXPRs (which evaluated their 
		arguments), but FEXPRs (which did not).  My next question was, why on earth call it a functional language?
		Why not just base everything on FEXPRs and force evaluation on the receiving side when needed?  I
		could never get a good answer, but the question was very helpful when it came time to invent
		Smalltalk, because this started a line of thought that said &#34;take the hardest and most profound thing
		you need to do, make it great, and then build every easier thing out of it&#34;.  That was the promise of
		LISP and the lure of lambda—needed was a better &#34;hardest and most profound&#34; thing.  Objects should
		be it.
		</p>

	<h2><a name="p12">III. 1970-72—Xerox PARC: The KiddiKomp, miniCOM, and Smalltalk-71</a></h2>

		<p>
		In July 1970, Xerox, at the urging of its chief scientist Jack Goldman, decided to set up a long range
		research center in Palo Alto, California.  In September, George Pake, the former chancellor at
		Washington University where Wes Clark&#39;s ARPA project was sited, hired Bob Taylor (who had left the 
		ARPA office and was taking a sabbatical year at Utah) to start a &#34;Computer Science Laboratory.&#34;  Bob
		visited Palo Alto and we stayed up all night talking about it.   The Mansfield Amendment was threatening
		to blindly muzzle the most enlightened ARPA funding in favor of directly military research, and
		this new opportunity looked like a promising alternative.  But work for a company?  He wanted me to
		consult and I asked for a direction.  He said: follow your instincts.  I immediately started working up a
		new version  of the KiddiKomp that could be made in enough quantity to do experiments leading to
		the user interface design for the eventual notebook.  Bob Barton liked to say that &#34;good ideas don&#39;t
		often scale.&#34;  He was certainly right when applied to the FLEX machine.  The B5000 just didn&#39;t directly
		scale down into a tiny machine.  Only the byte-codes did, and even these needed modification.  I
		decided to take another look at Wes Clark&#39;s LINC, and was ready to appreciate it much more this time
		[Clark 1965].
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/kiddikomp.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/kiddikomp.jpg" alt="KiddiKomp"/></a>
		<p>
		I still liked pattern-directed approaches and OOP so I came up with a language design called &#34;Simulation LOGO&#34; or SLOGO for short (I had a feeling the first versions might run nice and slow).  This
		was to be built into a SONY &#34;tummy trinitron&#34; and would use a coarse bit-map display and the FLEX
		machine rubber tablet as a pointing device.
		</p>
		<p>
		Another beautiful system that I had come across was Peter Deutsch&#39;s PDP-1 LISP (implemented
		when he was only 15) [Deutsch 1966].  It used only 2K (18-bit words) of code and could run quite well
		in a 4K machine (it was its own operating system and interface).  It seemed that even more could be
		done if the system were byte-coded, run by an architecture that was hospitable to dynamic systems,
		and stuck into the ever larger ROMs that were becoming available.  One of the basic insights I had gotten
		from Seymour was that you didn&#39;t have to do a lot to make a computer an &#34;object for thought&#34;
		for children, but what you did had to be done well and be able to apply deeply.
		</p>
		<p>
		Right after New Years 1971, Bob Taylor scored an enormous coup by attracting most of the 
		struggling Berkeley Computer Corp to PARC.  This group included Butler Lampson, Chuck Thacker, Peter
		Deutsch, Jim Mitchell, Dick Shoup, Willie Sue Haugeland, and Ed Fiala.  Jim Mitchell urged the group
		to hire Ed McCreight from CM and he arrived soon after.  Gary Starkweather was there already,
		having been thrown out of the Xerox Rochester Labs for wanting to build a laser printer (which was
		against the local religion).  Not long after, many of Doug Englebart&#39;s people joined up—part of the
		reason was that they want to reimplement NLS as a distributed network system, and Doug wanted to
		stay with time-sharing.  The group included Bill English (the co-inventor of the mouse), Jeff Rulifson,
		and Bill Paxton.
		</p>
		<p>
		Almost immediately we got into trouble with Xerox when the group decided that the new lab
		needed a PDP-10 for continuity with the ARPA community.  Xerox (which had bought SDS essentially
		sight unseen a few years before) was horrified at the idea of their main competitor&#39;s computer being
		used in the lab.  They balked.  The newly formed PARC group had a meeting in which it was decided
		that it would take about three years to do a good operating system for the XDS SIGMA-7 but that we
		could <i>build</i> &#34;our own PDP-10&#34; in a year.  My reaction was &#34;Holy cow!&#34;  In fact, they pulled it it off with 
		considerable panache.  MAXC was actually a microcoded emulation of the PDP-10 that used for the first
		time the new integrated chip memories (1K bits!) instead of core memory.  Having practical in house
		experience with both of these new technologies was critical for the more radical systems to come.
		</p>
		<p>
		One little incident of LISP beauty happened when Allen Newell visited PARC with his theory
		of hierarchical thinking and was challenged to prove it.  He was given a programming problem to solve
		while the protocol was collected.  The problem was: given a list of items, produce a list consisting of
		all of the odd indexed items followed by all of the even indexed items.  Newell&#39;s internal programming
		language resembled IPL-V in which pointers are manipulated explicitly, and he got into quite a
		struggle to do the program.  In 2 seconds I wrote down:
		</p>
		<pre>oddsEvens(x) = append(odds(x), evens(x))</pre>
		<p>
		the statement of the problem in Landin&#39;s LISP syntax—and also the first part of the solution.  Then a 
		few seconds later:
		</p>
		<pre>where odds(x) = if null(x) ∨ null(tl(x)) then x
                   else hd(x) &amp; odds(ttl(x))
     evens(x) = if null(x) ∨ null(tl(x)) then nil
                   else odds(tl(x))</pre>
		<p>
		This characteristic of writing down many solutions in declarative form and have them also be the
		programs is part of the appeal and beauty of this kind of language.  Watching a famous guy much
		smarter than I struggle for more than 30 minutes to not quite solve the problem his way (there was a
		bug) made quite an impression.  It brought home to me once again that &#34;point of view is worth 80 IQ
		points.&#34;  I wasn&#39;t smarter but I had a much better internal thinking tool to amplify my abilities.  This
		incident and others like it made paramount that any tool for children should have great thinking 
		patterns <u>and</u> deep beauty &#34;built-in.&#34;
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/penderypaperdisplay.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/penderypaperdisplay.jpg" alt="Pendery Paper Display Transducer Design"/></a>
		<p>
		Right around this time we were involved in another conflict with Xerox management, in particular
		with Don Pendery the head &#34;planner&#34;.  He really didn&#39;t understand what we were talking about and
		instead was interested in &#34;trends&#34; and
		&#34;what was the future going to be like&#34;
		and how could Xerox &#34;defend against
		it.&#34;  I got so upset I said to him, &#34;Look.
		<i>The best way to predict the future is to
		invent it.</i>  Don&#39;t worry about what all
		those other people might do, this is
		the century in which almost any clear vision can be made!&#34;  He remained
		unconvinced, and  that led to the famous &#34;Pendery Papers for PARC
		Planning Purposes,&#34; a collection of
		essays on various aspects of the 
		future.  Mine proposed a version of the notebook as a &#34;Display Transducer&#34;,
		and Jim Mitchell&#39;s was entitled &#34;NLS
		on a Minicomputer.&#34;
		</p>
		<p>
		Bill English took me under his wing and helped me start my group as I had always been a lone
		wolf and had no idea how to do it.  One of his suggestions was that I should make a budget.  I&#39;m
		afraid that I really did ask Bill, &#34;What&#39;s a budget?&#34;  I remembered at Utah, in pre-Mansfield
		Amendment days, Dave Evans saying to me as he went off on a trip to ARPA, &#34;We&#39;re almost out of
		money.  Got to go get some more.&#34;  That seemed about right to me.  They give you some money.  You
		spend it to find out what to do next.  You run out.  They give you some more.  And so on.  PARC never
		quite made it to that idyllic standard, but for the first half decade it came close.  I needed a group
		because I had finally realized that I did not have all of the temperaments required to completely finish
		an idea.  I called it the Learning Research Group (LRG) to be as vague as possible about our charter.
		I only hired people that got stars in their eyes when they heard about the notebook computer idea.  I
		didn&#39;t like meetings: didn&#39;t believe brainstorming could substitute for cool sustained thought.  When
		anyone asked me what to do, and I didn&#39;t have a strong idea, I would point at the notebook model
		and say, &#34;Advance that.&#34;  LRG members developed a very close relationship with each other—as Dan
		Ingalls was to say later: &#34;... the rest has enfolded through the love and energy of the whole Learning
		Research Group.&#34;  A lot of daytime was spent outside of PARC, playing tennis, bikeriding, drinking
		beer, eating Chinese food, and constantly talking about the Dynabook and its potential to amplify
		human reach and bring new ways of thinking to a faltering civilization that desperately needed it
		(that kind of goal was common in California in the aftermath of the sixties).
		</p>
		<p>
		In the summer of &#39;71 I refined the KiddiKomp idea into a tighter design called miniCOM.  It used a
		bit-slice approach like the NOVA 1200, had a bit-map display, a pointing device, a choice of 
		&#34;secondary&#34; (really tertiary) storages, and a language I now called &#34;Smalltalk&#34;—as in &#34;programming
		should be a matter of ...&#34; and &#34;children should program in ...&#34;.  The name was also a reaction against
		the &#34;IndoEuropean god theory&#34; where systems were named Zeus, Odin, and Thor, and hardly did
		anything.  I figured that &#34;Smalltalk&#34; was so innocuous a label that if it ever did anything nice people 
		would be pleasantly surprised.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/minicom.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/minicom.jpg" alt="miniCOM"/></a>

<pre>Smalltalk-71 Programs

to T &#39;and&#39; :y do &#39;y&#39;
to F &#39;and&#39; :y do F

to &#39;factorial&#39; 0 is 1
to &#39;factorial&#39; :n do &#39;n*factorial n-1&#39;

to &#39;fact&#39; :n do &#39;to &#39;fact&#39; n do factorial n. ^ fact n&#39;

to :e &#39;is-member-of&#39; [] do F
to :e &#39;is-member-of&#39; :group
          do&#39;if e = firstof group then T
		          else e is-member-of rest of group&#39;

to &#39;cons&#39; :x :y is self
to &#39;hd&#39; (&#39;cons&#39; :a :b) do &#39;a&#39;
to &#39;hd&#39; (&#39;cons&#39; :a :b) &#39;&lt;-&#39; :c do &#39;a &lt;- c&#39;
to &#39;tl&#39; (&#39;cons&#39; :a :b) do &#39;b&#39;
to &#39;tl&#39; (&#39;cons&#39; :a :b) &#39;&lt;-&#39; :c do &#39;b &lt;- c&#39;

to :robot &#39;pickup&#39; :block
         do &#39;robot clear-top-of block.
		 robot hand move-to block.
		 robot hand lift block 50.
		 to &#39;height-of&#39; block do 50&#39;
</pre>
		<p>
		This Smalltalk language (today labeled -71) was very influenced by FLEX, PLANNER, LOGO, META II, and my own
		derivatives from them.  It was a kind of parser with
		object-attachment that executed tokens directly.  (I think
		the awkward quoting conventions come from META).  I
		was less interested in programs as algebraic patterns
		than I was in a clear scheme that could handle a variety
		of styles of programming.  The patterned front-end
		allowed simple extension, patterns as &#34;data&#34; to be
		retrieved, a simple way to attach behaviors to objects,
		and a rudimentary but clear expression of its <i>eval</i> in
		terms that I thought children could understand after a
		few years experience with simpler programming.
		Program storage was sorted into a discrimination net and
		evaluation was straightforward pattern-matching.
		</p>


		<p>
		As I mentioned previously, it was annoying that the 
		surface beauty of LISP was marred by some of its key
		parts having to be introduced as &#34;special forms&#34; rather
		than as its supposed universal building block of
		functions.  The actual beauty of LISP came more from the
		<i>promise</i> of its metastructures than its actual model.  I spent
		a fair amount of time thinking about how objects could
		be characterized as universal computers without having to have any exceptions in the central
		metaphor.  What seemed to be needed was complete control over what was passed in a message send;
		in particular <i>when</i> and in <i>what environment</i> did expressions get evaluated?
		</p>
		<p>
		An elegant approach was suggested in a CMU thesis of Dave Fisher [Fisher 70] on the synthesis of
		control structures.  ALGOL60 required a separate link for dynamic subroutine linking and for access to
		static global state.  Fisher showed how a generalization of these links could be used to simulate a
		wide variety of control environments.  One of the ways to solve the &#34;funarg problem&#34; of LISP is to
		associate the proper global state link with expressions and functions that are to be evaluated later so
		that the free variables referenced are the ones that were actually implied by the static form of the
		language.  The notion of &#34;lazy evaluation&#34; is anticipated here as well.
		</p>
		<p>
		Nowadays this approach would be called <i>reflective design</i>.  Putting it together with the FLEX models
		suggested that all that should be required for &#34;doing LISP right&#34; or &#34;doing OOP right&#34; would be to
		handle the mechanics of invocations between modules without having to worry about the details of
		the modules themselves.  The difference between LISP and OOP (or any other system) would then be
		what the modules could contain.  A universal module (object) reference —ala B5000 and LISP—and a
		message holding structure—which could be virtual if the senders and receivers were sympatico—
		that could be used by all would do the job.
		</p>
		<p>
		If all of the fields of a messenger structure were enumerated according to this view, we would
		have:
		</p>
		<table summary="all of the fields of a messenger structure">
			<tbody><tr><td>GLOBAL:</td> <td><i>the environment of the parameter values</i></td></tr>
			<tr><td>SENDER:</td> <td><i>the sender of the message</i></td></tr>
			<tr><td>RECEIVER:</td> <td><i>the receiver of the message</i></td></tr>
			<tr><td>REPLY-STYLE:</td> <td><i>wait, fork, ...?</i></td></tr>
			<tr><td>STATUS:</td> <td><i>progress of the message</i></td></tr>
			<tr><td>REPLY:</td> <td><i>eventual result (if any)</i></td></tr>
			<tr><td>OPERATION SELECTOR:</td> <td><i>relative to the receiver</i></td></tr>
			<tr><td># OF PARAMETERS:</td> <td></td></tr>
			<tr><td>P1:</td> <td></td></tr>
			<tr><td>...:</td> <td></td></tr>
			<tr><td>Pn:</td> <td></td></tr>
		</tbody></table>

		<p>
		This is a generalization of a stack frame, such as used by the B5000, and very similar to what a good
		intermodule scheme would require in an operating system such as CAL-TSS—a lot of state for every
		transaction, but useful to think about.
		</p>
		<p>
		Much of the pondering during this state of grace (before any workable implementation) had to do
		with trying to understand what &#34;beautiful&#34; might mean with reference to object-oriented design.  A
		subjective definition of a beautiful thing is fairly easy but is not of much help: we think a thing
		beautiful because it evokes certain emotions.  The cliche has it lie &#34;in the eye of the beholder&#34; so that it is
		difficult to think of beauty as other than a relation between subject and object in which the predispositions
		of the subject are all important.
		</p>
		<p>
		If there are such a thing as universally appealing forms then we can perhaps look to our shared
		biological heritage for the predispositions.  But, for an object like LISP, it is almost certain that most of
		the basis of our judgment is learned and has much to do with other related areas that we think are
		beautiful, such as much of mathematics.
		</p>
		<p>
		One part of the perceived beauty of mathematics has to do with a wondrous synergy between parsimony,
		generality, enlightenment, and finesse.  For example, the Pythagorean Theorem is expressible
		in a single line, is true for all of the infinite number of right triangles, is incredibly useful in 
		understanding many other relationships, and can be shown by a few simple but profound steps.
		</p>
		<p>
		When we turn to the various languages for specifying computations we find many to be general
		and a few to be parsimonious.  For example, we can define universal machine languages in just a few
		instructions that can specify anything that can be computed.  But most of these we would not call
		beautiful, in part because the amount and kind of code that has to be written to do anything interesting
		is so contrived and turgid.  A simple and small system that can do interesting things also needs a 
		&#34;high slope&#34;—that is a good match between the degree of interestingness and the level of complexity
		needed to express it.
		</p>
		<p>
		A fertilized egg that can transform itself into the myriad of specializations needed to make a complex
		organism has parsimony, generality, enlightenment, and finesse—in short, beauty, and a beauty
		much more in line with my own esthetics.  I mean by this that Nature is wonderful <u>both</u> at elegance
		and practicality—the cell membrane is partly there to allow useful evolutionary kludges to do their
		necessary work and still be able act as component by presenting a uniform interface to the world.
		</p>
		<p>
		One of my continual worries at this time was about the size of the bit-map display.  Even if a mixed
		mode was used (between fine-grained generated characters and coarse-grained general bit-map for
		graphics) it would be hard to get enough information on the screen.  It occurred to me (in a shower,
		my favorite place to think) that FLEXtype windows on a bit-map display could be made to appear as 
		overlapping documents on a desktop.  When an overlapped one was refreshed it would appear to
		come to the top of the stack.  At the time, this did not appear as <u>the</u> wonderful solution to the problem
		but it did have the effect of magnifying the effective area  of the display enormously, so I decided to
		go with it.
		</p>
		<p>
		To investigate the use of video as a display medium, Bill English and Butler Lampson specified an
		experimental character generator (built by Roger Bates) for the POLOS (PARC OnLine Office System)
		terminals.  Gary Starkweather had just gotten the first laser printer to work and we ran a coax over to
		his lab to feed him some text to print.  The &#34;SLOT machine&#34; (Scanning Laser Output Terminal) was
		incredible. The only Xerox copier Gary could get to work on went at 1 page a second and could not 
		be slowed down.  So Gary just  made the laser run at that rate with a resolution of 500 pixels to the
		inch!
		</p>
		<p>
		The character generator&#39;s font memory turned out to be large enough to simulate a bit-map 
		display if one displayed a fixed &#34;strike&#34; and wrote into the font memory.  Ben Laws built a beautiful font
		editor and he and I spent several months learning about the peculiarities of the human visual system
		(it is decidedly non-linear).  I was very interested in high-quality text and graphical presentations
		because I thought it would be easier to get the Dynabook into schools as a &#34;trojan horse&#34; by simply
		replacing school books rather than to try to explain to teachers and school boards what was really
		great about personal computing.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/oldcharacter.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/oldcharacter.jpg" alt="The Old Character Generator — early 1972"/></a>
		<p>
		Things were generally going well all over the lab until May of 72 when I tried to get resources to
		build a few miniCOMs.  A relatively new executive (&#34;X&#34;) did not want to give them to me.  I wrote a
		memo explaining why the system was a good idea (see Appendix II), and then had a meeting to 
		discuss it.  &#34;X&#34; shot it down completely saying among other things that we had used too many green
		stamps getting Xerox to fund the time-shared MAXC and this use of resources for personal machines
		would confuse them.  I was shocked.  I crawled away back to the experimental character generator
		and made a plan to get 4 more made and hooked to NOVAs for the initial kid experiments.
		</p>
		<p>
		I got Steve Purcell, a summer student from Stanford, to build my design for bit-map painting so
		the kids could sketch as well as display computer graphics.  John Shoch built a line drawing and 
		gesture recognition system (based on Ledeen&#39;s [Newman and Sproull 72]) that was integrated with the
		painting.  Bill Duvall of POLOS built a miniNLS that was quite remarkable in its speed and power.  The
		first overlapping windows started to appear.  Bob Shur (with Steve Purcell&#39;s help) built a 2½D
		animation system.  Along with Ben Laws&#39; font editor, we could give quite a smashing demo of what we
		intended to build for real over the next few years.  I remember giving one of these to a Xerox 
		executive, including doing a portrait of him in the new painting system, and
		wound it up with a flourish declaring: &#34;And what&#39;s really great about
		this is that it only has a 20% chance of success.  We&#39;re taking risk just like
		you asked us to!&#34;  He looked me straight in the eye and said, &#34;Boy, that&#39;s great, but just make sure it
		works.&#34;  This was a typical executive notion about risk.  He wanted us to be in the &#34;20%&#34; one hundred
		percent of the time.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/firstpainting.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/firstpainting.jpg" alt="The First Painting System — Summer &#39;72"/></a>
		<p>
		That summer while licking my wounds and getting the demo simulations built and going, Butler
		Lampson, Peter Deutsch, and I worked out a general scheme for emulated HLL machine languages.  I
		liked the B5000 scheme, but Butler did not want to have to decode bytes, and pointed out that since
		an 8-bit byte had 256 total possibilities, what we should do is map different meanings onto different
		parts of the &#34;instruction space.&#34;  This would give us a &#34;poor man&#39;s Huffman code&#34; that would be
		both flexible and simple.  All subsequent emulators at PARC used this general scheme.
		</p>
		<p>
		I also took another pass at the language for the kids.  Jeff Rulifson was a big fan of Piaget (and
		semiotics) and we had many discussions about the &#34;stages&#34; and what iconic thinking might be
		about.  After reading Piaget and especially Jerome Bruner, I was worried that the directly symbolic
		approach taken by FLEX, LOGO (and the current Smalltalk) would be difficult for the kids to process
		since evidence existed that the symbolic stage (or mentality) was just starting to switch on.  In fact, all
		of the educators that I admired (including Montessori, Holt, and Suzuki) all seemed to call for a more
		figurative, more iconic approach.  Rudolph Arnheim [Arnheim 69] had written a classic book about
		visual thinking, and so had the eminent art critic Gombrich [Gombrich **].  It really seemed that
		something better needed to be done here.   GRAIL wasn&#39;t it, because its use of imagery was to portray
		and edit flowcharts, which seemed like a great step backwards.  But Rovner&#39;s AMBIT-G held considerably
		more promise [Rovner 68].  It was kind of a visual SNOBOL [Farber 63] and the pattern matching
		ideas looked like they would work for the more PLANNERlike scheme I was using.
		</p>
		<p>
		Bill English was still encouraging me to do more reasonable appearing things to get higher credibility,
		like making budgets, writing plans and milestone notes, so I wrote a plan that proposed over
		the next few years that we would build a real system on the character generators <i>cum</i> NOVAs that
		would involve OOP, windows, painting, music, animation, and &#34;iconic programming.&#34;  The latter was
		deemed to be hard and would be handled by the usual method for hard problems, namely, give them
		to grad students.
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/childrenwithdynabooks.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/childrenwithdynabooks.jpg" alt="Children with Dynabooks from &#39;A Personal Computer For Children Of All Ages [Ka 72], Iconic Bubble Sort from 1972 LRG Plan [Ka 72a]"/></a>


	<h2><a name="p17">IV. 1972-76—The first real Smalltalk (-72), its birth, applications, and improvements</a></h2>

		<p>
		In Sept, within a few weeks of each other, two bets happened that changed most of my plans.  First,
		Butler and Chuck came over and asked:  &#34;Do you have any money?&#34; I said, &#34;Yes, about $230K for
		NOVAs and CGs.  Why?&#34; They said, &#34;How would you like us to build your little machine for you?&#34;  I
		said, &#34;I&#39;d like it fine.  What is it?&#34;  Butler said: &#34;I want a &#39;$500 PDP-10&#39;, Chuck wants a &#39;10 times faster
		NOVA&#39;, and you want a &#39;kiddicomp&#39;.  What do you need on it?&#34; I told them most of the results we had
		gotten from the fonts, painting, resolution, animation, and music studies.  I asked where this had
		come from all of a sudden and Butler told me that they wanted to do it anyway, that Executive &#34;X&#34;
		was away for a few months on a &#34;task force&#34; so maybe they could &#34;Sneak it in&#34;, and that Chuck had
		a bet with Bill Vitic that he could do a whole machine in just 3 months.  &#34;Oh,&#34; I said.
		</p>
		<p>
		The second bet had even more surprising results.  I had expected that the new Smalltalk would be
		an iconic language and would take at least two years to invent, but fate intervened.  One day, in a typical
		PARC hallway bullsession, Ted Kaehler, Dan Ingalls, and I were standing around talking about
		programming languages.  The subject of power came up and the two of them wondered how large a
		language one would have to make to get great power.  With as much panache as I could muster, I
		asserted that you could define the &#34;most powerful language in the world&#34; in &#34;a page of code.&#34; They
		said, &#34;Put up or shut up.&#34;
		</p>
		<p>
		Ted went back to CMU but Dan was still around egging me on.  For the next two weeks I got to
		PARC every morning at four o&#39;clock and worked on the problem until eight, when Dan, joined by
		Henry Fuchs, John Shoch, and Steve Purcell showed up to kibbitz the morning&#39;s work.
		</p>
		<p>
		I had originally made the boast because McCarthy&#39;s self-describing LISP interpreter was written in
		itself.  It was about &#34;a page&#34;, and as far as power goes, LISP was the whole nine-yards for functional
		languages.  I was quite sure I could do the same for object-oriented languages <i>plus</i> be able to do a
		reasonable syntax for the code <i>a la</i> some of the FLEX machine techniques.
		</p>
		<p>
		It turned out to be more difficult than I had first thought for three reasons.  First, I wanted the 
		program to be more like McCarthy&#39;s second non-recursive interpreter—the one implemented as a loop
		that tried to resemble the original 709 implementation of Steve Russell as much as possible.  It was
		more &#34;real&#34;.  Second, the intertwining of the &#34;parsing&#34; with message receipt—the evaluation of
		parameters which was handled separately in LISP—required that my object-oriented interpreter re-enter
		itself &#34;sooner&#34; (in fact, much sooner) than LISP required.  And, finally, I was still not clear how
		<i>send</i> and <i>receive</i> should work with each other.
		</p>
		<p>
		The first few versions had flaws that were soundly criticized by the group.  But by morning 8 or so,
		a version appeared that seemed to work (see Appendix III for a sketch of how the interpreter was
		designed).  The major differences from the official Smalltalk-72 of a little bit later were that in the first
		version symbols were byte-coded and the receiving of return-values from a send was symmetric—i.e.
		receipt could be like parameter binding—this was particular useful for the return of multiple values.
		For various reasons, this was abandoned in favor of a more expression-oriented functional
		return style.
		</p>
		<p>
		Of course, I had gone to considerable pains to avoid doing any &#34;real work&#34; for the bet, but I felt I
		had
		proved my point.  This had been an interesting holiday from our official &#34;iconic programming&#34;
		pursuits, and I thought that would be the end of it.  Much to my surprise, only a few days later, Dan
		Ingalls showed me the scheme <u>working</u> on the NOVA.  He had coded it up (in BASIC!), added a lot of
		details, such as a token scanner, a list maker, etc., and there it was—running.  As he liked to say: &#34;You
		just do it and it&#39;s done.&#34;
		</p>
		<p>
		It evaluated <i>3+4</i> <u>v e r y  s l o w l y</u> (it was &#34;glacial&#34;, as Butler liked to say) but the answer always
		came out 7.  Well, there was nothing to do but keep going.  Dan loved to bootstrap on a system that
		&#34;always ran,&#34; and over the next ten years he made at least 80 major releases of various flavors of
		Smalltalk.
		</p>
		<p>
		In November, I presented these ideas and a  demonstration of the interpretation scheme to the MIT
		AI lab.  This eventually led to Carl Hewitt&#39;s more formal &#34;Actor&#34; approach [Hewitt 73].  In the first
		Actor paper the resemblance to Smalltalk is at its closest.  The paths later diverged, partly because we
		were much more interested in making things than theorizing, and partly because we had something
		no one else had: Chuck Thacker&#39;s Interim Dynabook (later known as the &#34;ALTO&#34;).
		</p>
		<p>
		Just before Chuck started work on the machine I gave a paper to the National Council of Teachers
		of English [Kay 72c] on the Dynabook and its potential as a learning and thinking amplifier—the
		paper was an extensive rotogravure of &#34;20 things to do with a Dynabook&#34; [Kay 72c].  By the time I got
		back from Minnesota, Stewart Brand&#39;s <i>Rolling Stone</i> article about PARC [Brand 1972] and the surrounding
		hacker community had hit the stands.  To our enormous surprise it caused a major furor at Xerox
		headquarters in Stamford, Connecticut.  Though it was a wonderful article that really caught the 
		spirit of the whole culture, Xerox went berserk, forced us to wear badges (over the years many were
		printed on t-shirts), and severely restricted the kinds of publications that could be made.  This was
		particularly disastrous for LRG, since we were the &#34;lunatic fringe&#34; (so-called by the other computer
		scientists), were planning to go out to the schools, and needed to share our ideas (and programs)
		with our colleagues such as Seymour Papert and Don Norman.
		</p>
		<p>
		Executive &#34;X&#34; apparently heard some harsh words at Stamford about us, because when he
		returned around Christmas and found out about the interim Dynabook, he got even more angry and
		tried to kill it.  Butler wound up writing a masterful defense of the machine to hold him off, and he
		went back to his &#34;task force.&#34;
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/bilbo.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/bilbo.jpg" alt="BILBO, the first &#39;interim Dynabook&#39;, and Cookie Monster&#39;, the first graphics it displayed. April, 1973"/></a>
		<p>
		Chuck had started his &#34;bet&#34; on November 22, 1972.  He and two technicians did all of the machine
		except for the disk interface which was done by Ed McCreight.  It had a ~500,000 pixel (606x808)
		bitmap display, its microcode instruction rate was about 6 MIPS, it had a grand total of 128k, and the
		entire machine (exclusive of the memory) was rendered in 160 MSI chips distributed on two cards.  It
		was beautiful [Thacker 1972, 1986].  One of the wonderful features of the machine was &#34;zero-over-head&#34;
		tasking.  It had 16 program counters, one for each task.  Condition flags were tied to interesting
		events (such as &#34;horizontal retrace pulse&#34;, and &#34;disk sector pulse&#34;, etc.).  Lookaside logic scanned the
		flags while the current instruction was executing and picked the highest priority program counter to
		fetch from next.  The machine never had to wait, and the result was that most hardware functions
		(particularly those that involved i/o (like feeding the display and handling the disk) could be
		replaced by microcode.  Even the refresh of the MOS dynamic RAM was done by a task.  In other
		words, this was a coroutine architecture.  Chuck claimed that he got the idea from a lecture I had
		given on coroutines a few months before, but I remembered that Wes Clark&#39;s TX-2 (the Sketchpad
		machine) had used the idea first, and I 
		probably mentioned that in the talk.
		</p>
		<p>
		In early April, just a little over three
		months from the start, the first Interim Dynabook, known as &#39;Bilbo,&#39; greeted the
		world and we had the first bit-map picture
		on the screen within minutes: the Muppets&#39; Cookie Monster that I had
		sketched on our painting system.
		</p>
		<p>
		Soon Dan had bootstrapped Smalltalk across, and for many months it was the sole software system to run on the
		Interim Dynabook.  Appendix I has an 
		&#34;acknowledgements&#34; document I wrote
		from this time that is interesting in its
		allocation of credits and the various 
		priorities associated with them.  My $230K
		was enough to get 15 of the original
		projected 30 machines (over the years some 2000 Interim Dynabooks were actually built).  True to
		Schopenhauer&#39;s observation, Executive &#34;X&#34; now decided that the Interim Dynabook was a <u>good</u> idea
		and he wanted <u>all but two</u> for his lab (I was in the other lab).  I had to go to considerable lengths to
		get our machines back, but finally succeeded.
		</p>
                <div>
		  <ol>
		    <li>Everything is an object</li>
		    <li>Objects communicate by sending and 
		      receiving <i>messages</i> (in terms of objects)</li>
		    <li>Objects have their <i>own memory</i> 
		      (in terms of objects)</li>
		    <li>Every object is an instance of a <i>class</i>
		      (which must be an object)</li>
		    <li>The class holds the shared <i>behavior</i>
		      for its instances (in the form of objects in a program list)</li>
		    <li>To eval a program list, control is passed to
			the first object and the remainder is treated
			as its message
		    </li>
		  </ol>
                </div>
                
		<p>
		By this time most of Smalltalk&#39;s schemes had been sorted
		out into six main ideas that were in accord with the initial
		premises in designing the interpreter.  The first three principles
		are what objects &#34;are about&#34;—how they are seen and
		used from &#34;the outside.&#34;  These did not require any modification
		over the years.  The last three—objects from the
		inside—were tinkered with in every version of Smalltalk
		(and in subsequent OOP designs).  In this scheme (1 &amp; 4)
		imply that classes are objects and that they must be 
		instances of themself.  (6) implies a LISPlike universal syntax,
		but with the receiving object as the first item followed by the
		message.  Thus <code>c<sub>i</sub> &lt;- de</code> (with subscripting rendered as &#34;○&#34;
		and multiplication as &#34;*&#34;) means:
		</p>
		<table summary="receiver and message">
			<tbody><tr><td><u>receiver</u></td><td><u>| message</u></td></tr>
			<tr><td><i>c</i></td><td><i>| ○ i &lt;- d*e</i></td></tr>
		</tbody></table>
		<p>
		The c is bound to the receiving object, and <u>all</u> of <code>○ i &lt;- d*e</code> is the message to it.  The message is made
		up of literal token &#34;○&#34;, an expression to be evaluated in the sender&#39;s context (in this case i), another
		literal token &lt;-, followed by an expression to be evaluated in the sender&#39;s context (d*e).  Since &#34;LISP&#34;
		pairs are made from 2 element objects they can be indexed more simply: <code>c hd</code>, <code>c tl</code>, and <code>c hd &lt;- foo</code>, etc.
		</p>
		<p>
		&#34;Simple&#34; expressions like <i>a+b</i> and <i>3+4</i> seemed more troublesome at first.  Did it really make sense
		to think of them as:
		</p>
		<table summary="receiver and message">
			<tbody><tr><td><u>receiver</u></td><td><u>| message</u></td></tr>
			<tr><td><i>a</i></td><td><i>| + b</i></td></tr>
			<tr><td><i>3</i></td><td><i>| + 4</i></td></tr>
		</tbody></table>
		<p>
		It seemed silly if only integers were considered, but there are many other metaphoric readings of
		&#34;+&#34;, such as:
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/add.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/add.jpg" alt="&#34;kitty&#34; |+ &#34;kat&#34; =&gt; &#34;kittykat&#34; [3 4 5 6 7 8] |+ 4 = [7 8 9 10 11 12]"/></a>
		<p>
		This led to a style of finding <i>generic behaviors</i> for message symbols.  &#34;Polymorphism&#34; is the official
		term (I believe derived from Strachey), but it is not really apt as its original meaning applied only to
		functions that could take more than one type of argument.  An example class of objects in Smalltalk-72,
		such as a model of CONS pairs, would look like:
		</p>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/conspairs.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/conspairs.jpg" alt="Model of CONS pairs"/></a>

		<p>Since control is passed to the class before any of the rest of the message is considered—the class
		can decide <u>not</u> to receive at its discretion—complete protection is retained.  Smalltalk-72 objects are
		&#34;shiny&#34; and impervious to attack.  Part of the environment is the binding of the SENDER in the 
		&#34;messenger object&#34; (a generalized activation record) which allows the receiver to determine differential
		privileges (see Appendix II for more details).  This looked ahead to the eventual use of Smalltalk as a
		network OS (See [Goldstein &amp; Bobrow 1980]), and I don&#39;t recall it being used very much in Smalltalk-72.
		</p>
		<p>
		One of the styles retained from Smalltalk-71 was the comingling of function and class ideas.  In
		other works, Smalltalk-72 classes looked like and could be used as functions, but it was easy to
		produce an instance (a kind of closure) by using the object ISNEW.  Thus factorial could be written
		&#34;extensionally&#34; as:
		</p>
			<p><i>to fact n (^if :n=0 then 1 else n*fact n-1)</i></p>
		<p>
		or &#34;intensionally,&#34; as part of class integer:
		</p>
			<p><i>(... ○! » (^:n=1) » (1) (n-1)!)</i></p>
		<p>
		Of course, the whole idea of Smalltalk (and OOP in general) is to define everything <i>intensionally</i>.
		And this was the direction of movement as we learned how to program in the new style.  I never
		liked this syntax (too many parentheses and nestings) and wanted something flatter and more 
		grammar-like as in Smalltalk-71.  To the right is an example 
		syntax from the notes of a talk I gave around
		then.  We will see something more like this a few
		years later in Dan&#39;s design for Smalltalk-76.  I think
		something similar happened with LISP—that the
		&#34;reality&#34; of the straightforward and practical syntax
		you could program in prevailed against the flights
		of fancy that never quite got built.
		</p>

<div>
<p>Proposed Smalltalk-72 Syntax</p>
<pre>Pair :h :t
    hd &lt;- :h
	hd              » h
	tl &lt;- :t
	tl              » t
	isPair          » true
	print           » &#39;( print. SELF mprint.
	mprint          » h print. if t isNil then &#39;) print
                               else if t isPair then t mprint
                               else &#39;* print. t print. &#39;) print
	length          » 1 + if t isList then t length else 0
</pre>
</div>
		
		<h3>Development of the Smalltalk-72 System and Applications</h3>
                <a href="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/firstbuildaltos.png" target="_blank"><img src="http://worrydream.com/EarlyHistoryOfSmalltalk/Images/thumbnails/firstbuildaltos.jpg" alt="One of the &#39;first build&#39; ALTOs, Early Smalltalk Windows on Interim Dynabook, Turtles"/></a>
		<p>
		The advent of a real Smalltalk on a real machine 
		started off an explosion of parallel paths that are too difficult
		to intertwine in strict historical order.  Let me first present
		the general development of the Smalltalk-72 system up to
		the transition to Smalltalk-76, and then follow that with
		the several years of work with children that were the
		primary motivation for the project.  The Smalltalk-72 interpreter
		on the Interim Dynabook was not exactly zippy
		(&#34;majestic&#34; was Butler&#39;s pronouncement), but was easy
		to change and quite fast enough for many real-time 
		interactive systems to be built in it.
		</p>
		<p>
		Overlapping windows were the first project tackled
		(with Diana Merry) after writing the code to read the
		keyboard and create a string of text.  Diana built an early
		version of a bit field block transfer (bitblt) for displaying
		variable pitch fonts and generally writing on the display.
		The first window versions were done as real 2½D draggable
		objects that were just a little too slow to be useful.
		We decided to wait until Steve Purcell got his animation
		system going to do it right, and opted for the style that is
		still in use today, which is more like &#34;2¼D&#34;.  Windows
		were perhaps the most redesigned and reimplemented class in Smalltalk because we didn&#39;t quite have enough
		compute power to just do the continual viewing to
		&#34;world coordinates&#34; and refreshing that my former Utah
		colleagues were starting to experiment with on the flight
		simulator projects at Evans &amp; Sutherland.  This is a simple,
		powerful model but it is difficult to do in real-time
		even in 2½D.  The first practical windows in Smalltalk
		used the GRAIL conventions of sensitive corners for moving,
		resizing, cloning, and closing.  Window scheduling
		used a simple &#34;loopless&#34; control scheme that threaded all
		of the windows together.
		</p>
		<p> One of the next classes to be implemented on the 
		Interim Dynabook (after the basics of numbers, strings,
		etc.) was an object-oriented version of the LOGO turtle
		implemented by Ted.  This could make many turtle
		instances that were used both for drawing and as a kind
		of value for graphics transformations.  Dan created a class
		of &#34;commander&#34; turtles that could control a troop of 
		turtles.  Soon the turtles were made so they could be clipped
		by the windows.
		</p>
		<p>
		John Shoch built a mouse-driven structured editor for 
		Smalltalk code.
		</p>
                <!-- table cellpadding="10" border="1" width="80%" align="center">
		<tr>
		<td valign="top">
		<b>Class new title: 'Window';<br>
		  fields: 'frame';<br>
		  asFollows!</b><br>
		<i>This is a superclass for presenting windows on the display.  It
		holds control until the stylus is depressed outside.  While it holds
		control, it distributes messages to itself based on user actions.</i><br>
		<b>Scheduling<br>
		startup</b><br>
		  [frame contains; stylus =><br>
		    self enter.<br>
		    repeat:<br>
		      [frame contains: stylus =><br>
		        [keyboard active => [ self keyboard ]<br>
		        stylus down => [ self pendown ]]<br>
		      self outside => []<br>
		      stylus down => [ ^self leave ]]]<br>
		  ^false]<br>
		<b>Default Event Responses<br>
		enter</b> [self show]<br>
		<b>leave<br>
		outside</b> [ ^false]<br>
		<b>pendown<br>
		keyboard</b> [ keyboard next.  frame flash ]<br>
		<b>Image<br>
		show</b><br>
		  [frame outline: 2.<br>
		titleframe put: self title at: frame origin + title loc.<br>
		titleframe complement]<br>
		... etc.
		</td>
		<td valign="top">
		<b>Class new title: 'DocWindow';<br>
		  subclassOf: Window;<br>
		  fields: 'document scrollbar editMenu';<br>
		  asFollows!</b><br>
		<i>User events are passed on to the document while the window is
		active.  If the stylus goes out of the window, scrollbar and the
		editMenu are each given a chance to gain control.</i>
		<b>Event Responses<br>
		enter</b> [ self show.  edit Menu show.  scrollbar show ]<br>
		<b>leave</b> [ document hideselection.  editMenu hide.  scrollbar hide ]<br>
		<b>outside</b><br>
		  [editMenu startup => []<br>
		  scrollbar startup => [self showdoc]<br>
		  ^false]<br>
		<b>pendown</b> [ document pendown ]<br>
		<b>keyboard</b> [ document keyboard ]<br>
		<b>Image<br>
		show</b> [ super show. self showDoc ]<br>
		<b>showDoc</b> [ document showin; frame at: scrollbar position ]<br>
		<b>title</b> [^document title]<br>
		</td>
		</tr>
		</table -->
		
                
                
		

		

		
                
                
		
		
		
		
		
                
		
		
		

    
	

	

		
		

		

		
		
		
		
		
		
		
		
		
		
		
		
		
                
		
		
                

									      


</div>
  </body>
</html>
