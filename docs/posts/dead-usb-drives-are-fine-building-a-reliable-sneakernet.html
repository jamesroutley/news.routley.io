<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://changelog.complete.org/archives/10421-dead-usb-drives-are-fine-building-a-reliable-sneakernet">Original</a>
    <h1>Dead USB Drives Are Fine: Building a Reliable Sneakernet</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>“OK,” you’re probably thinking.  “John, you <a href="https://www.complete.org/the-pc-internet-revolution-in-rural-america/">talk a lot</a> about things like <a href="https://www.complete.org/gopher/">Gopher</a> and <a href="https://www.complete.org/the-joy-of-easy-personal-radio-frs-gmrs-and-motorola-dlr-dtr/">personal radios</a>, and now you want to talk about building a reliable network out of…  <em>USB drives</em>?”</p>
<p>Well, yes.  In fact, I’ve already done it.</p>
<h2 id="what-is-sneakernet">What is sneakernet?</h2>
<p>Normally, “<a href="https://en.wikipedia.org/wiki/Sneakernet">sneakernet</a>” is a sort of tongue-in-cheek reference to using disconnected storage to transport data or messages.  By “disconnect storage” I mean anything like CD-ROMs, hard drives, SD cards, USB drives, and so forth.  There are times when loading up 12TB on a device and driving it across town is just faster and easier than using the Internet for the same.  And, sometimes you need to get data to places that have no Internet at all.</p>
<p>Another reason for sneakernet is security.  For instance, if your backup system is online, and your systems being backed up are online, then it could become possible for an attacker to destroy both your primary copy of data and your backups.  Or, you might use a dedicated computer with no network connection to do <a href="https://www.complete.org/gnupg-gpg/">GnuPG (GPG)</a> signing.</p>
<h2 id="what-about-reliable-sneakernet-then">What about “reliable” sneakernet, then?</h2>
<p>TCP is often considered a “reliable” protocol.  That means that the sending side is generally able to tell if its message was properly received.   As with most reliable protocols, we have these components:</p>
<ol>
<li>After transmitting a piece of data, the sender retains it.</li>
<li>After receiving a piece of data, the receiver sends an acknowledgment (<a href="https://en.wikipedia.org/wiki/Acknowledgement%5F(data%5Fnetworks)">ACK</a>) back to the sender.</li>
<li>Upon receiving the acknowledgment, the sender removes its buffered copy of the data.</li>
<li>If no acknowledgment is received at the sender, it <a href="https://en.wikipedia.org/wiki/Automatic%5Frepeat%5Frequest">retransmits</a> the data, in case it gets lost in transit.</li>
<li>It reorders any packets that arrive out of order, so that the recipient’s data stream is ordered correctly.</li>
</ol>
<p>Now, a lot of the things I just mentioned for sneakernet are legendarily unreliable.  USB drives fail, CD-ROMs get scratched, hard drives get banged up.  Think about putting these things in a bicycle bag or airline luggage.  Some of them are going to fail.</p>
<p>You might think, “well, I’ll just <em>copy</em> files to a USB drive instead of move them, and once I get them onto the destination machine, I’ll delete them from the source.”  Congratulations!  You are a human retransmit algorithm!  We should be able to automate this!</p>
<p>And we can.</p>
<h2 id="enter-nncp">Enter NNCP</h2>
<p><a href="https://www.complete.org/nncp/">NNCP</a> is one of those things that almost defies explanation.  It is a toolkit for building asynchronous networks.  It can use as a carrier: a pipe, TCP network connection, a mounted filesystem (specifically intended for cases like this), and much more.  It also supports multi-hop asynchronous routing and asynchronous meshing, but these are beyond the scope of this particular article.</p>
<p>NNCP’s transports that involve live communication between two hops already had all the hallmarks of being reliable; there was a positive ACK and retransmit.  As of version 8.7.0, NNCP’s ACKs themselves can also be asynchronous – meaning that <em>every NNCP transport can now be reliable</em>.</p>
<p>Yes, that’s right.  Your ACKs can flow over tapes and USB drives if you want them to.</p>
<p>I use this for archiving and backups.</p>
<p>If you aren’t already familiar with NNCP, you might take a look at my <a href="https://www.complete.org/nncp/">NNCP</a> page.  I also have <a href="https://changelog.complete.org/archives/tag/nncp">a lot of blog posts</a> about NNCP.</p>
<p>Those pages describe the basics of NNCP: the “packet” (the unit of transmission in NNCP, which can be tiny or many TB), the end-to-end encryption, and so forth.  The new command we will now be interested in is nncp-ack.</p>
<h2 id="the-basic-idea">The Basic Idea</h2>
<p>Here are the basic steps to processing this stuff with NNCP:</p>
<ol>
<li>First, we use <code>nncp-xfer -rx</code> to process incoming packets from the USB (or other media) device.  This <em>moves</em> them into the NNCP inbound queue, deleting them from the media device, and verifies the packet integrity.</li>
<li>We use <code>nncp-ack -node $NODE</code> to create ACK packets responding to the packets we just loaded into the rx queue.  It writes a list of generated ACKs onto fd 4, which we save off for later use.</li>
<li>We run <code>nncp-toss -seen</code> to process the incoming queue.  The use of <code>-seen</code> causes NNCP to remember the hashes of packets seen before, so a duplicate of an already-seen packet will not be processed twice.  This command also processes incoming ACKs for packets we’ve sent out previously; if they pass verification, the relevant packets are removed from the local machine’s tx queue.</li>
<li>Now, we use <code>nncp-xfer -keep -tx -mkdir -node $NODE</code> to send outgoing packets to a given node by writing them to a given directory on the media device.  <code>-keep</code> causes them to remain in the outgoing queue.</li>
<li>Finally, we use the list of generated ACK packets saved off in step 2 above.  That list is passed to <code>nncp-rm -node $NODE -pkt &lt; $FILE</code> to remove those specific packets from the outbound queue.  The reason is that there will never be an ACK of ACK packet (that would create an infinite loop), so if we don’t delete them in this manner, they would hang around forever.</li>
</ol>
<p>You can see these steps follow the same basic outline on <a href="https://nncp.mirrors.quux.org/nncp%5F002dack.html">upstream’s nncp-ack page</a>.</p>
<p>One thing to keep in mind: if anything else is running <code>nncp-toss</code>, there is a chance of a race condition between steps 1 and 2 (if nncp-toss gets to it first, it might not get an ack generated).  This would sort itself out eventually, presumably, as the sender would retransmit and it would be ACKed later.</p>
<h2 id="further-ideas">Further ideas</h2>
<p>NNCP guarantees the integrity of packets, but not ordering between packets; if you need that, you might look into my <a href="https://www.complete.org/filespooler/">Filespooler</a> program.  It is designed to work with NNCP and can provide ordered processing.</p>
<h2 id="an-example-script">An example script</h2>
<p>Here is a script you might try for this sort of thing.  It may have more logic than you need – really, you just need the steps above – but hopefully it is clear.</p>
<div>
<pre tabindex="0"><code data-lang="text">#!/bin/bash

set -eo pipefail

MEDIABASE=&#34;/media/$USER&#34;

# The local node name
NODENAME=&#34;`hostname`&#34;

# All nodes.  NODENAME should be in this list.
ALLNODES=&#34;node1 node2 node3&#34;

RUNNNCP=&#34;&#34;
# If you need to sudo, use something like RUNNNCP=&#34;sudo -Hu nncp&#34;
NNCPPATH=&#34;/usr/local/nncp/bin&#34;

ACKPATH=&#34;`mktemp -d`&#34;

# Process incoming packets.
#
# Parameters: $1 - the path to scan.  Must contain a directory
# named &#34;nncp&#34;.
procrxpath () {
    while [ -n &#34;$1&#34; ]; do
        BASEPATH=&#34;$1/nncp&#34;
        shift
        if ! [ -d &#34;$BASEPATH&#34; ]; then
            echo &#34;$BASEPATH doesn&#39;t exist; skipping&#34;
            continue
        fi

        echo &#34; *** Incoming: processing $BASEPATH&#34;
        TMPDIR=&#34;`mktemp -d`&#34;

        # This rsync and the one below can help with
        # certain permission issues from weird foreign
        # media.  You could just eliminate it and
        # always use $BASEPATH instead of $TMPDIR below.
        rsync -rt &#34;$BASEPATH/&#34; &#34;$TMPDIR/&#34;

        # You may need these next two lines if using sudo as above.
        # chgrp -R nncp &#34;$TMPDIR&#34;
        # chmod -R g+rwX &#34;$TMPDIR&#34;
        echo &#34;     Running nncp-xfer -rx&#34;
        $RUNNNCP $NNCPPATH/nncp-xfer -progress -rx &#34;$TMPDIR&#34;

        for NODE in $ALLNODES; do
                if [ &#34;$NODE&#34; != &#34;$NODENAME&#34; ]; then
                        echo &#34;     Running nncp-ack for $NODE&#34;

                        # Now, we generate ACK packets for each node we will
                        # process.  nncp-ack writes a list of the created
                        # ACK packets to fd 4.  We&#39;ll use them later.
                        # If using sudo, add -C 5 after $RUNNNCP.
                        $RUNNNCP $NNCPPATH/nncp-ack -progress -node &#34;$NODE&#34; \
                           4&gt;&gt; &#34;$ACKPATH/$NODE&#34;
                fi
        done

        rsync --delete -rt &#34;$TMPDIR/&#34; &#34;$BASEPATH/&#34;
        rm -fr &#34;$TMPDIR&#34;
    done
}


proctxpath () {
    while [ -n &#34;$1&#34; ]; do
        BASEPATH=&#34;$1/nncp&#34;
        shift
        if ! [ -d &#34;$BASEPATH&#34; ]; then
            echo &#34;$BASEPATH doesn&#39;t exist; skipping&#34;
            continue
        fi

        echo &#34; *** Outgoing: processing $BASEPATH&#34;
        TMPDIR=&#34;`mktemp -d`&#34;
        rsync -rt &#34;$BASEPATH/&#34; &#34;$TMPDIR/&#34;
        # You may need these two lines if using sudo:
        # chgrp -R nncp &#34;$TMPDIR&#34;
        # chmod -R g+rwX &#34;$TMPDIR&#34;

        for DESTHOST in $ALLNODES; do
            if [ &#34;$DESTHOST&#34; = &#34;$NODENAME&#34; ]; then
                continue
            fi

            # Copy outgoing packets to this node, but keep them in the outgoing
            # queue with -keep.
            $RUNNNCP $NNCPPATH/nncp-xfer -keep -tx -mkdir -node &#34;$DESTHOST&#34; -progress &#34;$TMPDIR&#34;

            # Here is the key: that list of ACK packets we made above - now we delete them.
            # There will never be an ACK for an ACK, so they&#39;d keep sending forever
            # if we didn&#39;t do this.
            if [ -f &#34;$ACKPATH/$DESTHOST&#34; ]; then
                echo &#34;nncp-rm for node $DESTHOST&#34;
                $RUNNNCP $NNCPPATH/nncp-rm -debug -node &#34;$DESTHOST&#34; -pkt &lt; &#34;$ACKPATH/$DESTHOST&#34;
            fi

        done

        rsync --delete -rt &#34;$TMPDIR/&#34; &#34;$BASEPATH/&#34;
        rm -rf &#34;$TMPDIR&#34;

        # We only want to write stuff once.
        return 0
    done
}

procrxpath &#34;$MEDIABASE&#34;/*

echo &#34; *** Initial tossing...&#34;

# We make sure to use -seen to rule out duplicates.
$RUNNNCP $NNCPPATH/nncp-toss -progress -seen

proctxpath &#34;$MEDIABASE&#34;/*

echo &#34;You can unmount devices now.&#34;

echo &#34;Done.&#34;
</code></pre>
</div>
<hr/>
<p><b><i>This post is also <a href="https://www.complete.org/dead-usb-drives-are-fine-building-a-reliable-sneakernet/">available on my webiste</a>, where it may be periodically updated.</i></b></p>
	</div></div>
  </body>
</html>
