<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://incident.io/blog/monolith">Original</a>
    <h1>Keep the Monolith, but Split the Workloads</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>I’m a big fan of monolithic architectures. Writing code is hard enough without each function call requiring a network request, and that’s before considering the investment in observability, RPC frameworks, and dev environments you need to be productive in a microservice environment.</p>
<p>But having spent half a decade stewarding a Ruby monolith from 20 to 200 engineers and watched its modest 10GB Postgres database grow beyond 5TB, there’s definitely a point where the pain outweighs the benefits.</p>
<p>This post is about a technique – splitting your workloads – that can significantly reduce that pain, costs little, and can be applied early. Something that if executed well, can let you enjoy that sweet monolithic goodness for that much longer.</p>
<p>Let’s dive in!</p>
<h2 id="wild-outage-appears">Wild outage appears!</h2>
<p>Back in November 2022 we had an outage we affectionately called <a href="https://incident.io/blog/intermittent-downtime">“Intermittent downtime from repeated crashes”</a>.</p>
<p>Probably the first genuinely major outage we’ve faced, it resulted in our app repeatedly crashing over a period of 32 minutes. Pretty stressful stuff, even for responders who spend their entire day jobs building incident tooling.</p>
<p>While the post-mortem goes into detail, the gist of the issue was:</p>
<ul>
<li>We run our app as a Go monolith in Heroku, using Heroku Postgres as a database, and GCP Pub/Sub as an async message queue.</li>
<li>Our application runs several replicas of a single binary running web, worker and cron threads.</li>
<li>When a bad Pub/Sub message was pulled into the binary, an unhandled panic would crash the entire app, meaning web, workers and crons all died.</li>
</ul>
<p>Well that sucks, and seems easily avoidable. If only we’d built everything as microservices, we’d only have crashed the service responsible for that message, right?</p>
<h2 id="what-is-reliability-really">What is reliability, really?</h2>
<p>The most common reason teams opt for a microservice architecture tends to be for reliability or scalability, often used interchangeably.</p>
<p>This means that:</p>
<ul>
<li>The blast radius of problems – such as the bad Pub/Sub message we saw above – is limited to the service it runs in, often allowing the service to degrade gracefully (continue serving most requests, failing only for certain features).</li>
<li>Each microservice can manage its own resources such as setting limits for CPU or memory that can be scaled to whatever that service needs at the time. This prevents a bad codepath from consuming all of a limited resource and impacting other code, as it might in a monolithic app.</li>
</ul>
<p>Microservices certainly solve these problems, but come with a huge amount of associated baggage (distributed system problems, RPC frameworks, etc). If we want the benefits of microservices without the baggage, we’ll need some alternative solutions.</p>
<h2 id="rule-1-never-mix-workloads">Rule 1: Never mix workloads</h2>
<p>First, we should apply the cardinal rule of running monoliths, which is: never mix your workloads.</p>
<p>For our <a href="http://incident.io">incident.io</a> app, we have three key workloads:</p>
<ul>
<li>Web servers that handle incoming requests.</li>
<li>Pub/Sub subscribers that process async work.</li>
<li>Cron jobs that fire on a schedule.</li>
</ul>
<p>We were breaking this rule by running all of this code inside of the same process (as in, literally the same linux process). And by mixing workloads we left ourselves open to:</p>
<ul>
<li>Bad code in a specific part of the codebase bringing down the whole app, as in our November incident.</li>
<li>If we deployed a Pub/Sub subscriber that was CPU heavy (maybe compressing Slack images, or a badly written loop that spun indefinitely) we’d impact the entire app, causing all web/worker/cron activity to slow to a halt. CPU in that process is a limited resource and by consuming 90% of it, we’d leave only 10% left for the other work.</li>
</ul>
<p>The same day as our incident occurred, we split our app into separate tiers of deployment for each workload type. This meant creating three separate dyno tiers in Heroku, which for those unfamiliar with Heroku just means three independent deployments of the app processing only its own type of workload.</p>
<p><span>
      <span></span>
  <img alt="Three dynos in Heroku" title="Three dynos in Heroku" src="https://brian.abelson.live/static/bbf88c74cc0c8d546bed5ee403d0de89/00d43/dynos.png" srcset="/static/bbf88c74cc0c8d546bed5ee403d0de89/63868/dynos.png 250w,
/static/bbf88c74cc0c8d546bed5ee403d0de89/0b533/dynos.png 500w,
/static/bbf88c74cc0c8d546bed5ee403d0de89/00d43/dynos.png 1000w,
/static/bbf88c74cc0c8d546bed5ee403d0de89/aa440/dynos.png 1500w,
/static/bbf88c74cc0c8d546bed5ee403d0de89/e7aec/dynos.png 1726w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" decoding="async"/>
    </span></p>
<p>You might ask if we’re doing this, then why not go the whole way and have separate microservices?</p>
<p>The answer is that this split preserves all the benefits of the monolith while totally solving the problems we presented above. Every deployment is running the same code, using the same Docker image and environment variables, the only thing that differs is the command we run to start the code. No complex dev setup required, or RPC framework needed, it’s the same old monolith, just operated differently.</p>
<p>Our application entrypoint code looks a bit like this:</p>
<div data-language="go"><pre><code><span>package</span> main

<span>var</span> <span>(</span>
  app     <span>=</span> kingpin<span>.</span><span>New</span><span>(</span><span>&#34;app&#34;</span><span>,</span> <span>&#34;incident.io&#34;</span><span>)</span>
  web     <span>=</span> app<span>.</span><span>Flag</span><span>(</span><span>&#34;web&#34;</span><span>,</span> <span>&#34;Run web server&#34;</span><span>)</span><span>.</span><span>Bool</span><span>(</span><span>)</span>
  workers <span>=</span> app<span>.</span><span>Flag</span><span>(</span><span>&#34;workers&#34;</span><span>,</span> <span>&#34;Run async workers&#34;</span><span>)</span><span>.</span><span>Bool</span><span>(</span><span>)</span>
  cron    <span>=</span> app<span>.</span><span>Flag</span><span>(</span><span>&#34;cron&#34;</span><span>,</span> <span>&#34;Run cron jobs&#34;</span><span>)</span><span>.</span><span>Bool</span><span>(</span><span>)</span>
<span>)</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
	<span>if</span> <span>*</span>web <span>{</span>
    
  <span>}</span>
	<span>if</span> <span>*</span>workers <span>{</span>
    
  <span>}</span>
	<span>if</span> <span>*</span>cron <span>{</span>
    
  <span>}</span>

	<span>wait</span><span>(</span><span>)</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>You can easily add this to any application, with the neat benefit that for your local development environment, you can have all components running in a single hot-reloaded process (a pipe dream for many microservice shops!).</p>
<p>As a small catch to switching over blindly, be aware that code assuming everything runs within the same process is both hard to recognise, subtly buggy, and difficult to fix. If, for example, your web server code stashes data in a process-local cache that the worker attempts to use, you’re going to have a sad time.</p>
<p>The good news is those dependencies are generally code smells are easily solved by pushing coordination into an external store such as Postgres or Redis, and won’t reappear after you’ve made the initial change. Worth doing even if you aren’t splitting your code, in my opinion.</p>
<p>Note there’s no limit to how granular you split these workloads. I’ve seen a deployment per queue or even job class before, going up to ~20 deployments for a single application environment.</p>
<h2 id="rule-2-apply-guardrails">Rule 2: Apply guardrails</h2>
<p>Ok, so our monolith is no longer a big bundle of code running all the things: it’s three separate, isolated deployments that can succeed or fail independently. Great.</p>
<p>Most people’s applications aren’t just about the code running in the process, though. One of the most significant reliability risks is rogue or even well-behaved but unfortunately timed code consuming the most precious of a monoliths limited resources, which is usually…</p>
<p>Database capacity. In our case, Postgres.</p>
<p>Even having split your workloads, you’ll always have the underlying data store that needs some form of protection. And this is where microservices – which often try to share nothing – can help, with each service deployment only able to indirectly consume database time via another services API.</p>
<p>This is solvable in our monolith though, we just need to <strong>create guardrails and limits around resource consumption</strong>. Limits that can be arbitrarily granular.</p>
<p>In our code, the guardrails around our Postgres database look like this:</p>
<div data-language="go"><pre><code><span>package</span> main

<span>var</span> <span>(</span>
  
  workers <span>=</span> app<span>.</span><span>Flag</span><span>(</span><span>&#34;workers&#34;</span><span>,</span> <span>&#34;Run async workers&#34;</span><span>)</span><span>.</span><span>Bool</span><span>(</span><span>)</span>
  workersDatabase <span>=</span> <span>new</span><span>(</span>database<span>.</span>ConnectOptions<span>)</span><span>.</span><span>Bind</span><span>(</span>
		app<span>,</span> <span>&#34;workers.database.&#34;</span><span>,</span> <span>20</span><span>,</span> <span>5</span><span>,</span> <span>&#34;30s&#34;</span><span>)</span>
<span>)</span>

<span>func</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  
  <span>if</span> <span>*</span>workers <span>{</span>
    db<span>,</span> err <span>:=</span> <span>createDatabasePool</span><span>(</span>ctx<span>,</span> <span>&#34;worker&#34;</span><span>,</span> workersDatabase<span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>return</span> errors<span>.</span><span>Wrap</span><span>(</span>err<span>,</span> <span>&#34;connecting to Postgres pool for workers&#34;</span><span>)</span>
		<span>}</span>

    <span>runWorkers</span><span>(</span>db<span>)</span> 
  <span>}</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>This code sets and allows customisation of the database pool used specifically for workers. The defaults mean “maximum of 20 active connections, allowing up to 5 idle connections, with a 30s statement timeout”.</p>
<p>Perhaps easier to see from the <code>app --help</code> output:</p>
<div data-language="go"><pre><code><span>--</span>workers<span>.</span>database<span>.</span>max<span>-</span>open<span>-</span>connections<span>=</span><span>20</span>
    Max database connections to open against the Postgres server
<span>--</span>workers<span>.</span>database<span>.</span>max<span>-</span>idle<span>-</span>connections<span>=</span><span>5</span>
    Max database connections to keep open while idle
<span>--</span>workers<span>.</span>database<span>.</span>max<span>-</span>connection<span>-</span>idle<span>-</span>time<span>=</span><span>10</span>m
    Max time to wait before closing idle Postgres server connections
<span>--</span>workers<span>.</span>database<span>.</span>max<span>-</span>connection<span>-</span>lifetime<span>=</span><span>60</span>m
    Max time to reuse a connection before recycling it
<span>--</span>workers<span>.</span>database<span>.</span>statement<span>-</span>timeout<span>=</span><span>&#34;30s&#34;</span>
    What to set as a statement timeout</code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Most applications will specify values for their connection pool, but the key ah-ha moment is that we have separate pools for any type of work we want to throttle or restrict, anticipating that it might – in an incident situation – consume too much database capacity and impact other components of the service.</p>
<p>Just some examples are:</p>
<ul>
<li><code>eventsDatabase</code> which is a pool of 2 connections used by a worker that consumes a copy of every Pub/Sub event and pushes it to BigQuery for later analysis. We don’t care about this queue falling behind but it would be very bad if it rinsed the database, especially if that happens – and it naturally would – at time when our service was most busy.</li>
<li><code>triggersDatabase</code> with 5 connections used by a cron job that scans all incidents for recent activity, helping drive nudges like “it’s been a while, would you like to send another incident update?”. These queries are expensive and nudges are best effort, so we’d rather fall behind than hurt the database trying to keep up.</li>
</ul>
<p>Using limits like this can help you protect a shared resource like database capacity from being overly consumed by any one part of your monolith. If you make them extremely easy to configure – as we have via a shared <code>database.ConnectOptions</code> helper – then it’s minimal effort to specify up-front “I expect to consume only up-to X of this resource, and beyond that I’d like to know”.</p>
<p>Useful for any moderately sized monolith, but even more powerful when multiple teams work in different parts of the codebase and protecting everyone from one another becomes a priority.</p>
<h2 id="your-monolith-keep-it">Your monolith? Keep it!</h2>
<p>Obviously you hit issues when scaling a monolith, but here’s the secret: microservices aren’t all rainbows and butterflies, and distributed system problems can be <em>really</em> nasty.</p>
<p>So let’s not throw the baby out with the bathwater. When you hit monolith scaling issues, try asking yourself “what is really the issue here?”. Most of the time you can add guardrails or build limits into your code that emulate some of the benefits of microservices while keeping yourself single codebase and avoiding the RPC complexity.</p></div></div></div></div>
  </body>
</html>
