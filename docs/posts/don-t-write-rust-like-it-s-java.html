<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jgayfer.com/dont-write-rust-like-java/">Original</a>
    <h1>Don&#39;t write Rust like it&#39;s Java</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article"><p>I’ve been interested in the <em>idea</em> of Rust for a couple years now. Type safe, memory safe, and an emphasis on correctness. What’s not to love?</p>
<p>The percentage of errors I encounter while working on <a href="https://apollo.fyi">Apollo</a> (a Python app) that could have been caught by the Rust compiler is quite high (I won’t claim 100%, but pretty close). In general, compilers can catch a lot of issues that might otherwise make their way to production when using a dynamic language (like Python or Ruby), though not all compilers are equal. Type safety is great, but Rust’s emphasis on <em>correctness</em> is where I find the most appeal.</p>
<p>I’ve been writing a fair chunk of Java at work. While not my favourite language, the compile time checks are empowering. Significant refactors aren’t as scary as in Python or Ruby. You have the compiler on your side! An incorrect or missing import statement isn’t going to grind your program to a halt at runtime. We usually have tests to catch these issues, yes, but there’s something to be said about having these checks baked into the language.</p>
<p>The Java compiler isn’t perfect however. There are entire classes of errors it does not protect against, the most infamous being null references. (Almost) everything can be null in Java, and you won’t find out until runtime. Rust on the other hand has constructs in place to guide you towards handling unknown values. You can of course choose to ignore such guidances, but the compiler forces you to make a deliberate decision to do so.</p>
<p>So is Rust a better Java? There is certainly a lot to like. The <em>promise</em> of Rust is one I find incredibly enticing. But my Rust journey hasn’t been all sunshine and rainbows. Despite the similarities, Rust is <em>not</em> Java. I didn’t discover the joy of writing Rust code until I stopped trying to make the language something it isn’t.</p>
<h2 id="everything-must-be-an-interface">Everything must be an interface</h2>
<p>While not entirely accurate, there’s some truth to the trope that Java developers need everything to be an interface (I am one such developer). Interfaces in Java are fun to work with. Your application is composed of small units of work, where no one unit of work has direct knowledge of the inner workings of another. Bootstrapping your dependency tree requires some work up front, but once complete, you have an army of independent services at your beck and call.</p>
<p>We don’t have interfaces in Rust; we have <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>. They’re similar to interfaces in Java in many ways. However, attempting to make <em>everything</em> a trait in Rust isn’t fun. Remember that great feature of Rust being memory safe? It comes at the cost of not being able to easily “inject” something that implements a trait.</p>
<pre is:raw="" tabindex="0"><code><span><span>trait</span><span> </span><span>Named</span><span> {</span></span>
<span><span>    </span><span>fn</span><span> </span><span>name</span><span>(&amp;</span><span>self</span><span>) -&gt; </span><span>String</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>struct</span><span> </span><span>Service</span><span> {</span></span>
<span><span>    </span><span>named</span><span>: </span><span>Named</span></span>
<span><span>}</span></span></code></pre>
<p>The above code will not compile, as the size of <code>Named</code> cannot be determined at compile time. To get around this, we can <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">“box”</a> the trait, allowing us to point to dynamically allocated memory on the heap (called a trait object). The <code>Box</code> itself is of a known size, allowing our program to compile.</p>
<pre is:raw="" tabindex="0"><code><span><span>trait</span><span> </span><span>Named</span><span> {</span></span>
<span><span>    </span><span>fn</span><span> </span><span>name</span><span>(&amp;</span><span>self</span><span>) -&gt; </span><span>String</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>struct</span><span> </span><span>Service</span><span> {</span></span>
<span><span>    </span><span>named</span><span>: </span><span>Box</span><span>&lt;</span><span>dyn</span><span> </span><span>Named</span><span>&gt;</span></span>
<span><span>}</span></span></code></pre>
<p>Boxing isn’t my favourite pattern as they’re awkward to work with. I avoid them if possible. We can instead use <em>generics</em> to specify the trait type.</p>
<pre is:raw="" tabindex="0"><code><span><span>trait</span><span> </span><span>Named</span><span> {</span></span>
<span><span>    </span><span>fn</span><span> </span><span>name</span><span>(&amp;</span><span>self</span><span>) -&gt; </span><span>String</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>struct</span><span> </span><span>Service</span><span>&lt;</span><span>T</span><span>: </span><span>Named</span><span>&gt; {</span></span>
<span><span>    </span><span>named</span><span>: </span><span>T</span></span>
<span><span>}</span></span></code></pre>
<p>How is this different? At first glance the result is the same. The difference comes down to <strong>dynamic</strong> vs <strong>static</strong> dispatch. With a trait object, the concrete type is resolved at <em>runtime</em>. With generics, the concrete type is resolved at <em>compile time</em>.</p>
<p>In practice this means that as long as we can infer all types at compile time, we can get away with generics. If types cannot be inferred until runtime, a box is necessary.</p>
<h2 id="what-about-ownership">What about ownership?</h2>
<p>The question of ownership remains. What if our <code>Named</code> trait is a required dependent of other services in our application? Do we create a single “master” <code>Named</code> and pass in a <code>&amp;Named</code> to each dependant, introducing lifetimes?</p>
<pre is:raw="" tabindex="0"><code><span><span>struct</span><span> </span><span>Service</span><span>&lt;&#39;</span><span>a</span><span>&gt; {</span></span>
<span><span>    </span><span>named</span><span>: &amp;&#39;</span><span>a</span><span> </span><span>dyn</span><span> </span><span>Named</span></span>
<span><span>}</span></span></code></pre>
<p>Or do we use an <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> such that our dependent services hold onto an <code>Arc&lt;dyn Named&gt;</code>, allowing concurrent access of the owned resource?</p>
<pre is:raw="" tabindex="0"><code><span><span>struct</span><span> </span><span>Service</span><span> {</span></span>
<span><span>    </span><span>named</span><span>: </span><span>Arc</span><span>&lt;</span><span>dyn</span><span> </span><span>Named</span><span>&gt;</span></span>
<span><span>}</span></span></code></pre>
<p>I’ve tried both approaches. They <em>work</em>, but aren’t enjoyable, especially when every service in our app is affected.</p>
<h2 id="its-okay-to-use-functions">It’s okay to use functions</h2>
<p>Forcing Rust to be a purely object oriented language isn’t fun. While I do still write “service objects” as in the above examples, I try and only use them where necessary, instead preferring functions.</p>
<p>Consider a function for handling a Stripe checkout session complete event that updates the Stripe customer ID in our system.</p>
<pre is:raw="" tabindex="0"><code><span><span>async</span><span> </span><span>fn</span><span> </span><span>handle_session_completed</span><span>(</span></span>
<span><span>    </span><span>user_repo</span><span>: &amp;</span><span>mut</span><span> </span><span>impl</span><span> </span><span>UserRepo</span><span>,</span></span>
<span><span>    </span><span>session</span><span>: &amp;</span><span>CheckoutSession</span><span>,</span></span>
<span><span>) -&gt; </span><span>anyhow</span><span>::</span><span>Result</span><span>&lt;()&gt; {</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>session</span></span>
<span><span>        .client_reference_id</span></span>
<span><span>        .</span><span>clone</span><span>()</span></span>
<span><span>        .</span><span>context</span><span>(</span><span>&#34;Missing client reference ID&#34;</span><span>)?;</span></span>
<span></span>
<span><span>    </span><span>let</span><span> </span><span>customer_id</span><span> </span><span>=</span><span> </span><span>session</span></span>
<span><span>        .customer_id</span></span>
<span><span>        .</span><span>clone</span><span>()</span></span>
<span><span>        .</span><span>context</span><span>(</span><span>&#34;Missing customer ID&#34;</span><span>)?;</span></span>
<span></span>
<span><span>    </span><span>user_repo</span></span>
<span><span>        .</span><span>update_stripe_customer_id</span><span>(</span><span>user_id</span><span>, &amp;</span><span>customer_id</span><span>)</span></span>
<span><span>        .</span><span>await</span><span>?;</span></span>
<span></span>
<span><span>    </span><span>Ok</span><span>(())</span></span>
<span><span>}</span></span></code></pre>
<p>While we could have written this as a service where <code>UserRepo</code> is an injected value, doing so would introduce the complexities we’ve already explored. There’s also no <em>reason</em> to write this as a service as we can still easily inject different implementations of <code>UserRepo</code>, such as providing an implementation that doesn’t hit a live database. The downside is our function signature can get a bit busy, but this level of “pain” is nothing compared to the alternatives.</p>
<h2 id="embrace-rust-for-what-it-is">Embrace Rust for what it is</h2>
<p>I fell deep into the hole of <strong>Rust is hard</strong>. A big reason was my insistence that Rust code should look like other code I’ve written before. While drawing from the past is the boon of experience, embracing existing idioms is important to achieve mastery. Rust requires a mindset shift. Don’t fight Rust for what it isn’t, embrace it for what it is.</p></article></div>
  </body>
</html>
