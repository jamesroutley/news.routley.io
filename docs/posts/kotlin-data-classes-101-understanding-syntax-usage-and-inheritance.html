<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hardiksachan.com/kotlin-data-classes-101-understanding-syntax-usage-and-inheritance">Original</a>
    <h1>Kotlin Data Classes 101: Understanding Syntax, Usage and Inheritance</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>Welcome back to <a target="_blank" href="https://hardiksachan.hashnode.dev/series/android-zero-to-hero">this series</a> of articles on Android Development with Kotlin and Jetpack Compose. In the <a target="_blank" href="https://hardiksachan.hashnode.dev/exploring-the-kotlin-type-system-and-understanding-null-safety">previous article</a>, we discussed the type system in Kotlin along with null safety. In this article, we will take a look at what data classes are, how they differ from regular classes, and how to use them effectively in your Android app development.</p>
<p>Kotlin provides us with a special modifier for classes - <code>data</code>. Such classes are known as data classes. They are typically used to represent a data model in an application, such as a user or a product. These data classes provide useful functionalities out f the box, such as <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code> methods, which are automatically generated for us by the compiler. This can save us a lot of time and make our code more readable and maintainable.</p>
<p>Let&#39;s get started!</p>
<h2 id="heading-syntax-and-usage">Syntax And Usage</h2>
<p>Let&#39;s see how can we model a <code>User</code> class using data classes. We&#39;ll store two properties <code>name</code> and <code>age</code>.</p>
<p>To declare a data class use the <code>data</code> keyword, followed by the class declaration. Make sure that there is at least one property in the primary constructor.</p>
<pre><code><span>data</span> <span><span>class</span> <span>User</span></span>(<span>val</span> name: String, <span>val</span> age: <span>Int</span>)
</code></pre>
<p>The <code>val</code> keyword in front of the properties indicates that they are read-only, and can only be initialized in the primary constructor. We can also use <code>var</code> to make the properties mutable.</p>
<p>We can create an instance of a data class similar to that of regular classes. For example:</p>
<pre><code><span>val</span> user = User(<span>&#34;John&#34;</span>, <span>30</span>)
</code></pre>
<p>We can then access the properties of the <code>User</code> class using the dot notation:</p>
<pre><code>println(user.name) 
println(user.age) 
</code></pre>
<p>One of the main benefits of data classes is that they come with several automatically generated functions that make it easy to work with instances of the class. These functions include:</p>
<ul>
<li><p><code>equals()</code>: This function compares two instances of the data class for equality. It is generated based on the properties defined in the primary constructor.</p>
</li>
<li><p><code>hashCode()</code>: This function generates a unique hash code for an instance of the data class. It is also generated based on the properties defined in the primary constructor.</p>
</li>
<li><p><code>toString()</code>: This function generates a string representation of an instance of the data class. The default implementation includes the class name and the values of the properties.</p>
</li>
</ul>
<p>Let&#39;s see how we can use the <code>equals()</code> function to compare two instances of the <code>User</code> class:</p>
<pre><code><span>val</span> user1 = User(<span>&#34;John&#34;</span>, <span>30</span>)
<span>val</span> user2 = User(<span>&#34;John&#34;</span>, <span>30</span>)
<span>val</span> user3 = User(<span>&#34;Jane&#34;</span>, <span>25</span>)

println(user1 == user2) 
println(user1 == user3) 
</code></pre>
<p>We can also use the <code>toString()</code> function to get a string representation of an instance of the data class:</p>
<pre><code><span>val</span> user = User(<span>&#34;John&#34;</span>, <span>30</span>)
println(user) 
</code></pre>
<p>In this section, we covered the syntax and usage of data classes in Kotlin, including how to define a data class, create an instance of a data class, access its properties, and use the automatically generated functions such as <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>.</p>
<h2 id="heading-properties-declared-in-the-class-body">Properties Declared in the class body</h2>
<p>In the previous section, we took a look at how to create a data class. We declared the properties in the primary constructor but we can also declare some properties in the class body. These properties are not considered part of the primary constructor and are not included in the automatically generated functions such as <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>. However, they can still be accessed and used like any other property.</p>
<p>For example, consider the following data class:</p>
<pre><code><span>data</span> <span><span>class</span> <span>Person</span></span>(<span>val</span> name: String) {
    <span>var</span> age: <span>Int</span> = <span>0</span>
}
</code></pre>
<p>In this example, <code>name</code> is a property of the primary constructor and <code>age</code> is a property declared in the class body. When comparing two <code>Person</code> objects using the <code>==</code> operator, only the <code>name</code> property will be considered.</p>
<pre><code><span>val</span> person1 = Person(<span>&#34;John&#34;</span>)
<span>val</span> person2 = Person(<span>&#34;John&#34;</span>)
person1.age = <span>10</span>
person2.age = <span>20</span>

println(<span>&#34;person1 == person2: <span>${person1 == person2}</span>&#34;</span>)
</code></pre>
<p>This will result in <code>person1 == person2: true</code>, even though the <code>age</code> property is different between the two objects.</p>
<p>In addition, the <code>toString()</code>, <code>hashCode()</code>, and <code>copy()</code> functions will also only include the <code>name</code> property. If we wish to include additional properties in these functions, we can override them in the class body.</p>
<p>It&#39;s important to keep in mind that properties declared in the class body are not considered part of the data class&#39; signature, and thus will not affect the automatically generated functions. They can be used for additional functionality and can be used to store additional data, but it&#39;s important to consider the trade-offs.</p>
<h2 id="heading-copy"><code>Copy()</code></h2>
<p>In Kotlin, the <code>copy()</code> function is a convenient way to create a new instance of a data class while altering some or all of its properties. The <code>copy()</code> function is generated automatically by the compiler for data classes and takes all properties of the class as its parameters. The values passed to the <code>copy()</code> function will be used to create a new instance of the class, while the values that are not passed will be taken from the original instance.</p>
<p>Here is an example of using the <code>copy()</code> function in a data class:</p>
<pre><code><span>data</span> <span><span>class</span> <span>Person</span></span>(<span>val</span> name: String, <span>val</span> age: <span>Int</span>)

<span><span>fun</span> <span>main</span><span>()</span></span> {
    <span>val</span> person1 = Person(<span>&#34;John&#34;</span>, <span>25</span>)
    <span>val</span> person2 = person1.copy(age = <span>30</span>)
    println(person1) 
    println(person2) 
}
</code></pre>
<p>In this instance, <code>person1</code> is an instance of the <code>Person</code> data class, with the name &#34;John&#34; and age 25. Using the <code>copy()</code> function, we modify the age to 30 and create a new instance of the class, <code>person2</code>. As we can see, two unique instances with different age values arise from copying the name property from the original instance and setting the age property to the new value.</p>
<p>It&#39;s important to keep in mind that the <code>copy()</code> function creates a new object with the provided properties rather than <em>altering</em> the original object. This makes it a helpful tool for making minor changes to existing instances before creating new ones.</p>
<p>In conclusion, the <code>copy()</code> function in Kotlin is a simple yet powerful tool for creating new instances of data classes with modified properties. It&#39;s easy to use, and it helps to keep your code clean and readable.</p>
<h2 id="heading-desctructuting-decarations-with-data-classes">Desctructuting decarations with data classes</h2>
<p>Data classes in Kotlin come with a set of automatically generated functions, including component functions. These component functions make it possible to use data classes in destructuring declarations.</p>
<p>A destructuring declaration is a way to decompose an object into its individual properties. It allows you to assign the properties of an object to separate variables in a single line. For example, consider the following data class:</p>
<pre><code><span>data</span> <span><span>class</span> <span>Person</span></span>(<span>val</span> name: String, <span>val</span> age: <span>Int</span>)
</code></pre>
<p>We can create an instance of this class and use it in a destructuring declaration as follows:</p>
<pre><code><span>val</span> jane = Person(<span>&#34;Jane&#34;</span>, <span>35</span>)
<span>val</span> (name, age) = jane
println(<span>&#34;<span>$name</span>, <span>$age</span> years of age&#34;</span>) 
</code></pre>
<p>In this example, the variables <code>name</code> and <code>age</code> are assigned the values of the <code>name</code> and <code>age</code> properties of the <code>jane</code> object, respectively. The variables are created and initialized in a single line, making the code more concise and readable.</p>
<p>It is also possible to use destructuring declarations with a specific component function. For example, if we only need the name property of the object, we can use the <code>component1()</code> function which is generated for the first property of the data class.</p>
<pre><code><span>val</span> (name) = jane
println(<span>&#34;Name: <span>$name</span>&#34;</span>) 
</code></pre>
<p>In summary, destructuring declarations provides a convenient and readable way to work with the properties of data classes. They allow us to easily access and assign the properties of an object without having to reference the object itself. This can make our code more readable and maintainable.</p>
<h2 id="heading-conclusion">Conclusion</h2>
<p>In conclusion, data classes in Kotlin provide a simple and efficient way to define classes that hold data. They allow developers to quickly create classes with minimal boilerplate code and automatically generated functions such as <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>. They also provide a convenient way to copy objects and use them in destructuring declarations.</p>
<p>In the coming article, we&#39;ll discuss sealed classes. See you then.</p>
<p>Happy Hacking!</p>
</div></div></div>
  </body>
</html>
