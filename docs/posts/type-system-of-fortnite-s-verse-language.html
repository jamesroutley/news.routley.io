<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brianmckenna.org/blog/verse_types">Original</a>
    <h1>Type system of Fortnite&#39;s Verse language</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Epic Games released an initial public implementation of the Verse programming language. Verse has been <a href="https://simon.peytonjones.org/assets/pdfs/verse-March23.pdf" title="‌">designed by some people</a> who really know what they’re doing:</p>
<ul>
<li>Lennart Augustsson</li>
<li>Joachim Breitner</li>
<li>Koen Claessen</li>
<li>Ranjit Jhala</li>
<li>Simon Peyton Jones</li>
<li>Olin Shivers</li>
<li>Tim Sweeney</li>
</ul>
<p>It’s amazing to see a CEO help design a programming language but Tim Sweeney has been advocating for functional programming in games <a href="https://web.archive.org/web/20001202193200/http://www.gamespy.com/legacy/articles/devweek_d.shtm" title="‌">since at least 2000</a> and has previously <a href="http://www.leafpetersen.com/leaf/publications/dtp2013/lambda-aleph-overview.pdf" title="‌">worked on dependent typing</a>.</p>
<p>I’ve read comments that it’s funny for Fortnite to use such a unique and interesting functional programming language. First of all, <em>why not</em> implement Fortnite using functional programming? But it’s also missing the point.</p>
<p>The goal behind Verse is even more ambitious. When people think of Fortnite, they’re probably thinking about the battle royale game mode. A battle royale lobby has just 100 players, which fit within a single compute shard.</p>
<p>But Fortnite is much more than just battle royale. A huge number of Fortnite players are on custom game modes made by people outside of Epic Games. It’s easy to imagine game modes having a few thousand players which can’t fit within a single shard. How do you scale to handle all that game state, correctly?</p>
<p>Software transactional memory is at the core of Verse. Computation is categorised by transactions and ability to rollback. The goal is to make it easy to write working software across multiple servers. A big goal; we don’t often see programmers do that successfully!</p>
<p>As a functional programmer, here are my thoughts about the current implementation of the Verse type system.</p>
<h4 id="types-are-values">Types are values</h4>
<p>Type aliasing is giving names to types. In Verse, this works just like giving names to any other values.</p>
<pre><code>ExampleValue := &#34;Hello world&#34;

integer := int
optional(a : type)&lt;computes&gt; := ?a</code></pre>
<p>This might remind you of Agda or Idris, where type aliases are written in pretty much the same way.</p>
<p>Which might make you ask about full on dependent typing! Let’s try something simple:</p>
<pre><code>int_or_float(b : logic)&lt;computes&gt; : type :=
  if(b?):
    int
  else:
    float

X : int_or_float(true) := 10
Y : int_or_float(false) := 10.0</code></pre>
<p>The above compiles, which <em>seems</em> fantastic! We should have a type which depends on a boolean (called <code>logic</code> in Verse) - but wait!</p>
<pre><code>Z : int_or_float(false) := &#34;Hello&#34;</code></pre>
<p>The above <em>also</em> compiles. How does that make any sense?</p>
<p><code>int_or_float</code> doesn’t actually represent either an <code>int</code> or a <code>float</code>. It always represents the <code>any</code> type! I’m not sure why but it happens whenever you have an explicit return type of <code>type</code>. All of the following uselessly represent the <code>any</code> type:</p>
<pre><code>any1 : type := int
any2 : type := string
any3() : type := interface:
any4() : type := class:</code></pre>
<p>I thought that Verse should just make explicit returns of <code>type</code> into an error, but the issue is much deeper. You can write a function which allows explicit type ascription and things are still broken:</p>
<pre><code>The(x : type, X : x)&lt;computes&gt; : x := X
typeOfInt()&lt;computes&gt; := The(type, int)

# Broken()&lt;computes&gt; : int := The(typeOfInt(), 1)</code></pre>
<p>And I have no idea what the error means:</p>
<blockquote>
<p>This function parameter expects a value of type <code>tuple(type(false, int),int)</code>, but this argument is an incompatible value of type <code>tuple(supertype(int),type{1})</code></p>
</blockquote>
<p>So explicitly referencing <code>type</code> is only useful in type parameters and the only way to define an alias is to not say it returns a <code>type</code>. Maybe we can get dependent types without that! Let’s try something super simple:</p>
<pre><code>documentedInt(S : string)&lt;computes&gt; := int</code></pre>
<p>Nope, doesn’t compile. We hit an explicit Verse restriction and get an error message:</p>
<blockquote>
<p>Parameters of a function without a specified return type must be of type <code>type</code>.</p>
</blockquote>
<p>So actual dependent types are specifically prohibited right now, but I’m guessing that some form of dependent types are coming soon. The only paper available on Verse is on the untyped Verse Calculus, so it’s hard to say, but this really looks like it’s “just” an implementation restriction.</p>
<p>Simon Peyton Jones also gave an interesting type example at the <a href="https://simon.peytonjones.org/assets/pdfs/haskell-exchange-22.pdf" title="‌">Haskell Exchange</a>:</p>
<blockquote>
<p><code>isEven</code> (which succeeds on even numbers and fails otherwise) is a type</p>
</blockquote>
<p>But he must have been talking about this theoretically because I can not see a way of actually doing that today.</p>
<h4 id="higher-kinded-types">Higher-kinded types</h4>
<p>It’s almost possible to express the kind of type constructors:</p>
<pre><code>typeConstructor := type{_(:type)&lt;computes&gt; : type}</code></pre>
<p>This type checks but suffers from the same problem with <code>type</code> being used as a return type - it’s inferred to be <code>any</code>.</p>
<p>But we don’t have to use that broken alias, syntactically we can write down a <code>functor</code> interface like so:</p>
<pre><code>functor(F(: type)&lt;computes&gt; : type) : type := interface:
    Map(a : type, b : type, G(:a)&lt;computes&gt; : b, MA : F(a))&lt;computes&gt; : F(b)</code></pre>
<p>But this has an explicit return type of <code>type</code> which means it’s equivalent to <code>any</code>. If we remove that explicit return type we’ll again get the message about parameters only being able to be <code>type</code>:</p>
<blockquote>
<p>Parameters of a function without a specified return type must be of type <code>type</code>.</p>
</blockquote>
<p>So I think we’re blocked on being able to reduce code duplication. You’ll have to write functions for lists, maps, arrays, optionals, etc. separately. Code duplication! Gross!</p>
<h4 id="effects">Effects</h4>
<p>The effect system is different from most others, it’s all about transactions. The “<a href="https://dev.epicgames.com/documentation/en-us/uefn/specifiers-and-attributes-in-verse">exclusive effects</a>” are:</p>
<ul>
<li>Converges (terminates)</li>
<li>Computes (pure)</li>
<li>Varies (reads random or non-constant state)</li>
<li>Transacts (has mutation)</li>
<li>No rollback (side-effects)</li>
</ul>
<p>You can’t write your own effects and you can’t write effect handlers. It’s all built-in to Verse. You can’t even write a <code>converges</code> function today, that’s reserved for native code. I can imagine Verse gaining a totality checker to enable writing non-native <code>converges</code> functions.</p>
<p>The documentation says that the default effect is <code>no_rollback</code> but this isn’t true for at least one case. Above I wrote a type alias for optional types:</p>
<pre><code>optional(a : type)&lt;computes&gt; := ?a</code></pre>
<p>But it looks like when Verse infers a return of <code>type</code>, it implicitly adds the <code>computes</code> effect. So this is equivalent:</p>
<pre><code>optional(a : type) := ?a</code></pre>
<p>What about effect polymorphism? For example, these two functions are not the same:</p>
<pre><code>Twice(F() : void) : void :=
  F()
  F()

TwiceTransacts(F()&lt;transacts&gt; : void)&lt;transacts&gt; : void :=
  F()
  F()</code></pre>
<p>Sadly Verse doesn’t support writing it just once, but it’s easy to imagine:</p>
<pre><code>Twice(e : exclusive_effect, F()&lt;e&gt; : void)&lt;e&gt; : void :=
  F()
  F()</code></pre>
<p>Since effects are quite limited, I’m not sure how useful effect polymorphism would be in a production system. I can easily see it being possible but I’m not sure there would be a demand for it.</p>
<h4 id="documentation">Documentation</h4>
<p>From reading forum posts, it looks like Verse has been in alpha testing for at least 6 months. I’m guessing the documentation has been slowly written over this time because I can see things which are slightly off but which might have worked at some point in Verse’s development.</p>
<p>The page on <a href="https://dev.epicgames.com/documentation/en-us/uefn/type-aliasing-in-verse" title="‌">Type Aliasing</a> says parametric type aliases are not supported, but the example given actually seems to work totally fine:</p>
<pre><code>comparison := enum:
    LT
    EQ
    GT

predicate(t : type) := type{_(:t, :t)&lt;computes&gt; : comparison}
compareInts(a : int, b : int)&lt;computes&gt; : comparison :=
    if (a &gt; b):
        comparison.GT
    else if (a = b):
        comparison.EQ
    else:
        comparison.LT
intPredicate : predicate(int) := compareInts</code></pre>
<p>The last example from <a href="https://dev.epicgames.com/documentation/en-us/uefn/parametric-types-in-verse" title="‌">Parametric Types</a> has a shadowed name (i.e. <code>t</code>) - which Verse doesn’t allow:</p>
<pre><code>class4(t : type) := class:
    Property : ?t

    Flatten(X:?class4(t) where t:type):?t =
        if (Y := X):
            Y.Property
        else:
            false</code></pre>
<p>The first example for the <a href="https://dev.epicgames.com/documentation/en-us/uefn/type-macro-in-verse" title="‌">Type Macro</a> doesn’t work at all because <code>Foo</code> needs to have a <code>computes</code> effect to be used in a type context and the <code>type</code> macro just doesn’t <em>support arbitrary expressions at all</em> - it only supports function types!</p>
<pre><code>Foo() : int = 0
Bar(X : type{Foo()}) : type{Foo()} = X</code></pre>
<p>Finally, at the bottom of each of the documentation pages there’s a link to a “Learning Library” which is 404.</p>
<p>Since most of these documentation issues are about restrictions, I’m going to guess the restrictions were added/removed <em>after</em> the documentation was already written. I think Verse team just needs some help to keep the docs up to date!</p>
<h4 id="summary">Summary</h4>
<p>I remember getting into programming by modding games like Half-Life. I struggled with learning C++ to be able to build the experiences that I wanted to make. I’m really excited that there will be 12-year-olds being introduced to programming by making Fortnite islands, using Verse and functional programming. On the public release day of Verse and the Unreal Editor for Fortnite, over 1000 projects were created every minute. The number of people who will learn functional programming using this tool is extremely exciting!</p>
<p>Verse’s compiler and tooling are currently closed source but both Tim Sweeney and Simon Peyton Jones have said that Verse is going to be open at some point.</p>
<p>I can see a path to full dependent types and I believe some form of dependent typing must be coming in the near future. It looks like dependent types have just been explicitly been disallowed for reasons, I’m guessing mostly implementation.</p>
<p>The same restrictions make it impossible to abstract over type constructors and higher-kinded types. Code duplication will be here until this restriction is lifted and I hope it is long before full dependent types are sorted out.</p>
<p>The effect system is very limited and definitely not the algebraic form that functional programmers might be used to. Some categories will be familiar (e.g. <code>computes</code> means pure) but don’t be confused and expect Verse effects to have any extensible functionality in terms of IO, configuration, error handling, etc.</p>
<p>The Verse team needs to start automating their documentation pages, they’re slightly outdated and I’m sure the Verse team is making changes quickly given the massive influx of users.</p>
<p>Verse has some interesting features and is a key part of an enormous project. Very exciting, I’ll continue to follow closely!</p>
  </div></div>
  </body>
</html>
