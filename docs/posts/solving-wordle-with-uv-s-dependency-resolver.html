<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mildbyte.xyz/blog/solving-wordle-with-uv-dependency-resolver/">Original</a>
    <h1>Solving Wordle with uv&#39;s dependency resolver</h1>
    
    <div id="readability-page-1" class="page"><div><article><a href="https://mildbyte.xyz/blog/solving-wordle-with-uv-dependency-resolver/"></a><section><p><img alt="" src="https://quin10ko9.com/images/wordle-uv-dependency-resolver/solver.png"/></p><p>In a previous life, I wrote a <a href="https://www.splitgraph.com/blog/poetry-dependency-resolver-sudoku">Sudoku solver that relied on Poetry&#39;s dependency resolver</a>. We ended up selling that startup to EDB (not because of the Poetry hack), which means that they now own this IP. And, since then, Python packaging has advanced, with <a href="https://docs.astral.sh/uv/"><code>uv</code></a> taking the world by storm.</p><p>This means that it&#39;s time for a refresh. Can we use <code>uv</code> instead of Poetry? And can we solve a Wordle instead of a Sudoku?</p><p>For the impatient: you can get the solver from <a href="https://github.com/mildbyte/uv-wordle-solver/">my GitHub</a>. Run <code>uv run main.py run</code> and watch it go.</p><p>The short summary of the Sudoku + Poetry post is that unlike Rust or JavaScript, a single Python project cannot use more than one version of a specific Python package. This means that we can easily represent a Sudoku grid as 81 Python packages, each with 9 possible versions. If a certain cell has a specific number (version), cells in the same row, column and a 3x3 square it belongs to cannot have that same number.</p><p>We can encode these rules as version constraints on other packages representing our cell&#39;s neighbours.</p><p>Once we have our 81 packages, all that remains is encoding our problem by making another package, specifying the precise versions of the cells where we already have numbers, leaving the rest as wildcards, and then letting Poetry generate a lockfile that will assign each number (version) to every cell (package), thus solving the puzzle.</p><p><a href="https://www.nytimes.com/games/wordle/index.html">This</a> is Wordle.</p><p>You have six attempts to guess a five-letter word. On each guess, you get what I&#39;ll be calling &#34;feedback&#34;: each letter in your guess becomes green (correct letter in the correct position), yellow (correct letter, wrong position) or nothing (wrong letter).</p><p>In this post, I&#39;ll represent it as a string <code>YGG..</code>, meaning that the feedback we got for our answer is:</p><ul><li>Yellow at position 1</li><li>Green at positions 2 and 3</li><li>Blank or &#34;dot&#34; at positions 4 and 5</li></ul><p>It is said that if you ask an LLM to think really hard about its answer and write down its thinking before giving the final response, then it can successfully count the number of r&#39;s in the word <code>strawberrry</code> and help you sell more inference tokens.</p><p>Let&#39;s do exactly that and break this down.</p><h2 id="basic-building-blocks">Basic building blocks<a aria-label="Anchor link for: basic-building-blocks" href="#basic-building-blocks"><span aria-hidden="true"></span></a></h2><p>Let&#39;s start simple. The solution to a Wordle is a five-letter word, and we&#39;d like our system to choose one possible word given all information that we feed into it. We can encode this as a single Python package with multiple possible versions, where each version represents a single word. This is a useful building block.</p><p>The other building block is that each position can only have one letter in it. We can easily represent this as five &#34;position&#34; packages, each of which can have 26 versions. If the position package 1 has version 2, that means &#34;B&#34; is in that position.</p><p>We can then draw dependencies between a specific version of our &#34;word&#34; package to specific versions of our &#34;position&#34; packages. If our word is <code>STALL</code>, then it&#39;ll depend on:</p><ul><li>position package 1, version 19 (S)</li><li>position package 2, version 20 (T)</li><li>position package 3, version 1 (A)</li><li>position packages 4 and 5, version 12 (L)</li></ul><h2 id="greens-and-yellows">Greens and yellows<a aria-label="Anchor link for: greens-and-yellows" href="#greens-and-yellows"><span aria-hidden="true"></span></a></h2><p>However, this is not enough. We need to encode some more complex facts about the solution in Wordle than we did with Sudoku. For example, let&#39;s assume that we guessed <code>CHILD</code> and the feedback we got is <code>..YG.</code>. This means:</p><ul><li>The fourth letter is L</li><li>The third letter is not I</li><li>But there is at least one I somewhere in the word</li><li>None of the letters are C, H or D</li></ul><p>Is this correct though? There is a bit of nuance here.</p><p>Let&#39;s try again, this time with a different guess but the same word. We try <code>ATOLL</code> (it&#39;s not an optimal play, but as a demonstration) and get <code>...GY</code>. Here, we can&#39;t just say that there is an L somewhere in the word (because there already is). We have to say that there is at least one L in the first, second or third position.</p><p>Now let&#39;s say we guess <code>LILLE</code> and get <code>.GGG.</code>. What does this mean? Just because L in the first position gave us a dot doesn&#39;t mean there are no Ls in the word at all (there clearly are). Instead, we need to say that the first and the fifth position don&#39;t contain an L.</p><p>One thing that stems from this is that the feedback we get for a specific letter in a specific position will change based on other letters in our guess. For example, let&#39;s say the real world is <code>BUNNY</code>. If we guess <code>NNNON</code>, we&#39;ll get <code>YYG.Y</code>. And if we then guess <code>NNNNN</code>, we&#39;ll get <code>..GG.</code>. Because we discovered all Ns in the word, the first, second and last letters become blanks instead of yellows.</p><p>So, these are the inferences we can draw when given a guess and the feedback:</p><ul><li>If a letter in a certain position is green: that letter has to be in that position</li><li>If it&#39;s yellow: then the letter is not in that position and at least one of the positions that are not green have to have that letter</li><li>If it&#39;s blank: none of the positions that aren&#39;t green or yellow have that letter</li></ul><h2 id="python-dependency-rules">Python dependency rules?<a aria-label="Anchor link for: python-dependency-rules" href="#python-dependency-rules"><span aria-hidden="true"></span></a></h2><p>However, encoding this as Python dependency rules isn&#39;t going to be fun. Because the feedback for a specific letter in a specific position can change, we can&#39;t have a fact like &#34;N in position 3 is blank&#34;: we have to preprocess the feedback and somehow encode these basic facts about which letters can or can&#39;t be in specific positions.</p><p>Python also doesn&#39;t support a package depending on one of several other packages. That is, if I want to encode that at least one of positions 1, 2 or 3 contains the letter L, I can&#39;t say <em>&#34;My package depends on either position package 1, version 12, or position package 2, version 12, or position package 3, version 12&#34;</em>.</p><h2 id="possible-position-packages">Possible position packages<a aria-label="Anchor link for: possible-position-packages" href="#possible-position-packages"><span aria-hidden="true"></span></a></h2><p>Instead, the encoding scheme I came up with is as follows. Let&#39;s add another set of packages, one for each letter. The version selected for this package will represent what positions this letter we think can appear in. So, in the above <code>ATOLL</code> / <code>...GY</code> example, we will say that we can select versions <code>[1,4]</code>, <code>[2,4]</code>, <code>[3,4]</code>, <code>[1,2,4]</code>, <code>[1,3,4]</code>, <code>[1,2,3,4]</code> of the possible position package for L, i.e. all versions where L appears at position 4, doesn&#39;t appear in position 5 and appears in at least one position of 1, 2, or 3.</p><p>Each possible position package has 32 versions, and we can use binary encoding to turn each list of possible positions into an allowed version (<code>[1, 4]</code>would get encoded as binary <code>10010</code>, that is, 18, and so on).</p><h2 id="feedback-packages">Feedback packages<a aria-label="Anchor link for: feedback-packages" href="#feedback-packages"><span aria-hidden="true"></span></a></h2><p>We could produce version constraints on possible position packages directly from the feedback we get for our guesses, but that would be doing too much work outside of <code>uv</code>.</p><p>Let&#39;s introduce another set of packages and call them &#34;feedback packages&#34;. Each one will represent a statement like &#34;L is in at least one of positions 1, 2, 3&#34; and will have two versions: 0 (meaning False, i.e. L is in neither of 1, 2 or 3) or 1 (meaning True). Then, encoding the feedback we got for our guess is a matter of adding dependencies on feedback packages to our project:</p><ul><li>If a letter in a certain position is green: add a dependency on <code>{letter}_in_{position}</code>, version 1</li><li>If it&#39;s yellow: <ul><li>add a dependency on <code>{letter}_in_{position}</code> version 0 for that position</li><li>let <code>other_positions</code> be all positions that aren&#39;t green and aren&#39;t <code>position</code> itself, add a dependency on <code>{letter}_in_{other_positions}</code>, version 1</li></ul></li><li>If it&#39;s blank: let <code>positions</code> be all positions that aren&#39;t green or yellow, add a dependency on <code>{letter}_in_{positions}</code>, version 0</li></ul><p>Let&#39;s connect all these sets of packages with dependency rules:</p><p><img alt="" src="https://quin10ko9.com/images/wordle-uv-dependency-resolver/package-diagram.png"/></p><p>We have our &#34;input layer&#34;, which is our feedback packages. Those depend on our &#34;hidden layer&#34; packages, or possible position packages, using straightforward rules. Version 1 of <code>a_in_13</code> depends on any version of <code>a_poss</code> that has 1 or 3 checked, and version 0 of <code>a_in_13</code> depends on any version of <code>a_poss</code> that doesn&#39;t have neither 1 or 3 checked.</p><p>On the other side, we have our &#34;exact position&#34; packages that also depend on the possible position packages. If position 1 has A (<code>pos_1</code> has version 1), that means that it depends on all versions of <code>a_poss</code> that have A in position 1. Crucially, it also depends on the versions of all other possible position packages (representing other letters) that <em>don&#39;t</em> have that letter in position 1. That is, if we have A in position 1, we better exclude all solutions that have B in position 1.</p><p>Finally, we have a couple thousand versions of the <code>word</code> package. Each one represents a potential solution and enforces the exact letters in each position via position packages.</p><p>And finally finally, our &#34;problem&#34; package has a dependency on any version of the <code>word</code> package and the feedback packages which we will dynamically add to the dependency list as we make guesses and get feedback from Wordle.</p><p>I wasn&#39;t going to make 5,000 package versions myself, so I wrote a Python program to generate them all.</p><h2 id="package-examples">Package examples<a aria-label="Anchor link for: package-examples" href="#package-examples"><span aria-hidden="true"></span></a></h2><p>Here&#39;s a sample feedback package with dependencies on a possible positions package:</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>wordle_a_in_125<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>1<span>&#34;</span></span>
</span><span><span><span>dependencies</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>wordle_a_poss !=0,!=2,!=4,!=6<span>&#34;</span></span><span>,</span><span>]</span>
</span><span>
</span><span><span>[</span><span><span>build-system</span></span><span>]</span>
</span><span><span><span>requires</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>uv_build&gt;=0.7.19,&lt;0.8.0<span>&#34;</span></span><span>,</span><span>]</span>
</span><span><span><span>build-backend</span></span> <span>=</span> <span><span>&#34;</span>uv_build<span>&#34;</span></span>
</span></code></pre><p>You&#39;ll notice something interesting here. I couldn&#39;t find a way to make a package depend on one of a certain list of versions in the <a href="https://packaging.python.org/en/latest/specifications/dependency-specifiers/">Python dependency specifier guide</a>, so instead I inverted the dependency specification. If I have a list of possible versions, I could also say &#34;this package can&#39;t depend on any version that isn&#39;t in my list&#34; and enumerate those versions.</p><p>Its inverse (version 0) has the opposite set of packages:</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>wordle_a_in_125<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>0<span>&#34;</span></span>
</span><span><span><span>dependencies</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>wordle_a_poss !=1,!=3,!=5,!=7,!=8,!=9,!=10,!=11,!=12,!=13,!=14,!=15,!=16,!=17,!=18,!=19,!=20,!=21,!=22,!=23,!=24,!=25,!=26,!=27,!=28,!=29,!=30,!=31<span>&#34;</span></span><span>,</span><span>]</span>
</span><span>
</span><span><span>[</span><span><span>build-system</span></span><span>]</span>
</span><span><span><span>requires</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>uv_build&gt;=0.7.19,&lt;0.8.0<span>&#34;</span></span><span>,</span><span>]</span>
</span><span><span><span>build-backend</span></span> <span>=</span> <span><span>&#34;</span>uv_build<span>&#34;</span></span>
</span></code></pre><p>A possible positions package doesn&#39;t have any dependencies:</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>wordle_a_poss<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>5<span>&#34;</span></span>
</span><span>
</span><span><span>[</span><span><span>build-system</span></span><span>]</span>
</span><span><span><span>requires</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>uv_build&gt;=0.7.19,&lt;0.8.0<span>&#34;</span></span><span>,</span><span>]</span>
</span><span><span><span>build-backend</span></span> <span>=</span> <span><span>&#34;</span>uv_build<span>&#34;</span></span>
</span></code></pre><p>An exact position package for the statement &#34;A is in position 1&#34; constrains the possible positions package for A to have that letter in position 1 and for other letters to not have them in that position:</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>wordle_pos_1<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>1<span>&#34;</span></span>
</span><span><span><span>dependencies</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>wordle_a_poss !=0,!=1,!=2,!=3,!=4,!=5,!=6,!=7,!=8,!=9,!=10,!=11,!=12,!=13,!=14,!=15<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_b_poss !=16,!=17,!=18,!=19,!=20,!=21,!=22,!=23,!=24,!=25,!=26,!=27,!=28,!=29,!=30,!=31<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_c_poss ...<span>&#34;</span></span><span>]</span>
</span><span>
</span><span><span>[</span><span><span>build-system</span></span><span>]</span>
</span><span><span><span>requires</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>uv_build&gt;=0.7.19,&lt;0.8.0<span>&#34;</span></span><span>,</span><span>]</span>
</span><span><span><span>build-backend</span></span> <span>=</span> <span><span>&#34;</span>uv_build<span>&#34;</span></span>
</span></code></pre><p>Here&#39;s the definition for the <code>word</code> package version 58, representing the word &#34;ALLOY&#34; (I got the wordlist <a href="https://roy-orbison.github.io/wordle-guesses-answers/">here</a>):</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>wordle_word<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>58<span>&#34;</span></span>
</span><span><span><span>dependencies</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>wordle_pos_1 ==1<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_pos_2 ==12<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_pos_3 ==12<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_pos_4 ==15<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_pos_5 ==25<span>&#34;</span></span><span>,</span><span>]</span>
</span><span>
</span><span><span>[</span><span><span>build-system</span></span><span>]</span>
</span><span><span><span>requires</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>uv_build&gt;=0.7.19,&lt;0.8.0<span>&#34;</span></span><span>,</span><span>]</span>
</span><span><span><span>build-backend</span></span> <span>=</span> <span><span>&#34;</span>uv_build<span>&#34;</span></span>
</span></code></pre><h2 id="find-links-and-wheels"><code>--find-links</code> and wheels<a aria-label="Anchor link for: find-links-and-wheels" href="#find-links-and-wheels"><span aria-hidden="true"></span></a></h2><p>Instead of using a devpi instance like I did with the Poetry solver, I managed to make <code>uv</code> output wheels to a single directory (hence the <code>build-system</code> stanza in every package). Then, I could use <code>uv lock --find-links ../output/wheels</code>, which would execute <code>uv</code>&#39;s dependency resolver directly against this directory, without having to run a local registry.</p><p><code>uv</code> is really fast. Building 4,883 wheels took only 2 minutes on my machine: that&#39;s about 40 wheels a second!</p><h2 id="harness">Harness<a aria-label="Anchor link for: harness" href="#harness"><span aria-hidden="true"></span></a></h2><p>Given all this, I wrote a simple harness that, in a loop:</p><ul><li>Gets the feedback for a guess</li><li>Generates a <code>pyproject.toml</code> file for a &#34;problem&#34; package, turning the feedback into a set of constraints on the &#34;feedback&#34; packages (appending to existing constraints from previous attempts)</li><li>Executes <code>uv lock</code></li><li>Reads the version of the <code>word</code> package that <code>uv</code> chose and attempts that as a guess</li><li>If the dependency resolution failed, there is no solution to the Wordle in our wordlist.</li></ul><p>Here is a sample <code>pyproject.toml</code> file after a few loops:</p><pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>project</span></span><span>]</span>
</span><span><span><span>name</span></span> <span>=</span> <span><span>&#34;</span>problem<span>&#34;</span></span>
</span><span><span><span>version</span></span> <span>=</span> <span><span>&#34;</span>0.1.0<span>&#34;</span></span>
</span><span><span><span>dependencies</span></span> <span>=</span> <span>[</span> <span><span>&#34;</span>wordle_word<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_b_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_o_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_b_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_b_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_y_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_w_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_r_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_u_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_n_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_g_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_v_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_i_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_v_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_i_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_d_in_12345 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_t_in_1 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_t_in_2345 ==1<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_t_in_4 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_t_in_1235 ==1<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_a_in_5 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_a_in_1234 ==1<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_h_in_23 ==0<span>&#34;</span></span><span>,</span> <span><span>&#34;</span>wordle_e_in_23 ==0<span>&#34;</span></span><span>,</span><span>]</span>
</span></code></pre><p>One final thing: there are plenty of <a href="https://www.nytimes.com/2022/02/10/crosswords/best-wordle-tips.html">Wordle strategies</a> out there and we can employ them to make our solver more clever.</p><p><code>uv</code> tries to select the newest version of a package, which means that we can sort our wordlist so that the more preferable words have a bigger version number.</p><p>I defined a simple sorting order: we prefer words that have more distinct characters, and then the ones where the characters are the most frequent:</p><pre data-lang="python"><code data-lang="python"><span><span><span>_FREQUENCIES</span></span><span>:</span> <span><span>Counter</span></span> <span>=</span> <span><span><span><span>Counter</span></span></span></span><span><span>(</span><span>)</span></span>
</span><span>
</span><span><span><span>for</span> <span>word</span> <span>in</span></span><span> <span><span>WORDS</span></span></span><span><span>:</span></span>
</span><span>    <span><span><span>_FREQUENCIES</span></span><span><span>.</span></span><span><span><span>update</span></span></span></span><span><span>(</span><span><span>word</span></span><span>)</span></span>
</span><span>
</span><span>
</span><span><span><span><span>def</span></span> <span><span>_score</span></span></span><span><span>(</span></span><span><span>word</span><span>)</span></span><span><span>:</span></span>
</span><span>    </span><span></span><span>
</span><span>
</span><span>    <span><span>no_distinct</span></span> <span>=</span> <span><span><span><span>len</span></span></span></span><span><span>(</span><span><span><span><span>set</span></span></span></span><span><span>(</span><span><span>word</span></span><span>)</span></span><span>)</span></span>
</span><span>    <span><span>freq_score</span></span> <span>=</span> <span><span><span><span>sum</span></span></span></span><span><span>(</span><span><span><span>_FREQUENCIES</span></span></span><span><span>[</span></span><span><span><span>c</span></span></span><span><span>]</span></span> <span><span>for</span> <span>c</span> <span>in</span></span> <span><span>word</span></span><span>)</span></span>
</span><span>    <span>return</span> <span><span>(</span><span><span>no_distinct</span></span><span>,</span> <span><span>freq_score</span></span><span>)</span></span>
</span><span>
</span><span>
</span><span><span><span>WORDS</span></span> <span>=</span> <span><span><span><span>sorted</span></span></span></span><span><span>(</span><span><span>WORDS</span></span><span>,</span> <span>key</span><span>=</span><span><span>_score</span></span><span>)</span></span>
</span></code></pre><p>This means that the first guess it attempts is &#34;LATER&#34;.</p><p>By accident, at first, I omitted the letter <code>u</code> in my list of letters that I was generating packages for, which caused extremely cryptic and long (500KB of <code>uv</code> painstakingly explaining to me why I was wrong) dependency resolution errors on specific guesses:</p><p><img alt="" src="https://quin10ko9.com/images/wordle-uv-dependency-resolver/error.png"/></p><p>I found a neat trick to debug these, in case anyone ever gets stuck turning <code>uv</code> into a SAT solver and needs help. I pinned my <code>word</code> dependency to the exact word that I had in mind and got a very short error message saying that the <code>pos_2</code> package version 21 (representing U) didn&#39;t exist.</p><p>The source code for this beautiful work of art is on <a href="https://github.com/mildbyte/uv-wordle-solver/">my GitHub</a>. You just need <code>uv</code> itself and you can execute the solver as follows:</p><pre><code><span>uv run main.py run 
</span></code></pre><p>It&#39;ll generate the constraint packages and drop you into a solver loop. You can even pass <code>--no-suppress</code> to watch <code>uv</code> do its magic:</p><pre><code><span>uv run main.py run --no-suppress --no-emit-project
</span><span>Using CPython 3.10.12 interpreter at: /usr/bin/python
</span><span>warning: No `requires-python` value found in the workspace. Defaulting to `&gt;=3.10`.
</span><span>Resolved 33 packages in 579ms
</span><span>GUESS: later
</span><span>&gt; YYY..
</span><span>Using CPython 3.10.12 interpreter at: /usr/bin/python
</span><span>warning: No `requires-python` value found in the workspace. Defaulting to `&gt;=3.10`.
</span><span>Resolved 41 packages in 1.79s
</span><span>Added wordle-a-in-1345 v1
</span><span>Added wordle-a-in-2 v0
</span><span>Updated wordle-a-poss v8 -&gt; v2
</span><span>Added wordle-e-in-45 v0
</span><span>Updated wordle-e-poss v2 -&gt; v4
</span><span>Added wordle-l-in-1 v0
</span><span>Added wordle-l-in-2345 v1
</span><span>Updated wordle-l-poss v16 -&gt; v1
</span><span>Updated wordle-pos-1 v12 -&gt; v19
</span><span>Updated wordle-pos-2 v1 -&gt; v20
</span><span>Updated wordle-pos-3 v20 -&gt; v5
</span><span>Updated wordle-pos-4 v5 -&gt; v1
</span><span>Updated wordle-pos-5 v18 -&gt; v12
</span><span>Added wordle-r-in-45 v0
</span><span>Updated wordle-r-poss v1 -&gt; v0
</span><span>Updated wordle-s-poss v0 -&gt; v16
</span><span>Added wordle-t-in-1245 v1
</span><span>Added wordle-t-in-3 v0
</span><span>Updated wordle-t-poss v4 -&gt; v8
</span><span>Updated wordle-word v2308 -&gt; v2296
</span><span>GUESS: steal
</span><span>&gt; GG.YG
</span><span>Using CPython 3.10.12 interpreter at: /usr/bin/python
</span><span>warning: No `requires-python` value found in the workspace. Defaulting to `&gt;=3.10`.
</span><span>Resolved 47 packages in 1.23s
</span><span>Added wordle-a-in-3 v1
</span><span>Added wordle-a-in-4 v0
</span><span>Updated wordle-a-poss v2 -&gt; v4
</span><span>Added wordle-e-in-3 v0
</span><span>Updated wordle-e-poss v4 -&gt; v0
</span><span>Added wordle-l-in-5 v1
</span><span>Updated wordle-l-poss v1 -&gt; v3
</span><span>Updated wordle-pos-3 v5 -&gt; v1
</span><span>Updated wordle-pos-4 v1 -&gt; v12
</span><span>Added wordle-s-in-1 v1
</span><span>Added wordle-t-in-2 v1
</span><span>Updated wordle-word v2296 -&gt; v531
</span><span>GUESS: stall
</span><span>&gt; GGGGG
</span><span>Hooray!
</span></code></pre></section><nav><div><p><a aria-describedby="right_title" aria-label="Prev" href="https://mildbyte.xyz/blog/cost-of-a-meeting/">Prev <span>→</span></a></p><p aria-hidden="true" id="right_title">The cost of a meeting isn&#39;t just the time it takes</p></div></nav></article></div></div>
  </body>
</html>
