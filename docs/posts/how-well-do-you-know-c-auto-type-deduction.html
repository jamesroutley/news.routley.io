<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/">Original</a>
    <h1>How well do you know C&#43;&#43; auto type deduction?</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of the most iconic C++ features is the language’s ability to deduce types with the <code>auto</code> keyword. In this post, I’ll give a series of code snippits. Your job is to assess what will be deduced for <code>v</code> in each case. Determine for each:</p><ol><li>The deduced type</li><li>If it is a value, an lvalue or rvalue reference, or a pointer</li><li>Which CV qualifiers are applicable</li></ol><p>Some of these may not even compile, so “this won’t work” is a totally valid answer.</p><p>Each section increases in difficulty. Good luck!</p><h2 id="basics">Basics</h2><p>Basic assignments and deduction from constants and straightforward types.</p><div><pre><code>
int x;
auto v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
auto v = 5, w = 0.1;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
auto v = &amp;x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
auto v = { 1, 2, 3 };
</code></pre><details><summary>Answer</summary><div><p><strong>Type:</strong> <code>std::initializer_list&lt;int&gt;</code></p></div></details></div><div><pre><code>
int x[5];
auto v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int foo(int x) {
    return x;
}
auto v = foo;
</code></pre><details><summary>Answer</summary></details></div><p>Exploring how references and CV-qualifiers are handled.</p><div><pre><code>
volatile const int x = 1;
auto v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
volatile const int x = 1;
auto v = &amp;x;
</code></pre><details><summary>Answer</summary><div><p><strong>Type:</strong> <code>volatile const int*</code></p></div></details></div><div><pre><code>
int x;
int&amp; y = x;
auto v = y;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
auto&amp; v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x[5];
auto&amp; v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int foo(const int x) {
    return x;
}
auto v = foo;
</code></pre><details><summary>Answer</summary></details></div><h2 id="advanced">Advanced</h2><p>Forwarding references, <code>decltype(auto)</code>, inheritance, structured binding, and lambdas.</p><div><pre><code>
int x;
auto&amp;&amp; v = x;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
auto x = [] () -&gt; int { 
    return 1;
};
auto&amp;&amp; v = x();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
auto y = [&amp;] () -&gt; int&amp; { 
    return x;
};
auto&amp;&amp; v = y();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
decltype(auto) v = (x);
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
struct Foo {};
auto&amp;&amp; v = Foo{};
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
struct Foo {};
decltype(auto) v = Foo{};
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
decltype(auto) v = std::move(x);
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int foo(int x) {
    return x;
}
decltype(auto) v = foo;
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int foo(int x) {
    return x;
}
decltype(auto) v = (foo);
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
class Base {
    public:
        auto foo() {
            return this;
        };
};

class Derived : public Base {
};

Derived d;
auto v = d.foo();
</code></pre><details><summary>Answer</summary></details></div><h2 id="oof">Oof</h2><p>Abandon all hope, ye who attempt to deduce the types of lambda captures in expressions with <code>decltype(auto)</code> and symbols defined via structured binding.</p><div><pre><code>
int x;
[&amp;] {
    decltype(auto) v = x;
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
[&amp;] {
    decltype(auto) v = (x);
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
[=] {
    decltype(auto) v = x;
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
[=] {
    decltype(auto) v = (x);
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
[=] mutable {
    decltype(auto) v = (x);
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
int x;
int&amp; y = x;
[=] () {
    decltype(auto) v = y;
}();
</code></pre><details><summary>Answer</summary></details></div><div><pre><code>
std::pair<int, float=""> x {1, 2.0};
auto [v, w] = x;
</int,></code></pre><details><summary>Answer</summary><div><p><strong>Type:</strong> <code>std::tuple_element&lt;0, std::pair&lt;int, float&gt; &gt;::type&amp;</code> (but which presents as an <code>int</code> in basically every observable way)</p></div></details></div><p>You can check any of these by using this <a href="https://godbolt.org/z/f83vKh8j8">GodBolt link</a>. Shoutout to this <a href="https://stackoverflow.com/questions/81870/is-it-possible-to-print-the-name-of-a-variables-type-in-standard-c/56766138#56766138">Stack Overflow thread</a> which provided the code snippit to print human readable names for a variable.</p><p>Do you have any interesting examples to share? Reach out at <a href="mailto:sam@volatileint.dev">sam@volatileint.dev</a> and let me know! If you found this article interesting, consider subscribing to the <a href="https://volatileint.dev/newsletter">newsletter</a> to hear about new posts!</p></div></div>
  </body>
</html>
