<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kerkour.com/bugs-rust-compiler-helps-prevent">Original</a>
    <h1>Bugs that the Rust compiler catches for you</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Over the decades, Humans <a href="https://www.lunasec.io/docs/blog/log4j-zero-day-update-on-cve-2021-45046/">have</a> <a href="https://blog.ethereum.org/2016/06/17/critical-update-re-dao-vulnerability/">proved</a> <a href="https://infosecwriteups.com/zoom-zero-day-4-million-webcams-maybe-an-rce-just-get-them-to-visit-your-website-ac75c83f4ef5">to be</a> <a href="https://www.henricodolfing.com/2019/06/project-failure-case-study-knight-capital.html">pretty bad</a> at <a href="https://www.searchenginejournal.com/vulnerability-found-in-wordpress-anti-malware-firewall/448101/">producing</a> <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1139">bug-free</a> <a href="https://www.openssl.org/news/secadv/20220315.txt">software</a>. Trying to apply our approximative, fuzzy thoughts to perfectly logical computers seems doomed.</p>
<p>While the practice of code reviews is increasing, especially with the culture of Open Source becoming dominant, the situation is still far from perfect: it costs a lot of time and thus money.</p>
<p>What if, instead, we could have a companion, always available, never tired, and the icing on the cake, that doesn&#39;t cost the <a href="https://insights.stackoverflow.com/survey/2021#work-salary">salaray of a developer</a> that would help us avoid bugs in our software before they reach production?</p>
<p>Let&#39;s see how a modern compiler and type system helps prevent many bugs and thus helps increase the security for everyone and reduces the costs of software production and maintenance.</p>
<h2 id="resources-leaks">Resources leaks</h2>
<p>It&#39;s so easy to forget to close a file or a connection:</p>
<pre tabindex="0"><code><span><span><span>resp</span>, <span>err</span> <span>:=</span> <span>http</span>.<span>Get</span>(<span>&#34;http://kerkour.com&#34;</span>)
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span><span><span><span>// defer resp.Body.Close() // DON&#39;T forget this line
</span></span></span></code></pre><p>On the other hand, Rust enforces <a href="https://doc.rust-lang.org/rust-by-example/scope/raii.html">RAII (Resource Acquisition Is Initialization)</a> which makes it close to impossible to leak resources: they automatically close when they are dropped.</p>
<pre tabindex="0"><code><span><span>  <span>let</span> wordlist_file <span>=</span> File::open(<span>&#34;wordlist.txt&#34;</span>)<span>?</span>;
</span></span><span><span>  <span>// do something...
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>// we don&#39;t need to close wordlist_file
</span></span></span><span><span><span></span>  <span>// it will be closed when the variable goes out of scope
</span></span></span></code></pre><h2 id="unreleased-mutexes">Unreleased mutexes</h2>
<p>Take a look at this Go code:</p>
<pre tabindex="0"><code><span><span><span>type</span> <span>App</span> <span>struct</span> {
</span></span><span><span>  <span>mutex</span> <span>sync</span>.<span>Mutex</span>
</span></span><span><span>  <span>data</span>  <span>map</span>[<span>string</span>]<span>string</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>app</span> <span>*</span><span>App</span>) <span>DoSomething</span>(<span>input</span> <span>string</span>) {
</span></span><span><span>  <span>app</span>.<span>mutex</span>.<span>Lock</span>()
</span></span><span><span>  <span>defer</span> <span>app</span>.<span>mutex</span>.<span>Unlock</span>()
</span></span><span><span>  <span>// do something with data and input
</span></span></span><span><span><span></span>}
</span></span></code></pre><p>So far, so good. but when we want to process many items, things can go very bad fast</p>
<pre tabindex="0"><code><span><span><span>func</span> (<span>app</span> <span>*</span><span>App</span>) <span>DoManyThings</span>(<span>input</span> []<span>string</span>) {
</span></span><span><span>  <span>for</span> <span>_</span>, <span>item</span> <span>:=</span> <span>range</span> <span>input</span> {
</span></span><span><span>      <span>app</span>.<span>mutex</span>.<span>Lock</span>()
</span></span><span><span>      <span>defer</span> <span>app</span>.<span>mutex</span>.<span>Unlock</span>()
</span></span><span><span>      <span>// do something with data and item
</span></span></span><span><span><span></span>  }
</span></span><span><span>}
</span></span></code></pre><p>We just created a deadlock because the mutex lock is not released when expected but at the end of the function.</p>
<p>In the same way, RAII in Rust helps to prevent unreleased mutexes:</p>
<pre tabindex="0"><code><span><span><span>for</span> item <span>in</span> input {
</span></span><span><span>  <span>let</span> _guard <span>=</span> mutex.lock().expect(<span>&#34;locking mutex&#34;</span>);
</span></span><span><span>  <span>// do something
</span></span></span><span><span><span></span>  <span>// mutex is released here as _guard is dropped
</span></span></span><span><span><span></span>}
</span></span></code></pre><h2 id="missing-switch-cases">Missing switch cases</h2>
<p>Let&#39;s imagine we are tracking the status of a product on an online shop:</p>
<pre tabindex="0"><code><span><span><span>const</span> (
</span></span><span><span>  <span>StatusUnknown</span>   <span>Status</span> = <span>0</span>
</span></span><span><span>  <span>StatusDraft</span>     <span>Status</span> = <span>1</span>
</span></span><span><span>  <span>StatusPublished</span> <span>Status</span> = <span>2</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>switch</span> <span>status</span> {
</span></span><span><span>    <span>case</span> <span>StatusUnknown</span>:
</span></span><span><span>        <span>// ...
</span></span></span><span><span><span></span>    <span>case</span> <span>StatusDraft</span>:
</span></span><span><span>        <span>// ...
</span></span></span><span><span><span></span>    <span>case</span> <span>StatusPublished</span>:
</span></span><span><span>        <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre><p>But then, if we add the <code>StatusArchived Status = 3</code> variant and forget to update this <code>switch</code> statement, the compiler still happily accepts the program and lets us introduce a bug.</p>
<p>While in Rust, a non-exhaustive <code>match</code> produces a compile-time error:</p>
<pre tabindex="0"><code><span><span><span>#[derive(Debug, Clone, Copy)]</span>
</span></span><span><span><span>enum</span> <span>Platform</span> {
</span></span><span><span>    Linux,
</span></span><span><span>    MacOS,
</span></span><span><span>    Windows,
</span></span><span><span>    Unknown,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>impl</span> fmt::Display <span>for</span> Platform {
</span></span><span><span>    <span>fn</span> <span>fmt</span>(<span>&amp;</span>self, f: <span>&amp;</span><span>mut</span> fmt::Formatter) -&gt; <span>fmt</span>::Result {
</span></span><span><span>        <span>match</span> self {
</span></span><span><span>            Platform::Linux <span>=&gt;</span> write!(f, <span>&#34;Linux&#34;</span>),
</span></span><span><span>            Platform::Macos <span>=&gt;</span> write!(f, <span>&#34;macOS&#34;</span>),
</span></span><span><span>            <span>// Compile time error! We forgot Windows and Unknown
</span></span></span><span><span><span></span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre><h2 id="invalid-pointer-dereference">Invalid pointer dereference</h2>
<p>As far as I know, it&#39;s not possible to create a reference to an invalid address in safe Rust.</p>
<pre tabindex="0"><code><span><span><span>type</span> <span>User</span> <span>struct</span> {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>Foo</span> <span>*</span><span>Bar</span> <span>// is it intended to be used a a pointer, or as an optional field?
</span></span></span><span><span><span></span>}
</span></span></code></pre><p>And even better, because Rust has the <a href="https://doc.rust-lang.org/std/option/"><code>Option</code></a> enum, you don&#39;t have to use <code>null</code> pointer to represent the absence of something.</p>
<pre tabindex="0"><code><span><span><span>struct</span> <span>User</span> {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    foor: Option<span>&lt;</span>Bar<span>&gt;</span>, <span>// it&#39;s clear that this field is optional
</span></span></span><span><span><span></span>}
</span></span></code></pre><h2 id="uninitialized-variables">Uninitialized variables</h2>
<p>Let&#39;s say that we are processing users accounts:</p>
<pre tabindex="0"><code><span><span><span>type</span> <span>User</span> <span>struct</span> {
</span></span><span><span>  <span>ID</span>          <span>uuid</span>.<span>UUID</span>
</span></span><span><span>  <span>CreatedAt</span>   <span>time</span>.<span>Time</span>
</span></span><span><span>  <span>UpdatedAt</span> <span>time</span>.<span>Time</span>
</span></span><span><span>  <span>Email</span>       <span>string</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> (<span>app</span> <span>*</span><span>App</span>) <span>CreateUser</span>(<span>email</span> <span>string</span>) {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>now</span> <span>:=</span> <span>time</span>.<span>Now</span>().<span>UTC</span>()
</span></span><span><span>
</span></span><span><span>    <span>user</span> <span>:=</span> <span>User</span> {
</span></span><span><span>      <span>ID</span>: <span>uuid</span>.<span>New</span>(),
</span></span><span><span>      <span>CreatedAt</span>: <span>now</span>,
</span></span><span><span>      <span>UpdatedAt</span>: <span>now</span>,
</span></span><span><span>      <span>Email</span>: <span>email</span>,
</span></span><span><span>    }
</span></span><span><span>    <span>err</span> = <span>app</span>.<span>repository</span>.<span>CreateUser</span>(<span>app</span>.<span>db</span>, <span>user</span>)
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>}
</span></span></code></pre><p>Good, but now, we need to add the field <code>AllowedStorage int64</code> to the <code>User</code> structure.</p>
<p>If we forget to update the <code>CreateUser</code> function, the compiler will still happily accept the code without any changes and use the default value of an <code>int64</code>: <code>0</code>, which may not be what we want.</p>
<p>While the following Rust code</p>
<pre tabindex="0"><code><span><span><span>struct</span> <span>User</span> {
</span></span><span><span>  id: <span>uuid</span>::Uuid,
</span></span><span><span>  created_at: <span>DateTime</span><span>&lt;</span>Utc<span>&gt;</span>,
</span></span><span><span>  updated_at: <span>DateTime</span><span>&lt;</span>Utc<span>&gt;</span>,
</span></span><span><span>  email: String,
</span></span><span><span>  allowed_storage: <span>i64</span>,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>create_user</span>(email: String)
</span></span><span><span>    <span>let</span> user <span>=</span> User {
</span></span><span><span>      id: <span>uuid</span>::new(),
</span></span><span><span>      created_at: <span>now</span>,
</span></span><span><span>      updated_at: <span>now</span>,
</span></span><span><span>      email: <span>email</span>,
</span></span><span><span>      <span>// we forgot to update the function to initialize allowed_storage
</span></span></span><span><span><span></span>    };
</span></span><span><span>}
</span></span></code></pre><p>produces a compile-time error, preventing us from shooting ourselves in the foot.</p>
<h2 id="unhandled-exceptions-and-errors">Unhandled exceptions and errors</h2>
<p>It may sound stupid, but you can&#39;t have unhandled exceptions if you don&#39;t have exceptions...</p>
<p><a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!()</code></a> exists in Rust, but that&#39;s not how recoverable errors are handled.</p>
<p>Thus, by imposing the programmers to handle each and every errors (or the compiler refuses to compile the program), all while providing ergonomic tools to handle errors (the <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"><code>Result</code> enum</a> and the <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html"><code>?</code></a> operator), the Rust compiler helps to prevent most (if not all) errors related to error handling.</p>
<h2 id="data-races">Data races</h2>
<p>Thanks to the <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> and <a href="https://doc.rust-lang.org/std/marker/trait.Send.html">Send</a> traits, Rust&#39;s compiler can statically assert that no <a href="https://doc.rust-lang.org/nomicon/races.html">data race</a> is going to happen.</p>
<p>How does it work? You can learn more in this <a href="https://medium.com/codex/eda-needs-to-be-using-rust-pt-2-59d2263ebb03">good write-up</a> by Jason McCampbell.</p>

<p>In Go, data streams are hidden behind the <a href="https://pkg.go.dev/io#Writer"><code>io.Writer</code></a> interface. On one hand, it allows to simplify its usage. On the other hand, it can reserve some surprise when used with types we don&#39;t expect to be a stream, <code>bytes.Buffer</code> for example.</p>
<p>And that&#39;s exactly what happened to me a <a href="https://kerkour.com/2022-03-23-newsletter-incident-postmortem">month ago</a>: a <code>bytes.Buffer</code> was reused in a loop to render templates which leads the templates to be appended to the buffer instead of the buffer to be cleaned and reused.</p>
<p>It would have never happened in Rust as <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html">Streams</a> are a very specific type and would never have been used in this situation.</p>
<h2 id="some-closing-thoughts">Some Closing Thoughts</h2>
<p>Are smart compilers the end of bugs and code reviews?</p>
<p>Of course not! But a strong type system, and the associated compiler are a weapon of choice for anyone who wants to drastically reduce the number of bugs in their software and make their users / customers happy.</p>

  </div></div>
  </body>
</html>
