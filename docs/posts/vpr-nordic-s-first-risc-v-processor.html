<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielmangum.com/posts/vpr-nordic-risc-v-processor/">Original</a>
    <h1>VPR: Nordic&#39;s First RISC-V Processor</h1>
    
    <div id="readability-page-1" class="page"><div>
      
  <section>
    <article>
      <header>
        
        <div>
          <p><span>
              <i aria-hidden="true"></i>
              <time datetime="2024-12-24T01:41:34-06:00">
                December 24, 2024
              </time>
            </span>
            <span>
              <i aria-hidden="true"></i>
              13-minute read
            </span>
          </p>
          
          
          
        </div>
      </header>

      <div>
        
        <p>VPR (pronounced “Viper”) is <a href="https://www.nordicsemi.com/">Nordic
Semiconductor’s</a> first
<a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V</a> processor, landing in the new
<a href="https://www.nordicsemi.com/Products/nRF54H20">nRF54H</a> and
<a href="https://www.nordicsemi.com/Products/nRF54L15">nRF54L</a> lines of SoCs after their
<a href="https://www.nordicsemi.com/Nordic-news/2023/04/nordic-semiconductor-redefines-its-leadership-in-bluetooth-low-energy-with-the-nrf54-series">initial</a>
<a href="https://www.nordicsemi.com/Nordic-news/2023/10/Nordic-announces-nRF54L-Series-expanding-industrys-most-efficient-Bluetooth-LE-portfolio">announcements</a>
in April and October of 2023 respectively. Readers of this blog are familiar
with my long-running <del>obsession</del> interest in RISC-V (see my <a href="https://danielmangum.com/risc-v-tips/">RISC-V
Tips</a> and <a href="https://danielmangum.com/categories/risc-v-bytes/">RISC-V
Bytes</a> series). However,
Nordic’s introduction of a RISC-V processor is particularly interesing to me as
their lineup of microcontrollers is extremely popular in low power wireless
domains, a common use case for <a href="https://golioth.io/">Golioth</a> customers.</p>
<p>Naturally, I was eager to look into the details of VPR as more information
became available. A basic description of registers and initialization can be
found in the <a href="https://docs.nordicsemi.com/bundle/ps_nrf54L15/page/vpr.html">nRF54L
documentation</a>.
VPR is an RV32E processor, meaning that it uses 32-bit registers but implements
only the lower 16 registers required by the embedded (E) specification rather
than the 32 defined by the full 32-bit integer (RV32I) specification. It also
implements multiplication and division operations (M), as well as the compressed
instruction (C) extension, which adds support for 16-bit instruction variants to
improve code density. All instructions are executed in machine mode (M), which
is the only implemented <a href="https://danielmangum.com/posts/risc-v-bytes-privilege-levels/">privilege
level</a>.</p>
<p>Alongside the <a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M33">Arm
Cortex-M33</a> application
processor, nRF54L MCUs include a single VPR processor, referred to as the <a href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54l/features.html#vpr_core"><em>fast
lightweight peripheral
processor</em></a>
(FLPR, pronounced “flipper”), while the nRF54H20 includes both a FLPR and a
<a href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54h/ug_nrf54h20_architecture_cpu.html#peripheral_processor_ppr"><em>peripheral
processor</em></a>
(PPR, pronounced “pepper”) alongside its dual Arm Cortex-M33 application and
network processors. The PPR is meant for peripheral handling with low power
consumption and it runs at 16 MHz. The FLPR runs at 320 MHz and is intended for
software-defined peripherals.</p>
<p>VPR processors must be configured and started by their controlling application
processor. This consists of setting the VPR’s program counter in the <a href="https://docs.nordicsemi.com/bundle/ps_nrf54L15/page/vpr.html#register.INITPC"><code>INITPC</code>
register</a>,
then writing to the <a href="https://docs.nordicsemi.com/bundle/ps_nrf54L15/page/vpr.html#ariaid-title38"><code>CPURUN</code>
register</a>
to start the processor. On the nRF54H20, the PPR VPR executes code from <a href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54h/ug_nrf54h20_architecture_memory.html#slow_global_ram_ram3x"><em>slow
global RAM</em>
(RAM3x)</a>.
Therefore, the controlling processor must copy code into the appropriate region,
before updating the program counter and starting the VPR processor.</p>
<p>I have previously written about the <a href="https://danielmangum.com/posts/risc-v-bytes-zephyr-before-main/">Zephyr boot
process</a>, and
specifically about <a href="https://danielmangum.com/posts/risc-v-bytes-zephyr-before-main/#hardware-initialization">hardware
initialization</a>.
Zephyr uses <a href="https://www.devicetree.org/">devicetree</a> to describe the hardware
and peripherals of supported processors and boards. In the
<a href="https://github.com/zephyrproject-rtos/zephyr/blob/f51729aadae9a7413290ee6417fb13b18d417147/dts/common/nordic/nrf54h20.dtsi#L46">nrf54h20.dtsi</a>
devicetree include file, there is a node representing the PPR VPR processor.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>		cpuppr: cpu@d {
</span></span><span><span>			compatible = &#34;nordic,vpr&#34;;
</span></span><span><span>			reg = &lt;13&gt;;
</span></span><span><span>			device_type = &#34;cpu&#34;;
</span></span><span><span>			clocks = &lt;&amp;fll16m&gt;;
</span></span><span><span>			clock-frequency = &lt;DT_FREQ_M(16)&gt;;
</span></span><span><span>			riscv,isa = &#34;rv32emc&#34;;
</span></span><span><span>			nordic,bus-width = &lt;32&gt;;
</span></span><span><span>
</span></span><span><span>			cpuppr_vevif_rx: mailbox {
</span></span><span><span>				compatible = &#34;nordic,nrf-vevif-task-rx&#34;;
</span></span><span><span>				status = &#34;disabled&#34;;
</span></span><span><span>				interrupt-parent = &lt;&amp;cpuppr_clic&gt;;
</span></span><span><span>				interrupts = &lt;0 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;1 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;2 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;3 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;4 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;5 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;6 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;7 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;8 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;9 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;10 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;11 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;12 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;13 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;14 NRF_DEFAULT_IRQ_PRIORITY&gt;,
</span></span><span><span>					     &lt;15 NRF_DEFAULT_IRQ_PRIORITY&gt;;
</span></span><span><span>				#mbox-cells = &lt;1&gt;;
</span></span><span><span>				nordic,tasks = &lt;16&gt;;
</span></span><span><span>				nordic,tasks-mask = &lt;0xfffffff0&gt;;
</span></span><span><span>			};
</span></span><span><span>		};
</span></span></code></pre></div><p>Previously mentioned attributes, such as the support for the <code>rv32emc</code> RISC-V
ISA, as well as the 16 MHz (<code>DT_FREQ_M(16)</code>) clock speed, are defined. There is
also a <a href="https://github.com/zephyrproject-rtos/zephyr/blob/f51729aadae9a7413290ee6417fb13b18d417147/dts/common/nordic/nrf54h20.dtsi#L697C1-L714C6">node under
<code>soc</code></a>
that defines the PPR as a coprocessor peripheral.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>			cpuppr_vpr: vpr@908000 {
</span></span><span><span>				compatible = &#34;nordic,nrf-vpr-coprocessor&#34;;
</span></span><span><span>				reg = &lt;0x908000 0x1000&gt;;
</span></span><span><span>				status = &#34;disabled&#34;;
</span></span><span><span>				#address-cells = &lt;1&gt;;
</span></span><span><span>				#size-cells = &lt;1&gt;;
</span></span><span><span>				ranges = &lt;0x0 0x908000 0x1000&gt;;
</span></span><span><span>				power-domains = &lt;&amp;gpd NRF_GPD_SLOW_ACTIVE&gt;;
</span></span><span><span>
</span></span><span><span>				cpuppr_vevif_tx: mailbox@0 {
</span></span><span><span>					compatible = &#34;nordic,nrf-vevif-task-tx&#34;;
</span></span><span><span>					reg = &lt;0x0 0x1000&gt;;
</span></span><span><span>					status = &#34;disabled&#34;;
</span></span><span><span>					#mbox-cells = &lt;1&gt;;
</span></span><span><span>					nordic,tasks = &lt;16&gt;;
</span></span><span><span>					nordic,tasks-mask = &lt;0xfffffff0&gt;;
</span></span><span><span>				};
</span></span><span><span>			};
</span></span></code></pre></div><p>The <code>compatible</code> property associates the PPR with the appropriate driver that
the controlling processor, in this case the nRF54H20 application processor
(<code>cpuapp</code>), can use to configure and start it. In the miscellaneous drivers,
there <a href="https://github.com/zephyrproject-rtos/zephyr/blob/b7575e8b95c6d963aa207f264d425dbae456f5c2/drivers/misc/nordic_vpr_launcher">is a
<code>nordic_vpr_launcher</code></a>,
which <a href="https://github.com/zephyrproject-rtos/zephyr/blob/b7575e8b95c6d963aa207f264d425dbae456f5c2/drivers/misc/nordic_vpr_launcher/nordic_vpr_launcher.c#L6C1-L6C49">defines its device
compatability</a>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#define DT_DRV_COMPAT nordic_nrf_vpr_coprocessor
</span></span></span></code></pre></div><p>The driver is relatively simple because it is only responsible for device
initialization. The <a href="https://github.com/zephyrproject-rtos/zephyr/blob/b7575e8b95c6d963aa207f264d425dbae456f5c2/drivers/misc/nordic_vpr_launcher/nordic_vpr_launcher.c#L32C1-L53C2">initialization
function</a>
performs the operations described in the documentation.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>int</span> nordic_vpr_launcher_init(<span>const</span> <span>struct</span> device *dev)
</span></span><span><span>{
</span></span><span><span>	<span>const</span> <span>struct</span> nordic_vpr_launcher_config *config = dev-&gt;config;
</span></span><span><span>
</span></span><span><span><span>#if DT_ANY_INST_HAS_PROP_STATUS_OKAY(source_memory)
</span></span></span><span><span><span></span>	<span>if</span> (config-&gt;size &gt; <span>0U</span>) {
</span></span><span><span>		LOG_DBG(<span>&#34;Loading VPR (%p) from %p to %p (%zu bytes)&#34;</span>, config-&gt;vpr,
</span></span><span><span>			(<span>void</span> *)config-&gt;src_addr, (<span>void</span> *)config-&gt;exec_addr, config-&gt;size);
</span></span><span><span>		memcpy((<span>void</span> *)config-&gt;exec_addr, (<span>void</span> *)config-&gt;src_addr, config-&gt;size);
</span></span><span><span>	}
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span><span>#if defined(CONFIG_SOC_NRF54L_CPUAPP_COMMON) &amp;&amp; !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)
</span></span></span><span><span><span></span>	nrf_spu_periph_perm_secattr_set(NRF_SPU00, nrf_address_slave_get((<span>uint32_t</span>)config-&gt;vpr),
</span></span><span><span>					<span>true</span>);
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>	LOG_DBG(<span>&#34;Launching VPR (%p) from %p&#34;</span>, config-&gt;vpr, (<span>void</span> *)config-&gt;exec_addr);
</span></span><span><span>	nrf_vpr_initpc_set(config-&gt;vpr, config-&gt;exec_addr);
</span></span><span><span>	nrf_vpr_cpurun_set(config-&gt;vpr, <span>true</span>);
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>The various <code>nrf_vpr_*</code> functions are <a href="https://github.com/zephyrproject-rtos/hal_nordic/blob/dbfe4a14cf0ac7425ef58f1a01576873f5976f4c/nrfx/hal/nrf_vpr.h">provided as inline by
<code>hal_nordic</code></a>.
The device configuration, which determines the memory source and destination
addresses used by the launcher, is <a href="https://github.com/zephyrproject-rtos/zephyr/blob/b7575e8b95c6d963aa207f264d425dbae456f5c2/drivers/misc/nordic_vpr_launcher/nordic_vpr_launcher.c#L55C1-L76C56">instantiated using various <code>DT_*</code> devicetree
macros</a>,
which are performed for every compatible node using
<code>DT_INST_FOREACH_STATUS_OKAY</code>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/* obtain VPR address either from memory or partition */</span>
</span></span><span><span><span>#define VPR_ADDR(node_id)                                                                          \
</span></span></span><span><span><span>	(DT_REG_ADDR(node_id) +                                                                    \
</span></span></span><span><span><span>	 COND_CODE_0(DT_FIXED_PARTITION_EXISTS(node_id), (0), (DT_REG_ADDR(DT_GPARENT(node_id)))))
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define NORDIC_VPR_LAUNCHER_DEFINE(inst)                                                           \
</span></span></span><span><span><span>	IF_ENABLED(DT_INST_NODE_HAS_PROP(inst, source_memory),                                     \
</span></span></span><span><span><span>		   (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) &lt;=          \
</span></span></span><span><span><span>				  DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),              \
</span></span></span><span><span><span>				 &#34;Execution memory exceeds source memory size&#34;);))                 \
</span></span></span><span><span><span>                                                                                                   \
</span></span></span><span><span><span>	static const struct nordic_vpr_launcher_config config##inst = {                            \
</span></span></span><span><span><span>		.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \
</span></span></span><span><span><span>		.exec_addr = VPR_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                    \
</span></span></span><span><span><span>		IF_ENABLED(DT_INST_NODE_HAS_PROP(inst, source_memory),                             \
</span></span></span><span><span><span>			   (.src_addr = VPR_ADDR(DT_INST_PHANDLE(inst, source_memory)),            \
</span></span></span><span><span><span>			    .size = DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)),))};      \
</span></span></span><span><span><span>                                                                                                   \
</span></span></span><span><span><span>	DEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL, &amp;config##inst,           \
</span></span></span><span><span><span>			      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);
</span></span></span><span><span><span></span>
</span></span><span><span>DT_INST_FOREACH_STATUS_OKAY(NORDIC_VPR_LAUNCHER_DEFINE)
</span></span></code></pre></div><p>We can see the initialization in action by building applications for both the
application processor and the PPR. Zephyr’s
<a href="https://docs.zephyrproject.org/latest/build/sysbuild/index.html">sysbuild</a>
allows for building for multiple targets. The <a href="https://docs.zephyrproject.org/latest/samples/sysbuild/hello_world/README.html"><code>hello_world</code>
sample</a>
demonstrates this capability by building the same application, which just prints
<code>Hello world from {target}</code>, for all specified targets.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>west build -p -b nrf54h20dk/nrf54h20/cpuapp -T sample.sysbuild.hello_world.nrf54h20dk_cpuapp_cpuppr .
</span></span></code></pre></div><p>The <code>-T</code> argument specifies one of the sample’s <a href="https://github.com/zephyrproject-rtos/zephyr/blob/4a7ef5c010bc0d184521ba042345feb038ad84f4/samples/sysbuild/hello_world/sample.yaml">test
configurations</a>,
which will automatically inject extra arguments into the build.</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  <span>sample.sysbuild.hello_world.nrf54h20dk_cpuapp_cpuppr</span>:
</span></span><span><span>    <span>platform_allow</span>:
</span></span><span><span>      - nrf54h20dk/nrf54h20/cpuapp
</span></span><span><span>    <span>integration_platforms</span>:
</span></span><span><span>      - nrf54h20dk/nrf54h20/cpuapp
</span></span><span><span>    <span>extra_args</span>:
</span></span><span><span>      SB_CONF_FILE=sysbuild/nrf54h20dk_nrf54h20_cpuppr.conf
</span></span><span><span>      hello_world_SNIPPET=nordic-ppr
</span></span></code></pre></div><p>The <code>SB_CONF_FILE</code> specifies the <a href="https://github.com/zephyrproject-rtos/zephyr/blob/4a7ef5c010bc0d184521ba042345feb038ad84f4/samples/sysbuild/hello_world/sysbuild/nrf54h20dk_nrf54h20_cpuppr.conf">sysbuild
configuration</a>.
For the nRF24H20 development kit (DK), the configuration file only serves to
specify the board target for the <code>remote</code> variant of the application, which is
the PPR.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>SB_CONFIG_REMOTE_BOARD=&#34;nrf54h20dk/nrf54h20/cpuppr&#34;
</span></span></code></pre></div><p>The <code>hello_world_SNIPPET</code> specifies a snippet that should be included in the
build. It includes two devicetree overlay files.
<a href="https://github.com/zephyrproject-rtos/zephyr/blob/4137c11ee37bdc4e7ea1242828d027e27e9ec4d9/snippets/nordic-ppr/nordic-ppr.overlay">One</a>,
<code>nordic-ppr.overlay</code>, enables the <code>cpuppr_vpr</code> node for any boards that
incoporate a PPR.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>&amp;cpuppr_vpr {
</span></span><span><span>	status = &#34;okay&#34;;
</span></span><span><span>};
</span></span></code></pre></div><blockquote>
<p>Observant readers will notice that it appears Nordic’s upcoming nRF9280 also
includes a PPR.</p>
</blockquote>
<p>The
<a href="https://github.com/zephyrproject-rtos/zephyr/blob/4a7ef5c010bc0d184521ba042345feb038ad84f4/snippets/nordic-ppr/soc/nrf54h20_cpuapp.overlay">second</a>,
<code>nrf54h20_cpuapp.overlay</code>, enables the memory region that is shared between the
application processor and the PPR.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>&amp;cpuppr_ram3x_region {
</span></span><span><span>	status = &#34;okay&#34;;
</span></span><span><span>};
</span></span></code></pre></div><p>After build, the application processor image will reside in <code>build/hello_world</code>,
while the PPR image will reside in <code>build/remote</code>. We can use the respective Arm
and RISC-V toolchains from the <a href="https://github.com/zephyrproject-rtos/sdk-ng">Zephyr
SDK</a> to inspect the ELF files and
understand how the configuration translates to instructions in the binary.</p>
<p>To disassemble the application processor image, use the <code>arm-zephyr-eabi</code>
toolchain’s <code>objdump</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ZEPHYR_SDK_PATH/arm-zephyr-eabi/bin/arm-zephyr-eabi-objdump -D build/hello_world/zephyr/zephyr.elf
</span></span></code></pre></div><p>For the PPR image, the <code>riscv64-zephyr-elf</code> variant can be used.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ZEPHYR_SDK_PATH/riscv64-zephyr-elf/bin/riscv64-zephyr-elf-objdump -D build/remote/zephyr/zephyr.elf
</span></span></code></pre></div><p>In the previously shown <code>nordic_vpr_launcher</code> driver initialization, the
<code>DEVICE_DT_INST_DEFINE</code> macro is used to define the PPR peripheral device with a
<code>POST_KERNEL</code> initialization level. This means that the device should be
initialized after the kernel boots. This is handled by <a href="https://github.com/zephyrproject-rtos/zephyr/blob/4a7ef5c010bc0d184521ba042345feb038ad84f4/kernel/init.c#L347">a call to
<code>z_sys_init_run_level</code></a>
with level <code>POST_KERNEL</code>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>void</span> z_sys_init_run_level(<span>enum</span> init_level level)
</span></span><span><span>{
</span></span><span><span>	<span>static</span> <span>const</span> <span>struct</span> init_entry *levels[] = {
</span></span><span><span>		__init_EARLY_start,
</span></span><span><span>		__init_PRE_KERNEL_1_start,
</span></span><span><span>		__init_PRE_KERNEL_2_start,
</span></span><span><span>		__init_POST_KERNEL_start,
</span></span><span><span>		__init_APPLICATION_start,
</span></span><span><span><span>#ifdef CONFIG_SMP
</span></span></span><span><span><span></span>		__init_SMP_start,
</span></span><span><span><span>#endif </span><span>/* CONFIG_SMP */</span><span>
</span></span></span><span><span><span></span>		<span>/* End marker */</span>
</span></span><span><span>		__init_end,
</span></span><span><span>	};
</span></span><span><span>	<span>const</span> <span>struct</span> init_entry *entry;
</span></span><span><span>
</span></span><span><span>	<span>for</span> (entry = levels[level]; entry &lt; levels[level+<span>1</span>]; entry++) {
</span></span><span><span>		<span>const</span> <span>struct</span> device *dev = entry-&gt;dev;
</span></span><span><span>		<span>int</span> result;
</span></span><span><span>
</span></span><span><span>		sys_trace_sys_init_enter(entry, level);
</span></span><span><span>		<span>if</span> (dev != <span>NULL</span>) {
</span></span><span><span>			result = do_device_init(entry);
</span></span><span><span>		} <span>else</span> {
</span></span><span><span>			result = entry-&gt;init_fn.sys();
</span></span><span><span>		}
</span></span><span><span>		sys_trace_sys_init_exit(entry, level, result);
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>We can see the disassembly in the application processor image.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0a9ca4 <span>&lt;</span>z_sys_init_run_level<span>&gt;</span>:
</span></span><span><span> e0a9ca4:	b538      	push	<span>{</span>r3, r4, r5, lr<span>}</span>
</span></span><span><span> e0a9ca6:	<span>4</span>b09      	ldr	r3, [pc, <span>#36]	; (e0a9ccc &lt;z_sys_init_run_level+0x28&gt;)
</span></span></span><span><span><span></span> e0a9ca8:	f853 <span>4020</span> 	ldr.w	r4, [r3, r0, lsl <span>#2]
</span></span></span><span><span><span></span> e0a9cac:	<span>3001</span>      	adds	r0, <span>#1
</span></span></span><span><span><span></span> e0a9cae:	f853 <span>5020</span> 	ldr.w	r5, [r3, r0, lsl <span>#2]
</span></span></span><span><span><span></span> e0a9cb2:	<span>42</span>a5      	cmp	r5, r4
</span></span><span><span> e0a9cb4:	d800      	bhi.n	<span>e0a9cb8</span> &lt;z_sys_init_run_level+<span>0x14</span>&gt;
</span></span><span><span> e0a9cb6:	bd38      	pop	<span>{</span>r3, r4, r5, pc<span>}</span>
</span></span><span><span> e0a9cb8:	<span>6863</span>      	ldr	r3, [r4, <span>#4]
</span></span></span><span><span><span></span> e0a9cba:	b123      	cbz	r3, <span>e0a9cc6</span> &lt;z_sys_init_run_level+<span>0x22</span>&gt;
</span></span><span><span> e0a9cbc:	<span>4620</span>      	mov	r0, r4
</span></span><span><span> e0a9cbe:	f003 f81f 	bl	<span>e0acd00</span> &lt;do_device_init&gt;
</span></span><span><span> e0a9cc2:	<span>3408</span>      	adds	r4, <span>#8
</span></span></span><span><span><span></span> e0a9cc4:	e7f5      	b.n	<span>e0a9cb2</span> &lt;z_sys_init_run_level+<span>0xe</span>&gt;
</span></span><span><span> e0a9cc6:	<span>6823</span>      	ldr	r3, [r4, <span>#0]
</span></span></span><span><span><span></span> e0a9cc8:	<span>4798</span>      	blx	r3
</span></span><span><span> e0a9cca:	e7fa      	b.n	<span>e0a9cc2</span> &lt;z_sys_init_run_level+<span>0x1e</span>&gt;
</span></span><span><span> e0a9ccc:	<span>0</span>e0ae818 	mcreq	<span>8</span>, <span>0</span>, lr, cr10, cr8, <span>{</span><span>0</span><span>}</span>
</span></span></code></pre></div><p>The second instruction, <code>ldr r3, [pc, #36]</code> loads the address at a 36 byte
offset from the current program counter (<code>pc</code>), which is the last entry in the
function disassembly: <code>0e0ae818</code>.</p>
<blockquote>
<p>Ignore the attempted instruction decoding by <code>objdump</code> for this address and
all stored memory addresses below.</p>
</blockquote>
<p>This is the address of the <code>levels</code> array, which contains <a href="https://github.com/zephyrproject-rtos/zephyr/blob/4a7ef5c010bc0d184521ba042345feb038ad84f4/include/zephyr/init.h#L103"><code>init_entry</code>
items</a>.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0ae818 <span>&lt;</span>levels.0<span>&gt;</span>:
</span></span><span><span> e0ae818:	<span>0</span>e0ad3cc 	cdpeq	<span>3</span>, <span>0</span>, cr13, cr10, cr12, <span>{</span><span>6</span><span>}</span>
</span></span><span><span> e0ae81c:	<span>0</span>e0ad3cc 	cdpeq	<span>3</span>, <span>0</span>, cr13, cr10, cr12, <span>{</span><span>6</span><span>}</span>
</span></span><span><span> e0ae820:	<span>0</span>e0ad40c 	cdpeq	<span>4</span>, <span>0</span>, cr13, cr10, cr12, <span>{</span><span>0</span><span>}</span>
</span></span><span><span> e0ae824:	<span>0</span>e0ad414 	cfmvdlreq	mvd10, sp
</span></span><span><span> e0ae828:	<span>0</span>e0ad464 	cdpeq	<span>4</span>, <span>0</span>, cr13, cr10, cr4, <span>{</span><span>3</span><span>}</span>
</span></span><span><span> e0ae82c:	<span>0</span>e0ad474 	mcreq	<span>4</span>, <span>0</span>, sp, cr10, cr4, <span>{</span><span>3</span><span>}</span>
</span></span><span><span> e0ae830:	<span>3566726</span>e 	strbcc	r7, [r6, <span>#-622]!	; 0xfffffd92
</span></span></span><span><span><span></span> e0ae834:	<span>30326834</span> 	eorscc	r6, r2, r4, lsr r8
</span></span><span><span> e0ae838:	<span>30406</span>b64 	subcc	r6, r0, r4, ror <span>#22
</span></span></span><span><span><span></span> e0ae83c:	<span>302</span>e392e 	eorcc	r3, lr, lr, lsr <span>#18
</span></span></span><span><span><span></span> e0ae840:	<span>66726</span>e2f 	ldrbtvs	r6, [r2], -pc, lsr <span>#28
</span></span></span><span><span><span></span> e0ae844:	<span>32683435</span> 	rsbcc	r3, r8, <span>#889192448	; 0x35000000
</span></span></span><span><span><span></span> e0ae848:	<span>70632</span>f30 	rsbvc	r2, r3, r0, lsr pc
</span></span><span><span> e0ae84c:	<span>70706175</span> 	rsbsvc	r6, r0, r5, ror r1
</span></span><span><span> e0ae850:	<span>6</span>c654800 	stclvs	<span>8</span>, cr4, [r5], <span>#-0
</span></span></span><span><span><span></span> e0ae854:	<span>77206</span>f6c 	strvc	r6, [r0, -ip, ror <span>#30]!
</span></span></span><span><span><span></span> e0ae858:	<span>646</span>c726f 	strbtvs	r7, [ip], <span>#-623	; 0xfffffd91
</span></span></span><span><span><span></span> e0ae85c:	<span>6</span>f726620 	svcvs	<span>0x00726620</span>
</span></span><span><span> e0ae860:	<span>7325206</span>d 			<span>; &lt;UNDEFINED&gt; instruction: 0x7325206d
</span></span></span><span><span><span></span> e0ae864:	<span>6146000</span>a 	cmpvs	r6, sl
</span></span><span><span> e0ae868:	<span>64656</span>c69 	strbtvs	r6, [r5], <span>#-3177	; 0xfffff397
</span></span></span><span><span><span></span> e0ae86c:	<span>206</span>f7420 	rsbcs	r7, pc, r0, lsr <span>#8
</span></span></span><span><span><span></span> e0ae870:	<span>6</span>f626572 	svcvs	<span>0x00626572</span>
</span></span><span><span> e0ae874:	<span>203</span>a746f 	eorscs	r7, sl, pc, ror <span>#8
</span></span></span><span><span><span></span> e0ae878:	<span>6</span>e697073 	mcrvs	<span>0</span>, <span>3</span>, r7, cr9, cr3, <span>{</span><span>3</span><span>}</span>
</span></span><span><span> e0ae87c:	<span>676</span>e696e 	strbvs	r6, [lr, -lr, ror <span>#18]!
</span></span></span><span><span><span></span> e0ae880:	<span>646</span>e6520 	strbtvs	r6, [lr], <span>#-1312	; 0xfffffae0
</span></span></span><span><span><span></span> e0ae884:	<span>7373656</span>c 	cmnvc	r3, <span>#108, 10	; 0x1b000000
</span></span></span><span><span><span></span> e0ae888:	<span>2</span>e2e796c 	vnmulcs.f16	s14, s28, s25	<span>; &lt;UNPREDICTABLE&gt;
</span></span></span><span><span><span></span> e0ae88c:	<span>69000</span>a2e 	stmdbvs	r0, <span>{</span>r1, r2, r3, r5, r9, fp<span>}</span>
</span></span><span><span> e0ae890:	<span>322</span>d6370 	eorcc	r6, sp, <span>#112, 6	; 0xc0000001
</span></span></span><span><span><span></span> e0ae894:	<span>0032312</span>d 	eorseq	r3, r2, sp, lsr <span>#2
</span></span></span><span><span><span></span> e0ae898:	<span>2</span>d637069 	stclcs	<span>0</span>, cr7, [r3, <span>#-420]!	; 0xfffffe5c
</span></span></span><span><span><span></span> e0ae89c:	<span>00332</span>d32 	eorseq	r2, r3, r2, lsr sp
</span></span><span><span> e0ae8a0:	<span>736</span>d6369 	cmnvc	sp, <span>#-1543503871	; 0xa4000001
</span></span></span><span><span><span></span> e0ae8a4:	<span>6</span>f775f67 	svcvs	<span>0x00775f67</span>
</span></span><span><span> e0ae8a8:	<span>00716</span>b72 	rsbseq	r6, r1, r2, ror fp
</span></span></code></pre></div><p>The fourth entry, <code>0e0ad414</code>, is the <code>init_entry</code> for the PPR peripheral device.
At that address, we’ll find the address of its <code>init_function</code> (<code>0e0ac7cb</code>) and a
pointer to the device structure (<code>0e0ad474</code>).</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0ad414 <span>&lt;</span>__init___device_dts_ord_60<span>&gt;</span>:
</span></span><span><span> e0ad414:	<span>0</span>e0ac7cb 	cdpeq	<span>7</span>, <span>0</span>, cr12, cr10, cr11, <span>{</span><span>6</span><span>}</span>
</span></span><span><span> e0ad418:	<span>0</span>e0ad474 	mcreq	<span>4</span>, <span>0</span>, sp, cr10, cr4, <span>{</span><span>3</span><span>}</span>
</span></span></code></pre></div><p>As expected, the <code>init_function</code> address is the location of the
<code>nordic_vpr_launcher_init</code> function. Or, almost. There is a one byte offset in
the address stored in the <code>init_entry</code> (<code>0e0ac7cb</code>) from the address of the
launcher function (<code>0e0ac7ca</code>). In a moment we’ll see why.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0ac7ca <span>&lt;</span>nordic_vpr_launcher_init<span>&gt;</span>:
</span></span><span><span> e0ac7ca:	b510      	push	<span>{</span>r4, lr<span>}</span>
</span></span><span><span> e0ac7cc:	<span>6844</span>      	ldr	r4, [r0, <span>#4]
</span></span></span><span><span><span></span> e0ac7ce:	<span>68</span>e2      	ldr	r2, [r4, <span>#12]
</span></span></span><span><span><span></span> e0ac7d0:	b11a      	cbz	r2, <span>e0ac7da</span> &lt;nordic_vpr_launcher_init+<span>0x10</span>&gt;
</span></span><span><span> e0ac7d2:	e9d4 <span>0101</span> 	ldrd	r0, r1, [r4, <span>#4]
</span></span></span><span><span><span></span> e0ac7d6:	f000 fd56 	bl	<span>e0ad286</span> &lt;memcpy&gt;
</span></span><span><span> e0ac7da:	e9d4 <span>3200</span> 	ldrd	r3, r2, [r4]
</span></span><span><span> e0ac7de:	f8c3 <span>2808</span> 	str.w	r2, [r3, <span>#2056]	; 0x808
</span></span></span><span><span><span></span> e0ac7e2:	<span>2201</span>      	movs	r2, <span>#1
</span></span></span><span><span><span></span> e0ac7e4:	<span>6823</span>      	ldr	r3, [r4, <span>#0]
</span></span></span><span><span><span></span> e0ac7e6:	<span>2000</span>      	movs	r0, <span>#0
</span></span></span><span><span><span></span> e0ac7e8:	f8c3 <span>2800</span> 	str.w	r2, [r3, <span>#2048]	; 0x800
</span></span></span><span><span><span></span> e0ac7ec:	bd10      	pop	<span>{</span>r4, pc
</span></span></code></pre></div><p><code>z_sys_init_run_level</code> calls <code>do_device_init</code> on the PPR peripheral.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>int</span> do_device_init(<span>const</span> <span>struct</span> init_entry *entry)
</span></span><span><span>{
</span></span><span><span>	<span>const</span> <span>struct</span> device *dev = entry-&gt;dev;
</span></span><span><span>	<span>int</span> rc = <span>0</span>;
</span></span><span><span>
</span></span><span><span>	<span>if</span> (entry-&gt;init_fn.dev != <span>NULL</span>) {
</span></span><span><span>		rc = entry-&gt;init_fn.dev(dev);
</span></span><span><span>		<span>/* Mark device initialized. If initialization
</span></span></span><span><span><span>		 * failed, record the error condition.
</span></span></span><span><span><span>		 */</span>
</span></span><span><span>		<span>if</span> (rc != <span>0</span>) {
</span></span><span><span>			<span>if</span> (rc &lt; <span>0</span>) {
</span></span><span><span>				rc = -rc;
</span></span><span><span>			}
</span></span><span><span>			<span>if</span> (rc &gt; UINT8_MAX) {
</span></span><span><span>				rc = UINT8_MAX;
</span></span><span><span>			}
</span></span><span><span>			dev-&gt;state-&gt;init_res = rc;
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	dev-&gt;state-&gt;initialized = <span>true</span>;
</span></span><span><span>
</span></span><span><span>	<span>if</span> (rc == <span>0</span>) {
</span></span><span><span>		<span>/* Run automatic device runtime enablement */</span>
</span></span><span><span>		(<span>void</span>)pm_device_runtime_auto_enable(dev);
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> rc;
</span></span><span><span>}
</span></span></code></pre></div><p>It loads the <code>init_function</code> address and device pointer from the passed
<code>init_entry</code> into <code>r3</code> and <code>r4</code> respectively (<code>ldrd r3, r4, [r0]</code>). Then, if the
device initialization function is not <code>NULL</code>, invokes the function (<code>blx r3</code>)
after moving the device pointer into <code>r0</code> to be passed (<code>mov r0, r4</code>).</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0acd00 <span>&lt;</span>do_device_init<span>&gt;</span>:
</span></span><span><span> e0acd00:	b510      	push	<span>{</span>r4, lr<span>}</span>
</span></span><span><span> e0acd02:	e9d0 <span>3400</span> 	ldrd	r3, r4, [r0]
</span></span><span><span> e0acd06:	b933      	cbnz	r3, <span>e0acd16</span> &lt;do_device_init+<span>0x16</span>&gt;
</span></span><span><span> e0acd08:	<span>2000</span>      	movs	r0, <span>#0
</span></span></span><span><span><span></span> e0acd0a:	<span>68</span>e2      	ldr	r2, [r4, <span>#12]
</span></span></span><span><span><span></span> e0acd0c:	<span>7853</span>      	ldrb	r3, [r2, <span>#1]
</span></span></span><span><span><span></span> e0acd0e:	f043 <span>0301</span> 	orr.w	r3, r3, <span>#1
</span></span></span><span><span><span></span> e0acd12:	<span>7053</span>      	strb	r3, [r2, <span>#1]
</span></span></span><span><span><span></span> e0acd14:	bd10      	pop	<span>{</span>r4, pc<span>}</span>
</span></span><span><span> e0acd16:	<span>4620</span>      	mov	r0, r4
</span></span><span><span> e0acd18:	<span>4798</span>      	blx	r3
</span></span><span><span> e0acd1a:	<span>2800</span>      	cmp	r0, <span>#0
</span></span></span><span><span><span></span> e0acd1c:	d0f4      	beq.n	<span>e0acd08</span> &lt;do_device_init+<span>0x8</span>&gt;
</span></span><span><span> e0acd1e:	<span>2800</span>      	cmp	r0, <span>#0
</span></span></span><span><span><span></span> e0acd20:	bfb8      	it	lt
</span></span><span><span> e0acd22:	<span>4240</span>      	neglt	r0, r0
</span></span><span><span> e0acd24:	<span>28</span>ff      	cmp	r0, <span>#255	; 0xff
</span></span></span><span><span><span></span> e0acd26:	bfa8      	it	ge
</span></span><span><span> e0acd28:	<span>20</span>ff      	movge	r0, <span>#255	; 0xff
</span></span></span><span><span><span></span> e0acd2a:	<span>68</span>e3      	ldr	r3, [r4, <span>#12]
</span></span></span><span><span><span></span> e0acd2c:	<span>7018</span>      	strb	r0, [r3, <span>#0]
</span></span></span><span><span><span></span> e0acd2e:	e7ec      	b.n	<span>e0acd0a</span> &lt;do_device_init+<span>0xa</span>&gt;
</span></span></code></pre></div><p>The use of the <code>blx</code> instruction (“Branch with Link and Exchange”) is the reason
for the 1 byte offset in address. The Cortex-M33 implements the Armv8-M
architecture, which uses the T32 (formerly Thumb2) instruction set. Armv8
supports
<a href="https://developer.arm.com/documentation/den0013/d/Introduction-to-Assembly-Language/Interworking">“interworking”</a>,
which allows dynamically switching between A32 and T32 instruction sets using
the least significant bit of the destination address for applicable interworking
instructions to indicate the ISA used by the callee. However, Armv8-M only
supports T32, so the least significant bit must always be a <code>1</code>. The Armv8-M
Architecture Reference Manual includes the following description for the <code>blx</code>
instruction.</p>
<blockquote>
<p>Bit[0] complies with the Arm architecture interworking rules for switching
between the A32 and T32 instruction sets. However, Armv8-M only supports the
T32 instruction set, so bit[0] must be 1. If bit[0] is 0 the PE takes an
INVSTATE UsageFault exception on the instruction at the target address.</p>
</blockquote>
<p>In the <code>device_area</code> section of the application processor binary, there is a
<code>device</code> structure for the PPR peripheral. Its address matches the second member of
the <code>init_entry</code> that was passed to <code>do_device_init</code> (<code>0e0ad474</code>).</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0ad474 <span>&lt;</span>__device_dts_ord_60<span>&gt;</span>:
</span></span><span><span> e0ad474:	<span>0</span>e0ae95e 			<span>; &lt;UNDEFINED&gt; instruction: 0x0e0ae95e
</span></span></span><span><span><span></span> e0ad478:	<span>0</span>e0ae5e8 	cfsh32eq	mvfx14, mvfx10, <span>#-8
</span></span></span><span><span><span></span> e0ad47c:	<span>00000000</span> 	andeq	r0, r0, r0
</span></span><span><span> e0ad480:	<span>2</span>f011404 	svccs	<span>0x00011404</span>
</span></span><span><span> e0ad484:	<span>00000000</span> 	andeq	r0, r0, r0
</span></span></code></pre></div><p>The second member of the <code>device</code> is a pointer to the <code>config</code> (<code>0e0ae5e8</code>) for
the PPR peripheral.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>0</span>e0ae5e8 <span>&lt;</span>config0<span>&gt;</span>:
</span></span><span><span> e0ae5e8:	<span>5</span>f908000 	svcpl	<span>0x00908000</span>
</span></span><span><span> e0ae5ec:	<span>2</span>fc00000 	svccs	<span>0x00c00000</span>
</span></span><span><span> e0ae5f0:	<span>0</span>e0e4000 	cdpeq	<span>0</span>, <span>0</span>, cr4, cr14, cr0, <span>{</span><span>0</span><span>}</span>
</span></span><span><span> e0ae5f4:	<span>0000</span>f800 	andeq	pc, r0, r0, lsl <span>#16
</span></span></span></code></pre></div><p>The <code>nordic_vpr_launcher</code> defines the <code>config</code> as follows.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> nordic_vpr_launcher_config {
</span></span><span><span>	NRF_VPR_Type *vpr;
</span></span><span><span>	<span>uintptr_t</span> exec_addr;
</span></span><span><span><span>#if DT_ANY_INST_HAS_PROP_STATUS_OKAY(source_memory)
</span></span></span><span><span><span></span>	<span>uintptr_t</span> src_addr;
</span></span><span><span>	<span>size_t</span> size;
</span></span><span><span><span>#endif
</span></span></span><span><span><span></span>};
</span></span></code></pre></div><p>In the nRF54H20 <a href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54h/ug_nrf54h20_architecture_memory.html">memory layout
documentation</a>,
the slow global RAM (RAM3x) that the PRR executes from has address range from
<code>2fc00000</code> to <code>2fc14000</code>. The <code>exec_addr</code> matches the top of the range
<code>2fc00000</code>. The <code>src_addr</code> is <code>0e0e4000</code>, which resides in the
<a href="https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/device_guides/nrf54h/ug_nrf54h20_architecture_memory.html#mram10">MRAM_10</a>
address range (<code>0e000000</code> to <code>0e100000</code>). MRAM_10 is non-volatile memory used
for storing firmware images. The VPR launcher copies the PPR firmware from
MRAM_10 to RAM3x, sets the PPR program counter to the start address of RAM3x,
then starts the PPR. In the dump of the PPR firmware image (now we’re looking at
RISC-V instructions), we can see that the start address corresponds to the
expected <code>__start</code> symbol.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>2</span>fc00000 <span>&lt;</span>__start<span>&gt;</span>:
</span></span><span><span><span>2</span>fc00000:	<span>00001297</span>          	auipc	t0,<span>0x1</span>
</span></span><span><span><span>2</span>fc00004:	<span>90028293</span>          	addi	t0,t0,-<span>1792</span> <span># 2fc00900 &lt;_isr_wrapper&gt;
</span></span></span><span><span><span></span><span>2</span>fc00008:	<span>00328293</span>          	addi	t0,t0,<span>3</span>
</span></span><span><span><span>2</span>fc0000c:	<span>30529073</span>          	csrw	mtvec,t0
</span></span><span><span><span>2</span>fc00010:	<span>00000297</span>          	auipc	t0,<span>0x0</span>
</span></span><span><span><span>2</span>fc00014:	<span>0</span>f028293          	addi	t0,t0,<span>240</span> <span># 2fc00100 &lt;_irq_vector_table&gt;
</span></span></span><span><span><span></span><span>2</span>fc00018:	<span>30729073</span>          	csrw	<span>0x307</span>,t0
</span></span><span><span><span>2</span>fc0001c:	<span>0</span>a50006f          	j	<span>2fc008c0</span> &lt;_vector_end&gt;
</span></span></code></pre></div><p>However, the PPR firmware image needs to be present in the MRAM_10 region before
it can be copied. This is handled by sysbuild on <code>west flash</code> as the flash order
is defined in the generated <code>domains.yaml</code>.</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>default</span>: hello_world
</span></span><span><span><span>build_dir</span>: zephyr/samples/sysbuild/hello_world/build
</span></span><span><span><span>domains</span>:
</span></span><span><span>  - <span>name</span>: hello_world
</span></span><span><span>    <span>build_dir</span>: zephyr/samples/sysbuild/hello_world/build/hello_world
</span></span><span><span>  - <span>name</span>: remote
</span></span><span><span>    <span>build_dir</span>: zephyr/samples/sysbuild/hello_world/build/remote
</span></span><span><span><span>flash_order</span>:
</span></span><span><span>  - remote
</span></span><span><span>  - hello_world
</span></span></code></pre></div><p>After successful programming, the application processor will boot, initialize
and start the PPR, then print to the configured console on <code>/dev/ttyACM0</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>*** Booting nRF Connect SDK v2.8.0-a2386bfc8401 ***
</span></span><span><span>*** Using Zephyr OS v3.7.99-0bc3393fb112 ***
</span></span><span><span>Hello world from nrf54h20dk@0.9.0/nrf54h20/cpuapp
</span></span></code></pre></div><p>After being started by the application processor, the PPR will boot and also
print to its configured console on <code>/dev/ttyACM1</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>*** Booting nRF Connect SDK v2.8.0-a2386bfc8401 ***
</span></span><span><span>*** Using Zephyr OS v3.7.99-0bc3393fb112 ***
</span></span><span><span>Hello world from nrf54h20dk@0.9.0/nrf54h20/cpuppr
</span></span></code></pre></div><p>It is exciting to see the use of RISC-V for domain specific operations alongside
the familiar Arm processors present in many microcontrollers. With the
incoporation of VPR processors across many of Nordic’s new SoCs, it is clear
that we’ll continue to see more heterogeneous compute resources in the coming
years. Understanding the architecture of the system and the interaction between
components allows us to more fully leverage the capabilities of these products.
As we continue exploring the PPR and FLPR VPR processors, we’ll see how they can
be used to improve performance and expand functionality.</p>

      </div>


      
    </article>

    
  </section>

    </div></div>
  </body>
</html>
