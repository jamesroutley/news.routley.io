<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/50-Largest-Receptacle-in-Histogram">Original</a>
    <h1>50-Largest Receptacle in Histogram</h1>
    
    <div id="readability-page-1" class="page"><article><p>Leetcode Link: <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">https://leetcode.com/problems/largest-rectangle-in-histogram/<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>I decided to document this one partially to document some weird quirks in implementations I found, which were not intuitive to me, and also just to think out loud and do some detective work since the only way I really understand one implementation I found was to tear it almost completely apart. I think I know understand it, but I definitely couldn’t come up with it. That said, some of the techniques used in it’s construction <em>may</em> come in handy later on - at the very least, I’d never seen them before.</p>
<p>Essentially I will go through my first failing attempt, cover the recommended neetcode implementation, and then cover a substantially difficult strategy that seems to have the same anatomy at first glance but is, in my eyes considerably less intuitive. That last implementation can be found as the most optimal typescript solution on neetcode - it was also what Claude gave me.</p>
<p>In summary, I think that this did help break open the anatomy of the stack algo. In short, there are three main events when using a stack. The information pushed to the stack at the time of stacking, any mutations that maintain the stack is new information becomes available, and the information at the time where a stack entry is resoled and can be popped off the stack. All of this is obvious, but since the information available at each of these points can be quite different, it has been helpful to view stack algo construction with these 3 parts. Part 2 is pretty optional, and the elite leetcode solution doesn’t partake, while neetcode’s does.</p>
<p>But I will point out, part 1 and 2 are basically mandatory, since a stack you never need to pop isn’t really a stack, and a stack that is never pushed to is also not a stack. Again, these statements are obvious, but I’ve found it’s a nice way to “read” and construct stack algorithms.</p>
<blockquote>
<p>Hot top: If you are on leetcode and you are looking at the submission page that shows a bargraph of time-complexity score, you can actually <em>click</em> on the bars. This will bring up the submissions associated with that level of performance.</p>
</blockquote>
<p>First attempt</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> largestRectangleArea</span><span>(</span><span>heights</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> stack</span><span>:</span><span> [</span><span>number</span><span>, </span><span>number</span><span>][] </span><span>=</span><span> []</span></span>
<span data-line=""><span>    let</span><span> maxArea </span><span>=</span><span> heights[</span><span>0</span><span>]</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // we have a height for every number leading up to starting height</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 1</span><span>; i </span><span>&lt;=</span><span> heights[</span><span>0</span><span>]; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>        stack.</span><span>push</span><span>([</span></span>
<span data-line=""><span>            i, i</span></span>
<span data-line=""><span>        ])</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> j </span><span>=</span><span> 1</span><span>; j </span><span>&lt;</span><span> heights.</span><span>length</span><span>; j</span><span>++</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        const</span><span> height</span><span> =</span><span> heights[j]</span></span>
<span data-line=""><span>        if</span><span> (height </span><span>===</span><span> 0</span><span>){</span></span>
<span data-line=""><span>            continue</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        while</span><span> (stack[stack.</span><span>length</span><span>-</span><span>1</span><span>][</span><span>0</span><span>] </span><span>&gt;</span><span> height){</span></span>
<span data-line=""><span>            stack.</span><span>pop</span><span>()</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // if height is greater than highest height currently recorded</span></span>
<span data-line=""><span>        if</span><span> (height </span><span>&gt;=</span><span> stack[stack.</span><span>length</span><span>-</span><span>1</span><span>][</span><span>0</span><span>]){</span></span>
<span data-line=""> </span>
<span data-line=""><span>            // then for each previous height, increment volume by it&#39;s own heght</span></span>
<span data-line=""><span>            for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> stack.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>                stack[i][</span><span>1</span><span>] </span><span>+=</span><span> stack[i][</span><span>0</span><span>]</span></span>
<span data-line=""><span>                // check if that volume has surpassed anything</span></span>
<span data-line=""><span>                maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(stack[i][</span><span>1</span><span>], maxArea)</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""><span>            for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> stack[stack.</span><span>length</span><span>-</span><span>1</span><span>][</span><span>0</span><span>] </span><span>+</span><span> 1</span><span>; i </span><span>&lt;=</span><span> height; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>                stack.</span><span>push</span><span>([height, height])</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(height, maxArea)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> maxArea</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>second attempt</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> largestRectangleArea</span><span>(</span><span>heights</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    // Add 0 at the end to handle remaining stack elements</span></span>
<span data-line=""><span>    heights.</span><span>push</span><span>(</span><span>0</span><span>);</span></span>
<span data-line=""><span>    const</span><span> stack</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> [</span><span>-</span><span>1</span><span>];  </span><span>// Initialize with -1 for edge case handling</span></span>
<span data-line=""><span>    let</span><span> maxArea </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> heights.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        // While current height is smaller than the last height in stack</span></span>
<span data-line=""><span>        while</span><span> (stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>!==</span><span> -</span><span>1</span><span> &amp;&amp;</span><span> </span></span>
<span data-line=""><span>               heights[i] </span><span>&lt;</span><span> heights[stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>]]) {</span></span>
<span data-line=""><span>            // Calculate area with the height of the popped bar</span></span>
<span data-line=""><span>            const</span><span> height</span><span> =</span><span> heights[stack.</span><span>pop</span><span>()</span><span>!</span><span>];</span></span>
<span data-line=""><span>            const</span><span> width</span><span> =</span><span> i </span><span>-</span><span> stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>            maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(maxArea, height </span><span>*</span><span> width);</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        stack.</span><span>push</span><span>(i);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Remove the added 0 to keep input array unchanged</span></span>
<span data-line=""><span>    heights.</span><span>pop</span><span>();</span></span>
<span data-line=""><span>    return</span><span> maxArea;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>claude answer (also happens to be, I believe, the most performant TS solution on leetcode)</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> largestRectangleArea</span><span>(</span><span>heights</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    // Add 0 at the end to handle remaining stack elements</span></span>
<span data-line=""><span>    heights.</span><span>push</span><span>(</span><span>0</span><span>);</span></span>
<span data-line=""><span>    const</span><span> stack</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> [</span><span>-</span><span>1</span><span>];  </span><span>// Initialize with -1 for edge case handling</span></span>
<span data-line=""><span>    let</span><span> maxArea </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> heights.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        // While current height is smaller than the last height in stack</span></span>
<span data-line=""><span>        while</span><span> (stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>!==</span><span> -</span><span>1</span><span> &amp;&amp;</span><span> </span></span>
<span data-line=""><span>               heights[i] </span><span>&lt;</span><span> heights[stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>]]) {</span></span>
<span data-line=""><span>            // Calculate area with the height of the popped bar</span></span>
<span data-line=""><span>            const</span><span> height</span><span> =</span><span> heights[stack.</span><span>pop</span><span>()</span><span>!</span><span>];</span></span>
<span data-line=""><span>            const</span><span> width</span><span> =</span><span> i </span><span>-</span><span> stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>            maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(maxArea, height </span><span>*</span><span> width);</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        stack.</span><span>push</span><span>(i);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Remove the added 0 to keep input array unchanged</span></span>
<span data-line=""><span>    heights.</span><span>pop</span><span>();</span></span>
<span data-line=""><span>    return</span><span> maxArea;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>The claude answer corresponds to the most performant answer on leetcode, but it’s not the most understandable at all. For that, I’d say neetcode’s is, as you’d expect:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>class</span><span> Solution</span><span> {</span></span>
<span data-line=""><span>    /**</span></span>
<span data-line=""><span>     * </span><span>@param</span><span> {number[]}</span><span> heights</span></span>
<span data-line=""><span>     * </span><span>@return</span><span> {number}</span></span>
<span data-line=""><span>     */</span></span>
<span data-line=""><span>    largestRectangleArea</span><span>(</span><span>heights</span><span>) {</span></span>
<span data-line=""><span>        let</span><span> maxArea </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""><span>        const</span><span> stack</span><span> =</span><span> []; </span><span>// pair: (index, height)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> heights.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>            let</span><span> start </span><span>=</span><span> i;</span></span>
<span data-line=""><span>            while</span><span> (</span></span>
<span data-line=""><span>                stack.</span><span>length</span><span> &gt;</span><span> 0</span><span> &amp;&amp;</span></span>
<span data-line=""><span>                stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>][</span><span>1</span><span>] </span><span>&gt;</span><span> heights[i]</span></span>
<span data-line=""><span>            ) {</span></span>
<span data-line=""><span>                const</span><span> [</span><span>index</span><span>, </span><span>height</span><span>] </span><span>=</span><span> stack.</span><span>pop</span><span>();</span></span>
<span data-line=""><span>                maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(maxArea, height </span><span>*</span><span> (i </span><span>-</span><span> index));</span></span>
<span data-line=""><span>                start </span><span>=</span><span> index;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            stack.</span><span>push</span><span>([start, heights[i]]);</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>const</span><span> [</span><span>index</span><span>, </span><span>height</span><span>] </span><span>of</span><span> stack) {</span></span>
<span data-line=""><span>            maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(maxArea, height </span><span>*</span><span> (heights.</span><span>length</span><span> -</span><span> index));</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        return</span><span> maxArea;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>It’s a bit more verbose but a lot easier to understand.</p>
<p>The way I think of it, it goes through each vertical height and, as long as that height is monotonically increasing, adds that column to our stack with a height and an index. (technically if you have an index you can always get height, which is where the more performant solution differs.)</p>
<p>Whenever you get a column that’s <em>smaller</em> than any of the heights recorded on that stack, you pop them all off and calculate their total area as you go.</p>
<p>I think about it this way - you could</p>
<ol>
<li>try to calculate ahead (for a cost of additional time complexity) for each height</li>
<li>calculate as you go along (I tried this and I think it would work but it’s a lot of extra work since the third option exists)</li>
<li>calculate whenever the area of a certain height <em>ends</em> because a new height has arrived and its shorter than the previous height(s).</li>
</ol>
<p>This last approach I think fits the best with the philosophy of using stacks itself. The second one reminds me more of sliding windows, and may not play well with stacks, whereas the first is really just brute force with O(n2) time complexity, which would work but would not impress an interviewer.</p>
<p>I say that approach #3 is so inline with the philosophy of stacks because stacks work the best when you are recording info to process later once you have its full context. That’s exactly what we’re doing here. We are saying “hey okay, this new height might be the start of a rectangle with the largest maxHeight. I’m going to save the information I have now, like the height and starting index, and then I will wait for a future event when I have the information to know when the rectangle ends. I will see if it has the maxArea then.”</p>
<p>Stacks are a useful approach to say hey, this stuff still needs to be processed, then once its processed, get it out of there.</p>
<p>There’s a twist to this, but it’s not really a twist at all. We just need to remember, in this use of stacks, we are updating info of a particular height <em>only twice</em>. Once when we initially add it to the stack, and another time when we pop it from the stack.</p>
<p>A few expectations follow from this -</p>
<ol>
<li>every item will be pushed to the stack</li>
<li>every item will eventually be popped from the stack</li>
</ol>
<p>To achieve the second condition, neetcode explicitly creates a forloop to do this.</p>
<p>There is also a simpler way that we can do that I borrowed from Claude’s answer, which is to just add a <code>0</code> to the end of heights and the shape of our ingested data to our advantage.</p>
<p>Most of the reason I actually started writing these notes though was because this single line <code>claude</code>’s answer / the most performant solution on Leetcode was a total mindfuck to me.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> width</span><span> =</span><span> i </span><span>-</span><span> stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>-</span><span> 1</span><span>;</span></span></code></pre></figure>
<p>After pondering this line for a while, I realized something that simply wasn’t intuitive to me right away -</p>
<p>because in <em>this</em> solution, the stack is being <code>pop()</code>’d <em>before</em> they calculate the width, they need to get a width that’s <em>just 1 narrower</em> than the post-<code>pop()</code> stack. If they just popped before, <code>i - stack[-1]</code> (to use python syntax for brevity) would provide the proper width.</p>
<p>Take the example where these are our heights:
<code>1, 2, 3, 4, 1</code></p>
<p>So that by the time we’ve saved the height for index <code>3</code> (which has height <code>4</code>), we have a stack that looks like this:</p>





























<div><table><thead><tr><th>start index</th><th>height</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>3</td></tr><tr><td>3</td><td>4</td></tr><tr><td>At this point we check to see if the last item of the stack is greater than the next height in the list, and it is - <code>4</code> is greater than <code>1</code>.</td><td></td></tr></tbody></table></div>
<p>So if we just subtracted the last <code>start index</code> value of our stack, which is <code>3</code> from our current index of <code>4</code>, we’d get <code>1</code>, which is exactly the width we want for the column with height <code>4</code> that only occurs over a distance of 1.</p>
<p><code>3</code> is also greater than one, so we do the same for <code>3</code> - we subtract it’s <code>start index</code> of <code>2</code> from our current index of <code>4</code> and we get <code>2</code>, which is also right - the rectangle starting at <code>3</code> has a width of <code>2</code>.</p>
<p>We do pretty much the same thing for the stack entry at <code>start index: 2</code>, and we get a width of <code>3</code>.</p>
<p>The thing is, in the Claude example, they <code>pop</code> first, so to get the same result, they need to subtract one from the last index in the stack.</p>
<p>The reason I needed to write this down is just because the math here, though simple, really confused me. What was counterintuitive was the idea of subtracting one from the difference to compensate for a starting index that was one too low.</p>
<p>The I finally realized than a starting index that was one too low would actually lead to a <em>higher</em> value for the difference. I.e, if we have <code>1, 2, 1</code> and we’re considering the last height at index <code>2</code> and we pop <code>[1, 2]</code> off our stack, the next item on the stack is <code>[0, 1</code>. If we subtract <code>0</code> from our index of <code>2</code>, we get <code>2</code> for the width of the <code>2</code> height column. But that’s not right - the 2 column is only there for a width of one. And this is because, having popped it, our starting index is too low by one.</p>
<p>To re-iterate just one more time, what was confusing for me was just how decreasing the value of the bottom of a range by actually <em>increments</em> the span of that range, not decrements. Somehow that was counterintuitive to me when I just just looking at numbers.</p>
<p>There are still a lot of things about the Claude solution that don’t make sense to me though.</p>
<ol>
<li>Why, when I get rid of this sort of backwards <code>1-stack[-1]-1</code> by putting <code>pop</code> <em>after</em> width calculation, does this algo fail on the <code>2, 1, 2</code> testcase?</li>
<li>How does <em>this</em> algo handling the backwards <code>start-index</code> checking like neetcode’s algo does?</li>
<li>How does this algo handle duplicates in the past, like in <code>1, 2, 1</code>?</li>
</ol>

<p>The best way to figure this out seems to be to go through the test case, which happens to be pretty short. Just to be clear, here’s what I changed Claude’s algo to:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> largestRectangleArea</span><span>(</span><span>heights</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    heights.</span><span>push</span><span>(</span><span>0</span><span>);</span></span>
<span data-line=""><span>    const</span><span> stack</span><span>:</span><span> number</span><span>[] </span><span>=</span><span> [</span><span>-</span><span>1</span><span>];</span></span>
<span data-line=""><span>    let</span><span> maxArea </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> heights.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        while</span><span> (</span></span>
<span data-line=""><span>	        stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>] </span><span>!==</span><span> -</span><span>1</span><span> &amp;&amp;</span><span> </span></span>
<span data-line=""><span>            heights[i] </span><span>&lt;</span><span> heights[stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>]]</span></span>
<span data-line=""><span>        ) {</span></span>
<span data-line=""><span>            const</span><span> width</span><span> =</span><span> i </span><span>-</span><span> stack[stack.</span><span>length</span><span> -</span><span> 1</span><span>];</span></span>
<span data-line=""><span>            const</span><span> height</span><span> =</span><span> heights[stack.</span><span>pop</span><span>()</span><span>!</span><span>];</span></span>
<span data-line=""><span>            maxArea </span><span>=</span><span> Math.</span><span>max</span><span>(maxArea, height </span><span>*</span><span> width);</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        stack.</span><span>push</span><span>(i);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> maxArea;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>See? I’ve put the <code>pop</code> statement after width calculation, and removed the <code>-1</code> addendum to the width calculation line. And this is correct for 53/99 test-cases, so it’s probably right for most of the more obvious cases, which means our odds for this very simple case showing us what is breaking it are good.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/6585accb35dcdb8e46506c16218d8353.png" alt="image"/></p>
<p>Okay so I tried it out, and it turns out that this algo must do the <code>backwards stack</code> computation in some different way that I’ve disrupted. We get that 1 continues through the second 2, but not that a rectangle with a height of 1 starts at the first 2 as well.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/4a7118eb9f6671a6297234fc67ad6795.png" alt="image"/></p>
<p>That’s why we get this wrong answer <code>2</code> instead of the expected <code>3</code>. But why do we get <code>3</code> when the popping happens earlier?</p>
<p>So here’s the one with some things shuffled around so all test cases pass:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>!</span><span>[image](https:</span><span>//thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/02266318d97a688de6828fc342e53338.png)</span></span></code></pre></figure>
<p>Let’s check it out. Oh also make note, that if we are getting <code>-1</code> on that width line, we’re actually <em>subtracting</em> <code>-1</code>, which is adding one. So right after popping that first <code>2</code>, we do <code>1+1-1</code> to get a width of <code>1</code>. Perfect.</p>
<p>Fuck. I followed it all the way through and it doesn’t make much more sense to me to be honest. It works so well, but I don’t get it. We pop off that last 2, and from our vantage point of <code>i = 3</code>, we do <code>3 - 1 - 1</code> and get <code>1</code>.</p>
<p>Cool. We would be doing <code>3 - 2</code> to get one, which would work fine, but of course we’re popping that <code>2</code> entry off first, so the previous index is just <code>1</code>. So we get the difference between <code>3</code> and <code>1</code> and it’s <code>2</code>, but we subtract an extra <code>1</code> from that to make it non-inclusive of the bottom delimiting index, which we don’t want to include since it’s not actually where the rectangle starts.</p>
<p>Now what happens for the <code>1</code> on the stack on the phase of the while loop that we pop it off?</p>
<p>I think what happens is this -
imagine that we had something more like <code>1, 3, 2, 3</code>. When we go to the second 1, the initial <code>2</code> would get popped off, leaving the last index before it to be a <code>0</code>. This means that when we pop off the <code>3</code> and then the <code>2</code> at the end, we check to see where the <code>2</code> began. We know it ends at <code>i</code>, which is <code>4</code>, cool. But where does it start? Well it start it at the space in front of <code>0</code> - <code>0</code> of course is not where it starts, there’s a 1 there. But we know that because that’s the last index with a LOWER value than <code>2</code>, if we subtract the index <em>just after that first lower value in the past</em> from our current index (which we know is a HIGHER value than 2, and is so in a monotonic way, ensuring no breaks in 2 up to that point) then we will get the width of that 2.</p>
<p>So there’s some logic there that makes sense. We pop first and then, instead of doing <code>neetcode</code>’s method of keeping our first index up to date <em>as we pop bigger values</em> that we can extend our lower values back into, we pop first, and we know that our current rectangle starts <em>just after</em> the new end of our stack, which now points to the first value going backwards that cannot be part of our rectangle.</p>
<p>We’re really finding these two discrete pieces of information - given a current index, what is the first position going <em>backwards</em> that <em>can’t</em> be in our rectangle?</p>
<p>answer: the one right before the value we just popped.</p>
<p>explanation: because we have enforced that our stack is monotonically ascending and there are no duplicates either, we know that our rectangle for any given value will always start just after the first value on the stack that is lower than it. And since we popped it, the first value lower than it is always going to be at the top of the stack.</p>
<p>This includes our <code>-1</code> sentinel value! <code>i-(-1)-1</code> is always going to equal <code>i</code> - the <code>-1</code> is a way to mathematically say that our current value goes all the way to the beginning, in very much the same way that if our value’s first instance was at index <code>0</code>, well, that would get popped <em>too</em>, since if it has a height of anything other than <code>0</code>, that last <code>0</code> value we push is going to pop that off and put us back at <code>-1</code>.</p>
<p>Geez. Yeah the logic of this is so strange. It does make sense, but it’s really twisted.</p>

<p>I pretty much handled this in the previous exploration. Backwards values are handled by you know, popping the current value and just getting the index of <em>one in front of</em> the last value on the stack, which is going to be the <em>first</em> index that we <em>can’t</em> include in our current rectangle as I feel I’ve now stated at least 4 times because it’s really hard to get into words. I think it should probably be a picture.</p>

<p>So let’s consider the case of <code>1, 2, 1</code>. What I’m curious about is, since our stack really becomes <code>1, 2, 1, 0</code>, once we get to that <code>0</code> and we pop off <code>1</code>, what happens then?</p>
<p>Well before that, we’ll have already popped off <code>2</code> once we’ve gotten to <code>i=2</code>. So let’s jump there.</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/e4e004ffa68396ebceb09497f47b3c9c.png" alt="image"/></p>
<p>Okay! The explanation is really simple actually!</p>
<p>The backwards-computation works as demonstrated thoroughly - once we pop the current height we’re considering, we end up starting our rectangle <em>just after</em> the last documented index. OR <code>-1</code> , which effectively allows us to just compute our width as being equivalent to <code>i</code>.</p>
<p>THE KICKER IS, with redundant values, we compute all duplicate heights in our stack, even if intermediate values like the <code>2</code> here have already been popped away leaving us with a stack where the heights pointed to by our indexes are <code>-, 1, 1</code>. From those repeats, an incomplete computation of the width of the first <code>1</code> is created, which extends only back into the <code>2</code> before it. But then, the other <code>i</code>’s width is computed to. This one <em>correctly</em> extends back to the index just after <code>-1</code>, which would be <code>0</code>, and just like the first one, also correctly extends to our current i of <code>3</code>. So we get a width of 3! The first <code>1</code>’s width is half right, but doesn’t go back far enough, even if it ends in the right place. The second <code>1</code>’s width is fully right. It starts <em>and</em> ends in the right place. It does make you think, since the second <code>1</code>’s width is, in this case, useless, we might optimize by not calculating it at all.</p>
<p>So I guess this all makes sense now. Is it intuitive? Eh. A little more so. Still a crazy way to do this, what with the <code>-1</code> sentinel value, the clever <code>0</code> put at the end of height. Although doing away with the backwards computation/mutation that neetcode does is pretty smart, and it allows us to compute the width at <code>pop</code>-time without doing any maintenance, which is cool.</p></article></div>
  </body>
</html>
