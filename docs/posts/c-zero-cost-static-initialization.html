<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cofault.com/zero-cost-static.html">Original</a>
    <h1>C&#43;&#43;: Zero-cost static initialization</h1>
    
    <div id="readability-page-1" class="page"><div><header>Zero-cost statics in C++</header>
<p><span> &#34;<i>Усердие все превозмогает!</i>&#34;</span></p>
<p><span> К. Прутков, <a href="https://ru.wikisource.org/wiki/%D0%9C%D1%8B%D1%81%D0%BB%D0%B8_%D0%B8_%D0%B0%D1%84%D0%BE%D1%80%D0%B8%D0%B7%D0%BC%D1%8B_I_(%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2)">Мысли и афоризмы, I</a>, 84</span></p>
<p>In C and C++ a static variable can be defined in a function scope:</p>
<pre><code>int foo() {
        static int counter = 1;
        printf(&#34;foo() has been called %i times.\n&#34;, counter++);
        ...
}</code></pre>
<p>Technically, this defines <code>counter</code> as an object of <a href="https://en.cppreference.com/w/cpp/language/storage_duration.html">static storage duration</a> that is allocated not within the function activation frame (which is typically on the stack, but can be on the heap for a <a href="https://en.cppreference.com/w/cpp/language/coroutines.html">coroutine</a>), but as a global object. This is often used to shift computational cost out of the hot path, by precomputing some state and storing it in a static object.</p>
<p>When exactly a static object is initialised?</p>
<p>For C this question is vacuous, because the initialiser must be a <a href="https://en.cppreference.com/w/c/language/initialization.html">compile-time constant</a>, so the actual value of the static object is embedded in the compiled binary and is always valid.</p>
<p>C++ has a bizarrely complicated taxonomy of <a href="https://en.cppreference.com/w/cpp/language/initialization.html">initialisations</a>. There is <a href="https://timsong-cpp.github.io/cppwp/n4861/basic.start.static">static</a> initialisation, which roughly corresponds to C initialisation, subdivided into constant-initialisation and zero-initialisation. Then there is <a href="https://timsong-cpp.github.io/cppwp/n4861/basic.start.dynamic">dynamic</a> initialisation, further divided into unordered, partially-ordered and ordered categories. None of these, however, captures our case: for block-local variables, the Standard has a special sub-section in &#34;Declaration statement&#34; [<a href="https://timsong-cpp.github.io/cppwp/n4861/stmt.dcl#4">stmt.dcl.4</a>]:</p>
<p>Dynamic initialization of a block-scope variable with static storage duration  or thread storage duration is performed the first time control passes through  its declaration; such a variable is considered initialized upon the completion  of its initialization. If the initialization exits by throwing an exception,  the initialization is not complete, so it will be tried again the next time  control enters the declaration. If control enters the declaration concurrently  while the variable is being initialized, the concurrent execution shall wait  for completion of the initialization. If control re-enters the declaration  recursively while the variable is being initialized, the behavior is  undefined.</p>
<p>For example in</p>
<pre><code>struct Bar {
        Bar() : var(1) {}
        int var;
};

int foo(int x) {
        static Bar b{};
        return b.var + 1;
}</code></pre>
<p>the constructor for <code>b</code> should be called exactly once when <code>foo()</code> is called the first time. This initialisation semantics is very close (sans the exceptions part) to <a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_once.html"><code>pthread_once</code></a><code>()</code>. It is clear that the compiler must add some sort of an internal flag to check whether the initialisation has already been performed and some synchronisation object to serialise concurrent calls to <code>foo()</code> [<a href="https://gcc.godbolt.org/z/3xKea3MW4">godbolt</a>]:</p>
<pre><code>foo(int):
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], edi
        movzx   eax, BYTE PTR guard variable for foo(int)::b[rip]
        test    al, al
        sete    al
        test    al, al
        je      .L3
        mov     edi, OFFSET FLAT:guard variable for foo(int)::b
        call    __cxa_guard_acquire
        test    eax, eax
        setne   al
        test    al, al
        je      .L3
        mov     edi, OFFSET FLAT:foo(int)::b
        call    Bar::Bar() [complete object constructor]
        mov     edi, OFFSET FLAT:guard variable for foo(int)::b
        call    __cxa_guard_release
.L3:
        mov     eax, DWORD PTR foo(int)::b[rip]
        add     eax, 1
        leave
        ret</code></pre>
<p>This corresponds roughly to the following code:</p>
<pre><code>int foo(int x) {
        static Bar b{};
        static std::atomic&lt;int&gt; __b_guard = 0;
        if (__cxa_guard_acquire(&amp;__b_guard) != 0) {
                new (&amp;b) Bar{}; /* Construct b in-place. */
                __cxa_guard_release(&amp;__b_guard)
        }
        return b.var + 1;
}</code></pre>
<p>Here <code>__b_guard</code> (<code>guard variable for foo(int)::b</code> in assembly) is the flag variable added by the compiler. <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/guard.cc#L272"><code>__cxa_guard_acquire</code></a><code>()</code> is a suprisingly complex function, which includes its own synchronisation mechanism implemented directly on top of the raw Linux <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex syscall</a>.</p>
<p>Even after the static variable has been initialised, the overhead of accessing it is still considerable: a function call to <code>__cxa_guard_acquire()</code>, plus <code>atomic_load_explicit(&amp;__b_guard, memory_order::acquire)</code> in <code>__cxa_guard_acquire()</code>. On ARM, such atomic load incurs a memory barrier---a fairly expensive operation.</p>
<p>Can this additional cost be reduced? Yes, in fact it can be completely eliminated, making block-level static variables exactly as efficient as file-level ones. For this we need a certain old, but little-known feature of UNIX linkers. From GNU binutils <a href="https://sourceware.org/binutils/docs/ld.html#Input-Section-Example">documentation</a> (beware than in the old versions the terminating symbol is mistakenly referred to as <code>__end_SECNAME</code>):</p>
<p>If an output section’s name is the same as the input section’s name and is representable as a C identifier, then the linker will automatically <code>PROVIDE</code> two symbols: <code>__start_SECNAME</code> and <code>__stop_SECNAME</code>, where <code>SECNAME</code> is the name of the section. These indicate the start address and end address of the output section respectively. Note: most section names are not representable as C identifiers because they contain a ‘.’ character.</p>
<p>(Solaris linker calls them &#34;Encapsulation Symbols&#34;, see <a href="https://docs.oracle.com/en/operating-systems/solaris/oracle-solaris/11.4/linkers-libraries/oracle-solaris-11.4-linkers-and-libraries-guide.pdf">here</a>.)</p>
<p>The idea is the following: instead of defining a block-level static instance of <code>Bar</code>, define a trivially-initialisable object of a size sufficient to hold an instance of <code>Bar</code> in a dedicated section <code>STATIC_Bar</code>, via (more or less portable) <a href="https://gcc.gnu.org/onlinedocs/gcc-4.8.5/gcc/Variable-Attributes.html"><code>__attribute__((section))</code></a>. Only such place-holder objects and nothing else are placed in this section. Then, during global static initialisation, scan the resulting array of place-holder objects from <code>__start_STATIC_Bar</code> to <code>__stop_STATIC_Bar</code> and initialise Bar instances in-place. Assuming that functions where static <code>Bar</code>s are defined are not themselves called during global static initialisation, this would initialise everything correctly: by the time <code>foo()</code> is called, its <code>b</code> has already been initialised.</p>
<p>Something like this:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;new&gt; /* For placement new. */

#define FAST_STATIC(T)                                                                    \
*({                                                                                       \
        struct placeholder {                                                              \
            alignas(T) char buf[sizeof(T)];                                               \
        };                                                                                \
        static constinit placeholder ph __attribute__((section (&#34;STATIC_&#34; #T))) {{}};     \
        reinterpret_cast&lt;T *&gt;(ph.buf);                                                    \
})

template &lt;typename T&gt; static int section_init(T *start, T *stop)
{
        for (T *s = start; s &lt; stop; ++s)
            new (s) T; /* Construct in-place. */
        return 0;
}

#define FAST_STATIC_INIT(T)                                     \
extern &#34;C&#34; T __start_STATIC_ ## T;                              \
extern &#34;C&#34; T __stop_STATIC_ ## T;                               \
static int _init_ ## T = section_init&lt;T&gt;(&amp;__start_STATIC_ ## T, \
                                         &amp;__stop_STATIC_ ## T);

struct Bar {
        Bar() : var(1) {}
        int var;
};

int foo(int x) {
        Bar &amp;b0 = FAST_STATIC(Bar);
        Bar &amp;b1 = FAST_STATIC(Bar);
        return b0.var + b1.var + 1;
}

FAST_STATIC_INIT(Bar);

int main(int argc, char **argv) {
        return printf(&#34;%i\n&#34;, foo(argc)); /* Prints &#34;3&#34;. */
}</code></pre>
<p>Check the resulting assembly [<a href="https://gcc.godbolt.org/z/bf3h7hzcz">godbolt</a>]:</p>
<pre><code>foo(int)::ph:
        .zero   4
foo(int)::ph:
        .zero   4
foo(int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     QWORD PTR [rbp-8], OFFSET FLAT:foo(int)::ph
        mov     QWORD PTR [rbp-16], OFFSET FLAT:foo(int)::ph
        mov     rax, QWORD PTR [rbp-8]
        mov     edx, DWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-16]
        mov     eax, DWORD PTR [rax]
        add     eax, edx
        add     eax, 1
        pop     rbp
        ret</code></pre>
<p><i>Voilà</i>! The calls to <code>__cxa_guard_acquire()</code> are gone, yet <code>b0</code> and <code>b1</code> are initialised before <code>foo()</code> is called, just as we want. <i>But not so fast</i>, it&#39;s C++.</p>
<p>Let&#39;s add another static Bar instance, this time in an inline function:</p>
<pre><code>int inline baz(int x) {
        Bar &amp;b = FAST_STATIC(Bar);
        return b.var * x;
}</code></pre>
<p>GCC reports [<a href="https://gcc.godbolt.org/z/Th1ece58b">godbolt</a>]:</p>
<pre><code>&lt;source&gt;:9:38: error: &#39;ph&#39; causes a section type conflict with &#39;ph&#39; in section &#39;STATIC_Bar&#39;</code></pre>
<p>(clang works fine [<a href="https://gcc.godbolt.org/z/YT9bdG5Ke">godbolt</a>], by the way.)</p>
<p>The problem is that in addition to name, sections output by the compiler also have attributes. The compiler selects the attributes based on the properties of the scope where the symbol (to which <code>__attribute__((section))</code> is applied) is defined. Inline functions force a different attribute selection (similarly do template members), and the linker ends up with multiple sections with the same name, but conflicting attributes. See <a href="https://stackoverflow.com/questions/35091862/inline-static-data-causes-a-section-type-conflict">stackoverflow</a> for details.</p>
<p>As it is, <code>FAST_STATIC()</code> is usable, but section attribute conflicts put awkward resrictions on its applicability. Is this the best we can do? For some time I thought that it is, but then I realised that there is another way to specify the section in which the variable is located: the <a href="https://sourceware.org/binutils/docs/as/PushSection.html"><code>.pushsection</code></a> directive of the embedded assembler (do not be afraid, we will use only portable part).</p>
<p>If you do something like</p>
<pre><code>__asm__(&#34;.pushsection STATIC_Bar,\&#34;aw\&#34;,@progbits\n&#34; \
        &#34;.quad &#34; symbol &#34;\n&#34;                         \
        &#34;.popsection\n&#34;)</code></pre>
<p>then the address of the <code>symbol</code> is placed in <code>STATIC_Bar</code> section with the specified <a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_117.html">attributes</a>.</p>
<p>All we need is something like</p>
<pre><code>#define FAST_STATIC(T)                                          \
*({                                                             \
        struct placeholder {                                    \
            alignas(T) char buf[sizeof(T)];                     \
        };                                                      \
        static constinit placeholder ph {{}};                   \
        __asm__(&#34;.pushsection STATIC_&#34; #T &#34;,\&#34;aw\&#34;,@progbits\n&#34; \
                &#34;.quad ph\n&#34;                                    \
                &#34;.popsection\n&#34;);                               \
        reinterpret_cast&lt;T *&gt;(ph.buf);                          \
})</code></pre>
<p>and we are good (<code>section_init()</code> needs to be fixed a bit, because <code>STATIC_Bar</code> now contains pointers, not instances). <i>But not so fast</i>, it&#39;s C++. This does not even compile [<a href="https://gcc.godbolt.org/z/b49974Wfr">godbolt</a>]:</p>
<pre><code>ld: /tmp/ccZRzXXj.o:(STATIC_Bar+0x0): undefined reference to `ph&#39;
ld: /tmp/ccZRzXXj.o:(STATIC_Bar+0x8): undefined reference to `ph&#39;
ld: /tmp/ccZRzXXj.o:(STATIC_Bar+0x10): undefined reference to `ph&#39;
collect2: error: ld returned 1 exit status
Execution build compiler returned: 1</code></pre>
<p>When you define <code>static constinit placeholder ph</code>, the actual name the compiler uses for the symbol is not <code>ph</code> it is the mangled version of something like <code>foo(int)::ph</code> that we saw in the assembly listing above. There is no <code>ph</code> for <code>.quad ph</code> to resolve to.</p>
<p>OK. Are we stuck <i>now</i>? In fact not. You can <a href="https://gcc.gnu.org/onlinedocs/gcc/Asm-Labels.html">instruct the compiler</a> to use a particular symbol name, instead of the mangled one. With</p>
<pre><code>        int foo asm (&#34;bar&#34;) = 2;</code></pre>
<p>the compiler will use &#34;bar&#34; as the symbol name for <code>foo</code> (both gcc and clang support this).</p>
<p>Of course if we just do</p>
<pre><code>        static constinit placeholder ph asm(&#34;ph&#34;) {{}};</code></pre>
<p>we fall in the opposite trap of having multiple definitions for &#34;ph&#34;. We need to define unique names for our symbols, but there is more or less standard trick for this, based on <a href="https://www.open-std.org/JTC1/sc22/wg14/www/docs/n3457.htm"><code>__COUNTER__</code></a> macro. We also need a couple of, again standard, macros for concatenation and stringification. The final version looks like this:</p>
<pre><code>#define CAT0(a, b) a ## b
#define CAT(a, b) CAT0(a, b)

#define STR0(x) # x
#define STR(x) STR0(x)

#define FAST_STATIC_DO(T, id)                                   \
*({                                                             \
        struct placeholder {                                    \
            alignas(T) char buf[sizeof(T)];                     \
        };                                                      \
        static constinit placeholder id asm(STR(id)) {{}};      \
        __asm__(&#34;.pushsection STATIC_&#34; #T &#34;,\&#34;aw\&#34;,@progbits\n&#34; \
                &#34;.quad &#34; STR(id) &#34;\n&#34;                           \
                &#34;.popsection\n&#34;);                               \
        reinterpret_cast&lt;T *&gt;(id.buf);                          \
})

#define FAST_STATIC(T) FAST_STATIC_DO(T, CAT(ph_, __COUNTER__))

template &lt;typename T&gt; static int section_init(T **start, T **stop)
{
        for (T **s = start; s &lt; stop; ++s)
                new (*s) T; /* Construct in-place. */
        return 0;
}

#define FAST_STATIC_INIT(T)                                      \
extern &#34;C&#34; T *__start_STATIC_ ## T;                              \
extern &#34;C&#34; T *__stop_STATIC_ ## T;                               \
static int _init_ ## T = section_init&lt;T&gt;(&amp;__start_STATIC_ ## T,  \
                                         &amp;__stop_STATIC_ ## T);</code></pre>
<p>The resulting assembly for <code>foo()</code> and <code>foo_init()</code> [<a href="https://gcc.godbolt.org/z/89xrYWhMh">godbolt</a>] accesses statics directly:</p>
<pre><code>foo(int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     QWORD PTR [rbp-8], OFFSET FLAT:ph_0
        mov     QWORD PTR [rbp-16], OFFSET FLAT:ph_1
        mov     rax, QWORD PTR [rbp-8]
        mov     edx, DWORD PTR [rax]
        mov     rax, QWORD PTR [rbp-16]
        mov     eax, DWORD PTR [rax]
        add     eax, edx
        add     eax, 1
        pop     rbp
        ret
foo_inline(int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-20], edi
        mov     QWORD PTR [rbp-8], OFFSET FLAT:ph_2
        mov     rax, QWORD PTR [rbp-8]
        mov     eax, DWORD PTR [rax]
        imul    eax, DWORD PTR [rbp-20]
        pop     rbp
        ret</code></pre>
<p>Finally we won!</p>
<p><span> &#34;<i>Бывает, что усердие превозмогает и рассудок</i>&#34;</span></p>
<p><span> К. Прутков, <a href="https://ru.wikisource.org/wiki/%D0%9C%D1%8B%D1%81%D0%BB%D0%B8_%D0%B8_%D0%B0%D1%84%D0%BE%D1%80%D0%B8%D0%B7%D0%BC%D1%8B_II_(%D0%9F%D1%80%D1%83%D1%82%D0%BA%D0%BE%D0%B2)">Мысли и афоризмы, II</a>, 27</span></p>
<p>P.S. The actual implementation requires more bells and whistles. Parameters need to be passed to constructors, they can be stored within the placeholder. Typenames are not necessarily valid identifiers (think <code>A::B::foo&lt;T&gt;</code>), so the section name needs to be a separate parameter, <i>etc</i>., but the basic idea should be clear.</p>
<p>P.P.S. I have a similar story about optimising access to thread-local variables, involving C++20 <a href="https://en.cppreference.com/w/cpp/language/constinit.html"><code>constinit</code></a> and <a href="https://www.ibm.com/docs/en/xl-c-and-cpp-aix/16.1.0?topic=attributes-tls-model-attribute"><code>__attribute__((tls_model(&#34;initial-exec&#34;)))</code></a>.</p></div></div>
  </body>
</html>
