<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duriansoftware.com/joe/type-erased-generic-functions-for-c:-a-modest-non-proposal">Original</a>
    <h1>Type-erased generic functions for C: A modest non-proposal</h1>
    
    <div id="readability-page-1" class="page">
<p>September 29, 2024</p>
Earlier this year, I read <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3212.pdf">Martin Uecker&#39;s proposal N3212</a> to add parametric polymorphism to C. It&#39;s easy to scoff at the idea of adding generic programming to plain C, when C++ already has templates, and nearly every modern systems language has some form of generic programming support, but it got me thinking there is an opportunity to do something meaningfully and usefully different from those other languages. C++ templates rely on monomorphization, meaning that when you write a generic function or type, the compiler generates a distinct specialization for every set of types you use it with. Most other systems-ish languages follow C++&#39;s lead, because monomorphization allows each specialization to be individually emitted and optimized specifically for the set of types it&#39;s instantiated on, and the resulting specializations don&#39;t need any runtime support to handle different types. However, monomorphization also implies a much more complicated compilation and linking model, where the source code (or some intermediate representation thereof) of generic definitions has to be consistently available to the compiler in order to generate new instantiations as needed.
<p>
Although C is not really the &#34;portable assembly language&#34; many want it to be, one function definition in C generally leads to one symbol in an object file, and having access to function bodies after they&#39;ve been compiled once is unnecessary (although helpful for optimization), and it would be good to retain these properties. A less-trodden path for implementing parametric polymorphism in systems-ish languages, used by Swift and also proposed here in N3212, is to use runtime metadata to handle generic types dynamically.  N3212 proposes a new <tt>_Type</tt> primitive type, which carries some metadata about a type&#39;s size and other properties, so that other values can be declared with the type represented by that <tt>_Type</tt> using the <tt>_Var</tt> specifier:
</p><pre>void sort(_Type T, size_t N, _Var(T) array[N], 
          int (*compare)(const _Var(T)*, const _Var(T)*))
{
   qsort(array, N, sizeof(_Var(T)), compare);
}
</pre>
One challenge specifying a language-integrated metadata system is that it needs to provide enough information to serve any possible use that the language supports, even if a particular interface only needs a subset of that metadata. A traditional qsort function only needs the size of the elements to do its work, but other generic functions might want to know a type&#39;s alignment, its name, how values of the type interact with the function calling convention, the specifier to use in printf, and so on. The vast body of existing C code uses all sorts of different idioms for ad-hoc polymorphic interfaces, so a language design that prescribes a single metadata mechanism is going to have a tough time finding a balance between providing enough metadata to support a wide range of use cases and not bloating code generation with too much metadata that most clients don&#39;t need.
<p>
So that&#39;s why I&#39;d like to explore a third approach that has the potential to be simpler to understand and implement, more flexible, and I think more in the subjective &#34;spirit of C&#34; than C++ style monomorphization or the proposed N3212 design. I think the combination of type-erased generics, paired with a default argument mechanism to collect situationally-appropriate metadata at call sites, could provide a surprising amount of expressivity, allow for better type checking to be retrofitted to existing C interfaces.
</p><h2>Disclaimer</h2>
To be up front, my language designer duties are focused elsewhere, and I&#39;m not going to formally propose this to the C working group any time soon. As such, I&#39;m only going to describe the broad strokes of a design direction here without working out all the details. I&#39;m strictly in &#34;ideas guy&#34; mode here. If you want to stop reading, that&#39;s fine. But if it inspires you to actually implement and/or propose something like this, then great!
<p>
You might also ask, why spend so much time thinking about big new features for C? Isn&#39;t C illegal now anyway? Well, I also think it&#39;d be generally good to see more systems languages that don&#39;t fall into the well-worn monomorphization rut. Maybe these thoughts will inspire an ambitious systems language designer to try something different.
</p><h2>Generic functions</h2>
In order for a single compiled version of a generic function to work with any input type, without needing any predefined runtime metadata about that type, then the function can&#39;t do anything that depends on the concrete layout of a specific type. C already has <i>incomplete types</i>, which are similar; you can forward-declare a struct or union, and the forward-declared type can be used as the pointee type of pointers, but not directly as the type of a variable or function parameter. As a starting point, we can say that generic type parameters also behave like incomplete types:
<pre>// T can appear as the pointee of a pointer, be cv-qualified, …
void good_generic«T»(const T *a, T *b);

// …but can&#39;t appear as a parameter type by itself
void bad_generic«T»(T a); // error; incomplete generic type T
</pre>
It may not seem like you&#39;d be able to do much in a generic function in this world, since you can&#39;t directly do anything with the value of an incomplete type. However, by passing function pointers with matching pointer argument types down along with a pointer, you can make useful generic functions:
<pre>// Traverse a list, given operations to visit each node in the list
// and to advance to the next node
void each_node«Node»(Node *head,
                     Node *(*next)(Node *),
                     void (*body)(Node *)) {
  for (Node *node = head; node; node = next(node)) {
    body(node);
  }
}

struct int_node {
  struct int_node *next;
  int value;
};

struct int_node *next_int_node(struct int_node *node) {
  return node-&gt;next;
}

void print_int_node(struct int_node *node) {
  printf(&#34;%d\n&#34;, node-&gt;value);
}

int main() {
  struct int_node list[] = {
    { .next = &amp;list[1], .value = 1 },
    { .next = &amp;list[2], .value = 2 },
    { .next = &amp;list[3], .value = 3 },
    { .next = &amp;list[4], .value = 5 },
    { .next = NULL,     .value = 8 },
  };

  each_node«struct int_node»(&amp;list[0], next_int_node, print_int_node);
}
</pre>
This is akin to passing a vtable for a generic interface (or a &#34;witness table&#34; as Swift calls them), but entirely under the program&#39;s control to indicate what&#39;s in that vtable.

<h2>Default arguments for gathering type metadata</h2>
To do much else with a generic value or data structure, you need more metadata about the type. To operate on an array or other data structure of some unknown element type, you generally need to know at least the size and possibly alignment of the elements. Needing to explicitly pass large bundles of metadata at every call site will get tedious, and it&#39;d also undermine the safety benefits of generics, since callers could easily pass the &#34;wrong&#34; metadata. If a generic function declaration could specify default arguments, that could provide a mechanism for automatically collecting relevant metadata from call sites:
<pre>// Reduce the values in an array
void reduce«T»(T *out, const T *array, size_t count,
               void (*sum)(T *out, const T *element),
               size_t element_size = sizeof(T)) {
  unsigned i;
  const T *element;
  for (i = 0, element = array;
       i &lt; count;
       ++i, element = (const T*)((const char *)T + element_size)) {
    sum(out, element);
  }
}

void sum_int(int *out, const int *value) {
  out += value;
}

int main() {
  int values[] = {0, 1, 1, 2, 3, 5, 8, 13};

  int sum = 0;

  // call site implicitly passes element_size = sizeof(int)
  reduce«int»(&amp;sum, values, sizeof(values)/sizeof(int), sum_int);

  printf(&#34;%d\n&#34;, sum);
}
</pre>
(Having to manually advance the <tt>element</tt> pointer in the <tt>reduce</tt> loop by casting to <tt>char*</tt> and back is kinda gross, so maybe there should be a way to associate a size expression with a generic type, just so pointer arithmetic works:)
<pre>// Declaring a generic parameter as <tt>T[size_expr]</tt> expresses that
// sizeof(T) == size_expr
void reduce«T[element_size]»(T *out, const T *array, size_t count,
                             void (*sum)(T *out, const T *element),
                             size_t element_size = sizeof(T)) {
  unsigned i;
  const T *element;
  for (i = 0, element = array;
       i &lt; count;
       // We can use normal pointer arithmetic on a T* if T has a
       // size expression
       ++i, ++element) {
    sum(out, element);
  }  
}
</pre>
<h2>Retrofitting generics onto existing functions</h2>
With these two features, we already have enough to retrofit some existing common C functions to take advantage of generics. N3212 uses sorting as a motivating example, and demonstrates a new <tt>sort</tt> interface as an alternative to the traditional <tt>qsort</tt> standard library function. But let&#39;s see if we can upgrade the existing <tt>qsort</tt> in place without breaking compatibility with existing C. <tt>qsort</tt>&#39;s traditional prototype looks something like:
<pre>void qsort(void *base, size_t nel, size_t width,
           int (*compar)(const void *, const void *));
</pre>
where <tt>base</tt> is a pointer to the first element in an array, <tt>nel</tt> is the number of elements in the array, <tt>width</tt> is the size of an element, and <tt>compar</tt> is a three-way comparison function that returns whether the first pointed-to element is considered less than, equal, or greater than the second. We could change this to:
<pre>void qsort«T[width]»(T *base, size_t nel, size_t width = sizeof(T),
                     int (*compar)(const T *, const T *));
</pre>
Since the generic type declaration itself has no runtime effect, it doesn&#39;t need to have any effect on the calling convention of <tt>qsort</tt>. And we&#39;re still passing pointers in all the same places we were passing pointers before. However, one concession to tradition is that the <tt>width</tt> parameter ought to default to <tt>sizeof(T)</tt>, but it&#39;s not the final argument to <tt>qsort</tt>, so if we follow C++&#39;s default argument rules, this wouldn&#39;t be allowed. But we could loosen that restriction, and allow any argument to be defaulted at a generic call site:
<pre>int compare_ints(const int *a, const int *b) {
  return a - b;
}

int main() {
  int array[] = {0, 1, 1, 13, 2, 21, 3, 34, 5, 8};

  qsort«int»(array, sizeof(array)/sizeof(int), /*default*/,
             compare_ints);
}
</pre>
To allow existing C code to continue to call <tt>qsort</tt> after its retroactive genericization, we could say that calling a generic function without generic arguments devolves those arguments back to <tt>void</tt>. Default arguments that depend on the generic parameters aren&#39;t available at a nongeneric call site, and the caller has to be supply an argument manually. Backward compatibility aside, this would also be useful as a way to get back into generic code using runtime metadata that&#39;s been stored in a way that can&#39;t be statically reasoned about. (Of course, this is also an easy way to escape type safety, though C is full of those already… maybe there should be a more opt-in way to do so?)
<h2>Generic structs</h2>
User-defined types could also be parameterized, with the same constraint as function parameters that the type parameters act like incomplete types and can&#39;t influence the layout of the type. A generic struct can package up methods and information about a type into a single value. For instance, to support a generic hash table implementation, we might need to know the size and alignment of keys, as well as how to hash a key and compare it for equality with another key. This is another place where defaults are helpful to capture information about a type that the compiler can automatically fill in: 
<pre>struct hashable«Key» {
  size_t size = sizeof(Key), alignment = alignof(Key);

  uint64_t hash(const Key *value);
  bool equal(const Key *a, const Key *b);
};

const struct hashable«int» int_hashable = {
  .hash = int_hash,
  .equal = int_equal,
};
</pre>
Incomplete types can also usefully carry generic parameters, to provide some type safety at an interface boundary:
<pre>struct hash_table«Key, Value»;
</pre>
<h2>Generic unions and enums</h2>
Enums and unions are interesting because they represent alternatives. Borrowing an idea from GADTs in functional languages, we can say that an enum or union can not only be generic, but also restrict some or all of its members to be available only for specific generic parameters. Among other things, this could allow for more type-safe tagged unions:
<pre>enum json_tag«T» {
  null«struct null»,
  boolean«bool»,
  number«double»,
  string«const char *»,
  array«struct json_array»,
  object«struct json_object»,
};

struct json«T» {
  enum json_tag«T» tag;

  union {
    struct null null«struct null»;
    bool boolean«bool»;
    double number«double»;
    const char *string«const char *»;
    struct json_array array«struct json_array»;
    struct json_object object«struct json_object»;
  };
};

struct json«double» zero = { .tag = number, .number = 0.0 };
struct json«const char *» greeting = {
  .tag = string,
  .string = &#34;hello world&#34;
};

struct json«double» bad_number = {
  // error, enum constant &#39;null&#39; has type &#39;json_tag«struct null»&#39;, not
  // &#39;json_tag«double»&#39;
  .tag = null,
  // error, union field &#39;string&#39; has type &#39;(anonymous union)«const char *»&#39;
  .string = &#34;0.0&#34;
};
</pre>
<h2>Parameterized globals?</h2>
The default argument mechanism works well for populating metadata parameters from builtin operations like <tt>sizeof</tt> and <tt>alignof</tt>, but C as it exists today doesn&#39;t provide a way to make open, user-defined associations between types and values. (<tt>_Generic</tt> does exist, but any one `_Generic expression can only cover a closed set of type alternatives.) The hash table example above demonstrates this:
<pre>struct hash_table«Key, Value» *hash_table_alloc«Key, Value»(
  size_t initial_buckets,
  const struct hashable«Key» *key_type,
  size_t value_size = sizeof(Value),
  size_t value_alignment = alignof(Value));
</pre>
The <tt>Value</tt>&#39;s size and alignment can be prepopulated using <tt>sizeof</tt> and <tt>alignof</tt>, but there isn&#39;t a good way to default the <tt>key_type</tt> parameter to a canonical <tt>hashable</tt> struct for a given type (aside from maybe using <tt>_Generic</tt> for a closed set of types). C++-style template specialization is probably not a great idea, since it makes type checking dependent on template instantiation, but one possible design might be to allow a global variable name to be declared as being parametric:
<pre>// Declare a compound name
_Generic const struct hashable«T» hashable_impl«T»;
</pre>
This wouldn&#39;t define any actual global variable itself, but would allow for definitions to be provided for specific types:
<pre>// Provide definitions for some common types:
const struct hashable«int» hashable_impl«int» = { ... };
const struct hashable«bool» hashable_impl«bool» = { ... };
const struct hashable«void *» hashable_impl«void *» = { ... };
</pre>
Other than the common name, each individual global variable definition would behave like an independent variable definition. Trying to access a parametric name for which no definition is visible would be an error:
<pre>auto *hashable_char = &amp;hashable_impl«char»; // error, no such definition

const struct hashable«char» hashable_impl«char» = { ... };

auto *hashable_char = &amp;hashable_impl«char»; // OK
</pre>
but this would give us the open association we need to provide a nice default for our hash table API:
<pre>struct hash_table«Key, Value» *hash_table_alloc«Key, Value»(
  size_t initial_buckets,
  const struct hashable«Key» *key_type = &amp;hashable_impl«Key»,
  size_t value_size = sizeof(Value),
  size_t value_alignment = alignof(Value));
</pre>
However, we&#39;re still type-erasing everything, so there&#39;s no dynamic lookup structure to recover this association at runtime. That would mean that you would not be able to refer to a parametric global generically, which might be weird:
<pre>const struct hashable«T» *get_hashable_impl«T»(void) {
  // error, can&#39;t look up hashable_impl for a generic type T
  return &amp;hashable_impl«T»;
}
</pre>
<h2>Conclusion</h2>
This might be a half-baked idea, but hopefully I&#39;ve demonstrated that there&#39;s some potential here for a generics design that isn&#39;t in conflict with some of the nice implementation properties of plain C, preserving the ability to do separate compilation without requiring any additional runtime support.

<p>
<a href="https://f.duriansoftware.com/@joe/113223736207786015">View and comment on this post</a> in the fediverse, or <a href="mailto:joe@duriansoftware.com">email me about it</a>.
</p>




</div>
  </body>
</html>
