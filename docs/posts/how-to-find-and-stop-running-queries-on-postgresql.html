<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adamj.eu/tech/2022/06/20/how-to-find-and-stop-running-queries-on-postgresql/">Original</a>
    <h1>How to Find and Stop Running Queries on PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><article><time datetime="2022-06-20">2022-06-20</time><img alt="Owl be stopping those pesky queries!" title="Owl be stopping those pesky queries!" src="https://adamj.eu/tech/assets/2022-06-20-owl.jpeg"/><p>Your PostgreSQL server is seizing up, with some naughty queries consuming too many resources or blocking others. Don’t panic! You can stop those problem queries and stabilize your system.</p><p>In this post we’ll look at stopping queries via SQL, techniques for finding problematic queries, and the occasionally useful ability to cancel via operating system tools.</p><div id="stopping-queries-via-sql-in-two-steps"><h2>Stopping Queries via SQL in Two Steps<a title="Permalink to this headline" href="#stopping-queries-via-sql-in-two-steps"></a></h2><p>Here’s the basic process to find and stop a query. Note you’ll need to connect as a user with adequate permissions to do so, such as an admin account.</p><div id="find-the-pid"><h3>1. Find the pid<a title="Permalink to this headline" href="#find-the-pid"></a></h3><p>PostgreSQL creates one process per connection, and it identifies each process with its operating system process ID, or <em>pid</em>. In order to cancel a query, you need to know the pid for the connection it’s running on.</p><p>One way to find this out is with the <a href="https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW"><code>pg_stat_activity</code> view</a>, which provides information about the live queries. For example, try this query:</p><div><pre><span></span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span></span>
<span>ORDER</span><span> </span><span>BY</span><span> </span><span>backend_start</span><span>;</span><span></span>
</pre></div><p>The <a href="https://www.postgresql.org/docs/current/functions-string.html#substr"><code>substr</code></a> call limits the displayed SQL to 100 characters, to avoid long queries taking up a lot of screen space. The <code>backend_type</code> filter avoids showing background server processes, such as the <a href="https://www.postgresql.org/docs/current/routine-vacuuming.html#AUTOVACUUM">autovacuum</a> launcher. Sorting by <code>backend_start</code> shows the longest running connections first, which often shows problematic long-running transactions.</p><p>Here’s an example of running this on my development server:</p><div><pre><span></span><span>stagingi_inventev</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span></span>
<span>ORDER</span><span> </span><span>BY</span><span> </span><span>backend_start</span><span>;</span><span></span>
<span> </span><span>pid</span><span> </span><span>|</span><span> </span><span>state</span><span>  </span><span>|</span><span>         </span><span>backend_start</span><span>         </span><span>|</span><span>                                                  </span><span>q</span><span></span>
<span>-----+--------+-------------------------------+-----------------------------------------------------------------------------------------------------</span>
<span>  </span><span>73</span><span> </span><span>|</span><span> </span><span>active</span><span> </span><span>|</span><span> </span><span>2022</span><span>-</span><span>06</span><span>-</span><span>17</span><span> </span><span>18</span><span>:</span><span>57</span><span>:</span><span>15</span><span>.</span><span>850803</span><span>+</span><span>00</span><span> </span><span>|</span><span> </span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span> </span><span>FROM</span><span> </span><span>pg_stat_activity</span><span> </span><span>WHERE</span><span> </span><span>backend_type</span><span></span>
<span>  </span><span>77</span><span> </span><span>|</span><span> </span><span>idle</span><span>   </span><span>|</span><span> </span><span>2022</span><span>-</span><span>06</span><span>-</span><span>17</span><span> </span><span>18</span><span>:</span><span>57</span><span>:</span><span>33</span><span>.</span><span>567574</span><span>+</span><span>00</span><span> </span><span>|</span><span> </span><span>SELECT</span><span> </span><span>/* long-running query */</span><span> </span><span>pg_sleep</span><span>(</span><span>10000</span><span>);</span><span></span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span><span></span>
</pre></div><p>Another way to find pid’s is through the operating system, using tools like <a href="https://htop.dev/">htop</a>. This is useful if you have access to your PostgreSQL server and want to find queries that are consuming the most resources.</p><p>Okay, you have a pid, now let’s stop that query!</p></div><div id="terminate-or-cancel-the-process"><h3>2. Terminate, or Cancel, the Process<a title="Permalink to this headline" href="#terminate-or-cancel-the-process"></a></h3><p>PostgreSQL has two query-stopping functions, with differences discussed below.</p><p>The “harsh” one is <a href="https://www.postgresql.org/docs/current/functions-admin.html#pg_terminate_backend"><code>pg_terminate_backend</code></a>, which you can use like:</p><div><pre><span></span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>pid</span><span>);</span><span></span>
</pre></div><p>I default to using this one, reasoning explained below.</p><p>The “kinder” function is <a href="https://www.postgresql.org/docs/current/functions-admin.html#pg_cancel_backend"><code>pg_cancel_backend</code></a>, which you can use like:</p><div><pre><span></span><span>SELECT</span><span> </span><span>pg_cancel_backend</span><span>(</span><span>pid</span><span>);</span><span></span>
</pre></div><p>When using either, replace <code>pid</code> with the pid you found in step 1. For example, to terminate the long-running query from above:</p><div><pre><span></span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>77</span><span>);</span><span></span>
</pre></div><p>And boom, it’s gone.</p><p>There are two differences that make <code>pg_terminate_backend</code> “harsher”.</p><p>First, <code>pg_terminate_backend</code> completely stops the process, causing the connection to close. This rolls back any open transaction on the connection, freeing all locks it holds.</p><p>In contrast, <code>pg_cancel_backend</code> interrupts only the running query, leaving the connection open. The current transaction or savepoint is aborted. Thus, if the connection is using savepoints, it can still keep the surrounding transaction open, with pending data changes and locks.</p><p>Second, <code>pg_terminate_backend</code> applies immediately*, whilst <code>pg_cancel_backend</code> can be deferred at certain points in the backend process lifecycle. So sometimes, you might run <code>pg_cancel_backend</code> and see nothing happen for a while. Specifically, this can occur when the process is reading input from the client, such as an incoming query. The backend process defers handling the cancellation until all the input has been read, since otherwise the connection could not be left open and functional.</p><p>(*<em>Ackshuallly</em>, <code>pg_terminate_backend</code> <em>can</em> also fail to apply immediately, but it’s much less likely. Small sections of the code also defer handling it. In theory, these sections don’t spend much time executing, but never say never. If you’re interested in diving into the source, start with <code>ProcessInterrupts</code> in <a href="https://github.com/postgres/postgres/blob/master/src/backend/tcop/postgres.c"><code>src/backend/tcop/postgres.c</code></a>.)</p><p>I default to using <code>pg_terminate_backend</code>. Normally, when I need to stop a query, I want to stop the whole application process that started it, roll back all data changes, and release all locks. When using <code>pg_cancel_backend</code>, there’s a risk that the application’s error-handling code will rollback the transaction/savepoint, and carry on to run similar queries. And it may continue to hold problematic locks.</p></div></div><div id="discovering-vexacious-running-queries"><h2>Discovering Vexacious Running Queries<a title="Permalink to this headline" href="#discovering-vexacious-running-queries"></a></h2><p>If you want to stop more than one query, it can be onerous to run <code>pg_terminate_backend()</code> on them one-by-one. You can use SQL to find the bad queries and generate the terminate statements, in order to get rid of them all with ease. Here are a couple of examples.</p><div id="queries-blocking-a-particular-process"><h3>Queries Blocking a Particular Process<a title="Permalink to this headline" href="#queries-blocking-a-particular-process"></a></h3><p>If you’re executing an <code>ALTER TABLE</code> and find it blocked, waiting for a table lock, you may want to terminate the connections holding locks on that table. This will allow the <code>ALTER TABLE</code> to proceed.</p><p>For example, I recently worked on an application with a few long-running transactions that blocked a database migration. These long-running queries were safe to terminate as the responsible application process would re-run later and fill in any gaps.</p><p>You can find the blocked pid of <code>ALTER TABLE</code> with a query against <code>pg_stat_activity</code> like so:</p><div><pre><span></span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span> </span><span>AND</span><span> </span><span>query</span><span> </span><span>LIKE</span><span> </span><span>&#39;ALTER TABLE%&#39;</span><span></span>
<span>ORDER</span><span> </span><span>BY</span><span> </span><span>backend_start</span><span>;</span><span></span>
</pre></div><p>With the blocked pid, you can use this query with <a href="https://www.postgresql.org/docs/current/functions-info.html#pg_blocking_pids"><code>pg_blocking_pids</code></a> to generate SQL to terminate the blocking processes:</p><div><pre><span></span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>pid</span><span> </span><span>=</span><span> </span><span>ANY</span><span> </span><span>(</span><span>pg_blocking_pids</span><span>(</span><span>blockedpid</span><span>));</span><span></span>
</pre></div><p>To run this query, replace <code>blockedpid</code> with the pid of the blocked process. Then copy-paste the output lines and run them.</p><p>Here’s an example session using these queries to unblock an <code>ALTER TABLE</code>:</p><div><pre><span></span><span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span></span>
<span>  </span><span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>  </span><span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span> </span><span>AND</span><span> </span><span>query</span><span> </span><span>LIKE</span><span> </span><span>&#39;ALTER TABLE%&#39;</span><span></span>
<span>  </span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>backend_start</span><span>;</span><span></span>
<span> </span><span>pid</span><span> </span><span>|</span><span> </span><span>state</span><span>  </span><span>|</span><span>         </span><span>backend_start</span><span>         </span><span>|</span><span>                       </span><span>q</span><span></span>
<span>-----+--------+-------------------------------+------------------------------------------------</span>
<span> </span><span>613</span><span> </span><span>|</span><span> </span><span>active</span><span> </span><span>|</span><span> </span><span>2022</span><span>-</span><span>06</span><span>-</span><span>17</span><span> </span><span>20</span><span>:</span><span>25</span><span>:</span><span>06</span><span>.</span><span>604326</span><span>+</span><span>00</span><span> </span><span>|</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>auth_user</span><span> </span><span>ADD</span><span> </span><span>COLUMN</span><span> </span><span>age</span><span> </span><span>int</span><span> </span><span>null</span><span>;</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>  </span><span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>  </span><span>WHERE</span><span> </span><span>pid</span><span> </span><span>=</span><span> </span><span>ANY</span><span> </span><span>(</span><span>pg_blocking_pids</span><span>(</span><span>613</span><span>));</span><span></span>
<span>             </span><span>?</span><span>column</span><span>?</span><span></span>
<span>----------------------------------</span>
<span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>77</span><span>);</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>77</span><span>);</span><span></span>
<span> </span><span>pg_terminate_backend</span><span></span>
<span>----------------------</span>
<span> </span><span>t</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pid</span><span>,</span><span> </span><span>state</span><span>,</span><span> </span><span>backend_start</span><span>,</span><span> </span><span>substr</span><span>(</span><span>query</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>100</span><span>)</span><span> </span><span>q</span><span></span>
<span>  </span><span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>  </span><span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span> </span><span>AND</span><span> </span><span>query</span><span> </span><span>LIKE</span><span> </span><span>&#39;ALTER TABLE%&#39;</span><span></span>
<span>  </span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>backend_start</span><span>;</span><span></span>
<span> </span><span>pid</span><span> </span><span>|</span><span> </span><span>state</span><span> </span><span>|</span><span>         </span><span>backend_start</span><span>         </span><span>|</span><span>                       </span><span>q</span><span></span>
<span>-----+-------+-------------------------------+------------------------------------------------</span>
<span> </span><span>613</span><span> </span><span>|</span><span> </span><span>idle</span><span>  </span><span>|</span><span> </span><span>2022</span><span>-</span><span>06</span><span>-</span><span>17</span><span> </span><span>20</span><span>:</span><span>25</span><span>:</span><span>06</span><span>.</span><span>604326</span><span>+</span><span>00</span><span> </span><span>|</span><span> </span><span>ALTER</span><span> </span><span>TABLE</span><span> </span><span>auth_user</span><span> </span><span>ADD</span><span> </span><span>COLUMN</span><span> </span><span>age</span><span> </span><span>int</span><span> </span><span>null</span><span>;</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>
</pre></div><p>Cowabunga!</p></div><div id="queries-against-a-particular-table"><h3>Queries Against a Particular Table<a title="Permalink to this headline" href="#queries-against-a-particular-table"></a></h3><p>Sometimes you may just want to terminate all queries running against a given table. This can be appropriate to stop overload from a particular misbehaving application process.</p><p>This query will generate SQL to terminate all running queries that look like they’re using a particlar table called <code>auth_user</code>:</p><div><pre><span></span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>query</span><span> </span><span>LIKE</span><span> </span><span>&#39;%auth_user%&#39;</span><span></span>
<span>  </span><span>AND</span><span> </span><span>pid</span><span> </span><span>!=</span><span> </span><span>pg_backend_pid</span><span>();</span><span></span>
</pre></div><p>To use this query, change the matched table name in <code>LIKE &#39;%auth_user%&#39;</code> before running it. Then copy-paste the output lines and run them.</p><p>Matching <code>query</code> with <code>LIKE</code> is a bit blunt, as it has the chance for false positives, but it is simple. The comparison with <a href="https://www.postgresql.org/docs/current/functions-info.html#pg_backend_pid"><code>pg_backend_pid</code></a> is required to avoid matching the current connection.</p><p>Here’s an example of using this query to terminate all queries to a table called <code>library_book</code>:</p><div><pre><span></span><span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>  </span><span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>  </span><span>WHERE</span><span> </span><span>query</span><span> </span><span>LIKE</span><span> </span><span>&#39;%library_book%&#39;</span><span></span>
<span>    </span><span>AND</span><span> </span><span>pid</span><span> </span><span>!=</span><span> </span><span>pg_backend_pid</span><span>();</span><span></span>
<span>           </span><span>?</span><span>column</span><span>?</span><span></span>
<span>-------------------------------</span>
<span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>123</span><span>);</span><span></span>
<span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>124</span><span>);</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>123</span><span>);</span><span></span>
<span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>124</span><span>);</span><span></span>
<span> </span><span>pg_terminate_backend</span><span></span>
<span>-------------------</span>
<span> </span><span>t</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span> </span><span>pg_terminate_backend</span><span></span>
<span>-------------------</span>
<span> </span><span>t</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>
</pre></div><p>🔥🔥🔥</p></div><div id="connections-open-longer-than-n-seconds"><h3>Connections Open Longer Than N Seconds<a title="Permalink to this headline" href="#connections-open-longer-than-n-seconds"></a></h3><p>A final example: how to filter out connections to those open longer than N seconds. This is quite the blunt hammer, but you may try it in emergencies.</p><div><pre><span></span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span></span>
<span>      </span><span>AND</span><span> </span><span>pid</span><span> </span><span>!=</span><span> </span><span>pg_backend_pid</span><span>()</span><span></span>
<span>      </span><span>AND</span><span> </span><span>backend_start</span><span> </span><span>&lt;</span><span> </span><span>NOW</span><span>()</span><span> </span><span>-</span><span> </span><span>&#39;10 seconds&#39;</span><span>::</span><span>interval</span><span>;</span><span></span>
</pre></div><p>Adjust <code>&#39;10 seconds&#39;</code> as appropriate.</p><p>For example:</p><div><pre><span></span><span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>&#39;SELECT pg_terminate_backend(&#39;</span><span> </span><span>||</span><span> </span><span>pid</span><span> </span><span>||</span><span> </span><span>&#39;);&#39;</span><span></span>
<span>FROM</span><span> </span><span>pg_stat_activity</span><span></span>
<span>WHERE</span><span> </span><span>backend_type</span><span> </span><span>=</span><span> </span><span>&#39;client backend&#39;</span><span></span>
<span>      </span><span>AND</span><span> </span><span>backend_start</span><span> </span><span>&lt;</span><span> </span><span>now</span><span>()</span><span> </span><span>-</span><span> </span><span>&#39;10 seconds&#39;</span><span>::</span><span>interval</span><span></span>
<span>      </span><span>AND</span><span> </span><span>pid</span><span> </span><span>!=</span><span> </span><span>pg_backend_pid</span><span>();</span><span></span>
<span>              </span><span>?</span><span>column</span><span>?</span><span></span>
<span>------------------------------------</span>
<span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>2675</span><span>);</span><span></span>
<span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>2676</span><span>);</span><span></span>
<span>(</span><span>2</span><span> </span><span>rows</span><span>)</span><span></span>

<span>mydb</span><span>=#</span><span> </span><span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>2675</span><span>);</span><span></span>
<span>SELECT</span><span> </span><span>pg_terminate_backend</span><span>(</span><span>2676</span><span>);</span><span></span>
<span> </span><span>pg_terminate_backend</span><span></span>
<span>----------------------</span>
<span> </span><span>t</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>

<span>WARNING</span><span>:</span><span>  </span><span>PID</span><span> </span><span>2676</span><span> </span><span>is</span><span> </span><span>not</span><span> </span><span>a</span><span> </span><span>PostgreSQL</span><span> </span><span>server</span><span> </span><span>process</span><span></span>
<span> </span><span>pg_terminate_backend</span><span></span>
<span>----------------------</span>
<span> </span><span>f</span><span></span>
<span>(</span><span>1</span><span> </span><span>row</span><span>)</span><span></span>
</pre></div><p>😅 Note in this case it seems pid 2676 completed between generating the SQL and running it.</p></div></div><div id="stopping-queries-through-the-operating-system"><h2>Stopping Queries Through the Operating System<a title="Permalink to this headline" href="#stopping-queries-through-the-operating-system"></a></h2><p>If you have access to your PostgreSQL server, you can also stop queries by signalling the relevant operating system processes. This requires you to have shell access to your PostgreSQL server, which isn’t so common these days with the rise of managed database platforms.</p><p>You can use a tool like <a href="https://htop.dev/">htop</a> to check the running backend processes. You may be able to find the problematic ones based on high CPU or memory usage.</p><p>Backend processes appear as children of the main PostgreSQL server process. Be careful you pick the right pid’s, as if kill the main process, the whole PostgreSQL server <a href="https://www.postgresql.org/docs/current/server-shutdown.html">shuts down</a>.</p><div id="on-linux-macos-unixes"><h3>On Linux/macOS/Unixes<a title="Permalink to this headline" href="#on-linux-macos-unixes"></a></h3><p>On Unix OS’s, you can <em>terminate</em> a running query by sending its process <code>SIGTERM</code> (the <em>terminate signal</em>) with <a href="https://linux.die.net/man/1/kill"><code>kill</code></a>:</p><p>Replace <code>pid</code> with the backend process pid.</p><p>And you can <em>cancel</em> a process by sending <code>SIGINT</code> (the <em>interrupt signal</em>):</p><p>🫡</p></div><div id="on-windows"><h3>On Windows<a title="Permalink to this headline" href="#on-windows"></a></h3><p>Windows does not have a <code>kill</code> command, so PostgreSQL provides the <a href="https://www.postgresql.org/docs/current/app-pg-ctl.html"><code>pg_ctl</code> tool</a> to send signals to processes. You can use it to terminate a query by sending the terminate signal like so:</p><p>Replace <code>pid</code> with the target backend pid.</p><p>You can use it to cancel a query by sending the interrupt signal like so:</p><p>…bye bye query!</p></div><div id="killing-query-processes"><h3>Killing Query Processes<a title="Permalink to this headline" href="#killing-query-processes"></a></h3><p>Using the OS, we can also stop a process <em>immediately</em>, guaranteed, by “killing” it. This is where the “kill” utility’s name comes from. (And its dated, violent terminology.) Doing so can be useful in rare situations where a process carries on consuming resources after termination, potentially due to a bug in PostgreSQL.</p><p>This action is, however, very drastic. Immediate termination stops the process instantly, without any chance to do cleanup. PostgreSQL’s design should prevent data loss (of committed rows), but you may miss other incidental data like log messages.</p><p>To kill a process, send it the <code>KILL</code> signal.</p><p>On Unixes:</p><p>On Windows:</p><p>💥 Kaboom!</p></div></div><div id="fin"><h2>Fin<a title="Permalink to this headline" href="#fin"></a></h2><p>May you rarely need to use this knowledge,</p><p>—Adam</p></div><hr/><p>Learn how to make your tests run quickly in my book <a href="https://adamchainz.gumroad.com/l/suydt">Speed Up Your Django Tests</a>.</p><hr/><p><small>One summary email a week, no spam, I pinky promise.</small></p><p><strong>Tags:</strong> <a href="https://adamj.eu/tech/tag/postgresql/" rel="tag">postgresql</a></p></article></div>
  </body>
</html>
