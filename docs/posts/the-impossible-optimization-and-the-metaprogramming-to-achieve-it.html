<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdagon.dev/blog/impossible-optimization">Original</a>
    <h1>The Impossible Optimization, and the Metaprogramming to Achieve It</h1>
    
    <div id="readability-page-1" class="page"><div class="page">
    <div>
  

        <div>
          <div>
  

            
    
<section>
<p>
Every once in a while, you come across an optimization that is so mind-blowingly <i>weird</i>, that you feel like you&#39;re peering into some sort of alternate dimension.
</p>

</section>
<section>
<p>
Until recently, I believed that metaprogramming is basically just normal C++ templates with a few neat features like <span>constexpr</span> thrown on top. I thought it was just &#34;writing code that writes code&#34;, like we&#39;ve been doing with PHP since the dawn of time. Simple stuff, right?
</p>

</section>
<section>
<p>
If you believe that like I did, buckle up! I&#39;m going to show you how metaprogramming can be used to unlock what I call <b>the impossible optimization</b>.
</p>

</section>
<section>
<p>
And I don&#39;t just mean little 5% optimizations. I&#39;m talking about crazy optimizations that make your code <i>ten times</i> faster.
</p>

</section>
<section>
<p>
Big shout-out to Alexandros Naskos&#39;s <a href="https://github.com/alexnask/ctregex.zig/tree/master">ctregex</a> Zig library, which is a great example of what metaprogramming can do, and inspired the examples in this post.
</p>

</section>

      </div>
  
<div>

      <nav>
      <p>The Impossible Optimization, and the Metaprogramming To Achieve It</p>
    
<ul>

</ul>

      </nav>
      
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="the-impossible-optimization">
 The Impossible Optimization</h3>
<p>
Imagine that you had a program using a simple regex function, and you wanted to use it to verify emails: <a href="#note0" data-noteid="0">0</a>
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>main</span><span>(</span><span>)</span><span>:</span>
<span>    </span><span>email_regex</span><span> </span><span>=</span>
<span>        </span><span>Regex</span><span>(</span><span>&#34;</span><span>\</span><span>w+(</span><span>\</span><span>+</span><span>\</span><span>w*)?@(</span><span>\</span><span>d+</span><span>\</span><span>.</span><span>\</span><span>d+</span><span>\</span><span>.</span><span>\</span><span>d+</span><span>\</span><span>.</span><span>\</span><span>d+|</span><span>\</span><span>w+</span><span>\</span><span>.</span><span>\</span><span>w+)</span><span>&#34;</span><span>)</span>
<span></span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>user@example.com</span><span>&#34;</span><span>)</span><span>)</span><span>      </span><span>#</span><span> Prints True</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>uexample.com</span><span>&#34;</span><span>)</span><span>)</span><span>          </span><span>#</span><span> Prints False</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>user@ecom</span><span>&#34;</span><span>)</span><span>)</span><span>             </span><span>#</span><span> Prints False</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>user+tag@example.com</span><span>&#34;</span><span>)</span><span>)</span><span>  </span><span>#</span><span> Prints True</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>user@100</span><span>&#34;</span><span>)</span><span>)</span><span>              </span><span>#</span><span> Prints False</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>howdy123@1.2.3.4</span><span>&#34;</span><span>)</span><span>)</span><span>      </span><span>#</span><span> Prints True</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>howdy1231.2.3.4</span><span>&#34;</span><span>)</span><span>)</span><span>       </span><span>#</span><span> Prints False</span>
<span>    </span><span>print</span><span>(</span><span>matches</span><span>(</span><span>email_regex</span><span>,</span><span> </span><span>&#34;</span><span>howdy123@1/2/3/4</span><span>&#34;</span><span>)</span><span>)</span><span>      </span><span>#</span><span> Prints False</span></code></pre>


</section>
<section>
<p>
We all know that regex is pretty slow, because it basically has to run a whole interpreter. Or, if we &#34;precompile&#34; a Regex, it would be interpreting an AST (or a DFA), which is still pretty slow. <a href="#note1" data-noteid="1">1</a>
</p>

</section>
<section>
<p>
When you really need speed, you skip regex entirely and make a hand-written <span>matches</span> function like this:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>matches</span><span>(</span><span>text</span><span>:</span><span> </span><span>String</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Bool</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>text_len</span><span> </span><span>=</span><span> </span><span>len</span><span>(</span><span>text</span><span>)</span>
<span>    </span><span>var</span><span> </span><span>word_matches</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>word_total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>        </span><span>if</span><span> </span><span>pos</span><span> </span><span>&gt;=</span><span> </span><span>text_len</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>var</span><span> </span><span>ch</span><span> </span><span>=</span><span> </span><span>text</span><span>[</span><span>pos</span><span>]</span>
<span>        </span><span>alias</span><span> </span><span>char_class</span><span> </span><span>=</span><span> </span><span>&#34;</span><span>word</span><span>&#34;</span>
<span>        </span><span>var</span><span> </span><span>char_matches</span><span> </span><span>=</span><span> </span><span>False</span>
<span>        </span><span>char_matches</span><span> </span><span>=</span><span> </span><span>(</span>
<span>            </span><span>(</span><span>ord</span><span>(</span><span>&#34;</span><span>a</span><span>&#34;</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>ch</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>&#34;</span><span>z</span><span>&#34;</span><span>)</span><span>)</span>
<span>            </span><span>or</span><span> </span><span>(</span><span>ord</span><span>(</span><span>&#34;</span><span>A</span><span>&#34;</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>ch</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>&#34;</span><span>Z</span><span>&#34;</span><span>)</span><span>)</span>
<span>            </span><span>or</span><span> </span><span>(</span><span>ord</span><span>(</span><span>&#34;</span><span>0</span><span>&#34;</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>ch</span><span>)</span><span> </span><span>&lt;=</span><span> </span><span>ord</span><span>(</span><span>&#34;</span><span>9</span><span>&#34;</span><span>)</span><span>)</span>
<span>            </span><span>or</span><span> </span><span>ch</span><span> </span><span>==</span><span> </span><span>&#34;</span><span>_</span><span>&#34;</span>
<span>        </span><span>)</span>
<span>        </span><span>if</span><span> </span><span>not</span><span> </span><span>char_matches</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>var</span><span> </span><span>chars_consumed</span><span> </span><span>=</span><span> </span><span>1</span>
<span>        </span><span>if</span><span> </span><span>chars_consumed</span><span> </span><span>==</span><span> </span><span>0</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>word_matches</span><span> </span><span>+=</span><span> </span><span>1</span>
<span>        </span><span>word_total_consumed</span><span> </span><span>+=</span><span> </span><span>chars_consumed</span>
<span>        </span><span>pos</span><span> </span><span>+=</span><span> </span><span>chars_consumed</span>
<span>    </span><span>if</span><span> </span><span>word_matches</span><span> </span><span>&lt;</span><span> </span><span>1</span><span>:</span>
<span>        </span><span>return</span><span> </span><span>False</span>
<span>    </span><span>total_consumed</span><span> </span><span>+=</span><span> </span><span>word_total_consumed</span>
<span>    </span><span>...</span><span>  </span><span>#</span><span> much more code, for the rest of the pattern</span></code></pre>


</section>
<section>
<p>
This is about 10.5x faster in my benchmarks. <a href="#note2" data-noteid="2">2</a>
</p>

</section>
<section>
<p>
It makes you wonder, can an optimizer somehow do this for us?
</p>
<p>
Unfortunately, no. There are a lot of challenges in the way, as I&#39;ll explain below.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note0" data-noteid="0">
<p><span>0</span></p><section>
<p>
...which is a TERRIBLE idea and you should never do it (see <a href="https://stackoverflow.com/questions/201323/how-can-i-validate-an-email-address-using-a-regular-expression">this page</a>) but what&#39;s life without a little regex-related sin!
</p>

</section>
</div>
<div id="note1" data-noteid="1">
<p><span>1</span></p><section>
<p>
 Real regex engines typically parse patterns into ASTs first, then compile them to state machines (DFAs/NFAs) that process input with state transitions. This toy implementation uses a recursive AST interpreter instead, which has function call overhead at every node, but it much better illustrates the powers of this technique: <i>all</i> the overhead is eliminated.

</p>

</section>
</div>
<div id="note2" data-noteid="2">
<p><span>2</span></p><section>
<p>
Tested on M2 Macbook Pro, run 200,000,000 times, more details below.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="the-challenge">
 The Challenge</h3>

</section>
<section>
<p>
The problem is that <span>matches</span> is kind of like an interpreter. It takes in a constant tree of nodes, like this:
</p>
<ul>
<li>
SequenceNode for <span>\w+(\+\w*)?@(\d+\.\d+\.\d+\.\d+|\w+\.\w+)</span>
</li>
<ul>
<li>
RepeatNode for <span>\w+</span>
</li>
<ul>
<li>
CharClassNode for <span>\w</span>
</li>
</ul>
<li>
RepeatNode for <span>(\+\w*)?</span>
</li>
<ul>
<li>
SequenceNode for <span>\+\w*</span>
</li>
<ul>
<li>
LiteralNode for <span>\+</span>
</li>
<li>
RepeatNode for <span>\w*</span>
</li>
<ul>
<li>
CharClassNode for <span>\w</span>
</li>
</ul>
</ul>
</ul>
<li>
LiteralNode for <span>@</span>
</li>
<li>
OrNode for <span>(\d+\.\d+\.\d+\.\d+|\w+\.\w+)</span>
</li>
<ul>
<li>
SequenceNode for <span>\d+\.\d+\.\d+\.\d+</span>
</li>
<ul>
<li>
RepeatNode for <span>\d+</span>
</li>
<ul>
<li>
CharClassNode for <span>\d</span>
</li>
</ul>
<li>
LiteralNode for <span>\.</span>
</li>
<li>
RepeatNode for <span>\d+</span>
</li>
<ul>
<li>
CharClassNode for <span>\d</span>
</li>
</ul>
<li>
LiteralNode for <span>\.</span>
</li>
<li>
RepeatNode for <span>\d+</span>
</li>
<ul>
<li>
CharClassNode for <span>\d</span>
</li>
</ul>
<li>
LiteralNode for <span>\.</span>
</li>
<li>
RepeatNode for <span>\d+</span>
</li>
<ul>
<li>
CharClassNode for <span>\d</span>
</li>
</ul>
</ul>
<li>
SequenceNode for <span>\w+\.\w+</span>
</li>
<ul>
<li>
RepeatNode for <span>\w+</span>
</li>
<ul>
<li>
CharClassNode for <span>\w</span>
</li>
</ul>
<li>
LiteralNode for <span>\.</span>
</li>
<li>
RepeatNode for <span>\w+</span>
</li>
<ul>
<li>
CharClassNode for <span>\w</span>
</li>
</ul>
</ul>
</ul>
</ul>
</ul>
<p>
...and it also takes in the user&#39;s string which is only known at run-time.
</p>

</section>
<section>
<p>
It then navigates up and down the tree according to what character is next in the user&#39;s string.
</p>

</section>
<section>
<p>
Actual regex implementations are a <i>lot</i> more sophisticated, and use state machines instead of an AST like this. This is my own simplistic Regex subset implementation made just for this post. <a href="#note3" data-noteid="3">3</a>
</p>

</section>
<section>
<p>
To illustrate, here&#39;s the top-level <span>matches</span> function:
</p>

</section>
<section>
<pre><code><span></span>
<span>@</span><span>no_inline</span>
<span>fn</span><span> </span><span>matches</span><span>(</span><span>regex</span><span>:</span><span> </span><span>Regex</span><span>,</span><span> </span><span>text</span><span>:</span><span> </span><span>String</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Bool</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_match_node</span><span>(</span><span>regex</span><span>.</span><span>nodes</span><span>,</span><span> </span><span>regex</span><span>.</span><span>root_idx</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>0</span><span>)</span>
<span>    </span><span>return</span><span> </span><span>result</span><span>.</span><span>matched</span><span> </span><span>and</span><span> </span><span>result</span><span>.</span><span>chars_consumed</span><span> </span><span>==</span><span> </span><span>len</span><span>(</span><span>text</span><span>)</span></code></pre>


</section>
<section>
<p>
...which really just calls into the (recursive) <span>_match_node</span> function:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>(</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span><span> </span><span>node_idx</span><span>:</span><span> </span><span>Int</span><span>,</span><span> </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>nodes</span><span>[</span><span>node_idx</span><span>]</span>
<span>    </span><span>if</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>LiteralNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>ref</span><span> </span><span>literal_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>LiteralNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_literal</span><span>(</span><span>nodes</span><span>,</span><span> </span><span>literal_node</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>RepeatNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>ref</span><span> </span><span>repeat_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>RepeatNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_repeat</span><span>(</span><span>nodes</span><span>,</span><span> </span><span>repeat_node</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>...</span></code></pre>


</section>
<section>
<p>
...which calls various functions, like the below <span>_match_repeat</span> function. This function checks the repeating parts of the regular expression, like how how email regex&#39;s <span>\w+</span> uses <span>+</span> to repeat the <span>\w</span>.
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_repeat</span><span>(</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span><span>  </span><span>#</span><span> All the regex nodes</span>
<span>    </span><span>node</span><span>:</span><span> </span><span>LiteralNode</span><span>,</span><span>       </span><span>#</span><span> Which node we&#39;re currently on</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span><span>            </span><span>#</span><span> User&#39;s string</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span><span>           </span><span>#</span><span> Where in the user&#39;s string we&#39;re at</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>start_pos</span>
<span>    </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>        </span><span>if</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_match_node</span><span>(</span><span>nodes</span><span>,</span><span> </span><span>node</span><span>.</span><span>repeated</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>pos</span><span>)</span>
<span>        </span><span>if</span><span> </span><span>not</span><span> </span><span>result</span><span>.</span><span>matched</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>if</span><span> </span><span>result</span><span>.</span><span>chars_consumed</span><span> </span><span>==</span><span> </span><span>0</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>matches</span><span> </span><span>+=</span><span> </span><span>1</span>
<span>        </span><span>total_consumed</span><span> </span><span>+=</span><span> </span><span>result</span><span>.</span><span>chars_consumed</span>
<span>        </span><span>pos</span><span> </span><span>+=</span><span> </span><span>result</span><span>.</span><span>chars_consumed</span>
<span>    </span><span>if</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>minimum_times</span><span>:</span>
<span>        </span><span>return</span><span> </span><span>MatchResult</span><span>(</span><span>True</span><span>,</span><span> </span><span>total_consumed</span><span>)</span>
<span>    </span><span>else</span><span>:</span>
<span>        </span><span>return</span><span> </span><span>MatchResult</span><span>(</span><span>False</span><span>,</span><span> </span><span>0</span><span>)</span></code></pre>


</section>
<section>
<p>
One benefit of the recursive approach is that it&#39;s very flexible. It can execute an arbitrary tree of nodes; it can execute an arbitrary regular expression. The hand-written version doesn&#39;t have that flexibility, it&#39;s coded up-front.
</p>

</section>
<section>
<p>
But of course, the <b>flexibility has a cost:</b> recursion requires more function calls than the hand-written version, and <b>function calls have overhead.</b> Every time we call a function, that&#39;s pushing and popping on the stack. The hand-written version is faster because it doesn&#39;t have that problem.
</p>

</section>
<section>
<p>
Another problem is that this general regex code has extra flexibility that the hand-written one doesn&#39;t need. Look at this condition from above:
</p>

</section>
<section>
<pre><code><span>    </span><span>if</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span>:</span>
<span>        </span><span>break</span></code></pre>


</section>
<section>
<p>
This code is only relevant when we want a maximum number of matches, as if we said <span>\w{,7}</span> to mean maximum 7 matches. But our particular email regex has things like <span>\w+</span> with no upper limit, to match any number of <span>\w</span> characters. So it&#39;s unfortunate that this useless code is in here, slowing things down. The hand-written version is faster because it doesn&#39;t have that problem.
</p>

</section>
<section>
<p>
The hand-written version is also theoretically more optimizable because everything is in one function, as if we <b>inlined all these recursive <span>_match_node</span>, <span>_match_repeat</span>, etc calls.</b> Optimizers generally do better when everything is in one function.
</p>

</section>
<section>
<p>
Is there a way to get these benefits for our general <span>Regex</span> code?
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note3" data-noteid="3">
<p><span>3</span></p><section>
<p>
I had to hold myself back from adding even more interesting features to it, like SIMD. This implementation also doesn&#39;t support backtracking, which real regex engines need for more complex patterns.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h3 id="can-we-inline-recursive-calls">
 Can we inline recursive calls?</h3>
<p>
Above, I said that the hand-written function is almost as if we inlined all these recursive <span>_match_node</span> calls.
</p>

</section>
<section>
<p>
So the obvious question: can we inline <span>_match_node</span>?
</p>

</section>
<section>
<p>
Let&#39;s try it, by throwing a <span>@always_inline</span> on it:
</p>

</section>
<section>
<pre><code><span>@</span><span>always_inline</span>
<span>fn</span><span> </span><span>_match_node</span><span>(</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span><span> </span><span>node_idx</span><span>:</span><span> </span><span>Int</span><span>,</span><span> </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>...</span></code></pre>


</section>
<section>
<p>
But of course, trying to inline a recursive call causes a compile error:
</p>

</section>
<section>

    <div>
      
      <pre><code>main_rt_inlined.mojo:19:4: error: function has recursive call to &#39;always_inline&#39; function
fn _match_node(
   ^
main_rt_inlined.mojo:28:29: note: through call here
        return _match_repeat(nodes, repeat_node, text, start_pos)
                            ^
main_rt_inlined.mojo:119:4: note: to function marked &#39;always_inline&#39; here
fn _match_repeat(
   ^
main_rt_inlined.mojo:128:33: note: call here recurses
        var result = _match_node(nodes, node.repeated, text, pos)
                                ^
main_rt_inlined.mojo:19:4: note: back to function here
fn _match_node(
   ^</code></pre>
    </div>
  

</section>
<section>
<p>
So let&#39;s table this line of thinking for now. We might come back to it later.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="the-sorcery">
 The Sorcery</h3>
<p>
I promised something mind-blowingly <i>weird</i>, so let&#39;s make things weird.
</p>

</section>
<section>
<p>
We&#39;re going to do some <a href="https://en.wikipedia.org/wiki/Multi-stage_programming">multi-stage programming</a> to get similar effects to the <a href="https://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections">first Futamura projection</a>, <a href="#note4" data-noteid="4">4</a> or as it&#39;s known to some, &#34;the three steps of Futamura sorcery&#34;. <a href="#note5" data-noteid="5">5</a>
</p>

</section>
<section>
<p>
We&#39;ll:
</p>
<ul>
<li>
Parse the regular expression and create the Regex <b>at compile-time.</b>
</li>
<li>
Make it a compile-time parameter, and use compile-time operations.
</li>
<li>
Inline.
</li>
</ul>
<p>
...and then something amazing happens.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note4" data-noteid="4">
<p><span>4</span></p><section>
<p>
Specifically, we&#39;re specializing an interpreter for a specific program, though we&#39;ll use a few explicit staging annotations (<span>alias</span> and square brackets) rather than automatic partial evaluation.
</p>

</section>
</div>
<div id="note5" data-noteid="5">
<p><span>5</span></p><section>
<p>
By &#34;some&#34;, I mean like three people. Two if you don&#39;t count me.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h4 id="step-1-parse-the-regex-at-compile-time">
 Step 1: Parse the Regex at compile-time</h4>
<p>
Most Regex implementations first parse the regular expression into a list of nodes. If we could move that parsing to compile time, we can save some run-time.
</p>

</section>
<section>
<p>
To parse the Regex into nodes at compile time, we simply need to change the <span>var regex</span> to <span>alias regex</span>.
</p>

</section>
<section>
<p>
Before:
</p>

</section>
<section>
<pre><code><span>#</span><span> Parse the regex (at runtime)</span>
<span>var</span><span> </span><span>regex</span><span> </span><span>=</span><span> </span><span>Regex</span><span>(</span><span>&#34;</span><span>w+(+w*)?@(d+.d+.d+.d+|w+.w+)</span><span>&#34;</span><span>)</span>
<span>regex</span><span>.</span><span>match</span><span>(</span><span>regex</span><span>.</span><span>nodes</span><span>,</span><span> </span><span>regex</span><span>.</span><span>root_node</span><span>,</span><span> </span><span>user_string</span><span>,</span><span> </span><span>0</span><span>)</span></code></pre>


</section>
<section>
<p>
After:
</p>

</section>
<section>
<pre><code><span>#</span><span> Parse the regex (at compile time)</span>
<span>alias</span><span> </span><span>regex</span><span> </span><span>=</span><span> </span><span>Regex</span><span>(</span><span>&#34;</span><span>w+(+w*)?@(d+.d+.d+.d+|w+.w+)</span><span>&#34;</span><span>)</span>
<span>_match_node</span><span>[</span><span>regex</span><span>.</span><span>nodes</span><span>,</span><span> </span><span>regex</span><span>.</span><span>root_node</span><span>]</span><span>(</span><span>user_string</span><span>,</span><span> </span><span>0</span><span>)</span></code></pre>


</section>
<section>
<p>
<span>alias</span> is Mojo-speak for &#34;compile-time variable&#34;. <a href="#note6" data-noteid="6">6</a>
</p>

</section>
<section>
<p>
&#34;But wait Evan, that&#39;s a <i>lot</i> of code to run at compile time, can compilers really execute general code at compile-time?&#34;
</p>
<p>
They can! This is one of the nicer features of Mojo (and a few other languages like D, Nim, Zig, etc.). A simple keyword (<span>alias</span>) can lift almost any computation <a href="#note7" data-noteid="7">7</a> to compile time, and the same code can be run at compile-time or run-time depending on how it&#39;s used (like <span>var</span> vs <span>alias</span>).
</p>
<p>
In this case, the compiler is running a whole little parser, with its own recursion, heap allocation, all sorts of stuff. And now it&#39;s happening at compile-time.
</p>

</section>
<section>
<p>
&#34;Wait Evan, did you say heap allocation? Isn&#39;t heap allocation at compile-time impossible?&#34;
</p>
<p>
It&#39;s rare, but not impossible! Mojo, D, Nim, and Zig can do it, and C++ <a href="https://accu.org/journals/overload/31/176/fertig/#:~:text=Or%20in,appealing%20use-cases">as of C++20</a>. There are likely some other languages that can do it, but these are the only ones that can truly run normal run-time code at compile time, as opposed to requiring compile-time calculations to be expressed in a different dialect. Though, I&#39;d bet that some Lisps were doing all this back in the 60s and 70s too, as is usually the case!
</p>

</section>
<section>
<p>
Deep inside the Mojo compiler, there&#39;s a compile-time interpreter that works closely with the instantiator (the &#34;elaborator&#34;, which monomorphizes all generics), which runs all expressions inside generic arguments (<span>[...]</span>) and inside <span>alias</span> statements. This compile-time interpreter can execute pretty much any operation that a normal CPU could execute, including malloc and free.
</p>

</section>

      </div>
  
<div>

      <div>
        <div>
    
<div id="note6" data-noteid="6">
<p><span>6</span></p><section>
<p>
I kind of wish Mojo had a <span>comptime</span> keyword like Zig, but alas!
</p>

</section>
</div>
<div id="note7" data-noteid="7">
<p><span>7</span></p><section>
<p>
I say almost because there are things a language shouldn&#39;t allow at compile time, like reading from stdin, etc.
</p>

</section>
</div>

        </div>
      </div>
    
</div>

    </div>
    <div>
      <div>
  
<section>
<h4 id="step-2-make-regex-a-compile-time-parameter-use-compile-time-operations">
 Step 2: Make Regex a compile-time parameter, use compile-time operations</h4>

</section>
<section>
<p>
We just created this <span>Regex</span> at compile time.
</p>
<p>
Do we read it at run-time? Do we put it into a global or something?
</p>
<p>
No! We&#39;re going to <b>only read it at compile-time.</b>
</p>

</section>
<section>
<p>
&#34;But Evan, we <i>need</i> to read the <span>Regex</span> at run-time! Otherwise, how does the run-time program even know what to do? How does it know what functions to call, what branches to take, etc.?&#34;
</p>
<p>
Great question! The answer is that <b>we can make all those decisions at compile time.</b>
</p>
<p>
I know that doesn&#39;t make any sense, but bear with me.
</p>

</section>
<section>
<p>
Here&#39;s how we change our program.
</p>
<p>
Before:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>(</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span>
<span>    </span><span>node_idx</span><span>:</span><span> </span><span>Int</span><span>,</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>nodes</span><span>[</span><span>node_idx</span><span>]</span>
<span>    </span><span>if</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>LiteralNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>ref</span><span> </span><span>literal_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>LiteralNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_literal</span><span>(</span><span>nodes</span><span>,</span><span> </span><span>literal_node</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>RepeatNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>ref</span><span> </span><span>repeat_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>RepeatNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_repeat</span><span>(</span><span>nodes</span><span>,</span><span> </span><span>repeat_node</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>...</span></code></pre>


</section>
<section>
<p>
After:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>[</span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span><span> </span><span>node_idx</span><span>:</span><span> </span><span>Int</span><span>]</span><span>(</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>alias</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>nodes</span><span>[</span><span>node_idx</span><span>]</span>
<span>    </span><span>@</span><span>parameter</span>
<span>    </span><span>if</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>LiteralNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>alias</span><span> </span><span>literal_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>LiteralNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_literal</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>literal_node</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>node</span><span>.</span><span>isa</span><span>[</span><span>RepeatNode</span><span>]</span><span>(</span><span>)</span><span>:</span>
<span>        </span><span>alias</span><span> </span><span>repeat_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>RepeatNode</span><span>]</span>
<span>        </span><span>return</span><span> </span><span>_match_repeat</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>repeat_node</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>    </span><span>elif</span><span> </span><span>...</span></code></pre>


</section>
<section>
<p>
There are two main changes:
</p>
<ul>
<li>
The <span>nodes</span> and <span>node_idx</span> run-time parameters are now <b>compile-time parameters</b>, because they&#39;re inside <span>[...]</span>. We&#39;re using Mojo&#39;s generics system to hold these values at compile-time.
</li>
<li>
The <span>@parameter if</span>. <span>@parameter</span> means &#34;at compile time&#34; in Mojo-speak, so this <span>if</span> is run at compile-time, not run-time. This is like a <span>constexpr if</span> in C++ terms, or in C terms it&#39;s more like <span>#define</span> than <span>if</span>.
</li>
</ul>

</section>
<section>
<p>
That means <span>_match_node</span> is now a generic function, a template.
</p>

</section>
<section>
<p>
There&#39;s only one <span>nodes</span> value (from the <span>Regex</span>), but there are 28 different <span>node_idx</span>s for this <span>Regex</span>. That means we&#39;ll have 28 different instantiations of this <span>_match_node</span>, one for each <span>node_idx</span>.
</p>

</section>
<section>
<p>
Previously, we had a very simple call tree, with only one <span>_match_node</span>, that was recursive. The call tree looked like this:
</p>
<ul>
<li>
<span>main</span>
</li>
<ul>
<li>
<span>match</span>
</li>
<ul>
<li>
<span>_match_node</span>
</li>
<ul>
<li>
<span>_match_node</span>
</li>
<ul>
<li>
<span>_match_node</span>
</li>
<ul>
<li>
<span>_match_node</span>
</li>
<ul>
<li>
<span>_match_node</span>
</li>
<ul>
<li>
... and so on
</li>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

</section>
<section>
<p>
Now, we have 28 versions of <span>_match_node</span>, with a call tree that looks like this:
</p>
<ul>
<li>
<span>main</span>
</li>
<ul>
<li>
<span>match[Regex instance]</span>
</li>
<ul>
<li>
<span>_match_node[List(...), 0]</span> (for whole expr)
</li>
<ul>
<li>
<span>_match_node[List(...), 1]</span> (for first <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 2]</span> (for <span>\w</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 3]</span> (for <span>(\+\w*)?</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 4]</span> (for <span>\+\w*</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 5]</span> (for <span>\+</span>)
</li>
<li>
<span>_match_node[List(...), 6]</span> (for <span>\w*</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 7]</span> (for <span>\w</span>)
</li>
</ul>
</ul>
</ul>
<li>
<span>_match_node[List(...), 8]</span> (for <span>@</span>)
</li>
<li>
<span>_match_node[List(...), 9]</span> (for <span>(\d+\.\d+\.\d+\.\d+|\w+\.\w+)</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 10]</span> (for <span>\d+\.\d+\.\d+\.\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 11]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 12]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 13]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 14]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 15]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 16]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 17]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 18]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 19]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 20]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 21]</span> (for <span>\d</span>)
</li>
</ul>
</ul>
<li>
<span>_match_node[List(...), 22]</span> (for <span>\w+\.\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 23]</span> (for <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 24]</span> (for <span>\w</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 25]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 26]</span> (for <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 27]</span> (for <span>\w</span>)
</li>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

</section>
<section>
<p>
28 versions, each different only in their <span>node_idx</span> compile-time parameter.
</p>

</section>
<section>
<p>
To understand that better, let&#39;s look at the <span>_match_node[List(...), 1]</span> function for the first <span>\w+</span>.
</p>

</section>
<section>
<p>
When the compiler instantiates it as <span>_match_node[List(...), 1]</span>, it would look like below. The <span>@parameter if</span> is evaluated at compile time, so only one of its branches is included. I&#39;ll leave them in as comments to illustrate:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>[</span><span>List(...), 1</span><span>]</span><span>(</span><span>  </span><span>#</span><span> Node 1 is a RepeatNode</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>#</span><span>   alias node = nodes[node_idx]</span>
<span>#</span><span>   @parameter</span>
<span>#</span><span>   if node.isa[LiteralNode]():</span>
<span>#</span><span>       alias literal_node = node[LiteralNode]</span>
<span>#</span><span>       return _match_literal[nodes, literal_node](text, start_pos)</span>
<span>#</span><span>   elif node.isa[RepeatNode]():</span>
<span>#</span><span>       alias repeat_node = node[RepeatNode]</span>
<span>        </span><span>return</span><span> </span><span>_match_repeat</span><span>[</span><span>List</span><span>(</span><span>...</span><span>)</span><span>,</span><span> </span><span>RepeatNode</span><span>(</span><span>2</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>)</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span>
<span>#</span><span>   elif ...</span></code></pre>


</section>
<section>
<p>
The benefit here is that we don&#39;t have to do the <span>node.isa[LiteralNode]</span>, <span>node.isa[RepeatNode]</span>, etc. at run-time. That&#39;s pretty nice, it eliminates a bit of overhead.
</p>
<p>
It also executed the <span>alias</span> statements for us too, so we don&#39;t have to do those lookups (and bounds checks) at run-time. Another nice speedup!
</p>

</section>
<section>
<p>
We&#39;ll see the biggest benefit in the next section though.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h4 id="step-3-inline">
 Step 3: Inline</h4>
<p>
Let&#39;s look at the call tree again:
</p>
<ul>
<li>
<span>main</span>
</li>
<ul>
<li>
<span>match[Regex instance]</span>
</li>
<ul>
<li>
<span>_match_node[List(...), 0]</span> (for whole expr)
</li>
<ul>
<li>
<span>_match_node[List(...), 1]</span> (for first <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 2]</span> (for <span>\w</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 3]</span> (for <span>(\+\w*)?</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 4]</span> (for <span>\+\w*</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 5]</span> (for <span>\+</span>)
</li>
<li>
<span>_match_node[List(...), 6]</span> (for <span>\w*</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 7]</span> (for <span>\w</span>)
</li>
</ul>
</ul>
</ul>
<li>
<span>_match_node[List(...), 8]</span> (for <span>@</span>)
</li>
<li>
<span>_match_node[List(...), 9]</span> (for <span>(\d+\.\d+\.\d+\.\d+|\w+\.\w+)</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 10]</span> (for <span>\d+\.\d+\.\d+\.\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 11]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 12]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 13]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 14]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 15]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 16]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 17]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 18]</span> (for <span>\d</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 19]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 20]</span> (for <span>\d+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 21]</span> (for <span>\d</span>)
</li>
</ul>
</ul>
<li>
<span>_match_node[List(...), 22]</span> (for <span>\w+\.\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 23]</span> (for <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 24]</span> (for <span>\w</span>)
</li>
</ul>
<li>
<span>_match_node[List(...), 25]</span> (for <span>\.</span>)
</li>
<li>
<span>_match_node[List(...), 26]</span> (for <span>\w+</span>)
</li>
<ul>
<li>
<span>_match_node[List(...), 27]</span> (for <span>\w</span>)
</li>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>
</ul>

</section>
<section>
<p>
Note how these are <b>not actually recursive calls</b> anymore. The compiler doesn&#39;t see these as recursive, it sees them as completely different functions, because they are.
</p>
<p>
As far as the compiler is concerned, this is a normal call tree, not a potentially infinite call tree.
</p>

</section>
<section>
<p>
So... maybe we can inline them? Can we put <span>@always_inline</span> on these functions?
</p>
<p>
Yes we can!
</p>

</section>
<section>
<p>
Let&#39;s start by inlining the <span>_match_repeat</span> function. We do that by putting <span>@always_inline</span> on <span>fn _match_repeat</span>:
</p>

</section>
<section>
<pre><code><span>@</span><span>always_inline</span>
<span>fn</span><span> </span><span>_match_repeat</span><span>[</span>
<span>    </span><span>nodes</span><span>:</span><span> </span><span>List</span><span>[</span><span>RegexNode</span><span>]</span><span>,</span><span> </span><span>repeat_node</span><span>:</span><span> </span><span>RepeatNode</span>
<span>]</span><span>(</span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span><span> </span><span>start_pos</span><span>:</span><span> </span><span>Int</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>var</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>pos</span><span> </span><span>=</span><span> </span><span>start_pos</span>
<span>    </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>        </span><span>if</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_match_node</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>node</span><span>.</span><span>repeated</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>pos</span><span>)</span>
<span>        </span><span>...</span></code></pre>


</section>
<section>
<p>
And now it will be inlined into its caller.
</p>

</section>
<section>
<p>
Remember our <span>_match_node[List(...), 1]</span> function?
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>[</span><span>List(...), 5</span><span>]</span><span>(</span><span>  </span><span>#</span><span> Node 5 is a RepeatNode</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>alias</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>nodes</span><span>[</span><span>node_idx</span><span>]</span>
<span>    </span><span>alias</span><span> </span><span>repeat_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>RepeatNode</span><span>]</span>
<span>    </span><span>#</span><span> Let&#39;s inline this _match_repeat call first!</span>
<span>    </span><span>return</span><span> </span><span>_match_repeat</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>repeat_node</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>start_pos</span><span>)</span></code></pre>


</section>
<section>
<p>
Now that <span>_match_repeat</span> is inlined, <span>_match_node</span> looks more like this now:
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>[</span><span>List(...), 1</span><span>]</span><span>(</span><span>  </span><span>#</span><span> Node 1 is a RepeatNode</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>alias</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>nodes</span><span>[</span><span>node_idx</span><span>]</span>
<span>    </span><span>alias</span><span> </span><span>repeat_node</span><span> </span><span>=</span><span> </span><span>node</span><span>[</span><span>RepeatNode</span><span>]</span>
<span>    </span><span>#</span><span> Inlined <span>_match_repeat</span> call</span>
<span>    </span><span>var</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>        </span><span>if</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span>:</span>
<span>            </span><span>break</span>
<span>        </span><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_match_node</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>node</span><span>.</span><span>repeated</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>pos</span><span>)</span>
<span>        </span><span>...</span>
<span>    </span><span>...</span></code></pre>


</section>
<section>
<p>
And the compiler will also execute those <span>alias</span> statements at compile time and inline their results.
</p>
<p>
This part:
</p>

</section>
<section>
<pre><code><span>if</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>node</span><span>.</span><span>maximum_times</span><span>:</span>
<span>    </span><span>break</span></code></pre>


</section>
<section>
<p>
actually becomes:
</p>

</section>
<section>
<pre><code><span>if</span><span> </span><span>RepeatNode</span><span>(</span><span>2</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>-</span><span>1</span><span>)</span><span>_times</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>RepeatNode</span><span>(</span><span>2</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>)</span><span>.</span><span>maximum_times</span><span>:</span>
<span>    </span><span>break</span></code></pre>


</section>
<section>
<p>
which then becomes:
</p>

</section>
<section>
<pre><code><span>if</span><span> </span><span>-</span><span>1</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>-</span><span>1</span><span>:</span>
<span>    </span><span>break</span></code></pre>


</section>
<section>
<p>
which then becomes:
</p>

</section>
<section>
<pre><code><span>if</span><span> </span><span>False</span><span> </span><span>and</span><span> </span><span>matches</span><span> </span><span>&gt;=</span><span> </span><span>-</span><span>1</span><span>:</span>
<span>    </span><span>break</span></code></pre>


</section>
<section>
<p>
which is then completely eliminated, because it&#39;s impossible.
</p>
<p>
So in the end, our <span>_match_node[List(...), 1]</span> function is much simpler, and more specialized to this particular RepeatNode.
</p>

</section>
<section>
<pre><code><span>fn</span><span> </span><span>_match_node</span><span>[</span><span>List(...), 1</span><span>]</span><span>(</span><span>  </span><span>#</span><span> Node 1 is a RepeatNode</span>
<span>    </span><span>text</span><span>:</span><span> </span><span>String</span><span>,</span>
<span>    </span><span>start_pos</span><span>:</span><span> </span><span>Int</span>
<span>)</span><span> </span><span>-&gt;</span><span> </span><span>MatchResult</span><span>:</span>
<span>    </span><span>#</span><span> No node lookup!</span>
<span>    </span><span>var</span><span> </span><span>matches</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>var</span><span> </span><span>total_consumed</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>while</span><span> </span><span>True</span><span>:</span>
<span>        </span><span>#</span><span> No useless maximum_times checks here!</span>
<span>        </span><span>var</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>_match_node</span><span>[</span><span>nodes</span><span>,</span><span> </span><span>node</span><span>.</span><span>repeated</span><span>]</span><span>(</span><span>text</span><span>,</span><span> </span><span>pos</span><span>)</span>
<span>        </span><span>...</span>
<span>    </span><span>...</span></code></pre>


</section>
<section>
<p>
We got all that benefit from just one <span>@always_inline</span> on one function!
</p>

</section>
<section>
<p>
Let&#39;s throw <span>@always_inline</span> on all the functions:
</p>
<ul>
<li>
<span>_match_literal</span>
</li>
<li>
<span>_match_charclass</span>
</li>
<li>
<span>_match_or</span>
</li>
<li>
<span>_match_sequence</span>
</li>
<li>
<span>_match_repeat</span>
</li>
<li>
<span>_match_node</span>
</li>
</ul>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="the-result">
 The Result</h3>
<p>
Suddenly, our large call tree above becomes simply this:
</p>
<ul>
<li>
<span>main</span>, which calls:
</li>
<ul>
<li>
<span>match[Regex instance]</span>
</li>
</ul>
</ul>

</section>
<section>
<p>
And looking at the generated IR, <b>it was all folded down into one function</b>, structured similarly to the hand-written version.
</p>

</section>
<section>
<p>
The final results (tested on an M2 Macbook Pro), run 200,000,000 times:
</p>
<ul>
<li>
Normal recursive version (main_rt.mojo): 135.9 seconds
</li>
<li>
Metaprogrammed version (main_ct.mojo): 13.4 seconds
</li>
<li>
Hand-written version (13.0 seconds)
</li>
</ul>

</section>
<section>
<p>
The metaprogrammed version is <b>10x faster than the normal recursive version,</b> and within ~3% of the hand-written version.
</p>
<p>
Pretty impressive!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="could-this-go-even-faster-than-the-hand-written-version">
 Could this go even faster than the hand-written version?</h3>
<p>
It could!
</p>

</section>
<section>
<p>
Regex libraries often do their own custom optimizations on the AST, before matching against the user&#39;s strings.
</p>
<p>
For example, the pattern <span>(catastrophe|catapult|category)</span> shares the prefix &#39;cat&#39;. At compile-time, we could detect this and generate code that&#39;s more like <span>cat(astrophe|apult|egory)</span>, saving some comparisons.
</p>
<p>
Or, for patterns like <span>\b(GET|POST|PUT|DELETE)\b</span>, it could figure out (at compile-time) a perfect hash table or trie, replacing 4 string comparisons with one hash lookup / string compare.
</p>

</section>
<section>
<p>
These are techniques you rarely see in hand-written versions, but are common in normal regex engines.
</p>
<p>
If we combine those with this technique, we could get those optimizations <i>on top of</i> hand-written performance.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="the-downside">
 The Downside</h3>
<p>
Let&#39;s talk about the main downside: <b>compile times!</b>
</p>

</section>
<section>
<p>
This takes much more time to compile, because the compiler is generating <i>much</i> more code. In this example, we made 28 <span>_match_node[...]</span> functions, each about a fifth of the size of the original run-time recursive <span>_match_node</span>. So this technique generated about 5x as much <span>_match_node</span> code.
</p>

</section>
<section>
<p>
And if you do custom optimizations like I mentioned in the last section, that also gets more performance at the cost of more compile time.
</p>

</section>
<section>
<p>
One should use this technique wisely, only on code that needs to run fast.
</p>

</section>
<section>
<p>
I should mention, I suspect drawback can be mitigated or avoided entirely. I think a user could theoretically use <a href="https://github.com/modular/modular/issues/4887#issuecomment-3045841971">MaybeComptime</a> and a few accompanying tools to have a dev/test mode where these calculations happen at run-time instead. Not proven, but my spidey sense says it&#39;s possible.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="metaprogramming">
 Metaprogramming</h3>
<p>
<i>This</i> is metaprogramming. It&#39;s not just templates and <span>constexpr</span>. It&#39;s moving entire aspects of your entire program into compile-time, doing custom optimizations so that it can work even better than hand-written code.
</p>
<p>
Metaprogramming is a term I&#39;ve heard for many, many years, but I admit, I didn&#39;t truly understand its power and implications until seeing what it could do here.
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="the-implications">
 The Implications</h3>
<p>
This regex example is just something most of us can relate to, but I think this technique can be used for much, much more.
</p>

</section>
<section>
<p>
This is just wild speculation, but I think you could use this for:
</p>
<ul>
<li>
Compiling entire database queries
</li>
<li>
Fusing graphics shaders together or GPU kernels together
</li>
<li>
Eliminate redundant network fetches or file system reads, like how we eliminated those redundant regex sub-expressions
</li>
<li>
Eliminate redundant matrix operations (like two transposes next to each other)
</li>
<li>
Combining a map, reduce, and map all into one operation
</li>
<li>
Crazy data structures, like in-memory journaled databases / persistent data structures.
</li>
</ul>

</section>
<section>
<p>
If I was to generalize:
</p>
<ul>
<li>
Any time you are <b>making decisions based on information that you know at compile time,</b> you could apply this technique.
</li>
<li>
This lets you do <b>custom, high-level optimizations</b>.
</li>
<li>
If you ever have <b>data describing computations</b>, you could use this to remove that data layer, to remove that abstraction.
</li>
</ul>

</section>
<section>
<p>
There&#39;s a few other directions I want to explore here:
</p>
<ul>
<li>
If you squint, this is a kind of constant propagation, where a compiler is more aware of what&#39;s known at compile-time and what&#39;s not. And given that, I suspect we could combine it with the <span>MaybeComptime</span> concept described <a href="https://github.com/modular/modular/issues/4887#issuecomment-3045841971">here</a> and <a href="https://github.com/modular/modular/issues/1731#issuecomment-1931462973">here</a> (for working with data when you don&#39;t know if it&#39;s known at compile time) to take it one step further and let the compiler constant-propagate even more.
</li>
<li>
If we get can feed in more details about the target machine, like cache size, kind of CPU, kind of graphics or compute cards, etc., then we can specialize code according to those details, giving us code that&#39;s way, way faster. This is actually pretty convenient for Mojo, which is compiled on the user&#39;s machine, since it&#39;s part of the Python ecosystem.
</li>
</ul>

</section>
<section>
<p>
If you have any thoughts on where this technique can go, let me know!
</p>

</section>

      </div>
  


    </div>
    <div>
      <div>
  
<section>
<h3 id="conclusion">
 Conclusion</h3>
<p>
It turns out, the impossible optimization is totally possible!
</p>
<p>
All it took was a little metaprogramming sorcery.
</p>
<p>
If you want to see the code, you can find it <a href="https://github.com/Verdagon/MojoCompileTimeRegex">here</a>.
</p>

</section>
<section>
<p>
If you want to read more on this technique, search for <a href="https://en.wikipedia.org/wiki/Partial_evaluation#Futamura_projections">first Futamura projection</a> or &#34;staged programming&#34; which is a similar concept.
</p>

</section>
<section>
<p>
I hope you enjoyed this! Stay tuned for more articles by subscribing to the <a href="https://verdagon.dev/rss.xml">RSS feed</a>, <a href="https://twitter.com/verdagon">twitter</a>, and come hang out in the <a href="https://discord.gg/modular">Mojo discord</a> or find me on the <a href="https://discord.gg/SNB8yGH">Vale discord</a>.
</p>

</section>
<section>
<p>
Cheers!
</p>
<p>
- Evan
</p>

</section>


      </div>
  


    </div>
    
  

    </div>
  </div></div>
  </body>
</html>
