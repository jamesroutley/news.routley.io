<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/bleichenbachers-attack-on-rsa/">Original</a>
    <h1>Building a demo of the Bleichenbacher RSA attack in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>Recently while reading Real-World Cryptography, I got nerd sniped by the mention of <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">Bleichenbacher&#39;s attack on RSA</a>.
This is cool, how does it work?
I had to understand, and to understand something, I usually have to build it.</p>
<p>Well, friends, that is what I did.
I implemented RSA from scratch, wrote the attack to decrypt a message, and made a web demo of it.
Here&#39;s how I did it, from start to finish.</p>
<p>If you&#39;re here for <a href="https://www.ntietz.com/demos/bleichenbacher/">the demo</a>, feel free to peruse it before, during, or after reading this post!
It&#39;s a lot of fun.
Otherwise, buckle in for a fun ride.</p>

<p>Okay, so let&#39;s take a step back.
RSA itself is a cryptosystem that&#39;s, unfortunately, still widely used despite it being a bad idea to use it.
That&#39;s covered in my <a href="https://monodraw.helftone.com/blog/rsa-deceptively-simple/">post about RSA</a>, which gives a nice overview.
And the Bleichenbacher attack is a famous way to take an RSA-encrypted message and find what it means without having the private key.</p>
<p>When I learned about the Bleichenbacher attack, I wanted to know how it worked in <em>detail</em>, not just broad strokes.
So I went to the source, the <a href="https://link.springer.com/content/pdf/10.1007/BFb0055716.pdf">paper he wrote</a> in 1998.
The paper contains a lot of math, but it&#39;s surprisingly approachable as long as you&#39;re looking to understand how to <em>implement</em> the attack.
Why it works, and the math derivations? I dunno.
But how it works in practice, algorithmically? Approachable!</p>
<p>After I read the paper, though, I realized I needed to know more—a lot more—about how RSA itself works.
So I read the <a href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA page on Wikipedia</a> a couple of times and worked through some examples by hand with very small numbers.
Comfortable that I understood it more or less, I turned back to the paper.</p>
<p>That&#39;s when I remembered that the paper was talking about a particular encoding scheme used with RSA, called <a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS #1 v1.5</a>.
So I had to read about that, too.
Then I read the paper <em>again</em> in that context, and was ready to dive in.</p>
<p>I came up with a plan of attack, pun intended:</p>
<ul>
<li><strong>Implement RSA.</strong> I wanted to do this myself so I can use very small keys and small messages, which would be faster to attack, so that I would know more quickly if my attack works or not. A lot of existing implementations strongly discourage, or prevent, using the vulnerable stuff, which was kind of the <em>point</em> here.</li>
<li><strong>Implement the attack.</strong> Then it would just be code up the paper, right? How hard could it be, right?</li>
<li><strong>Make a web demo!</strong> This was always the end goal, so it influenced the design from the beginning. I don&#39;t want to ship Python to the browser, for example.</li>
</ul>

<p>Writing my own RSA library was definitely a good choice for learning.
I <em>strongly</em> recommend people do this for fun and education, and also please license it under something that discourages usage unless you&#39;re actually getting it vetted and checked.</p>
<p>For my library, <a href="https://crates.io/crates/cryptoy">cryptoy</a>, I used Rust so that I could use that sweet WASM toolchain.
This would let me build it for the web and make an interactive demo!</p>
<p>I built it once, then rebuilt it again to make the interfaces better.
And then I realized that the bigint library I was using was going to make things difficult for the demo I wanted, so I migrated to a different one.
I was originally using <a href="https://crates.io/crates/crypto-bigint">crypto-bigint</a>, which is probably the one you want for any real cryptography applications in Rust, because it uses constant time operations wherever possible.
The challenge was that it requires fixed precision, and that meant that it would be tough to write something that handles both very small and very large keys.</p>
<p>So, I migrated to use <a href="https://crates.io/crates/num-bigint-dig">num-bigint-dig</a>.
It has bigints with arbitrary precision at runtime, exactly what I want.
It library seems reasonable for my purposes, but doesn&#39;t have the vetting that <code>crypto-bigint</code> does, so I&#39;d be more wary of it in production.
It very well could be fine, but it hasn&#39;t been audited and I <em>don&#39;t know</em> if there are problems.
But given that the whole <em>point</em> here is to produce something vulnerable to a particular attack?
Yeah, I&#39;m okay with that.</p>
<p>The other point in favor of <code>num-bigint-dig</code> was that it had nice things built in, like generating random primes.
These were needed and I didn&#39;t have to go looking for them, so it makes the code nicer and tighter.
The ergonomics of the code also feel better, which is subjective.</p>
<p>After I implemented RSA, I started to build a demo of it in a little playground.
I got started, but didn&#39;t finish it.
It was really fun pairing with a friend on this for a bit, and ultimately I didn&#39;t find the thing that would make it a compelling demo, so it was dropped.
But like <a href="https://en.wikipedia.org/wiki/Chekhov%27s_gun">Chekov&#39;s gun</a>, will it return?</p>

<p>The attack itself was pretty easy to get <em>partially</em> working, and then very challenging to flush the bugs out of.
It would make progress, make progress, then stall.
At some point I figured out that the problem related to rounding (in part by looking at other implementations, and mostly by squinting at the paper a lot).
Somewhere, my rounding went wrong.
I fixed it, <em>mostly</em>.
Then I rewrote it again and it worked!
I&#39;m still not sure what the difference was and I&#39;m not looking back to figure out.</p>
<p>That part was left with one fatal bug which annoying but I accepted, just to be done with the project: keys over a certain size would just totally fail!
Except I couldn&#39;t really let it go, it kept bugging me.
Eventually I realized that my iteration counter was an 8-bit int, for reasons that escape me.
The upshot of that was that every 256th iteration, my code thought it was at iteration 0, and it reset things.
Once that was a larger type, bigger keys worked!</p>
<p>Once it was done and I had it output some stats like the number of iterations taken and the number of messages required, I was pretty sure there was a bug: this was converging <em>too</em> fast, yeah?
But it turns out, it&#39;s actually fine!
There&#39;s <a href="https://ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/appliedcrypto/education/theses/Experimenting%20with%20the%20Bleichenbacher%20Attack%20-%20Livia%20Capol.pdf">a thesis</a> which shows that my messages required are about in the ballpark when using the kind of oracle I have.</p>
<p>The original paper called for an oracle which requires the padding to entirely be valid, but later results use a different oracle which just checks for two bytes at the start, <code>0x00 0x02</code>.
It was shown in <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-bock.pdf">Bock &#39;18</a> that a <em>lot</em> of real-world cases of this attack provide this sort of oracle.
So, this is a realistic assumption.</p>
<p>After this was done, I built another version of it as an iterator.
I used the original code and encoded the state into an iterator so that, for a demo, I can show the progress and intermediate internal state along the way.
Converting it to an iterator was fun, and pretty straightforward!
It&#39;s a nice technique for looping algorithms, so that you have pause points between iterations where you can do other work.</p>

<p>To make the demo, I first procrastinated by looking at all the different Rust single-page app frameworks for an hour or two under the premise of &#34;research&#34;.
Then I decided to just use the one I already used on a different project, a framework called <a href="https://yew.rs/">Yew</a>.</p>
<p>I sketched out the design and figured out that what I wanted was something where you can see different steps along the way, but more importantly, get a <em>feel</em> for how the attack is progressing.
I wanted you to <em>feel how fast</em> it is to decrypt one of these messages.</p>
<p>From there I just worked through it.
Most of the code is boilerplate, lots of state hooks and forms passing data back out for later use.
The code is <a href="https://git.sr.ht/~ntietz/cryptoy/tree/main/item/playground">all available</a> if you do want to read it, so if you are curious, take a look!
The most interesting part is probably the container for the attack itself.
I needed to keep some state in there for where we are in the attack, and also needed to have it run on its own.</p>
<p>That state was kept inside the <code>AttackDemo</code> struct.</p>
<pre data-lang="rust"><code data-lang="rust">#[derive(Debug)]
pub struct AttackDemo {
    /// internal state, and the iterator for the attack
    pub attack_state: AttackState,

    /// stats we want to display
    pub iterations: usize,
    pub oracle_calls: usize,
    pub span: BigUint,

    /// a ticker which gives us a call every so often
    pub ticker: Option&lt;Interval&gt;,
}
</code></pre>
<p>Then I implement Yew&#39;s <code>Component</code> trait for it.
We start with the associated types: we have <code>Msg</code> for the different messages we can send upon events, and a properties type for what&#39;s passed into the component.</p>
<pre data-lang="rust"><code data-lang="rust">impl Component for AttackDemo {
    type Message = Msg;
    type Properties = AttackProps;

    // ...
}

pub enum Msg {
    Step,
    Run,
    Pause,
    Reset,
}

#[derive(Properties, PartialEq)]
pub struct AttackProps {
    pub attack_state: AttackState,
}
</code></pre>
<p>Then we have the methods.
The <code>create</code> and <code>view</code> functions are boilerplate, just initializing the state and rendering some HTML with buttons for emitting different messages.
A stripped down form of <code>view</code> to just contain one button which sends a message would look like this.
The rest of it is similar to add more buttons, and render some data which we get from <code>self</code>.</p>
<pre data-lang="rust"><code data-lang="rust">    def view(&amp;self, ctx: Context&lt;Self&gt;) -&gt; Html {
        let run = ctx.link().callback(|_| Msg::Run);

        html! {
            &lt;div class=&#34;attack&#34;&gt;
                &lt;input type=&#34;button&#34; value=&#34;Run&#34; onclick={run} /&gt;
            &lt;/div&gt;
        }
    }
</code></pre>
<p>The <code>update</code> function is where the attack code is invoked!
It looks like this.
We receive a message, and then pattern match on it.
For <code>Step</code>, we perform one iteration and cancel the ticker if we&#39;ve exhausted the iterator.
For <code>Run</code>, we start a ticker for every 20 milliseconds (faster and you can&#39;t see the attack progress).
<code>Pause</code> does the opposite, and stops the ticker. And <code>Reset</code> clears all the state so we can start over!</p>
<pre data-lang="rust"><code data-lang="rust">    fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
        match msg {
            Msg::Step(n) =&gt; {
                if let Some((_message, state)) = self.attack_state.attack_iter.next() {
                    self.set_iteration_state(&amp;state);
                    true
                } else {
                    self.ticker = None;
                    false
                }
            }
            Msg::Run =&gt; {
                self.ticker = {
                    let link = ctx.link().clone();
                    Some(Interval::new(20, move || {
                        link.send_message(Msg::Step(1));
                    }))
                };
                true
            }
            Msg::Pause =&gt; {
                self.ticker = None;
                true
            }
            Msg::Reset =&gt; {
                self.ticker = None;
                self.reset_state(&amp;ctx.props().attack_state.current);
                self.attack_state = ctx.props().attack_state.clone();
                true
            }
        }
    }
</code></pre>
<p>While working on it, I had to remember to use release builds for larger key sizes as I was testing, otherwise my computer got really hot and things never finished.
Then again, it was pretty cold outside... so that was sometimes a benefit.</p>
<p>The final step was to create the release build and put it in a page on my blog!
This was pretty straightforward, though I have some manual steps.
There&#39;s not a good way that I can see to have <a href="https://trunkrs.dev/">Trunk</a> build artifacts you can embed into another page; it wants to build <em>the</em> page, and have other things embed into it.
Since I wanted to use my usual blog templates, I snagged out the pieces that I wanted from there, all good.</p>
<hr/>
<p>This was a really fun project, end to end!
I don&#39;t think I would use Yew in production, because I am just not as productive in it as other things.
And I <em>certainly</em> wouldn&#39;t use my own RSA code (or any other RSA) in production!
But the point was to learn and have fun, and that was well achieved.</p>
<p>Now if you haven&#39;t gone and played with <a href="https://www.ntietz.com/demos/bleichenbacher/">the demo</a>, please do!</p>
<hr/>





</div><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, you can email <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts and support my work, subscribe to the <a href="https://monodraw.helftone.com/newsletter/">newsletter</a>. There is also an <a href="https://monodraw.helftone.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
