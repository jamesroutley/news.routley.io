<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://udamonic.com/what-is-a-scamp.html">Original</a>
    <h1>Scamp – a self-contained Forth computer</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2023-01-18T12:55:00+00:00">January 18, 2023</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section itemprop="text">
        
        



<p><a href="https://decomposition.al/blog/2022/08/11/an-example-run-of-a-matrix-based-causal-unicast-protocol/">Last August</a>, I wrote about a <a href="https://www.sciencedirect.com/science/article/pii/0020019091900086">classic protocol published by Raynal et al. in 1991</a> for ensuring that unicast messages in a distributed system are delivered in causal order.  The Raynal et al. protocol works by queuing received messages on the recipient’s end until they’re deemed deliverable.  It determines the deliverability of a message by inspecting the causal metadata attached to the message.  This kind of <em>receiver-side enforcement</em> of causal message delivery seems to be the standard approach – for instance, <a href="https://decomposition.al/blog/2022/09/07/verified-causal-broadcast-with-liquid-haskell/">Birman et al.’s classic causal broadcast protocol</a> does something similar in the setting of <em>broadcast</em> messages.</p>

<p>In <a href="https://link.springer.com/chapter/10.1007/3-540-60042-6_14">a 1995 article</a><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>, Mattern and Fünfrocken propose an alternative approach.  Instead of eagerly sending messages and delaying delivery on the recipient’s side, their protocol delays messages on the <em>sender’s</em> side until they’re safely sendable, then unconditionally delivers messages on the recipient’s side as soon as they’re received.  This <em>sender-side</em> approach to enforcement of causally-ordered delivery seems to be rather less widely used than the receiver-side approach.  Let’s take a closer look at how the sender-side approach works and and consider the pros and cons of each.</p>

<h2 id="motivating-example-an-awkward-work-situation">Motivating example: an awkward work situation</h2>

<p>I’ll begin by briefly recapping the motivating example from <a href="https://decomposition.al/blog/2022/08/11/an-example-run-of-a-matrix-based-causal-unicast-protocol/">my post about the Raynal et al. algorithm</a>.  Suppose that Alice, Bob, and Carol work together.  One day, Alice messages Carol, saying “Let’s meet at 3pm to talk about the Foo project.”  Alice then decides that Bob should be in the meeting, too, so she messages Bob, asking, “Can you join a meeting with Carol and me at 3pm?”  Both messages go out over an asynchronous network, meaning that there’s no bound on how long they may take to arrive at their destination.  In this case, it so happens that Bob sees the message from Alice pretty quickly, and he then messages Carol: “What’s the 3pm meeting with Alice about?”  But Carol hasn’t yet heard anything from Alice about a meeting, so she’s confused.</p>

<figure>
  <img src="https://decomposition.al/assets/images/causal-unicast-1.png" alt="A violation of causal message delivery.  It could happen to you!"/>
  <figcaption>A violation of causal message delivery.  It could happen to you!</figcaption>
</figure>

<p>What went wrong here?  Alice sent a message to Carol before she sent one to Bob, so we know that her message to Carol <a href="https://en.wikipedia.org/wiki/Happened-before">happened before</a>, or <em>causally preceded</em>, her message to Bob.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>  Likewise, we know that Alice’s message to Bob happened before Bob’s message to Carol, because Bob received Alice’s message before sending one to Carol.  Because the happens-before relation is transitive, we can put those two relationships together to see that Alice’s message to Carol happened before Bob’s message to Carol – but that’s not the order Carol saw them in.  No wonder Carol is confused.</p>

<p>We can solve this problem by using a messaging protocol that ensures <em>causal message delivery</em>: if a message \(m\) happens before a message \(m&#39;\), then any process delivering both messages should deliver \(m\) before delivering \(m&#39;\).  (In distributed systems jargon, <em>delivering</em> a message is something that the process receiving the message can do.  It means taking the received message and processing it in some way, such as by handing it off to whatever application might be waiting for it, like Carol’s chat client.)</p>

<h2 id="receiver-side-and-sender-side-enforcement-of-causal-message-delivery">Receiver-side and sender-side enforcement of causal message delivery</h2>

<p>The Raynal et al. protocol uses the receiver-side approach.  It decouples message reception from message delivery: when Bob’s message arrives at Carol, the protocol delays delivery of that message until Alice’s message to Carol has been both received and delivered on Carol’s end.  Here’s a simplified visualization:</p>

<figure>
  <img src="https://decomposition.al/assets/images/receiver-side-enforcement.png" alt="An example of receiver-side enforcement of causal message delivery.  The dotted line represents the receiver-side mechanism that determines which messages need to be queued up for later delivery."/>
  <figcaption>An example of receiver-side enforcement of causal message delivery.  The dotted line represents the receiver-side mechanism that queues messages for later delivery.</figcaption>
</figure>

<p>I won’t go into details here about how the Raynal et al. algorithm works, since that’s already discussed in detail in my <a href="https://decomposition.al/blog/2022/08/11/an-example-run-of-a-matrix-based-causal-unicast-protocol/">post from last August</a>.  In a nutshell, though, the decision about whether a message is deliverable is made based on causal metadata attached to the message, which requires each participant in the system to do some extra bookkeeping.  Worse, it increases the size of each message.  In particular, in the Raynal et al. algorithm, the size of the causal metadata is \(O(n^2)\) in a system of \(n\) participants, which could quickly become prohibitively large if we need to scale up to lots of participants.</p>

<p>Mattern and Fünfrocken’s protocol takes a different approach.  Instead of delaying message delivery on the receiver’s end, it works by delaying message <em>sending</em>.  In the case of Alice, Bob, and Carol’s interaction, Alice’s message to Bob goes into an outgoing message queue, where it waits to be sent until an acknowledgment comes from Carol.  There’s therefore no chance of Bob’s message to Carol overtaking Alice’s message to Carol.  Here’s a simplified visualization:</p>

<figure>
  <img src="https://decomposition.al/assets/images/sender-side-enforcement.png" alt="An example of sender-side enforcement of causal message delivery.  The dotted line represents the sender-side mechanism that queues messages for later sending."/>
  <figcaption>An example of sender-side enforcement of causal message delivery.  The dotted line represents the sender-side mechanism that queues messages for later sending.</figcaption>
</figure>

<p>Sender-side enforcement of causal message delivery has some advantages.  We don’t need to worry about whether or not to deliver a received message – if a process gets to the point of receiving it, it’s always okay to deliver!  As a result, there’s no need to keep track of causal metadata or attach it to messages, so there’s no issue with scaling the protocol to lots of participants.  An obvious downside, though, is that having to wait for acknowledgements from message recipients could make things slow compared to the receiver-side approach.  We’ll consider this trade-off further in a bit.</p>

<h2 id="the-sender-side-protocol">The sender-side protocol</h2>

<p>In Mattern and Fünfrocken’s protocol, the key idea is that after sending a message, a process must wait for an acknowledgment before sending another message.  If we treat acknowledgments just like ordinary messages, though, this approach can lead to a deadlock, as Mattern and Fünfrocken explain.  In particular, if two processes concurrently send messages to each other, each can get stuck waiting for the other’s acknowledgment, as we can see in the following example with Alice and Bob.</p>

<figure>
  <img src="https://decomposition.al/assets/images/deadlock.png" alt="Here, Alice and Bob each send messages to each other concurrently.  Alice receives Bob&#39;s message after sending her own, but she can&#39;t send an acknowledgment to Bob because she&#39;s waiting for an acknowledgment from him.  Meanwhile, Bob receives Alice&#39;s message but can&#39;t acknowledge it because he&#39;s waiting for an acknowledgment from her.  The two processes are deadlocked."/>
  <figcaption>Here, Alice and Bob each send messages to each other concurrently.  Alice receives Bob&#39;s message after sending her own, but she can&#39;t send an acknowledgment to Bob because she&#39;s waiting for an acknowledgment from him.  Meanwhile, Bob receives Alice&#39;s message but can&#39;t acknowledge it because he&#39;s waiting for an acknowledgment from her.  The two processes are deadlocked.</figcaption>
</figure>

<p>To avoid deadlocks like this, Mattern and Fünfrocken suggest adding an <em>output buffer</em> to each process.  The output buffer is a FIFO queue where ordinary outgoing messages (that is, <em>not</em> acknowledgment messages) hang out.  Whenever a process has an ordinary message to send, the process enqueues the message in its output buffer.  The output buffer waits for messages to appear.  Whenever the buffer isn’t empty, it dequeues the next message and transmits it to its destination, then waits for an acknowledgment from the destination process before dequeuing and transmitting another message.</p>

<p>Crucially, acknowledgment messages <em>don’t</em> go through the output buffer of their sender.  They’re sent immediately, as soon as an ordinary message is received.  On the receiving end, acknowledgment messages go right to the <em>output buffer</em> of the original message’s sender, letting it know that it’s cleared to dequeue and transmit more messages, if there are any.</p>

<p>Adding this level of indirection lets us avoid deadlocks, as illustrated below:</p>

<figure>
  <img src="https://decomposition.al/assets/images/deadlock-avoidance.png" alt="With the addition of output buffers, Alice and Bob can send concurrent messages to each other without any risk of deadlock."/>
  <figcaption>With the addition of output buffers, Alice and Bob can send concurrent messages to each other without any risk of deadlock.</figcaption>
</figure>

<p>In Mattern and Fünfrocken’s paper, the setup is a bit more complicated than this: each process also has an explicit <em>input buffer</em>, another FIFO queue that hands incoming messages off to the process and is responsible for transmitting acknowledgments back to their senders.  In other words, the “main thread” of the process doesn’t do any external communication; the input and output buffers handle it all.  In real life, something like Mattern and Fünfrocken’s input buffer would certainly exist at some level of the networking stack.  In this post, though, I’m leaving the input buffers out of the diagrams to keep the discussion simple, essentially collapsing their functionality into the main thread.  (I’m not pulling any sneaky tricks here; keep in mind that the input buffer doesn’t need to do anything smart to check whether a message’s causal dependencies have been satisfied, as would be necessary in receiver-side enforcement of causal delivery.  Rather, it’s merely a FIFO queue that also sends an ack whenever a message gets dequeued.)</p>

<p>With output buffers in place, we can see how Mattern and Fünfrocken’s protocol avoids the awkward work situation we saw earlier.  Alice’s outgoing messages go into her output buffer, and her message to Carol can be transmitted over the network right away.  However, Alice’s message to Bob has to sit in her output buffer until she’s gotten an acknowledgment that Carol has received (and delivered) her first message.  Only then can Alice’s second message be transmitted to Bob.  Because Bob’s “What’s the meeting about?” message to Carol is caused by Alice’s message to Bob, that message is naturally also sent later, and so there’s no risk of it overtaking Alice’s message to Carol.  Everyone’s messages can always be delivered as soon as they show up on the receiving end.  Here’s what the whole execution looks like:</p>

<figure>
  <img src="https://decomposition.al/assets/images/sender-side-enforcement-detail.png" alt="With the sender-side approach, Alice&#39;s message to Bob is delayed until Alice gets an ack from Carol, which in turn delays the sending of Bob&#39;s message, so there&#39;s no chance of Carol getting Bob&#39;s message out of causal order."/>
  <figcaption>With the sender-side approach, Alice&#39;s message to Bob is delayed until Alice gets an ack from Carol, which in turn delays the sending of Bob&#39;s message, so there&#39;s no chance of Carol getting Bob&#39;s message out of causal order.</figcaption>
</figure>

<p>And that’s all there is to it!  Just by instituting a simple “don’t send a message until you get an acknowledgment of the last one you sent” policy, we get causal order, without any need to track causal metadata and attach it to messages.</p>

<h2 id="but-isnt-this-kind-ofslow">But isn’t this kind of…slow?</h2>

<p>Yep!</p>

<p>The reason the sender-side approach does the job is because it approximates <em>synchronous</em> communication on top of an asynchronous network.  It’s well known that synchronous communication is stronger than causal communication (that is, synchronous executions are a subset of causal executions)<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>, and so any approach that gives you synchronous communication gives you causal communication for free.</p>

<p>That’s also the weakness of the sender-side approach, though – it’s more conservative than necessary.  In particular, the protocol is “pessimistic” in the sense that Alice’s message to <em>Bob</em> gets delayed, even though it wouldn’t be a violation of causal delivery for it to be delivered earlier.  The receiver-side approach is “optimistic” in the sense that it goes ahead and sends messages whenever, and leaves it to the receving end to sort it out.</p>

<p>Lately, my students and I have been thinking about ways to modify the sender-side approach to regain some of the optimism of the receiver-side approach, while keeping the lack of metadata overhead that the sender-side approach enjoys.  One reason to do this: suppose Bob has a time-consuming task to do as a result of receiving a message from Alice, and which needs to be done before he can take further actions (like talking to Carol).  If that’s the case, then the delay imposed by the sender-side approach <em>especially</em> sucks, because it prevents Bob from getting started on the time-consuming task.</p>

<figure>
  <img src="https://decomposition.al/assets/images/sender-side-enforcement-long-running-task.png" alt="If Bob has a long-running task to do as a result of getting Alice&#39;s message, then the conservativeness of the sender-side approach seems especially bad.  It would be better if Bob could get started on the long-running task sooner."/>
  <figcaption>If Bob has a long-running task to do as a result of getting Alice&#39;s message, then the conservativeness of the sender-side approach seems especially bad.  It would be better if Bob could get started on the long-running task sooner.</figcaption>
</figure>

<p>It’d be nice if Bob could get started on any time-consuming tasks optimistically, with a solemn promise to not tell anyone about the result until Alice has told him that it’s okay.</p>

<h2 id="a-can-you-keep-a-secret-protocol">A “can you keep a secret?” protocol</h2>

<p>To that end, here’s a slight tweak to the Mattern and Fünfrocken protocol.  In our example execution, things start out the same as before: Alice queues up her message to Carol, and it gets transmitted right away.</p>

<p>Alice then queues up her message to Bob.  This is where things differ from the original protocol: because the destination of this message differs from that of the previous, thus far unacknowledged message, Alice does what we’ll call an <em>eager send</em>: she sends the message with a caveat that the receiver cannot take any externally observable actions, such as sending messages, until it gets a follow-up from Alice that says it’s okay.  (Messages back <em>to Alice</em>, however, are fine.)</p>

<p>When Bob gets Alice’s message, he can get started on any time-consuming tasks right away.  When Alice has received both the acknowledgment of her eager send <em>and</em> the acknowledgment of her previous normal send, she sends another message to Bob that says, essentially, “OK, now you can tell.”  At that point, Bob can send messages or do whatever he wants.</p>

<figure>
  <img src="https://decomposition.al/assets/images/sender-side-secret.png" alt="In this tweak to the sender-side protocol, participants can send messages eagerly and later follow them up with a now-you-can-tell message.  This way, Bob can get started on his long-running task, as long as he doesn&#39;t tell Carol about it before Alice gives him the go-ahead."/>
  <figcaption>In this tweak to the sender-side protocol, participants can send messages eagerly and later follow them up with a now-you-can-tell message.  This way, Bob can get started on his long-running task, as long as he doesn&#39;t tell Carol about it before Alice gives him the go-ahead.</figcaption>
</figure>

<p>In a nutshell: if a message in the output buffer has a different destination than preceding messages in the output, then it can be “eagerly” sent and later followed up with a “now you can tell” message. The receiver cannot send any messages (except back to the eager sender) until receiving the “now you can tell” message, but it may take internal actions and receive messages.</p>

<p><strong>Is this a done thing?</strong>  If there are existing protocols that use this kind of “here you go, but don’t tell yet”/”now you can tell” approach, I’d be interested to hear about it!</p>

<h2 id="some-design-considerations">Some design considerations</h2>

<p>Here are a couple of things to consider when designing a “can you keep a secret?” protocol:</p>

<ul>
  <li>Should a recipient acknowledge eagerly sent messages right away, or wait until it gets the “now you can tell” message to send an ack?  My answer: I think it has to  be immediate, because we need to make sure the now-you-can-tell message doesn’t overtake the eagerly sent message, so we should wait until getting an ack for the eagerly sent message before sending the now-you-can-tell message.</li>
  <li>Can you do an eager send as a result of an eager send?  Consider what would happen here when Bob gets done processing Alice’s message and then queues up his own to send.  If Bob could eagerly send a message to Carol, it could overtake Alice’s message on the way to Carol, which is the violation of causal delivery that we wanted to prevent in the first place.  So I’m inclined to say that no, you can’t do an eager send as a result of an eager send.  (On the other hand: if Carol does get an eager send from Bob too soon, consider what she’s allowed to do as a result.  She can’t take any externally observable actions!  So it’s not like anyone can <em>find out</em> that she got the message out of causal order.  If a message violates causal delivery in the forest and nobody hears it, does it make a sound?)</li>
  <li>Okay, let’s say you can’t do an eager send as a result of an eager send.  When a process wants to send a message as a result of an eager send it previously received, should the new message go into the output buffer while waiting for the now-you-can-tell message, or should it not even be buffered yet?  This I’m not sure about.</li>
  <li>A downside of the “can you keep a secret?” approach seems to be that it creates more message traffic.  As a PL person, I can’t help but think that some sort of language-based <a href="https://en.wikipedia.org/wiki/Information_flow_(information_theory)">information flow</a> analysis could be helpful here.  If Alice is sending two messages and an analysis can determine that they are in fact <em>not</em> related, then it seems that she ought to be able to send the second without regard to whether she’s heard back about the first.  The bigger issue here is that the standard happens-before relation is quite coarse, and relates a lot of messages that in reality are not causally related, and just happened to be sent in a given order for some arbitrary reason.  We use happens-before because it’s a reasonable overapproximation of <em>actual</em> causality that’s relatively easy to compute.  But if we can get some input from the language level on what secrets actually need to be kept, maybe we can use a “can you keep a secret?” protocol judiciously.  (If you’re interested in working on this stuff, let me know!)</li>
</ul>



        
      </section>

      

      

      
  <nav>
    
      <a href="https://decomposition.al/blog/2022/12/20/course-announcement-distributed-software-systems-global-first-and-local-first-perspectives/" title="Course announcement: Distributed Software Systems: Global-First and Local-First Perspectives
">Previous</a>
    
    
      <a href="#">Next</a>
    
  </nav>

    </div></div>
  </body>
</html>
