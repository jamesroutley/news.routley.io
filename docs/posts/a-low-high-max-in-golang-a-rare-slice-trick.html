<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://build-your-own.org/blog/20230316_go_full_slice/">Original</a>
    <h1>a[low:high:max] in Golang – A Rare Slice Trick</h1>
    
    <div id="readability-page-1" class="page"><div>
<h2 id="introduction">01. Introduction</h2>
<p>The usual slice syntax in Golang is <code>a[low:high]</code>, which
you are probably familiar with. There is also another <a href="https://go.dev/ref/spec#Slice_expressions">slice syntax</a> in the
form of <code>a[low:high:max]</code>, which takes three indexes instead
of two. What does the 3rd index <code>max</code> do? Hint: It is not the
<code>step</code> index in the Python slice syntax
<code>a[low:high:step]</code>.</p>
<p>Answer: The 3rd index is for setting the capacity of the slice! It is
called a “full slice expression” in the Golang specification.</p>
<h2 id="understanding-golang-slices">02. Understanding Golang
Slices</h2>
<p>To understand why this was added to Golang and how it is useful,
let’s start with arrays and pointers.</p>
<p>Out-of-bounds errors are common in C programs, and Golang mitigates
this problem by having built-in runtime bounds checkers. Bounds checking
for arrays is simple because Golang arrays are of fixed length, however,
bounds checking for pointers is not so simple, because the bounds of
pointers are not explicitly defined. Slices in Golang are just one
solution to bounds checking for pointers.</p>
<p>Instead of using plain pointers to access array elements, Golang
augments pointers with a length field; the result (pointer-with-length)
is then called a “slice”, or “fat pointer” elsewhere. With the length
field, runtime bounds checking is easy.</p>
<p>Golang slices are not just pointer-with-length, they also have a
“capacity” field, because growing a dynamically allocated array is such
a common task. And the capacity of a slice also acts as a bounds checker
for the slice expression <code>a[low:high]</code> — the end of a slice
cannot exceed its capacity.</p>
<h2 id="understanding-alowhighmax">03. Understanding
<code>a[low:high:max]</code></h2>
<p>The slice index expressions are bounds-checked by the length field,
and the length field can be reduced by slicing to provide the desired
bounds-checking.</p>
<p>Likewise, one might wonder if it is possible to reduce the capacity
of a slice to tighten the bounds check for the slice expression
<code>a[low:high]</code>. For example, the following expression reduces
the capacity of a slice to its length:</p>

<p>After this, the slice <code>a</code> is restricted to itself, the
elements past the end of the slice cannot be accessed or modified, even
if you accidentally re-slice or <code>append</code> to it.</p>
<p>This trick is useful for returning a slice from an immutable array;
if you accidentally <code>append</code> to the supposedly immutable
slice, a copy is forced and no data is overwritten because there is no
more capacity left.</p>
<p>This form of slice expression is called a “full slice expression” in
the Golang <a href="https://go.dev/ref/spec#Slice_expressions">specification</a>.</p>
</div></div>
  </body>
</html>
