<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/juspay/hyperswitch/wiki/Ask-not-what-the-compiler-can-do-for-you">Original</a>
    <h1>Ask not what the compiler can do for you</h1>
    
    <div id="readability-page-1" class="page"><div data-view-component="true">          <div id="wiki-body">
              <div>
                <blockquote>
<p>By Sampras Lopes, Nishant Joshi &amp; Sanchith Hegde</p>
</blockquote>
<p>Everyone knows that Rust is the language of the gods. Here’s how we still managed to shoot ourselves in the foot. We were gearing up for a release and had just deployed to our internal test environment. We were not particularly seeking any adventure that evening but our application promptly crashed. We checked the logs to quickly find out that we had reached the thread stack limit.</p>
<p>On redeploying after enabling backtraces(RUST_BACKTRACE = 1), we learnt that Rust does not print a backtrace for stack overflows. Completely clueless, we rolled back to the latest stable version.</p>
<p>The code was working fine locally. So, we tried reproducing the issue in another test environment, the failures were intermittent and random, adding to our woes. We decided to get our hands dirty and run the code on <code>rust-lldb</code> with restricted stack size. After multiple runs, we saw some of the frames had many KBs of stack usage.</p>
<p>We tried bisecting through the commits and after a long agonizing wait, were able to locate the commit causing the issue.</p>
<h2><a id="user-content-dormammu-ive-come-to-bargain" aria-hidden="true" href="#dormammu-ive-come-to-bargain"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Dormammu, I&#39;ve Come to Bargain</h2>
<p>We reached the offending function and as it turned out, the bug was literally one word long. See if you can spot it.</p>
<p>Consider the example below:</p>
<div data-snippet-clipboard-copy-content="struct PsqlWrapper;

struct KafkaWrapper {
	inner: PsqlWrapper
}

#[async_trait::async_trait]
trait DBInterface {
	async fn do_something_first(&amp;self);
	async fn do_something_second(&amp;self);
}

#[async_trait::async_trait]
impl DBInterface for PsqlWrapper {
	async fn do_something_first(&amp;self) {
		// Do some Psql related stuff
	}
	async fn do_something_second(&amp;self) {
		// Do some Psql related stuff
	}
}

#[async_trait::async_trait]
impl DBInterface for KafkaWrapper {
	async fn do_something_first(&amp;self) {
		// Do some kafka related stuff ...
		self.inner.do_something_first().await
	}


	async fn do_something_second(&amp;self) {
		self.do_something_second().await
	}
}"><pre><span>struct</span> <span>PsqlWrapper</span><span>;</span>

<span>struct</span> <span>KafkaWrapper</span> <span>{</span>
	<span>inner</span><span>:</span> <span>PsqlWrapper</span>
<span>}</span>

<span>#<span>[</span>async_trait<span>::</span>async_trait<span>]</span></span>
<span>trait</span> <span>DBInterface</span> <span>{</span>
	<span>async</span> <span>fn</span> <span>do_something_first</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span>;</span>
	<span>async</span> <span>fn</span> <span>do_something_second</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span>;</span>
<span>}</span>

<span>#<span>[</span>async_trait<span>::</span>async_trait<span>]</span></span>
<span>impl</span> <span>DBInterface</span> <span>for</span> <span>PsqlWrapper</span> <span>{</span>
	<span>async</span> <span>fn</span> <span>do_something_first</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>{</span>
		<span>// Do some Psql related stuff</span>
	<span>}</span>
	<span>async</span> <span>fn</span> <span>do_something_second</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>{</span>
		<span>// Do some Psql related stuff</span>
	<span>}</span>
<span>}</span>

<span>#<span>[</span>async_trait<span>::</span>async_trait<span>]</span></span>
<span>impl</span> <span>DBInterface</span> <span>for</span> <span>KafkaWrapper</span> <span>{</span>
	<span>async</span> <span>fn</span> <span>do_something_first</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>{</span>
		<span>// Do some kafka related stuff ...</span>
		<span>self</span><span>.</span><span>inner</span><span>.</span><span>do_something_first</span><span>(</span><span>)</span><span>.</span><span>await</span>
	<span>}</span>


	<span>async</span> <span>fn</span> <span>do_something_second</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>{</span>
		<span>self</span><span>.</span><span>do_something_second</span><span>(</span><span>)</span><span>.</span><span>await</span>
	<span>}</span>
<span>}</span></pre></div>
<p>We have 2 structs here. The <code>PsqlWrapper</code> is a struct that allows us to connect to the Postgres Database. In addition, we implemented a <code>KafkaWrapper</code> around the <code>PsqlWrapper</code>. Inside the <code>KafkaWrapper</code>, we generated a kafka event where needed, and intended to call the underlying function from the  <code>PsqlWrapper</code>. So, we just used <code>PsqlWrapper</code> as a field within <code>KafkaWrapper</code>.</p>
<p>But instead of calling the function from the <code>PsqlWrapper</code>, we ended up calling the one from the <code>KafkaWrapper</code>. So, the fix here was simple.</p>
<div data-snippet-clipboard-copy-content="- // Instead of
- self.do_something_second().await
+ // It should be
+ self.inner.do_something_second().await"><pre>- <span>// Instead of</span>
- <span>self</span><span>.</span><span>do_something_second</span><span>(</span><span>)</span><span>.</span><span>await</span>
+ <span>// It should be</span>
+ <span>self</span><span>.</span><span>inner</span><span>.</span><span>do_something_second</span><span>(</span><span>)</span><span>.</span><span>await</span></pre></div>
<p>We caused an unconditional recursion unbeknownst to the Rust compiler. What?</p>
<p>There was no reason to suspect the Kafka wrapper because the failing API relied on <code>do_something_second</code> which we knew didn’t add any logic at all. We also used the <code>PsqlWrapper</code> directly in the local setup. That’s why it worked fine locally.</p>
<h2><a id="user-content-whos-to-blame-here" aria-hidden="true" href="#whos-to-blame-here"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Who’s to blame here?</h2>
<p>Mostly us, but we wanted to understand how this evaded the ever watchful rust compiler. In cases of unconditional recursion, Rust provides us with a helpful warning indicating that there is a recursion. But, in this case neither Rust nor Clippy gave us any hint. Why is that the case? Is it because of <code>async</code>? turns out, it isn’t. In the case of <code>async</code>, Rust is quite strict. It throws an error at compile time. How did rust fail to catch this problem? It&#39;s how the async is implemented here that allowed the issue to sneak through.</p>
<p><code>async_trait</code> is the second culprit under investigation. Currently, Rust on its own doesn’t support async traits, so someone came up with a clever way to achieve it. (GG <code>dtolnay/async_trait</code>). They used the <code>dyn Future</code>. Fun fact, Rust itself recommends using the <code>dyn Future</code> if we want to achieve recursion. However Rust doesn’t warn us about unconditional_recursion when we use it.</p>
<div data-snippet-clipboard-copy-content="async fn do_something() {
    do_something().await;
}

/*
error[E0733]: recursion in an `async fn` requires boxing
  --&gt; src/main.rs:10:25
   |
10 | async fn do_something() {
   |                         ^ recursive `async fn`
   |
   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`
   = note: consider using the `async_recursion` crate:[ https://crates.io/crates/async_recursion](https://crates.io/crates/async_recursion)
*/"><pre><span>async</span> <span>fn</span> <span>do_something</span><span>(</span><span>)</span> <span>{</span>
    <span>do_something</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span>
<span>}</span>

<span>/*</span>
<span>error[E0733]: recursion in an `async fn` requires boxing</span>
<span>  --&gt; src/main.rs:10:25</span>
<span>   |</span>
<span>10 | async fn do_something() {</span>
<span>   |                         ^ recursive `async fn`</span>
<span>   |</span>
<span>   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`</span>
<span>   = note: consider using the `async_recursion` crate:[ https://crates.io/crates/async_recursion](https://crates.io/crates/async_recursion)</span>
<span>*/</span></pre></div>
<p>If you’re curious, here’s the general idea behind how async_trait (the crate) achieves async trait (the behavior). It takes a function that returns <code>impl Future&lt;Output = …&gt;</code> and converts it into <code>Pin&lt;Box&lt;dyn Future&lt;Output = …&gt;&gt;&gt;</code>. This acts like a concrete type and Rust allows it to be the return type of a function inside traits.</p>
<p>(<code>Pin&lt;Box&lt;...&gt;&gt;</code> just pins the internal value to a specific location in memory, and prevents it from moving)</p>
<p>A function that returns an <code>impl Future</code>:</p>
<div data-snippet-clipboard-copy-content="fn do_something() -&gt; impl Future&lt;Output = ()&gt; {
    async { do_something().await }
}

/*
error[E0720]: cannot resolve opaque type
 --&gt; src/main.rs:7:22
  |
7 | fn do_something() -&gt; impl Future&lt;Output = ()&gt; {
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type
8 |     async { do_something().await }
  |     ------------------------------
  |     |       |
  |     |       async closure captures itself here
  |     returning here with type `[async block@src/main.rs:8:5: 8:35]`
*/"><pre><span>fn</span> <span>do_something</span><span>(</span><span>)</span> -&gt; <span>impl</span> <span>Future</span><span>&lt;</span><span>Output</span> = <span>(</span><span>)</span><span>&gt;</span> <span>{</span>
    <span>async</span> <span>{</span> <span>do_something</span><span>(</span><span>)</span><span>.</span><span>await</span> <span>}</span>
<span>}</span>

<span>/*</span>
<span>error[E0720]: cannot resolve opaque type</span>
<span> --&gt; src/main.rs:7:22</span>
<span>  |</span>
<span>7 | fn do_something() -&gt; impl Future&lt;Output = ()&gt; {</span>
<span>  |                      ^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type</span>
<span>8 |     async { do_something().await }</span>
<span>  |     ------------------------------</span>
<span>  |     |       |</span>
<span>  |     |       async closure captures itself here</span>
<span>  |     returning here with type `[async block@src/main.rs:8:5: 8:35]`</span>
<span>*/</span></pre></div>
<p>A function that returns a <code>dyn Future</code>:</p>
<div data-snippet-clipboard-copy-content="fn do_something() -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; {
    Box::pin(async { do_something().await })
}

/*
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
*/"><pre><span>fn</span> <span>do_something</span><span>(</span><span>)</span> -&gt; <span>Pin</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>dyn</span> <span>Future</span><span>&lt;</span><span>Output</span> = <span>(</span><span>)</span><span>&gt;</span><span>&gt;</span><span>&gt;</span> <span>{</span>
    <span>Box</span><span>::</span><span>pin</span><span>(</span><span>async</span> <span>{</span> <span>do_something</span><span>(</span><span>)</span><span>.</span><span>await</span> <span>}</span><span>)</span>
<span>}</span>

<span>/*</span>
<span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s</span>
<span>*/</span></pre></div>
<p>However, it’s clear that this is something that was overlooked while writing as well as reviewing our code. Got to love a language that makes you trust it so much. So, when we talk about Rust being very secure, there comes a point where one must ponder about just how much responsibility we can leave on the compiler. Even with all the brilliant features that the compiler provides there are always some things that the compiler might not catch. This is where the precision of the developer and the keen eye of the reviewer matter the most.</p>
<hr/>
<ul>
<li>Want to contribute? Check out some of our <a href="https://github.com/juspay/hyperswitch/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">good first issues here.</a>
</li>
<li>Try Hyperswitch. <a href="https://app.hyperswitch.io/" rel="nofollow">Get your API keys here.</a>
</li>
</ul>

              </div>

          </div>
</div></div>
  </body>
</html>
