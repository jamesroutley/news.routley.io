<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dbos.dev/blog/durable-queues">Original</a>
    <h1>I solved a distributed queue problem after 15 years</h1>
    
    <div id="readability-page-1" class="page"><div><p>When I was responsible for the infrastructure at Reddit, the most important thing I maintained was Postgres, but a close second was RabbitMQ, our message broker. It was essential to the operation of reddit — everything went into a distributed queue before it went to a database. For example, if you upvoted a post, that was written to the queue and the cache, and then returned success to the user. Then a queue runner would take that item, and attempt to write it to the database as well as create a new work item to recalculate all the listings that upvote affected.</p><p>We used this task queue architecture because it was simple and scalable with powerful features:</p><ul role="list"><li><strong>Horizontal scalability</strong>. Task queues let us run many tasks in parallel, utilizing the resources of many servers. They were also fairly simple to scale–just add more workers.</li><li><strong>Flow control</strong>. With task queues, we could customize the rate at which workers consume tasks from different queues. For example, for resource-intensive tasks, we could limit the number of those tasks that can run concurrently on a single worker. If a task accesses a rate-limited API, we could limit how many tasks are executed per second to avoid overwhelming the API. </li><li><strong>Scheduling</strong>. Task queues let us define when or how often a task runs. For example, we could run tasks on a cron schedule, or schedule tasks to execute some time in the future.</li></ul><p>This system scaled well, but it could break in all sorts of tricky ways. If the databases for votes were down, the item would have to go back onto the queue. If the listings cache was down, the listings couldn’t get recalculated. If the queue processor crashed after it had taken the item but before it acted on it, the data was just lost. And if the queue itself went down, as it was prone to do, we could just lose votes, or comments, or submissions (did you ever think “I know I voted on that but it’s gone!” when using reddit?  That’s why).</p><p>What we really needed to make distributed task queueing robust are <strong>durable queues</strong> that checkpoint the status of our queued tasks to a durable store like Postgres. With a durable queue, we could have resumed failed jobs from their last completed step and we wouldn’t have lost data when there were program crashes.</p><p>Durable queues were rare when I was at Reddit, but they’re more and more popular now. Essentially, they work by combining task queues with durable workflows, helping you <strong>reliably orchestrate workflows of many parallel tasks</strong>. Architecturally, durable queues closely resemble conventional queues, but use a persistent store (typically a relational database) as both message broker and backend:</p><figure><p><img src="https://cdn.prod.website-files.com/672411cbf038560468c9e68f/68b7c9f14b71a122d3861644_Durable-Queues-Diagram.png" loading="lazy" alt="How to make queues durable"/></p></figure><p>The core abstraction in durable queues is a <strong>workflow</strong> of many tasks. For example, you can submit a document processing task that splits a document into pages, processes each page in parallel in separate tasks, then postprocesses and returns the results:</p><figure><p><img src="https://cdn.prod.website-files.com/672411cbf038560468c9e68f/68b7bf757d45df00d5753d88_fbbbe73e.png" loading="lazy" alt="durable queueing library for python"/></p></figure><p>Durable queues work by <strong>checkpointing</strong> workflows in their persistent store. When a client submits a task, the task and its inputs are recorded. Then, whenever that task invokes another task, this subtask and its inputs is recorded as a <strong>child </strong>of its caller. Thus, the queue system has a complete persistent record of all tasks and their relationships.</p><p>These workflows are most relevant when recovering from failures. If a non-durable worker is interrupted while executing a task, the queue restarts it from the beginning at best, or loses the task at worst. This isn’t ideal for long-running workflows or tasks with critical data. Instead, when a durable queue system recovers a workflow, it looks up its checkpoints to recover from the <strong>last completed step</strong>, avoiding resubmission of any completed work.</p><p>‍</p><h3>Durable Queues and Observability</h3><p>Another advantage of durable queues is <strong>built-in</strong> <strong>observability</strong>. Because they persist detailed records of every workflow and task that was ever submitted, durable queues make it easy to monitor what queues and workflows are doing at any given time. For example, looking up the current contents of a queue (or any past content) is just a SQL query. Similarly, looking up the <a href="https://www.dbos.dev/blog/why-workflows-should-be-postgres-rows">current status of a workflow is another SQL query</a>. </p><p>‍</p><h3>Durable Queueing Tradeoffs</h3><p>So, when should you use durable queues? As always, the answer comes down to <strong>tradeoffs</strong>. For durable queues, the main tradeoff is around <strong>message broker performance</strong>. Most distributed task queues use an in-memory key-value store like Redis for brokering messages and storing task outputs. However, durable queues need to use a durable store, often a relational database like Postgres, as both message broker and backend. The latter provides stronger guarantees, but the former higher throughput. Thus, you should prefer durable queues when handling a lower volume of larger business-critical tasks and distributed task queues when handling a very large volume of smaller tasks.</p><p>‍</p><h3>Additional Reading</h3><ul role="list"><li><a href="https://www.dbos.dev/case-studies/dosu">Dosu</a> - migrating queuing from Celery to DBOS</li><li><a href="https://www.dbos.dev/case-studies/bms">Bristol Myers Squibb</a> - durable, observable horizontal scaling of genomic data pipelines with DBOS</li><li><a href="https://www.dbos.dev/case-studies/ai-powered-causal-reasoning">cStructure</a> - migrating queuing from Celery to DBOS</li><li><a href="https://docs.dbos.dev/python/reference/queues">DOCS: DBOS durable queuing</a></li></ul></div></div>
  </body>
</html>
