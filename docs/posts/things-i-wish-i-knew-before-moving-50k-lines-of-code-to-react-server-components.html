<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mux.com/blog/what-are-react-server-components">Original</a>
    <h1>Things I wish I knew before moving 50K lines of code to React Server Components</h1>
    
    <div id="readability-page-1" class="page"><div><p>React Server Components are a lot. We recently <a href="https://miles.land/blog/the-building-blocks-of-great-docs">rethought our docs</a> and <a href="https://miles.land/blog/rebranding-during-a-recession">rebranded Mux</a> and, while we were at it, moved all of <a href="https://miles.land/">mux.com</a> and <a href="https://docs.mux.com">docs.mux.com</a> over to Server Components. So… believe me. I know. I also know that it’s possible and not that scary and probably worth it.</p><p>Let me show you why by answering the following questions: <a href="#how-did-we-get-here">Why do Server Components matter</a>, and <a href="#what-are-react-server-components-what-are-they-good-for">what are they good for</a>? <a href="#what-arent-react-server-components-good-for">What are they not good for</a>? <a href="#how-do-i-use-react-server-components">How do you use them</a>, <a href="#how-do-i-incrementally-adopt-react-server-components-in-a-real-life-codebase">how do you incrementally adopt them</a>, and <a href="#did-someone-say-advanced-patterns">what kind of advanced patterns should you use</a> to keep them under control? By the end of all this, you should have a pretty good idea of <a href="#so-should-i-use-react-server-components">whether you should use React Server Components</a> and how to use them effectively.</p><h2 id="how-did-we-get-here"><a href="#how-did-we-get-here"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>How did we get here?</strong></a></h2><p>One great way to understand React Server Components is to understand what problem they’re solving. So let’s start there.</p><p>Long ago, in days of yore, we generated websites on servers using tech like PHP. This was great for fetching data by using secrets and doing CPU-heavy work on big computers so that clients could just get a nice, light HTML page, personalized to them.</p><p>Then, we started wondering: What if we wanted faster responses and more interactivity? Every time a user takes an action, do we <em>really</em> want to send cookies back to the server and make the server generate a whole new page? What if we made the client do that work instead? We can just send all the rendering code to the client as JavaScript!</p><p>This was called client-side rendering (CSR) or single-page applications (SPA) and was <a href="https://begin.com/blog/posts/2023-02-21-why-does-everyone-suddenly-hate-single-page-apps">widely considered a bad move</a>. Sure, it’s simple, which is worth a lot! In fact, for a long time, the React team recommended it as the default approach with their tool, <a href="https://create-react-app.dev/">create-react-app</a>. And for frequently changing, highly interactive pages like a dashboard, it’s probably enough. But what if you want a search engine to read your page, and that search engine doesn’t execute JavaScript? What if you need to keep secrets on a server? What if your users’ devices are low-powered or have poor connections (<a href="https://unctad.org/topic/least-developed-countries/chart-april-2021">as so many do</a>)?</p><p>This is where server-side rendering (SSR) and static site generation (SSG) came in. Tools like <a href="https://nextjs.org/">Next.js</a> and <a href="https://www.gatsbyjs.com/">Gatsby</a> used SSR and SSG to generate the pages on the server and send them to the client as HTML <em>and</em> JavaScript. The best of both worlds. The client can immediately show that HTML so the user has something to look at. Then, once the JS loads, the site becomes nice and interactive. Bonus: search engines can read that HTML, which is cool.</p><p>This is actually quite good! But there are still a few problems to solve. First: most SSR/SSG approaches send <em>all the JavaScript used to generate the page</em> to the client, where the client then <em>runs it all again</em> and marries that HTML with the JavaScript that just booted up. (This marriage, by the way, is called hydration — a term you’ll see a lot in this neck of the woods.) Do we really need to send and run all that JavaScript? Do we really need to duplicate all of the rendering work just to hydrate?</p><p>Second, what if that server-side render takes a long time? Maybe it runs a lot of code, maybe it’s stuck waiting for a slow database call. Then the user’s stuck waiting. Bummer.</p><p>This is where React Server Components come in.</p><h2 id="what-are-react-server-components-what-are-they-good-for"><a href="#what-are-react-server-components-what-are-they-good-for"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>What are React Server Components? What are they good for?</strong></a></h2><p>React Server Components (RSCs) are, unsurprisingly, React components that run on the server instead of on the client. The “what” isn’t nearly as interesting as the “why,” though. Why do we want RSCs? Well, frameworks that support RSCs have two big advantages over SSR.</p><p>First, frameworks that support RSCs give us a way to define where our code runs: what needs to run <em>only</em> on the server (like in the good ol&#39; PHP days) and what should run on the client (like SSR). These are called Server Components and Client Components, respectively. Because we can be explicit about where our code runs, we can send less JavaScript to the client, leading to smaller bundle sizes and less work during hydration.</p><p>The second advantage of RSC-driven frameworks: Server Components can fetch data <em>directly from within the component</em>. When that fetch is complete, Server Components can <em>stream</em> that data to the client.</p><p>This new data-fetching story changes things in two ways. First, fetching data in React is way easier to think about now. Any Server Component can just… fetch data directly using a node library or using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch"><span>fetch</span></a> function we all know and love. Your user component can fetch user data, your movie component can fetch movie data, and so on and so forth. No more using a library or using <a href="https://react.dev/reference/react/useEffect#fetching-data-with-effects"><span>useEffect</span></a> to manage complex loading states (<a href="https://tanstack.com/query/v3/">react-query</a> I still love you), and no more fetching a bunch of data at the page level with <a href="https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props"><span>getServerSideProps</span></a> and then drilling it down to the component that needs it.</p><p>Second, it solves the problem we talked about earlier. Slow database call? No need to wait; we’ll just send that slow component to the client when it’s ready. Your users can enjoy the rest of the site in the meantime.</p><p>Bonus round: What if you need to fetch data on the server in response to a user’s action on the client (like a form submission)? We have a way to do that, too. The client can send data to the server, and the server can do its fetching or whatever, and stream the response back to the client just like it streamed that initial data. This two-way communication isn&#39;t <em>technically</em> React Server Components — this is <a href="https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions#actions">React Actions</a> — but it’s built on the same foundation and is closely related. We’re not going to talk much about React Actions here, though. Gotta save something for <a href="https://miles.land/blog/what-are-react-server-actions">the next blog post.</a></p><h2 id="what-arent-react-server-components-good-for"><a href="#what-arent-react-server-components-good-for"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>What <em>aren’t</em> React Server Components good for?</strong></a></h2><p>Up until now, I’ve been painting a pretty rosy picture. If RSCs are so much better than CSR and SSR, why <em>wouldn’t</em> you use them? I was wondering the same thing, and I learned the hard way — as the title of this post suggests — that there is indeed a catch. A few, actually. Here are the three things we spent the most time on when migrating to React Server Components.</p><h3 id="css-in-js-is-a-nonstarter"><a href="#css-in-js-is-a-nonstarter"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>CSS-in-JS is a nonstarter</strong></a></h3><p>Turns out that, as of right now, CSS-in-JS <a href="https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration#step-7-styling">doesn’t work in Server Components</a>. This one hurt. Moving from <a href="https://styled-components.com/">styled-components</a> to <a href="https://tailwindcss.com/">Tailwind CSS</a> was probably the biggest part of our RSC conversion, although <a href="https://miles.land/blog/the-building-blocks-of-great-docs#tailwind-css">we thought it was worth the trouble</a>.</p><p>So, if you went all-in on CSS-in-JS, you’ve got some work to do. At least it’s a great opportunity to migrate to something better, right?</p><h3 id="react-context-doesnt-work-in-server-components"><a href="#react-context-doesnt-work-in-server-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>React Context doesn’t work in Server Components</strong></a></h3><p>You can access <a href="https://react.dev/learn/passing-data-deeply-with-context">React Context</a> <a href="https://nextjs.org/docs/getting-started/react-essentials#rendering-third-party-context-providers-in-server-components"><em>only</em> in Client Components</a>. If you want to share data between Server Components without using props, you’ll probably have to use plain ol&#39; <a href="https://nextjs.org/docs/getting-started/react-essentials#sharing-data-between-server-components">modules</a>.</p><p>And here’s the kicker: If you want some sort of data to be limited to a <em>subtree</em> of your React application, there is no great mechanism for doing that in Server Components. (If I&#39;m wrong, please correct me. I really miss this.)</p><p>On our docs site, this wasn’t too big of a problem. The places where we used React Context heavily were also the places that were highly interactive and needed to be shipped to the client anyway. Our search experience, for example, shares state like <span>queryString</span> and <span>isOpen</span> throughout the component tree.</p><p>On our marketing site, though, this really got us. Our marketing site has areas that share a theme. For example, in the screenshot below, each component in our pre-footer needs to understand that it is on a green background so it knows to use the dark green border. Normally, I would’ve reached for Context to share that theme state, but since these are largely static components that are ideal candidates for Server Components, Context wasn’t an option. We worked around this by leaning hard on <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">CSS custom properties</a> (which is probably better, since this is a styling concern, not a data concern). But other developers may not be so lucky.</p><h3 id="honestly-its-hard-to-keep-everything-in-your-head-all-at-once"><a href="#honestly-its-hard-to-keep-everything-in-your-head-all-at-once"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>Honestly, it’s hard to keep everything in your head all at once</strong></a></h3><p>Fundamentally, RSCs give you more flexibility about where your code runs and what your data fetching looks like. <strong>With flexibility comes complexity</strong>. No tool can completely <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">paint over this complexity</a>, so at some point, you’re going to have to understand it and confront it and communicate it to other developers.</p><p>Every time a new developer picked up our codebase, the questions came up: “What’s running on the server? What’s running on the client?” Every PR had feedback regarding something accidentally/unnecessarily shipped to the client. I frequently added console logs to my code to see if the server or the client would do the logging. And don’t even get me started on the complexity of <a href="https://nextjs.org/docs/app/building-your-application/data-fetching/caching">caching</a>.</p><p>This has gotten better with practice and with reliable patterns. So let’s talk about that. How do we use React Server Components? How do we suggest migrating incrementally? How do we do tricky things <em>without</em> creating an illegible hairball of spaghetti code?</p><h2 id="how-do-i-use-react-server-components"><a href="#how-do-i-use-react-server-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>How do I use React Server Components?</strong></a></h2><p>You haven’t been scared away yet? Think the pros outweigh the cons? Great! Let’s dive in, starting with the basics.</p><div><p>As of the time of writing, the only production-ready implementation of RSCs is Next.js 13’s new <a href="https://nextjs.org/docs/app">app directory</a>. You <em>could</em> roll your own RSC framework, but if you’re the kind of developer who does that, you’re probably not reading my blog post. Anyway, some notes here might be a bit specific to Next.js.</p></div><h3 id="server-components"><a href="#server-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>Server Components</strong></a></h3><p>The mental model of Server Components may be complicated, but the syntax is blissfully simple. By default, any component you write in Next.js 13’s new <a href="https://nextjs.org/docs/app">app directory</a> will be a Server Component. In other words, by default, none of your page’s code is getting sent to the client.</p><div><figure><figcaption><p>A basic Server Component</p></figcaption><pre><code><span></span><span>function</span> <span>Description</span><span>(</span><span>)</span> <span>{</span> 
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span>p</span><span>&gt;</span></span><span>
<span></span>      None of this code is getting sent to the client. Just the HTML!
<span></span>    </span><span><span><span>&lt;/</span>p</span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span></code></pre></figure></div><p>Add async to that Server Component and you can just… fetch data! Here’s what that might look like:</p><div><figure><figcaption><p>A Server Component with data fetching</p></figcaption><pre><code><span></span><span>async</span> <span>function</span> <span>getVideo</span><span>(</span><span>id</span><span>)</span> <span>{</span>
<span></span>  <span>const</span> res <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span><span>`</span><span>https://api.example.com/videos/</span><span><span>${</span>id<span>}</span></span><span>`</span></span><span>)</span>
<span></span>  <span>return</span> res<span>.</span><span>json</span><span>(</span><span>)</span>
<span></span><span>}</span>
<span></span>
<span></span><span>async</span> <span>function</span> <span>Description</span><span>(</span><span><span>{</span> videoId <span>}</span></span><span>)</span> <span>{</span>
<span></span>  <span>const</span> video <span>=</span> <span>await</span> <span>getVideo</span><span>(</span>userId<span>)</span>
<span></span>  <span>return</span> <span><span><span>&lt;</span>p</span><span>&gt;</span></span><span>{</span>video<span>.</span>description<span>}</span><span><span><span>&lt;/</span>p</span><span>&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><p>There’s one last ingredient to really unlock the power of RSCs. If you don’t want to be stuck waiting for one slow data fetch, you can wrap your Server Components in <span>React.Suspense</span>. React will show the client a loading fallback, and when the server is done with its data fetching, it will stream the result to the client. The client can then replace the loading fallback with the full component.</p><p>In the example below, the client will see “loading comments” and “loading related videos.” When the server is done fetching the comments, it will render the <span>&lt;Comments /&gt;</span> component and stream the rendered component to the client; likewise with related videos.</p><div><figure><figcaption><p>A Server Component with data fetching and streaming</p></figcaption><pre><code><span></span><span>import</span> <span>{</span> Suspense <span>}</span>  <span>from</span> <span>&#39;react&#39;</span>
<span></span>
<span></span><span>async</span> <span>function</span> <span>VideoSidebar</span><span>(</span><span><span>{</span> videoId <span>}</span></span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span><span>Suspense</span></span> <span>fallback</span><span><span>=</span><span>{</span><span><span><span>&lt;</span>p</span><span>&gt;</span></span><span>loading comments...</span><span><span><span>&lt;/</span>p</span><span>&gt;</span></span><span>}</span></span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span><span>Comments</span></span> <span>videoId</span><span><span>=</span><span>{</span>videoId<span>}</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;/</span><span>Suspense</span></span><span>&gt;</span></span>
<span></span>    <span><span><span>&lt;</span><span>Suspense</span></span> <span>fallback</span><span><span>=</span><span>{</span><span><span><span>&lt;</span>p</span><span>&gt;</span></span><span>loading related videos...</span><span><span><span>&lt;/</span>p</span><span>&gt;</span></span><span>}</span></span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span><span>RelatedVideos</span></span> <span>videoId</span><span><span>=</span><span>{</span>videoId<span>}</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;/</span><span>Suspense</span></span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span></code></pre></figure></div><p>Embracing <span>React.Suspense</span> has advantages beyond streaming data when it’s ready. React can also take advantage of Suspense boundaries to prioritize hydrating certain parts of an app in response to user interaction. This is called selective hydration, and is probably a topic better left to <a href="https://www.youtube.com/watch?v=Q98l5o1y3ao">the experts</a>.</p><h3 id="client-components"><a href="#client-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>Client Components</strong></a></h3><p>Now let’s say you have some code that needs to run on the client. For example, maybe you have an <span>onClick</span> listener, or you’re reacting to data stored in <span>useState</span>.</p><p>A component gets shipped in one of two ways. The first: By adding <span>“use client”</span> at the top of a file, that module will be shipped to the client so it can respond to user interaction.</p><div><figure><figcaption><p>A basic Client Component</p></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>&#39;react&#39;</span>
<span></span>
<span></span><span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span>
<span></span>  <span>const</span> <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span>
<span></span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>increment<span>}</span></span><span>&gt;</span></span><span>
<span></span>      The count is </span><span>{</span>count<span>}</span><span>
<span></span>    </span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span></code></pre></figure></div><p>The second way a component gets shipped to the client is if it’s <em>imported</em> by a Client Component. In other words, if you mark a component with <span>“use client”</span>, not only will that component be shipped to the client, but <em>all the components it imports will also be shipped to the client</em>.</p><p>(Does this mean that a Server Component can’t be a child of a Client Component? No, but it’s a little complicated. More on that later.)</p><p>If it’s helpful, you can think of it this way: <span>“use client”</span> is telling your bundler that <em>this</em> is the client/server boundary. If that’s not helpful, well, ignore the last sentence.</p><h3 id="what-if-a-library-doesnt-support-client-components"><a href="#what-if-a-library-doesnt-support-client-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>What if a library doesn’t support Client Components?</strong></a></h3><p>We can leverage this second way to solve a common problem. Let’s say you want to use a library that doesn’t yet support React Server Components, so it doesn’t have <span>“use client”</span> directives. If you want to make sure that library ships to the client, import it from a Client Component, and it will be shipped to the client too.</p><div><figure><figcaption><p>Converting a library to a Client Component</p></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span>
<span></span>
<span></span>
<span></span><span>import</span> MuxPlayer <span>from</span> <span>&#34;@mux/mux-player-react&#34;</span>
<span></span>
<span></span><span>function</span> <span>ClientMuxPlayer</span><span>(</span><span>props</span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span><span><span>&lt;</span><span>MuxPlayer</span></span> <span><span>{</span><span>...</span>props<span>}</span></span> <span>/&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><h3 id="when-should-i-opt-in-to-client-components"><a href="#when-should-i-opt-in-to-client-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>When should I opt in to Client Components?</strong></a></h3><p>Let’s take a step back and summarize.</p><p>Server Components are the brave new React world. They’re great for fetching data and running expensive code that you don’t want or need to send to the client: rendering the text of a blog post, for example, or syntax-highlighting a code block. When convenient, you should leave your code as Server Components to avoid bloating your client bundle.</p><p>Client Components are the React you know and love. They can be server-side rendered, and they’re sent to the client to be hydrated and executed. Client Components are great when you want to react to user input or change state over time.</p><p>If your whole app was made of Client Components, it would work just like it used to with yesterday’s SSR frameworks. So don’t feel pressured to convert your whole app to Server Components all at once! Adopt them incrementally in places that would stand to gain the most. And… speaking of incremental adoption…</p><h2 id="how-do-i-incrementally-adopt-react-server-components-in-a-real-life-codebase"><a href="#how-do-i-incrementally-adopt-react-server-components-in-a-real-life-codebase"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>How do I incrementally adopt React Server Components in a real-life codebase?</strong></a></h2><p>This is the part of the show where folks tend to say, “Neat! But this seems like a lot of work, and I don’t have time to rewrite my whole codebase.” Well, I’m here to tell you that you don’t need to. Here’s the three-step playbook we used to bring most of our code to Server Components:</p><ol><li>Add the <span>“use client”</span> directive to the root of your app</li><li>Move the directive as low in the rendering tree as you can</li><li>Adopt advanced patterns when performance issues arise</li></ol><p>Let’s walk through that.</p><h3 id="1-add-use-client-directive-to-the-root-of-your-app"><a href="#1-add-use-client-directive-to-the-root-of-your-app"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>1. Add <span>“use client”</span> directive to the root of your app</strong></a></h3><p>Yup. That’s it. If you’re in Next.js 13, go to your top-level <span>page.tsx</span> and plop in a <span>“use client”</span> at the top. Your page works just like it used to, except now you’re ready to take on the world of Server Components!</p><div><figure><figcaption><div><p>video</p><!-- --><p>/<wbr/>page.jsx</p></div></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span>
<span></span><span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span><span><span>&lt;</span></span><span>&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;</span><span>Player</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;</span><span>Title</span></span> <span>/&gt;</span></span><span>
<span></span>  </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><p>Got any server-side data fetching? We can’t do that from a Client Component, so we’re going to add a Server Component. Let’s add it as a parent of the Client Component. That Server Component will perform the data fetching and pass it into our page. Here’s what that will look like:</p><div><figure><figcaption><div><p>video</p><!-- --><p>/<wbr/>page.jsx</p></div></figcaption><pre><code><span></span>
<span></span><span>import</span> VideoPageClient <span>from</span> <span>&#39;./page.client.jsx&#39;</span>
<span></span>
<span></span>
<span></span><span>async</span> <span>function</span> <span>fetchData</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>const</span> res <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#39;https://api.example.com&#39;</span><span>)</span>
<span></span>  <span>return</span> <span>await</span> res<span>.</span><span>json</span><span>(</span><span>)</span>
<span></span><span>}</span>
<span></span>
<span></span><span>export</span> <span>default</span> <span>async</span> <span>function</span> <span>FetchData</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>const</span> data <span>=</span> <span>await</span> <span>fetchData</span><span>(</span><span>)</span>
<span></span>  <span>{</span><span>}</span>
<span></span>  <span>const</span> <span><span><span>&lt;</span><span>VideoPageClient</span></span> <span>data</span><span><span>=</span><span>{</span>data<span>}</span></span> <span>/&gt;</span></span>
<span></span><span>}</span>
<span></span>
<span></span><span>export</span> <span>default</span> Page</code></pre></figure></div><div><figure><figcaption><div><p>video</p><!-- --><p>/<wbr/>page.client.jsx</p></div></figcaption><pre><code><span></span>
<span></span><span>&#34;use client&#34;</span>
<span></span>
<span></span><span>export</span> <span>default</span> <span>function</span> <span>App</span><span>(</span><span><span>{</span> data <span>}</span></span><span>)</span> <span>{</span>
<span></span>  <span><span><span>&lt;</span></span><span>&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;</span><span>Player</span></span> <span>videoId</span><span><span>=</span><span>{</span>data<span>.</span>videoId<span>}</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;</span><span>Title</span></span> <span>content</span><span><span>=</span><span>{</span>data<span>.</span>title<span>}</span></span> <span>/&gt;</span></span><span>
<span></span>  </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><h3 id="2-move-the-directive-as-low-in-the-rendering-tree-as-you-can"><a href="#2-move-the-directive-as-low-in-the-rendering-tree-as-you-can"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>2. Move the directive as low in the rendering tree as you can</strong></a></h3><p>Next, take that <span>“use client”</span> directive and move it from that top-level component into each of its children. In our example, we’ll be moving it from our <span>&lt;Client /&gt;</span> component into our <span>&lt;Player /&gt;</span> and <span>&lt;Title /&gt;</span> components.</p><div><figure><figcaption><div><p>video</p><!-- --><p>/<wbr/>Player.jsx</p></div></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span><span>import</span> MuxPlayer <span>from</span> <span>&#34;@mux/mux-player-react&#34;</span>
<span></span>
<span></span><span>function</span> <span>Player</span><span>(</span><span><span>{</span> videoId <span>}</span></span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span><span><span>&lt;</span><span>MuxPlayer</span></span> <span>streamType</span><span><span>=</span><span>&#34;</span>on-demand<span>&#34;</span></span> <span>playbackId</span><span><span>=</span><span>{</span>videoId<span>}</span></span> <span>/&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><div><figure><figcaption><div><p>video</p><!-- --><p>/<wbr/>Title.jsx</p></div></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span>
<span></span><span>function</span> <span>Title</span><span>(</span><span><span>{</span> content <span>}</span></span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span><span><span>&lt;</span>h1</span><span>&gt;</span></span><span>{</span>content<span>}</span><span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
<span></span><span>}</span></code></pre></figure></div><p>And repeat! Except… because neither <span>&lt;Player /&gt;</span> nor <span>&lt;Title /&gt;</span> have children into which we can push the <span>“use client”</span> directive, let’s remove it!</p><p><span>&lt;Title /&gt;</span> has no issues, because <span>&lt;Title /&gt;</span> doesn’t require any client-side code and can be shipped as pure HTML. Meanwhile, <span>&lt;Player /&gt;</span> throws an error.</p><p>Great. That’s as low as we can go. Let’s restore <span>“use client”</span> to the <span>&lt;Player /&gt;</span> component to address that error and call it a day.</p><p>See? That wasn’t too bad. We’ve moved our app to Server Components. Now, as we add new components and refactor old ones, we can write with Server Components in mind. And, we’ve saved a bit of bundle size by not shipping <span>&lt;Title /&gt;</span> !</p><h3 id="3-adopt-advanced-patterns-when-performance-issues-arise"><a href="#3-adopt-advanced-patterns-when-performance-issues-arise"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>3. Adopt advanced patterns when performance issues arise</strong></a></h3><p>Steps 1 and 2 should be enough for most cases. But if you’re noticing performance issues, there are still some wins you can squeeze out of your RSC conversion.</p><p>For example, when we <a href="https://miles.land/blog/the-building-blocks-of-great-docs">migrated our docs site to RSCs</a>, we leaned on two patterns to unlock deeper gains. The first was wrapping key Server Components in <span>Suspense</span> to enable streaming of slow data fetches (as demonstrated earlier). Our whole app is statically generated except for the changelog sidebar, which comes from a <a href="https://en.wikipedia.org/wiki/Content_management_system">CMS</a>. By wrapping that sidebar in Suspense, the rest of the app doesn’t have to wait for the CMS fetch to resolve. Beyond that, we leveraged Next.js 13’s <a href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming"><span>loading.js</span></a> convention, which uses Suspense/streaming under the hood.</p><p>The second optimization we applied was creatively rearranging Client and Server Components to ensure that large libraries, like our syntax highlighting, <a href="https://prismjs.com/">Prism</a>, stayed on the server. And speaking of creatively rearranging Client and Server Components…</p><h2 id="did-someone-say-advanced-patterns"><a href="#did-someone-say-advanced-patterns"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>Did someone say advanced patterns?</strong></a></h2><h3 id="how-do-you-mix-client-and-server-components"><a href="#how-do-you-mix-client-and-server-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>How do you mix Client and Server Components?</strong></a></h3><p>We established earlier that any component imported from a Client Component would itself become a Client Component. So… how do you make a Server Component a child of a Client Component? Long story short,<strong> pass Server Components as children or props instead of importing them.</strong> The Server Component will be rendered on the server, serialized, and sent to your Client Component.</p><p>This, imo, is the hardest thing to wrap your head around in this whole RSC mess. It gets easier with practice. Let’s check out some examples, starting with the wrong way.</p><div><figure><figcaption><p>How NOT to mix Client and Server Components</p></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span>
<span></span>
<span></span>
<span></span><span>import</span> ServerComponentB <span>from</span> <span>&#39;./ServerComponentB.js&#39;</span>
<span></span>
<span></span><span>function</span> <span>ClientComponent</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>onClickFunction<span>}</span></span><span>&gt;</span></span><span>Button</span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span><span>
<span></span>      </span><span>{</span><span>}</span><span>
<span></span>      </span><span><span><span>&lt;</span><span>ServerComponentB</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span></code></pre></figure></div><p>By importing <span>ServerComponent</span> in a Client Component, we shipped <span>ServerComponent</span> to the client. Oh no! To do this properly, we have to go up a level to the nearest Server Component — in this case, <span>ServerPage</span> — and do our work there.</p><div><figure><figcaption><p>How to mix Client and Server Components</p></figcaption><pre><code><span></span><span>import</span> ClientComponent <span>from</span> <span>&#39;./ClientComponent.js&#39;</span>
<span></span><span>import</span> ServerComponentB <span>from</span> <span>&#39;./ServerComponentB.js&#39;</span>
<span></span>
<span></span>
<span></span><span>function</span> <span>ServerComponentA</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span><span>ClientComponent</span></span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span><span>ServerComponentB</span></span> <span>/&gt;</span></span><span>
<span></span>    </span><span><span><span>&lt;/</span><span>ClientComponent</span></span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span>
<span></span>
<span></span>
<span></span><span>function</span> <span>ServerPage</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span><span>ClientComponent</span></span>
<span></span>      <span>content</span><span><span>=</span><span>{</span><span><span><span>&lt;</span><span>ServerComponentB</span></span> <span>/&gt;</span></span><span>}</span></span>
<span></span>    <span>/&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span></code></pre></figure></div><h3 id="can-you-make-half-of-a-file-a-server-component-and-half-of-it-a-client-component"><a href="#can-you-make-half-of-a-file-a-server-component-and-half-of-it-a-client-component"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>Can you make half of a file a Server Component and half of it a Client Component?</strong></a></h3><p>Nope! But here’s a pattern we use a lot, when we want part of our component’s functionality to stay on the server. Let’s say we’re making a <span>&lt;CodeBlock /&gt;</span> component. We might want the syntax highlighting to stay on the server so we don’t have to ship that large library, but we might also want some client functionality so that the user can switch between multiple code examples. First, we break the component into two halves: <span>CodeBlock.server.js</span> and <span>CodeBlock.client.js</span>. The former imports the latter. (The names could be anything; we use <span>.server</span> and <span>.client</span> just to keep things straight.)</p><div><figure><figcaption><div><p>components</p><!-- --><p>/<wbr/>CodeBlock</p><!-- --><p>/<wbr/>CodeBlock.server.js</p></div></figcaption><pre><code><span></span>
<span></span><span>import</span> Highlight <span>from</span> <span>&#39;expensive-library&#39;</span>
<span></span><span>import</span> ClientCodeBlock <span>from</span> <span>&#39;./CodeBlock.client.js&#39;</span>
<span></span><span>import</span> <span>{</span> example0<span>,</span> example1<span>,</span> example2 <span>}</span> <span>from</span> <span>&#39;./examples.js&#39;</span>
<span></span>
<span></span><span>function</span> <span>ServerCodeBlock</span><span>(</span><span>)</span> <span>{</span>
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span><span>ClientCodeBlock</span></span>
<span></span>      
<span></span>      <span>renderedExamples</span><span><span>=</span><span>{</span><span>[</span>
<span></span>        <span><span><span>&lt;</span><span>Highlight</span></span> <span>code</span><span><span>=</span><span>{</span>example0<span>.</span>code<span>}</span></span> <span>language</span><span><span>=</span><span>{</span>example0<span>.</span>language<span>}</span></span> <span>/&gt;</span></span><span>,</span>
<span></span>        <span><span><span>&lt;</span><span>Highlight</span></span> <span>code</span><span><span>=</span><span>{</span>example1<span>.</span>code<span>}</span></span> <span>language</span><span><span>=</span><span>{</span>example1<span>.</span>language<span>}</span></span> <span>/&gt;</span></span><span>,</span>
<span></span>        <span><span><span>&lt;</span><span>Highlight</span></span> <span>code</span><span><span>=</span><span>{</span>example2<span>.</span>code<span>}</span></span> <span>language</span><span><span>=</span><span>{</span>example2<span>.</span>language<span>}</span></span> <span>/&gt;</span></span>
<span></span>      <span>]</span><span>}</span></span>
<span></span>    <span>&gt;</span></span><span>
<span></span>  )
<span></span>}
<span></span>
<span></span>export default ServerCodeBlock</span></code></pre></figure></div><div><figure><figcaption><div><p>components</p><!-- --><p>/<wbr/>CodeBlock</p><!-- --><p>/<wbr/>CodeBlock.client.js</p></div></figcaption><pre><code><span></span><span>&#34;use client&#34;</span>
<span></span><span>import</span> <span>{</span> useState <span>}</span> <span>from</span> <span>&#39;react&#39;</span>
<span></span>
<span></span><span>function</span> <span>ClientCodeBlock</span><span>(</span><span><span>{</span> renderedExamples <span>}</span></span><span>)</span> <span>{</span>
<span></span>  
<span></span>  
<span></span>  <span>const</span> <span>[</span>currentExample<span>,</span> setCurrentExample<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>1</span><span>)</span>
<span></span>  
<span></span>  <span>return</span> <span>(</span>
<span></span>    <span><span><span>&lt;</span></span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCurrentExample</span><span>(</span><span>0</span><span>)</span><span>}</span></span><span>&gt;</span></span><span>Example 1</span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCurrentExample</span><span>(</span><span>1</span><span>)</span><span>}</span></span><span>&gt;</span></span><span>Example 2</span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span><span>
<span></span>      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCurrentExample</span><span>(</span><span>2</span><span>)</span><span>}</span></span><span>&gt;</span></span><span>Example 3</span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span><span>
<span></span>      </span><span>{</span> renderedExamples<span>[</span>currentExample<span>]</span> <span>}</span><span>
<span></span>    </span><span><span><span>&lt;/</span></span><span>&gt;</span></span>
<span></span>  <span>)</span>
<span></span><span>}</span>
<span></span>
<span></span><span>export</span> <span>default</span> ClientCodeBlock</code></pre></figure></div><p>Now that we have those two components, let’s make them easy to consume with a <a href="https://www.joshwcomeau.com/react/file-structure/">delightful file structure</a>. Let’s put those two files in a folder called <span>CodeBlock</span> and add an <span>index.js</span> file that looks like this:</p><div><figure><figcaption><div><p>components</p><!-- --><p>/<wbr/>CodeBlock</p><!-- --><p>/<wbr/>index.js</p></div></figcaption><pre><code><span></span><span>export</span> <span>{</span> <span>default</span> <span>}</span> <span>from</span> <span>&#39;./CodeBlock.server.js&#39;</span></code></pre></figure></div><p>Now, any consumer can <span>import CodeBlock from ‘components/CodeBlock.js’</span> and the Client and Server Components remain transparent.</p><h3 id="this-is-confusing-how-can-i-be-sure-that-my-code-is-running-on-the-server"><a href="#this-is-confusing-how-can-i-be-sure-that-my-code-is-running-on-the-server"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>This is confusing. How can I be sure that my code is running on the server?</strong></a></h3><p>Honestly, at first, we just added <span>console.log</span> to our code during development and checked to see if that log came out of the server or web browser. This was enough to begin with, but we did eventually find a better way.</p><p>If you want to be extra sure that your Server Component will never get included in a bundle, you can import the <a href="https://www.npmjs.com/package/server-only"><span>server-only</span> package</a>. This is extra handy if you want to make sure a large library or a secret key doesn’t end up where it shouldn’t. (Though if you’re using Next.js, <a href="https://nextjs.org/docs/app/building-your-application/configuring/environment-variables#bundling-environment-variables-for-the-browser">it<em> will</em> protect you</a> from accidentally shipping your environment variables.)</p><p>Using <span>server-only</span> also had another subtle but meaningful benefit for us: <em>legibility and maintainability</em>. Maintainers who see <span>server-only</span> at the top of a file know exactly where that file is running without having to keep a complete mental model of the component tree.</p><h2 id="so-should-i-use-react-server-components"><a href="#so-should-i-use-react-server-components"><span><span><svg xmlns="http://www.w3.org/2000/svg" width="42" height="42" fill="none" viewBox="0 0 42 42"><path d="m18.172 15.343 3.535-3.535a5 5 0 0 1 7.071 0l1.414 1.414a5 5 0 0 1 0 7.07l-3.535 3.536M23.828 26.657l-3.535 3.535a5 5 0 0 1-7.071 0l-1.414-1.414a5 5 0 0 1 0-7.07l3.535-3.536" vector-effect="non-scaling-stroke"></path><path stroke-linecap="round" d="m25.243 16.757-8.486 8.486" vector-effect="non-scaling-stroke"></path></svg><span>Link42Icon</span></span></span><strong>So, should I use React Server Components?</strong></a></h2><p>At the end of the day, React Server Components don’t come for free. It’s not just those gotchas surrounding CSS-in-JS or React Context. It’s also the added complexity: understanding what’s running on the server and what’s running on the client, <a href="https://www.joshwcomeau.com/react/the-perils-of-rehydration/">understanding hydration</a>, incurring infrastructure costs, and of course, managing the code complexity (especially when mixing Client and Server Components). Every facet of complexity adds another surface for bugs to sneak in and for code to become less maintainable. Frameworks reduce this complexity, but they don’t eliminate it.</p><p>When deciding whether to adopt RSCs, weigh these costs against the benefits — like smaller bundle sizes and faster execution, which can be critical to SEO. Or advanced data loading patterns that can be used to optimize complex data-heavy sites. <a href="https://twitter.com/jescalan">Jeff Escalante</a>, trying to answer the same question in their <a href="https://www.youtube.com/watch?v=TJOiXyVKExg&amp;list=PLRvKvw42Rc7MoxLVE_9qM24NAjqDdbBJc&amp;index=5">Reactathon talk</a>, nailed it with this diagram:</p><p>If your team is ready to take on the mental overhead and the performance benefits are worthwhile, then RSCs might just be for you.</p></div></div>
  </body>
</html>
