<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tim.siosm.fr/blog/2023/12/19/ssh-over-unix-socket/">Original</a>
    <h1>Sudo without a setuid binary or SSH over a Unix socket</h1>
    
    <div id="readability-page-1" class="page"><section itemprop="text"><p>In this post, I will detail how to replace <code>sudo</code> (a setuid binary) by using SSH over a local UNIX socket.</p><p>I am of the opinion that <a href="https://en.wikipedia.org/wiki/Setuid"><code>setuid</code>/<code>setgid</code> binaries</a> are a UNIX legacy that should be deprecated. I will explain the security reasons behind that statement in a future post.</p><p>This is related to the work of the <a href="https://fedoraproject.org/wiki/SIGs/ConfinedUsers">Confined Users SIG</a> in Fedora.</p><!-- more --><h2 id="why-bother">Why bother?</h2><p>The main benefit of this approach is that it enables <code>root</code> access to the host from any unprivileged toolbox / distrobox container. This is particularly useful on Fedora Atomic desktops (Silverblue, Kinoite, Sericea, Onyx) or Universal Blue (Bluefin, Bazzite) for example.</p><p>As a side effect of this setup, we also get the following security advantages:</p><ul><li>No longer rely on <code>sudo</code> as a <code>setuid</code> binary for privileged operations.</li><li>Access control via a physical hardware token (here a Yubikey) for each privileged operation.</li></ul><h2 id="setting-up-the-server">Setting up the server</h2><p>Create the following systemd units:</p><p><code>/etc/systemd/system/sshd-unix.socket</code>:</p><figure><pre><code data-lang="systemd"><span>[Unit]</span>
<span>Description</span><span>=</span>OpenSSH Server Unix Socket
<span>Documentation</span><span>=</span>man:sshd(8) man:sshd_config(5)

<span>[Socket]</span>
<span>ListenStream</span><span>=</span>/run/sshd.sock
<span>Accept</span><span>=</span>yes

<span>[Install]</span>
<span>WantedBy</span><span>=</span>sockets.target</code></pre></figure><p><code>/etc/systemd/system/sshd-unix@.service</code>:</p><figure><pre><code data-lang="systemd"><span>[Unit]</span>
<span>Description</span><span>=</span>OpenSSH per-connection server daemon (Unix socket)
<span>Documentation</span><span>=</span>man:sshd(8) man:sshd_config(5)
<span>Wants</span><span>=</span>sshd-keygen.target
<span>After</span><span>=</span>sshd-keygen.target

<span>[Service]</span>
<span>ExecStart</span><span>=</span>-/usr/sbin/sshd -i -f /etc/ssh/sshd_config_unix
<span>StandardInput</span><span>=</span>socket</code></pre></figure><p>Create a dedicated configuration file <code>/etc/ssh/sshd_config_unix</code>:</p><figure><pre><code data-lang="ssh"><span># Deny all non key based authentication methods</span>
<span>PermitRootLogin</span> prohibit-password
<span>PasswordAuthentication</span> <span>no</span>
<span>PermitEmptyPasswords</span> <span>no</span>
<span>GSSAPIAuthentication</span> <span>no</span>

<span># Only allow access for specific users</span>
<span>AllowUsers</span> root tim

<span># The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span>
<span># but this is overridden so installations will only check .ssh/authorized_keys</span>
<span>AuthorizedKeysFile</span> .ssh/authorized_keys

<span># override default of no subsystems</span>
<span>Subsystem</span> sftp /usr/libexec/openssh/sftp-server</code></pre></figure><p>Enable and start the new socket unit:</p><figure><pre><code data-lang="console"><span>$</span><span> </span><span>sudo </span>systemctl daemon-reload
<span>$</span><span> </span><span>sudo </span>systemctl <span>enable</span> <span>--now</span> sshd-unix.socket</code></pre></figure><p>Add your SSH Key to <code>/root/.ssh/authorized_keys</code>.</p><h2 id="setting-up-the-client">Setting up the client</h2><p>Install <code>socat</code> and use the following snippet in <code>/.ssh/config</code>:</p><figure><pre><code data-lang="ssh"><span>Host</span> host.local
    <span>User</span> root
    <span># We use `run/host/run` instead of `/run` to transparently work in and out of containers</span>
    <span>ProxyCommand</span> socat - UNIX-CLIENT:/run/host/run/sshd.sock
    <span># Path to your SSH key. See: https://tim.siosm.fr/blog/2023/01/13/openssh-key-management/</span>
    <span>IdentityFile</span> ~/.ssh/keys/localroot
    <span># Force TTY allocation to always get an interactive shell</span>
    <span>RequestTTY</span> <span>yes</span>
    <span># Minimize log output</span>
    <span>LogLevel</span> QUIET</code></pre></figure><p>Test your setup:</p><figure><pre><code data-lang="console"><span>$</span><span> </span>ssh host.local
<span>[root@phoenix ~]#</span></code></pre></figure><h2 id="shell-alias">Shell alias</h2><p>Let’s create a <code>sudohost</code> shell “alias” (function) that you can add to your Bash or ZSH config to make using this command easier:</p><figure><pre><code data-lang="bash"><span># Get an interactive root shell or run a command as root on the host</span>
sudohost<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>${#}</span> <span>-eq</span> 0 <span>]]</span><span>;</span> <span>then
        </span>ssh host.local <span>&#34;cd </span><span>\&#34;</span><span>${</span><span>PWD</span><span>}</span><span>\&#34;</span><span>; exec </span><span>\&#34;</span><span>${</span><span>SHELL</span><span>}</span><span>\&#34;</span><span> --login&#34;</span>
    <span>else
        </span>ssh host.local <span>&#34;cd </span><span>\&#34;</span><span>${</span><span>PWD</span><span>}</span><span>\&#34;</span><span>; exec </span><span>\&#34;</span><span>${</span><span>@</span><span>}</span><span>\&#34;</span><span>&#34;</span>
    <span>fi</span>
<span>}</span></code></pre></figure><p>Test the alias:</p><figure><pre><code data-lang="console"><span>$</span><span> </span>sudohost <span>id</span>
<span>uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</span><span>$</span><span> </span>sudohost <span>pwd</span>
<span>/var/home/tim
</span><span>$</span><span> </span>sudohost <span>ls</span>
<span>Desktop Downloads ...</span></code></pre></figure><p>We’ll keep a distinct alias for now as we’ll still have a need for the “real” <code>sudo</code> in our toolbox containers.</p><h2 id="security">Security?</h2><p>As-is, this setup is basically a free local root for anything running under your current user that has access to your SSH private key. This is however likely already the case on most developer’s workstations if you are part of the <code>wheel</code>, <code>sudo</code> or <code>docker</code> groups, as any code runnning under your user can edit your shell config and set a <a href="https://security.stackexchange.com/questions/232924/is-sudo-almost-useless">backdoored alias for <code>sudo</code></a> or run arbitrary privileged containers via Docker. <code>sudo</code> itself is not a security boundary as commonly configured by default.</p><p>To truly increase our security posture, we would instead need to remove <code>sudo</code> (and all other <code>setuid</code> binaries) and run our session under a fully unprivileged, confined user, but that’s for a future post.</p><h3 id="setting-up-u2f-authentication-with-an-sk-based-ssh-key-pair">Setting up U2F authentication with an sk-based SSH key-pair</h3><p>To make it more obvious when commands are run as root, we can setup SSH authentication using U2F with a Yubikey as an example. While this, by itself, does not, strictly speaking, increase the security of this setup, this makes it harder to run commands without you being somewhat aware of it.</p><p>First, we need to figure out which algorithm are supported by our Yubikey:</p><figure><pre><code data-lang="console"><span>$</span><span> </span>lsusb <span>-v</span> 2&gt;/dev/null | <span>grep</span> <span>-A2</span> Yubico | <span>grep</span> <span>&#34;bcdDevice&#34;</span> | <span>awk</span> <span>&#39;{print $2}&#39;</span></code></pre></figure><p>If the value is <code>5.2.3</code> or higher, then we can use <code>ed25519-sk</code>, otherwise we’ll have to use <code>ecdsa-sk</code> to generate the SSH key-pair:</p><figure><pre><code data-lang="console"><span>$</span><span> </span>ssh-keygen <span>-t</span> ed25519-sk
<span>#</span><span> </span>or
<span>$</span><span> </span>ssh-keygen <span>-t</span> ecdsa-sk</code></pre></figure><p>Add the new sk-based SSH public key to <code>/root/.ssh/authorized_keys</code>.</p><p>Update the server configuration to only accept sk-based SSH key-pairs:</p><p><code>/etc/ssh/sshd_config_unix</code>:</p><figure><pre><code data-lang="ssh"><span># Only allow sk-based SSH key-pairs authentication methods</span>
<span>PubkeyAcceptedKeyTypes</span> sk-ecdsa-sha2-nistp256@openssh.com,sk-ssh-ed25519@openssh.com

<span>...</span></code></pre></figure><h3 id="restricting-access-to-a-subset-of-users">Restricting access to a subset of users</h3><p>You can also further restrict the access to the UNIX socket by configuring classic user/group UNIX permissions:</p><p><code>/etc/systemd/system/sshd-unix.socket</code>:</p><figure><pre><code data-lang="ini"><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
</pre></td><td><pre><span>...</span>

<span>[Socket]</span>
<span>...</span>
<span>SocketUser</span><span>=</span><span>tim</span>
<span>SocketGroup</span><span>=</span><span>tim</span>
<span>SocketMode</span><span>=</span><span>0660</span>
<span>...</span>
</pre></td></tr></tbody></table></code></pre></figure><p>Then reload systemd’s configuration and restart the socket unit.</p><h2 id="next-steps-disabling-sudo">Next steps: Disabling sudo</h2><p>Now that we have a working alias to run privileged commands, we can disable <code>sudo</code> access for our user.</p><h3 id="important-backup--pre-requisite-step">Important backup / pre-requisite step</h3><p>Make sure that you have a backup and are able to boot from a LiveISO in case something goes wrong.</p><p>Set a strong password for the <code>root</code> account. Make sure that can locally log into the system via a TTY console.</p><p>If you have the classic <code>sshd</code> server enabled and listening on the network, make sure to disable remote login as <code>root</code> or password logins.</p><h3 id="removing-yourself-from-the-wheel--sudo-groups">Removing yourself from the <code>wheel</code> / <code>sudo</code> groups</h3><p>Open a terminal running as <code>root</code> (i.e. don’t use <code>sudo</code> for those commands) and remove you users from the <code>wheel</code> or <code>sudo</code> groups using:</p><figure><pre><code data-lang="console"><span>$</span><span> </span>usermod <span>-dG</span> wheel tim</code></pre></figure><p>You can also update the <code>sudo</code> config to remove access for users that are part of the <code>wheel</code> group:</p><div><div><pre><code># Comment / delete this line
%wheel  ALL=(ALL)       ALL
</code></pre></div></div><h3 id="removing-the-setuid-binaries">Removing the setuid binaries</h3><p>To fully benefit from the security advantage of this setup, we need to remove the <code>setuid</code> binares (<code>sudo</code> and <code>su</code>).</p><p>If you can, uninstall <code>sudo</code> and <code>su</code> from your system. This is usually not possible due to package dependencies (<code>su</code> is part of <code>util-linux</code> on Fedora).</p><p>Another option is to remove the <code>setuid</code> bit from the <code>sudo</code> and <code>su</code> binaries:</p><figure><pre><code data-lang="console"><span>$</span><span> </span><span>chmod </span>u-s <span>$(</span>which <span>sudo</span><span>)</span>
<span>$</span><span> </span><span>chmod </span>u-s <span>$(</span>which su<span>)</span></code></pre></figure><p>You will have to re-run those commands after each update on classic systems.</p><p>Setting this up for Fedora Atomic desktops is a little bit different as <code>/usr</code> is read only. This will be the subject of an upcoming blog post.</p><h2 id="conclusion">Conclusion</h2><p>Like most of the time with security, this is not a silver bullet solution that will make your system “more secure” (TM). I have been working on this setup as part of my investigation to reduce our reliance on <code>setuid</code> binaries and trying to figure out alternative for common use cases.</p><p>Let me know if you found this interesting as that will likely motivate me to write the next part!</p><h2 id="references">References</h2><ul><li>Pull request for openssh-portable to enable the SSH client to connect directly to a UNIX socket (will remove the need for socat): <a href="https://github.com/openssh/openssh-portable/pull/435">enable ssh connection to a unix socket</a></li><li><a href="https://unix.stackexchange.com/questions/451788/ssh-connect-to-a-unix-socket-instead-of-hostname">SSH connect to a UNIX socket instead of hostname</a></li><li><a href="https://cryptsus.com/blog/how-to-configure-openssh-with-yubikey-security-keys-u2f-otp-authentication-ed25519-sk-ecdsa-sk-on-ubuntu-18.04.html">How to configure SSH with YubiKey Security Keys U2F Authentication on Ubuntu</a></li></ul></section></div>
  </body>
</html>
