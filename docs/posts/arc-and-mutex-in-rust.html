<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://itsallaboutthebit.com/arc-mutex/">Original</a>
    <h1>Arc and Mutex in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    
  <div>
  	
  	
  	

    

  	<p>When writing concurrent Rust you will encounter <code>Arc</code> and <code>Mutex</code> types sooner
or later. And although <code>Mutex</code> might already sound familiar as it&#39;s a concept
known in many languages, chances are you haven&#39;t heard about <code>Arc</code> before Rust.
What&#39;s more, you can&#39;t fully understand these concepts without tying them to the
ownership model in Rust. This post is my take on understanding <code>Arc</code> and <code>Mutex</code>
in Rust.</p>
<p>Typically when you share data in a concurrent environment you either
share memory or pass data as messages.
You might often hear that passing messages (for
example by using channels) is a preferred way to handle concurrency, but in Rust
I don&#39;t think the safety or correctness differences are as big as in other languages due to
the ownership model in Rust. Or more specifically: you can&#39;t have a data race in safe
Rust. That&#39;s why when I choose between message passing or memory sharing in
Rust, I do it mostly in relation to convinience, not safety.</p>
<p>If you choose to share data by sharing memory you will quickly encounter that
you can&#39;t do much without <code>Arc</code> and <code>Mutex</code>. <code>Arc</code> is a smart pointer that let&#39;s
you safely share a value between multiple threads. <code>Mutex</code> is a wrapper over
another type, which allows safe mutability across threads. In order
to fully understand these concepts, though, let&#39;s dive into the ownership model.</p>
<h3 id="ownership-in-rust">Ownership in Rust</h3>
<p>If you tried to distill the ownership model in Rust, you would probably get the
following points:</p>
<ul>
<li>a value can have only one owner</li>
<li>you can have multiple shared immutable references to a value</li>
<li>you can have only one mutable reference to a value</li>
</ul>
<p>Let&#39;s see how it plays out. Given a <code>User</code> struct containing a <code>String</code> field
named <code>name</code> we create a thread and print out a message for the user:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>std::thread::spawn;
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>4</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>5</td><td><span>    </span><span>name</span><span>: String
</span></td></tr><tr><td>6</td><td><span>}
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>9</td><td><span>    </span><span>let</span><span> user = User { name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>() };
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span>    </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>12</td><td><span>        println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, user.name);
</span></td></tr><tr><td>13</td><td><span>    }).</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>14</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>So far so good, the program compiles and prints the message. Now imagine we need
to add a second thread that also has access to the <code>user</code> instance:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>2</td><td><span>    </span><span>let</span><span> user = User { name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>() };
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>    </span><span>let</span><span> t1 = </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>5</td><td><span>        println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, user.name);
</span></td></tr><tr><td>6</td><td><span>    });
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>    </span><span>let</span><span> t2 = </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>9</td><td><span>        println!(&#34;</span><span>Hello from the second thread </span><span>{}</span><span>&#34;, user.name);
</span></td></tr><tr><td>10</td><td><span>    });
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    t1.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>13</td><td><span>    t2.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>14</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>With this code we get the following error:</p>
<pre><code><span>error[E0382]: use of moved value: `user.name`
</span><span>  --&gt; src/main.rs:15:20
</span><span>   |
</span><span>11 |     let t1 = spawn(move || {
</span><span>   |                    ------- value moved into closure here
</span><span>12 |         println!(&#34;Hello from the first thread {}&#34;, user.name);
</span><span>   |                                                    --------- variable moved due to use in closure
</span><span>...
</span><span>15 |     let t2 = spawn(move || {
</span><span>   |                    ^^^^^^^ value used here after move
</span><span>16 |         println!(&#34;Hello from the second thread {}&#34;, user.name);
</span><span>   |                                                    --------- use occurs due to use in closure
</span><span>   |
</span><span>   = note: move occurs because `user.name` has type `String`, which does not implement the `Copy` trait
</span></code></pre>
<p>What does the compiler want? The error reads &#34;use of moved value <code>user.name</code>&#34;.
The compiler is even nice enough to point us to specific places where the
problem occurs. We first move the value to the first thread on line 11 and
then we try to do the same thing with the second thread on line 15.
If you look at the ownership rules, this shouldn&#39;t be surprising. A value can
have only one owner. With the current version of the code we need to
&#34;move&#34; the value to the first thread if we want to use it, and thus we can&#39;t move it to
the other thread. It already changed ownership. But we don&#39;t mutate the data,
right? Which means we can have multiple shared references. Let&#39;s try that.</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>2</td><td><span>    </span><span>let</span><span> user = User { name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>() };
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>    </span><span>let</span><span> t1 = </span><span>spawn</span><span>(|| {
</span></td></tr><tr><td>5</td><td><span>        println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, &amp;user.name);
</span></td></tr><tr><td>6</td><td><span>    });
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>    </span><span>let</span><span> t2 = </span><span>spawn</span><span>(|| {
</span></td></tr><tr><td>9</td><td><span>        println!(&#34;</span><span>Hello from the second thread </span><span>{}</span><span>&#34;, &amp;user.name);
</span></td></tr><tr><td>10</td><td><span>    });
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    t1.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>13</td><td><span>    t2.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>14</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>I removed the <code>move</code> keyword in the thread closures and I made the threads
borrow the <code>user</code> value immutably, or in other words get a shared reference,
which is represented by the ampersand.
With this code we get the following:</p>
<pre><code><span>error[E0373]: closure may outlive the current function, but it borrows `user.name`, which is owned by the current function
</span><span>  --&gt; src/main.rs:15:20
</span><span>   |
</span><span>15 |     let t2 = spawn(|| {
</span><span>   |                    ^^ may outlive borrowed value `user.name`
</span><span>16 |         println!(&#34;Hello from the first thread {}&#34;, &amp;user.name);
</span><span>   |                                                     --------- `user.name` is borrowed here
</span><span>   |
</span><span>note: function requires argument type to outlive `&#39;static`
</span><span>  --&gt; src/main.rs:15:14
</span><span>   |
</span><span>15 |       let t2 = spawn(|| {
</span><span>   |  ______________^
</span><span>16 | |         println!(&#34;Hello from the second thread {}&#34;, &amp;user.name);
</span><span>17 | |     });
</span><span>   | |______^
</span><span>help: to force the closure to take ownership of `user.name` (and any other referenced variables), use the `move` keyword
</span><span>   |
</span><span>15 |     let t2 = spawn(move || {
</span><span>   |                    ++++
</span></code></pre>
<p>Now the error says that the closure can outlive the function. In other words the
Rust compiler can&#39;t guarantee that the closure in the thread will finish before
the <code>main()</code> function finishes. Threads are borrowing the user struct, but
it&#39;s still owned by the main function. In this scenario if the main function
finishes, the user struct goes out of scope and the memory is dropped. Thus if
it was allowed to share the value with threads in that manner, there could be a
scenario when a thread is trying to read freed memory.
Which is an undefined behaviour and we certainly don&#39;t want that.</p>
<p>The note also says that it may help to move the variable <code>user</code> to the thread in
order to avoid borrowing, but we&#39;re just coming from that scenario, so it&#39;s
no good. Now, there are two easy solutions to fix this and one of them is to use
<code>Arc</code>, but let&#39;s explore the other solution first: scoped threads.</p>
<h3 id="scoped-threads">Scoped threads</h3>
<p>Scoped
threads is a feature available either from an excellent <a href="https://docs.rs/crossbeam/latest/crossbeam/fn.scope.html">crossbeam
crate</a>
or as an <a href="https://doc.rust-lang.org/nightly/std/thread/fn.scope.html">experimental nightly feature</a> in Rust.
For the purpose of this article I will use crossbeam, but the API is very similar for 
both versions. After adding <code>crossbeam = &#34;0.8&#34;</code> to dependencies in
<code>Cargo.toml</code> this code will work without problems</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>crossbeam::scope;
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>4</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>5</td><td><span>    </span><span>name</span><span>: String,
</span></td></tr><tr><td>6</td><td><span>}
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>9</td><td><span>    </span><span>let</span><span> user = User {
</span></td></tr><tr><td>10</td><td><span>        name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>(),
</span></td></tr><tr><td>11</td><td><span>    };
</span></td></tr><tr><td>12</td><td><span>
</span></td></tr><tr><td>13</td><td><span>    </span><span>scope</span><span>(|</span><span>s</span><span>| {
</span></td></tr><tr><td>14</td><td><span>        s.</span><span>spawn</span><span>(|_| {
</span></td></tr><tr><td>15</td><td><span>            println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, &amp;user.name);
</span></td></tr><tr><td>16</td><td><span>        });
</span></td></tr><tr><td>17</td><td><span>
</span></td></tr><tr><td>18</td><td><span>        s.</span><span>spawn</span><span>(|_| {
</span></td></tr><tr><td>19</td><td><span>            println!(&#34;</span><span>Hello from the second thread </span><span>{}</span><span>&#34;, &amp;user.name);
</span></td></tr><tr><td>20</td><td><span>        });
</span></td></tr><tr><td>21</td><td><span>    })
</span></td></tr><tr><td>22</td><td><span>    .</span><span>unwrap</span><span>();
</span></td></tr><tr><td>23</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>The way scoped threads work is all of the threads created in the scope are
guaranteed to be finished before the <code>scope</code> closure finishes. Or in other words</p>
<ul>
<li>before the scoped closure goes out of scope, the threads are joined and
awaited to be finished. Thanks to that the compiler knows that none of the
borrows will outlive the owner.</li>
</ul>
<p>One interesting thing to note here is that as a human reader we would have
interpreted both of these programs as valid. In the version that Rust
rejects we join both threads before the <code>main()</code> function finishes, so 
it would be actually safe to share the user value with the threads. This is,
unfortunately, something that you may encounter when writing in Rust. Writing
a compiler that would accept all of the valid programs is not possible, thus 
we&#39;re left with the next best thing: a compiler that will reject all invalid
programs at a cost of being overly strict. Scoped threads is a future written
specifically to allow us to write this code in a way that compiler can accept.</p>
<p>As useful as the scoped threads feature is, however, you can&#39;t always use it, for example when writing async code.
Let&#39;s get to the <code>Arc</code> solution then.</p>
<h3 id="arc-to-the-rescue">Arc to the rescue</h3>
<p><code>Arc</code> is a smart pointer enabling sharing data between threads. Its
name is a shortcut for &#34;atomic reference counter&#34;. The way <code>Arc</code> works is
essentially to wrap a value we&#39;re trying to share and act as a pointer to it.
<code>Arc</code> keeps track of all of the copies of the pointer and as soon as
the last pointer goes out of scope it can safely free the memory. The solution
to our small problem with <code>Arc</code> would look something like this:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>std::thread::spawn;
</span></td></tr><tr><td>2</td><td><span>use </span><span>std::sync::Arc;
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>5</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>6</td><td><span>    </span><span>name</span><span>: String
</span></td></tr><tr><td>7</td><td><span>}
</span></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>10</td><td><span>    </span><span>let</span><span> user_original = Arc::new(User { name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>() });
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>13</td><td><span>    </span><span>let</span><span> t1 = </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>14</td><td><span>        println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, user.name);
</span></td></tr><tr><td>15</td><td><span>    });
</span></td></tr><tr><td>16</td><td><span>
</span></td></tr><tr><td>17</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>18</td><td><span>    </span><span>let</span><span> t2 = </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>19</td><td><span>        println!(&#34;</span><span>Hello from the first thread </span><span>{}</span><span>&#34;, user.name);
</span></td></tr><tr><td>20</td><td><span>    });
</span></td></tr><tr><td>21</td><td><span>
</span></td></tr><tr><td>22</td><td><span>    t1.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>23</td><td><span>    t2.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>24</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Let&#39;s go through it step by step. First, on line 10, we create a user value,
but we also wrap it with an <code>Arc</code>. Now the value is stored in memory and <code>Arc</code>
acts only as a pointer. Whenever we clone the <code>Arc</code> we only clone the
reference, not the user value itself. On lines 12 and 17 we clone the <code>Arc</code>
and thus a copy of the pointer is moved to each of the threads. As you can see 
<code>Arc</code> allows us to share the data regardless of the lifetimes. In this example
we will have three pointers to the user value. One created when an <code>Arc</code>
is created, one created by cloning before starting the first thread and moved to the first thread
and one created by cloning before starting the second thread and moved the first
thread. As long as any of these pointers is alive, Rust will not free the
memory. But when both the threads and the main function finish, all of the <code>Arc</code>
pointers will get out of scope, dropped and as soon as the last one drops, it
will also drop the user value.</p>
<h3 id="send-and-sync"><code>Send</code> and <code>Sync</code></h3>
<p>Let&#39;s go a bit deeper, though. If you look at the <code>Arc</code> documentation, you will
see it <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Send">implements <code>Send</code> and <code>Sync</code> traits</a>,
but <em>only</em> if the wrapped type also implements both <code>Send</code> and <code>Sync</code>. In order
to understand what it means and why it&#39;s implemented this way let&#39;s start by
defining <code>Send</code> and <code>Sync</code>.</p>
<p>The Rustonomicon <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html">defines <code>Send</code> and <code>Sync</code> as</a>:</p>
<ul>
<li>A type is Send if it is safe to send it to another thread.</li>
<li>A type is Sync if it is safe to share between threads (T is Sync if and only if &amp;T is Send).</li>
</ul>
<p>Feel free to read about these traits on Rustonomicon, but I&#39;ll also try to share
my understanding here. Both <code>Send</code> and <code>Sync</code> are traits acting as markers -
they don&#39;t have any implemented methods nor they require you to implement
anything. What they allow is to notify the compiler about a type&#39;s ability to be
shared or sent between threads. Let&#39;s start with <code>Send</code>, which is a bit more
straightforward. What it means is that you can&#39;t send type which is <code>!Send</code>
(read: not <code>Send</code>) to another thread. For example you can&#39;t send it through a
channel nor can you move it to a thread. For example this code will not compile:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>#![</span><span>feature</span><span>(negative_impls)]
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>4</td><td><span>struct </span><span>Foo {}
</span></td></tr><tr><td>5</td><td><span>impl </span><span>!Send for Foo {}
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>8</td><td><span>    </span><span>let</span><span> foo = Foo {};
</span></td></tr><tr><td>9</td><td><span>    </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>10</td><td><span>        dbg!(foo);
</span></td></tr><tr><td>11</td><td><span>    });
</span></td></tr><tr><td>12</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p><code>Send</code> and <code>Sync</code> are autoderived, meaning that for example if all of the
attributes of a type are <code>Send</code>, the type will also be <code>Send</code>. This code uses an
experimental feature called <code>negative_impls</code>, which lets us tell the compiler &#34;I
explicitly want to mark this type as <code>!Send</code>&#34;. Trying to compile this code
will result in an error:</p>
<pre><code><span>`Foo` cannot be sent between threads safely
</span></code></pre>
<p>The same would happen if you created a channel to send <code>foo</code> to a thread. So now
what with <code>Arc</code>? As you might have guessed it will also not help, this will also
error out in the same way (and the same would be true for a <code>!Sync</code> type as
<code>Arc</code> needs both traits):</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>#![</span><span>feature</span><span>(negative_impls)]
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>4</td><td><span>struct </span><span>Foo {}
</span></td></tr><tr><td>5</td><td><span>impl </span><span>!Send for Foo {}
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>8</td><td><span>    </span><span>let</span><span> foo = Arc::new(Foo {});
</span></td></tr><tr><td>9</td><td><span>    </span><span>spawn</span><span>(</span><span>move </span><span>|| {
</span></td></tr><tr><td>10</td><td><span>        dbg!(foo);
</span></td></tr><tr><td>11</td><td><span>    });
</span></td></tr><tr><td>12</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Now, why is that the case? Isn&#39;t <code>Arc</code> supposed to be wrapping our type and give it more
capabilities? While this is certainly true, <code>Arc</code> can&#39;t magically make our type
threadsafe. I will give you a more in-depth example to show you why at the end
of this article, but for now let&#39;s continue with learning on how to use these
types.</p>
<p>What we learned so far is this: <code>Arc</code> enables us to share references to types
that are <code>Send + Sync</code> between threads without us having to worry about
lifetimes (because it&#39;s not a regular reference, but rather a smart pointer).</p>
<h3 id="modifying-data-with-mutex">Modifying data with Mutex</h3>
<p>Now let&#39;s talk about <code>Mutex</code>. Mutexes in many languages are treated like
semaphores. You create a mutex object and you can guard a certain piece (or
pieces) of the code with the mutex in a way that only one thread at a time can
access the guarded place. In Rust <code>Mutex</code> behaves more like a wrapper. It
consumes the underlying value and let&#39;s you access it only after locking the
mutex. Typically <code>Mutex</code> is used with conjunction with <code>Arc</code> to make it easier
to share it between threads. Let&#39;s look at the following example:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>std::time::Duration;
</span></td></tr><tr><td>2</td><td><span>use </span><span>std::{thread, thread::sleep};
</span></td></tr><tr><td>3</td><td><span>use </span><span>std::sync::{Arc, Mutex};
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>6</td><td><span>    </span><span>name</span><span>: String
</span></td></tr><tr><td>7</td><td><span>}
</span></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>10</td><td><span>    </span><span>let</span><span> user_original = Arc::new(Mutex::new(User { name: String::from(&#34;</span><span>drogus</span><span>&#34;) }));
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>13</td><td><span>    </span><span>let</span><span> t1 = thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>14</td><td><span>        </span><span>let mut</span><span> locked_user = user.</span><span>lock</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>15</td><td><span>        locked_user.name = String::from(&#34;</span><span>piotr</span><span>&#34;);
</span></td></tr><tr><td>16</td><td><span>        </span><span>// after locked_user goes out of scope, mutex will be unlocked again,
</span></td></tr><tr><td>17</td><td><span>        </span><span>// but you can also explicitly unlock it with:
</span></td></tr><tr><td>18</td><td><span>        </span><span>// drop(locked_user);
</span></td></tr><tr><td>19</td><td><span>    });
</span></td></tr><tr><td>20</td><td><span>
</span></td></tr><tr><td>21</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>22</td><td><span>    </span><span>let</span><span> t2 = thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>23</td><td><span>        </span><span>sleep</span><span>(Duration::from_millis(</span><span>10</span><span>));
</span></td></tr><tr><td>24</td><td><span>
</span></td></tr><tr><td>25</td><td><span>        </span><span>// it will print: Hello piotr
</span></td></tr><tr><td>26</td><td><span>        println!(&#34;</span><span>Hello </span><span>{}</span><span>&#34;, user.</span><span>lock</span><span>().</span><span>unwrap</span><span>().name);
</span></td></tr><tr><td>27</td><td><span>    });
</span></td></tr><tr><td>28</td><td><span>
</span></td></tr><tr><td>29</td><td><span>    t1.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>30</td><td><span>    t2.</span><span>join</span><span>().</span><span>unwrap</span><span>();
</span></td></tr><tr><td>31</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Let&#39;s go over it. in the first line of the <code>main()</code> function we create an
instance of the <code>User</code> struct and we wrap it with a <code>Mutex</code> and an <code>Arc</code>. With
an <code>Arc</code> we can easily clone the pointer and thus share the mutex between
threads. In the 13th line you can see the mutex is locked and since that moment
the underlying value can be used exclusively by this thread. Then we modify the
value in the next line. The mutex is unlocked once the locked guard goes out of
scope or we manually drop it with <code>drop(locked_user)</code>.</p>
<p>In the second thread we wait 10ms and print the name, which should be the name
updated in the first thread. This time locking is done in one line, so the mutex
will be dropped in the same statement.</p>
<p>One more thing that is worth mentioning is the <code>unwrap()</code> method we call after
<code>lock()</code>. <code>Mutex</code> from the standard library has a notion of being poisoned.
If a thread panics while the mutex is locked we can&#39;t be certain if the value
inside <code>Mutex</code> is still valid and thus the default behaviour is to return an
error instead of a guard. So <code>Mutex</code> can either return an <code>Ok()</code> variant with
the wrapped value as an argument or an error. You can read more about it <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning">in the
docs</a>. In
general leaving <code>unrwap()</code> methods in the production code is not recommended,
but in case of <code>Mutex</code> it might be a valid strategy - if a mutex has been
poisoned we might decide that the application state is invalid and crash the
application.</p>
<p>Another interesting thing about <code>Mutex</code> is that as long as a type inside the
<code>Mutex</code> is <code>Send</code>, <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync"><code>Mutex</code> will also be
<code>Sync</code></a>. This
is because <code>Mutex</code> ensures that only one thread can get access to the underlying
value and thus it&#39;s safe to share <code>Mutex</code> between threads.</p>
<h3 id="mutex-add-sync-to-a-send-type"><code>Mutex</code>: add <code>Sync</code> to a <code>Send</code> type</h3>
<p>As you may remember from the beginning of the article, <code>Arc</code> needs an underlying
type to be <code>Send + Sync</code> in order for <code>Arc</code> to be <code>Send + Sync</code> too. <code>Mutex</code>
only requires and underlying type to be <code>Send</code> in order for <code>Mutex</code> to be <code>Send + Sync</code>. In other words <code>Mutex</code> will make a <code>!Sync</code> type <code>Sync</code>, so you can
share it between threads and modify it too.</p>
<h3 id="mutex-without-arc"><code>Mutex</code> without <code>Arc</code>?</h3>
<p>An interesting question that you may ask is if <code>Mutex</code> can be used without
<code>Arc</code>. I encourage you to think about it a little before reading further: what
does it mean that <code>Mutex</code> is <code>Send + Sync</code> for types that are <code>Send</code>?</p>
<p>If you get back to the first part of this post you can see what it means for the
<code>Arc</code> type and in case of <code>Mutex</code> it means a very similar thing. If we can use
something like scope threads it&#39;s entirely possible to use <code>Mutex</code> without
<code>Arc</code>:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>crossbeam::scope;
</span></td></tr><tr><td>2</td><td><span>use </span><span>std::{sync::Mutex, thread::sleep, time::Duration};
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>5</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>6</td><td><span>    </span><span>name</span><span>: String,
</span></td></tr><tr><td>7</td><td><span>}
</span></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>10</td><td><span>    </span><span>let</span><span> user = Mutex::new(User {
</span></td></tr><tr><td>11</td><td><span>        name: &#34;</span><span>drogus</span><span>&#34;.</span><span>to_string</span><span>(),
</span></td></tr><tr><td>12</td><td><span>    });
</span></td></tr><tr><td>13</td><td><span>
</span></td></tr><tr><td>14</td><td><span>    </span><span>scope</span><span>(|</span><span>s</span><span>| {
</span></td></tr><tr><td>15</td><td><span>        s.</span><span>spawn</span><span>(|_| {
</span></td></tr><tr><td>16</td><td><span>            user.</span><span>lock</span><span>().</span><span>unwrap</span><span>().name = String::from(&#34;</span><span>piotr</span><span>&#34;);
</span></td></tr><tr><td>17</td><td><span>        });
</span></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td>19</td><td><span>        s.</span><span>spawn</span><span>(|_| {
</span></td></tr><tr><td>20</td><td><span>            </span><span>sleep</span><span>(Duration::from_millis(</span><span>10</span><span>));
</span></td></tr><tr><td>21</td><td><span>
</span></td></tr><tr><td>22</td><td><span>            </span><span>// should print: Hello piotr
</span></td></tr><tr><td>23</td><td><span>            println!(&#34;</span><span>Hello </span><span>{}</span><span>&#34;, user.</span><span>lock</span><span>().</span><span>unwrap</span><span>().name);
</span></td></tr><tr><td>24</td><td><span>        });
</span></td></tr><tr><td>25</td><td><span>    })
</span></td></tr><tr><td>26</td><td><span>    .</span><span>unwrap</span><span>();
</span></td></tr><tr><td>27</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>In this program we achieve the same goal. We are accessing a value behind a mutex in
two separate threads, but we share mutexes by reference and not by using an <code>Arc</code>. But
again, this is not always possible, for example in async code, so <code>Mutex</code> is
very often used along with <code>Arc</code>.</p>
<h3 id="summary">Summary</h3>
<p>I&#39;m hoping that in this article I helped you understand what are <code>Arc</code> and
<code>Mutex</code> types in Rust and how to use them. To sum it up I would say you would
typically use <code>Arc</code> whenever you want to share data between threads and you
can&#39;t do so using regular references. You would also use <code>Mutex</code> if you need to
modify data you share between threads. And then you would use
<code>Arc&lt;Mutex&lt;...&gt;&gt;</code> whenever you want to modify data you share between threads and
you can&#39;t share a mutex using references.</p>
<h3 id="bonus-why-arc-needs-type-to-be-sync">Bonus: Why <code>Arc</code> needs type to be <code>Sync</code></h3>
<p>Now let&#39;s get back to the question of &#34;why <code>Arc</code> needs the underlying type to be
both <code>Send</code> and <code>Sync</code> to mark it as <code>Send</code> and <code>Sync</code>). Feel free to ignore
this last section, though, it&#39;s not really needed for you to use <code>Arc</code> and
<code>Mutex</code> in your code. It might help you understand markter traits a bit better.</p>
<p>Lets take <code>Cell</code> as an example. <code>Cell</code> wraps another type and
enables &#34;interior mutability&#34; or in other words it allows us to modify a value
inside an immutable struct. <code>Cell</code> is <code>Send</code>, but it&#39;s <code>!Sync</code>.</p>
<p>An example of using <code>Cell</code> would be:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>std::cell::Cell;
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>4</td><td><span>    </span><span>age</span><span>: Cell&lt;</span><span>usize</span><span>&gt;
</span></td></tr><tr><td>5</td><td><span>}
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>8</td><td><span>    </span><span>let</span><span> user = User { age: Cell::new(</span><span>30</span><span>) };
</span></td></tr><tr><td>9</td><td><span>
</span></td></tr><tr><td>10</td><td><span>    user.age.</span><span>set</span><span>(</span><span>36</span><span>);
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    </span><span>// will print: Age: 36
</span></td></tr><tr><td>13</td><td><span>    println!(&#34;</span><span>Age: </span><span>{}</span><span>&#34;, user.age.</span><span>get</span><span>());
</span></td></tr><tr><td>14</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p><code>Cell</code> is useful in some situations, but it isn&#39;t thread safe or in other words
it&#39;s <code>!Sync</code>. If you somehow shared a value wrapped in a cell between multiple threads you could modify the
same place in memory from two threads, for example:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>// this example will not compile, `Cell` is `!Sync` and thus
</span></td></tr><tr><td>2</td><td><span>// `Arc` will be `!Sync` and `!Send`
</span></td></tr><tr><td>3</td><td><span>use </span><span>std::cell::Cell;
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>6</td><td><span>    </span><span>age</span><span>: Cell&lt;</span><span>usize</span><span>&gt;
</span></td></tr><tr><td>7</td><td><span>}
</span></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>10</td><td><span>    </span><span>let</span><span> user_original = Arc::new(User { age: Cell::new(</span><span>30</span><span>) });
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>13</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>14</td><td><span>        user.age.</span><span>set</span><span>(</span><span>2</span><span>);
</span></td></tr><tr><td>15</td><td><span>    });
</span></td></tr><tr><td>16</td><td><span>
</span></td></tr><tr><td>17</td><td><span>    </span><span>let</span><span> user = user_original.</span><span>clone</span><span>();
</span></td></tr><tr><td>18</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>19</td><td><span>        user.age.</span><span>set</span><span>(</span><span>3</span><span>);
</span></td></tr><tr><td>20</td><td><span>    });
</span></td></tr><tr><td>21</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>If that worked, it could result in an undefined behaviour. That&#39;s why <code>Arc</code> will
not work with any type that is not <code>Send</code> <em>nor</em> <code>Sync</code>. At the same time <code>Cell</code>
is <code>Send</code>, meaning that you can send it between threads. Why is that? Sending,
or in other words moving, will not make a value accessible from more than one
thread, it will have to always be only one thread. Once you move it to another,
the previous thread doesn&#39;t own the value anymore. With that in mind, we can
always mutate a <code>Cell</code> locally.</p>
<h3 id="bonus-why-arc-needs-type">Bonus: why <code>Arc</code> needs type</h3>
<p>At this point you might also wonder why <code>Arc</code> will not provide the <code>Send</code> trait
for a <code>!Send</code> type, either. One of the types in Rust which is <code>!Send</code> is <code>Rc</code>.
<code>Rc</code> is a cousin of <code>Arc</code>, but it&#39;s not &#34;atomic&#34;, <code>Rc</code> expands to just
&#34;reference counter&#34;. Its role is pretty much the same as <code>Arc</code>, but it can only
be used in a single thread. Not only it can&#39;t be shared between threads, but
also it can&#39;t be moved between threads. Let&#39;s see why.</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>// this code won&#39;t compile, Rc is !Send and !Sync
</span></td></tr><tr><td>2</td><td><span>use </span><span>std::rc::Rc;
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>5</td><td><span>    </span><span>let</span><span> foo = Rc::new(</span><span>1</span><span>);
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>    </span><span>let</span><span> foo_clone = foo.</span><span>clone</span><span>();
</span></td></tr><tr><td>8</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>9</td><td><span>        dbg!(foo_clone);
</span></td></tr><tr><td>10</td><td><span>    });
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>    </span><span>let</span><span> foo_clone = foo.</span><span>clone</span><span>();
</span></td></tr><tr><td>13</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>14</td><td><span>        dbg!(foo_clone);
</span></td></tr><tr><td>15</td><td><span>    });
</span></td></tr><tr><td>16</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>This example won&#39;t compile, because <code>Rc</code> is <code>!Sync + !Send</code>. Its internal
counter is not atomic and thus sharing it between threads could result in an
inaccurate count of references. Now imagine that <code>Arc</code> would make <code>!Send</code> types
<code>Send</code>:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>use </span><span>std::rc::Rc;
</span></td></tr><tr><td>2</td><td><span>use </span><span>std::sync::Arc;
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span>#[</span><span>derive</span><span>(Debug)]
</span></td></tr><tr><td>5</td><td><span>struct </span><span>User {
</span></td></tr><tr><td>6</td><td><span>    </span><span>name</span><span>: Rc&lt;String&gt;,
</span></td></tr><tr><td>7</td><td><span>}
</span></td></tr><tr><td>8</td><td><span>unsafe impl </span><span>Send </span><span>for </span><span>User {}
</span></td></tr><tr><td>9</td><td><span>unsafe impl </span><span>Sync </span><span>for </span><span>User {}
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span>fn </span><span>main</span><span>() {
</span></td></tr><tr><td>12</td><td><span>    </span><span>let</span><span> foo = Arc::new(User {
</span></td></tr><tr><td>13</td><td><span>        name: Rc::new(String::from(&#34;</span><span>drogus</span><span>&#34;)),
</span></td></tr><tr><td>14</td><td><span>    });
</span></td></tr><tr><td>15</td><td><span>
</span></td></tr><tr><td>16</td><td><span>    </span><span>let</span><span> foo_clone = foo.</span><span>clone</span><span>();
</span></td></tr><tr><td>17</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>18</td><td><span>        </span><span>let</span><span> name = foo_clone.name.</span><span>clone</span><span>();
</span></td></tr><tr><td>19</td><td><span>    });
</span></td></tr><tr><td>20</td><td><span>
</span></td></tr><tr><td>21</td><td><span>    </span><span>let</span><span> foo_clone = foo.</span><span>clone</span><span>();
</span></td></tr><tr><td>22</td><td><span>    std::thread::spawn(</span><span>move </span><span>|| {
</span></td></tr><tr><td>23</td><td><span>        </span><span>let</span><span> name = foo_clone.name.</span><span>clone</span><span>();
</span></td></tr><tr><td>24</td><td><span>    });
</span></td></tr><tr><td>25</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>This example will compile, but it&#39;s wrong, please don&#39;t do it in your actual
code! In here I define a <code>User</code> struct, which holds an <code>Rc</code> inside. Because
<code>Send</code> and <code>Sync</code> are autoderived and <code>Rc</code> is <code>!Send + !Sync</code>, the <code>User</code> struct
should also be <code>!Send + !Sync</code>, but we can explicitly tell the compiler to mark
it differently, in this case <code>Send + Sync</code>, using <code>unsafe impl</code> syntax.</p>
<p>Now you can clearly see what would go wrong if <code>Arc</code> allowed <code>!Send</code> types to be
moved between threads. In the example <code>Arc</code> clones are moved into separate
threads and then nothing is stopping us from cloning the <code>Rc</code> type. And because
<code>Rc</code> type is not thread safe, it could result in an inacurate count of
references and thus could either free memory too soon or it could not free it at
all even though it should.</p>
<p>I know that this article is a long one, so kudos too all of you that got it all
the way here, thanks!</p>



    <div>
      <hr/>
      <p>If you like this post please consider following me on <a href="https://twitter.com/drogus">Twitter</a>!</p>
  </div>

	

  

  </div></div></div>
  </body>
</html>
