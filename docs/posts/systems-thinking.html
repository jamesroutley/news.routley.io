<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://theprogrammersparadox.blogspot.com/2026/02/systems-thinking.html">Original</a>
    <h1>Systems Thinking</h1>
    
    <div id="readability-page-1" class="page"><div><p>Nice observation. Captures what software engineering is supposed to mean I think. In the pre-small system days, systems like telephony switches or airlinre reservation systems were engineered. Constraints of time and money made the upfront design worthwhile. Brooks&#39; famous Mythical Man-Month observations were an extreme case, where R&amp;D and engineering were intertwined, they tried to design a new approach to OS&#39;s while shipping one. Same with Multics. The lessons learned there led to the small Bell Labs team success with Unix that we all love :-)  The engineering behind it stood on solid research about semaphores, regular expressions, parsing and grammars, etc. As computing got cheaper and more accessible, we could afford toe experiment and iterate, and evolve systems as you put it. It makes total sense. However it does present maintenance issues, since the structure can grow to be byzantine. It has become a social activity to write readeable code that works and can be maintained. With LLM&#39;s we can strive for the same thing if we make sure to understand and communicate the underlying engineering behind our design decicions. To manage dependencies well, they must be contained, and this goes against the business model of software upgrades for profit (sometimes).  I think the example I like best for a posterchild of good engineering for complex systems is the compiler one. A solid theoretical foundation, lots of rigourous multi-environment testing, and an evolution path as research comes in about things like optimization techniques.  </p><p><span><a target="_self" data-comment-id="4329747788758435084">Reply</a><span><a target="_self" href="https://www.blogger.com/comment/delete/6104420435021904082/4329747788758435084">Delete</a></span></span></p></div></div>
  </body>
</html>
