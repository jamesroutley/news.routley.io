<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gavinray97.github.io/blog/adding-invariant-to-cpp-design-by-contract">Original</a>
    <h1>Adding design-by-contract conditions to C&#43;&#43; via a GCC plugin</h1>
    
    <div id="readability-page-1" class="page"><div><details open=""><summary>Table of Contents</summary></details><hr/><blockquote><p>Note: You can find the source code for this project here: <a target="_blank" rel="noopener noreferrer" href="https://github.com/GavinRay97/gcc-invariant-plugin">https://github.com/GavinRay97/gcc-invariant-plugin</a></p></blockquote><p>Last month, GCC landed support for <strong>Contracts</strong> in trunk:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=ea63396f6b08f88f1cde827e6cab94cd488f7fa7">https://gcc.gnu.org/git/?p=gcc.git;a=commit;h=ea63396f6b08f88f1cde827e6cab94cd488f7fa7</a></li></ul><p>If you aren&#39;t a C++ developer, or you are a C++ developer but haven&#39;t followed the Contracts feature/don&#39;t have an interest in Design-by-Contract, what this proposal does is allow you to annotate your functions with <strong>pre/post conditions</strong> that are checked when the method is called.</p><p>A trivial example might be something like:</p><div><pre><code><span><span>int</span> <span>divide_returns_gt_10</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span>
</span><span>  <span>[</span><span>[</span>pre<span>:</span> a <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> b <span>&gt;</span> <span>0</span><span>]</span><span>]</span> 
</span><span>  <span>[</span><span>[</span>post r<span>:</span> r <span>&gt;</span> <span>10</span><span>]</span><span>]</span>      
</span><span><span>{</span>
</span><span>    <span>return</span> a <span>/</span> b<span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>This functionality is fantastic because it allows you to encode your requirements and assertions declaratively into your methods.</p><p>But, the most powerful feature of Design-by-Contract is the <strong><code>invariant</code></strong>. An <code>invariant</code> condition allows you to write a set of assertions/assumptions about the state of an object/program that should always hold true.</p><p><strong>Invariants</strong> are incredibly useful <em><strong>for enforcing properties of systems</strong></em>, or data structures. Especially when the validity of a data structure requires conforming to a set of properties.</p><p>In my free time over the last 6-8 months, I&#39;ve been writing a database from scratch.</p><p>As a highschool dropout, this experience has been... a lot different than what I thought it would be.</p><p>There are many things you pick up as part of a CS degree that (I now know) are assumed knowledge when working on databases. One of those things is the family of B-Trees.</p><p>Like many folks, I&#39;m on holiday, and it&#39;s been a great time for study. Except I&#39;ve grown exceedingly infuriated at my own seeming inability to do basic CS tasks. Like write a proper B+ Tree:</p><blockquote><p>If anyone reads my feed and thinks:</p></blockquote><p>My code had all the shape and feel of a tree-like structure, but it wasn&#39;t preserving the properties of a B+ Tree.</p><p>I was ending up with garbage, and not realizing it until I had visualized it with Graphviz! üôÅ</p><p>Imagine if we had invariants that we could assert after every property change to the tree.</p><p>Below is an example of what an invariant implementation for a B-Tree data structure might look like:</p><div><pre><code><span><span>struct</span> <span>BTree</span>
</span><span><span>{</span>
</span><span>  <span>[</span><span>[</span>invariant<span>]</span><span>]</span>
</span><span>  <span>void</span> <span>check_invariants</span><span>(</span><span>)</span> <span>{</span> <span>check_node_invariants</span><span>(</span>root<span>)</span><span>;</span> <span>}</span>
</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  <span>void</span> <span>check_node_invariants</span><span>(</span>Node<span>*</span> node<span>)</span>
</span><span>  <span>{</span>
</span><span>    <span>if</span> <span>(</span>node <span>==</span> <span>nullptr</span><span>)</span>
</span><span>      <span>return</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>assert</span><span>(</span>node<span>-&gt;</span>num_children <span>&lt;=</span> MAX_VALUES <span>+</span> <span>1</span><span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span>node<span>-&gt;</span><span>is_internal</span><span>(</span><span>)</span><span>)</span>
</span><span>      <span>assert</span><span>(</span>node<span>-&gt;</span>num_children <span>&gt;=</span> MIN_VALUES<span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>!</span>node<span>-&gt;</span><span>is_leaf</span><span>(</span><span>)</span><span>)</span>
</span><span>      <span>assert</span><span>(</span>node<span>-&gt;</span>num_children <span>&gt;=</span> <span>2</span><span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>!</span>node<span>-&gt;</span><span>is_leaf</span><span>(</span><span>)</span><span>)</span>
</span><span>      <span>assert</span><span>(</span>node<span>-&gt;</span>num_children <span>==</span> node<span>-&gt;</span>num_values <span>+</span> <span>1</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> node<span>-&gt;</span>num_children<span>;</span> i<span>++</span><span>)</span>
</span><span>      <span>check_node_invariants</span><span>(</span>node<span>-&gt;</span>children<span>[</span>i<span>]</span><span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span><span>}</span><span>;</span>
</span></code></pre></div><p>Now, assuming that this <code>check_invariants</code> method is called any time that our B-Tree changes, we can be 100% sure that it&#39;s a proper B-Tree.</p><p>Super powerful!</p><p>The rest of this article will walk through what it means to make this sentence come to life:</p><blockquote><p><em>Now, assuming that this <code>check_invariant</code> method is called any time that our B-Tree changes...</em></p></blockquote><p>There are a few things to be said about developing GCC plugins:</p><ul><li>Documentation is essentially non-existent</li><li>There are few people with experience working with the GCC IR API&#39;s (GIMPLE/RTL etc)</li><li>Most of existing plugins and examples you can find online have to do with analysis, and so show read-only usage of the API&#39;s.</li></ul><p>The following code is cobbled together primarily from examples taken from these two blogposts:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html">https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://stephanfr.blog/2013/05/19/building-gcc-plugins-part-1-c-11-generalized-attributes/">https://stephanfr.blog/2013/05/19/building-gcc-plugins-part-1-c-11-generalized-attributes/</a></li></ul><p>The working code for insertion of the <code>check_invariants</code> statements was a stroke of dumb luck after 15 hours, from one of the suggestions given by Github Copilot.</p><p>(More on this later. I&#39;m not fully happy with the insertion code, because it depends on implicit fallback to the <code>this-&gt;</code> member namespace rather than an explicit call)</p><p>With that said, let&#39;s begin!</p><h2 id="setting-up"><a href="#setting-up" aria-hidden="true" tabindex="-1"><span></span></a>Setting Up</h2><p>If you&#39;re following along at home (this will be an easy one, it requires just a <code>CMakeLists.txt</code> and a single <code>.cpp</code> file), this is the CMake definition we&#39;ll be using to build and test our plugin code:</p><div><pre><code><span><span>project</span><span>(</span>gcc-invariant-plugin<span>)</span>
</span><span><span>set</span><span>(</span><span>CMAKE_EXPORT_COMPILE_COMMANDS</span> <span>ON</span><span>)</span>
</span><span>
</span><span><span>set</span><span>(</span>G++_COMPILER /usr/local/gcc-dev/bin/g++<span>)</span>
</span><span><span>set</span><span>(</span>GCC_PLUGIN_DIR /usr/local/gcc-dev/lib/gcc/x86_64-linux-gnu/<span>13.0.0</span>/plugin<span>)</span>
</span><span>
</span><span><span>add_library</span><span>(</span>gcc-invariant-plugin <span>SHARED</span> src/plugin.cpp<span>)</span>
</span><span><span>target_compile_options</span><span>(</span>gcc-invariant-plugin <span>PRIVATE</span> -fno-rtti<span>)</span>
</span><span><span>target_include_directories</span><span>(</span>gcc-invariant-plugin <span>PRIVATE</span> <span>${</span>GCC_PLUGIN_DIR<span>}</span>/include<span>)</span>
</span><span>
</span><span>
</span><span><span>add_custom_command</span><span>(</span>TARGET gcc-invariant-plugin POST_BUILD
</span><span>    COMMAND <span>${</span><span>CMAKE_COMMAND</span><span>}</span> -E copy_if_different
</span><span>        <span>${</span><span>CMAKE_CURRENT_BINARY_DIR</span><span>}</span>/compile_commands.json
</span><span>        <span>${</span><span>CMAKE_CURRENT_SOURCE_DIR</span><span>}</span>/compile_commands.json
</span><span><span>)</span>
</span><span>
</span><span>
</span><span><span>add_custom_target</span><span>(</span>run-gcc ALL
</span><span>    COMMAND <span>${</span>G++_COMPILER<span>}</span> -fplugin=./libgcc-invariant-plugin.so -std=c++<span>20</span> -O0 -g -ggdb3 -fcontracts
</span><span>            -o <span>${</span><span>CMAKE_CURRENT_SOURCE_DIR</span><span>}</span>/test-binary
</span><span>            <span>${</span><span>CMAKE_CURRENT_SOURCE_DIR</span><span>}</span>/test/test.cpp
</span><span>    <span>DEPENDS</span> gcc-invariant-plugin
</span><span>    <span>WORKING_DIRECTORY</span> <span>${</span><span>CMAKE_CURRENT_BINARY_DIR</span><span>}</span>
</span><span><span>)</span>
</span></code></pre></div><p>This assumes a directory layout like:</p><div><pre><code><span>‚îú‚îÄ‚îÄ CMakeLists.txt
</span><span>‚îú‚îÄ‚îÄ src
</span><span>‚îÇ   ‚îî‚îÄ‚îÄ plugin.cpp
</span><span>‚îî‚îÄ‚îÄ test
</span><span>    ‚îî‚îÄ‚îÄ test.cpp
</span></code></pre></div><h2 id="initial-skeleton"><a href="#initial-skeleton" aria-hidden="true" tabindex="-1"><span></span></a>Initial Skeleton</h2><p>Now, we can mimic the structure of Gabriele&#39;s plugin, with some slight changes and using the scoped-plugin sample from Stephan&#39;s post. This is so that we can call our attribute [[demo::invariant]] to distinguish it from a language-level attribute.</p><p>What we want is to create a skeleton plugin that does two things:</p><ul><li>Create a new custom attribute, <code>[[demo::invariant]]</code> that we can use and check for the existence of</li><li>Hook into the parsing of struct/class member functions, and performs some &#34;Hello-world&#34; like behavior to check that it&#39;s working as intended</li></ul><p>With these two things, we would have much of the ingredients needed for adding <code>invariant</code> support to C++!</p><p>To do this, looks something like the below:</p><ol><li>First, we include some order-sensitive (hooray!) headers:</li></ol><div><pre><code><span>
</span><span>
</span><span><span><span>#</span><span>include</span> <span>&lt;gcc-plugin.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;context.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;plugin-version.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;tree.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;gimple.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;tree-pass.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;attribs.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;tree-pretty-print.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;plugin.h&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;cp/cp-tree.h&gt;</span></span>
</span><span>
</span></code></pre></div><ol start="2"><li>Next, we define some general configuration settings for our plugin:</li></ol><div><pre><code><span><span>namespace</span>
</span><span><span>{</span>
</span><span>
</span><span>
</span><span>
</span><span><span>constexpr</span> <span>auto</span> DEBUG <span>=</span> <span>1</span><span>;</span>
</span><span>
</span><span><span>constexpr</span> <span>auto</span> ATTRIBUTE_NAME   <span>=</span> <span>&#34;invariant&#34;</span><span>;</span>
</span><span><span>constexpr</span> <span>auto</span> PLUGIN_VERSION   <span>=</span> <span>&#34;0.1&#34;</span><span>;</span>
</span><span><span>constexpr</span> <span>auto</span> PLUGIN_HELP      <span>=</span> <span>&#34;This plugin instruments functions with the invariant attribute&#34;</span><span>;</span>
</span><span><span>constexpr</span> <span>auto</span> PLUGIN_NAME      <span>=</span> <span>&#34;invariant_plugin&#34;</span><span>;</span>
</span><span><span>constexpr</span> <span>auto</span> PLUGIN_GCC_BASEV <span>=</span> <span>&#34;13.0.0&#34;</span><span>;</span>
</span><span>
</span><span></span><span></span><span>
</span><span><span>const</span> <span>struct</span> <span>plugin_info</span> invariant_plugin_info <span>=</span> <span>{</span>
</span><span>  <span>.</span>version <span>=</span> PLUGIN_VERSION<span>,</span>
</span><span>  <span>.</span>help    <span>=</span> PLUGIN_HELP<span>,</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span></span><span></span><span>
</span><span><span>const</span> <span>struct</span> <span>plugin_gcc_version</span> invariant_plugin_version <span>=</span> <span>{</span>
</span><span>  <span>.</span>basever <span>=</span> PLUGIN_GCC_BASEV<span>,</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span><span>}</span><span>;</span> 
</span></code></pre></div><ol start="3"><li>We define the configuration and callback handlers for a custom <code>[[demo::invariant]]</code> attribute (this does not register the attribute yet)</li></ol><div><pre><code><span><span>namespace</span>
</span><span><span>{</span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span></span><span></span><span></span><span>
</span><span>tree
</span><span><span>handle_invariant_attribute</span><span>(</span>tree<span>*</span> node<span>,</span> tree name<span>,</span> tree args<span>,</span> <span>int</span> flags<span>,</span> <span>bool</span><span>*</span> no_add_attrs<span>)</span>
</span><span><span>{</span>
</span><span>  <span>if</span> <span>constexpr</span> <span>(</span>DEBUG <span>==</span> <span>1</span><span>)</span>
</span><span>  <span>{</span>
</span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;&gt; Found attribute\n&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\tnode = &#34;</span><span>)</span><span>;</span>
</span><span>    <span>print_generic_stmt</span><span>(</span><span>stderr</span><span>,</span> <span>*</span>node<span>,</span> TDF_NONE<span>)</span><span>;</span>
</span><span>
</span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\tname = &#34;</span><span>)</span><span>;</span>
</span><span>    <span>print_generic_stmt</span><span>(</span><span>stderr</span><span>,</span> name<span>,</span> TDF_NONE<span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span>  <span>return</span> NULL_TREE<span>;</span>
</span><span><span>}</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span>
</span><span>
</span><span>
</span><span><span>const</span> <span>struct</span> <span>attribute_spec</span> invariant_attribute <span>=</span> <span>{</span>
</span><span>  
</span><span>  <span>.</span>name                   <span>=</span> <span>&#34;invariant&#34;</span><span>,</span>
</span><span>  <span>.</span>min_length             <span>=</span> <span>0</span><span>,</span>
</span><span>  <span>.</span>max_length             <span>=</span> <span>0</span><span>,</span>
</span><span>  <span>.</span>decl_required          <span>=</span> <span>true</span><span>,</span>
</span><span>  <span>.</span>type_required          <span>=</span> <span>false</span><span>,</span>
</span><span>  <span>.</span>function_type_required <span>=</span> <span>false</span><span>,</span>
</span><span>  <span>.</span>affects_type_identity  <span>=</span> <span>false</span><span>,</span>
</span><span>  <span>.</span>handler                <span>=</span> handle_invariant_attribute<span>,</span>
</span><span>  <span>.</span>exclude                <span>=</span> <span>nullptr</span><span>,</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span>
</span><span><span>const</span> attribute_spec scoped_attributes<span>[</span><span>]</span> <span>=</span> <span>{</span>
</span><span>  invariant_attribute<span>,</span>
</span><span>  <span>{</span> <span>NULL</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>false</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span> <span>}</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span></span><span></span><span>
</span><span><span>void</span>
</span><span><span>register_attributes</span><span>(</span><span>void</span><span>*</span> event_data<span>,</span> <span>void</span><span>*</span> data<span>)</span>
</span><span><span>{</span>
</span><span>  <span>warning</span><span>(</span><span>0</span><span>,</span> <span>&#34;Callback to register attributes&#34;</span><span>)</span><span>;</span>
</span><span>  <span>register_scoped_attributes</span><span>(</span>scoped_attributes<span>,</span> <span>&#34;demo&#34;</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>}</span><span>;</span> 
</span></code></pre></div><ol start="4"><li>We define the configuration and handler for a GIMPLE pass, which we will eventually use to insert calls to the <code>[[demo::invariant]]</code>-marked function. For now, it only prints out the name of member functions which should be processed.</li></ol><div><pre><code><span><span>namespace</span>
</span><span><span>{</span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span></span><span></span><span>
</span><span><span>unsigned</span> <span>int</span>
</span><span><span>instrument_invariants_plugin_exec</span><span>(</span><span>void</span><span>)</span>
</span><span><span>{</span>
</span><span>  
</span><span>  tree fndecl <span>=</span> current_function_decl<span>;</span>
</span><span>
</span><span>  
</span><span>  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;&gt; Inspecting function &#39;%s&#39;\n&#34;</span><span>,</span> <span>IDENTIFIER_POINTER</span><span>(</span><span>DECL_NAME</span><span>(</span>fndecl<span>)</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>if</span> <span>(</span><span>TREE_CODE</span><span>(</span><span>DECL_CONTEXT</span><span>(</span>fndecl<span>)</span><span>)</span> <span>!=</span> RECORD_TYPE<span>)</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span>
</span><span>  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t - Found a member function of a struct/class\n&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span>  <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span>
</span><span><span>const</span> <span>struct</span> <span>pass_data</span> invariant_pass_data <span>=</span> <span>{</span>
</span><span>  <span>.</span>type                 <span>=</span> GIMPLE_PASS<span>,</span>     
</span><span>  <span>.</span>name                 <span>=</span> PLUGIN_NAME<span>,</span>     
</span><span>  <span>.</span>optinfo_flags        <span>=</span> OPTGROUP_NONE<span>,</span>   
</span><span>  <span>.</span>tv_id                <span>=</span> TV_NONE<span>,</span>         
</span><span>  <span>.</span>properties_required  <span>=</span> PROP_gimple_any<span>,</span> 
</span><span>  <span>.</span>properties_provided  <span>=</span> <span>0</span><span>,</span>               
</span><span>  <span>.</span>properties_destroyed <span>=</span> <span>0</span><span>,</span>               
</span><span>  <span>.</span>todo_flags_start     <span>=</span> <span>0</span><span>,</span>               
</span><span>  <span>.</span>todo_flags_finish <span>=</span>
</span><span>    TODO_update_ssa <span>|</span> TODO_cleanup_cfg     
</span><span><span>}</span><span>;</span>
</span><span>
</span><span></span><span></span><span></span><span></span><span>
</span><span><span>class</span> <span>invariant_gimple_pass</span> <span>:</span> <span><span>public</span> <span>gimple_opt_pass</span></span>
</span><span><span>{</span>
</span><span><span>public</span><span>:</span>
</span><span>  </span><span></span><span>
</span><span>  <span>invariant_gimple_pass</span><span>(</span><span>const</span> pass_data<span>&amp;</span> data<span>,</span> gcc<span>::</span>context<span>*</span> ctxt<span>)</span>
</span><span>    <span>:</span> <span>gimple_opt_pass</span><span>(</span>data<span>,</span> ctxt<span>)</span>
</span><span>  <span>{</span>
</span><span>  <span>}</span>
</span><span>
</span><span>  </span><span></span><span></span><span></span><span>
</span><span>  <span>unsigned</span> <span>int</span> <span>execute</span><span>(</span>function<span>*</span> exec_fun<span>)</span> <span>{</span> <span>return</span> <span>instrument_invariants_plugin_exec</span><span>(</span><span>)</span><span>;</span> <span>}</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span><span>}</span><span>;</span> 
</span></code></pre></div><ol start="5"><li>Finally, we define the entry point for the plugin, <code>plugin_init</code>, which is called by GCC when the plugin is loaded. We register the attribute and the GIMPLE pass.</li></ol><div><pre><code><span>
</span><span>
</span><span>
</span><span>
</span><span><span>int</span> plugin_is_GPL_compatible<span>;</span>
</span><span>
</span><span></span><span></span><span>
</span><span><span>int</span>
</span><span><span>plugin_init</span><span>(</span>plugin_name_args<span>*</span> plugin_info<span>,</span> plugin_gcc_version<span>*</span> version<span>)</span>
</span><span><span>{</span>
</span><span>  <span>if</span> <span>(</span><span>!</span><span>plugin_default_version_check</span><span>(</span>version<span>,</span> <span>&amp;</span>gcc_version<span>)</span><span>)</span>
</span><span>    <span>return</span> <span>1</span><span>;</span>
</span><span>
</span><span>  <span>register_callback</span><span>(</span>plugin_info<span>-&gt;</span>base_name<span>,</span> PLUGIN_INFO<span>,</span> <span>NULL</span><span>,</span> <span>(</span><span>void</span><span>*</span><span>)</span> <span>&amp;</span>invariant_plugin_info<span>)</span><span>;</span>
</span><span>  <span>printf</span><span>(</span><span>&#34;&gt; plugin &#39;%s @ %s&#39; was loaded onto GCC\n&#34;</span><span>,</span> PLUGIN_NAME<span>,</span> PLUGIN_VERSION<span>)</span><span>;</span>
</span><span>
</span><span>  register_pass_info invariant_pass <span>=</span> <span>{</span>
</span><span>    <span>.</span>pass                     <span>=</span> <span>new</span> <span>invariant_gimple_pass</span><span>(</span>invariant_pass_data<span>,</span> g<span>)</span><span>,</span>
</span><span>    <span>.</span>reference_pass_name      <span>=</span> <span>&#34;ssa&#34;</span><span>,</span> 
</span><span>    <span>.</span>ref_pass_instance_number <span>=</span> <span>1</span><span>,</span>     
</span><span>    <span>.</span>pos_op                   <span>=</span> PASS_POS_INSERT_AFTER<span>,</span>
</span><span>  <span>}</span><span>;</span>
</span><span>
</span><span>  <span>register_callback</span><span>(</span>plugin_info<span>-&gt;</span>base_name<span>,</span> PLUGIN_PASS_MANAGER_SETUP<span>,</span> <span>NULL</span><span>,</span> <span>&amp;</span>invariant_pass<span>)</span><span>;</span>
</span><span>  <span>register_callback</span><span>(</span>plugin_info<span>-&gt;</span>base_name<span>,</span> PLUGIN_ATTRIBUTES<span>,</span> register_attributes<span>,</span> <span>NULL</span><span>)</span><span>;</span>
</span><span>
</span><span>  <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><h3 id="testing-the-skeleton"><a href="#testing-the-skeleton" aria-hidden="true" tabindex="-1"><span></span></a>Testing the Skeleton</h3><p>Now that we have the bare-bones outline of the plugin, lets create a test-case file that we&#39;ll use throughout the rest of this post, and run the plugin against it.</p><div><pre><code><span>
</span><span><span><span>#</span><span>include</span> <span>&lt;cassert&gt;</span></span>
</span><span><span><span>#</span><span>include</span> <span>&lt;iostream&gt;</span></span>
</span><span>
</span><span><span>class</span> <span>Stack</span>
</span><span><span>{</span>
</span><span><span>private</span><span>:</span>
</span><span>  <span>static</span> <span>constexpr</span> <span>int</span> MAX_SIZE <span>=</span> <span>100</span><span>;</span>
</span><span>
</span><span>  <span>int</span> top <span>=</span> <span>0</span><span>;</span>
</span><span>  <span>int</span> old_top <span>=</span> <span>0</span><span>;</span>
</span><span>  <span>int</span> data<span>[</span>MAX_SIZE<span>]</span><span>;</span>
</span><span>
</span><span>  <span>[</span><span>[</span>demo<span>::</span>invariant<span>]</span><span>]</span>
</span><span>  <span>void</span> <span>check_invariants</span><span>(</span><span>)</span>
</span><span>  <span>{</span>
</span><span>    
</span><span>    
</span><span>    <span>assert</span><span>(</span>top <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> top <span>&lt;=</span> MAX_SIZE<span>)</span><span>;</span>
</span><span>  <span>}</span>
</span><span>
</span><span><span>public</span><span>:</span>
</span><span>  <span>bool</span> <span>empty</span><span>(</span><span>)</span> <span>const</span> <span>{</span> <span>return</span> top <span>==</span> <span>0</span><span>;</span> <span>}</span>
</span><span>  <span>bool</span> <span>full</span><span>(</span><span>)</span> <span>const</span> <span>{</span> <span>return</span> top <span>==</span> MAX_SIZE<span>;</span> <span>}</span>
</span><span>
</span><span>  <span>void</span> <span>push</span><span>(</span><span>int</span> value<span>)</span>
</span><span>  <span>[</span><span>[</span>pre<span>:</span> <span>!</span><span>full</span><span>(</span><span>)</span><span>]</span><span>]</span>
</span><span>  <span>[</span><span>[</span>post<span>:</span> top <span>==</span> old_top <span>+</span> <span>1</span><span>]</span><span>]</span>
</span><span>  <span>{</span>
</span><span>    data<span>[</span>top<span>++</span><span>]</span> <span>=</span> value<span>;</span>
</span><span>    old_top <span>=</span> top<span>;</span>
</span><span>  <span>}</span>
</span><span>
</span><span>
</span><span>  <span>int</span> <span>pop</span><span>(</span><span>)</span>
</span><span>  <span>[</span><span>[</span>pre<span>:</span> <span>!</span><span>empty</span><span>(</span><span>)</span><span>]</span><span>]</span>
</span><span>  <span>[</span><span>[</span>post<span>:</span> top <span>==</span> old_top <span>-</span> <span>1</span><span>]</span><span>]</span>
</span><span>  <span>{</span>
</span><span>    old_top <span>=</span> top<span>;</span>
</span><span>    <span>return</span> data<span>[</span><span>--</span>top<span>]</span><span>;</span>
</span><span>  <span>}</span>
</span><span><span>}</span><span>;</span>
</span><span>
</span><span><span>int</span> <span>main</span><span>(</span><span>)</span>
</span><span><span>{</span>
</span><span>  Stack stack<span>;</span>
</span><span>
</span><span>  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span>
</span><span>    stack<span>.</span><span>push</span><span>(</span>i<span>)</span><span>;</span>
</span><span>
</span><span>  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span>
</span><span>    std<span>::</span>cout <span>&lt;&lt;</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span> <span>&lt;&lt;</span> std<span>::</span>endl<span>;</span>
</span><span>
</span><span>  <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div><p>If we run <code>cmake --build ./build --target run-test</code> we should see:</p><div><pre><code><span>[build] &lt;built-in<span>&gt;</span>: warning: Callback to register attributes
</span><span>[build] <span>&gt;</span> Found attribute
</span><span>[build] 	node = check_invariants
</span><span>[build] 	name = invariant
</span><span>[build] <span>&gt;</span> Inspecting function &#39;push&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;empty&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;full&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;push&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;__ct_base &#39;
</span><span>[build] 	 - Found a member function of a struct/class
</span><span>[build] <span>&gt;</span> Inspecting function &#39;main&#39;
</span><span>[build] <span>&gt;</span> plugin &#39;invariant_plugin @ <span>0.1</span>&#39; was loaded onto GCC
</span><span>[build] [<span>2</span>/<span>2</span>] cd /home/user/projects/gcc-invariant-plugin/build/default &amp;&amp; /home/user/projects/gcc-invariant-plugin/test-binary
</span><span>[build] <span>99</span>
</span><span>[build] <span>98</span>
</span><span>...
</span><span>[build] <span>1</span>
</span><span>[build] <span>0</span>
</span><span>[build] Build finished with exit code <span>0</span>
</span></code></pre></div><p>Hooray!</p><h3 id="implementing-the-invariant-call-code-generation"><a href="#implementing-the-invariant-call-code-generation" aria-hidden="true" tabindex="-1"><span></span></a>Implementing the [[invariant]] call code-generation</h3><p>Now, we need to implement the logic to to insert calls to the member function marked <code>[[demo::invariant]]</code> (if any exists) in all other member functions of any class/struct which contains an invariant function.</p><p>There are a few nuances to this:</p><ul><li>We don&#39;t want to insert at the <em>beginning</em> of constructors, because fields won&#39;t have been initialized yet.</li><li>We don&#39;t want to insert calls at the <em>end</em> of destructors, because fields will have been destroyed</li><li>There are probably others I haven&#39;t thought about</li></ul><p>But other than that, I&#39;ve implemented it as inserting at both the beginning and end of the function (before the <code>return</code>, if it exists)</p><p>Below is the code to do this:</p><details><summary>üëá CLICK TO EXPAND CODE üëá</summary><div><pre><code><span><span>unsigned</span> <span>int</span>
</span><span><span>instrument_invariants_plugin_exec</span><span>(</span><span>void</span><span>)</span>
</span><span><span>{</span>
</span><span>  
</span><span>  tree fndecl <span>=</span> current_function_decl<span>;</span>
</span><span>
</span><span>  
</span><span>  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;&gt; Inspecting function &#39;%s&#39;\n&#34;</span><span>,</span> <span>FN_NAME</span><span>(</span>fndecl<span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>if</span> <span>(</span><span>TREE_CODE</span><span>(</span><span>DECL_CONTEXT</span><span>(</span>fndecl<span>)</span><span>)</span> <span>!=</span> RECORD_TYPE<span>)</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span>
</span><span>  
</span><span>  tree invariant_fn <span>=</span> NULL_TREE<span>;</span>
</span><span>  
</span><span>  <span>for</span> <span>(</span>tree f <span>=</span> <span>TYPE_FIELDS</span><span>(</span><span>DECL_FIELD_CONTEXT</span><span>(</span>fndecl<span>)</span><span>)</span><span>;</span> f <span>!=</span> NULL_TREE<span>;</span> f <span>=</span> <span>DECL_CHAIN</span><span>(</span>f<span>)</span><span>)</span>
</span><span>  <span>{</span>
</span><span>    <span>if</span> <span>(</span><span>TREE_CODE</span><span>(</span>f<span>)</span> <span>==</span> FUNCTION_DECL<span>)</span>
</span><span>    <span>{</span>
</span><span>      
</span><span>      tree attrs <span>=</span> <span>DECL_ATTRIBUTES</span><span>(</span>f<span>)</span><span>;</span>
</span><span>      <span>for</span> <span>(</span>tree attr <span>=</span> attrs<span>;</span> attr <span>!=</span> <span>nullptr</span><span>;</span> attr <span>=</span> <span>TREE_CHAIN</span><span>(</span>attr<span>)</span><span>)</span>
</span><span>      <span>{</span>
</span><span>        
</span><span>        <span>if</span> <span>(</span><span>get_attribute_name</span><span>(</span>attr<span>)</span> <span>==</span> <span>get_identifier</span><span>(</span><span>&#34;invariant&#34;</span><span>)</span><span>)</span>
</span><span>        <span>{</span>
</span><span>          invariant_fn <span>=</span> f<span>;</span>
</span><span>        <span>}</span>
</span><span>      <span>}</span>
</span><span>    <span>}</span>
</span><span>  <span>}</span>
</span><span>
</span><span>  <span>if</span> <span>(</span>invariant_fn <span>==</span> NULL_TREE<span>)</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>if</span> <span>(</span><span>DECL_NAME</span><span>(</span>fndecl<span>)</span> <span>==</span> <span>DECL_NAME</span><span>(</span>invariant_fn<span>)</span><span>)</span>
</span><span>    <span>return</span> <span>0</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t attribute %s found! \n&#34;</span><span>,</span> ATTRIBUTE_NAME<span>)</span><span>;</span>
</span><span>
</span><span>  
</span><span>  basic_block entry <span>=</span> <span>ENTRY_BLOCK_PTR_FOR_FN</span><span>(</span>cfun<span>)</span><span>-&gt;</span>next_bb<span>;</span>
</span><span>
</span><span>  <span>auto</span> insert_invariant_calls_intelligently <span>=</span> <span>[</span><span>&amp;</span><span>]</span> <span>{</span>
</span><span>    
</span><span>    gimple<span>*</span> first_stmt <span>=</span> <span>gsi_stmt</span><span>(</span><span>gsi_start_bb</span><span>(</span>entry<span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>DECL_CONSTRUCTOR_P</span><span>(</span>fndecl<span>)</span><span>)</span>
</span><span>    <span>{</span>
</span><span>      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t skipping constructor start invariant call\n&#34;</span><span>)</span><span>;</span>
</span><span>      <span>return</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t adding function call before &#34;</span><span>)</span><span>;</span>
</span><span>    <span>print_gimple_stmt</span><span>(</span><span>stderr</span><span>,</span> first_stmt<span>,</span> <span>0</span><span>,</span> TDF_NONE<span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    gimple_stmt_iterator gsi <span>=</span> <span>gsi_for_stmt</span><span>(</span>first_stmt<span>)</span><span>;</span>
</span><span>    <span>gsi_insert_before</span><span>(</span><span>&amp;</span>gsi<span>,</span> <span>gimple_build_call</span><span>(</span>invariant_fn<span>,</span> <span>0</span><span>)</span><span>,</span> GSI_SAME_STMT<span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>DECL_DESTRUCTOR_P</span><span>(</span>fndecl<span>)</span><span>)</span>
</span><span>    <span>{</span>
</span><span>      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t skipping destructor end invariant call\n&#34;</span><span>)</span><span>;</span>
</span><span>      <span>return</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    
</span><span>    gimple_stmt_iterator gsi2      <span>=</span> <span>gsi_last_bb</span><span>(</span><span>ENTRY_BLOCK_PTR_FOR_FN</span><span>(</span>cfun<span>)</span><span>-&gt;</span>next_bb<span>)</span><span>;</span>
</span><span>    gimple<span>*</span>              last_stmt <span>=</span> <span>gsi_stmt</span><span>(</span>gsi2<span>)</span><span>;</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span>first_stmt <span>==</span> last_stmt<span>)</span>
</span><span>    <span>{</span>
</span><span>      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t first and last statement are the same, skipping last statement\n&#34;</span><span>)</span><span>;</span>
</span><span>      <span>return</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    
</span><span>    <span>if</span> <span>(</span><span>gimple_code</span><span>(</span>last_stmt<span>)</span> <span>==</span> GIMPLE_RETURN<span>)</span>
</span><span>    <span>{</span>
</span><span>      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t adding function call before &#34;</span><span>)</span><span>;</span>
</span><span>      <span>print_gimple_stmt</span><span>(</span><span>stderr</span><span>,</span> last_stmt<span>,</span> <span>0</span><span>,</span> TDF_NONE<span>)</span><span>;</span>
</span><span>      <span>gsi_insert_before</span><span>(</span><span>&amp;</span>gsi2<span>,</span> <span>gimple_build_call</span><span>(</span>invariant_fn<span>,</span> <span>0</span><span>)</span><span>,</span> GSI_SAME_STMT<span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>    <span>else</span>
</span><span>    <span>{</span>
</span><span>      <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;\t adding function call after &#34;</span><span>)</span><span>;</span>
</span><span>      <span>print_gimple_stmt</span><span>(</span><span>stderr</span><span>,</span> last_stmt<span>,</span> <span>0</span><span>,</span> TDF_NONE<span>)</span><span>;</span>
</span><span>      <span>gsi_insert_after</span><span>(</span><span>&amp;</span>gsi2<span>,</span> <span>gimple_build_call</span><span>(</span>invariant_fn<span>,</span> <span>0</span><span>)</span><span>,</span> GSI_SAME_STMT<span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>  <span>}</span><span>;</span>
</span><span>
</span><span>  
</span><span>  
</span><span>  <span>insert_invariant_calls_intelligently</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span>  
</span><span>  <span>return</span> <span>0</span><span>;</span>
</span><span><span>}</span>
</span></code></pre></div></details><h3 id="testing-again-violating-invariants"><a href="#testing-again-violating-invariants" aria-hidden="true" tabindex="-1"><span></span></a>Testing again, violating invariants</h3><p>If we modify our test code so that the invariant is violated:</p><div><pre><code><span><span>void</span> <span>check_invariants</span><span>(</span><span>)</span> <span>{</span> <span>assert</span><span>(</span>top <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> top <span>&lt;=</span> <span>50</span><span>)</span><span>;</span> <span>}</span>
</span></code></pre></div><p>And then re-compile with our plugin:</p><div><pre><code><span>[build] &lt;built-in<span>&gt;</span>: warning: Callback to register attributes
</span><span>[build] <span>&gt;</span> Found attribute
</span><span>[build] 	node = check_invariants
</span><span>[build] 	name = invariant
</span><span>[build] <span>&gt;</span> Inspecting function &#39;push&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before retval.1_4 = <span>Stack::full</span> <span>(</span><span>this_2</span><span>(</span>D<span>)</span><span>)</span>;
</span><span>[build] 	 adding function call after <span>if</span> <span>(</span>retval.1_4 != <span>0</span><span>)</span>
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before retval.2_4 = <span>Stack::empty</span> <span>(</span><span>this_2</span><span>(</span>D<span>)</span><span>)</span>;
</span><span>[build] 	 adding function call after <span>if</span> <span>(</span>retval.2_4 != <span>0</span><span>)</span>
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before _1 = <span>this_5</span><span>(</span>D<span>)</span>-<span>&gt;</span>top;
</span><span>[build] 	 adding function call after <span>if</span> <span>(</span>_1 != _3<span>)</span>
</span><span>[build] <span>&gt;</span> Inspecting function &#39;check_invariants&#39;
</span><span>[build] <span>&gt;</span> Inspecting function &#39;empty&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before _1 = <span>this_3</span><span>(</span>D<span>)</span>-<span>&gt;</span>top;
</span><span>[build] 	 adding function call after _4 = _1 == <span>0</span>;
</span><span>[build] <span>&gt;</span> Inspecting function &#39;full&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before _1 = <span>this_3</span><span>(</span>D<span>)</span>-<span>&gt;</span>top;
</span><span>[build] 	 adding function call after _4 = _1 == <span>100</span>;
</span><span>[build] <span>&gt;</span> Inspecting function &#39;push&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before <span>Stack::push</span> <span>(</span><span>this_7</span><span>(</span>D<span>)</span>, <span>value_8</span><span>(</span>D<span>)</span><span>)</span>;
</span><span>[build] 	 adding function call before return;
</span><span>[build] <span>&gt;</span> Inspecting function &#39;pop&#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 adding function call before <span>Stack::pop</span> <span>(</span><span>this_7</span><span>(</span>D<span>)</span><span>)</span>;
</span><span>[build] 	 adding function call after _13 = _12;
</span><span>[build] <span>&gt;</span> Inspecting function &#39;__ct_base &#39;
</span><span>[build] 	 attribute invariant found!
</span><span>[build] 	 skipping constructor start invariant call
</span><span>[build] <span>&gt;</span> Inspecting function &#39;main&#39;
</span><span>[build] <span>&gt;</span> plugin &#39;invariant_plugin @ <span>0.1</span>&#39; was loaded onto GCC
</span></code></pre></div><p>And run the test program, we should see:</p><div><pre><code><span>[user@MSI gcc-invariant-plugin]$ ./test-binary
</span><span>test-binary: /home/user/projects/gcc-invariant-plugin/test/test.cpp:13: void Stack::check_invariants(): Assertion `top &gt;= 0 &amp;&amp; top &lt;= 50&#39; failed.
</span><span>Aborted
</span></code></pre></div><p>Et-voila! We&#39;ve done it!</p><h3 id="checking-the-codegen-in-ghidra"><a href="#checking-the-codegen-in-ghidra" aria-hidden="true" tabindex="-1"><span></span></a>Checking the codegen in Ghidra</h3><p>To be sure things have come out right, we can take a look at the compiled code in something like Ghidra.</p><blockquote><p>Note: this is stepping outside of my forte, so there might be easier ways of doing this.</p></blockquote><p>Opening <code>test-binary</code> in Ghidra, and checking the primary definition of <code>Stack.push()</code> (note that the pre/post contracts will also generate function entries) we should see the below:</p><p><img alt="ghidra-stack-push-code" src="https://www.moderndescartes.com/static/images/ghidra-check-invariants.png"/></p><p>So we have a plugin, and it technically works, and that&#39;s cool. Sweet!</p><p>But remember when I said above:</p><blockquote><p>... I&#39;m not fully happy with the insertion code, because it depends on implicit fallback to the <code>this-&gt;</code> member namespace rather than an explicit call</p></blockquote><p>With the current state of the plugin code, I&#39;m still not fully satisfied with the GIMPLE calls used to invoke the invariant method.</p><p>I don&#39;t pretend to be an expert on C++. I <em>think</em> letting it look up the invariant function in the current scope/context is fine.</p><p>But what it <em>should</em> do is form an explicit member-function call to <code>this-&gt;check_invariant();</code>, which I burned some ~8 hours on trying to figure out.</p><h2 id="a-request-for-help"><a href="#a-request-for-help" aria-hidden="true" tabindex="-1"><span></span></a>A Request for Help</h2><p>If anyone knows how to do this, please let me know. Submit an issue/PR, or reach out via email/Twitter.</p><p>I submitted questions to StackOverflow, reached out on the GCC mailing list, and even had a chat with Iain Buclaw, the maintainer of GDC (the D-language frontend for GCC).</p><p>Iain got me going down the right path I think, which I am pretty sure involves a combination of <code>lookup_member()</code> and <code>build_new_method_call()</code>, but I&#39;ve not gotten it to work.</p><p>All the details are here in case anyone&#39;s interested in pursuing it further:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/74964153/gcc-gimple-c-api-how-to-insert-a-call-to-a-member-function-from-another-membe">https://stackoverflow.com/questions/74964153/gcc-gimple-c-api-how-to-insert-a-call-to-a-member-function-from-another-membe</a></li></ul><p>I&#39;d like to thank the following people:</p><ul><li>Iain Buclaw, for letting me bug him, and just generally maintaining the GDC compiler and helping with release management + infrastructure.</li><li>The authors of these two blogposts:<ul><li><a target="_blank" rel="noopener noreferrer" href="https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html">https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://stephanfr.blog/2013/05/19/building-gcc-plugins-part-1-c-11-generalized-attributes/">https://stephanfr.blog/2013/05/19/building-gcc-plugins-part-1-c-11-generalized-attributes/</a></li></ul></li></ul><p>I &#34;borrowed&#34; the image in the OpenGraph metadata tag from the below blogpost, which is well-written and worth the read. I couldn&#39;t find any information on the page on whether it was copyright protected.</p><p>Hopefully the author doesn&#39;t mind, if they do I&#39;ll remove it!</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://dominikberner.ch/design-by-contract-en/">https://dominikberner.ch/design-by-contract-en/</a></li></ul></div></div>
  </body>
</html>
