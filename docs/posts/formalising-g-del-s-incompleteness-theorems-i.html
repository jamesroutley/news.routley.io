<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lawrencecpaulson.github.io//2022/05/18/Formalising-Incompleteness-I.html">Original</a>
    <h1>Formalising Gödel&#39;s incompleteness theorems, I</h1>
    
    <div id="readability-page-1" class="page"><section>

      
<p>18 May 2022</p>

<p><a href="https://plato.stanford.edu/entries/goedel-incompleteness/">Gödel’s incompleteness theorems</a> state limits on formal systems.
(1) A consistent system strong enough to express the basic properties of integer addition and multiplication must be <em>incomplete</em>: there exists a formula that is neither provable nor refutable within the system, and (2) no such formal system can prove its own consistency.
The first theorem is proved by using integer arithmetic to encode logical formulas, operations on them such as substitution, and inference according to the rules of the formal system. A fixedpoint construction yields an explicit formula expressing its own unprovability.
The technical complications of the first theorem are formidable but were overcome already by <a href="https://doi.org/10.1017/CBO9780511569883">Shankar</a> in the 1980s and again by John Harrison and <a href="https://rdcu.be/cNaig">Russell O’Connor</a>.
This post introduces <a href="https://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-logic.pdf">my own formalisation</a>, using Isabelle/HOL. It also demonstrates formalising syntax involving variable binding using the <em>nominal package</em> of Christian Urban and Stefan Berghofer.
More generally, it illustrates how to specify the syntax, semantics and proof theory of a formal system.</p>



<p>One difficulty with formalising incompleteness is purely technical: much of the reasoning in the proof is straightforward mathematically, but has to be carried out within the given formal calculus. We’ve already seen how hard it is to <a href="https://lawrencecpaulson.github.io/2022/01/12/Proving-the-obvious.html">prove obvious things</a> in a theorem prover, despite all its automation; now imagine proving those things in a raw formal calculus, itself nothing more than a data structure formalised in a theorem prover. So here is a spoiler: such proofs were typically hundreds of lines long. I’ve written a <a href="https://rdcu.be/bpgqj">second paper</a> that comments extensively on the length of each component of the development.</p>

<p>My formalisation follows a development by <a href="https://doi.org/10.4064/DM422-0-1">Świerczkowski</a>.
He gave a no-handwaving informal proof, a gift for anyone who might come along later to formalise it. He wrote out many details glossed over in textbooks.
He made strategic decisions to minimise the effort needed to reach even the second incompleteness theorem, which had been regarded by many as unattainable.</p>

<p>Świerczkowski chose to rely on the <a href="https://lawrencecpaulson.github.io/2022/02/23/Hereditarily_Finite.html">hereditarily finite sets</a> rather than the integers as the basis for coding. Decoding $2^x3^y$ requires the fundamental theorem of arithmetic; an alternative coding option needs the Chinese remainder theorem and neither is tempting to formalise in an internalised first-order calculus. The set theoretic treatment of ordered pairs as $\{\{x\},\{x,y\}\}$ is infinitely simpler.
He also proved a meta-theorem stating that every true Σ-formula is provable in the calculus with no need to write out the proofs. A Σ-formula can begin with any number of existential quantifiers, and they are sufficient to express much of the logic of coding. The standard approach yields a more powerful meta-theorem (where also <em>false</em> formulas have explicit <em>disproofs</em>), but it requires all quantifiers to be bounded, and ultimately requiring more work than just writing out some formal proofs.</p>

<p>The stages of the proofs of the first theorem are as follows:</p>
<ol>
  <li>Formalisation of the internal calculus, HF</li>
  <li>Meta-theorem stating that every true Σ-sentence is provable</li>
  <li>Defining a coding system for all HF terms and formulas</li>
  <li>Defining predicates within HF itself to recognise terms, formulas and operations such as substitution; then inference rules and provability itself</li>
  <li>Exhibiting the actual undecidable HF formula</li>
</ol>

<h3 id="on-the-treatment-of-bound-variables">On the treatment of bound variables</h3>

<p>Formal reasoning about syntax including variable binding is generally fraught with difficulties connected with substitution and variable capture. In Isabelle/HOL we are lucky to have the <a href="https://www.isa-afp.org/entries/Nominal2.html">nominal package</a>, created by <a href="https://rdcu.be/cNfaC">Christian Urban</a> and based on theoretical work by Andrew Pitts and Jamie Gabbay. The <a href="https://www.cl.cam.ac.uk/~amp12/papers/newaas/newaas-jv.pdf">nominal approach</a> to variable binding provides a calculus of permutations on variable names, and provides a smooth treatment of syntactic operations that treat bound variables appropriately (which in particular means that all results are independent of which names are chosen for the bound variables). It precisely defines the notion of a variable being fresh and gives you a means of picking fresh variables. You get to assume that variables are magically renamed whenever necessary.</p>

<p>My formal development of the incompleteness theorems <a href="https://rdcu.be/bpgqj">uses the nominal approach</a> in formalising the logical calculus: its syntax, syntactic operations and inference rules.
When it comes to coding formulas of the calculus, we need a different approach to variable binding, as attempting to formalise the nominal approach within the formal calculus itself is not to be imagined. Although Swierczkowski used plain variable names, I felt certain that a nameless representation would work better, and the obvious one is <a href="https://doi.org/10.1016/1385-7258(72)90034-0">de Bruijn’s</a> (explanation <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">on Wikipedia</a>).</p>

<p>The proof requires proving that the encoded operations carry out their intended effect. Happily, there’s a simple correspondence between syntax and operations formalised using the nominal approach and their counterparts using de Bruijn indices.</p>

<h3 id="a-formal-logic-and-its-isabellehol-formalisation">A formal logic and its Isabelle/HOL formalisation</h3>

<p>Now let’s see a few highlights of the <a href="https://www.isa-afp.org/entries/Incompleteness.html">Isabelle formalisation of incompleteness</a>.
A bit of magic (omitted here) sets up the nominal package and creates the type <code>name</code> to serve as a type of variable names.
The nominal package provide its own datatype declaration facility.
We can now declare a type for the terms of our formalism. Terms can be variables, 0 or “eats” ($A \lhd x$ for the set whose elements are those of $A$, plus $x$).</p>

<pre><span>nominal_datatype</span> tm <span>=</span> Zero <span>|</span> Var <span>name</span> <span>|</span> Eats <span>tm</span> <span>tm</span>
</pre>

<p>The formulas provide a bare bones predicate calculus, able to express $x\in y$, $x=y$, $\phi\lor\psi$, $\neg \phi$ and $\exists x.\, \phi$.
The phrase <kbd><span>binds</span> <span>x</span> <span>in</span> f</kbd> indicates that the occurrence of <code>x</code> is binding.</p>

<pre><span>nominal_datatype</span> fm <span>=</span><span>
    </span>Mem <span>tm</span> <span>tm</span>    <span>(</span><span>infixr</span> <span><span>&#34;</span><span>IN</span><span>&#34;</span></span> 150<span>)</span><span>
  </span><span>|</span> Eq <span>tm</span> <span>tm</span>     <span>(</span><span>infixr</span> <span><span>&#34;</span><span>EQ</span><span>&#34;</span></span> 150<span>)</span><span>
  </span><span>|</span> Disj <span>fm</span> <span>fm</span>   <span>(</span><span>infixr</span> <span><span>&#34;</span><span>OR</span><span>&#34;</span></span> 130<span>)</span><span>
  </span><span>|</span> Neg <span>fm</span><span>
  </span><span>|</span> Ex x<span>::</span><span>name</span> f<span>::</span><span>fm</span> <span>binds</span> <span>x</span> <span>in</span> f
</pre>

<p>This is all we need to define the syntax of our first-order calculus. The next steps will define substitution (necessary to express the rules of inference) and the semantics.</p>

<h3 id="defining-substitution">Defining substitution</h3>

<p>Substitution of a term for a variable in another term is trivial. It has no effect on 0; a variable is replaced by the new term if it matches; compound terms (involving $\lhd$) are substituted recursively.
The last line proves that the function uses names legitimately.
It is the last such proof we are going to see: they become gruesome, which is the only real drawback of the nominal package.</p>

<pre><span>nominal_function</span> <span>subst</span> <span>::</span> <span><span>&#34;</span>name <span>⇒</span> tm <span>⇒</span> tm <span>⇒</span> tm<span>&#34;</span></span><span>
  </span><span>where</span><span>
   </span><span><span>&#34;</span><span>subst</span> <span>i</span> <span>x</span> Zero       <span>=</span> Zero<span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>subst</span> <span>i</span> <span>x</span> <span>(</span>Var <span>k</span><span>)</span>    <span>=</span> <span>(</span><span>if</span> <span>i</span><span>=</span><span>k</span> <span>then</span> <span>x</span> <span>else</span> Var <span>k</span><span>)</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>subst</span> <span>i</span> <span>x</span> <span>(</span>Eats <span>t</span> <span>u</span><span>)</span> <span>=</span> Eats <span>(</span><span>subst</span> <span>i</span> <span>x</span> <span>t</span><span>)</span> <span>(</span><span>subst</span> <span>i</span> <span>x</span> <span>u</span><span>)</span><span>&#34;</span></span>
<span>by</span> <span>(</span><span>auto</span> <span>simp</span><span>:</span> eqvt_def subst_graph_aux_def<span>)</span> <span>(</span><span>metis</span> tm.strong_exhaust<span>)</span>
</pre>

<p>Substitution over formulas is also pretty straightforward. In most cases it is simply built up recursively.
The line for the existential quantifier says in effect, ensure that the quantified variable is fresh with respect to the variable and term of the substitution, then simply substitute recursively. We can read this as an order to rename the bound variable appropriately to prevent a name clash, and we don’t actually care what name is chosen.</p>

<pre><span>nominal_function</span>  <span>subst_fm</span> <span>::</span> <span><span>&#34;</span>fm <span>⇒</span> name <span>⇒</span> tm <span>⇒</span> fm<span>&#34;</span></span> <span>(</span><span><span>&#34;</span>_<span>&#39;(</span>_<span>::=</span>_<span>&#39;)</span><span>&#34;</span></span> <span>[</span>1000<span>,</span> 0<span>,</span> 0<span>]</span> 200<span>)</span><span>
  </span><span>where</span><span>
    </span>Mem<span>:</span>  <span><span>&#34;</span><span>(</span>Mem <span>t</span> <span>u</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span>  <span>=</span> Mem <span>(</span>subst <span>i</span> <span>x</span> <span>t</span><span>)</span> <span>(</span>subst <span>i</span> <span>x</span> <span>u</span><span>)</span><span>&#34;</span></span><span>
  </span><span>|</span> Eq<span>:</span>   <span><span>&#34;</span><span>(</span>Eq <span>t</span> <span>u</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span>   <span>=</span> Eq  <span>(</span>subst <span>i</span> <span>x</span> <span>t</span><span>)</span> <span>(</span>subst <span>i</span> <span>x</span> <span>u</span><span>)</span><span>&#34;</span></span><span>
  </span><span>|</span> Disj<span>:</span> <span><span>&#34;</span><span>(</span>Disj <span>A</span> <span>B</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span> <span>=</span> Disj <span>(</span><span>A</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span><span>)</span> <span>(</span><span>B</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span><span>)</span><span>&#34;</span></span><span>
  </span><span>|</span> Neg<span>:</span>  <span><span>&#34;</span><span>(</span>Neg <span>A</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span>    <span>=</span> Neg  <span>(</span><span>A</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span><span>)</span><span>&#34;</span></span><span>
  </span><span>|</span> Ex<span>:</span>   <span><span>&#34;</span>atom <span>j</span> <span>♯</span> <span>(</span><span>i</span><span>,</span> <span>x</span><span>)</span> <span>⟹</span> <span>(</span>Ex <span>j</span> <span>A</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span> <span>=</span> Ex <span>j</span> <span>(</span><span>A</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span><span>)</span><span>&#34;</span></span>
</pre>

<p>The condition <span>atom <span>j</span> <span>♯</span> <span>(</span><span>i</span><span>,</span> <span>x</span><span>)</span></span> in the last line above requires an explanation. 
Crucial to the nominal approach is the idea of a variable being <strong>fresh</strong> for a given expression, which roughly means that it is not free in that expression: $a\mathbin{\sharp} E$ means “$a$ is fresh for $E$”.
The condition in the last line is that <span>j</span>, the quantified variable, must be fresh for both
<span>i</span>, the variable being substituted, and <span>x</span>, the replacement term.</p>

<p>Now let’s prove that if a variable is fresh for a term, then substitution has no effect. Its proof is one line: “induction then simplify”. 
The analogous theorem for formulas has an equally simple proof, and in particular, it tells us that
<span>
    <span>(</span>Ex <span>i</span> <span>A</span><span>)</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span> <span>=</span> Ex <span>i</span> <span>A</span>.
</span></p>

<pre><span>lemma</span> forget_subst_tm <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span>&#34;</span>atom <span>a</span> <span>♯</span> <span>tm</span> <span>⟹</span> subst <span>a</span> <span>x</span> <span>tm</span> <span>=</span> <span>tm</span><span>&#34;</span></span><span>
  </span><span>by</span> <span>(</span><span>induct</span> <span>tm</span> <span>rule</span><span>:</span> tm.induct<span>)</span> <span>(</span><span>simp_all</span> <span>add</span><span>:</span> fresh_at_base<span>)</span>
</pre>

<p>The following little result states that two successive substitutions within a formula are equivalent to a single substitution on the formula, the other substitution taking place in the term. The proof is another one-line induction, where the “avoiding” clause informs the nominal package of the syntactic entities that quantified bound variables must avoid.</p>
<pre><span>lemma</span> subst_fm_commute<span>[</span><span>simp</span><span>]</span><span>:</span><span>
  </span><span><span>&#34;</span>atom <span>j</span> <span>♯</span> <span>A</span> <span>⟹</span> <span>(</span><span>A</span><span>(</span><span>i</span><span>::=</span><span>t</span><span>)</span><span>)</span><span>(</span><span>j</span><span>::=</span><span>u</span><span>)</span> <span>=</span> <span>A</span><span>(</span><span>i</span> <span>::=</span> subst <span>j</span> <span>u</span> <span>t</span><span>)</span><span>&#34;</span></span>
  <span>by</span> <span>(</span><span>nominal_induct <span>A</span> <span>avoiding</span><span>:</span> <span>i</span> <span>j</span> <span>t</span> <span>u</span> <span>rule</span><span>:</span> fm.strong_induct<span>)</span> <span>(</span><span>auto</span> <span>simp</span><span>:</span> fresh_at_base<span>)</span></span>
</pre>

<p>This sort of proof can be absolutely fiendish with other approaches to variable binding. Nominal requires some effort to justify a function definition, but in return it makes reasoning about the function really easy.</p>

<h3 id="formal-semantics-of-the-calculus">Formal semantics of the calculus</h3>

<p>The formal semantics is defined in terms of the existing development of hereditarily finite sets.
Variables are interpreted with respect to an environment, a <a href="http://www.andreas-lochbihler.de/pub/lochbihler09tphols.pdf">finite function</a> mapping names to <code>hf</code> sets.
The corresponding <a href="https://www.isa-afp.org/entries/FinFun.html">AFP entry</a> is among the most heavily used in the entire Archive.</p>

<p>As before, the definition for terms has a trivial justification (omitted anyway).
The semantics of a term map the HF constructors (Zero and Eats) to the corresponding operators, while the meaning of a variable is looked up in the environment.</p>

<pre><span>nominal_function</span> <span>eval_tm</span> <span>::</span> <span><span>&#34;</span><span>(</span>name<span>,</span> hf<span>)</span> finfun <span>⇒</span> tm <span>⇒</span> hf<span>&#34;</span></span><span>
  </span><span>where</span><span>
   </span><span><span>&#34;</span><span>eval_tm</span> <span>e</span> Zero <span>=</span> <span>0</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>eval_tm</span> <span>e</span> <span>(</span>Var <span>k</span><span>)</span> <span>=</span> finfun_apply <span>e</span> <span>k</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>eval_tm</span> <span>e</span> <span>(</span>Eats <span>t</span> <span>u</span><span>)</span> <span>=</span> <span>eval_tm</span> <span>e</span> <span>t</span> <span>◃</span> <span>eval_tm</span> <span>e</span> <span>u</span><span>&#34;</span></span>
</pre>

<p>An omitted bit of magic allows us to write the semantics of a term as
<span>⟦</span><span>t</span><span>⟧</span><span>e</span>
instead of
<span>eval_tm</span> <span>e</span> <span>t</span>.
Now for formulas:
given an environment, the semantics of the formula of our calculus is a Boolean. It is a standard <a href="https://plato.stanford.edu/entries/tarski-truth/">Tarski truth definition</a>, in effect an embedding of our calculus into higher-order logic.</p>

<pre><span>nominal_function</span> <span>eval_fm</span> <span>::</span> <span><span>&#34;</span><span>(</span>name<span>,</span> hf<span>)</span> finfun <span>⇒</span> fm <span>⇒</span> bool<span>&#34;</span></span><span>
  </span><span>where</span><span>
   </span><span><span>&#34;</span><span>eval_fm</span> <span>e</span> <span>(</span><span>t</span> <span>IN</span> <span>u</span><span>)</span> <span>⟷</span> <span>⟦</span><span>t</span><span>⟧</span><span>e</span> <span><span>❙</span><strong>∈</strong></span> <span>⟦</span><span>u</span><span>⟧</span><span>e</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>eval_fm</span> <span>e</span> <span>(</span><span>t</span> <span>EQ</span> <span>u</span><span>)</span> <span>⟷</span> <span>⟦</span><span>t</span><span>⟧</span><span>e</span> <span>=</span> <span>⟦</span><span>u</span><span>⟧</span><span>e</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>eval_fm</span> <span>e</span> <span>(</span><span>A</span> <span>OR</span> <span>B</span><span>)</span> <span>⟷</span> <span>eval_fm</span> <span>e</span> <span>A</span> <span>∨</span> <span>eval_fm</span> <span>e</span> <span>B</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span><span>eval_fm</span> <span>e</span> <span>(</span>Neg <span>A</span><span>)</span> <span>⟷</span> <span>(</span><span>~</span> <span>eval_fm</span> <span>e</span> <span>A</span><span>)</span><span>&#34;</span></span><span>
 </span><span>|</span> <span><span>&#34;</span>atom <span>k</span> <span>♯</span> <span>e</span> <span>⟹</span> <span>eval_fm</span> <span>e</span> <span>(</span>Ex <span>k</span> <span>A</span><span>)</span> <span>⟷</span> <span>(</span><span>∃</span><span>x</span><span>.</span> <span>eval_fm</span> <span>(</span>finfun_update <span>e</span> <span>k</span> <span>x</span><span>)</span> <span>A</span><span>)</span><span>&#34;</span></span>
</pre>

<p>Omitted once again is an ugly proof that the function definition is legitimate.
The only difficult case refers to the last line above, which the semantics of a quantified formula <em>provided</em> the bound variable is fresh in the environment.
It is straightforward to prove that the last line in fact holds unconditionally.</p>

<p>Now for some proofs. And once again, proofs about the functions just defined are simple. This one says that the semantics of a term <code>t</code> is unaffected if we update the environment at a variable that is fresh for <code>t</code>.</p>

<pre><span>lemma</span> forget_eval_tm <span>[</span><span>simp</span><span>]</span><span>:</span> <span><span>&#34;</span>atom <span>i</span> <span>♯</span> <span>t</span> <span>⟹</span>  <span>⟦</span><span>t</span><span>⟧</span><span>(</span>finfun_update <span>e</span> <span>i</span> <span>x</span><span>)</span> <span>=</span> <span>⟦</span><span>t</span><span>⟧</span><span>e</span><span>&#34;</span></span><span>
  </span><span>by</span> <span>(</span><span>induct</span> <span>t</span> <span>rule</span><span>:</span> tm.induct<span>)</span> <span>(</span><span>simp_all</span> <span>add</span><span>:</span> fresh_at_base<span>)</span>
</pre>

<p>This lemma is the analogous result for formulas. The proof is once again “induction, then simplify”.</p>

<pre><span>lemma</span> forget_eval_fm <span>[</span><span>simp</span><span>]</span><span>:</span><span>
   </span><span><span>&#34;</span>atom <span>k</span> <span>♯</span> <span>A</span> <span>⟹</span> eval_fm <span>(</span>finfun_update <span>e</span> <span>k</span> <span>x</span><span>)</span> <span>A</span> <span>=</span> eval_fm <span>e</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>by</span> <span>(</span><span>nominal_induct <span>A</span> <span>avoiding</span><span>:</span> <span>k</span> <span>e</span> <span>rule</span><span>:</span> fm.strong_induct<span>)</span><span>
     </span><span>(</span><span>simp_all</span> <span>add</span><span>:</span> fresh_at_base finfun_update_twist<span>)</span></span>
</pre>

<p>The following two lemmas relate syntax with semantics: the effect of syntactic substitution is identical to that of updating the environment with the semantics of the substituted term.</p>

<pre><span>lemma</span> eval_subst_tm&lt;/span&gt;<span>:</span> <span><span>&#34;</span><span>⟦</span>subst <span>i</span> <span>t</span> <span>u</span><span>⟧</span><span>e</span> <span>=</span> <span>⟦</span><span>u</span><span>⟧</span><span>(</span>finfun_update <span>e</span> <span>i</span> <span>⟦</span><span>t</span><span>⟧</span><span>e</span><span>)</span><span>&#34;</span></span><span>
  </span><span>by</span> <span>(</span><span>induct</span> <span>u</span> <span>rule</span><span>:</span> tm.induct<span>)</span> <span>(</span><span>auto</span><span>)</span>
</pre>

<p>And the same thing for formulas.</p>

<pre><span>lemma</span> eval_subst_fm<span>:</span> <span><span>&#34;</span>eval_fm <span>e</span> <span>(</span><span>fm</span><span>(</span><span>i</span><span>::=</span> <span>t</span><span>)</span><span>)</span> <span>=</span> eval_fm <span>(</span>finfun_update <span>e</span> <span>i</span> <span>⟦</span><span>t</span><span>⟧</span><span>e</span><span>)</span> <span>fm</span><span>&#34;</span></span><span>
  </span><span>by</span> <span>(</span><span>nominal_induct <span>fm</span> <span>avoiding</span><span>:</span> <span>i</span> <span>t</span> <span>e</span> <span>rule</span><span>:</span> fm.strong_induct<span>)</span><span>
     </span><span>(</span><span>simp_all</span> <span>add</span><span>:</span> eval_subst_tm finfun_update_twist fresh_at_base<span>)</span></span>
</pre>

<p>Nobody should imagine that such simple proofs could be possible in any approach based on naïve variable names.</p>

<h3 id="the-inference-system">The inference system</h3>

<p>HF, the internal calculus, is defined by a Hilbert system. HF formulas have only disjunctions, negations and existential quantifiers, so the missing connectives such as conjunctions and universal quantifiers must be defined as the obvious abbreviations.
For Boolean logic, the proof system incorporates the following fairly arbitrary set of axiom schemes.
I defined it inductively for convenience, although there is no recursion.</p>

<pre><span>inductive_set</span> <span>boolean_axioms</span> <span>::</span> <span><span>&#34;</span>fm set<span>&#34;</span></span><span>
  </span><span>where</span><span>
    </span>Ident<span>:</span>     <span><span>&#34;</span><span>A</span> <span>IMP</span> <span>A</span> <span>∈</span> <span>boolean_axioms</span><span>&#34;</span></span><span>
  </span><span>|</span> DisjI1<span>:</span>    <span><span>&#34;</span><span>A</span> <span>IMP</span> <span>(</span><span>A</span> <span>OR</span> <span>B</span><span>)</span> <span>∈</span> <span>boolean_axioms</span><span>&#34;</span></span><span>
  </span><span>|</span> DisjCont<span>:</span>  <span><span>&#34;</span><span>(</span><span>A</span> <span>OR</span> <span>A</span><span>)</span> <span>IMP</span> <span>A</span> <span>∈</span> <span>boolean_axioms</span><span>&#34;</span></span><span>
  </span><span>|</span> DisjAssoc<span>:</span> <span><span>&#34;</span><span>(</span><span>A</span> <span>OR</span> <span>(</span><span>B</span> <span>OR</span> <span>C</span><span>)</span><span>)</span> <span>IMP</span> <span>(</span><span>(</span><span>A</span> <span>OR</span> <span>B</span><span>)</span> <span>OR</span> <span>C</span><span>)</span> <span>∈</span> <span>boolean_axioms</span><span>&#34;</span></span><span>
  </span><span>|</span> DisjConj<span>:</span>  <span><span>&#34;</span><span>(</span><span>C</span> <span>OR</span> <span>A</span><span>)</span> <span>IMP</span> <span>(</span><span>(</span><span>(</span>Neg <span>C</span><span>)</span> <span>OR</span> <span>B</span><span>)</span> <span>IMP</span> <span>(</span><span>A</span> <span>OR</span> <span>B</span><span>)</span><span>)</span> <span>∈</span> <span>boolean_axioms</span><span>&#34;</span></span>
</pre>

<p>The scheme of “special axioms” defines existential quantification.
In standard notation, these axioms have the form $\phi(t)\to \exists x.\,\phi(x)$, where $t$ is any term.</p>

<pre><span>inductive_set</span> <span>special_axioms</span> <span>::</span> <span><span>&#34;</span>fm set<span>&#34;</span></span> <span>where</span><span>
  </span>I<span>:</span> <span><span>&#34;</span><span>A</span><span>(</span><span>i</span><span>::=</span><span>x</span><span>)</span> <span>IMP</span> <span>(</span>Ex <span>i</span> <span>A</span><span>)</span> <span>∈</span> <span>special_axioms</span><span>&#34;</span></span>
</pre>

<p>The induction axioms include every instance of the induction scheme for HF sets.
In standard notation, these axioms have the form
$\phi(0) \land \forall xy\, [\phi(x)\land\phi(y)\to\phi(x\lhd y)]\to \forall x\,\phi(x)$.</p>

<pre><span>inductive_set</span> <span>induction_axioms</span> <span>::</span> <span><span>&#34;</span>fm set<span>&#34;</span></span> <span>where</span><span>
  </span>ind<span>:</span><span>
  </span><span><span>&#34;</span>atom <span>(</span><span>j</span><span>::</span>name<span>)</span> <span>♯</span> <span>(</span><span>i</span><span>,</span><span>A</span><span>)</span><span>
   </span><span>⟹</span> <span>A</span><span>(</span><span>i</span><span>::=</span>Zero<span>)</span> <span>IMP</span> <span>(</span><span>(</span>All <span>i</span> <span>(</span>All <span>j</span> <span>(</span><span>A</span> <span>IMP</span> <span>(</span><span>A</span><span>(</span><span>i</span><span>::=</span> Var <span>j</span><span>)</span> <span>IMP</span> <span>A</span><span>(</span><span>i</span><span>::=</span> Eats<span>(</span>Var <span>i</span><span>)</span><span>(</span>Var <span>j</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>
      </span><span>IMP</span> <span>(</span>All <span>i</span> <span>A</span><span>)</span><span>)</span><span>
    </span><span>∈</span> <span>induction_axioms</span><span>&#34;</span></span>
</pre>

<p>Further axioms (omitted) describe the properties of the HF operators <code>Zero</code> and <code>Eats</code>; there are also some standard equality axioms. Finally, there’s an unspecified <strong>extra axiom</strong>, standing for any else finite statement we wish to assume. The extra axiom is required to be true in the semantics, and all the other axioms are proved to hold, so this proof calculus will be consistent by construction.</p>

<p>We are finally ready to behold the inference system itself.
Because it is a Hilbert system, $\Gamma\vdash\phi$ means that $\phi$ follows from the given set of assumptions, $\Gamma$.
The first line is the trivial inclusion and the next six lines state that the various axioms are theorems.</p>

<pre><span>inductive</span> <span>hfthm</span> <span>::</span> <span><span>&#34;</span>fm set <span>⇒</span> fm <span>⇒</span> bool<span>&#34;</span></span> <span>(</span><span>infixl</span> <span><span>&#34;</span><span>⊢</span><span>&#34;</span></span> 55<span>)</span><span>
  </span><span>where</span><span>
    </span>Hyp<span>:</span>    <span><span>&#34;</span><span>A</span> <span>∈</span> <span>H</span> <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> Extra<span>:</span>  <span><span>&#34;</span><span>H</span> <span>⊢</span> extra_axiom<span>&#34;</span></span><span>
  </span><span>|</span> Bool<span>:</span>   <span><span>&#34;</span><span>A</span> <span>∈</span> boolean_axioms <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> Eq<span>:</span>     <span><span>&#34;</span><span>A</span> <span>∈</span> equality_axioms <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> Spec<span>:</span>   <span><span>&#34;</span><span>A</span> <span>∈</span> special_axioms <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> HF<span>:</span>     <span><span>&#34;</span><span>A</span> <span>∈</span> HF_axioms <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> Ind<span>:</span>    <span><span>&#34;</span><span>A</span> <span>∈</span> induction_axioms <span>⟹</span> <span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span><span>
  </span><span>|</span> MP<span>:</span>     <span><span>&#34;</span><span>H</span> <span>⊢</span> <span>A</span> <span>IMP</span> <span>B</span> <span>⟹</span> <span>H&#39;</span> <span>⊢</span> <span>A</span> <span>⟹</span> <span>H</span> <span>∪</span> <span>H&#39;</span> <span>⊢</span> <span>B</span><span>&#34;</span></span><span>
  </span><span>|</span> Exists<span>:</span> <span><span>&#34;</span><span>H</span> <span>⊢</span> <span>A</span> <span>IMP</span> <span>B</span> <span>⟹</span> atom <span>i</span> <span>♯</span> <span>B</span> <span>⟹</span> <span>∀</span><span>C</span> <span>∈</span> <span>H</span><span>.</span> atom <span>i</span> <span>♯</span> <span>C</span> <span>⟹</span> <span>H</span> <span>⊢</span> <span>(</span>Ex <span>i</span> <span>A</span><span>)</span> <span>IMP</span> <span>B</span><span>&#34;</span></span>
</pre>

<p>The last two lines above are inference rules:</p>
<ol>
  <li>modus ponens: from $\phi\to\psi$ and $\phi$ infer $\psi$</li>
  <li>so-called $\exists$-introduction: from $\phi\to\psi$ infer $(\exists x.\,\phi)\to\psi$ provided $x$ is fresh</li>
</ol>

<p>It is now easy to prove that the internal calculus is sound. The proof is a straightforward induction, referring to (omitted) proofs that the axioms are true in the semantics.
The calculus is therefore consistent. This development of incompleteness differs from many others, which typically assume a more abstract calculus with consistency requirements.</p>

<pre><span>theorem</span> hfthm_sound<span>:</span> <span>assumes</span> <span><span>&#34;</span><span>H</span> <span>⊢</span> <span>A</span><span>&#34;</span></span> <span>shows</span> <span><span>&#34;</span><span>(</span><span>∀</span><span>B</span><span>∈</span><span>H</span><span>.</span> eval_fm <span>e</span> <span>B</span><span>)</span> <span>⟹</span> eval_fm <span>e</span> <span>A</span><span>&#34;</span></span>
<span>using</span> assms
<span>proof</span> <span>(</span><span>induct</span> <span>arbitrary</span><span>:</span> <span>e</span><span>)</span><span>
  </span><span>case</span> <span>(</span>Hyp <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>auto</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Extra <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> extra_axiom_holds<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Bool <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> boolean_axioms_hold<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Eq <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> equality_axioms_hold<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Spec <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> special_axioms_hold<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>HF <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> HF_axioms_hold<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Ind <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> induction_axioms_hold<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>MP <span>H</span> <span>A</span> <span>B</span> <span>H&#39;</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>auto</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Exists <span>H</span> <span>A</span> <span>B</span> <span>i</span> <span>e</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>auto</span> <span>(</span><span>metis</span> forget_eval_fm<span>)</span>
<span>qed</span>
</pre>

<h3 id="proving-the-deduction-theorem">Proving the deduction theorem</h3>

<p>We now have a sound Hilbert system, but it would be extremely inconvenient for conducting actual proofs, which we shall have to do. A substantial amount of largely routine work is necessary to derive from it a sort of sequent calculus, which will allow a little bit of automation and sane-looking, if lengthy, proofs.</p>

<p>The only nontrivial step in this derivation is proving the deduction theorem, which describes the relationship between assumptions and implication. Precisely, it says that any assumption can be made explicit as an implication. The full proof is given below (though referring to some omitted lemmas). It’s another perfectly straightforward induction. Even the quantifier case is simple enough.</p>

<pre><span>lemma</span> deduction_Diff<span>:</span> <span>assumes</span> <span><span>&#34;</span><span>H</span> <span>⊢</span> <span>B</span><span>&#34;</span></span> <span>shows</span> <span><span>&#34;</span><span>H</span> <span>-</span> <span>{</span><span>C</span><span>}</span> <span>⊢</span> <span>C</span> <span>IMP</span> <span>B</span><span>&#34;</span></span>
<span>using</span> assms
<span>proof</span> <span>(</span><span>induct</span><span>)</span><span>
  </span><span>case</span> <span>(</span>Hyp <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Bool Imp_triv_I boolean_axioms.Ident hfthm.Hyp member_remove remove_def<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Extra <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Extra<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Bool <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Bool<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Eq <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Eq<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Spec <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Spec<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>HF <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.HF<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Ind <span>A</span> <span>H</span><span>)</span> <span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Ind<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>MP <span>H</span> <span>A</span> <span>B</span> <span>H&#39;</span><span>)</span><span>
  </span><span>hence</span> <span><span>&#34;</span><span>(</span><span>H</span><span>-</span><span>{</span><span>C</span><span>}</span><span>)</span> <span>∪</span> <span>(</span><span>H&#39;</span><span>-</span><span>{</span><span>C</span><span>}</span><span>)</span> <span>⊢</span> Imp <span>C</span> <span>B</span><span>&#34;</span></span><span>
    </span><span>by</span> <span>(</span><span>simp</span> <span>add</span><span>:</span> S<span>)</span><span>
  </span><span>thus</span> <span>?case</span><span>
    </span><span>by</span> <span>(</span><span>metis</span> Un_Diff<span>)</span>
<span>next</span><span>
  </span><span>case</span> <span>(</span>Exists <span>H</span> <span>A</span> <span>B</span> <span>i</span><span>)</span> <span>show</span> <span>?case</span><span>
  </span><span>proof</span> <span>(</span><span>cases</span> <span><span>&#34;</span><span>C</span> <span>∈</span> <span>H</span><span>&#34;</span></span><span>)</span><span>
    </span><span>case</span> True<span>
    </span><span>hence</span> <span><span>&#34;</span>atom <span>i</span> <span>♯</span> <span>C</span><span>&#34;</span></span> <span>using</span> Exists <span>by</span> <span>auto</span><span>
    </span><span>moreover</span> <span>have</span> <span><span>&#34;</span><span>H</span> <span>-</span> <span>{</span><span>C</span><span>}</span> <span>⊢</span> <span>A</span> <span>IMP</span> <span>C</span> <span>IMP</span> <span>B</span><span>&#34;</span></span> <span>using</span> Exists<span>
      </span><span>by</span> <span>(</span><span>metis</span> Imp_Imp_commute<span>)</span><span>
    </span><span>ultimately</span> <span>have</span> <span><span>&#34;</span><span>H</span> <span>-</span> <span>{</span><span>C</span><span>}</span> <span>⊢</span> <span>(</span>Ex <span>i</span> <span>A</span><span>)</span> <span>IMP</span> <span>C</span> <span>IMP</span> <span>B</span><span>&#34;</span></span> <span>using</span> Exists<span>
      </span><span>by</span> <span>(</span><span>metis</span> fm.fresh<span>(</span>3<span>)</span> fm.fresh<span>(</span>4<span>)</span> hfthm.Exists member_remove remove_def<span>)</span><span>
    </span><span>thus</span> <span>?thesis</span><span>
      </span><span>by</span> <span>(</span><span>metis</span> Imp_Imp_commute<span>)</span><span>
  </span><span>next</span><span>
    </span><span>case</span> False<span>
    </span><span>hence</span> <span><span>&#34;</span><span>H</span> <span>-</span> <span>{</span><span>C</span><span>}</span> <span>=</span> <span>H</span><span>&#34;</span></span> <span>by</span> <span>auto</span><span>
    </span><span>thus</span> <span>?thesis</span> <span>using</span> Exists<span>
      </span><span>by</span> <span>(</span><span>metis</span> Imp_triv_I hfthm.Exists<span>)</span><span>
  </span><span>qed</span>
<span>qed</span>
</pre>

<p>That’s surely enough for now. More next week!</p>






      


    </section></div>
  </body>
</html>
