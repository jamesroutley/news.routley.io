<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jonashietala.se/blog/2024/03/19/lets_create_a_tree-sitter_grammar/">Original</a>
    <h1>Let&#39;s create a Tree-sitter grammar</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      
<article>
  <header>
    
    
    


  </header>

   <p>One of my favorite features in Neovim is the Tree-sitter integration.
It allows for fast syntax highlighting that works well even in an error state (often the case when you’re editing code), and it has additional semantics (you can differentiate between function parameters and local variables).</p>
<p>With <a href="https://github.com/nvim-treesitter/nvim-treesitter-textobjects">nvim-treesitter-textobjects</a> you can also jump between nodes (such as <code>]c</code> to jump to next class) or target deletion (<code>cif</code> to delete the function body and enter insert mode).
An amazing feature as it works across languages, no matter how they look like, as long as they have a Tree-sitter grammar (most do).</p>
<p>But, you might wonder what does a Tree-sitter grammar look like,
and how do you create one for a language?</p>
<p>I started thinking about this and before I knew it I was <a href="https://github.com/treeman/tree-sitter-djot">trying to make my own parser</a> for <a href="https://djot.net/">Djot</a> (a markup language similar to Markdown).
There are some good tutorials on how to get started, but not on some more advanced things.</p>
<p>I spent quite some time trying to figure it out—while refreshing my 10 year old knowledge of grammars—and decided to document some of my findings.</p>
<p>The post spiraled out of control a little, and it will go through:</p>
<ol>
<li>
How to use an external scanner
</li>
<li>
Using Tree-sitter’s built-in conflicts resolution
</li>
<li>
Syntax highlighting with language injection
</li>
<li>
Use the grammar from Neovim for syntax highlighting and textobjects
</li>
<li>
Embed the grammar into this Blog for syntax highlighting
</li>
</ol>
<p>The source code for the complete grammar we’ll develop <a href="https://github.com/treeman/tree-sitter-sdjot">can be found on GitHub</a>.</p>
<section id="Our-subset">
<h2><a href="#Our-subset">Our subset</a></h2>
<p>For the purpose of this blog post, we’ll implement a small subset of <a href="https://djot.net/">Djot</a>, where we’ll support:</p>
<ul>
<li>
Paragraphs
</li>
<li>
Divs
</li>
<li>
Code blocks
</li>
<li>
Emphasis
</li>
</ul>
<p>This will allow us to parse markup like this:</p>
<div><pre><code><span>This is a</span>
<span>multiline <span><span>_</span>paragraph<span>_</span></span></span>
<span></span>
<span></span><span>:::</span>
<span>This is a paragraph inside a div</span>
<span></span><span>:::</span>

<span><span>```</span><span>gleam</span></span>
<span><span>let</span> <span>x</span> <span>=</span> <span>2</span>;</span>
<span><span>```</span></span>
</code></pre></div>
<p>(Yes, the <code>sdjot</code> highlight uses our grammar.)</p>
<p>At first blush, this seems like it’s too simple to require anything more complex than some simple grammar rules, but later on we’ll see that even these simple rules requires a bit more effort to fully support.</p>
</section>
<section id="Simple-beginnings">
<h2><a href="#Simple-beginnings">Simple beginnings</a></h2>
<p>The point of this post isn’t to go through how the Tree-sitter grammar description in <code>grammar.js</code> works.
The <a href="https://tree-sitter.github.io/tree-sitter/creating-parsers">Tree-sitter docs</a> goes through how to get started.
I named the project <code>sdjot</code> and this is the <code>grammar.js</code> we’ll start with:</p>
<div><pre><code><span>module<span>.</span><span>exports</span> <span>=</span> grammar<span><span><span><span>(</span></span></span></span><span><span><span><span>{</span>
  name<span>:</span> <span><span><span>&#34;</span>sdjot<span>&#34;</span></span></span><span>,</span>

        <span><span>extras</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span>[</span><span><span><span>&#34;</span><span>\r</span><span>&#34;</span></span></span><span>]</span></span><span>,</span>

  rules<span>:</span> <span><span>{</span>
    <span><span>document</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> repeat<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_block</span><span>)</span></span></span><span>,</span>

        <span><span>_block</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> choice<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>div</span><span>,</span> $<span>.</span><span>code_block</span><span>,</span> $<span>.</span><span>paragraph</span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>

        <span><span>div</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span>
      prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>div_marker</span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>,</span> repeat<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_block</span><span>)</span></span></span><span>,</span> $<span>.</span><span>div_marker</span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span>
    <span><span>div_marker</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>&#34;</span>:::<span>&#34;</span></span></span><span>,</span>

        <span><span>code_block</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span>
      seq<span><span><span><span>(</span></span></span></span><span><span>
        $<span>.</span><span>code_block_marker</span><span>,</span>
        optional<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>language</span><span>)</span></span></span><span>,</span>
        <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>,</span>
        optional<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>code</span><span>)</span></span></span><span>,</span>
        $<span>.</span><span>code_block_marker</span><span>,</span>
      <span>)</span></span></span><span>,</span>
    <span><span>code_block_marker</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>&#34;</span>```<span>&#34;</span></span></span><span>,</span>
    <span><span>code</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> repeat1<span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span><span><span>[</span><span>^</span><span>\n</span><span>]</span></span><span>*</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span>
    <span><span>language</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>/</span><span><span>[</span><span>^</span><span>\s</span><span>]</span></span><span>+</span><span>/</span></span></span><span></span><span>,</span>

            <span><span>paragraph</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span>repeat<span><span>1</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_inline</span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>

            <span><span>_inline</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> repeat1<span><span><span><span>(</span></span></span></span><span><span>choice<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>emphasis</span><span>,</span> $<span>.</span><span>_text</span><span>)</span></span></span><span>)</span></span></span><span>,</span>
    <span><span>emphasis</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>,</span> $<span>.</span><span>_inline</span><span>,</span> <span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span>
    <span><span>_text</span></span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>/</span><span><span>[</span><span>^</span><span>\n</span><span>]</span></span><span>/</span></span></span><span></span><span>,</span>
  <span>}</span></span><span>,</span>
<span>}</span></span><span>)</span></span></span><span>;</span>
</span></code></pre></div>
<p>It recognizes paragraphs with text and emphasis, and it identifies divs and code blocks.</p>
<p>We can create an <code>example-file</code> with these contents:</p>
<div><pre><code><span>:::</span>
<span>A paragraph <span><span>_</span>with emphasis<span>_</span></span> inside a div</span>
<span></span>
<span></span><span>:::</span>
</code></pre></div>
<p>And parse it with the <code>tree-sitter</code> cli:</p>
<div><pre><code><span>$ </span><span>tree-sitter</span> parse example-file
(document [0, 0] - [5, 0]
  (div [0, 0] - [4, 0]
    (div_marker [0, 0] - [0, 3])
    (paragraph [1, 0] - [3, 0]
      (emphasis [1, 12] - [1, 27]))
    (div_marker [3, 0] - [3, 3])))
</code></pre></div>
<p>Et voilà!</p>
<section id="Missing-features">
<h3><a href="#Missing-features">Missing features</a></h3>
<p>But I told you it wasn’t supposed to be this easy, and there are features missing from our parser.
Most notably:</p>
<ol type="A">
<li>
There can be an arbitrary number of <code>:</code>, allowing divs to be nested.
</li>
<li>
Closing a div should close other open blocks (divs and paragraphs in our case).
</li>
</ol>
<p>In essence, we need to be able to parse this:</p>
<div><pre><code><span>:::</span>
<span>Top-level div</span>
<span></span>
<span></span><span>::::</span>
<span>A paragraph inside a second div,</span>
<span>both closed when the top-level div is closedj</span>
<span></span><span>:::</span>
</code></pre></div>
<p>This is… Complicated.</p>
<p>Sure, we can work around the varying levels of <code>:</code> with something hacky like enumerating the number of colons, using something like this:</p>
<div><pre><code><span><span>div</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> choice<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_div3</span><span>,</span> $<span>.</span><span>_div4</span><span>,</span> $<span>.</span><span>_div5</span><span>,</span> $<span>.</span><span>_div6</span><span>,</span> $<span>.</span><span>_div7</span><span>,</span> $<span>.</span><span>_div8</span><span>)</span></span></span><span>,</span>
<span>_div3</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{3}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{3}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_div4</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{4}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{4}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_div5</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{5}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{5}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_div6</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{6}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{6}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_div7</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{7}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{7}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_div8</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>/</span>:<span>{8}</span><span>/</span></span></span><span></span><span>,</span> $<span>.</span><span>_inside_div</span><span>,</span> <span><span><span>/</span>:<span>{8}</span><span>/</span></span></span><span></span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_inside_div</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span><span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>,</span> repeat<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_block</span><span>)</span></span></span><span>)</span></span></span><span>,</span>
</span></code></pre></div>
<p>But it’s not <em>neat</em>, and automatically closing contained blocks is much harder (to my brain it seems impossible, but I’m no expert).</p>
<p>With an external scanner we can do this (and more).</p>
</section>
</section>
<section id="External-scanner">
<h2><a href="#External-scanner">External scanner</a></h2>
<p>A Tree-sitter parser is actually a C program.
The grammar we’ve seen has been described in JavaScript, but it’s only used as a description to generate the parser in C.
If you’re a masochist, you can take a look at it in <code>src/parser.c</code> after running <code>tree-sitter generate</code>.</p>
<p>An external scanner is just some custom C code that’s inserted into the parser, and it allows us to override the parser precedence, keep track of a context state, or whatever else we might need or want to do.</p>
<p>To get started the <a href="https://tree-sitter.github.io/tree-sitter/creating-parsers#external-scanners">official docs</a> was pretty good.
Basically you need to:</p>
<ol>
<li>
Create a <code>src/scanner.c</code> and include it in <code>binding.gyp</code> <code>bindings/rust/build.rs</code>.
</li>
<li>
Setup <code>externals</code> tokens in <code>grammar.js</code> and a matching C enum in <code>scanner.c</code>.
</li>
<li>
Define and implement five C functions.
</li>
</ol>
<p>Let’s take a look.</p>
<section id="Div-markers-closes-open-paragraphs">
<h3><a href="#Div-markers-closes-open-paragraphs">Div markers closes open paragraphs</a></h3>
<p>Let’s start by closing a paragraph early when a <code>:::</code> is encountered.
This is simpler because we can solve this without storing any state.</p>
<p>When parsing <code>$.paragraph</code> we’ll give the parser a choice between ending the paragraph on a newline or on our new <code>$._close_paragraph</code> token:</p>
<div><pre><code><span><span>paragraph</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span>
  seq<span><span><span><span>(</span></span></span></span><span><span>repeat<span><span>1</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_inline</span><span>,</span> <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span> choice<span><span><span><span>(</span></span></span></span><span><span><span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>,</span> $<span>.</span><span>_close_paragraph</span><span>)</span></span></span><span>)</span></span></span><span>,</span>
</span></code></pre></div>
<p><code>$._close_paragraph</code> is handled by the external scanner, which is specified using the <code>externals</code> field:</p>
<div><pre><code><span><span>externals</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> <span><span>[</span>$<span>.</span><span>_close_paragraph</span><span>]</span></span><span>,</span>
</span></code></pre></div>
<p>Now let’s turn our attention to <code>src/scanner.c</code>.
The tokens in <code>externals</code> gets assigned an incremented number, starting from 0…
Just like an enum in C!</p>
<div><pre><code><span><span>typedef</span> <span>enum</span> <span><span>{</span> CLOSE_PARAGRAPH <span>}</span></span> <span>TokenType</span><span>;</span>
</span></code></pre></div>
<p>The five functions we need to implement are these:</p>
<div><pre><code><span><span>bool</span> <span><span>tree_sitter_sdjot_external_scanner_scan</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                                             <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
    <span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span></span></span>

<span>void</span> <span>*</span><span><span>tree_sitter_sdjot_external_scanner_create</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span> <span>return</span> <span>NULL</span><span>;</span> </span></span><span><span><span>}</span></span></span>
<span>void</span> <span><span>tree_sitter_sdjot_external_scanner_destroy</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span>

<span>unsigned</span> <span><span>tree_sitter_sdjot_external_scanner_serialize</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span>
                                                      <span>char</span> <span>*</span><span>buffer</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
<span>void</span> <span><span>tree_sitter_sdjot_external_scanner_deserialize</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> <span>char</span> <span>*</span><span>buffer</span><span>,</span>
                                                    <span>unsigned</span> <span>length</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Because we won’t use any state, we’ll only have to update the <code>scan</code> function.</p>
<p>What you’re supposed to do is check <code>valid_symbols</code> for the tokens we can return at any point in time, and return <code>true</code> if any was found:</p>
<div><pre><code><span><span>bool</span> <span><span>tree_sitter_sdjot_external_scanner_scan</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                                             <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>if</span> <span><span>(</span>valid_symbols<span><span>[</span>CLOSE_PARAGRAPH<span>]</span></span> <span>&amp;&amp;</span> <span><span>parse_close_paragraph</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>
  <span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>To decide if we’re going to close the paragraph early, we’ll look ahead for any <code>:::</code>, and if so we’ll close it without consuming any characters.
This might not be the most efficient solution because we’ll have to parse the <code>:::</code> again, but it gets the job done.</p>
<p>The matched token should be stored in 
<code><span>lexer<span>-&gt;</span>result_symbol</span></code>:</p>
<div><pre><code><span><span>static</span> <span>bool</span> <span><span>parse_close_paragraph</span></span><span><span><span>(</span></span></span><span><span>TSLexer <span>*</span><span>lexer</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
      lexer<span>-&gt;</span><span><span>mark_end</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>;</span>

  <span>uint8_t</span> colons <span>=</span> <span><span>consume_chars</span><span><span>(</span></span></span><span><span>lexer<span>,</span> <span><span>&#39;</span>:<span>&#39;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
  <span>if</span> <span><span>(</span>colons <span>&gt;=</span> <span>3</span><span>)</span></span> <span><span>{</span>
    lexer<span>-&gt;</span>result_symbol <span>=</span> CLOSE_PARAGRAPH<span>;</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span> <span>else</span> <span><span>{</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>}</span></span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Note that the resulting token will mark any symbol we advance over as owned by that token.
So <code>:::</code> would be marked as <code>_close_paragraph</code> (which will be ignored by the output since it begins with an underscore), instead of <code>div_marker</code>.
To prevent this, we turn <code>_close_paragraph</code> into a zero-width token by marking the end before advancing the lexer.</p>
<p>How do we advance the lexer?
We call 
<code><span>lexer<span>-&gt;</span>advance</span></code>:</p>
<div><pre><code><span><span>static</span> <span>uint8_t</span> <span><span>consume_chars</span></span><span><span><span>(</span></span></span><span><span>TSLexer <span>*</span><span>lexer</span><span>,</span> <span>char</span> <span>c</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>uint8_t</span> count <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span><span>(</span>lexer<span>-&gt;</span>lookahead <span>==</span> c<span>)</span></span> <span><span>{</span>
    lexer<span>-&gt;</span><span><span>advance</span><span><span>(</span></span></span><span><span>lexer<span>,</span> <span>false</span></span></span><span><span><span>)</span></span></span><span>;</span>
    <span>+</span><span>+</span>count<span>;</span>
  <span>}</span></span>
  <span>return</span> count<span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>This is almost all we can do with the lexer.
We only process one character at a time, cannot look behind, and our only tool to look ahead is to <code>mark_end</code> at the correct place.
(We can also query the current column position.)</p>
<p>With this we have a working external scanner and div tags now close paragraphs:</p>
<div><pre><code><span>:::</span>
<span>A paragraph inside a div</span>
<span></span><span>:::</span>
</code></pre></div>
<div><pre><code><span>$ </span><span>tree-sitter</span> parse example-file
(document [0, 0] - [4, 0]
  (div [0, 0] - [3, 0]
    (div_marker [0, 0] - [0, 3])
    (paragraph [1, 0] - [2, 0])
    (div_marker [2, 0] - [2, 3])))
</code></pre></div>
</section>
<section id="Nested-blocks">
<h3><a href="#Nested-blocks">Nested blocks</a></h3>
<p>To automatically close other open blocks we need to add some context to our parser, which means we’ll need state management.</p>
<p>The small subset we’re implementing is only concerned with closing divs—because it would be a terribly long post otherwise—but I’ll try to implement this in a general manner, to be more indicative of a real-world parser.</p>
<p>Our strategy is this:</p>
<ol>
<li>
<p>A div can have a varying number of <code>:</code> that must match.</p>
<p>Therefore we’ll parse colons in an external scanner and store it on a stack.</p>
</li>
<li>
<p>When we find a div marker, we’ll need to decide if it should start a new div, or close an existing one.</p>
<p>We’ll look at the stack of open blocks and see if we find a match.</p>
</li>
<li>
<p>If we have need to close a nested div, that is if we want to close a div further down the stack, we need to close the nested div(s) first.</p>
<p>Thus we’ll introduce a <code>block_close</code> marker that ends a div, and leave the ending div marker as optional.</p>
</li>
</ol>
<p>First we’ll ask the grammar to let the external scanner manage the begin and end tokens.
We’ll use a <code>_block_close</code> marker to end the div, and leave the end marker optional.
(You could probably use a <code>choice()</code> between the two, but this made more sense to me when I was implementing it.)</p>
<div><pre><code><span><span>div</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span>
  prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span>
    seq<span><span><span><span>(</span></span></span></span><span><span>
                  alias<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_div_marker_begin</span><span>,</span> $<span>.</span><span>div_marker</span><span>)</span></span></span><span>,</span>
      <span><span><span>&#34;</span><span>\n</span><span>&#34;</span></span></span><span>,</span>
      repeat<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_block</span><span>)</span></span></span><span>,</span>
      $<span>.</span><span>_block_close</span><span>,</span>
      optional<span><span><span><span>(</span></span></span></span><span><span>alias<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>_div_marker_end</span><span>,</span> $<span>.</span><span>div_marker</span><span>)</span></span></span><span>)</span></span></span>
    <span>)</span></span></span>
  <span>)</span></span></span><span>,</span>

<span>externals</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> <span><span>[</span>
  $<span>.</span><span>_close_paragraph</span><span>,</span>
  $<span>.</span><span>_block_close</span><span>,</span>
  $<span>.</span><span>_div_marker_begin</span><span>,</span>
  $<span>.</span><span>_div_marker_end</span><span>,</span>

      $<span>.</span><span>_ignored</span><span>,</span>
<span>]</span></span><span>,</span>
</span></code></pre></div>
<p>And remember to update the list of external tokens in the scanner (order matters):</p>
<div><pre><code><span><span>typedef</span> <span>enum</span> <span><span>{</span>
  CLOSE_PARAGRAPH<span>,</span>
  BLOCK_CLOSE<span>,</span>
  DIV_MARKER_BEGIN<span>,</span>
  DIV_MARKER_END<span>,</span>
<span>  IGNORED
</span><span>}</span></span> <span>TokenType</span><span>;</span>
</span></code></pre></div>
<p>Then to our stack of blocks.</p>
<p>I used a <code>Block</code> type to keep track of the type and number of colons:</p>
<div><pre><code><span><span>typedef</span> <span>enum</span> <span><span>{</span> DIV <span>}</span></span> <span>BlockType</span><span>;</span>

<span>typedef</span> <span>struct</span> <span><span>{</span>
  BlockType type<span>;</span>
  <span>uint8_t</span> level<span>;</span>
<span>}</span></span> <span>Block</span><span>;</span>
</span></code></pre></div>
<p>I know that <code>level</code> isn’t the best name, but I couldn’t find a very good general name for the number of colons, indentation level, etc.
With sum types you could model it in a clearer way, like this:</p>
<div><pre><code><span><span><span>enum</span> <span>Block</span> <span><span>{</span>
    Div <span><span>{</span> colons<span>:</span> <span>u32</span> </span><span><span>}</span></span><span>,</span>
    Footnote <span><span>{</span> indent<span>:</span> <span>u32</span> </span><span><span>}</span></span><span>,</span>
    </span><span><span>}</span></span></span>
</span></code></pre></div>
<blockquote>
<p>I will, in fact, claim that the difference between a bad programmer and a good one
is whether he considers his code or his data structures more important.
Bad programmers worry about the code.
Good programmers worry about data structures and their relationships.
</p>

</blockquote>
<p>But I digress, I’ll go with <code>level</code> like a bad programmer.</p>
<p>Another joy of programming C is that you’ll get to re-implement standard data structures such as a growable stack.
It’s not truly difficult, but it’s annoying and bug-prone.</p>
<p>Luckily, during the time I’m writing this blog post, <a href="https://github.com/tree-sitter/tree-sitter/releases/tag/v0.22.1">tree-sitter 0.22.1</a> was released with an array implementation.
So now I don’t have to show you my shoddy stack implementation, and we can use their array for our stack instead.</p>
<p>We’ll shove our <code>Array</code> of <code>Block*</code> into a <code>Scanner</code> struct, because we’ll need to track more data later:</p>
<div><pre><code><span><span><span>#include</span> <span><span>&#34;</span>tree_sitter/array.h<span>&#34;</span></span>
</span>
<span>typedef</span> <span>struct</span> <span><span>{</span>
  <span><span>Array</span><span><span>(</span></span></span><span><span>Block <span>*</span></span></span><span><span><span>)</span></span></span> <span>*</span> open_blocks<span>;</span>
<span>}</span></span> <span>Scanner</span><span>;</span>
</span></code></pre></div>
<p>When you manage state in tree-sitter, you need to do some data management in the <code>tree_sitter_</code> functions we defined earlier.</p>
<p>Allocations are managed in the <code>_create</code> and <code>_destroy</code> functions.
Also new for 0.22.1 is the recommendation to use <code>ts_</code> functions for allocations, to allow consumers to override the default allocator:</p>
<div><pre><code><span><span><span>#include</span> <span><span>&#34;</span>tree_sitter/alloc.h<span>&#34;</span></span>
</span>
<span>void</span> <span>*</span><span><span>tree_sitter_sdjot_external_scanner_create</span></span><span><span><span>(</span></span></span><span><span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span><span><span>ts_malloc</span><span><span>(</span></span></span><span><span><span>sizeof</span><span><span>(</span></span><span>Scanner</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>

    s<span>-&gt;</span>open_blocks <span>=</span> <span><span>ts_malloc</span><span><span>(</span></span></span><span><span><span>sizeof</span><span><span>(</span></span><span><span><span>Array</span><span><span>(</span></span></span><span><span>Block <span>*</span></span></span><span><span><span>)</span></span></span></span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
  <span><span>array_init</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks</span></span><span><span><span>)</span></span></span><span>;</span>

  <span>return</span> s<span>;</span>
</span></span><span><span><span>}</span></span></span>

<span>void</span> <span><span>tree_sitter_sdjot_external_scanner_destroy</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span>payload<span>;</span>

        <span>for</span> <span><span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>-&gt;</span>open_blocks<span>-&gt;</span>size<span>;</span> <span>+</span><span>+</span>i<span>)</span></span> <span><span>{</span>
        <span><span>ts_free</span><span><span>(</span></span></span><span><span><span><span>array_get</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks<span>,</span> i</span></span><span><span><span>)</span></span></span></span></span><span><span><span>)</span></span></span><span>;</span>
  <span>}</span></span>

      <span><span>array_delete</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks</span></span><span><span><span>)</span></span></span><span>;</span>

  <span><span>ts_free</span><span><span>(</span></span></span><span><span>s</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>I allocate the blocks in a <code>push_block</code> helper:</p>
<div><pre><code><span><span>static</span> <span>void</span> <span><span>push_block</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> BlockType <span>type</span><span>,</span> <span>uint8_t</span> <span>level</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Block <span>*</span>b <span>=</span> <span><span>ts_malloc</span><span><span>(</span></span></span><span><span><span>sizeof</span><span><span>(</span></span><span>Block</span><span><span>)</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
  b<span>-&gt;</span>type <span>=</span> type<span>;</span>
  b<span>-&gt;</span>level <span>=</span> level<span>;</span>

    <span><span>array_push</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks<span>,</span> b</span></span><span><span><span>)</span></span></span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>You also need to define the serialize functions.
These store and retrieve the managed state, to allow tree-sitter to backtrack.</p>
<div><pre><code><span><span>unsigned</span> <span><span>tree_sitter_sdjot_external_scanner_serialize</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span>
                                                      <span>char</span> <span>*</span><span>buffer</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span>payload<span>;</span>
  <span>unsigned</span> size <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span><span>(</span><span>size_t</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>-&gt;</span>open_blocks<span>-&gt;</span>size<span>;</span> <span>+</span><span>+</span>i<span>)</span></span> <span><span>{</span>
    Block <span>*</span>b <span>=</span> <span>*</span><span><span>array_get</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks<span>,</span> i</span></span><span><span><span>)</span></span></span><span>;</span>
    buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span> <span>=</span> <span><span>(</span><span>char</span><span>)</span></span>b<span>-&gt;</span>type<span>;</span>
    buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span> <span>=</span> <span><span>(</span><span>char</span><span>)</span></span>b<span>-&gt;</span>level<span>;</span>
  <span>}</span></span>
  <span>return</span> size<span>;</span>
</span></span><span><span><span>}</span></span></span>

<span>void</span> <span><span>tree_sitter_sdjot_external_scanner_deserialize</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> <span>char</span> <span>*</span><span>buffer</span><span>,</span>
                                                    <span>unsigned</span> <span>length</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span>payload<span>;</span>
  <span><span>array_init</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks</span></span><span><span><span>)</span></span></span><span>;</span>
  <span>size_t</span> size <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span><span>(</span>size <span>&lt;</span> length<span>)</span></span> <span><span>{</span>
    BlockType type <span>=</span> <span><span>(</span>BlockType<span>)</span></span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span><span>;</span>
    <span>uint8_t</span> level <span>=</span> <span><span>(</span><span>uint8_t</span><span>)</span></span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span><span>;</span>
    <span><span>push_block</span><span><span>(</span></span></span><span><span>s<span>,</span> type<span>,</span> level</span></span><span><span><span>)</span></span></span><span>;</span>
  <span>}</span></span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>And that’s the (initial) state management taken care of!</p>

</section>
<section id="Div-markers">
<h3><a href="#Div-markers">Div markers</a></h3>
<p>Of course, we haven’t used our state yet.
Let’s change that.</p>
<p>First, let’s add the <code>parse_div</code> entry point to our scan function:</p>
<div><pre><code><span><span>bool</span> <span><span>tree_sitter_sdjot_external_scanner_scan</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                                             <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span>payload<span>;</span>

    <span>if</span> <span><span>(</span>valid_symbols<span><span>[</span>CLOSE_PARAGRAPH<span>]</span></span> <span>&amp;&amp;</span> <span><span>parse_close_paragraph</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>

    <span>if</span> <span><span>(</span><span><span>parse_div</span><span><span>(</span></span></span><span><span>s<span>,</span> lexer<span>,</span> valid_symbols</span></span><span><span><span>)</span></span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>

  <span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Because advancing the lexer is primitive, and we cannot “go back a char”, it’s important to only advance it if we really need to.
Therefore we always need to check <code>valid_symbols</code> before we continue:</p>
<div><pre><code><span><span>static</span> <span>bool</span> <span><span>parse_div</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span> <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>if</span> <span><span>(</span><span>!</span>valid_symbols<span><span>[</span>DIV_MARKER_BEGIN<span>]</span></span> <span>&amp;&amp;</span> <span>!</span>valid_symbols<span><span>[</span>DIV_MARKER_END<span>]</span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>}</span></span>

  </span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Next we’ll need to consume all colons we’re at, and only continue if we see at least three:</p>
<div><pre><code><span><span>static</span> <span>uint8_t</span> <span><span>consume_chars</span></span><span><span><span>(</span></span></span><span><span>TSLexer <span>*</span><span>lexer</span><span>,</span> <span>char</span> <span>c</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>uint8_t</span> count <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span><span>(</span>lexer<span>-&gt;</span>lookahead <span>==</span> c<span>)</span></span> <span><span>{</span>
    lexer<span>-&gt;</span><span><span>advance</span><span><span>(</span></span></span><span><span>lexer<span>,</span> <span>false</span></span></span><span><span><span>)</span></span></span><span>;</span>
    <span>+</span><span>+</span>count<span>;</span>
  <span>}</span></span>
  <span>return</span> count<span>;</span>
</span></span><span><span><span>}</span></span></span>

<span>static</span> <span>bool</span> <span><span>parse_div</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span> <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  
  <span>uint8_t</span> colons <span>=</span> <span><span>consume_chars</span><span><span>(</span></span></span><span><span>lexer<span>,</span> <span><span>&#39;</span>:<span>&#39;</span></span></span></span><span><span><span>)</span></span></span><span>;</span>
  <span>if</span> <span><span>(</span>colons <span>&lt;</span> <span>3</span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>}</span></span>

  </span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Opening a new div is simple; we push the block and register the number of colons:</p>
<div><pre><code><span><span><span>push_block</span><span><span>(</span></span></span><span><span>s<span>,</span> DIV<span>,</span> colons</span><span><span>)</span></span></span><span>;</span>
lexer<span>-&gt;</span>result_symbol <span>=</span> DIV_MARKER_BEGIN<span>;</span>
<span>return</span> <span>true</span><span>;</span>
</span></code></pre></div>
<p>But to the decide if we should open or close a div, we need a way to search through the stack.
This function does that, while also returning how many blocks deep into the stack we found the div (which we’ll use shortly):</p>
<div><pre><code><span><span>static</span> <span>size_t</span> <span><span>number_of_blocks_from_top</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> BlockType <span>type</span><span>,</span>
                                        <span>uint8_t</span> <span>level</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>for</span> <span><span>(</span><span>int</span> i <span>=</span> s<span>-&gt;</span>open_blocks<span>-&gt;</span>size <span>-</span> <span>1</span><span>;</span> i <span>&gt;=</span> <span>0</span><span>;</span> <span>-</span><span>-</span>i<span>)</span></span> <span><span>{</span>
    Block <span>*</span>b <span>=</span> <span>*</span><span><span>array_get</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks<span>,</span> i</span></span><span><span><span>)</span></span></span><span>;</span>
    <span>if</span> <span><span>(</span>b<span>-&gt;</span>type <span>==</span> type <span>&amp;&amp;</span> b<span>-&gt;</span>level <span>==</span> level<span>)</span></span> <span><span>{</span>
      <span>return</span> s<span>-&gt;</span>open_blocks<span>-&gt;</span>size <span>-</span> i<span>;</span>
    <span>}</span></span>
  <span>}</span></span>
  <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span></span></span>

<span>static</span> <span>bool</span> <span><span>parse_div</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span> <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  
  <span>size_t</span> from_top <span>=</span> <span><span>number_of_blocks_from_top</span><span><span>(</span></span></span><span><span>s<span>,</span> DIV<span>,</span> colons</span></span><span><span><span>)</span></span></span><span>;</span>

      <span>if</span> <span><span>(</span>from_top <span>&gt;</span> <span>0</span><span>)</span></span> <span><span>{</span>
      <span>}</span></span> <span>else</span> <span><span>{</span>
        lexer<span>-&gt;</span><span><span>mark_end</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>;</span>
    <span><span>push_block</span><span><span>(</span></span></span><span><span>s<span>,</span> DIV<span>,</span> colons</span></span><span><span><span>)</span></span></span><span>;</span>
    lexer<span>-&gt;</span>result_symbol <span>=</span> DIV_MARKER_BEGIN<span>;</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>But we have a problem: when we want to close the div, we want to be able to output multiple tokens.</p>
<p>For example, with this type of input:</p>
<div><pre><code><span>:::</span>
<span>:::::</span>
<span>:::::::</span>
<span>text</span>
<span></span><span>:::</span>
</code></pre></div>
<p>We’ll have a stack of 3 divs when we see the closing <code>:::</code> marker:</p>
<div><pre><code>7 (top)
5
3 (the one we want to close)
</code></pre></div>
<p>In the code above, <code>from_top</code> will be <code>3</code> and we need to output 4 tokens: 3 <code>BLOCK_CLOSE</code> (one for each div) and 1 <code>DIV_MARKER_END</code> (for the last <code>:::</code>).
But the scanner can only output a single token at a time.</p>
<p>The way I solved this is by introducing more state to the Scanner.
Specifically, I introduced a <code>blocks_to_close</code> variable that we’ll use to output <code>BLOCK_CLOSE</code>, and some variables to output (and consume) the <code>DIV_MARKER_END</code>.</p>
<div><pre><code><span><span>typedef</span> <span>struct</span> <span><span>{</span>
  <span><span>Array</span><span><span>(</span></span></span><span><span>Block <span>*</span></span></span><span><span><span>)</span></span></span> <span>*</span> open_blocks<span>;</span>

    <span>uint8_t</span> blocks_to_close<span>;</span>

    TokenType delayed_token<span>;</span>
    <span>uint8_t</span> delayed_token_width<span>;</span>
<span>}</span></span> <span>Scanner</span><span>;</span>
</span></code></pre></div>
<p>We need to remember to update the create and serialize functions too.</p>
<p>Serialize:</p>
<div><pre><code><span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span> <span>=</span> <span><span>(</span><span>char</span><span>)</span></span>s<span>-&gt;</span>blocks_to_close<span>;</span>
buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span> <span>=</span> <span><span>(</span><span>char</span><span>)</span></span>s<span>-&gt;</span>delayed_token<span>;</span>
buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span> <span>=</span> <span><span>(</span><span>char</span><span>)</span></span>s<span>-&gt;</span>delayed_token_width<span>;</span>
</span></code></pre></div>
<p>Deserialize:</p>
<div><pre><code><span>s<span>-&gt;</span>blocks_to_close <span>=</span> <span><span>(</span><span>uint8_t</span><span>)</span></span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span><span>;</span>
s<span>-&gt;</span>delayed_token <span>=</span> <span><span>(</span>TokenType<span>)</span></span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span><span>;</span>
s<span>-&gt;</span>delayed_token_width <span>=</span> <span><span>(</span><span>uint8_t</span><span>)</span></span>buffer<span><span>[</span>size<span>+</span><span>+</span><span>]</span></span><span>;</span>
</span></code></pre></div>
<p>We’ll use <code>IGNORED</code> as the unused token, so we’ll need to reset it when we create the scanner:</p>
<div><pre><code><span>s<span>-&gt;</span>blocks_to_close <span>=</span> <span>0</span><span>;</span>
s<span>-&gt;</span>delayed_token <span>=</span> IGNORED<span>;</span>
</span></code></pre></div>
<p>Now when we scan we should first check <code>blocks_to_close</code> and then <code>delayed_token</code>, before we scan other things:</p>
<div><pre><code><span><span>bool</span> <span><span>tree_sitter_sdjot_external_scanner_scan</span></span><span><span><span>(</span></span></span><span><span><span>void</span> <span>*</span><span>payload</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                                             <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  Scanner <span>*</span>s <span>=</span> <span><span>(</span>Scanner <span>*</span><span>)</span></span>payload<span>;</span>

  <span>if</span> <span><span>(</span>valid_symbols<span><span>[</span>BLOCK_CLOSE<span>]</span></span> <span>&amp;&amp;</span> <span><span>handle_blocks_to_close</span><span><span>(</span></span></span><span><span>s<span>,</span> lexer</span></span><span><span><span>)</span></span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>

  <span>if</span> <span><span>(</span><span><span>output_delayed_token</span><span><span>(</span></span></span><span><span>s<span>,</span> lexer<span>,</span> valid_symbols</span></span><span><span><span>)</span></span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>

  </span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>When we see <code>blocks_to_close &gt; 0</code>, we should output a <code>BLOCK_CLOSE</code> and remove the top block (with some sanity checks for good measure):</p>
<div><pre><code><span><span>static</span> <span>void</span> <span><span>remove_block</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>if</span> <span><span>(</span>s<span>-&gt;</span>open_blocks<span>-&gt;</span>size <span>&gt;</span> <span>0</span><span>)</span></span> <span><span>{</span>
    <span><span>ts_free</span><span><span>(</span></span></span><span><span><span><span>array_pop</span><span><span>(</span></span></span><span><span>s<span>-&gt;</span>open_blocks</span></span><span><span><span>)</span></span></span></span></span><span><span><span>)</span></span></span><span>;</span>
    <span>if</span> <span><span>(</span>s<span>-&gt;</span>blocks_to_close <span>&gt;</span> <span>0</span><span>)</span></span> <span><span>{</span>
      <span>-</span><span>-</span>s<span>-&gt;</span>blocks_to_close<span>;</span>
    <span>}</span></span>
  <span>}</span></span>
</span></span><span><span><span>}</span></span></span>

<span>static</span> <span>bool</span> <span><span>handle_blocks_to_close</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>if</span> <span><span>(</span>s<span>-&gt;</span>open_blocks<span>-&gt;</span>size <span>==</span> <span>0</span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>}</span></span>

    <span>if</span> <span><span>(</span>lexer<span>-&gt;</span><span><span>eof</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span> <span>||</span> s<span>-&gt;</span>blocks_to_close <span>&gt;</span> <span>0</span><span>)</span></span> <span><span>{</span>
    lexer<span>-&gt;</span>result_symbol <span>=</span> BLOCK_CLOSE<span>;</span>
    <span><span>remove_block</span><span><span>(</span></span></span><span><span>s</span></span><span><span><span>)</span></span></span><span>;</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span></span>
  <span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>With this we can output multiple <code>BLOCK_CLOSE</code>, and now to handle delayed tokens:</p>
<div><pre><code><span><span>static</span> <span>bool</span> <span><span>output_delayed_token</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                          <span>const</span> <span>bool</span> <span>*</span><span>valid_symbols</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span>if</span> <span><span>(</span>s<span>-&gt;</span>delayed_token <span>==</span> IGNORED <span>||</span> <span>!</span>valid_symbols<span><span>[</span>s<span>-&gt;</span>delayed_token<span>]</span></span><span>)</span></span> <span><span>{</span>
    <span>return</span> <span>false</span><span>;</span>
  <span>}</span></span>

  lexer<span>-&gt;</span>result_symbol <span>=</span> s<span>-&gt;</span>delayed_token<span>;</span>
  s<span>-&gt;</span>delayed_token <span>=</span> IGNORED<span>;</span>
    <span>while</span> <span><span>(</span>s<span>-&gt;</span>delayed_token_width<span>-</span><span>-</span><span>)</span></span> <span><span>{</span>
    lexer<span>-&gt;</span><span><span>advance</span><span><span>(</span></span></span><span><span>lexer<span>,</span> <span>false</span></span></span><span><span><span>)</span></span></span><span>;</span>
  <span>}</span></span>
  lexer<span>-&gt;</span><span><span>mark_end</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>;</span>
  <span>return</span> <span>true</span><span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Another way to design this is to have a stack of delayed tokens and then just pop that.
It’s certainly more powerful, I just happened to choose this way when I was playing around with it because it’s more explicit and it felt a little easier to follow what was happening.</p>
<p>Either way, we can now implement the div end handling. In <code>parse_div</code>:</p>
<div><pre><code><span><span>size_t</span> from_top <span>=</span> <span><span>number_of_blocks_from_top</span><span><span>(</span></span></span><span><span>s<span>,</span> DIV<span>,</span> colons</span></span><span><span><span>)</span></span></span><span>;</span>

<span>if</span> <span><span>(</span>from_top <span>&gt;</span> <span>0</span><span>)</span></span> <span><span>{</span>
    <span><span>close_blocks_with_final_token</span><span><span>(</span></span></span><span><span>s<span>,</span> lexer<span>,</span> from_top<span>,</span> DIV_MARKER_END<span>,</span> colons</span></span><span><span><span>)</span></span></span><span>;</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span></span> <span>else</span> <span><span>{</span>
  lexer<span>-&gt;</span><span><span>mark_end</span><span><span>(</span></span></span><span><span>lexer</span></span><span><span><span>)</span></span></span><span>;</span>
  <span><span>push_block</span><span><span>(</span></span></span><span><span>s<span>,</span> DIV<span>,</span> colons</span></span><span><span><span>)</span></span></span><span>;</span>
  lexer<span>-&gt;</span>result_symbol <span>=</span> DIV_MARKER_BEGIN<span>;</span>
  <span>return</span> <span>true</span><span>;</span>
<span>}</span></span>
</span></code></pre></div>
<p><code>close_blocks_with_final_token</code> is a general helper that sets up the number of blocks to close and the final token:</p>
<div><pre><code><span><span>static</span> <span>void</span> <span><span>close_blocks_with_final_token</span></span><span><span><span>(</span></span></span><span><span>Scanner <span>*</span><span>s</span><span>,</span> TSLexer <span>*</span><span>lexer</span><span>,</span>
                                          <span>size_t</span> <span>count</span><span>,</span> TokenType <span>final</span><span>,</span>
                                          <span>uint8_t</span> <span>final_token_width</span><span>)</span></span></span><span> </span><span><span><span>{</span></span></span><span><span>
  <span><span>remove_block</span><span><span>(</span></span></span><span><span>s</span></span><span><span><span>)</span></span></span><span>;</span>
  s<span>-&gt;</span>blocks_to_close <span>=</span> s<span>-&gt;</span>blocks_to_close <span>+</span> count <span>-</span> <span>1</span><span>;</span>
  lexer<span>-&gt;</span>result_symbol <span>=</span> BLOCK_CLOSE<span>;</span>
  s<span>-&gt;</span>delayed_token <span>=</span> final<span>;</span>
  s<span>-&gt;</span>delayed_token_width <span>=</span> final_token_width<span>;</span>
</span></span><span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Now we can finally try to close divs:</p>
<div><pre><code><span>:::::</span>
<span>:::</span>
<span>:::::::</span>
<span>Divception</span>
<span></span><span>:::</span>
</code></pre></div>
<div><pre><code><span>$ </span><span>tree-sitter</span> parse example-file
(document [0, 0] - [6, 0]
  (div [0, 0] - [6, 0]
    (div_marker [0, 0] - [0, 5])
    (div [1, 0] - [4, 3]
      (div_marker [1, 0] - [1, 3])
      (div [2, 0] - [4, 0]
        (div_marker [2, 0] - [2, 7])
        (paragraph [3, 0] - [4, 0]))
      (div_marker [4, 0] - [4, 3]))))
</code></pre></div>
<p>We can see that it parses without error, the last marker closes the <em>second</em> div correctly, and the last marker captures the final <code>:::</code>.</p>
<p>While I’m jumping to a working implementation directly in this post, when I first did this that was of course not the case.
I found the <code>-d</code> argument useful to see what characters are consumed and what token is output in each step.</p>
<p>Here’s a part of the output (when scanning the final <code>:::</code>), with some comments to point out some interesting things:</p>
<div><pre><code><span>$ </span><span>tree-sitter</span> parse example-file -d
...
process version:0, version_count:1, state:34, row:4, col:0
lex_external state:4, row:4, column:0
  consume character:&#39;:&#39;                         // Scan `:::`
  consume character:&#39;:&#39;
  consume character:&#39;:&#39;
lexed_lookahead sym:_close_paragraph, size:0    // Output _close_paragraph
reduce sym:paragraph_repeat1, child_count:2
shift state:17
process version:0, version_count:1, state:17, row:4, col:0
lex_external state:3, row:4, column:0           // Still on first `:`
  consume character:&#39;:&#39;                         // Scan `:::` again
  consume character:&#39;:&#39;
  consume character:&#39;:&#39;
lexed_lookahead sym:_block_close, size:0        // Close div with _block_close
reduce sym:paragraph, child_count:2
shift state:12
process version:0, version_count:1, state:12, row:4, col:0
lex_external state:5, row:4, column:0           // Still on first `:`
lexed_lookahead sym:_block_close, size:0        // Close second div with _block_close
reduce sym:div, child_count:4
shift state:12
process version:0, version_count:1, state:12, row:4, col:0
lex_external state:5, row:4, column:0           // Still on first `:`
  consume character:&#39;:&#39;                         // Consume `:::`
  consume character:&#39;:&#39;
  consume character:&#39;:&#39;
lexed_lookahead sym:div_marker, size:3          // div_marker is size 3, marks `:::`
shift state:23
</code></pre></div>
<p>While the output seems confusing, when you know what to look for it’s very useful.
I’ve found that a deliberate process, where I look at a single character at a time, helps me get through the problems I’ve encountered so far.</p>
</section>
</section>
<section id="Handling-conflicts">
<h2><a href="#Handling-conflicts">Handling conflicts</a></h2>
<p>Our grammar works pretty well, but there are issues you might want to fix.
One issue, that took much longer to figure out than I care to admit, is adding a fallback to text when a markup rule doesn’t match.</p>
<p>A simple example for our grammar is a single underscore in a paragraph:</p>

<p>I’d assume this would produce a paragraph with text, but instead we get an error:</p>
<div><pre><code><span>$ </span><span>tree-sitter</span> parse example-file
(document [0, 0] - [2, 0]
  (ERROR [0, 0] - [0, 3]))
</code></pre></div>
<p>This is weird, because one of the main selling points of Tree-sitter is the GLR algorithm, which should explore the different interpretations to find something that succeeds.
But for some reason, it doesn’t trigger for us.</p>
<p>Let’s take a look.
These are the relevant lines from the grammar:</p>
<div><pre><code><span><span>_inline</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> repeat<span><span>1</span></span><span><span><span><span>(</span></span></span></span><span><span>choice<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>emphasis</span><span>,</span> $<span>.</span><span>_text</span><span>)</span></span></span><span>)</span></span></span><span>,</span>
<span>emphasis</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>,</span> $<span>.</span><span>_inline</span><span>,</span> <span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span>
<span>_text</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>/</span><span><span>[</span><span>^</span><span>\n</span><span>]</span></span><span>/</span></span></span><span></span><span>,</span>
</span></code></pre></div>
<p>When we try to match a <code>_</code> then the grammar can match either <code>emphasis</code> or <code>_text</code> because <code>_</code> matches both 
<code><span><span><span><span>&#34;</span>_<span>&#34;</span></span></span></span></code> and 
<code><span><span><span><span>/</span><span><span>[</span><span>^</span><span>\n</span><span>]</span></span><span>/</span></span></span><span></span></span></code>.
The issue seems to be that Tree-sitter doesn’t recognize this as a conflict.</p>
<p>If we instead add a fallback with a <code>_</code> string then Tree-sitter will treat it as a conflict:</p>
<div><pre><code><span><span>_inline</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> repeat<span><span>1</span></span><span><span><span><span>(</span></span></span></span><span><span>choice<span><span><span><span>(</span></span></span></span><span><span>$<span>.</span><span>emphasis</span><span>,</span> $<span>.</span><span>_text</span><span>,</span> $<span>.</span><span>_fallback</span><span>)</span></span></span><span>)</span></span></span><span>,</span>
<span>emphasis</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> prec<span>.</span><span><span>left</span></span><span><span><span><span>(</span></span></span></span><span><span>seq<span><span><span><span>(</span></span></span></span><span><span><span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>,</span> $<span>.</span><span>_inline</span><span>,</span> <span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>)</span></span></span><span>)</span></span></span><span>,</span>
<span>_fallback</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> prec<span>.</span><span><span>dynamic</span></span><span><span><span><span>(</span></span></span></span><span><span><span>-</span><span><span>100</span></span><span>,</span> <span><span><span>&#34;</span>_<span>&#34;</span></span></span><span>)</span></span></span><span>,</span>
<span>_text</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>_<span>)</span></span></span> =<span>&gt;</span> <span><span><span>/</span><span><span>[</span><span>^</span><span>\n</span><span>]</span></span><span>/</span></span></span><span></span><span>,</span>
</span></code></pre></div>
<p>And when we call <code>tree-sitter generate</code> we’re made aware of the conflict:</p>
<div><pre><code><span>$ </span><span>tree-sitter</span> generate
Unresolved conflict for symbol sequence:

  &#39;_&#39;  •  &#39;_&#39;  …

Possible interpretations:

  1:  (_fallback  &#39;_&#39;)  •  &#39;_&#39;  …
  2:  (emphasis  &#39;_&#39;  •  _inline  &#39;_&#39;)  (precedence: 0, associativity: Left)

Possible resolutions:

  1:  Specify a higher precedence in `emphasis` than in the other rules.
  2:  Specify a higher precedence in `_fallback` than in the other rules.
  3:  Specify a left or right associativity in `_fallback`
  4:  Add a conflict for these rules: `emphasis`, `_fallback`
</code></pre></div>
<p>What we want to do is mark them as a conflict that’s supposed to exist in the grammar using the <code>conflicts</code> field:</p>
<div><pre><code><span><span>conflicts</span><span>:</span> <span><span><span><span>(</span></span></span></span><span><span>$<span>)</span></span></span> =<span>&gt;</span> <span><span>[</span><span><span>[</span>$<span>.</span><span>emphasis</span><span>,</span> $<span>.</span><span>_fallback</span><span>]</span></span><span>]</span></span><span>,</span>
</span></code></pre></div>
<p>And now we can parse paragraphs containing only a single <code>_</code> without errors.</p>
<p>So it seems like Tree-Sitter doesn’t recognize a conflict between a string and a regex.
Another gotcha is that it doesn’t seem like you can trigger the GLR algorithm with a token returned by an external scanner, because the external scanner overrules Tree-sitter’s lexing behavior.</p>
</section>
<section id="Some-tests">
<h2><a href="#Some-tests">Some tests</a></h2>
<p>Using <code>tree-sitter parse example-file</code> (with or without the <code>-d</code> or <code>-D</code> flags, try them if you haven’t) is fine for experimental tests, but we really should add the different test cases as proper unit tests.
Tree-sitter has a built-in test harness for this purpose.</p>
<p>Let’s add the very first test case to <code>test/corpus/syntax.txt</code>:</p>
<div><pre><code>===============================================================================
Parsing goal
===============================================================================
This is a
multiline _paragraph_

:::
This is a paragraph inside a div
:::

```gleam
let x = 2;
```

-------------------------------------------------------------------------------

(document
  (paragraph (emphasis))
  (div
    (div_marker)
    (paragraph)
    (div_marker))
  (code_block
    (code_block_marker)
    (language)
    (code)
    (code_block_marker)))
</code></pre></div>
<p>And run it:</p>
<div><pre><code>$ tree-sitter test
  syntax:
    ✓ Parsing goal
</code></pre></div>
<p>Yay!</p>
<p>We should add (a lot) more tests here, but I won’t bother writing them out in this already too long blog post.</p>
</section>
<section id="Using-tree-sitter-for-something-useful">
<h2><a href="#Using-tree-sitter-for-something-useful">Using tree-sitter for something useful</a></h2>
<p>I like a theoretical excursion as much as the next nerd, but I started looking at Tree-sitter because I wanted to <em>do</em> something with the Grammar, not just play around with it all day.
Let’s end the post by seeing some things we can use it for.</p>
<section id="Syntax-highlighting">
<h3><a href="#Syntax-highlighting">Syntax highlighting</a></h3>
<p>Syntax highlighting is made using queries from the <code>highlights.scm</code> file.
It’s common to have it placed in the <code>src</code> directory in the same repository as the grammar, but it’s not required.</p>
<p>Here’s an example <code>src/highlights.scm</code> file that highlights the different elements of our markup:</p>
<div><pre><code><span><span><span>(</span>div_marker<span>)</span></span> @punctuation.delimiter
<span><span>(</span>code_block_marker<span>)</span></span> @punctuation.delimiter

<span><span>(</span>emphasis <span><span>&#34;</span>_<span>&#34;</span></span> @punctuation.delimiter<span>)</span></span> @markup.italic
<span><span>(</span>language<span>)</span></span> @tag.attribute

<span><span>(</span>code_block<span>)</span></span> @markup.raw
<span><span>(</span>paragraph<span>)</span></span> @markup
</span></code></pre></div>
<p>What colors to choose is a bit arbitrary, these works well enough I suppose.</p>
<p>See the <a href="https://tree-sitter.github.io/tree-sitter/syntax-highlighting">documentation</a> for more details on how the queries and highlighting works.</p>
</section>
<section id="Language-injection">
<h3><a href="#Language-injection">Language injection</a></h3>
<p>One big question I had when starting writing my grammar was how to mix multiple parsers in the same document, to for example highlight code blocks using the specified language:</p>

<p>Turns out, this is quite straightforward.</p>
<p>With the initial grammar, the code block parses into:</p>
<div><pre><code>(code_block
  (code_block_marker)
  (language)
  (code)
  (code_block_marker)))
</code></pre></div>
<p>Which we’ll use in <code>src/injections.scm</code> to specify that we want to parse <code>(code)</code> using the grammar specified in <code>(language)</code>:</p>
<div><pre><code><span><span><span>(</span>code_block
  <span><span>(</span>language<span>)</span></span> @injection.language
  <span><span>(</span>code<span>)</span></span> @injection.content<span>)</span></span>
</span></code></pre></div>
<p>When we’ll embed the grammar into a program with highlighting support, it will delegate the text inside the code block to the injected language.</p>
</section>
<section id="Using-our-grammar-with-Neovim">
<h3><a href="#Using-our-grammar-with-Neovim">Using our grammar with Neovim</a></h3>
<figure><img alt="" src="https://zachahn.com/images/sdjot_neovim.png"/>
</figure>
<p>I typically install Tree-sitter grammars in Neovim using <code>:TSInstall</code> provided by <a href="https://github.com/nvim-treesitter/nvim-treesitter">nvim-treesitter</a>.
But you can <a href="https://github.com/nvim-treesitter/nvim-treesitter#adding-parsers">install local Tree-sitter grammars</a> as well:</p>
<div><pre><code><span><span>local</span> parser_config <span>=</span> <span>require</span>(<span><span>&#34;</span>nvim-treesitter.parsers<span>&#34;</span></span>).get_parser_configs()
parser_config.sdjot <span>=</span> {
    install_info <span>=</span> {
                url <span>=</span> <span><span>&#34;</span>~/code/tree-sitter-sdjot<span>&#34;</span></span>,
                files <span>=</span> { <span><span>&#34;</span>src/parser.c<span>&#34;</span></span>, <span><span>&#34;</span>src/scanner.c<span>&#34;</span></span> },
        generate_reqires_npm <span>=</span> <span>false</span>,
        requires_generate_from_grammar <span>=</span> <span>false</span>,
    },
        filetype <span>=</span> <span><span>&#34;</span>sdjot<span>&#34;</span></span>,
}
</span></code></pre></div>
<p>Just make sure you have a <code>&#34;tree-sitter&#34;</code> section in the grammar’s <code>package.json</code>:</p>
<div><pre><code><span><span><span>&#34;</span>tree-sitter<span>&#34;</span></span>: <span><span>[</span>
  <span><span>{</span>
    <span><span><span>&#34;</span>scope<span>&#34;</span></span></span><span><span>:</span> <span><span>&#34;</span>source.sdjot<span>&#34;</span></span><span>,</span></span>
    <span><span><span>&#34;</span>file-types<span>&#34;</span></span></span><span><span>:</span> <span><span>[</span>
      <span><span>&#34;</span>sdj<span>&#34;</span></span>
    <span>]</span></span><span>,</span></span>
    <span><span><span>&#34;</span>injection-regex<span>&#34;</span></span></span><span><span>:</span> <span><span>&#34;</span>sdjot<span>&#34;</span></span><span>,</span></span>
    <span><span><span>&#34;</span>highlights<span>&#34;</span></span></span><span><span>:</span> <span><span>[</span>
      <span><span>&#34;</span>queries/highlights.scm<span>&#34;</span></span>
    <span>]</span></span>
  </span><span>}</span></span>
<span>]</span></span>,
</span></code></pre></div>
<p>With this you can do <code>:TSInstall sjdot</code> and <code>:TSUpdate sdjot</code> when you make changes.</p>
<p><code>:TSInstall</code> doesn’t install queries automatically though.
What I did was symlink the queries directory into Neovims config directory:</p>
<div><pre><code><span>ln</span> -s ~/code/tree-sitter-sdjot/queries ~/.config/nvim/queries/sdjot
</code></pre></div>
<p><code>:TSPlaygroundToggle</code> is very useful for debugging the grammar, and <code>:Inspect</code> shows you the highlight groups under your cursor.
It might be good to check out <code>:help treesitter-highlight-groups</code> if you want to play with your theme, as the theme needs to support the highlight groups we use for coloring to appear.</p>
<p>You also need to have the Tree-sitter grammar for the injected language installed, if you want to highlight the contents of code blocks.</p>
</section>
<section id="Jumping-and-selecting-with-textobjects">
<h3><a href="#Jumping-and-selecting-with-textobjects">Jumping and selecting with textobjects</a></h3>
<p>I mentioned <a href="https://github.com/nvim-treesitter/nvim-treesitter-textobjects">nvim-treesitter-textobjects</a> as a good example of why Tree-sitter is about more than syntax highlighting.</p>
<p>To make use of our grammar we can add some capture groups to <code>src/textobjects.scm</code>.
For example we can register our code blocks as “functions”:</p>
<div><pre><code><span><span><span>(</span>code_block <span><span>(</span>code<span>)</span></span> @function.inner<span>)</span></span> @function.outer
</span></code></pre></div>
<p>The objects are arbitrary, but <code>@function</code> is one of the standard objects so I guess it might make sense.</p>
<p>With the symlink ready, you need to register keymaps with <a href="https://github.com/nvim-treesitter/nvim-treesitter-textobjects">nvim-treesitter-textobjects</a> and you’re good to go.
I have it setup so I can jump between <code>@function.outer</code> with <code>[f</code> and <code>]f</code>, and selections with <code>af</code> and <code>if</code>.</p>
<p>This means that with the above textobject definition I can for example jump to the next code block with <code>]f</code> and then remove all the code inside with <code>cif</code> to end up in insert mode, ready to replace it with some new code.</p>
<p>Although this example is a bit arbitrary, this general functionality is <strong><em>extremely</em></strong> useful for programming languages.
For a markup language like <a href="https://djot.net/">Djot</a>, jumping between headings might be a more relevant use-case.</p>
</section>
<section id="Embedding-the-grammar-with-Rust">
<h3><a href="#Embedding-the-grammar-with-Rust">Embedding the grammar with Rust</a></h3>
<p>One of the selling points of Tree-sitter is that you should be able to embed it in any application.
Such as this blog!</p>
<p>I’ve been wanting to add Tree-sitter powered highlighting to my blog for a while, and now I have an excuse to do just that.</p>
<p>This blog is a static site generator written in Rust, and <a href="https://docs.rs/tree-sitter-highlight/latest/tree_sitter_highlight/">tree-sitter-highlight</a> looks like a suitable library to try.
Let’s add it to our <code>Cargo.toml</code>:</p>
<div><pre><code><span><span>[</span><span><span>dependencies</span></span><span>]</span>
<span><span>tree-sitter-highlight</span></span> <span>=</span> <span><span>&#34;</span>^0.20.0<span>&#34;</span></span>
<span><span>tree-sitter-sdjot</span></span> <span>=</span> <span>{</span> <span><span>git</span></span> <span>=</span> <span><span>&#34;</span>https://github.com/treeman/tree-sitter-sdjot.git<span>&#34;</span></span> <span>}</span>
</span></code></pre></div>
<p>I use a slightly older version because some other grammars I want depend on the older version, and it’s a big pain but they all need to use a matching version.
Bleh.</p>
<p><a href="https://docs.rs/tree-sitter-highlight/latest/tree_sitter_highlight/">According to the docs</a> we first need to setup a <code>HighlightConfiguration</code>.
I used <code>lazy_static!</code> to create a global map with configurations to be used by any parallel rendering on the blog.
It’s not the most beautiful code I’ve written, but it gets the job done:</p>
<div><pre><code><span><span>static</span> <span>HIGHLIGHT_NAMES</span><span>:</span> <span>&amp;</span><span><span>[</span><span>&amp;</span><span>str</span><span>]</span></span> <span>=</span> <span>&amp;</span><span><span>[</span>
       <span><span>&#34;</span>markup<span>&#34;</span></span><span>,</span>
   <span><span>&#34;</span>markup.italic<span>&#34;</span></span><span>,</span>
   <span><span>&#34;</span>markup.raw<span>&#34;</span></span><span>,</span>
   <span><span>&#34;</span>punctuation.delimiter<span>&#34;</span></span><span>,</span>
   <span><span>&#34;</span>tag.attribute<span>&#34;</span></span><span>,</span>
<span>]</span></span><span>;</span>

<span>lazy_static!</span> <span><span>{</span>
    <span>static</span> <span>ref</span> <span>CONFIGS</span><span>:</span> <span>HashMap<span>&lt;</span>String, HighlightConfiguration<span>&gt;</span></span> <span>=</span> <span>init_configurations</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span>

<span><span><span>fn</span> </span><span>init_configurations</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>HashMap<span>&lt;</span>String, HighlightConfiguration<span>&gt;</span></span></span> </span><span><span><span>{</span>
    <span><span>[</span>
                <span><span>(</span>
            <span><span>&#34;</span>sdjot<span>&#34;</span></span><span>,</span>
            <span>HighlightConfiguration<span>::</span></span>new<span><span>(</span>
                <span>tree_sitter_sdjot<span>::</span></span>language<span><span>(</span></span><span><span>)</span></span><span>,</span>
                <span>tree_sitter_sdjot<span>::</span></span><span>HIGHLIGHTS_QUERY</span><span>,</span>
                <span>tree_sitter_sdjot<span>::</span></span><span>INJECTIONS_QUERY</span><span>,</span>
                <span><span>&#34;</span><span>&#34;</span></span><span>,</span>
            </span><span><span>)</span></span>
            .<span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
        </span><span><span>)</span></span><span>,</span>
    <span>]</span></span>
    .<span>into_iter</span><span><span>(</span></span><span><span>)</span></span>
    .<span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span><span>(</span></span><span><span>name</span><span>,</span> <span>mut</span> <span>config</span></span><span><span>)</span></span><span>|</span></span> </span><span><span><span>{</span>
        config.<span>configure</span><span><span>(</span><span>&amp;</span><span>HIGHLIGHT_NAMES</span></span><span><span>)</span></span><span>;</span>
        <span><span>(</span>name.<span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>,</span> config</span><span><span>)</span></span>
    </span><span><span>}</span></span></span></span><span><span>)</span></span>
    .<span>collect</span><span><span>(</span></span><span><span>)</span></span>
</span><span><span>}</span></span></span>
</span></code></pre></div>
<p>Notice how all highlight names we’re interested in have to be explicitly specified.
This is a big pain, especially if you’re going to include many larger grammars.</p>
<p>The names can be filtered for with <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> with something like this:</p>
<div><pre><code><span>rg</span> <span>&#34;@[<span>\w</span>.]+&#34;</span> -INo --trim highlights.scm <span>|</span> <span>sort</span> <span>|</span> <span>uniq</span>
</code></pre></div>
<p>I already have syntax highlighting via <a href="https://github.com/trishume/syntect">syntect</a>, so I wrap the highlighters in their own types:</p>
<div><pre><code><span><span><span>enum</span> <span>HighlighterType</span>&lt;&#39;a&gt; <span><span>{</span>
    Syntect<span><span>(</span><span>SyntectHighlighter<span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span><span><span>)</span></span><span>,</span>
    Treesitter<span><span>(</span><span>TreesitterHighlighter<span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span><span><span>)</span></span><span>,</span>
</span><span><span>}</span></span></span>

<span><span>pub</span> <span>struct</span> </span><span><span><span>TreesitterHighlighter</span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span></span><span> </span><span><span><span>{</span>
    <span>config</span><span>:</span> <span>&amp;</span><span>&#39;a</span> HighlightConfiguration,
</span><span><span>}</span></span></span>

<span><span>impl</span></span><span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span><span> <span>TreesitterHighlighter</span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span> </span><span><span><span>{</span>
    <span><span><span>pub</span> <span>fn</span> </span><span>find</span></span><span><span><span>(</span><span>lang_id</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Option<span>&lt;</span><span>Self</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>CONFIGS</span>.<span>get</span><span><span>(</span>lang_id</span><span><span>)</span></span>.<span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>config</span><span>|</span></span> </span><span><span>Self</span> <span><span>{</span> config </span><span><span>}</span></span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre></div>
<p>The interesting part is of course the <code>highlight</code> method, that takes a string of code and applies syntax highlighting on it:</p>
<div><pre><code><span><span><span>impl</span></span><span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span></span><span> <span>TreesitterHighlighter</span><span><span>&lt;</span><span>&#39;a</span><span>&gt;</span></span> </span><span><span><span>{</span>
    <span><span><span>pub</span> <span>fn</span> </span><span>highlight</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>code</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span>String<span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> <span>mut</span> highlighter <span>=</span> <span>Highlighter<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>

        <span>let</span> highlights <span>=</span> highlighter.<span>highlight</span><span><span>(</span><span>self</span>.config<span>,</span> code.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span><span>,</span> <span>None</span><span>,</span> <span><span><span>|</span></span></span><span><span><span>lang</span><span>|</span></span> </span><span><span><span>{</span>
                                    <span>let</span> res <span>=</span> <span>CONFIGS</span>.<span>get</span><span><span>(</span>lang</span><span><span>)</span></span><span>;</span>
            <span>if</span> <span>!</span>res.<span>is_some</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
                <span>warn!</span><span><span>(</span><span><span>&#34;</span>Couldn&#39;t find treesitter grammar for `{lang}` to inject<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
            </span><span><span>}</span></span>
            res
        </span><span><span>}</span></span></span></span><span><span>)</span></span><span>?</span><span>;</span>

        <span>let</span> <span>mut</span> renderer <span>=</span> <span>HtmlRenderer<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>
        renderer.<span>render</span><span><span>(</span>highlights<span>,</span> code.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span><span>,</span> <span>&amp;</span><span>|</span>attr<span>|</span> <span><span>{</span>
                    </span><span><span>}</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
        <span>let</span> res <span>=</span> renderer.<span>lines</span><span><span>(</span></span><span><span>)</span></span>.<span>join</span><span><span>(</span><span><span>&#34;</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
        <span>Ok</span><span><span>(</span>res</span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
</span><span><span>}</span></span></span>
</span></code></pre></div>
<p>I want to point out the API in <code>HtmlRenderer</code>, where we stumble upon a very annoying problem:
what should we return from the callback, and how should we do that?</p>
<p>What the callback does is inject the return value into the <code>span</code> element, like this:</p>
<div><pre><code><span><span><span>&lt;</span><span>span</span> <span>CALLBACK_RESULT</span> <span>&gt;</span></span>highlight<span><span>&lt;/</span><span>span</span><span>&gt;</span></span>
</span></code></pre></div>
<p>So we’d like to return something like 
<code><span><span><span>&#34;</span>class=<span>\&#34;</span>markup italic<span>\&#34;</span><span>&#34;</span></span></span></code>, using <code>attr</code> which is only a <code>usize</code> into <code>HIGHLIGHT_NAMES</code>:</p>
<div><pre><code><span>renderer.<span>render</span><span><span>(</span>highlights<span>,</span> code.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span><span>,</span> <span>&amp;</span><span>|</span>attr<span>|</span> <span><span>{</span>
    <span>format!</span><span><span>(</span></span><span><span><span>r</span><span>#</span>&#34;class=&#34;<span>{}</span>&#34;<span>&#34;#</span></span></span><span><span>,</span> <span>HIGHLIGHT_NAMES</span><span><span>[</span>attr.<span>0</span><span>]</span></span>.<span>replace</span><span><span>(</span><span><span>&#34;</span>.<span>&#34;</span></span><span>,</span> <span><span>&#34;</span> <span>&#34;</span></span></span><span><span>)</span></span><span>)</span></span>.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span>
</span><span><span>}</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre></div>
<p>Because we return a slice of bytes into a string that’s created inside the callback, of course the Rust compiler will be mad at us:</p>
<div><pre><code>error[E0515]: cannot return value referencing temporary value
  --&gt; src/markup/syntax_highlight/treesitter_highlighter.rs:33:13
   |
33 |             format!(r#&#34;class=&#34;{}&#34;&#34;#, HIGHLIGHT_NAMES[attr.0].replace(&#34;.&#34;, &#34; &#34;)).as_bytes()
   |             -------------------------------------------------------------------^^^^^^^^^^^
   |             |
   |             returns a value referencing data owned by the current function
   |             temporary value created here
</code></pre></div>
<p>How to dynamically create a string from inside the callback… That outlives the callback itself?</p>
<p>Not easily I tell you.</p>
<p>It would be so much easier if the callback would return a <code>Cow&lt;str&gt;</code> or something.
I wonder how the designers of the API expects it to be used?
This surely isn’t a very unique requirement, to wrap the attribute in a <code>class</code>?</p>
<p>Oh well.
One way to solve this is to store the generated strings in a container that outlives the callback, and reference that (yeah it’s a <code>Fn</code> callback, but there are hacky ways around that).
Or you could, you know, write your own <code>HtmlRenderer</code>.</p>
<p>Or you could pre-generate the classes and reference them:</p>
<div><pre><code><span><span>lazy_static!</span> <span><span>{</span>
    <span>static</span> <span>ref</span> <span>CLASSES</span><span>:</span> <span>Vec<span>&lt;</span>String<span>&gt;</span></span> <span>=</span> <span>HIGHLIGHT_NAMES</span>
        .<span>iter</span><span><span>(</span></span><span><span>)</span></span>
        .<span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>name</span><span>|</span></span> </span><span><span>format!</span><span><span>(</span></span><span><span><span>r</span><span>#</span>&#34;class=&#34;<span>{}</span>&#34;<span>&#34;#</span></span></span><span><span>,</span> name.<span>replace</span><span><span>(</span><span><span>&#34;</span>.<span>&#34;</span></span><span>,</span> <span><span>&#34;</span> <span>&#34;</span></span></span><span><span>)</span></span><span>)</span></span></span></span><span><span>)</span></span>
        .<span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span>
</span></code></pre></div>
<div><pre><code><span>renderer.<span>render</span><span><span>(</span>highlights<span>,</span> code.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span><span>,</span> <span>&amp;</span><span>|</span>attr<span>|</span> <span><span>{</span>
    <span>CLASSES</span><span><span>[</span>attr.<span>0</span><span>]</span></span>.<span>as_bytes</span><span><span>(</span></span><span><span>)</span></span>
</span><span><span>}</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre></div>
<p>This should be the fastest option and is the one I currently use…
But speed isn’t a bottleneck here and I’d rather just return a <code>String</code> with <code>format!</code> and be done with it.</p>
<hr/>
<p>With this I’ve integrated Tree-sitter based syntax highlighting into my blog!</p>
<div><pre><code><span><span>```</span></span>
<span>With great powers comes great responsibility</span>
<span><span>```</span></span>
</code></pre></div>
<p>I could start moving the various languages over from Syntect to Tree-sitter…
But I won’t.</p>
<p>There are some issues:</p>
<ol type="A">
<li>
<p>You need a compatible version of <code>tree-sitter</code> for all grammars.</p>
<p>The more grammars you add the more painful the upgrade path becomes.</p>
</li>
<li>
<p>Syntect gives better highlighting for some languages (like Rust and C).</p>
<p>Neovim has their own highlighter implementation and has made tweaks to certain grammars and gets much nicer highlighting than I got out of the box.</p>
<p>Integrating that code into my site generator is probably possible, but not a rabbit hole I want to jump into right now.</p>
</li>
<li>
<p>The highlighter library feels a bit immature.</p>
<p>A newer library broke the highlight groups I got from some grammars and I don’t see any support for how to add a language specific class to <code>span</code> for injected languages.</p>
</li>
</ol>
<p>Because of these issues I’ll evaluate what highlighter to use on a case-by-case basis, with Syntect as the default choice.</p>
</section>
</section>
<section id="Within-edge-cases-lies-complexity">
<h2><a href="#Within-edge-cases-lies-complexity">Within edge-cases lies complexity</a></h2>
<p>If you’ve read the post to the end, congratulations.
You made it!</p>
<p>I don’t claim to be an expert at grammars or Tree-sitter, and I’m sure there are plenty of things that can be improved with the way the grammar is made.
But I hope it can be helpful as a starting point if you’re curious on how to write a Tree-sitter grammar of your own.</p>
<p>See the <a href="https://github.com/treeman/tree-sitter-djot">tree-sitter-djot repo</a> for how I developed the grammar further to support the full <a href="https://htmlpreview.github.io/?https://github.com/jgm/djot/blob/master/doc/syntax.html">Djot specification</a> (but remember, I’m not an expert).</p>
<p>Just one word of advice before you go.
Writing a grammar for simple rules is pretty easy, but in the real world things can get messy quickly.
This is especially true if you need to juggle multiple conflicting rules in the external scanner—keeping a sane structure is challenging.</p>
<p>(Even in our simple grammar there are bugs, but I don’t care to fix them.)</p>
<blockquote>
<p>The night is dark and full of terrors
</p>

</blockquote>
</section>
 

  
</article>

    </div></div>
  </body>
</html>
