<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/a-brief-introduction-to-interval-arithmetic/">Original</a>
    <h1>A brief introduction to interval arithmetic</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <date>
                        
                            June 25, 2024
                        </date>
                
                
                
                    <h2>
                        Why x^2 isn&#39;t always x*x.
                    </h2>
                

                

                
                    
                        <p>You&#39;ve got a wall in your apartment and a couch. You measure the wall with a ruler and get 7 feet, then you measure the couch and get 7 feet. Can you fit the couch against that wall?</p>
<p>Maybe. If the two measure is <em>exactly</em> 7 feet than sure, 7 ≤ 7. But you probably didn&#39;t line your measuring stick up perfectly with the couch, and also the stick itself might be a tiny bit long. There&#39;s some uncertainty around the edges, say 1/10th of a foot. </p>
<p>Instead of treating each as exactly 7 feet, we can instead say that each is <em>somewhere</em> between a minimum of 6.9 feet and a maximum of 7.1. We can write this as an <strong>interval</strong> (6.9, 7.1). From there, we can say interval (a, b) is &#34;definitely less than&#34; another interval (c, d) if <code>b &lt; c</code>, ie the first interval ends before the second starts. Since 7.1 !&lt; 6.9, we can&#39;t say for certain that the couch will fit against the wall. Your couch could actually be 7.1 feet and the wall 6.9 feet, or 7.05 and 7.01 feet, anything like that.</p>
<h2>More arithmetic</h2>
<p>When adding/multiplying/subtracting/dividing an interval by a scalar (single number), we just apply the op to both ends. I&#39;ll be using <a href="https://frinklang.org/" target="_blank">frink</a> because it has a built-in interval type.</p>
<div><pre><span></span><code>  i[a, b] := new interval [a, b]
  i[2, 4] + 2
[4, 6]

  i[2, 4] * 2
[4, 8]
</code></pre></div>
<p>Operating on two intervals is more complicated. The general principle is &#34;pick a value from each interval that, when operating, give the minimum value, and do the same for the maximum value&#34;. If you measure two lengths as 3 ± 1 foot, then the length of both of them together must be 6 ± 2 feet. We can get this by just adding the minimums and maximums of the intervals together.</p>

<p>If we measure a rectangle&#39;s length as <code>(5, 7)</code> and it&#39;s width as <code>(3, 4)</code>, what&#39;s the area? Multiplication <em>seems</em> like it&#39;d be the same as addition, just multiply the two minimums and the two maximums together:</p>
<div><pre><span></span><code>  i[5, 7] * i[3, 4]
[15, 28]
</code></pre></div>
<p>But this is breaks down when intervals cover negative numbers. If we just multiplied minimums and maximums, <code>(-3, 3) * (-3, 3)</code> would give us <code>(9, 9)</code>. But we instead get the true minimum by picking -3 from the first interval and 3 from the second, which gives us -9. So the real interval is <code>(-9, 9)</code>.</p>
<p>What about division? It works kinda like multiplication, <em>except</em> if the dividing interval spans 0, the result is undefined. Overall, interval arithmetic is like regular arithmetic except with more headaches.</p>
<h3>Trouble in paradise</h3>
<p>Now, how about <code>(-3, 3)²</code>? On first thought we say <code>(-3, 3)² = (-3, 3)*(-3, 3)</code>, which gives us the same interval <code>(-9, 9)</code>. But again, that&#39;s wrong. In <code>(-3, 3)*(-3, 3)</code>, we pick one number from each interval and multiply them together, while in <code>(-3, 3)^2</code> we pick one number from the interval and multiply it by itself. So the actual interval is <code>(0, 9)</code>. </p>


<p>But wait, doesn&#39;t that mean that <code>x*x != x^2</code>? Yes, it does. Err no, it doesn&#39;t. Maybe. It depends on what we mean by &#34;x&#34;.</p>
<h3>The two interpretations</h3>
<ol>
<li><code>x</code> is some value in the interval <code>(-3, 3)</code>, but we don&#39;t know what it is. Then <code>x*x</code> is the same value both times, so it should be <code>(0, 9)</code>.</li>
<li><code>x</code> is &#34;smeared out&#34; over the <em>entire interval</em>. Then <code>x*x</code> can be treated as two separate intervals, giving us <code>(-9, 9)</code>.</li>
</ol>
<p>Now usually people use intervals to mean [1], but most interval arithmetic systems I&#39;ve seen do [2], or at least a mix of both with a bias towards [2]. </p>
<p>There&#39;s two reasons why. First of all, you can reason about [2] locally. Consider the equation <code>y = sin(x)*cos(x)</code> where x is the interval <code>(0, 2π)</code>.<sup id="fnref:tau"><a href="#fn:tau">1</a></sup> Figuring out <code>y</code> under [2] is easy: it&#39;s just <code>(-1*1, 1*1) = (-1, 1)</code>. But this is impossible under [1], because sin is only ±1 when cos is 0! The actual interval under [1] is <code>(-0.5, 0.5)</code>. </p>
<p>Notice that <code>(-0.5, 0.5)</code> is a subinterval of <code>(-1, 1)</code>. That&#39;s the other reason to assume [2] in calculations: the result will always cover [1]. </p>
<p>Nonetheless [2] leads to lots of weird behavior, like <code>x*x != x^2</code>. This is called <em>overdetermination</em> and leads to <em>overestimation</em>, where your interval bounds are too wide to be that useful to you. Frink tries to be smart about this, and will in some cases rewrite interval arithmetic to avoid overdetermination, even when you <em>want</em> the intervals to be different.</p>

<p>This is all moot if we assign the same value interval to <code>(-3, 3)</code> to different variables, though, because then the interpretations of [1] and [2] don&#39;t have any differences.</p>
<div><pre><span></span><code>  x = i[-3, 3]
  y = i[-3, 3]
  x*y
[-9, 9]
</code></pre></div>
<h2>How this affects you</h2>
<div><pre><span></span><code><span># Python time!</span>
<span>&gt;&gt;&gt;</span> <span>x</span> <span>=</span> <span>0.3</span>
<span>&gt;&gt;&gt;</span> <span>x</span> <span>+</span> <span>0.00000000000000001</span>
<span>0.3</span>
<span>&gt;&gt;&gt;</span> <span>x</span> <span>+</span> <span>0.00000000000000002</span>
<span>0.3</span>
<span>&gt;&gt;&gt;</span> <span>x</span> <span>+</span> <span>0.00000000000000003</span>
<span>0.30000000000000004</span>
</code></pre></div>
<p>If a (double precision) floating point calculation lands in the interval <code>(0.3 - 3e-17, 0.3 + 3e-17)</code>, it&#39;s collapsed to the value <code>0.3</code>. This has lead to some proposals to use interval arithmetic <em>instead of</em> floating point. An interval may be less <em>precise</em> than a single FP number, but it will be more <em>accurate</em>: you won&#39;t have an exact number but you&#39;ll know that the correct number is somewhere in the bounds. While a bunch of FP computations will always give you an exact number, but it could be very far from the actual answer. </p>
<p>These proposals have been around as long as floating point. The father of the IEEE-754 standard, <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html" target="_blank">William Kahan</a>, <a href="https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf" target="_blank">wrote an essay</a> about why interval arithmetic can&#39;t replace FP. His argument comes back to overestimation: in most computations, interval boundaries grow too big to be useful. </p>
<p>He wrote that back in 2006. Since then, there&#39;s been one big new interval arithmetic proposal: John Gutafson&#39;s <a href="https://en.wikipedia.org/wiki/Unum_(number_format)" target="_blank">universal numbers</a>. I <em>think</em> his <a href="http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf" target="_blank">posit version</a> isn&#39;t intervals but I&#39;m not sure? This is well outside of the my area of expertise. I can tell, though, that Gustafson and Kahan <a href="http://www.johngustafson.net/pdfs/DebateTranscription.pdf" target="_blank">hate each other</a>.</p>
<p>That&#39;s the main connection between intervals and computer science. Of course, there are also particular domains where intervals are really important, such as in manufacturing tolerances.</p>
<hr/>

<p>14k words! Writing a bunch of exercises and examples this week.</p>

                    
                

                
                    <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.email/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
                

            </div></div>
  </body>
</html>
