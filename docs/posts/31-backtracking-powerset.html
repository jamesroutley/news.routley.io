<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/31%29-Backtracking---Powerset">Original</a>
    <h1>31) Backtracking - Powerset</h1>
    
    <div id="readability-page-1" class="page"><article><p>Problem: <a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>I have never done backtracking problems before and don’t really have the patience to try to come to the conclusions of those algorithms on my own at the moment, so I’ll just study what backtracking is by finding the answer to this problem and understanding what sort of techniques it employs, as dishonorable as that may be.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> subsets</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span>[][] {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> result</span><span>:</span><span> number</span><span>[][] </span><span>=</span><span> []</span></span>
<span data-line=""> </span>
<span data-line=""><span>    function</span><span> backtrack</span><span>(</span><span>start</span><span>:</span><span> number</span><span>, </span><span>current</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> void</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>        result.</span><span>push</span><span>([</span><span>...</span><span>current])</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> start; i </span><span>&lt;</span><span> nums.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>            current.</span><span>push</span><span>(nums[i])</span></span>
<span data-line=""><span>            backtrack</span><span>(i </span><span>+</span><span> 1</span><span>, current)</span></span>
<span data-line=""><span>            current.</span><span>pop</span><span>()</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""> </span>
<span data-line=""><span>    backtrack</span><span>(</span><span>0</span><span>, [])</span></span>
<span data-line=""><span>    return</span><span> result</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Phew. Okay. Xin Rui Li helped walk me through this, quite painfully, on a whiteboard. It took me a while, but I finally got it. It was sort of a combination of two groks.</p>
<p>The first is this:
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/dacf8357d097805db7e7cde250e0e4fc.jpeg" alt="image"/></p>
<p>This is me realizing the path that <code>current</code> follows. If you look at the code, you can see that <code>current</code> is only initialized once. Various snapshots of it are saved to <code>results</code>, and these are all those snapshots. We start at that first one <code>[]</code>, and go from there. We start down this first leg of our journey.</p>
<p>Where you see <code>x</code>’s are where we’ve gotten to a place where <code>i &lt; 3</code> is no longer true so we stop going down that path. To be honest, I didn’t get all the <code>x</code>’s right, but I think they still illustrate the overall flow of the mutations of <code>current</code> and the places it has to “turn back”. It turns out this is a very difficult concept to illustrate, but Xin did a really good job of being patient and taking me through it.</p>
<p>I sort of understand how this made sense. It very much resembled <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/7)-Depth-First-Search" data-slug="devnotes/LeetCode-Journal/7)-Depth-First-Search">DFS</a>. But Xin pointed out it was really different in what it works with -</p>
<p>DFS uses a single node that is guaranteed to have either 1 or 2 branches. In this backtracking problem, we start with n number of nodes, and each of them has n paths to explore.</p>
<p>So instead of running two potential recursive functions like we could in a binary tree, we <em>instead</em> create this sort of flywheel of a for loop that spins up as many recursive functions as it needs to.</p>
<p>I think I may have skipped ahead in leetcode a bit though, because this felt like a really big jump to make. Not only are the paths dynamic, but they <em>also</em> are non-repeating. The backtracking part, which takes place in the very short line <code>current.pop()</code>.</p>
<p>I understood this was supposed to point us backward somehow, but didn’t really understand how. In order to really feel this, or trust it, I needed to go from this line to the next place that <code>current</code>, which has now been modified to have one less element on the end because of pop, is used.</p>
<p>Which is, of course, the top of our for loop! We go back to the for-loop, and this is where we might push <code>3</code> if we had just popped off <code>2</code>.</p>
<p>The <code>backtrack</code> instantiation we call before the <code>pop</code> function saves the <code>[1,2,3]</code> result for us. Then we proceed to pop off the <code>2</code> and see what happens if we keep going through the loop. It turns out that the next thing we get is <code>[1, 3</code>. Perfect!</p>
<p>In the end, I visualized this best with my body. It’s like I’m in the woods, and there’s a fork in the road. I take the right path to see what’s up there. Cool. I snap a pic maybe, and make a mental note. Then I go back to the fork. I see what’s on the other one. I get to explore each one this way by walking <em>back</em> to the fork.</p>
<p>At the same time, it is of course not like this at all - that’s a bit more like doing DFS on a binary tree.</p>
<p>But it doesn’t illustrate that visceral feeling of <em>going back</em> to try something else, and to do that you need to <code>pop</code> off the leg of the fork you just walked.</p>
<p>AH. This hurt a lot to learn. But! After a couple of hours of really studying it, I feel good about it. I was able to rewrite it from (shallow) memory in <code>2:22</code>:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> subsets</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span>[][] {</span></span>
<span data-line=""><span>    const</span><span> result</span><span>:</span><span> number</span><span>[][] </span><span>=</span><span> []</span></span>
<span data-line=""> </span>
<span data-line=""><span>    function</span><span> backtrack</span><span>(</span><span>start</span><span>:</span><span> number</span><span>, </span><span>current</span><span>:</span><span> number</span><span>[]){</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        result.</span><span>push</span><span>([</span><span>...</span><span>current])</span></span>
<span data-line=""> </span>
<span data-line=""><span>        for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> start; i </span><span>&lt;</span><span> nums.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>            current.</span><span>push</span><span>(nums[i])</span></span>
<span data-line=""><span>            backtrack</span><span>(i</span><span>+</span><span>1</span><span>, current)</span></span>
<span data-line=""><span>            current.</span><span>pop</span><span>()</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    backtrack</span><span>(</span><span>0</span><span>, [])</span></span>
<span data-line=""><span>    return</span><span> result</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>I think I need to return to BFS and DFS and trees to grok those spaces a bit better - clearly backtracking was super foreign. A good metaphor is skipping a few steps on a staircase and needing to leap, but falling slightly times before making it.</p></article></div>
  </body>
</html>
