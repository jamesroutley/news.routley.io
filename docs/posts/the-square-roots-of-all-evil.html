<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neilmadden.blog/2024/12/03/the-square-roots-of-all-evil/">Original</a>
    <h1>The square roots of all evil</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Every programmer knows Donald Knuth’s famous quote that “<em>premature optimization is the root of all evil</em>”, from his <a href="https://dl.acm.org/doi/pdf/10.1145/1283920.1283929?download=true">1974 Turing Award lecture (pdf)</a>. A fuller quotation of the surrounding context gives a rounder view:</p>



<blockquote>
<p>I am sorry to say that many people nowadays are condemning program efficiency, telling us that it is in bad taste. The reason for this is that we are now experiencing a reaction from the time when efficiency was the only reputable criterion of goodness, and programmers in the past have tended to be so preoccupied with efficiency that they have produced needlessly complicated code; the result of this unnecessary complexity has been that net efficiency has gone down, due to difficulties of debugging and maintenance. </p>



<p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming. </p>
</blockquote>



<p>A lot has been written about this topic and exactly what constitutes “premature” optimisation. I don’t want to rehash those debates, but instead to rephrase them. It is not premature <em>optimisation</em> as such that the root of all evil, but rather <em>premature specialisation</em>. </p>



<p>Optimisation almost always involves making some assumptions about the context in which a program will run. At a micro level, concerns about CPU architecture, memory hierarchy, caches, what features have hardware acceleration, etc. At a macro level, even choice of big-O algorithm may require assumptions to be made about data: e.g., these data points are all integers in a certain range so I can sort them in linear time: but will that always be true? Maybe I need to dynamically pick which code to use based on what environment I’m running in, so that I can run the most efficient code for that CPU/etc. These assumptions all lead to special-case code, tailored to that context. It is that specialisation that leads to complexity and inflexibility, rather than optimisation per se. </p>



<p>Programming is frequently a<a href="https://www.tumblr.com/accidentallyquadratic">ccidentally quadratic,</a> and we were all taught in school that quadratic equations can have two roots. So it is with evil in programming, and I would like to propose that there is another root of all evil that deserves to be called out: <em>premature generalisation</em>. </p>



<p>Premature generalisation is the flip side of premature specialisation, but can be just as dangerous to the health of a codebase. We have all laughed at <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition">Enterprise FizzBuzz</a> jokes, with their FactoryBuilderFactoryStrategies and so on. And I’m sure many of us have seen codebases affected by such monstrosities, where an “enterprise architect” applied a Pokémon “gotta catch ‘em all” approach to Martin Fowler’s blog. But this is just an extreme (although sadly common) example. </p>



<p>Examples of premature generalisation are everywhere. As a security and cryptography engineer, I see the same mindset in tools like PGP or JWTs (JOSE): overly-complex and easy to screw up footguns because they try to cover too many use-cases in a single tool. The reaction has been the development of special-purpose tools like A<a href="https://age-encryption.org/">ge </a>or <a href="https://jedisct1.github.io/minisign/">minisign</a>, that follow the Unix philosophy of “do one thing well”. </p>



<p>On a perhaps more controversial level, I would also point to the (over-)use of category theory as an example of premature generalisation. Sure, maybe your widget <em>could </em>be a Monad, but does that actually solve a concrete problem you have right now? Might you want to change the implementation in future in ways that make it harder to maintain the Monad contract?</p>



<p>When I was a PhD student, I was interested in logical approaches to AI. The big deal at the time was the semantic web and description logics. As part of my work I was developing an ontology of events in online games to describe what was going on in those environments. I found myself endlessly wanting to generalise and unify concepts as much as possible. I wasted a lot of time trying to develop a perfect “upper level ontology” as these things were called then. Eventually my adviser gently nudged me to <em>solve the problem I have in front of me</em>. </p>



<p>That is probably the biggest lesson I have learned in programming, and the only way I know to try to walk the fine line between premature specialisation and premature generalisation. Solve the problem in front of you. Don’t try and solve a more general version of the problem, and don’t try and “optimise” until you are fairly sure something is going to be a performance issue. </p>



<p>This is not to say you should just live in the moment and write code with no thought at all beyond that specific problem. If you are writing code to handle a FooWidget and you know there are 200 other types of widget you’re going to have to code up later, it’s not premature to think about how those might share functionality. If you are designing a programming language or database, it is not premature to make it very general (and please do take a look at category theory and other unifying frameworks). If you know you’ll have to process millions of FooWidgets per hour then it’s not premature to think about efficiency. And likewise, if it’s extremely unlikely that you’re ever going to move off PostgreSQL as your database then it is not unreasonable to use database-specific features if it makes other code simpler. </p>



<p>There’s a lot more that could be said on this topic, including trade-offs between individual tool/component complexity vs whole-system/ecosystem complexity, and accidental vs necessary complexity. But then I’d be making this article more complex. Better to leave that for other articles and leave this one <em>just right</em>. </p>



<figure><img data-attachment-id="3976" data-permalink="https://neilmadden.blog/img_4192-1/" data-orig-file="https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg" data-orig-size="1024,690" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="img_4192-1" data-image-description="" data-image-caption="" data-medium-file="https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=300" data-large-file="https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=1024" width="1024" height="690" src="https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=1024" alt="" srcset="https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg 1024w, https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=150 150w, https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=300 300w, https://neilmadden.blog/wp-content/uploads/2024/12/img_4192-1.jpg?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Goldilocks runs from the bears of premature generalisation and specialisation</figcaption></figure>
</div></div>
  </body>
</html>
