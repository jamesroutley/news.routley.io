<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cofault.com/2025/02/long-story-of-division.html">Original</a>
    <h1>Long division verified via Hoare logic</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3504612436864435404" itemprop="description articleBody">


<div>
  <p>The following text can be viewed as extremely dry and intimidating, or, equally, lightheadedly funny.</p>
  <p>Let&#39;s formally verify the venerable long-division algorithm.</p>
<div><pre>uintN_t div(uintN_t n, uintN_t d) {
        uintN_t q := 0;
        uintN_t r := 0;
        int     i := N - 1;
        while (i != -1) {
                r &lt;&lt;= 1;
                r |= ((n &gt;&gt; i) &amp; 1);
                if (r &gt;= d) {
                        r := r - d;
                        q |= 1 &lt;&lt; i;
                }
                i := i - 1;
        }
        return q;
}</pre></div>
  
  <p>Here <code>uintN_t</code> is the type of unsigned <code>N</code>-bit integers, <code>N &gt; 0</code>.
  
  We shall establish formal correctness via <a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>. The following is by no means an introduction to the subject, our presentation skims over a large number of important details, please refer to the literature cited on the Wikipedia page. The basic element of Hoare logic is a <em>Hoare triple</em>, which is a construction of the form</p>
  
  <div><pre><b>⟦</b>  <span>precondition</span>  <b>⟧</b>
COMMAND
<b>⟦</b> <span>postcondition</span>  <b>⟧</b></pre></div>
  <p>This triple means that if an execution of <code>COMMAND</code> starts in a state satisfying <code>precondition</code>, then the execution can only terminate in a state satisfying <code>postcondition</code>. (We use <b>⟦</b> and <b>⟧</b> instead of more traditional { and }, because our ambient language uses braces.) The pre- and postconditions are formulae of predicate calculus that can refer to the terms of the programming language (variables, literals, <i>etc</i>.). A triple is valid, if it can be proved starting from the usual rules of the predicate calculus and certain axioms. For a given programming language, one presents a list of axioms, describing the behaviour of the language constructs, and then proves <em><a href="https://en.wikipedia.org/wiki/Soundness">soundness</a></em>, <i>i.e.</i>, establishes that the axioms and the accepted rules of inference are satisfied by all possible computations. We will need the following axioms:</p>
    
  <h2>Axiom of assignment</h2>
  
<div><pre><b>⟦</b>  <span>S[ x := E ]</span>  <b>⟧</b>
x := E
<b>⟦</b>  <span>S</span>  <b>⟧</b></pre></div>
  <p>Here <code>S[ x:= E ]</code> is the result of substituting <code>E</code> for each occurrence of <code>x</code> in the formula <code>S</code>. (In this form the axiom really only works for simple unaliased variables and does not work for pointers or arrays, which is sufficient in our case.) The axiom looks &#34;backward&#34;, so let&#39;s play with it a bit. First, check that the assignment does set the variable to the desired value:</p>
  
<div><pre><b>⟦</b>  <span>?</span>  <b>⟧</b>
x := 4
<b>⟦</b>  <span>x == 4</span>  <b>⟧</b></pre></div>
<p>The command is a simple assignment <code>x := 4</code>, the postcondition, <code>x == 4</code>, verifies that the variable got the expected value. What precondition guarantees that the assignment establishes the postcondition? The assignment axiom gives us for the precondition <code>(x == 4)[ x := 4 ] = (4 == 4) = true</code>. That is, no matter what was going on before the assignment, after it terminates, <code>x == 4</code>, as expected:</p>
  <div><pre><b>⟦</b>  <span>true</span>  <b>⟧</b>
x := 4
<b>⟦</b>  <span>x == 4</span>  <b>⟧</b></pre></div>
  <p>A bit more complex example:</p>
<div><pre><b>⟦</b>  <span>?</span>  <b>⟧</b>
x := x + 1
<b>⟦</b>  <span>x &gt; 0</span>  <b>⟧</b></pre></div>
  <p>What precondition guarantees that <code>x</code> will be positive after increment? We can compute the precondition, it is <code>(x &gt; 0)[ x := x + 1 ] = (x + 1 &gt; 0) = (x &gt; -1)</code> — perfectly reasonable.</p>
  <p>What if we are given a precondition does not have the form that the axiom requires?</p>  
<div><pre><b>⟦</b>  <span>x == A</span>  <b>⟧</b>
x := x + d
<b>⟦</b>  <span>?</span>  <b>⟧</b></pre></div><p>
There is no postcondition <code>S</code>, such that <code>(x == A) = S[ x := x + d ]</code></p><p>Well, in this case you are stuck. To derive a postcondition using the axiom of assignment, you first have to massage the precondition in a form, where <code>x</code> only happens as part of <code>E</code>. Fortunately in this case it&#39;s easy:
  
</p><div><pre>/* Comments as in PL/I. */
<b>⟦</b>  <span>x == A</span>  <b>⟧</b>
/* Simple arithmetics: add d to both sides. */
<b>⟦</b>  <span>x + d == A + d</span>  <b>⟧</b>
x := x + d
<b>⟦</b>  <span>x == A + d</span>  <b>⟧</b></pre></div>
  <p>What if the precondition does not contain <code>x</code>? Then the assignment is useless for program correctness, and, hence, can be most likely discarded. :-)</p>
  <p>Typically, when you use the assignment axiom for a formal verification, you have to come up with a precondition, that has one or more instances of <code>E</code> and then the axiom let&#39;s you to jump to a postcondition where each <code>E</code> is simplified to <code>x</code>.
    
Next is
  </p><h2>Axiom of composition</h2>
  <p>This axiom describes the <code>;</code>-sequencing operator.</p>
  <p>If we have
  </p><div><pre><b>⟦</b>  <span>precondition</span>  <b>⟧</b>
COMMAND0
<b>⟦</b>  <span>condition</span>  <b>⟧</b></pre></div>
  <p>and</p>
  <div><pre><b>⟦</b>  <span>condition</span>  <b>⟧</b>
COMMAND1
<b>⟦</b>  <span>postcondition</span>  <b>⟧</b></pre></div>
  <p>Then the axiom allows us to conclude</p>
  <div><pre><b>⟦</b>  <span>precondition</span>  <b>⟧</b>
COMMAND0 ; COMMAND1
<b>⟦</b>  <span>postcondition</span>  <b>⟧</b></pre></div>
  <p>This matches the expected semantics of sequential execution.</p>
  <h2>Conditional axiom</h2>
  <p>For a conditional statement of a form</p>
<div><pre>if (guard) { 
        COMMAND0 
} else {
        COMMAND1 
}</pre></div>
  
  <p>We have</p>
 <div><pre><b>⟦</b>  <span>precondition</span>  <b>⟧</b>
if (guard) {
        <b>⟦</b>  <span>guard &amp;&amp; precondition</span>  <b>⟧</b>
        COMMAND0;
        <b>⟦</b>  <span>postcondition</span>  <b>⟧</b>
} else {
        <b>⟦</b>  <span>!guard &amp;&amp; precondition</span>  <b>⟧</b>
        COMMAND0;
        <b>⟦</b>  <span>postcondition</span>  <b>⟧</b>
}
<b>⟦</b>  <span>postcondition</span>  <b>⟧</b></pre></div>
  <p>That is, if both &#34;then&#34; and &#34;else&#34; commands establish the same postcondition, given the original precondition strengthened by the guard or its negation, then the entire conditional statement establishes the same postcondition. This is fairly intuitively obvious.</p>

<p>Finally, we need</p>
<h2>While-loop axiom</h2>
  <p>Consider a loop</p>

  
<p>To apply the while-loop axiom, we have to find an assertion, called <em>a loop invariant</em> that is preserved by the loop body, that is such that</p><div><pre><b>⟦</b>  <span>guard &amp;&amp; invariant</span>  <b>⟧</b>
BODY
<b>⟦</b>  <span>invariant</span>  <b>⟧</b></pre></div>
<p>If the body is entered, while the invariant holds (and the guard holds too), then the invariant is true at the end of the body execution. Given an invariant, the while-loop axiom gives
</p><div><pre><b>⟦</b>  <span>invariant</span>  <b>⟧</b>
while (guard) {
        BODY
}
<b>⟦</b>  <span>!guard &amp;&amp; invariant</span>  <b>⟧</b>
</pre></div>

<p>In other words, if the invariant was true at the beginning of the loop execution, then it is true when the loop terminates. The while-loop axiom shows to an observant reader that loops are pure magic: it is the only construction that starts in a state satisfying a known condition, given by the invariant, and then miraculously strengthens that condition by adding <code>!guard</code> conjunct. Perhaps due to this the founders of structured programming preferred while-loops to the much-derided loops with &#34;a control variable&#34;, like <code>DO</code> loops in FORTRAN and for-each loops of the modern languages.</p>
  
<p>There are many more axioms (what about the rules for function calls and recursion?), but we won&#39;t need them or will hand-wave around them.</p>
  
  
  <hr/>
  


<p>Now, back to the long division. We want to establish the validity of the following triple:</p>

<div><pre>uintN_t div(uintN_t n, uintN_t d) {
        <b>⟦</b>  <span>d &gt; 0</span>  <b>⟧</b>
        uintN_t q := 0;
        uintN_t r := 0;
        int     i := N - 1;
        while (i != -1) {
                r &lt;&lt;= 1;
                r |= ((n &gt;&gt; i) &amp; 1);
                if (r &gt;= d) {
                        r := r - d;
                        q |= 1 &lt;&lt; i;
                }
                i := i - 1;
        }
        <b>⟦</b>  <span>n == d*q + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d</span>  <b>⟧</b>
        return q;
}</pre></div>
  
  <p>The structure of the code basically forces the structure of any possible proof:</p>
  <ul>
    <li>Find an invariant, preserved by the loop body.</li>
    <li>Prove that the invariant is established before the loop is entered.</li>
    <li>Prove that the desired postcondition follows from the conjunction of the invariant and the negation of the guard.</li>
  </ul>
  <p>Finding a suitable invariant is the most non-trivial part of the job. Fortunately, in this case we are helped by our (presumed) experience of manually executing this algorithm all too many times at the elementary school. To make it less boring, I give an example of how long division is done in my native country, you should be able to figure it out:</p>

 	<center><img src="https://raw.githubusercontent.com/nikitadanilov/nikitadanilov.github.io/refs/heads/master/div/log-div.jpg"/></center>

<p>After the first step (when the subtraction under the first horizontal line on the left has been completed), the algorithm established that <code>273 == 97*2 + 79</code>, where by construction <code>79 &lt; 97</code>, which looks promisingly similar to the form of the postcondition that we want to establish: <code>n == d*q + r &amp;&amp; r &lt; d</code>. It then makes sense to select as the invariant &#34;the highest <code>N - i - 1</code> digits of dividend (<it>i.e.</it>, <code>n</code>), divided by the divisor (<it>i.e.</it>, <code>d</code>), have the highest <code>N - i - 1</code> digits of <code>q</code> as the quotient and <code>r</code> at the remainder&#34; (in our binary case the digits are bits).</p>
  
<p>Provided that we manage to establish that this is actually an invariant, the other remaining pieces fall in place quickly:</p>
  <ul>
    <li>At the beginning of the loop, <code>i == N - 1</code> so &#34;the highest <code>N - i - 1</code> bits&#34; degenerate into &#34;the highest 0 bits&#34;, for which the condition is vacuous.</li>
    <li>Similarly at the termination of the loop we have <code>i == -1</code>, so <code>N - i - 1 == N</code> and we have the desired postcondition.</li>
  </ul>
  
  <p>But before we embark on the actual proof, we have to introduce some terminology, to simplify the necessary formal manipulations.</p>
  <p>We are operating on <code>N</code>-bit unsigned binary numbers. We shall refer to the more and less significant bits as &#34;left&#34; or &#34;last&#34; or &#34;high&#34; and &#34;right&#34; or &#34;first&#34; or &#34;low&#34; respectively, with the appropriate comparative and superlative forms and without, of course, making any assumptions about endianness. Bits are indexed  <code>0 ... N - 1</code> from right to left (Thank you, Fibonacci, very clever! Not.).</p>
  <p>We will do a lot of bit-shifting. Recall that for <code>t &gt;= 0</code>, <code>x &gt;&gt; t == floor(x/2^t)</code> and <code>x &lt;&lt; t == x*2^t</code>. Again, all values are unsigned, and so are shifts. Bitwise <code>OR</code> and <code>AND</code> are denoted as <code>|</code> and <code>&amp;</code> as in C.</p>
  <p>On a loop iteration with a particular value of <code>i</code>, we will be especially interested in shifts by <code>i</code> and <code>i + 1</code> bits. Write</p>
  <ul>
    <li><code>B&#39; = (1 &lt;&lt; i)</code> for the <code>i</code>-th bit bitmask.</li>
    <li><code>B&#34; = (1 &lt;&lt; (i + 1))</code> for the <code>(i + 1)</code>-st bit bitmask.</li>
    <li><code>t&#39; = (t &gt;&gt; i)</code>, for the value <code>t</code> shifted <code>i</code> bits right.</li>
    <li><code>t&#34; = (t &gt;&gt; (i + 1))</code>, for the value <code>t</code> shifted <code>i + 1</code> bits right.</li>
    <li><code>M(k) = (1 &lt;&lt; k) - 1</code>, for the bitmask of the first <code>k</code> bits.</li>
  </ul>
  <p>We treat <code>&#39;</code> and <code>&#34;</code> as <a href="https://en.wikipedia.org/wiki/Arity#:~:text=the%20term%20%22singulary%22%20is%20the%20correct%20adjective%2C%20rather%20than%20%22unary%22">singular</a> operators, binding tighter than any binary ones.</p>
  <p>As a warm-up, prove the following</p>
  <p><b>LEMMA</b> <code>x&#39; == 2*x&#34; + x&#39;&amp;1</code></p>
  <p>(Once you rewrite <code>2*x&#34;</code> as <code>(x &gt;&gt; (i + 1)) &lt;&lt; 1</code>, it should be trivial.)</p>
  
  
  <hr/>
  

  <p>&#34;The highest <code>N - i - 1</code> bits&#34; of <code>x</code> mentioned in the informal invariant above can be obtained by discarding the remaining <code>N - (N - i - 1) == i + 1</code> bits, and so are <code>x &gt;&gt; (i + 1)</code>, or, as we luckily agreed, <code>x&#34;</code>. It makes sense to try <code>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r</code> as the invariant. This assertion is established at the loop entrance and guarantees the final postcondition after the loop termination. Unfortunately, it is *not* an invariant of our loop. To conclude this, observe that this assertion holds at the loop entrance even if the initial value of <code>q</code> is not <code>0</code>. If it were an invariant, then initialising <code>q</code> to an arbitrary value would still produce a correct result, which is clearly not the case, because bits of <code>q</code> are only set (by <code>q |= 1 &lt;&lt; i</code>) and never cleared, so in the final value of <code>q</code> all the bits set initially remain set.</p>
  <p>As it turns out (after many a painful attempt), this is the only obstruction and once we add to the invariant a conjunct <code>q&amp;M(i + 1) == 0</code> stating that <code>i + 1</code> lowest bits of <code>q</code> are 0, we obtain the desired invariant:</p>
  <p><b>LOOP INVARIANT</b> <code>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</code></p>
  <p>(If you want a good laugh and have some time to spare, paste <code>div()</code> code in a <a href="https://chatgpt.com/">ChatGPT</a> chat and ask various models what the loop invariant is.)</p>
  <p>To the proof then. First, check that the invariant is established at the loop entrance that is, that the following triple is valid.</p>
<div><pre><b>⟦</b>  <span>d &gt; 0</span>  <b>⟧</b>
uintN_t q := 0;
uintN_t r := 0;
int     i := N - 1;
<b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Go from bottom to top, applying the assignment axiom and simplifying on each step. First, expand the invariant as</p>
  <div><pre><b>⟦</b>  <span>n &gt;&gt; (i + 1) == d*(q &gt;&gt; (i + 1)) + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;((1 &lt;&lt; (i + 1)) - 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Now apply the assignment axiom (<i>i.e.</i>, replace <code>i</code> with <code>(N - 1)</code>)...</p>
  <div><pre><b>⟦</b>  <span>n &gt;&gt; ((N - 1) + 1) == d*(q &gt;&gt; ((N - 1) + 1)) + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;((1 &lt;&lt; ((N - 1) + 1)) - 1) == 0</span>  <b>⟧</b>
i := N - 1;
<b>⟦</b>  <span>n &gt;&gt; (i + 1) == d*(q &gt;&gt; (i + 1)) + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;((1 &lt;&lt; (i + 1)) - 1) == 0</span>  <b>⟧</b></pre></div>
  <p>... simplify, use <code>x &gt;&gt; N == 0</code> for any <code>N</code>-bit value, and apply the assignment axiom again ... </p>
  <div><pre><b>⟦</b>  <span>0 == d*0 + 0 &amp;&amp; 0 &lt; d &amp;&amp; 0 &lt;= 0 &amp;&amp; (q &amp; ~0) == 0</span>  <b>⟧</b>
r := 0
<b>⟦</b>  <span>0 == d*0 + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; (q &amp; ~0) == 0</span>  <b>⟧</b></pre></div>
<p> ... and one more time ... </p>
  
<div><pre><b>⟦</b>  <span>0 == 0 &amp;&amp; 0 &lt; d &amp;&amp; (0 &amp; ~0) == 0</span>  <b>⟧</b>
q := 0
<b>⟦</b>  <span>0 == d*0 + 0 &amp;&amp; 0 &lt; d &amp;&amp; 0 &lt;= 0 &amp;&amp; (q &amp; ~0) == 0</span>  <b>⟧</b></pre></div>
  <p> ... which finally gives</p>

  <p>Which is exactly the given precondition. <i>Voilà!</i> Interestingly, it seems division by zero is impossible, because there is no suitable remainder.</p>

  
  <hr/>
  

<p>Next, we need to prove that the invariant is preserved by the loop body. This is by far the most complex and inundating part of the proof. We want to establish the following triple (at this point let&#39;s expand the compound assignment operators and add a trivial <code>else</code> to the conditional so that it conforms to the form expected by our conditional axiom):</p>

<div><pre><b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; i != -1</span>  <b>⟧</b>
r := r &lt;&lt; 1;
r := r | ((n &gt;&gt; i) &amp; 1);
if (r &gt;= d) {
        r := r - d;
        q := q | (1 &lt;&lt; i);
} else {
}
i := i - 1;
<b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>First, the guard <code>i != -1</code> is only needed to guarantee that shifts by <code>i</code> and <code>i + 1</code> bits make sense. It is not used for anything else and will not be mentioned again.</p>
  <p>We can proceed as before: start at the bottom and apply the assignment axiom to work our way up:</p>
  
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  <b>⟧</b>
i := i - 1;
<b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Note that after substituting <code>i - 1</code> for <code>i</code>, <code>x&#34;</code> nicely transforms into <code>x&#39;</code>. But at this point we are stuck: we know the postcondition that the conditional operator must establish, but we have no idea what <em>its</em> suitable precondition is. Take a step back. We now have <code>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</code>, that we will call the <em>target</em>. The composition of two assignments and one conditional operator, starting from the loop invariant must establish the target. Write it down:</p>
   <p><b>LOOP INVARIANT</b> <code>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</code></p>
   <p><b>TARGET</b> <code>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</code></p>
    <p>Comparing the loop invariant and the target, we see that transforming the former into the latter takes:</p>
   <ul>	
     <li>Replacing <code>q&#34;</code> with <code>q&#39;</code>.</li>
     <li>Replacing <code>n&#34;</code> with <code>n&#39;</code>.</li>
     <li>Replacing <code>q&amp;M(i + 1) == 0</code> with <code>q&amp;M(i) == 0</code>.</li>
  </ul>
  <p>The last one is easy: if the first <code>i + 1</code> bits of <code>q</code> are zero (this is what <code>q&amp;M(i + 1) == 0</code> means), then <i>a fortiori</i> so are its <code>i</code> first bits, so <code>q&amp;M(i) == 0</code>.</p>
  <p>As for replacing <code>q&#34;</code> with <code>q&#39;</code> and <code>n&#34;</code> with <code>n&#39;</code>, we will do this via the lemma we stated (and you proved) earlier. We will now apply transformations to the loop invariant such that: (i) it will make it possible to apply the lemma and (ii) it will produce the result that will be a suitable precondition for the following assignments. The right-hand sides of the assignments are <code>r &lt;&lt;= 1</code> (that is <code>2*r</code>) and <code>r | ((n &gt;&gt; i) &amp; 1)</code> (that is <code>r | (n&#39;&amp;1)</code>), so we will try to produce an assertion having sub-formulae of this form.</p>
  <p>The starting invariant again:</p>
<div><pre><b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Multiply both sides of all conjuncts by <code>2</code>. This produces terms such that the lemma and the assignment axiom for <code>r := 2*r</code> can be applied.</p>
<div><pre><b>⟦</b>  <span>2*n&#34; == 2*d*q&#34; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Immediately we can apply the lemma: <code>2*q&#34; == q&#39; - q&#39;&amp;1</code>.</p>
<div><pre><b>⟦</b>  <span>2*n&#34; == d*(q&#39; - q&#39;&amp;1) + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p> <code>q&amp;M(i + 1) == 0</code> hence we can drop <code>q&#39;&amp;1</code>, as it is guaranteed to be <code>0</code>.</p>
<div><pre><b>⟦</b>  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>Amazing! We got rid of <code>q&#34;</code> and this is even before the first statement of the loop body was executed. Continue...</p>
  <p>Looking forward to  <code>r := r | n&#39;&amp;1</code>, we see that we have no <code>|</code>-s in sight, so the assignment axiom cannot be applied directly. Intuitively, this should not be the problem, because after <code>r</code> is doubled, its lowest bit is zero, and so <code>|</code> to it is the same as <code>+</code>, and we have plenty of additions. To prove this it will be nice to have a conjunct <code>r&amp;1 == 0</code> at that point. But if such a conjunct is present, then <em>before</em> the <code>r := 2*r</code> assignment it looked (as per the assignment axiom) as <code>(2*r)&amp;1 == 0</code>, which is always true, and so we can just as well insert it at this point!</p>
<div><pre><b>⟦</b>  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; (2*r)&amp;1 == 0</span>  <b>⟧</b></pre></div>
  <p>More pressingly, to apply the assignment axiom to <code>r := r | n&#39;&amp;1</code> we need <code>n&#39;&amp;1</code> next to each <code>r</code>. To this end, observe that <code>n&#39;&amp;1</code> is either <code>0</code> or <code>1</code>, and so if <code>2*r &lt; 2*d</code> then <code>2*r + n&#39;&amp;1 &lt; 2*d</code>.</p>
<div><pre><b>⟦</b>  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; (2*r)&amp;1 == 0</span>  <b>⟧</b></pre></div>
  <p>We are fully ready to apply the assignment axiom:</p>  
<div><pre><b>⟦</b>  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; (2*r)&amp;1 == 0</span>  <b>⟧</b>
r := 2*r
<b>⟦</b>  <span>2*n&#34; == d*q&#39; + r &amp;&amp; r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  <b>⟧</b>
</pre></div>
  <p>Apply the lemma: <code>2*n&#34; == n&#39; - n&#39;&amp;1</code></p>
  
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + r + n&#39;&amp;1 &amp;&amp; r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  <b>⟧</b></pre></div>
  <p>The next statement is the assignment <code>r := r | n&#39;&amp;1</code>. Thanks to <code>r&amp;1 == 0</code> conjunct, carefully prepared in advance, we know that we can replace <code>r + n&#39;&amp;1</code> with <code>r | n&#39;&amp;1</code> and apply the assignment axiom:</p>
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + r + n&#39;&amp;1 &amp;&amp; r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  <b>⟧</b>
<b>⟦</b>  <span>n&#39; == d*q&#39; + (r | n&#39;&amp;1) &amp;&amp; (r | n&#39;&amp;1) &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  <b>⟧</b>
r := r | n&#39;&amp;1
<b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b></pre></div>
  <p>One starts feeling at this point, that the steps of the derivation are practically forced by the form of the invariant. The appearance of <code>r + n&#39;&amp;1</code> components in the assertion is a result of using the lemma to get rid of <code>q&#34;</code> and <code>n&#34;</code>. In fact, it seems possible that the algorithm itself could have been derived <i>ad initio</i>, given the invariant. More about this at the end.</p>
<p>We found the mysterious precondition of the conditional statement. One relatively simple final step remains: we have to establish that both conditional branches, given this precondition, establish the target. Let&#39;s start with the <code>r &gt;= d</code> branch. We need</p>
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &gt;= d</span>  <b>⟧</b>
r := r - d;
q := q | B&#39;
<b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  <b>⟧</b></pre></div>
  <p>Experienced as we are at this point, we can easily transform the precondition to a form suitable for the next assignment (and also drop the redundant <code>0 &lt;= r</code> conjunct, implied by the conditional guard):</p>
  
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + (r - d) + d &amp;&amp; r - d &lt; d &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r - d &gt;= 0</span>  <b>⟧</b></pre></div>
  <p>Apply the assignment axiom</p>
  
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + (r - d) + d &amp;&amp; r - d &lt; d &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r - d &gt;= 0</span>  <b>⟧</b>
r := r - d
<b>⟦</b>  <span>n&#39; == d*q&#39; + r + d &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &gt;= 0</span>  <b>⟧</b>
  </pre></div>
  <p>Prepare for the <code>q := q | B&#39;</code> assignment. To this end, we have to transform the last assertion to a form where <code>q</code> only happens as a part of <code>q | B&#39;</code>. First, from <code>q&amp;M(i + 1) == 0</code> it follows that <code>q | B&#39; == q + B&#39;</code> (because <code>i</code>-th bit of <code>q</code> is zero). Next, do the easy part, <code>q&amp;M(i + 1) == 0</code>: weaken it, as was discussed above, to <code>q&amp;M(i) == 0</code>, then, use <code>(B&#39; | M(i)) == 0</code> (immediately from the definition of <code>M(i)</code>) to arrive at <code>(q | B&#39;)&amp;M(i) == 0</code>.</p>
  <p>Next, deal with <code>d*q&#39; + r + d</code>.</p>
    
<div><pre>        d*q&#39; + r + d
      == d*(q&#39; + 1)  + r
      == d*(q + B&#39;)&#39; + r /* Convince yourself that (x &gt;&gt; i) + 1 == (x + (1 &lt;&lt; i)) &gt;&gt; i */
      == d*(q | B&#39;)&#39; + r
  </pre></div>
  <p>Apply the assignment axiom</p>
<div><pre><b>⟦</b>  <span>n&#39; == d*(q | B&#39;)&#39; + r &amp;&amp; r &lt; d &amp;&amp; (q|B&#39;)&amp;M(i) == 0 &amp;&amp; r &gt;= 0</span>  <b>⟧</b>
q := q | B&#39;
<b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i) == 0 &amp;&amp; r &gt;= 0</span>  <b>⟧</b></pre></div>
  <p>Wait a second. This is exactly the target: <code>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</code>. We are done! What remains, is the trivial verification for the <code>r &lt; d</code> conditional branch:</p>
  
<div><pre><b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &lt; d</span>  <b>⟧</b>
/* Algebra and weakening q&amp;M(i + 1) == 0 to q&amp;M(i) == 0 */
<b>⟦</b>  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  <b>⟧</b>  </pre></div>
  <p><b>We are done with the verification of the loop invariant!</b></p>

  
  <hr/>
  

  <p>We now know that our loop invariant is indeed an invariant. The while-loop axiom then assures us that at the termination of the loop, the invariant will still hold, together with the negation of the guard:</p>
  
<div><pre><b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  <b>⟧</b>
while (i != -1) {
        r &lt;&lt;= 1;
        r |= ((n &gt;&gt; i) &amp; 1);
        if (r &gt;= d) {
                r := r - d;
                q |= 1 &lt;&lt; i;
        }
        i := i - 1;
}
<b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; i == -1</span>  <b>⟧</b></pre></div>
  <p>OK, so substitute <code>i == -1</code> to the invariant:</p>
  
<div><pre><b>⟦</b>  <span>n&#34; == d*q&#34; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; i == -1</span>  <b>⟧</b>
<b>⟦</b>  <span>n == d*q + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r</span>  <b>⟧</b></pre></div>
  <p>Hallelujah!</p>
  
  <p>Let&#39;s put it all together</p>

  <div><pre>uintN_t div(uintN_t n, uintN_t d) {
⟦  <span>d &gt; 0</span>  ⟧
⟦  <span>0 == 0 &amp;&amp; 0 &lt; d &amp;&amp; (0 &amp; ~0) == 0</span>  ⟧
        uintN_t q := 0;
⟦  <span>0 == d*0 + 0 &amp;&amp; 0 &lt; d &amp;&amp; 0 &lt;= 0 &amp;&amp; (q &amp; ~0) == 0</span>  ⟧
        uintN_t r := 0;
⟦  <span>0 == d*0 + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; (q &amp; ~0) == 0</span>  ⟧
        int     i := N - 1;
⟦  <span>n&#34; == d*q&#34; + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
        while (i != -1) {
⟦  <span>n&#34; == d*q&#34; + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d  &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; i != -1</span>  ⟧
⟦  <span>2*n&#34; == 2*d*q&#34; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
⟦  <span>2*n&#34; == d*(q&#39; - q&#39;&amp;1) + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
⟦  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
⟦  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; (2*r)&amp;1 == 0</span>  ⟧
⟦  <span>2*n&#34; == d*q&#39; + 2*r &amp;&amp; 2*r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= 2*r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; (2*r)&amp;1 == 0</span>  ⟧
                r &lt;&lt;= 1;
⟦  <span>2*n&#34; == d*q&#39; + r &amp;&amp; r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  ⟧
⟦  <span>n&#39; == d*q&#39; + r + n&#39;&amp;1 &amp;&amp; r + n&#39;&amp;1 &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r&amp;1 == 0</span>  ⟧
                r |= ((n &gt;&gt; i) &amp; 1);
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
                if (r &gt;= d) {
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &gt;= d</span>  ⟧
⟦  <span>n&#39; == d*q&#39; + r + d &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &gt;= 0</span>  ⟧
                        r := r - d;
⟦  <span>n&#39; == d*q&#39; + r + d &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &gt;= 0</span>  ⟧
⟦  <span>n&#39; == d*(q | B&#39;)&#39; + r &amp;&amp; r &lt; d &amp;&amp; (q|B&#39;)&amp;M(i) == 0 &amp;&amp; r &gt;= 0</span>  ⟧
                        q |= 1 &lt;&lt; i;
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  ⟧
                } else {
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; 2*d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i + 1) == 0 &amp;&amp; r &lt; d</span>  ⟧
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  ⟧
                }
⟦  <span>n&#39; == d*q&#39; + r &amp;&amp; r &lt; d &amp;&amp; 0 &lt;= r &amp;&amp; q&amp;M(i) == 0</span>  ⟧
                i := i - 1;
⟦  <span>n&#34; == d*q&#34; + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d &amp;&amp; q&amp;M(i + 1) == 0</span>  ⟧
        }
⟦  <span>n&#34; == d*q&#34; + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d &amp;&amp; i == -1</span>  ⟧
⟦  <span>n == d*q + r &amp;&amp; 0 &lt;= r &amp;&amp; r &lt; d</span>  ⟧
        return q;
}</pre></div>

  
  <hr/>
  

  <p>Seriously, the proof above looks at a first (and then any following) sight, as a random barrage of bizarre formal spasms in haphazard directions. It is practically impossible to construct such a sequence of assertions in a top-to-bottom fashion, unless one spends an unhealthy amount of time interacting with Hoare triples in dark alleys.</p>
  <p>And this is why nobody is doing it this way (among humans that is, automated provers are only too happy to try insane numbers of possible dead-ends). Early on, a much better-structured approach, going in the opposite direction, starting from the known targets (postconditions) was developed, see <a href="https://en.wikipedia.org/wiki/Predicate_transformer_semantics">Predicate transformer semantics</a>, or better still, read <a href="https://www.amazon.com/Discipline-Programming-Edsger-W-Dijkstra/dp/013215871X">A Discipline of Programming</a> (&#34;59683rd Edition&#34; as the Amazon page mentions nonchalantly). Dijkstra also shared the opinion that the structure of the program and the postcondition are tightly locked to the extent that it is possible to derive a program, given its formal specification, see the amazing <a href="https://www.cs.utexas.edu/~EWD/ewd11xx/EWD1162.PDF">EWD1162</a>.</p>
    
  <!--<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>
<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>
  
<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>
  
<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>
  
<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>
  
<div style="background: #f0f0f0; overflow:auto; width:80%; border:solid gray; border-width:.1em .1em .1em .8em; padding:.2em .6em;"><pre style="line-height: 125%; margin: 0px;"><code class>
  </pre></div>-->
  
</div> <!--justify-->

</div></div>
  </body>
</html>
