<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">Original</a>
    <h1>Pointers Are Complicated II, or: We need better language specs (2020)</h1>
    
    <div id="readability-page-1" class="page"><article id="-content">
      <header>
    
    
</header>

<p>Some time ago, I wrote a blog post about how <a href="https://moerner.com/blog/2018/07/24/pointers-and-bytes.html">there’s more to a pointer than meets the eye</a>.
One key point I was trying to make is that</p>

<blockquote>
  <p><em>just because two pointers point to the same address, does not mean they are equal in the sense that they can be used interchangeably.</em></p>
</blockquote>

<p>This “extra information” that distinguishes different pointers to the same address is typically called <a href="https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#pointer-provenance"><em>provenance</em></a>.
This post is another attempt to convince you that provenance is “real”, by telling a cautionary tale of what can go wrong when provenance is not considered sufficiently carefully in an optimizing compiler.
The post is self-contained; I am not assuming that you have read the first one.
There is also a larger message here about how we could prevent such issues from coming up in the future by spending more effort on the specification of compiler IRs.</p>

<!-- MORE -->

<p>Below, I will show a series of three compiler transformations that each seem “intuitively justified”, but when taken together they lead to a clearly incorrect result.
I will use LLVM for these examples, but the goal is not to pick on LLVM—other compilers suffer from similar issues.
The goal is to convince you that to build a correct compiler for languages permitting unsafe pointer manipulation such as C, C++, or Rust,
we need to take IR semantics (and specifically provenance) more seriously.
I use LLVM for the examples because it is particularly easy to study with its single, extensively-documented IR that a lot of infrastructure evolved around.
Let’s get started!</p>

<h2 id="warm-up-why-irs-need-a-precise-semantics">Warm-up: Why IRs need a precise semantics</h2>

<p>As a warm-up, I will give a simple example showing that compiler IRs such as LLVM IR need a precise (and precisely documented) semantics.
If you are already familiar with the idea of treating compiler IRs as proper programming languages in their own right, or if you are just here for the pointers and their provenance, you can skip to the next section.</p>

<p>Consider the following simple (and contrived, for the sake of this example) piece of C code computing <code>n * (i+j)</code>:</p>

<figure><pre><code data-lang="c"><span>int</span> <span>sum_up</span><span>(</span><span>int</span> <span>i</span><span>,</span> <span>int</span> <span>j</span><span>,</span> <span>unsigned</span> <span>int</span> <span>n</span><span>)</span> <span>{</span>
  <span>int</span> <span>result</span> <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span><span>n</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>result</span> <span>+=</span> <span>i</span> <span>+</span> <span>j</span><span>;</span>
    <span>n</span> <span>-=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>result</span><span>;</span>
<span>}</span></code></pre></figure>

<p>One transformation the compiler might want to do is to move the addition <code>i+j</code> out of the loop, to avoid computing the sum each time around the loop (this is called “loop-invariant code motion”<sup id="fnref:loop"><a href="#fn:loop" rel="footnote" role="doc-noteref">1</a></sup>):</p>

<figure><pre><code data-lang="c"><span>int</span> <span>sum_up</span><span>(</span><span>int</span> <span>i</span><span>,</span> <span>int</span> <span>j</span><span>,</span> <span>unsigned</span> <span>int</span> <span>n</span><span>)</span> <span>{</span> <span>// optimized version</span>
  <span>int</span> <span>result</span> <span>=</span> <span>0</span><span>;</span>
  <span>int</span> <span>s</span> <span>=</span> <span>i</span> <span>+</span> <span>j</span><span>;</span>
  <span>while</span> <span>(</span><span>n</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>result</span> <span>+=</span> <span>s</span><span>;</span>
    <span>n</span> <span>-=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>result</span><span>;</span>
<span>}</span></code></pre></figure>

<p>However, that transformation is actually incorrect.
If we imagine a caller using this function as <code>sum_up(INT_MAX, 1, 0)</code>, then this is a perfectly correct way to call <code>sum_up</code>: the loop is never entered, so the overflowing addition <code>INT_MAX+1</code> is never performed.
However, after the desired optimization, the program now causes a signed integer overflow, which is UB (Undefined Behavior) and thus May Never Happen!<sup id="fnref:signed-int-overflow"><a href="#fn:signed-int-overflow" rel="footnote" role="doc-noteref">2</a></sup></p>

<p>One might be tempted to ignore this problem because the UB on integer overflow is a compiler-only concept; every target supported by the compiler will do the obvious thing and just produce an overflowing result.
However, there might be other compiler passes running after the optimization we are considering.
One such pass might inline <code>sum_up</code>, and another pass might notice the <code>INT_MAX+1</code> and replace it by <code>unreachable</code> since UB code is “by definition” unreachable, and another pass might then just remove all our code since it is unreachable.
Each of these passes has a good reason to exist (it can help real code become a lot faster or help prune dead code), but if we combine them all with loop-invariant code motion, the result is a disaster.</p>

<p>One way (and the only systematic way I know) to avoid such problems is to make sure that we can justify the correctness of each optimization <em>in isolation</em>.
Each optimization must be <em>correct</em> for any possible program, where <em>correct</em> means that the optimized program must only “do things” that the original program could have done as well.
(This is basically the “as-if” rule in the C standard, and is typically called “refinement” in the academic literature.)
In particular, no optimization must ever introduce UB into a UB-free program.</p>

<p>It may seem now that under this premise, it is impossible to perform the loop-invariant code motion we are considering.
But that is not the case!
So far, what we have seen is that the optimization is not <em>correct</em> when being performed on a C program.
But when LLVM performs these optimizations, it does not consider the program to be written in C—it considers the program to be written in LLVM IR, which has a different semantics than C.
Specifically, the <a href="https://llvm.org/docs/LangRef.html">LLVM LangRef</a> says that signed integer overflow in LLVM IR yields a <code>poison</code> value.
It is not UB to produce <code>poison</code>, it is just UB to use <code>poison</code> in certain ways (the details of this do not matter here).
In a call to the optimized <code>sum_up(INT_MAX, 1, 0)</code>, the <code>s</code> variable introduced by loop-invariant code motion is unused, so the fact that its value is <code>poison</code> does not matter!</p>

<p>Due to this behavior of signed integer overflow, this case of loop-invariant code motion is <em>correct</em> if we consider it as an optimization on programs that are written in LLVM IR.<sup id="fnref:cheat"><a href="#fn:cheat" rel="footnote" role="doc-noteref">3</a></sup>
The “price” we pay for this is that replacing <code>INT_MAX+1</code> by <code>unreachable</code> is not <em>correct</em> in LLVM IR, since it is not UB.</p>

<p>The great thing about <em>correct</em> optimizations is that we can combine any number of them in any order (such as inlining, replacing definite UB by <code>unreachable</code>, and removing unreachable code), and we can be sure that the result obtained after all these optimizations is a correct compilation of our original program.
(In the academic lingo, we would say that “refinement is transitive”.)</p>

<p>However, to make the argument that an optimization is <em>correct</em>, the exact semantics of LLVM IR (what the behavior of all possible programs is and when they have UB) needs to be documented.
All involved optimizations need to exactly agree on what is and is not UB, to ensure that whatever code they produce will not be considered UB by a later optimization.
This is exactly what we also expect from the specification of a programming language such as C, which is why I think we should consider compiler IRs as proper programming languages in their own right, and specify them with the same diligence as we would specify “normal” languages.<sup id="fnref:ub-difference"><a href="#fn:ub-difference" rel="footnote" role="doc-noteref">4</a></sup>
Sure, no human is going to write many programs in LLVM IR, so their syntax barely matters, but clang and rustc produce LLVM IR programs all the time, and as we have seen understanding the exact rules governing the behavior of programs is crucial to ensuring that the optimizations LLVM performs do not change program behavior.</p>

<p><em>Take-away:</em> If we want to be able to justify the correctness of a compiler in a modular way, considering only one optimization at a time, we need to perform these optimizations in an IR that has a precise specification of all aspects of program behavior, including UB.
Then we can, for each optimization separately, consider the question: does the optimization ever change program behavior, and does it ever introduce UB into UB-free programs?
For a <em>correct</em> optimization, the answer to these questions is “no”.</p>

<h2 id="how-3-seemingly-correct-optimizations-can-be-incorrect-when-used-together">How 3 (seemingly) correct optimizations can be incorrect when used together</h2>

<p>With the warm-up done, we are now ready to consider some more tricky optimizations, which we will use to explore the question of how precise a language specification needs to be.
We will look at three different optimizations LLVM can perform, and I will show that they <em>cannot all be correct</em> since the first and last program we are considering actually have <em>different behavior</em>.
(More precisely: the last program has a possible behavior that was not possible for the first program.)
This is only possible if at least one optimization changed program behavior in an incorrect way, but it is actually not entirely clear which optimization is the culprit.</p>

<p>The sequence of examples is taken from <a href="https://sf.snu.ac.kr/llvmtwin/files/presentation.pdf#page=32">this talk</a> by Chung-Kil Hur; it was discovered while working on a mathematically rigorous specification of LLVM.</p>

<p>Here is the source program:</p>

<figure><pre><code data-lang="c"><span>char</span> <span>p</span><span>[</span><span>1</span><span>],</span> <span>q</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
<span>uintptr_t</span> <span>ip</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)(</span><span>p</span><span>+</span><span>1</span><span>);</span>
<span>uintptr_t</span> <span>iq</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>q</span><span>;</span>
<span>if</span> <span>(</span><span>iq</span> <span>==</span> <span>ip</span><span>)</span> <span>{</span>
  <span>*</span><span>(</span><span>char</span><span>*</span><span>)</span><span>iq</span> <span>=</span> <span>10</span><span>;</span>
  <span>print</span><span>(</span><span>q</span><span>[</span><span>0</span><span>]);</span>
<span>}</span></code></pre></figure>

<p>I am using C syntax here just as a convenient way to write programs in LLVM IR.</p>

<p>This program has two possible behaviors: either <code>ip</code> (the address one-past-the-end of <code>p</code>) and <code>iq</code> (the address of <code>q</code>) are different, and nothing is printed.
Or the two are equal, in which case the program will print “10” (<code>iq</code> is the result of casting <code>q</code> to an integer, so casting it back will yield the original pointer, or at least a pointer pointing to the same object / location in memory).</p>

<p>The first “optimization” we will perform is to exploit that if we enter the <code>if</code> body, we have <code>iq == ip</code>, so we can replace all <code>iq</code> by <code>ip</code>.
Subsequently the definition of <code>ip</code> is inlined:</p>

<figure><pre><code data-lang="c"><span>char</span> <span>p</span><span>[</span><span>1</span><span>],</span> <span>q</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
<span>uintptr_t</span> <span>ip</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)(</span><span>p</span><span>+</span><span>1</span><span>);</span>
<span>uintptr_t</span> <span>iq</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>q</span><span>;</span>
<span>if</span> <span>(</span><span>iq</span> <span>==</span> <span>ip</span><span>)</span> <span>{</span>
  <span>*</span><span>(</span><span>char</span><span>*</span><span>)(</span><span>uintptr_t</span><span>)(</span><span>p</span><span>+</span><span>1</span><span>)</span> <span>=</span> <span>10</span><span>;</span> <span>// &lt;- This line changed</span>
  <span>print</span><span>(</span><span>q</span><span>[</span><span>0</span><span>]);</span>
<span>}</span></code></pre></figure>

<p>The second optimization notices that we are taking a pointer <code>p+1</code>, casting it to an integer, and casting it back, so we can remove the cast roundtrip:</p>

<figure><pre><code data-lang="c"><span>char</span> <span>p</span><span>[</span><span>1</span><span>],</span> <span>q</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
<span>uintptr_t</span> <span>ip</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)(</span><span>p</span><span>+</span><span>1</span><span>);</span>
<span>uintptr_t</span> <span>iq</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>q</span><span>;</span>
<span>if</span> <span>(</span><span>iq</span> <span>==</span> <span>ip</span><span>)</span> <span>{</span>
  <span>*</span><span>(</span><span>p</span><span>+</span><span>1</span><span>)</span> <span>=</span> <span>10</span><span>;</span> <span>// &lt;- This line changed</span>
  <span>print</span><span>(</span><span>q</span><span>[</span><span>0</span><span>]);</span>
<span>}</span></code></pre></figure>

<p>The final optimization notices that <code>q</code> is never written to, so we can replace <code>q[0]</code> by its initial value <code>0</code>:</p>

<figure><pre><code data-lang="c"><span>char</span> <span>p</span><span>[</span><span>1</span><span>],</span> <span>q</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
<span>uintptr_t</span> <span>ip</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)(</span><span>p</span><span>+</span><span>1</span><span>);</span>
<span>uintptr_t</span> <span>iq</span> <span>=</span> <span>(</span><span>uintptr_t</span><span>)</span><span>q</span><span>;</span>
<span>if</span> <span>(</span><span>iq</span> <span>==</span> <span>ip</span><span>)</span> <span>{</span>
  <span>*</span><span>(</span><span>p</span><span>+</span><span>1</span><span>)</span> <span>=</span> <span>10</span><span>;</span>
  <span>print</span><span>(</span><span>0</span><span>);</span> <span>// &lt;- This line changed</span>
<span>}</span></code></pre></figure>

<p>However, this final program is different from the first one!
Specifically, the final program will either print nothing or print “0”, while the original program <em>could never print “0”</em>.
This shows that the sequence of three optimizations we performed, as a whole, is <em>not correct</em>.</p>

<h4 id="what-went-wrong">What went wrong?</h4>

<p>Clearly, one of the three optimizations is incorrect in the sense that it introduced a change in program behavior.
But which one is it?</p>

<p>In an ideal world, we would have a sufficiently precise semantics for LLVM IR that we would just have to read the docs (or, even better, run some Miri-like tool) to figure out the answer.
However, describing language semantics at this level of precision is <em>hard</em>, and full of trade-offs.
The LLVM LangRef will not give us a clear answer here, and indeed obtaining a clear answer requires some decisions that have not been explicitly made yet.</p>

<p>To proceed, we will use the three optimizations that we considered above as cues: assuming that the optimization is correct for LLVM IR, what does that tell us about the semantics?</p>

<p>Let us start with the last optimization, where the <code>print</code> argument is changed from <code>q[0]</code> to <code>0</code>.
This optimization is based on alias analysis:
<code>q[0]</code> gets initialized to <code>0</code> at the beginning of the program, and the only write between that initialization and the <code>print</code> is to the pointer <code>p+1</code>.
Since <code>q</code> and <code>p</code> point to different local variables, a pointer derived from <code>p</code> cannot alias <code>q[0]</code>, and hence we know that this write cannot affect the value stored at <code>q[0]</code>.</p>

<p>Looking more closely, however, reveals that things are not quite so simple!
<code>p+1</code> is a one-past-the-end pointer, so it actually <em>can</em> have the same address as <code>q[0]</code>
(and, in fact, inside the conditional we know this to be the case).
However, LLVM IR (just like C) does not permit memory accesses through one-past-the-end pointers.
It makes a difference whether we use <code>p+1</code> or <code>q</code> inside the <code>if</code>, even though we know (in that branch) that both pointers point to the same memory location.
This demonstrates that in LLVM IR, there is more to a pointer than just the address it points to—it also matters how this address was computed.
This extra information is typically called <em>provenance</em>.
It is impossible to argue for the <em>correct</em>ness of the third optimization without acknowledging that provenance is a real part of the semantics of an LLVM IR program.
In a flat memory model where pointers are just integers (such as most assembly languages), this optimization is simply wrong.</p>

<p>Now that we know that provenance exists in pointers, we have to also consider what happens to provenance when a pointer gets cast to an integer and back.
The second optimization gives us a clue into this aspect of LLVM IR semantics: casting a pointer to an integer and back is optimized away, which means that <em>integers have provenance</em>.
To see why, consider the two expressions <code>(char*)(uintptr_t)(p+1)</code> and <code>(char*)(uintptr_t)q</code>:
if the optimization of removing pointer-integer-pointer roundtrips is correct, the first operation will output <code>p+1</code> and the second will output <code>q</code>, which we just established are two different pointers (they differ in their provenance).
The only way to explain this is to say that the input to the <code>(char*)</code> cast is different, since the program state is otherwise identical in both cases.
But we know that the integer values computed by <code>(uintptr_t)(p+1)</code> and <code>(uintptr_t)q</code> (i.e., the bit pattern as stored in some CPU register) are the same, and hence a difference can only arise if these integers consist of more than just this bit pattern—just like pointers, integers have provenance.</p>

<p>Finally, let us consider the first optimization.
Here, a successful equality test <code>iq == ip</code> prompts the optimizer to replace one value by the other.
This optimization demonstrates that <em>integers do not have provenance</em>:
the optimization is only correct if a successful run-time equality test implies that the two values are equivalent in the “Abstract Machine” that is used to describe the language semantics.
But this means that the Abstract Machine version of this value cannot have any “funny” extra parts that are not represented at run-time.
Of course, provenance is exactly such a “funny” extra part.
A different way to phrase the same argument is to say that this optimization is correct only if <code>iq == ip</code> evaluating to <code>true</code> implies that both values have the same “Abstract Machine” representation, so if that representation involves provenance, both values must have the same provenance.
This would be a possible definition of <code>==</code> in LLVM IR, but only in principle—in practice this means the LLVM backends have to compile <code>==</code> in a way that pointer provenance is taken into account, which of course is impossible.</p>

<p><em>Take-away:</em>
By considering each of these three optimizations in terms of what they tell us about the semantics of LLVM IR, we learned that pointers have provenance, that integers remember the provenance of the pointer they come from in case of a pointer-to-integer cast, and that integers do not have provenance.
This is a contradiction, and this contradiction explains why we saw incorrect compilation results when applying all three optimizations to the same program.</p>

<h4 id="how-can-we-fix-this">How can we fix this?</h4>

<p>To fix the problem, we will have to declare one of the three optimizations incorrect and stop performing it.
Speaking in terms of the LLVM IR semantics, this corresponds to deciding whether pointers and/or integers have provenance:</p>
<ul>
  <li>We could say both pointers and integers have provenance, which invalidates the first optimization.</li>
  <li>We could say pointers have provenance but integers do not, which invalidates the second optimization.</li>
  <li>We could say nothing has provenance, which invalidates the third optimization.</li>
</ul>

<p>In my opinion, the first and last options are not tenable.
Removing provenance altogether kills all but the most simple alias analyses.<sup id="fnref:alias"><a href="#fn:alias" rel="footnote" role="doc-noteref">5</a></sup>
On the other hand, declaring that integers have provenance does not just disable the first optimization in the chain shown above, it also disables common arithmetic optimizations such as <code>x - x</code> being equivalent to <code>0</code>.
Even achieving commutativity and associativity of <code>+</code> becomes non-trivial once integers have provenance.</p>

<p>So, I think that the issue should be resolved by saying that pointers have provenance but integers do not, which means that it is the second optimization that is wrong.
This also corresponds to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">what has been recently proposed to the C standard committee</a>.
That’s why <a href="https://bugs.llvm.org/show_bug.cgi?id=34548">LLVM bug #34548</a> says that optimizing away pointer-integer-pointer roundtrips is incorrect, and LLVM should stop doing this in the general case.
There might still be special cases where this can be done, but figuring out the limits of this requires a more precise description of LLVM IR semantics such as what we proposed <a href="https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf">in this paper</a>.</p>

<p>But ultimately, it will be up to the LLVM community to make this decision.
All I can say for sure is that they have to make a choice, because the status quo of doing all three of these optimizations leads to incorrect compilation results.</p>

<h2 id="conclusion">Conclusion</h2>

<p>What did we learn?
First of all, pointers are complicated.
Precisely describing their semantics in a way that is consistent with common alias analyses requires adding a notion of “provenance”.
In a language such as Java or ML where pointers are opaque types whose representation cannot be observed, this is actually fairly easy to do.
But in a language such as Rust, C, or C++ that supports pointer-integer casts, the introduction of provenance poses some really tricky questions, and at least one of the commonly performed optimizations in this space has to give.</p>

<p>We also learned that LLVM has a bug, but that was <em>not</em> the point of this blog post.
The GCC developers <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82282">made exactly the same mistake</a>, and I got word that MSVC and ICC have the same issue (though I do not know how to verify this).
And I cannot blame them; the way compiler development typically works, I think bugs like this are inevitable: when exactly UB arises in an IR is often only loosely specified, in many cases “by omission” (where cases not covered in the spec are implicitly UB), so evaluating whether some optimization is <em>correct</em> in the sense defined above can be very tricky or even impossible.
Pointer provenance is just a particularly good (and subtle) example.
For another example, see <a href="https://plv.mpi-sws.org/validc/paper.pdf">§2.3 of this paper</a> (Figure 3 contains the code) which shows how a sequence of two optimizations can lead to a miscompilation, where the first optimization is <em>correct</em> under the LLVM concurrency model, and the second optimization is <em>correct</em> under the C++11 concurrency model—but there is no concurrency model under which <em>both</em> optimizations are correct, so each compiler (or rather, each compiler IR) needs to pick one or the other.
Finally, this <a href="https://www.cs.utah.edu/~regehr/papers/undef-pldi17.pdf">paper on <code>undef</code> and <code>poison</code></a> gives examples for optimizations that are broken by the presence of <code>undef</code> in LLVM, and describes some of the trade-offs that arise when defining the semantics of <code>poison</code>.
Again miscompilations arise because the consequence of a statement in one place of the specification (<code>undef</code> picks a fresh value at each use) are not considered elsewhere (testing an integer for equality with zero dos not imply it is zero; it could also be <code>undef</code>).</p>

<p>Which brings me to my main conclusion for this post: to avoid the problem of incompatible optimizations, I think we need to take compiler IRs more serious as programming languages in their own right, and give them a precise specification—including all the UB.
Now, you may object by saying that LLVM has an <a href="https://llvm.org/docs/LangRef.html">extensive LangRef</a>, and still, by reading the LLVM specification one could convince oneself that each of the three optimizations above is correct, which as we have seen is contradictory.
What is missing? Do we need a formal mathematical definition to avoid such ambiguities?
I do not think so; I think there is something simpler that will already help a lot.
The source of the contradiction is that some parts of the specification <em>implicitly</em> assume that pointers have provenance, which is easy to forget when considering other operations.
That’s why I think it is very important to make such assumptions more explicit: the specification should <em>explicitly</em> describe the information that “makes up” a value, which will include things like provenance and <a href="https://moerner.com/blog/2018/07/24/pointers-and-bytes.html">whether the value is (wholly or partially) initialized</a>.<sup id="fnref:C"><a href="#fn:C" rel="footnote" role="doc-noteref">6</a></sup>
This information needs to be extensive enough such that a hypothetical interpreter can use it to detect all the UB.
Doing so makes it obvious that a pointer has provenance, since otherwise it is impossible to correctly check for out-of-bounds pointer arithmetic while also permitting one-past-the-end pointers.</p>

<p>This is my bar for what I consider a sufficiently precise language specification: it needs to contain all the information needed such that writing a UB-checking interpreter is just a matter of “putting in the work”, but does not require introducing anything new that is not described in the specification.</p>

<p>The good news is that the process of developing these more precise specifications is already underway!</p>

<p>On the Rust side, this is mainly apparent in the <a href="https://github.com/rust-lang/miri/">Miri interpreter</a>, which is a concrete realization of the “hypothetical” interpreter that I mentioned above.
In fact, this is why I originally started working on Miri.
Nowadays, its main purpose is to help unsafe code authors avoid UB, but for me personally, I find it equally important that it helps us think about the semantics of Rust and MIR in a different way.
It also feeds back into the design of the UB rules by discovering patterns that people want or need to use but that are not currently accepted by Miri.</p>

<p>On the LLVM side, the main development in this area is <a href="https://blog.regehr.org/archives/1722">Alive</a>, a tool that can automatically validate<sup id="fnref:validate"><a href="#fn:validate" rel="footnote" role="doc-noteref">7</a></sup> optimizations performed by LLVM.
Alive has found <a href="https://github.com/AliveToolkit/alive2/blob/master/BugList.md">many bugs in LLVM optimizations</a>, and indeed much of the recent dialog with the LLVM community aimed at a more precise IR semantics is pushed by the people building Alive, led by Nuno P. Lopes and John Regehr.</p>

<p>Progress on these specification efforts is slow, though, in particular when it turns out that <a href="https://www.cs.utah.edu/~regehr/papers/undef-pldi17.pdf">LLVM IR semantics should be changed</a>.
I hope this post can raise awareness for the subtle problems optimizing compilers are facing, and convince some people that figuring out the specification of compiler IRs is an important and interesting problem to work on. :)</p>

<p>That’s all I have for today, thanks for sticking with me!
As usual, this post can be <a href="https://internals.rust-lang.org/t/pointers-are-complicated-ii-or-we-need-better-language-specs/13562">discussed in the Rust forums</a> and <a href="https://www.reddit.com/r/rust/comments/kd157i/pointers_are_complicated_ii_or_we_need_better/">on Reddit</a>.
I am curious what your thoughts are on how we can build compilers that do not suffer from the issues I have discussed here.</p>







    </article></div>
  </body>
</html>
