<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://berthub.eu/articles/posts/how-to-get-a-unix-epoch-from-a-utc-date-time-string/">Original</a>
    <h1>The surprising struggle to get a Unix Epoch time from a UTC string in C or C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
  

  <div>
  <p>So how hard could it be. As input we have something like <code>Fri, 17 Jan 2025 06:07:07</code> in UTC, and we’d like to turn this into 1737094027, the notional (but not actual) number of seconds that have passed since 1970-01-01 00:00:00 UTC.</p>
<p>Trying to figure this out led me to discover many ‘surprise features’ and otherwise unexpected behaviour of POSIX time handling functions as implemented in various C libraries &amp; the languages that build on them. There are many good things in the world of C and UNIX, but time handling is not one of them.</p>
<p>There is a narrow path of useful behaviour however. But first some context.</p>
<blockquote>
<p>The tl;dr: <strong>as long as you never call</strong> <code>setlocale()</code>, you can use <code>strptime()</code> to parse a UTC time string. Do not use %z or %Z. Pass the <code>struct tm</code> calculated by <code>strptime()</code> to the pre-standard function <code>timegm()</code> (<code>mkgmtime()</code> on Windows) to get the correct UNIX epoch timestamp for your UTC time string. Do read on for solutions for if you do use locales. C++ has better support, which could also help you from C.</p>
</blockquote>

<p>Time is difficult enough by itself, even if we ignore leap seconds and <a href="https://en.wikipedia.org/wiki/Barycentric_Dynamical_Time">general relativity</a>. When we add human behaviour and politics, it all becomes exceptionally challenging. Timestamps as used by human beings range from impossible to imprecise.</p>
<p>For example in Amsterdam, “the 30th of March 2025, 02:20” does not exist as a time:</p>
<pre tabindex="0"><code>$ TZ=Europe/Amsterdam date -d &#39;20250330 01:59:59&#39;
Sun Mar 30 01:59:59 AM CET 2025
$ TZ=Europe/Amsterdam date -d &#39;20250330 02:30:00&#39;
date: invalid date ‘20250330 02:30:00’
</code></pre><p>This at least is clear. Because of daylight saving time we go straight from 01:59:59 to 03:00:00. Our tooling rightfully refuses to parse “02:30:00” since that timestamp never exists in Amsterdam on that day.</p>
<p>But “the 27th of October 2024, 02:30” is harder to interpret. The second after 02:59:59, it is 02:00:00 again. This means we have <em>two</em> points in time locals would call ‘02:00’. And here already we can see our tooling starting to make arbitrary choices:</p>
<pre tabindex="0"><code>$ TZ=Europe/Amsterdam date -d &#39;20241027 01:59:59&#39; +&#34;%Y-%m-%d %H:%M:%S %s %z&#34;
2024-10-27 01:59:59 1729987199 +0200
$ TZ=Europe/Amsterdam date -d &#39;20241027 02:00:00&#39; +&#34;%Y-%m-%d %H:%M:%S %s %z&#34;
2024-10-27 02:00:00 1729990800 +0100
</code></pre><p>Apparently, when asked to interpret 02:00:00, my copy of GNU date picks the <em>second</em> time this happens. As far as I can tell, this is because I’m running the command in January. In April it would likely have picked the first 02:00:00 instance. Wild eh?</p>

<p>The only useful way anyone should ever be specifying a point of time is of course as a number of seconds after or before a known ’epoch’. For POSIX/Unix this is 1970-01-01 00:00:00 UTC, for GPS this is 1980-01-06 00:00:00 UTC, for Galileo (‘EU GPS’) 21st of August 1999, 23:59:47 UTC, for BeiDou 2006-01-01 00:00:00 UTC. GPS, Galileo and BeiDou wisely ignore leap seconds, leaving these as things for human beings to worry about.</p>
<p>But, our preference for the POSIX/Unix “time_t” is well founded. There is never any ambiguity, except during leap seconds, which might never happen again.</p>
<p>However, human beings have a hard time parsing 1737214750, so we do need to convert to and from timestamps that include messy things like ‘months’. To this end, UNIX offered us <code>struct tm</code>, holding the ‘broken-down time’:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>tm</span> {
</span></span><span><span>  <span>int</span>  tm_sec;    <span>/* Seconds          [0, 60] */</span>
</span></span><span><span>  <span>int</span>  tm_min;    <span>/* Minutes          [0, 59] */</span>
</span></span><span><span>  <span>int</span>  tm_hour;   <span>/* Hour             [0, 23] */</span>
</span></span><span><span>  <span>int</span>  tm_mday;   <span>/* Day of the month [1, 31] */</span>
</span></span><span><span>  <span>int</span>  tm_mon;    <span>/* Month            [0, 11]  (January = 0) */</span>
</span></span><span><span>  <span>int</span>  tm_year;   <span>/* Year minus 1900 */</span>
</span></span><span><span>  <span>int</span>  tm_wday;   <span>/* Day of the week  [0, 6]   (Sunday = 0) */</span>
</span></span><span><span>  <span>int</span>  tm_yday;   <span>/* Day of the year  [0, 365] (Jan/01 = 0) */</span>
</span></span><span><span>  <span>int</span>  tm_isdst;  <span>/* Daylight savings flag */</span>
</span></span><span><span>  <span>long</span> tm_gmtoff; <span>/* Seconds East of UTC */</span>
</span></span><span><span>  <span>const</span> <span>char</span> <span>*</span>tm_zone;   <span>/* Timezone abbreviation */</span>
</span></span><span><span>};
</span></span></code></pre></div><p>The standards say that <code>struct tm</code> contains <em>at least</em> these fields. There could be more. Now, this struct is of course wildly overdetermined. Day of the week and day of the year follow from the rest, for example. The meanings of <code>tm_gmtoff</code>, <code>tm_zone</code> and <code>tm_isdst</code> are badly specified and also badly understood, and vary based on how the struct is used.</p>
<blockquote>
<p>Interestingly, the Soviet GLONASS satellite navigation system is not based on an epoch timestamp.  They took the <code>struct tm</code> approach based on ‘Moscow wall clock time’, including leap seconds. This reportedly causes lots of problems. <a href="https://en.wikipedia.org/wiki/Slava_Ukraini">And they deserve them</a>.</p>
</blockquote>
<p>One major role of <code>struct tm</code> is as input to <code>mktime()</code>, which as <em>part</em> of its work turns a ‘broken-down time <strong>according to your local TZ</strong>’ into a UNIX epoch timestamp. However, it also does many other things!</p>
<blockquote>
<p>Note that at least the Linux glibc manpage for <code>mktime()</code> is pretty vague. The <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/mktime.html">IEEE Std 1003.1-2024</a> specification offers a lot more (discouraging) words.</p>
</blockquote>
<p>It is important to understand that <code>mktime()</code> does absolutely nothing with <code>tm_gmtoff</code> or <code>tm_zone</code>. Its inputs are defined to exclusively be: <code>tm_year</code>, <code>tm_mon</code>, <code>tm_mday</code>, <code>tm_hour</code>, <code>tm_min</code>, <code>tm_sec</code>, and <code>tm_isdst</code>. <code>tm_isdst</code> can be negative, which means that <code>mktime()</code> should figure out if daylight saving time is active at the specified time.</p>
<p>As noted, time is difficult. If you for example want to adjust a date by a week, you could add 604800 seconds to a <code>time_t</code> timestamp. However, if that adjustment crosses a daylight savings time boundary, your 2PM appointment might suddenly turn into a 1PM or 3PM appointment next week. Humans do not expect this.</p>
<p><code>mktime()</code> not only returns a <code>time_t</code>, it also <em>normalizes</em> the <code>struct tm</code> you passed it. And, at least as of 2024 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/mktime.html">there are rules for how it should do so</a>. This means that to get the date that a human being would identify as “the same time next week” you can take the current time, add 7 to <code>tm.tm_mday</code>, and call <code>mktime()</code> again. Although you just created a date like ‘March 35’, <code>mktime()</code> will fix that up for you.</p>
<p>Now, if we do this, we find that it doesn’t work:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>struct</span> <span>tm</span> tm <span>=</span> {.tm_hour<span>=</span><span>14</span>, .tm_mday <span>=</span> <span>28</span>,
</span></span><span><span>                .tm_mon <span>=</span> <span>2</span>, .tm_year <span>=</span> <span>2025</span> <span>-</span> <span>1900</span>,
</span></span><span><span>				.tm_isdst <span>=</span> <span>-</span><span>1</span>};  <span>// &lt;- NOTE the -1
</span></span></span><span><span><span></span>
</span></span><span><span>time_t t <span>=</span> mktime(<span>&amp;</span>tm);
</span></span><span><span>cout <span>&lt;&lt;</span> <span>&#34;original:         &#34;</span><span>&lt;&lt;</span> ctime(<span>&amp;</span>t);
</span></span><span><span>
</span></span><span><span>tm.tm_mday <span>+=</span> <span>7</span>;
</span></span><span><span>t <span>=</span> mktime(<span>&amp;</span>tm);
</span></span><span><span>
</span></span><span><span>cout <span>&lt;&lt;</span> <span>&#34;mktime adjusted:  &#34;</span><span>&lt;&lt;</span> ctime(<span>&amp;</span>t);
</span></span></code></pre></div><p>Here in the Europe/Amsterdam timezone this prints:</p>
<pre tabindex="0"><code>original:        Fri Mar 28 14:00:00 2025
mktime adjusted: Fri Apr  4 15:00:00 2025
</code></pre><p>What happened, why did our appointment shift by an hour? <code>tm.tm_isdst</code> is what happened. <code>mktime()</code> may not be perfect, but it does force you to make up your mind. Is the time it is looking at daylight savings time or not? Or, at your choice, do you want <code>mktime()</code> to take a stab at figuring that out for you? The latter option is what we initially chose by setting <code>tm.tm_isdst</code> to -1.</p>
<p>When we then ran <code>mktime()</code>, it discovered we were initially not in daylight saving time, so it set <code>tm_isdst</code> to 0. When we ran <code>mktime()</code> for the second time, this DST setting remained in place, even though the new intended time <em>does</em> happen in DST. The fix is to reset <code>tm_isdst</code> to -1 before the second call.</p>

<p>Now, <code>mktime()</code> will interpret whatever you pass it as “local time”. This in means you should set your timezone to UTC before calling <code>mktime()</code> to process a UTC time. Changing the timezone for your whole application however might have side effects if you have other threads running. But, you could do that if you have no other threads.</p>
<p>UPDATE: It <a href="https://mastodon.social/@Junco/113856868255254143">has been pointed out</a> that <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/exec.html">multi-threaded programs can’t change their environment variables anyhow</a>. So much for that idea.</p>
<p>There is a non-standard/pre-standard function that is very widely available that makes the UTC situation a lot better. From IEEE Std 1003.1-2024: “A future version of this standard is expected to add a <code>timegm()</code> function that is similar to <code>mktime()</code>, except that the tm structure pointed to by timeptr contains a broken-down time in Coordinated Universal Time”.</p>
<p>To parse a broken-down time in UTC, I can much recommend using <code>timegm()</code> instead of messing with the TZ environment variable. On Windows, <code>timegm()</code> <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/mkgmtime-mkgmtime32-mkgmtime64?view=msvc-170&amp;redirectedfrom=MSDN">is available as <code>mkgmtime()</code></a>. And if you are on AIX, the lone platform without <code>timegm()</code>, you can find a <a href="https://github.com/lzsiga/timegm">standalone implementation here</a>.</p>
<p>Summarising:</p>
<ol>
<li>When using <code>mktime()</code> on local times, set <code>tm_isdst</code> to -1, which is almost always what ‘human beings’ expect. There is a chance you randomly get back one of two instances of ‘02:30’ (or equivalent) during DST fall back.</li>
<li>Make sure to zero the rest of <code>struct tm</code> before filling it out, just to be sure.</li>
<li>Be aware that <code>mktime()</code> does surgery on your <code>struct tm</code>, and that this may have side effects. At least reset <code>tm_isdst</code> before reuse.</li>
<li>No matter what you do with <code>tm_gmtoffset</code> or <code>tm_zone</code>, <code>mktime()</code> will use your current timezone. If you want it to interpret your <code>struct tm</code> as UTC, you actually need to set the TZ environment variable to UTC. This will however mess with any other threads doing time operations.</li>
<li>Just use <code>timegm()</code> or <code>mkgmtime()</code> instead</li>
</ol>
<p>But, how do we get our time string into a <code>struct tm</code>?</p>

<p>Now, it would be lovely if we could feed <code>Fri, 17 Jan 2025 06:07:07 GMT</code> into <code>strptime()</code> and get a sensible <code>struct tm</code> in return. The <a href="https://man7.org/linux/man-pages/man3/strptime.3.html">Linux glibc <code>strptime()</code> manpage</a> has some airy words about how the %z and %Z timezone format specifiers might or likely might not do something. You just can’t tell:</p>
<blockquote>
<p>“For reasons of symmetry, glibc tries to support for strptime() the same format characters as for strftime(3).  (In <strong>most cases</strong>, the corresponding fields are parsed, but no field in tm is changed.)</p>
</blockquote>
<p>Now, our goal is to convert a UTC time string into a UNIX epoch timestamp. Many people justifiably harbor some expectations that <code>strptime()</code> with %Z (to parse ‘GMT’) followed by <code>mktime()</code> could make that happen.</p>
<p>Above we learned however that <code>mktime()</code> does not look at the <code>tm_gmtoffset</code> or <code>tm_zone</code> fields at all, so there really is nothing that <code>strptime()</code> can achieve there, even if it did the right thing. Oh, and it also does not do the right thing.</p>
<p>As of 2024, there is <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/strptime.html">a decent specification of <code>strptime()</code> courtesy of the Open Group</a>, in which we can read all kinds of sad news on what implementations out there actually do. Or don’t do.</p>
<p>Because of this <code>strptime()</code> has no more specified behaviour for ‘%z’, which was one day supposed to do something with “+0200” style offset identifiers, which would have been lovely. But you can’t count on ‘%z’ doing anything useful. <a href="https://en.wiktionary.org/wiki/nasal_demon">Nasal demons</a> might ensue.</p>
<p>There is however some wording on <code>%Z</code>, but it is very limited. If your locale is known to have a DST timezone identifier (‘CEST’) that is different from the regular time zone (‘CET’), and if ‘%Z’ sees any of these two, it will set <code>tm_isdst</code> to the right value for you. <a href="https://www.redhat.com/en/blog/brief-history-mktime">Except possibly if you live in Ireland</a>. In general, it is also not useful to try to parse a string like ‘EST’, as it has no well defined meaning anyhow, except perhaps locally.</p>
<p>Luckily, because we discovered <code>gmtime()</code> above, we can just ignore %z and %Z as we don’t need them anyhow.</p>

<p>Very often, we want to parse date strings with English day and month names. We’d like to be sure that <code>strptime()</code> will then also do that. The <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/strptime.html">IEEE/Open Group standard for <code>strptime()</code> however is quite clear</a>, “The conversions are determined using the LC_TIME category of the current locale”. Oops.</p>
<p>Now, what I didn’t know is that unless they specifically ask for it, C and C++ programs will stick to the “C” locale, which effectively is American English. This means that out of the box all LC_TIME etc environment variables are ignored. For our purposes of parsing time strings found in data, this is usually great, since these are almost exclusively in English.</p>
<p>However, if you are in a C or C++ program that <em>does</em> call <code>setlocale()</code>, thus asking for a possibly non-C locale, suddenly your program might only work for Dutch time strings. And these are quite rare.</p>
<p>Now, you might ponder changing the locale to “C” before calling <code>strptime()</code> and then changing it back, but sadly <code>setlocale()</code> is not safe to call in multithreaded programs (except before launching threads). Also you might confuse the output of other threads even if this was safe.</p>
<p>So in general, if you need to parse specific time strings and you want to use <code>strptime()</code>, do make sure your program is on the locale you expect it to be. And although <code>strftime_l()</code> exists, in which you can specify the locale to use for formatting time, the equivalent <code>strptime_l()</code> is not officially available.</p>
<blockquote>
<p>The OpenBSD <code>strptime()</code> implementation decided to <a href="https://man.openbsd.org/strptime">just ignore the locale anyhow, and only support C</a>.</p>
</blockquote>
<p>Alternatively, it is not that hard to parse a string like <code>17 Jan 2025 06:07:07</code> and fill out a <code>struct tm</code> and then let <code>mktime()</code> do the actual hard work of calculating a UNIX epoch timestamp.</p>

<p>C++ iostreams are not much loved, but they did have a better think about locales than C/POSIX did. In C++ you can set the locale per iostream. <a href="https://github.com/berthubert/utchelper">Here is a C++ helper that you can call from C</a> if you want to parse arbitrary UTC time strings in programs that do set the locale:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>extern</span> <span>&#34;C&#34;</span>
</span></span><span><span><span>int</span> utcstr2epoch(<span>const</span> <span>char</span><span>*</span> timestr, <span>const</span> <span>char</span><span>*</span> fmtstr, <span>struct</span> <span>tm</span><span>*</span> output)
</span></span><span><span>{
</span></span><span><span>  std<span>::</span>tm t <span>=</span> {}; <span>// tm_isdst = 0, don&#39;t think about it please, this is UTC
</span></span></span><span><span><span></span>  std<span>::</span>istringstream ss(timestr);
</span></span><span><span>  ss.imbue(std<span>::</span>locale()); <span>// &#34;LANG=C&#34;, but local
</span></span></span><span><span><span></span>  
</span></span><span><span>  ss <span>&gt;&gt;</span> std<span>::</span>get_time(<span>&amp;</span>t, fmtstr);
</span></span><span><span>  <span>if</span> (ss.fail()) 
</span></span><span><span>    <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>  <span>// now fix up the day of week, day of year etc
</span></span></span><span><span><span></span>  t.tm_isdst <span>=</span> <span>0</span>; <span>// no thinking!
</span></span></span><span><span><span></span>  t.tm_wday <span>=</span> <span>-</span><span>1</span>;
</span></span><span><span>  <span>if</span>(mktime(<span>&amp;</span>t) <span>==</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> t.tm_wday <span>==</span> <span>-</span><span>1</span>) <span>// &#34;real error&#34;
</span></span></span><span><span><span></span>    <span>return</span> <span>-</span><span>1</span>;
</span></span><span><span>  
</span></span><span><span>  <span>*</span>output <span>=</span> t;
</span></span><span><span>  <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>This incidentally also shows how to do error handling for <code>mktime()</code>, which will helpfully return -1, <em>its error code</em>, if you ask it to look at 31st of December 1969 23:59. The trick is to employ <code>tm_wday</code> as a sentinel to see if anything was processed or not. This tells you there was no error.</p>
<p>There <a href="https://github.com/berthubert/utchelper/blob/main/utcparse.c">is also a small C-based demo of this code</a> that parses English UTC timestamps and prints them using the calling environment locale:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ LC_TIME<span>=</span><span>&#34;nl_NL.utf-8&#34;</span> ./utcparse <span>&#34;1 Jan 1970 00:00:00&#34;</span> <span>&#34;%d %b %Y %H:%M:%S&#34;</span>
</span></span><span><span>UTC Time: donderdag,  <span>1</span> januari <span>1970</span> 00:00:00, day of year <span>001</span>
</span></span><span><span>time_t:   <span>0</span>
</span></span></code></pre></div>
<p>C++20 and beyond contain a luxurious timezone database. This is not yet available on all compilers, but luckily the <a href="https://howardhinnant.github.io/date/tz.html">pre-standardized version</a> is available for standalone use. Sometimes we get lucky because someone sacrifices a few years of their life to give us some truly excellent code that we really don’t deserve, and Howard Hinnant clearly delivered.</p>
<p>Here is a glorious example:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>auto</span> meet_nyc <span>=</span> make_zoned(<span>&#34;America/New_York&#34;</span>, 
</span></span><span><span>	date<span>::</span>local_days{Monday[<span>1</span>]<span>/</span>May<span>/</span><span>2016</span>} <span>+</span> <span>9</span>h);
</span></span><span><span><span>auto</span> meet_lon <span>=</span> make_zoned(<span>&#34;Europe/London&#34;</span>,    meet_nyc);
</span></span><span><span><span>auto</span> meet_syd <span>=</span> make_zoned(<span>&#34;Australia/Sydney&#34;</span>, meet_nyc);
</span></span><span><span>cout <span>&lt;&lt;</span> <span>&#34;The New York meeting is &#34;</span> <span>&lt;&lt;</span> meet_nyc <span>&lt;&lt;</span> <span>&#39;\n&#39;</span>;
</span></span><span><span>cout <span>&lt;&lt;</span> <span>&#34;The London   meeting is &#34;</span> <span>&lt;&lt;</span> meet_lon <span>&lt;&lt;</span> <span>&#39;\n&#39;</span>;
</span></span><span><span>cout <span>&lt;&lt;</span> <span>&#34;The Sydney   meeting is &#34;</span> <span>&lt;&lt;</span> meet_syd <span>&lt;&lt;</span> <span>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>This picks “the first Monday of May 2016, 9AM local time in New York”, and then seamlessly converts this to two other timezones:</p>
<pre tabindex="0"><code>The New York meeting is 2016-05-02 09:00:00 EDT
The London   meeting is 2016-05-02 14:00:00 BST
The Sydney   meeting is 2016-05-02 23:00:00 AEST
</code></pre><p>Being truly luxurious, the tz library supports using not just your operating system’s time zone databases, which might lack crucial leap second detail, but can also source the IANA tzdb directly. This allows you to faithfully calculate the actual duration of a plane flight in 1978 that not only passed through a DST change, but also an actual leap second. I don’t swoon easily, <a href="https://howardhinnant.github.io/date/tz.html#Examples">but I’m swooning</a>.</p>

<ul>
<li><a href="https://ssoready.com/blog/engineering/truths-programmers-timezones/">Australia/Lord_Howe is the weirdest timezone</a></li>
<li><a href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">Falsehoods programmers believe about time</a> - in general I’m not a great fan of these “falsehoods programmers believe” posts. Programmers are not universal experts on the whole world, and we should not expect them to be. However, since time is very much our kind of jam, I do feel we should be getting this right.</li>
<li><a href="https://www.redhat.com/en/blog/brief-history-mktime">A brief history of mktime()</a>, including the very weird Ireland timezone situation.</li>
<li><a href="https://phpc.social/@derickr/113845974849351218">The guy who mentioned that Ireland situation</a>, and look where it got us.</li>
<li><a href="https://www.joda.org/joda-time/">Joda-Time</a> - a highly regarded Java time library that is now part of Java itself</li>
</ul>

</div>

  



</article></div>
  </body>
</html>
