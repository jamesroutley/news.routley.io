<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maplant.com/2025-02-17-Why-I%27m-Writing-a-Scheme-Implementation-in-2025-%28The-Answer-is-Async-Rust%29.html">Original</a>
    <h1>Why I&#39;m writing a Scheme implementation in 2025: Async Rust</h1>
    
    <div id="readability-page-1" class="page">
    
    
    
by Matthew Plant
<p>This blog post is an introduction to <a href="https://www.github.com/maplant/scheme-rs">scheme-rs</a>.</p>
<p>I really love Rust. I’ve been using it as my language of choice for about ten years now. I
believe that it is a remarkably well designed language, and that includes the parts that are
often most criticized, most notably async.</p>
<p>But while I thing that async Rust is well designed from the context of the space it occupies,
programming with it is not a particularly great experience once you finish your first draft
of code and want to start iterating. As soon as you run <code>cargo build</code>, inconveniences show:
slow compile times, inscrutable error messages with stack traces that are mostly just tokio
functions, and just overall a poor debugging experience make async Rust a frustrating
experience for rapid iteration.</p>
<p>The thing is, this experience is the result of conscious trade-offs, trade-offs that I believe
were chosen <em>correctly</em>. I don’t believe that async Rust necessarily needs to change at all,
although I don’t doubt that the experience could be improved. In my mind, what async Rust
really needs is a proper glue language. That’s where <code>scheme-rs</code> comes in.</p>
<p><code>Scheme-rs</code> is a work-in-progress implementation of <a href="https://www.r6rs.org/">R6RS</a> that allows
for seamless interoperability with async Rust. All you have to do is add <code>scheme-rs</code> to your
<code>Cargo.toml</code>, define some bridge functions with the provided proc macros, and <code>scheme-rs</code>
will provide you with a way to dynamically glue your code together, including allowing you to
provide a REPL for debugging, inspecting, or even orchestrating your system.</p>
<p>Why Scheme and not a new language? There are a couple of reasons, the first is that Scheme
strikes an excellent balance between having a small core and being extremely expressive.
Choosing Scheme lets one take advantage of the millions of lines of Scheme code already
written.</p>
<p>As an aside, R6RS happens to have the best macro system of any programming language ever.
Macros are hygienic by default but let you selectively break free from hygiene in a
remarkably clean way. Additionally, the homoiconic nature and ease of dealing with
s-expressions means you rarely have to do any complicated parsing or deal with ASTs. While
<code>scheme-rs</code> is very much still a WIP, it implements R6RS macros nearly perfectly, including
all of the necessary hygiene conditions and ways to bend them, including <code>syntax-case</code> and
<code>datum-&gt;syntax</code>.</p>
<p>The second reason I chose Scheme instead of a new language is that I <em>do</em> want to create a
new language, but I want to be built upon Scheme and to have it utilizes its beautiful
macro system and syntax while providing a stronger and more useful type system (in particular,
Hindley-Milner with sum types, type classes, and some form of limited subtyping (perhaps
<a href="https://blog.sigplan.org/2025/01/29/parametric-subtyping-for-structural-parametric-polymorphism/">Parametric Subtyping</a>)).</p>
<p>I call this theoretical language Gouki, and it would sit somewhere in the middle of <code>scheme-rs</code>
and Rust. Ideally you would write almost all of your code in Gouki, going down into Rust
when you need to do low-level stuff, and use Scheme occsionally whether it be via REPL or
incidentally (Gouki is intended to be a superset of Scheme, so every valid Scheme program
is a valid Gouki program).</p>
<p>Such a language is squarely in the design phase, but here’s a preview of what it might look
like:</p>
<pre>

<span>(</span><span>enum</span> <span>Option</span> <span>(</span><span>Some</span> <span>&#39;</span><span>a</span><span>)</span>
             <span>(</span><span>None</span><span>)</span><span>)</span>

<span>(</span><span>let</span> <span>(</span><span>[</span><span>x</span> <span>(</span><span>Some</span> 5<span>)</span><span>]</span><span>)</span>
    <span>(</span><span>match</span> <span>x</span>
       <span>(</span><span>(</span><span>Some</span> <span>y</span><span>)</span> <span>y</span><span>)</span>
       <span>(</span><span>(</span><span>None</span><span>)</span> <span>(</span><span>random</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>fn</span> <span>random</span> <span>(</span><span>)</span> <span>(</span><span>-&gt;</span> <span>&#39;</span><span>a</span><span>)</span>
    <span>(</span><span>where</span> <span>(</span><span>:</span> <span>&#39;</span><span>a</span> <span>Distribution</span><span>)</span><span>)</span>
    <span>(</span><span>sample</span> <span>(</span><span>thread-rng</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>class</span> <span>Eq</span> <span>(</span><span>self</span><span>)</span>
    <span>(</span><span>:</span> <span>=</span> <span>(</span><span>-&gt;</span> <span>self</span> <span>self</span> <span>bool</span><span>)</span><span>)</span><span>)</span>
    
<span>(</span><span>instance</span> <span>Eq</span> <span>(</span><span>Number</span><span>)</span>
    <span>(</span><span>fn</span> <span>=</span> <span>(</span><span>lhs</span> <span>rhs</span><span>)</span> <span>(</span><span>-&gt;</span> <span>Number</span> <span>Number</span> <span>bool</span><span>)</span>
        <span>(</span><span>num-equal</span> <span>lhs</span> <span>rhs</span><span>)</span><span>)</span><span>)</span>
</pre>
<p>So, I mentioned twice now that <code>scheme-rs</code> is a WIP, how close is it to being usable? Well,
in one sense it is usable right now. Besides missing a large number builtins, in terms of
core language features we’re currently missing <code>dynamic-wind</code>, error handling, and records
Additionally, the interface is a little bit clunky. But the bones are there: tail calls are
implemented properly, as is call-by-current-continuation, and as I mentioned earlier the macro
system is extremely robust. The hard work has been done, and now it’s just a matter of adding
features.</p>
<p>I spent my free time for the last month converting <code>scheme-rs</code> from an interpreter to a
compiler, one that converts the expanded Scheme program into a CPS mid-level IR, and then
to LLVM SSA for JIT compilation. This actually significantly slowed the performance of
<code>scheme-rs</code>, as the CPS and LLVM outputs are very poorly optimized. But I did not initiate
this huge re-architecture because it would be immediately faster, I initiated it because it
was necessary to eventually make <code>scheme-rs</code> competitive performance-wise with more mature
Scheme compilers like <code>ChezScheme</code>.</p>
<p>R6RS is a pretty massive spec, but I hope to complete it somewhat soon (although I started a new
job recently, so no idea what that really means), and after that I hope to focus on making the
compiler produce the best code as possible. In the mean time, I hope you consider taking a look
at <code>scheme-rs</code>, and contributing if you find the project interesting.</p>


  
</div>
  </body>
</html>
