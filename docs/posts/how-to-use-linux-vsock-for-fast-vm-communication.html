<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/how-to-use-linux-vsock-for-fast-vm-communication/">Original</a>
    <h1>How to use Linux vsock for fast VM communication</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p><a href="https://twitter.com/popovicu94?ref_src=twsrc%5Etfw" data-show-count="false">Follow @popovicu94</a></p>
<p>I’ve recently been experimenting with various ways to construct Linux VM images, but for these images to be practical, they need to interact with the outside world. At a minimum, they need to communicate with the host machine.</p>
<p><code>vsock</code> is a technology specifically designed with VMs in mind. It eliminates the need for a TCP/IP stack or network virtualization to enable communication with or between VMs. At the API level, it behaves like a standard socket but utilizes a specialized addressing scheme.</p>
<p>In the experiment below, we’ll explore using <code>vsock</code> as the transport mechanism for a gRPC service running on a VM. We’ll build this project with Bazel for easy reproducibility. Check out <a href="https://popovicu.com/posts/build-all-software-in-one-command-with-bazel/">this post</a> if you need an intro to Bazel.</p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li>
<p><a href="#motivation">Motivation</a></p>
</li>
<li>
<p><a href="#github-repo">GitHub repo</a></p>
</li>
<li>
<p><a href="#code-breakdown">Code breakdown</a></p>
<ul>
<li><a href="#external-dependencies">External dependencies</a></li>
<li><a href="#grpc-library-generation">gRPC library generation</a></li>
<li><a href="#server-implementation">Server implementation</a></li>
<li><a href="#client-implementation">Client implementation</a></li>
</ul>
</li>
<li>
<p><a href="#running-it-all-together">Running it all together</a></p>
</li>
<li>
<p><a href="#under-the-hood">Under the hood</a></p>
</li>
<li>
<p><a href="#conclusion">Conclusion</a></p>
</li>
</ul>
</details>
<h2 id="motivation">Motivation</h2>
<p>There are many use cases for efficient communication between a VM and its host (or between multiple VMs). One simple reason is to create a hermetic environment within the VM and issue commands via RPC from the host. This is the primary driver for using gRPC in this example, but you can easily generalize the approach shown here to build far more complex systems.</p>
<h2 id="github-repo">GitHub repo</h2>
<p>The complete repository is hosted <a href="https://github.com/popovicu/vsock-grpc">here</a> and serves as the source of truth for this experiment. While there may be minor inconsistencies between the code blocks below and the repository, please rely on GitHub as the definitive source.</p>
<h2 id="code-breakdown">Code breakdown</h2>
<p>Let’s break down the code step by step:</p>
<h3 id="external-dependencies">External dependencies</h3>
<p>Here are the external dependencies listed as Bazel modules:</p>
<pre is:raw="" tabindex="0"><code><span><span>bazel_dep</span><span>(</span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;rules_proto&#34;</span><span>, </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;7.1.0&#34;</span><span>)</span></span>
<span><span>bazel_dep</span><span>(</span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;rules_cc&#34;</span><span>, </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;0.2.14&#34;</span><span>)</span></span>
<span><span>bazel_dep</span><span>(</span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;protobuf&#34;</span><span>, </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;33.1&#34;</span><span>, </span><span>repo_name</span><span> </span><span>=</span><span> </span><span>&#34;com_google_protobuf&#34;</span><span>)</span></span>
<span><span>bazel_dep</span><span>(</span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;grpc&#34;</span><span>, </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;1.76.0.bcr.1&#34;</span><span>)</span></span></code></pre>
<p>This is largely self-explanatory. The <code>protobuf</code> repository is used for C++ proto-generation rules, and <code>grpc</code> provides the monorepo for Bazel rules to generate gRPC code for the C++ family of languages.</p>
<h3 id="grpc-library-generation">gRPC library generation</h3>
<p>The following Bazel targets generate the necessary C++ Protobuf and gRPC libraries:</p>
<pre is:raw="" tabindex="0"><code><span><span>load</span><span>(</span><span>&#34;@rules_proto//proto:defs.bzl&#34;</span><span>, </span><span>&#34;proto_library&#34;</span><span>)</span></span>
<span><span>load</span><span>(</span><span>&#34;@com_google_protobuf//bazel:cc_proto_library.bzl&#34;</span><span>, </span><span>&#34;cc_proto_library&#34;</span><span>)</span></span>
<span><span>load</span><span>(</span><span>&#34;@grpc//bazel:cc_grpc_library.bzl&#34;</span><span>, </span><span>&#34;cc_grpc_library&#34;</span><span>)</span></span>
<span></span>
<span><span>proto_library</span><span>(</span></span>
<span><span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;vsock_service_proto&#34;</span><span>,</span></span>
<span><span>    </span><span>srcs</span><span> </span><span>=</span><span> [</span><span>&#34;vsock_service.proto&#34;</span><span>],</span></span>
<span><span>)</span></span>
<span></span>
<span><span>cc_proto_library</span><span>(</span></span>
<span><span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;vsock_service_cc_proto&#34;</span><span>,</span></span>
<span><span>    </span><span>deps</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;:vsock_service_proto&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>visibility</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;//server:__subpackages__&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//client:__subpackages__&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>)</span></span>
<span></span>
<span><span>cc_grpc_library</span><span>(</span></span>
<span><span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;vsock_service_cc_grpc&#34;</span><span>,</span></span>
<span><span>    </span><span>grpc_only</span><span> </span><span>=</span><span> </span><span>True</span><span>,</span></span>
<span><span>    </span><span>srcs</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;:vsock_service_proto&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>deps</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;:vsock_service_cc_proto&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>visibility</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;//server:__subpackages__&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//client:__subpackages__&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>)</span></span></code></pre>
<p>The protocol definition is straightforward:</p>
<pre is:raw="" tabindex="0"><code><span><span>syntax = &#34;proto3&#34;;</span></span>
<span><span></span></span>
<span><span>package popovicu_vsock;</span></span>
<span><span></span></span>
<span><span>service VsockService {</span></span>
<span><span>  rpc Addition(AdditionRequest) returns (AdditionResponse) {}</span></span>
<span><span>}</span></span>
<span><span></span></span>
<span><span>message AdditionRequest {</span></span>
<span><span>  int32 a = 1;</span></span>
<span><span>  int32 b = 2;</span></span>
<span><span>}</span></span>
<span><span></span></span>
<span><span>message AdditionResponse {</span></span>
<span><span>  int32 c = 1;</span></span>
<span><span>}</span></span></code></pre>
<p>It simply exposes a service capable of adding two integers.</p>
<h3 id="server-implementation">Server implementation</h3>
<p>The <code>BUILD</code> file is straightforward:</p>
<pre is:raw="" tabindex="0"><code><span><span>load</span><span>(</span><span>&#34;@rules_cc//cc:defs.bzl&#34;</span><span>, </span><span>&#34;cc_binary&#34;</span><span>)</span></span>
<span></span>
<span><span>cc_binary</span><span>(</span></span>
<span><span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;server&#34;</span><span>,</span></span>
<span><span>    </span><span>srcs</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;server.cc&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>deps</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;@grpc//:grpc++&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//proto:vsock_service_cc_grpc&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//proto:vsock_service_cc_proto&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>linkstatic</span><span> </span><span>=</span><span> </span><span>True</span><span>,</span></span>
<span><span>    </span><span>linkopts</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;-static&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>)</span></span></code></pre>
<p>We want a statically linked binary to run on the VM. This choice simplifies deployment, allowing us to drop a single file onto the VM.</p>
<p>The code is largely self-explanatory:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;iostream&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;memory&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;string&gt;</span></span>
<span></span>
<span><span>#include</span><span> </span><span>&lt;grpc++/grpc++.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&#34;proto/vsock_service.grpc.pb.h&#34;</span></span>
<span></span>
<span><span>using</span><span> grpc::Server;</span></span>
<span><span>using</span><span> grpc::ServerBuilder;</span></span>
<span><span>using</span><span> grpc::ServerContext;</span></span>
<span><span>using</span><span> grpc::Status;</span></span>
<span><span>using</span><span> popovicu_vsock::VsockService;</span></span>
<span><span>using</span><span> popovicu_vsock::AdditionRequest;</span></span>
<span><span>using</span><span> popovicu_vsock::AdditionResponse;</span></span>
<span></span>
<span><span>// Service implementation</span></span>
<span><span>class</span><span> </span><span>VsockServiceImpl</span><span> </span><span>final</span><span> : </span><span>public</span><span> VsockService::</span><span>Service</span><span> {</span></span>
<span><span>  </span><span>Status</span><span> </span><span>Addition</span><span>(</span><span>ServerContext</span><span>*</span><span> </span><span>context</span><span>, </span><span>const</span><span> </span><span>AdditionRequest</span><span>*</span><span> </span><span>request</span><span>,</span></span>
<span><span>                  </span><span>AdditionResponse</span><span>*</span><span> </span><span>response</span><span>) </span><span>override</span><span> {</span></span>
<span><span>    </span><span>int32_t</span><span> result </span><span>=</span><span> </span><span>request</span><span>-&gt;</span><span>a</span><span>() </span><span>+</span><span> </span><span>request</span><span>-&gt;</span><span>b</span><span>();</span></span>
<span><span>    </span><span>response</span><span>-&gt;</span><span>set_c</span><span>(result);</span></span>
<span><span>    std::cout </span><span>&lt;&lt;</span><span> </span><span>&#34;Addition: &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>request</span><span>-&gt;</span><span>a</span><span>() </span><span>&lt;&lt;</span><span> </span><span>&#34; + &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>request</span><span>-&gt;</span><span>b</span><span>()</span></span>
<span><span>              </span><span>&lt;&lt;</span><span> </span><span>&#34; = &#34;</span><span> </span><span>&lt;&lt;</span><span> result </span><span>&lt;&lt;</span><span> std::endl;</span></span>
<span><span>    </span><span>return</span><span> Status::OK;</span></span>
<span><span>  }</span></span>
<span><span>};</span></span>
<span></span>
<span><span>void</span><span> </span><span>RunServer</span><span>() {</span></span>
<span><span>  // Server running on VM (guest)</span></span>
<span><span>  // vsock:-1:9999 means listen on port 9999, accept connections from any CID</span></span>
<span><span>  // CID -1 (VMADDR_CID_ANY) allows the host to connect to this VM server</span></span>
<span><span>  std::string </span><span>server_address</span><span>(</span><span>&#34;vsock:3:9999&#34;</span><span>);</span></span>
<span><span>  VsockServiceImpl service;</span></span>
<span></span>
<span><span>  ServerBuilder builder;</span></span>
<span><span>  </span><span>builder</span><span>.</span><span>AddListeningPort</span><span>(server_address, grpc::</span><span>InsecureServerCredentials</span><span>());</span></span>
<span><span>  </span><span>builder</span><span>.</span><span>RegisterService</span><span>(</span><span>&amp;</span><span>service);</span></span>
<span></span>
<span><span>  std::unique_ptr</span><span>&lt;</span><span>Server</span><span>&gt;</span><span> </span><span>server</span><span>(</span><span>builder</span><span>.</span><span>BuildAndStart</span><span>());</span></span>
<span><span>  std::cout </span><span>&lt;&lt;</span><span> </span><span>&#34;Server listening on &#34;</span><span> </span><span>&lt;&lt;</span><span> server_address </span><span>&lt;&lt;</span><span> std::endl;</span></span>
<span></span>
<span><span>  </span><span>server</span><span>-&gt;</span><span>Wait</span><span>();</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>() {</span></span>
<span><span>  </span><span>RunServer</span><span>();</span></span>
<span><span>  </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>The only part requiring explanation is the <code>server_address</code>. The <code>vsock:</code> prefix indicates that we’re using <code>vsock</code> as the transport layer. gRPC supports various transports, including TCP/IP and Unix sockets.</p>
<p>The number <code>3</code> is the CID, or <strong>Context ID</strong>. This functions similarly to an IP address. Certain CIDs have special meanings. For instance, CID 2 represents the VM host itself; if the VM needs to connect to a <code>vsock</code> socket on the host, it targets CID 2. CID 1 is reserved for the loopback address. Generally, VMs are assigned CIDs starting from 3.</p>
<p>The <code>9999</code> is simply the port number, functioning just as it does in TCP/IP.</p>
<h3 id="client-implementation">Client implementation</h3>
<p>The <code>BUILD</code> file is, again, quite simple:</p>
<pre is:raw="" tabindex="0"><code><span><span>load</span><span>(</span><span>&#34;@rules_cc//cc:defs.bzl&#34;</span><span>, </span><span>&#34;cc_binary&#34;</span><span>)</span></span>
<span></span>
<span><span>cc_binary</span><span>(</span></span>
<span><span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;client&#34;</span><span>,</span></span>
<span><span>    </span><span>srcs</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;client.cc&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>deps</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;@grpc//:grpc++&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//proto:vsock_service_cc_grpc&#34;</span><span>,</span></span>
<span><span>        </span><span>&#34;//proto:vsock_service_cc_proto&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>    </span><span>linkstatic</span><span> </span><span>=</span><span> </span><span>True</span><span>,</span></span>
<span><span>    </span><span>linkopts</span><span> </span><span>=</span><span> [</span></span>
<span><span>        </span><span>&#34;-static&#34;</span><span>,</span></span>
<span><span>    ],</span></span>
<span><span>)</span></span></code></pre>
<p>And the C++ code:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;iostream&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;memory&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;string&gt;</span></span>
<span></span>
<span><span>#include</span><span> </span><span>&lt;grpc++/grpc++.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&#34;proto/vsock_service.grpc.pb.h&#34;</span></span>
<span></span>
<span><span>using</span><span> grpc::Channel;</span></span>
<span><span>using</span><span> grpc::ClientContext;</span></span>
<span><span>using</span><span> grpc::Status;</span></span>
<span><span>using</span><span> popovicu_vsock::VsockService;</span></span>
<span><span>using</span><span> popovicu_vsock::AdditionRequest;</span></span>
<span><span>using</span><span> popovicu_vsock::AdditionResponse;</span></span>
<span></span>
<span><span>class</span><span> </span><span>VsockClient</span><span> {</span></span>
<span><span> </span><span>public:</span></span>
<span><span>  </span><span>VsockClient</span><span>(std::</span><span>shared_ptr</span><span>&lt;</span><span>Channel</span><span>&gt; </span><span>channel</span><span>)</span></span>
<span><span>      : </span><span>stub_</span><span>(</span><span>VsockService</span><span>::</span><span>NewStub</span><span>(channel)) {}</span></span>
<span></span>
<span><span>  </span><span>int32_t</span><span> </span><span>Add</span><span>(</span><span>int32_t</span><span> </span><span>a</span><span>, </span><span>int32_t</span><span> </span><span>b</span><span>) {</span></span>
<span><span>    AdditionRequest request;</span></span>
<span><span>    </span><span>request</span><span>.</span><span>set_a</span><span>(a);</span></span>
<span><span>    </span><span>request</span><span>.</span><span>set_b</span><span>(b);</span></span>
<span></span>
<span><span>    AdditionResponse response;</span></span>
<span><span>    ClientContext context;</span></span>
<span></span>
<span><span>    Status status </span><span>=</span><span> </span><span>stub_</span><span>-&gt;</span><span>Addition</span><span>(</span><span>&amp;</span><span>context, request, </span><span>&amp;</span><span>response);</span></span>
<span></span>
<span><span>    </span><span>if</span><span> (</span><span>status</span><span>.</span><span>ok</span><span>()) {</span></span>
<span><span>      </span><span>return</span><span> </span><span>response</span><span>.</span><span>c</span><span>();</span></span>
<span><span>    } </span><span>else</span><span> {</span></span>
<span><span>      std::cout </span><span>&lt;&lt;</span><span> </span><span>&#34;RPC failed: &#34;</span><span> </span><span>&lt;&lt;</span><span> </span><span>status</span><span>.</span><span>error_code</span><span>() </span><span>&lt;&lt;</span><span> </span><span>&#34;: &#34;</span></span>
<span><span>                </span><span>&lt;&lt;</span><span> </span><span>status</span><span>.</span><span>error_message</span><span>() </span><span>&lt;&lt;</span><span> std::endl;</span></span>
<span><span>      </span><span>return</span><span> </span><span>-</span><span>1</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span></span>
<span><span> </span><span>private:</span></span>
<span><span>  std::unique_ptr</span><span>&lt;</span><span>VsockService::Stub</span><span>&gt;</span><span> stub_;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>() {</span></span>
<span><span>  // Client running on host, connecting to VM server</span></span>
<span><span>  // vsock:3:9999 means connect to CID 3 (guest VM) on port 9999</span></span>
<span><span>  // CID 3 is an example - adjust based on your VM&#39;s actual CID</span></span>
<span><span>  std::string </span><span>server_address</span><span>(</span><span>&#34;vsock:3:9999&#34;</span><span>);</span></span>
<span></span>
<span><span>  VsockClient </span><span>client</span><span>(</span></span>
<span><span>      grpc::</span><span>CreateChannel</span><span>(server_address, grpc::</span><span>InsecureChannelCredentials</span><span>()));</span></span>
<span></span>
<span><span>  </span><span>int32_t</span><span> a </span><span>=</span><span> </span><span>5</span><span>;</span></span>
<span><span>  </span><span>int32_t</span><span> b </span><span>=</span><span> </span><span>7</span><span>;</span></span>
<span><span>  </span><span>int32_t</span><span> result </span><span>=</span><span> </span><span>client</span><span>.</span><span>Add</span><span>(a, b);</span></span>
<span></span>
<span><span>  std::cout </span><span>&lt;&lt;</span><span> </span><span>&#34;Addition result: &#34;</span><span> </span><span>&lt;&lt;</span><span> a </span><span>&lt;&lt;</span><span> </span><span>&#34; + &#34;</span><span> </span><span>&lt;&lt;</span><span> b </span><span>&lt;&lt;</span><span> </span><span>&#34; = &#34;</span><span> </span><span>&lt;&lt;</span><span> result</span></span>
<span><span>            </span><span>&lt;&lt;</span><span> std::endl;</span></span>
<span></span>
<span><span>  </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<h2 id="running-it-all-together">Running it all together</h2>
<p>Bazel shines here. You only need a working C++ compiler on your host system. Bazel automatically fetches and builds everything else on the fly, including the Protobuf compiler.</p>
<p>To get the statically linked server binary:</p>
<pre is:raw="" tabindex="0"><code><span><span>bazel</span><span> </span><span>build</span><span> </span><span>//server</span></span></code></pre>
<p>Similarly, for the client:</p>
<pre is:raw="" tabindex="0"><code><span><span>bazel</span><span> </span><span>build</span><span> </span><span>//client</span></span></code></pre>
<p>To create a VM image, I used <code>debootstrap</code> on an <code>ext4</code> image, as described in this post on X:</p>
<blockquote><p dir="ltr" lang="en">Stop downloading 4GB ISOs to create Linux VMs.</p>— Uros Popovic (@popovicu94) <a href="https://twitter.com/popovicu94/status/1993165606997156077?ref_src=twsrc%5Etfw">November 25, 2025</a></blockquote> 
<p>This is a quick, albeit hacky, solution for creating a runnable Debian instance.</p>
<p>Next, I copied the newly built server binary to <code>/opt</code> within the image.</p>
<p>Now, the VM can be booted straight into the server binary as soon as the kernel runs:</p>
<pre is:raw="" tabindex="0"><code><span><span> qemu-system-x86_64 -m 1G -kernel /tmp/linux/linux-6.17.2/arch/x86/boot/bzImage \</span></span>
<span><span>  -nographic \</span></span>
<span><span>  -append &#34;console=ttyS0 init=/opt/server root=/dev/vda rw&#34; \</span></span>
<span><span>  --enable-kvm \</span></span>
<span><span>  -smp 8 \</span></span>
<span><span>  -drive file=./debian.qcow2,format=qcow2,if=virtio -device vhost-vsock-pci,guest-cid=3</span></span></code></pre>
<p>As shown in the last line, a virtual device is attached to the QEMU VM acting as <code>vsock</code> networking hardware, configured with CID 3.</p>
<p>The QEMU output shows:</p>
<pre is:raw="" tabindex="0"><code><span><span>[    1.581192] Run /opt/server as init process</span></span>
<span><span>[    1.889382] random: crng init done</span></span>
<span><span>Server listening on vsock:3:9999</span></span></code></pre>
<p>To send an RPC to the server from the host, I ran the client binary:</p>
<pre is:raw="" tabindex="0"><code><span><span>bazel run //client</span></span></code></pre>
<p>The output confirmed the result:</p>
<pre is:raw="" tabindex="0"><code><span><span>Addition result: 5 + 7 = 12</span></span></code></pre>
<p>Correspondingly, the server output displayed:</p>
<pre is:raw="" tabindex="0"><code><span><span>Addition: 5 + 7 = 12</span></span></code></pre>
<p>We have successfully invoked an RPC from the host to the VM!</p>
<h2 id="under-the-hood">Under the hood</h2>
<p>I haven’t delved into the low-level system API for <code>vsock</code>s, as frameworks typically abstract this away. However, <code>vsock</code>s closely resemble TCP/IP sockets. Once created, they are used in the same way, though the creation API differs. Information on this is readily available online.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I believed it was more valuable to focus on a high-level RPC system over <code>vsock</code> rather than raw sockets. With gRPC, you can invoke a structured RPC on a server running inside the VM. This opens the door to running interesting applications in sealed, isolated environments, allowing you to easily combine different OSes (e.g., a Debian host and an Arch guest) or any platform supporting <code>vsock</code>. Additionally, gRPC allows you to write clients and servers in many different languages and technologies. This is achieved without network virtualization, resulting in increased efficiency.</p>
<p>I hope this was fun and useful to you as well.</p>
<p>Please consider following me on <a href="https://x.com/popovicu94">X</a> and <a href="https://www.linkedin.com/in/upopovic/">LinkedIn</a> for further updates.</p>
    </article></div>
  </body>
</html>
