<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://airbus-seclab.github.io/qemu_blog/">Original</a>
    <h1>QEMU Internals (2021)</h1>
    
    <div id="readability-page-1" class="page"><section>

      

<p>This is a series of posts about <strong>QEMU internals</strong>. It won’t cover
everything about QEMU, but should help you understand how it works and
foremost how to hack into it for fun and profit.</p>

<p>We won’t explain usage and other things that can be found in the
official documentation. The following topics will be addressed:</p>

<ul>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/machine.html">Creating a new machine</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/regions.html">Controlling memory regions</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/devices.html">Creating a new device</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/interrupts.html">Interrupts controller</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/timers.html">Timers</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/pci.html">PCI controller</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/pci_slave.html">PCI devices</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/options.html">Options</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/exec.html">Execution loop</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/brk.html">Breakpoints handling</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/runstate.html">VM running states</a></li>
  <li>TCG internals <a href="https://airbus-seclab.github.io/qemu_blog/tcg_p1.html">part 1</a>, <a href="https://airbus-seclab.github.io/qemu_blog/tcg_p2.html">part 2</a> and <a href="https://airbus-seclab.github.io/qemu_blog/tcg_p3.html">part 3</a></li>
  <li><a href="https://airbus-seclab.github.io/qemu_blog/snapshot.html">Snapshots</a></li>
</ul>

<p>The official code and documentation can be found here:</p>

<ul>
  <li>https://github.com/qemu/qemu</li>
  <li>https://www.qemu.org/documentation/</li>
</ul>



<h2 id="host-and-target">Host and target</h2>

<p>The host is the plaform and architecture which QEMU is running
on. Usually an x86 machine.</p>

<p>The target is the architecture which is emulated by QEMU. You can
choose at build time which one you want:</p>

<div><div><pre><code>./configure --target-list=ppc-softmmu ...
</code></pre></div></div>

<p>As such, in the source code organisation you will find all supported
architectures in the <code>target/</code> directory:</p>

<div><div><pre><code>(qemu-git) ll target
drwxrwxr-x 2 xxx xxx 4.0K alpha
drwxrwxr-x 2 xxx xxx 4.0K arm
drwxrwxr-x 2 xxx xxx 4.0K cris
drwxrwxr-x 2 xxx xxx 4.0K hppa
drwxrwxr-x 3 xxx xxx 4.0K i386
drwxrwxr-x 2 xxx xxx 4.0K lm32
drwxrwxr-x 2 xxx xxx 4.0K m68k
drwxrwxr-x 2 xxx xxx 4.0K microblaze
drwxrwxr-x 2 xxx xxx 4.0K mips
drwxrwxr-x 2 xxx xxx 4.0K moxie
drwxrwxr-x 2 xxx xxx 4.0K nios2
drwxrwxr-x 2 xxx xxx 4.0K openrisc
drwxrwxr-x 3 xxx xxx 4.0K ppc
drwxr-xr-x 3 xxx xxx 4.0K riscv
drwxrwxr-x 2 xxx xxx 4.0K s390x
drwxrwxr-x 2 xxx xxx 4.0K sh4
drwxrwxr-x 2 xxx xxx 4.0K sparc
drwxrwxr-x 2 xxx xxx 4.0K tilegx
drwxrwxr-x 2 xxx xxx 4.0K tricore
drwxrwxr-x 2 xxx xxx 4.0K unicore32
drwxrwxr-x 9 xxx xxx 4.0K xtensa
</code></pre></div></div>

<p>The <code>qemu-system-&lt;target&gt;</code> binaries are built into their respective <code>&lt;target&gt;-softmmu</code> directory:</p>

<div><div><pre><code>(qemu-git) ls -ld *-softmmu
drwxr-xr-x  9 xxx xxx 4096 i386-softmmu
drwxrwxr-x 11 xxx xxx 4096 ppc-softmmu
drwxr-xr-x  9 xxx xxx 4096 x86_64-softmmu
</code></pre></div></div>

<h2 id="system-and-user-modes">System and user modes</h2>

<p>QEMU is a system emulator. It offers emulation of a lot of
architectures and can be run on a lot of architectures.</p>

<p>It is able to emulate a full system (cpu, devices, kernel and apps)
through the <code>qemu-system-&lt;target&gt;</code> command line tool. This is the mode we
will dive into.</p>

<p>It also provides a <em>userland</em> emulation mode through the <code>qemu-&lt;target&gt;</code>
command line tool.</p>

<p>This allows to directly run <code>&lt;target&gt;</code> architecture Linux binaries on
a Linux host. It mainly emulates <code>&lt;target&gt;</code> instructions set and
forward system calls to the host Linux kernel. The emulation is only
related to user level cpu instructions, not system ones, no device
nore low level memory handling.</p>

<p>We won’t cover qemu user mode in this blog post series.</p>

<h2 id="emulation-jit-and-virtualization">Emulation, JIT and virtualization</h2>

<p>Initially QEMU was an emulation engine, with a Just-In-Time compiler
(TCG). The TCG is here to dynamically translate <code>target</code> instruction
set architecture (ISA) to <code>host</code> ISA.</p>

<p>We will later see that in the context of the TCG, the <code>tcg-target</code>
becomes the architecture to which the TCG has to generate final
assembly code to run on (which is host ISA). Obvious !</p>

<p>There exists scenario where <code>target</code> and <code>host</code> architectures are the
same. This is typically the case in classical virtualization
environment (VMware, VirtualBox, …) when a user wants to run Windows
on Linux for instance. The terminology is usually Host and Guest
(<em>target</em>).</p>

<p>Nowadays, QEMU offers virtualization through different
<strong>accelerators</strong>. Virtualization is considered an accelerator because
it prevents unneeded emulation of instructions when host and target
share the same architecture. Only system level (aka
<em>supervisor/ring0</em>) instructions might be emulated/intercepted.</p>

<p>Of course, the QEMU virtualization capabilities are tied to the host
OS and architecture. The x86 architecture offers hardware
virtualization extensions (Intel VMX/AMD SVM). But the host operating
system must allow QEMU to take benefit of them.</p>

<p>Under an x86-64 Linux host, we found the following accelerators:</p>

<div><div><pre><code>$ qemu-system-x86_64 -accel ?
Possible accelerators: kvm, xen, hax, tcg
</code></pre></div></div>

<p>While on an x86-64 MacOS host:</p>

<div><div><pre><code>$ qemu-system-x86_64 -accel ?
Possible accelerators: tcg, hax, hvf
</code></pre></div></div>

<p>The supported accelerators can be found in
<a href="https://github.com/qemu/qemu/tree/v4.2.0/cpus.c#L2134"><code>qemu_init_vcpu()</code></a>:</p>

<div><div><pre><code><span>void</span> <span>qemu_init_vcpu</span><span>(</span><span>CPUState</span> <span>*</span><span>cpu</span><span>)</span>
<span>{</span>
<span>...</span>
    <span>if</span> <span>(</span><span>kvm_enabled</span><span>())</span> <span>{</span>
        <span>qemu_kvm_start_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>hax_enabled</span><span>())</span> <span>{</span>
        <span>qemu_hax_start_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>hvf_enabled</span><span>())</span> <span>{</span>
        <span>qemu_hvf_start_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>tcg_enabled</span><span>())</span> <span>{</span>
        <span>qemu_tcg_init_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>whpx_enabled</span><span>())</span> <span>{</span>
        <span>qemu_whpx_start_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>qemu_dummy_start_vcpu</span><span>(</span><span>cpu</span><span>);</span>
    <span>}</span>
<span>...</span>
<span>}</span>
</code></pre></div></div>

<p>To make it short:</p>

<ul>
  <li><code>kvm</code> is the <em>Linux Kernel-based Virtual Machine</em> accelerator;</li>
  <li><code>hvf</code> is the MacOS <em>Hypervisor.framework</em> accelerator;</li>
  <li><code>hax</code> is the cross-platform Intel HAXM accelerator;</li>
  <li><code>whp</code> is the <em>Windows Hypervisor Platform</em> accelerator.</li>
</ul>

<p>You can take benefit of the speed of x86 hardware virtualization under
the three major operating systems. Notice that the TCG is also
considered an accelerator. We can enter a long debate about
terminology here …</p>

<h2 id="qemu-apis">QEMU APIs</h2>

<p>There exists a lot of APIs in QEMU, some are obsolete and not well
documented. Reading the source code still remains your best
option. There is a good overview
<a href="https://habkost.net/posts/2016/11/incomplete-list-of-qemu-apis.html">available</a>.</p>

<p>The posts series will mainly address QOM, qdev and VMState. The QOM is
the more abstract one. While QEMU is developped in C language, the
developpers chose to implement the QEMU Object Model to provide a
framework for registering user creatable types and instantiating
objects from those types: device, machine, cpu, … People used to
<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>
concepts will find their mark in the QOM.</p>

<p>We will briefly illustrate how to make use of it, but won’t detail its
underlying implementation. Stay pragmatic !</p>

<p>The interested reader can have a look at
<a href="https://github.com/qemu/qemu/tree/v4.2.0/include/qom/object.h">include/qom/object.h</a>.</p>



<p>It shall be noted that Airbus does not commit itself on the
exhaustiveness and completeness regarding this blog post series. The
information presented here results from the author knowledge and
understandings as of <a href="https://github.com/qemu/qemu/tree/v4.2.0">QEMU
v4.2.0</a>.</p>


      </section></div>
  </body>
</html>
