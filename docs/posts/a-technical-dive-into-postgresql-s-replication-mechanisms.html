<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://airbyte.com/blog/a-guide-to-logical-replication-and-cdc-in-postgresql">Original</a>
    <h1>A Technical Dive into PostgreSQL&#39;s replication mechanisms</h1>
    
    <div id="readability-page-1" class="page"><div id="blog-content" fs-richtext-element="rich-text" fs-toc-element="contents-3" fs-toc-offsettop="6rem" fs-codehighlight-element="code" fs-codehighlight-theme="base16/harmonic16-dark"><p>PostgreSQL is a database that needs no introduction. Started as an <a href="https://dsf.berkeley.edu/papers/ERL-M85-95.pdf">open-source project</a> out of UC Berkeley, it has evolved through decades of careful stewardship to become one of the world’s most relied on and <a href="https://db-engines.com/en/blog_post/106#:~:text=PostgreSQL%20is%20the%20database%20management,DBMS%20of%20the%20Year%202023.">beloved relational database management systems</a> (RDBMS). </p><p>There will inevitably come a time when the data captured and stored in your PostgreSQL database needs to exist somewhere else. Perhaps you need to replicate data between Postgres servers, to ensure your system survives a critical failure or heavy spikes in traffic. Alternatively, you may need to move your data to an environment better suited for data analysis and activation.</p><p>In this blog, we’ll look at how to satisfy both of these requirements using logical replication. We’ll review the internal mechanisms that enable replication in PostgreSQL, compare different types of replication, and finally, provide a guide to efficiently replicate your data between Postgres instances and other data stores.</p><p>Let’s jump right in!</p><p>‍</p><h2><strong>What is Database Replication?</strong></h2><p>Database replication is the process of copying and maintaining database objects (in our case today, tables), in multiple locations. This can happen synchronously or asynchronously, at the byte, block, or logical level, and is crucial for high availability, load balancing, and data activation.</p><p>Replication in PostgreSQL is handled by several processes and features. We’ll discuss how these components work below.</p><h2>‍</h2><p>‍</p><p>The first component to know is the Write-Ahead Log (WAL). The idea behind the WAL is that changes to data files (eg. tables, indexes) must be written to disk only after those changes have been logged. The WAL, then, is that log - an append-only ledger that records every change in the database. </p><p>Using a WAL comes with a few benefits. It ensures PostgreSQL can recover from a crash, even if the crash occurs in the middle of a transaction. It also allows for point-in-time recovery, and helps optimize I/O operations.</p><p>WAL records are created every time a table’s contents are modified. They are first written to the WAL buffer (whose size is determined by the wal_buffers settings). By writing to memory first, PostgreSQL can optimize and reduce the number of disk I/O operations. When the buffer is full, the data is flushed to disk as a WAL segment.</p><p>Each WAL record entry describes a change at the byte or block level in the database. The insert position of the record is described by its Log Sequence Number (LSN), a byte offset that increases with each new record. WAL files are stored in the pg_wal directory, and are a maximum of 16 MB by default (though this is configurable). </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/659dca76cbff9097fc9d4bb5_IiGEuiM1EkpyLRrRV9Fis_J3D3AlVPE2qrZxXLd9ULM83TzJH7fVTVDjESYL9NFdecMtBNOzPaTyRJ25KunVpvVq0A_9GVLYWhti2BVgeqiuLcG7BqbRebp7n-xGi69lC9tj-83zWdFOzZBIV2iYeAdN1B002ZVKcESBqyysacrF5kl_YeHnZzsKrO-BdA.png" alt=""/></p><figcaption><em>How incoming data and WAL records move through PostgreSQL<br/></em></figcaption></figure><p>Through the process of <strong>logical decoding</strong>, WAL files can be turned into a readable format that represents high-level database operations like INSERT, UPDATE, and DELETE. So, for example, the record might originally say “byte A in file B was changed to C”, but through the process of logical decoding, it can be read as “row R in table T was updated to value V”. These logical change records can be “published” by a database instance to “subscribers”. After WAL records are flushed to the publisher’s disk, the <strong>WAL Sender Process</strong> streams the committed WAL segment data to the subscribed standby servers. This, in a (rather large) nutshell, is how <strong>CDC replication</strong> works in PostgreSQL.<br/></p><p>A PostgreSQL database can only have so many subscribers. The relationship between publisher and subscriber is mediated by PostgreSQL’s replication slots. <strong>Replication slots</strong> are a persistent data structure used to track the progress of replication across subscribers, and to ensure that WAL data needed for replication is not prematurely removed (or recycled). They work by storing the LSN of the WAL record most recently received by each subscriber. When a replication slot is active, PostgreSQL will retain all relevant WAL segments that are necessary for the subscriber to stay in sync with the publisher - even if they are older than the retention policy would normally allow. This guarantees that the subscriber can always catch up, and prevents data loss due to missing WAL segments.</p><p>There are two kinds of replication slots in PostgreSQL - physical (for physical replication) and logical (for logical replication). Let’s take a moment to distinguish between the two types of replication, before we cover how to implement CDC between Postgres servers and other data stores.</p><p><strong>Physical vs Logical Replication</strong></p><p>Replication in PostgreSQL is either physical or logical. <strong>Physical replication </strong>is at the byte-level. The exact binary data from the master server’s disk are copied to the replica (including, but not limited to, the WAL). Physical replication is typically used when setting up a master-replica architecture. Physical replication in Postgres has native support for streaming, making it useful for setups that ensure high availability via standby servers.</p><p>‍<strong>Logical replication</strong>, on the other hand, is at the transaction level. Rather than copying bytes off the disk, the logical change records (detailing INSERTs, UPDATEs, DELETEs) are copied over. Because it’s at the logic level, filters can be applied to only replicate specific tables, rows or columns, making it much more flexible than physical replication. Logical replication is ideal for syncing your transactional data to a data lake or data warehouse. Both approaches are suitable for read-replica load-balancing, though logical replication introduces <strong>replication lag. </strong></p><p>It’s important to note that when using logical replication, the database schema and DDL commands are not replicated. Schema changes must be kept in sync manually. When the schema between producer and subscriber are out of sync, the replication process will error - this can be avoided by applying any additive schema changes to the subscriber first.</p><p>We’ll first look at how to replicate PostgreSQL data between two or more PostgreSQL servers, otherwise known as <strong>master-replica logical replication</strong>. Then, we’ll cover how to replicate PostgreSQL data to OLAP environments for further processing and analysis using Airbyte.</p><h2>‍</h2><p>Load-balancing read requests to replicas is a common approach to reduce the load on your primary database. In this guide, we’ll look at how to implement the master-replica (or <strong>primary-standby</strong>) pattern using logical replication. In this case, the primary is the publishing PostgreSQL database, while the standbys are subscribers. This approach is only suitable for workloads without hard real-time requirements, as there will always be some degree of replication lag when implementing logical replication. </p><p>2. Create a user role with replication privileges with the following command:</p><div><pre><code>CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD &#39;password&#39;;</code></pre></div><p>3. Edit the `pg_hba.conf` file to allow the replication role to connect from the replicas’ IP addresses.</p><p>4. Create a Publication on the primary using the following command:</p><p>5. Next, on each standby server, create a subscription with the following command:</p><div><pre><code>CREATE SUBSCRIPTION my_subscription
CONNECTION &#39;host=master_ip dbname=db_name user=replicator password=password&#39;
PUBLICATION my_publication;
</code></pre></div><p>Before creating your subscription, you may want to initialize the standby’s database with a snapshot of the primary’s data. This can be achieved with `pg_dump` and `pg_restore`, Postgres utilities for backup and restoration.</p><p>The above approach is well-suited for PostgreSQL-to-PostgreSQL replication. But what if you need your data in a centralized environment more suitable for analysis?</p><p>Several tools exist to help you extract and replicate your data out of PostgreSQL and into analytical stores through logical replication. In the next section, we’ll look at how to do so with Airbyte, the open-source standard for data movement. </p><h2><strong>Replicating Data Between PostgreSQL and External Data Stores with Airbyte</strong></h2><p>Airbyte works by providing two connectors - a source connector and a destination connector. These connectors can then create a connection, which is your EL pipeline. Many connectors in the Airbyte catalog are community built and maintained. The PostgreSQL source connector is <a href="https://docs.airbyte.com/integrations/connector-support-levels">certified</a>, meaning the Airbyte team maintains the connector, and provides a production-readiness guarantee. You can expect excellent performance as well - check out our <a href="https://airbyte.com/blog/postgres-replication-performance-benchmark-airbyte-vs-fivetran">replication benchmark against Fivetran</a> to learn more.</p><p>To begin replicating your PostgreSQL database, start with steps 1 and 2 from above. Create a replication slot on your Postgres database to track changes you want to sync. Then, create publication and replication identities for each Postgres table you want to replicate. <strong>Publication identities</strong> specify the set of tables (and, optionally, specific rows within those tables) whose changes you want to publish. <strong>Replication identities </strong>are configurations on the replica side that determine how the replicated data should be handled or applied.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6064b31ff49a2d31e0493af1/659ef1d5afd88cc238260c8e_Screenshot%202024-01-10%20at%2011.35.42%E2%80%AFAM.png" loading="lazy" alt=""/></p><figcaption><em>A look at the Airbyte UI for setting up a PostgreSQL source connector</em></figcaption></figure><p>From there, it’s as simple as walking through Airbyte’s UI to set up your PostgreSQL source connector, and a destination connector (for example, <a href="https://docs.airbyte.com/integrations/destinations/bigquery">BigQuery</a>, <a href="https://docs.airbyte.com/integrations/destinations/snowflake">Snowflake</a>, or <a href="https://docs.airbyte.com/integrations/destinations/redshift">Redshift</a>). For a more detailed walkthrough, check out our <a href="https://docs.airbyte.com/integrations/sources/postgres">documentation</a>.</p><h2>‍<strong>Replicating Data Between Neon and External Data Stores with Airbyte</strong></h2><p>Effectively managing and scaling PostgreSQL deployments in the cloud can be expensive and impractical for smaller teams. Several companies now offer Postgres database maintenance with cloud-native scalability. <a href="https://neon.tech/">Neon</a> is one such platform for serverless PostgreSQL. It comes with features you’d expect from a managed cloud solution, like autoscaling and the separation of compute and storage, but also supports advanced features like <a href="https://neon.tech/branching">database branching</a>.</p><p>Neon recently added support for <a href="https://neon.tech/blog/change-data-capture-with-serverless-postgres">logical replication</a>, and is fully-compatible with Airbyte’s CDC solution. Pairing a cloud database like Neon with Airbyte’s own managed offering, Airbyte Cloud, can deliver a scalable, reliable, and low-cost solution for your OLTP and replication needs.</p><p>To get started, check out Neon’s <a href="https://neon.tech/docs/guides/logical-replication-airbyte">documentation</a> on connecting to Airbyte. </p><h2>Final Thoughts</h2><p>Before signing off, let’s take a quick look at some WAL configurations you’ll want to keep in mind when configuring your logical replication setup.</p><p>- <strong>`wal_compression`</strong> is a setting that can minimize the impact of WAL accumulation between Airbyte syncs. As mentioned, once a replication slot is filled, WAL records are kept around until they are successfully published to the subscriber. If there is significant time between syncs and you are storage-conscientious, setting a `wal_compression` policy will save you on space at the cost of some extra CPU.</p><p>PostgreSQL is a time- and battle-tested workhorse. Its robust community, dedicated contributors, and flexible feature-set make it an excellent choice for a wide range of use cases. </p><p>Today, we’ve examined how PostgreSQL implements logical replication, as well as how Airbyte can be used in your CDC replication setup. We hope you found this guide informative. If you liked this content, share it with a friend, or reach out to us on LinkedIn. We’d love to hear from you!</p><p>Until next time.</p><h2>‍</h2><ul role="list"><li><a href="https://www.postgresql.org/docs/current/different-replication-solutions.html">https://www.postgresql.org/docs/current/different-replication-solutions.html</a></li><li><a href="https://www.postgresql.org/docs/current/wal-internals.html">https://www.postgresql.org/docs/current/wal-internals.html</a></li><li><a href="https://www.postgresql.org/docs/current/logical-replication.html">https://www.postgresql.org/docs/current/logical-replication.html</a></li><li><a href="https://www.postgresql.org/docs/16/runtime-config-replication.html">https://www.postgresql.org/docs/16/runtime-config-replication.html</a></li></ul></div></div>
  </body>
</html>
