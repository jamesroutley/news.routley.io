<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pytorch.org/blog/introducing-pytorch-monarch/">Original</a>
    <h1>PyTorch Monarch</h1>
    
    <div id="readability-page-1" class="page"><div>

            
            <div role="main">

            
<article id="post-5523">
  
  <div>

		<div data-hide-featured-media="1">
      
        <div><p><span>We now live in a world where ML workflows (pre-training, post training, etc) are heterogeneous, must contend with hardware failures, are increasingly asynchronous and highly dynamic. Traditionally, PyTorch has relied on an HPC-style  multi-controller model, where multiple copies of the same script are launched across different machines, each running its own instance of the application (often referred to as SPMD). ML workflows are becoming more complex: pre-training might combine advanced parallelism with asynchrony and partial failure; while RL models used in post-training require a high degree of dynamism with complex feedback loops.  While the logic of these workflows may be relatively straightforward, they are notoriously difficult to implement well in a multi-controller system, where each node must decide how to act based on only a local view of the workflow’s state.</span></p>
<p><img fetchpriority="high" decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/1-2.png" alt="" width="1600" height="680" srcset="https://pytorch.org/wp-content/uploads/2025/10/1-2.png 1600w, https://pytorch.org/wp-content/uploads/2025/10/1-2-300x128.png 300w, https://pytorch.org/wp-content/uploads/2025/10/1-2-1024x435.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></p>
<p><span>We believe that the long-term sustainable way to address this is through a </span><i><span>single controller</span></i><span> programming model, in which a single script orchestrates all distributed resources, making them feel almost local. This architectural shift simplifies distributed programming—your code looks and feels like a single-machine Python program, but can scale across thousands of GPUs. You can directly use Pythonic constructs—classes, functions, loops, tasks, futures—to express complex distributed algorithms.</span></p>
<p><span>We’re excited to introduce </span><b>Monarch</b><span>, a distributed programming framework that brings the simplicity of single-machine PyTorch to entire clusters.</span></p>
<p><span>Monarch lets you program distributed systems the way you’d program a single machine, hiding the complexity of distributed computing:</span></p>
<ol>
<li aria-level="1"><b>Program clusters like arrays.</b><span> Monarch organizes hosts, processes, and actors into scalable </span><i><span>meshes</span></i><span> that you can manipulate directly. You can operate on entire meshes (or slices of them) with simple APIs—Monarch handles the distribution and vectorization automatically, so you can think in terms of what you want to compute, not where the code runs. </span></li>
<li aria-level="1"><b>Progressive fault handling.</b><span> With Monarch, you write your code as if nothing fails. When something does fail, Monarch fails fast by default—stopping the whole program, just like an uncaught exception in a simple local script. Later, you can progressively add fine-grained fault handling exactly where you need it, catching and recovering from failures just like you’d catch exceptions.</span></li>
<li aria-level="1"><b>Separate control from data.</b><span> Monarch splits control plane (messaging) from data plane (RDMA transfers), enabling direct GPU-to-GPU memory transfers across your cluster. Monarch lets you send commands through one path, while moving data through another, optimized for what each does best.</span></li>
<li aria-level="1"><b>Distributed tensors that feel local.</b><span> Monarch integrates seamlessly with PyTorch to provide tensors that are sharded across clusters of GPUs. Monarch tensor operations look local but are executed across distributed large clusters, with Monarch handling the complexity of coordinating across thousands of GPUs.</span></li>
</ol>
<h3><span>Programming Model</span></h3>
<h4><span>Key APIs: Process and Actor Meshes</span></h4>
<p><span>Monarch organizes resources into multidimensional arrays, or </span><b>meshes</b><span>. A </span><b>process mesh</b><span> is an array of processes spread across many hosts; an </span><b>actor mesh</b><span> is an array of actors, each running inside a separate process. Like array programming in NumPy or PyTorch, meshes make it simple to dispatch operations efficiently across large systems.</span></p>
<p><span>At launch, Monarch supports process meshes over GPU clusters—typically one process per GPU—onto which you can spawn actors into actor meshes. For local development, the same meshes can also run on a local development server. </span></p>
<h4><span>Advanced APIs: Tensor Engine and RDMA Buffer</span></h4>
<p><span>Monarch’s </span><i><span>tensor engine</span></i><span> brings distributed tensors to process meshes. It lets you write PyTorch programs as if the entire cluster of GPUs were attached to the machine running the script. For bulk data movement, Monarch also provides an RDMA buffer API, enabling direct, high-throughput transfers between processes on supported NICs.</span></p>
<p><a href="https://meta-pytorch.org/monarch/generated/examples/getting_started.html"><span>Extensive details</span></a><span> and </span><a href="https://meta-pytorch.org/monarch/generated/examples/index.html"><span>more detailed examples</span></a><span> can be found on our </span><a href="https://meta-pytorch.org/monarch/index.html"><span>GitHub page.</span></a></p>
<h4><span>A Simple Example</span></h4>
<p><span>Monarch code imperatively describes how to create processes and actors using a simple Python API:</span></p>
<pre><span>from</span> monarch.actor <span>import</span> Actor, endpoint, this_host

procs = this_host().spawn_procs({<span>&#34;gpus&#34;</span>: <span>8</span>})

<span># define an actor that has one method</span>
<span>class</span> Example(Actor):
   @endpoint
   <span>def</span> say_hello(self, txt):
       <span>return</span> <span>f&#34;hello {txt}</span>&#34;

<span># spawn the actors</span>
actors = procs.spawn(&#34;actors&#34;, Example)

# <span>have them say hello</span>
hello_future = actors.say_hello.call(&#34;world&#34;)

<span># print out the results</span>
<span>print</span>(hello_future.get())

</pre>
<p><span>In the above example, we define an Actor called “Example” that is deployed on 8 GPUs on the local host. The controller then invokes this example across the host and waits for their response. The actors can expose a variety of interfaces. </span></p>
<h4><span>Slicing Meshes</span></h4>
<p><span>We express broadcasted communication by organizing actors into a Mesh – a multidimensional container with named dimensions. For instance, a cluster might have dimensions {“hosts”: 32, “gpus”: 8}. Dimension names are normally things like “hosts”, indexing across the hosts in a cluster, or “gpus”, indexing across things in a machine.</span></p>
<pre><span>from</span> <span>monarch.actor</span> <span>import</span> <span>Actor,</span> <span>endpoint,</span> <span>this_host</span>

<span>procs</span> <span>=</span> <span>this_host().spawn_procs({</span><span>&#34;gpus&#34;</span><span>:</span> <span>8</span><span>})</span>

<span># define an actor that has two methods</span>
<span>class</span> <span>Example(Actor):</span>
<span>   </span><span>@endpoint</span>
<span>   </span><span>def</span> <span>say_hello(self,</span> <span>txt):</span>
<span>       </span><span>return</span> <span><span>f&#34;hello {txt}</span>&#34;</span>

<span>   </span><span>@endpoint</span>
<span>   </span><span>def</span> <span>say_bye(self,</span> <span>txt):</span>
<span>       </span><span>return</span> <span><span>f&#34;goodbye {txt}</span>&#34;</span>

<span># spawn the actors</span>
<span>actors</span> <span>=</span> <span>procs.spawn(</span><span>&#34;actors&#34;</span><span>,</span> <span>Example)</span>

<span># have half of them say hello</span>
<span>hello_fut</span> <span>=</span> <span>actors.</span><span>slice</span><span>(gpus=</span><span>slice</span><span>(</span><span>0</span><span>,</span><span>4</span><span>)).say_hello.call(</span><span>&#34;world&#34;</span><span>)</span>

<span># the other half say good bye</span>
<span>bye_fut</span> <span>=</span> <span>actors.</span><span>slice</span><span>(gpus=</span><span>slice</span><span>(</span><span>4</span><span>,</span><span>8</span><span>)).say_bye.call(</span><span>&#34;world&#34;</span><span>)</span>

<span>print</span><span>(hello_fut.get())</span>
<span>print</span><span>(bye_fut.get())

</span></pre>
<h4><span>Fault Recovery</span></h4>
<p><span>Users can express distributed programs that can error through pythonic try, except blocks. Complex fault detection and fault recovery schemes can be built on top of these primitives. The following showcases handling a simple runtime Exception in a remote actor.</span></p>
<pre><span>from</span> <span>monarch.actor</span> <span>import</span> <span>Actor,</span> <span>endpoint,</span> <span>this_host</span>

<span>procs</span> <span>=</span> <span>this_host().spawn_procs({</span><span>&#34;gpus&#34;</span><span>:</span> <span>8</span><span>})</span>

<span>class</span> <span>Example(Actor):</span>
<span>   </span><span>@endpoint</span>
<span>   </span><span>def</span> <span>say_hello(self,</span> <span>txt):</span>
<span>       </span><span>return</span> <span>f&#34;hello {txt}&#34;</span>

<span>   </span><span>@endpoint</span>
<span>   </span><span>def</span> <span>say_bye(self,</span> <span>txt):</span>
<span>       </span><span>raise</span> <span>Exception(</span><span>&#34;saying bye is hard&#34;</span><span>)</span>

<span>actors</span> <span>=</span> <span>procs.spawn(</span><span>&#34;actors&#34;</span><span>,</span> <span>Example)</span>
<span>hello_fut</span> <span>=</span> <span>actors.</span><span>slice</span><span>(gpus=</span><span>slice</span><span>(</span><span>0</span><span>,</span><span>4</span><span>)).say_hello.call(</span><span>&#34;world&#34;</span><span>)</span>
<span>bye_fut</span> <span>=</span> <span>actors.</span><span>slice</span><span>(gpus=</span><span>slice</span><span>(</span><span>4</span><span>,</span><span>8</span><span>)).say_bye.call(</span><span>&#34;world&#34;</span><span>)</span>

<span>try</span><span>:</span>
<span>   </span><span>print</span><span>(hello_fut.get())</span>
<span>except</span><span>:</span>
<span>   </span><span>print</span><span>(</span><span>&#34;couldn&#39;t say hello&#34;</span><span>)</span>

<span>try</span><span>:</span>
<span>   </span><span>print</span><span>(bye_fut.get())</span>
<span>except</span> <span>Exception:</span>
<span>   </span><span>print</span><span>(</span><span>&#34;got an exception saying bye&#34;</span><span>)

</span></pre>
<p><span>See “Case Study 2: Fault Tolerance in Large Scale Pre Training” for a more realistic use case.</span></p>
<h2><span>The Monarch Backend</span></h2>
<p><span>Monarch is split into a Python-based </span><i><span>frontend</span></i><span>, and a backend implemented in Rust. Python is the lingua franca of machine learning, and our Python frontend APIs allow users to seamlessly integrate with existing code and libraries (like PyTorch!), and to use Monarch with interactive computing tools like Jupyter notebooks. Our Rust-based backend facilitates our performance, scale, and robustness  — we amply use Rust’s </span><i><span>fearless concurrency</span></i><span> in Monarch’s implementation.</span></p>
<h3><span>Hyperactor and hyperactor_mesh</span></h3>
<p><span>At the bottom of the stack is a Rust-based actor framework called </span><a href="https://github.com/meta-pytorch/monarch/tree/main/hyperactor"><i><span>hyperactor</span></i></a><span>. Hyperactor is a low-level distributed actor system, focused on performant message passing and robust supervision. </span><i><span>hyperactor_mesh</span></i><span> is built on top of hyperactor, and combines its various components into an efficient “vectorized” actor implementation. Hyperactor_mesh is oriented towards providing actor operations cheaply over large </span><i><span>meshes</span></i><span> of actors.</span></p>
<p><span>Monarch’s core Python APIs, in turn, are fairly thin wrappers around hyperactor_mesh.</span></p>
<h3><span>Scalable messaging</span></h3>
<p><span>Everything in Monarch relies on </span><i><span>scalable messaging</span></i><span>: the core APIs supporting </span><i><span>casting</span></i><span> messages to large meshes of actors. Hyperactor achieves this through two mechanisms: multicast trees and multipart messaging.</span></p>
<p><span>First, in order to support multicasting, Hyperactor sets up multicast trees to distribute messages. When a message is cast, it is first sent to some initial nodes, which then forward copies of the message to a set of its children, and so on, until the message has been fully distributed throughout the mesh. This lets us avoid single-host bottlenecks, effectively using the whole mesh as a distributed cluster for message forwarding. (Cite scalability numbers here.)</span></p>
<p><span>Second, we ensure that the control plane is never in the critical path of data delivery. For example, we use multipart messaging to avoid copying, to enable sharing data across high-fanout sends (such as those that occur in our multicast trees), and materialize into efficient, vectorized writes managed by the OS.</span></p>
<h2><span>Case Studies</span></h2>
<p><span>We believe that this general purpose API and its native integration with PyTorch will unlock the next generation of AI applications at scale and the more complex orchestration requirements that they present. </span></p>
<h3><span>Case Study 1: Reinforcement Learning</span></h3>
<p><span>Reinforcement learning has been critical to the current generation of frontier models. RL enables models to do deep research, perform tasks in an environment and solve challenging problems such as math and code. For a deeper dive, we recommend this </span><a href="https://pytorch.org/blog/a-primer-on-llm-post-training/?ajs_aid=57910bf1-d592-4619-a7d5-295ab7d39433"><span>post</span></a><span> for a deeper dive into the topics. </span></p>
<p><span>In order to train a reasoning model (see figure below), generator processes produce prompts from the reasoning model specializing in a specific domain (say, programming code generation). The generator uses these prompts (an incomplete coding problem statement) to derive a set of solutions or trajectories (executable code in this example) often interacting with the world through tools (compiler) and environments. Reward pipelines evaluate these solutions and come up with scores. These scores and rewards are used to train the same model whose weights are then transferred back to the systems that generated the prompt responses.</span></p>
<p><span>This constitutes a single training loop! As illustrated in the figure below, this is effectively a real-time pipeline of a number of heterogeneous computations </span><b><i>within a training loop</i></b><span> that may have to be orchestrated and scaled individually.</span></p>
<p><span><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/unnamed-2.png" alt="" width="1600" height="985" srcset="https://pytorch.org/wp-content/uploads/2025/10/unnamed-2.png 1600w, https://pytorch.org/wp-content/uploads/2025/10/unnamed-2-300x185.png 300w, https://pytorch.org/wp-content/uploads/2025/10/unnamed-2-1024x630.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></span></p>
<p><span>When implementing the RL example above in Monarch, each component — generator, trainer, inference engine, reward pipeline — might be represented by a mesh: a mesh of generators, a mesh of trainers, a mesh of inference nodes, a mesh of reward pipelines. (The figure above shows a simplistic example with only two meshes: generator and trainer).</span></p>
<p><span>The training script then uses these meshes to orchestrate the overall flow of the job: telling the generator mesh to start working from a new batch of prompts, passing the data to the training mesh when they are done, and updating the inference mesh when a new model snapshot is ready. The orchestrator is written as an ordinary Python program, calling methods on meshes and passing data between them. Because Monarch supports remote memory transfers (RDMA) natively, the actual data is transferred directly between members of meshes (just like you might copy a tensor from one GPU to another), enabling efficient and scalable workflows.</span></p>
<h4><span>VERL</span></h4>
<p><span>Volcano Engine Reinforcement Learning (</span><a href="https://github.com/volcengine/verl"><span>VERL</span></a><span>) is a widely used Reinforcement Learning framework in the industry today.  </span></p>
<p><span>We integrated Monarch with VERL as a proof-of-concept and post-trained the </span><a href="https://huggingface.co/open-r1/Qwen2.5-Math-7B-RoPE-300k"><span>Qwen-2.5-7B math model</span></a><span> using GRPO on a curated math dataset and evaluated it on the AIME 2024 benchmark. We trained for 500+ training steps on H200 GPUs using </span><a href="https://github.com/NVIDIA/Megatron-LM"><span>Megatron-LM</span></a><span> scaling progressively from 16, 64, 1024 to 2048 GPUs. The runs were stable and yielded good numerical parity with existing options, demonstrating that Monarch can orchestrate existing RL frameworks. </span></p>
<p><span>We are actively working on open-sourcing this integration to allow future users to evaluate Monarch as an option in their VERL jobs.</span></p>
<p><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/3-3.png" alt="" width="984" height="584" srcset="https://pytorch.org/wp-content/uploads/2025/10/3-3.png 984w, https://pytorch.org/wp-content/uploads/2025/10/3-3-300x178.png 300w" sizes="(max-width: 984px) 100vw, 984px"/></p>
<h4><span>TorchForge</span></h4>
<p><span>TorchForge represents a different approach: a pytorch native RL framework designed from the ground up with Monarch primitives.</span></p>
<p><span>TorchForge’s goal is to let researchers express RL algorithms as naturally as pseudocode, while Monarch handles the distributed complexity underneath. The result is code that looks like this:</span></p>
<pre><span>async def </span>continuous_rollouts():
    <span>while</span> True:
        prompt, target = <span>await</span> dataloader.sample.route()
        response = <span>await</span> policy.generate.route(prompt)
        reward = <span>await</span> reward.evaluate_response.route(prompt, response.text, target)
        <span>await</span> replay_buffer.add.route(Episode(...))</pre>
<p><span>No distributed coordination code, no retry logic, just RL written in Python. </span></p>
<h4><span>Building on Monarch: Services and TorchStore</span></h4>
<p><span>This clean API is possible because torchforge builds two key abstractions on Monarch’s primitives:</span></p>
<p><span>“</span><b>Services</b><span>” wrap Monarch ActorMeshes with RL-specific patterns. They leverage Monarch’s fault tolerance, resource allocation, and mailbox system, while adding patterns like load-balanced routing (`.route()`), parallel broadcasts (`.fanout()`), and sticky sessions for stateful operations.</span></p>
<pre><span># A service is a managed group of ActorMeshes with routing primitives</span>
<span>policy</span> <span>=</span> <span>PolicyActor.options(</span>
<span>    </span><span>procs=</span><span>8</span><span>,</span> <span>with_gpus=True,</span> <span>num_replicas=</span><span>16</span> <span># Creates 16 replicas, each with 8 GPUs</span>
<span>).as_service()</span>

<span># Services provide RL-friendly adverbs built on Monarch actors</span>
<span>response</span> <span>=</span> <span>await</span> <span>policy.generate.route(prompt)</span><span>     </span><span># Load-balanced routing</span>
<span>await</span> <span>policy.update_weights.fanout(version)</span><span>        </span><span>#</span> <span>Parallel</span> <span>broadcast</span><span> 

</span></pre>
<p><b>TorchStore</b><span> is a distributed key-value store for PyTorch tensors that handles weight synchronization between training and inference. Built on Monarch’s RDMA primitives and single-controller design, it provides simple DTensor APIs while efficiently resharding weights on the fly – critical for off-policy RL where training and inference use different layouts.</span></p>
<p><span>These abstractions demonstrate Monarch’s composability: torchforge uses Monarch’s primitives (actors, RDMA, fault tolerance) as building blocks to create RL-specific infrastructure. The resulting framework handles coordination complexity at the infrastructure layer, letting researchers focus on algorithms.</span></p>
<p><span>For detailed examples of Forge’s APIs, component integration, and design philosophy, see our <a href="https://pytorch.org/blog/introducing-torchforge/">torchforge</a> blog post.</span></p>
<h3><span>Case Study 2: Fault Tolerance in Large Scale Pre Training</span></h3>
<p><span>Hardware and software failures are common and frequent at scale. For example, in </span><a href="https://arxiv.org/pdf/2407.21783"><span>our Llama3 training runs</span></a><span> we experienced 419 interruptions across a 54 day training window for a 16k GPU training job. This averages to about one failure every 3 hours. If we project this out to 10s of thousands of GPUs, this represents a failure once every hour or more frequently. Restarting the entire job for each of these failures will reduce the effective training time. </span></p>
<p><span>A solution is to use methods to further leverage distributed training through methods to make the numerics of the model more tolerant of having the various groups run more asynchronously. For example, </span><a href="https://pytorch.org/blog/fault-tolerant-llama-training-with-2000-synthetic-failures-every-15-seconds-and-no-checkpoints-on-crusoe-l40s/"><span>TorchFT</span></a><span>, released from PyTorch, provides a way to withstand failures of GPUs and allow the training to continue. One strategy is to use Hybrid Sharded Data Parallelism that combines fault tolerant DDP with FSDP v2 and PP. On failure we use </span><a href="https://pytorch.org/blog/torchcomms/"><span>torchcomms</span></a><span> to gracefully handle errors and UI training on the next batch without downtime. This isolates failures to a single “replica group” and we can continue training with a subset of the original job.</span></p>
<p><span>Monarch </span><a href="https://github.com/meta-pytorch/torchft/tree/main/examples/monarch"><span>integrates</span></a><span> with </span><a href="https://github.com/meta-pytorch/torchft"><span>TorchFT</span></a><span>. Monarch centralizes the control plane into a single-controller model. Monarch uses its fault detection primitives to detect failures, and upon detection, can spin up new logical replica groups (Monarch Meshes) to join training once initialized. TorchFT’s Lighthouse server acts as a Monarch actor. Monarch provides configurable recovery strategies based on failure type. On faults, the controller first attempts fast, process‑level restarts within the existing allocation and only escalates to job reallocation when necessary, while TorchFT keeps healthy replicas stepping so progress continues during recovery.</span></p>
<p><span>We ran this code on a 30 node (240 H100s) Coreweave cluster, using the SLURM scheduler to train Qwen3-32B using torchtitan and TorchFT. We injected 100 injected failures every 3 minutes across multiple failure modes (segfaults, process kills, NCCL abort, host eviction, GIL deadlock). Monarch allows for configurable recovery strategies based on failure type — we observed this to be 60% faster by avoiding unnecessary job rescheduling (relative to full SLURM job restarts). We see 90s avg recovery for process failures and 2.5min avg recovery machine failures. For more details, see the </span><a href="https://github.com/meta-pytorch/torchft/tree/main/examples/monarch"><span>README</span></a><span>.</span></p>
<pre><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/4-1.png" alt="" width="990" height="590" srcset="https://pytorch.org/wp-content/uploads/2025/10/4-1.png 990w, https://pytorch.org/wp-content/uploads/2025/10/4-1-300x179.png 300w" sizes="(max-width: 990px) 100vw, 990px"/></pre>
<h3><span>Case Study 3: Interactive Debugging with a Large GPU cluster </span></h3>
<p><span>The actor framework is not just limited to large scale orchestration of complex jobs. It enables the ability to seamlessly debug complex, multi-GPU computations interactively. This capability represents a fundamental shift from traditional batch-oriented debugging to real-time, exploratory problem-solving that matches the scale and complexity of contemporary AI systems.</span></p>
<p><span>Traditional debugging workflows break down when confronted with the realities of modern ML systems. A model that trains perfectly on a single GPU may exhibit subtle race conditions, deadlocks, memory fragmentation, or communication bottlenecks when scaled across dozens of accelerators. </span></p>
<p><span>Monarch provides an interactive developer experience. With a local jupyter notebook, a user can drive a cluster as a Monarch mesh. </span></p>
<ol>
<li aria-level="1"><span>Persistent distributed compute allows very fast iteration without submitting new jobs</span></li>
<li aria-level="1"><span>Workspace sync_workspace API quickly syncs local conda environment code to Mesh nodes.</span></li>
<li aria-level="1"><span>Monarch provides a mesh-native, </span><a href="https://meta-pytorch.org/monarch/generated/examples/debugging.html"><span>distributed debugger</span></a></li>
</ol>
<p><span>See a jupyter tutorial at </span><a href="https://docs.pytorch.org/tutorials/intermediate/monarch_distributed_tutorial.html"><span>pytorch.org</span></a></p>
<h3><span>Monarch + Lightning AI Notebook</span></h3>
<p><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/5-1.png" alt="" width="1600" height="990" srcset="https://pytorch.org/wp-content/uploads/2025/10/5-1.png 1600w, https://pytorch.org/wp-content/uploads/2025/10/5-1-300x186.png 300w, https://pytorch.org/wp-content/uploads/2025/10/5-1-1024x634.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></p>
<p><span>See Monarch in action as we launch a 256-GPU training job from a single Studio notebook, powered by TorchTitan. Experience seamless scaling, persistent resources, and interactive debugging — all in one single Notebook. The figure above shows this schema.  Also, see our </span><a href="https://pytorch.org/blog/integration-idea-monarch/"><span>Monarch-Lightning blog post</span></a><span>. In this example, the traditional SPMD TorchTitan workload is encapsulated as an Actor within Monarch, allowing users to pre-train large language models (such as Llama-3 and Llama-4) interactively from a Studio Notebook.</span></p>
<p><span>Monarch enables you to reserve and maintain compute resources directly from your local Studio Notebook in lightning. Even if your notebook session is interrupted or code disconnects, your cluster allocation remains active through Multi-Machine Training (MMT). This persistence of the process allocator allows you to iterate, experiment, and resume work seamlessly, reducing manual intervention and making the notebook a reliable control center for distributed training tasks.</span></p>
<p><span>Using Monarch’s Actor model, you can define and launch the Titan Trainer as an Actor on a process mesh, scaling your training jobs to hundreds of GPUs – all from within the Studio notebook. Monarch handles the orchestration, code and file sharing, and log collection, so you can reconfigure and relaunch jobs quickly. Logs and metrics are available directly in the notebook, as well as through external tools like Litlogger and WandB, making it easy to monitor and manage large-scale training.</span></p>
<p><span>Monarch brings interactive debugging to distributed training. You can set Python breakpoints in your Actor code, inspect running processes, and attach to specific actors for real-time troubleshooting – all from the notebook interface. After training, you can modify configurations or define new actors and relaunch jobs on the same resources without waiting for new allocations. This dynamic workflow accelerates experimentation and provides deep insight into your distributed training runs. </span></p>
<p><span>The code snippet in the </span><a href="https://pytorch.org/blog/integration-idea-monarch/"><span>Monarch-Lightning blog post</span></a><span>  shows the sample Lightning studio notebook for Monarch to pre-train the Llama-3.1 – 8B model using TorchTitan on 256 GPUs. </span></p>
<h3><span>Try Monarch Today: Build, Scale, and Debug Distributed AI Workflows with Ease</span></h3>
<p><span>Monarch is available now on GitHub—ready for you to explore, build with, and contribute to. Dive into the </span><a href="https://github.com/meta-pytorch/monarch"><b>Monarch repo</b></a><span> to get started, explore the </span><a href="https://meta-pytorch.org/monarch/"><b>documentation</b></a><span> for deeper technical details, and try out our </span><a href="https://github.com/meta-pytorch/monarch/blob/main/examples/slurm_titan.ipynb"><b>interactive Jupyter notebook</b></a><span> to see Monarch in action. For an end-to-end example of launching large-scale training directly from your notebook, check out the</span> <a href="https://pytorch.org/blog/integration-idea-monarch/"><b>Lightning.ai integration</b></a><span>. Whether you’re orchestrating massive training runs, experimenting with reinforcement learning, or interactively debugging distributed systems, Monarch gives you the tools to do it all—simply and at scale.</span></p>
<h3><span>Acknowledgments</span></h3>
<p><span>Thank you to the whole Monarch team for making this work possible.  Also, a special thanks to our </span><a href="https://github.com/meta-pytorch/monarch/graphs/contributors"><span>Top Contributors</span></a><span> on GitHub!</span></p>
<p><span>Ahmad Sharif, Allen Wang, Alireza Shamsoshoara, Amir Afzali, Amr Mahdi, Andrew Gallagher, Benji Pelletier, Carole-Jean Wu, Chris Gottbrath, Colin Taylor, Davide Italiano, Dennis van der Staay, Eliot Hedeman, Gayathri Aiyer, Gregory Chanan, </span><span>Hamid Shojanazeri, </span><span>James Perng, James Sun, Jana van Greunen, Jayasi Mehar, Joe Spisak, John William Humphreys, Jun Li, Kai Li, Keyan Pishdadian, Kiuk Chung, Lucas Pasqualin, Marius Eriksen, Marko Radmilac, Mathew Oldham, Matthew Zhang, Michael Suo, Matthias Reso, Osama Abuelsorour, Pablo Ruiz Fischer Bennetts, Peng Zhang, Rajesh Nishtala, Riley Dulin, Rithesh Baradi, Robert Rusch, Sam Lurye, Samuel Hsia, Shayne Fletcher, Tao Lin, Thomas Wang, Victoria Dudin, Vidhya Venkat, Vladimir Ivanov, Zachary DeVito</span></p>
</div>        
      </div><!--/post-content-->
      
    </div><!--/inner-wrap-->
    
</article>
        </div><!--/post-area-->

            
        </div></div>
  </body>
</html>
