<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2026-01_missing-programming-language">Original</a>
    <h1>The Missing Programming Language - Why There&#39;s No S-Tier Language (Yet)</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://visualrambling.space/blog/disclosures">(disclosures)</a></p><div><p>I&#39;ve spent years searching for a programming language that has it all: expressive types, a large ecosystem, good performance, and good devx.</p>
<p>Every language I&#39;ve tried makes me choose. So here I wanted to share my view of the current language landscape, where they fall short, and what I think they can do to have it all and become S-Tier.</p>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-01_programming-language-tier-list">My 2025 Programming Language Tier List</a> - where I noted S-tier is conspicuously empty</em></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gJXv0BjFFCc?si=mguuXQYL73Nw87UG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="programming-language-wish-list">Programming Language Wish List</h2>
<p>What I want in a language:</p>
<ul>
<li><strong>Expressive types</strong> - Sum types, exhaustive matching, native immutability, sound types that don&#39;t lie at runtime</li>
<li><strong>Big ecosystem</strong> - Lots of packages, active maintainers, docs for everything, general-purpose across platforms</li>
<li><strong>Large community</strong> - Jobs available, Stack Overflow answers, AI knows it well (after all, <a href="https://hamy.xyz/blog/2025-12_ai-is-here-to-stay">AI is here to stay</a>)</li>
<li><strong>Good performance</strong> - Fast enough for most use cases</li>
<li><strong>Good DevX</strong> - No manual memory management (unless you want it), reasonable learning curve, and productivity is on par with other high level langs when you get up to speed</li>
</ul>
<p>I don&#39;t think this is unreasonable. Each of these features exist, just not in the same package.</p>
<h3 id="my-definition-of-expressive-types">My Definition of Expressive Types</h3>
<p>I get asked about this a lot and I think everyone has their own definition so I want to be clear about what I mean. When I say expressive types, I mean:</p>
<ul>
<li><strong>Sum types / discriminated unions</strong> - Can model &#34;this is A or B&#34; as a distinct type, not just interfaces or inheritance. Examples include: Rust&#39;s <code>enum</code>, F#&#39;s discriminated unions, TypeScript&#39;s union types.</li>
<li><strong>Exhaustive pattern matching</strong> - The compiler ensures you handle all cases. Add a new variant? Compiler errors everywhere you forgot to handle it so it&#39;s easy to go back and fix those.</li>
<li><strong>Native immutability</strong> - Immutable bindings for runtime values (like Rust&#39;s <code>let</code> or F#&#39;s <code>let</code>), not just <code>const</code> for compile-time constants (like C#). Immutable by default is even better. Ideally the immutability is structural - the data itself is immutable, not just preventing reassignment of the binding.</li>
<li><strong>Sound types</strong> - Types don&#39;t lie at runtime. A variable of type <code>int</code> will contain an int - or an error is thrown. TypeScript and Python fail here - you can declare <code>x: int</code> and silently have it be a string at runtime. This includes null safety - if a type is non-nullable, it shouldn&#39;t be null / undefined at runtime. Languages without null safety (Java, Go, older C#) let you pass <code>null</code> anywhere, causing NullReferenceExceptions/NPEs at runtime instead of compile-time errors.</li>
<li><strong>Option/Result capable</strong> - Easy to build or use these patterns. Doesn&#39;t have to be built-in, but the language shouldn&#39;t fight you.</li>
</ul>
<p>Most languages have 1-2 of these. Few have all 5. But IMO these are powerful tools for modeling the domain and if you can model the domain well you can make invalid types unrepresentable and if you can do that you end with a system that is MUCH more robust to many kinds of common errors. If you can&#39;t do that then you have implicit rules engineers need to keep in mind long term and it&#39;s an error waiting to happen when someone eventually misses that implicit.</p>
<p><em>Note: Ergonomics matter too - the easier types are to read and write, the more developers will use them to model simple, correct domains. But since this is highly subjective I&#39;m not including it in the formal criteria. But as a general rule, less boilerplate is good.</em></p>
<p><img src="https://cdn.hamy.xyz/labs/posts/2026/2026-01_the-missing-programming-language/2026-01_the-missing-programming-language_table.png" alt="Programming Language Scores"/></p>
<h2 id="the-programming-language-landscape">The Programming Language Landscape</h2>
<p>Here&#39;s how I&#39;d score popular languages across these dimensions:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Expressive Types</th>
<th>Big Ecosystem</th>
<th>Large Community</th>
<th>Performance</th>
<th>DevX</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>C#</strong></td>
<td>Mixed</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>4.5</td>
</tr>
<tr>
<td><strong>Kotlin</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Mixed</td>
<td>Yes</td>
<td>Yes</td>
<td>4.5</td>
</tr>
<tr>
<td><strong>TypeScript</strong></td>
<td>Mixed</td>
<td>Yes</td>
<td>Yes</td>
<td>Mixed</td>
<td>Yes</td>
<td>4.0</td>
</tr>
<tr>
<td><strong>Go</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>4.0</td>
</tr>
<tr>
<td><strong>Rust</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>4.0</td>
</tr>
<tr>
<td><strong>Swift</strong></td>
<td>Yes</td>
<td>Mixed</td>
<td>Mixed</td>
<td>Yes</td>
<td>Yes</td>
<td>4.0</td>
</tr>
<tr>
<td><strong>Java</strong></td>
<td>Mixed</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Mixed</td>
<td>4.0</td>
</tr>
<tr>
<td><strong>F#</strong></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>3.0</td>
</tr>
<tr>
<td><strong>PHP</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>3.0</td>
</tr>
<tr>
<td><strong>Python</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>3.0</td>
</tr>
<tr>
<td><strong>Ruby</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>3.0</td>
</tr>
<tr>
<td><strong>C/C++</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>3.0</td>
</tr>
<tr>
<td><strong>Gleam</strong></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Mixed</td>
<td>Yes</td>
<td>2.5</td>
</tr>
<tr>
<td><strong>Elixir</strong></td>
<td>No</td>
<td>Mixed</td>
<td>Mixed</td>
<td>Mixed</td>
<td>Yes</td>
<td>2.5</td>
</tr>
<tr>
<td><strong>Zig</strong></td>
<td>Mixed</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Mixed</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<p><em>Scoring: Yes=1, Mixed=0.5, No=0. Max possible = 5.0 (S-Tier). No current language achieves it.</em></p>
<p>Some patterns:</p>
<ul>
<li>Languages with expressive types (Rust, F#, Gleam, Swift, Kotlin) tend to have smaller ecosystems or other tradeoffs</li>
<li>Languages with big ecosystems (Go, Python) tend to lack expressive types entirely, while others (C#, Java, TypeScript) have partial support</li>
<li>Rust comes closest on paper but fails on DevX (borrow checker learning curve)</li>
<li>C# and Kotlin score highest but each has a critical gap</li>
</ul>
<p>Here&#39;s my reasoning for each language:</p>
<h3 id="c-almost-there-4.5">C# - Almost There (4.5)</h3>
<ul>
<li><strong>Expressive Types: Mixed</strong> - Discriminated unions &#34;coming&#34; for years. Mads Torgersen (C# designer) outlined plans for C# 15 (Nov 2026), though he explicitly noted it&#39;s not a committed timeline (<a href="https://blog.ndepend.com/csharp-unions/">NDepend coverage</a>). Has immutable records, pattern matching, but no local immutability (<code>var</code> is mutable, no <code>let</code>/<code>val</code>). Nullable reference types provide partial null safety since C# 8, but it&#39;s opt-in, produces warnings not errors, and nulls can still sneak in via interop, reflection, array defaults, and the null-forgiving operator (<code>!</code>). Types are otherwise sound.</li>
<li><strong>Big Ecosystem: Yes</strong> - Huge NuGet ecosystem, decades of enterprise packages, great tooling, works everywhere (web, CLI, games, data).</li>
<li><strong>Large Community: Yes</strong> - Top 5 language, tons of jobs, excellent AI support, Stack Overflow answers for everything.</li>
<li><strong>Performance: Yes</strong> - .NET is fast, keeps getting faster with almost every release.</li>
<li><strong>DevX: Yes</strong> - No manual memory management, productive quickly, familiar syntax. Though there is a decent amount of boilerplate.</li>
</ul>
<p>Closest to S-tier for me. If unions land well in C# 15, this could be the answer. But I have reservations about whether it actually will be in this release and how the ergonomics play out in terms of boilerplate and interop with the rest of the language / ecosystem.</p>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-11_why-im-moving-blog-fsharp-to-csharp">Why I&#39;m Moving my Blog from F# to C#</a></em></p>
<h3 id="kotlin-jvms-best-hope-4.5">Kotlin - JVM&#39;s Best Hope (4.5)</h3>
<ul>
<li><strong>Expressive Types: Yes</strong> - Sealed classes are proper sum types, null safety built-in, <code>val</code> for local immutability, exhaustive <code>when</code>, types are sound.</li>
<li><strong>Big Ecosystem: Yes</strong> - Full JVM ecosystem access, plus Kotlin-native libraries. Multiplatform story improving.</li>
<li><strong>Large Community: Mixed</strong> - Strong in Android, growing elsewhere, but not as universal as Java/Python/TS. Job market skews mobile.</li>
<li><strong>Performance: Yes</strong> - JVM performance is solid.</li>
<li><strong>DevX: Yes</strong> - Much better than Java, concise syntax, no memory management.</li>
</ul>
<p>If you&#39;re okay with JVM, this is a strong choice. The Android-centric community is the main gap.</p>
<h3 id="typescript-great-types-that-lie-4.0">TypeScript - Great Types That Lie (4.0)</h3>
<ul>
<li><strong>Expressive Types: Mixed</strong> - Great union syntax and exhaustive matching possible, but types lie at runtime (unsound) requiring you to add your own runtime checks. <code>const</code> exists for immutable bindings but objects remain mutable - no native deep immutability. Has <code>strictNullChecks</code> for null safety but since types are erased at runtime, you can still get unexpected nulls / undefineds. And of course you can always just fudge the types with <code>any</code> or <code>X as Y</code>s.</li>
<li><strong>Big Ecosystem: Yes</strong> - Entire npm ecosystem, largest package registry on earth. Works web, server, CLI, mobile.</li>
<li><strong>Large Community: Yes</strong> - Top 3 language, massive job market, AI is excellent at TS.</li>
<li><strong>Performance: Mixed</strong> - Fast enough for most web workloads, but won&#39;t win benchmarks against compiled languages.</li>
<li><strong>DevX: Yes</strong> - Easy to learn, productive quickly, no memory management.</li>
</ul>
<p>Most pragmatic choice. Types don&#39;t lie often enough to matter for most projects. Web-native is a huge plus.</p>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-07_typescript-result-types">TypeScript Result Types</a></em></p>
<h3 id="go-deliberately-incomplete-4.0">Go - Deliberately Incomplete (4.0)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - No sum types (<a href="https://github.com/golang/go/issues/19412">proposal #19412</a> open since March 2017, one of the most requested features). No local immutability - everything mutable by default. No null safety - any pointer/interface can be nil.</li>
<li><strong>Big Ecosystem: Yes</strong> - Great standard library, solid package ecosystem, excellent for CLI/infra/backend.</li>
<li><strong>Large Community: Yes</strong> - Top 10 language, lots of jobs, good AI support.</li>
<li><strong>Performance: Yes</strong> - Fast compilation, fast runtime, low memory footprint.</li>
<li><strong>DevX: Yes</strong> - Simple syntax, no memory management, productive quickly.</li>
</ul>
<p>If Go had expressive types, it would be THE language. The deliberate design against it is one of the primary factors <a href="https://hamy.xyz/blog/2025-01_programming-language-tier-list">I rank it in C Tier</a>.</p>
<h3 id="rust-the-learning-curve-4.0">Rust - The Learning Curve (4.0)</h3>
<ul>
<li><strong>Expressive Types: Yes</strong> - Excellent enums with associated data, exhaustive matching, Option/Result built-in, immutable by default. Best-in-class type system.</li>
<li><strong>Big Ecosystem: Yes</strong> - Cargo/crates.io has grown substantially, good packages for most needs.</li>
<li><strong>Large Community: Yes</strong> - Growing fast, 72% admiration in <a href="https://survey.stackoverflow.co/2025/technology">2025 Stack Overflow survey</a>.</li>
<li><strong>Performance: Yes</strong> - Blazing fast, zero-cost abstractions.</li>
<li><strong>DevX: No</strong> - Borrow checker is a &#34;notorious learning barrier&#34; per academic research (<a href="https://arxiv.org/abs/2011.06171">&#34;The Usability of Ownership&#34;</a>) and anecdata from 1ks of forum posts. Async ecosystem is fragmented though does seem to be coalescing around tokio. Fighting the compiler is real.</li>
</ul>
<p>On paper, Rust is closest. In practice, the DevX cost is real. I&#39;m currently trying &#34;high-level Rust&#34; with Arc/Clone to avoid the edges during <a href="https://hamy.xyz/blog/2026-01_recurse-center-statement">my time at Recurse Center</a> but we&#39;ll see how this works in practice.</p>
<h3 id="swift-apples-walled-garden-4.0">Swift - Apple&#39;s Walled Garden (4.0)</h3>
<ul>
<li><strong>Expressive Types: Yes</strong> - Enums with associated values, exhaustive switch, optionals built-in, <code>let</code> for local immutability, types are sound.</li>
<li><strong>Big Ecosystem: Mixed</strong> - Excellent for Apple platforms, limited elsewhere. Server-side Swift exists but niche.</li>
<li><strong>Large Community: Mixed</strong> - Strong in iOS/macOS, weak outside Apple ecosystem. Jobs are Apple-focused.</li>
<li><strong>Performance: Yes</strong> - Fast, compiled, good memory characteristics.</li>
<li><strong>DevX: Yes</strong> - ARC handles memory, productive syntax, good tooling (on Mac).</li>
</ul>
<p>Great language trapped in Apple&#39;s ecosystem. If you&#39;re building for Apple, it&#39;s excellent. Otherwise, limited.</p>
<h3 id="java-the-boilerplate-king-4.0">Java - The Boilerplate King (4.0)</h3>
<ul>
<li><strong>Expressive Types: Mixed</strong> - Has sum types via sealed classes with exhaustive pattern matching, but very verbose and clunky compared to native discriminated unions. Local immutability requires verbose <code>final</code> keyword. No null safety - any reference can be null, leading to NPEs (though there&#39;s an <a href="https://openjdk.org/jeps/8303099">open proposal</a> to change this). Types are otherwise sound.</li>
<li><strong>Big Ecosystem: Yes</strong> - Massive enterprise ecosystem, Maven Central is huge, decades of libraries.</li>
<li><strong>Large Community: Yes</strong> - Still a top 5 language, enormous job market, AI knows it well.</li>
<li><strong>Performance: Yes</strong> - JVM is fast, especially with modern GCs.</li>
<li><strong>DevX: Mixed</strong> - No memory management, but verbose syntax, slow to evolve, boilerplate everywhere.</li>
</ul>
<p>Enterprise workhorse but showing its age. Kotlin exists for a reason.</p>
<h3 id="php-surprisingly-decent-now-3.0">PHP - Surprisingly Decent Now (3.0)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - Has types now but not expressive. No sum types, no exhaustive matching.</li>
<li><strong>Big Ecosystem: Yes</strong> - Massive web ecosystem, Composer/Packagist, WordPress alone is huge.</li>
<li><strong>Large Community: Yes</strong> - Top 10 language, lots of jobs (especially web/WordPress), AI knows it well.</li>
<li><strong>Performance: No</strong> - PHP 8+ has improved significantly with JIT, but still slow. Laravel benchmarks at 16,800 RPS vs Django&#39;s 32,651 RPS on TechEmpower - slower than Python in web workloads.</li>
<li><strong>DevX: Yes</strong> - No memory management, easy to deploy, productive for web.</li>
</ul>
<p>PHP has improved dramatically but the type system hasn&#39;t kept up. Fine for web and a very productive language but I think there are better options out there.</p>
<h3 id="f-beautiful-but-lonely-3.0">F# - Beautiful but Lonely (3.0)</h3>
<ul>
<li><strong>Expressive Types: Yes</strong> - Discriminated unions, exhaustive matching, Option/Result built-in, immutable by default, types are sound. One of the best type systems.</li>
<li><strong>Big Ecosystem: No</strong> - Tiny, many abandoned packages. Can use C# libs but nulls still leak in, wrappers needed.</li>
<li><strong>Large Community: No</strong> - 42nd most popular language with 0.9% usage per <a href="https://hamy.xyz/blog/2024-11_fsharp-popularity">Stack Overflow 2024 survey</a>. Few jobs, limited AI support, sparse Stack Overflow.</li>
<li><strong>Performance: Yes</strong> - .NET is fast.</li>
<li><strong>DevX: Yes</strong> - No memory management, functional-first is productive once learned.</li>
</ul>
<p>My favorite language that I can&#39;t fully commit to. <a href="https://hamy.xyz/blog/2024-02_fsharp-is-fun">It&#39;s fun</a> but the ecosystem gap is painful.</p>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-06_7-reasons-fsharp-sucks">7 Reasons F# Sucks</a>, <a href="https://hamy.xyz/blog/2025-11_why-im-moving-blog-fsharp-to-csharp">Why I&#39;m Moving my Blog from F# to C#</a></em></p>
<h3 id="python-easy-but-fragile-3.0">Python - Easy but Fragile (3.0)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - Type hints exist but they lie - not enforced at runtime (unsound). Union types exist (<code>X | Y</code>) but no exhaustive matching, no native immutability. You can declare <code>x: int</code> and assign a string.</li>
<li><strong>Big Ecosystem: Yes</strong> - Massive, especially for data/ML/AI.</li>
<li><strong>Large Community: Yes</strong> - Top language, jobs everywhere, AI is excellent at Python.</li>
<li><strong>Performance: No</strong> - Slow. Yes, there are workarounds (Cython, etc.) but core Python is slow.</li>
<li><strong>DevX: Yes</strong> - No memory management, easy syntax, productive quickly for small projects.</li>
</ul>
<p>Great for scripts and ML, painful at scale. The lack of real types catches up with you.</p>
<p><em>Related: <a href="https://hamy.xyz/blog/2024-09_types-vs-no-types">Types vs No Types - How Types Allow Code to Scale</a></em></p>
<h3 id="ruby-developer-happiness-type-sadness-3.0">Ruby - Developer Happiness, Type Sadness (3.0)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - Dynamically typed, no static types built-in. Third-party type systems exist (<a href="https://github.com/ruby/rbs">RBS</a> - Ruby 3&#39;s official type signature format, and <a href="https://sorbet.org/">Sorbet</a> - Stripe&#39;s static type checker) but neither is widely adopted in the ecosystem. No sum types, no exhaustive matching.</li>
<li><strong>Big Ecosystem: Yes</strong> - RubyGems is mature, Rails ecosystem is extensive, lots of web dev packages.</li>
<li><strong>Large Community: Yes</strong> - Still popular for web dev, Rails jobs exist, AI knows it well.</li>
<li><strong>Performance: No</strong> - Slow like Python. YJIT has improved things but still not competitive with compiled languages.</li>
<li><strong>DevX: Yes</strong> - &#34;Developer happiness&#34; is a core philosophy. No memory management, expressive syntax, productive for web apps.</li>
</ul>
<p>Similar story to Python - great DevX and ecosystem, but no real types and slow. Rails is still a productivity powerhouse if you accept the tradeoffs.</p>
<h3 id="cc-manual-everything-3.0">C/C++ - Manual Everything (3.0)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - No sum types (C++ has std::variant but clunky). Type system is primitive by modern standards.</li>
<li><strong>Big Ecosystem: Yes</strong> - Decades of libraries, runs everywhere, foundational.</li>
<li><strong>Large Community: Yes</strong> - Still top 5, jobs exist, AI knows it.</li>
<li><strong>Performance: Yes</strong> - As fast as it gets.</li>
<li><strong>DevX: No</strong> - Manual memory management. Segfaults. Undefined behavior. Decades of footguns.</li>
</ul>
<p>Still necessary for systems programming, but I&#39;m not reaching for it unless I have to - and even then I&#39;m trying very hard to bend other langs to accomplish the task instead.</p>
<h3 id="gleam-the-new-contender-2.5">Gleam - The New Contender (2.5)</h3>
<ul>
<li><strong>Expressive Types: Yes</strong> - Proper algebraic data types, exhaustive matching, Result built-in, immutable by default, types are sound. ML-family type system.</li>
<li><strong>Big Ecosystem: No</strong> - Very young, small package ecosystem. BEAM ecosystem access helps.</li>
<li><strong>Large Community: No</strong> - Just hit stable in 2024, tiny but enthusiastic community.</li>
<li><strong>Performance: Mixed</strong> - BEAM is great for concurrency, not for compute-intensive work.</li>
<li><strong>DevX: Yes</strong> - No memory management, clean syntax, productive.</li>
</ul>
<p>Most promising new language. If BEAM&#39;s compute limits don&#39;t matter for your use case, watch this one. Though it probably needs corporate backing and several years to mature before it can gain the ecosystem and community it needs to compete.</p>
<h3 id="lua-embedded-niche-2.5">Lua - Embedded Niche (2.5)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - Dynamically typed, no static types built-in. <a href="https://github.com/teal-language/tl">Teal</a> (a typed dialect that compiles to Lua) exists but is not widely adopted. No sum types, no exhaustive matching in base Lua.</li>
<li><strong>Big Ecosystem: Mixed</strong> - Small but focused. Great for game scripting, embedded uses.</li>
<li><strong>Large Community: Mixed</strong> - Niche. Jobs exist in games/embedded.</li>
<li><strong>Performance: Mixed</strong> - LuaJIT is fast for a scripting language, but it&#39;s still a scripting language.</li>
<li><strong>DevX: Yes</strong> - Tiny footprint, easy to embed, no memory management for user code.</li>
</ul>
<p>Excellent at what it does (embedding), not a general-purpose choice.</p>
<h3 id="elixir-beam-without-types-2.5">Elixir - BEAM Without Types (2.5)</h3>
<ul>
<li><strong>Expressive Types: No</strong> - Dynamically typed. Type specs exist but not enforced.</li>
<li><strong>Big Ecosystem: Mixed</strong> - Hex is decent, BEAM ecosystem, good for web with Phoenix.</li>
<li><strong>Large Community: Mixed</strong> - Niche but dedicated (<a href="https://survey.stackoverflow.co/2025/technology">only 3% of developers use Elixir</a>). Jobs exist, especially for real-time/distributed.</li>
<li><strong>Performance: Mixed</strong> - BEAM excels at concurrency, struggles with compute.</li>
<li><strong>DevX: Yes</strong> - No memory management, pattern matching is nice, productive for web.</li>
</ul>
<p>Great for specific use cases (real-time, distributed web), but no types and niche usecase is a dealbreaker for me.</p>
<h3 id="zig-not-ready-yet-2.0">Zig - Not Ready Yet (2.0)</h3>
<ul>
<li><strong>Expressive Types: Mixed</strong> - Better than C, has tagged unions, but type system is still minimal compared to Rust/F#.</li>
<li><strong>Big Ecosystem: No</strong> - Very young, small package ecosystem.</li>
<li><strong>Large Community: No</strong> - Niche, growing interest but small.</li>
<li><strong>Performance: Yes</strong> - C-level performance, that&#39;s the point.</li>
<li><strong>DevX: Mixed</strong> - No GC but manual-ish memory (allocators). Simpler than C++ but still systems-level.</li>
</ul>
<p>Interesting C replacement, but not trying to be high-level. Not what I&#39;m looking for.</p>
<h2 id="why-does-this-gap-exist">Why Does This Gap Exist?</h2>
<h3 id="network-effects-lock-in-flawed-languages">Network Effects Lock In Flawed Languages</h3>
<p>Once a language is big, ecosystem compounds. Jobs exist, so people learn it, so more jobs exist. Even flawed languages stay dominant because switching costs are too high.</p>
<ul>
<li><strong>JavaScript</strong> - no native types, weird quirks (<code>[] + [] = &#34;&#34;</code>), but the web ecosystem is too massive.</li>
<li><strong>Python</strong> - slow and no sound types, but the data science/ML ecosystem locked it in.</li>
<li><strong>PHP</strong> - historically poor design, but WordPress and the web ecosystem keep it relevant.</li>
<li><strong>Java</strong> - verbose and no sum types, but enterprise investments are too large to abandon.</li>
</ul>
<p><em>Related: <a href="https://hamy.xyz/blog/2025-12_programming-language-death-spiral">The Programming Language Death Spiral</a></em></p>
<h3 id="backwards-compatibility-traps">Backwards Compatibility Traps</h3>
<p>Once a language has billions of lines of code in production, adding fundamental features becomes nearly impossible without breaking existing code.</p>
<ul>
<li><strong>Go</strong> - Can&#39;t add sum types because they would &#34;interfere [with interfaces] in destructive ways&#34; per a Go team member in a <a href="https://groups.google.com/g/golang-nuts/c/0bcyZaL3T8E">2011 golang-nuts discussion</a>.</li>
<li><strong>C#</strong> - Slowly adding F# features but they&#39;re clunky adaptations (unions &#34;coming&#34; for years).</li>
<li><strong>Java</strong> - Sealed classes are verbose compared to native discriminated unions.</li>
<li><strong>Python</strong> - Type hints can&#39;t be enforced at runtime without breaking the billions of lines that rely on duck typing.</li>
</ul>
<p>Easier to design right from scratch than retrofit.</p>
<h3 id="design-philosophy-misalignment">Design Philosophy Misalignment</h3>
<p>Sometimes languages miss important features not because of technical constraints, but because the creators&#39; backgrounds and problem domains didn&#39;t prioritize those needs.</p>
<ul>
<li><strong>Go</strong> - Created by systems programmers (Rob Pike, Ken Thompson, Robert Griesemer from Unix/Plan 9/JVM backgrounds) for &#34;working programmers at Google building large-scale server software.&#34; They prioritized simplicity, fast compilation, and concurrency over type safety. Sum types weren&#39;t in their mental model.</li>
<li><strong>Ruby</strong> - Matz designed Ruby to &#34;make programmers happy,&#34; explicitly prioritizing developer experience and dynamic typing over type safety. <a href="https://dev.to/adolfont/does-jose-valim-prefer-dynamic-typing-or-static-typing-27fg">He&#39;s stated</a> he believes type signatures will be obsolete, reflecting a deliberate philosophical choice.</li>
<li><strong>Python</strong> - The <a href="https://www.python.org/dev/peps/pep-0020/">&#34;Zen of Python&#34;</a> emphasizes &#34;readability&#34; and &#34;one obvious way&#34; - static types weren&#39;t part of the original vision. Guido later came around, stating type hints are valuable <a href="https://www.odbms.org/blog/2025/10/beyond-the-ai-hype-guido-van-rossum-on-pythons-philosophy-simplicity-and-the-future-of-programming/">above 10,000 lines of code</a>.</li>
<li><strong>Elixir</strong> - Jos√© Valim has stated he <a href="https://dev.to/adolfont/does-jose-valim-prefer-dynamic-typing-or-static-typing-27fg">prefers dynamic typing</a>, following Erlang&#39;s philosophy of building systems that &#34;manage to correct themselves when failures happen&#34; rather than catching all problems through typing. Gradual typing is now being added, but dynamic-first remains the philosophy.</li>
</ul>
<h3 id="ai-amplifies-the-adoption-gap-between-mainstream-and-niche-languages">AI Amplifies the Adoption Gap Between Mainstream and Niche Languages</h3>
<p>AI is better at top 10 languages (more training data). Small languages get worse AI support, making them harder to use. So larger languages will be easier to onboard to and stick with.</p>
<ul>
<li><strong>Languages with excellent AI support</strong>: Python, JavaScript, TypeScript, Java, C#, Go - massive training data, AI can write idiomatic code and knows ecosystem quirks.</li>
<li><strong>Languages with poor AI support</strong>: F#, Gleam, Elixir, Zig - small codebases mean AI hallucinates, suggests wrong patterns, or falls back to related languages (C# patterns for F#, Erlang patterns for Elixir).</li>
</ul>
<p>This accelerates <a href="https://hamy.xyz/blog/2025-12_programming-language-death-spiral">the death spiral</a> - developers choose languages where AI helps them, making those languages more popular, generating more training data, making AI even better at them.</p>
<h2 id="is-there-hope">Is There Hope?</h2>
<h3 id="c-unions-2026">C# Unions (2026?)</h3>
<p>Mads Torgersen outlined plans for C# 15. Even if it lands, will the ergonomics be good? F# interop is an open question. But if it works, C# becomes the closest thing to an S-tier language for general-purpose development.</p>
<h3 id="high-level-rust">High-Level Rust</h3>
<p>I&#39;m experimenting with writing Rust like a high-level language - Using Arc and Clone generously to avoid ownership and lifetime complexity. Trades some performance (10%) for productivity (??%). If this works, Rust could be the language I&#39;ve been looking for but really all depends on the devx gains.</p>
<h3 id="gleam">Gleam</h3>
<p>Great types, BEAM ecosystem. 70% admiration in its first Stack Overflow survey appearance (second only to Rust). If your use case is web/distributed and not compute-intensive, worth considering. But I do think it has several years of maturing / growing to do before it&#39;s &#34;stable&#34;.</p>
<h3 id="kotlin-multiplatform">Kotlin Multiplatform</h3>
<p>Already has the type system. JetBrains is actively pushing Kotlin Multiplatform for cross-platform development. If the multiplatform story matures and community expands beyond Android, it could hit S-tier.</p>
<p>Main gap: Community perception as &#34;the Android language&#34; - hard to shake even when the tech is there.</p>
<h3 id="typescript-runtime-validation">TypeScript Runtime Validation</h3>
<p>If runtime type checking became standard (runtime validators, ts-native libraries that enforce types), it would close the soundness gap. V8 keeps improving, Bun/Deno close the performance gap with compiled languages.</p>
<p>Main gap: Unsound types are a design choice, not a bug. Tooling can mitigate but may never fully fix.</p>
<h3 id="someone-builds-it">Someone Builds It</h3>
<p>The features exist. Someone just needs to combine them right. With a Rust backend for performance, TS-like syntax for familiarity, F#-like types for safety. A Zig moment for typed functional programming.</p>
<h2 id="next">Next</h2>
<p>The missing language is real. Each option forces a tradeoff I don&#39;t want to make.</p>
<p>For now, my approach: TypeScript for web stuff (pragmatic), C# for backend (best of the mainstream), trying out high-level Rust to see if it can be productive.</p>
<p>Maybe C# 15 is the answer. Maybe someone builds something new. Maybe I&#39;m too picky.</p>
<p>But I don&#39;t think wanting good types AND a good ecosystem is unreasonable. We should demand better from our tools.</p>
<p>Q: What&#39;s your current favorite language? What tradeoffs are you making for it?</p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2025-01_programming-language-tier-list">My 2025 Programming Language Tier List</a></li>
<li><a href="https://hamy.xyz/blog/2025-12_programming-language-death-spiral">The Programming Language Death Spiral</a></li>
<li><a href="https://hamy.xyz/blog/2024-04_comparing-ts-go-elixir-rust-fsharp">A Brief Comparison of Modern Programming Languages - TypeScript vs Golang vs Elixir vs Rust vs F#</a></li>
</ul>
</div></div>
  </body>
</html>
