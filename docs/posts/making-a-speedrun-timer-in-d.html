<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bradley.chatha.dev/blog/linux-speedrun-timer-dlang/post/">Original</a>
    <h1>Making a Speedrun Timer in D</h1>
    
    <div id="readability-page-1" class="page"><div> <section>  <section> <a href="https://bradley.chatha.dev/blog/linux-speedrun-timer-dlang"> <div> <svg width="1rem" height="1rem" viewBox="0 0 16 16" data-icon="rivet-icons:chevron-left">   <path fill="currentColor" d="M9.737.854L3.69 8l6.047 7.146l1.526-1.292L6.31 8l4.953-5.854z"></path> </svg> <p><span>Group: How I made a speedrun timer in D</span> </p></div> </a> </section>  <p>I semi-recently played through the original Deus Ex, and enjoyed my time with it so much that I felt like getting into speedrunning it, which ended up with me having to create a <a href="https://github.com/BradleyChatha/deusex-timer">custom speedrun timer</a> that “injects” itself into the game in order to implement features such as auto-splitting and load time removal.</p>
<p>This article details the rough journey I went through. It’s not super well structured, but I was sorely lacking resources such as this when I was implementing the more complicated parts of the timer, so I wanted to share my experience.</p>
<p>This is basically a detailing of “baby’s first game hack” as none of the techniques I’ve used here are advanced, and are more basic building blocks for injecting your own stuff into another process, but resources like this article were severely lacking/hard to find in my experience, so I imagine this will still be useful to someone.</p>
<p>If you read this entire thing then I’m afraid to say you have a fatal case of nerdism (welcome!).</p>
<h2 id="summary">Summary</h2>
<ul>
<li><a href="#linux-limitations">Linux Limitations</a></li>
<li><a href="#the-goal">The goal</a></li>
<li><a href="#the-search-for-a-loading-flag">The search for a loading flag</a></li>
<li><a href="#pre-requisite-research---syscalls">Pre-requisite research - syscalls</a></li>
<li><a href="#pre-requisite-research---finding-the-loadmap-function">Pre-requisite research - finding the LoadMap function</a></li>
<li><a href="#pre-requisite-research---finding-some-unused-memory-i-can-modify">Pre-requisite research - finding some unused memory I can modify</a></li>
<li><a href="#pre-requisite-research---summary">Pre-requisite research - summary</a></li>
<li><a href="#framework---runningprocess">Framework - RunningProcess</a></li>
<li><a href="#framework---gameprocess">Framework - GameProcess</a></li>
<li><a href="#framework---patcher">Framework - Patcher</a></li>
<li><a href="#framework---ui">Framework - UI</a></li>
<li><a href="#mvp---setting-the-flag">MVP - Setting the flag</a></li>
<li><a href="#mvp---unsetting-the-flag">MVP - Unsetting the flag</a></li>
<li><a href="#mvp---the-rest-of-the-owl">MVP - The rest of the owl</a></li>
<li><a href="#last-loaded-map---research">Last Loaded Map - research</a></li>
<li><a href="#last-loaded-map---reading-it-from-the-timer">Last Loaded Map - reading it from the timer</a></li>
<li><a href="#issue---exception-handling-isnt-patched">Issue - exception handling isn’t patched</a></li>
<li><a href="#issue---save-screens-arent-handled-at-all">Issue - Save screens aren’t handled at all</a></li>
<li><a href="#improvement---use-a-different-mechanism-for-detecting-loading-transitions">Improvement - use a different mechanism for detecting loading transitions</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="linux-limitations">Linux Limitations</h2>
<p>Deus Ex speedrunners on Windows will have access to LiveSplit, which is the standard go-to speedrunning tool. LiveSplit has a lot of features, one of which includes the ability to write plugins that implement auto-splitting and load removal for particular games.</p>
<p>To be brief: A “split” can be thought of as just a level in a game. Speedrunners often want to track how fast they perform individual levels/splits, and so will create a list of these splits to track and manage over time.</p>
<p>Most games require the speedrunner to manually trigger the next split once they’re done with their current one. This is annoying and inaccurate, so some games will have a plugin that enables auto-splitting - automatic detection of when the current split has finished (e.g. detecting a level change).</p>
<p>Additionally some games are very heavy on how many times the speedrunner must load levels or saves. As the time it takes for these loads to happen is very greatly dependent on the runner’s computer (and other factors), it’s common for these games to <em>not</em> take into account loading times into the final time achieved.</p>
<p>Some games will have LiveSplit plugins that implement this functionality - such as in Deus Ex’s case - however for technical reasons I’m not privy to, these plugins are unable to work on Linux, even if you use something like Wine to run LiveSplit (or maybe I just couldn’t figure it out myself, either/or).</p>
<p>This means if you speedrun on Linux you’ll have inferior tooling and a complete inability to perform auto-splitting and load removal, preventing you from getting an accurate measurement of how fast your runs and splits actually are.</p>
<h2 id="the-goal">The goal</h2>
<p>My goal with the timer was to have the following features:</p>
<ul>
<li>
<p>A timer that is relatively accurate (it’s really, really hard to even get close to 100% accuracy with external timing software).</p>
</li>
<li>
<p>The ability to detect when I reach a new level in order to power auto-splitting - ideally with as little delay as I can achieve.</p>
</li>
<li>
<p>The ability to detect when I’m in a loading screen, so the timer can automatically pause.</p>
</li>
<li>
<p>The ability to create and track splits.</p>
</li>
</ul>
<p>I decided to write the timer in the <a href="https://dlang.org/">D programming language</a> as:</p>
<ol>
<li>
<p>It’s my main language.</p>
</li>
<li>
<p>It’s a systems-level language with a C compatible memory model, so I can access all the lower level syscalls and functions I need as easily as I could in C or C++, with no compromises.</p>
</li>
<li>
<p>It has a sleuth of high-level features - including a garbage collector - so I can give myself a pleasent and easy to use interface in front of the lower level code.</p>
</li>
<li>
<p>(For Reddit and Hacker News if this gets posted there) No, D does not have 2 standard libraries, and that hasn’t been the case for a very long time. No, the GC doesn’t magically make this sort of program impossible. No, I’m not rewriting it in Rust or Zig. Yes, something something Dick joke something something. Thank you, please actually foster a discussion now.</p>
</li>
</ol>
<h2 id="the-search-for-a-loading-flag">The search for a loading flag</h2>
<p>Deus Ex was made on a very early version of the Unreal Engine, and so you can actually extract all of the game’s scripts directly from its compiled data as they’re just sitting there in plain text.</p>
<p>Specifically, by running <code>strings Engine.u</code> to extract all the plain text strings from one specific file, we can see the following enum:</p>
<div><figure><pre data-language="txt"><code><div><p><span>var transient enum ELevelAction</span></p></div><div><p><span><span>        </span></span><span>LEVACT_None,</span></p></div><div><p><span><span>        </span></span><span>LEVACT_Loading,</span></p></div><div><p><span><span>        </span></span><span>LEVACT_Saving,</span></p></div><div><p><span><span>        </span></span><span>LEVACT_Connecting,</span></p></div><div><p><span><span>        </span></span><span>LEVACT_Precaching</span></p></div><div><p><span>} LevelAction;</span></p></div></code></pre></figure></div>
<p>There also exists some code to set a global variable to <code>LEVACT_Loading</code> during a loading screen, so in theory I should be able to find a byte somewhere that changes to (what I assumed) to be <code>1</code> during loading, and <code>0</code> during normal gameplay, right? <em>right</em>?</p>
<p>I started off by:</p>
<ol>
<li>
<p>Running the game.</p>
</li>
<li>
<p>Using <code>ps aux</code> to find the PID for the game.</p>
</li>
<li>
<p>Attaching <a href="https://github.com/scanmem/scanmem">scanmem</a> to the PID so I can start pin-pointing where this mythical loading flag exists.</p>
</li>
<li>
<p>Trigger a loading screen; quickly swap to scanmem and trigger a scan for the value <code>1</code> - causing it to pause the game’s process while it performs a scan, and then repeating the process to whittle down the result list.</p>
</li>
</ol>
<p>In other old/simpler games this approach generally works to find a specific memory address for some specific variable, however I made the mistake of believing that Unreal’s VM/interpreter for its game script would lay out its memory in a clean, familiar way, and that it wouldn’t constantly allocate and move things around in memory all the time.</p>
<p>Ultimately I couldn’t find any singular memory address that changed to <code>1</code> during loading screens and <code>0</code> outside of them. I’d often find multiple addresses that behaved like this, but these addresses would always change during loading screens (or other events) and so were unfeasable to reliably use in the timer (trust me, I made a lot of <a href="https://github.com/BradleyChatha/deusex-timer/blob/master/source/old_app.d">hacky attempts</a> to make it work).</p>
<p>In the end I gave up on the idea of a quick win after at least 20 hours of my life gone, and instead accepted that I had needed to do things in a more “proper” way.</p>
<h2 id="pre-requisite-research---syscalls">Pre-requisite research - syscalls</h2>
<p>My next idea felt very ambitious, as this isn’t something I’d have ever done before, but in a way that also served as motivation to get it implemented and working.</p>
<p>Due to the very existance of debuggers I knew that there were ways to read and write into another process’ memory, and so I thought that the following process must be possible:</p>
<ol>
<li>
<p>I should be able to inject my own machine code into the game, so e.g. that I could set my own flag in a well-known location.</p>
</li>
<li>
<p>I should then be able to check said flag at regular intervals, and respond to it in kind.</p>
</li>
</ol>
<p>After a bit of google-fu I found a few syscalls that Linux supports which allow me to achieve these exact goals:</p>
<ul>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace</a> - This can do a lot, but essentially allows a process to become the “parent” of another process, and allows it to perform a lot of debugger-like activities.</p>
</li>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/process_vm_readv.2.html">process_vm_readv</a> - Allows one process to read from another process’ memory, as long as the parent process has <code>ptrace</code> permissions.</p>
</li>
</ul>
<p>Notably a <code>process_vm_writev</code> syscall also exists, however it adhears to memory page protections - so if I wanted to inject data into a write-protected memory page, it’d fail. Curiously <code>ptrace</code> is able to bypass protections, but has a different limitation in that you always have to “poke” 8 bytes at a time, no more, no less, which is definitely annoying to deal with.</p>
<p>While D does provide a lot of bindings for libc functions, it unfortunately (and sadly unsuprisingly) lacked bindings for these two functions.</p>
<p>D is heavily compatible with C however, so it’s trivial to define our own bindings:</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>core.sys.posix.sys.uio</span><span> : </span><span>iovec</span><span>;</span></p></div><div></div><div><p><span>// D fact: Enums don&#39;t physically exist in the final output like an `int PTRACE_ATTACH = 16` would,</span></p></div><div><p><span>// they&#39;re compile-time-only constants.</span></p></div><div><p><span>enum</span><span> </span><span>PTRACE_ATTACH</span><span> </span><span>=</span><span> </span><span>16</span><span>;</span></p></div><div><p><span>enum</span><span> </span><span>PTRACE_DETACH</span><span> </span><span>=</span><span> </span><span>17</span><span>;</span></p></div><div><p><span>enum</span><span> </span><span>PTRACE_POKEDATA</span><span> </span><span>=</span><span> </span><span>5</span><span>;</span></p></div><div></div><div><p><span>extern</span><span>(</span><span>C</span><span>) </span><span>long</span><span> </span><span>ptrace</span><span>(</span><span>int</span><span> </span><span>op</span><span>,</span><span> </span><span>int</span><span> </span><span>pid</span><span>,</span><span> </span><span>void*</span><span> </span><span>addr</span><span>,</span><span> </span><span>void*</span><span> </span><span>data</span><span>);</span></p></div><div><p><span>extern</span><span>(</span><span>C</span><span>) </span><span>ptrdiff_t</span><span> </span><span>process_vm_readv</span><span>(</span><span>int</span><span> </span><span>pid</span><span>,</span><span> </span><span>iovec</span><span>*</span><span> </span><span>local</span><span>,</span><span> </span><span>size_t</span><span> </span><span>len</span><span>,</span><span> </span><span>iovec</span><span>*</span><span> </span><span>remote</span><span>,</span><span> </span><span>size_t</span><span> </span><span>rlen</span><span>,</span><span> </span><span>ulong</span><span> </span><span>flags</span><span>);</span></p></div></code></pre></figure></div>
<h2 id="pre-requisite-research---finding-the-loadmap-function">Pre-requisite research - finding the LoadMap function</h2>
<p>So now that I had a way to write/read from the game’s memory, my next goal was to find an appropriate function to inject some custom logic into.</p>
<p>Windows binaries are in the <a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format">PE</a> format, and so after having a little read about the format itself there’s one section that stood out to me: the Export Address Table.</p>
<p>To keep it simple, for our purposes this table contains a list of functions that Unreal Engine exposes to the game, including a Relative Virtual Address (RVA) which is basically just an offset within the game’s machine code to the first instruction for any given, exported function.</p>
<p>Fortunately we can dump these tables even on Linux, in this case for Engine.dll: <code>llvm-readobj --coff-exports Engine.dll</code></p>
<p>I then searched for the word “Load” and quickly found this particular entry for a <code>LoadMap</code> function:</p>
<div><figure><pre data-language="c++"><code><div><p><span>Export {</span></p></div><div><p><span>  </span><span>Ordinal</span><span>: </span><span>1278</span></p></div><div><p><span>  </span><span>Name</span><span>: </span><span>?</span><span>LoadMap@UGameEngine@@UAEPAVULevel@@ABVFURL@@PAVUPendingLevel@@PBV</span><span>?</span><span>$TMap@VFString@@V1@@@AAVFString@@@Z</span></p></div><div><p><span><span>  </span></span><span>RVA</span><span>:</span><span> </span><span>0x</span><span>33A5</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>I then decompiled Engine.dll: <code>objdump -d Engine.dll</code> and noticed that the base address was <code>0x10300000</code>. So by adding the RVA (<code>0x33A5</code>) to this base address (equalling <code>0x103033A5</code>) we end up on this exact instruction:</p>
<div><figure><pre data-language="asm"><code><div><p><span>103033a5:</span><span>  e9 </span><span>46</span><span> 8e </span><span>08</span><span> </span><span>00</span><span>  </span><span>jmp</span><span> </span><span>0x1038c1f0</span></p></div></code></pre></figure></div>
<p><strong>Miracle #1:</strong> Since all calls to LoadMap point to this instruction which then jumps into the actual start address of the function, this is the only instruction I need to patch if I change the start address, rather than having to find and patch all <code>call</code> instructions for LoadMap instead.</p>
<p>Following the address that this jmp instruction points to leads us to the start of an actual function (the first two instructions setup a <a href="https://en.wikipedia.org/wiki/Call_stack#Structure">stack frame</a>, which is a dead giveaway):</p>
<div><figure><pre data-language="asm"><code><div><p><span>1038c1f0:</span><span>  </span><span>55</span><span>                 </span><span>push</span><span>   %</span><span>ebp</span></p></div><div><p><span>1038c1f1:</span><span>  8b ec              </span><span>mov</span><span>    %</span><span>esp</span><span>,%</span><span>ebp</span></p></div><div><p><span>1038c1f3:</span><span>  6a ff              </span><span>push</span><span>   $0xffffffff</span></p></div><div><p><span>1038c1f5:</span><span>  </span><span>68</span><span> bb ff </span><span>41</span><span> </span><span>10</span><span>     </span><span>push</span><span>   $0x1041ffbb</span></p></div><div><p><span>1038c1fa:</span><span>  </span><span>64</span><span> a1 </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>mov</span><span>    %</span><span>fs</span><span>:</span><span>0x0</span><span>,%</span><span>eax</span></p></div><div><p><span>1038c200:</span><span>  </span><span>50</span><span>                 </span><span>push</span><span>   %</span><span>eax</span></p></div><div><p><span>...</span></p></div></code></pre></figure></div>
<p>I don’t really know why, but functions in Engine.dll have a ton of <code>int3</code> instructions just before them, and a ton of <code>nop</code> instructions at the end:</p>
<div><figure><pre data-language="asm"><code><div><p><span>... even more int3s</span></p></div><div><p><span>1038c1ec:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ed:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ee:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ef:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1f0:</span><span>  </span><span>55</span><span>              </span><span>push</span><span>   %</span><span>ebp</span></p></div><div><p><span>1038c1f1:</span><span>  8b ec           </span><span>mov</span><span>    %</span><span>esp</span><span>,%</span><span>ebp</span></p></div><div><p><span>... </span><span>rest</span><span> of LoadMap</span></p></div><div><p><span>1038e72b:</span><span>  6a </span><span>00</span><span>           </span><span>push</span><span>   $0x0</span></p></div><div><p><span>1038e72d:</span><span>  e8 9e </span><span>4d</span><span> </span><span>08</span><span> </span><span>00</span><span>  </span><span>call</span><span>   </span><span>0x104134d0</span></p></div><div><p><span>1038e732</span><span>:  </span><span>90</span><span>              </span><span>nop</span></p></div><div><p><span>1038e733</span><span>:  </span><span>90</span><span>              </span><span>nop</span></p></div><div><p><span>1038e734</span><span>:  </span><span>90</span><span>              </span><span>nop</span></p></div><div><p><span>1038e735</span><span>:  </span><span>90</span><span>              </span><span>nop</span></p></div><div><p><span>... even more nops, followed by int3s</span></p></div></code></pre></figure></div>
<p><strong>Miracle #2</strong>: We have plenty of free space to inject our own code, so we don’t have to do any other potential shennanigans with shuffling the entire function about, but only portions of it - I’ll get to that part later.</p>
<p>Just to confirm that this is indeed <strong>the</strong> LoadMap function, I performed the following steps:</p>
<ol>
<li>
<p>I launched the game.</p>
</li>
<li>
<p>I used <code>ps aux</code> and manually searched for which PID the game was running under.</p>
</li>
<li>
<p>I attached a debugger to the game via <code>lldb -p $PID</code>.</p>
</li>
<li>
<p>I created a breakpoint at LoadMap’s first push instruction <code>b 0x1038c1f0</code>.</p>
</li>
<li>
<p>I loaded the game’s first level, and saw that the breakpoint triggered!</p>
</li>
</ol>
<div><figure><pre data-language="asm"><code><div><p><span>Process </span><span>2620396</span><span> stopped</span></p></div><div><p><span>* thread #</span><span>1</span><span>, name = &#39;DeusEx.exe&#39;, stop reason = breakpoint </span><span>1.1</span></p></div><div><p><span><span>    </span></span><span>frame #</span><span>0</span><span>: </span><span>0x1038c1f0</span></p></div><div><p><span>-&gt;  </span><span>0x1038c1f0</span><span>: pushl  %</span><span>ebp</span></p></div><div><p><span>    </span><span>0x1038c1f1</span><span>: movl   %</span><span>esp</span><span>, %</span><span>ebp</span></p></div><div><p><span>    </span><span>0x1038c1f3</span><span>: pushl  $-</span><span>0x1</span></p></div><div><p><span>    </span><span>0x1038c1f5</span><span>: pushl  $0x1041ffbb    </span><span>; imm = 0x1041FFBB</span></p></div></code></pre></figure></div>
<h2 id="pre-requisite-research---finding-some-unused-memory-i-can-modify">Pre-requisite research - finding some unused memory I can modify</h2>
<p>With a way to modify the game’s code; the location of the LoadMap function, and the general idea that I want to modify LoadMap so that it sets a <code>loading</code> flag somewhere, I now need to find where that “somewhere” is.</p>
<p>Linux allows you to inspect the memory maps for any process by looking at the special <code>/proc/&lt;PID&gt;/maps</code> file. Here’s two example entries:</p>
<div><figure><pre data-language="text"><code><div><p><span>f7f6c000-f7f6d000 rw-p 00003000 fe:00 469819172 /home/bradley/.local/share/Steam/steamapps/common/Proton - Experimental/files/bin/wine</span></p></div><div><p><span>f7f6d000-f7f6f000 r--p 00000000 00:00 0         [vvar]</span></p></div></code></pre></figure></div>
<p>I won’t go through the entire format, but essentially what I’m looking for is an area of memory that is writeable (has the <code>w</code> flag) and has a small portion that the game never uses itself (so it doesn’t clobber my own values I stuff there).</p>
<p>When a process is running in memory, it’ll have maps containing the contents of any shared libraries that it’s linked against. Interestingly this holds true for Windows DLLs running under Wine/Proton as well (I have a big knowledge gap here if you couldn’t tell).</p>
<p>So if we look for mappings for <code>Engine.dll</code> that we can also write to (which may or may not be a good idea for me to use ;D) - <code>cat /proc/2637581/maps | grep -E &#34; .w.. .+Engine.dll&#34;</code>, we can see there’s at least two writeable mappings:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>10479000-10486000 rwxp 00179000 103:02 2416829569 /nvme2/Games/steamapps/common/Deus Ex/System/Engine.dll</span></p></div><div><p><span>10599000-105a0000 rwxp 00186000 103:02 2416829569 /nvme2/Games/steamapps/common/Deus Ex/System/Engine.dll</span></p></div></code></pre></figure></div>
<p>Being able to use one of these maps to store our data would be useful, since it’d be easy to code for “find the second Engine.dll mapping and use the last few bytes for our own purposes” rather than a more generalised approach.</p>
<p>So I run the game; attach to it with lldb, and use <code>mem read 0x105a0000-0xFF -c 0xFF -s1</code> to peek at the last 255 bytes of the second mapping. It was all 0!</p>
<p>I did a casual <del>slowrun</del> speedrun; ocassionally running the above lldb command, and saw that nothing ever seems to write to this area of memory, making it a perfect area for us to store the little bits and bobs we need for ourselves.</p>
<h2 id="pre-requisite-research---summary">Pre-requisite research - summary</h2>
<ul>
<li>
<p>I have the means to access the game’s memory from another process, which includes modifying its running machine code.</p>
</li>
<li>
<p>I have the perfect function to modify in order to track whether we’re in a loading screen or not.</p>
</li>
<li>
<p>I have a consistent memory location that should always be safe to store a bit of custom data into.</p>
</li>
</ul>
<p>At this point it was clear there was a valid pathway for me to implement the new plan, and so came time to get a small MVP of the injection functionality sorted.</p>
<h2 id="framework---runningprocess">Framework - RunningProcess</h2>
<p>Instead of hacking together a bunch of code like I was doing with my earlier experiments, I decided that it was worth the time to setup a mini framework for myself in order to keep myself sane (and keep the code clean, I <em>guess</em>).</p>
<p>The first thing I needed was a way to list all running processes so I can find which one the game is.</p>
<p>By iterating over the directories of <code>/proc/</code> we can easily discover all currently running PIDs, as most directory names are a PID. I’ve already talked about <code>/proc/&lt;PID&gt;/maps</code>, but there’s also another interesting file called <code>/proc/&lt;PID&gt;/comm</code> which contains the name of the binary that the process was created for:</p>
<div><figure><pre data-language="bash"><code><div><p><span>&gt;</span><span> cat /proc/2637581/comm</span></p></div><div><p><span>DeusEx.exe</span></p></div></code></pre></figure></div>
<p>In other words we can easily find the PID for the game by just looking out for which one has <code>DeusEx.exe</code> as its <code>comm</code>.</p>
<p>I started off with writing a <code>RunningProcess</code> struct that contains a static function to eagerly fetch all currently running processes:</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>RunningProcess</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>int</span><span> </span><span>pid</span><span>;</span></p></div><div></div><div><p><span>    </span><span>// Values directly corresponding to the same named files in /proc/&lt;pid&gt;/</span></p></div><div><p><span>    </span><span>string</span><span> </span><span>cmdline</span><span>;</span></p></div><div><p><span>    </span><span>string</span><span> </span><span>comm</span><span>;</span></p></div><div></div><div><p><span>    </span><span>static</span><span> </span><span>RunningProcess</span><span>[] </span><span>listAll</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>// D fact: Scoped, selective imports!</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>all</span><span>,</span><span> </span><span>filter</span><span>,</span><span> </span><span>map</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.array</span><span>     : </span><span>array</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.conv</span><span>      : </span><span>to</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.file</span><span>      : </span><span>dirEntries</span><span>,</span><span> </span><span>SpanMode</span><span>,</span><span> </span><span>readText</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.path</span><span>      : </span><span>baseName</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.string</span><span>    : </span><span>chomp</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.uni</span><span>       : </span><span>isNumber</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// D fact: UFCS (Uniform Function Call Syntax) allows all free standing functions</span></p></div><div><p><span>        </span><span>//         to use member function call syntax. &#34;baz(bar(foo))&#34; can be written as &#34;foo.bar().baz()&#34;</span></p></div><div><p><span>        </span><span>//</span></p></div><div><p><span>        </span><span>// Also:   `!Yada` and `!(Yada)` are used to pass in template parameters.</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>dirEntries</span><span>(</span><span>&#34;/proc&#34;</span><span>,</span><span> </span><span>SpanMode.shallow</span><span>)</span></p></div><div><p><span><span>            </span></span><span>.</span><span>filter</span><span>!(</span><span>de</span><span> =&gt; </span><span>de.baseName.all</span><span>!</span><span>isNumber</span><span>)</span></p></div><div><p><span><span>            </span></span><span>.</span><span>map</span><span>!((</span><span>de</span><span>) {</span></p></div><div><p><span>                </span><span>RunningProcess</span><span> </span><span>process</span><span>;</span></p></div><div><p><span>                </span><span>process.pid</span><span> </span><span>=</span><span> </span><span>de.baseName.to</span><span>!int</span><span>;</span></p></div><div></div><div><p><span>                </span><span>// D fact: `A ~ B` means &#34;append B to A&#34;</span></p></div><div><p><span>                </span><span>process.cmdline</span><span> </span><span>=</span><span> </span><span>readText</span><span>(</span><span>de.name</span><span> </span><span>~</span><span> </span><span>&#34;/cmdline&#34;</span><span>).</span><span>chomp</span><span>; </span><span>// NOTE: cmdline isn&#39;t too interesting to explain, so I&#39;ve ignored it.</span></p></div><div><p><span>                </span><span>process.comm</span><span>    </span><span>=</span><span> </span><span>readText</span><span>(</span><span>de.name</span><span> </span><span>~</span><span> </span><span>&#34;/comm&#34;</span><span>).</span><span>chomp</span><span>;</span></p></div><div></div><div><p><span>                </span><span>return</span><span> </span><span>process</span><span>;</span></p></div><div><p><span><span>            </span></span><span>})</span></p></div><div><p><span><span>            </span></span><span>.</span><span>array</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>string</span><span> </span><span>command</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>this</span><span>.cmdline.length</span><span> ? </span><span>this</span><span>.cmdline</span><span> : </span><span>this</span><span>.comm</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h2 id="framework---gameprocess">Framework - GameProcess</h2>
<p>Now I wanted a wrapper around a RunningProcess that had more specific functionality for handling <code>ptrace</code>, as well as reading data (but not writing yet).</p>
<p>I started off with a simple enough class that can handle attaching and detaching from the game process via <code>ptrace</code>:</p>
<div><figure><pre data-language="d"><code><div><p><span>class</span><span> </span><span>GameProcess</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>int</span><span> </span><span>_pid</span><span>;</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>_attached</span><span>;</span></p></div><div></div><div><p><span>        </span><span>this</span><span>(</span><span>int</span><span> </span><span>pid</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>this</span><span>._pid</span><span> </span><span>=</span><span> </span><span>pid</span><span>;</span></p></div><div><p><span>            </span><span>this.attach</span><span>();</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>~</span><span>this</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>this</span><span>._pid</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>this</span><span>._attached</span><span>)</span></p></div><div><p><span>            </span><span>this.detach</span><span>();</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>static</span><span> </span><span>GameProcess</span><span> </span><span>fromPid</span><span>(</span><span>int</span><span> </span><span>pid</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>new </span><span>GameProcess</span><span>(</span><span>pid</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>static</span><span> </span><span>GameProcess</span><span> </span><span>fromProcess</span><span>(</span><span>RunningProcess</span><span> </span><span>process</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>new </span><span>GameProcess</span><span>(</span><span>process.pid</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>attach</span><span>()</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>!this</span><span>._attached</span><span>,</span><span> </span><span>&#34;Already attached&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>ptrace</span><span>(</span><span>PTRACE_ATTACH</span><span>,</span><span> </span><span>pid</span><span>,</span><span> </span><span>null</span><span>,</span><span> </span><span>null</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>// I kept procrastinating on DRYing this, and eventually gave up on the idea entirely, so this</span></p></div><div><p><span>            </span><span>// code is duplicated a _lot_.</span></p></div><div><p><span>            </span><span>import</span><span> </span><span>core.stdc.errno</span><span> : </span><span>errno</span><span>;</span></p></div><div><p><span>            </span><span>import</span><span> </span><span>std.string</span><span> : </span><span>fromStringz</span><span>;</span></p></div><div><p><span>            </span><span>import</span><span> </span><span>core.sys.posix.string</span><span> : </span><span>strerror</span><span>;</span></p></div><div><p><span>            </span><span>throw</span><span> </span><span>new </span><span>Exception</span><span>(</span><span>&#34;Failed to attach to process: &#34;</span><span> </span><span>~</span><span> </span><span>strerror</span><span>(</span><span>errno</span><span>).</span><span>fromStringz.idup</span><span>);</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>this</span><span>._attached</span><span> </span><span>=</span><span> </span><span>true</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>detach</span><span>()</span></p></div><div><p><span>    </span><span>in</span><span>(</span><span>this</span><span>._attached</span><span>,</span><span> </span><span>&#34;Not attached&#34;</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>ptrace</span><span>(</span><span>PTRACE_DETACH</span><span>,</span><span> </span><span>pid</span><span>,</span><span> </span><span>null</span><span>,</span><span> </span><span>null</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span><span>/*...*/</span><span>}</span></p></div><div></div><div><p><span>        </span><span>this</span><span>._attached</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>pause</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>core.sys.posix.signal</span><span> : </span><span>kill</span><span>,</span><span> </span><span>SIGSTOP</span><span>;</span></p></div><div><p><span>        </span><span>kill</span><span>(</span><span>this</span><span>._pid</span><span>,</span><span> </span><span>SIGSTOP</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>resume</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>core.sys.posix.signal</span><span> : </span><span>kill</span><span>,</span><span> </span><span>SIGCONT</span><span>;</span></p></div><div><p><span>        </span><span>kill</span><span>(</span><span>this</span><span>._pid</span><span>,</span><span> </span><span>SIGCONT</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>int</span><span> </span><span>pid</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>this</span><span>._pid</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>I was then able to write a small function to select the Deus Ex process, and wrap it into a <code>GameProcess</code>:</p>
<div><figure><pre data-language="d"><code><div><p><span>int</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>GameProcess</span><span> </span><span>deusex</span><span>;</span></p></div><div><p><span>    </span><span>Patcher</span><span> </span><span>enginePatcher</span><span>; </span><span>// Ignore for now - I&#39;ll get to this</span></p></div><div><p><span>    </span><span>findDeusEx</span><span>(</span><span>deusex</span><span>,</span><span> </span><span>enginePatcher</span><span>);</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>findDeusEx</span><span>(</span><span>out</span><span> </span><span>GameProcess</span><span> </span><span>deusex</span><span>,</span><span> </span><span>out</span><span> </span><span>Patcher</span><span> </span><span>enginePatcher</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>;</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.range</span><span>     : </span><span>takeExactly</span><span>;</span></p></div><div></div><div><p><span>    </span><span>auto</span><span> </span><span>process</span><span> </span><span>=</span><span> </span><span>RunningProcess</span></p></div><div><p><span>                    </span><span>.listAll</span><span>()</span></p></div><div><p><span><span>                    </span></span><span>.</span><span>filter</span><span>!(</span><span>p</span><span> =&gt; </span><span>p.comm</span><span> </span><span>==</span><span> </span><span>&#34;deusex.exe&#34;</span><span> </span><span>||</span><span> </span><span>p.comm</span><span> </span><span>==</span><span> </span><span>&#34;DeusEx.exe&#34;</span><span>)</span></p></div><div><p><span>                    </span><span>.takeExactly</span><span>(</span><span>1</span><span>)</span></p></div><div><p><span><span>                    </span></span><span>.</span><span>front</span><span>;</span></p></div><div></div><div><p><span>    </span><span>deusex</span><span> </span><span>=</span><span> </span><span>GameProcess.fromProcess</span><span>(</span><span>process</span><span>);</span></p></div><div></div><div><p><span>    </span><span>// Again, I&#39;ll get to this a bit later.</span></p></div><div><p><span>    </span><span>enginePatcher</span><span> </span><span>=</span><span> </span><span>new </span><span>Patcher</span><span>(</span><span>deusex</span><span>,</span><span> (</span><span>map</span><span>){</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>endsWith</span><span>;</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>map.pathname.endsWith</span><span>(</span><span>&#34;Engine.dll&#34;</span><span>);</span></p></div><div><p><span><span>    </span></span><span>});</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>As I also needed programatic access of the process’ memory maps, I decided to stuff that into GameProcess as well. I decided to use a simple regex since it just needed to be a quick and simple solution:</p>
<div><figure><pre data-language="d"><code><div><p><span>class</span><span> </span><span>GameProcess</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// D fact: Nested structs/classes will be given a hidden context pointer to the parent type,</span></p></div><div><p><span>    </span><span>//         unless you mark it as `static`.</span></p></div><div><p><span>    </span><span>static</span><span> </span><span>struct</span><span> </span><span>MemoryMap</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>ulong</span><span> </span><span>start</span><span>;</span></p></div><div><p><span>        </span><span>ulong</span><span> </span><span>end</span><span>;</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>readable</span><span>;</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>writable</span><span>;</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>executable</span><span>;</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>private_</span><span>;</span></p></div><div><p><span>        </span><span>ulong</span><span> </span><span>offset</span><span>;</span></p></div><div><p><span>        </span><span>uint</span><span> </span><span>major</span><span>;</span></p></div><div><p><span>        </span><span>uint</span><span> </span><span>minor</span><span>;</span></p></div><div><p><span>        </span><span>uint</span><span> </span><span>inode</span><span>;</span></p></div><div><p><span>        </span><span>string</span><span> </span><span>pathname</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>MemoryMap</span><span>[] </span><span>_maps</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>refreshMaps</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.conv</span><span>   : </span><span>to</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.file</span><span>   : </span><span>readText</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.string</span><span> : </span><span>lineSplitter</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.regex</span><span>  : </span><span>regex</span><span>,</span><span> </span><span>matchFirst</span><span>;</span></p></div><div></div><div><p><span>        </span><span>// D fact: `r` strings don&#39;t support escape characters, so they&#39;re great for regexes!</span></p></div><div><p><span>        </span><span>MemoryMap</span><span>[] </span><span>mappings</span><span>;</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>reg</span><span> </span><span>=</span><span> </span><span>regex</span><span>(</span><span>r&#34;([0-9a-f]+)-([0-9a-f]+)\s+([-r][-w][-x][-p])\s+([0-9a-f]+)\s+([0-9a-f]+):([0-9a-f]+)\s([0-9]+)\s+(.*)&#34;</span><span>);</span></p></div><div></div><div><p><span>        </span><span>foreach</span><span>(</span><span>line</span><span>;</span><span> </span><span>readText</span><span>(</span><span>&#34;/proc/&#34;</span><span> </span><span>~</span><span> </span><span>this</span><span>._pid.to</span><span>!string</span><span> </span><span>~</span><span> </span><span>&#34;/maps&#34;</span><span>).</span><span>lineSplitter</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>const</span><span> </span><span>captures</span><span> </span><span>=</span><span> </span><span>line.matchFirst</span><span>(</span><span>reg</span><span>);</span></p></div><div><p><span>            </span><span>if</span><span>(</span><span>!</span><span>captures</span><span>)</span></p></div><div><p><span>                </span><span>continue</span><span>;</span></p></div><div></div><div><p><span>            </span><span>mappings</span><span> </span><span>~=</span><span> </span><span>MemoryMap</span><span>(</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>1</span><span>].</span><span>to</span><span>!</span><span>ulong</span><span>(</span><span>16</span><span>)</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>2</span><span>].</span><span>to</span><span>!</span><span>ulong</span><span>(</span><span>16</span><span>)</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>3</span><span>][</span><span>0</span><span>] </span><span>==</span><span> </span><span>&#39;r&#39;</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>3</span><span>][</span><span>1</span><span>] </span><span>==</span><span> </span><span>&#39;w&#39;</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>3</span><span>][</span><span>2</span><span>] </span><span>==</span><span> </span><span>&#39;x&#39;</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>3</span><span>][</span><span>3</span><span>] </span><span>==</span><span> </span><span>&#39;p&#39;</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>4</span><span>].</span><span>to</span><span>!</span><span>ulong</span><span>(</span><span>16</span><span>)</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>5</span><span>].</span><span>to</span><span>!</span><span>uint</span><span>(</span><span>16</span><span>)</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>6</span><span>].</span><span>to</span><span>!</span><span>uint</span><span>(</span><span>16</span><span>)</span><span>,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>7</span><span>].</span><span>to</span><span>!uint,</span></p></div><div><p><span>                </span><span>captures</span><span>[</span><span>8</span><span>]</span></p></div><div><p><span><span>            </span></span><span>);</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>this</span><span>._maps</span><span> </span><span>=</span><span> </span><span>mappings</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>bool</span><span> </span><span>mapStillExists</span><span>(</span><span>MemoryMap</span><span> </span><span>map</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>any</span><span>;</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>this</span><span>._maps.any</span><span>!(</span><span>m</span><span> =&gt; </span><span>m.start</span><span> </span><span>==</span><span> </span><span>map.start</span><span> </span><span>&amp;&amp;</span><span> </span><span>m.end</span><span> </span><span>==</span><span> </span><span>map.end</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>MemoryMap</span><span>[] </span><span>memoryMaps</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>this</span><span>._maps</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Finally, GameProcess also needed to provide an interface for reading memory from the game, which is where the <code>process_vm_readv</code> comes in.</p>
<p>One issue I ran into with <code>process_vm_readv</code> is that it would often fail to accurately read larger chunks of memory, providing me with completely wrong values. I suspect this is because <code>process_vm_readv</code> for some reason doesn’t ensure the pages it needs to read from are still swapped in by the time it reads from them (or some other page related madness)?</p>
<p>Either way, this is why the following code snippet provides the <code>peek</code> functions for cases where I only need to access a specific portion of the game’s memory, instead of entire maps at a time.</p>
<p>In short, <code>process_vm_readv</code> works by filling in at least two <code>iovec</code> structures - one containing a pointer + length for a buffer on the caller process’ side, and one pointing to a memory address + length on the target process’ side. Linux will then copy the target process’ memory over to the caller process’ provided buffer.</p>
<div><figure><pre data-language="d"><code><div><p><span>class</span><span> </span><span>GameProcess</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// D fact: A `delegate` is a function pointer with a hidden context pointer attached to it, e.g.</span></p></div><div><p><span>    </span><span>//         so the delegate can access stack variables.</span></p></div><div><p><span>    </span><span>void</span><span> </span><span>accessMemory</span><span>(</span><span>MemoryMap</span><span> </span><span>map</span><span>,</span><span> </span><span>void</span><span> </span><span>delegate</span><span>(</span><span>scope</span><span> </span><span>const</span><span> </span><span>ubyte</span><span>[]) </span><span>callback</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>core.memory</span><span> : </span><span>GC</span><span>;</span></p></div><div></div><div><p><span>        </span><span>auto</span><span> </span><span>buffer</span><span> </span><span>=</span><span> (</span><span>cast(ubyte</span><span>*</span><span>)</span><span>GC.malloc</span><span>(</span><span>map.end</span><span> </span><span>-</span><span> </span><span>map.start</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>typeid</span><span>(</span><span>ubyte</span><span>)))[</span><span>0</span><span>..</span><span>map.end</span><span> </span><span>-</span><span> </span><span>map.start</span><span>];</span></p></div><div><p><span>        </span><span>scope(exit)</span><span> </span><span>GC.free</span><span>(</span><span>buffer.ptr</span><span>); </span><span>// scope(exit) is just like `defer` in Go.</span></p></div><div></div><div><p><span>        </span><span>iovec</span><span> </span><span>local</span><span>;</span></p></div><div><p><span>        </span><span>local.iov_base</span><span> </span><span>=</span><span> </span><span>buffer.ptr</span><span>;</span></p></div><div><p><span>        </span><span>local.iov_len</span><span> </span><span>=</span><span> </span><span>buffer.length</span><span>;</span></p></div><div></div><div><p><span>        </span><span>iovec</span><span> </span><span>remote</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_base</span><span> </span><span>=</span><span> </span><span>cast(void</span><span>*</span><span>)</span><span>map.start</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_len</span><span> </span><span>=</span><span> </span><span>buffer.length</span><span>;</span></p></div><div></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>process_vm_readv</span><span>(</span><span>this</span><span>._pid</span><span>,</span><span> </span><span>&amp;</span><span>local</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>&amp;</span><span>remote</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{ </span><span>/* error handling */</span><span> }</span></p></div><div></div><div><p><span>        </span><span>callback</span><span>(</span><span>buffer</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>T</span><span> </span><span>peek</span><span>(</span><span>T</span><span>)(</span><span>size_t</span><span> </span><span>address</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>T</span><span> </span><span>ret</span><span>;</span></p></div><div></div><div><p><span>        </span><span>iovec</span><span> </span><span>local</span><span>;</span></p></div><div><p><span>        </span><span>local.iov_base</span><span> </span><span>=</span><span> </span><span>cast(void</span><span>*</span><span>)&amp;</span><span>ret</span><span>;</span></p></div><div><p><span>        </span><span>local.iov_len</span><span> </span><span>=</span><span> </span><span>T.sizeof</span><span>;</span></p></div><div></div><div><p><span>        </span><span>iovec</span><span> </span><span>remote</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_base</span><span> </span><span>=</span><span> </span><span>cast(void</span><span>*</span><span>)</span><span>address</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_len</span><span> </span><span>=</span><span> </span><span>T.sizeof</span><span>;</span></p></div><div></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>process_vm_readv</span><span>(</span><span>this</span><span>._pid</span><span>,</span><span> </span><span>&amp;</span><span>local</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>&amp;</span><span>remote</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{ </span><span>/* error handling */</span><span> }</span></p></div><div></div><div><p><span>        </span><span>return</span><span> </span><span>ret</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>ubyte</span><span>[] </span><span>peek</span><span>(</span><span>size_t</span><span> </span><span>address</span><span>,</span><span> </span><span>return</span><span> </span><span>ubyte</span><span>[] </span><span>buffer</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>iovec</span><span> </span><span>local</span><span>;</span></p></div><div><p><span>        </span><span>local.iov_base</span><span> </span><span>=</span><span> </span><span>cast(void</span><span>*</span><span>)&amp;</span><span>buffer</span><span>[</span><span>0</span><span>];</span></p></div><div><p><span>        </span><span>local.iov_len</span><span> </span><span>=</span><span> </span><span>buffer.length</span><span>;</span></p></div><div></div><div><p><span>        </span><span>iovec</span><span> </span><span>remote</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_base</span><span> </span><span>=</span><span> </span><span>cast(void</span><span>*</span><span>)</span><span>address</span><span>;</span></p></div><div><p><span>        </span><span>remote.iov_len</span><span> </span><span>=</span><span> </span><span>buffer.length</span><span>;</span></p></div><div></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>process_vm_readv</span><span>(</span><span>this</span><span>._pid</span><span>,</span><span> </span><span>&amp;</span><span>local</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>&amp;</span><span>remote</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>0</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{ </span><span>/* error handling */</span><span> }</span></p></div><div></div><div><p><span>        </span><span>return</span><span> </span><span>buffer</span><span>[</span><span>0</span><span>..</span><span>result</span><span>];</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Since D contains a bunch of high-level features like first-class functions, I decided to make <code>accessMemory</code> use a callback pattern, so that the caller never has to worry about dealing with the underlying short-lived memory (which I only do to reduce the amount of GC pauses, by freeing early to hopefully reduce pressure).</p>
<p>Here’s a few snippets on how these functions are used, these snippets will be covered in depth later on:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Example of accessMemory</span></p></div><div><p><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>retPopAndMovInstructions</span><span>;</span></p></div><div><p><span>deusex.accessMemory</span><span>(</span><span>loadMapSig.map</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memory</span><span>){</span></p></div><div><p><span>    </span><span>// Note: since we&#39;re assigning to a static array, the data is copied - `memory` is NOT being incorrectly escaped</span></p></div><div><p><span>    </span><span>retPopAndMovInstructions</span><span> </span><span>=</span><span> </span><span>memory</span><span>[</span><span>retPopAndMovOffset</span><span>..</span><span>retPopAndMovOffset</span><span>+</span><span>8</span><span>];</span></p></div><div></div><div><p><span>    </span><span>const</span><span> </span><span>target</span><span> </span><span>=</span><span> [</span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>]; </span><span>// nop nop nop nop</span></p></div><div><p><span>    </span><span>while</span><span>(</span><span>endOfLoadMapInstructions</span><span> </span><span>&lt;</span><span> </span><span>memory.length</span><span> </span><span>-</span><span> </span><span>target.length</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>memory</span><span>[</span><span>endOfLoadMapInstructions</span><span>..</span><span>endOfLoadMapInstructions</span><span>+</span><span>target.length</span><span>] </span><span>==</span><span> </span><span>target</span><span>)</span></p></div><div><p><span>            </span><span>return</span><span>;</span></p></div><div><p><span>        </span><span>endOfLoadMapInstructions</span><span>++</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>throw</span><span> </span><span>new </span><span>Exception</span><span>(</span><span>&#34;Could not find end of LoadMap?&#34;</span><span>);</span></p></div><div><p><span>});</span></p></div><div></div><div><p><span>// Example of peek</span></p></div><div></div><div><p><span>// process_vm_readv sometimes fails with ESRCH and I have no idea why, so ignore any errors for now.</span></p></div><div><p><span>bool</span><span> </span><span>isLoading</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span></p></div><div><p><span>try</span><span> </span><span>isLoading</span><span> </span><span>=</span><span> </span><span>deusex.peek</span><span>!bool</span><span>(</span><span>flagsAddress</span><span>);</span></p></div><div><p><span>catch</span><span>(</span><span>Exception</span><span>) </span><span>return</span><span>;</span></p></div></code></pre></figure></div>
<p>This should hopefully showcase why I love using D - in this case it effortlessly allowed me to wrap my low-level code in a higher-level syntax, without any real compromise or additional complexity.</p>
<h2 id="framework---patcher">Framework - Patcher</h2>
<p>For the final part of the “low-level” related classes, we have the <code>Patcher</code> class which as the name implies, is responsible for allowing me to modify the game’s memory.</p>
<p>I originally imagined the patcher as being a lot more complex than it ended up being, hence why I decided to have a dedicated class for write operations, but realistically I could’ve gotten away with putting this stuff into <code>GameProcess</code> as well.</p>
<p>Here’s the class in mostly its entirety, with some legacy cruft removed:</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.typecons</span><span> : </span><span>Nullable</span><span>;</span></p></div><div></div><div><p><span>class</span><span> </span><span>Patcher</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// D fact: alias != typedef, it&#39;s basically just a way to provide a different name for an existing type,</span></p></div><div><p><span>    </span><span>//         rather than creating an entirely new type.</span></p></div><div><p><span>    </span><span>alias</span><span> </span><span>MapSelector</span><span> </span><span>=</span><span> </span><span>bool</span><span> </span><span>delegate</span><span>(</span><span>const</span><span> </span><span>GameProcess.MemoryMap</span><span>);</span></p></div><div></div><div><p><span>    </span><span>static</span><span> </span><span>struct</span><span> </span><span>FunctionEstimate</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>GameProcess.MemoryMap</span><span> </span><span>map</span><span>;</span></p></div><div><p><span>        </span><span>size_t</span><span> </span><span>offset</span><span>;</span></p></div><div><p><span>        </span><span>size_t</span><span> </span><span>estimatedSize</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>GameProcess</span><span> </span><span>_process</span><span>;</span></p></div><div><p><span>        </span><span>MapSelector</span><span> </span><span>_mapSelector</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>this</span><span>(</span><span>GameProcess</span><span> </span><span>process</span><span>,</span><span> </span><span>MapSelector</span><span> </span><span>selector</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this</span><span>._process</span><span> </span><span>=</span><span> </span><span>process</span><span>;</span></p></div><div><p><span>        </span><span>this</span><span>._mapSelector</span><span> </span><span>=</span><span> </span><span>selector</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>Nullable</span><span>!</span><span>FunctionEstimate</span><span> </span><span>signatureScan</span><span>(</span></p></div><div><p><span>        </span><span>int</span><span>[] </span><span>bytes</span><span>,</span></p></div><div><p><span>        </span><span>size_t</span><span> </span><span>delegate</span><span>(</span><span>scope</span><span> </span><span>const</span><span> </span><span>ubyte</span><span>[] </span><span>memoryStartingFromSignature</span><span>) </span><span>sizeEstimator</span><span>,</span></p></div><div><p><span><span>    </span></span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this._process.refreshMaps</span><span>();</span></p></div><div><p><span>        </span><span>foreach</span><span>(</span><span>map</span><span>;</span><span> </span><span>this</span><span>._process.memoryMaps</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>if</span><span>(</span><span>!</span><span>this._mapSelector</span><span>(</span><span>map</span><span>))</span></p></div><div><p><span>                </span><span>continue</span><span>;</span></p></div><div></div><div><p><span>            </span><span>Nullable</span><span>!</span><span>FunctionEstimate</span><span> </span><span>result</span><span>;</span></p></div><div><p><span>            </span><span>this._process.accessMemory</span><span>(</span><span>map</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memory</span><span>){</span></p></div><div><p><span>                </span><span>if</span><span>(</span><span>bytes.length</span><span> </span><span>&lt;</span><span> </span><span>bytes.length</span><span>)</span></p></div><div><p><span>                    </span><span>return</span><span>;</span></p></div><div></div><div><p><span>                </span><span>size_t</span><span> </span><span>byteIndex</span><span>;</span></p></div><div><p><span>                </span><span>Failed:</span><span> </span><span>while</span><span>(</span><span>byteIndex</span><span> </span><span>&lt;</span><span> </span><span>memory.length</span><span> </span><span>-</span><span> </span><span>bytes.length</span><span>)</span></p></div><div><p><span><span>                </span></span><span>{</span></p></div><div><p><span>                    </span><span>const</span><span> </span><span>offset</span><span> </span><span>=</span><span> </span><span>byteIndex</span><span>;</span></p></div><div><p><span>                    </span><span>foreach</span><span>(</span><span>i</span><span>,</span><span> </span><span>check</span><span>;</span><span> </span><span>bytes</span><span>)</span></p></div><div><p><span><span>                    </span></span><span>{</span></p></div><div><p><span>                        </span><span>// Note: This if statement allows for things like `-1` to mean &#34;any byte&#34;.</span></p></div><div><p><span>                        </span><span>//       This functionality never got used in the end.</span></p></div><div><p><span>                        </span><span>if</span><span>(</span><span>bytes</span><span>[</span><span>i</span><span>] </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>bytes</span><span>[</span><span>i</span><span>] </span><span>&lt;=</span><span> </span><span>0xFF</span><span>)</span></p></div><div><p><span><span>                        </span></span><span>{</span></p></div><div><p><span>                            </span><span>if</span><span>(</span><span>memory</span><span>[</span><span>offset</span><span> </span><span>+</span><span> </span><span>i</span><span>] </span><span>!=</span><span> </span><span>bytes</span><span>[</span><span>i</span><span>])</span></p></div><div><p><span><span>                            </span></span><span>{</span></p></div><div><p><span>                                </span><span>byteIndex</span><span>++</span><span>;</span></p></div><div><p><span>                                </span><span>goto</span><span> </span><span>Failed</span><span>;</span></p></div><div><p><span><span>                            </span></span><span>}</span></p></div><div><p><span><span>                        </span></span><span>}</span></p></div><div><p><span><span>                    </span></span><span>}</span></p></div><div></div><div><p><span>                    </span><span>result</span><span> </span><span>=</span><span> </span><span>FunctionEstimate</span><span>(</span><span>map</span><span>,</span><span> </span><span>offset</span><span>,</span><span> </span><span>sizeEstimator</span><span>(</span><span>memory</span><span>[</span><span>offset</span><span>..$</span><span>]));</span></p></div><div><p><span>                    </span><span>return</span><span>;</span></p></div><div><p><span><span>                </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>});</span></p></div><div></div><div><p><span>            </span><span>if</span><span>(</span><span>!</span><span>result.isNull</span><span>)</span></p></div><div><p><span>                </span><span>return</span><span> </span><span>result</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>// D fact: typeof(return) is the function&#39;s return type.</span></p></div><div><p><span>        </span><span>// Also  : All D types expose their default initialiser under the special `.init` property.</span></p></div><div><p><span>        </span><span>//         In this case, the `.init` of a `Nullable` is one where `.isNull` returns true.</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>typeof(return)</span><span>.</span><span>init</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>poke8Bytes</span><span>(</span><span>FunctionEstimate</span><span> </span><span>func</span><span>,</span><span> </span><span>ptrdiff_t</span><span> </span><span>offset</span><span>,</span><span> </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>bytes</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>ptrace</span><span>(</span></p></div><div><p><span>            </span><span>PTRACE_POKEDATA</span><span>,</span></p></div><div><p><span>            </span><span>this</span><span>._process.pid</span><span>,</span></p></div><div><p><span>            </span><span>cast(void</span><span>*</span><span>)</span><span>(</span><span>func.map.start</span><span> </span><span>+</span><span> </span><span>func.offset</span><span> </span><span>+</span><span> </span><span>offset</span><span>)</span><span>,</span></p></div><div><p><span>            </span><span>cast(void</span><span>*</span><span>)</span><span>(</span><span>*</span><span>(</span><span>cast(size_t</span><span>*</span><span>)</span><span>bytes.ptr</span><span>))</span></p></div><div><p><span><span>        </span></span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>==</span><span> </span><span>-</span><span>1</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{ </span><span>/* error handling */</span><span> }</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Signature scanning is a common technique that’s used for figuring out where specific functions/specific code exists - specifically by looking for a specific set of instructions that are known to uniquely identify the thing you’re looking for.</p>
<p>For example, I’ve confirmed that these instructions from the start of LoadMap are unique to it, so can easily be used as the “signature” to scan for:</p>
<div><figure><pre data-language="asm"><code><div><p><span>0x55</span><span>,                           </span><span>push</span><span> </span><span>ebp</span></p></div><div><p><span>0x8B</span><span>, </span><span>0xEC</span><span>,                     </span><span>mov</span><span> </span><span>ebp</span><span>, </span><span>esp</span></p></div><div><p><span>0x6A</span><span>, </span><span>0xFF</span><span>,                     </span><span>push</span><span> </span><span>0xFFFFFFFF</span></p></div><div><p><span>0x68</span><span>, </span><span>0xBB</span><span>, </span><span>0xFF</span><span>, </span><span>0x41</span><span>, </span><span>0x10</span><span>    </span><span>push</span><span> </span><span>0x1041ffbb</span></p></div></code></pre></figure></div>
<p>In DeusEx’s case, none of the signatures I need to look for change after the game is loaded into memory, so I can hard code everything. In other cases things like memory address may be randomised or in some way dynamic, so some signature scanning code you see elsewhere will support the concept of “placeholders” (often denoted as ”??”) for specific bytes that can’t be hardcoded. While the Patcher supports this, it’s not really needed, so I’ll leave the topic there.</p>
<p>The Patcher’s <code>signatureScan</code> is pretty straightforward: do a simple linear search across any maps that the user’s provided <code>MapSelector</code> allows for; then reach into a user provided callback to estimate the size of the function (for the user code’s own purposes really). Curiously this code never appears to run into the <code>process_vm_readv</code> issue I mentioned earlier.</p>
<p>The only other function that the Patcher provides (again, I expected this to be a lot more complicated than it turned out as being), is the <code>poke8Bytes</code> function - this is where <code>ptrace</code> comes in handy due to its ability to bypass page protections, with the previously mentioned downside of having to poke 8 bytes exactly, no more and no less than that.</p>
<p>Just like that, we have a semi-structured approach for finding functions and modifying their code.</p>
<h2 id="framework---ui">Framework - UI</h2>
<p>The code also features an OOP-style way of displaying a TUI within the console, but there’s basically nothing interesting there to talk about, so I’ll be skipping past it.</p>
<h2 id="mvp---setting-the-flag">MVP - Setting the flag</h2>
<p>I ended up making one mega function to perform pretty much all of the steps I’ve described: finding the LoadMap function; patching it, and finding a place to store our “is loading” flag:</p>
<div><figure><pre data-language="d"><code><div><p><span>int</span><span> </span><span>main</span><span>()</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>size_t</span><span> </span><span>flagsAddress</span><span>;</span></p></div><div><p><span>    </span><span>size_t</span><span> </span><span>lastLoadedMapAddress</span><span>; </span><span>// I&#39;ll get to this later.</span></p></div><div></div><div><p><span>    </span><span>try</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>deusex</span><span>,</span><span> </span><span>enginePatcher</span><span>,</span><span> </span><span>/*out*/</span><span> </span><span>flagsAddress</span><span>,</span><span> </span><span>/*out*/</span><span> </span><span>lastLoadedMapAddress</span><span>);</span></p></div><div><p><span>    </span><span>finally</span><span> </span><span>deusex.detach</span><span>(); </span><span>// PTRACE_ATTACH forces the program to pause, so this is just to unpause it. We don&#39;t need it to modify memory anymore.</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span></p></div><div><p><span>    </span><span>GameProcess</span><span> </span><span>deusex</span><span>,</span></p></div><div><p><span>    </span><span>Patcher</span><span> </span><span>enginePatcher</span><span>,</span></p></div><div><p><span>    </span><span>out</span><span> </span><span>size_t</span><span> </span><span>flagsAddress</span><span>,</span></p></div><div><p><span>    </span><span>out</span><span> </span><span>size_t</span><span> </span><span>lastLoadedMapAddress</span><span>,</span></p></div><div><p><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ... Will be covered in a moment</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The first step was figuring out where LoadMap + its jump table entry were - I technically could’ve hard coded this, but decided it’d be fun to do things “properly” using my newly made toolkit:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.stdio</span><span> : </span><span>writefln</span><span>;</span></p></div><div></div><div><p><span>    </span><span>/++ Find the LoadMap function, as well as its entry in the jump table. ++/</span></p></div><div><p><span>    </span><span>auto</span><span> </span><span>loadMapSig</span><span> </span><span>=</span><span> </span><span>enginePatcher.signatureScan</span><span>([</span></p></div><div><p><span>        </span><span>0x55</span><span>,</span><span>                           </span><span>// push ebp</span></p></div><div><p><span>        </span><span>0x8B</span><span>,</span><span> </span><span>0xEC</span><span>,</span><span>                     </span><span>// mov ebp, esp</span></p></div><div><p><span>        </span><span>0x6A</span><span>,</span><span> </span><span>0xFF</span><span>,</span><span>                     </span><span>// push 0xFFFFFFFF</span></p></div><div><p><span>        </span><span>0x68</span><span>,</span><span> </span><span>0xBB</span><span>,</span><span> </span><span>0xFF</span><span>,</span><span> </span><span>0x41</span><span>,</span><span> </span><span>0x10</span><span>    </span><span>// push 0x1041ffbb</span></p></div><div><p><span><span>    </span></span><span>]</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memoryAfterSig</span><span>){</span></p></div><div><p><span>        </span><span>// Look for the main ret instruction, to get an estimate of the function&#39;s size.</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>target</span><span> </span><span>=</span><span> [</span><span>0xC2</span><span>,</span><span> </span><span>0x10</span><span>,</span><span> </span><span>0x00</span><span>]; </span><span>// ret 0x10</span></p></div><div><p><span>        </span><span>foreach</span><span>(</span><span>i</span><span>,</span><span> </span><span>_</span><span>;</span><span> </span><span>memoryAfterSig</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>if</span><span>(</span><span>i</span><span> </span><span>&gt;=</span><span> </span><span>memoryAfterSig.length</span><span> </span><span>-</span><span> </span><span>target.length</span><span>)</span></p></div><div><p><span>                </span><span>throw</span><span> </span><span>new </span><span>Exception</span><span>(</span><span>&#34;Could not find return instruction?&#34;</span><span>);</span></p></div><div></div><div><p><span>            </span><span>if</span><span>(</span><span>memoryAfterSig</span><span>[</span><span>i</span><span>..</span><span>i</span><span>+</span><span>target.length</span><span>] </span><span>==</span><span> </span><span>target</span><span>)</span></p></div><div><p><span>                </span><span>return</span><span> </span><span>i</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>assert(</span><span>false</span><span>)</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}).</span><span>get</span><span>;</span></p></div><div><p><span>    </span><span>writefln</span><span>(</span></p></div><div><p><span>        </span><span>&#34;Found LoadMap at 0x%08X - ret is at 0x%08X (incorrect if already patched)&#34;</span><span>,</span></p></div><div><p><span>        </span><span>loadMapSig.map.start</span><span> </span><span>+</span><span> </span><span>loadMapSig.offset</span><span>,</span></p></div><div><p><span>        </span><span>loadMapSig.map.start</span><span> </span><span>+</span><span> </span><span>loadMapSig.offset</span><span> </span><span>+</span><span> </span><span>loadMapSig.estimatedSize</span><span>,</span></p></div><div><p><span><span>    </span></span><span>); </span><span>// e.g.: Found LoadMap at 0x1038C1F0 - ret is at 0x1038E461</span></p></div><div></div><div><p><span>    </span><span>auto</span><span> </span><span>loadMapJumpSigResult</span><span> </span><span>=</span><span> </span><span>enginePatcher.signatureScan</span><span>([</span></p></div><div><p><span>        </span><span>0xE9</span><span>,</span><span> </span><span>0x46</span><span>,</span><span> </span><span>0x8e</span><span>,</span><span> </span><span>0x08</span><span>,</span><span> </span><span>0x00</span><span> </span><span>// jmp [rel LoadMap]</span></p></div><div><p><span><span>    </span></span><span>]</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memoryAfterSig</span><span>){ </span><span>return</span><span> </span><span>0</span><span>; });</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Next step was to find the address I could safely store the loading flag (and the “last loaded map” stuff I’ll get to later on) into:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>,</span><span> </span><span>out</span><span> </span><span>size_t</span><span> </span><span>flagsAddress</span><span>,</span><span> </span><span>out</span><span> </span><span>size_t</span><span> </span><span>lastLoadedMapAddress</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>filter</span><span>,</span><span> </span><span>canFind</span><span>;</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.array</span><span>     : </span><span>array</span><span>;</span></p></div><div></div><div><p><span>    </span><span>// Engine.dll creates at least 2 writeable mappings.</span></p></div><div><p><span>    </span><span>// It&#39;s very unlikely the last bytes of the last mapping are in actual use, so we can use it to store our own values.</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>mapToStoreFlags</span><span> </span><span>=</span><span> </span><span>deusex.memoryMaps</span></p></div><div><p><span><span>                            </span></span><span>.</span><span>filter</span><span>!(</span><span>m</span><span> =&gt; </span><span>m.pathname.canFind</span><span>(</span><span>&#34;Engine.dll&#34;</span><span>) </span><span>&amp;&amp;</span><span> </span><span>m.writable</span><span>)</span></p></div><div><p><span><span>                            </span></span><span>.</span><span>array</span><span>[</span><span>$-</span><span>1</span><span>];</span></p></div><div><p><span>    </span><span>flagsAddress</span><span> </span><span>=</span><span> </span><span>mapToStoreFlags.end</span><span> </span><span>-</span><span> </span><span>1</span><span>;</span></p></div><div><p><span>    </span><span>lastLoadedMapAddress</span><span> </span><span>=</span><span> </span><span>mapToStoreFlags.end</span><span> </span><span>-</span><span> </span><span>9</span><span>;</span></p></div><div><p><span>    </span><span>writefln</span><span>(</span><span>&#34;Storing flag byte at 0x%08X&#34;</span><span>,</span><span> </span><span>flagsAddress</span><span>); </span><span>// e.g: ... at 0x1059FFFF</span></p></div><div><p><span>    </span><span>writefln</span><span>(</span><span>&#34;Storing last loaded map pointer at 0x%08X&#34;</span><span>,</span><span> </span><span>lastLoadedMapAddress</span><span>); </span><span>// e.g: ... at 0x1059FFF7</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Now for the exciting part, I essentially want to turn the start of the LoadMap function from this:</p>
<div><figure><pre data-language="asm"><code><div><p><span>... more int3s</span></p></div><div><p><span>1038c1e8:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1e9:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ea:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1eb:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ec:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ed:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ee:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1ef:</span><span>  cc              </span><span>int3</span></p></div><div><p><span>1038c1f0:</span><span>  </span><span>55</span><span>              </span><span>push</span><span>   %</span><span>ebp</span></p></div><div><p><span>1038c1f1:</span><span>  8b ec           </span><span>mov</span><span>    %</span><span>esp</span><span>,%</span><span>ebp</span></p></div><div><p><span>... </span><span>rest</span><span> of LoadMap</span></p></div></code></pre></figure></div>
<p>Into this (reminder, I <strong>have</strong> to write 8 bytes at a time, hence the random <code>nop</code> paddings you’ll start seeing):</p>
<div><figure><pre data-language="asm"><code><div><p><span>1038c1e8:</span><span> c6 </span><span>05</span><span> ff ff </span><span>59</span><span> </span><span>10</span><span> </span><span>01</span><span>  </span><span>mov</span><span>    $0x1, </span><span>0x1059ffff</span></p></div><div><p><span>1038c1ef:</span><span> </span><span>90</span><span>                    </span><span>nop</span></p></div><div><p><span>1038c1f0:</span><span> </span><span>55</span><span>                    </span><span>push</span><span>   %</span><span>ebp</span></p></div><div><p><span>1038c1f1:</span><span> 8b ec                 </span><span>mov</span><span>    %</span><span>esp</span><span>, %</span><span>ebp</span></p></div></code></pre></figure></div>
<p>I also need to modify LoadMap’s jump table entry so that it points towards my newly injected code instead:</p>
<div><figure><pre data-language="d"><code><div><p><span>From:</span><span> </span><span>103033a5</span><span>: </span><span>e9</span><span> </span><span>46</span><span> </span><span>8e</span><span> </span><span>08</span><span> </span><span>00</span><span>  </span><span>jmp</span><span> </span><span>0x1038c1f0</span></p></div><div><p><span>To:</span><span>   </span><span>103033a5</span><span>: </span><span>e9</span><span> </span><span>3e</span><span> </span><span>8e</span><span> </span><span>08</span><span> </span><span>00</span><span>  </span><span>jmp</span><span> </span><span>0x1038c1e8</span></p></div></code></pre></figure></div>
<p>Which with the <code>Patcher</code> class ended up being very easy to pull off:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>Patcher</span><span> </span><span>enginePatcher</span><span>,</span><span> </span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>// Write 8 bytes before the first instruction of LoadMap</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>-</span><span>8</span><span>,</span><span> [</span></p></div><div><p><span>        </span><span>// mov byte [FlagsAddress], 1</span></p></div><div><p><span>        </span><span>0xC6</span><span>,</span><span> </span><span>0x05</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>(</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF00</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>1</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF0000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>2</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF000000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>3</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>0x01</span><span>,</span></p></div><div></div><div><p><span>        </span><span>0x90</span><span>,</span><span> </span><span>// nop</span></p></div><div><p><span><span>    </span></span><span>]);</span></p></div><div></div><div><p><span>    </span><span>// `jmp` uses a relative offset, rather than an absolute address, so the easiest option</span></p></div><div><p><span>    </span><span>// is to read in the instruction; subtract 8 from the offset, and inject the change back in.</span></p></div><div><p><span>    </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>jumpInstructions</span><span>;</span></p></div><div><p><span>    </span><span>deusex.accessMemory</span><span>(</span><span>loadMapJumpSig.map</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memory</span><span>){</span></p></div><div><p><span>        </span><span>jumpInstructions</span><span> </span><span>=</span><span> </span><span>memory</span><span>[</span><span>loadMapJumpSig.offset</span><span>..</span><span>loadMapJumpSig.offset</span><span>+</span><span>8</span><span>];</span></p></div><div><p><span><span>    </span></span><span>});</span></p></div><div><p><span>    </span><span>jumpInstructions</span><span>[</span><span>1</span><span>] </span><span>-=</span><span> </span><span>8</span><span>;</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapJumpSig</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>jumpInstructions</span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>At this point I was happy enough to manually check that the flag gets set, so:</p>
<ol>
<li>I load up the game.</li>
<li>Ran the timer to inject its changes (and some painful debugging I’m skipping over :D).</li>
<li>Attached LLDB to the game as before.</li>
<li>Loaded a map.</li>
<li>Used LLDB to see if the flag got set.</li>
</ol>
<div><figure><pre data-language="bash"><code><div><p><span>(</span><span>lldb</span><span>) </span><span>mem</span><span> </span><span>read</span><span> </span><span>0x1059FFFF</span><span> </span><span>-c</span><span> </span><span>1</span></p></div><div><p><span>0x1059ffff:</span><span> </span><span>01</span></p></div></code></pre></figure></div>
<p>Success!</p>
<h2 id="mvp---unsetting-the-flag">MVP - Unsetting the flag</h2>
<p>This is where things got a little tricky - unsetting the flag <em>should</em> be as simple as doing <code>mov [FlagAddress], 0</code> just before the main <code>ret</code> instruction, right? Yes! However there’s some additional complications in order to pull such a thing off.</p>
<p>The first issue is around how the <code>LoadMap</code> function is layed out: The main <code>ret</code> instruction which handles success cases isn’t the final instruction of the function, but instead is followed by what I believe to be an exception handling branch:</p>
<div><figure><pre data-language="asm"><code><div><p><span>... </span><span>rest</span><span> of LoadMap&#39;s happy path</span></p></div><div><p><span>1038e45e:</span><span>  8b e5                  </span><span>mov</span><span>    %</span><span>ebp</span><span>,%</span><span>esp</span></p></div><div><p><span>1038e460</span><span>:  </span><span>5d</span><span>                     </span><span>pop</span><span>    %</span><span>ebp</span></p></div><div><p><span>1038e461</span><span>:  c2 </span><span>10</span><span> </span><span>00</span><span>               </span><span>ret</span><span>    $0x10 </span><span>; &lt;-- Main success case ret instruction</span></p></div><div><p><span>... beginning of some other branch</span></p></div><div><p><span>1038e464</span><span>:  8b </span><span>4d</span><span> b0               </span><span>mov</span><span>    -</span><span>0x50</span><span>(%</span><span>ebp</span><span>),%</span><span>ecx</span></p></div><div><p><span>1038e467</span><span>:  </span><span>8d</span><span> </span><span>95</span><span> 7c ff ff ff      </span><span>lea</span><span>    -</span><span>0x84</span><span>(%</span><span>ebp</span><span>),%</span><span>edx</span></p></div></code></pre></figure></div>
<p>I’ll talk about the exception handling stuff at the very end, but the main pain point here is that there’s no free space for me to inject my <code>mov</code> instruction.</p>
<p>Essentially, what has to be done here is:</p>
<ol>
<li>Inject my <code>mov</code> instruction into where the function-ending <code>nop</code>s are.</li>
<li>Move the <code>ret</code> instruction, and a few surrounding instructions to also be where the <code>nop</code>s are, just after my <code>mov</code> instruction.</li>
<li>Inject a <code>jmp</code> instruction where the old instructions we moved used to be - this <code>jmp</code> will go to where the <code>mov</code>, <code>ret</code>, etc. instructions are now placed.</li>
</ol>
<p>It sounds a bit messy and complex, but bare with me since it’s not as bad as it seems once implemented.</p>
<p>The main thing to think about here is the <code>jmp</code> instruction I need to inject. I’d need 5 bytes to inject this particular instruction, which means I need to move the <code>ret</code> (which is 3 bytes), as well as any other instructions before it that total to at least 5 bytes:</p>
<div><figure><pre data-language="asm"><code><div><p><span>1038e45e:</span><span>  8b e5      </span><span>mov</span><span>    %</span><span>ebp</span><span>,%</span><span>esp</span><span> </span><span>; 2 bytes - I have to include both bytes to not cut the instruction in half</span></p></div><div><p><span>1038e460</span><span>:  </span><span>5d</span><span>         </span><span>pop</span><span>    %</span><span>ebp</span><span>      </span><span>; 3 bytes</span></p></div><div><p><span>1038e461</span><span>:  c2 </span><span>10</span><span> </span><span>00</span><span>   </span><span>ret</span><span>    $0x10     </span><span>; 6 bytes</span></p></div><div></div><div><p><span>; Since I need a multiple of 8, I&#39;ll also read in the first 2 bytes of this instruction, but leave</span></p></div><div><p><span>; them unmodified &amp; not copy them anywhere.</span></p></div><div><p><span>1038e464</span><span>:  8b </span><span>4d</span><span> b0   </span><span>mov</span><span>    -</span><span>0x50</span><span>(%</span><span>ebp</span><span>),%</span><span>ecx</span></p></div></code></pre></figure></div>
<p>I can then change the above instructions to look like this:</p>
<div><figure><pre data-language="asm"><code><div><p><span>1038e45e:</span><span> e9 cf </span><span>02</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>jmp</span><span>    </span><span>0x1038e732</span><span> </span><span>; This address is where the nops start - i.e. where we&#39;re injecting our new code.</span></p></div><div><p><span>1038e463</span><span>: </span><span>90</span><span>              </span><span>nop</span></p></div><div></div><div><p><span>; (Unmodified)</span></p></div><div><p><span>1038e464</span><span>:  8b </span><span>4d</span><span> b0   </span><span>mov</span><span>    -</span><span>0x50</span><span>(%</span><span>ebp</span><span>),%</span><span>ecx</span></p></div></code></pre></figure></div>
<p>While then also changing the nops at the end of LoadMap to look like this:</p>
<div><figure><pre data-language="asm"><code><div><p><span>; From</span></p></div><div><p><span>1038e732</span><span>:  </span><span>90</span><span>                     </span><span>nop</span></p></div><div><p><span>1038e733</span><span>:  </span><span>90</span><span>                     </span><span>nop</span></p></div><div><p><span>1038e734</span><span>:  </span><span>90</span><span>                     </span><span>nop</span></p></div><div><p><span>1038e735</span><span>:  </span><span>90</span><span>                     </span><span>nop</span></p></div><div><p><span>1038e736</span><span>:  </span><span>90</span><span>                     </span><span>nop</span></p></div><div><p><span>...</span></p></div><div></div><div><p><span>; To</span></p></div><div><p><span>1038e732</span><span>: c6 </span><span>05</span><span> ff ff </span><span>59</span><span> </span><span>10</span><span> </span><span>00</span><span>  movb   $0x0, </span><span>0x1059ffff</span><span> </span><span>; Unset the loading flag</span></p></div><div><p><span>1038e739</span><span>: </span><span>90</span><span>                    </span><span>nop</span></p></div><div><p><span>...</span></p></div><div><p><span>1038e751</span><span>: </span><span>90</span><span>                    </span><span>nop</span></p></div><div><p><span>1038e752</span><span>: 8b e5                 movl   %</span><span>ebp</span><span>, %</span><span>esp</span><span> </span><span>; Old instructions we&#39;re preserving</span></p></div><div><p><span>1038e754</span><span>: </span><span>5d</span><span>                    popl   %</span><span>ebp</span></p></div><div><p><span>1038e755</span><span>: c2 </span><span>10</span><span> </span><span>00</span><span>              retl   $0x10</span></p></div></code></pre></figure></div>
<p>You may have noticed that I’ve kept a lot of <code>nops</code> between the flag unsetter and the old return instructions - this is because we’ll be injecting more code there soon, so we’ll need some space.</p>
<p>Let’s start off with simply reading in the instructions we’re going to move, and figuring out where the true end of the function is:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>const</span><span> </span><span>retOffset</span><span> </span><span>=</span><span> </span><span>loadMapSig.offset</span><span> </span><span>+</span><span> </span><span>loadMapSig.estimatedSize</span><span>; </span><span>// `esimatedSize` was calculated earlier by looking for the `ret 0x10` instruction.</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>retPopAndMovOffset</span><span> </span><span>=</span><span> </span><span>retOffset</span><span> </span><span>-</span><span> </span><span>3</span><span>; </span><span>// start of where we need to copy from</span></p></div><div><p><span>    </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>retPopAndMovInstructions</span><span>; </span><span>// The first 6 are the instructions we&#39;re overwriting/moving, the other 2 are from that unrelated instruction we&#39;re not doing anything with.</span></p></div><div></div><div><p><span>    </span><span>size_t</span><span> </span><span>endOfLoadMapInstructions</span><span> </span><span>=</span><span> </span><span>retPopAndMovOffset</span><span>; </span><span>// Gets modified below.</span></p></div><div></div><div><p><span>    </span><span>deusex.accessMemory</span><span>(</span><span>loadMapSig.map</span><span>,</span><span> (</span><span>scope</span><span> </span><span>memory</span><span>){</span></p></div><div><p><span>        </span><span>// Copy the mov; pop; ret, and 2 bytes of that other instruction.</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span> </span><span>=</span><span> </span><span>memory</span><span>[</span><span>retPopAndMovOffset</span><span>..</span><span>retPopAndMovOffset</span><span>+</span><span>8</span><span>];</span></p></div><div></div><div><p><span>        </span><span>// Find the actual ending of the function - where all the weird nops are</span></p></div><div><p><span>        </span><span>const</span><span> </span><span>target</span><span> </span><span>=</span><span> [</span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span>]; </span><span>// nop nop nop nop</span></p></div><div><p><span>        </span><span>while</span><span>(</span><span>endOfLoadMapInstructions</span><span> </span><span>&lt;</span><span> </span><span>memory.length</span><span> </span><span>-</span><span> </span><span>target.length</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>if</span><span>(</span><span>memory</span><span>[</span><span>endOfLoadMapInstructions</span><span>..</span><span>endOfLoadMapInstructions</span><span>+</span><span>target.length</span><span>] </span><span>==</span><span> </span><span>target</span><span>)</span></p></div><div><p><span>                </span><span>return</span><span>;</span></p></div><div><p><span>            </span><span>endOfLoadMapInstructions</span><span>++</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>throw</span><span> </span><span>new </span><span>Exception</span><span>(</span><span>&#34;Could not find end of LoadMap?&#34;</span><span>);</span></p></div><div><p><span><span>    </span></span><span>});</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Then let’s handle replacing the old instructions with our new <code>jmp</code> instruction:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>// Reminder: relative jmps occur after the IP is updated, so we have to</span></p></div><div><p><span>    </span><span>//           remove the extra bytes that are read as part of the jmp instruction.</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>relativeJumpOffset</span><span> </span><span>=</span><span> (</span><span>endOfLoadMapInstructions</span><span> </span><span>-</span><span> </span><span>retOffset</span><span>) </span><span>-</span><span> </span><span>2</span><span>;</span></p></div><div><p><span>    </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>jumpMiniDetourInstructions</span><span> </span><span>=</span><span> [</span></p></div><div><p><span>        </span><span>// jmp [rel NewEndOfLoadMap]</span></p></div><div><p><span>        </span><span>0xE9</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>(</span><span>relativeJumpOffset</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>relativeJumpOffset</span><span> </span><span>&amp;</span><span> </span><span>0xFF00</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>1</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>relativeJumpOffset</span><span> </span><span>&amp;</span><span> </span><span>0xFF0000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>2</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>relativeJumpOffset</span><span> </span><span>&amp;</span><span> </span><span>0xFF000000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>3</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>0x90</span><span>,</span><span> </span><span>// nop</span></p></div><div></div><div><p><span>        </span><span>// Preserve existing instructions.</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>6</span><span>]</span><span>,</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>7</span><span>]</span><span>,</span></p></div><div><p><span><span>    </span></span><span>];</span></p></div><div><p><span>    </span><span>// (second parameter needs to be relative to `loadMapSig.offset` - not important, just maths getting in the way of my hopes and dreams)</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>retPopAndMovOffset</span><span> </span><span>-</span><span> </span><span>loadMapSig.offset</span><span>,</span><span> </span><span>jumpMiniDetourInstructions</span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>We can now set the instruction our <code>jmp</code> points to, to be the flag unsetter instruction, while also moving over the other instructions we wanted to preserve:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div></div><div><p><span>    </span><span>const</span><span> </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>unsetFlagInstructions</span><span> </span><span>=</span><span> [</span></p></div><div><p><span>        </span><span>// mov byte [FlagsAddress], 0</span></p></div><div><p><span>        </span><span>0xC6</span><span>,</span><span> </span><span>0x05</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>(</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF00</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>1</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF0000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>2</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>cast(ubyte)</span><span>((</span><span>flagsAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF000000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>3</span><span>))</span><span>,</span></p></div><div><p><span>        </span><span>0x00</span><span>,</span></p></div><div></div><div><p><span>        </span><span>0x90</span><span>,</span><span> </span><span>// nop</span></p></div><div><p><span><span>    </span></span><span>];</span></p></div><div></div><div><p><span>    </span><span>const</span><span> </span><span>ubyte</span><span>[</span><span>8</span><span>] </span><span>preservedInstructions</span><span> </span><span>=</span><span> [</span></p></div><div><p><span>        </span><span>// mov</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>0</span><span>]</span><span>,</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>1</span><span>]</span><span>,</span></p></div><div></div><div><p><span>        </span><span>// pop</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>2</span><span>]</span><span>,</span></p></div><div></div><div><p><span>        </span><span>// ret</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>3</span><span>]</span><span>,</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>4</span><span>]</span><span>,</span></p></div><div><p><span>        </span><span>retPopAndMovInstructions</span><span>[</span><span>5</span><span>]</span><span>,</span></p></div><div></div><div><p><span>        </span><span>0x90</span><span>,</span><span> </span><span>0x90</span><span> </span><span>// nop nop</span></p></div><div><p><span><span>    </span></span><span>];</span></p></div><div></div><div><p><span>    </span><span>endOfLoadMapInstructions</span><span> </span><span>-=</span><span> </span><span>loadMapSig.offset</span><span>; </span><span>// Make it relative to the start of the function, rather than the start of the memory map.</span></p></div><div></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>endOfLoadMapInstructions</span><span>,</span><span> </span><span>unsetFlagInstructions</span><span>);</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>endOfLoadMapInstructions</span><span>+</span><span>32</span><span>,</span><span> </span><span>preservedInstructions</span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>And after that slightly annoying, kind of confusing dance that was just performed, I loaded up the game; performed the injection, and observed that the flag was <code>1</code> during the loading screen, and <code>0</code> afterwards.</p>
<p>Huzzah, the pain’s not over yet.</p>
<h2 id="mvp---the-rest-of-the-owl">MVP - The rest of the owl</h2>
<p>I won’t cover this part too much, but this is essentially when I started to get the basic UI + timer logic together. My timer logic isn’t overly accurate, and the UI code isn’t anything special, hence why I’m not really covering it.</p>
<p>The main part that’s interesting is the update controller, which gets ran on every UI tick (yep… UI logic and update logic aren’t separate…):</p>
<div><figure><pre data-language="d"><code><div><p><span>auto</span><span> </span><span>deusExController</span><span>(</span></p></div><div><p><span>    </span><span>Timer</span><span> </span><span>timer</span><span>,</span></p></div><div><p><span>    </span><span>Label</span><span> </span><span>mapLabel</span><span>,</span></p></div><div><p><span>    </span><span>SplitList</span><span> </span><span>splitList</span><span>,</span></p></div><div><p><span>    </span><span>GameProcess</span><span> </span><span>deusex</span><span>,</span></p></div><div><p><span>    </span><span>size_t</span><span> </span><span>flagsAddress</span><span>,</span></p></div><div><p><span>    </span><span>size_t</span><span> </span><span>lastLoadedMapAddress</span><span>,</span></p></div><div><p><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>core.time</span><span> : </span><span>Duration</span><span>;</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.algorithm</span><span> : </span><span>canFind</span><span>;</span></p></div><div></div><div><p><span>    </span><span>enum</span><span> </span><span>State</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>waitingForFirstLoad</span><span>,</span></p></div><div><p><span>        </span><span>normal</span><span>,</span></p></div><div><p><span>        </span><span>endCutscene</span><span>,</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>    </span><span>State</span><span> </span><span>state</span><span>;</span></p></div><div><p><span>    </span><span>bool</span><span> </span><span>wasLoadingLastTick</span><span>;</span></p></div><div><p><span>    </span><span>bool</span><span> </span><span>endOnce</span><span>;</span></p></div><div><p><span>    </span><span>string</span><span> </span><span>lastLoadedMap</span><span>;</span></p></div><div></div><div><p><span>    </span><span>return</span><span> </span><span>delegate</span><span> (</span><span>Duration</span><span> </span><span>_</span><span>,</span><span> </span><span>BackgroundUpdate</span><span> </span><span>__</span><span>,</span><span> </span><span>UiInput</span><span> </span><span>___</span><span>){</span></p></div><div><p><span>        </span><span>// process_vm_readv sometimes fails with ESRCH and I have no idea why, so ignore any errors for now.</span></p></div><div><p><span>        </span><span>bool</span><span> </span><span>isLoading</span><span> </span><span>=</span><span> </span><span>false</span><span>;</span></p></div><div><p><span>        </span><span>try</span><span> </span><span>isLoading</span><span> </span><span>=</span><span> </span><span>deusex.peek</span><span>!bool</span><span>(</span><span>flagsAddress</span><span>);</span></p></div><div><p><span>        </span><span>catch</span><span>(</span><span>Exception</span><span>) </span><span>return</span><span>;</span></p></div><div></div><div><p><span>        </span><span>scope(exit)</span><span> </span><span>wasLoadingLastTick</span><span> </span><span>=</span><span> </span><span>isLoading</span><span>;</span></p></div><div><p><span>        </span><span>splitList.updateElapsedTime</span><span>(</span><span>timer.elapsed</span><span>);</span></p></div><div></div><div><p><span>        </span><span>if</span><span>(</span><span>wasLoadingLastTick</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>isLoading</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>FStringNoCap</span><span> </span><span>lastLoadedMapPtr</span><span>;</span></p></div><div><p><span>            </span><span>while</span><span>(</span><span>true</span><span>)</span></p></div><div><p><span><span>            </span></span><span>{</span></p></div><div><p><span>                </span><span>try</span><span> </span><span>lastLoadedMapPtr</span><span> </span><span>=</span><span> </span><span>deusex.peek</span><span>!</span><span>FStringNoCap</span><span>(</span><span>lastLoadedMapAddress</span><span>);</span></p></div><div><p><span>                </span><span>catch</span><span>(</span><span>Exception</span><span>) </span><span>continue</span><span>;</span></p></div><div><p><span>                </span><span>break</span><span>;</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div></div><div><p><span>            </span><span>if</span><span>(</span><span>lastLoadedMapPtr.ptr</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span></p></div><div><p><span><span>            </span></span><span>{</span></p></div><div><p><span>                </span><span>// ...</span></p></div><div><p><span>                </span><span>lastLoadedMap</span><span> </span><span>=</span><span> </span><span>toDString</span><span>(</span><span>deusex</span><span>,</span><span> </span><span>lastLoadedMapPtr</span><span>)</span><span>.stripRight.stripRight</span><span>(</span><span>&#34;</span><span>\0</span><span>&#34;</span><span>);</span></p></div><div><p><span>                </span><span>// ...</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>void</span><span> </span><span>restart</span><span>()</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>state</span><span> </span><span>=</span><span> </span><span>State.waitingForFirstLoad</span><span>;</span></p></div><div><p><span>            </span><span>mapLabel.text</span><span> </span><span>=</span><span> </span><span>&#34;Restart was detected&#34;</span><span>;</span></p></div><div><p><span>            </span><span>timer.reset</span><span>();</span></p></div><div><p><span>            </span><span>splitList.reset</span><span>();</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span>        </span><span>// D fact: The `with` statement allows you to introduce an implicit lookup scope.</span></p></div><div><p><span>        </span><span>//         So `State.waitingForFirstLoad` can simply become `waitingForFirstLoad`.</span></p></div><div><p><span>        </span><span>//</span></p></div><div><p><span>        </span><span>// Also:   `final switch` will crash if their implicit `default` case is taken,</span></p></div><div><p><span>        </span><span>//          great for exhaustive enum switching!</span></p></div><div><p><span>        </span><span>final switch</span><span>(</span><span>state</span><span>) </span><span>with</span><span>(</span><span>State</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>case</span><span> </span><span>waitingForFirstLoad</span><span>: </span><span>// ...</span></p></div><div><p><span>            </span><span>case</span><span> </span><span>normal</span><span>: </span><span>// ...</span></p></div><div><p><span>            </span><span>case</span><span> </span><span>endCutscene</span><span>: </span><span>// ...</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>};</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>It showcases how the <code>peek</code> functions are being used, and teases further the “last loaded map” stuff, which, speaking about that…</p>
<h2 id="last-loaded-map---research">Last Loaded Map - research</h2>
<p>The autosplitter cannot work solely off of whether we’re in a loading screen or not since any given loading screen doesn’t necssarily mean that a new map is being loaded. e.g. Reloading the current map is used/abused to perform some major glitches during the speedrun, so the only safe way to know whether we’ve actually gone onto a different map, is by figuring out which map the game loaded.</p>
<p>To start, while I’ve been referring to LoadMap as <code>LoadMap</code> - its full mangled signature looks like this:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>?LoadMap@UGameEngine@@UAEPAVULevel@@ABVFURL@@PAVUPendingLevel@@PBV?$TMap@VFString@@V1@@@AAVFString@@@Z</span></p></div></code></pre></figure></div>
<p>Which, when put through a <a href="https://demangler.com/">demangler</a> comes out as:</p>
<div><figure><pre data-language="c++"><code><div><p><span>public:</span><span> </span><span>virtual</span><span> </span><span>class</span><span> </span><span>ULevel</span><span> * __thiscall UGameEngine::</span><span>LoadMap</span><span>(</span></p></div><div><p><span><span>    </span></span><span>class FURL const &amp;,</span></p></div><div><p><span><span>    </span></span><span>class UPendingLevel *,</span></p></div><div><p><span><span>    </span></span><span>class TMap&lt;</span><span>class</span><span> </span><span>FString</span><span>,</span><span>class</span><span> </span><span>FString</span><span>&gt; const *,</span></p></div><div><p><span><span>    </span></span><span>class FString &amp;</span></p></div><div><p><span>)</span></p></div></code></pre></figure></div>
<p>There’s several potential leads here to learn about what map the game is trying to load:</p>
<ol>
<li>The return type is a <code>ULevel</code>, which may include the map name as a field.</li>
<li>The first parameter is an <code>FURL</code>, which might be a path to a map file to load.</li>
<li>The second parameter also sounds like it could contain a path or name about what to load.</li>
<li>… And so could the last parameter.</li>
</ol>
<p>I’m can’t remember exactly why, but I decided to first look into checking out the return value to obtain the map name, rather than have a peek at the parameters.</p>
<p>I couldn’t really find much comprehensive documentation about the <code>__thiscall</code> convention, but from a quick glance at the dissambled code, it looked like it was using the <code>eax</code> register to provide the returned <code>ULevel*</code> - strangely standard coming from a convention made by Microsoft.</p>
<p>So I hooked up LLDB, added a breakpoint onto LoadMap’s <code>ret</code> instruction, and began having a poke around in memory:</p>
<div><figure><pre data-language="bash"><code><div><p><span># Getting the pointer stored in eax</span></p></div><div><p><span>(</span><span>lldb</span><span>) </span><span>reg</span><span> </span><span>read</span><span> </span><span>eax</span></p></div><div><p><span>     </span><span>eax</span><span> </span><span>=</span><span> </span><span>0x0af91400</span></p></div><div></div><div><p><span># Having a peek at the memory being pointed to</span></p></div><div><p><span>(</span><span>lldb</span><span>) </span><span>mem</span><span> </span><span>read</span><span> </span><span>0x0af91400</span><span> </span><span>-c</span><span> </span><span>0xFF</span></p></div><div><p><span>0x0af91400:</span><span> </span><span>fc</span><span> </span><span>8a</span><span> </span><span>42</span><span> </span><span>10</span><span> </span><span>85</span><span> </span><span>b9</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>e0</span><span> </span><span>d2</span><span> </span><span>42</span><span> </span><span>05</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>..B.......B.....</span></p></div><div><p><span>0x0af91410:</span><span> </span><span>00</span><span> </span><span>78</span><span> </span><span>39</span><span> </span><span>06</span><span> </span><span>95</span><span> </span><span>0e</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>e0</span><span> </span><span>b6</span><span> </span><span>5a</span><span> </span><span>06</span><span> </span><span>41</span><span> </span><span>00</span><span> </span><span>07</span><span> </span><span>60</span><span>  </span><span>.x9.......Z.A..`</span></p></div><div><p><span>0x0af91420:</span><span> </span><span>67</span><span> </span><span>56</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>58</span><span> 8b </span><span>58</span><span> </span><span>10</span><span> d4 8a </span><span>42</span><span> </span><span>10</span><span> </span><span>00</span><span> c0 fb </span><span>04</span><span>  gV..X.X...B.....</span></p></div><div><p><span>0x0af91430:</span><span> 7c </span><span>04</span><span> </span><span>00</span><span> </span><span>00</span><span> 3f </span><span>05</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>14</span><span> f9 0a </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>|</span><span>...</span><span>?</span><span>...........</span></p></div><div><p><span>0x0af91440:</span><span> </span><span>00</span><span> ee 6f </span><span>01</span><span> 3a c7 </span><span>60</span><span> </span><span>01</span><span> </span><span>07</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>07</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  ..o.:.`</span><span>.........</span></p></div><div><p><span>0x0af91450:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>6e</span><span> </span><span>1e</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>............n...</span></p></div><div><p><span>0x0af91460:</span><span> </span><span>ac</span><span> </span><span>9e</span><span> </span><span>b2</span><span> </span><span>08</span><span> </span><span>09</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>09</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>28</span><span> </span><span>e3</span><span> </span><span>5f</span><span> </span><span>06</span><span>  </span><span>............</span><span>(</span><span>._.</span></p></div><div><p><span>0x0af91470:</span><span> </span><span>02</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>02</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af91480:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>01</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>d9</span><span> </span><span>08</span><span>  </span><span>................</span></p></div><div><p><span>0x0af91490:</span><span> </span><span>d7</span><span> </span><span>06</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>d7</span><span> </span><span>06</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>f0</span><span> </span><span>06</span><span> </span><span>0b</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af914a0:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af914b0:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af914c0:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af914d0:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>................</span></p></div><div><p><span>0x0af914e0:</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>38</span><span> </span><span>0e</span><span> </span><span>e6</span><span> </span><span>0a</span><span> </span><span>01</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>01</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span>  </span><span>....8...........</span></p></div><div><p><span>0x0af914f0:</span><span> </span><span>20</span><span> </span><span>6e</span><span> </span><span>b7</span><span> </span><span>02</span><span> </span><span>08</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>cb</span><span> </span><span>04</span><span> </span><span>c0</span><span> </span><span>08</span><span> </span><span>5d</span><span>      </span><span>n............]</span></p></div></code></pre></figure></div>
<p>The situation here is that I’m looking for the map name, specifically this means I’m looking for something resembling a string/character array.</p>
<p>Most standard array types are implemented with the following layout:</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>Array</span><span>(</span><span>T</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>T</span><span>*</span><span> </span><span>ptr</span><span>;</span></p></div><div><p><span>    </span><span>size_t</span><span> </span><span>length</span><span>;</span></p></div><div><p><span>    </span><span>size_t</span><span> </span><span>capacity</span><span>; </span><span>// sometimes</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>So in other words I wanted to look for any two pairs of four bytes (since DeusEx is a 32-bit game), where the first four bytes look like a pointer (a bunch of seemingly ‘random’ bytes) and where the second four bytes looked like a length (a smaller number where most of the bytes should be 0).</p>
<p>I tried a couple of pairs that looked like what I wanted, before I ended up on this particular part, which is 0x60 bytes into where the pointer in <code>eax</code> points to:</p>
<div><figure><pre data-language="bash"><code><div><p><span>0x0af91460:</span><span> </span><mark><span>ac</span><span> </span><span>9e</span><span> </span><span>b2</span><span> </span><span>08</span></mark><span> </span><mark><span>09</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span></mark><span> </span><mark><span>09</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>00</span></mark><span> </span><span>28</span><span> </span><span>e3</span><span> </span><span>5f</span><span> </span><span>06</span><span>  </span><span>............</span><span>(</span><span>._.</span></p></div></code></pre></figure></div>
<p>The two <code>09 00 00 00</code> side by side looked suspiciously like a length + capacity pair, and it followed the <code>ac 9e b2 08</code> which looked suspiciously like a pointer.</p>
<p>Following the pointer, we get the following result:</p>
<div><figure><pre data-language="bash"><code><div><p><span>(</span><span>lldb</span><span>) </span><span>mem</span><span> </span><span>read</span><span> </span><span>0x08b29eac</span><span> </span><span>-c</span><span> </span><span>0x09</span></p></div><div><p><span>0x08b29eac:</span><span> </span><span>30</span><span> </span><span>00</span><span> </span><span>30</span><span> </span><span>00</span><span> </span><span>5f</span><span> </span><span>00</span><span> </span><span>49</span><span> </span><span>00</span><span> </span><span>6e</span><span>    </span><span>0.0._.I.n</span></p></div></code></pre></figure></div>
<p>It <em>kinda</em> looks like string data, but is obviously incomplete. The hint here is that the game is actually using a 2-byte character type (there’s a 00 between each ascii character, potentially UTF-16?), so instead of reading 9 bytes, we just have to read in 18 instead:</p>
<div><figure><pre data-language="bash"><code><div><p><span>(</span><span>lldb</span><span>) </span><span>mem</span><span> </span><span>read</span><span> </span><span>0x08b29eac</span><span> </span><span>-c</span><span> </span><span>0x12</span></p></div><div><p><span>0x08b29eac:</span><span> </span><span>30</span><span> </span><span>00</span><span> </span><span>30</span><span> </span><span>00</span><span> </span><span>5f</span><span> </span><span>00</span><span> </span><span>49</span><span> </span><span>00</span><span> </span><span>6e</span><span> </span><span>00</span><span> </span><span>74</span><span> </span><span>00</span><span> </span><span>72</span><span> </span><span>00</span><span> </span><span>6f</span><span> </span><span>00</span><span>  </span><span>0.0._.I.n.t.r.o.</span></p></div><div><p><span>0x08b29ebc:</span><span> </span><span>00</span><span> </span><span>00</span><span>                                            </span><span>..</span></p></div></code></pre></figure></div>
<p>et voila, we know that 0x60 bytes within a <code>ULevel</code> points to a map name, and that we can easily access the <code>ULevel*</code> that LoadMap returns.</p>
<p>I expected this to be a <em>lot</em> more painful to figure out, especially since I actually did some fruitless string searching in my initial hacky attempts. At least I found out why I couldn’t find the string “00_Intro” in memory before… because of the 2-byte character type ;(</p>
<p>The LoadMap function signature has a parameter typed as <code>FString</code>, so I named the D version <code>FStringNoCap</code> as I had no interest in the capacity field.</p>
<div><figure><pre data-language="d"><code><div><p><span>struct</span><span> </span><span>FStringNoCap</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>uint</span><span> </span><span>ptr</span><span>;</span></p></div><div><p><span>    </span><span>uint</span><span> </span><span>length</span><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h2 id="last-loaded-map---reading-it-from-the-timer">Last Loaded Map - reading it from the timer</h2>
<p>This process is largely familiar already:</p>
<ol>
<li>Remember we left some extra nops between our “flag unsetter” and “return” instructions. This is the perfect place to store our next bit of code.</li>
<li>We just need to stuff the pointer <code>*(eax + 0x60)</code> and the length <code>*(eax + 0x64)</code> somewhere we can read it later.</li>
<li>We have plenty of unused space around where we store the loading flag, so we can just stuff the values there.</li>
</ol>
<p>Here’s how it was implemented:</p>
<div><figure><pre data-language="d"><code><div><p><span>void</span><span> </span><span>patchFlagSettersIntoLoadMap</span><span>(</span><span>/*...*/</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>const</span><span> </span><span>ubyte</span><span>[</span><span>8</span><span>][</span><span>3</span><span>] </span><span>stashMapNameInstructions</span><span> </span><span>=</span><span> [</span></p></div><div><p><span><span>        </span></span><span>[</span></p></div><div><p><span>            </span><span>// eax (used as the return register) contains a ULevel. ULevel + 0x60 is a string type,</span></p></div><div><p><span>            </span><span>// where the first four bytes is a pointer to the raw string data. This string is the level name.</span></p></div><div></div><div><p><span>            </span><span>// mov dword ecx, [eax + 0x60]</span></p></div><div><p><span>            </span><span>0x8B</span><span>,</span><span> </span><span>0x48</span><span>,</span><span> </span><span>0x60</span><span>,</span></p></div><div></div><div><p><span>            </span><span>// mov [LastLoadedMapPtr], ecx</span></p></div><div><p><span>            </span><span>0x89</span><span>,</span><span> </span><span>0x0D</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>(</span><span>lastLoadedMapAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>((</span><span>lastLoadedMapAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF00</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>1</span><span>))</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>((</span><span>lastLoadedMapAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF0000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>2</span><span>))</span><span>,</span></p></div><div><p><span><span>        </span></span><span>]</span><span>,</span></p></div><div><p><span><span>        </span></span><span>[</span></p></div><div><p><span>            </span><span>// Last byte of the previous instruction</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>((</span><span>lastLoadedMapAddress</span><span> </span><span>&amp;</span><span> </span><span>0xFF000000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>3</span><span>))</span><span>,</span></p></div><div></div><div><p><span>            </span><span>// We also need to stash the length so we know exactly how much memory to read, otherwise</span></p></div><div><p><span>            </span><span>// we&#39;d have to write a (potentially) slooow loop.</span></p></div><div><p><span>            </span><span>0x8B</span><span>,</span><span> </span><span>0x48</span><span>,</span><span> </span><span>0x64</span><span>,</span><span> </span><span>// mov dword ecx, [eax + 0x64]</span></p></div><div></div><div><p><span>            </span><span>// mov [LastLoadedMapLength], ecx</span></p></div><div><p><span>            </span><span>0x89</span><span>,</span><span> </span><span>0x0D</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>((</span><span>lastLoadedMapAddress</span><span> </span><span>+</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>(((</span><span>lastLoadedMapAddress</span><span> </span><span>+</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0xFF00</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>1</span><span>))</span><span>,</span></p></div><div><p><span><span>        </span></span><span>]</span><span>,</span></p></div><div><p><span><span>        </span></span><span>[</span></p></div><div><p><span>            </span><span>// Last two bytes of the previous instruction</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>(((</span><span>lastLoadedMapAddress</span><span> </span><span>+</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0xFF0000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>2</span><span>))</span><span>,</span></p></div><div><p><span>            </span><span>cast(ubyte)</span><span>(((</span><span>lastLoadedMapAddress</span><span> </span><span>+</span><span> </span><span>4</span><span>) </span><span>&amp;</span><span> </span><span>0xFF000000</span><span>) </span><span>&gt;&gt;</span><span> (</span><span>8</span><span> </span><span>*</span><span> </span><span>3</span><span>))</span><span>,</span></p></div><div></div><div><p><span>            </span><span>// nops</span></p></div><div><p><span>            </span><span>0x90</span><span>,</span><span>0x90</span><span>,</span><span>0x90</span><span>,</span><span>0x90</span><span>,</span><span>0x90</span><span>,</span><span>0x90</span><span>,</span></p></div><div><p><span><span>        </span></span><span>]</span></p></div><div><p><span><span>    </span></span><span>];</span></p></div><div></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>endOfLoadMapInstructions</span><span>+</span><span>8</span><span>,</span><span> </span><span>stashMapNameInstructions</span><span>[</span><span>0</span><span>]);</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>endOfLoadMapInstructions</span><span>+</span><span>16</span><span>,</span><span> </span><span>stashMapNameInstructions</span><span>[</span><span>1</span><span>]);</span></p></div><div><p><span>    </span><span>enginePatcher.poke8Bytes</span><span>(</span><span>loadMapSig</span><span>,</span><span> </span><span>endOfLoadMapInstructions</span><span>+</span><span>24</span><span>,</span><span> </span><span>stashMapNameInstructions</span><span>[</span><span>2</span><span>]);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>From there, the update controller is able to read in the map name:</p>
<div><figure><pre data-language="d"><code><div><p><span>auto</span><span> </span><span>deusExController</span><span>(</span><span>/*...*/</span><span>,</span><span> </span><span>size_t</span><span> </span><span>lastLoadedMapAddress</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div><p><span>    </span><span>FStringNoCap</span><span> </span><span>lastLoadedMapPtr</span><span>;</span></p></div><div><p><span>    </span><span>while</span><span>(</span><span>true</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>try</span><span> </span><span>lastLoadedMapPtr</span><span> </span><span>=</span><span> </span><span>deusex.peek</span><span>!</span><span>FStringNoCap</span><span>(</span><span>lastLoadedMapAddress</span><span>);</span></p></div><div><p><span>        </span><span>catch</span><span>(</span><span>Exception</span><span>) </span><span>continue</span><span>;</span></p></div><div><p><span>        </span><span>break</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>if</span><span>(</span><span>lastLoadedMapPtr.ptr</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.string</span><span> : </span><span>stripRight</span><span>;</span></p></div><div><p><span>        </span><span>lastLoadedMap</span><span> </span><span>=</span><span> </span><span>toDString</span><span>(</span><span>deusex</span><span>,</span><span> </span><span>lastLoadedMapPtr</span><span>)</span><span>.stripRight.stripRight</span><span>(</span><span>&#34;</span><span>\0</span><span>&#34;</span><span>);</span></p></div><div><p><span>        </span><span>mapLabel.text</span><span> </span><span>=</span><span> </span><span>lastLoadedMap</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>    </span><span>// ...</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>And finish off most of the other un-mentioned logic used by the timer to keep track of current map, as well as perform autosplitting.</p>
<p>The <code>toDString</code> function basically just converts the 2-byte characters into 1-byte characters, since the game only uses ASCII for the map names anyway.</p>
<p>And that’s <em>basically it</em> from the complicated side of things. At this point I sorted out the logic for saving and loading splits; updated the UI to be a bit more usable, and so on. All relatively boring stuff.</p>
<h2 id="issue---exception-handling-isnt-patched">Issue - exception handling isn’t patched</h2>
<p>During the any% speedrun route used for DeusEx, you’ll have to use a glitch called the “Glitchy Save”.</p>
<p>I don’t know the details behind it, but you essentially create a save during a third person cutscene, and then any attempts to load this save breaks the game script in useful ways.</p>
<p>The problem is that loading a Glitchy Save causes LoadMap to take a different branch, as it has to handle an exception being thrown during loading. This means the logic for unsetting the loading flag (and fetching the map name) will never trigger, as a that entire section of code doesn’t get executed.</p>
<p>This means the timer will be permanently paused until a valid map is loaded. I added a hacky way around this by keeping a list of levels that require the glitchy save, and making it so the timer will never pause on these levels, but it’s a less than ideal solution.</p>
<p>I haven’t really had the energy or motivation to look into this properly, but it shouldn’t be too much of a hassle to eventually fix… hopefully.</p>
<h2 id="issue---save-screens-arent-handled-at-all">Issue - Save screens aren’t handled at all</h2>
<p>The timer should also be trying to eliminated the time it takes to create a save, but currently I’ve not even attempted to bother with that - largely due to lack of motivation.</p>
<p>It should be very straightforward though, since I don’t even need to add any “fetch map name” logic. It’d just need the “is saving” flag logic.</p>
<h2 id="improvement---use-a-different-mechanism-for-detecting-loading-transitions">Improvement - use a different mechanism for detecting loading transitions</h2>
<p>Currently the timer will attempt to check the state of the loading flag + last loaded map name, every UI tick (8ms).</p>
<p>The issue is that the syscalls being performed for reading appear to cause the game to stutter in a slight but noticable way, making it a bit less pleasent to play.</p>
<p>I’ve been brainstorming a whole bunch on more efficient methods for detecing when “not loading -&gt; loading” and vice versa transition occurs, namely around trying to generate a Linux signal from the game’s side that then gets caught by the timer.</p>
<p>I haven’t found the energy yet to do some R&amp;D around this solution, but in theory it <em>could</em> work and help me avoid this currently janky method. It would require a decent refactor of both the timer logic and code injection though.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This article covered a ton of stuff from:</p>
<ul>
<li>Linux syscalls.</li>
<li>Special Linux directories.</li>
<li>Several cool features of D.</li>
<li>A deeper dive into a single function of DeusEx than most people would ever care about.</li>
<li>Basic assembly.</li>
</ul>
<p>I’m too tired to write a cheesy outro. bye.</p> <section> <a href="https://bradley.chatha.dev/blog/linux-speedrun-timer-dlang"> <div> <svg width="1rem" height="1rem" viewBox="0 0 16 16" data-icon="rivet-icons:chevron-left">   <path fill="currentColor" d="M9.737.854L3.69 8l6.047 7.146l1.526-1.292L6.31 8l4.953-5.854z"></path> </svg> <p><span>Group: How I made a speedrun timer in D</span> </p></div> </a> </section>  </section>  </div></div>
  </body>
</html>
