<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bartoszsypytkowski.com/wasm-replayable-functions/">Original</a>
    <h1>WebAssembly and Replayable Functions</h1>
    
    <div id="readability-page-1" class="page"><article>

		<!-- .post-header -->


		<div>
			<!--kg-card-begin: markdown--><p>... or how to make a non-deterministic functions deterministic through the power of isolated WASM sandbox. This time we&#39;ll go through the problems of unpredictability in code, which execution could be affected by external factors like I/O operations, time etc. Then we&#39;ll see what kind of domains would greatly benefit if we managed to solve these issues. And finally: how Web Assembly could help us in dealing with them.</p>
<h2 id="motivation">Motivation</h2>
<p>Let&#39;s consider several scenarios, where being able to isolate and control sources of uncertainty could benefit us.</p>
<h3 id="flaky-tests">Flaky tests</h3>
<p>One of the problems that developers often struggle with is diagnosing occasionally failing tests. This often happens when the bug inside of a test is related to a non-deterministic code execution sources like time conditional logic, random number generators, I/O operation or an order of scheduled tasks in parallel computation. Since any of these can produce different results with each call, they make hard to reproduce bugs.</p>
<p>Unfortunately almost none of the languages, runtimes and ecosystems used in production systems nowadays has sufficient abstractions allowing us to easily identify and substitute all possible sources of non-determinism. This forces users to sometimes introduce their own - often half-backed and incomplete - abstractions to isolate them.</p>
<h3 id="stateful-workflows">Stateful workflows</h3>
<p>Workflows are another candidate. We&#39;re talking about programs representing complex state machine, potentially within a long-running processes, that can include orchestrating multiple services, I/O operations over potentially long periods of time: days, weeks or months. Examples of such could be periodic subscription events like automated mailing or payment scheduling services.</p>
<p>Since we cannot simply call <code>sleep(1.month())</code> inside of a function logic hoping that machine it lives on won&#39;t die. This issue was usually solved by splitting the logic into steps, with complex frameworks or hand-crafted code gluing, persisting and navigating the state machine created by such workflow. All of that plumbing logic can easily obfuscate the actual domain, making it harder to reason about and maintain.</p>
<p>With that in mind solutions like <a href="https://learn.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp-inproc&amp;ref=bartoszsypytkowski.com">Azure Durable Functions</a> or <a href="https://temporal.io/?ref=bartoszsypytkowski.com">temporal.io</a> started offering an execution environment, capable of running, suspending and restoring the state produced by language-idiomatic code across multiple machine runs.</p>
<h3 id="replicating-state-by-replicating-functions">Replicating state by replicating functions</h3>
<p>The problem of state machine replication is quite popular in both industry and academia. Paxos and Raft are commonly used by pretty much any distributed system that needs to manage state. Conflict-free Replicated Data Types are another approach that also targets the same issue, but with different set of constraints.</p>
<p>Many of these implementations relly of something called <strong>replicated log of operations</strong>, meaning we replicate a sequence of records describing state change over multiple machines. These are usually predefined by system. We described that approach in <a href="https://www.bartoszsypytkowski.com/operation-based-crdts-protocol/">context of CRDTs</a> in the past.</p>
<p>Now imagine that the produced state change was huge or generated by some user defined script like <em>stored procedure or a formula in a spreadsheet</em>. We have to replicate the results of that formula execution (potentially thousands of cells), even if replicating the formula itself and recomputing it on other nodes would be much more lightweight option, mostly because:</p>
<ol>
<li>Custom scripts may be hard to serialize.</li>
<li>Logic often relies on at least one resource (usually time), which varies across replicated content execution.</li>
</ol>
<p>With Web Assembly, we can solve both of these issues.</p>
<h2 id="challenge">Challenge</h2>
<p>All of the examples above suffer from the same condition: non-determinism. Unfortunately many useful programs must rely on external inputs - changing over time - that are hard to identify and control.</p>
<p>What if we could escape that insanity? What if we could repeat the same function call to expect the same result, even if it was dependent on the external factors?</p>
<h2 id="here-comes-the-wasm">Here comes the WASM</h2>
<p>Nice thing about Web Assembly is that its implementations offer us a sandboxed environment which - thanks to deny-by-default architecture - cuts it off from all peripherals like clock and I/O devices. These can be provided by host if it specifies them explicitly as part of its imports (we&#39;ll see them later).</p>
<p>Below we&#39;re going to use code from <a href="https://github.com/Horusiath/replayable-functions/?ref=bartoszsypytkowski.com">this repository</a>. Our demo comes in two parts:</p>
<ol>
<li>Web Assembly binary written in Rust, which provides our &#34;user-defined stored procedure&#34;.</li>
<li>JavaScript host program which initialized a WASM virtual machine and executed WASM binary code.</li>
</ol>
<p>We&#39;ll be running following Rust program:</p>
<pre><code>#[no_mangle]
pub unsafe extern &#34;C&#34; fn echo() {
    // our &#34;business logic&#34; receive 5 messages from the outside
    // and send them back with &#39;echo:&#39; prefix, waiting 2 seconds
    // each time
    for _ in 0..5 {
        let timestamp = receive();
        sleep(2000.0);
        send(&amp;format!(&#34;echo: {}&#34;, timestamp))
    }
}

fn send(data: &amp;str) {
    let ptr = data.as_ptr();
    unsafe { write(ptr, data.len() as u32) }
}

const BUF_LEN: usize = 16;
static mut BUF: [u8; BUF_LEN] = [0u8; BUF_LEN];

fn receive() -&gt; String {
    let mut result = String::new();
    // concat buffered slices into full message
    while {
        unsafe {
            let ptr = BUF.as_mut_ptr();
            let n = read(ptr, BUF_LEN as u32) as usize;
            result.push_str(std::str::from_utf8_unchecked(&amp;BUF[0..n]));
            n == BUF_LEN
        }
    } { }
    result
}

extern &#34;C&#34; {
    /// Signal host that there&#39;s a string to write at address `ptr` 
    /// and it&#39;s `len` bytes long.
    fn write(ptr: *const u8, len: u32);
    /// Signal host that we want to read the next message, which could 
    /// be written into a buffer at a given address and provided length. 
    /// Returns number of bytes written into a buffer.
    fn read(ptr: *mut u8, len: u32) -&gt; u32;
    fn sleep(millis: f64);
}
</code></pre>
<p>Since WASM sandbox barrier primitives are very constrained - basically all we can pass are numbers/pointer addresses and shared memory between the host and WASM module - we use buffering pattern similar to reading the contents of the file.</p>
<p>What you can see is that our <code>echo</code> function depends on three external functions, that we expect to be provided by a WASM host: <code>send</code>/<code>receive</code> used for communication with the world outside, and sleep to present how to handle delays. Here, we&#39;ll use following definition:</p>
<pre><code>const env = {
    read: () =&gt; new Date().toISOString(),
    write: (str) =&gt; console.log(str),
    // sleep actively blocks current thread before returning
    sleep: (ms) =&gt; Atomics.wait(new Int32Array(new SharedArrayBuffer(4)),0 ,0, Number(ms)),
}
</code></pre>
<p>The problem here is that passing strings through WebAssembly instance requires writing to a shared memory. It doesn&#39;t happen automatically, so we need to add some extra logic to make our <code>env</code> object compliant with Rust extern function signatures:</p>
<pre><code>function imports(env) {
    const read = env.read
    const write = env.write
    const sleep = env.sleep
    
    let buf = null
    let readIdx = 0
    return {
        env: {
            read: (ptr, len) =&gt; {
                if (buf === null || readIdx === buf.byteLength) {
                    // we already passed full message, read the next one
                    const json = read()
                    const encoder = new TextEncoder()
                    buf = encoder.encode(json)
                    readIdx = 0
                }
                let n = Math.min(len, buf.byteLength - readIdx)
                const slice = buf.slice(readIdx, readIdx + n)
                readIdx += n
                const view = new Uint8Array(this.memory.buffer, ptr, n)
                view.set(slice)
                return n
            },
            write: (ptr, len) =&gt; {
                const view = new Uint8Array(this.memory.buffer, ptr, len)
                const decoder = new TextDecoder((&#39;utf-8&#39;))
                const json = decoder.decode(view)
                write(json)
            },
            sleep,
        }
    }
}
</code></pre>
<p>Since our reads happen through shared buffer memory, we need to split messages into chunks, that would fit into provided client buffer. If we would want to pass more complex data types, the logic is similar. We can do one of:</p>
<ol>
<li>Serialize object, pass it through shared memory and deserialize on the executing client code. This is the approach we use here.</li>
<li>Have a dedicated map, store object there and pass its unique key. We can define a set of dedicated methods to operate on that object using its identifier instead. It comes with a cost of indirection, but allows us to also ie. execute methods of object living in a host space. It&#39;s basically how <code>wasm-bindgen</code> enables our Rust code to perform reflection and interact with an external JavaScript environment.</li>
</ol>
<p>The <code>read</code>/<code>write</code>/<code>sleep</code> function signatures are good for our demo, but for building general purpose programs they may be too limiting. In order to avoid every framework/compiler to rely on it&#39;s own set of abstractions, Bytecode Alliance - organization in care of WASM future development - proposed to standardize them in form of <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/?ref=bartoszsypytkowski.com">WASI</a>. It&#39;s a thing worth keeping some attention on.</p>
<p>With all of definitions prepared, we can create a Web Assembly instance straight from JavaScript like in the code below:</p>
<pre><code>import * as fs from &#39;fs&#39;

// binary payload representing our complete WASM script
const bin = fs.readFileSync(&#39;path/to/wasm/binary.wasm&#39;)

this.memory = null // atm. we didn&#39;t construct memory object yet
function imports(env) { ... }
const env = { ... }
             
const importObject = imports(env)
const module = new WebAssembly.Module(bin)
const instance = new WebAssembly.Instance(module, importObject)
// rebind memory used by exported functions
this.memory = instance.exports.memory 

// get handle to Rust function and run it
const { echo } = instance.exports
echo()
</code></pre>
<p>For now if you try to run this program several times, you can notice that each time you&#39;ll run it, it will hang for few seconds (due to <code>sleep</code> call) and produce different result each time. We&#39;re going to change that.</p>
<h3 id="capturing-and-replaying-function-calls">Capturing and replaying function calls</h3>
<p>Our idea is very simple - we&#39;re going to wrap functions declared at the very beginning of our <code>imports</code> definition with a result capturing mechanism. That mechanism will work in two phases:</p>
<ol>
<li><strong>capturing</strong> is executed originally at source, first time a function is being called. During this phase we are running original underlying function calls and record their results on the fly onto call list (since the same function can be called multiple times over the course of WASM program execution).</li>
<li><strong>replaying</strong> is used to replay captured context of the function without actually doing any of the underlying extern calls. Instead it will return captured call results in FIFO order.</li>
</ol>
<p>Thankfully, building such mechanism is very simple:</p>
<pre><code>export class CapturingContext {
    constructor() {
        this.isCapturing = true
        this.callPointers = {}
        this.calls = {}
        this.memory = null
    }

    capture(name, fn) {
        return ((...args) =&gt; {
            const ctx = this.calls[name] || []
            this.calls[name] = ctx
            if (this.isCapturing) {
                let result = fn(...args)
                ctx.push(result) // record result before returning
                return result
            } else {
                // dequeue the next result from queue of records
                // and return it instead of doing a function call
                let ptr = this.callPointers[name] | 0
                let result = ctx[ptr++]
                this.callPointers[name] = ptr
                return result
            }
        }).bind(this)
    }

    imports(env) {
        const read = this.capture(&#39;read&#39;, env.read)
        const write = env.write
        // uncomment line below to capture the printed output as well
        //const write = this.capture(&#39;write&#39;, env.write)
        const sleep = this.capture(&#39;sleep&#39;, env.sleep)
     
        /* ... rest of our imports function defined before */   
    }
}
</code></pre>
<p>Our <code>capture</code> method is basically replacing original import function definitions with wrappers recording and replying their outputs depending on the execution context (capture vs. replay). Now let&#39;s compose our <code>CapturingContext</code> into a WASM instance.</p>
<pre><code>function run(context) {
    const module = new WebAssembly.Module(bin)
    const importObject = context.imports(env)
    const instance = new WebAssembly.Instance(module, importObject)
    context.memory = instance.exports.memory
    const { echo } = instance.exports

    echo() // our Rust code call
}

const context = new CapturingContext()
run(context) // first call - record execution trace
const snapshot = context.snapshot() // snapshot recorded calls

const context2 = new CapturingContext()
// restore recorded functions and replay the same logic
context2.replay(snapshot) 
run(context2)
</code></pre>
<p>Even if you run a new WASM instance over this captured snapshot, in second <code>run</code> call you&#39;ll notice two things:</p>
<ol>
<li>Results are exactly the same - we replaced time-dependent calls with results captured from previous run.</li>
<li>Our script executes almost instantaneously - this is result of capturing the <code>sleep</code> function itself. We still can see the console outputs though. It&#39;s because <strong>we didn&#39;t capture</strong> the <code>write</code> method. If we did so, printed statements would also be omitted in the second run. Depending on the use case this may or may not be a desired outcome.</li>
</ol>
<p>If you&#39;re ie. diagnosing a flaky test, this captured snapshot could be used to investigate the last failing run. If you&#39;re replicating this stored procedure call via ie. <a href="https://reubenbond.github.io/posts/caspaxos?ref=bartoszsypytkowski.com">CAS Paxos</a>, this snapshot could be a part of message payload to guarantee that the final state on each replica is consistent.</p>
<h3 id="workflows">Workflows</h3>
<p>When it comes to workflows, there are more considerations, however the basics are already there. What&#39;s special here is that long running processes usually can be cut into series of steps, split from each other by things like I/O operations or longer <code>sleep</code> periods.</p>
<p>The idea here is that we could build a boundaries around these natural barriers in code ie. in order to support long running processes, we could adapt our <code>sleep</code> function implementation to persist context snapshot recorded so far, scrap current WASM instance, then schedule a cron job to wake it up and restart in cases when sleep is about to take longer.</p>
<p>Each process restart means quickly replaying captured effects from the barrier functions - like immediate omission of <code>sleep</code> call, so that we could move to next execution steps right away - until we reach the next non-captured execution step.</p>
<p>This also means that the difference between capture/replay modes blurs out, as our workflow execution is both capturing un-executed steps and replaying the ones already performed on each restart, until the program completes.</p>
<h2 id="what-else">What else?</h2>
<p>We didn&#39;t cover non-determinism caused by multithreaded function execution - we didn&#39;t need to as WASM instances are by definition single threaded. We could of course change that - if you didn&#39;t notice our <code>send</code>/<code>receive</code> methods are already hints to an actor programming model - but again, since this happen over the boundaries of extern functions that we have control over, we can substitute them as well.</p>
<p>Keep in mind that replaying means re-executing code blocks between external functions - if such code contains ie. CPU-intensive logic, it will be executed each time it&#39;s called. That could be a problem, however it&#39;s much less frequent in scenarios we discussed above and can also be solved by having a conditional logic over the captured functions.</p>
<!--kg-card-end: markdown-->
		</div><!-- .post-content -->

		<!-- .post-footer -->

		<!-- .comments-area -->



	</article></div>
  </body>
</html>
