<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bitbanksoftware.blogspot.com/2024/01/surprise-esp32-s3-has-few-simd.html">Original</a>
    <h1>ESP32-S3 has a few SIMD instructions</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-8755256533679090735">
<h2>Intro</h2><p>Espressif Systems released their ESP32-S3 SoC a few years ago, but only recently have they released more documentation and support of its full capabilities. Without any changes to your code, the S3 runs about 15% faster than older ESP32 CPUs at the same clock speed. It has a &#39;hidden&#39; capability that&#39;s more difficult to use, but can be worth the effort if you need more speed. This article is aimed at programmers who are already familiar with <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> instructions on other platforms.</p><p>I&#39;ve been optimizing code with SIMD for more than 15 years on Intel, Arm and DSPs (even Cadence&#39;s), so when I heard that the S3 had SIMD instructions, I immediately went searching for documentation. When the S3 became available to buy, there was only a promise of documentation and support. In the 2+ years since then, not much has changed. At the end of 2023, Espressif released a document describing the new instructions:</p><p><a href="https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf">S3 Technical Reference Manual</a></p><p>The document has a decent level of detail and only a few errors, but what&#39;s missing still are examples and documentation on how to use them in your own code - conspicuously absent are instructions on using the assembler and linking them to your C/C++ code. This isn&#39;t entirely the fault of Espressif. The Xtensa processor comes from <a href="https://www.cadence.com/en_US/home/tools/ip/tensilica-ip/tensilica-xtensa-controllers-and-extensible-processors.html">Cadence</a> and for some reason they like to keep everything under NDA, even information which would help people use their processors. I find it hard to understand why the instruction set should be kept secret; a CPU vendor should make it as easy as possible for engineers to use their CPUs. The &#39;trade secrets&#39; are in the hardware design, not in the instruction set. I&#39;ve worked with Cadence&#39;s DSPs before, so I&#39;m familiar with their way of doing things. Their Vision DSPs have a robust and powerful instruction set. Unfortunately, the S3 has a very minimal set of SIMD instructions,Â  probably due to cost and silicon area limits.</p><p>Since the SIMD &#39;Processor Extension&#39; is treated as a coprocessor, the main instruction set must be mixed in the code. Here&#39;s the document for the main LX7 instructions:</p><p><a href="https://dl.espressif.com/github_assets/espressif/xtensa-isa-doc/releases/download/latest/Xtensa.pdf">Xtensa ISA</a></p><p>The programmer model consists of 16 general purpose/address registers (a0-a15), 8 128-bit wide SIMD registers (q0-q7), and two special accumulator registers for multiply/accumulate operations. The memory bus is documented as 128-bits wide, so it is definitely advantageous to read and write to memory at the native width. There are also some instructions to manipulate GPIO bits.</p><h3>How I got started with S3 SIMD</h3><p>I spent the better part of a day searching and experimenting with these instructions until I got working code. I started with a search on Github for any public repos containing the one instruction needed for any S3 SIMD project - load (ee.vld.128). A few hits popped up in Espressif&#39;s esp-dsp project. A lot of their ESP32-S3 code is closed source, but a few functions pulled back the veil on how to use them in my own projects. This is the code I used as a starting point:</p><p>https://github.com/espressif/esp-dsp/blob/master/modules/fft/fixed/dsps_fft2r_sc16_aes3.S</p><p>I tried putting multiple functions into a single .S file, but that doesn&#39;t seem to work so every function gets it&#39;s own file. My first use case for these instructions is to optimize the color conversion step of my JPEG decoder. The YCbCr-&gt;RGB step takes a significant amount of time and is a good fit for SIMD optimization.</p><h3>The Instruction Set</h3><p>I&#39;ve written SIMD code for the pixel color conversion multiple times in multiple SIMD instruction sets and what struck me with the S3 was how little I had to work with. One of the main sticking points is that even though the instruction encodings are 24-bits each, there&#39;s no bits reserved for shift amount. There are explicit shift instructions and even they don&#39;t have the shift amount encoded. The multiply instructions can shift right after multiply, but the shift amount must first be loaded into the SAR (shift amount register). This requires 2 additional instructions (and potentially additional pipeline cycles) to accomplish. The main sticking points which make it harder to get work done are that the instructions are not orthogonal across data sizes and are missing a lot of things needed to make efficient code. For example, the shift left and right instructions only operate on 32-bit values and only do arithmetic shifting (carry the sign bit), not logical. To generate RGB565 output, I need to shift 16-bit values. My workaround was to multiply by 1 and set the SAR for right shifting and multiply by a power of 2 and set the SAR to 0 for left shifting.</p><p>Here&#39;s a short list of what I consider essential SIMD features that are missing on the S3:</p><p>- Shift right logical</p><p>Also missing (Nice to haves) that other Cadence DSPs have:</p><p>- Scatter / gather writes/reads</p><h3>Where to go from here...</h3><p>I&#39;m going to add some optimized functions to my various imaging libraries where appropriate and see where it takes me. I did an initial test with my <a href="https://github.com/bitbank2/JPEGDEC">JPEGDEC</a> library and saw a nearly 40% speedup (14ms -&gt; 10ms) by using the S3 SIMD instructions for the color conversion step. I&#39;ll publish this code after I&#39;ve had time to fully flesh it out and test it. Good luck with your use of S3 SIMD...</p>
</div></div>
  </body>
</html>
