<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philosophicalhacker.com/post/aoc-sql/aoc-sql/">Original</a>
    <h1>Postgres SQL Lessons From Advent of Code Challenges</h1>
    
    <div id="readability-page-1" class="page"><article><hr/>
<p><strong><em>Note: This post was originally published on <a href="https://heap.io/blog/engineering/building-better-code-review-at-heap" target="_blank">heap’s blog</a> and was co-written with <a href="https://www.linkedin.com/in/amanda-murphy-17940835/details/experience/" target="_blank">Amanda Murphy</a></em></strong></p>
<hr/>
<p>We did something odd for Advent of Code this year: We solved a few challenges in javascript and then in PostgreSQL. We learned a few interesting things about SQL that we’d like to share here.</p>
<p>Disclaimer: We did not complete all 25 days in SQL (judging by the links from <a href="https://news.ycombinator.com/item?id=29472244" target="_blank">this HN thread</a>, it looks like pretty much no one did), but we still think the things we learned about SQL are useful and worth sharing, especially for non-experts. If you’re an expert, you may not learn anything here.</p>

<p>First, a quick refresher on window functions: you probably know that window functions perform calculations across a set of table rows that are somehow related to the current row. The example from <a href="https://www.postgresql.org/docs/current/tutorial-window.html" target="_blank">the Postgres docs</a> is calculating the department-specific average salary for a particular employee. The SQL looks like this:</p>
<div><pre><code data-lang="sql"><span>SELECT</span> depname, empno, salary, <span>avg</span>(salary) OVER (PARTITION <span>BY</span> depname) <span>FROM</span> empsalary;
</code></pre></div><p>In the above example, the “window” of rows considered are all rows whose department matches the department of the current row, but while working on the challenges, we learned that it’s also possible to define windows using ranges.</p>
<p>For example, on <a href="https://adventofcode.com/2021/day/1" target="_blank">day 1</a>, we’re asked to count the number of times the sum of values in a sliding window of three elements increases. You can express a sum of a sliding window of three elements using window function ranges. The SQL looks like this:</p>
<div><pre><code data-lang="sql"><span>SELECT</span> row_number, <span>sum</span>(value) OVER (<span>ORDER</span> <span>BY</span> row_number RANGE <span>BETWEEN</span> <span>CURRENT</span> <span>ROW</span> <span>AND</span> <span>2</span> FOLLOWING) <span>AS</span> value
         <span>FROM</span> input_with_rows
</code></pre></div><p>And the overall solution looks like this:</p>
<div><pre><code data-lang="sql"><span>WITH</span> input_with_rows <span>AS</span> (
    <span>SELECT</span> row_number() over () <span>AS</span> row_number, value
    <span>FROM</span> day1_input
),
     windows <span>AS</span> (
         <span>SELECT</span> row_number, <span>sum</span>(value) OVER (<span>ORDER</span> <span>BY</span> row_number RANGE <span>BETWEEN</span> <span>CURRENT</span> <span>ROW</span> <span>AND</span> <span>2</span> FOLLOWING) <span>AS</span> value
         <span>FROM</span> input_with_rows
     ),
     lagged <span>AS</span> (
         <span>SELECT</span> row_number, lag(value) OVER () <span>AS</span> value
         <span>FROM</span> windows
     )
<span>SELECT</span> <span>count</span>(<span>*</span>)
<span>FROM</span> windows
         <span>JOIN</span> lagged <span>ON</span> (windows.row_number <span>=</span> lagged.row_number <span>AND</span> lagged.value <span>&lt;</span> windows.value);
</code></pre></div><p>Ranges are just the tip of the iceberg. There are many other methods of defining windows. Check out <a href="https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" target="_blank">this page</a> of the Postgres docs for more.</p>

<p>Common Table Expressions or CTE’s are temporary, scoped, and aliased tables created via a simple query expression. Subqueries can achieve the same result in most cases, and although subqueries are more common in textbooks and database documentation than CTEs, we found that using CTE’s instead of subqueries eliminated a great deal of nesting.</p>
<p>There are plenty of resources that explain why deeply nested code is a code smell. Nesting can quickly become difficult to reason about. Following the flow of execution adds additional cognitive load when the reader has to jump around to get context. CTEs are sequential, and it’s easier for us humans to follow sequential steps.</p>
<p>Another advantage of using CTEs is that they can refer to their own output if you use the <code>RECURSIVE</code> keyword. <a href="https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-RECURSIVE" target="_blank">The docs</a> recommend using recursive CTEs to work with arbitrarily nested hierarchical data, but they can also be used for iteration.</p>
<p>We learned how to use CTEs for iteration while working on day 3. In the second part, we’re asked to:</p>
<ol>
<li>Start with a list of binary numbers and consider just the first bit of those numbers.</li>
<li>Discard numbers whose first bit does not match the most common bit in the first-bit position of all remaining numbers</li>
<li>If you only have one number left, stop; this is the value you’re looking for</li>
<li>Otherwise, repeat the process, considering the next bit to the right.</li>
</ol>
<p>The SQL for this is below. The interesting part where we use a recursive CTE is lines 14 - 40:</p>
<div><pre><code data-lang="sql"><span>\</span><span>copy</span> day3_input <span>FROM</span> <span>&#39;day3.txt&#39;</span>;


<span>WITH</span> bits_with_row_number <span>AS</span> (
    <span>SELECT</span> row_number() over ()            <span>AS</span> row_number,
           regexp_split_to_array(bits, <span>&#39;&#39;</span>) <span>AS</span> bits
    <span>FROM</span> day3_input
),
     bits_with_column_number <span>AS</span> (
         <span>SELECT</span> <span>*</span>, row_number() over (partition <span>by</span> row_number) <span>AS</span> col_number
         <span>FROM</span> bits_with_row_number
     ),
     recurse <span>AS</span> (
         <span>WITH</span> <span>RECURSIVE</span> filter <span>AS</span> (
             (<span>WITH</span> target_bit <span>AS</span> (<span>SELECT</span> bits,
                                         <span>CASE</span>
                                             <span>WHEN</span> (<span>sum</span>(bits[<span>1</span>]::integer) OVER ()) <span>&lt;</span> ((<span>count</span>(<span>*</span>) OVER ())::float <span>/</span> <span>2</span>) <span>THEN</span> <span>0</span>
                                             <span>ELSE</span> <span>1</span> <span>END</span> <span>AS</span> o2,
                                         <span>CASE</span>
                                             <span>WHEN</span> (<span>sum</span>(bits[<span>1</span>]::integer) OVER ()) <span>&lt;</span> ((<span>count</span>(<span>*</span>) OVER ())::float <span>/</span> <span>2</span>) <span>THEN</span> <span>1</span>
                                             <span>ELSE</span> <span>0</span> <span>END</span> <span>AS</span> co2
                                  <span>FROM</span> bits_with_column_number)
              <span>SELECT</span> <span>*</span>, <span>1</span> <span>AS</span> i
              <span>FROM</span> target_bit
              <span>WHERE</span> bits[<span>1</span>]::integer <span>=</span> co2
             )
             <span>UNION</span> <span>ALL</span>
             (<span>WITH</span> target_bit <span>AS</span> (<span>SELECT</span> bits,
                                         i,
                                         <span>CASE</span>
                                             <span>WHEN</span> <span>sum</span>(bits[i <span>+</span> <span>1</span>]::integer) OVER () <span>&lt;</span> ((<span>count</span>(<span>*</span>) OVER ())::float <span>/</span> <span>2</span>) <span>THEN</span> <span>0</span>
                                             <span>ELSE</span> <span>1</span> <span>END</span> <span>AS</span> o2,
                                         <span>CASE</span>
                                             <span>WHEN</span> <span>sum</span>(bits[i <span>+</span> <span>1</span>]::integer) OVER () <span>&lt;</span> ((<span>count</span>(<span>*</span>) OVER ())::float <span>/</span> <span>2</span>) <span>THEN</span> <span>1</span>
                                             <span>ELSE</span> <span>0</span> <span>END</span> <span>AS</span> co2
                                  <span>FROM</span> filter)
              <span>SELECT</span> bits, o2, co2, i <span>+</span> <span>1</span> <span>AS</span> i
              <span>FROM</span> target_bit
              <span>WHERE</span> bits[i <span>+</span> <span>1</span>]::integer <span>=</span> target_bit.co2)
         )
         <span>SELECT</span> <span>*</span>
         <span>FROM</span> filter
     )
<span>SELECT</span> <span>*</span>
<span>FROM</span> recurse
<span>WHERE</span> i <span>=</span> (<span>SELECT</span> <span>max</span>(i) <span>FROM</span> recurse);
</code></pre></div><p>There are <a href="https://malisper.me/understanding-postgres-recursive-ctes/" target="_blank">plenty</a> <a href="https://www.citusdata.com/blog/2018/05/15/fun-with-sql-recursive-ctes/" target="_blank">of</a> <a href="https://www.postgresql.org/docs/13/queries-with.html" target="_blank">good</a> explanations of how recursive CTEs work out there, so we won’t repeat those explanations here.</p>

<p>On day 4, we’re given a list of numbers and a list of bingo boards and we’re asked to find which bingo board wins first. When we started writing the SQL portion, we assumed that we would need to use a recursive CTE so that we could iterate over the boards, but the exercise of solving the problem in SQL helped us see the problem through a new lens. We learned that just because there’s an iterative aspect in the problem statement doesn’t mean we can’t abstract it away.</p>
<p>Breaking down the problem into smaller pieces allowed us to see another way. We needed to find the first winning board, but what does that mean? Well, first, we need to think about how a board wins. A board wins when all the numbers in a column or row have been called. So, we need to find out when each column and row won.</p>
<p>Breaking it down in this way allowed us to see that it was a sorting problem. We already knew the order the numbers were called in. You can use the number order to assign a “time” to each column and row that represents when that column or row won. Then we just find the min of that time for each board. Once you have that, you know when the board won. Then you sort the boards by when they won and you have your answer!</p>
<p>Translating this to SQL looks like this:</p>
<div><pre><code data-lang="sql"><span>WITH</span> boards_ordered_with_call_order <span>AS</span> (
         <span>SELECT</span> <span>*</span>
         <span>FROM</span> boards_ordered
                  <span>JOIN</span> called_numbers_with_row
                       <span>ON</span> called_numbers_with_row.called_number <span>=</span> boards_ordered.value
     ),
     col_win_orders <span>AS</span> (
         <span>SELECT</span> board_no, col_number, <span>max</span>(call_order) <span>AS</span> max_col_call_order
         <span>FROM</span> boards_ordered_with_call_order
         <span>GROUP</span> <span>BY</span> board_no, col_number
     ),
     row_win_orders <span>AS</span> (
         <span>SELECT</span> board_no, row_number, <span>max</span>(call_order) <span>AS</span> max_row_call_order
         <span>FROM</span> boards_ordered_with_call_order
         <span>GROUP</span> <span>BY</span> board_no, row_number
     ),
     row_and_col_win_orders <span>AS</span> (
         <span>SELECT</span> <span>*</span>
         <span>FROM</span> col_win_orders
                  <span>JOIN</span> row_win_orders
                       <span>USING</span> (board_no)
         <span>ORDER</span> <span>BY</span> board_no, row_number, col_number
     ),
     winning_boards <span>AS</span> (
         <span>SELECT</span> board_no,
                <span>min</span>(LEAST(max_col_call_order, max_row_call_order)) <span>AS</span> winning_call_number
         <span>FROM</span> row_and_col_win_orders
         <span>GROUP</span> <span>BY</span> board_no
         <span>ORDER</span> <span>BY</span> <span>2</span>
         <span>LIMIT</span> <span>1</span>
     ),
     last_called_number <span>AS</span> (
         <span>SELECT</span> <span>min</span>(called_numbers_with_row.called_number) <span>AS</span> number
         <span>FROM</span> winning_boards
                  <span>JOIN</span> called_numbers_with_row <span>ON</span> (called_numbers_with_row.call_order <span>=</span> winning_call_number)
     )
<span>SELECT</span> board_no, <span>sum</span>(value::integer <span>*</span> called_numbers_with_row.called_number::integer)
<span>FROM</span> boards_ordered_with_call_order
         <span>JOIN</span> winning_boards <span>USING</span> (board_no)
         <span>JOIN</span> called_numbers_with_row <span>ON</span> called_numbers_with_row.call_order <span>=</span> winning_call_number
<span>WHERE</span> boards_ordered_with_call_order.call_order <span>&gt;</span> winning_call_number
<span>GROUP</span> <span>BY</span> <span>1</span>
</code></pre></div><p>This exercise was a great way to add additional tools to our algorithmic toolboxes.</p>

<p>While rewriting our javascript solutions in SQL, we were struck by how compactly and safely we could express solutions in SQL. For example, one challenge requires that you calculate the position of a submarine after it executes a series of up-down-forward commands (it’s <a href="https://adventofcode.com/2021/day/2" target="_blank">day 2, part 1</a> if you really want to know the details of the problem). Here’s a solution in javascript:</p>
<div><pre><code data-lang="js"><span>let</span> <span>depth</span> <span>=</span> <span>0</span>;
<span>let</span> <span>horizontal</span> <span>=</span> <span>0</span>;
<span>instructions</span>.<span>forEach</span>(({ <span>direction</span>, <span>distance</span> }) =&gt; {
  <span>switch</span> (<span>direction</span>) {
    <span>case</span> <span>&#34;up&#34;</span><span>:</span>
      <span>depth</span> <span>-=</span> <span>distance</span>;
      <span>break</span>;
    <span>case</span> <span>&#34;down&#34;</span><span>:</span>
      <span>depth</span> <span>+=</span> <span>distance</span>;
      <span>break</span>;
    <span>case</span> <span>&#34;forward&#34;</span><span>:</span>
      <span>horizontal</span> <span>+=</span> <span>distance</span>;
      <span>break</span>;
  }
});

<span>console</span>.<span>log</span>(<span>depth</span> <span>*</span> <span>horizontal</span>);
</code></pre></div><p>And here’s the same solution in SQL:</p>
<div><pre><code data-lang="sql"><span>SELECT</span> <span>sum</span>(distance) FILTER ( <span>WHERE</span> direction <span>=</span> <span>&#39;forward&#39;</span> ) <span>*</span>
       (<span>-</span> <span>sum</span>(distance) FILTER ( <span>WHERE</span> direction <span>=</span> <span>&#39;up&#39;</span> ) <span>+</span>
        <span>sum</span>(distance) FILTER ( <span>WHERE</span> direction <span>=</span> <span>&#39;down&#39;</span> )) <span>AS</span> <span>position</span>
<span>FROM</span> day2_input
</code></pre></div><p>SQL actually looks more declarative and compact here than the javascript solution. We expected nearly all of my SQL solutions to be awkward but was pleasantly surprised to find it very elegant in this problem and in other cases.</p>
<p>We had another goal in writing this post. We’re hiring and these learnings provide a nice glimpse into the engineering culture at Heap. We use a lot of Postgres. We participate in Advent of Code challenges together. We have a growth mindset and love learning new things; if that sounds like a neat place to work, check us out.</p>
</article></div>
  </body>
</html>
