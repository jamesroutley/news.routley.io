<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.n16f.net/blog/reduce-vs-fold-in-common-lisp/">Original</a>
    <h1>Reduce vs. Fold in Common Lisp</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
      <h2 id="introduction">Introduction</h2>
<p>If you have already used functional languages, you are probably familiar with
fold, a high order function used to iterate on a collection of values to
combine them and return a result. You may be surprised that Common Lisp does
not have a fold function, but provides <code>REDUCE</code> which works a bit differently.
Let us see how they differ.</p>
<h2 id="understanding-reduce">Understanding <code>REDUCE</code></h2>
<p>In its simplest form, <code>REDUCE</code> accepts a function and a sequence (meaning
either a list or a vector). It then applies the function to successive pairs
of sequence elements.</p>
<p>You can easily check what happens by tracing the function:</p>
<pre><code>CL-USER&gt; (trace +)
CL-USER&gt; (reduce #&#39;+ &#39;(1 2 3 4 5))
  0: (+ 1 2)
  0: + returned 3
  0: (+ 3 3)
  0: + returned 6
  0: (+ 6 4)
  0: + returned 10
  0: (+ 10 5)
  0: + returned 15
15
</code></pre>
<p>In this example, the call to <code>REDUCE</code> evaluates <code>(+ (+ (+ (+ 1 2) 3) 4) 5)</code>.</p>
<p>You can reverse the order using the <code>:from-end</code> keyword argument:</p>
<pre><code>CL-USER&gt; (trace +)
CL-USER&gt; (reduce #&#39;+ &#39;(1 2 3 4 5) :from-end t)
  0: (+ 4 5)
  0: + returned 9
  0: (+ 3 9)
  0: + returned 12
  0: (+ 2 12)
  0: + returned 14
  0: (+ 1 14)
  0: + returned 15
15
</code></pre>
<p>In which case you will evaluate <code>(+ 1 (+ 2 (+ 3 (+ 4 5))))</code>. The result is of
course the same since the <code>+</code> function is associative.</p>
<p>You can of course provide an initial value, in which case <code>REDUCE</code> will behave
as if this value has been present at the beginning (or the end with
<code>:from-end</code>) of the sequence.</p>
<p>The surprising aspect of <code>REDUCE</code> is its behaviour when called on a
sequence with less than two elements:</p>
<ul>
<li>If the sequence contains a single element:
<ul>
<li>if there is no initial value, the function is not called and the element
is returned directly;</li>
<li>if there is one, the function is called on both the initial value and the
single element.</li>
</ul>
</li>
<li>If the sequence is empty:
<ul>
<li>if there is no initial value, the function is called without any argument;</li>
<li>if there is one, the function is not called and the initial value is
returned directly.</li>
</ul>
</li>
</ul>
<p>As a result, any function passed to <code>REDUCE</code> must be able to handle being
called with zero, one or two arguments. Most examples found on the Internet
use <code>+</code> or <code>append</code>, and these functions happen to handle it (e.g. <code>(+)</code>
returns the identity element of the addition, zero). If you write your own
functions, you will have to deal with it using the <code>&amp;OPTIONAL</code> lambda list
keyword.</p>
<p>This can lead to unexpected behaviours. If you compute the sum of a sequence
of floats using <code>(reduce #&#39;+ floats)</code>, you may find it logical to obtain a
float. But if <code>FLOATS</code> is an empty sequence, you will get <code>0</code> which is not a
float. Something to keep in mind.</p>
<h2 id="differences-with-fold">Differences with fold</h2>
<p>The fold function is traditionally defined as accepting three arguments: a
function, an initial value — or accumulator — and a list. The function is
called repeatedly with both the accumulator and a list element, using the
value returned by the function as next accumulator.</p>
<p>For example in Erlang:</p>
<pre><code>lists:foldl(fun(X, Sum) -&gt; Sum + X end, 0, [1, 2, 3, 4, 5]).
</code></pre>
<p>An interesting consequence is that fold functions are always called with the
same type of arguments (the list value and the accumulator), while <code>REDUCE</code>
functions can be called with zero or two list values. This makes it
harder to write functions when the accumulated value has a different type from
sequence values.</p>
<p>Fold is also simpler than <code>REDUCE</code> since it does not have any special case,
making it easier to reason about its behaviour.</p>
<p>It would be interesting to know why a function as fundamental as fold was not
included in the Common Lisp standard.</p>
<h2 id="implementing-foldl">Implementing <code>FOLDL</code></h2>
<p>We can of course implement a fold function in Common Lisp. We will concentrate
on the most common (and most efficient) left-to-right version. Let us start by
a simple implementation for lists:</p>
<pre><code>(defun foldl/list (function value list)
  (declare (type (or function symbol) function)
           (type list list))
  (if list
      (foldl/list function (funcall function value (car list)) (cdr list))
      value))
</code></pre>
<p>As clearly visible, the recursive call to <code>FOLDL/LIST</code> is in tail position and
SBCL will happily perform tail-call elimination.</p>
<p>For vectors we use an iterative approach:</p>
<pre><code>(defun foldl/vector (function value vector)
  (declare (type (or function symbol) function)
           (type vector vector))
  (do ((i 0 (1+ i))
       (accumulator value))
      ((&gt;= i (length vector))
       accumulator)
    (setf accumulator (funcall function accumulator (aref vector i)))))
</code></pre>
<p>Finally we write the main <code>FOLDL</code> function which operates on any sequence:</p>
<pre><code>(defun foldl (function value sequence)
  (declare (type (or function symbol) function)
           (type sequence sequence))
  (etypecase sequence
    (list (foldl/list function value sequence))
    (vector (foldl/vector function value sequence))))
</code></pre>
<p>At the point we can already use <code>FOLDL</code> for various operations. We could of
course improve it with the addition of the usual <code>:START</code>, <code>:END</code> and <code>:KEY</code>
keyword arguments for more flexibility.</p>

    </section>
  </div></div>
  </body>
</html>
