<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://somerandomidiot.com/blog/2022/03/04/chamelon/">Original</a>
    <h1>Chamelon: MVP persistent block storage for MirageOS</h1>
    
    <div id="readability-page-1" class="page"><div>

  

  <p>TL;DR: I wrote a <a href="https://github.com/mirage/mirage-kv">key-value store</a> for <a href="https://mirage.io">MirageOS</a> backed by <a href="https://github.com/mirage/mirage-block">block storage</a>. It’s called <a href="https://github.com/yomimono/chamelon">chamelon</a>, it’s based off <a href="https://github.com/littlefs-project/littlefs">LittleFS</a>, and if you’re brave, you can use it to store data.  Examples are available: <a href="https://github.com/yomimono/url-shortener">a URL shortener</a> and an <a href="https://github.com/yomimono/oauth2_server">OAuth2 authorization server</a>.</p>

<p>In English: I couldn’t save or load files before, and now I could. Wowzers!</p>



<p>I’ve spent a long time avoiding needing persistent writeable storage in my MirageOS unikernels. This blog, for example, doesn’t serve files from a filesystem - it uses <a href="https://github.com/mirage/ocaml-crunch">crunch</a> to make an in-memory key-value store for the unikernel out of files from the system on which the unikernel was built. Since the blog doesn’t generate any information while running that it needs to store, that’s plenty fine.  Many other “needs” for storage can be served by a remote database server, rather than a local filesystem, and in fact should be for any nontrivial data storage.</p>

<p>Unfortunately, there’s an inconvenient middle ground, where we need to store a small amount of crucial data which we’d prefer to keep as close to the vest as possible. For reasons that do not need explaining at this juncture, I recently found myself unavoidably on that middle ground.  To fill the gap between <code>block</code> and <code>kv</code>, there is a released <a href="https://github.com/mirage/ocaml-fat">FAT library for MirageOS</a> which I found unsatisfactory based on previous use and wasn’t interested in improving, and an unreleased filesystem called <a href="https://github.com/g2p/wodan">wodan</a> which I wasn’t confident would ever see release.</p>

<p>In short, it seemed my choices were to commit to maintaining a storage layer someone else had initially written, or maintain a storage layer I’d done the initial work on myself.  I’ve done a lot of work on MirageOS that sounds like “maintain something someone else initially wrote”, and since resigning from the core team, I’ve been enjoying not doing that anymore.  I decided to continue not doing that, and start my own filesystem implementation.  At least I would get to make all the design mistakes in this one!</p>



<p>Speaking of design, I’m not a storage expert. We wrote an <a href="https://www.freebsd.org/cgi/man.cgi?query=ffs&amp;sektion=7&amp;manpath=FreeBSD+7.4-RELEASE">ffs</a> implementation in <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf">my undergrad Operating Systems course</a>, and that’s about the most complicated storage thing I’ve ever been involved in.  I did, however, have an idea of the traits I wanted in a storage system:</p>

<ul>
<li>possible to implement <code>mirage-kv</code>’s hierarchical dictionaries on top of (in practice, a directory-based filesystem)</li>
<li>tolerates arbitrary poweroff without data loss or corruption</li>
<li>supports very small underlying storage (&lt; 1Mb, but ideally smaller)</li>
</ul>

<p>Like any underinformed person, I set about searching the web with stuff like “easy small fault-tolerant filesystem”. After an hour of depressing results, I came across <a href="https://github.com/littlefs-project/littlefs">the LittleFS project</a>.  In its own words,</p>

<blockquote>
<p>At a high level, LittleFS is a block based filesystem that uses small logs to store metadata and larger copy-on-write (COW) structures to store file data.</p>
</blockquote>

<p>Although the design had a lot of nice attributes, I’ll admit that the following quote from <a href="https://github.com/littlefs-project/littlefs/blob/master/DESIGN.md">DESIGN.md</a> is what hooked me:</p>

<blockquote>
<p>This relies on the
super secret computer science hack where you can pretend any algorithmic
complexity is <em>O(1)</em> by bounding the input.</p>
</blockquote>

<p>That’s the kind of design philosophy I can get behind.  <code>chamelon</code>, which the Internet informs me is French for “little camel” and definitely not a swear or anything, is only not named <code>ocaml-littlefs</code> because I was afraid that would be insulting to LittleFS.</p>



<p><code>chamelon</code> started off as a read-only tool for interpreting LittleFS filesystems, based on the on-disk structure documentation in <a href="https://github.com/littlefs-project/littlefs/blob/master/SPEC.md">SPEC.md</a>.  LittleFS’s reference implementation came with several useful tools for diagnosing my implementation’s various failures in interpreting on-disk structures, and the FUSE implementation for LittleFS also went a long way toward generating test cases for a reasonable OCaml implementation.</p>

<p>There are a few properties of LittleFS that make sense for the original intended environment (microcontrollers directly addressing flash devices) that I chose not to include for <code>chamelon</code>:</p>

<ul>
<li>wear-leveling: for a unikernel, we expect to get a virtual block device which the hypervisor is managing via its own device driver, which is presumably handling these details.</li>
<li>write fault detection: as above. However, we implement CRC32 checksumming on commits as in the LittleFS spec so as to retain interoperability; we just don’t check the CRC32 after write.</li>
<li>singly linked list threaded through the directory tree for constant RAM traversal. The additional complexity isn’t justified for any of my use cases.</li>
</ul>

<p>Additionally, since we’re not implementing a POSIX filesystem layer but rather the MirageOS <code>KV.RW</code> module type, there’s a lot we don’t need to do.  Prominently, we don’t care about <code>mv</code> operations at all, let alone atomic <code>mv</code> operations, which removes the motivation for a lot of global state manipulation in LittleFS.</p>

<p>LittleFS does not specify any on-disk format for timestamps, let alone modification or creation time. Implementing <code>mirage-kv</code> requires one to have some way of recording modification time, so this is implemented via “user attributes”.</p>



<p><code>chamelon</code> has been lightly <a href="https://github.com/yomimono/chamelon/blob/main/fuzz/fuzz.ml">fuzz tested</a> for graceful failure when initially connecting to a filesystem, and to ensure that formatting a block device always results in a clean filesystem.</p>

<p>It has also been <a href="https://github.com/yomimono/chamelon/blob/main/bench/read.ml">lightly benchmarked</a> to make sure baseline performance when searching directories is not worse than O(n).</p>

<p>A suite of manually created tests is available for <a href="https://github.com/yomimono/chamelon/blob/main/lib_test">LittleFS structure handling</a> as well as the MirageOS <a href="https://github.com/yomimono/chamelon/blob/main/mirage_test"><code>KV.RW</code> module implementation</a>.</p>

<p>Most of <code>chamelon</code>’s <a href="https://github.com/yomimono/chamelon/issues?q=is%3Aissue+is%3Aclosed">critical problems</a> have been discovered by the good old-fashioned practice of testing in prod.  They are overwhelmingly related to the <code>split</code> operation, which allows multiple metadata blocks to represent a single directory; future testing, both manual and automated, is likely to focus on this area.</p>



<h2 id="table-stakes">Table Stakes</h2>

<p>It’s <a href="https://github.com/yomimono/oauth2_server/blob/main/unikernel.ml#L27">trivial</a> to wire into a MirageOS unikernel.  <a href="https://github.com/yomimono/oauth2_server">It works</a> for the thing I wanted to use it for.</p>

<h2 id="it-s-small">It’s Small</h2>

<p>The smallest possible <code>littlefs</code> filesystem is, indeed, <em>very</em> little, a property <code>chamelon</code> inherits. It can handle block devices smaller than many hypervisors are ready to provide.</p>



<h2 id="performance-performance-performance">Performance, performance, performance</h2>

<p>Lists of items within a directory are unordered, so any operation on a directory (including finding a file within it) is <code>O(n)</code> on items within the directory.</p>

<p>The <code>mirage-kv</code> interface has a few functions (<code>last_modified</code>, <code>digest</code>) which are recursive over the contents of a dictionary (in <code>chamelon</code>, this means we have to apply them on all directory contents).  <code>chamelon</code> currently has no optimizations for these operations, although they could be implemented via user attributes.  However, doing so would sacrifice some interoperability with <code>littlefs</code> tools, which wouldn’t update these attributes when writing to the filesystem.</p>

<h2 id="space-usage">Space Usage</h2>

<p>This implementation is not suitable for use as a large filesystem. Addressing is limited to 32-bit block indices, and currently the solo5 block implementation supports blocks of a maximum size of 512 bytes, for a maximum addressible filesystem of 65535 MiB.  Block devices of larger size can be supplied, but only 64 GiB will be usable by <code>chamelon</code>.</p>

<p><code>littlefs</code> is most efficient in its space usage with many small ( &lt; <sup>1</sup>⁄<sub>4</sub> block size) files in a broad hierarchy (i.e. most directories have many files or other directories in them).  It is least space-efficient with many files of size &gt; <sup>1</sup>⁄<sub>4</sub> block size and &lt; 1 block size, and with deeply-nested directory structures.  Combined with the duplication of every block’s metadata, this can result in lots of wasted space in worst-case scenarios.</p>



<p>OK! <code>chamelon</code> (and <code>chamelon-unix</code>, a suite of command-line tools) are available in opam as of midday on 2022/03/04, thanks to <a href="https://github.com/ocaml/opam-repository/pull/20838#issuecomment-1059261250">lots of help from the opam maintainer team</a>.</p>

<p>The <code>mirage</code> front-end tool doesn’t know about <code>chamelon</code>, so in order to use it you’ll have to ask for a block device in your <code>config.ml</code> and then run <code>Kv.Make</code> on the block device in your unikernel’s main method.  See the examples at the top of this page for more details.</p>

<p>Happy saving!</p>
  
  




</div></div>
  </body>
</html>
