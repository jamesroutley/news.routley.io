<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jsgroth.dev/blog/posts/dkc2-open-bus/">Original</a>
    <h1>Donkey Kong Country 2 and Open Bus</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>Donkey Kong Country 2 has a pretty well-known bug in the old SNES emulator ZSNES where some stages have spinning barrels that don’t work properly. One of the earliest pictured here, in the first stage of Krem Quay (third world):</p>
<p><img src="https://jsgroth.dev/blog/images/dkc2/barrel.png" alt="Barrel"/><span>Barrel Bayou</span></p>
<p>After you jump into the barrel, you’re supposed to be able to completely control its rotation by pressing left and right on the d-pad, with the barrel only rotating while you’re holding left or right. In ZSNES, this is horribly bugged. Tapping left or right makes the barrel spin forever in that direction, until you press the opposite direction…which simply makes it spin forever in the opposite direction.</p>
<p>This is more than just annoying - it makes these stages significantly more difficult than the developers intended, since later on the spinning barrels show up over spikes and other hazards:</p>
<p><img src="https://jsgroth.dev/blog/images/dkc2/more-barrel.png" alt="More Barrel"/><span>Klobber Karnage</span></p>
<p>This used to be somewhat documented in threads on the ZSNES forums, but those unfortunately seem to have gone offline since last I looked at them, and I can’t find the relevant threads indexed in the Wayback Machine.</p>
<p>This bug is caused by ZSNES not emulating open bus behavior. I believe this was originally discovered by Anomie roughly two decades ago, who subsequently fixed the same bug in Snes9x. This original fix hardcoded the specific addresses to return the values that the game depends on rather than properly emulating open bus, but it fixed DKC2 and probably didn’t break anything else. The bug was never fixed in ZSNES, which is now a long abandoned project (last release in 2007).</p>
<p>Purely out of curiosity, I wanted to dig into this a little more to figure out what exactly in the game code causes these barrels to spin forever in an emulator that doesn’t emulate open bus behavior.</p>
<h2 id="open-bus-behavior-and-65816-memory-addressing"><a href="#open-bus-behavior-and-65816-memory-addressing"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:open-bus-behavior-and-65816-memory-addressing">Open Bus Behavior and 65816 Memory Addressing</a></h2>
<p>On older platforms like the SNES, reading from an invalid memory address <em>usually</em> does not crash the program. There are cases where accessing specific invalid addresses can cause the hardware to lock up, but I don’t believe this can happen on SNES.</p>
<p>Instead, reading from an invalid address usually triggers <a href="https://snes.nesdev.org/wiki/Open_bus" target="_blank" rel="noopener">open bus behavior</a>, where the CPU re-reads the last value that was put on the data bus. SNES specifically has several different internal buses that can retain different open bus values, but this doesn’t affect DKC2.</p>
<p>The main SNES CPU is a <a href="https://en.wikipedia.org/wiki/WDC_65C816" target="_blank" rel="noopener">65C816</a> (aka 65816). There’s some other hardware around it as part of the <a href="https://en.wikipedia.org/wiki/Ricoh_5A22" target="_blank" rel="noopener">Ricoh 5A22</a> S-CPU package, such as a multiplication/division unit and a DMA unit, but the core CPU is a 65816.</p>
<p>65816 is a 16-bit extension of the <a href="https://en.wikipedia.org/wiki/MOS_Technology_6502" target="_blank" rel="noopener">6502</a>, a very popular 8-bit CPU used in many systems including the NES (with slight modifications). The 65816 is mostly backwards compatible with 6502 software, which was not important for the SNES (which has no NES backwards compatibility) but was very important for the <a href="https://en.wikipedia.org/wiki/Apple_IIGS" target="_blank" rel="noopener">Apple IIGS</a> that this CPU was originally designed for.</p>
<p>I personally think the 65816 ISA is pretty awkward. 8-bit vs. 16-bit operation is based on new processor status flags M (accumulator / memory size) and X (index register size) rather than being encoded into opcode bits, so software needs to frequently execute the new instructions SEP (set processor flags) and REP (reset processor flags) to manually adjust register and memory access sizes as needed. This also makes 65816 disassembly extraordinarily painful without tracing execution in an emulator, since some instructions vary in length depending on the current processor flags - e.g. an immediate operand can be either 1 byte (8-bit) or 2 bytes (16-bit).</p>
<p>Beyond that (and slightly more relevant to this post), addressing more than 64 KB of memory requires dealing with memory banking which is not fun. The 65816 has a 24-bit address bus, but most addresses are created by combining an 8-bit bank with a 16-bit offset. This is sort of similar to how the earliest x86 CPUs segment memory into 64 KB segments, except 65816 has no address overlap between different 64 KB memory banks.</p>
<p><img src="https://jsgroth.dev/blog/images/dkc2/address.png" alt="Address"/><span>24-bit 65816 address</span></p>
<p>Many instructions still operate using 16-bit addresses internally, like on 6502, plus the program counter is still 16-bit. There’s a new 8-bit program bank register (PBR / K) used for instruction fetches, and a new 8-bit data bank register (DBR / B) used for instructions and addressing modes that produce a 16-bit memory address rather than 24-bit. Software needs to manually track and update these bank registers as needed. There are long jump instructions that simultaneously update PBR and PC, but regular jump instructions and conditional branch instructions cannot jump between different program banks.</p>
<p>The hardware stack and the direct page (65816’s replacement for the zero page) are not banked - they are always located within memory bank $00.</p>
<p>The SNES memory map is <em>very much</em> designed around the 65816’s memory banking. It’s much more useful to think of SNES memory addresses as a separate 8-bit bank and 16-bit offset rather than a single 24-bit address.</p>
<p>When you’re inside one of these spinning barrels, Donkey Kong Country 2 reads from addresses $2000 and $2001 in bank $B3. In some other banks these addresses would map to either the cartridge or RAM, but in bank $B3 they are not mapped to anything, so reading from them is open bus behavior. Why does the game do this?</p>
<h2 id="disassemble"><a href="#disassemble"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:disassemble">Disassemble!</a></h2>
<p>Here’s a disassembly of the part of the game code that performs the open bus read, generated from an execution trace and then edited a bit for clarity (e.g. replacing the relative branch offset with a label). This is part of a routine that’s executed once per frame, beginning when you release left/right on the gamepad while you’re in a spinning barrel:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span><span>; initial state:
</span></span></span><span><span><span>;   DBR (data bank) = $B3
</span></span></span><span><span><span>;   D (direct page) = $0000
</span></span></span><span><span><span>;   M and X flags both clear (16-bit registers and memory)
</span></span></span><span><span><span>;   X = $0E9E
</span></span></span><span><span><span>;   Y = $0DE2
</span></span></span><span><span><span></span>  <span>lda</span> <span>$48</span><span>,</span><span>x</span>
</span></span><span><span>  <span>clc</span>
</span></span><span><span>  <span>adc</span> <span>$0028</span><span>,</span><span>y</span>
</span></span><span><span>  <span>sta</span> <span>$32</span>
</span></span><span><span>  <span>eor</span> <span>$48</span><span>,</span><span>x</span>
</span></span><span><span>  <span>and</span> <span>$2000</span>       <span>; 16-bit open bus read!
</span></span></span><span><span><span></span>  <span>beq</span> <span>continue</span>
</span></span><span><span>
</span></span><span><span><span>; this part of the routine will never execute if open bus reads always return 0
</span></span></span><span><span><span></span>  <span>lda</span> <span>#$0000
</span></span></span><span><span><span></span>  <span>sta</span> <span>$0028</span><span>,</span><span>y</span>
</span></span><span><span>  <span>lda</span> <span>$32</span>
</span></span><span><span>  <span>clc</span>
</span></span><span><span>  <span>adc</span> <span>#$1000
</span></span></span><span><span><span></span>  <span>and</span> <span>#$e000
</span></span></span><span><span><span></span>  <span>sta</span> <span>$48</span><span>,</span><span>x</span>
</span></span><span><span>  <span>rts</span>
</span></span><span><span>
</span></span><span><span><span>continue:</span>
</span></span><span><span>  <span>lda</span> <span>$32</span>
</span></span><span><span>  <span>sta</span> <span>$48</span><span>,</span><span>x</span>
</span></span><span><span>  <span>rts</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>This routine accesses a few memory addresses in the $0000-$2001 range. Some of them are through absolute addressing modes that use the current data bank of $B3, while others use direct page addressing modes that always access bank $00. The direct page itself is located at $0000 here, same as the 6502 zero page.</p>
<p>Banks $B3 and $00 happen to have the same memory map for this $0000-$2001 address range. In banks $00-$3F and $80-$BF, $0000-$1FFF always maps to the first 8 KB of the console’s 128 KB of working RAM (WRAM). $2000-$20FF is entirely unmapped, so the <code>and $2000</code> instruction is an open bus read.</p>
<p>It’s using a few WRAM addresses here that seem to contain the following, based on what values the game writes to them and what it uses them for:</p>
<ul>
<li>$0EE6 ($48 + X=$0E9E): The current barrel orientation</li>
<li>$0E0A ($0028 + Y=$0DE2): Per-frame rotation amount, as a change to barrel orientation</li>
<li>$0032: Seems to be used as just a temporary variable</li>
</ul>
<p>I imagine the exact orientation/rotation locations in WRAM are different for different barrels.</p>
<p>The barrel orientation appears to be on a scale where 0x0000 is pointing straight down, 0x4000 is pointing straight left, etc.</p>
<p><img src="https://jsgroth.dev/blog/images/dkc2/orientation.png" alt="Barrel Orientation"/><span>Barrel orientation values</span></p>
<p>The rotation amount determines the barrel rotation speed. For the barrel I looked at, the game sets the rotation amount to 0x0300 when rotating clockwise and 0xFD00 (-0x0300) when rotating counterclockwise. This makes a full 360 degree rotation take just over 85 frames, a little less than 1.5 seconds at 60 frames per second.</p>
<p>Okay, starting to step through this routine:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span>  <span>lda</span> <span>$48</span><span>,</span><span>x</span>     <span>; $0EE6 - barrel orientation
</span></span></span><span><span><span></span>  <span>clc</span>
</span></span><span><span>  <span>adc</span> <span>$0028</span><span>,</span><span>y</span>   <span>; $0E0A - rotation amount
</span></span></span><span><span><span></span>  <span>sta</span> <span>$32</span>       <span>; $0032 - temp
</span></span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>This part is straightforward: It loads the current orientation, adds the rotation amount, and stores the result in a temporary variable. It executes CLC (clear carry flag) before ADC (add with carry) because the 65816, like the 6502, does not have an add without carry instruction.</p>
<p>Next is the interesting part:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span>  <span>eor</span> <span>$48</span><span>,</span><span>x</span>     <span>; $0EE6 - barrel orientation
</span></span></span><span><span><span></span>  <span>and</span> <span>$2000</span>     <span>; open bus read!
</span></span></span><span><span><span></span>  <span>beq</span> <span>continue</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>It XORs the updated orientation with the previous orientation, bitwise ANDs the result with an open bus read from $2000, and then branches based on whether the bitwise AND produced zero. The spinning forever bug triggers when the branch is <em>always</em> taken because the bitwise AND result is <em>always</em> zero.</p>
<p>On actual hardware, the 16-bit open bus read from $2000 always returns 0x2020. This is because the last byte read from the bus is always the high byte of the $2000 absolute address encoded in the instruction bytes, little-endian:</p>
<pre tabindex="0"><code>2D 00 20
</code></pre><p><span>Machine code for <code>and $2000</code> (3 bytes)</span></p>
<p>Since the 65816 only has an 8-bit data bus, it implements 16-bit reads by performing two consecutive 8-bit reads, which in this case will both return 0x20. Hence the 16-bit value 0x2020.</p>
<p>So, in practice, that part of the routine behaves equivalently to this:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span>  <span>eor</span> <span>$48</span><span>,</span><span>x</span>     <span>; $0EE6 - barrel orientation
</span></span></span><span><span><span></span>  <span>and</span> <span>#$2020    ; replace open bus read with constant 0x2020
</span></span></span><span><span><span></span>  <span>beq</span> <span>continue</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>Moving on, when the AND result is zero and the <code>beq continue</code> branch is taken, it does this:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span><span>continue:</span>
</span></span><span><span>  <span>lda</span> <span>$32</span>       <span>; $0032 - temp
</span></span></span><span><span><span></span>  <span>sta</span> <span>$48</span><span>,</span><span>x</span>     <span>; $0EE6 - barrel orientation
</span></span></span><span><span><span></span>  <span>rts</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>It loads the pre-XOR rotated orientation from the temporary variable, writes it to the permanent orientation location in WRAM, then returns. The rotation will continue next frame.</p>
<p>When the AND is non-zero and the branch is not taken, it does this:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span><span>  <span>lda</span> <span>#$0000
</span></span></span><span><span><span></span>  <span>sta</span> <span>$0028</span><span>,</span><span>y</span>   <span>; $0E0A - rotation amount
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>lda</span> <span>$32</span>       <span>; $0032 - temp
</span></span></span><span><span><span></span>  <span>clc</span>
</span></span><span><span>  <span>adc</span> <span>#$1000
</span></span></span><span><span><span></span>  <span>and</span> <span>#$e000
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>sta</span> <span>$48</span><span>,</span><span>x</span>     <span>; $0EE6 - barrel orientation
</span></span></span><span><span><span></span>  <span>rts</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>First, it zeroes out the rotation amount. 65816 has a dedicated instruction STZ (store zero) for zeroing out a memory location, but STZ doesn’t support any Y-indexed addressing modes like what the game uses here (absolute indexed Y).</p>
<p>Next, it loads the pre-XOR rotated orientation, adds 0x1000, and masks out all but the highest 3 bits. This is a crude but fast way of approximately rounding to the nearest multiple of 0x2000.</p>
<p>Finally, it writes the rounded orientation to the permanent location in WRAM and then returns.</p>
<p>All together, in a higher level language, this routine is doing this:</p>
<div><div>
<div><table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="python"><span><span><span>new_orientation</span> <span>=</span> <span>(</span><span>orientation</span> <span>+</span> <span>rotation</span><span>)</span> <span>&amp;</span> <span>0xFFFF</span>
</span></span><span><span><span>if</span> <span>(</span><span>orientation</span> <span>^</span> <span>new_orientation</span><span>)</span> <span>&amp;</span> <span>0x2020</span> <span>!=</span> <span>0</span><span>:</span>
</span></span><span><span>    <span># Approximately round orientation and terminate rotation</span>
</span></span><span><span>    <span>orientation</span> <span>=</span> <span>(</span><span>new_orientation</span> <span>+</span> <span>0x1000</span><span>)</span> <span>&amp;</span> <span>0xE000</span>
</span></span><span><span>    <span>rotation</span> <span>=</span> <span>0</span>
</span></span><span><span><span>else</span><span>:</span>
</span></span><span><span>    <span># Continue rotation</span>
</span></span><span><span>    <span>orientation</span> <span>=</span> <span>new_orientation</span>
</span></span></code></pre></td></tr></tbody></table></div>
</div>
</div><p>With the open bus read returning 0x2020, the XOR-then-AND result will be non-zero when adding the rotation amount to orientation changes either bit 5 (0x0020) or bit 13 (0x2000). Given a rotation amount of 0x0300 or 0xFD00, bit 5 is always 0, so only bit 13 can ever change.</p>
<p>For convenience, here’s the orientation values diagram again:
<img src="https://jsgroth.dev/blog/images/dkc2/orientation.png" alt="Barrel Orientation"/></p>
<p>Looking at this, an orientation change of 0x2000 corresponds to a single-step change in cardinal or ordinal direction. This means that bit 13 will change when the barrel either reaches or passes over one of these 8 directions. Whether it changes upon reaching or upon passing over depends on the rotation direction, but it’s not really significant from a player perspective since it’s only a 1-frame difference and only in specific cases.</p>
<p>Rounding to the nearest multiple of 0x2000 ensures that the stopped barrel points exactly in a cardinal or ordinal direction, since it may have passed over the direction on the final rotation frame.</p>
<p>So, if you replace the open bus read with a constant 0x2000, I think this logic makes sense! When you release the d-pad, the barrel continues to rotate in the same direction until it reaches the next cardinal or ordinal direction, and then the rotation stops with the barrel pointing exactly in that direction.</p>
<h2 id="conclusion"><a href="#conclusion"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"></path></svg></a><a href="#contents:conclusion">Conclusion</a></h2>
<p>At this point I am pretty sure the open bus read was simply caused by a typo.</p>
<p>I think that <code>and $2000</code> instruction (absolute addressing) was supposed to be <code>and #$2000</code> (immediate addressing). <code>and $2000</code> just happens to work because the 16-bit open bus read from $2000 returns a value that is functionally equivalent to 0x2000 in this logic as long as the per-frame rotation amount always has its lowest 6 bits set to 0.</p>
<p>The incorrect opcode is executed at bank $B3 offset $EDAC, which maps to $33EDAC in the game’s 4 MB of ROM. Changing this byte from 0x2D (AND with absolute addressing) to 0x29 (AND with immediate addressing) makes the spinning barrels work correctly even if open bus reads always return 0. The exact location in ROM probably varies between different revisions of the game; I only looked at one revision.</p>
<p>This was purely an academic exercise since the game works perfectly fine in just about every SNES emulator other than the long-obsolete ZSNES, but my curiosity is satisfied.</p>

            </div></div>
  </body>
</html>
