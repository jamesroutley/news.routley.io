<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.upbound.io/scaling-kubernetes-to-thousands-of-crds/">Original</a>
    <h1>Scaling Kubernetes to Thousands of CRDs</h1>
    
    <div id="readability-page-1" class="page"><section>
				<p>Over the past few months <a href="https://crossplane.io">Crossplane</a> has pushed the boundaries of Kubernetes with the number of Custom Resources it supports. In this post we’ll explore the limitations <a href="https://upbound.io">Upbound</a> engineers have discovered and how we’ve helped to overcome them.</p><h2 id="background">Background</h2><p>Upbound founded Crossplane to help you build cloud control planes. These control planes sit one level above the cloud providers and allow you to customize the APIs they expose. Platform teams use Crossplane to offer the developers they support simpler, safer, self-service interfaces to the cloud.</p><p>Crossplane uses what we call a provider to extend a control plane with support for new clouds - for example installing the AWS provider allows your control plane to wrap AWS with your own concepts and policy. A Crossplane provider extends Crossplane with support for all of the APIs that its underlying cloud provider supports. We call these APIs Managed Resources, or MRs.</p><p>MRs are the building blocks of which the APIs you define using Crossplane are composed. To build a control plane with Crossplane you:</p><ol><li>Define the APIs you’d like your control plane to expose.</li><li>Install the providers you’d like to use to power those APIs.</li><li>Teach Crossplane which MRs to create, update, or delete when someone calls your APIs.</li></ol><figure><img src="https://blog.upbound.io/content/images/2022/08/simpler.png" alt="" loading="lazy" width="2000" height="902" srcset="https://blog.upbound.io/content/images/size/w600/2022/08/simpler.png 600w, https://blog.upbound.io/content/images/size/w1000/2022/08/simpler.png 1000w, https://blog.upbound.io/content/images/size/w1600/2022/08/simpler.png 1600w, https://blog.upbound.io/content/images/size/w2400/2022/08/simpler.png 2400w" sizes="(min-width: 1200px) 1200px"/><figcaption>Crossplane can be configured to expose a simple PostgreSQLInstance API that is powered by an RDSInstance Managed Resource.</figcaption></figure><p>Crossplane providers aim to be high fidelity, full coverage representations of their corresponding cloud providers. At the time of writing AWS exposes around 1,000 API endpoints, which means installing an AWS provider with full coverage of the AWS API would extend Crossplane with support for around 1,000 new kinds of MR. A multi-cloud control plane that uses full coverage AWS, Azure, and GCP providers would support around 2,000 MRs. Behind the scenes, each of these MRs is defined by a Kubernetes Custom Resource Definition (CRD).</p><p>The Kubernetes API server is a key component of a Crossplane control plane. Upbound identified the strength of Kubernetes’s control plane early on and chose to build Crossplane on it. The API server offers an extensible JSON REST API with out-of-the-box support for reliable persistence (i.e. etcd) as well as useful features like Role Based Access Control (RBAC) and webhooks that can mutate or validate the data contained in an API call before it is committed to storage.</p><p>The API server distinguishes between “built in” API resources that power mostly container-focused concepts like Pods, Deployments, and Services from “Custom (API) Resources” (CRs) that may represent anything. A Crossplane MR is a kind of Kubernetes CR. The API server uses CRDs to learn about new kinds of CRs. A CRD includes all the information the API server needs to expose a new CR - for example its type and OpenAPI schema. This is a fairly novel approach; the API server exposes an API that can be called to teach it other APIs to expose.</p><p>Before Crossplane even the most advanced Kubernetes users extended their API servers with only a modest amount of CRs - perhaps creating tens of CRDs. As Crossplane began to support hundreds of MRs we began to discover limits to the number of CRDs Kubernetes could handle.</p><h2 id="api-discovery">API Discovery</h2><p>The issues we’ve observed can be grouped into two buckets - client-side and server-side. The client-side issues are largely contained to a process known as discovery. Clients like kubectl use this process to discover what APIs an API server supports. This allows clients - among other things - to ‘autocomplete’ API types. For example, to know that when someone types kubectl get po they probably mean kubectl get pods.</p><p>The key issue with the discovery process is that it requires a client to “walk” many of the API server’s endpoints. Custom resources are served by the API server at endpoints like:</p><!--kg-card-begin: markdown--><pre><code>https://example.org/apis/&lt;group&gt;/&lt;version&gt;/&lt;kind&gt;/&lt;name&gt; ‌
</code></pre>
<!--kg-card-end: markdown--><p>For example a MR named cool-db and of kind: Instance in the rds.aws.upbound.io/v1 API group would be served at:</p><!--kg-card-begin: markdown--><pre><code>https://example.org/apis/rds.aws.upbound.io/v1/instances/cool-db
</code></pre>
<!--kg-card-end: markdown--><p>In order to discover that this endpoint exists a client queries:</p><ol><li>https://example.org/apis to get the list of supported API groups, e.g. rds.aws.upbound.io.</li><li>https://example.org/apis/rds.aws.upbound.io to determine what versions exist within a group, e.g. v1.</li><li>https://example.org/apis/rds.aws.upbound.io/v1 to determine what kinds of CR exist at version v1.</li></ol><p>When there are thousands of different kinds of CR, clients have to hit <em>a lot</em> of API endpoints to complete the discovery process. For example the ~2,000 kinds of Crossplane MR offered by the “big three” cloud providers - AWS, Azure, and GCP - are spread across about 300 API groups and versions, meaning that clients must make around 300 HTTP requests to perform discovery. This isn’t fundamentally that bad - responses to these requests are reasonably small relative to modern network speeds and clients can leverage HTTP/2 to avoid the overhead of many TCP connections to the API server. The scaling issues we’ve seen around discovery are largely due to assumptions made by client-side rate limiters and caches.</p><h2 id="client-side-rate-limits">Client-Side Rate Limits</h2><p>The first client side issues we noticed made themselves quite obvious - every ten minutes kubectl’s cache of discovery results would be invalidated and it would emit logs like the following for up to 5 or 6 minutes before actually doing what you asked it to do:</p><!--kg-card-begin: markdown--><pre><code>Waited for 1.033772408s due to client-side throttling, not priority and fairness, request: GET:https://api.example.org/apis/pkg.crossplane.io/v1?timeout=32s
</code></pre>
<!--kg-card-end: markdown--><p>This issue was fairly straightforward to address. The part of kubectl that performs discovery uses a rate limiter to ensure it doesn’t overload the API server. When we first noticed these logs the rate limiter allowed the client to make 5 requests per second on average, with bursts of up to 100 requests.</p><p>The quick fix for this issue was to relax the rate limits. Today discovery is still limited to 5 requests per second but allows bursts of up to 300 per second. This limit was <a href="https://github.com/kubernetes/kubernetes/pull/105520">raised in kubectl</a> in time for the v1.22 release at the request of engineers from Cruise and Upbound among others. The discovery cache was also <a href="https://github.com/kubernetes/kubernetes/pull/107141">configured to expire after 6 hours</a> rather than 10 minutes. <a href="https://github.com/kubernetes/kubernetes/pull/109141">As of Kubernetes v1.25</a> all clients built on <a href="https://github.com/kubernetes/client-go">the client-go library</a> will enjoy the raised limit.</p><h2 id="client-side-cache-writes">Client-Side Cache Writes</h2><p>The next client-side issue was a little tougher to diagnose. Our analysis showed that even with rate limiting completely disabled it could take almost 20 seconds to perform discovery of ~300 API groups. At first we assumed this was a network limitation - that it simply took around 20 seconds for a modern internet connection to download the discovery data. Through <a href="https://github.com/crossplane/crossplane/issues/2895#issuecomment-1162688419">a stroke of good luck</a> we noticed that it actually only took 20 seconds on macOS - on Linux it was almost instantaneous.</p><figure><img src="https://blog.upbound.io/content/images/2022/08/clipped.png" alt="" loading="lazy" width="338" height="492"/><figcaption><em>Lots of time spent inside the diskv.WriteStream mutex.</em></figcaption></figure><p>Fortunately kubectl has a convenient -profile flag that allows us to gain insight into where it’s spending its time. After trying a few different types of profile we noticed that the mutex profiler showed that 94% of kubectl’s time was spent inside a code path related to caching the discovery data.</p><p>We found that the <a href="https://github.com/peterbourgon/diskv">diskv</a> library kubectl uses to cache discovery data was configured to <a href="https://man7.org/linux/man-pages/man2/fdatasync.2.html">fsync</a> all cached files - one file for each of the ~300 discovery endpoints. This system call ensures that the operating system flushes data written to a particular file all the way down to persistent storage. On macOS <a href="https://go-review.googlesource.com/c/go/+/130676/">Go uses the F_FULLSYNC fnctl</a> to provide a strong guarantee that data has been persisted to disk. This is apparently much slower than on other operating systems, and <a href="https://developer.apple.com/documentation/xcode/reducing-disk-writes#Minimize-Explicit-Storage-Synchronization">not recommended by Apple</a> except where it&#39;s critical to persist data.</p><blockquote><em>F_FULLFSYNC Does the same thing as </em><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/fsync.2.html#//apple_ref/doc/man/2/fsync"><em>fsync(2)</em></a><em> then asks the drive to flush all buffered data to the permanent storage device (arg is ignored). This is currently implemented on HFS, MS-DOS (FAT), and Universal Disk Format (UDF) file systems. The operation may take quite a while to complete.</em></blockquote><p>There’s <a href="https://twitter.com/marcan42/status/1494213862970707969?lang=en">some amount of controversy</a> around whether Apple’s storage layer is fundamentally slower than others, or whether their hardware is simply more honest about the time required to fully persist data. Either way, the level of guarantee provided by this call is not required for a cache that can easily be recreated.</p><p>As of Kubernetes v1.25 Upbound has <a href="https://github.com/kubernetes/kubernetes/pull/110851">updated kubectl</a> (and all client-go based clients) to guarantee the integrity of the discovery cache using checksums rather than fsyncs. Instead of trying hard to persist the cache at write time we detect and invalidate corrupt entries at read time. This approach provides similar integrity ~25x faster on macOS (it’s also ~2x faster on Linux).</p><p>Before our fix it took ~22ms to write then read a cached value:</p><!--kg-card-begin: markdown--><pre><code>$ go test -v -bench . -run &#39;^Bench&#39;
goos: darwin
goarch: arm64
pkg: k8s.io/client-go/discovery/cached/disk
BenchmarkDiskCache
BenchmarkDiskCache-10    	      60	  22272642 ns/op
PASS
ok  	k8s.io/client-go/discovery/cached/disk	2.582s
</code></pre>
<!--kg-card-end: markdown--><p>After our fix it takes ~0.7ms to write then read a cached value:</p><!--kg-card-begin: markdown--><pre><code>$ go test -v -bench . -run &#39;^Bench&#39;
goos: darwin
goarch: arm64
pkg: k8s.io/client-go/discovery/cached/disk
BenchmarkDiskCache
BenchmarkDiskCache-10    	    1534	    761469 ns/op
PASS
ok  	k8s.io/client-go/discovery/cached/disk	1.483s```</code></pre>
<!--kg-card-end: markdown--><h2 id="future-client-side-improvements">Future Client-side Improvements</h2><p>The discovery rate limits have (infamously?) been <a href="https://github.com/kubernetes/kubernetes/pull/105520#discussion_r723535829">compared to</a> the <a href="https://home.treasury.gov/policy-issues/financial-markets-financial-institutions-and-fiscal-service/debt-limit">US debt ceiling</a> - a limit that is raised every time it is hit. The current limits are <em>just</em> enough for Crossplane’s most intensive use cases but that won’t last long. There’s an increasing demand to remove them entirely.</p><p>The spirit of the client-side rate limits is to avoid overloading the API server with too many requests. This is intuitively a good idea, but suffers from two issues:</p><ul><li>Rate limiter state doesn’t persist past the lifetime of the client. Most kubectl commands complete within a second or three, so a rate limiter has a small amount of context in which to make decisions. If each kubectl command takes a second to complete a tight loop of commands would effectively be limited to 300 requests per second.</li><li>There’s no coordination between clients - many clients all bursting to 300 requests per second at once could still overload the API server.</li></ul><p><a href="https://kubernetes.io/docs/concepts/cluster-administration/flow-control/">API Priority and Fairness</a> (AP&amp;F), which became a beta feature of the API server in v1.20, overcomes the above issues. It uses server-side queues and traffic shedding to protect the API server. With AP&amp;F:</p><ul><li>Each API server has a configurable number of priority levels.</li><li>RBAC-like rules classify requests to priority level by resource type, user, namespace, etc.</li><li>Requests may be <a href="https://aws.amazon.com/builders-library/workload-isolation-using-shuffle-sharding/">shuffle-sharded</a> across several queues to significantly reduce the impact of noisy clients on their peers, even at the same priority level.</li><li>Requests are served an inexpensive HTTP 429 “Too Many Requests” response when the API server is overloaded.</li></ul><p>Work is also underway to reduce the number of HTTP requests required to perform discovery, obviating the need for rate limits. <a href="https://github.com/kubernetes/enhancements/blob/6e877297a54fcddc319db90b7459a9476b9018dc/keps/sig-api-machinery/3352-aggregated-discovery/README.md">A Kubernetes Enhancement Proposal</a> (KEP) that would add a single aggregated HTTP endpoint for discovery has been approved and is targeting alpha support in Kubernetes v1.26. With this endpoint in place clients would be able to perform discovery by hitting a single HTTP endpoint. This aggregated discovery endpoint will also support <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag#caching_of_unchanged_resources">ETag based caching</a>, allowing clients to ensure they download discovery data only when their cache is known to be stale.</p><h2 id="openapi-schema-computation">OpenAPI Schema Computation</h2><p>Around the same time we first saw reports of client-side rate limiting we also noticed that the Kubernetes API Server <a href="https://github.com/crossplane/crossplane/issues/2649#issuecomment-954581257">would act strangely</a> under CRD load:</p><blockquote><em>I saw all kinds of crazy errors, from etcd leaders changing to the API server reporting that there was no such kind as CustomResourceDefinition, to HTTP 401 Unauthorized despite my credentials working on subsequent requests.</em></blockquote><p>Primarily we would see requests taking a long time to be served, if they were served at all. This behavior seemed to persist for up to approximately one hour after a few hundred CRDs were created.</p><figure><img src="https://blog.upbound.io/content/images/2022/08/cpu-bad.png" alt="" loading="lazy" width="1024" height="768" srcset="https://blog.upbound.io/content/images/size/w600/2022/08/cpu-bad.png 600w, https://blog.upbound.io/content/images/size/w1000/2022/08/cpu-bad.png 1000w, https://blog.upbound.io/content/images/2022/08/cpu-bad.png 1024w" sizes="(min-width: 720px) 720px"/><figcaption><em><em>A period of intense CPU utilization immediately following the creation of 765 AWS CRDs</em></em></figcaption></figure><p>When we looked at monitoring dashboards we would see that the API server showed a period of heavy CPU utilization immediately after many CRDs were created. Interestingly, we noted that this period of elevated utilization was even longer when we added a large batch of CRDs to an API server that already had many.</p><p>Profiling the API server’s CPU utilization showed that the main offender was <a href="https://github.com/kubernetes/kubernetes/blob/00aab63/staging/src/k8s.io/apiextensions-apiserver/pkg/controller/openapi/controller.go#L156">the logic that computes its aggregate OpenAPI v2 schema</a>. Each time a CRD was added or updated the OpenAPI controller would:</p><ol><li>Build a swagger spec for the defined CR.</li><li>Merge swagger specs of all known CRs together into one big spec.</li><li>Serialize the giant merged spec into JSON, so it could be served by the /openapi/v2 endpoint.</li></ol><p>That is, each time a CRD was added or updated the API server was doing serialization work that became more and more expensive as the number of CRDs increased. Adding many CRDs at once caused this to happen in a tight loop that could easily starve the API server’s CPU budget.</p><p>In this case we were lucky. After <a href="https://github.com/kubernetes/kubernetes/issues/101755">earlier reports</a> of increased <em>memory</em> usage following CRD creation the API server maintainers had identified and begun work on a fix that also alleviated the CPU usage we had observed. <a href="https://github.com/kubernetes/kube-openapi/pull/251">This fix</a> makes computation of the schema served at /openapi/v2 lazy - it defers all processing until a client actually makes a request to that API endpoint. With a little help from Upbound to bump dependencies and keep cherry-picks moving, the fix made it into Kubernetes v1.23.0 and was backported to patch releases v1.20.13, v1.21.7, and v1.22.4.</p><h2 id="etcd-clients">etcd Clients</h2><p>With the new, more efficient approach to OpenAPI schema computation we quickly noticed the next API server-side bottleneck - persistently elevated memory utilization. In our experiments we found that the API server uses a little over 4MiB of physical (Resident Set Size, or RSS) memory per CRD.</p><figure><img src="https://blog.upbound.io/content/images/2022/08/kube-apiserver-mem-metrics.png" alt="" loading="lazy" width="2000" height="453" srcset="https://blog.upbound.io/content/images/size/w600/2022/08/kube-apiserver-mem-metrics.png 600w, https://blog.upbound.io/content/images/size/w1000/2022/08/kube-apiserver-mem-metrics.png 1000w, https://blog.upbound.io/content/images/size/w1600/2022/08/kube-apiserver-mem-metrics.png 1600w, https://blog.upbound.io/content/images/size/w2400/2022/08/kube-apiserver-mem-metrics.png 2400w" sizes="(min-width: 1200px) 1200px"/><figcaption><em>API server memory usage with 780 CRDs installed</em></figcaption></figure><p>This is particularly problematic for hosted Kubernetes services like Google Kubernetes Engine (GKE), which often limit the CPU and memory available to the API server. These services can gracefully scale the API server up when they predict it will require more resources - e.g. when more nodes are created. Unfortunately at the time of writing most don’t factor in more CRDs being created and won’t begin scaling until the API server is repeatedly “OOM killed” (terminated for exceeding its memory budget).</p><blockquote><em>Although it took only ~150 s for the ProviderRevision to acquire the Healthy condition, the regional GKE cluster went through the repairing mode at least three times afterwards. In between these &#34;RUNNING&#34; and &#34;RECONCILING&#34; states of the regional cluster, we have observed different kinds of errors in response to the kubectl commands run, notably connection errors and I/O timeouts while reaching the API server. It took over an hour for the cluster to stabilize. However, the control-plane was intermittently available for short periods during this period.</em></blockquote><p>All the hosted Kubernetes services we’ve tested (i.e. GKE, AKS, and EKS) are affected by this issue to various extents. They all self-heal, but experience periods of API server unavailability ranging from 4-5 seconds through to an hour until they do. Note that this doesn’t stop the cluster from functioning entirely - Kubelets and containers continue to run - but it does stop all reconciliation.</p><p>Again we turned to Go’s handy built-in profiling tools, and immediately found some low-hanging fruit. It turns out that a logging library named <a href="https://github.com/uber-go/zap">Zap</a> was responsible for more than 20% of in-use API server memory. Ironically Zap is explicitly designed for low overhead, but was accidentally being misused.</p><figure><img src="https://blog.upbound.io/content/images/2022/08/profile.png" alt="" loading="lazy" width="2000" height="1054" srcset="https://blog.upbound.io/content/images/size/w600/2022/08/profile.png 600w, https://blog.upbound.io/content/images/size/w1000/2022/08/profile.png 1000w, https://blog.upbound.io/content/images/size/w1600/2022/08/profile.png 1600w, https://blog.upbound.io/content/images/size/w2400/2022/08/profile.png 2400w" sizes="(min-width: 1200px) 1200px"/><figcaption>zapcore.newCounters is responsible for 23% of memory of an idle API server with 1,878 CRDs</figcaption></figure><p>The API server actually <a href="https://github.com/kubernetes/kubernetes/issues/111622">creates an etcd client per served version of a CR</a> (i.e. at least one etcd client per CRD), and each etcd client was instantiating its own Zap logger. This not only results in <a href="https://github.com/kubernetes/kubernetes/issues/111476">a significant memory impact from hundreds of redundant loggers</a>, but hundreds of unnecessary TCP connections between the API server and the etcd database in which it stores its data.</p><p>Most Kubernetes API machinery maintainers seem to agree that the correct fix to this problem is to have all CR endpoints share a single etcd client. However, because we raised this issue late in the Kubernetes v1.25 release cycle we’ve opted to make a small strategic fix and simply <a href="https://github.com/kubernetes/kubernetes/pull/111477">have all etcd clients share a single logger</a>. This fix will be included with Kubernetes 1.25 when it is released in late August, as well as the next round of patch releases for Kubernetes 1.22, 1.23, and 1.24 that will be released around the same time. We’re hopeful that this ~20% reduction in memory usage will alleviate some of the issues we’ve observed with hosted Kubernetes services.</p><h2 id="future-server-side-improvements">Future Server-side Improvements</h2><p>We expect that our long term efforts server-side will be focused on lowering the compute resource cost of a CRD. In the more immediate future we’ve <a href="https://github.com/kubernetes/kubernetes/pull/111559">begun work</a> to dramatically reduce the number of etcd clients the API server uses from one per defined CR version to one per transport (i.e. per etcd cluster). We’re also working with the GKE, EKS, and AKS engineering teams to ensure their services can handle the number of CRDs Crossplane installs.</p><p>Early investigation also shows that the API server is responsive to garbage collection tuning, with a naive experiment to trigger garbage collection when the heap grows by 50% (as opposed to the default behavior of triggering at 100% heap growth) resulting in a 25% reduction in peak RSS memory usage on an idle API server with ~2,000 CRDs installed. Further testing is required to determine whether the CPU impact of more frequent garbage collection is tolerable. Once Go 1.19 is released it may also be worth experimenting with <a href="https://tip.golang.org/doc/gc-guide#Memory_limit">the new memory limit setting</a>, which provides a soft memory limit that the Go runtime will attempt to respect.</p><h2 id="summary">Summary</h2><p>Over the last 12 months the Crossplane community has identified a new Kubernetes scaling dimension - number of defined Custom Resources - and pushed it beyond its limits. Upbound engineers have helped diagnose and remove these limits, including:</p><ul><li>Restrictive client-side rate-limiters.</li><li>Slow client-side caches.</li><li>Inefficient OpenAPI schema computation.</li><li>Redundant, expensive, etcd clients.</li></ul><p>Alper Rifat Uluçınar in particular has been instrumental in helping diagnose most of these issues - thank you Alper! If you found this post to be interesting you may also like his <a href="https://www.youtube.com/watch?v=jYiLN0vmncw">recent Kubecon talk on the subject</a>.</p><p>If building, profiling, and optimizing cutting edge distributed systems sounds like a fun challenge (it is!), consider joining us at <a href="https://www.upbound.io/">Upbound</a>. We’re helping platform teams around the world to build internal cloud platforms that help them deliver amazing experiences to their own end users. We’re a global remote-first company – as of the writing of this post, Upbounders work fully remotely from 10 countries on five continents. Take a look at <a href="https://boards.greenhouse.io/upbound">our open roles</a> - we’re hiring.</p>
			</section></div>
  </body>
</html>
