<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.bittacklr.be/the-workflow-pattern.html">Original</a>
    <h1>The Workflow Pattern</h1>
    
    <div id="readability-page-1" class="page"><div><p>Over the past months I&#39;ve finally started experimenting with event sourced workflows, a topic I had been contemplating the last couple of years. I&#39;ve taken inspiration from other products and projects, such as <a href="https://docs.aws.amazon.com/step-functions/">AWS Step Functions</a>, <a href="https://cloud.google.com/workflows">GCP Workflows</a>, <a href="https://temporal.io/">Temporal</a>, <a href="https://camunda.com/">Camunda</a>, <a href="https://particular.net/nservicebus">NServiceBus</a> and <a href="https://masstransit-project.com/">MassTransit</a> to name a few. I do want to point out that, if you&#39;re already heavily invested into any of these, I&#39;m not trying to deter you from using them. After all, a simple pattern can&#39;t cover the breadth of a product. If you&#39;re applying event sourcing, then the following pattern <em>may</em> prove to be a useful stepping stone.</p>
<p>Why did I decide to climb this particular hill? Well, on the one hand, I&#39;m not particularly overwhelmed by the workflow authoring experience some products offer. Granted, this may be a point of contention. On the other hand, there are not a lot of examples out there on how to model an event sourced workflow. But more importantly, it was an itch and scratching was long overdue.</p>
<p>What&#39;s a workflow anyway? For the purpose of this blog post, I&#39;m going to position it as the automation of a process (or part of), which we can not accomplish in a single transaction for one reason or another. Those reasons may be either technical or functional, or both. In this context, workflows are more akin to <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html">process managers</a> than <a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">sagas</a>, meaning a central unit that orchestrates. In my experience most workflows can be modelled as state machines or <a href="https://statecharts.dev/what-is-a-statechart.html">state charts</a>. The ability to visualize those state machines in turn helps us see the bigger picture and spot deficiencies in our design more easily.</p>
<p>Where do workflows sit? Sometimes at the edges of, other times inside of a service or bounded context or module, however you partitioned your system. This is also the reason why their codified form may only be a small part of the overall process we&#39;re trying to automate. Central unit does not automatically mean <em>centralize the whole process</em>. If we were to do that, we would bring ourselves in the awkward position of not knowing where to place it. Instead multiple workflows, each one in its proper place, can, together, automate the overall process, to whatever degree we deem useful. At the edges they can observe both the <em>outside</em> and <em>inside</em> and mediate between them, sometimes acting as a slayer of corruption, other times as a translator from Babylon.</p>
<p>What&#39;s the purpose of a workflow? To make decisions that help move the overall process along. Each decision causes a state transition, meaning it goes from its current state to the next state, even if that next state is the same state as the current state. This is acceptable, since we only make those states explicit that have a particular relevance to moving the process along. Well-designed workflows have a beginning, a middle and an ending. Unless they are really simple, it&#39;s recommended to zoom in on each of those stages in a workflow&#39;s lifecycle. That implies something causes them to begin, to continue to be, and to end. In state machine speak, we call the things that cause transitions <em>triggers</em>. Not surprisingly, <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html">messages</a> make for good trigger candidates.</p>
<blockquote>
<p>Most workflows I encounter in existing implementations are more like riddles. Hidden as columns or properties ending with a suffix called <code>Status</code> or <code>State</code>, often having <code>Active</code>, <code>Inactive</code>, <code>Pending</code>, <code>InProgress</code> as values. Mingled with other boolean columns and properties, they indicate we&#39;re in a certain state of the machine, thus somewhere along in the process. Does this sort of implementation sound familiar? I&#39;m sure it does for some of you. It baffles me how well versed domain experts and their proxies have become in this sort of <code>column</code> speak. The meaning of the words used as values has to be explained over and over again because they are in effect weasel words. It&#39;s as if they&#39;ve forgotten how to articulate a process without leaning on the current solution as a crutch. All the more reason to make the implicit explicit, if you ask me.</p>
</blockquote>
<p>When it comes to implementing workflows there are quite a few problems that need to be tackled:</p>
<ul>
<li>How is a workflow initiated and how do you know which workflow to initiate?</li>
<li>How will messages be delivered to a workflow?</li>
<li>How are messages correlated to a workflow?</li>
<li>What does a workflow need to remember, how and where do we store that memory, how do we correlate that memory back to a workflow?</li>
<li>How and when are the decisions taken by a workflow executed?</li>
<li>How can we observe workflow execution behavior?</li>
</ul>
<p>This list is not exhaustive by any means but already covers some interesting problems. Most of these can be considered generic, that is, the solution is the same regardless of which workflow we&#39;re trying to implement. The components that take care of these problems are often highly reusable and not surprisingly, products, libraries and frameworks are born to solve them. With that in mind, the part that&#39;s left is the authoring experience for developers.</p>
<p>Explaining workflows in the abstract is one thing, yet binding it to concrete examples is much more useful. So before we continue, I have to tell you a true story. Well, more like a confession üòâ</p>
<blockquote>
<p>I recently received a letter from the police with an amicable settlement for a traffic violation I committed. It&#39;s a rare phenomenon, me breaking a speed limit, but it did happen on this particular occasion. The car the infraction was committed with is registered to my company, which explains why the letter was addressed to my company instead of my person. In Belgium you&#39;ve got 15 days to identify who drove the car at the time of the infraction - they can&#39;t make any assumptions - or, if you don&#39;t know who drove it, who is responsible for the car. Failing to do so causes you to incur a higher fine or being prosecuted. The reason this is required is because the infraction has to be added to someone&#39;s criminal record. Once the driver is identified, they in turn will be invited to pay the fine. You can still choose to pay as a company or have the driver pay. You can choose the order in which you perform payment and driver identification. You can ask for a payment plan but you have to realize it&#39;s limited to 6 months. If you don&#39;t pay in time, you&#39;ll get payment reminders but the fine itself will increase with each reminder. You can contest the fine and have this dispute accepted or rejected. If the dispute is rejected, the procedure continues as though it wasn&#39;t contested - you just have to pay the fine. Not paying causes all kinds of escalations that would have me stray too far off topic.</p>
</blockquote>
<p>There&#39;s plenty of possible workflows in the above narrative, if you ask me. I&#39;ve taken some liberty in how I&#39;ve modelled them, so bear with me.</p>
<p>At the edges of the subsystem that deals with traffic fines lives a workflow that&#39;s observing the police&#39;s reporting subsystem.</p>
<p>flowchart TB
    InputChannel([Input Channel])
    OutputChannel([Output Channel])
    OutputChannel--Police Report Published--&gt;InputChannel
    subgraph Police Reporting System
        PoliceReport--Police Report Published--&gt;OutputChannel
    end
    subgraph Traffic Fine System
        InputChannel--Police Report Published--&gt;IssueTrafficFineForSpeedingViolationWorkflow
    end
</p>
<p>Its job is to make sure that police reports that report a speeding violation cause a traffic fine to be issued to the subject to whom the vehicle is registered.</p>
<p>stateDiagram-v2
    state IsSpeedingViolationChoice &lt;&lt;choice&gt;&gt;
    [*] --&gt; IsSpeedingViolation: PoliceReportPublished
    IsSpeedingViolation--&gt;IsSpeedingViolationChoice
    IsSpeedingViolationChoice--&gt;AwaitingSystemNumber: [yes]\n / Send(GenerateTrafficFineSystemNumber)
    IsSpeedingViolationChoice--&gt;[*]: [no]\n / Complete
    AwaitingSystemNumber--&gt;AwaitingManualIdentificationCode: TrafficFineSystemNumberGenerated / Send(GenerateTrafficFineManualIdentificationCode)
    AwaitingManualIdentificationCode--&gt;[*]: TrafficFineManualIdentificationCodeGenerated\n / Send(IssueTrafficFine), Complete
</p>
<p>Not all police reports are about speeding violations. For simplicity sake, I&#39;ve kept it to one offense per police report. If there&#39;s no speeding violation, we simply complete the workflow immediately, signaling that it is done. If it does have a speeding violation as an offense, we need to generate a number that uniquely identifies the traffic fine we&#39;re about to issue in the rest of the system. Because the people to whom the car is registered may not have a digital identity - that&#39;s a thing in Belgium - or simply do not want to use their digital identity, we also need to generate a manual identification code, which, together with the police report and traffic fine number, can be used to access the website where you can view, pay and contest your traffic fine. Once all that&#39;s done, we can issue the traffic fine and complete the workflow. Nothing too complicated, in my opinion.</p>
<p>This all largely happens within the <code>Traffic Fine System</code>. There&#39;s a perpetual motion of messages flowing in and out of the workflow as depicted below. You can enlarge the image by clicking it and follow the sequence numbers.</p>
<p>flowchart TB
    IssueTrafficFineForSpeedingViolationWorkflow[Issue\nTraffic Fine\nFor\nSpeeding Violation\nWorkflow]
    InputChannel([Input Channel])
    GenerateTrafficFineSystemNumberTopic([Generate\nTraffic Fine\nSystemNumber\nTopic])
    GenerateTrafficFineManualIdentificationCodeTopic([Generate\nTraffic Fine\nManual Identification Code\nTopic])
    IssueTrafficFineTopic([Issue\nTraffic Fine\nTopic])
    subgraph Traffic Fine System
        direction TB
        InputChannel--&#34;(1)Police Report\nPublished&#34;--&gt;IssueTrafficFineForSpeedingViolationWorkflow
        IssueTrafficFineForSpeedingViolationWorkflow--&#34;(2)Send(Generate\nTraffic Fine\nSystem Number)&#34;--&gt;GenerateTrafficFineSystemNumberTopic
        GenerateTrafficFineSystemNumberTopic--&#34;(3)Generate\nTraffic Fine\nSystem Number&#34;--&gt;TrafficFineSystemNumberGenerator
        TrafficFineSystemNumberGenerator--&#34;(4)Traffic Fine\nSystem Number\nGenerated&#34;--&gt;InputChannel
        InputChannel--&#34;(5)Traffic Fine\nSystem Number\nGenerated&#34;--&gt;IssueTrafficFineForSpeedingViolationWorkflow
        IssueTrafficFineForSpeedingViolationWorkflow--&#34;(6)Send(Generate\nTraffic Fine\nManual Identification Code)&#34;--&gt;GenerateTrafficFineManualIdentificationCodeTopic
        GenerateTrafficFineManualIdentificationCodeTopic--&#34;(7)Generate\nTraffic Fine\nManual Identification Code&#34;--&gt;TrafficFineManualIdentificationCodeGenerator
        TrafficFineManualIdentificationCodeGenerator--&#34;(8)Traffic Fine\nManual Identification Code\nGenerated&#34;--&gt;InputChannel
        InputChannel--&#34;(9)Traffic Fine\nManual Identification Code\nGenerated&#34;--&gt;IssueTrafficFineForSpeedingViolationWorkflow
        IssueTrafficFineForSpeedingViolationWorkflow--&#34;(10)Send(Issue\nTraffic Fine)&#34;--&gt;IssueTrafficFineTopic
        IssueTrafficFineTopic--&#34;(11)Issue\nTraffic Fine&#34;--&gt;TrafficFine
    end
</p>
<p>Let&#39;s see what that could look like in code. I&#39;ve picked <a href="https://fsharp.org/">F#</a> for this purpose, leaning on its terseness, but honestly, this can be expressed in just about any programming language in a very similar way.</p>
<pre><code>module IssueTrafficFineForSpeedingViolationWorkflow =
    let decide message state =
        match (message, state) with
        | PoliceReportPublished m, Initial -&gt;
            match m.Offense with
            | SpeedingViolation _ -&gt; 
                [ Send(
                    GenerateTrafficFineSystemNumber { 
                      PoliceReportId = m.PoliceReportId }) ]
            | _ -&gt; [ Complete ]
        | TrafficFineSystemNumberGenerated m,
            AwaitingSystemNumber s -&gt;
            [ Send(
                GenerateTrafficFineManualIdentificationCode
                  { PoliceReportId = s.PoliceReportId
                    SystemNumber = m.Number }
              ) ]
        | TrafficFineManualIdentificationCodeGenerated m,
            AwaitingManualIdentificationCode s -&gt;
            [ Send(
                IssueTrafficFine
                  { PoliceReportId = s.PoliceReportId
                    SystemNumber = s.SystemNumber
                    ManualIdentificationCode = m.Code }
              )
              Complete ]
        | _, _ -&gt; 
          failwithf &#34;%A not supported by %A&#34; message state
</code></pre>
<p>Even if you&#39;re not familiar with <code>F#</code> and its pattern matching, the translation from the state diagram into its code counterpart should be fairly intuitive.</p>
<ul>
<li>This workflow is initiated by the <code>PoliceReportPublished</code> message. Nothing happened yet so we must be in the <code>Initial</code> state of the workflow. If the offense on the police report is a <code>SpeedingViolation</code>, we go ahead and <strong>decide</strong> to <code>Send</code> a <code>GenerateTrafficFineSystemNumber</code> message. If it&#39;s a <code>ParkingViolation</code>, we <strong>decide</strong> to immediately <code>Complete</code> the workflow.</li>
<li>We then wait for the system number to be generated. Once that happens, the workflow is continued by the <code>TrafficFineSystemNumberGenerated</code> message and it appears we&#39;ve somehow moved onto the <code>AwaitingSystemNumber</code> state. The only <strong>decision</strong> to take, now that we know the system number, is to <code>Send</code> a <code>GenerateTrafficFineManualIdentificationCode</code> message.</li>
<li>No surprise here, we wait for that manual identification code to be generated. Again, once that happens, the workflow is continued by the <code>TrafficFineManualIdentificationCodeGenerated</code> message and we&#39;ve moved onto the <code>AwaitingManualIdentificationCode</code> state.</li>
<li>Our final <strong>decision</strong> is to <code>Send</code> the <code>IssueTrafficFine</code> message and to <code>Complete</code> the workflow. If we encounter a transition our state machine does not understand, we can either ignore it by returning no decisions or fail hard and complain about it, which is what we&#39;ve done here.</li>
</ul>
<p>Why don&#39;t we pause here for a minute. There&#39;s something important to point out. That is, our workflow takes <strong>decisions</strong>. But it doesn&#39;t actually perform the decisions taken. Making sure those decisions get executed is a delegated responsibility. <strong>Its decision logic is side effect free and can be implemented as a pure function.</strong> This property is not to be underestimated. Testing the workflow&#39;s decision logic becomes fairly straightforward. All you need is a message and some state to check whether the actual decisions taken match the ones you expected to be taken. If we generalize the signature of our workflow&#39;s <code>decide</code> function we get something along the lines of this:</p>
<pre><code>type Workflow&lt;&#39;TInput,&#39;TState,&#39;TOutput&gt; = {
    Decide: &#39;TInput -&gt; &#39;TState -&gt; WorkflowCommand&lt;&#39;TOutput&gt; list
}
</code></pre>
<p>It takes an input message and the current state it is in, and produces a list of decisions. For now, with what we&#39;ve seen so far, that <code>WorkflowCommand</code> - what I&#39;ve called <strong>decision</strong> up until now - is fairly simple. We either decide to send a message or to complete the workflow.</p>
<pre><code>type WorkflowCommand&lt;&#39;TOutput&gt; =
    | Send of message: &#39;TOutput
    | Complete
</code></pre>
<p>Not all workflows are created equal. Some may also publish an event, schedule a timeout message to themselves, or reply to whomever sent the input message to the workflow, or any mixture of those. The point is to only include those decisions any of your workflows are going to take. The set of decisions, the sending, publishing, replying, scheduling, completing, etc ... it is finite and that&#39;s a good thing. It means we can start thinking about generalizing it.</p>
<pre><code>type WorkflowCommand&lt;&#39;TOutput&gt; =
    | Reply of &#39;TOutput
    | Send of &#39;TOutput
    | Publish of &#39;TOutput
    | Schedule of after: TimeSpan * message: &#39;TOutput
    | Complete
</code></pre>
<p>When the workflow is about to begin, meaning it&#39;s about to receive its first message and take its first decisions, there&#39;s no previous state we know of. So we have to tell what that initial state is, that is the state it is in when we start out. The fact I called it <code>Initial</code> in the <code>IssueTrafficFineForSpeedingViolationWorkflow</code> above is purely happenstance. I could have called it <code>AwaitingPoliceReportWithPossibleSpeedingViolation</code> instead. For simplicity sake, I&#39;ve encoded it into the workflow itself as <code>InitialState</code>, because, well, it has to be encoded somewhere for workflow surrounding code to be able to find and use it. This way, when calling the <code>decide</code> function for the first time, we know what initial state to pass in.</p>
<pre><code>type Workflow&lt;&#39;TInput,&#39;TState,&#39;TOutput&gt; = {
    InitialState: &#39;TState
    Decide: 
        &#39;TInput 
        -&gt; &#39;TState 
        -&gt; WorkflowCommand&lt;&#39;TOutput&gt; list
}
</code></pre>
<p>Often there&#39;s a desire to encapsulate information next to the actual message we receive as input. This often goes by a name ending with the word <code>Context</code> in a lot of other products. Here I called it <code>WorkflowTrigger</code>. It can be useful at times if the workflow surrounding code treats the head and body of a message as distinct parts, but it&#39;s not strictly necessary. The workflow trigger could have properties which we tend to classify as <code>metadata</code> or <code>headers</code>, e.g. source, message name, message version, causation and correlation identifiers, ... next to the body. The main motivation to use this is when the workflow code itself uses it as part of its decision making process. If not, then it&#39;s just noise.</p>
<pre><code>type Workflow&lt;&#39;TInput,&#39;TState,&#39;TOutput&gt; = {
    InitialState: &#39;TState
    Decide: 
        WorkflowTrigger&lt;&#39;TInput&gt; 
        -&gt; &#39;TState 
        -&gt; WorkflowCommand&lt;&#39;TOutput&gt; list
}
</code></pre>
<p>Another missing piece of the puzzle that probably had you ü•Å ... <em>puzzled</em> is how we actually moved thru the state machine. There&#39;s an additional function that takes care of that.</p>
<pre><code>module IssueTrafficFineForSpeedingViolationWorkflow =
    let evolve state message =
        match (state, message) with
        | Initial, InitiatedBy(PoliceReportPublished m) -&gt;
            match m.Offense with
            | SpeedingViolation v -&gt; 
                AwaitingSystemNumber { 
                  PoliceReportId = m.PoliceReportId }
            | ParkingViolation v -&gt; Final
        | AwaitingSystemNumber s,
            Received(TrafficFineSystemNumberGenerated m) -&gt;
            AwaitingManualIdentificationCode {
              PoliceReportId = s.PoliceReportId
              SystemNumber = m.Number }
        | AwaitingManualIdentificationCode _,
            Received(TrafficFineManualIdentificationCodeGenerated _) -&gt;
            Final
        | _, _ -&gt; 
          failwithf &#34;%A not supported by %A&#34; message state
</code></pre>
<p>Again, it&#39;s a fairly straightforward translation from the state diagram. We start out in the <code>Initial</code> state, the solid sphere on the diagram. What name you want to give this state is totally up to you - whatever makes most sense. Receiving or rather, being initiated by a <code>PoliceReportPublished</code> message, in this state causes it to transition either to the <code>Final</code> state, when no speeding violation, or the <code>AwaitingSystemNumber</code>, when there&#39;s a speeding violation. Not only do we transition to the next state, we also copy any necessary data we need to keep track of onto the next state. This data can come from the message, the previous state or simply by virtue of transitioning. Receiving <code>TrafficFineSystemNumberGenerated</code> moves us from <code>AwaitingSystemNumber</code> to <code>AwaitingManualIdentificationCode</code> and, finally, receiving <code>TrafficFineManualIdentificationCodeGenerated</code> moves us from <code>AwaitingManualIdentificationCode</code> to the <code>Final</code> state. If we encounter a transition our machine does not understand, we can either ignore it by returning the same state or fail hard and complain about it, which is what we&#39;ve done here. Our workflow signature can now cater for the <code>evolve</code> function too.</p>
<pre><code>type Workflow&lt;&#39;TInput,&#39;TState,&#39;TOutput&gt; = {
    InitialState: &#39;TState
    Evolve: &#39;TState -&gt; WorkflowEvent&lt;&#39;TInput, &#39;TOutput&gt; -&gt; &#39;TState
    Decide: &#39;TInput -&gt; &#39;TState -&gt; WorkflowCommand&lt;&#39;TOutput&gt; list
}
</code></pre>
<p>So the <code>evolve</code> function takes a previous state and an <em>event</em>, and produces the next state, which may just well be the same state. But what&#39;s that <code>WorkflowEvent&lt;&#39;TInput, &#39;TOutput&gt;</code> you have there? Well, evolving the state of a workflow should be able to observe both the past received input and past taken decisions. <code>WorkflowEvent&lt;&#39;TInput, &#39;TOutput&gt;</code> is what embodies that. In the above <code>evolve</code> the workflow state was only moved based on workflow input, but that&#39;s just a coincidence.</p>
<pre><code>type WorkflowEvent&lt;&#39;TInput, &#39;TOutput&gt; =
    | Began
    | InitiatedBy of &#39;TInput
    | Received of &#39;TInput
    | Replied of &#39;TOutput
    | Sent of &#39;TOutput
    | Published of &#39;TOutput
    | Scheduled of after: TimeSpan * message: &#39;TOutput
    | Completed
</code></pre>
<p>Using this construct, we can start telling the story of a typical workflow execution. Do note that I&#39;ve put the messages on a diet for legibility reasons.</p>
<pre><code>[
    Began
    InitiatedBy(PoliceReportPublished { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;
        Offense = SpeedingViolation { MaximumSpeed = &#34;50km/h&#34; } })
    Sent(GenerateTrafficFineSystemNumber { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;})

    Received(TrafficFineSystemNumberGenerated { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;
        Number = &#34;PPXRG/23TV8457&#34; })
    Sent(GenerateTrafficFineManualIdentificationCode { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;
        SystemNumber = &#34;PPXRG/23TV8457&#34; })

    Received(TrafficFineManualIdentificationCodeGenerated { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;
        Number = &#34;PPXRG/23TV8457&#34;
        Code = &#34;XMfhyM&#34; })
    Sent(IssueTrafficFine { 
        PoliceReportId = &#34;XG.96.L1.5000267/2023&#34;
        SystemNumber = &#34;PPXRG/23TV8457&#34;
        ManualIdentificationCode = &#34;XMfhyM&#34; })
    Completed
]
</code></pre>
<p>By now it should start to dawn on you how <a href="https://www.eventstore.com/blog/what-is-event-sourcing">event sourcing</a> fits into all of this. Using <code>WorkflowEvent&lt;&#39;TInput, &#39;TOutput&gt;</code> we can build up a stream of events around the workflow: when it began, what message initiated it, which decisions were taken, how more messages we&#39;ve received continued it and more decisions were taken, until finally it completed. Past tense is great for evolving and describing history, but I prefer imperative for decision making, which is why <code>WorkflowCommand&lt;&#39;TOutput&gt;</code> is there. While it&#39;s a great authoring tool, it&#39;s a <strong>transient</strong> concept nonetheless. It&#39;s trivial to translate between the two since it&#39;s mainly a matter of knowing whether we&#39;re beginning the workflow and turning the imperative (a workflow command) into past tense (a workflow event). By piping all messages and their accompanying decisions, i.e. our workflow commands, thru this translation, we get the entire history of a workflow as a sequence of events.</p>
<pre><code>let translate begins message commands =
    [
        if begins then
            yield Began
            yield InitiatedBy message
        else
            yield Received message

        for command in commands do
            yield 
                match command with
                | Reply m -&gt; Replied m
                | Send m -&gt; Sent m
                | Publish m -&gt; Published m
                | Schedule (t, m) -&gt; Scheduled (t, m)
                | Complete m -&gt; Completed m
    ]
</code></pre>
<p>Note that, if you are using <a href="https://www.eventstore.com/">EventStoreDB</a>, you could use the expected stream revision or the absence of a stream, denoted by <code>StreamRevision.None</code>, as the value of <code>begins</code>. You usually obtain this value when you try to read the stream and use the stored events to <code>evolve</code> the workflow.</p>
<p>Above the choice was made not to bother the workflow author with having to explicitly indicate whether or not the workflow began and which message caused it to be initiated. This is a choice and trade off. Making it part of the decision making simply moves it into the authoring experience. That would work too, and just like for <code>Complete</code>, you must not forget to <code>Begin</code> as part of receiving the initial message. Stitching a <code>Received</code> message in the history becomes a tad trickier and human error starts lurking. The minor difference between <code>Received</code> and <code>InitiatedBy</code> is again a design choice. I&#39;ve gone back and forth on these sort of things. It&#39;s good to play with the subtle differences in a design to see where they take you.</p>
<p>Now, with that in place and the rather mundane task of encoding input and output messages as json serialized events, it&#39;s not that hard to get to a working implementation in <a href="https://www.eventstore.com/eventstoredb">EventStoreDB</a>, as shown below.</p>
<p><a href="https://blog.bittacklr.be/the-workflow-pattern/persisted_workflow_stream.png"><img src="https://blog.bittacklr.be/the-workflow-pattern/persisted_workflow_stream.png" alt="" title="Click here to expand image"/></a>
<a href="https://blog.bittacklr.be/the-workflow-pattern/persisted_workflow_stream_message.png" title="Click here to expand image"><img src="https://blog.bittacklr.be/the-workflow-pattern/persisted_workflow_stream_message.png" alt=""/></a></p>
<p>What stream name format to pick for a workflow, how we encode the workflow events, it&#39;s all a matter of choice. There is no real difference with other event sourced entities in this regard. Encoding the workflow event in the event type caters for a nice form of readability, in my opinion. We could have made the intent, that is to send, to publish, to schedule, etc. part of the meta data of an event instead. By all means, bring your own conventions.</p>
<p>One thing to watch out for is that workflow streams may have copies of messages that originate from other streams. Without proper precautions in place your projections and other consumers may start observing the same messages twice. You could teach them to ignore workflow streams, you could make sure the event type does not match, etc ... fair warning, that&#39;s all.</p>
<p>At this point, there may be a few concerns.</p>
<ul>
<li><p>We&#39;re using past tense to indicate that a message has been sent, published, scheduled, etc. but in reality, that sending, publishing, scheduling, etc. has not taken place yet. When I read a <code>decide</code> function, I can reason about the decisions it&#39;s taking using the imperative. Yet as soon as I exit that <code>decide</code> function, it&#39;s a done deal, as far as authoring goes at least. I&#39;m now leaning on other parts of the system to actually do the persisting, sending, publishing, scheduling, replying, etc ... and they should not fail for reasons other than technical ones. If we take the perspective of the workflow itself, past tense makes sense. As far as it is concerned, those decisions have happened. If the decisions don&#39;t get persisted atomically, we&#39;ll retry at a later time or that input message may well end up getting dead-lettered in some way. Now, if the decisions decided do not get carried out, are never carried out, or we suspect the potential for that to happen is there, we should lean on scheduling timeouts for a workflow or make reporting failure back to a workflow explicit. Additionally, we can observe and monitor workflow streams for the one&#39;s that <code>Began</code> but never <code>Completed</code> within a <em>reasonable</em> amount of time. This amount of time may be very different from one workflow to another, from one domain to another. Using telemetry may be another angle by which to observe the behavior of our workflows.</p>
</li>
<li><p>Choosing to persist a workflow&#39;s events rather than its commands is a choice. We could ditch the entire concept of a workflow event and simply persist the workflow commands. We could ditch the entire concept of a workflow command and go straight for workflow events while authoring. Having these sort of choices to make is great, just make sure they don&#39;t paralyze you.</p>
</li>
<li><p>Why do we have a difference between the input and output messages? After all, there may be overlap between them. For example, scheduling an output message to oneself after a time will cause that message to appear as input to the same workflow. We could entertain the idea of unifying the input and output messages into one set of messages that the workflow either receives or emits. It simplifies encoding somewhat, but it obviously makes it less clear which messages serve as input or output.</p>
</li>
<li><p>The words command and event may be used in a way that interferes with what they mean in other areas where you apply event sourcing. Examples? A workflow command to publish an event. A workflow event that indicates a command or query was sent. It&#39;s best to view things from the workflow&#39;s perspective and to not look too closely at the tense of the message a workflow command carries. Doing anything else is going to hurt your brain.</p>
</li>
<li><p>Consequently, the type of message that triggers a workflow is deliberately unconstrained and neither is the type of message used as payload of a decision. Whether a workflow gets triggered by an event, a command, a query, a document or a query response does not materially affect the authoring or its design. There really is no need for any sort of artificial translation or shoehorning. For decisions, it makes sense for the payload to match the semantics of the workflow command, be it sending, publishing, replying, scheduling, ... if only for legibility reasons. There&#39;s something quite liberating about letting go.</p>
</li>
<li><p>There&#39;s no addressing. We&#39;re not specifying where to send or publish to, in the workflow&#39;s <code>decide</code> function itself. This is intentional. The name of the message determines its destination. If that&#39;s not sufficient, I&#39;d entertain the idea of adding logical endpoints as a destination to <code>Send</code> or <code>Publish</code> to, but never physical endpoints. It&#39;d be fairly insidious to make assumptions about the stability of physical endpoints over the course of time, since the whole point is to keep the history of a workflow persisted as a sequence of events. The map between the logical and physical endpoints could live in code or configuration.</p>
</li>
</ul>
<h3>And ... Action!</h3>
<p>With our workflow events now persisted, our stream itself has developed an interesting property. Not only can we use it to rebuild our workflow&#39;s state, by replaying (also known as folding) all workflow events in it using our <code>evolve</code> function, but it effectively acts as an <a href="https://event-driven.io/en/outbox_inbox_patterns_and_delivery_guarantees_explained/">outbox</a> for all the workflow commands that have been written as workflow events. We can use <a href="https://developers.eventstore.com/clients/grpc/persistent-subscriptions.html#persistent-subscriptions">persistent</a> or <a href="https://developers.eventstore.com/clients/grpc/subscriptions.html#catch-up-subscriptions">catch-up</a> subscriptions on top of those streams to have a workflow event processor <em>carry out</em> the workflow commands. Given that the workflow commands are generic, there is a high chance their execution <em>can</em> be generalized. When starting out with this pattern, however, it can be useful to postpone this generalization and get to grips with what carrying out the workflow commands means.</p>
<p>As an example, assuming we&#39;ve set up a topic per message type in Google&#39;s Cloud Platform, our processor could publish each workflow <code>send</code> command message to its corresponding topic, as shown below. The repetition is fairly easy to spot.</p>
<pre><code>module IssueTrafficFineForSpeedingViolationWorkflowProcessor =
    let private options =
        JsonFSharpOptions
            .Default()
            .WithUnionExternalTag()
            .WithUnionUnwrapRecordCases()
            .ToJsonSerializerOptions()

    let private envelop workflow_id message_id m =
        let json = JsonSerializer.Serialize(m, options)
        let envelope =
            PubsubMessage(Data = ByteString.CopyFromUtf8(json))
        envelope.Attributes.Add(&#34;workflow_id&#34;, workflow_id)
        envelope.Attributes.Add(&#34;message_id&#34;, message_id)
        envelope

    let handle clients workflow_id message_id command =
        task {
            match command with
            | Send(GenerateTrafficFineSystemNumber m) -&gt; 
                let envelope = envelop workflow_id message_id m
                do! 
                    clients
                        .SystemNumberTopic
                        .PublishAsync(envelope) 
                    :&gt; Task
            | Send(GenerateTrafficFineManualIdentificationCode m) -&gt; 
                let envelope = envelop workflow_id message_id m
                do! 
                    clients
                        .ManualIdentificationCodeTopic
                        .PublishAsync(envelope) 
                    :&gt; Task
            | Send(IssueTrafficFine m) -&gt; 
                let envelope = envelop workflow_id message_id m
                do! 
                    clients
                        .IssueTrafficFineTopic
                        .PublishAsync(envelope) 
                    :&gt; Task
            | _ -&gt; 
                failwith 
                    &#34;%A command has not been implemented.&#34; 
                    command
        }
</code></pre>
<p>The working <em>assumption</em> is that some <a href="https://developers.eventstore.com/clients/grpc/subscriptions.html">subscription</a> mechanism is going to deliver the relevant workflow commands to the <code>handle</code> function above. This would involve translating some of those workflow events back into the imperative - another design choice, really depends on what you like to read and write. The <code>handle</code> function takes the topics to publish to, called <code>clients</code> here, as a dependency, along with the <code>workflow&#39;s identity</code>, the <code>workflow command&#39;s message identity</code> and the actual <code>workflow command</code>, and routes each message to the corresponding topic. Note that there&#39;s no reason to put all of a workflow&#39;s command processing in one function nor to publish messages on a topic. These are all <em>implementation choices</em> and for illustration purposes only.</p>
<p>It&#39;s important that, whatever you do, the <code>workflow identity</code> flows along. Performing the <code>GenerateTrafficFineSystemNumber</code> command is what causes the <code>TrafficFineSystemNumberGenerated</code> event, same for <code>GenerateTrafficFineManualIdentificationCode</code> causing <code>TrafficFineManualIdentificationCodeGenerated</code>. The event needs to make its way back to our workflow. But which workflow? That&#39;s the purpose of the workflow identity, it acts as a <a href="https://www.enterpriseintegrationpatterns.com/CorrelationIdentifier.html">correlation identifier</a>.</p>
<p>It goes without saying that keeping track of the position you&#39;ve reached in a <a href="https://developers.eventstore.com/clients/grpc/subscriptions.html#catch-up-subscriptions">catch-up subscription</a> in a durable fashion matters. Not the kind of data you can afford to lose, if you catch my drift. There&#39;s always some of that at play, meaning that in the absence of a distributed transaction across the resource that stores the position and the resources that you interact with to perform the workflow command, the workflow command&#39;s message identity is your friend. It <em>can</em> help deal with <a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/IdempotentReceiver.html">idempotency</a>. For <a href="https://developers.eventstore.com/clients/grpc/persistent-subscriptions.html#persistent-subscriptions">persistent subscriptions</a> things are subtly different, in that which workflow commands we&#39;ve already observed is managed for us, but the chance of observing the same workflow command more than once is still present.</p>
<p>If you&#39;re into <a href="https://eventmodeling.org/">Event Modeling</a>, you could use the <a href="https://eventmodeling.org/posts/event-modeling-cheatsheet/">Automation Pattern</a> instead to carry out the workflow commands, using a todo list in the middle. This in turn would allow you to do things like batch executing commands across workflows, e.g. if what you&#39;re calling is costly.</p>
<p>I don&#39;t want to dwell too much on the implementation of an outbox nor on how messages make their way (back) to a workflow. These are solved problems and the implementation is highly contextual.</p>
<h3>Look! No events!</h3>
<p>There&#39;s a variation on this pattern that foregoes the use of event sourcing or an event store for that matter(*). If we draw inspiration from <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, it&#39;s not that far of a stretch to design the workflow as:</p>
<pre><code>type Workflow&lt;&#39;TInput,&#39;TState,&#39;TOutput&gt; = {
    InitialState: &#39;TState
    Decide: 
        &#39;TInput 
        -&gt; &#39;TState 
        -&gt; (&#39;TState * WorkflowCommand&lt;&#39;TOutput&gt; list)
}
</code></pre>
<p>Here, the decide function takes an input message and a state, and produces a tuple of the new state and the decisions taken. No events in sight. Applied to our workflow it may look like this:</p>
<pre><code>module IssueTrafficFineForSpeedingViolationWorkflow =
    let decide message state =
        match (message, state) with
        | PoliceReportPublished m, Initial -&gt;
            match m.Offense with
            | SpeedingViolation _ -&gt;
                (AwaitingSystemNumber { 
                    PoliceReportId = m.PoliceReportId },
                 [ Send(
                     GenerateTrafficFineSystemNumber { 
                       PoliceReportId = m.PoliceReportId }) ])
            | _ -&gt; (Final, [ Complete ])
        | TrafficFineSystemNumberGenerated m,
            AwaitingSystemNumber s -&gt;
            (AwaitingManualIdentificationCode
                { PoliceReportId = s.PoliceReportId
                  SystemNumber = m.Number },
             [ Send(
                 GenerateTrafficFineManualIdentificationCode
                   { PoliceReportId = s.PoliceReportId
                     SystemNumber = m.Number }
             ) ])
        | TrafficFineManualIdentificationCodeGenerated m,
            AwaitingManualIdentificationCode s -&gt;
            (Final,
             [ Send(
                 IssueTrafficFine
                   { PoliceReportId = s.PoliceReportId
                     SystemNumber = s.SystemNumber
                     ManualIdentificationCode = m.Code }
               )
               Complete ])
        | _, _ -&gt; 
          failwithf &#34;%A not supported by %A&#34; message state
</code></pre>
<p>Effectively, we&#39;ve merged the behavior of the <code>decide</code> and <code>evolve</code> function. Imagine we&#39;re using a relational database to persist the workflow state and commands. We can do that in one transaction and use the <a href="https://microservices.io/patterns/data/transactional-outbox.html">outbox</a> pattern for the workflow commands. There&#39;s not a lot of difference to it, is there?</p>
<p>(*) What if I told you, you could use the event sourced version above instead and still be able to persist the workflow state and commands. All you&#39;re sacrificing in the end is remembering the past events. You would not know how you got to the workflow&#39;s current state, you&#39;d only know what the workflow&#39;s current state is. When decisions come out of the workflow&#39;s <code>decide</code> function, you can translate them into events, feed them to its <code>evolve</code> function, and out would come the next state to be persisted alongside the commands. In effect, from the workflow authoring perspective, it does not materially matter how or what you persist. Only whether you use the <code>decide</code> and <code>evolve</code> functions separately or combine them into one function.</p>

<p>The main thing I want you to take away from this post is the ease of authoring a workflow, how state machines play a supporting role, what an event sourced workflow could look like, and a glimpse at the mechanics. I&#39;ve not gone into what transactions look like, how scheduling messages to oneself would work, how we&#39;d tame the dragon called versioning, nor how monitoring and telemetry fit into all of this. I&#39;ve been sitting on this for some time now and felt that it was better to publish as is and tackle those bits in a subsequent post.</p>
<h3>Credits</h3>
<ul>
<li><p>Some astute reader will notice a striking resemblance with the <a href="https://thinkbeforecoding.com/post/2021/12/17/functional-event-sourcing-decider">work</a> that <a href="https://twitter.com/thinkb4coding">J√©r√©mie Chassaing</a> has been putting forth. I&#39;ve adopted most of the terminology where I could. His work is at a higher level of abstraction and has broader applicability than what I&#39;m proposing here. I&#39;m probably straying here and there, as I didn&#39;t come to the workflow pattern thru the lense of the decider pattern.</p>
</li>
<li><p>The workflow command names used here were heavily inspired by what <a href="https://particular.net/nservicebus">NServiceBus</a> offers via its message handler context. In a way, you could say that I&#39;ve turned the methods into messages, channeling my inner Alan Kay.</p>
</li>
<li><p>Special thanks to Antonios Klimis and Oskar Dudycz for taking the time to review.</p>
</li>
</ul>
</div></div>
  </body>
</html>
