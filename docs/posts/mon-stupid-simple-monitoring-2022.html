<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomscii.sig7.se/2022/07/uMon-stupid-simple-monitoring">Original</a>
    <h1>μMon: Stupid simple monitoring (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">
  
  <div itemprop="articleBody">
    <p>Let me introduce you to <a href="https://tomscii.sig7.se/umon">μMon</a>, my
personal, minimalist, opinionated take on host monitoring based on
<a href="https://oss.oetiker.ch/rrdtool/">RRDtool</a>, SNMP, some lightweight
shell scripting, and a small FastCGI server written using a modest
subset of modern C++.</p>

<p>Migrating my monitoring setup to <em>μMon</em> also serves as a case study
in <em>complexity reduction,</em> which is the broader theme of this post.</p>

<!--more-->

<p>Here is an example of how <em>μMon</em> might look like:</p>

<p><a href="https://tomscii.sig7.se/images/umon/aurora_main.png"><img src="https://tomscii.sig7.se/images/umon/aurora_main_thumb.jpg" alt=""/></a></p>

<p>The above view covers the better part of my Pinebook Pro upgrading
itself to OpenBSD 7.1, compiling the whole system from source. The
vertical gaps are due to the machine being off.<sup><a href="#f1">1</a></sup></p>

<p>Here is a second example with a different view on another host:</p>

<p><a href="https://tomscii.sig7.se/images/umon/hq_ups.png"><img src="https://tomscii.sig7.se/images/umon/hq_ups_thumb.jpg" alt=""/></a></p>

<p>This view captures a short planned test of my UPS (visible in the
middle).  Data is sourced directly from the output of the <code>upsc</code>
command, as opposed to
<a href="https://github.com/tomscii/upsc-snmp-agent">SNMP</a>.
(Yeah, I know. Time for a new UPS battery.)</p>



<p>I created <em>μMon</em> due to my love of minimalism and how short
existing solutions fall from that ideal. Specifically, I migrated my
stack of Prometheus + Grafana that I have been running at home for the
last couple years to <em>μMon</em>. By doing so, I managed to finally get
rid of:</p>

<ul>
  <li>
    <p>A full-blown time-series database (with gigabytes
of rolling on-disk data).</p>
  </li>
  <li>
    <p>Several Go binaries dozens of megabytes each, also consuming runtime
resources. (One of them got habitually stuck in an endless loop, so
I put in a crontab entry to restart it daily. I do not appreciate
black boxes like that.)</p>
  </li>
  <li>
    <p>Lengthy configuration files and lengthy argument lists to said
binaries.</p>
  </li>
  <li>
    <p>Systems continuously talking to each other over the network (even
when nobody is looking at any dashboard), periodically pulling
metrics from nodes into Prometheus, which in turn runs all sorts of
consolidation routines on that data. A constant source of noise in
otherwise idling systems.</p>
  </li>
  <li>
    <p>A mind-boggingly complex web front-end (Grafana) with its own
database, tons of JavaScript running in my browser, and role-based
access control over multiple users.</p>
  </li>
  <li>
    <p>A bespoke query language to pull metrics into dashboards, and lots
of specialized knowledge in how to build useful dashboards.  It is
all meant to be intuitive, but man, is it complicated!  (People
write whole books on how to operate and use this!)</p>
  </li>
  <li>
    <p>Tons of eye candy I did not really mind, but did not really
appreciate either.</p>
  </li>
</ul>

<p>No doubt this complex (and to me, opaque) stack would inevitably get
obsolete, necessitating migrations prone to failure, or demand my
attention in other, even less predictable ways. In short: keeping up
with the state of the art requires an ongoing investment.</p>

<p>I have a general inclination towards minimalism, and a preference for
long-term durable solutions that do not need continuous attention and
care. Having spent many years as a student of complexity (commonly
referred to as a career in IT), I have come to hate the kind of
surprises that complex (clever, if you will) systems are so prone to.
Nowadays, when I provision something, I ask: would this run for 10
years if I forgot about it? How long before it would break, or need to
be redeployed with a new (incompatible) major version? Or, if nothing
else, go hopelessly out of fashion (hello docker!)?</p>

<p>So I substituted all the above with an extremely lightweight stack
based on very well understood, several decades old concepts and
programs. I now have a system that is comprehensible in its scope and
size, and trivially understandable in its simplicity. I did this in
the hope that it will serve me for decades to come, without any undue
need of caring for it. In fact, my ambition was to solve the problem
of server monitoring <em>once and for all</em>, at least for all systems in
my care. This fits neatly into my overall strategy of establishing
fully autonomous, sustainable personal computing. Less bells and
whistles, less overhead and less <em>churn</em> equals less to worry about,
while keeping all the features actually needed.</p>

<p>By the way, I am not meaning to pick on Prometheus and Grafana in
particular. If you have used Cacti, Collectd, Graphite, InfluxDB,
Nagios, OpenNMS, Zabbix, or anything similar, then you will probably
agree that setting up and using any of these tools is anything but
simple. In fact, any monitoring stack will be similar to what I
described above in terms of its complexity.<sup><a href="#f2">2</a></sup>
Granted, if you get paid as a <del>sysadmin</del> <del><em>DevOps</em></del> <strong>Site
Reliability Engineer</strong>, you probably need to master some locally
useful combination of these comprehensive tools. If that is not your
job, and you want something <a href="https://en.wikipedia.org/wiki/KISS_principle">simple and
stupid</a>, you might find
<em>μMon</em> interesting.</p>

<p>Keeping it simple and stupid is such a priority that as an all-time
reminder, I decided to include the word <em>simplicity</em> right in the
<em>μMon</em> logo I “designed”:</p>

<p><img src="https://tomscii.sig7.se/images/umon/umon_logo_black.png" alt=""/></p>

<p>In total, I estimate that I spent the equivalent of <em>at most</em> one week
of full-time engineering work (scattered over about a month of
evenings and weekends) on creating <em>μMon</em>. Including the logo!</p>

<p>Granted, <em>μMon</em> does not cater to every need, only my very own —
and those are definitely modest. I do not run anything that could be
considered modern or fashionable; I only run a bunch of Unix boxes (a
mixture of Linux and BSD). No Docker (or podman), no ProxMox, no
Kubernetes. Anywhere I get to decide, I use stable, proven, old
technology. In addition, my monitoring needs are fairly modest: I only
want basic metrics. Most importantly, I do not use any fancy alerting
functionality.<sup><a href="#f3">3</a></sup> That could be added on top of what
exists in <em>μMon</em>, but it stands for a sizable chunk of complexity
in the “real” monitoring systems mentioned above; getting it right is
very non-trivial, and not just from a technical
perspective.<sup><a href="#f4">4</a></sup> Since the small-scale servers I run
work pretty much unattended year in and year out, this is fine — I
only want to be able to look at metrics to spot trends and interesting
times to investigate by looking at event logs, etc.</p>

<p>That said, <em>μMon</em> gives me everything I have ever gotten from my
old setup (mostly the “interesting subset” of the output of
<code>node_exporter</code>, plus the metrics of a custom <code>upsc</code> feeder I hacked
together). And there are distinct advantages to <em>μMon</em>:</p>

<ul>
  <li>
    <p>A well understood, constant-space storage model thanks to RRDtool. I
know exactly how much disk space the aggregated data takes, and more
importantly, I know it will never grow beyond that extent.</p>
  </li>
  <li>
    <p>A well understood model of data consolidation and retention, built
on RRDtool’s consolidation functions. I can look back at anywhere
between the last one hour and the last two years, with the right
temporal resolution.</p>
  </li>
  <li>
    <p>Independent nodes. Each host runs <em>μMon</em> on its own, both to
collect metrics and to serve the webpage. There is no single point
of collection, storage, or access to the system, nor a single point
of failure. (Arguably, this can be a disadvantage depending on your
perspective, but it matches my preference.)</p>
  </li>
  <li>
    <p>Very lightweight data collection. Each host collects its own metrics
in locally stored round-robin archives; data collection does not
incur any network activity. Configuration of metrics collection
equals listing the probes you want (but you can use all the power of
shell scripting, if you wish).</p>
  </li>
  <li>
    <p>Very simple server setup. I use <code>(x)inetd</code> to serve the FastCGI of
<em>μMon</em> via a TCP socket to whatever web server I have on the host
(or a different host). The <em>μMon</em> collector script is run by cron.
Everything that belongs to <em>μMon</em> resides and runs under an
unprivileged user.</p>
  </li>
  <li>
    <p>Extremely minimal dependencies. To install <em>μMon</em>, all I need is a
Unix system with a POSIX shell (<code>/bin/sh</code>), a modern C++ compiler,
and the ability to install <code>rrdtool</code>. No PHP (or other web toolkit),
no Python, no NodeJs. No database (time-series or relational). A
local webserver (with FastCGI support) is optional; a remote
webserver can act as the proxy as well.</p>
  </li>
  <li>
    <p>Graphs (plots of certain groups of metrics) and views (collections
of graphs) can be created or modified any time, by editing simple,
small shell scripts. They can even be edited in place for immediate
effect (nothing to restart). Of course, knowledge of RRDtool and the
POSIX shell is mandatory, but then again, <em>μMon</em> is for hardcore
Unix sysadmins with modest needs.  Anything you need to know above
what is already etched into your brain you will find in the <code>rrd*</code>
man pages. But you can get started without changing anything.</p>
  </li>
</ul>



<p>You could argue that I am exhibiting <a href="https://en.wikipedia.org/wiki/Not_invented_here">NIH
syndrome</a> by
inventing my own (inferior) solution to a problem space well
understood and explored by many, many others. You would perhaps not be
very wrong.</p>

<p>To my defense, let me state that I am not forcing (not even
encouraging) anyone to adopt and use <em>μMon</em>. Rather, I am showing
it here as a case study in the noble pursuit of complexity reduction,
something that I feel is getting more and more important.  Especially
when focusing on one’s own personal computing affairs.</p>



<p>Here is a table to recap the transition from all-in to minimal
complexity. Note that this is <em>not</em> a moral stance against higher
complexity, which you might need for fully legitimate reasons (such as
requiring complex alerting over metrics aggregated from different
hosts) that <em>μMon</em> does not support.</p>

<table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Prometheus + Grafana</th>
      <th>μMon</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>look and feel</td>
      <td>shiny, modern</td>
      <td>old-school</td>
    </tr>
    <tr>
      <td>development</td>
      <td>probably several man-decades</td>
      <td>one man-week (tops)</td>
    </tr>
    <tr>
      <td>system model</td>
      <td>central servers, distributed feeders</td>
      <td>one independent node per host</td>
    </tr>
    <tr>
      <td>technologies</td>
      <td>Go, HTTP, JavaScript, TSDB, …</td>
      <td>/bin/sh, RRDtool, SNMP</td>
    </tr>
    <tr>
      <td>daemons</td>
      <td>collectors, prometheus, grafana</td>
      <td>umon_fcgi invoked by (x)inetd</td>
    </tr>
    <tr>
      <td>database</td>
      <td>bespoke TSDB with WAL, etc.</td>
      <td>RRDtool</td>
    </tr>
    <tr>
      <td>db size</td>
      <td>dynamic; gigabytes</td>
      <td>constant; a couple megabytes</td>
    </tr>
    <tr>
      <td>db activity</td>
      <td>has its own inner life, runs GC, etc.</td>
      <td>static (in-place RRA overwrites)</td>
    </tr>
    <tr>
      <td>frontend</td>
      <td>complete web stack</td>
      <td>FastCGI server invoking hooks</td>
    </tr>
    <tr>
      <td>configuration</td>
      <td>point-and-click, stored in opaque db</td>
      <td>small shell scripts</td>
    </tr>
    <tr>
      <td>plugins</td>
      <td>bespoke (large) binaries</td>
      <td>SNMP and simple shell scripts</td>
    </tr>
    <tr>
      <td>collection</td>
      <td>over the network</td>
      <td>local (works offline) via cron</td>
    </tr>
    <tr>
      <td>alerting</td>
      <td>complex conditions, several channels</td>
      <td>no support at all</td>
    </tr>
    <tr>
      <td>maintenance</td>
      <td>ongoing upgrades &amp; migrations</td>
      <td>minimal, if any</td>
    </tr>
  </tbody>
</table>





<p>I am not saying that “big solutions” are necessarily bad or wrong. But
I do want to argue that there is a place for small, perhaps even
bespoke, site-only solutions that can serve the common 80% of needs
just as well, at several orders of magnitude less complexity. All the
while retaining nimbleness to be extended to cover the remaining 20%,
when prompted by actual need. There is something to be said for a
(figurative) napkin’s worth of code hacked together in a man-week that
is capable of bringing the same ultimate value as a full-fledged stack
that was no doubt developed in what is probably several man-decades
(if not centuries) of engineering work.  Sometimes a simple, dumb
solution can be fairly robust and complete. I believe <em>μMon</em> is a
good illustration of this general idea.</p>

<p>At the same time, I feel this is ultimately less of a surprise than it
might first seem. Let us not forget that running Unix-descended or
Unix-like systems means we are standing on the shoulders of giants: we
have time-proven architectural tenets, open standards and systems
programming APIs, plus free development tools at our disposal. On top
of that, the venerable RRDtool embeds some pretty sophisticated,
time-honed data sampling and graph rendering logic.  Granted, it takes
an educated sysadmin to make use of it all (being a competent systems
programmer as well is a big plus), but that is pretty much the
original intended audience of these operating systems.</p>

<p><a href="https://github.com/tomscii/umon">μMon</a> is released to the public
under the BSD license (the same zero-clause flavour that OpenBSD
uses).  If you feel inclined to try it yourself, please recall that it
is not my goal to supply you (or the world) with a toolkit that works
out of the box and suits everyone. I am specifically not advocating
<em>μMon</em> as a direct substitute to any of the well-known monitoring
stacks.<sup><a href="#f5">5</a></sup> In the spirit of the BSD license, it is
simply my gift to the world. What you do with it (whether or not you
find it useful) is up to you.  At any rate, you are expected to read
your way through some simple shell scripts and adapt them to your
needs. That said, if you have educated questions or constructive
feedback (positive or negative) about it, feel free to <a href="https://tomscii.sig7.se/id/">contact
me</a>.</p>

<hr/>

<p><b id="f1">1</b> The machine froze Friday night, which I did not
notice for over an hour. Apparently building the OpenBSD base system
with <code>-j 6</code> was too much to ask from the hardware, so I resumed with
my usual <code>-j 4</code>.</p>

<p><b id="f2">2</b> What looks like the closest existing solution to
<em>μMon</em> is a stack of programs called
<a href="https://wpd.home.xs4all.nl/symon/index.html">symon</a>, consisting of
(at least) <code>symon</code>, <code>symux</code> and <code>syweb</code>. This is also largely
RRDtool-based. But… the user needs to configure listeners with port
numbers just to get some data collection going; needs to install
RRDtool into a webserver chroot; needs a webserver with PHP enabled,
etc.</p>

<p><b id="f3">3</b> I do have my personal collection of cron-driven
scripts that check essentials (such as expired SSL certificates) and
email me if there is anything that needs my attention. I just prefer
to keep these things separate from monitoring data rates and disk
usage percentages.</p>

<p><b id="f4">4</b> I could rant about the incessant floods of useless
email/pager alerts coming from everywhere, seemingly so inseparable
from Big Tech Company Culture, complete with the inevitable result of
people ignoring/filtering them out, for a net result of precisely zero
business value achieved at a tremendous cost. But that is another post
patiently waiting to be written.</p>

<p><b id="f5">5</b> Let’s be real: <em>μMon</em> absolutely <em>does not</em>
support many of the important use cases of the more complicated
stacks. Do I care about any of it? Absolutely not. The point of this
exercise was not to create a rewrite of Prometheus + Grafana (they are
fine as is), but rather create something that is at least three orders
of magnitude smaller, while providing all the functionality I need.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
