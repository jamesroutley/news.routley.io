<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/08/03/behind--hello-world/">Original</a>
    <h1>Behind &#34;Hello World&#34; on Linux</h1>
    
    

<p>Today I was thinking about &ndash; what happens when you run a simple &ldquo;Hello World&rdquo;
Python program on Linux, like this one?</p>

<pre><code>print(&quot;hello world&quot;)
</code></pre>

<p>Here&rsquo;s what it looks like at the command line:</p>

<pre><code>$ python3 hello.py
hello world
</code></pre>

<p>But behind the scenes, there&rsquo;s a lot more going on. I&rsquo;ll
describe some of what happens, and (much much more importantly!) explain some tools you can use to
see what&rsquo;s going on behind the scenes yourself. We&rsquo;ll use <code>readelf</code>, <code>strace</code>,
<code>ldd</code>, <code>debugfs</code>, <code>/proc</code>, <code>ltrace</code>, <code>dd</code>, and <code>stat</code>. I won&rsquo;t talk about the Python-specific parts at all &ndash; just what happens when you run any dynamically linked executable.</p>

<p>Here&rsquo;s a table of contents:</p>

<ol>
<li><a href="#1-the-shell-parses-the-string-python3-hello-py-into-a-command-to-run-and-a-list-of-arguments-python3-and-hello-py">parse &ldquo;python3 hello.py&rdquo;</a></li>
<li><a href="#2-the-shell-figures-out-the-full-path-to-python3">figure out the full path to python3</a></li>
<li><a href="#3-stat-under-the-hood">stat, under the hood</a></li>
<li><a href="#4-time-to-fork">time to fork</a></li>
<li><a href="#5-the-shell-calls-execve">the shell calls execve</a></li>
<li><a href="#6-get-the-binary-s-contents">get the binary&rsquo;s contents</a></li>
<li><a href="#7-find-the-interpreter">find the interpreter</a></li>
<li><a href="#8-dynamic-linking">dynamic linking</a></li>
<li><a href="#9-go-to-start">go to _start</a></li>
<li><a href="#10-write-a-string">write a string</a></li>
</ol>

<h3 id="before-execve">before <code>execve</code></h3>

<p>Before we even start the Python interpreter, there are a lot of things that
have to happen. What executable are we even running? Where is it?</p>

<h4 id="1-the-shell-parses-the-string-python3-hello-py-into-a-command-to-run-and-a-list-of-arguments-python3-and-hello-py">1: The shell parses the string <code>python3 hello.py</code> into a command to run and a list of arguments: <code>python3</code>, and <code>['hello.py']</code></h4>

<p>A bunch of things like glob expansion could happen here. For example if you run <code>python3 *.py</code>, the shell will expand that into <code>python3 hello.py</code></p>

<h4 id="2-the-shell-figures-out-the-full-path-to-python3">2: The shell figures out the full path to <code>python3</code></h4>

<p>Now we know we need to run <code>python3</code>. But what&rsquo;s the full path to that binary? The way this works is that there&rsquo;s a special environment variable named <code>PATH</code>.</p>

<p><strong>See for yourself</strong>: Run <code>echo $PATH</code> in your shell. For me it looks like this.</p>

<pre><code>$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</code></pre>

<p>When you run a command, the shell will search every directory in that list (in order) to try to find a match.</p>

<p>In <code>fish</code> (my shell), you can see the <a href="https://github.com/fish-shell/fish-shell/blob/900a0487443f10caa6539634ca8c49fb6e3ce5ba/src/path.cpp#L31-L45">path resolution logic here</a>.
It uses the <code>stat</code> system call to check if files exist.</p>

<p><strong>See for yourself</strong>: Run <code>strace -e stat bash</code>, and then run a command like <code>python3</code>. You should see output like this:</p>

<pre><code>stat(&quot;/usr/local/sbin/python3&quot;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&quot;/usr/local/bin/python3&quot;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&quot;/usr/sbin/python3&quot;, 0x7ffcdd871f40) = -1 ENOENT (No such file or directory)
stat(&quot;/usr/bin/python3&quot;, {st_mode=S_IFREG|0755, st_size=5479736, ...}) = 0
</code></pre>

<p>You can see that it finds the binary at <code>/usr/bin/python3</code> and stops: it
doesn&rsquo;t continue searching <code>/sbin</code> or <code>/bin</code>.</p>

<h4 id="2-1-a-note-on-execvp">2.1: A note on <code>execvp</code></h4>

<p>If you want to run the same PATH searching logic as the shell does without
reimplementing it yourself, you can use the libc function <code>execvp</code> (or one of
the other <code>exec*</code> functions with  <code>p</code> in the name).</p>

<h4 id="3-stat-under-the-hood">3: <code>stat</code>, under the hood</h4>

<p>Now you might be wondering &ndash; Julia, what is <code>stat</code> doing? Well, when your OS opens a file, it&rsquo;s split into 2 steps.</p>

<ol>
<li>It maps the <strong>filename</strong> to an <strong>inode</strong>, which contains metadata about the file</li>
<li>It uses the <strong>inode</strong> to get the file&rsquo;s contents</li>
</ol>

<p>The <code>stat</code> system call just returns the contents of the file&rsquo;s inodes &ndash; it
doesn&rsquo;t read the contents at all. The advantage of this is that it&rsquo;s a lot
faster. Let&rsquo;s go on a short adventure into inodes. (<a href="https://www.cyberdemon.org/2023/07/19/bunch-of-bits.html">this great post &ldquo;A disk is a bunch of bits&rdquo; by Dmitry Mazin</a> has more details)</p>

<pre><code>$ stat /usr/bin/python3
  File: /usr/bin/python3 -&gt; python3.9
  Size: 9         	Blocks: 0          IO Block: 4096   symbolic link
Device: fe01h/65025d	Inode: 6206        Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-08-03 14:17:28.890364214 +0000
Modify: 2021-04-05 12:00:48.000000000 +0000
Change: 2021-06-22 04:22:50.936969560 +0000
 Birth: 2021-06-22 04:22:50.924969237 +0000
</code></pre>

<p><strong>See for yourself</strong>: Let&rsquo;s go see where exactly that inode is on our hard drive.</p>

<p>First, we have to find our hard drive&rsquo;s device name</p>

<pre><code>$ df
...
tmpfs             100016      604     99412   1% /run
/dev/vda1       25630792 14488736  10062712  60% /
...
</code></pre>

<p>Looks like it&rsquo;s <code>/dev/vda1</code>. Next, let&rsquo;s find out where the inode for <code>/usr/bin/python3</code> is on our hard drive:</p>

<pre><code>$ sudo debugfs /dev/vda1
debugfs 1.46.2 (28-Feb-2021)
debugfs:  imap /usr/bin/python3
Inode 6206 is part of block group 0
	located at block 658, offset 0x0d00
</code></pre>

<p>I have no idea how <code>debugfs</code> is figuring out the location of the inode for that filename, but we&rsquo;re going to leave that alone.</p>

<p>Now, we need to calculate how many bytes into our hard drive &ldquo;block 658, offset 0x0d00&rdquo; is on the big array of bytes that is your hard drive. Each block is 4096 bytes, so we need to go <code>4096 * 658 + 0x0d00</code> bytes. A calculator tells me that&rsquo;s <code>2698496</code></p>

<pre><code>$ sudo dd if=/dev/vda1 bs=1 skip=2698496 count=256 2&gt;/dev/null | hexdump -C
00000000  ff a1 00 00 09 00 00 00  f8 b6 cb 64 9a 65 d1 60  |...........d.e.`|
00000010  f0 fb 6a 60 00 00 00 00  00 00 01 00 00 00 00 00  |..j`............|
00000020  00 00 00 00 01 00 00 00  70 79 74 68 6f 6e 33 2e  |........python3.|
00000030  39 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |9...............|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000060  00 00 00 00 12 4a 95 8c  00 00 00 00 00 00 00 00  |.....J..........|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 2d cb 00 00  |............-...|
00000080  20 00 bd e7 60 15 64 df  00 00 00 00 d8 84 47 d4  | ...`.d.......G.|
00000090  9a 65 d1 60 54 a4 87 dc  00 00 00 00 00 00 00 00  |.e.`T...........|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre>

<p>Neat! There&rsquo;s our inode! You can see it says <code>python3</code> in it, which is a really
good sign. We&rsquo;re not going to go through all of this, but the <a href="https://github.com/torvalds/linux/blob/fdf0eaf11452d72945af31804e2a1048ee1b574c/fs/ext4/ext4.h#L769">ext4 inode struct from the Linux kernel</a>
says that the first 16 bits are the &ldquo;mode&rdquo;, or permissions. So let&rsquo;s work that out how <code>ffa1</code> corresponds to file permissions.</p>

<ul>
<li>The bytes <code>ffa1</code> correspond to the number <code>0xa1ff</code>, or 41471 (because x86 is little endian)</li>
<li>41471 in octal is <code>0120777</code></li>
<li>This is a bit weird &ndash; that file&rsquo;s permissions could definitely be <code>777</code>, but what
are the first 3 digits? I&rsquo;m not used to seeing those! You can find out what
the <code>012</code> means in <a href="https://man7.org/linux/man-pages/man7/inode.7.html">man inode</a> (scroll down to &ldquo;The file type and mode&rdquo;).
There&rsquo;s a little table that says <code>012</code> means &ldquo;symbolic link&rdquo;.</li>
</ul>

<p>Let&rsquo;s list the file and see if it is in fact a symbolic link with permissions <code>777</code>:</p>

<pre><code>$ ls -l /usr/bin/python3
lrwxrwxrwx 1 root root 9 Apr  5  2021 /usr/bin/python3 -&gt; python3.9
</code></pre>

<p>It is! Hooray, we decoded it correctly.</p>

<h4 id="4-time-to-fork">4: Time to fork</h4>

<p>We&rsquo;re still not ready to start <code>python3</code>. First, the shell needs to create a
new child process to run. The way new processes start on Unix is a little weird
&ndash; first the process clones itself, and then runs <code>execve</code>, which replaces the
cloned process with a new process.</p>

<p>*<strong>See for yourself:</strong> Run <code>strace -e clone bash</code>, then run <code>python3</code>. You should see something like this:</p>

<pre><code>clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f03788f1a10) = 3708100
</code></pre>

<p><code>3708100</code> is the PID of the new process, which is a child of the shell process.</p>

<p>Some more tools to look at what&rsquo;s going on with processes:</p>

<ul>
<li><code>pstree</code> will show you a tree of all the processes on your system</li>
<li><code>cat /proc/PID/stat</code> shows you some information about the process. The contents of that file are documented in <code>man proc</code>. For example the 4th field is the parent PID.</li>
</ul>

<h4 id="4-1-what-the-new-process-inherits">4.1: What the new process inherits.</h4>

<p>The new process (which will become <code>python3</code>) has inherited a bunch of from the shell. For example, it&rsquo;s inherited:</p>

<ol>
<li><strong>environment variables</strong>: you can look at them with <code>cat /proc/PID/environ | tr '\0' '\n'</code></li>
<li><strong>file descriptors</strong> for stdout and stderr: look at them with <code>ls -l /proc/PID/fd</code></li>
<li>a <strong>working directory</strong> (whatever the current directory is)</li>
<li><strong>namespaces and cgroups</strong> (if it&rsquo;s in a container)</li>
<li>the <strong>user</strong> and <strong>group</strong> that&rsquo;s running it</li>
<li>probably more things I&rsquo;m not thinking of right now</li>
</ol>

<h4 id="5-the-shell-calls-execve">5: The shell calls <code>execve</code></h4>

<p>Now we&rsquo;re ready to start the Python interpreter!</p>

<p><strong>See for yourself</strong>: Run <code>strace -e -f execve bash</code>, then run <code>python3</code>. The <code>-f</code> is important because we want to follow any forked child subprocesses. You should see something like this:</p>

<pre><code>[pid 3708381] execve(&quot;/usr/bin/python3&quot;, [&quot;python3&quot;], 0x560397748300 /* 21 vars */) = 0
</code></pre>

<p>The first argument is the binary, and the second argument is the list of
command line arguments. The command line arguments get placed in a special
location in the program&rsquo;s memory so that it can access them when it runs.</p>

<p>Now, what&rsquo;s going on inside <code>execve</code>?</p>

<h4 id="6-get-the-binary-s-contents">6: get the binary&rsquo;s contents</h4>

<p>The first thing that has to happen is that we need to open the <code>python3</code>
binary file and read its contents. So far we&rsquo;ve only used the <code>stat</code> system call to access its metadata,
but now we need its contents.</p>

<p>Let&rsquo;s look at the output of <code>stat</code> again:</p>

<pre><code>$ stat /usr/bin/python3
  File: /usr/bin/python3 -&gt; python3.9
  Size: 9         	Blocks: 0          IO Block: 4096   symbolic link
Device: fe01h/65025d	Inode: 6206        Links: 1
...
</code></pre>

<p>This takes up 0 blocks of space on the disk. This is because the contents of
the symbolic link (<code>python3.9</code>) are actually in the inode itself: you can see
them here (from the binary contents of the inode above, it&rsquo;s split across 2
lines in the hexdump output):</p>

<pre><code>00000020  00 00 00 00 01 00 00 00  70 79 74 68 6f 6e 33 2e  |........python3.|
00000030  39 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |9...............|
</code></pre>

<p>So we&rsquo;ll need to open <code>/usr/bin/python3.9</code> instead. All of this is happening
inside the kernel so you won&rsquo;t see it another system call for that.</p>

<p>Every file is made up of a bunch of <strong>blocks</strong> on the hard drive. I think each of these
blocks on my system is 4096 bytes, so the minimum size of a file is 4096 bytes
&ndash; even if the file is only 5 bytes, it still takes up 4KB on disk.</p>

<p><strong>See for yourself</strong>: We can find the block numbers using <code>debugfs</code> like this: (again, I got these instructions from <a href="https://www.cyberdemon.org/2023/07/19/bunch-of-bits.html">dmitry mazin&rsquo;s &ldquo;A disk is a bunch of bits&rdquo; post</a>)</p>

<pre><code>$ debugfs /dev/vda1
debugfs:  blocks /usr/bin/python3.9
145408 145409 145410 145411 145412 145413 145414 145415 145416 145417 145418 145419 145420 145421 145422 145423 145424 145425 145426 145427 145428 145429 145430 145431 145432 145433 145434 145435 145436 145437
</code></pre>

<p>Now we can use <code>dd</code> to read the first block of the file. We&rsquo;ll set the block size to 4096 bytes, skip <code>145408</code> blocks, and read 1 block.</p>

<pre><code>$ dd if=/dev/vda1 bs=4096 skip=145408 count=1 2&gt;/dev/null | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..&gt;.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
</code></pre>

<p>You can see that we get the exact same output as if we read the file with <code>cat</code>, like this:</p>

<pre><code>$ cat /usr/bin/python3.9 | hexdump -C | head
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  c0 a5 5e 00 00 00 00 00  |..&gt;.......^.....|
00000020  40 00 00 00 00 00 00 00  b8 95 53 00 00 00 00 00  |@.........S.....|
00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1e 00 1d 00  |....@.8...@.....|
00000040  06 00 00 00 04 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000050  40 00 40 00 00 00 00 00  40 00 40 00 00 00 00 00  |@.@.....@.@.....|
00000060  68 02 00 00 00 00 00 00  68 02 00 00 00 00 00 00  |h.......h.......|
00000070  08 00 00 00 00 00 00 00  03 00 00 00 04 00 00 00  |................|
00000080  a8 02 00 00 00 00 00 00  a8 02 40 00 00 00 00 00  |..........@.....|
00000090  a8 02 40 00 00 00 00 00  1c 00 00 00 00 00 00 00  |..@.............|
</code></pre>

<h4 id="an-aside-on-magic-numbers">an aside on magic numbers</h4>

<p>This file starts with <code>ELF</code>, which is a &ldquo;magic number&rdquo;, or a byte sequence that
tells us that this is an ELF file. ELF is the binary file format on Linux.</p>

<p>Different file formats have different magic numbers, for example the magic
number for gzip is <code>1f8b</code>. The magic number at the beginning is how <code>file blah.gz</code> knows that it&rsquo;s a gzip file.</p>

<p>I think <code>file</code> has a variety of heuristics for figuring out the file type of a
file, not just magic numbers, but the magic number is an important one.</p>

<h4 id="7-find-the-interpreter">7: find the interpreter</h4>

<p>Let&rsquo;s parse the ELF file to see what&rsquo;s in there.</p>

<p><strong>See for yourself:</strong> Run <code>readelf -a /usr/bin/python3.9</code>. Here&rsquo;s what I get (though I&rsquo;ve redacted a LOT of stuff):</p>

<pre><code>$ readelf -a /usr/bin/python3.9
ELF Header:
    Class:                             ELF64
    Machine:                           Advanced Micro Devices X86-64
...
-&gt;  Entry point address:               0x5ea5c0
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
  INTERP         0x00000000000002a8 0x00000000004002a8 0x00000000004002a8
                 0x000000000000001c 0x000000000000001c  R      0x1
-&gt;      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
        ...
-&gt;        1238: 00000000005ea5c0    43 FUNC    GLOBAL DEFAULT   13 _start
</code></pre>

<p>Here&rsquo;s what I understand of what&rsquo;s going on here:</p>

<ol>
<li>it&rsquo;s telling the kernel to run <code>/lib64/ld-linux-x86-64.so.2</code> to start this program. This is called the <strong>dynamic linker</strong> and we&rsquo;ll talk about it next</li>
<li>it&rsquo;s specifying an entry point (at <code>0x5ea5c0</code>, which is where this program&rsquo;s code starts)</li>
</ol>

<p>Now let&rsquo;s talk about the dynamic linker.</p>

<h4 id="8-dynamic-linking">8: dynamic linking</h4>

<p>Okay! We&rsquo;ve read the bytes from disk and we&rsquo;ve started this &ldquo;interpreter&rdquo; thing. What next? Well, if you run <code>strace -o out.strace python3</code>, you&rsquo;ll see a bunch of stuff like this right after the <code>execve</code> system call:</p>

<pre><code>execve(&quot;/usr/bin/python3&quot;, [&quot;python3&quot;], 0x560af13472f0 /* 21 vars */) = 0
brk(NULL)                       = 0xfcc000
access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=32091, ...}) = 0
mmap(NULL, 32091, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f718a1e3000
close(3)                        = 0
openat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libpthread.so.0&quot;, O_RDONLY|O_CLOEXEC) = 3
read(3, &quot;\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0 l\0\0\0\0\0\0&quot;..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=149520, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f718a1e1000
...
close(3)                        = 0
openat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libdl.so.2&quot;, O_RDONLY|O_CLOEXEC) = 3
</code></pre>

<p>This all looks a bit intimidating at first, but the part I want you to pay
attention to is <code>openat(AT_FDCWD, &quot;/lib/x86_64-linux-gnu/libpthread.so.0&quot;</code>.
This is opening a C threading library called <code>pthread</code> that the Python
interpreter needs to run.</p>

<p><strong>See for yourself:</strong> If you want to know which libraries a binary needs to load at runtime, you can use <code>ldd</code>. Here&rsquo;s what that looks like for me:</p>

<pre><code>$ ldd /usr/bin/python3.9
	linux-vdso.so.1 (0x00007ffc2aad7000)
	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f2fd6554000)
	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f2fd654e000)
	libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2fd6549000)
	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2fd6405000)
	libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f2fd63d6000)
	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2fd63b9000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2fd61e3000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f2fd6580000)
</code></pre>

<p>You can see that the first library listed is <code>/lib/x86_64-linux-gnu/libpthread.so.0</code>, which is why it was loaded first.</p>

<h4 id="on-ld-library-path">on LD_LIBRARY_PATH</h4>

<p>I&rsquo;m honestly still a little confused about dynamic linking. Some things I know:</p>

<ul>
<li>Dynamic linking happens in userspace and the dynamic linker on my system is at <code>/lib64/ld-linux-x86-64.so.2</code>. If you&rsquo;re missing the dynamic linker, you can end up with weird bugs like this <a href="https://jvns.ca/blog/2021/11/17/debugging-a-weird--file-not-found--error/">weird &ldquo;file not found&rdquo; error</a></li>
<li>The dynamic linker uses the <code>LD_LIBRARY_PATH</code> environment variable to find libraries</li>
<li>The dynamic linker will also use the <code>LD_PRELOAD</code> environment to override any dynamically linked function you want (you can use this for <a href="https://jvns.ca/blog/2014/11/27/ld-preload-is-super-fun-and-easy/">fun hacks</a>, or to replace your default memory allocator with an alternative one like jemalloc)</li>
<li>there are some <code>mprotect</code>s in the strace output which are marking the library code as read-only, for security reasons</li>
<li>on Mac, it&rsquo;s <code>DYLD_LIBRARY_PATH</code> instead of <code>LD_LIBRARY_PATH</code></li>
</ul>

<p>You might be wondering &ndash; if dynamic linking happens in userspace, why don&rsquo;t we
see a bunch of <code>stat</code> system calls where it&rsquo;s searching through
<code>LD_LIBRARY_PATH</code> for the libraries, the way we did when bash was searching the
<code>PATH</code>?</p>

<p>That&rsquo;s because <code>ld</code> has a cache in <code>/etc/ld.so.cache</code>, and all of those
libraries have already been found in the past. You can see it opening the cache
in the strace output &ndash; <code>openat(AT_FDCWD, &quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</code>.</p>

<p>There are still a bunch of system calls after dynamic linking in the <a href="https://gist.github.com/jvns/4254251bea219568df9f43a2efd8d0f5">full strace output</a> that I
still don&rsquo;t really understand (what&rsquo;s <code>prlimit64</code> doing? where does the locale
stuff come in? what&rsquo;s <code>gconv-modules.cache</code>? what&rsquo;s <code>rt_sigaction</code> doing?
what&rsquo;s <code>arch_prctl</code>? what&rsquo;s <code>set_tid_address</code> and <code>set_robust_list</code>?). But this feels like a good start.</p>

<h4 id="aside-ldd-is-actually-a-simple-shell-script">aside: ldd is actually a simple shell script!</h4>

<p>Someone on mastodon <a href="https://octodon.social/@lkundrak/110832640058459399">pointed out</a> that <code>ldd</code> is actually a shell script
that just sets the <code>LD_TRACE_LOADED_OBJECTS=1</code> environment variable and
starts the program. So you can do exactly the same thing like this:</p>

<pre><code>$ LD_TRACE_LOADED_OBJECTS=1 python3
	linux-vdso.so.1 (0x00007ffe13b0a000)
	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f01a5a47000)
	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f01a5a41000)
	libutil.so.1 =&gt; /lib/x86_64-linux-gnu/libutil.so.1 (0x00007f2fd6549000)
	libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f2fd6405000)
	libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007f2fd63d6000)
	libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f2fd63b9000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2fd61e3000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f2fd6580000)
</code></pre>

<p>Apparently <code>ld</code> is also a binary you can just run, so <code>/lib64/ld-linux-x86-64.so.2 --list /usr/bin/python3.9</code> also does the the same thing.</p>

<h4 id="on-init-and-fini">on <code>init</code> and <code>fini</code></h4>

<p>Let&rsquo;s talk about this line in the <code>strace</code> output:</p>

<pre><code>set_tid_address(0x7f58880dca10)         = 3709103
</code></pre>

<p>This seems to have something to do with threading, and I think this might be
happening because the <code>pthread</code> library (and every other dynamically loaded)
gets to run initialization code when it&rsquo;s loaded. The code that runs when the
library is loaded is in the <code>init</code> section (or maybe also the <code>.ctors</code> section).</p>

<p><strong>See for yourself:</strong> Let&rsquo;s take a look at that using readelf:</p>

<pre><code>$ readelf -a /lib/x86_64-linux-gnu/libpthread.so.0
...
  [10] .rela.plt         RELA             00000000000051f0  000051f0
       00000000000007f8  0000000000000018  AI       4    26     8
  [11] .init             PROGBITS         0000000000006000  00006000
       000000000000000e  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         0000000000006010  00006010
       0000000000000560  0000000000000010  AX       0     0     16
...
</code></pre>

<p>This library doesn&rsquo;t have a <code>.ctors</code> section, just an <code>.init</code>. But what&rsquo;s in
that <code>.init</code> section? We can use <code>objdump</code> to disassemble the code:</p>

<pre><code>$ objdump -d /lib/x86_64-linux-gnu/libpthread.so.0
Disassembly of section .init:

0000000000006000 &lt;_init&gt;:
    6000:       48 83 ec 08             sub    $0x8,%rsp
    6004:       e8 57 08 00 00          callq  6860 &lt;__pthread_initialize_minimal&gt;
    6009:       48 83 c4 08             add    $0x8,%rsp
    600d:       c3
</code></pre>

<p>So it&rsquo;s calling <code>__pthread_initialize_minimal</code>.  I found the <a href="https://github.com/bminor/glibc/blob/a78e5979a92c7985eadad7246740f3874271303f/nptl/nptl-init.c#L100">code for that function in glibc</a>,
though I had to find an older version of glibc because it looks like in more
recent versions <a href="https://developers.redhat.com/articles/2021/12/17/why-glibc-234-removed-libpthread">libpthread is no longer a separate library</a>.</p>

<p>I&rsquo;m not sure whether this <code>set_tid_address</code> system call actually comes from
<code>__pthread_initialize_minimal</code>, but at least we&rsquo;ve learned that libraries can
run code on startup through the <code>.init</code> section.</p>

<p>Here&rsquo;s a note from <code>man elf</code> on the <code>.init</code> section:</p>

<pre><code>$ man elf
 .init  This section holds executable instructions that contribute to the process initialization code.  When a program starts to run
              the system arranges to execute the code in this section before calling the main program entry point.
</code></pre>

<p>There&rsquo;s also a <code>.fini</code> section in the ELF file that runs at the end, and
<code>.ctors</code> / <code>.dtors</code> (constructors and destructors) are other sections that
could exist.</p>

<p>Okay, that&rsquo;s enough about dynamic linking.</p>

<h4 id="9-go-to-start">9: go to <code>_start</code></h4>

<p>After dynamic linking is done, we go to <code>_start</code> in the Python interpreter.
Then it does all the normal Python interpreter things you&rsquo;d expect.</p>

<p>I&rsquo;m not going to talk about this because here I&rsquo;m interested in general
facts about how binaries are run on Linux, not the Python interpreter
specifically.</p>

<h4 id="10-write-a-string">10: write a string</h4>

<p>We still need to print out &ldquo;hello world&rdquo; though. Under the hood, the Python <code>print</code> function calls some function from libc. But which one? Let&rsquo;s find out!</p>

<p><strong>See for yourself</strong>: Run <code>ltrace -o out python3 hello.py</code>.</p>

<pre><code>$ ltrace -o out python3 hello.py
$ grep hello out
write(1, &quot;hello world\n&quot;, 12) = 12
</code></pre>

<p>So it looks like it&rsquo;s calling <code>write</code></p>

<p>I honestly am always a little suspicious of ltrace &ndash; unlike strace (which I
would trust with my life), I&rsquo;m never totally sure that ltrace is actually
reporting library calls accurately. But in this case it seems to be working. And
if we look at the <a href="https://github.com/python/cpython/blob/400835ea1626c8c6dcd967c7eabe0dad4a923182/Python/fileutils.c#L1955">cpython source code</a>, it does seem to be calling <code>write()</code> in some places. So I&rsquo;m willing to believe that.</p>

<h4 id="what-s-libc">what&rsquo;s libc?</h4>

<p>We just said that Python calls the <code>write</code> function from libc. What&rsquo;s libc?
It&rsquo;s the C standard library, and it&rsquo;s responsible for a lot of basic things
like:</p>

<ul>
<li>allocating memory with <code>malloc</code></li>
<li>file I/O (opening/closing/</li>
<li>executing programs (with <code>execvp</code>, like we mentioned before)</li>
<li>looking up DNS records with <code>getaddrinfo</code></li>
<li>managing threads with <code>pthread</code></li>
</ul>

<p>Programs don&rsquo;t <em>have</em> to use libc (on Linux, Go famously doesn&rsquo;t use it and
calls Linux system calls directly instead), but most other programming
languages I use (node, Python, Ruby, Rust) all use libc. I&rsquo;m not sure about Java.</p>

<p>You can find out if you&rsquo;re using libc by running <code>ldd</code> on your binary: if you
see something like <code>libc.so.6</code>, that&rsquo;s libc.</p>

<h4 id="why-does-libc-matter">why does libc matter?</h4>

<p>You might be wondering &ndash; why does it matter that Python calls the libc <code>write</code>
and then libc calls the <code>write</code> system call? Why am I making a point of saying
that <code>libc</code> is in the middle?</p>

<p>I think in this case it doesn&rsquo;t really matter (AFAIK the <code>write</code> libc function
maps pretty directly to the <code>write</code> system call)</p>

<p>But there are different libc implementations, and sometimes they behave
differently. The two main ones are glibc (GNU libc) and musl libc.</p>

<p>For example, until recently <a href="https://www.openwall.com/lists/musl/2023/05/02/1">musl&rsquo;s <code>getaddrinfo</code> didn&rsquo;t support TCP DNS</a>, <a href="https://christoph.luppri.ch/fixing-dns-resolution-for-ruby-on-alpine-linux">here&rsquo;s a blog post talking about a bug that that caused</a>.</p>

<h4 id="a-little-detour-into-stdout-and-terminals">a little detour into stdout and terminals</h4>

<p>In this program, stdout (the <code>1</code> file descriptor) is a terminal. And you can do
funny things with terminals! Here&rsquo;s one:</p>

<ol>
<li>In a terminal, run <code>ls -l /proc/self/fd/1</code>. I get <code>/dev/pts/2</code></li>
<li>In another terminal window, write <code>echo hello &gt; /dev/pts/2</code></li>
<li>Go back to the original terminal window. You should see <code>hello</code> printed there!</li>
</ol>

<h4 id="that-s-all-for-now">that&rsquo;s all for now!</h4>

<p>Hopefully you have a better idea of how <code>hello world</code> gets printed! I&rsquo;m going to stop
adding more details for now because this is already pretty long, but obviously there&rsquo;s
more to say and I might add more if folks chip in with extra details. I&rsquo;d
especially love suggestions for other tools you could use to inspect parts of
the process that I haven&rsquo;t explained here.</p>

<h3 id="i-d-love-to-see-a-mac-version-of-this">I&rsquo;d love to see a Mac version of this</h3>

<p>One of my frustrations with Mac OS is that I don&rsquo;t know how to introspect my
system on this level &ndash; when I print <code>hello world</code>, I can&rsquo;t figure out how to
spy on what&rsquo;s going on behind the scenes the way I can on Linux. I&rsquo;d love to
see a really in depth explainer.</p>

<p>Some Mac equivalents I know about:</p>

<ul>
<li><code>ldd</code> -&gt; <code>otool -L</code></li>
<li><code>readelf</code> -&gt; <code>otool</code></li>
<li>supposedly you can use <code>dtruss</code> or <code>dtrace</code> on mac instead of strace but I&rsquo;ve never been brave enough to turn off system integrity protection to get it to work</li>
<li><code>strace</code> -&gt; <code>sc_usage</code> seems to be able to collect stats about syscall usage, and <code>fs_usage</code> about file usage</li>
</ul>

<h3 id="more-reading">more reading</h3>

<p>Some more links:</p>

<ul>
<li><a href="https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a></li>
<li><a href="https://people.freebsd.org/~brooks/talks/asiabsdcon2017-helloworld/helloworld.pdf">an exploration of &ldquo;hello world&rdquo; on FreeBSD</a></li>
<li>From LWN: <a href="https://lwn.net/Articles/630727/">how programs get run</a> (<a href="https://lwn.net/Articles/631631/">and part two</a>) have a bunch more details on the internals of <code>execve</code></li>
<li><a href="https://cpu.land/how-to-run-a-program">how to run a program</a></li>
</ul>

  </body>
</html>
