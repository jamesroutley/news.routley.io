<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sh4dy.com/2024/08/03/beetracer/">Original</a>
    <h1>Writing a system call tracer using eBPF</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <h2 id="Pre-Requisites"><a href="#Pre-Requisites" title="Pre-Requisites"></a>Pre-Requisites</h2><p>System calls, eBPF, C, basics of low-level programming.</p>
<h2 id="Introduction"><a href="#Introduction" title="Introduction"></a>Introduction</h2><p>eBPF (Extended Berkeley Packet Filter) is a technology that allows users to run custom programs within the kernel. BPF / or cBPF (classic BPF), the predecessor of eBPF provided a simple and efficient way to filter packets based on predefined rules. eBPF programs offer enhanced safety, portability, and maintainability as compared to kernel modules. There are several high-level methods available for working with eBPF programs, such as <a target="_blank" rel="noopener" href="https://github.com/cilium/ebpf">Cilium’s go library</a>, <a target="_blank" rel="noopener" href="https://github.com/bpftrace/bpftrace">bpftrace</a>, <a target="_blank" rel="noopener" href="https://github.com/libbpf/libbpf">libbpf</a>, etc.</p>
<ul>
<li><code>Note</code>: This post requires the reader to have a basic understanding of <code>eBPF</code>. If you’re not familiar with it, <a target="_blank" rel="noopener" href="https://ebpf.io/what-is-ebpf/">this post</a> by <code>ebpf.io</code> is a great read.</li>
</ul>
<h2 id="Objectives"><a href="#Objectives" title="Objectives"></a>Objectives</h2><p>You must already be familiar with the famous tool <code>strace</code>. We’ll be developing something similar to that using eBPF. For example,</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>./beetrace /bin/ls</span><br/></pre></td></tr></tbody></table></figure>

<h2 id="Concepts"><a href="#Concepts" title="Concepts"></a>Concepts</h2><p>Before we start writing our tool, we need to familiarize ourselves with some key concepts.</p>
<ol>
<li><p><code>Tracepoints</code>: They are instrumentation points placed in various parts of the Linux kernel code. They provide a way to hook into specific events or code paths within the kernel without modifying the kernel source code. The events available of tracing can be found at <code>/sys/kernel/debug/tracing/events</code>.</p>
</li>
<li><p>The <code>SEC</code> macro: It creates a new section with the name as the name of the tracepoint within the target ELF. For example, <code>SEC(tracepoint/raw_syscalls/sys_enter)</code> creates a new section with this name. The sections can be viewed using readelf.</p>
</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>readelf -s --wide somefile.o</span><br/></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><code>Maps</code>: They are shared data structures that can be accessed from both eBPF programs and applications running in the userspace.</li>
</ol>
<h2 id="Writing-the-eBPF-programs"><a href="#Writing-the-eBPF-programs" title="Writing the eBPF programs"></a>Writing the eBPF programs</h2><p>We won’t be writing a comprehensive tool for tracing all the system calls due to the vast number of system calls present in the Linux kernel. Instead, we’ll focus on tracing a few common system calls. To achieve this, we’ll write two types of programs: eBPF programs and a loader (which loads the BPF objects into the kernel and attaches them).</p>
<p>Let’s start by creating a few data structures to set things up.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>The loader will read the path of the ELF file to be traced, which will be provided by the user as a command line argument. Then, the loader will spawn a child process and use <code>execve</code> to run the program specified in the command line argument.</p>
<p>The parent process will handle all the necessary setup for loading and attaching the eBPF programs. It also performs the crucial task of sending the child process’s ID to the eBPF program via the BPF hashmap.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>To trace system calls, we need to write eBPF programs that are triggered by the <code>tracepoint/raw_syscalls/sys_enter</code> and <code>tracepoint/raw_syscalls/sys_exit</code> tracepoints. These tracepoints provide access to the system call number and arguments. For a given system call, the <code>tracepoint/raw_syscalls/sys_enter</code> tracepoint is always triggered before the <code>tracepoint/raw_syscalls/sys_exit</code> tracepoint. We can use the former to retrieve the system call arguments and the latter to obtain the return value. Additionally, we will use eBPF maps to share information between the user-space program and our eBPF programs. Specifically, we will use two types of eBPF maps: hashmaps and ring buffers.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>Having defined the maps, we’re ready to write the programs. Let’s start by writing the program for the tracepoint <code>tracepoint/raw_syscalls/sys_enter</code>.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>Similarly, we can write the program for reading the return value and sending it to userland.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>
<p>Let’s now finalize the functionality for the parent process in the loader program. Before doing that, we need to understand how some key functions work.</p>
<ol>
<li><code>bpf_object__open</code>: Creates a bpf_object by opening the BPF ELF object file pointed to by the passed path and loading it into memory.</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>struct</span> bpf_object *<span>bpf_object__open</span><span>(<span>const</span> <span>char</span> *path)</span>;</span><br/></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><code>bpf_object__load</code>: Loads BPF object into kernel.</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>int</span> <span>bpf_object__load</span><span>(<span>struct</span> bpf_object *obj)</span>;</span><br/></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><code>bpf_object__find_program_by_name</code>: Returns a pointer to a valid BPF program.</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>struct</span> bpf_program *<span>bpf_object__find_program_by_name</span><span>(<span>const</span> <span>struct</span> bpf_object *obj,<span>const</span> <span>char</span> *name)</span>;</span><br/></pre></td></tr></tbody></table></figure>

<ol start="4">
<li><p><code>bpf_program__attach</code>: Function for attaching a BPF program based on auto-detection of program type, attach type, and extra paremeters, where applicable.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>struct</span> bpf_link *<span>bpf_program__attach</span><span>(<span>const</span> <span>struct</span> bpf_program *prog)</span>;</span><br/></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>bpf_map__update_elem</code>: Allows to insert or update value in BPF map that corresponds to provided key.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>int</span> <span>bpf_map__update_elem</span><span>(<span>const</span> <span>struct</span> bpf_map *<span>map</span>,<span>const</span> <span>void</span> *key, <span>size_t</span> key_sz, <span>const</span> <span>void</span> *value, <span>size_t</span> value_sz, __u64 flags)</span>;</span><br/></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>bpf_object__find_map_fd_by_name</code>: Given a BPF map name, it returns a file descriptor to it.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>int</span> <span>bpf_object__find_map_fd_by_name</span><span>(<span>const</span> <span>struct</span> bpf_object *obj, <span>const</span> <span>char</span> *name)</span>;</span><br/></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>ring_buffer__new</code>: Returns a pointer to the ring buffer.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>struct</span> ring_buffer *<span>ring_buffer__new</span><span>(<span>int</span> map_fd, ring_buffer_sample_fn sample_cb, <span>void</span> *ctx, <span>const</span> <span>struct</span> ring_buffer_opts *opts)</span>;</span><br/></pre></td></tr></tbody></table></figure>
<p>The second argument must be a function which can be used for handling the data received from the ring buffer.</p>
</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>bool</span> initialized = <span>false</span>;</span></pre></td></tr></tbody></table></figure>
<p>It prints the name and arguments of the system calls.</p>
<ol start="8">
<li><code>ring_buffer__consume</code>: It processes the available events in the ring buffer.</li>
</ol>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>LIBBPF_API <span>int</span> <span>ring_buffer__consume</span><span>(<span>struct</span> ring_buffer *rb)</span>;</span><br/></pre></td></tr></tbody></table></figure>

<p>We now have everything needed to write the loader.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>And, here are the eBPF programs. The C code will be compiled into a single object file.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span></span></pre></td></tr></tbody></table></figure>

<p>Before compiling, we can create a test program which will be traced by our tool.</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>#<span>include</span><span>&lt;stdio.h&gt;</span></span></span></pre></td></tr></tbody></table></figure>

<p>The following Makefile can be used to compile all the stuff. </p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>compile:</span></span></pre></td></tr></tbody></table></figure>
<p>Now let’s execute the loader with root privileges.</p>
<figure><table><tbody><tr><td><pre><span>1</span><br/></pre></td><td><pre><span>sudo ./beetrace ./test</span><br/></pre></td></tr></tbody></table></figure>

<p><img src="https://sh4dy.com/images/ebpf/img2.png"/></p>
<p>The entire code can be found in <a target="_blank" rel="noopener" href="https://github.com/0xSh4dy/bee_tracer">this</a> GitHub repository.</p>
<p>References:</p>
<p><a target="_blank" rel="noopener" href="https://ebpf.io/">https://ebpf.io/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/libbpf/libbpf">https://github.com/libbpf/libbpf</a></p>

  </div></div>
  </body>
</html>
