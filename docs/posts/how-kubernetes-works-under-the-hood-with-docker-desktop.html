<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.docker.com/blog/how-kubernetes-works-under-the-hood-with-docker-desktop/">Original</a>
    <h1>How Kubernetes works under the hood with Docker Desktop</h1>
    
    <div id="readability-page-1" class="page"><div>
			  
<p>Docker Desktop makes developing applications for Kubernetes easy. It provides a smooth Kubernetes setup experience by hiding the complexity of the installation and wiring with the host. Developers can focus entirely on their work rather than dealing with the Kubernetes setup details. </p>



<p>This blog post covers development use cases and what happens under the hood for each one of them. We analyze how Kubernetes is set up to facilitate the deployment of applications, whether they are built locally or not, and the ease of access to deployed applications.</p>



<h3 id="1-kubernetes-setup">1. Kubernetes setup</h3>



<p>Kubernetes can be enabled from the <a href="https://docs.docker.com/desktop/kubernetes/">Kubernetes settings panel</a> as shown below.</p>



<figure><img data-attachment-id="29380" data-permalink="https://www.docker.com/blog/how-kubernetes-works-under-the-hood-with-docker-desktop/screen-shot-2022-03-03-at-4-26-40-pm/" data-orig-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM.png" data-orig-size="1860,944" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screen-Shot-2022-03-03-at-4.26.40-PM" data-image-description="" data-image-caption="" data-medium-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-591x300.png" data-large-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-1110x563.png" width="1110" height="563" src="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-1110x563.png" alt="" srcset="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-1110x563.png 1110w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-591x300.png 591w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM-1536x780.png 1536w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.26.40-PM.png 1860w" sizes="(max-width: 1110px) 100vw, 1110px"/></figure>



<p>Checking the <em>Enable Kubernetes</em> box and then pressing <em>Apply &amp; Restart</em> triggers the installation of a single-node Kubernetes cluster. This is all a developer needs to do.</p>



<p>What exactly is happening under the hood? </p>



<p>Internally, the following actions are triggered in the Docker Desktop Backend and VM:</p>



<ul><li>Generation of certificates and cluster configuration</li><li>Download and installation of Kubernetes internal components</li><li>Cluster bootup</li><li>Installation of additional controllers for networking and storage</li></ul>



<p>The diagram below shows the interactions between the internal components of Docker Desktop for the cluster setup.</p>



<figure><img data-attachment-id="29381" data-permalink="https://www.docker.com/blog/how-kubernetes-works-under-the-hood-with-docker-desktop/screen-shot-2022-03-03-at-4-27-33-pm/" data-orig-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM.png" data-orig-size="1544,1742" data-comments-opened="0" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screen-Shot-2022-03-03-at-4.27.33-PM" data-image-description="" data-image-caption="" data-medium-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-266x300.png" data-large-file="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-908x1024.png" loading="lazy" width="908" height="1024" src="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-908x1024.png" alt="" srcset="https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-908x1024.png 908w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-266x300.png 266w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM-1361x1536.png 1361w, https://www.docker.com/blog/wp-content/uploads/2022/03/Screen-Shot-2022-03-03-at-4.27.33-PM.png 1544w" sizes="(max-width: 908px) 100vw, 908px"/></figure>



<h3 id="generating-cluster-certs-keys-and-config-files"><strong><em>Generating cluster certs, keys and config files</em></strong></h3>



<p>Kubernetes requires certificates and keys for authenticated connections between its internal components, and with the outside. Docker Desktop takes care of generating these server and client <a href="https://kubernetes.io/docs/setup/best-practices/certificates/">certificates </a>for the main internal services: kubelet (node manager), service account management, frontproxy, api server, and etcd components.</p>



<p>Docker Desktop installs Kubernetes using <em>kubeadm</em>, therefore it needs to create the kubeadm runtime and cluster-wide configuration. This includes configuration for the cluster’s network topology, certificates, control plane endpoint etc.  It uses Docker Desktop-specific naming and is not customizable by the user. The current-context, user and cluster names are always set to <em>docker-desktop </em>while the global endpoint of the cluster is using the DNS name <em>https://kubernetes</em><a href="https://kubernetes.docker.internal:6443"><em>.</em></a><em>docker</em><a href="https://kubernetes.docker.internal:6443"><em>.</em></a><em>internal:6443</em>. Port 6443 is the default port the Kubernetes control plane is bound to. Docker Desktop forwards this port on the host which facilitates the communication with the control plane as it would be installed directly on the host.</p>



<h3 id="download-and-installation-of-kubernetes-components"><strong><em>Download and installation of Kubernetes components</em></strong> </h3>



<p>Inside the Docker Desktop VM, a management process named <em>Lifecycle service </em>takes care of deploying and starting services such as Docker daemon and notifying their state change.</p>



<p>Once the Kubernetes certificates and configuration have been generated, a request is made to the Lifecycle service to install and start Kubernetes. The request contains the required certificates (Kubernetes PKI) for the setup.</p>



<p>The lifecycle service then starts pulling all the images of the Kubernetes internal components from Docker Hub. These images contain binaries such as kubelet, kubeadm, kubectl, crictl etc which are extracted and placed in `/usr/bin`.</p>



<h3 id="cluster-bootup"><strong><em>Cluster bootup</em></strong></h3>



<p>Once these binaries are in place and the configuration files have been written to the right paths, the Lifecycle service runs<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow"> `kubeadm init`</a> to initialize the cluster and then start the kubelet process. As this is a single-node cluster setup, only one kubelet instance is being run.</p>



<p>The Lifecycle service then waits for the following system pods to be running in order to notify Docker Desktop host service that Kubernetes is started: coredns, kube-controller-manager and the kube-apiserver. </p>



<h3 id="install-additional-controllers"><strong><em>Install additional controllers</em></strong></h3>



<p>Once Kubernetes internal services have started, Docker Desktop triggers the installation of additional controllers such as <strong>storage-provisioner</strong> and <strong>vpnkit-controller</strong>. Their roles concern persisting application state between reboots/upgrades and how to access applications once deployed.</p>



<p>Once these controllers are up and running, the Kubernetes cluster is fully operational and the Docker Dashboard is notified of its state.</p>



<p>We can now run kubectl commands and deploy applications.</p>



<pre><code>$ kubectl get svc
NAME       TYPE       CLUSTER-IP   EXTERNAL-IP     PORT(S)    	AGE
kubernetes ClusterIP  10.96.0.1    &lt;none&gt;    	   443/TCP    	1m</code></pre>



<p>Checking system pods at this state should return the following:</p>



<figure><p><code>$ kubectl get pods -n kube-system</code></p></figure>



<h3 id="2-deploying-and-accessing-applications">2. Deploying and accessing applications</h3>



<p>Let’s take as an example a Kubernetes yaml for the deployment of <em>docker/getting-started</em>, the Docker Desktop tutorial. This is a generic Kubernetes yaml deployable anywhere, it does not contain any Docker Desktop-specific configuration.</p>



<pre><code>---
apiVersion: v1
kind: Service
metadata:
  name: tutorial
spec:
  ports:
	- name: 80-tcp
  	port: 80
  	protocol: TCP
  	targetPort: 80
  selector:
	com.docker.project: tutorial
  type: LoadBalancer
status:
  loadBalancer: {}

---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
	com.docker.project: tutorial
  name: tutorial
spec:
  replicas: 1
  selector:
	matchLabels:
  	com.docker.project: tutorial
  strategy:
	type: Recreate
  template:
	metadata:
  	labels:
    	com.docker.project: tutorial
	spec:
  	containers:
    	- image: docker/getting-started
        name: tutorial
        ports:
        - containerPort: 80
          protocol: TCP
        resources: {}
  	restartPolicy: Always
status: {}</code></pre>



<p>On the host of Docker Desktop, open a terminal and run:</p>



<pre><code>$ kubectl apply -f tutorial.yaml
service/tutorial created
deployment.apps/tutorial created</code></pre>



<p>Check services:</p>



<pre><code>$ kubectl get svc
NAME       TYPE   	CLUSTER-IP     EXTERNAL-IP   PORT(S)       AGE
kubernetes ClusterIP  	10.96.0.1      &lt;none&gt;        443/TCP       118m
tutorial   LoadBalancer 10.98.217.243  localhost     80:31575/TCP  12m</code></pre>



<p>Services of type LoadBalancer are exposed outside the Kubernetes cluster. Opening a browser and navigating to <em>localhost:80</em> displays the Docker tutorial.</p>



<p>What needs to be noticed here is that service access is trivial as if running directly on the host. Developers do not need to concern themselves with any additional configurations. </p>



<p>This is due to Docker Desktop taking care of exposing service ports on the host to make them directly accessible on it. This is done via the additional controller installed previously.</p>



<p><strong>Vpnkit-controller</strong> is a port forwarding service which opens ports on the host and forwards</p>



<p>connections transparently to the pods inside the VM. It is being used for forwarding connections</p>



<p>to LoadBalancer type services deployed in Kubernetes.</p>



<h2 id="3-speed-up-the-develop-test-inner-loop">3. Speed up the develop-test inner loop</h2>



<p>We have seen how to deploy and access an application in the cluster. However, the development cycle consists of developers modifying the code of an application and testing it continuously. </p>



<p>Let’s take as an example an application we are developing locally. </p>



<pre><code>$ cat main.go
package main

import (
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;net/http&#34;
)
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Println(r.URL.RawQuery)
	fmt.Fprintf(w, `
          ##         .
    ## ## ##        ==
 ## ## ## ## ##    ===
/&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;\___/ ===
{                       /  ===-
\______ O           __/
 \    \         __/
  \____\_______/
	
Hello from Docker!

`)
}
func main() {
	http.HandleFunc(&#34;/&#34;, handler)
	log.Fatal(http.ListenAndServe(&#34;:80&#34;, nil))
}</code></pre>



<p>The Dockerfile to build and package the application as a Docker image:</p>



<pre><code>$ cat Dockerfile 
FROM golang:1.16 AS build

WORKDIR /compose/hello-docker
COPY main.go main.go
RUN CGO_ENABLED=0 go build -o hello main.go

FROM scratch
COPY --from=build /compose/hello-docker /usr/local/bin/hello
CMD [&#34;/usr/local/bin/hello&#34;]</code></pre>



<p>To build the application, we run docker build as usual:</p>



<pre><code>$ docker images
REPOSITORY   TAG   	IMAGE ID   CREATED   SIZE


$ docker build -t hellodocker .
[+] Building 0.9s (10/10) FINISHED                               	 
 =&gt; [internal] load build definition from Dockerfile         	0.0s
 =&gt; =&gt; transferring dockerfile: 38B                          	0.0s
. . . 
 =&gt; =&gt; naming to docker.io/library/hellodocker               	0.0s</code></pre>



<p>We can see the image resulting from the build stored in the Docker engine cache.</p>



<pre><code>$ docker images
REPOSITORY      TAG   	IMAGE ID   	CREATED     	SIZE
hellodocker     latest	903fe47400c8    4 hours ago 	6.13MB</code></pre>



<p>But now we have a problem!</p>



<p>Kubernetes normally pulls images from a registry, which would mean we would have to push and pull the image we have built after every change. Docker Desktop removes this friction by using  <a href="https://kubernetes.io/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/#role-of-dockershim"><em>dockershim</em></a> to share the image cache between the Docker engine and Kubernetes. Dockershim is an internal component of <a href="https://github.com/kubernetes/kubernetes/tree/release-1.23/pkg/kubelet/dockershim">Kubernetes</a> that acts like a translation layer between kubelet and Docker Engine.</p>



<p>For development, this provides an essential advantage: Kubernetes can create containers from images stored in the Docker Engine image cache. We can build images locally and test them right away without having to push them to a registry first. </p>



<p>In the kubernetes yaml from the <em>tutorial</em> example, update the image name to <em>hellodocker</em> and set the image pull policy to <em>IfNotPresent</em>. This ensures that the image from the local cache is going to be used.</p>



<pre><code>...
      containers:
        - name: hello
          image: hellodocker
          ports:
            - containerPort: 80
              protocol: TCP
          resources: {}
          imagePullPolicy: IfNotPresent
      restartPolicy: Always
...</code></pre>



<p>Re-deploying applies the new updates:</p>



<pre><code>$ kubectl apply -f tutorial.yaml
service/tutorial configured
deployment.apps/tutorial configured

$ kubectl get svc
NAME       TYPE       	CLUSTER-IP       EXTERNAL-IP   PORT(S) 	     AGE
tutorial   LoadBalancer 10.109.236.243   localhost     80:31371/TCP  4s
kubernetes ClusterIP  	10.96.0.1        &lt;none&gt;        443/TCP       6h56m

$ curl localhost:80

      	##     	.
	## ## ##    	==
 ## ## ## ## ##	===
/&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;\___/ ===
{                   	/  ===-
\______ O       	__/
 \	\     	__/
  \____\_______/


Hello from Docker!</code></pre>



<p>To delete the application from the cluster run:</p>



<figure><p><code>$ kubectl delete -f tutorial.yaml</code></p></figure>



<h3 id="4-updating-kubernetes">4. Updating Kubernetes</h3>



<p>When this is the case, the Kubernetes version can be upgraded after a Docker Desktop update. However, when a new Kubernetes version is added to Docker Desktop, the user needs to reset its current cluster in order to use the newest version.</p>



<p>As pods are designed to be ephemeral, deployed applications usually save state to persistent volumes. This is where the <strong>storage-provisioner</strong> helps in persisting the local storage data.</p>



<h3 id="conclusion">Conclusion</h3>



<p>Docker Desktop offers a Kubernetes installation with a solid host integration aiming to work without any user intervention. Developers in need of a Kubernetes cluster without concerning themselves about its setup can simply install Docker Desktop and enable the Kubernetes cluster to have everything in place in a matter of a few minutes. </p>



<p>To get Docker Desktop, follow the instructions in the <a href="https://docs.docker.com/desktop/">Docker documentation</a>. It also contains a dedicated guide on how to <a href="https://docs.docker.com/desktop/kubernetes/">enable Kubernetes</a>.</p>



<h3 id="join-us-at-dockercon-2022">Join us at DockerCon 2022</h3>



<p>DockerCon is the world’s largest development conference of its kind and it’s coming to you virtually and completely free on May 10th, 2022. DockerCon 2022 is an amazing opportunity for you and your developers to learn directly from the community, get tips, tricks, and best practices that will elevate your Docker knowledge, and to learn about what’s coming up on the <a href="https://github.com/docker/roadmap">Docker Roadmap</a>. You can register for DockerCon now, <a href="https://www.docker.com/dockercon/">pre-registration is free and open</a>.</p>
          </div></div>
  </body>
</html>
