<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joaoabbottgribben.bearblog.dev/maze-making-in-rust-part-one/">Original</a>
    <h1>Maze making in Rust (part 1)</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>One of my aims while at the Recurse Center (RC) is to write a maze making program, using Jamis Buck’s <em>Mazes for Programmers</em> as my guide. This article summarises my first step in writing the program, that of creating a basic cell type. (Spoiler alert: I do not finish creating a basic cell type).</p>
<p>During this work I’ve been repeatedly taken off-guard by the concepts I’ve had to navigate in order to get even a partial implementation of the cell. The beauty of being at RC is that I’ve been able to take the time to dig into these one by one, rather than moving swiftly on once I’ve got something working.</p>
<p>This post covers the various misunderstandings and clarifications I made along the way about:</p>
<ol>
<li><a href="https://one-from-nippon.ghost.io/dagashiya/rusts-option-data-type">Rust’s <code>Option</code> data type</a></li>
<li><a href="#recursive-data-types">Recursive data types</a></li>
<li><a href="#indirection">Indirection</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#indirection-in-relation-to-recursive-data-types">Indirection in relation to recursive data types</a></li>
<li><a href="#finally-understanding-how-these-things-all-fit-together">Finally understanding how these things all fit together</a></li>
<li><a href="#understanding-my-misunderstandings">Understanding my misunderstandings</a></li>
<li><a href="#most-recent-but-probably-not-final-iteration-of-the-cell-type">Most recent (but probably not final) iteration of the <code>Cell</code> type</a></li>
</ol>
<p>As much as I’ve summarised what I’ve learnt about these topics, I’ve also really dug into the particulars of what I was <em>not</em> understanding. So, for readers more interested in just seeing where I’ve got up to with the code implementation, it might be best to skip to the <a href="#most-recent-but-probably-not-final-iteration-of-the-cell-type">end</a> of the post.</p>
<p>For those still up for tottering shakily between the above topics, read on!</p>
<h2 id="rusts-option-data-type">Rust’s <code>Option</code> data type</h2>
<p>The first step in Buck’s approach is to declare a cell type. This will be the building block for the maze. Depending on which algorithm you use, different walls of each cell will disappear or remain, eventually leaving you with a maze. Buck uses Ruby for the book’s code examples, so you get a nice simple declaration like this:</p>
<div><pre><span></span><span>class</span><span> </span><span>Cell</span>
<span>    </span><span>attr_reader</span><span> </span><span>:row</span><span>,</span><span> </span><span>:column</span>
<span>    </span><span>attr_accessor</span><span> </span><span>:north</span><span>,</span><span> </span><span>:south</span><span>,</span><span> </span><span>:east</span><span>,</span><span> </span><span>:west</span>
</pre></div>
<p>Here’s my naive initial attempt in Rust:</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span> <span>Cell</span><span> </span><span>{</span>
<span>    </span><span>row</span>: <span>u8</span><span>,</span>
<span>    </span><span>column</span>: <span>u8</span><span>,</span>
<span>    </span><span>north</span>: <span>Cell</span><span>,</span>
<span>    </span><span>east</span>: <span>Cell</span><span>,</span>
<span>    </span><span>south</span>: <span>Cell</span><span>,</span>
<span>    </span><span>west</span>: <span>Cell</span>
<span>}</span>
</pre></div>
<p>For anyone familiar with Rust and/or mazes, reading this code will be accompanied by internal sad trombone sound effects. This is partly because…</p>
<ul>
<li>The implementation doesn’t consider cells at the edge of the maze.</li>
<li>Cells at the edge of the maze won’t be surrounded by a <code>Cell</code> type on all sides.</li>
<li>So, I need to declare that <code>Cell</code> may or may not be present for <code>north</code>, <code>east</code>, <code>south</code> and <code>west</code></li>
</ul>
<p>On reading the Rust <a href="https://doc.rust-lang.org/rust-by-example/std/option.html">docs</a> I decide that <code>Option</code> is what to use in this scenario:</p>
<blockquote>
<p>The <code>Option</code> type encodes the very common scenario in which a value could be something or it could be nothing.</p>
</blockquote>
<p>Below is the second iteration, where I wrap <code>Cell</code> in <code>Option</code>. (I’ve also derived from the Debug trait for easy printing of the struct):</p>
<div><pre><span></span><span>#[derive(Debug)]</span>
<span>pub</span><span> </span><span>struct</span> <span>Cell</span><span> </span><span>{</span>
<span>    </span><span>row</span>: <span>u8</span><span>,</span>
<span>    </span><span>column</span>: <span>u8</span><span>,</span>
<span>    </span><span>north</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>east</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>south</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>west</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>}</span>
</pre></div>
<p>That’s the maybe-there-maybe-not-ness covered for neighbours, but alas the sad trombone plays on…</p>
<ul>
<li>When I try to declare a few cells and print them, the compiler complains with <a href="https://doc.rust-lang.org/error_codes/E0072.html">E0072</a> saying “A recursive type has infinite size because it doesn&#39;t have an indirection.”</li>
</ul>
<h2 id="recursive-data-types">Recursive data types</h2>
<p>On reading around this, it seems Rust is not happy with types that could infinitely recurse. Why?</p>
<p>The docs of E0072 have this to say:</p>
<blockquote>
<p>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like <code>Box</code>, <code>&amp;</code> or <code>Rc</code>). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</p>
</blockquote>
<p>Yes, those are words and I have read them. Computer words. After reading this, I can add to a few more questions to my initial one of “What on earth is indirection?” :</p>
<ol>
<li>Why do structs and enums require a well-defined size?</li>
<li>Why do pointers keep the size of the type bounded?</li>
</ol>
<p>I’ll start with indirection…</p>
<h2 id="indirection">Indirection</h2>
<p>Broadly, it seems that indirection means “rather than using a thing directly, use something else that references that thing” (at least according to this SO <a href="https://stackoverflow.com/a/18003704">answer</a>) . I’ve come across <a href="https://medium.com/@nmckinnonblog/indirection-fba1857630e2">wrapping</a> as a synonym, and it seemed abstraction was also a candidate for a synonym, until I read this <a href="https://softwareengineering.stackexchange.com/a/113310">post</a> which gives strong arguments to the contrary.</p>
<p>What I’ve found most helpful in understanding indirection, is considering <a href="https://stackoverflow.com/a/15818763">pointers</a> as an example of indirection in action.</p>
<h2 id="pointers">Pointers</h2>
<p>For those who haven’t come across pointers before, I’ve found the following analogy useful for understanding them :</p>
<blockquote>
<p>The relationship between a pointer and the value it refers to, is like that of a house and its address. The address allows you to locate the house, but it is not the house itself.</p>
</blockquote>
<p>Or as one SO <a href="https://stackoverflow.com/a/15818709">answer</a> more tersely put it:</p>
<blockquote>
<p>…a pointer is a variable that holds a memory address.</p>
</blockquote>
<p>So we can take the initial description of indirection ( “rather than using a thing directly, use something else that references that thing”) and highlight how pointers demonstrate this:</p>
<blockquote>
<p>“rather than using a thing (a value at a particular memory address) directly, use something else (a pointer that stores that particular memory address ) that references that thing”</p>
</blockquote>
<p>At this point, I’m happy with having answered the first question “What on earth is indirection?”, but as is often the case, it’s raised a follow up question: “How on earth does indirection relate to recursive data types?”…</p>
<h2 id="indirection-and-recursive-data-types">Indirection and recursive data types</h2>
<p>Wikipedia’s entry on <a href="https://en.wikipedia.org/wiki/Indirection">indirection</a> points us in the right (ahem) direction:</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Recursive_data_type">Recursive data types</a> are usually implemented using indirection, because otherwise if a value of a datatype can contain the entirety of another value of the same datatype, there is no limit to the size a value of this datatype could need.</p>
</blockquote>
<p>This rephrased what’s in the rust docs, but I still didn’t really grok the issue, instead it generated a few more questions:</p>
<ol>
<li>Is the converse true? i.e. When datatypes contain values of <em>different</em> datatypes is a limit imposed on the size a value of the datatype could need?</li>
<li>How does using indirection mean that the size required for a recursive data type becomes limited and/or predictable?</li>
</ol>
<p>What I’m struggling with is the fact that the actual memory potentially taken up by a recursive type remains the same whether you use indirection or not. Using indirection the memory is still required, it’s just that it’s not directly held in the enclosing datatype as you’re instead holding a reference to the memory address instead - but the memory at that address still has the potential to be used, as does any remaining memory because in theory this datatype could be declared in a way that recurses infinitely (?)</p>
<p>At this point I really feel like I’m missing something about what is happening at compile time with different data types. So, I open up various articles on <a href="https://rustc-dev-guide.rust-lang.org/memory.html">Rust memory management</a>, <a href="https://rustc-dev-guide.rust-lang.org/overview.html">what happens at compile time</a>, <a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/second-edition/ch15-01-box.html">Box pointers and recursion</a> and so on and so forth.
Then, when reading the final article, the pieces came together (not that they weren’t all there from the beginning in the initial error message!) and I wrote down the questions that got me to understanding:</p>
<ul>
<li>So, <code>Box</code> has a known size, which allows the code to compile, because the compiler is able to allocate a given amount of memory accurately?</li>
<li>Does this mean that datatypes like <code>u8</code> have a known size?</li>
<li>So Rust will allocate particular amounts of memory depending on a data type?</li>
</ul>
<h2 id="finally-understanding-how-these-things-all-fit-together">Finally understanding how these things all fit together</h2>
<p>With answering “yes” to these three questions I finally understood what was happening during compiling to throw the error I was seeing. From the compiler’s perspective, this is what happens after looking at the <code>Cell</code> struct as it&#39;s currently declared:</p>
<div><pre><span></span><span>#[derive(Debug)]</span>
<span>pub</span><span> </span><span>struct</span> <span>Cell</span><span> </span><span>{</span>
<span>    </span><span>row</span>: <span>u8</span><span>,</span>
<span>    </span><span>column</span>: <span>u8</span><span>,</span>
<span>    </span><span>north</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>east</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>south</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>    </span><span>west</span>: <span>Option</span><span>&lt;</span><span>Cell</span><span>&gt;</span><span>,</span>
<span>}</span>
</pre></div>
<p>(Now imagine all of the below is said in the voice of the compiler...)</p>
<ul>
<li>We’ve got a <code>Cell</code> type here, that’s not a type I recognise so I don’t know what memory to allocate to that, let’s look at what data types it expects so I can allocate some memory for it</li>
<li><code>row</code> is <code>u8</code>, ok I’ll allocate 8 bits of memory to that variable</li>
<li><code>column</code> is also <code>u8</code>, so I’ll allocate 8 bits memory to that too</li>
<li><code>north</code> is <code>Cell</code> type, that’s not a type I recognise so I don’t know what memory to allocate to that, let’s look at what data types it expects so I can allocate some memory for it<ul>
<li><code>row</code> is <code>u8</code>, ok I’ll allocate 8 bits of memory to that variable</li>
<li><code>column</code> is also <code>u8</code>, so I’ll allocate 8 bits memory to that too</li>
<li><code>north</code> is <code>Cell</code> type, that’s not a type I recognise so I don’t know what memory to allocate to that, let’s look at what data types it expects so I can allocate some memory for it<ul>
<li><code>row</code> is <code>u8</code>, ok I’ll allocate 8 bits of memory to that variable</li>
<li><code>column</code> is also <code>u8</code>, so I’ll allocate 8 bits memory to that too</li>
<li><code>north</code> is <code>Cell</code> type, that’s not a type I recognise so I don’t know what memory to allocate to that, let’s look at what data types it expects so I can allocate some memory for it...</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>…and so on</p>
<p>With that perspective, I can see why the compiler would complain. If I was a compiler I too would like to finish compiling and would complain if I couldn’t.
This leads to the question of why <em>didn’t</em> I understand the error message when it first appeared?</p>
<h2 id="understanding-my-misunderstandings">Understanding my misunderstandings</h2>
<p>I’m never fully satisfied with a new understanding if I’m unsure why I didn’t understand it in the first place. So, I’m going to go back over the questions I raised leading up to this point (marked with ‘Q’) and try to provide answers (marked with ‘A’) to my past self.</p>
<p>Q</p>
<blockquote>
<ol>
<li>Why do structs and enums require a well-defined size?</li>
<li>Why do pointers keep the size of the type bounded?</li>
</ol>
</blockquote>
<p>A</p>
<ol>
<li>So the compiler knows how much memory to allocate to variables of this type</li>
<li>Because a pointer is a known type, the compiler knows how much memory to allocate to it</li>
</ol>
<p>Those two were fairly straight forward, but from here on we get onto the deeper misunderstandings that I had…</p>
<p>Q</p>
<blockquote>
<p>…it seems Rust is not happy with types that could infinitely recurse. Why?</p>
</blockquote>
<p>A</p>
<p>Q</p>
<blockquote>
<ol>
<li>Is the converse true? i.e. When datatypes contain values of <em>different</em> datatypes is a limit imposed on the size a value of the datatype could need?</li>
<li>How does using indirection mean that the size required for a recursive data type becomes limited and/or predictable?</li>
</ol>
</blockquote>
<p>A</p>
<ol>
<li>Rather than it being about the fact that it’s a different datatype setting a limit on its size, it’s about it being a known and defined datatype e.g. <code>i32</code>. In theory you could declare a struct with a field of a different type, and if that type was recursive and declared without using indirection, it would still fail to compile. So it’s not that <em>difference</em> is what’s required to address the error, it’s <em>boundedness</em>.</li>
<li>Indirection, specifically using pointers, makes the datatype bounded because a pointer has a known size, as the range of possibly memory addresses is known in advance. The compiler can refer to this size and allocate that amount of memory to the variable.</li>
</ol>
<p>Q</p>
<blockquote>
<p>What I’m struggling with is the fact that the actual memory potentially taken up by a recursive type remains the same whether you use indirection or not. Using indirection the memory is still required, it’s just that it’s not directly held in the enclosing datatype as you’re instead holding a reference to the memory address instead - but the memory at that address still has the potential to be used, as does any remaining memory because in theory this datatype could be declared in a way that recurses infinitely.</p>
</blockquote>
<p>A</p>
<p>So we’ve just taken a confused and meandering path through recursive data types, Rust’s <code>Option</code> , indirection, pointers and compile time memory allocation. But what about the mazes??? Well, now I actually understand what the error message is saying, we can get round to implementing a fix.</p>
<p>The error message gave various options that could help resolve its complaint : <code>Box</code>, <code>&amp;</code> and <code>Rc</code> (Rust’s error messages are one of the reasons I’m interested in the language - they’re so humane and considerate) .</p>
<p>Based on no investigation whatsoever, I went with <code>Box</code>, changing the declaration to this:</p>
<div><pre><span></span><span>pub</span><span> </span><span>struct</span> <span>Cell</span><span> </span><span>{</span>
<span>    </span><span>row</span>: <span>u8</span><span>,</span>
<span>    </span><span>column</span>: <span>u8</span><span>,</span>
<span>    </span><span>north</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>east</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>south</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>west</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>
</pre></div>
<ul>
<li>The code now compiles and I can print the second cell I declared (see below for the full piece of code).</li>
<li>However, the <code>cell_one</code> can’t be printed, due to how its ownership is being handled.</li>
<li>I worry about whether <code>Box</code> is going to make sense going forward, because I’ve read a few things about ownership and hierarchy in relation to <code>Box</code>. One of my fellow recursers suggested I may need to use <code>Rc</code> instead.</li>
<li>I’ll continue to post updates here, so a comparison of <code>Box</code> <code>Rc</code> and <code>&amp;</code> will probably be the topic of my next post</li>
</ul>
<h2 id="most-recent-but-probably-not-final-iteration-of-the-cell-type">Most recent (but probably not final) iteration of the <code>Cell</code> type:</h2>
<div><pre><span></span><span>#[derive(Debug)]</span>
<span>pub</span><span> </span><span>struct</span> <span>Cell</span><span> </span><span>{</span>
<span>    </span><span>row</span>: <span>u8</span><span>,</span>
<span>    </span><span>column</span>: <span>u8</span><span>,</span>
<span>    </span><span>north</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>east</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>south</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>    </span><span>west</span>: <span>Option</span><span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>}</span>

<span>fn</span> <span>main</span><span>(){</span>
<span>    </span><span>let</span><span> </span><span>cell_one</span>: <span>Cell</span><span> </span><span>=</span><span> </span><span>Cell</span><span> </span><span>{</span>
<span>        </span><span>row</span>: <span>1</span><span>,</span>
<span>        </span><span>column</span>: <span>1</span><span>,</span>
<span>        </span><span>north</span>:  <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>        </span><span>east</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>        </span><span>south</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>        </span><span>west</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span>
<span>    </span><span>};</span>
<span>    </span><span>let</span><span> </span><span>cell_two</span>: <span>Cell</span><span> </span><span>=</span><span> </span><span>Cell</span><span>{</span>
<span>        </span><span>row</span>: <span>0</span><span>,</span>
<span>        </span><span>column</span>: <span>0</span><span>,</span>
<span>        </span><span>north</span>: <span>Some</span><span>(</span><span>Box</span>::<span>new</span><span>(</span><span>cell_one</span><span>)),</span>
<span>        </span><span>east</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>        </span><span>south</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span><span>,</span>
<span>        </span><span>west</span>: <span>None</span>::<span>&lt;</span><span>Box</span><span>&lt;</span><span>Cell</span><span>&gt;&gt;</span>
<span>    </span><span>};</span>
<span>    </span><span>println!</span><span>(</span><span>&#34;{:#?}&#34;</span><span>,</span><span> </span><span>cell_two</span><span>);</span>
<span>}</span>
</pre></div>
</div>
</div></div>
  </body>
</html>
