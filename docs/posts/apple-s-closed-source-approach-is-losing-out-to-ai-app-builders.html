<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.telkins.dev/blog/how-apples-closed-source-approach-is-losing-out-to-ai-app-builders">Original</a>
    <h1>Apple’s closed-source approach is losing out to AI app builders</h1>
    
    <div id="readability-page-1" class="page"><div id="article-content"><p>As a long-time iOS developer, it&#39;s frustrating — to say the least — as I watch the entire development landscape change while we are stuck in place. I&#39;ve tried <a target="_blank" rel="noopener noreferrer" href="https://lovable.dev">lovable.dev</a> and <a target="_blank" rel="noopener noreferrer" href="https://a0.dev">a0.dev</a> to build some websites and apps and the experiences feel magical. Meanwhile, we barely have a working Github Copilot in Xcode and every developer I know has disabled Apple &#34;Intelligence&#34;.</p><p><a target="_blank" rel="noopener noreferrer" href="https://x.com/Baconbrix/status/1888633966938276267">According to Evan Bacon</a>, one of the developers leading the Expo project, 40 of the top 100 iOS shopping apps (*) are now non-native. And with the proliferation of AI app builders, the future is starting to look even more non-native.</p><p>Where is the Cursor experience for iOS development?</p><p>The reason for this, in my opinion, is due to Apple&#39;s closed-source history. This is a story of how long-held company decisions can accumulate and become disastrous. Let&#39;s take a look at what it would take to build an a0.dev experience for iOS.</p><p><em>(*): I originally said &#34;all&#34; apps which was a mistake, sorry!</em></p><h2 id="code-editor"><a href="#code-editor" aria-hidden="true" tabindex="-1"><span></span></a>Code editor</h2><p>When a user prompts for changes they want, we need a way to update the code and see if it builds. This should be easy, right?</p><p>For starters, you need a Mac machine. From there, compiling code for iOS is notoriously difficult and not officially supported outside of using Xcode. For example, there is an <code>xcodebuild</code> command you can run, but it often doesn&#39;t work with table stakes features like incremental builds. And there are tons of slow papercuts you&#39;ll encounter such as it pinging the Apple servers several times to check for provisioning profile updates and whether your app has the correct entitlements (permission to use OS features). Again, features to lock down your app that nobody asked for.</p><p>In a local test project I&#39;m able to get this command working. I added a compilation error to show how that looks:</p><div><pre><code><span>➜  <span>Snake</span> git<span>:</span><span>(</span>main<span>)</span> ✗ xcodebuild <span>-</span>scheme <span>Snake</span> <span>-</span>configuration <span>Debug</span> <span>-</span>json <span>-</span>destination <span>&#39;platform=iOS Simulator,id=C286A4E0-BC6C-49EA-A0C7-BBAB40CB0E0B&#39;</span> <span>-</span>quiet build
</span><span><span>/</span><span>Users</span><span>/</span>telkins<span>/</span>dev<span>/</span>ios<span>/</span><span>Snake</span><span>/</span><span>SnakeTabView</span><span>.</span><span>swift</span><span>:</span><span>8</span><span>:</span><span>4</span><span>:</span> error<span>:</span> unknown attribute <span>&#39;States&#39;</span>
</span><span>  @<span>States</span> <span>private</span> <span>var</span> <span>path</span><span>:</span> <span>[</span><span>Screen</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
</span><span>   <span>^</span>
</span><span><span>/</span><span>Users</span><span>/</span>telkins<span>/</span>dev<span>/</span>ios<span>/</span><span>Snake</span><span>/</span><span>SnakeTabView</span><span>.</span><span>swift</span><span>:</span><span>8</span><span>:</span><span>4</span><span>:</span> error<span>:</span> unknown attribute <span>&#39;States&#39;</span>
</span><span>  @<span>States</span> <span>private</span> <span>var</span> <span>path</span><span>:</span> <span>[</span><span>Screen</span><span>]</span> <span>=</span> <span>[</span><span>]</span>
</span><span>   <span>^</span>
</span><span><span>/</span><span>Users</span><span>/</span>telkins<span>/</span>dev<span>/</span>ios<span>/</span><span>Snake</span><span>/</span><span>SnakeTabView</span><span>.</span><span>swift</span><span>:</span><span>15</span><span>:</span><span>29</span><span>:</span> error<span>:</span> cannot find <span>&#39;$path&#39;</span> <span>in</span> scope
</span><span>      <span><span>NavigationStack</span></span><span>(</span><span><span>path</span><span>:</span> $path</span><span>)</span> <span>{</span>
</span><span>                            <span>^</span><span>~</span><span>~</span><span>~</span><span>~</span>
</span><span><span>**</span> <span>BUILD</span> <span>FAILED</span> <span>**</span>
</span></code></pre></div><p>This works and is probably parseable by an LLM since we want to automatically fix build errors for the user. Awesome, some progress!</p><p>What if our AI prompt results in creating a new file. Adding a new file should be easy, right?</p><p>Unfortunately this is also more challenging than necessary because Xcode&#39;s propietary project format requires you to track file references, so we need a way to edit this file and hope it doesn&#39;t get out of sync. I&#39;m not aware of any official tool or library to help edit this file, although there&#39;s a commonly used <a target="_blank" rel="noopener noreferrer" href="https://github.com/CocoaPods/Xcodeproj">xcodeproj</a> Ruby gem.</p><p>In 2025 it&#39;s recommended to put as much of your code into Swift Packages, which work great, but they still need to be integrated into your project file. We&#39;re still in a weird transition period where we can&#39;t fully build an app with Swift Packages.</p><p>Luckily all hope is not lost, there are a few projects in development worth mentioning:</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/swiftlang/swift-build">Swift Build</a> was recently open sourced, so I expect a lot of improvements in this area soon.</li><li><a target="_blank" rel="noopener noreferrer" href="https://dimillian.medium.com/why-you-should-use-xcode-16-buildable-folders-instead-of-groups-6f438611914d">Buildable folders</a> were added in Xcode 16 which do help a lot for code not in a package. Now you only need to add a project file reference to a folder and not every file within it.</li><li>Some folks have been working on a VSCode extension called <a target="_blank" rel="noopener noreferrer" href="https://sweetpad.hyzyla.dev/">Sweetpad</a> which simplifies a lot of this.</li></ul><p>But really this is all too little too late. iOS development as a whole is still closed source for the time being.</p><h2 id="previewing"><a href="#previewing" aria-hidden="true" tabindex="-1"><span></span></a>Previewing</h2><p>Now let&#39;s pretend we&#39;ve used AI to make some code changes, it successfully compiled, and we want to preview the result. From what I can tell with services like Lovable.dev, they run a local development server on a VM and your browser simply has to view the right page. For a0.dev with React Native apps it&#39;s basically the same thing, you are viewing a <code>react-native-web</code> instance in your browser. a0.dev is essentially displaying:</p><div><pre><code><span><span><span><span>&lt;</span>foreignObject</span>
</span></span><span><span>  <span>x</span><span><span>=</span><span>&#34;</span>21.25<span>&#34;</span></span>
</span></span><span><span>  <span>y</span><span><span>=</span><span>&#34;</span>19.25<span>&#34;</span></span>
</span></span><span><span>  <span>width</span><span><span>=</span><span>&#34;</span>389.5<span>&#34;</span></span>
</span></span><span><span>  <span>height</span><span><span>=</span><span>&#34;</span>843.5<span>&#34;</span></span>
</span></span><span><span>  <span>clip-path</span><span><span>=</span><span>&#34;</span>url(#roundedCorners)<span>&#34;</span></span>
</span></span><span><span>  <span>class</span><span><span>=</span><span>&#34;</span>overflow-hidden<span>&#34;</span></span>
</span></span><span><span><span>&gt;</span></span>
</span><span>  <span><span><span>&lt;</span>iframe</span>
</span></span><span><span>    <span>src</span><span><span>=</span><span>&#34;</span>https://a0.dev/v2/52/index.html?initialUrl=exp%3A%2F%2Fu.expo.dev%2F933fd9c0-1666-11e7-afca-d980795c5824%3Fruntime-version%3Dexposdk%253A52.0.0%26channel-name%3Dproduction%26snack%3Dcc18e8a0-8c69-4bdd-8df0-7d15181cac48%26snack-channel%3D5PYBIUJa1n<span title="&amp;">&amp;amp;</span>origin=https%3A%2F%2Fa0.dev<span title="&amp;">&amp;amp;</span>verbose=false<span>&#34;</span></span>
</span></span><span><span>    <span>class</span><span><span>=</span><span>&#34;</span>w-full h-full border-0<span>&#34;</span></span>
</span></span><span><span>    <span>allowfullscreen</span><span><span>=</span><span>&#34;</span><span>&#34;</span></span>
</span></span><span><span>    <span>allow</span><span><span>=</span><span>&#34;</span>cross-origin-isolated; accelerometer; ambient-light-sensor; autoplay; battery; camera; fullscreen; gamepad; geolocation; gyroscope; idle-detection; magnetometer; microphone; midi; payment; picture-in-picture; screen-wake-lock; usb<span>&#34;</span></span>
</span></span><span><span>  <span>&gt;</span></span><span><span><span>&lt;/</span>iframe</span><span>&gt;</span></span>
</span><span><span><span><span>&lt;/</span>foreignObject</span><span>&gt;</span></span>
</span></code></pre></div><p>And that <code>&lt;iframe&gt;</code> is loading the <code>react-native-web</code> HTML page, which you can see by inspecting the element. Since React Native is just React code, it&#39;s possible to swap out the underlying platform target and get a nice preview in your browser.</p><p>On the other hand, iOS development targets an iOS runtime, so you have to run your app on a Simulator device. Everything becomes much more complicated. You have to manage launching simulators (which require a lot of memory), deal with device updates and simulator runtimes, and figure out how to pipe video output to a browser while sending user interactions back to the simulator. Not an easy task.</p><p>So it appears the iOS runtime is a big blocker here. What if we could target SwiftUI for the web through WASM or some other mechanism? Sorry, SwiftUI is closed source! We&#39;re at Apple&#39;s mercy to ever develop such a feature. There is a neat project <a target="_blank" rel="noopener noreferrer" href="https://github.com/OpenSwiftUIProject/OpenSwiftUI">OpenSwiftUI</a>, but it&#39;s achieved through painstakingly reverse engineering the framwork. Why Apple made SwiftUI closed source I will never understand, especially when the Android competitor, Jetpack Compose, is open source and thriving in cross-platform development with <a target="_blank" rel="noopener noreferrer" href="https://www.jetbrains.com/compose-multiplatform/">Compose Multiplatform</a>. There are some neat projects like <a target="_blank" rel="noopener noreferrer" href="https://skip.tools/">Skip</a> but that only targets Android and not the web.</p><h2 id="building-at-scale"><a href="#building-at-scale" aria-hidden="true" tabindex="-1"><span></span></a>Building at scale</h2><p>Now let’s pretend we managed to solve the simulator problem and want to scale our solution so thousands of developers can use it. Server virtualization is a solved problem, right?</p><p>Not when it comes to iOS. Since we need to run a simulator, we also need macOS machines. Here’s the snag: deploying macOS servers at scale is extremely difficult.</p><p>For starters, macOS virtual machines can only legally run on real Apple hardware. Then, according to Apple’s licensing terms, you have to reserve these bare-metal Mac instances for a minimum of 24 hours. (Check out the hoops you jump through with <a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-mac-instances.html">AWS bare-metal Mac instances</a>.)</p><p>Second, once you do get a Mac instance running, Apple’s Virtualization Framework limits you to just two concurrent VMs. You’d want to run your build service in a VM because simulator devices have access to the host filesystem—and a malicious app could potentially read or steal data from the host or other users. Therefore, running at scale means lots and lots of bare-metal Macs.</p><p>Finally, macOS simply isn’t built to be a headless server OS. You’ll run into a ton of quirks that you don’t see on Linux, which “just works” for server purposes.</p><h2 id="what-about-android"><a href="#what-about-android" aria-hidden="true" tabindex="-1"><span></span></a>What about Android?</h2><p>It&#39;s worth quickly mentioning Google&#39;s Android since it&#39;s open-source. Does it fare bettera than Apple?</p><p>In theory it should, most projects will compile successfully with a simple <code>./gradlew assembleDebug</code> command.</p><p>The emulator problem is largely the same though. Running Android emulators at scale is possible but has its own set of headaches. Your Android app would likely have to target a web platform using Compose Multiplatform. I&#39;ve seen projects where Compose views have been rendered on the web so it&#39;s definitely possible right now, just a matter of making the developer experience much better to match Expo.</p><h2 id="takeaway"><a href="#takeaway" aria-hidden="true" tabindex="-1"><span></span></a>Takeaway</h2><p>Thank you for making it this far. So what’s the lesson? From my perspective, Apple’s secretive, closed-source approach to software has finally caught up with them, leaving them behind in the AI race. The UI platforms thriving right now are all built on open source software. More and more teams are building apps in React Native rather than Swift—especially now that AI services make bootstrapping an app unbelievably fast. I would love to see something like Lovable or A0 for building truly native iOS apps, but the quirks of Apple’s ecosystem make it unfeasible.</p><p>For years, developers have complained about the terrible developer experience (DX) on Apple platforms, yet Apple never tackled the root problems. Now, they’ve dug themselves quite a hole.</p></div></div>
  </body>
</html>
