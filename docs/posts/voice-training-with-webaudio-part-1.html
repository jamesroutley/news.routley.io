<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glitch.at.goth.cafe/voice-training-with-webaudio-part-1/">Original</a>
    <h1>Voice Training with WebAudio Part 1</h1>
    
    <div id="readability-page-1" class="page"><div><p>Hello there. I’m going to explore a pitch detection method called the McLeod Pitch Method, using the power of JavaScript and WebAudio. I’ll try to use this work later for a web-based voice training app to help with voice triggered dysphoria, but it can be used for other things as well.</p><h4 id="a-brief-overview-of-the-mcleod-pitch-method">A Brief Overview of the McLeod Pitch Method</h4><p>Before we delve into the code, it’s worthwhile to understand the McLeod Pitch Method (MPM). In simple terms, this method evaluates the similarity between a waveform (our sound signal) and its time-shifted version. By systematically doing this for a series of shifts, we can determine the predominant frequency - the pitch we’re looking for.</p><p>For those inclined to explore deeper, <a href="http://www.music.mcgill.ca/~ich/research/misc/papers/cr1172.pdf">this</a> research paper provides a thorough examination of MPM.</p><h4 id="an-implementation">An Implementation</h4><p>To implement the algorithm outlined in the paper, we need to perform the following steps:</p><p><strong>Step 1</strong>. Normalized Squared Difference Function (NSDF) Calculation: In this step, we measure the similarity between the waveform and its shifted version. It’s done by carefully iterating through our signal and working out NSDF values for each potential shift.</p><p><strong>Step 2</strong>. Identifying Local Maxima: Within the NSDF array, we search for points where a value stands out by being larger than its immediate neighbors. These peaks are crucial in identifying the dominant frequency.</p><p><strong>Step 3</strong>. Selecting the Pitch from the Highest Peak: The most prominent peak gives us the pitch we’re searching for. We then seamlessly convert this to a frequency measure in Hertz (Hz).</p><p>So how do we do this in JavaScript? Let’s explore with our code below.</p><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>mcleodPitchMethod</span>(<span>signal</span>) {
</span></span><span><span>    <span>// 1. Calculate the normalized squared difference function (NSDF).
</span></span></span><span><span><span></span>    <span>// NSDF is a measure of how similar a waveform is to a time-shifted version of itself.
</span></span></span><span><span><span></span>    
</span></span><span><span>    <span>let</span> <span>nsdf</span> <span>=</span> <span>new</span> <span>Float32Array</span>(<span>signal</span>.<span>length</span>); <span>// Array to store NSDF values.
</span></span></span><span><span><span></span>    <span>for</span> (<span>let</span> <span>tau</span> <span>=</span> <span>0</span>; <span>tau</span> <span>&lt;</span> <span>signal</span>.<span>length</span>; <span>tau</span><span>++</span>) {
</span></span><span><span>        <span>// &#39;tau&#39; is the amount of time-shift.
</span></span></span><span><span><span></span>        <span>let</span> <span>m</span> <span>=</span> <span>0.0</span>; <span>// Accumulator for the numerator of the NSDF formula.
</span></span></span><span><span><span></span>        <span>let</span> <span>n1</span> <span>=</span> <span>0.0</span>; <span>// Part of the denominator.
</span></span></span><span><span><span></span>        <span>let</span> <span>n2</span> <span>=</span> <span>0.0</span>; <span>// Another part of the denominator.
</span></span></span><span><span><span></span>        
</span></span><span><span>        <span>for</span> (<span>let</span> <span>j</span> <span>=</span> <span>0</span>; <span>j</span> <span>&lt;</span> <span>signal</span>.<span>length</span> <span>-</span> <span>tau</span>; <span>j</span><span>++</span>) {
</span></span><span><span>            <span>// Calculate the values used in the NSDF formula.
</span></span></span><span><span><span></span>            <span>m</span> <span>+=</span> <span>signal</span>[<span>j</span>] <span>*</span> <span>signal</span>[<span>j</span> <span>+</span> <span>tau</span>];
</span></span><span><span>            <span>n1</span> <span>+=</span> <span>signal</span>[<span>j</span>] <span>*</span> <span>signal</span>[<span>j</span>];
</span></span><span><span>            <span>n2</span> <span>+=</span> <span>signal</span>[<span>j</span> <span>+</span> <span>tau</span>] <span>*</span> <span>signal</span>[<span>j</span> <span>+</span> <span>tau</span>];
</span></span><span><span>        }
</span></span><span><span>        
</span></span><span><span>        <span>// Calculate the NSDF value for this value of &#39;tau&#39;.
</span></span></span><span><span><span></span>        <span>nsdf</span>[<span>tau</span>] <span>=</span> <span>2.0</span> <span>*</span> <span>m</span> <span>/</span> (<span>n1</span> <span>+</span> <span>n2</span>);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// 2. Find local maxima in the NSDF array.
</span></span></span><span><span><span></span>    <span>// These are potential candidates for the detected pitch period.
</span></span></span><span><span><span></span>    <span>let</span> <span>maxPositions</span> <span>=</span> []; <span>// Array to store positions of local maxima.
</span></span></span><span><span><span></span>    <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>1</span>; <span>i</span> <span>&lt;</span> <span>nsdf</span>.<span>length</span> <span>-</span> <span>1</span>; <span>i</span><span>++</span>) {
</span></span><span><span>        <span>// Check if the current value is greater than its neighbors.
</span></span></span><span><span><span></span>        <span>if</span> (<span>nsdf</span>[<span>i</span>] <span>&gt;</span> <span>nsdf</span>[<span>i</span> <span>-</span> <span>1</span>] <span>&amp;&amp;</span> <span>nsdf</span>[<span>i</span>] <span>&gt;</span> <span>nsdf</span>[<span>i</span> <span>+</span> <span>1</span>]) {
</span></span><span><span>            <span>maxPositions</span>.<span>push</span>(<span>i</span>);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// 3. Choose the highest peak as the pitch period.
</span></span></span><span><span><span></span>    <span>// The highest peak corresponds to the best match for the pitch period.
</span></span></span><span><span><span></span>    <span>let</span> <span>highestPeakPos</span> <span>=</span> <span>maxPositions</span>[<span>0</span>];
</span></span><span><span>    <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>1</span>; <span>i</span> <span>&lt;</span> <span>maxPositions</span>.<span>length</span>; <span>i</span><span>++</span>) {
</span></span><span><span>        <span>if</span> (<span>nsdf</span>[<span>maxPositions</span>[<span>i</span>]] <span>&gt;</span> <span>nsdf</span>[<span>highestPeakPos</span>]) {
</span></span><span><span>            <span>highestPeakPos</span> <span>=</span> <span>maxPositions</span>[<span>i</span>];
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Convert the pitch period (in samples) to frequency (in Hz).
</span></span></span><span><span><span></span>    <span>// &#39;sampleRate&#39; is the number of samples processed per second. 
</span></span></span><span><span><span></span>    <span>// In the context of this function, it&#39;s assumed to be known globally or passed as a parameter.
</span></span></span><span><span><span></span>    
</span></span><span><span>    <span>let</span> <span>pitchFrequency</span> <span>=</span> <span>sampleRate</span> <span>/</span> <span>highestPeakPos</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>pitchFrequency</span>;
</span></span><span><span>}
</span></span></code></pre></div><h4 id="volume-thresholding">Volume Thresholding</h4><p>The algorithm above works well for detecting pitch in a signal. However, it’s not very robust to noise. To make it more robust, we can add a volume threshold. This means that we only detect pitch when the volume of the signal exceeds a certain threshold. This is a common technique used in audio processing. We can use RMS (Root Mean Square) to calculate the volume of the signal. The code below shows how to do this.</p><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>// Function to calculate the Root Mean Square (RMS) of a set of audio
</span></span></span><span><span><span>// samples. RMS provides a measure of the magnitude (or volume) of an
</span></span></span><span><span><span>// audio signal.
</span></span></span><span><span><span></span><span>function</span> <span>calculateRMS</span>(<span>samples</span>) {
</span></span><span><span>  <span>// Initialize the sum of squares of each sample.
</span></span></span><span><span><span></span>  <span>let</span> <span>sumOfSquares</span> <span>=</span> <span>0</span>;
</span></span><span><span>
</span></span><span><span>  <span>// Loop through each sample in the audio buffer.
</span></span></span><span><span><span></span>  <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>samples</span>.<span>length</span>; <span>i</span><span>++</span>) {
</span></span><span><span>    <span>// Square each sample value and add it to the sum.
</span></span></span><span><span><span></span>    <span>sumOfSquares</span> <span>+=</span> <span>samples</span>[<span>i</span>] <span>*</span> <span>samples</span>[<span>i</span>];
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>// Calculate the mean (average) of the squared samples.
</span></span></span><span><span><span></span>  <span>// Then, take the square root of that mean to get the RMS value.
</span></span></span><span><span><span></span>  <span>let</span> <span>rms</span> <span>=</span> Math.<span>sqrt</span>(<span>sumOfSquares</span> <span>/</span> <span>samples</span>.<span>length</span>);
</span></span><span><span>
</span></span><span><span>  <span>// Return the RMS value.
</span></span></span><span><span><span></span>  <span>return</span> <span>rms</span>;
</span></span><span><span>}
</span></span></code></pre></div><h4 id="webaudio-and-audio-capture">WebAudio and audio capture</h4><p>Now that we have a pitch detection method, and a way to detect volume, we need to capture audio from the microphone and feed it to the algorithm. We can do this using the WebAudio API. The code below shows how to do this.</p><div><pre tabindex="0"><code data-lang="javascript"><span><span><span>const</span> <span>PITCH_VOLUME_THRESHOLD</span> <span>=</span> <span>0.03</span>; <span>// This is an arbitrary number; adjust based on testing and requirements.
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Create a new audio context. This is the primary object used in the Web Audio API.
</span></span></span><span><span><span></span><span>let</span> <span>audioContext</span> <span>=</span> <span>new</span> (window.<span>AudioContext</span> <span>||</span> window.<span>webkitAudioContext</span>)();
</span></span><span><span>
</span></span><span><span><span>// Create a script processor node with a buffer size of 4096 samples.
</span></span></span><span><span><span>// This node lets us directly process raw audio data using JavaScript.
</span></span></span><span><span><span>// params are: buffer size, input channels, output channels.
</span></span></span><span><span><span></span><span>let</span> <span>processor</span> <span>=</span> <span>audioContext</span>.<span>createScriptProcessor</span>(<span>4096</span>, <span>1</span>, <span>1</span>);
</span></span><span><span><span>let</span> <span>sampleRate</span> <span>=</span> <span>audioContext</span>.<span>sampleRate</span>;
</span></span><span><span>
</span></span><span><span><span>// Request access to the user&#39;s microphone.
</span></span></span><span><span><span></span><span>navigator</span>.<span>mediaDevices</span>
</span></span><span><span>  .<span>getUserMedia</span>({ <span>audio</span><span>:</span> <span>true</span> })
</span></span><span><span>  .<span>then</span>((<span>stream</span>) =&gt; {
</span></span><span><span>    <span>// If access is granted, create a media stream source from the microphone stream.
</span></span></span><span><span><span></span>    <span>let</span> <span>source</span> <span>=</span> <span>audioContext</span>.<span>createMediaStreamSource</span>(<span>stream</span>);
</span></span><span><span>
</span></span><span><span>    <span>// Connect the media source to the script processor node.
</span></span></span><span><span><span></span>    <span>// This means that audio from the mic will flow into our custom processing node.
</span></span></span><span><span><span></span>    <span>source</span>.<span>connect</span>(<span>processor</span>);
</span></span><span><span>
</span></span><span><span>    <span>// Also, connect the script processor to the audio context&#39;s destination.
</span></span></span><span><span><span></span>    <span>// This ensures the audio plays back, so you can hear it (optional, based on use case).
</span></span></span><span><span><span></span>    <span>processor</span>.<span>connect</span>(<span>audioContext</span>.<span>destination</span>);
</span></span><span><span>
</span></span><span><span>    <span>// This event fires whenever our buffer (of 4096 samples in this case) is full.
</span></span></span><span><span><span></span>    <span>processor</span>.<span>onaudioprocess</span> <span>=</span> <span>function</span> (<span>event</span>) {
</span></span><span><span>      <span>// Get the audio samples from the input buffer.
</span></span></span><span><span><span></span>      <span>let</span> <span>inputBuffer</span> <span>=</span> <span>event</span>.<span>inputBuffer</span>;
</span></span><span><span>
</span></span><span><span>      <span>// We&#39;re assuming mono sound, so only one channel.
</span></span></span><span><span><span></span>      <span>let</span> <span>inputData</span> <span>=</span> <span>inputBuffer</span>.<span>getChannelData</span>(<span>0</span>);
</span></span><span><span>
</span></span><span><span>      <span>// Calculate the volume (RMS) of the current buffer.
</span></span></span><span><span><span></span>      <span>let</span> <span>rms</span> <span>=</span> <span>calculateRMS</span>(<span>inputData</span>);
</span></span><span><span>
</span></span><span><span>      <span>// Check if the volume exceeds the threshold.
</span></span></span><span><span><span></span>      <span>if</span> (<span>rms</span> <span>&gt;</span> <span>PITCH_VOLUME_THRESHOLD</span>) {
</span></span><span><span>        <span>// If the volume is above the threshold, we process the data to detect pitch.
</span></span></span><span><span><span></span>        <span>let</span> <span>pitch</span> <span>=</span> <span>mcleodPitchMethod</span>(<span>inputData</span>, <span>sampleRate</span>);
</span></span><span><span>        <span>console</span>.<span>log</span>(<span>&#34;Pitch:&#34;</span>, <span>pitch</span>);
</span></span><span><span>      } <span>else</span> {
</span></span><span><span>        <span>// If the volume is too low, skip processing and log a message.
</span></span></span><span><span><span></span>        <span>console</span>.<span>log</span>(<span>&#34;Volume too low. Skipping processing.&#34;</span>);
</span></span><span><span>      }
</span></span><span><span>    };
</span></span><span><span>  })
</span></span><span><span>  .<span>catch</span>((<span>err</span>) =&gt; {
</span></span><span><span>    <span>// Handle any errors that occur when trying to access the microphone.
</span></span></span><span><span><span></span>    <span>console</span>.<span>error</span>(<span>&#34;Error accessing the microphone&#34;</span>, <span>err</span>);
</span></span><span><span>  });
</span></span></code></pre></div><p>Thanks for reading. In part 2, we will discuss the concept of “Foments” and how they can also be a useful metric for voice training and continue from there.</p></div></div>
  </body>
</html>
