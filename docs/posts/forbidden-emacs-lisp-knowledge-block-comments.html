<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emacsninja.com/posts/forbidden-emacs-lisp-knowledge-block-comments.html">Original</a>
    <h1>Forbidden Emacs Lisp Knowledge: Block Comments</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>

<p><span>12/02/2022</span></p>


<p><strong>Note</strong>: The <tt>\037</tt> sequence appearing in the code snippets is one
character, escaped for readability.</p>
<p>It’s been eight years since I started using Emacs and Emacs Lisp and I
still keep running into dusty corners. Traditionally, Lisp dialects
use the semicolon for line comments, with block and s-expression
comments being optional features.</p>
<table>
<colgroup>
<col width="28%"/>
<col width="20%"/>
<col width="21%"/>
<col width="31%"/>
</colgroup>
<thead>
<tr><th>Dialect</th>
<th>Line comment</th>
<th>Block comment</th>
<th>S-expression comment</th>
</tr>
</thead>
<tbody>
<tr><td>Clojure, Hy</td>
<td><tt>;</tt></td>
<td>n/a</td>
<td><tt>#_</tt></td>
</tr>
<tr><td>Common Lisp<a href="#forbidden-emacs-lisp-knowledge-block-comments_footnote-1" id="forbidden-emacs-lisp-knowledge-block-comments_footnote-reference-1">[1]</a></td>
<td><tt>;</tt></td>
<td><tt><span>#|...|#</span></tt></td>
<td><tt><span>#+(or)</span></tt></td>
</tr>
<tr><td>Emacs Lisp, Lush</td>
<td><tt>;</tt></td>
<td>n/a</td>
<td>n/a</td>
</tr>
<tr><td>ISLisp, LFE, uLisp</td>
<td><tt>;</tt></td>
<td><tt><span>#|...|#</span></tt></td>
<td>n/a</td>
</tr>
<tr><td>NewLisp</td>
<td><tt>;</tt>, <tt>#</tt></td>
<td>n/a</td>
<td>n/a</td>
</tr>
<tr><td>Picolisp<a href="#forbidden-emacs-lisp-knowledge-block-comments_footnote-2" id="forbidden-emacs-lisp-knowledge-block-comments_footnote-reference-2">[2]</a></td>
<td><tt>#</tt></td>
<td><tt><span>#{...}#</span></tt></td>
<td>n/a</td>
</tr>
<tr><td>Racket, Scheme<a href="#forbidden-emacs-lisp-knowledge-block-comments_footnote-3" id="forbidden-emacs-lisp-knowledge-block-comments_footnote-reference-3">[3]</a></td>
<td><tt>;</tt></td>
<td><tt><span>#|...|#</span></tt></td>
<td><tt>#;</tt></td>
</tr>
<tr><td>TXR Lisp</td>
<td><tt>;</tt></td>
<td>n/a</td>
<td><tt>#;</tt></td>
</tr>
<tr><td>WAT<a href="#forbidden-emacs-lisp-knowledge-block-comments_footnote-4" id="forbidden-emacs-lisp-knowledge-block-comments_footnote-reference-4">[4]</a></td>
<td><tt>;;</tt></td>
<td><tt><span>(;...;)</span></tt></td>
<td>n/a</td>
</tr>
</tbody>
</table>
<p>Emacs Lisp is special though. Here’s an unusual section from <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Comments.html">the
Emacs Lisp reference on comments</a>:</p>
<blockquote>
The <tt>#@COUNT</tt> construct, which skips the next COUNT characters,
is useful for program-generated comments containing binary data.
The Emacs Lisp byte compiler uses this in its output files (see
“Byte Compilation”). It isn’t meant for source files, however.</blockquote>
<p>At first sight, this seems useless. This feature is meant to be used
in <tt>.elc</tt>, not <tt>.el</tt> files and looking at a file produced by the
byte compiler, its only use is to emit docstrings:</p>
<pre><span>;;; This file uses dynamic docstrings, first added in Emacs 19.29.</span>

<span>[</span><span>...</span><span>]</span>

<span>#</span><span>@11</span> <span>docstring\037</span>
<span>(</span><span>defalias</span> <span>&#39;my-test</span> <span>#</span><span>[</span><span>...</span><span>])</span>
</pre>
<p>This is kind of like a block-comment, except there is no comment
terminator. For this reason, the characters to be commented out need
to be counted. You’d think that the following would work, but it
fails with an “End of file during parsing” error:</p>
<pre><span>(</span><span>defvar</span> <span>my-variable</span> <span>#</span><span>@8</span> <span>(</span><span>/</span> <span>1</span> <span>0</span><span>)</span> <span>123</span><span>)</span>
</pre>
<p>It took me <a href="https://git.savannah.gnu.org/cgit/emacs.git/tree/src/lread.c?id=a602e86bc1c10f44dbe9d2680bece2f552a54707#n378">a dive into the reader</a> to find out why:</p>
<pre><span>#define FROM_FILE_P(readcharfun)                            \
  (EQ (readcharfun, Qget_file_char)                         \
   || EQ (readcharfun, Qget_emacs_mule_file_char))
</span><span>
</span><span>static</span><span> </span><span>void</span><span>
</span><span>skip_dyn_bytes</span><span> </span><span>(</span><span>Lisp_Object</span><span> </span><span>readcharfun</span><span>,</span><span> </span><span>ptrdiff_t</span><span> </span><span>n</span><span>)</span><span>
</span><span>{</span><span>
  </span><span>if</span><span> </span><span>(</span><span>FROM_FILE_P</span><span> </span><span>(</span><span>readcharfun</span><span>))</span><span>
    </span><span>{</span><span>
      </span><span>block_input</span><span> </span><span>();</span><span>                </span><span>/* FIXME: Not sure if it&#39;s needed.  */</span><span>
      </span><span>fseek</span><span> </span><span>(</span><span>infile</span><span>-&gt;</span><span>stream</span><span>,</span><span> </span><span>n</span><span> </span><span>-</span><span> </span><span>infile</span><span>-&gt;</span><span>lookahead</span><span>,</span><span> </span><span>SEEK_CUR</span><span>);</span><span>
      </span><span>unblock_input</span><span> </span><span>();</span><span>
      </span><span>infile</span><span>-&gt;</span><span>lookahead</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
    </span><span>}</span><span>
  </span><span>else</span><span>
    </span><span>{</span><span> </span><span>/* We&#39;re not reading directly from a file.  In that case, it&#39;s difficult
         to reliably count bytes, since these are usually meant for the file&#39;s
         encoding, whereas we&#39;re now typically in the internal encoding.
         But luckily, skip_dyn_bytes is used to skip over a single
         dynamic-docstring (or dynamic byte-code) which is always quoted such
         that \037 is the final char.  */</span><span>
      </span><span>int</span><span> </span><span>c</span><span>;</span><span>
      </span><span>do</span><span> </span><span>{</span><span>
        </span><span>c</span><span> </span><span>=</span><span> </span><span>READCHAR</span><span>;</span><span>
      </span><span>}</span><span> </span><span>while</span><span> </span><span>(</span><span>c</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span> </span><span>&amp;&amp;</span><span> </span><span>c</span><span> </span><span>!=</span><span> </span><span>&#39;\037&#39;</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>}</span>
</pre>
<p>Due to encoding difficulties, the <tt>#@COUNT</tt> construct is always used
with a terminating <tt>\037</tt> AKA unit separator character. While it
seems that the <tt>FROM_FILE_P</tt> macro applies when using the reader
with <tt><span>get-file-char</span></tt> or <tt><span>get-emacs-mule-file-char</span></tt> (which are used
by <tt>load</tt> internally), I never managed to trigger that code path.
The reader therefore seems to always ignore the count argument,
essentially turning <tt>#@COUNT</tt> into a block comment facility.</p>
<p>Given this information, one could obfuscate Emacs Lisp code to hide
something unusual going on:</p>
<pre><span>(</span><span>message</span> <span>&#34;Fire the %s!!!&#34;</span> <span>#</span><span>@11</span> <span>&#34;rockets&#34;</span><span>)</span><span>\037</span>

<span>(</span><span>reverse</span> <span>&#34;sekun&#34;</span><span>))</span>
</pre>
<p>A more legitimate usecase is <a href="https://stackoverflow.com/a/6259330/8729149">a multi-line shebang</a>:</p>
<pre><span>#</span><span>!/bin/sh</span>
<span>#</span><span>@0</span> <span>-*-</span> <span>emacs-lisp</span> <span>-*-</span>
<span>exec</span> <span>emacs</span> <span>-Q</span> <span>--script</span> <span>&#34;$0&#34;</span> <span>--</span> <span>&#34;$@&#34;</span>
<span>exit</span>
<span>#</span><span>\037</span>

<span>(</span><span>when</span> <span>(</span><span>equal</span> <span>(</span><span>car</span> <span>argv</span><span>)</span> <span>&#34;--&#34;</span><span>)</span>
  <span>(</span><span>pop</span> <span>argv</span><span>))</span>

<span>(</span><span>while</span> <span>argv</span>
  <span>(</span><span>message</span> <span>&#34;Argument: %S&#34;</span> <span>(</span><span>pop</span> <span>argv</span><span>)))</span>
</pre>
<p>In case you want to experiment with this and want to use the correct
counts, here’s a quick and dirty command:</p>
<pre><span>(</span><span>defun</span> <span>cursed-elisp-block-comment</span> <span>(</span><span>beg</span> <span>end</span><span>)</span>
  <span>(</span><span>interactive</span> <span>&#34;r&#34;</span><span>)</span>
  <span>(</span><span>save-excursion</span>
    <span>(</span><span>save-restriction</span>
      <span>(</span><span>narrow-to-region</span> <span>beg</span> <span>end</span><span>)</span>
      <span>(</span><span>goto-char</span> <span>(</span><span>point-min</span><span>))</span>
      <span>;; account for space and terminator</span>
      <span>(</span><span>insert</span> <span>(</span><span>format</span> <span>&#34;#@%d &#34;</span> <span>(</span><span>+</span> <span>(</span><span>-</span> <span>end</span> <span>beg</span><span>)</span> <span>2</span><span>)))</span>
      <span>(</span><span>goto-char</span> <span>(</span><span>point-max</span><span>))</span>
      <span>(</span><span>insert</span> <span>&#34;\037&#34;</span><span>))))</span>
</pre>
<p>There’s <a href="https://git.savannah.gnu.org/cgit/emacs.git/tree/src/lread.c?id=a602e86bc1c10f44dbe9d2680bece2f552a54707#n3297">one more undocumented feature though</a>, <tt>#@00</tt> is
special-cased as EOF comment:</p>
<pre><span>/* Read a decimal integer.  */</span><span>
</span><span>while</span><span> </span><span>((</span><span>c</span><span> </span><span>=</span><span> </span><span>READCHAR</span><span>)</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>
       </span><span>&amp;&amp;</span><span> </span><span>c</span><span> </span><span>&gt;=</span><span> </span><span>&#39;0&#39;</span><span> </span><span>&amp;&amp;</span><span> </span><span>c</span><span> </span><span>&lt;=</span><span> </span><span>&#39;9&#39;</span><span>)</span><span>
  </span><span>{</span><span>
    </span><span>if</span><span> </span><span>((</span><span>STRING_BYTES_BOUND</span><span> </span><span>-</span><span> </span><span>extra</span><span>)</span><span> </span><span>/</span><span> </span><span>10</span><span> </span><span>&lt;=</span><span> </span><span>nskip</span><span>)</span><span>
      </span><span>string_overflow</span><span> </span><span>();</span><span>
    </span><span>digits</span><span>++</span><span>;</span><span>
    </span><span>nskip</span><span> </span><span>*=</span><span> </span><span>10</span><span>;</span><span>
    </span><span>nskip</span><span> </span><span>+=</span><span> </span><span>c</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>digits</span><span> </span><span>==</span><span> </span><span>2</span><span> </span><span>&amp;&amp;</span><span> </span><span>nskip</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span>
      </span><span>{</span><span> </span><span>/* We&#39;ve just seen #@00, which means &#34;skip to end&#34;.  */</span><span>
        </span><span>skip_dyn_eof</span><span> </span><span>(</span><span>readcharfun</span><span>);</span><span>
        </span><span>return</span><span> </span><span>Qnil</span><span>;</span><span>
      </span><span>}</span><span>
  </span><span>}</span>
</pre>
<p>The EOF comment version can be used to create polyglots. An Emacs Lisp
script could end with <tt>#@00</tt>, then concatenated with a file
tolerating leading garbage. The ZIP format is known for its permissive
behavior, thereby allowing you to embed several resources into one
file:</p>
<pre><span>[wasa@box ~]$ </span>cat polyglot.el
<span>(message &#34;This could be a whole wordle game&#34;)</span>
<span><span>(message &#34;I&#39;ve attached some dictionaries for you though&#34;)</span><span>#</span>@00
<span>[wasa@box ~]$ </span>cat polyglot.el wordle.zip &gt; wordle.el
<span>[wasa@box ~]$ </span>file wordle.el
<span>wordle.el: data
</span><span>[wasa@box ~]$ </span>emacs --script wordle.el
<span>This could be a whole wordle game
I&#39;ve attached some dictionaries for you though
</span><span>[wasa@box ~]$ </span>unzip wordle.el
<span>Archive:  wordle.el
warning [wordle.el]:  109 extra bytes at beginning or within zipfile
  (attempting to process anyway)
  inflating: wordle.de
  inflating: wordle.uk</span>
</span></pre>
<p>This could be combined with the multi-line shebang trick to create a
<a href="https://en.wikipedia.org/wiki/Self-extracting_archive">self-extracting archive format</a>. Or maybe an installer? Or just a
script that can access its own resources? Let me know if you have any
interesting ideas.</p>





<hr/></article></div></div>
  </body>
</html>
