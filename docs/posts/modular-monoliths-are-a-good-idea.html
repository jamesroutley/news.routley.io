<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://materializedview.io/p/modular-monoliths-are-a-good-idea">Original</a>
    <h1>Modular Monoliths Are a Good Idea</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><p><em><span>I’ve been doing personal angel investing for several years. I’m excited to announce that I’ve launched </span><a href="https://materializedview.capital/" rel="">Materialized View Capital (MVC)</a><span>. MVC is a micro VC fund where I’ll continue investing in early stage infrastructure startups. I’ll also continue tagging any companies that I mention on my newsletter with a ﹩ if I’ve invested in them. Thanks for all your support!</span></em></p><p><em><span>In other news, my </span><a href="https://www.prefect.io/events/prefect-summit-2024" rel="">Prefect Summit 2024</a><span> keynote is up. Check out </span><a href="https://www.youtube.com/watch?v=8X0_RymDOHY" rel="">4 infrastructure trends in 20 minutes</a><span> to learn about primary persistence on object storage, composable databases, PostgreSQL&#39;s renaissance, and durable execution.</span></em></p><div id="youtube2-8X0_RymDOHY" data-attrs="{&#34;videoId&#34;:&#34;8X0_RymDOHY&#34;,&#34;startTime&#34;:null,&#34;endTime&#34;:null}" data-component-name="Youtube2ToDOM"><p><iframe src="https://www.youtube-nocookie.com/embed/8X0_RymDOHY?rel=0&amp;autoplay=0&amp;showinfo=0&amp;enablejsapi=0" frameborder="0" loading="lazy" gesture="media" allow="autoplay; fullscreen" allowautoplay="true" allowfullscreen="true" width="728" height="409"></iframe></p></div><p>It’s a story as old as time. A tech startup is born. Early engineers work night and day to build a product that customers want. They iterate furiously—adding new features and repurposing old code. No time to refactor; they need revenue. And then, if they’re lucky, miraculously, the startup gets customers. Product market fit is achieved, and it’s time to put the pedal to the metal. More customers, more features, more scale, and more engineers.</p><p>Somewhere along the way, the codebase goes from 100,000 lines to 10,000,000. The application that the early engineers built—a monolithic application in a single repository—is now a house of cards. Every change breaks something. It’s taking longer to build, test, and deploy. Even checking the code out is cause for a coffee break.</p><p>And then the FAANG engineers arrive. What are you even doing, they ask. You need scale, you need isolation, you need to decouple. You have a fever, and the only prescription is more microservices. And so the “escape the monolith” death march begins.</p><p>Scaling a monolith is hard, no doubt. To date, the only real tool we’ve had in our toolbox has been to switch to a service oriented architecture. Services can be built and deployed independently. This isolation keeps build times small, tests passing, and makes deployment easier.</p><p>At least that’s the pitch. In practice microservices can be just as tough to wrangle as monoliths. Services get tightly coupled; deploying a change in one can break another. Deploying 1000s of services independently requires an immense amount of tooling. Developers now need to spin up dozens of services to test locally, or manage their own cloud environment. Remote procedure call (RPC) frameworks need tooling to enforce compatible schema changes. Operations has to wrangle service meshes, distributed tracing, Kubernetes, Terraform, and so much more.</p><p><span>I’ve lived this story twice. First as an understudy at LinkedIn, then as an instigator at WePay. Both projects were brutal. At LinkedIn, we had to halt much of engineering for several months while we tore our monolith apart. Kevin Scott, our SVP of engineering wrote a great write-up about this in, </span><a href="https://www.linkedin.com/pulse/when-your-tech-debt-comes-due-kevin-scott/" rel="">When Your Tech Debt Comes Due</a><span>. At WePay, the monolith migration project never ended. I wrote WePay’s second microservice when I joined in 2015. When I left in 2021, the monolith still housed much of WePay’s core logic. I have microservice fatigue.</span></p><p><span>Yet, I don’t see a lot of alternative solutions being offered. So I’m pleased to see the </span><a href="https://www.milanjovanovic.tech/blog/what-is-a-modular-monolith" rel="">modular monolith</a><span> trend growing. The idea is to build a monolithic application as a </span><a href="https://www.thoughtworks.com/en-us/insights/blog/microservices/modular-monolith-better-way-build-software" rel="">series of modules</a><span>, each responsible for a portion of business logic. At first blush, this sounds silly. Isn’t this just good engineering? I was skeptical</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png" width="689" height="195" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:195,&#34;width&#34;:689,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:37154,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2b8c13b3-70c4-42de-ae0d-db293a8773b2_689x195.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>But the more I think about modular monoliths, the more excited I get. Yes, writing modular code is a good idea, and yes it’s obvious. Yet, we’re not doing it. Our monoliths always end up as spaghetti code. Rather than fixing the monolithic code, we’ve jumped straight to microservices. Why? I think the answer is tooling.</p><p>What might modular monolith tooling look like? Let’s start with the benefits that microservices confer: they can be built, tested, and deployed independently; they have isolated databases; and they have clear public APIs. To get similar characteristics from a monolith, developers need:</p><ul><li><p>Incremental build systems</p></li><li><p>Incremental testing frameworks</p></li><li><p>Branch management tooling</p></li><li><p>Code isolation enforcement</p></li><li><p>Database isolation enforcement</p></li></ul><p><span>Incremental build systems speed up monolithic build times. Rather than rebuilding an entire application, only the portions that change are rebuilt. Similarly, incremental testing allows developers and continuous integration (CI) systems to run tests only for the portion of the monolith that’s changed (including upstream and downstream dependencies). </span><a href="https://bazel.build/" rel="">Bazel</a><span> is doing a lot of work in this area.</span></p><p><span>Since all developers are committing to the same codebase, branch management is also important. There are many options here: </span><a href="https://docs.github.com/en/get-started/using-github/github-flow" rel="">GitHub Flow</a><span>, </span><a href="https://about.gitlab.com/topics/version-control/what-is-gitlab-flow/" rel="">GitLab Flow</a><span>, </span><a href="https://trunkbaseddevelopment.com/" rel="">Trunk-Based Development</a><span>, and so on.</span></p><p>By extension, CI tooling is important. If a developer breaks the monolith, they’ve broken it for everyone. Breaking builds must be quickly detected and fixed. Tools to predict whether a change is risky, to detect which change in a batch of commits broke the build, and to manage reverting or fixing forward are all required. Unlike incremental build and test, I find many teams are rolling their own scripts to manage such activities.</p><p><span>Changes that introduce new cross-module dependencies must be detected. Calls to non-public interfaces must be actively rejected. And code owners must be notified when new modules depend on their own modules. Code ownership files that define owners and approvers for each module must be added, and tooling built around them. </span><a href="https://gauge.sh" rel="">Gauge</a><span>﹩ is doing interesting work here with their open source dependency management tool, </span><a href="https://github.com/gauge-sh/tach/" rel="">Tach</a><span>.</span></p><p>Finally, monolithic databases need to be broken up. This is often the biggest chunk of work for any monolith migration. All parts of the codebase share a single ORM and assume they’re interacting with a single transactional database. Transaction boundaries must be defined and separated between modules. Tables must be grouped by module and isolated from other modules. Tables must then be migrated to separate schemas either on the same database or a separate one. I am not aware of any tools that help detect such boundaries and enforce isolation right now.</p><p><span>For monoliths just starting out, it would be great if full stack frameworks like </span><a href="https://nextjs.org/" rel="">Next.js</a><span>, </span><a href="https://redwoodjs.com/" rel="">Redwood.js</a><span>, </span><a href="https://rubyonrails.org/" rel="">Rails</a><span>, and others began to adopt modular concepts in their codebase. This would help developers writing new software to do the write thing from the get-go.</span></p><p>Best of all, I don’t see the modular monolith vs. microservices as an either-or choice. I see it as a stepping stone that can extend a monolith’s life. For some, the modular monolith might be all that’s needed. For others, it can provide a more natural transition to a service based architecture. Modular monolith tooling could even facilitate such a migration. And I suspect the result of a migration would be a well maintained monolith with 7 ± 2 services. I find such an architecture far more appealing than 1000s of services. We’ve spent decades building tooling for microservices. It’s time to give monoliths the same respect.</p><p><span>Support this newsletter by purchasing </span><a href="https://www.amazon.com/Missing-README-Guide-Software-Engineer/dp/1718501838" rel="">The Missing README: A Guide for the New Software Engineer</a><span> for yourself or gifting it to someone.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png" width="146" height="164.12413793103448" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/de442631-41a6-4119-a99a-62957cd53edb_870x978.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:978,&#34;width&#34;:870,&#34;resizeWidth&#34;:146,&#34;bytes&#34;:null,&#34;alt&#34;:&#34;&#34;,&#34;title&#34;:&#34;&#34;,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" title="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fde442631-41a6-4119-a99a-62957cd53edb_870x978.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p data-attrs="{&#34;url&#34;:&#34;https://www.amazon.com/Missing-README-Guide-Software-Engineer/dp/1718501838&#34;,&#34;text&#34;:&#34;Buy Now&#34;,&#34;action&#34;:null,&#34;class&#34;:&#34;button-wrapper&#34;}" data-component-name="ButtonCreateButton"><a href="https://www.amazon.com/Missing-README-Guide-Software-Engineer/dp/1718501838" rel=""><span>Buy Now</span></a></p><p><span>I occasionally invest in infrastructure startups. Companies that I’ve invested in are marked with a ﹩ in this newsletter. See my </span><a href="https://www.linkedin.com/in/riccomini/" rel="">LinkedIn profile</a><span> for a complete list.</span></p></div></div></div>
  </body>
</html>
