<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pkh.me/p/45-code-golfing-a-tiny-demo-using-maths-and-a-pinch-of-insanity.html">Original</a>
    <h1>Code golfing a tiny demo using maths and a pinch of insanity</h1>
    
    <div id="readability-page-1" class="page"><article><p>A few weeks ago, I made a tiny demo that fits into 462 characters:</p>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/red-alp.frag"></canvas>
  <figcaption>Red Alp GLSL demo in 462 characters</figcaption>
</figure>
<pre><code>void main(){vec3 c,p,K=vec3(3,1,0);for(float i,a,g=1.,t,h,d,w,k=.15;i++&lt;1e2;d=
max(max(d-3.,-d),0.)*k,w=g-g/exp(mix(h*3e2,d*2.5,a=h&lt;.001?0.:1.)),g-=a*=w,c+=a*
d*9.+(d==0.?K*.01*h:c-c),a=min(p.y+2.,1.),c.r+=w*a*a*.2,t+=min(h*.2,k*=1.015),
p=normalize(vec3(P+P-R,R.y))*t,p.xz*=mat2(cos(sin(T*.2)+K.zyxz*11.)),p.z+=T*.3)
for(d=p.y,h=d+.5,a=.01;a&lt;1.;a+=a)p.xz*=mat2(8,6,-6,8)*.1,d+=abs(dot(sin((p/a+T)
*.3),p/p))*a,h+=abs(dot(sin(p.xz*.6/a),P/P))*a;O=vec4(tanh(c*.5),1);}
</code></pre>
<p>There is no texture, no mesh, no 3D helper: it&#39;s simply a procedural
mathematical formula evaluated at each pixel assigning them a color. Code
golfing is about making it as short as possible, and thus is part of the art
performance.</p>
<p>To put things into perspective, the 853x480 JPEG thumbnail of this article is
162x larger than this code.</p>
<p>You can watch a larger version on <a href="https://b.pkh.me/2025-09-08-red-alp.htm">its main dedicated page</a>, or a
portage on <a href="https://www.shadertoy.com/view/WflfR8">Shadertoy</a> (506 chars). If your device is not powerful
enough (I&#39;m sorry for the lag on this page) or doesn&#39;t support WebGL2, a short
preview video can be seen on <a href="https://fosstodon.org/@bug/115168470956294772">Mastodon</a>.</p>
<p>I&#39;m guessing the wizardry of the code has confused many people so we&#39;re going
to dive through the making-of together. Overall, this demo is a particularly
dense and entangled compilation of different techniques, where each aspect could
mandate a dedicated article. For that reason, some parts will prefer to link to
external resources when the literacy is verbose on the subject.</p>
<div>
<p>Warning</p>
<p>Some demos in this article will start &#34;decaying&#34; over time due to floating
point variables getting too large. Reloading the page should fix that.</p>
</div>
<h2>The base template</h2>
<p>The code is written in GLSL and is executed for each pixel (technically each
fragment) on a simple quad geometry (to be accurate it&#39;s even <a href="https://wallisc.github.io/rendering/2021/04/18/Fullscreen-Pass.html">a single big
triangle</a>). There is no geometry aside from that, it&#39;s basically just
a fragment shader.</p>
<p>The fragment receives 3 different inputs:</p>
<ul>
<li>the canvas resolution <code>vec2 R</code></li>
<li>the time <code>float T</code></li>
<li>the pixel position <code>vec2 P</code> (basically <code>gl_FragCoord.xy</code>)</li>
</ul>
<p>And it has to output a sRGB color in <code>out vec3 O</code>. The code has to be written in
a <code>void main()</code> function, and that&#39;s pretty much all we need to start.</p>
<p>If you&#39;re curious about the glue to setup WebGL2, just look at the source code
on <a href="https://b.pkh.me/2025-09-08-red-alp.htm">the dedicated page</a>. There is no external dependency and the canvas
setup code is pretty simple.</p>
<h2>Development setup</h2>
<p>For development, people usually directly use Shadertoy. I prefer to use
my own local live coding environment: <a href="https://github.com/ubitux/ShaderWorkshop">ShaderWorkshop</a>. It can be run
without setting up anything, just <code>uv run --with shader-workshop sw-server</code>
(assuming the <code>uv</code> Python package manager is installed on the machine).
Aside from the comfort of being able to use your favorite code editor, it
allows instancing live controls for uniforms very easily, making it smooth to
interact with any value and get an immediate feedback.</p>
<figure>
    <img src="https://blog.pkh.me/img/demomaking/shader-workshop.png" alt=""/>
    <figcaption>Red Alp demo with user controls as seen from ShaderWorkshop</figcaption>
</figure>
<h2>Noise</h2>
<p>One of the core primitive we need is a noise function: it is required for the
mountains, the fog, and the clouds.</p>
<p>In a recent article, I <a href="https://blog.pkh.me/p/42-sharing-everything-i-could-understand-about-gradient-noise.html">talked about gradient noise</a>. We could
technically use that, but it will have a lot of drawbacks. First of all, it&#39;s
super expensive. I know because I made a demo using it the other day, and it was
awfully slow. Once per pixel would be fine, but in our case it will have to be
evaluated a hundred times, so we need something faster.</p>
<p>Secondly, we&#39;re trying to make it as short as possible, and the 2D gradient
noise, even minified, is already twice as big as the size of the full demo. We
will also need a 3D noise for the clouds and fog, which is even larger and more
expensive. And that&#39;s not even accounting for the fbm signal combination code.</p>
<p>Inigo Quilez, in his famous <a href="https://www.shadertoy.com/view/4ttSWf">Rainforest</a>, used value noise. It is faster, but
it still won&#39;t do for us for the same reasons, just somehow mitigated. And since
we&#39;re professionals, we&#39;re not going to cheat by sampling a noise texture.</p>
<p>Fortunately, while reverse engineering some Shadertoy demos, in particular the
ones from <a href="https://www.shadertoy.com/user/diatribes">diatribes</a>, I came across some code that made use of this incredible
technique of accumulating sine waves.</p>
<h3>Combining sin waves</h3>
<p>Let&#39;s say we want to combine two sine waves in order to get a height map as a
3rd dimension. There are multiple ways of achieving that. For example, we can
multiply them:</p>
<p>
z = \sin x \times \sin y
</p>

<p>But we could also add them together:</p>
<p>
z = \sin x + \sin y
</p>

<p>The surprising take here is that... it&#39;s pretty much equivalent. It doesn&#39;t give
the same result for sure, but visually it could be considered the same, just
with a frequency and amplitude a bit different, and rotated on the z axis by 45°.</p>
<p>Similarly, you may think using cosines instead of sinusoids would make a
difference, but no, even when combined together, they always give the same base
pattern we just saw.</p>
<p>
z = \sin x + \cos y
</p>

<p>So let&#39;s pick one, let&#39;s say <span>z=\sin x + \sin y</span>. But this time, we&#39;re going to
take the absolute value to transform the up and down pattern into bumps:</p>
<p>
z = |\sin x + \sin y|
</p>

<p>These bumps are the perfect base for clouds, but not so much for spiky mountains
going through aggressive erosion. But with the help of this weird little trick,
we can just flip the shape upside down to get sharp edges:</p>
<p>
z = -|\sin x + \sin y|
</p>

<p>We now have the basis for both our clouds and mountains, but it&#39;s not yet
convincing. The next step is to use the fbm loop as if we were dealing with
Gaussian or value noise: we accumulate several frequencies of our signal
together:</p>
<p>
z = S \sum_{i=0}^{N-1} F(\begin{bmatrix}x \\ y\end{bmatrix} \cdot l^{i}) g^{i}
</p>
<ul>
<li><span>S</span> is the sign (-1 for spiky, 1 for bobby)</li>
<li><span>i</span> is the octave identifier going from 0 to <span>N-1</span> (included).</li>
<li><span>F(x,y)</span> is usually the noise signal function, in our case it&#39;s the sinusoid
combination function, we choose <span>|\sin x + \sin y|</span> here.</li>
<li><span>l</span> is the lacunarity factor, that is how frequency changes at each
octaves; this is usually a multiply by 2 or a close value.</li>
<li><span>g</span> is the gain, that is by how the amplitude changes at each octaves; this is
usually a multiply by 0.5 or a close value.</li>
</ul>

<p>Without surprise this is still very periodic, but we can see a glimpse of chaos
emerging. The final touch does all the magic: all we have to do now is simply
rotate each layer by like, 30° or something (I&#39;ll pick 0.5 radians here, or
about 29°):</p>

<p>The symmetry around the origin is still noticeable, but the illusion will work
as we will move away from it. It&#39;s also possible to add some phase or offsetting
(arbitrary addition within the <code>sin</code> or between each layer).</p>
<p>I implemented this in a <a href="https://www.desmos.com/3d/odvwh2ttdb">Desmos 3D scene</a> with all the
parameters if one wants to play with it. The formula there has a few more
controls, for example the vertical location, an optional transition offset in
addition to the rotation, and controls for the base frequency and amplitude.</p>
<p><img src="https://blog.pkh.me/img/demomaking/desmos.png" alt="Screenshot of fake noise in Desmos 3D"/></p>
<p>If this mathematical gibberish is above your head, a GLSL code for the 2D noise
could look like this with a lacunarity of 2, a gain of 0.5 and 5 octaves:</p>
<pre><code>float noise(vec2 p) {
    float v = 0.0;
    float amplitude = 1.0;
    for (int i = 0; i &lt; 5; i++) {
        p = rotate(0.5) * p; // rotate our space (more on this in the next section)
        v += abs(sin(p.x) + sin(p.y)) * amplitude; // accumulate noise
        p *= 2.0; // double the frequency at each octave
        amplitude *= 0.5; // half the amplitude at each octave
    }
    return v;
}
</code></pre>
<p>One cool trick here: <code>abs(sin(p.x)+sin(p.y))</code> could also be written
<code>abs(dot(sin(p),vec2(1)))</code>. This is interesting because now we can operate on
the two components of <code>p</code>, easing the possibility to modify them at once (for
example doing <code>p*A+B</code>). The <code>dot</code> trick doesn&#39;t work with <code>sin(p.x)*sin(p.y)</code>,
but fortunately, as we saw before, multiply and addition are similar and could
be swapped in various situations.</p>
<h2>Rotations</h2>
<p>We needed some rotation for the noise, and they will be required again soon, so
we need to have a closer look to them. Let&#39;s start with the formula most people
are familiar with:</p>
<p>
M =
\begin{bmatrix}
    \cos \theta &amp; -\sin \theta \\
    \sin \theta &amp; \cos \theta
\end{bmatrix}
</p>
<p>A matrix can be seen as a function, so mathematically writing <span>p&#39;=M \cdot p</span>
would be equivalent to the code <code>p=rotate(angle)*p</code> with:</p>
<pre><code>// Matrix for a counter-clockwise rotation
mat2 rotate(float a) {
    return mat2(
        cos(a), sin(a), // column 1
       -sin(a), cos(a)  // column 2
    );
}
</code></pre>
<p>Doing <span>p&#39;=M \cdot p</span> is rotating the <em>space</em> <span>p</span> lies into, which means it gives
the illusion the <em>object</em> is rotating <strong>clockwise</strong>. Though, in the expression
<code>p=rotate(angle)*p</code>, I can&#39;t help but be bothered by the redundancy of <code>p</code>,
so I would prefer to write <code>p*=rotate(angle)</code> instead. Since matrices are
not commutative, this will instead do a <strong>counter-clockwise</strong> rotation of the
object. The inlined rotation ends up being:</p>
<pre><code>p *= mat2(cos(a),sin(a),-sin(a),cos(a)); // counter-clockwise rotation of object at point p
</code></pre>
<div>
<p>Note</p>
<p>To make the rotation clockwise, we can of course use <code>-a</code>, or we can
transpose the matrix: <code>mat2(cos(a),-sin(a),sin(a),cos(a))</code>.</p>
</div>
<p>This is problematic though: we need to repeat the angle 4 times, which can be
particularly troublesome if we want to create a macro and/or don&#39;t want an
intermediate variable for the angle. But I got you covered: trigonometry has a
shitton of identities, and we can express every <code>sin</code> according to a <code>cos</code> (and
the other way around).</p>
<p>For example, here is another formulation of the same expression:</p>
<pre><code>p *= mat2(cos(a + vec4(0,3,1,0)*PI/2.0));
</code></pre>
<p>Now the angle appears only once, in a vectorized cosine call.</p>
<p>GLSL has <code>degrees()</code> and <code>radians()</code> functions, but it doesn&#39;t expose anything
for <span>\pi</span> nor <span>\tau</span> constants. And of course, it doesn&#39;t have <code>sinpi</code> and
<code>cospi</code> implementation either. So it&#39;s obvious they want us to use <span>\arccos(-1)</span>
for <span>\pi</span> and <span>\arccos(0)</span> for <span>\pi/2</span>:</p>
<pre><code>p *= mat2(cos(a + vec4(0,3,1,0)*acos(0.)));
</code></pre>
<div>
<p>Note</p>
<p>To specify <code>a</code> as a normalized value, we can use
<code>mat2(cos((a*4.+vec4(0,3,1,0))*acos(0.)))</code>.</p>
</div>
<p>On his Unofficial Shadertoy blog, Fabrice Neyret goes further and provide us
with <a href="https://shadertoyunofficial.wordpress.com/#vector-maths">a very cute approximation</a>, which is the one we will use:</p>
<pre><code>p *= mat2(cos(a + vec4(0,11,33,0)));
</code></pre>
<p>I <a href="https://github.com/ubitux/research/blob/main/misc/rotation-approx.py">checked for the best numbers in 2 digits</a>, and I can confirm
they are indeed the ones providing the best accuracy.</p>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/rotations-precision.frag"></canvas>
  <figcaption>Comparison of the 2 rotations matrices</figcaption>
</figure>
<p>On this last figure, the slight red/green on the outline of the circle
represents the loss of precision.</p>
<div>
<p>Note</p>
<p>With 3 digits, <code>344</code> and <code>699</code> can respectively be used instead of <code>11</code>
and <code>33</code>.</p>
</div>
<p>This is good when we want a dynamic rotation angle (we will need that for the
camera panning typically), but sometimes we just need a hardcoded value: for
example in the <code>rotate(0.5)</code> of our combined noise function.</p>
<p><code>mat2(cos(.5+vec4(0,11,33,0)))</code> is fine but we can do better. Through Inigo&#39;s
demos I found the following: <code>mat2(.8,.6,-.6,.8)</code>. It makes a rotation angle of
about 37° (around 0.64 radians) in a very tiny form. Since 0.5 was pretty much
arbitrary, we can just use this matrix as well. And we can make it even smaller
(thank you <a href="https://www.shadertoy.com/user/jolle">jolle</a>):</p>
<pre><code>p *= mat2(8,6,-6,8)*.1; // rotate p counter-clockwise by about 37° without any trigo
</code></pre>
<p>One last rotation tip from Fabrice&#39;s bag of tricks: rotating in 3D around an
axis can be done with the help of GLSL swizzling:</p>
<pre><code>p.xz *= rotate(0.5); // 3D rotation around y-axis (the absent component)
</code></pre>
<p>We will use this too.</p>
<div>
<p>Note</p>
<p><code>p.zy *= rotate(.5)</code> is the same <code>p.yz *= rotate(-.5)</code>, if we need to save
one character and can&#39;t transpose the matrix.</p>
</div>
<h2>Camera (and axis) setup</h2>
<p>One last essential before going creative is the camera setup.</p>
<p>We start with the 2D <code>P</code> pixel coordinates which we are going to make resolution
independent by transforming them into a traditional mathematical coordinates
system:</p>
<pre><code>// 1:1 ratio with [-1,1] along the shortest axis (horizontal or vertical)
vec2 u = (2.0*P - R) / min(R.x, R.y);
</code></pre>
<p><img src="https://blog.pkh.me/img/demomaking/coords-system.png" alt="coordinate system"/></p>
<p>Since we know our demo will be rendered in landscape mode, dividing by <code>R.y</code>
is enough. We can also save one character using <code>P+P</code>:</p>
<pre><code>// 1:1 ratio with [-1,1] along the vertical axis
vec2 u = (P+P - R) / R.y;
</code></pre>
<p>To enter 3D space, we append a third component, giving us either a right or a
left-handed Y-up coordinates system. This choice is not completely random.</p>
<p>Indeed, it&#39;s easier/shorter to add a 3rd dimension at the end compared
to interleaving a middle component. Compare the length of <code>vec3(P, z)</code> to
<code>vec3(P.x, z, P.y)</code> (Z-up convention). In the former case, picking just a plane
remains short and easy thanks to swizzling: <code>p.xz</code> instead of <code>p.xy</code>.</p>
<p>To work in 3D, we need an origin point (<code>ro</code> for ray origin) and a looking
direction (<code>rd</code> for ray direction). <code>ro</code> is picked arbitrarily for the eye
position, while <code>rd</code> is usually calculated thanks to a <code>lookAt</code> helper:</p>
<pre><code>// Right-hand with Y-up (like Godot)
mat3 lookAt(vec3 origin /* where we are */, vec3 target /* where we look */) {
    vec3 w = normalize(target - origin);
    vec3 u = normalize(cross(w, vec3(0,1,0)));
    vec3 v = normalize(cross(u, w)); // Note: normalize() can be ditched here
    return mat3(u, v, w);
}
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/coord-system.frag"></canvas>
  <figcaption>Right-hand Y-up 3D coordinates system</figcaption>
</figure>
<p>Which is then used like that, for example:</p>
<pre><code>vec2 u = (P+P - R) / R.y;
vec3 target = /* ... */;
vec3 ro = /* ... */;
vec3 rd = normalize(lookAt(ro, target) * vec3(u, 1));
</code></pre>
<div>
<p>Note</p>
<p>I made a <a href="https://www.shadertoy.com/view/wcfBRS">Shadertoy demo</a> to experiment with different
3D coordinate spaces if you are interested in digging this further.</p>
</div>
<p>All of this is perfectly fine because it is flexible, but it&#39;s also way too much
unnecessary code for our needs, so we need to shrink it.</p>
<p>One approach is to pick a simple origin and straight target point so that the
matrix is as simple as possible. And then later on apply some transformations on
the point. If we give <code>ro=vec3(0)</code> and <code>target=vec3(0,0,1)</code>, we end up with an
identity matrix, so we can ditch everything and just write:</p>
<pre><code>vec3 rd = normalize(vec3((P+P - R) / R.y, 1));
</code></pre>
<p>This can be shorten further: since the vector is normalized anyway, we can scale
it at will, for example by a factor <code>R.y</code>, saving us precious characters:</p>
<pre><code>vec3 rd = normalize(vec3(P+P - R, R.y));
</code></pre>
<p>And just like that, we are located at the origin <code>vec3(0)</code>, looking toward Z+,
ready to render our scene.</p>
<h2>Mountain height map</h2>
<p>It&#39;s finally time to build our scene. We&#39;re going to start with our <code>noise</code>
function previously defined, but we&#39;re going tweak it in various ways to craft a
mountain height map function.</p>
<p>Here is our first draft:</p>
<pre><code>const float mountain_y = -0.5; // mountain y-axis position
const float mountain_f = 0.6; // mountain base frequency

float mountain_height_map(vec2 p) {
    float h = mountain_y;
    for (float a = 1.0; a &gt; 0.01; a /= 2.0) {
        p *= rotate(0.5);
        h += abs(dot(sin(p*mountain_f / a), vec2(1))) * a; // dot(sin(v),1) -&gt; sin(v.x)+sin(v.y)
    }
    return -h; // minus for the spiky version of the noise
}
</code></pre>
<p>We&#39;re exploiting one important correlation of the noise function: at every
octave, the amplitude is halving while the frequency is doubling. So instead
of having 2 running variables, we just have an amplitude <code>a</code> getting halved
every octave, and we <em>divide</em> our position <code>p</code> by <code>a</code> (which is the same as
multiplying by a frequency that doubles itself).</p>
<p>I actually like this way of writing the loop because we can stop the loop
when the amplitude is meaningless (<code>a&gt;0.01</code> acts as a precision stopper).
Unfortunately, we&#39;ll have to change it to save one character: <code>a/=2.</code> is too
long for the iteration, we&#39;re going to double instead by using <code>a+=a</code> which
saves one character. So instead the loop will be written the other way around:
<code>for (float a=.01; a&lt;1.; a+=a)</code>. It&#39;s not exactly equivalent, but it&#39;s good
enough (and we can still tweak the values if necessary).</p>
<p>We&#39;re going to inline the constants and rotate, and use one more cool trick:
<code>vec2(1)</code> can be shortened: we just need another <code>vec2</code>. Luckily we have <code>p</code>,
so we can simply write <code>p/p</code>. Similarly, if we needed <code>0</code> we could have written
<code>p-p</code> (it works also like that: <code>p-p+.3</code> to shorten <code>vec2(.3)</code>). We can also get
rid of the braces of the <code>for</code> loop by using the <code>,</code> in its local scope.</p>
<p>In the end, this is our function:</p>
<pre><code>float mountain_height_map(vec2 p) {
    float h = -.5;
    for (float a=.01; a&lt;1.; a+=a)
        p *= mat2(8,6,-6,8)*.1,
        h += abs(dot(sin(p*.6/a), p/p))*a;
    return -h;
}
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/hmap.frag"></canvas>
  <figcaption>Mountain height map in 2D (rescaled for display)</figcaption>
</figure>
<p>To render this in 3D, we are going to do some ray-marching.</p>
<h2>Solid ray-marching</h2>
<p>The main technique used in most Shadertoy demos is ray-marching. I will assume
familiarity with the technique, but if that&#39;s not the case, <a href="https://www.youtube.com/watch?v=khblXafu7iA">An introduction
to Raymarching (YouTube)</a> by kishimisu and <a href="https://blog.maximeheckel.com/posts/painting-with-math-a-gentle-study-of-raymarching/">Painting with Math:
A Gentle Study of Raymarching</a> by Maxime Heckel were good
resources for me.</p>
<p>In short: we start from a position in space called the ray origin <code>ro</code> and we
project it toward a ray direction <code>rd</code>. At every iteration we check the distance
to the closest solid in our scene, and step toward that distance, hoping to
converge closer and closer to the object boundary.</p>
<p>We end up with this main loop template:</p>
<pre><code>float t = 0.0;

vec3 ro = vec3(0); // ray origin
vec3 rd = normalize(vec3(P+P - R, R.y)); // ray direction

// 100 iterations should be enough to hit something if there is any
for (int i = 0; i &lt; 100; i++) {
    vec3 p = ro + rd*t; // t amount in rd direction from ro origin
    float h = distance_to_solid(p); // 3D distance function
    if (h &lt; 0.001) { // we converged close enough to a solid
        // Here we assign a color according to where p is
        // [...]
        break;
    }
    t += h; // there is no solid closer than h so we step by that much
}
</code></pre>
<p>This works fine for solids expressed with <a href="https://iquilezles.org/articles/distfunctions/">3D distance fields</a>, that is
functions that for a given point give the distance to the object. We will use
it for our mountain, with one subtlety: the noise height map of the mountain
is not exactly a distance (it is only the distance to what&#39;s below our current
point <code>p</code>):</p>
<pre><code>float distance_to_solid(vec3 p) { // positive outside, negative inside
    return p.y - mountain_height_map(p.xz);
}
</code></pre>
<p>Because of this, we can&#39;t step by the distance directly, or we&#39;re likely to go
through mountains during the stepping (<code>t += h</code>). A common workaround here is to
step a certain percentage of that distance to play it safe.</p>
<p>Technically we should <a href="https://www.peterstefek.me/ray-marching-heightfields.html">figure out the theorical proper shrink
factor</a>, but we&#39;re going to take a shortcut today and just
arbitrarily cut. Using trial and error I ended up with 20% of the distance.</p>
<p>After a few simplifications, we end up with the following (complete) code:</p>
<pre><code>float mountain_height_map(vec2 p) {
    float h = .5;
    for (float a=.01; a&lt;1.; a+=a)
        p *= mat2(8,6,-6,8)*.1,
        h += abs(dot(sin(p*.6/a), p/p))*a;
    return -h;
}

float distance_to_solid(vec3 p) {
    return p.y - mountain_height_map(p.xz);
}

void main() {
    vec3 rd = normalize(vec3(P+P - R, R.y));

    float t = 0.0, color = 0.0;
    for (int i = 0; i &lt; 100; i++) {
        vec3 p = rd*t;

        p.z += T*.2; // move ahead (also prevents undefined behavior when doing p/p)

        float h = distance_to_solid(p);
        if (h &lt; 0.001) {
            color = exp(-t*t*.01); // depth map like &#34;coloring&#34;
            break;
        }
        t += h * 0.2;
    }

    O = vec4(vec3(pow(color, 3.0/2.2)), 1);
}
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/hmap3d.frag"></canvas>
  <figcaption>Basic ray-marching of the mountain height map</figcaption>
</figure>
<p>We start at <code>ro=vec3(0)</code> so I dropped the variable entirely. Also, to avoid
the division by 0 in <code>p/p</code> in <code>mountain_height_map</code>, <code>p</code> is moved right at the
beginning (we could also initialize <code>t</code> to a value slightly different than 0).</p>
<p>You may be curious about the power at the end; this is just a combination
of luminance perception with gamma 2.2 (sRGB) transfer function. It only
works well for grayscale; for more information, see <a href="https://blog.pkh.me/p/43-the-current-technology-is-not-ready-for-proper-blending.html">my previous article on
blending</a>.</p>
<h2>Clouds and fog</h2>
<p>Compared to the mountain, the clouds and fog will need a 3 dimensional noise.
Well, we don&#39;t need to be very original here; we simply extend the 2D noise
to 3D:</p>
<pre><code>float noise3(vec3 p) {
    float v;
    for (float a=.01; a&lt;1.; a+=a)
        p.xz *= mat2(8,6,-6,8)*.1,
        v += abs(dot(sin(p*.3/a + T*.3), p/p))*a;
    return v;
}
</code></pre>
<p>The base frequency is lowered to <code>0.3</code> to make it smoother, and the <code>p</code> goes
from 2 to 3 dimensions. Notice how the rotation is only done on the y-axis, the
one pointing up): don&#39;t worry, it&#39;s good enough for our purpose.</p>
<p>We also add a phase (meaning we are offsetting the sinusoid) of <code>T*0.3</code> (<code>T</code> is
the time in seconds, slowed down by the multiply) to slowly morph it over time.
The base frequency and time scale being identical is a happy &#34;coincidence&#34; to be
factored out later (I actually forgot about it until <a href="https://www.shadertoy.com/user/jolle">jolle</a> reminded me of it).</p>
<p>You also most definitely noticed <code>v</code> isn&#39;t explicitly initialized: while only
true WebGL, it <a href="https://registry.khronos.org/webgl/specs/latest/1.0/#6.39">guarantees zero initialization</a> so we&#39;re saving a
few characters here.</p>
<h2>Volumetric ray-marching</h2>
<p>For volumetric material (clouds and fog), the loop is a bit different: instead
of calculating the distance to the solid for our current point <code>p</code>, we do
compute the density of our target &#34;object&#34;. Funny enough, it can be thought
as a 3D SDF but with the sign flipped: positive inside (because the density
increases as we go deeper) and negative outside (there is no density, we&#39;re not
in it).</p>
<pre><code>const float clouds_y = 3.0; // vertical position

float clouds_density(vec3 p) {
    float n = noise3(p);     // random value associated with a 3D position in space
    float h = -clouds_y + n; // similar to mountain_height_map() but 3d and bobby
    float d = p.y - h;       // similar to distance_to_solid()
    d = -d;                  // flip sign: distance to density
    // We are only interested in the density within the material,
    // the density will be considered 0 when outside of it.
    return max(d, 0.0);
}
</code></pre>
<p>For simplicity, we&#39;re going to rewrite the function like this:</p>
<pre><code>const float clouds_y = 3.0;

float clouds_density(vec3 p) {
    float n = noise3(p);
    float d = -p.y - cloud_y + n;
    return max(d, 0.0);
}
</code></pre>
<p>Compared to the solid ray-marching loop, the volumetric one doesn&#39;t bail out
when it reaches the target. Instead, it slowly steps into it, damping the light
as the density increases:</p>
<pre><code>const float absorption = 0.15;
const float radiance   = 1.0;

void main() {
    float step_len = 0.15;
    float t;

    vec3 rd = normalize(vec3(P+P-R,R.y));
    vec3 color;

    float transmittance = 1.0; // remaining visibility
    for (int i = 0; i &lt; 100; i++) {
        vec3 p = rd*t;

        // Move camera forward
        p.z += T * 1.5;

        // How many particules of the material we can find at that position
        // If negative, we&#39;re not in the element yet, otherwise it&#39;s the density
        // (getting higher as we go deeper into it typically).
        float d = clouds_density(p);

        // Integrate the density discretely: we assume the segment of length
        // we&#39;re walking has the same point density all along
        d *= step_len;

        // The fraction of light that survives through this segment (Beer-Lambert law)
        // The denser, the closer to 0 this gets
        float attenuation = exp(-d*absorption);

        float emission = d*radiance; // how much light is emitted along the segment (glow)
        float alpha = 1.0 - attenuation; // fraction of light removed for that given density segment

        float weight = alpha * transmittance;

        // Accumulate color emission
        color += weight * emission;

        transmittance -= weight; // could also be written transmittance *= attenuation

        // Normal volumetric marching (step_len) clamped to the distance to the
        // solid (mountain)
        t += step_len;

        // Larger volumetric steps as we go far
        step_len *= 1.015;
    }

    O = vec4(pow(color, vec3(3.0/2.2)), 1);
}
</code></pre>
<p>The core idea is that the volumetric material emit some radiance but also
absorbs the atmospheric light. The deeper we get, the smaller the transmittance
gets, til it converges to 0 and stops all light. All the threshold you see are
chosen by tweaking them through trial and error, not any particular logic. It is
also highly dependent on the total number of iterations.</p>
<div>
<p>Note</p>
<p>Steps get larger and larger as the distance increases; this is because we
don&#39;t need as much precision per &#34;slice&#34;, but we still want to reach a long
distance.</p>
</div>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/clouds.frag"></canvas>
  <figcaption>Basic volumetric ray-marching of the clouds density map</figcaption>
</figure>
<p>We want to be positioned below the clouds, so we&#39;re going to need a simple sign
flip in the function.</p>
<p>The fog will take the place at the bottom, except upside down (the
sharpness will give a mountain-hug feeling) and at a different position.
<code>clouds_density()</code> becomes:</p>
<pre><code>const float clouds_y = 3.0;
const float fog_y    = 0.0;

float clouds_fog_density(vec3 p) {
    float n = noise3(p);

    float clouds_d = p.y - clouds_y + n;
    float fog_d    = p.y - fog_y    + n;

    // Pick the element with the highest density (they don&#39;t overlap anyway)
    float d = max(clouds_d, -fog_d);

    return max(d, 0.0);
}
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/cloudsfog.frag"></canvas>
  <figcaption>Both clouds and fog with volumetric ray-marching</figcaption>
</figure>
<h2>Combining ray-marching</h2>
<p>Having a single ray-marching loop combining the two methods (solid and
volumetric) can be challenging. In theory, we should stop the marching when we
hit a solid, bail out of the loop, do some fancy normal calculations along with
light position. We can&#39;t afford any of that, so we&#39;re going to start doing art
from now on.</p>
<p>We start from the volumetric ray-marching loop, and add the distance to the
mountain:</p>
<pre><code>for (int i = 0; i &lt; 100; i++) {
    vec3 p = rd*t;

    // ...

    float d = clouds_fog_density(p);
    float h = distance_to_solid(p);

    // ...
}
</code></pre>
<p>If <code>h</code> gets small enough, we can assume we hit a solid:</p>
<pre><code>bool solid = h &lt; 0.001;
</code></pre>
<p>In volumetric, the attenuation is calculated with the Beer-Lambert law. For solid,
we&#39;re simply going to make it fairly high:</p>
<pre><code>-    float attenuation = exp(-d*absorption);
+    float attenuation = solid ? 0.95 : exp(-d*absorption);
</code></pre>
<p>This has the effect of making the mountain like a very dense gas.</p>
<p>We&#39;re also going to disable the light emission from the solid (it will be
handled differently down the line):</p>
<pre><code>-    float emission = d*radiance;
+    float emission = solid ? 0.0 : d*radiance;
</code></pre>
<p>The transmittance is not going to be changed when we hit a solid as we just want
to accumulate light onto it:</p>
<pre><code>-    transmittance -= weight;
+    if (!solid) transmittance -= weight;
</code></pre>
<p>Finally, we have to combine the volumetric stepping (<code>t += step_len</code>) with the
solid stepping (<code>t += h*0.2</code>) by choosing the safest step length, that is the
minimum:</p>
<pre><code>-    t += step_len;
+    t += min(h*0.2, step_len);
</code></pre>
<p>We end up with the following:</p>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/comb0.frag"></canvas>
  <figcaption>Combination of volumetric and solid ray-marching</figcaption>
</figure>
<p>We can notice the mountain from negative space and the discrete presence of the
fog, but it&#39;s definitely way too dark. So the first thing we&#39;re going to do is boost
the radiance, as well as the absorption for the contrast:</p>
<pre><code>-const float absorption = 0.15;
-const float radiance   = 1.0;
+const float absorption = 2.5;
+const float radiance   = 9.0;
</code></pre>
<p>This will make the light actually overshoot, so we also have to replace
the current gamma 2.2 correction with a <a href="https://mini.gmshaders.com/p/func-tanh">cheap and simple tone mapping
hack</a>: <code>tanh()</code>. Halving the color is yet another tweak that is not
obtained on anything but trial and error. There might be clever ways to reach
the same result, but I leave that up to the reader:</p>
<pre><code>-    O = vec4(pow(color, vec3(3.0/2.2)), 1);
+    O = vec4(tanh(color * 0.5), 1);
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/comb1.frag"></canvas>
  <figcaption>Tonemapping the scene</figcaption>
</figure>
<p>The clouds and fog are much better but the mountain is still trying to act cool.
So we&#39;re going to tweak it in the loop:</p>
<pre><code>emission += 0.2;
</code></pre>
<p>This boosts the overall emission.</p>
<p>While at it, since the horizon is also sadly dark, we want to blast some light
into it:</p>
<pre><code>color += d == 0.0 ? 0.01*h : 0.0;
</code></pre>
<p>When the density is null (meaning we&#39;re outside clouds and fog), an additional
light is added, proportional to how far we are from any solid (the sky gets the
most boost basically).</p>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/comb2.frag"></canvas>
  <figcaption>More atmospheric light</figcaption>
</figure>
<p>The mountain looks fine but I wanted a more eerie atmosphere, so I changed the
attenuation:</p>
<pre><code>-    float attenuation = solid ? 0.95 : exp(-d*absorption);
+    float attenuation = exp(solid ? -h*300.0 : -d*absorption);
</code></pre>
<p>Now instead of being a hard value, the attenuation is correlated with the
proximity to the solid (when getting close to it). This has nothing to with any
physics formula or anything, it&#39;s more of an implementation trick which relies
on the ray-marching algorithm. The effect it creates is those crack-like polygon
edges on the mountain.</p>
<p>To add more to the effect, the emission boost is tweaked into:</p>
<pre><code>-    emission += 0.2;
+    float z = min(p.y - mountain_y + 1.5, 1.0);
+    emission += z*z * 0.2;
</code></pre>
<p>This makes the bottom of the mountain darker quadratically: only the tip of the
mountain would have the glowing cracks.</p>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/comb3.frag"></canvas>
  <figcaption>Making mountains eerie</figcaption>
</figure>
<h2>Color</h2>
<p>We&#39;ve been working in grayscale so far, which is a usually a sound approach to
visual art in general. But we can afford a few more characters to move the scene
to a decent piece of art from the 21st century.</p>
<p>Adding the color just requires very tiny changes. First, the emission boost is going
to target only the red component of the color:</p>
<pre><code>-    emission += z*z * 0.2;
     float alpha = 1. - attenuation;
     float weight = alpha * transmittance;
     color += weight * emission;
+    color.r += weight * z*z * 0.2;
</code></pre>
<p>And similarly, the overall addition of light into the horizon/atmosphere is
going to get a redish/orange tint:</p>
<pre><code>-    color += d == 0.0 ? 0.01*h : 0.0;
+    color += d == 0.0 ? vec3(3,1,0)*0.01*h : vec3(0.0);
</code></pre>
<figure>
  <canvas width="480" height="240" data-fragment="/frag/demomaking/comb4.frag"></canvas>
  <figcaption>Add a red/orange tint</figcaption>
</figure>
<h2>Last tweaks</h2>
<p>We&#39;re almost done. For the last tweak, we&#39;re going to add a cyclic panning
rotation of the camera, and adjust the moving speed:</p>
<pre><code>p.xz *= mat2(cos(sin(T*.2)+vec4(0,11,33,0)));
p.z += T*.3;
</code></pre>
<div>
<p>Note</p>
<p>I&#39;m currently satisfied with the &#34;seed&#34; of the scene, but otherwise it would
have been possible to nudge the noise in different ways. For example,
remember the <code>sin</code> can be replaced with <code>cos</code> in either or both volumetric
and mountain related noises. Similarly, the offsetting <code>+T</code> could be changed
into <code>-T</code> for a different morphing effect. And of course the rotations can
be swapped (either by changing <code>.xz</code> into <code>.zx</code> or transposing the values).</p>
</div>
<h2>Code golfing</h2>
<p>At this point, our code went through early stages of code golfing, but it still
needs some work to reach perfection. Stripped out of its comments, it looks
like this:</p>
<pre><code>// Reference code: 1285 chars (unnecessary spaces and line breaks are not counted)
const float fog_y      = 0.0;
const float clouds_y   = 3.0;
const float mountain_y = -0.5;
const float absorption = 2.5;
const float radiance   = 9.0;

float noise3(vec3 p) {
    float v;
    for(float a=.01; a&lt;1.; a+=a)
        p.xz *= mat2(8,6,-6,8)*.1,
        v += abs(dot(sin(p*.3/a + T*.3), vec3(1)))*a;
    return v;
}

float clouds_fog_density(vec3 p) {
    float n = noise3(p);
    float clouds_d = p.y-clouds_y+n;
    float fog_d    = p.y-fog_y+n;
    float d = max(clouds_d, -fog_d);
    return max(d, 0.0);
}

float mountain_height_map(vec2 p) {
    float h = -mountain_y;
    for (float a=.01; a&lt;1.; a+=a)
        p *= mat2(8,6,-6,8)*.1,
        h += abs(dot(sin(p*.6/a), vec2(1)))*a;
    return -h;
}

float distance_to_solid(vec3 p) {
    return p.y - mountain_height_map(p.xz);
}

void main() {
    float step_len = 0.15;
    float t;

    vec3 color;

    float transmittance = 1.0;
    vec3 rd = normalize(vec3(P+P-R,R.y));
    for (int i = 0; i &lt; 100; i++) {
        vec3 p = rd*t;

        p.xz *= mat2(cos(sin(T*.2)+vec4(0,11,33,0)));
        p.z += T*.3;

        float d = clouds_fog_density(p);
        float h = distance_to_solid(p);

        bool solid = h &lt; 0.001;
        d *= step_len;
        float attenuation = exp(solid ? -h*300.0 : -d*absorption);
        float emission = solid ? 0.0 : d*radiance;
        float z = min(p.y - mountain_y + 1.5, 1.0);
        float alpha = 1. - attenuation;
        float weight = alpha * transmittance;
        color   += weight * emission;
        color.r += weight * z*z * 0.2;
        color += d == 0.0 ? vec3(3,1,0)*0.01*h : vec3(0.0);
        if (!solid) transmittance -= weight;
        t += min(h*0.2, step_len);
        step_len *= 1.015;
    }

    O = vec4(tanh(color*.5), 1);
}
</code></pre>
<p>The first thing we&#39;re going to do is notice that both the mountain, clouds, and
fog use the exact same loop. Factoring them out and inlining the whole thing in
the main function is the obvious move:</p>
<pre><code>// 929 chars
const float fog_y      = 0.0;
const float clouds_y   = 3.0;
const float mountain_y = -0.5;
const float absorption = 2.5;
const float radiance   = 9.0;

void main() {
    float step_len = 0.15;
    float t;

    vec3 color;

    float transmittance = 1.0;
    vec3 rd = normalize(vec3(P+P-R,R.y));
    for (int i = 0; i &lt; 100; i++) {
        vec3 p = rd*t;

        p.xz *= mat2(cos(sin(T*.2)+vec4(0,11,33,0)));
        p.z += T*.3;

        float d = p.y;
        float h = p.y-mountain_y;
        for (float a=.01; a&lt;1.; a+=a)
            p.xz *= mat2(8,6,-6,8)*.1,
            d += abs(dot(sin(p*.3/a + T*.3), vec3(1)))*a,
            h += abs(dot(sin(p.xz*.6/a), vec2(1)))*a;
        d = max(max(d-clouds_y, -(d-fog_y)), 0.0);

        bool solid = h &lt; 0.001;
        d *= step_len;
        float attenuation = exp(solid ? -h*300.0 : -d*absorption);
        float emission = solid ? 0.0 : d*radiance;
        float z = min(p.y - mountain_y + 1.5, 1.0);
        float alpha = 1. - attenuation;
        float weight = alpha * transmittance;
        color   += weight * emission;
        color.r += weight * z*z * 0.2;
        color += d == 0.0 ? vec3(3,1,0)*0.01*h : vec3(0.0);
        if (!solid) transmittance -= weight;
        t += min(h*0.2, step_len);
        step_len *= 1.015;
    }

    O = vec4(tanh(color*.5), 1);
}
</code></pre>
<p>Next, we are going to do the following changes:</p>
<ul>
<li>Rename every variable to single letter or inline them whenever possible</li>
<li>Inline all constants</li>
<li>Remove <a href="https://registry.khronos.org/webgl/specs/latest/1.0/#6.39">any explicit zero initialization</a></li>
<li>Use <code>float</code> instead of <code>int</code> for the iterator and <code>bool</code> for the solid flag</li>
<li>Pack all <code>float</code> and <code>vec3</code> declarations together</li>
<li>Simplify numbers: <code>1e2</code> instead of <code>100.0</code>, <code>3.</code> instead of <code>3.0</code>, etc.</li>
<li><code>vec*()</code> constructor act like cast, so you can pass down integers</li>
</ul>
<pre><code>// 499 chars
void main() {
    vec3 c, p;
    for (float i, a, g=1., t, h, d, w, k=.15, x, z; i &lt; 1e2; i++) {
        p = normalize(vec3(P+P-R,R.y))*t;
        p.xz *= mat2(cos(sin(T*.2)+vec4(0,11,33,0)));
        p.z += T*.3;
        d = p.y;
        h = p.y+.5;
        for (a=.01; a&lt;1.; a+=a)
            p.xz *= mat2(8,6,-6,8)*.1,
            d += abs(dot(sin(p*.3/a + T*.3), vec3(1)))*a,
            h += abs(dot(sin(p.xz*.6/a), vec2(1)))*a;
        d = max(max(d-3., -d), 0.);
        x = h &lt; .001 ? 0. : 1.;
        d *= k;
        z = min(p.y+2., 1.);
        w = g * (1. - exp(x==0. ? -h*3e2 : -d*2.5));
        c += w * x*d*9.;
        c.r += w * z*z * .2;
        c += d == 0. ? vec3(3,1,0)*.01*h : vec3(0);
        g -= w * x;
        t += min(h*.2, k);
        k *= 1.015;
    }
    O = vec4(tanh(c*.5), 1);
}
</code></pre>
<p>Onto the next pass of tricks:</p>
<ul>
<li>Merge and unroll more expressions together</li>
<li>Use <code>mix()</code> to reduce a ternary</li>
<li>Use alternative forms for <code>vec*(0)</code> or <code>vec*(1)</code></li>
<li>Rely on mathematical equivalences such as <span>e^{-x}=1/e^x</span></li>
<li>Some symbol names can be reused (see <code>a</code>)</li>
<li>Notice how the rotation matrix coefficients (<code>0,11,33,0</code>) are close to the
red factors (<code>3,1,0</code>)? That&#39;s right, we can factor that out into a shared
constant <code>K</code>.</li>
<li>Iterate <code>i</code> within the condition</li>
<li>We&#39;re going to inline <code>k*=1.015</code> inside the <code>min()</code>: this is <em>not</em> equivalent,
but in practice it makes no difference</li>
</ul>
<p>I&#39;m also reordering a bit some instructions for clarity 🙃</p>
<pre><code>// 465 chars
void main() {
    vec3 c,p,K=vec3(3,1,0);
    for (float i,a,g=1.,t,h,d,w,k=.15; i++&lt;1e2;) {
        p = normalize(vec3(P+P-R,R.y))*t;
        p.xz *= mat2(cos(sin(T*.2)+K.zyxz*11.));
        p.z += T*.3;
        for (d=p.y,h=d+.5,a=.01;a&lt;1.;a+=a)
            p.xz *= mat2(8,6,-6,8)*.1,
            d += abs(dot(sin((p/a+T)*.3),p/p))*a,
            h += abs(dot(sin(p.xz*.6/a),P/P))*a;
        d = max(max(d-3.,-d),0.)*k;
        w = g-g/exp(mix(h*3e2,d*2.5,a=h&lt;.001?0.:1.));
        g -= a*=w;
        c += a*d*9.+(d==0.?K*.01*h:c-c);
        a = min(p.y+2.,1.);
        c.r += w*a*a*.2;
        t += min(h*.2,k*=1.015);
    }
    O = vec4(tanh(c*.5),1);
}
</code></pre>
<p>The last touch is going to be nasty: we&#39;re going to reorder the instructions
such that the 2nd loop is located at the very beginning of the 1st one:</p>
<pre><code>// 465 chars
void main() {
    vec3 c,p,K=vec3(3,1,0);
    for (float i,a,g=1.,t,h,d,w,k=.15; i++&lt;1e2;) {
        for (d=p.y,h=d+.5,a=.01;a&lt;1.;a+=a)
            p.xz *= mat2(8,6,-6,8)*.1,
            d += abs(dot(sin((p/a+T)*.3),p/p))*a,
            h += abs(dot(sin(p.xz*.6/a),P/P))*a;
        d = max(max(d-3.,-d),0.)*k;
        w = g-g/exp(mix(h*3e2,d*2.5,a=h&lt;.001?0.:1.));
        g -= a*=w;
        c += a*d*9.+(d==0.?K*.01*h:c-c);
        a = min(p.y+2.,1.);
        c.r += w*a*a*.2;
        t += min(h*.2,k*=1.015);
        // This is supposed to be at the beginning:
        p = normalize(vec3(P+P-R,R.y))*t;
        p.xz *= mat2(cos(sin(T*.2)+K.zyxz*11.));
        p.z += T*.3;
    }
    O = vec4(tanh(c*.5),1);
}
</code></pre>
<p>&#34;Why?!&#34; you may ask. Before answering this question, let&#39;s see why it still
works: the first iteration ends up being executed with <code>p=(0,0)</code>, where most
calculations just cancel themselves out, leading to one wasted iteration (out
of 100). Visually, it makes zero difference. But thanks to this weird change, we
end up with a bunch of instructions that we can pack into the last placeholder
of the main loop, comma separated. This notably allows us to drop the <code>{}</code> of
the main loop:</p>
<pre><code>// 462 chars
void main() {
    vec3 c,p,K=vec3(3,1,0);
    for (float i,a,g=1.,t,h,d,w,k=.15; i++&lt;1e2;
        d = max(max(d-3.,-d),0.)*k,
        w = g-g/exp(mix(h*3e2,d*2.5,a=h&lt;.001?0.:1.)),
        g -= a*=w,
        c += a*d*9.+(d==0.?K*.01*h:c-c),
        a = min(p.y+2.,1.),
        c.r += w*a*a*.2,
        t += min(h*.2,k*=1.015),
        p = normalize(vec3(P+P-R,R.y))*t,
        p.xz *= mat2(cos(sin(T*.2)+K.zyxz*11.)),
        p.z += T*.3)
        for (d=p.y,h=d+.5,a=.01;a&lt;1.;a+=a)
            p.xz *= mat2(8,6,-6,8)*.1,
            d += abs(dot(sin((p/a+T)*.3),p/p))*a,
            h += abs(dot(sin(p.xz*.6/a),P/P))*a;
    O = vec4(tanh(c*.5),1);
}
</code></pre>
<p>And here we are. All we have to do now is remove all unnecessary spaces and
line breaks to obtain the final version. I&#39;ll leave you here with this readable
version.</p>
<figure>
    <img src="https://blog.pkh.me/img/demomaking/courtney-cook-FALrwN_MpeE-unsplash.jpg" alt=""/>
    <figcaption>Golfer by Courtney Cook (Unsplash)</figcaption>
</figure>
<h2>Forewords</h2>
<p>I&#39;m definitely breaking the magic of that artwork by explaining everything
in detail here. But it should be replaced with an appreciation for how much
concepts, math, and art can be packed in so little space. Maybe this is possible
because they fundamentally overlap?</p>
<p>Nevertheless, writing such a piece was extremely refreshing and liberating. As a
developer, we&#39;re so used to navigate through mountains of abstractions, dealing
with interoperability issues, and pissing glue code like robots. Here, even
though GLSL is a very crude language, I can&#39;t stop but being in awe by how much
beauty we can produce with a standalone shader. It&#39;s just... Pure code and math,
and I just love it.</p>
</article><p>For updates and more frequent content you can follow me on
<a href="https://fosstodon.org/@bug">Mastodon</a>. Feel also free to subscribe to the
<a href="https://blog.pkh.me/rss.xml">RSS</a> in order to be notified of new write-ups. It is also usually
possible to reach me through other means (check the footer below). Finally,
discussions on some of the articles can sometimes be found on HackerNews,
Lobste.rs and Reddit.</p></div>
  </body>
</html>
