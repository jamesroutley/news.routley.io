<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2014/10/21/">Original</a>
    <h1>C Object Oriented Programming (2014)</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  
  <time datetime="2014-10-21">
    October 21, 2014
  </time>
  <p>
    nullprogram.com/blog/2014/10/21/
  </p>

  <p><del>Object oriented programming, polymorphism in particular, is
essential to nearly any large, complex software system. Without it,
decoupling different system components is difficult.</del> (<em>Update in
2017</em>: I no longer agree with this statement.) C doesn’t come with
object oriented capabilities, so large C programs tend to grow their
own out of C’s primitives. This includes huge C projects like the
Linux kernel, BSD kernels, and SQLite.</p>

<h3 id="starting-simple">Starting Simple</h3>

<p>Suppose you’re writing a function <code>pass_match()</code> that takes an input
stream, an output stream, and a pattern. It works sort of like grep.
It passes to the output each line of input that matches the pattern.
The pattern string contains a shell glob pattern to be handled by
<a href="http://man7.org/linux/man-pages/man3/fnmatch.3.html">POSIX <code>fnmatch()</code></a>. Here’s what the interface looks like.</p>

<div><div><pre><code><span>void</span> <span>pass_match</span><span>(</span><span>FILE</span> <span>*</span><span>in</span><span>,</span> <span>FILE</span> <span>*</span><span>out</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>);</span>
</code></pre></div></div>

<p>Glob patterns are simple enough that pre-compilation, as would be done
for a regular expression, is unnecessary. The bare string is enough.</p>

<p>Some time later the customer wants the program to support regular
expressions in addition to shell-style glob patterns. For efficiency’s
sake, regular expressions need to be pre-compiled and so will not be
passed to the function as a string. It will instead be a <a href="http://man7.org/linux/man-pages/man3/regexec.3.html">POSIX
<code>regex_t</code></a> object. A quick-and-dirty approach might be to
accept both and match whichever one isn’t NULL.</p>

<div><div><pre><code><span>void</span> <span>pass_match</span><span>(</span><span>FILE</span> <span>*</span><span>in</span><span>,</span> <span>FILE</span> <span>*</span><span>out</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>,</span> <span>regex_t</span> <span>*</span><span>re</span><span>);</span>
</code></pre></div></div>

<p>Bleh. This is ugly and won’t scale well. What happens when more kinds
of filters are needed? It would be much better to accept a single
object that covers both cases, and possibly even another kind of
filter in the future.</p>

<h3 id="a-generalized-filter">A Generalized Filter</h3>

<p>One of the most common ways to customize the the behavior of a
function in C is to pass a function pointer. For example, the final
argument to <a href="http://man7.org/linux/man-pages/man3/qsort.3.html"><code>qsort()</code></a> is a comparator that determines how
objects get sorted.</p>

<p>For <code>pass_match()</code>, this function would accept a string and return a
boolean value deciding if the string should be passed to the output
stream. It gets called once on each line of input.</p>

<div><div><pre><code><span>void</span> <span>pass_match</span><span>(</span><span>FILE</span> <span>*</span><span>in</span><span>,</span> <span>FILE</span> <span>*</span><span>out</span><span>,</span> <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>const</span> <span>char</span> <span>*</span><span>));</span>
</code></pre></div></div>

<p>However, this has one of the <a href="https://nullprogram.com/blog/2014/08/29/">same problems as <code>qsort()</code></a>:
the passed function lacks context. It needs a pattern string or
<code>regex_t</code> object to operate on. In other languages these would be
attached to the function as a closure, but C doesn’t have closures. It
would need to be smuggled in via a global variable, <a href="https://nullprogram.com/blog/2014/10/12/">which is not
good</a>.</p>

<div><div><pre><code><span>static</span> <span>regex_t</span> <span>regex</span><span>;</span>  <span>// BAD!!!</span>

<span>bool</span> <span>regex_match</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>return</span> <span>regexec</span><span>(</span><span>&amp;</span><span>regex</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Because of the global variable, in practice <code>pass_match()</code> would be
neither reentrant nor thread-safe. We could take a lesson from GNU’s
<code>qsort_r()</code> and accept a context to be passed to the filter function.
This simulates a closure.</p>

<div><div><pre><code><span>void</span> <span>pass_match</span><span>(</span><span>FILE</span> <span>*</span><span>in</span><span>,</span> <span>FILE</span> <span>*</span><span>out</span><span>,</span>
                <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>const</span> <span>char</span> <span>*</span><span>,</span> <span>void</span> <span>*</span><span>),</span> <span>void</span> <span>*</span><span>context</span><span>);</span>
</code></pre></div></div>

<p>The provided context pointer would be passed to the filter function as
the second argument, and no global variables are needed. This would
probably be good enough for most purposes and it’s about as simple as
possible. The interface to <code>pass_match()</code> would cover any kind of
filter.</p>

<p>But wouldn’t it be nice to package the function and context together
as one object?</p>

<h3 id="more-abstraction">More Abstraction</h3>

<p>How about putting the context on a struct and making an interface out
of that? Here’s a tagged union that behaves as one or the other.</p>

<div><div><pre><code><span>enum</span> <span>filter_type</span> <span>{</span> <span>GLOB</span><span>,</span> <span>REGEX</span> <span>};</span>

<span>struct</span> <span>filter</span> <span>{</span>
    <span>enum</span> <span>filter_type</span> <span>type</span><span>;</span>
    <span>union</span> <span>{</span>
        <span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>;</span>
        <span>regex_t</span> <span>regex</span><span>;</span>
    <span>}</span> <span>context</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>There’s one function for interacting with this struct:
<code>filter_match()</code>. It checks the <code>type</code> member and calls the correct
function with the correct context.</p>

<div><div><pre><code><span>bool</span> <span>filter_match</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>switch</span> <span>(</span><span>filter</span><span>-&gt;</span><span>type</span><span>)</span> <span>{</span>
    <span>case</span> <span>GLOB</span><span>:</span>
        <span>return</span> <span>fnmatch</span><span>(</span><span>filter</span><span>-&gt;</span><span>context</span><span>.</span><span>pattern</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
    <span>case</span> <span>REGEX</span><span>:</span>
        <span>return</span> <span>regexec</span><span>(</span><span>&amp;</span><span>filter</span><span>-&gt;</span><span>context</span><span>.</span><span>regex</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>abort</span><span>();</span> <span>// programmer error</span>
<span>}</span>
</code></pre></div></div>

<p>And the <code>pass_match()</code> API now looks like this. This will be the final
change to <code>pass_match()</code>, both in implementation and interface.</p>

<div><div><pre><code><span>void</span> <span>pass_match</span><span>(</span><span>FILE</span> <span>*</span><span>input</span><span>,</span> <span>FILE</span> <span>*</span><span>output</span><span>,</span> <span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>);</span>
</code></pre></div></div>

<p>It still doesn’t care how the filter works, so it’s good enough to
cover all future cases. It just calls <code>filter_match()</code> on the pointer
it was given. However, the <code>switch</code> and tagged union aren’t friendly
to extension. Really, it’s outright hostile. We finally have some
degree of polymorphism, but it’s crude. It’s like building duct tape
into a design. Adding new behavior means adding another <code>switch</code> case.
This is a step backwards. We can do better.</p>

<h4 id="methods">Methods</h4>

<p>With the <code>switch</code> we’re no longer taking advantage of function
pointers. So what about putting a function pointer on the struct?</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>{</span>
    <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>);</span>
<span>};</span>
</code></pre></div></div>

<p>The filter itself is passed as the first argument, providing context.
In object oriented languages, that’s the implicit <code>this</code> argument. To
avoid requiring the caller to worry about this detail, we’ll hide it
in a new <code>switch</code>-free version of <code>filter_match()</code>.</p>

<div><div><pre><code><span>bool</span> <span>filter_match</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>return</span> <span>filter</span><span>-&gt;</span><span>match</span><span>(</span><span>filter</span><span>,</span> <span>string</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Notice we’re still lacking the actual context, the pattern string or
the regex object. Those will be different structs that embed the
filter struct.</p>

<div><div><pre><code><span>struct</span> <span>filter_regex</span> <span>{</span>
    <span>struct</span> <span>filter</span> <span>filter</span><span>;</span>
    <span>regex_t</span> <span>regex</span><span>;</span>
<span>};</span>

<span>struct</span> <span>filter_glob</span> <span>{</span>
    <span>struct</span> <span>filter</span> <span>filter</span><span>;</span>
    <span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>For both the original filter struct is the first member. This is
critical. We’re going to be using a trick called <em>type punning</em>. The
first member is guaranteed to be positioned at the beginning of the
struct, so a pointer to a <code>struct filter_glob</code> is also a pointer to a
<code>struct filter</code>. Notice any resemblance to inheritance?</p>

<p>Each type, glob and regex, needs its own match method.</p>

<div><div><pre><code><span>static</span> <span>bool</span>
<span>method_match_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>(</span><span>struct</span> <span>filter_regex</span> <span>*</span><span>)</span> <span>filter</span><span>;</span>
    <span>return</span> <span>regexec</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>

<span>static</span> <span>bool</span>
<span>method_match_glob</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_glob</span> <span>*</span><span>glob</span> <span>=</span> <span>(</span><span>struct</span> <span>filter_glob</span> <span>*</span><span>)</span> <span>filter</span><span>;</span>
    <span>return</span> <span>fnmatch</span><span>(</span><span>glob</span><span>-&gt;</span><span>pattern</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>I’ve prefixed them with <code>method_</code> to indicate their intended usage. I
declared these <code>static</code> because they’re completely private. Other
parts of the program will only be accessing them through a function
pointer on the struct. This means we need some constructors in order
to set up those function pointers. (For simplicity, I’m not error
checking.)</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>*</span><span>filter_regex_create</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>regex</span><span>));</span>
    <span>regcomp</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>,</span> <span>pattern</span><span>,</span> <span>REG_EXTENDED</span><span>);</span>
    <span>regex</span><span>-&gt;</span><span>filter</span><span>.</span><span>match</span> <span>=</span> <span>method_match_regex</span><span>;</span>
    <span>return</span> <span>&amp;</span><span>regex</span><span>-&gt;</span><span>filter</span><span>;</span>
<span>}</span>

<span>struct</span> <span>filter</span> <span>*</span><span>filter_glob_create</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_glob</span> <span>*</span><span>glob</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>glob</span><span>));</span>
    <span>glob</span><span>-&gt;</span><span>pattern</span> <span>=</span> <span>pattern</span><span>;</span>
    <span>glob</span><span>-&gt;</span><span>filter</span><span>.</span><span>match</span> <span>=</span> <span>method_match_glob</span><span>;</span>
    <span>return</span> <span>&amp;</span><span>glob</span><span>-&gt;</span><span>filter</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Now this is real polymorphism. It’s really simple from the user’s
perspective. They call the correct constructor and get a filter object
that has the desired behavior. This object can be passed around
trivially, and no other part of the program worries about how it’s
implemented. Best of all, since each method is a separate function
rather than a <code>switch</code> case, new kinds of filter subtypes can be
defined independently. Users can create their own filter types that
work just as well as the two “built-in” filters.</p>

<h4 id="cleaning-up">Cleaning Up</h4>

<p>Oops, the regex filter needs to be cleaned up when it’s done, but the
user, by design, won’t know how to do it. Let’s add a <code>free()</code> method.</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>{</span>
    <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>);</span>
    <span>void</span> <span>(</span><span>*</span><span>free</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>);</span>
<span>};</span>

<span>void</span> <span>filter_free</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>filter</span><span>)</span>
<span>{</span>
    <span>return</span> <span>filter</span><span>-&gt;</span><span>free</span><span>(</span><span>filter</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>And the methods for each. These would also be assigned in the
constructor.</p>

<div><div><pre><code><span>static</span> <span>void</span>
<span>method_free_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>(</span><span>struct</span> <span>filter_regex</span> <span>*</span><span>)</span> <span>f</span><span>;</span>
    <span>regfree</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>);</span>
    <span>free</span><span>(</span><span>f</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span>
<span>method_free_glob</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>free</span><span>(</span><span>f</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The glob constructor should perhaps <code>strdup()</code> its pattern as a
private copy, in which case it would be freed here.</p>

<h3 id="object-composition">Object Composition</h3>

<p>A good rule of thumb is to prefer composition over inheritance. Having
tidy filter objects opens up some interesting possibilities for
composition. Here’s an AND filter that composes two arbitrary filter
objects. It only matches when both its subfilters match. It supports
short circuiting, so put the faster, or most discriminating, filter
first in the constructor (user’s responsibility).</p>

<div><div><pre><code><span>struct</span> <span>filter_and</span> <span>{</span>
    <span>struct</span> <span>filter</span> <span>filter</span><span>;</span>
    <span>struct</span> <span>filter</span> <span>*</span><span>sub</span><span>[</span><span>2</span><span>];</span>
<span>};</span>

<span>static</span> <span>bool</span>
<span>method_match_and</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>s</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_and</span> <span>*</span><span>and</span> <span>=</span> <span>(</span><span>struct</span> <span>filter_and</span> <span>*</span><span>)</span> <span>f</span><span>;</span>
    <span>return</span> <span>filter_match</span><span>(</span><span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>0</span><span>],</span> <span>s</span><span>)</span> <span>&amp;&amp;</span> <span>filter_match</span><span>(</span><span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>1</span><span>],</span> <span>s</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span>
<span>method_free_and</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_and</span> <span>*</span><span>and</span> <span>=</span> <span>(</span><span>struct</span> <span>filter_and</span> <span>*</span><span>)</span> <span>f</span><span>;</span>
    <span>filter_free</span><span>(</span><span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>0</span><span>]);</span>
    <span>filter_free</span><span>(</span><span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>1</span><span>]);</span>
    <span>free</span><span>(</span><span>f</span><span>);</span>
<span>}</span>

<span>struct</span> <span>filter</span> <span>*</span><span>filter_and</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>a</span><span>,</span> <span>struct</span> <span>filter</span> <span>*</span><span>b</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_and</span> <span>*</span><span>and</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>and</span><span>));</span>
    <span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>a</span><span>;</span>
    <span>and</span><span>-&gt;</span><span>sub</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>b</span><span>;</span>
    <span>and</span><span>-&gt;</span><span>filter</span><span>.</span><span>match</span> <span>=</span> <span>method_match_and</span><span>;</span>
    <span>and</span><span>-&gt;</span><span>filter</span><span>.</span><span>free</span> <span>=</span> <span>method_free_and</span><span>;</span>
    <span>return</span> <span>&amp;</span><span>and</span><span>-&gt;</span><span>filter</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>It can combine a regex filter and a glob filter, or two regex filters,
or two glob filters, or even other AND filters. It doesn’t care what
the subfilters are. Also, the <code>free()</code> method here frees its
subfilters. This means that the user doesn’t need to keep hold of
every filter created, just the “top” one in the composition.</p>

<p>To make composition filters easier to use, here are two “constant”
filters. These are statically allocated, shared, and are never
actually freed.</p>

<div><div><pre><code><span>static</span> <span>bool</span>
<span>method_match_any</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>static</span> <span>bool</span>
<span>method_match_none</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span>
<span>method_free_noop</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
<span>}</span>

<span>struct</span> <span>filter</span> <span>FILTER_ANY</span>  <span>=</span> <span>{</span> <span>method_match_any</span><span>,</span>  <span>method_free_noop</span> <span>};</span>
<span>struct</span> <span>filter</span> <span>FILTER_NONE</span> <span>=</span> <span>{</span> <span>method_match_none</span><span>,</span> <span>method_free_noop</span> <span>};</span>
</code></pre></div></div>

<p>The <code>FILTER_NONE</code> filter will generally be used with a (theoretical)
<code>filter_or()</code> and <code>FILTER_ANY</code> will generally be used with the
previously defined <code>filter_and()</code>.</p>

<p>Here’s a simple program that composes multiple glob filters into a
single filter, one for each program argument.</p>

<div><div><pre><code><span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter</span> <span>*</span><span>filter</span> <span>=</span> <span>&amp;</span><span>FILTER_ANY</span><span>;</span>
    <span>for</span> <span>(</span><span>char</span> <span>**</span><span>p</span> <span>=</span> <span>argv</span> <span>+</span> <span>1</span><span>;</span> <span>*</span><span>p</span><span>;</span> <span>p</span><span>++</span><span>)</span>
        <span>filter</span> <span>=</span> <span>filter_and</span><span>(</span><span>filter_glob_create</span><span>(</span><span>*</span><span>p</span><span>),</span> <span>filter</span><span>);</span>
    <span>pass_match</span><span>(</span><span>stdin</span><span>,</span> <span>stdout</span><span>,</span> <span>filter</span><span>);</span>
    <span>filter_free</span><span>(</span><span>filter</span><span>);</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Notice only one call to <code>filter_free()</code> is needed to clean up the
entire filter.</p>

<h3 id="multiple-inheritance">Multiple Inheritance</h3>

<p>As I mentioned before, the filter struct must be the first member of
filter subtype structs in order for type punning to work. If we want
to “inherit” from two different types like this, they would both need
to be in this position: a contradiction.</p>

<p>Fortunately type punning can be generalized such that it the
first-member constraint isn’t necessary. This is commonly done through
a <code>container_of()</code> macro. Here’s a C99-conforming definition.</p>

<div><div><pre><code><span>#include &lt;stddef.h&gt;
</span>
<span>#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))
</span></code></pre></div></div>

<p>Given a pointer to a member of a struct, the <code>container_of()</code> macro
allows us to back out to the containing struct. Suppose the regex
struct was defined differently, so that the <code>regex_t</code> member came
first.</p>

<div><div><pre><code><span>struct</span> <span>filter_regex</span> <span>{</span>
    <span>regex_t</span> <span>regex</span><span>;</span>
    <span>struct</span> <span>filter</span> <span>filter</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>The constructor remains unchanged. The casts in the methods change to
the macro.</p>

<div><div><pre><code><span>static</span> <span>bool</span>
<span>method_match_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>container_of</span><span>(</span><span>f</span><span>,</span> <span>struct</span> <span>filter_regex</span><span>,</span> <span>filter</span><span>);</span>
    <span>return</span> <span>regexec</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span>
<span>method_free_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>container_of</span><span>(</span><span>f</span><span>,</span> <span>struct</span> <span>filter_regex</span><span>,</span> <span>filter</span><span>);</span>
    <span>regfree</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>);</span>
    <span>free</span><span>(</span><span>f</span><span>);</span>

<span>}</span>
</code></pre></div></div>

<p>It’s a constant, compile-time computed offset, so there should be no
practical performance impact. The filter can now participate freely in
other <em>intrusive</em> data structures, like linked lists and such. It’s
analogous to multiple inheritance.</p>

<h3 id="vtables">Vtables</h3>

<p>Say we want to add a third method, <code>clone()</code>, to the filter API, to
make an independent copy of a filter, one that will need to be
separately freed. It will be like the copy assignment operator in C++.
Each kind of filter will need to define an appropriate “method” for
it. As long as new methods like this are added at the end, this
doesn’t break the API, but it does break the ABI regardless.</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>{</span>
    <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>);</span>
    <span>void</span> <span>(</span><span>*</span><span>free</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>);</span>
    <span>struct</span> <span>filter</span> <span>*</span><span>(</span><span>*</span><span>clone</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>);</span>
<span>};</span>
</code></pre></div></div>

<p>The filter object is starting to get big. It’s got three pointers —
24 bytes on modern systems — and these pointers are the same between
all instances of the same type. That’s a lot of redundancy. Instead,
these pointers could be shared between instances in a common table
called a <em>virtual method table</em>, commonly known as a <em>vtable</em>.</p>

<p>Here’s a vtable version of the filter API. The overhead is now only
one pointer regardless of the number of methods in the interface.</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>{</span>
    <span>struct</span> <span>filter_vtable</span> <span>*</span><span>vtable</span><span>;</span>
<span>};</span>

<span>struct</span> <span>filter_vtable</span> <span>{</span>
    <span>bool</span> <span>(</span><span>*</span><span>match</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>);</span>
    <span>void</span> <span>(</span><span>*</span><span>free</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>);</span>
    <span>struct</span> <span>filter</span> <span>*</span><span>(</span><span>*</span><span>clone</span><span>)(</span><span>struct</span> <span>filter</span> <span>*</span><span>);</span>
<span>};</span>
</code></pre></div></div>

<p>Each type creates its own vtable and links to it in the constructor.
Here’s the regex filter re-written for the new vtable API and clone
method. This is all the tricks in one basket for a big object oriented
C finale!</p>

<div><div><pre><code><span>struct</span> <span>filter</span> <span>*</span><span>filter_regex_create</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>);</span>

<span>struct</span> <span>filter_regex</span> <span>{</span>
    <span>regex_t</span> <span>regex</span><span>;</span>
    <span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>;</span>
    <span>struct</span> <span>filter</span> <span>filter</span><span>;</span>
<span>};</span>

<span>static</span> <span>bool</span>
<span>method_match_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>string</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>container_of</span><span>(</span><span>f</span><span>,</span> <span>struct</span> <span>filter_regex</span><span>,</span> <span>filter</span><span>);</span>
    <span>return</span> <span>regexec</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>,</span> <span>string</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
<span>}</span>

<span>static</span> <span>void</span>
<span>method_free_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>container_of</span><span>(</span><span>f</span><span>,</span> <span>struct</span> <span>filter_regex</span><span>,</span> <span>filter</span><span>);</span>
    <span>regfree</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>);</span>
    <span>free</span><span>(</span><span>f</span><span>);</span>
<span>}</span>

<span>static</span> <span>struct</span> <span>filter</span> <span>*</span>
<span>method_clone_regex</span><span>(</span><span>struct</span> <span>filter</span> <span>*</span><span>f</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>container_of</span><span>(</span><span>f</span><span>,</span> <span>struct</span> <span>filter_regex</span><span>,</span> <span>filter</span><span>);</span>
    <span>return</span> <span>filter_regex_create</span><span>(</span><span>regex</span><span>-&gt;</span><span>pattern</span><span>);</span>
<span>}</span>

<span>/* vtable */</span>
<span>struct</span> <span>filter_vtable</span> <span>filter_regex_vtable</span> <span>=</span> <span>{</span>
    <span>method_match_regex</span><span>,</span> <span>method_free_regex</span><span>,</span> <span>method_clone_regex</span>
<span>};</span>

<span>/* constructor */</span>
<span>struct</span> <span>filter</span> <span>*</span><span>filter_regex_create</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>pattern</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>filter_regex</span> <span>*</span><span>regex</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>regex</span><span>));</span>
    <span>regex</span><span>-&gt;</span><span>pattern</span> <span>=</span> <span>pattern</span><span>;</span>
    <span>regcomp</span><span>(</span><span>&amp;</span><span>regex</span><span>-&gt;</span><span>regex</span><span>,</span> <span>pattern</span><span>,</span> <span>REG_EXTENDED</span><span>);</span>
    <span>regex</span><span>-&gt;</span><span>filter</span><span>.</span><span>vtable</span> <span>=</span> <span>&amp;</span><span>filter_regex_vtable</span><span>;</span>
    <span>return</span> <span>&amp;</span><span>regex</span><span>-&gt;</span><span>filter</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This is almost exactly what’s going on behind the scenes in C++. When
a method/function is declared <code>virtual</code>, and therefore dispatches
based on the run-time type of its left-most argument, it’s listed in
the vtables for classes that implement it. Otherwise it’s just a
normal function. This is why functions need to be declared <code>virtual</code>
ahead of time in C++.</p>

<p>In conclusion, it’s relatively easy to get the core benefits of object
oriented programming in plain old C. It doesn’t require heavy use of
macros, nor do users of these systems need to know that underneath
it’s an object system, unless they want to extend it for themselves.</p>

<p>Here’s the whole example program once if you’re interested in poking:</p>

<ul>
  <li><a href="https://gist.github.com/skeeto/5faa131b19673549d8ca">https://gist.github.com/skeeto/5faa131b19673549d8ca</a></li>
</ul>



  
  <ol></ol>

  

  <nav>
  
    
  
  
    
  
  </nav>
</article>

</div></div>
  </body>
</html>
