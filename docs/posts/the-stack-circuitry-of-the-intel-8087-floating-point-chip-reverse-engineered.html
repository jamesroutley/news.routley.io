<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2025/12/8087-stack-circuitry.html">Original</a>
    <h1>The stack circuitry of the Intel 8087 floating point chip, reverse-engineered</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1883798277085402615" itemprop="description articleBody">
<p>Early microprocessors were very slow when operating with floating-point numbers.
But in 1980, Intel introduced the 8087 floating-point coprocessor, performing
floating-point operations up
to 100 times faster.
This was a huge benefit for IBM PC
applications such as AutoCAD, spreadsheets, and flight simulators.
The 8087 was so effective that today&#39;s computers still use a floating-point system based on the 8087.<span id="fnref:ieee-754"><a href="#fn:ieee-754">1</a></span></p>
<!--
It's hard to compute floating-point operations both quickly and accurately.
Problems can arise from overflow, rounding, transcendental operations, and numerous edge cases.
Prior to the 8087, each manufacturer had their own incompatible ad hoc implementation of floating point.
Intel, however, enlisted numerical analysis expert [William Kahan](https://en.wikipedia.org/wiki/William_Kahan) to design accurate floating point
based on rigorous principles.
    The 8087 has its problems, but it was a large improvement on earlier floating-point systems.
    The designers of the 8087 commented on the guidance offered by Professor Kahan: "We did not do as well as he wanted, but we did better than he expected."
-- The 8087 Primer, page viii
-->

<p>The 8087 was an extremely complex chip for its time, containing somewhere between
40,000 and 75,000 transistors, depending on the source.<span id="fnref:count"><a href="#fn:count">2</a></span>
To explore how the 8087 works, I opened up a chip and took numerous photos of the silicon die with a microscope.
Around the edges of the die, you can see the hair-thin bond wires that connect the chip to its 40 external pins.
The complex patterns on the die are formed by its metal wiring, as well as the polysilicon and silicon underneath.
The bottom half of the chip is the &#34;datapath&#34;, the circuitry that performs calculations on 80-bit floating point values. 
At the left of the datapath, a <a href="https://www.righto.com/2020/05/extracting-rom-constants-from-8087-math.html">constant ROM</a> holds important constants such as π.
At the right are the eight registers that form the stack, along with the stack control circuitry.</p>
<p><a href="https://static.righto.com/images/8087-stack/8087-die-labeled.jpg"><img alt="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image." height="587" src="https://static.righto.com/images/8087-stack/8087-die-labeled-w450.jpg" title="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image." width="450"/></a></p><p>Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5mm×6mm.  Click for a larger image.</p>
<p>The chip&#39;s instructions are defined by the large <a href="https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html">microcode ROM</a> in the middle.
This ROM is very unusual; it is semi-analog, storing two bits per transistor by using four transistor sizes.
To execute a floating-point instruction, the 8087 decodes the instruction and the microcode engine starts executing
the appropriate micro-instructions from the microcode ROM.
The decode circuitry to the right of the ROM generates the appropriate control signals from each micro-instruction.
The bus registers and control circuitry handle interactions with the main 8086 processor and the rest of the system.
Finally, the <a href="https://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html">bias generator</a>
uses a charge pump to create a negative voltage to bias the chip&#39;s substrate, the underlying silicon.</p>
<p>The stack registers and control circuitry (in red above) are the subject of this blog post. 
Unlike most processors, the 8087 organizes its registers in a stack, with instructions operating on the top of the stack.
For instance, the square root instruction replaces the value on the top of the stack with its square root.
You can also access a register relative to the top of the stack, for instance, adding the top value to the value two positions down from the top.
The stack-based architecture was intended to improve the instruction set, simplify compiler design, and make function
calls more efficient, although it didn&#39;t work as well as hoped.</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-diagram.jpg"><img alt="The stack on the 8087. From The 8087 Primer, page 60." height="204" src="https://static.righto.com/images/8087-stack/stack-diagram-w350.jpg" title="The stack on the 8087. From The 8087 Primer, page 60." width="350"/></a></p><p>The stack on the 8087. From <i>The 8087 Primer</i>, page 60.</p>
<p>The diagram above shows how the stack operates. The stack consists of eight registers, with the Stack Top
(ST) indicating the current top of the stack.
To push a floating-point value onto the stack, the Stack Top is decremented and then the value is stored in the new top register.
A pop is performed by copying the value from the stack top and then incrementing the Stack Top.
In comparison, most processors specify registers directly, so register 2 is always the same register.</p>
<h2>The registers</h2>
<p>The stack registers occupy a substantial area on the die of the 8087 because floating-point numbers take many bits.
A floating-point number consists of a fractional part (sometimes called the mantissa or significand), along with
the exponent part; the exponent allows floating-point numbers to cover a range from extremely small to extremely
large.
In the 8087, floating-point numbers are 80 bits: 64 bits of significand, 15 bits of exponent, and a sign bit.
An 80-bit register was very large in the era of 8-bit or 16-bit computers; the eight registers in the 8087
would be equivalent to 40 registers in the 8086 processor.</p>
<p><a href="https://static.righto.com/images/8087-stack/registers.jpg"><img alt="The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry." height="684" src="https://static.righto.com/images/8087-stack/registers-w500.jpg" title="The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry." width="500"/></a></p><p>The registers in the 8087 form an 8×80 grid of cells. The close-up shows an 8×8 block. I removed the metal layer with acid to reveal the underlying silicon circuitry.</p>
<p>The registers store each bit in a static RAM cell. Each cell has two inverters connected in a loop.
This circuit forms a stable feedback loop, with one inverter on and one inverter off.
Depending on which inverter is on, the circuit stores a 0 or a 1.
To write a new value into the circuit, one of the lines is pulled low, flipping the loop into the desired state.
The trick is that each inverter uses a very weak transistor to pull the output high, so its output is easily overpowered
to change the state.</p>
<p><a href="https://static.righto.com/images/8087-stack/inverter-loop.png"><img alt="Two inverters in a loop can store a 0 or a 1." height="121" src="https://static.righto.com/images/8087-stack/inverter-loop-w250.png" title="Two inverters in a loop can store a 0 or a 1." width="250"/></a></p><p>Two inverters in a loop can store a 0 or a 1.</p>
<p>These inverter pairs are arranged in an 8 × 80 grid that implements eight words of 80 bits. Each of the 80 rows has two <em>bitlines</em> that provide access to a bit.
The bitlines provide both read and write access to a bit; the pair of bitlines allows either inverter to be pulled low to store the desired bit value.
Eight vertical <em>wordlines</em> enable access to one word, one column of 80 bits.
Each wordline turns on 160 pass transistors, connecting the bitlines to the inverters in the selected column.
Thus, when a wordline is enabled, the bitlines can be used to read or write that word.</p>
<p>Although the chip looks two-dimensional, it actually consists of multiple layers.
The bottom layer is silicon.
The pinkish regions below are where the silicon has been &#34;doped&#34; to change its electrical properties, making it an active
part of the circuit.
The doped silicon forms a grid of horizontal and vertical wiring, with larger doped regions in the middle.
On top of the silicon, polysilicon wiring provides two functions. First, it provides a layer of wiring to connect the circuit.
But more importantly, when polysilicon crosses doped silicon, it forms a transistor. The polysilicon provides the gate, turning the transistor on and off.
In this photo, the polysilicon is barely visible, so I&#39;ve highlighted part of it in red.
Finally, horizontal metal wires provide a third layer of interconnecting wiring.
Normally, the metal hides the underlying circuitry, so I removed the metal with acid for this photo.
I&#39;ve drawn blue lines to represent the metal layer.
Contacts provide connections between the various layers.</p>
<p><a href="https://static.righto.com/images/8087-stack/memory-cell-layers.jpg"><img alt="A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon." height="336" src="https://static.righto.com/images/8087-stack/memory-cell-layers-w500.jpg" title="A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon." width="500"/></a></p><p>A close-up of a storage cell in the registers. The metal layer and most of the polysilicon have been removed to show the underlying silicon.</p>
<p>The layers combine to form the inverters and selection transistors of a memory cell, indicated with the dotted line below.
There are six transistors (yellow), where polysilicon crosses doped silicon. Each inverter has a transistor that
pulls the output low and a weak transistor to pull the output high.
When the word line (vertical polysilicon) is active, it connects the selected inverters to the bit lines (horizontal metal) through the two selection
transistors.
This allows the bit to be read or written.</p>
<p><a href="https://static.righto.com/images/8087-stack/memory-cell-labeled.jpg"><img alt="The function of the circuitry in a storage cell." height="303" src="https://static.righto.com/images/8087-stack/memory-cell-labeled-w500.jpg" title="The function of the circuitry in a storage cell." width="500"/></a></p><p>The function of the circuitry in a storage cell.</p>
<p>Each register has two tag bits associated with it, an unusual form of metadata to indicate
if the register is empty, contains zero, contains a valid value, or
contains a special value such as infinity.
The tag bits are used to optimize performance internally and are mostly irrelevant to the programmer.
As well as being accessed with a register, the tag bits can be accessed in parallel as a 16-bit &#34;Tag Word&#34;.
This allows the tags to be saved or loaded as part of the 8087&#39;s state, for instance,
during interrupt handling.</p>
<h2>The decoder</h2>
<p>The decoder circuit, wedged into the middle of the register file, selects one of the registers.
A register is specified internally with a 3-bit value. The decoder circuit energizes one of the eight register select
lines based on this value.</p>
<p>The decoder circuitry is straightforward: it has eight 3-input NOR gates to match one of the eight bit patterns.
The select line is then powered through a high-current driver that uses large transistors.
(In the photo below, you can compare the large serpentine driver transistors to the small transistors in a bit cell.)</p>
<p><a href="https://static.righto.com/images/8087-stack/decoder.jpg"><img alt="The decoder circuitry has eight similar blocks to drive the eight select lines." height="273" src="https://static.righto.com/images/8087-stack/decoder-w600.jpg" title="The decoder circuitry has eight similar blocks to drive the eight select lines." width="600"/></a></p><p>The decoder circuitry has eight similar blocks to drive the eight select lines.</p>
<p>The decoder has an interesting electrical optimization.
As shown earlier, the register select lines are eight polysilicon lines running vertically, the length of the
register file. 
Unfortunately, polysilicon has fairly high resistance, better than silicon but much worse than metal.
The problem is that the resistance of a long polysilicon line will slow down the system.
That is, the capacitance of transistor gates in combination with high resistance causes an RC (resistive-capacitive) delay in the signal.</p>
<p>The solution is that the register select lines also run in the metal layer, a second set of lines immediately to the
right of the register file.
These lines branch off from the register file about 1/3 of the way down, run to the bottom, and then connect back
to the polysilicon select lines at the bottom.
This reduces the maximum resistance through a select line, increasing the speed.</p>
<p><a href="https://static.righto.com/images/8087-stack/select.jpg"><img alt="A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit." height="419" src="https://static.righto.com/images/8087-stack/select-w300.jpg" title="A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit." width="300"/></a></p><p>A diagram showing how 8 metal lines run parallel to the main select lines. The register file is much taller than shown; the middle has been removed to make the diagram fit.</p>
<h2>The stack control circuitry</h2>
<p>A stack needs more control circuitry than a regular register file, since the circuitry must keep track of the
position of the top of the stack.<span id="fnref:status-word"><a href="#fn:status-word">3</a></span>
The control circuitry increments and decrements the top of stack (TOS) pointer as values are pushed or popped
(purple).<span id="fnref:patents"><a href="#fn:patents">4</a></span>
Moreover, an 8087 instruction can access a register based on its offset, for instance the third register
from the top.
To support this, the control circuitry can temporarily add an offset to the top of stack position (green).
A multiplexer (red) selects either the top of stack or the adder output, and feeds it to the decoder (blue),
which selects one of the eight stack registers in the register file (yellow), as described earlier.</p>
<p><a href="https://static.righto.com/images/8087-stack/patent-diagram.jpg"><img alt="The register stack in the 8087. Adapted from Patent USRE33629E. I don&#39;t know what the GRX field is. I also don&#39;t know why this shows a subtractor and not an adder." height="378" src="https://static.righto.com/images/8087-stack/patent-diagram-w700.jpg" title="The register stack in the 8087. Adapted from Patent USRE33629E. I don&#39;t know what the GRX field is. I also don&#39;t know why this shows a subtractor and not an adder." width="700"/></a></p><p>The register stack in the 8087. Adapted from <a href="https://patents.google.com/patent/USRE33629E">Patent USRE33629E</a>. I don&#39;t know what the GRX field is. I also don&#39;t know why this shows a subtractor and not an adder.</p>
<!--
    The stack has a key role in most 8087 instructions.
    The `FLD` (Load Real) and `FSTP` (Store Real and Pop) instructions and their variants push or pop a stack value respectively.
    The `FST` (Store Real) instruction reads a stack value without popping it.
    Many instructions affect the top stack register and a specified position in the stack, such as
    `FXCH` (Exchange Registers).
    The standard arithmetic operations (add, subtract, multiply, divide) can use the stack in multiple ways.
    The "classical" form is to perform the operation on the top two stack locations and replace the top stack value
    with the result.
    Alternatively, the second argument can come from an arbitrary stack location, with the result going into either
    the top of stack or the second location.
    The top value can also be popped, shrinking the stack.
    Finally, one argument can come from memory.
    The less common arithmetic operations (e.g. square root, partial remainder) operate on the top of stack or the
    two top elements as appropriate.
    The point of this is that the 8087 uses the stack in a wide variety of ways, so the circuitry reflects this
    complexity.

    The stack pointer can be directly manipulated with the
    `FINCSTP` and `FDECSTP` instructions (increment or decrement stack pointer).
    The stack pointer is part of the Status Word, and can be stored to memory with the `FSTSW` (Store Status Word)
    instruction. It can also be stored to memory or loaded from memory as part of the `FLDENV` and `FSTENV`
    (Load Environment or Store Environment) instructions or the `FSAVE` and `FRSTOR` (Save State and Restore State)
    instructions.
-->

<p>The physical implementation of the stack circuitry is shown below.
The logic at the top selects the stack operation based on the 16-bit micro-instruction.<span id="fnref:microcode"><a href="#fn:microcode">5</a></span>
Below that are the three latches that hold the top of stack value.
(The large white squares look important, but they are simply &#34;jumpers&#34; from the ground line to the circuitry, passing
under metal wires.)</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-circuitry.jpg"><img alt="The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
" height="653" src="https://static.righto.com/images/8087-stack/stack-circuitry-w350.jpg" title="The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
" width="350"/></a></p><p>The stack control circuitry. The blue regions on the right are oxide residue that remained when I dissolved the metal rail for the 5V power.
</p>
<p>The three-bit adder is at the bottom, along with the multiplexer.
You might expect the adder to use a simple &#34;full adder&#34; circuit. Instead, it is
a faster <a href="https://en.wikipedia.org/wiki/Carry-lookahead_adder">carry-lookahead</a> adder.
I won&#39;t go into details here, but the summary is that at each bit position, an AND gate produces a Carry Generate
signal while an XOR gate produces a Carry Propagate signal.
Logic gates combine these signals to produce the output bits in parallel, avoiding the slowdown of the carry rippling
through the bits.</p>
<p>The incrementer/decrementer uses a completely different approach.
Each of the three bits uses a toggle flip-flop.
A few logic gates determine if each bit should be toggled or should keep its previous value.
For instance, when incrementing, the top bit is toggled if the lower bits are 11 (e.g. incrementing from 011 to 100).
For decrementing, the top bit is toggled if the lower bits are 00 (e.g. 100 to 011).
Simpler logic determines if the middle bit should be toggled.
The bottom bit is easier, toggling every time whether incrementing or decrementing.</p>
<p>The schematic below shows the circuitry for one bit of the stack.
Each bit is implemented with a moderately complicated flip-flop that can be cleared, loaded with
a value, or toggled, based on control signals from the microcode.
The flip-flop is constructed from two set-reset (SR) latches. Note that the flip-flop outputs are crossed when fed back
to the input, providing the inversion for the toggle action.
At the right, the multiplexer selects either the register value or the sum from the adder (not shown), generating the signals
to the decoder.</p>
<p><a href="https://static.righto.com/images/8087-stack/stack-schematic.jpg"><img alt="Schematic of one bit of the stack." height="294" src="https://static.righto.com/images/8087-stack/stack-schematic-w700.jpg" title="Schematic of one bit of the stack." width="700"/></a></p><p>Schematic of one bit of the stack.</p>
<h2>Drawbacks of the stack approach</h2>
<p>According to the designers of the 8087,<span id="fnref:references"><a href="#fn:references">7</a></span>
the main motivation for using a stack rather than a flat register set was that instructions didn&#39;t have enough bits to address multiple register operands.
In addition, a stack has &#34;advantages over general registers for expression parsing and nested function calls.&#34;
That is, a stack works well for a mathematical expression since sub-expressions can be evaluated on the top
of the stack.
And for function calls, you avoid the cost of saving registers to memory, since the subroutine can use the stack without disturbing the values underneath.
At least that was the idea.</p>
<!--
The designers considered a "classical" stack architecture, which has only two or three cells in hardware and accesses
the rest of the stack from memory. However, this approach was rejected because the excessive traffic between the memory and stack would have been a bottleneck.
-->

<p>The main problem is &#34;stack overflow&#34;.
The 8087&#39;s stack has eight entries, so if you push a ninth value onto the stack, the stack will overflow.
Specifically, the top-of-stack pointer will wrap around, obliterating the bottom value on the stack.
The 8087 is designed to detect a stack overflow using the register tags:
pushing a value to a non-empty register triggers an invalid operation exception.<span id="fnref:underflow"><a href="#fn:underflow">6</a></span></p>
<p>The designers expected that stack overflow would be rare and could be handled by the operating system (or library code).
After detecting a stack overflow, the software should dump the existing stack to memory to
provide the illusion of an infinite stack.
Unfortunately, bad design decisions made it difficult &#34;both technically and commercially&#34; to handle stack overflow.</p>
<p>One of the 8087&#39;s designers (Kahan) attributes the 8087&#39;s stack problems to the time difference between California,
where the designers lived, and Israel, where the 8087 was implemented.
Due to a lack of communication, each team thought the other was implementing the overflow software.
It wasn&#39;t until the
8087 was in production that they realized that &#34;it might not be possible to handle 8087 stack underflow/overflow in a reasonable way. It&#39;s not impossible, just impossible to do it in a reasonable way.&#34;</p>
<p>As a result, the stack was largely a problem rather than a solution.
Most 8087 software saved the full stack to memory before performing
a function call, creating more memory traffic.
Moreover, compilers turned out to work better with regular registers than a stack,
so compiler writers awkwardly used the stack to emulate regular registers.
The <code>GCC</code> compiler <a href="https://langdev.stackexchange.com/a/2408">reportedly</a> needs 3000 lines of extra code to support the x87 stack.</p>
<p>In the 1990s, Intel introduced a new floating-point system called <a href="https://www.cs.uaf.edu/2012/fall/cs301/lecture/11_02_other_float.html">SSE</a>, followed by AVX in 2011.
These systems use regular (non-stack) registers and provide parallel operations for higher performance,
making the 8087&#39;s stack instructions largely obsolete.</p>
<h2>The success of the 8087</h2>
<p>At the start, Intel was unenthusiastic about producing the 8087, viewing it as unlikely to be a success.
John Palmar, a principal architect of the chip, had little success convincing
skeptical Intel management that the market for the 8087 was enormous.
Eventually,
he said, &#34;I&#39;ll tell you what. I&#39;ll relinquish my salary, provided you&#39;ll write down your number of how many you expect to sell, then give me a dollar for every one you sell beyond that.&#34;<span id="fnref2:references"><a href="#fn:references">7</a></span>
Intel didn&#39;t agree to the deal—which would have made a fortune for Palmer—but they reluctantly agreed to produce the chip.</p>
<p>Intel&#39;s Santa Clara engineers shunned the 8087, considering it unlikely to work:
the 8087 would be two to three times more complex than the 8086,
with a die so large that a wafer might not have a single working die.
Instead, Rafi Nave, at Intel&#39;s Israel site, took on the risky project: “Listen, everybody knows it&#39;s not going to work, so if it won&#39;t work, I would just fulfill their expectations or their assessment.
If, by chance, it works, okay, then we&#39;ll gain tremendous respect and tremendous breakthrough on our abilities.”</p>
<p>A small team of seven engineers developed the 8087 in Israel.
They designed the chip on Mylar sheets: a millimeter on Mylar represented a micron on the physical chip.
The drawings were then digitized on a Calma system by clicking on each polygon to create the layout.
When the chip was moved into production,
the yield was very low but better than feared: two working dies per four-inch wafer.</p>
<p>The 8087 ended up being a large success, said to have been Intel&#39;s most profitable product line at times.
The success of the 8087 (along with the 8088) cemented the reputation of Intel Israel, which eventually became Israel&#39;s largest tech employer.
The benefits of floating-point hardware proved to be so great that Intel integrated the floating-point unit into later processors
starting with the 80486 (1989).
Nowadays, most modern computers, from cellphones to mainframes, provide floating point based on the
8087,
so I consider the 8087 one of the most influential chips ever created.</p>
<p>For more, follow me on
 Bluesky (<a href="https://bsky.app/profile/righto.com">@righto.com</a>),
Mastodon (<a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="355e505b465d5c47475c5353755a5951574c4150461b4645545650">[email protected]</span></a>),
or <a href="https://www.righto.com/feeds/posts/default">RSS</a>.
I wrote some articles about the 8087 a few years ago, including <a href="https://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html">the die</a>,
<a href="https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html">the ROM</a>,
the <a href="https://www.righto.com/2020/05/die-analysis-of-8087-math-coprocessors.html">bit shifter</a>,
and <a href="https://www.righto.com/2020/05/extracting-rom-constants-from-8087-math.html">the constants</a>, so you may have seen some of this material before.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
