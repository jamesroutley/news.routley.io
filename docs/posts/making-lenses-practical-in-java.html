<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chriskiehl.com/article/practical-lenses">Original</a>
    <h1>Making Lenses Practical in Java</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><article id="article"><p><img alt="" src="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted-image-20230115104306.jpeg" srcset="https://d39wtn5cxihhz5.cloudfront.net/content/800Pasted-image-20230115104306.jpeg 800w, https://d39wtn5cxihhz5.cloudfront.net/content/667Pasted-image-20230115104306.jpeg 667w, https://d39wtn5cxihhz5.cloudfront.net/content/534Pasted-image-20230115104306.jpeg 534w, https://d39wtn5cxihhz5.cloudfront.net/content/401Pasted-image-20230115104306.jpeg 401w, https://d39wtn5cxihhz5.cloudfront.net/content/268Pasted-image-20230115104306.jpeg 268w, https://d39wtn5cxihhz5.cloudfront.net/content/135Pasted-image-20230115104306.jpeg 135w"/></p><p><small>Published: 2023-01-15</small></p><p>This is about Lenses, what they are, how you write them by hand, why writing them by hand sucks, how to <em>stop</em> writing them by hand, and how to have <a href="https://github.com/chriskiehl/Deoplice">an awesome library</a> do it for you. We&#39;re going to turn code like this: </p><pre><code>pendingOrders.map(order -&gt; 
        order.withApproval(order.getApproval().withConfirmation(
                order.getApproval().getConfirmation().withUpdatedOn(LocalDateTime.now())
        )) 
    )
</code></pre><p>into code like this: </p><pre><code>pendingOrders.map(setApprovalConfirmationUpdatedOn(LocalDateTime.now()));
</code></pre> <p>What&#39;s a lens? For the purposes of Java speak, we&#39;re going to call them chainable (or maybe fluent?) getters and setters<sup>[0]</sup>. They give us a way to update complex, potentially nested, <em>immutable</em> objects without any of the awful boilerplate that we usually have to endure. </p><p>They don&#39;t come for free, though. Actually, on their own, Lenses are pretty impractical if you&#39;re trying to type them out by hand. They require laying <i>a lot</i> of code scaffolding before you can start doing anything useful. It&#39;s the type of thing where you can end up writing hundreds of lines of code in an effort to save dozens. However, once they&#39;re in place, they enable expressing updates with a level of clarity that borders on magical.<br/></p><h2>Background: making updates without lenses</h2><p>The main problem here is that making complex updates to immutable data classes is terrible. While <a href="https://projectlombok.org/">Lombok</a> has helped drag us out of the dark ages, updating our shiny immutable data classes is still done with primitive tools. The more complex the data, the less effective these tools become. </p><p>Java&#39;s hammer for immutable updates is the <code>withFoo(...)</code> pattern (&#34;Withers&#34; from here on out). These are just like the fluent builders and setters of old, except they return back a <i>copy</i> of the object, rather than mutating it in place. </p><pre><code>// These are the data classes we&#39;ll use 
// throughout the article

@With
@Value
class PurchaseOrder {
    String number; 
    Approval approval; 
    Integer version; 
}
@With
@Value
class Approval {
    ApprovalStatus status;
    List&lt;Comment&gt; comments; 
    Confirmation confirmation;
}
@With
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
</code></pre><p>The Withers are actually pretty great as long as your updates are simple and at the root level of your object. </p><pre><code>order.withNumber(&#34;000A12&#34;).withVersion(1)  
</code></pre><p>However, as soon as you try to do any updates that involves the object&#39;s children things descend into chaos. </p><pre><code>order.withApproval(order.getApproval().withConfirmation(
	order.getApproval().getConfirmation().withUpdatedOn(LocalDateTime.now())
));
</code></pre><p>What we&#39;re trying to accomplish (stamping the current time on the Confirmation) is completely overshadowed by the mechanics required to do it. We&#39;ve lost the &#34;what&#34; in a sea of &#34;how&#34;. The more complex the action, the worse this boilerplate becomes. </p><p>The problem is that Withers don&#39;t compose across types. They only know about the object they belong to, which is why we&#39;re forced to create pyramids of nested Withers whenever we need to update child objects. </p><h2>Lenses make updates composable</h2><p>Here&#39;s the same update using lenses.</p><pre><code>approval.compose(confirmation).compose(updatedOn).set(order, LocalDateTime.now())
</code></pre><p>We&#39;re composing things by hand for sake of example, so this is still a bit boilerplate-y. We can do better by factoring out the manual composition:</p><pre><code>set($approval, $confirmation, $updatedOn, LocalDateTime.now()).apply(order)
</code></pre><p>And then we can go even further – because composition with lenses is entirely and mindlessly mechanical, we don&#39;t need to do any of it by hand! Just like Lombok can automatically generate Withers that operate on the root object, we can have <a href="https://github.com/chriskiehl/Deoplice">Deoplice</a> generate Withers that operate across <i>the entire hierarchy of the data type</i>!<br/></p><pre><code>setApprovalConfirmationUpdatedOn(LocalDateTime.now()).apply(order) 
</code></pre><p>Further, you can generate these custom methods for <i>every</i> field in your class. Because lenses compose, you can turn even complex updates across multiple data hierarchies into crystal clear declarative statements. </p><pre><code>// Try doing this with just nested `withX(...)` statements! 
addApprovalComments(Comment.of(&#34;lgtm!&#34;))
	.andThen(setApprovalStatus(COMPLETED)) 
	.andThen(updateVersion(x -&gt; x + 1))
	.apply(order)
</code></pre><p>Beyond just the reduction in boilerplate (which is a lot!), the main gain is <em>readability</em>. We&#39;re no longer burying the &#34;what&#34; in layers of &#34;how&#34;. We get to live up in declarative land where we can just say &#34;Add a new comment, change the status to completed, and bump the version.&#34;</p><p>How does it work? </p><h2>Lenses: from the ground up</h2><p>Lenses, at their most basic, are just an abstraction on top of getters and setters. This is the whole definition<sup>[0]</sup>: </p><pre><code>interface Lens&lt;A, B&gt; {  
    B get(A a);
    A set(A a, B b)
}
</code></pre><p>This is just saying that for some object type <code>A</code> we must have a getter and setter for its field of some type <code>B</code>. </p><p>An implementation looks something like this: </p><pre><code>@With
@Value
class Confirmation {
    LocalDateTime updatedOn; 
} 

// NEW! 
// This lens &#34;focuses&#34; on the updatedOn field of the Confirmation class
Lens&lt;Confirmation, LocalDateTime&gt; $updatedOn = new Lens&lt;&gt;() {  
    @Override  
    public LocalDateTime get(Confirmation conf) {  
        return conf.getUpdatedOn();
    }  
  
    @Override  
    public Confirmation set(Confirmation conf, LocalDateTime updatedOn) {
        return updatedOn.withUpdatedOn(updatedOn);     
    }  
};
</code></pre><blockquote><p>In Optics parlance, this lens <i>focuses</i> on the <code>updatedOn</code> field inside of the <code>Confirmation</code> class.<br/></p></blockquote><p>On it&#39;s own, it&#39;s not very interesting. All we&#39;ve done is wrap the getters and setters we already had on the object. The real power comes from the fact that we can define what it means for two lenses to <i>compose</i> </p><pre><code>interface Lens&lt;A, B&gt; {
    B get(A a);
    A set(A a, B b);

	// NEW! 
	default &lt;C&gt; Lens&lt;A, C&gt; compose(Lens&lt;B, C&gt; inner) {  
		Lens&lt;A, B&gt; outer = this;  
		return new Lens&lt;A, C&gt;() {  
			@Override  
			public C get(A a) {  
				return inner.get(outer.get(a));  
			}  
	  
			@Override  
			public A set(A a, C c) {  
				// Check it out! We&#39;re abstracting away the mechanics 
				// of &#34;how&#34; we descend into inner child types so that we 
				// don&#39;t have to deal with it as consumers
				return outer.set(a, inner.set(outer.get(a), c));  
			}  
		};  
	}
}
</code></pre><p>Now we&#39;ve got something that&#39;s <strong><i>subtly magical</i></strong>. We can compose <em>lenses</em> just like we can compose <em>functions</em>. If we&#39;ve got a Lens from <code>PurchaseOrder -&gt; Approval</code> and we compose it with a Lens from  <code>Approval -&gt; Confirmation</code>, we&#39;re gifted a new function that goes from <code>PurchaseOrder -&gt; Confirmation</code>. This is massive, because now we don&#39;t have to <i>nest</i> ever deeper calls to withers when we want to change a piece of nested data -- the lens does it for us -- we can just compose a recipe that targets it, and then call <code>set</code>.<br/></p><p>Here&#39;s an example of just that: </p><pre><code>@With  // NEW! 
@Value
class Approval {
    Confirmation confirmation;
}
@With
@Value
class Confirmation {
    LocalDateTime updatedOn; 
} 


// NEW! This lens focuses on Approval&#39;s confirmation field
Lens&lt;Approval, Confirmation&gt; $confirmation = new Lens&lt;&gt;() {  
    @Override  
    public Confirmation get(Approval approval) {  
        return approval.getConfirmation();
    }  
  
    @Override  
    public Approval set(Approval approval, Confirmation conf) {
        return approval.withConfirmation(conf);     
    }  
};


Lens&lt;Confirmation, LocalDateTime&gt; $updatedOn = new Lens&lt;&gt;() {  
    @Override  
    public LocalDateTime get(Confirmation conf) {  
        return conf.getUpdatedOn();
    }  
  
    @Override  
    public Confirmation set(Confirmation conf, LocalDateTime updatedOn) {
        return updatedOn.withUpdatedOn(updatedOn);     
    }  
};
</code></pre><p>This compositional power takes us from nested withers: </p><pre><code>approval.withConfirmation(approval.getConfirmation().withUpdatedOn(LocalDateTime.now()))

</code></pre><p>To composed lenses! </p><pre><code>$confirmation.compose($updatedOn).set(approval, LocalDateTime.now())
</code></pre><p>Pretty sick! Now you see the real boilerplate reducing power of lenses! To save typing 20 characters, we only had to type an extra <em>723</em>! That&#39;s a huge savi– wait a minute – no, no.  right... This still sucks. </p><p>This code explosion is why writing lenses by hand is impractical. We could, of course, offload the creation to helper functions to hide the boilerplate of the interface implementation, but the root problem remains: typing this out for every field in every class would suuuuuck. God help you if you decide to rename one of those fields. </p><p>Which is why we <i>don&#39;t</i> do that. We offload that drudgery to the machines. </p><h2>Automatically Generating Lenses in Java</h2><blockquote><p>Note: Deoplice is in alpha and is currently symbiotic with Lombok. It depends on its @With annotations in order to generate the Lenses which back its API implementation  <br/></p></blockquote><p><a href="https://github.com/chriskiehl/Deoplice">Deoplice</a> is a library<sup>[1]</sup> for automatically generating lens implementations. It works via annotations just like Lombok. </p><p>Given our same set of starting classes, we can generate not only lenses for every field, but also <i>all of their possible compositions</i> as a pre-baked API! </p><pre><code>@With
@Value
@Updatable // NEW! 
class PurchaseOrder {
    String number; 
    Approval approval; 
    Integer version; 
}
@With
@Value
class Approval {
    ApprovalStatus status;
    List&lt;Comment&gt; comments; 
    Confirmation confirmation;
}
@With
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
</code></pre><p>The generated lenses mirror your classes 1:1 but will have an added <code>Lens</code> suffix on the class name, and a <code>$</code> prefix on the variable names (to avoid collisions). So, our <code>PurchaseOrder</code> class: </p><pre><code>class PurchaseOrder {
    String number; 
    Approval approval; 
    Integer version; 
}
</code></pre><p>Would get a generated lens version like this: </p><pre><code>class PurchaseOrderLens {
	Lens&lt;PurchaseOrder, String&gt; $number = ... 
	Lens&lt;PurchaseOrder, Approval&gt; $approval = ... 
	Lens&lt;PurchaseOrder, Integer&gt; $version = ... 
}
</code></pre><p>And ditto for every other class referenced from the annotated one. </p><p>Since manually composing lenses is still obnoxious, Deoplice also ships with a suite of helper methods for building long chains of updates. </p><pre><code>set($approval, $confirmation, $updatedOn, LocalDateTime.now())
	.andThen(update($approval, $version, x -&gt; x + 1))
	.apply(order); 
</code></pre><p>But lenses – even when entirely generated – are still too verbose! The <em>real</em> way to use Deoplice is to move one level up the abstraction ladder and use the API it generates <i>on top</i> of the lenses! </p><p>With it, you can create declarative updates that read just like English prose. </p><pre><code>addApprovalComments(Comment.of(&#34;lgtm!&#34;))
	.andThen(setApprovalStatus(COMPLETED)) 
    .andThen(updateVersion(x -&gt; x + 1))
    .apply(order)
</code></pre><p>Further, it goes beyond getters and setters and provides immutable facades for interacting with collection types on your objects! Trying to deal with Java&#39;s mutable collections when they&#39;re used on what is supposed to be an <em>immutable</em> object is usually a recipe for pain. Almost invariably, to do something as simple as adding an item to a list, you have to pull the list out of the POJO, make a copy, do the transform, and then <code>with</code> (or <code>Lens.set</code>) it back into place.</p><pre><code>List&lt;Comment&gt; original = order.getApproval().getComments()
List&lt;Comment&gt; updated = Stream.concat(original, Stream.of(Comment.of(&#34;lgtm!&#34;)).collect(Collectors.toList());
return order.withApproval(order.getApproval().withComments(updated));
</code></pre><p>More boilerplate that hides what we&#39;re trying to actually accomplish! Instead, Deoplice&#39;s API does all of this copy-on-write for you behind the scenes. You get to stay up in declarative land and leave all the plumbing to the generated code. </p><p>Here&#39;s how that exact same action looks with Deoplice&#39;s generated API: </p><pre><code>addApprovalComment(Comment.of(&#34;lgtm!&#34;)).apply(order); 
</code></pre><p>This is what updating immutable data classes can look like with modern tooling. </p><p>Checkout <a href="https://github.com/chriskiehl/Deoplice">Deoplice</a> and let me know what you think! </p><h3>Footnotes</h3><ul><small> 		<li>[0] The Optics nerds would call such a definition worthless and wrong, but that&#39;s OK. </li> 		<li>[1] Written by a <a href="https://chriskiehl.com/about">super cool dude</a>. </li> 	</small></ul><small> </small></article></div></div></div></div>
  </body>
</html>
