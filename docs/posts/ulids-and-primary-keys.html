<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.daveallie.com/ulid-primary-keys">Original</a>
    <h1>ULIDs and Primary Keys</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>When it comes to picking the type for your database&#39;s primary keys, there are a few divided camps. When making this
decision for <a href="https://www.linkedin.com/company/visibuild-pty-ltd/">Visibuild</a> I had to choose between the simplicity of
sequential IDs and the longevity/future benefits of non-sequential IDs. I chose non-sequential IDs to make it easier to
deal with sharding and regional databases in the future. Out of the many flavours of non-sequential IDs I chose ULIDs.</span></p><p><span>Here&#39;s how I got there.</span></p><p><span>Let&#39;s start where most people do, with UUIDs.</span></p><p><span>UUIDs (universally unique identifiers) are 128-bit labels typically represented as a hexadecimal string broken up into
5 sections containing 32 bits, 16 bits, 16 bits, 16 bits, and 48 bits respectively.</span></p><p><span>Here&#39;s an example:</span></p><p><span><span>
      <a href="https://blog.daveallie.com/static/3e5a890ed37a8b9eed84de01519d99de/b5cea/UUID.png">
    <span></span>
  <img alt="UUID" title="UUID" src="https://blog.daveallie.com/static/3e5a890ed37a8b9eed84de01519d99de/b5cea/UUID.png" srcset="/static/3e5a890ed37a8b9eed84de01519d99de/5a46d/UUID.png 300w,/static/3e5a890ed37a8b9eed84de01519d99de/0a47e/UUID.png 600w,/static/3e5a890ed37a8b9eed84de01519d99de/b5cea/UUID.png 1140w" sizes="(max-width: 1140px) 100vw, 1140px" loading="lazy" decoding="async"/>
  </a>
    </span></span></p><p><span>Within the UUID standard (which you can read about in <a href="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</a>), there
are 5 different versions of that same 128-bit label. The differences between the versions are which inputs are required
to generate the UUID and the structure of the bits that are output.</span></p><p><span>Version 1 requires knowledge of the computer&#39;s MAC address to generate the label. Version 2 is only guaranteed to be
unique if at most one is generated per computer about every 7 minutes. Versions 3 and 5, are deterministic based on the
supplied input. This leaves only version 4 as a suitable choice for scalable, non-deterministic UUIDs.</span></p><p><span>When people say UUID they&#39;re almost always referring to UUIDv4. It&#39;s the most prevalent and widely supported UUID
standard, even the example UUID given above is a UUIDv4. As UUIDv4 is based solely on randomness, it is extremely
portable and can be used with very little prior knowledge about the state of the system.</span></p><p><span>UUIDv4 are composed of <strong>122</strong> bits of randomness, and <strong>6</strong> bits of version/variant identification.</span></p><p><span><div><p><span>
      <a href="https://blog.daveallie.com/static/3837534af89b4507b55b4fbbd0635652/b5cea/UUIDv4.png">
    <span></span>
  <img alt="UUIDv4" title="UUIDv4" src="https://blog.daveallie.com/static/3837534af89b4507b55b4fbbd0635652/b5cea/UUIDv4.png" srcset="/static/3837534af89b4507b55b4fbbd0635652/5a46d/UUIDv4.png 300w,/static/3837534af89b4507b55b4fbbd0635652/0a47e/UUIDv4.png 600w,/static/3837534af89b4507b55b4fbbd0635652/b5cea/UUIDv4.png 1140w" sizes="(max-width: 1140px) 100vw, 1140px" loading="lazy" decoding="async"/>
  </a>
    </span></p><pre></pre></div></span></p><p><span><div><p><span>info_outline</span></p><p>Click the &#34;Regenerate&#34; button to see a few different UUIDv4.</p></div></span></p><p><span>The only non-random sections of a UUDv4 are the version and variant. The version is represented by 4 bits and is always
set to 4 for UUIDv4, you can see it highlighted as the first orange nibble above. The variant is represented by 2 bits
and is set to 2 for the UUIDv4 standard, you can see it highlighted as the second orange nibble above.</span></p><p><span><div><p><span>info_outline</span></p><p>The variant is only the first 2 bits of the second highlighted nibble. While the remaining 2 are random, meaning the value of that nibble can be 8 (<code>1000</code>), 9 (<code>1001</code>), a (<code>1010</code>), or b (<code>1011</code>)</p></div></span></p><p><span>While there are only 5 UUID variants in the RFC, there&#39;s
<a href="https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format">a draft</a> that includes 3 new ones:
UUIDv6, UUIDv7, and UUIDv8.</span></p><p><span>The three new versions are all based on a similar structure of a combination of time bits in the most significant
positions, followed by random bits. The difference between the three is which kind of clock is used to generate the time
bits. Version 7 from the draft is using Unix Epoch time, making it the likely candidate for adoption in the future.</span></p><p><span>Even within version 7, there are a few different ways to represent the time. Different levels of sub-second precision
can be used, but the more precise in time you get, the fewer random bits you&#39;ll be able to use. Let&#39;s take a look at the
millisecond precision setup of UUIDv7.</span></p><p><span>With the millisecond precision setup, there are <strong>48</strong> bits of time, <strong>6</strong> bits of version/variant, <strong>12</strong> bits for a
monotonic sequence, and <strong>62</strong> bits of randomness.</span></p><p><span><div>  <p><span>
      <a href="https://blog.daveallie.com/static/4eb658ded2f2eb0bfc610f11af09c0b5/cd1d6/UUIDv7.png">
    <span></span>
  <img alt="UUIDv7" title="UUIDv7" src="https://blog.daveallie.com/static/4eb658ded2f2eb0bfc610f11af09c0b5/cd1d6/UUIDv7.png" srcset="/static/4eb658ded2f2eb0bfc610f11af09c0b5/5a46d/UUIDv7.png 300w,/static/4eb658ded2f2eb0bfc610f11af09c0b5/0a47e/UUIDv7.png 600w,/static/4eb658ded2f2eb0bfc610f11af09c0b5/cd1d6/UUIDv7.png 1141w" sizes="(max-width: 1141px) 100vw, 1141px" loading="lazy" decoding="async"/>
  </a>
    </span></p><pre></pre></div></span></p><p><span>UUIDv7 always dedicates the first 36 bits to the seconds of the timestamp, and then a variable amount of bits for the
sub-second precision, in our case that&#39;s 12 bits for the milliseconds within the second.</span></p><p><span><div><p><span>info_outline</span></p><p>If you click &#34;Regenerate&#34; a few times, you should see the first 9 characters of the timestamp only change once a second, these are the bits representing the Unix Epoch time in seconds. The last three bits are the milliseconds within that second.</p></div></span></p><p><span>The version and variant follow the same setup as UUIDv4, however the version is set to 7.</span></p><p><span>The main value for the timestamp at the front of the UUID is that UUIDv7s (and the other new UUIDs in the draft) are
monotonically increasing (within the same sub-second), meaning that a UUIDv7 generated now is always going to be larger
than a UUIDv7 generated a millisecond ago.</span></p><p><span>You&#39;ll also notice a new kind of section in UUIDv7, the &#34;monotonic sequence&#34; section. This section of 12 bits is
designed to ensure that the UUIDs generated within the same sub-second are also monotonically increasing. In our case,
for each subsequent UUIDv7 generated within the same millisecond, the monotonic sequence counter will increase by one.
Note that this is only relevant for UUIDs generated on the same machine within the same millisecond, it will not ensure
any ordering of UUIDs if they&#39;re generated independently of each other in the same millisecond.</span></p><p><span>Here are some example UUIDs generated in the same millisecond:</span></p><p><span><ul><li><code>061ff8d8-e24b-7000-8092-ca1e5440d491</code></li><li><code>061ff8d8-e24b-7001-b653-1c41e471cd78</code></li><li><code>061ff8d8-e24b-7002-9bc2-82b5da559f1d</code></li></ul></span></p><p><span>When using UUIDv7 as a primary key, you get the same sortability as a sequential ID with the flexibility of
distributed generation. If you&#39;re looking to do a performant sort on creation time using UUIDv4, you&#39;d need a separate
indexed creation time column, but if you&#39;re using UUIDv7 then you can use the primary key as the sort column (since it&#39;s
already indexed).</span></p><p><span>In late 2017, almost 4 years before the UUIDv7 specification was drafted, the Universally Unique Lexicographically
Sortable Identifier (or ULID) was proposed, not as an RFC Draft, but as a grassroots proposal over GitHub. You can take
a read of the (quite concise) <a href="https://github.com/ulid/spec">specification for ULID</a> on GitHub.</span></p><p><span>A ULID is a 128-bit label, just like a UUID. It&#39;s sortable, has millisecond precision, and is monotonically increasing,
just like UUIDv7.</span></p><p><span>ULIDs are typically represented as a <a href="http://www.crockford.com/base32.html">Crockford&#39;s Base 32</a> encoded string, instead
of a hexadecimal string like UUIDs. As an example, instead of <code>017eb31e-1440-b69e-d82f-5f0937f823c8</code>, the same value can
be represented as <code>0GWWXY2G84DFMRVWQNJ1SRYCMC</code>.</span></p><p><span>For the purpose of comparison with UUIDs, I&#39;m going to represent all ULIDs as hexadecimal strings, in the same 8, 4, 4,
4, 12 segments which we have been using.</span></p><p><span>Within a ULID, there are <strong>48</strong> bits of time and <strong>80</strong> bits of randomness.</span></p><p><span><div>  <p><span>
      <a href="https://blog.daveallie.com/static/cda2a3c6f2f8e211041c36c6f5d3640b/b5cea/ULID.png">
    <span></span>
  <img alt="ULID" title="ULID" src="https://blog.daveallie.com/static/cda2a3c6f2f8e211041c36c6f5d3640b/b5cea/ULID.png" srcset="/static/cda2a3c6f2f8e211041c36c6f5d3640b/5a46d/ULID.png 300w,/static/cda2a3c6f2f8e211041c36c6f5d3640b/0a47e/ULID.png 600w,/static/cda2a3c6f2f8e211041c36c6f5d3640b/b5cea/ULID.png 1140w" sizes="(max-width: 1140px) 100vw, 1140px" loading="lazy" decoding="async"/>
  </a>
    </span></p><pre></pre></div></span></p><p><span>While there are 48 bits of time information in both UUIDv7 (with millisecond precision) and ULID, the ULID standard
encodes the time as Unix Epoch in milliseconds for the whole 48 bits whereas UUIDv7 splits the time into 36 seconds bits
and 12 millisecond bits.</span></p><p><span>ULIDs also remove the bits pertaining to the version and variant, giving us 6 extra bits to play with but removing all
indication that ULIDs are in fact ULIDs. Because UUIDs encode version and variant information inside the label, they can
be reliably decoded into their composite parts (e.g. timestamp and randomness). If you wanted to extract the timestamp
from a ULID, the client would need to know that the string being processed is a ULID, and not an invalid (or potentially
valid looking) UUID.</span></p><p><span>ULIDs are monotonically increasing, but there is no defined monotonic counter like in UUIDv7. Instead, ULIDs generated
in the same millisecond on the same machine will have sequential randomness sections.</span></p><p><span>Here are some example ULIDs generated in the same millisecond:</span></p><p><span><ul><li><code>017ece40-2a1e-63ac-a58d-e336f30c1d76</code></li><li><code>017ece40-2a1e-63ac-a58d-e336f30c1d77</code></li><li><code>017ece40-2a1e-63ac-a58d-e336f30c1d78</code></li></ul></span></p><p><span>ULIDs are a great alternative to ULIDv7s. They contain more randomness and a straightforward structure at the cost of
not explicitly exposing the version, variant, or monotonic counter. UUIDs are also the perfect choice if you&#39;re writing
some apocalypse-scenario software (assuming you have a working computer) as they can continue to be generated until
10,889AD compared to UUIDv7s measly 4,147AD death date.</span></p><div><div><h2>The main differences between UUIDv7 and ULID are:</h2></div></div><p><span><ul><li>UUIDv7</li><li>UUIDv7 will work until 4,147AD whereas ULID will work until 10,889AD</li></ul></span></p><div><div><table><thead><tr><th>Format</th><th>Sortable</th><th>Monotonic</th><th>Randomness</th></tr></thead><tbody><tr><td>UUIDv4</td><td>No</td><td>No</td><td>122 bits</td></tr><tr><td>UUIDv7</td><td>Yes</td><td>Yes</td><td>62 bits</td></tr><tr><td>ULID</td><td>Yes</td><td>Yes</td><td>80 bits<!-- -->*</td></tr></tbody></table></div></div><p><span>*<!-- --> - Random bits are incremented sequentially within the same millisecond.</span></p><div><div><h2>Implementing UUIDs/ULIDs in PostgreSQL</h2></div></div><p><span><div><p><span>info_outline</span></p><p>This section is tailored to PostgreSQL, if you&#39;re using a different database engine then you&#39;ll need to look elsewhere to understand how to implement these kinds of primary keys.</p></div></span></p><p><span>While all of these formats can be generated by the client before inserting them into the database, for the purpose of
simplicity and consistency, having them be generated within the database engine is preferred.</span></p><p><span>Thankfully, PostgreSQL includes a <a href="https://www.postgresql.org/docs/14/datatype-uuid.html"><code>uuid</code> data type</a> which
accepts a case insentive 128-bit hexadecimal string, parses it into binary data and stores it as 16 bytes of data. This
is drastically better than storing the value as a string in the database, which would take up 37 bytes of space
including the dashes, or 33 bytes of space with the dashes stripped out.</span></p><p><span>Here are some implementation details for populating those <code>uuid</code> columns and setting up tables with UUID/ULID primary
keys:</span></p><p><span>PostgreSQL has built in support for UUIDv4 through the <code>pgcrypto</code> or the <code>uuid-ossp</code> extensions.</span></p><pre><div><div><div><pre><code><span>CREATE</span><span> EXTENSION IF NOT EXISTS pgcrypto;
</span>
<span></span><span>SELECT</span><span> gen_random_uuid();
</span><span>--&gt; </span><span>f449a5bc</span><span>-a</span><span>221</span><span>-</span><span>4</span><span>e</span><span>9</span><span>d-</span><span>8819</span><span>-e</span><span>7</span><span>f</span><span>22</span><span>b</span><span>83</span><span>d</span><span>8</span><span>ae</span></code></pre></div></div></div></pre><p><span>This makes it extremely easy to setup a table with a UUIDv4 primary key:</span></p><pre><div><div><div><pre><code><span>CREATE</span><span> </span><span>TABLE</span><span> my_uuidv4_things(
</span><span>  </span><span>id</span><span> </span><span>UUID</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span> </span><span>DEFAULT</span><span> gen_random_uuid(),
</span><span>  </span><span>name</span><span> </span><span>TEXT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,
</span><span>  PRIMARY </span><span>KEY</span><span> (</span><span>id</span><span>)
</span>);
<!-- -->
<span></span><span>INSERT</span><span> </span><span>INTO</span><span> my_uuidv4_things(</span><span>name</span><span>) </span><span>VALUES</span><span> (</span><span>&#39;foo&#39;</span><span>);
</span>
<span></span><span>SELECT</span><span> * </span><span>FROM</span><span> my_uuidv4_things;
</span><span></span><span>--                  id                  | name</span><span>
</span><span></span><span>----------------------------------------+------</span><span>
</span><span></span><span>-- 8501364b-b669-4c17-bd98-00bad8cd8f7d | foo</span></code></pre></div></div></div></pre><p><span>There don&#39;t seem to be any existing built-in or extension functions that support generating UUIDv7s in PostgreSQL. To
generate a UUIDv7, the function below could be tweaked in order to support the correct formatting.</span></p><p><span>There are a few different implementations of ULIDs in <a href="https://github.com/iCyberon/pg_ulid">Go</a>, or in
<a href="https://github.com/geckoboard/pgulid">plsql</a>. However, both of these implementations return the Crockford Base 32 text
representation of ULID (taking up 26 bytes), instead of as a UUID datatype (taking up 16 bytes). Due to the natural
multiplexing nature of PostgreSQL (and relational databases in general), having a consistent, shared monotonic counter
is difficult, if not impossible. The <a href="https://github.com/oklog/ulid">Go library</a> used by the Go PostgreSQL
implementation includes an implementation of the monotonic counter, however, it&#39;s not used by the Go PostgreSQL
extension. The plsql implementation doesn&#39;t have a monotonic counter at all.</span></p><p><span>I wanted a simple ULID PostgreSQL implementation without the complexity of the monotonic counter that generated a
UUID data typed value. So I wrote one:</span></p><pre><div><div><div><pre><code><span>CREATE</span><span> </span><span>EXTENSION</span><span> </span><span>IF</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> pgcrypto;
</span>
<span></span><span>CREATE</span><span> </span><span>OR REPLACE</span><span> </span><span>FUNCTION</span><span> generate_ulid() </span><span>RETURNS</span><span> </span><span>uuid</span><span>
</span><span>    </span><span>AS</span><span> $$</span><span>
</span><span>        </span><span>SELECT</span><span> (lpad(to_hex(floor(extract(</span><span>epoch</span><span> </span><span>FROM</span><span> clock_timestamp()) * </span><span>1000</span><span>)::</span><span>bigint</span><span>), </span><span>12</span><span>, </span><span>&#39;0&#39;</span><span>) || encode(gen_random_bytes(</span><span>10</span><span>), </span><span>&#39;hex&#39;</span><span>))::</span><span>uuid</span><span>;
</span><span>    $$</span><span> </span><span>LANGUAGE</span><span> </span><span>SQL</span><span>;
</span>
<span></span><span>SELECT</span><span> generate_ulid();
</span><span></span><span>--&gt; 017eb31e-1440-b69e-d82f-5f0937f823c8</span></code></pre></div></div></div></pre><p><span>Breaking down the function:</span></p><p><span><ul><li>The first half <code>lpad(to_hex(floor(extract(epoch FROM clock_timestamp()) * 1000)::bigint), 12, &#39;0&#39;)</code> gets the
milliseconds since the Unix Epoch, and converts it to a hexadecimal string of length 12 (it&#39;ll have a leading 0 for the
next 500 years or so).</li><li>The second half <code>encode(gen_random_bytes(10), &#39;hex&#39;)</code> generates 10 random bytes and converts them to hexadecimal.</li></ul></span></p><p><span>Together these make the 16-byte (or 128-bit) ULID label, which is finally cast to a UUID data type with <code>::uuid</code>.</span></p><p><span>Our new function can now be used as a default value for a primary key:</span></p><pre><div><div><div><pre><code><span>CREATE</span><span> </span><span>TABLE</span><span> my_ulid_things(
</span><span>  </span><span>id</span><span> </span><span>UUID</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span> </span><span>DEFAULT</span><span> generate_ulid(),
</span><span>  </span><span>name</span><span> </span><span>TEXT</span><span> </span><span>NOT</span><span> </span><span>NULL</span><span>,
</span><span>  PRIMARY </span><span>KEY</span><span> (</span><span>id</span><span>)
</span>);
<!-- -->
<span></span><span>INSERT</span><span> </span><span>INTO</span><span> my_ulid_things(</span><span>name</span><span>) </span><span>VALUES</span><span> (</span><span>&#39;foo&#39;</span><span>);
</span>
<span></span><span>SELECT</span><span> * </span><span>FROM</span><span> my_ulid_things;
</span><span></span><span>--                  id                  | name</span><span>
</span><span></span><span>----------------------------------------+------</span><span>
</span><span></span><span>-- 017eb31e-1440-b69e-d82f-5f0937f823c8 | foo</span></code></pre></div></div></div></pre><p><span>When compared to the native implementation of <code>gen_random_uuid()</code>, <code>generate_ulid()</code> performs <strong>73% slower</strong> when
<strong>generating</strong> 10 million values, but only <strong>31% slower</strong> when <strong>generating and inserting</strong> 1 million values.</span></p><p><span>Meaning that while ULIDs are slower to generate (at least with this implementation), they are much faster to insert. My
guess is that due to the sequential and highly clustered significant bytes of the ULIDs, they are much faster to create the
index entries for. Meanwhile, the UUIDv4s are extremely sparse, so they are much slower to create the index entries for.</span></p><p><span>Here&#39;s how I got these numbers:</span></p><pre></pre><pre><div><div><div><p><span></span><span>generate-benchmark.sql</span></p><pre><code><span>EXPLAIN</span><span> </span><span>ANALYSE</span><span> </span><span>SELECT</span><span> gen_random_uuid() </span><span>FROM</span><span> generate_series(</span><span>1</span><span>, </span><span>1000000</span><span>);
</span><span></span><span>-- 6766.681ms</span><span>
</span>
<span></span><span>EXPLAIN</span><span> </span><span>ANALYSE</span><span> </span><span>SELECT</span><span> generate_ulid() </span><span>FROM</span><span> generate_series(</span><span>1</span><span>, </span><span>1000000</span><span>);
</span><span></span><span>-- 11750.966ms</span></code></pre></div></div></div></pre><pre><div><div><div><p><span></span><span>generate-insert-benchmark.sql</span></p><pre><code><span>CREATE</span><span> </span><span>TABLE</span><span> uuid_keys(id </span><span>UUID</span><span>);
</span><span></span><span>CREATE</span><span> </span><span>TABLE</span><span> ulid_keys(id </span><span>UUID</span><span>);
</span>
<span></span><span>EXPLAIN</span><span> </span><span>ANALYSE</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> uuid_keys(id)
</span><span></span><span>SELECT</span><span> gen_random_uuid() </span><span>FROM</span><span> generate_series(</span><span>1</span><span>, </span><span>1000000</span><span>);
</span><span></span><span>-- 1372.470ms</span><span>
</span>
<span></span><span>EXPLAIN</span><span> </span><span>ANALYSE</span><span> </span><span>INSERT</span><span> </span><span>INTO</span><span> ulid_keys(id)
</span><span></span><span>SELECT</span><span> generate_ulid() </span><span>FROM</span><span> generate_series(</span><span>1</span><span>, </span><span>1000000</span><span>);
</span><span></span><span>-- 1803.472ms</span></code></pre></div></div></div></pre><p><span>ULIDs are slower than their counterparts. For me, the benefits of a sortable globally unique identifier make the
tradeoff worth it.</span></p></div></div>
  </body>
</html>
