<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ducktypelabs.com/how-does-turbo-listen-for-turbo-streams/">Original</a>
    <h1>How does Turbo listen for Turbo Streams</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <nav>
        <a href="https://ducktypelabs.com/">Home</a>
      </nav>
      
      
      <section><p><img src="https://ducktypelabs.com/assets/images/ben-about-to-bark.png" alt="Ben about to raise hell"/>
</p>

<p><a href="https://ducktypelabs.com/the-anatomy-of-a-turbo-stream/">Turbo Stream</a> elements are custom HTML elements which change the DOM when they are added to it. A <code>&lt;turbo-stream&gt;</code> tag can, by specifying an <code>action</code> attribute, trigger one of <a href="https://turbo.hotwired.dev/handbook/streams#stream-messages-and-actions">seven “DOM changing” actions</a>: append, prepend, replace, update, remove, before and after. For example, a user lands on a page with a list of Books and sees a form to create a new book. They fill out the form and submit, and the server responds with a <code>&lt;turbo-stream action=&#34;append&#34;&gt;</code> element which contains within it the entry for the newly created book. Turbo sees that and adds it to the DOM, which triggers the relevant <code>append</code> <a href="https://github.com/hotwired/turbo/blob/main/src/core/streams/stream_actions.js#L9">stream action</a> and adds the new book HTML to the page.</p>

<p>That’s really cool, but it raises a few questions. First, when the form is submitted, how is Turbo telling our server to send us back one or more Turbo Stream elements? And second, when the server does respond back with one or more Turbo Stream elements, how does Turbo know that it should add them to the DOM?</p>

<p>Let’s try to peer behind the curtain and figure out the answer to these questions. Doing so has a couple of important benefits:</p>

<ul>
  <li>Knowing how things work behind the scenes will improve your ability to solve issues you run into when building a feature</li>
  <li>If Turbo for some reason doesn’t do what you want it to do, knowing how it actually works will allow you to extend its behavior with confidence</li>
</ul>

<h3 id="how-does-turbo-handle-form-submissions">How does Turbo handle form submissions?</h3>

<p>When Turbo starts up in the user’s browser, it <a href="https://github.com/hotwired/turbo/blob/main/src/observers/form_submit_observer.js#L13">adds an event listener</a> to <code>document</code>, and listens for the <code>submit</code> event. When any form in the user’s browser is submitted, and that submission meets a few criteria (e.g. the submission does not happen in an iframe) this listener asks <a href="https://turbo.hotwired.dev/handbook/drive">Turbo Drive</a> to submit the form. Turbo Drive, via its <a href="https://github.com/hotwired/turbo/blob/main/src/core/drive/navigator.js#L27"><code>Navigator</code> class</a>, initiates the form submission. Form submission in Turbo Drive amounts to a two step process:</p>

<ol>
  <li>First, Turbo Drive calls <code>preventDefault</code> on the submit event. This tells the browser not to submit the form.</li>
  <li>Then, Turbo sends the form data to the server using the <code>fetch</code> API.</li>
</ol>

<p>The server thus receives the same data it would have received had Turbo not intercepted the submission. There is one important difference however; to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept">“Accept”</a> request header, Turbo adds the content/<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME</a> type: <code>text/vnd.turbo-stream.html</code>. This tells the server that it can respond with <code>&lt;turbo-stream&gt;</code> elements. The server, in turn, sends the <code>Content-Type: text/vnd.turbo-stream.html</code> header back to Turbo if it is responding with Turbo Stream elements.</p>

<p>If the server doesn’t want to respond to a successful submission with Turbo Streams, then, according to the Turbo Handbook, it should <a href="https://turbo.hotwired.dev/handbook/drive#redirecting-after-a-form-submission"><em>issue a redirect</em></a>. If not, Turbo will throw an error. On the other hand, if it wants to respond to an invalid or erroneous request with plain old HTML (containing validation error messages, presumably), it can do so and Turbo will render that on the current page.</p>

<h3 id="how-does-turbo-handle-turbo-stream-responses">How does Turbo handle Turbo Stream responses?</h3>

<p>When Turbo starts up, it attaches a listener to the <code>turbo:before-fetch-response</code> event. The listener is called (as of August 2025) <code>StreamObserver#inspectFetchResponse</code>.</p>

<p>After Turbo makes the <code>fetch</code> request and retrieves the response, it dispatches the <code>turbo:before-fetch-response</code> event, attaching the response data to it. Dispatching an event in JavaScript causes all attached listeners to be executed in order synchronously, and thus <code>inspectFetchResponse</code> is executed.</p>

<p><code>inspectFetchResponse</code> first checks if the response is a Turbo Stream response (it is if its <code>Content-Type</code> is <code>text/vnd.turbo-stream.html</code>) and if so, adds the response to the DOM. As we learned in my <a href="https://ducktypelabs.com/the-anatomy-of-a-turbo-stream/">article about Turbo Streams</a>, when <code>&lt;turbo-stream&gt;</code> elements are added to the DOM, it triggers custom JavaScript code that runs and performs the action embedded in each stream (“append”, “prepend”, “remove” etc). The cool thing about this is that the server can respond with multiple <code>&lt;turbo-stream&gt;</code> elements in a single response, and all actions will be performed one after the other.</p>

<p>Very naively (without bothering with event dispatching), we can implement this behavior like so:</p>

<div><div><pre><code><span>// Listen for all form submit events</span>
<span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;</span><span>submit</span><span>&#34;</span><span>,</span> <span>async</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>event</span><span>.</span><span>preventDefault</span><span>();</span>

  <span>const</span> <span>form</span> <span>=</span> <span>event</span><span>.</span><span>target</span><span>;</span>
  <span>const</span> <span>url</span> <span>=</span> <span>form</span><span>.</span><span>action</span><span>;</span>
  <span>const</span> <span>method</span> <span>=</span> <span>form</span><span>.</span><span>method</span><span>;</span>

  <span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>url</span><span>,</span> <span>{</span>
    <span>method</span><span>,</span>
    <span>headers</span><span>:</span> <span>{</span>
      <span>Accept</span><span>:</span> <span>&#34;</span><span>text/vnd.turbo-stream.html</span><span>&#34;</span><span>,</span>
    <span>},</span>
    <span>body</span><span>:</span> <span>new</span> <span>FormData</span><span>(</span><span>form</span><span>),</span>
    <span>// and other important stuff like credentials and CSRF token</span>
  <span>});</span>

  <span>if</span> <span>(</span><span>response</span><span>.</span><span>headers</span><span>.</span><span>get</span><span>(</span><span>&#34;</span><span>content-type</span><span>&#34;</span><span>)</span> <span>===</span> <span>&#34;</span><span>text/vnd.turbo-stream.html</span><span>&#34;</span><span>)</span> <span>{</span>
    <span>const</span> <span>turboStreamContent</span> <span>=</span> <span>await</span> <span>response</span><span>.</span><span>text</span><span>();</span>
    <span>// Adding stream elements to the DOM triggers turbo stream actions!</span>
    <span>document</span><span>.</span><span>body</span><span>.</span><span>insertAdjacentHTML</span><span>(</span><span>&#34;</span><span>beforeend</span><span>&#34;</span><span>,</span> <span>turboStreamContent</span><span>);</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// other logic to handle HTML responses</span>
  <span>}</span>
<span>});</span>
</code></pre></div></div>

<h3 id="what-about-a-regular-fetch-request">What about a regular <code>fetch</code> request?</h3>

<p>To get your server to send you back Turbo Streams when making a regular old <code>fetch</code> request, you’ll need to update the <code>Accept</code> header yourself. In Rails, this is convenient to do with the <code>@rails/request</code> library. What’s more, this library will even automatically add Turbo Stream responses to the DOM.</p>

<div><div><pre><code><span>import</span> <span>{</span> <span>patch</span> <span>}</span> <span>from</span> <span>&#34;</span><span>@rails/request.js</span><span>&#34;</span>
<span>...</span>
<span>updateBook</span><span>(</span><span>bookId</span><span>,</span> <span>book</span><span>)</span> <span>{</span>
  <span>patch</span><span>(</span><span>`my-app.com/books/</span><span>${</span><span>bookId</span><span>}</span><span>`</span><span>,</span> <span>{</span>
    <span>body</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>({</span> <span>book</span> <span>}),</span>
    <span>responseKind</span><span>:</span> <span>&#34;</span><span>turbo-stream</span><span>&#34;</span><span>,</span>
  <span>})</span>
<span>}</span>
</code></pre></div></div>

<p>Pretty convenient, huh?</p>

<p>Setting the <code>responseKind</code> to <code>turbo-stream</code> is important because it adds the <code>text/vnd.turbo-stream.html</code> MIME type to the request’s <code>Accept</code> header. That lets your server’s <code>respond_to</code> block know to render Turbo Streams.</p>

<h3 id="what-happens-if-the-server-responds-with-plain-old-html-to-a-successful-turbo-stream-form-submission">What happens if the server responds with plain old HTML to a successful Turbo stream form submission?</h3>

<p>In this case, Turbo will raise an error. If you want to render HTML, you have to issue a redirect. This seems to be a philosophical choice of sorts. Responding with HTML to a successful form submission conventionally implies a new page (and potentially a new path), so Turbo wants you to redirect to it instead of rendering it in place. If you want to render changes in place, then Turbo wants you to use Turbo Stream elements.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Conceptually, the Turbo Stream “form submission flow” is quite simple. Turbo first intercepts submissions and adds a header telling the server to respond with Turbo Streams. The successful server response is then added to the DOM. Finally, the pre-defined custom element behavior of each Turbo Stream runs automatically, making app updates visible to the user.</p>

<p>We’ve discussed Turbo Streams coming back from the server as a response to a request that the client makes. It is also possible for the server to send Turbo Streams to the client through WebSockets, without the client having to make a separate request. If you’re curious about how that works, check out my article on <a href="https://ducktypelabs.com/how-does-turbo-work-with-action-cable/">how Turbo works with ActionCable.</a></p>

<p>If you got value out of this article and want to hear more from me, consider subscribing to my email newsletter to get notified whenever I publish a new article.</p>
</section>
      <section>
        <!-- Begin Mailchimp Signup Form -->
        
      </section>
      
    </div></div>
  </body>
</html>
