<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://werat.dev/blog/how-wine-works-101/">Original</a>
    <h1>How Wine works 101</h1>
    
    <div id="readability-page-1" class="page"><div><p><strong>Wine</strong> is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, &amp; BSD (<a href="https://www.winehq.org">https://www.winehq.org</a>).</p><p>If you have been using Linux for some time now, chances are you’ve used Wine at some point. Maybe to run that one very important Windows program that doesn’t have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve’s <a href="https://www.steamdeck.com/">Steam Deck</a> uses a Wine-based solution to run games (called <a href="https://github.com/ValveSoftware/Proton/">Proton</a>).</p><p>In the last year I’ve spent quite some time working on a debugger capable of debugging both the Wine layer and the Windows application running with it. It was very interesting to learn about the Wine internals – I’ve used Wine many times before, but never knew how it worked. If you ever wondered how it’s possible to take a Windows executable and just run it on Linux without any modifications – welcome to this article!</p><h2 id="disclaimer">Disclaimer
<a href="#disclaimer"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p><img src="https://werat.dev/blog/how-wine-works-101/1.png" alt="I have approximate knowledge of many things!"/></p><p>This article greatly simplifies reality and I don’t claim to know all the details. However I hope the explanation here will give you a general understanding of how things like Wine work.</p><h2 id="not-an-emulator">Not an Emulator
<a href="#not-an-emulator"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Before describing how Wine works, let’s explore how it doesn’t work. Wine is a recursive acronym and it stands for “Wine Is Not an Emulator”. Why isn’t it? There are lots of great emulators, both for older architecture and for modern consoles. Could Wine be implemented as an emulator? Yep, but there are good reasons not to do this. Let’s take a quick look at how emulators work in general.</p><p>Imagine we have some simple hardware, with two instructions:</p><ul><li><code>push &lt;value&gt;</code> – pushes given <code>value</code> to the stack</li><li><code>setpxl</code> – pops three values from the stack and draws a pixel with color <code>arg1</code> at <code>(arg2, arg3)</code></li></ul><p>(this should be enough to create some cool demoscenes, right?)</p><div><pre tabindex="0"><code data-lang="text"><span><span>&gt; dump-instructions game.rom
</span></span><span><span>...
</span></span><span><span># draw red dot at (10,10)
</span></span><span><span>push 10
</span></span><span><span>push 10
</span></span><span><span>push 0xFF0000
</span></span><span><span>setpxl
</span></span><span><span># draw green dot at (15,15)
</span></span><span><span>push 15
</span></span><span><span>push 15
</span></span><span><span>push 0x00FF00
</span></span><span><span>setpxl
</span></span></code></pre></div><p>The game binary (or ROM cartridge) is a sequence of these instructions, which the hardware can load into the memory and then execute. The <em>real</em> hardware can execute them <em>natively</em>, but what if we want to play the game on our modern laptop? We’ll create a software emulator – a program that loads the ROM in memory and then executes its instructions. An interpreter or a virtual machine, if you will. The implementation of the emulator for our two-instructions console can be pretty simple:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>enum</span> <span>Opcode</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>Push(<span>i32</span>),<span>
</span></span></span><span><span><span>    </span>SetPixel,<span>
</span></span></span><span><span><span></span>};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span>program: <span>Vec</span><span>&lt;</span>Opcode<span>&gt;</span><span> </span><span>=</span><span> </span>read_program(<span>&#34;game.rom&#34;</span>);<span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span>window<span> </span><span>=</span><span> </span>create_new_window(<span>160</span>,<span> </span><span>144</span>);<span> </span><span>// Virtual screen of 160x144 pixels
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span>stack<span> </span><span>=</span><span> </span><span>Vec</span>::new();<span> </span><span>// Stack for passing arguments
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>for</span><span> </span>opcode<span> </span><span>in</span><span> </span>program<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span>opcode<span> </span>{<span>
</span></span></span><span><span><span>        </span>Opcode::Push(value)<span> </span><span>=&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>            </span>stack.push(value);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>        </span>Opcode::SetPixel<span> </span><span>=&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span>color<span> </span><span>=</span><span> </span>stack.pop();<span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span>x<span> </span><span>=</span><span> </span>stack.pop();<span>
</span></span></span><span><span><span>            </span><span>let</span><span> </span>y<span> </span><span>=</span><span> </span>stack.pop();<span>
</span></span></span><span><span><span>            </span>window.set_pixel(x,<span> </span>y,<span> </span>color);<span>
</span></span></span><span><span><span>        </span>}<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code></pre></div><p>The real emulators are a lot more complicated, but the basic idea is the same: maintain some context (memory, registers, etc), handle input (e.g. keyboard/mouse) and output (e.g. drawing to some window), parse input data (ROM) and execute the instructions one by one, applying their side-effects.</p><p>This could be one way to implement Wine, but there are two reasons against it. First, the emulators are “slow” – there’s a significant overhead on executing every single instruction programmatically. This may be acceptable for older hardware, but not so much for the state of the art (and video games have always been one of the most demanding types of applications). The second reason is that there’s no need! Linux/macOS are perfectly capable of running Windows binaries <em>natively</em>, they just need a little push…</p><p>Let’s compile a simple program for both Linux and Windows and compare the results:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>int</span> <span>foo</span>(<span>int</span> x) {
</span></span><span><span>    <span>return</span> x <span>*</span> x;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span>(<span>int</span> argc) {
</span></span><span><span>    <span>int</span> code <span>=</span> foo(argc);
</span></span><span><span>    <span>return</span> code;
</span></span><span><span>}
</span></span></code></pre></div><p><img src="https://werat.dev/blog/how-wine-works-101/2.png" alt="image"/>
(left – Linux, right – Windows)</p><p>The results are visibly different, but the instruction set is actually the same: <code>push</code>, <code>pop</code>, <code>mov</code>, <code>add</code>, <code>sub</code>, <code>imul</code>, <code>ret</code>. So if we had an “emulator” that can execute these instructions, theoretically it should be able to execute both. And turns out that we do have it – that’s our CPU.</p><h2 id="how-linux-runs-a-binary">How Linux runs a binary
<a href="#how-linux-runs-a-binary"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Before running a Windows binary on Linux, let’s figure out how to run a normal Linux binary.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ cat app.cc
</span></span><span><span><span>#include &lt;stdio.h&gt;</span>
</span></span><span><span>
</span></span><span><span>int main<span>()</span> <span>{</span>
</span></span><span><span>  printf<span>(</span><span>&#34;Hello!\n&#34;</span><span>)</span>;
</span></span><span><span>  <span>return</span> 0;
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>❯ clang app.cc -o app
</span></span><span><span>
</span></span><span><span>❯ ./app
</span></span><span><span>Hello!  <span># works!</span>
</span></span></code></pre></div><p>Simple enough, let’s go a bit deeper. What happens when we do <code>./app</code>?</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ ldd app
</span></span><span><span>        linux-vdso.so.1 <span>(</span>0x00007ffddc586000<span>)</span>
</span></span><span><span>        libc.so.6 <span>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span>(</span>0x00007f743fcdc000<span>)</span>
</span></span><span><span>        /lib64/ld-linux-x86-64.so.2 <span>(</span>0x00007f743fed3000<span>)</span>
</span></span><span><span>
</span></span><span><span>❯ readelf -l app
</span></span><span><span>
</span></span><span><span>Elf file <span>type</span> is DYN <span>(</span>Position-Independent Executable file<span>)</span>
</span></span><span><span>Entry point 0x1050
</span></span><span><span>There are <span>13</span> program headers, starting at offset <span>64</span>
</span></span><span><span>
</span></span><span><span>Program Headers:
</span></span><span><span>  Type           Offset             VirtAddr           PhysAddr
</span></span><span><span>                 FileSiz            MemSiz              Flags  Align
</span></span><span><span>  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
</span></span><span><span>                 0x00000000000002d8 0x00000000000002d8  R      0x8
</span></span><span><span>  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
</span></span><span><span>                 0x000000000000001c 0x000000000000001c  R      0x1
</span></span><span><span>      <span>[</span>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2<span>]</span>
</span></span><span><span>...
</span></span></code></pre></div><p>First of all, we see that the <code>app</code> is a dynamic executable. This means that it depends on some dynamic libraries and requires them to be present in runtime to be able to run. Another interesting thing here is the “requesting program interpreter” part. What’s an interpreter doing here? I thought C++ was a compiled language, unlike Python…</p><p>In this context the interpreter is the “dynamic loader”. It’s a special program that bootstraps the execution of the original program: it resolves and loads its dependencies and then gives over the control.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ ./app
</span></span><span><span>Hello!  <span># This works!</span>
</span></span><span><span>
</span></span><span><span>❯ /lib64/ld-linux-x86-64.so.2 ./app
</span></span><span><span>Hello!  <span># This works too!</span>
</span></span><span><span>
</span></span><span><span><span># Homework exercise, run this and try to make sense of the output.</span>
</span></span><span><span>❯ <span>LD_DEBUG</span><span>=</span>all /lib64/ld-linux-x86-64.so.2 ./app
</span></span></code></pre></div><p>When running the executable, the Linux kernel detects that it’s dynamic and requires a loader. Then it executes the loader, which does all the work. We can verify that by running the program under the debugger, for example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ lldb ./app
</span></span><span><span><span>(</span>lldb<span>)</span> target create <span>&#34;./app&#34;</span>
</span></span><span><span>Current executable <span>set</span> to <span>&#39;/home/werat/src/cpp/app&#39;</span> <span>(</span>x86_64<span>)</span>.
</span></span><span><span><span>(</span>lldb<span>)</span> process launch --stop-at-entry
</span></span><span><span>Process <span>351228</span> stopped
</span></span><span><span>* thread <span>#1, name = &#39;app&#39;, stop reason = signal SIGSTOP</span>
</span></span><span><span>    frame <span>#0: 0x00007ffff7fcd050 ld-2.33.so`_start</span>
</span></span><span><span>ld-2.33.so<span>`</span>_start:
</span></span><span><span>    0x7ffff7fcd050 &lt;+0&gt;: movq   %rsp, %rdi
</span></span><span><span>    0x7ffff7fcd053 &lt;+3&gt;: callq  0x7ffff7fcdd70            ; _dl_start at rtld.c:503:1
</span></span><span><span>
</span></span><span><span>ld-2.33.so<span>`</span>_dl_start_user:
</span></span><span><span>    0x7ffff7fcd058 &lt;+0&gt;: movq   %rax, %r12
</span></span><span><span>    0x7ffff7fcd05b &lt;+3&gt;: movl   0x2ec57<span>(</span>%rip<span>)</span>, %eax       ; _dl_skip_args
</span></span><span><span>Process <span>351228</span> launched: <span>&#39;/home/werat/src/cpp/app&#39;</span> <span>(</span>x86_64<span>)</span>
</span></span></code></pre></div><p>Here we can see that the first instruction executed is in <code>ld-2.33.so</code>, <em>not</em> the <code>app</code> binary.</p><p>To summarize, the process of running a dynamically linked executable on Linux looks roughly like this:</p><ul><li>Kernel loads the image (≈ binary) and sees it’s a dynamic executable</li><li>Kernel loads the dynamic loader (<code>ld.so</code>) and gives it control</li><li>The dynamic loader resolves the dependencies and loads them</li><li>The dynamic loader gives the control back to the original binary</li><li>The original binary starts execution in <code>_start()</code> and eventually gets to <code>main()</code></li></ul><p>At this point it’s pretty clear why simply running a Windows executable won’t work – it has different format and the kernel simply doesn’t know what to do with it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ ./HalfLife4.exe
</span></span><span><span>-bash: HalfLife4.exe: cannot execute binary file: Exec format error
</span></span></code></pre></div><p>However, if we could get past the steps 1-4 and somehow get to 5, it should work in theory, right? Since we’re talking about “execution”, what does it mean, from the OS perspective, to “run” the binary?</p><p>Every executable has the <code>.text</code> section, which contains the serialized CPU instructions:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>❯ objdump -drS app
</span></span><span><span>
</span></span><span><span>app:     file format elf64-x86-64
</span></span><span><span>
</span></span><span><span>...
</span></span><span><span>
</span></span><span><span>Disassembly of section .text:
</span></span><span><span>
</span></span><span><span><span>0000000000001050</span> &lt;_start&gt;:
</span></span><span><span>    1050:       <span>31</span> ed                   xor    %ebp,%ebp
</span></span><span><span>    1052:       <span>49</span> <span>89</span> d1                mov    %rdx,%r9
</span></span><span><span>    1055:       5e                      pop    %rsi
</span></span><span><span>    1056:       <span>48</span> <span>89</span> e2                mov    %rsp,%rdx
</span></span><span><span>    1059:       <span>48</span> <span>83</span> e4 f0             and    <span>$0</span>xfffffffffffffff0,%rsp
</span></span><span><span>    105d:       <span>50</span>                      push   %rax
</span></span><span><span>    105e:       <span>54</span>                      push   %rsp
</span></span><span><span>    105f:       4c 8d <span>05</span> 6a <span>01</span> <span>00</span> <span>00</span>    lea    0x16a<span>(</span>%rip<span>)</span>,%r8        <span># 11d0 &lt;__libc_csu_fini&gt;</span>
</span></span><span><span>    1066:       <span>48</span> 8d 0d <span>03</span> <span>01</span> <span>00</span> <span>00</span>    lea    0x103<span>(</span>%rip<span>)</span>,%rcx        <span># 1170 &lt;__libc_csu_init&gt;</span>
</span></span><span><span>    106d:       <span>48</span> 8d 3d cc <span>00</span> <span>00</span> <span>00</span>    lea    0xcc<span>(</span>%rip<span>)</span>,%rdi        <span># 1140 &lt;main&gt;</span>
</span></span><span><span>    1074:       ff <span>15</span> 4e 2f <span>00</span> <span>00</span>       call   *0x2f4e<span>(</span>%rip<span>)</span>        <span># 3fc8 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span>
</span></span><span><span>    107a:       f4                      hlt
</span></span><span><span>    107b:       0f 1f <span>44</span> <span>00</span> <span>00</span>          nopl   0x0<span>(</span>%rax,%rax,1<span>)</span>
</span></span><span><span>...
</span></span></code></pre></div><p>In order to “run” the executable the operating system loads the binary into memory (specifically the <code>.text</code> section), sets the current instruction pointer to an address where the code is located and that’s it, the executable is running. Can we do the same for Windows executables?</p><p>Yes! The code inside the executables is “portable” between Windows and Linux (assuming the same CPU architecture). If we just take the code out of the Windows executable, load it in memory and point <code>%rip</code> to the right place – the processor will happily execute it!</p><p><img src="https://werat.dev/blog/how-wine-works-101/3.jpg" alt="code is code!"/></p><h2 id="hello-wine">Hello, Wine!
<a href="#hello-wine"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>Essentially, <code>wine</code> is a “dynamic loader” for Windows executables. It’s a native Linux binary, hence it can just run normally, and it knows how to deal with EXE and DLLs. It’s kinda an equivalent of <code>ld-linux-x86-64.so.2</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># running an ELF binary</span>
</span></span><span><span>❯ /lib64/ld-linux-x86-64.so.2 ./app
</span></span><span><span>
</span></span><span><span><span># running a PE binary</span>
</span></span><span><span>❯ wine64 HalfLife4.exe
</span></span></code></pre></div><p><code>wine</code> loads the Windows executable into memory, parses it, figures out the dependencies, figures out where the executable code is (i.e. the <code>.text</code> section) and then finally jumps into that code.</p><blockquote><p>Well, in reality it jumps into something like <code>ntdll.dll!RtlUserThreadStart()</code>, which is the “user-space” entry point in the Windows world. It will eventually get to <code>mainCRTStartup()</code> (the equivalent of <code>_start</code>) and then finally to the actual <code>main()</code>.</p></blockquote><p>At this point our Linux system is executing the code originally compiled for Windows and everything seems to work. Except…</p><h2 id="system-calls">System calls
<a href="#system-calls"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>System calls, or syscalls for short, is what makes Wine so complicated. <strong>Syscall</strong> is a call of a function that is implemented in the operating system (hence, <em>system</em> call), not in the application binary or any of its dynamic libraries. The set of syscalls provided by the OS is essentially the operating system API.</p><p>Examples on Linux: <code>read</code>, <code>write</code>, <code>open</code>, <code>brk</code>, <code>getpid</code></p><p>Examples on Windows: <code>NtReadFile</code>, <code>NtCreateProcess</code>, <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FMutant%2FNtCreateMutant.html"><code>NtCreateMutant</code></a> 😱</p><p>System calls are not regular function calls in the code. Opening a file, for example, must be performed by the kernel itself, since it’s the one keeping track of the file descriptors. Therefore the application code needs a way to “interrupt” itself and give control to the kernel (this operation is typically called <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>).</p><p>The set of functions exposed by the operating system and the way they should be called are different on every operating system. On Linux, for example, in order to call <code>read()</code> the binary would put the file descriptor into the register <code>%rdi</code>, the buffer pointer to <code>%rsi</code> and the number of bytes to read to <code>%rdx</code>. On Windows, however, there’s no <code>read()</code> function in the kernel! Neither the arguments would make any sense. Therefore the binary compiled for Windows will use the Windows-way of doing syscalls, which will not work on Linux as is. I won’t go deep into how exactly syscalls work, here’s a great article about the Linux implementation – <a href="https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/">https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/</a>.</p><p>Let’s compile another small program and compare the generated code on Linux and Windows:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    printf(<span>&#34;Hello!</span><span>\n</span><span>&#34;</span>);
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p><img src="https://werat.dev/blog/how-wine-works-101/4.png" alt="image"/>
(left – Linux, right – Windows)</p><p>This time we’re calling a function from the standard library, which, in turn, eventually performs a system call. On the screenshot above the Linux version calls <code>puts</code> and the Windows one – <code>printf</code>. These functions are coming from the standard library (<code>libc.so</code> on Linux, <code>ucrtbase.dll</code> on Windows), which the application uses to simplify the communication with the kernel. On Linux it’s fairly common these days to build statically linked binaries, which don’t depend on any dynamic libraries. In that case, the implementation of <code>puts</code> is embedded into the binary and no <code>libc.so</code> is involved in runtime.</p><p>On Windows, at least until not so long ago, “only malware used direct system calls”<sup>[citation needed]</sup>. Normal applications always depend on <code>kernel32.dll/kernelbase.dll/ntdll.dll</code>, which hide the low level magic of communicating with the kernel. The application just calls a function and the libraries take care of the rest:</p><p><img src="https://werat.dev/blog/how-wine-works-101/5.png" alt="image"/></p><p>(credit <a href="https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/">https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/</a>)</p><p>At this point you probably already have a feeling of what we’re going to do next 😏</p><h2 id="runtime-translation-of-syscalls">Runtime translation of syscalls
<a href="#runtime-translation-of-syscalls"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>What if we could “intercept” a syscall? Like, whenever the application calls <code>NtWriteFile()</code>, we would get in between, call <code>write()</code> instead and return the result in a format the binary expects. That should work. The quick and dirty solution for the example above might look something like this:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>// HelloWorld.exe
</span></span></span><span><span><span></span><span>lea</span>     <span>rcx</span>, <span>OFFSET</span> <span>FLAT</span>:<span>`</span><span>string</span><span>&#39;</span>
</span></span><span><span><span>call</span>    <span>printf</span>
</span></span><span><span>  <span>↓↓</span>
</span></span><span><span><span>// &#34;Fake&#34; ucrtbase.dll
</span></span></span><span><span><span></span><span>mov</span> <span>edi</span>, <span>rcx</span>   <span>// Convert the arguments to Linux ABI
</span></span></span><span><span><span></span><span>call</span> <span>puts@PLT</span>  <span>// Call the real Linux implementation
</span></span></span><span><span><span></span>  <span>↓↓</span>
</span></span><span><span><span>// Real libc.so
</span></span></span><span><span><span></span><span>mov</span> <span>rdi</span>, <span>&lt;</span><span>stdout</span><span>&gt;</span>  <span>// write to STDOUT
</span></span></span><span><span><span></span><span>mov</span> <span>rsi</span>, <span>edi</span>       <span>// pointer to &#34;Hello&#34;
</span></span></span><span><span><span></span><span>mov</span> <span>rdx</span>, <span>5</span>         <span>// how many chars to write
</span></span></span><span><span><span></span><span>syscall</span>
</span></span></code></pre></div><p>We can provide a custom version of <code>ucrtbase.dll</code> which would have a special implementation of <code>printf</code>. Instead of trying to call the Windows kernel, it would follow the Linux ABI and call the <code>write</code> function from <code>libc.so</code>. In practice, however, the application can link against <code>ucrtbase.dll</code> statically and we can’t modify the code of the binary for a number of reasons – it’s messy and complicated, it messes with the DRM, etc.</p><p>So instead we would modify the place that stands in between the binary and the kernel – <code>ntdll.dll</code>. This is the “gateway” into the kernel and Wine indeed provides its <a href="https://github.com/wine-mirror/wine/tree/3602c676dadf823a4868b0b72f326159cb93766e/dlls/ntdll">custom implementation</a>. In the recent versions of Wine it consists of two parts: <code>ntdll.dll</code> (which is a PE library) and <code>ntdll.so</code> (which is an ELF library). The first one is a thin layer that just redirects the calls into the ELF counterpart. The ELF counterpart contains a special function called <code>__wine_syscall_dispatcher</code>, which <a href="https://github.com/wine-mirror/wine/blob/1d178982ae5a73b18f367026c8689b56789c39fd/dlls/ntdll/unix/signal_x86_64.c#L3142">performs a magic trick</a> of converting the current stack from Windows to Linux and back.</p><p>Therefore, when doing a syscall the call stack of the process running with Wine looks like this:</p><p><img src="https://werat.dev/blog/how-wine-works-101/6.png" alt="call stack of process running with Wine"/></p><p>The syscall dispatcher is a bridge between the Windows world and the Linux world. It takes care of the calling conventions – allocates some stack space, moves the registers around, etc. Once the execution is in the Linux library (<code>ntdll.so</code>), we’re free to use any regular Linux APIs (e.g. libc or syscall) and can actually read/write files, lock/unlock mutexes and so on.</p><h2 id="is-that-it">Is that it?
<a href="#is-that-it"><i aria-hidden="true" title="Link to heading"></i>
<span>Link to heading</span></a></h2><p>It sounds almost <em>too easy</em>. And it would be. First of all, there are a LOT of Windows APIs. And they’re poorly documented and have known (and unknown haha) bugs, which must be preserved exactly as is. Most of the Wine source code is the implementation of various Windows DLLs.</p><p>Second, there are different ways to perform syscalls. Technically nothing prevents the application to do a direct system call via the <code>syscall</code> instruction and ideally this should work too (remember, Windows games do all kinds of crazy things). Linux kernel has a <a href="https://lwn.net/Articles/824380/">special mechanism</a> to handle this and of course it only adds complexity.</p><p>Third, there’s this whole 32-bit vs 64-bit nonsense. There are a lot of old 32-bit games, which are never going to be re-released as 64-bit. Wine has support for both and again, this adds up to the overall complexity of the system.</p><p>Fourth, I didn’t even mention <code>wine-server</code> – a separate process spawned by Wine, which maintains the kernel “state” (open file descriptors, mutexes, etc).</p><p>Fifth, oh, did you want to run a game? Not just a hello world? Then you need to deal with DirectX, audio (hello PulseAudio, my old friend), input devices (gamepads, joysticks), etc. It’s a lot of work!</p><p>Wine has been in development for many years and came a long way. Today you can run the latest games like Cyberpunk 2077 or Elden Ring without any issues. Damn, sometimes Wine has even better performance compared to Windows! What a time to be alive…</p><hr/><p>I hope this article gave you a basic idea of how Wine works. As I warned in the disclaimer, I’ve simplified a bunch of things and I may be wrong about some details (hopefully not too much). If you see that I’m outright misleading people, please reach out and correct me!</p><hr/><p>Discuss this article on <a href="https://lobste.rs/s/7f8exp/how_wine_works_101">lobste.rs</a> or <a href="https://news.ycombinator.com/item?id=33156727">HackerNews</a> or Reddit (<a href="https://www.reddit.com/r/linux_gaming/comments/y0ts39/how_wine_works_101/">r/Linux_Gaming</a>, <a href="https://www.reddit.com/r/programming/comments/y0tbuf/how_wine_works_101/">r/programming</a>)</p><hr/></div></div>
  </body>
</html>
