<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adamj.eu/tech/2026/01/14/python-introducing-tprof/">Original</a>
    <h1>Python: Tprof, a Targeting Profiler</h1>
    
    <div id="readability-page-1" class="page"><article><time datetime="2026-01-14">2026-01-14</time><img alt="Can you hit your target?" title="Can you hit your target?" src="https://adamj.eu/tech/assets/2026-01-14-target.webp"/><p>Profilers measure the performance of a whole program to identify where most of the time is spent. But once youâ€™ve found a target function, re-profiling the whole program to see if your changes helped can be slow and cumbersome. The profiler introduces overhead to execution and you have to pick out the stats for the one function you care about from the report. I have often gone through this loop while optimizing client or open source projects, such as when I optimized Djangoâ€™s system checks framework (<a href="https://adamj.eu/tech/2024/03/23/django-optimizing-system-checks/">previous post</a>).</p><p>The pain here inspired me to create <a href="https://pypi.org/project/tprof/"><strong>tprof</strong></a>, a targeting profiler for Python 3.12+ that only measures the time spent in specified target functions. Use it to measure your program before and after an optimization to see if it made any difference, with a quick report on the command line.</p><p>For example, say youâ€™ve realized that creating <a href="https://docs.python.org/3/library/pathlib.html#pathlib.Path"><code>pathlib.Path</code></a> objects is the bottleneck for your code. You could run tprof like so:</p><img alt="tprof in action measuring pathlib.Path performance." src="https://adamj.eu/tech/assets/2026-01-14-tprof-screenshot.webp"/><div id="benchmark-with-comparison-mode"><h2>Benchmark with comparison mode<a title="Permalink to this headline" href="#benchmark-with-comparison-mode"></a></h2><p>Sometimes when optimizing code, you want to compare several functions, such as â€œbeforeâ€ and â€œafterâ€ versions of a function youâ€™re optimizing. tprof supports this with its comparison mode, which adds a â€œdeltaâ€ column to the report showing how much faster or slower each function is compared to a baseline.</p><p>For example, given this code:</p><div><pre><span></span><span>def</span> <span>before</span><span>():</span>
    <span>total</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>100_000</span><span>):</span>
        <span>total</span> <span>+=</span> <span>i</span>
    <span>return</span> <span>total</span>


<span>def</span> <span>after</span><span>():</span>
    <span>return</span> <span>sum</span><span>(</span><span>range</span><span>(</span><span>100_000</span><span>))</span>


<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
    <span>before</span><span>()</span>
    <span>after</span><span>()</span>
</pre></div><p>â€¦you can run tprof like this to compare the two functions:</p><div><pre><span></span><span>$ </span>tprof<span> </span>-x<span> </span>-t<span> </span>before<span> </span>-t<span> </span>after<span> </span>-m<span> </span>example
<span>ğŸ¯ tprof results:</span>
<span> function         calls total  mean Â± Ïƒ      min â€¦ max   delta</span>
<span> example:before()   100 227ms   2ms Â± 34Î¼s   2ms â€¦ 2ms   -</span>
<span> example:after()    100  86ms 856Î¼s Â± 15Î¼s 835Î¼s â€¦ 910Î¼s -62.27%</span>
</pre></div><p>The output shows that <code>after()</code> is about 60% faster than <code>before()</code>, in this case.</p></div><div id="python-api"><h2>Python API<a title="Permalink to this headline" href="#python-api"></a></h2><p>tprof also provides a Python API via a context manager / decorator, <code>tprof()</code>. Use it to profile functions within a specific block of code.</p><p>For example, to recreate the previous benchmarking example within a self-contained Python file:</p><div><pre><span></span><span>from</span> <span>tprof</span> <span>import</span> <span>tprof</span>


<span>def</span> <span>before</span><span>():</span>
    <span>total</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>100_000</span><span>):</span>
        <span>total</span> <span>+=</span> <span>i</span>
    <span>return</span> <span>total</span>


<span>def</span> <span>after</span><span>():</span>
    <span>return</span> <span>sum</span><span>(</span><span>range</span><span>(</span><span>100_000</span><span>))</span>


<span>with</span> <span>tprof</span><span>(</span><span>before</span><span>,</span> <span>after</span><span>,</span> <span>compare</span><span>=</span><span>True</span><span>):</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>100</span><span>):</span>
        <span>before</span><span>()</span>
        <span>after</span><span>()</span>
</pre></div><p>â€¦which produces output like:</p><div><pre><span></span><span>$ </span>python<span> </span>example.py
<span>ğŸ¯ tprof results:</span>
<span> function          calls total  mean Â± Ïƒ      min â€¦ max delta</span>
<span> __main__:before()   100 227ms   2ms Â± 83Î¼s   2ms â€¦ 3ms -</span>
<span> __main__:after()    100  85ms 853Î¼s Â± 22Î¼s 835Î¼s â€¦ 1ms -62.35%</span>
</pre></div></div><div id="how-it-works"><h2>How it works<a title="Permalink to this headline" href="#how-it-works"></a></h2><p>tprof uses Pythonâ€™s <a href="https://docs.python.org/3/library/sys.html#sys.monitoring"><code>sys.monitoring</code></a>, a new API introduced in Python 3.12 for triggering events when functions or lines of code execute. <code>sys.monitoring</code> allows tprof to register callbacks for only specific target functions, meaning it adds no overhead to the rest of the program. Timing is done in C to further reduce overhead.</p><p>Thanks to Mark Shannon for contributing sys.monitoring to CPython! This is the second time Iâ€™ve used itâ€”the first time was for tracking down an unexpected mutation (see <a href="https://adamj.eu/tech/2024/12/30/python-spy-changes-sys-monitoring/">previous post</a>).</p></div><div id="fin"><h2>Fin<a title="Permalink to this headline" href="#fin"></a></h2><p>If tprof sounds useful to you, please give it a try and let me know what you think! Install <a href="https://pypi.org/project/tprof/"><strong>tprof</strong></a> from PyPI with your favourite package manager.</p><p>May you hit your Q1 targets,</p><p>â€”Adam</p></div><hr/><p>ğŸ˜¸ğŸ˜¸ğŸ˜¸ Check out my new book on using GitHub effectively, <strong><a href="https://adamj.eu/tech/2025/11/11/boost-your-github-dx-out-now/">Boost Your GitHub DX</a></strong>! ğŸ˜¸ğŸ˜¸ğŸ˜¸</p><hr/><p><small>One summary email a week, no spam, I pinky promise.</small></p><p><strong>Related posts:</strong></p><ul><li><a href="https://adamj.eu/tech/2024/03/23/django-optimizing-system-checks/">Django: Write-up on optimizing the system check framework</a></li></ul><p><strong>Tags:</strong> <a href="https://adamj.eu/tech/tag/python/" rel="tag">python</a></p></article></div>
  </body>
</html>
