<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2025/05/22/ssl/">Original</a>
    <h1>Why I no longer have an old-school cert on my https site</h1>
    
    
<p>
At the start of 2023, I
<a href="https://rachelbythebay.com/w/2023/01/03/ssl/">wrote a post</a>
talking about why I still had an &#34;old-school cert&#34; on my https site.  
Well, things have shifted, and it&#39;s time to talk about why.
</p>
<p>
I&#39;ve been aware of the ACME protocol for a while.  I have tech notes 
going back as far as 2018, and every time I looked at it, I recoiled in 
horror.  The whole thing amounts to &#34;throw in every little bit of 
webshit tech that we can&#34;, and it makes for a real problem to try to 
implement this in a safe and thorough way.
</p>
<p>
Many of the existing clients are also scary code, and I was not about to 
run any of them on my machines.  They haven&#39;t earned the right to run 
with privileges for my private keys and/or ability to frob the web 
server (as root!) with their careless ways.
</p>
<p>
That meant I was stuck: unwilling to bring myself to deal with the 
protocol while simultaneously unwilling to budge on allowing the cruft 
code of existing projects into my life.
</p>
<p>
Well, time passed, and I managed to crack some of my own barriers.  It 
wasn&#39;t by using the other projects, though.  I started ripping into them 
to figure out just how the spec really worked, and started biting off 
really really small pieces of the problem.  It took a particular forcing 
function to get me off my butt and into motion.
</p>
<p>
About six months ago, I realized that it was probably time to get away 
from Gandi as a registrar and also SSL provider (reseller).  They had 
been eaten by private equity some years before, and the rot has been 
setting in.  Their &#34;no bullshit&#34; tagline is gone, and their prices have 
been creeping up.  I happened to renew my domains for multiple years 
and have been insulated for a while, but it was going to be a problem 
in 2025.
</p>
<p>
Giving them the &#34;yeet&#34; was no big deal, but the damn rbtb certificate 
was going to be a problem.  Was I going to start paying even more for 
the stupid thing every year, or was I going to finally suck it up and 
deal with ACME?
</p>
<p>
That still left the problem of overcoming my inherent disgust for the 
entire protocol and having to deal with all of these encodings they 
force upon you.  My first steps towards the solution involved writing 
really small and stupid utility functions and libraries that would come 
in handy later.  I&#39;m talking about wrapping jansson (a C library that 
handles JSON) so that it made sense in my C++ world and I could import 
JSON (something I use as little as possible).  That kind of thing.
</p>
<p>
This also meant going down some dead-ends, like noticing that libraries 
existed which would allegedly create certain things (like a JWK) for 
you, and then realizing that they were not going to make my life any 
easier.  I&#39;d poke at it, reach my limit, and then swear and walk away 
for another couple of days.
</p>
<p>
This went on for some time.  I have a series of notes where I&#39;d grab a 
piece of the problem, wrangle it around for a while, get grossed out, 
and then set it down and go do something else.  This just kept happening 
but I slowly made progress with small pieces that would Do Stuff, and 
then they&#39;d connect to each other, and so on like this.
</p>
<p>
One positive development during all of this was discovering this 
&#34;pebble&#34; test server I could run on an isolated fake system.  It would 
act as an ACME server and would let me harass it with my feeble attempts 
at implementing a client instead of bothering the real CAs.  Even 
&#34;staging&#34; servers deserve better treatment than active development, 
after all.
</p>
<p>
And, well, after a whole lot of mangling and dead-ends and rewrites and 
other terrible crap, I had an awful little tool that would take a CSR, 
do all of the idiot dances and would plop out a certificate.  I pointed 
it at Let&#39;s Encrypt staging, and it worked.  Then I pointed it at their 
prod site, and _that_ worked.  So I did it for the real thing 
([www.]rachelbythebay.com), and *that* worked, and I dropped it into 
place.
</p>
<p>
Thus, for the past couple of weeks, if you&#39;ve been hitting the https 
version of my site, you&#39;ve been doing it across the new setup.
</p>
<p>
Now, I took notes about this, and I wanted to share some of my original 
off-the-cuff thoughts about implementing this for anyone who&#39;s 
similarly broken in the head and wants to see how bad it can be.  I will 
note that I wrote this based on the first thing that worked, and it does 
not necessarily reflect the implementation I&#39;m on a few weeks later.
</p>
<p>
...
</p>
<p>
Make an RSA key for your web site.  Then make a CSR for it, setting the 
CN and adding a matching altname as an extension.  No other fields 
matter.  Nobody looks at those, anyway, and none of them will influence 
your final certificate no matter how prosaic or precise you get in 
there.
</p>
<p>
Make an RSA key of 4096 bits.  Call it your personal key.
</p>
<p>
Write something that&#39;ll read a CSR.  It needs to extract the CN and the 
SANs - the DNS: ones, at least.  Ensure there&#39;s actually a CN [*] and 
actually SANs, and that the CN occurs within the SANs.  So, yes, you 
have to have at least one SAN.
</p>
<p>
[* - I now know you can run with just SANs.  I did not at the time.]
</p>
<p>
Write something that&#39;ll do a HTTP GET to &lt;directory URL&gt; which is given 
to you by the ACME service operator.  It then needs to parse the body as 
JSON (or die) and extract some strings from the top-level object: 
&#34;newNonce&#34;, &#34;newAccount&#34; and &#34;newOrder&#34; at the very least.
</p>
<p>
Write something that&#39;ll read an RSA key file on disk.  It needs to 
extract the publicExponent (probably 65537, but you never know...) and 
the modulus.  Make it read your personal key from earlier.
</p>
<p>
If you end up using &#34;openssl rsa -in foo -noout -text&#34; to do this, the 
modulus is a bunch of printed hex digits, like 
&#34;00:ff:11:ab:cd:ef:22:33&#34;.  It hard-wraps the output and also indents 
the lines, so you get to clean all of that up first.
</p>
<p>
Skip the first 00 for some inexplicable reason.  Take the other bytes of 
the modulus and turn them into the actual character values, so a literal 
0xff, 0x11, 0xab, 0xcd and so on down the line in the same order you 
find them in the file.   Hang on to these values for later.
</p>
<p>
Write something that&#39;ll turn an ordinary integer into its equivalent 
big-endian bag of bytes, but don&#39;t pad it out to any particular 
alignment.  You need to take that &#34;65537&#34; from your publicExponent and 
turn it into the equivalent bytes, so 0x01, 0x00, 0x01.  Yes, it&#39;s a 
number you just turned back into a binary representation.
</p>
<p>
Write something that will do base64 *style* encoding, but not quite.  
The last two characters in the encoding set are usually + and /, but 
that won&#39;t do for webshit, so you need to make it use - and _ instead.
</p>
<p>
Take that publicExponent (65537), pump it through your big-endian 
bag-of-bytes encoder to get 0x01 0x00 0x01, then put it through your 
&#34;base64web&#34; encoder to get &#34;AQAB&#34;.
</p>
<p>
Start a new JSON object.  Add a string called &#34;e&#34; and set it to the 
output of the above step.  So, yes, instead of saying that &#34;e&#34; equals 
&#34;65537&#34;, you&#39;re saying that &#34;e&#34; equals &#34;AQAB&#34;.  Aren&#39;t you glad you did 
those extra steps?
</p>
<p>
Add another string called &#34;kty&#34; and set it to &#34;RSA&#34;.
</p>
<p>
Add another string called &#34;n&#34; and set it to the &#34;base64web&#34; version of 
your modulus bag-of-bytes from earlier.
</p>
<p>
Take this JSON object and make it into a sorted compact string 
representation.  This means it goes &#34;e, kty, n&#34; and it also has all of 
the usual padding (spaces) squished out.  Call this a JWK string and 
save it for later.
</p>
<p>
Create a second JSON object.  Add a boolean to it named 
&#34;termsOfServiceAgreed&#34; that&#39;s set to true.  (Guess you&#39;d better 
agree...)
</p>
<p>
Look up the URL for &#34;newNonce&#34; from the directory JSON you got earlier.
</p>
<p>
Make a HTTP HEAD request to that URL.  Dig around in the headers (not 
the body, since there is no body on a HEAD) until you find 
&#34;Replay-Nonce&#34;.  Extract the value of that header.  Hang onto it for 
later.
</p>
<p>
Look up the URL for &#34;newAccount&#34; from that directory JSON for before.
</p>
<p>
Create a third JSON object.  Add a string to it called &#34;url&#34;.  Set it to 
that (newAccount) URL.  Add a string called &#34;alg&#34;.  Set it to &#34;RS256&#34;.  
Add a string called &#34;nonce&#34; and set it to the value from the *header* 
in that last HTTP HEAD request.
</p>
<p>
Add an object to this third object called &#34;jwk&#34;.  Within it, add &#34;e&#34;, 
&#34;kty&#34; and &#34;n&#34; in a manner that matches what you did earlier (you know, 
from the &#34;JWK string&#34; you&#39;re still holding for later).
</p>
<p>
Dump this third JSON object to a sorted compact string representation.  
Call it &#34;protected&#34;.
</p>
<p>
Dump the second JSON object to a sorted compact string representation.  
Call it &#34;payload&#34;.
</p>
<p>
Create a string where you literally concatenate those two prior strings, 
such that it&#39;s the value of protected, then an actual period (as in 
0x2e, a full stop, whatever), then the value of payload.
</p>
<p>
Write something that&#39;ll create a SHA256 digest of an arbitrary string 
and will sign it with an arbitrary RSA key (like &#34;openssl dgst -sha256 
-sign &lt;key&gt;&#34;).  The key in question is your personal key.
</p>
<p>
Pump that &#34;&lt;protected&gt;.&lt;payload&gt;&#34; string through the digest function.  
Then run it through your &#34;base64web&#34; encoder.  Call this the signature.
</p>
<p>
Create a fourth JSON object.  Add a string called &#34;protected&#34; and set it 
to whatever you built a few steps earlier.  Add another string called 
&#34;payload&#34; and set it likewise.  Then add one called &#34;signature&#34; and set 
it, too.
</p>
<p>
Take this fourth JSON object and dump it to a sorted compact string 
representation.  Call this your post body.
</p>
<p>
Make a HTTP POST request to the &#34;newAccount&#34; URL from the directory.  
Set the content-type to &#34;application/jose+json&#34;.  Set the post data to 
the post body string from the previous step.
</p>
<p>
Dig around in the headers of the response, looking for one named 
&#34;Location&#34;.  Don&#39;t follow it like a redirection.  Why would you ever 
follow a Location header in a HTTP header, right?  Nope, that&#39;s your 
user account&#39;s identifier!  Yes, you are a URL now.  Hang on to that URL 
for later.
</p>
<p>
You now have an account.
</p>
<p>
You still have much to do.
</p>
<p>
...
</p>
<p>
That&#39;s about where I stopped writing my take on the protocol.
</p>
<p>
Again, my program no longer works quite like this, but this is where it 
started after having observed a bunch of other stuff that already 
existed.
</p>
<p>
So far, we have (at least): RSA keys, SHA256 digests, RSA signing, 
base64 but not really base64, string concatenation, JSON inside JSON, 
Location headers used as identities instead of a target with a 301 
response, HEAD requests to get a single value buried as a header, 
making one request (nonce) to make ANY OTHER request, and there&#39;s more 
to come.
</p>
<p>
We haven&#39;t even scratched the surface of creating an order, dealing with 
authorizations and challenges, the whole &#34;key thumbprint&#34; thing, what 
actually goes into those TXT records, and all of that other fun stuff.
</p>
<p>
...
</p>
<p>
Random side note: while looking at existing ACME clients, I found that 
at least one of them screws up their encoding of the publicExponent and 
ends up interpreting it as hex instead of decimal.  That is, instead of 
65537, aka 0x10001, it reads it as 0x65537, aka 415031!  
</p>
<p>
Somehow, this anomaly exists and apparently doesn&#39;t break anything?  I 
haven&#39;t actually run the client in question, but I imagine people are 
using it since it&#39;s in apt.
</p>
<p>
...
</p>
<p>
This complexity must be job security for somebody.  Maybe multiple 
somebodies.
</p>

  </body>
</html>
