<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.nsl.com/k/f/f.htm">Original</a>
    <h1>F (2006)</h1>
    
    <div id="readability-page-1" class="page">



<p><a href="https://blog.jacobvosmaer.nl/0025-music-how/f.k">F</a> is a pure functional concatenative 
language originally designed as an extension of <a href="https://blog.jacobvosmaer.nl/papers/false.htm">False</a>. F contains the list-operations of <a href="http://www.kx.com">K3</a> and the <em>dip</em> combinator 
of <a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">Joy</a>. Floating-point and symbolic datatypes are supported. One-time assignment
is enforced in syntax. A theory of function-valence and -charge is outlined. F also contains a general continuation
primitive $, and the pattern sublanguage of <a href="https://blog.jacobvosmaer.nl/xy/xy.htm">XY</a>.  <a href="https://blog.jacobvosmaer.nl/0025-music-how/g.k">G</a> is a variant of F in which the K3 adverbs are implemented as primitives.</p>

<h2>0. Introduction</h2>

<p>F has the following properties:</p>

<blockquote>
    <ul>
        <li>The language is concatenative</li>
        <li>The language is purely functional</li>
        <li>All K verbs are implemented</li>
        <li>All primitives are denoted by single symbols</li>
        <li>Primitive symbols are as mnemonic as possible</li>
    </ul>
</blockquote>

<p><em>The language is concatenative.</em> F tokens are words,
words denote functions, and the concatenation of words denotes
the composition of functions. In classical concatenative
languages, everything is a function from stacks to stacks. In F,
everything is a function from triples of
(environment;stack;queue) to triples of
(environment;stack;queue).</p>

<p><em>The language is purely functional.</em> There are no
side-effects. F has assignment, but not reassignment. This means
that you can&#39;t use a variable to store dynamic state. F
assignment associates names with values in an environment which
is passed as an argument and returned as a value. F also has
commands for interacting with the run-time environment and the
file-system, but these operations are notationally differentiated
from the operators of F: &#34;h&#34;, &#34;r&#34;, &amp;c.
They are intended as debugging aids only.</p>

<p><em>All K verbs are implemented.</em> Some K verbs are
implemented as primitives, and some are derived in the F prelude.
For example, the <em>atom</em> primitive @ of K is defined as
[#ints~]; i.e. shape matches the empty integer vector. Where K
provides a pair of functions, one of which is easily defined in
terms of the other, F implements one as a primitive and derives the
other. For example, <em>and</em> is primitive (&amp;) and <em>or</em>
is derived.  The criterion for dividing related pairs is simply
this:  the derived definition must not be egregiously inefficient
when compared to the primitive it supplants.</p>

<p><em>All primitives are denoted by single symbols.</em>
Although list-notation ([x y z]) is supported, any list can be
constructed functionally with &#39; (<em>quote</em>) and , (<em>join</em>).</p>

<p><em>Primitive symbols are as mnemonic as possible.</em> There
are five ways the mapping of a function to a symbol can be
mnemonic:</p>

<blockquote>
    <ol>
        <li>The symbol is in common use for the mapped function
            (e.g. + for addition)</li>
        <li>The symbol is mapped to that function in K (e.g. ?
            for <em>find</em>) or False (e.g. ! for <em>unquote</em>)</li>
        <li>The name of the symbol is a homonym for the mapped
            function (e.g. &#39; for <em>quote</em>)</li>
        <li>A pair of related functions (inverses, or
            near-inverses) are mapped to a pair of related
            symbols (e.g. / and \ for <em>take</em> and <em>drop</em>)</li>
        <li>Where several K primitives are mapped to one symbol,
            the primitives should form an easily remembered group
            based on some common property; e.g. both <em>upgrade</em>
            and <em>enum</em> return indices based on an
            ascending relation, so both are mapped to &lt;. </li>
    </ol>
</blockquote>

<h2>1. Datatypes</h2>

<p>The initial state of the interpreter consists of an
environment containing the F words of the prelude, an empty
result stack, and a string (character-vector) to be evaluated.
The input string is tokenized and parsed to obtain the initial
queue. </p>

<p>The input queue is a K list, possibly containing integers,
floats, symbols, <em>null</em>, functions, and lists
(&#34;quotations&#34;). The result stack is initially empty.
The environment is a K dictionary. F processes the environment,
stack, and queue repeatedly until the queue is empty. </p>

<p>If the first item on the queue is an integer, float, <em>null</em>,
the prototype symbol `, or a list, the item is pushed onto the
stack.</p>

<p>If the first item is an undefined symbol, then if it&#39;s a <em>shuffle</em>
it&#39;s applied; otherwise, a variable is created (in the environment)
having the top of the stack as the value. </p>

<p>If the first item is a defined symbol, its value is
retrieved (from the environment) and pushed onto the stack.</p>

<p>If the first item is a function, then it is applied to the
environment, stack, and queue to produce a new environment,
stack, and queue.</p>

<p>Observe that the domain of the result stack is a proper subset
of the domain of the input queue. On the queue we may find
character-atoms, such as &#34;r&#34;, and strings, such as
&#34;blah&#34;. But character-atoms are executed away when they
are evaluated, and no F primitive ever produces one, and strings
are comments, which are not processed.</p>

<p>The <em>trace</em> command displays the stack and queue for
selected objects in the trace list T:</p>

<blockquote>
    <pre>F&gt;[fac] &#34;t&#34;

F&gt;3 fac!
                                       3 ♦ fac !
                                     3 2 ♦ fac ! *
                                   3 2 1 ♦ fac ! * *
6
F&gt;

F&gt;[fac cond] &#34;t&#34;

F&gt;3 fac!
                                       3 ♦ fac !
       3 [1 =] [] [dup ! pred ! fac ! *] ♦ cond !
                                     3 2 ♦ fac ! *
     3 2 [1 =] [] [dup ! pred ! fac ! *] ♦ cond ! *
                                   3 2 1 ♦ fac ! * *
   3 2 1 [1 =] [] [dup ! pred ! fac ! *] ♦ cond ! * *
6
F&gt;

F&gt;[] &#34;t&#34;

F&gt;3 fac!
6</pre>
</blockquote>

<h2>2. Primitives</h2>

<h3>Operators (O)</h3>

<blockquote>
    <pre>09*-		int		123 -&gt; 123
09*.09*-	float		123.45 -&gt; 123.45

az.AZ*		name		myName -&gt; value or null
az*-AZ*		shuffle		10 20 ab-ba -&gt; 20 10

[..]		list		[10 + [3 a]] -&gt; [10 + [3 a]]

+		add		1 2 + -&gt; 3
-		sub		2 3 - -&gt; 1
*		mul		3 4 * -&gt; 12
%		div		5 3 % -&gt; 1.666667
^		power		2 3 ^ -&gt; 8
_		floor		3.2 _ -&gt; 3

=		equal		2 2 = -&gt; 1
&gt;		more		4 6 &gt; -&gt; 0
&amp;		and/min		4 3 &amp; -&gt; 3

~		match		[1 2][1 2] ~ -&gt; 1

#		shape		[1 2 3] # -&gt; [3]

|		reverse		[1 2 3] | -&gt; [3 2 1]

@		where		[0 1 1 0 1] @ -&gt; [1 2 4]
@		flip		[[1 2 3][4 5 6]] @ -&gt; [[1 4][2 5][3 6]]

/		take		2[1 2 3] / -&gt; [1 2]
/		reshape		[3 2][1 2 3] / -&gt; [[1 2][3 1][2 3]]

\		drop		2[1 2 3] \ -&gt; [3]
\		cut		[0 2][1 2 3] \ -&gt; [[1 2][3]]
\		rotate		[1 2 3 4] 2 \ -&gt; [3 4 1 2]

?		find		[10 20 30] 20 ? -&gt; 1
?		mod		2 [3 4 5] ? -&gt; [1 0 1]

;		unique		[10 20 10 10 30] ; -&gt; [10 20 30]
:		group		[10 20 10 10 30] : -&gt; [[0 2 3][1][4]]

&lt;		enum		3 &lt; -&gt; [0 1 2]
&lt;		upgrade		[10 30 20] &lt; -&gt; [0 2 1]

.		infra		1 2 [[2 3 +]] . 3 4 -&gt; 1 2 [5] 3 4
.		index		[[1 2 3][[1 0]]] . -&gt; [2 1]
.		monad		[[1 2 3][[1 0]][-1*]] . -&gt; [-1 -2 3]
.		dyad		[[1 2 3][[1 0]]+[3 8]] . -&gt; [9 5 3]

!		unquote		2 [3 +] ! -&gt; 5
`		dip		2 3 4 [+] ` -&gt; 5 4
&#39;		quote		&#39;+ -&gt; [+]

,		join  		[1][2 3] , -&gt; [1 2 3]

$		state		1 2 3 &#39;\ $ 4 5 6 -&gt; 4 5 6 1 2 3

)		s -&gt; s		stack-&gt;stack pattern
(		s -&gt; q		stack-&gt;queue pattern

}		q -&gt; s		queue-&gt;stack pattern
{		q -&gt; q		queue-&gt;queue pattern</pre>
</blockquote>

<h3>System Functions (K)</h3>

<p>The K system functions have reserved names:</p>

<blockquote>
    <pre>type (4::)
log exp abs sqr sqrt floor dot mul inv lsq
sin cos tan asin acos atan sinh cosh tanh
draw
in lin bin binl dv dvl di vs sv</pre>
</blockquote>

<h3>Literals (L)</h3>

<p>F has nine reserved names for literals:</p>

<blockquote>
    <pre>Nan		minint (0N)
Inf		maxint (0I)

nan		NaN (0n)
inf		infinity (0i)

null		null (_n)
sym		prototype sym (`)

ints		empty integer vector (!0)
floats		empty float vector (0#0.)
syms		empty sym vector (0#`)</pre>
</blockquote>

<h3>Commands (I)</h3>

<p>F has the following interactive commands:</p>

<blockquote>
    <pre>&#34;..&#34;		comment		1 &#34;skip&#34; 2	comment not processed

&#34;b&#34;		break		&#39;x &#34;b&#34;		signal error (&#39;x)
&#34;c&#34;		clear		1 2 &#34;c&#34; 3 4	clear, load f, prelude
&#34;d&#34;		defined		&#39;foo &#34;d&#34;	is foo defined?
&#34;e&#34;		error		0 &#34;e&#34;		set/unset error trap (\e)
&#34;f&#34;		F		&#34;f&#34; 2 unit!	set F semantics, clear
&#34;j&#34;		Joy		&#34;j&#34; 2 unit	set Joy semantics, clear
&#34;k&#34;		K		1 2 &#34;k&#34; 3 4	exit to K
&#34;l&#34;		load		&#39;x &#34;l&#34;		load f/x.f|x.j
&#34;m&#34;		measure		[10&lt;] &#34;m&#34;	measure time in ms
&#34;o&#34;		words		&#39;map &#34;o&#34;	show word form
&#34;p&#34;		precision	3 &#34;p&#34;		print precision (\p)
&#34;r&#34;		read		1 2 &#34;r&#34; 3 4	read, parse, eval
&#34;s&#34;		store		y &#39;x &#34;s&#34;	store f/x.f|x.j
&#34;t&#34;		trace		null &#34;t&#34; 3 4	set trace-list (T)
&#34;u&#34;		undefine	x &#34;u&#34;		undefine vars in x
&#34;v&#34;		variables	1 2 &#34;v&#34; 3 4	show vars (!environment)
&#34;x&#34;		exit		1 2 &#34;x&#34; 3 4	_exit 0
&#34;w&#34;		write		1 2 &#34;w&#34; 3 4	format, write
&#34;z&#34;		halt		1 2 &#34;z&#34; 3 4	: to continue
</pre></blockquote>

<h3>Names and numbers</h3>

<p>Spaces (<em>blank</em>, <em>tab</em>, <em>return</em>) are
necessary to separate names from names and numbers from numbers,
but not names from numbers.</p>

<p>A name must begin with a letter and may contain letters, .,
or a single -.  A name containing a - is a shuffle-symbol.</p>

<p>A numerical expression must begin with either a digit or - 
followed by a digit, and must end with a digit.  A floating-point 
numerical expression must contain exactly one . which
must be flanked by digits.</p>

<h3>Operators</h3>

<p>The math, logic, and relational operators are <em>atomic
functions</em>. For example,</p>

<blockquote>
    <pre>F&gt;[1 2 3][[4 5 6] 7 8]+
[[5 6 7] 9 11]</pre>
</blockquote>

<p>In several instances, distinct K operations have been mapped
to one symbol: </p>

<blockquote>
    <pre>int &lt;			enum			!x
~atom &lt;			upgrade			&lt;x
atom &lt;			nonce

int/ints @		where			&amp;x
list @			flip			+x
			nonce

atom y ?		mod			y!x
~atom y ?		find			x?y

list atom \		rotate			y!x
atom list \		drop			x _ y
atom atom \		drop			x _(),y
list list \		cut			x _ y

1=#x .			infra
x .			index/monad/dyad	. x</pre>
</blockquote>

<h3>Iterators</h3>

<p>The False combinators <em>if</em> and <em>while</em> have been
eliminated, and <em>cond</em>, <em>if</em>, and <em>while</em>
have been defined as words in the prelude. The truth-values of F
are more general than those of K: 0 is <em>false</em>, any other
value is <em>true</em>.</p>

<h3>Assignment</h3>

<p>Assignment has the form <em>value unassigned_name</em>. An
assigned name may not be re-assigned.</p>

<p>Reserved names cannot be assigned:</p>

<blockquote>
    <pre>F&gt;12 inf
12 inf</pre>
</blockquote>

<p>Use of an assigned name (a variable) places the value assigned
to it on the stack:</p>

<blockquote>
    <pre>F&gt;10 a

F&gt;a
10
F&gt;12 a
10 12 10
F&gt;a
10 12 10 10</pre>
</blockquote>

<p>A symbol can be produced indirectly:</p>

<blockquote>
    <pre>F&gt;10 foo

F&gt;foo
10
F&gt;[foo] first!
foo
F&gt;!
10</pre>
</blockquote>

<h3>Quotation</h3>

<p>The <em>quote</em> primitive &#39; takes the next item on the
queue and quotes it:</p>

<blockquote>
    <pre>F&gt;&#39;+
[+]
F&gt;
F&gt;&#39;[1 2 3]
[[1 2 3]]
F&gt;
F&gt;&#39;&#39;
[&#39;]</pre>
</blockquote>

<p>The <em>unquote</em> combinator ! is Joy&#39;s <em>i</em>. ! takes
the top item <em>x</em> on the stack and prepends the elements of
<em>x</em> to the queue:</p>

<blockquote>
    <pre>F&gt;2 3 &#39;+ !
5</pre>
</blockquote>

<p>The <em>dip</em> combinator is defined as it is in Joy. `
takes the top two items <em>x</em> <em>y</em> on the stack and
prepends <em>y,,x</em> to the queue. For example, with trace on,
the input queue is displayed to the right of the diamond and the
result stack to the left:</p>

<blockquote>
    <pre>F&gt;10 2 3 4 20 [+*]`
                                         ♦ 10 2 3 4 20 [+ *] `
                                      10 ♦ 2 3 4 20 [+ *] `
                                    10 2 ♦ 3 4 20 [+ *] `
                                  10 2 3 ♦ 4 20 [+ *] `
                                10 2 3 4 ♦ 20 [+ *] `
                             10 2 3 4 20 ♦ [+ *] `
                       10 2 3 4 20 [+ *] ♦ `
                                10 2 3 4 ♦ + * 20
                                  10 2 7 ♦ * 20
                                   10 14 ♦ 20
                                10 14 20 ♦
F&gt;</pre>
</blockquote>

<h3>State</h3>

<p>F has two programs for manipulating the stack, and two for
manipulating the queue:</p>

<blockquote>
    <pre>stack		push the stack onto the stack
unstack		set the stack to the top of the stack  
queue		move the top of the stack to the queue
unqueue		move the end of the queue to the stack</pre>
</blockquote>

<p>These are defined using the <em>state</em> combinator $:</p>

<blockquote>
    <pre>[[[|uncons!|swap!]`swap!unit!,]$]       queue
[[|uncons!|[unit!,]`]$]                 unqueue

[[[dup!unit!,]`]$]                      stack
[[[last!]`]$]                           unstack</pre>
</blockquote>

<p>$ expects a program on top of the stack. The program expects
two quotations beneath it: the current queue, and beneath that,
the current stack. F expects the program to return two
quotations: the new queue, and beneath that, the new list.</p>

<h3>Stack Operations</h3>

<p>The False stack operators <em>pop</em>, <em>dup</em>, and <em>swap</em>
are defined using shuffles:</p>

<blockquote>
    <pre>[a-]                            pop
[ab-ba]                         swap
[a-aa]                          dup</pre>
</blockquote>

<h3>List Operations</h3>

<p>The list operations <em>cons</em> and <em>uncons</em> are
total: </p>

<blockquote>
    <pre>F&gt;1 2 cons!
[1 2]
F&gt;

F&gt;[1 2] uncons!
1 [2]
F&gt;

F&gt;[1] uncons!
1 ints
F&gt;

F&gt;[] uncons!
null []
F&gt;

F&gt;2 uncons!
2 ints</pre>
</blockquote>

<p>These are defined using the ( and ) operators:</p>

<blockquote>
    <pre>[[[[a A]]a A])]                 uncons
[[[a b][a]b,](]                 cons</pre>
</blockquote>

<h3>Errors</h3>
<blockquote><pre><em>F stack</em>			The stack-valence greater than the stack-size.

<em>F queue</em>			The queue-valence is greater than the queue-size.

<em>F pattern</em>		The stack-size is greater than the pattern scheme-size.

<em>F char: &lt;x&gt;</em>		x is an illegal character.

<em>F nonce: &lt;x&gt;</em>		Primitive x is not defined for the arguments supplied.
</pre></blockquote>

<h2>3. Implementation</h2>

<p>The implementation consists of a single <a href="https://blog.jacobvosmaer.nl/0025-music-how/f.k">script</a><a> which defines a
node (.f) on the K tree.</a></p><a>

<h3>Globals</h3>

<blockquote>
    <pre>J	0 (F semantics) 1 (Joy semantics).

O	Look-up table of operator character, operator

I	I.x is an interactive (or interpreter) command.

L	L.x is a literal whose representation is x.

K	K.x is a K system function

C	C i is a vector of characters of lexical category i.

V	A string of state-names.

W	A string of final-state-names.

X	In V i read a character in C j, go to X[i;j].

T	0 (no trace) 1 (trace).

E	Global environment.

S	Global stack.

Z	(states x 256) transition matrix.</pre>
</blockquote>

<h3>Functions</h3>

<blockquote>
    <pre>F	F interpreter.

n	Interpret pattern.

q	Interpret shuffle-symbol.
    
i	Transform dictionary -&gt; list.

j	Transform list -&gt; dictionary.

l	Load and interpret a .f script.

s	Format an F value and save it to a .f script.

u	Update the stack (S) and environment (E).

p	Tokenize and parse an input string to create a queue.

v	Evaluate token.

r	Recursively construct a list from (&#34;[&#34;;...;&#34;]&#34;).

m	<em>infra</em>, <em>index</em>, <em>monadic amend</em>, <em>dyadic amend</em>.

e	Evaluate the queue (z) on the stack (y) in the environment (x).

a	Apply the top of the queue to the stack in the environment.

b	Evaluate symbol.

k	Create a variable in the environment.

c	Process the value of a defined symbol (J-sensitive).

x	Apply n-ad f, append the enlisted result to the stack.

y	Apply n-ad f, append the result to the stack.

z	Apply n-ad f, prepend the result to the queue.

w	Apply n-ad f to stack, queue, return new stack, new queue.

t	If T is a non-empty list, trace the impending step.

d	Display the trace.

f	Format the stack.

g	Format an element on the stack.

h	Pretty printer

o	Translate symbols into names.</pre>
</blockquote>

<h2>4. Operation</h2>

<p>Say</p>

<blockquote>
    <pre>k f</pre>
</blockquote>

<p>to start the F interpreter.</p>

<blockquote>
    <pre>k f .. &lt;script&gt; ..</pre>
</blockquote>

<p>starts the interpreter, then reads and evaluates the F
scripts. For example</p>

<blockquote>
    <pre>k f f/fac</pre>
</blockquote>

<p>Joy or F semantics may be specified with an initial boolean
value of J:</p>

<blockquote>
    <pre>k f 1 f/fac</pre>
</blockquote>

<p>The prompt is F&gt; for F semantics and J&gt; for Joy
semantics.</p>

<p>If, in a .f or .j script, the interpreter encounters a single
unmated &#34;, evaluation on that script terminates. (Analogous
to \ in .k scripts.)</p>

<p>Exit to K, or from the current trace or stop, by entering a
single space. Clear the stack by pressing &lt;return&gt; with
null input.</p>

<h2>5. Examples</h2>

</a><p><a>The F prelude is </a><a href="https://blog.jacobvosmaer.nl/0025-music-how/f/prelude.f">here</a>. </p>

<p>An F implementation of <em>factorial</em> is <a href="https://blog.jacobvosmaer.nl/0025-music-how/f/fac.f">here</a>:</p>

<blockquote>
    <pre>F&gt;[[1=][][dup!pred!fac!*]cond!]fac

F&gt;6fac!
720</pre>
</blockquote>

<p>An F script containing synonyms for the symbolic operations is
<a href="https://blog.jacobvosmaer.nl/0025-music-how/f/f.f">here</a>.</p>

<p>Versions of the prelude and factorial function adapted for Joy
semantics are <a href="https://blog.jacobvosmaer.nl/0025-music-how/f/prelude.j">here</a> and <a href="https://blog.jacobvosmaer.nl/0025-music-how/f/fac.j">here</a>.</p>

<h2>6. Comments</h2>

<h3>Names</h3>

<p>In Joy, use of a name causes the value associated with the
name to be executed against the stack:</p>

<blockquote>
    <pre>plustwo == 2 +</pre>
</blockquote>

<blockquote>
    <pre>3 plustwo .
5</pre>
</blockquote>

<p>In F, use of a name causes the value associated with the name
to placed on the stack:</p>

<blockquote>
    <pre>F&gt;[2 +] plustwo

F&gt;3 plustwo
3 [2 +]</pre>
</blockquote>

<p>The value may then be executed with !:</p>

<blockquote>
    <pre>3 [2 +]
F&gt;!
5</pre>
</blockquote>

<p>In Joy, adjacent names must be separated by a blank, or the
equivalent. The corresponding F code has greater visual density,
but is nearly as concise. For example, the <em>reduce</em>
combinator is:</p>

<blockquote>
    <pre>[swap!dup!proto!swap!unit!bot!over!]</pre>
</blockquote>

<p>as opposed to:</p>

<blockquote>
    <pre>[swap dup proto swap unit bot over]</pre>
</blockquote>

<p>One might say that F occupies a middle-ground between Joy,
which evaluates names aggressively, and False, which breaks the
semantics of name evaluation into even smaller steps:</p>

<blockquote>
    <pre>[swap;!dup;!proto;!swap;!unit;!bot;!over;!]</pre>
</blockquote>

<p>In False, a name leaves itself on the stack. ; takes a
name and leaves the value of the name on the stack. ! executes
values.</p>

<p>In addition, F semantics makes it easy for one program to
modify the code of another: invoke the program by name, which
leaves a quotation on the stack, modify the quotation, execute.</p>

<p>In any case, it should be noted that switching F to Joy
semantics is a trivial matter. The <em>c</em> function takes the
value of a defined symbol <em>z</em>, the stack <em>x</em>, and
the queue <em>y</em> and appends it to the stack:</p>

<blockquote>
    <pre>(x,,z;y)</pre>
</blockquote>

<p>For Joy, we change this to:</p>

<blockquote>
    <pre>(x;z,y)</pre>
</blockquote>

<p>which prepends the <em>contents</em> of <em>z</em> to the <em>queue</em>.
Subsequent processing will evaluate elements of the value
one-by-one.</p>

<p>It is important to note that in both dialects, some primitives
have names. For example, <em>in</em> is a primitive system function, so:</p>

<blockquote>
    <pre>F&gt;10 [2 3 4 10 12 2] in
1</pre>
</blockquote>

<p>is valid code in both Joy and F dialects.</p>

<p>Note: this switch has been implemented in the script for F,
viz. J is 0 for F semantics, 1 for Joy semantics.</p>

<p>Note: The &#34;o&#34; command spells out F programs. In Joy
mode:</p>

<blockquote>
    <pre>F&gt;&#39;map &#34;o&#34;
[[dup count [] top] dip swap
 [quote uncons dip dup top
  [cons unit eval first swons]
  dipd] 
 do pop pop rev]</pre>
</blockquote>

<p>It is possible to write programs in this way, using the words
defined in the <a href="https://blog.jacobvosmaer.nl/0025-music-how/f/f.f">f</a> scripts.</p>

<h3>Program = List = Quotation</h3>

<p>In Joy, a quotation is a list and also a program. All programs
are lists, and vice-versa. Intuitively, there does seem to be a
difference between [1 2 3] and [2 +]. It cannot be that the
former contains &#34;data elements&#34; and the latter a data
element and a function, since numbers are just as much functions
as the + operator. Both 2 and + are functions from stacks to
stacks.</p>

<p>The difference between quotations-as-lists and
quotations-as-programs reduces to this: a quotation is list-like
when we want to examine or manipulate its parts or structure; and
a quotation is program-like when want to execute it. So the same
object can appear list-like in certain contexts and program-like
in others. Indeed, it can appear to be neither if we are merely
pushing it onto the stack without regard to its structure or
execution-properties, or both if we first manipulate contents and
structure and then execute it.</p>

<h3>Valence and Charge</h3>

<p>The <em>valence</em> of a program is a pair of integers. The
first element of the pair is the <em>stack-valence</em>. The
stack-valence of a program is the number of elements it takes
from the stack. The second element is the <em>queue-valence</em>.
The queue-valence is the number of elements it takes from the
queue. </p>

<p>The <em>quote</em> operator &#39; is the only primitive having
non-zero queue-valence: it expects to find one element on the
queue, which it enlists and pushes onto the stack. Hence, <em>quote</em>
has stack-valence 1.</p>

<p>The + operator has stack-valence 2. It takes two elements from
the stack and pushes the sum onto the stack.</p>

<p>The <em>charge</em> of a program is also a pair of integers.
The first element is the <em>stack-charge</em>, and the second is
the <em>queue-charge</em>. </p>

<p>+ has stack-charge 1 (it pushes a single element onto the
stack) and queue-charge 0. <em>dup</em> has stack-valence 1 and
stack-charge 2. <em>swap</em> has stack-valence 2 and
stack-charge 2.</p>

<p>! (<em>unquote</em>) has stack-valence 1 and infinite
queue-charge: it takes a quotation off the stack and pushes as
many elements onto the queue as there are in the quotation.</p>

<p>` (<em>dip</em>) has stack-valence 2 and infinite
queue-charge: it takes two things off the stack: a quotation and
an element X and pushes first X, and then the quotation onto the
queue.</p>

<p>All primitives have non-negative charge and valence. A
negative value means that the program operates on the <em>bottom</em>
of the stack or queue.</p>

<p>If the stack has fewer elements than the (absolute value of
the) stack-valence, an <em>F stack</em> error is signalled. If
the queue has fewer elements than the (absolute value of the)
queue-valence, an <em>F queue</em> error is signalled.</p>

<h3>XY operators: Stack, Unstack, Queue, Unqueue</h3>

<p>F implements four <a href="https://blog.jacobvosmaer.nl/xy/xy.htm">XY</a> operators:</p>

<p>The <em>stack</em> program takes the stack, enlists it, and
appends it to the stack:</p>

<blockquote>
    <pre>F&gt;1 2 3 stack!
1 2 3 [1 2 3]</pre>
</blockquote>

<p>The <em>unstack</em> program expects a quotation <em>q</em> at
the top of the stack, and sets the stack to the contents of <em>q</em>:</p>

<blockquote>
    <pre>F&gt;1 2 3 [4 5 6] unstack!
4 5 6</pre>
</blockquote>

<p>The <em>queue</em> program expects a quotation at the top of
the stack, and appends it to the end of the queue:</p>

<blockquote>
    <pre>F&gt;1 2 3 [4 5 6] queue! 7 8 9
1 2 3 7 8 9 [4 5 6]</pre>
</blockquote>

<p>The <em>unqueue</em> program expects a quotation at the end of
the queue, and pushes it onto the stack:</p>

<blockquote>
    <pre>F&gt;1 2 3 unqueue! 4 5 6 [7 8 9]
1 2 3 [7 8 9] 4 5 6</pre>
</blockquote>

<p>The XY programs have valence and charge:</p>

<blockquote>
    <pre>operator	stack-valence	stack-charge	queue-valence	queue-charge
--------	-------------	------------	-------------	------------
stack		inf		1		0		0
unstack		1		inf		0		0
queue		1		0		0		-1
unqueue		0		1		-1		0</pre>
</blockquote>

<p>The implementation of $ is one of two primitives which
recursively calls the F evaluator <em>e</em>. $ is a K function
which takes <em>x</em>, the environment, <em>y</em>, the stack,
and <em>z</em>, the queue, and is defined:</p>

<blockquote>
    <pre>{x,e[x;(-1_ y;z);*-1#y]1}</pre>
</blockquote>

<h3>Infra, Index, Monad, Dyad</h3>

<p>The implementation of . is the other primitive which
recursively calls the F evaluator <em>e</em>. </p>

<blockquote>
    <pre>m:{:[1=#y           ;e[x;();*y]1                                  / infra
     2=#y           ;(*y). e[x;();y 1]1                           / index
     (4:*y)_in 4 6  ;&#39;&#34;G nonce: .&#34;                                / no assignment
     3=#y           ;.@[y;2;{{*-1#e[*x;y,();x 1]1}[(x;y)]}[x]]    / monad
                     .@[y;2;{{*-1#e[*x;y,,z;x 1]1}[(x;y)]}[x]]]}  / dyad</pre>
</blockquote>

<p>where <em>y</em> is the quotation on top of the stack and <em>x</em>
is the environment.</p>

<p>Assignment to globals (*y a symbol) or null (*y null) is blocked.</p>

<p>For example, if the expression to be evaluated is</p>

<blockquote>
    <pre>[[10 20 30][[0 1]]] .</pre>
</blockquote>

<p>then the count of <em>y</em> is 2. <em>m</em> indexes the
first element of y, which is 10 20 30, by the value of the second
element of y in the environment x, which is ,0 1.</p>

<h3>Patterns and Shuffles</h3>

<p>F incorporates a version of the pattern sublanguage of <a href="https://blog.jacobvosmaer.nl/xy/xy.htm">XY</a>.</p>

<p>A <em>pattern</em> is a list whose head is a scheme and whose
tail is a template</p>

<p>A <em>scheme</em> is a name or a list of schemes. The case of
the first letter in a name is significant. If lower-case, the
name matches a single element. If upper-case, the name must occur
as the final element in a list of schemes, and will match zero or
more elements, viz. the remainder of the list whose initial
elements are matched by schemes preceding the terminal name.</p>

<p>A <em>template</em> is a list. If <em>s</em> is a symbol in
the template which also occurs in the scheme, the value matched
by <em>s</em> is substituted for <em>s</em> in the template.</p>

<p>F contains four primitive operations on patterns:</p>

<blockquote><pre>)       Applies a pattern to the stack and pushes the result onto the stack.

(       Applies a pattern to the stack and prepends the result to the queue.

}       Applies a pattern to the queue and pushes the result onto the stack.

{       Applies a pattern to the queue and prepends the result to the queue.</pre></blockquote>

<p>Although F supports the <em>dip</em> combinator as a primitive,
it is possible to define it as a pattern:</p>

<blockquote><pre>F&gt;[[[f a]f!a](] pdip
F&gt;10 20 5 pdip!
30 5
</pre></blockquote>

<p>As an example of how patterns can simplify programming in F,
compare the definition of <em>cond</em> as given in the prelude:</p>

<blockquote><pre>[pair![dupd!]dip!quote!!dip!swap!false!pair!index!!]        cond
</pre></blockquote>

<p>with an equivalent definition using the stack-to-queue operator
(:</p>

<blockquote><pre>[[[d i t f]d[[t f]]d i!false!join!index!!](]                pcond
</pre></blockquote>

<p><em>pcond</em> expects a data-item <em>d</em>, a condition <em>i</em> of <em>d</em>, 
a program <em>t</em> to evaluate on <em>d</em> if <em>d i</em> is true (i.e. not false),
and a program <em>f</em> to evaluate on <em>d</em> if <em>d i</em> is false.</p>

<p>The template evaluates the condition and uses the result to index out
the appropriate program, which is then evaluated on the data-item.</p>

<p>The extent to which patterns can be used to avoid list construction and
deconstruction can be seen in this version, in which the template is used
to create a diagram of the penultimate structure.  <em>infra</em> evaluates
the quotation, <em>index</em> selects the right piece of the result, which
is then evaluated on the data-item:</p>

<blockquote><pre>[[[d i t f]d[[[t f]d i!false!]]infra!index!!](]             qcond
</pre></blockquote>

<p>The pattern versions are arguably clearer than the version which
makes use of stack operators.  One objection to the use of patterns is that
the resulting programs violate the Concatenativity property: a concatenative
program can be cut into two sub-programs, both of which are concatenative
programs, as long as the cut does not fall within the boundaries of a 
quotation.  For example, <em>cond</em> can be cut into:</p>

<blockquote><pre>[pair![dupd!]dip!quote!!dip!]                               acond
[swap!false!pair!index!!]                                   bcond
</pre></blockquote>

<p>and then <em>cond</em> can be defined as:

</p><blockquote><pre>[acond!bcond!]                                              abcond
</pre></blockquote>

<p>But <em>pcond</em> cannot be cut into smaller programs, because every
pattern-based program has the structure <em>[[[scheme] template] operator]</em>.
The only point available for the cut is between the pattern and the operator.
This is a consequence of the fact that the meaning of symbols in the pattern-template 
depends on the assignments implied by the pattern-scheme.</p>

<p>F also supports <em>shuffle-symbols</em>, a simplified, weaker
version of ). For example, <em>swap</em> is:</p>

<blockquote>
    <pre>F&gt;10 20 ab-ba
20 10</pre>
</blockquote>

<p>Shuffles can reduce stack-noise, but the resulting programs still
have the Concatenativity property.  For example, <em>cond</em> can be defined
as:</p>

<blockquote><pre>[ditf-dditf pair!unit!quote!!dip!swap!false!join!index!!]   scond
</pre></blockquote>

<p>A potentially fruitful approach to program construction would require that 
all programs be defined as alternating pairs of shuffles and stack-manipulation-free
stretches of functional code.  For example,</p><blockquote><pre>[ab-bab     +*
 abc-bcca   -|,.]</pre></blockquote>
 
<p>In such programs, one would never find on the right-hand side
programs such as <em>pop</em> or <em>swap</em>.</p>

<p>Note: This material has benefited greatly from discussions
with William Tanksley, Jr.</p>

<h2>7. Notes</h2>

<p>F began as an exercise in extending Wouter van Oormerssen&#39;s concatenative language <a href="https://blog.jacobvosmaer.nl/papers/false.htm">False</a>, but it rapidly acquired a life of its own.  At
this point, little trace remains of the original.</p>

<p>See Randall Holmes&#39; functional extensions to False, <a href="http://math.boisestate.edu/~holmes/holmes/sfdocs.pdf">Strictly
False</a>, which stimulated the present project.</p>

<p>An earlier version of F with primitive stack and list operations
and a somewhat different mapping of primitives to symbols is <a href="https://blog.jacobvosmaer.nl/f_obsolete/f.htm">here</a>.</p>

<h2>8. K and F</h2>

<h3>Verbs: K -&gt; F</h3>

<blockquote>
    <pre>	       <strong>Dyad</strong>				      <strong>Monad</strong>
               ====				      =====
	<strong>K</strong>		<strong>F</strong>			<strong>K</strong>		<strong>F</strong>
	-		-			-		-
+       plus            +			flip		@
-       minus           -			negate		<em>neg</em>
*       times           *			first		<em>first</em>
%       divide          %			reciprocal	<em>rec</em>
&amp;       min/and         &amp;			where		@
|       max/or          <em>max</em>,<em>or</em>			reverse		|
&gt;       more            &gt;			downgrade	<em>down</em>
&lt;	less		<em>less</em>			upgrade		&lt;
=       equal           =			group		:
^       power           ^			shape		#
!       mod/rotate      ? \			enum		&lt;
~       match           ~			not		<em>not</em>
,       join            ,			enlist		&#39;
#       take/reshape    /			count		<em>count</em>
_       drop/cut        \			floor		_ 
$       form/format     NA			format		NA
?       find/invert     ?			unique		;
@       at              NA			atom		<em>atom</em>
.       dot             .			value		.
:	dex		<em>pop</em>			identity	<em>id</em></pre>
</blockquote>

<h3>Adverbs: K -&gt; F</h3>

<blockquote>
    <pre><strong>K</strong>	<strong>F</strong>
-	-
&#39;	<em>each</em>
/	<em>over</em>, <em>do</em>, <em>while</em>, <em>vector</em>, <em>matrix</em>
\	<em>Over</em>, <em>Do</em>, <em>While</em>, <em>Vector</em>, <em>Matrix</em>
&#39;:	<em>prior</em>
/:	<em>right</em>
\:	<em>left</em></pre>
</blockquote>

<h3>Redefinitions</h3>

<blockquote>
    <pre>	<strong>K</strong>		<strong>F</strong>
	-		-
$	format		state
\	scan		drop
/	over		take
!	enum		unquote
`	symbol		dip
&#39;	each		quote
;	seperator	unique
:	dex		group
[	open apply	open list
]	close apply	close list
{	open lambda	queue -&gt; queue
}	close lambda	queue -&gt; stack
(	open expr	stack -&gt; queue
)	close expr	stack -&gt; stack
?	find		find/mod
@	at		where/flip
&#34;	quotation	command/comment</pre>
</blockquote>

<h2>9. G</h2>

<p>The <a href="https://blog.jacobvosmaer.nl/0025-music-how/g.k">G</a> variant of F implements the adverbs of K as primitives.</p>

<blockquote>
    <pre>09*-		int		123 -&gt; 123
09*.09*-	float		123.45 -&gt; 123.45

az.AZ*		name		myName -&gt; value or null
az*-AZ*		shuffle		10 20 ab-ba -&gt; 20 10

[..]		list		[10 + [3 a]] -&gt; [10 + [3 a]]

+		add		1 2 + -&gt; 3
-		sub		2 3 - -&gt; 1
*		mul		3 4 * -&gt; 12
%		div		5 3 % -&gt; 1.666667
^		power		2 3 ^ -&gt; 8
_		floor		3.2 _ -&gt; 3

=		equal		2 2 = -&gt; 1
&gt;		more		4 6 &gt; -&gt; 0
&amp;		and/min		4 3 &amp; -&gt; 3

~		match		[1 2][1 2] ~ -&gt; 1

#		shape		[1 2 3] # -&gt; [3]

|		reverse		[1 2 3] | -&gt; [3 2 1]

@		where		[0 1 1 0 1] @ -&gt; [1 2 4]
@		flip		[[1 2 3][4 5 6]] @ -&gt; [[1 4][2 5][3 6]]

(		take		2[1 2 3] ( -&gt; [1 2]
(		reshape		[3 2][1 2 3] ( -&gt; [[1 2][3 1][2 3]]

)		drop		2[1 2 3] ) -&gt; [3]
)		cut		[0 2][1 2 3] ) -&gt; [[1 2][3]]
)		rotate		[1 2 3 4] 2 ) -&gt; [3 4 1 2]

?		find		[10 20 30] 20 ? -&gt; 1
?		mod		2 [3 4 5] ? -&gt; [1 0 1]

}		unique		[10 20 10 10 30] } -&gt; [10 20 30]
{		group		[10 20 10 10 30] { -&gt; [[0 2 3][1][4]]

&lt;		enum		3 &lt; -&gt; [0 1 2]
&lt;		upgrade		[10 30 20] &lt; -&gt; [0 2 1]

.		infra		1 2 [[2 3 +]] . 3 4 -&gt; 1 2 [5] 3 4
.		index		[[1 2 3][[1 0]]] . -&gt; [2 1]
.		monad		[[1 2 3][[1 0]][-1*]] . -&gt; [-1 -2 3]
.		dyad		[[1 2 3][[1 0]]+[3 8]] . -&gt; [9 5 3]

!		unquote		2 [3 +] ! -&gt; 5
&#39;		quote		&#39;+ -&gt; [+]

,		join  		[1][2 3] , -&gt; [1 2 3]

$		state		1 2 3 &#39;\ $ 4 5 6 -&gt; 4 5 6 1 2 3

/		over		3 [1 2 3]&#39;+/ -&gt; 9
\		under		3 [1 2 3]&#39;+\ -&gt; [3 4 6 9]

:		each		[[[1 2][3 4 5]]][!#]: -&gt; [&#39;2 &#39;3]
;		prior		[1 3 2 4]&#39;-; -&gt; [2 -1 2]

`		s -&gt; s		stack-&gt;stack pattern</pre>
</blockquote>

<p><em>dip</em> is defined:</p>

<blockquote><pre>[[[a b][b!a]]`!]                dip
</pre></blockquote>

<p>The <em>each-right</em> and <em>each-left</em> adverbs are defined:</p>

<blockquote><pre>[[unit!]dip!:popd!]             right
[swapd![swap!]swap!,right!]     left
</pre></blockquote>

<p id="copyright">Copyright (c) 2006-7, Stevan Apter. All Rights
Reserved.</p>


</div>
  </body>
</html>
