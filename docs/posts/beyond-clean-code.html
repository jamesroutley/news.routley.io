<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tobeva.com/articles/beyond/">Original</a>
    <h1>Beyond Clean Code</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      <div>
        
        <main role="main">
          
<div>
	
	<p>Layers of Optimization</p>
	
	<p><em>There’s also a <a href="#video">YouTube Video</a> for this post.</em></p>
<h3 id="optimization">Optimization</h3>
<p>Programming can be an emotional rollercoaster. This isn’t externally obvious as
we impassively look at our screens and tap on the keyboard, but inside it’s
sometimes a tumultuous ride. And no software engineering endeavor produces more
twists and turns than optimization. The dynamic range of possible outcomes of
an optimization session are vast.</p>
<p>There’s the sublime satisfaction of a well-earned performance gain, culminating
in the sweet reward of sending a victory message to the team. Conversely,
there’s the frenzy of late-night coding that quietly ends when you reluctantly
revert a change that didn’t produce a noticeable speedup, leaving you feeling
defeated and empty as you push back from the laptop.</p>
<h3 id="clean-code">Clean Code</h3>
<p>The phrase “clean code” from Uncle Bob’s 2008 book <em>Clean Code</em> has, in some
circles, confusingly come to mean “bad code.” Critics argue that clean code is
overengineered, is filled with useless abstractions, obscures the flow of
control with tiny methods and classes, and leads to poor performance.</p>
<p>I’m going to tease apart the difference between clean code, as described in
Uncle Bob’s book, and clean code, a generic term of praise used in engineering
contexts for decades. I will debunk the claim that clean code inevitably leads
to poor performance, showing exactly when it does and when it doesn’t.</p>
<p>Then we’ll move beyond clean code and talk overhead in general and
mixed-language systems which blend together code with different degrees of
optimization, and learn why optimizing the wrong thing leads to that defeated
and empty feeling.</p>
<h3 id="the-book">The Book</h3>
<p>Robert C. Martin almost certainly didn’t realize publishing <a href="https://henrikwarne.com/2015/01/03/book-review-clean-code/"><em>Clean Code</em></a> in 2008 would lead to so much confusion. The book contains many generic suggestions for writing code, like “use good names,” but also quite a few OOP-specific suggestions. This is because, as Uncle Bob writes in Chapter 1, emphasis his, “Consider this book a description of the <em>Object Mentor School of Clean Code</em>. The techniques and teachings within are the way that <em>we</em> practice <em>our</em> art.”</p>
<p>Wait, what’s Object Mentor? <a href="https://www.linkedin.com/company/object-mentor/">Object Mentor</a> was Uncle Bob’s consulting firm, founded in 1991 and now defunct. They specialized “in object-oriented technologies,” and much of their work was done in Java, which heavily embraces OOP. This is why the Clean Code contains a lot of OOP, not because Uncle Bob thinks only OOP code can be clean, but because it documents the practices of a specific Java shop that he personally ran back in the 1990s and 2000s.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/books_huebbfad1edfa8e198fe68a27ac6a615ca_57453_600x0_resize_q75_catmullrom.jpg" width="600" height="201"/></p>
	
</div>
<p>Uncle Bob knew then that his version of Clean Code was only one of many possible takes. Again, in Chapter 1, he wrote, “There are probably as many definitions [of clean code] as there are programmers.” To underscore this, he included several well-known programmer’s definitions of clean code:</p>
<p><em>Clean code is elegant, efficient and straight-forward.</em></p>
<p><em>Clean code is simple and direct.</em></p>
<p><em>Clean code can be read, and enhanced by a developer</em></p>
<p>Clean code looks like it was written by someone that cares.</p>
<p>Nothing about OOP there. These are good generic definitions of “clean code.” We should continue to use “clean code” in this generic sense and not allow it to mean “bad code.” For one reason, clean code was a term long before Uncle Bob’s book.</p>
<h3 id="usenet">Usenet</h3>
<p>Here are two references to “clean code” from the 1980s:</p>
<p><em>This is certainly true however, the tendency to write unreadable code is accentuated in Forth because the language itself provides no help whatsoever to aid the programmer in writing clean code.</em></p>
<p>From net.lang.c <a href="https://groups.google.com/g/net.lang.c/c/xyfbw2tpuQ8/m/aZp2DuBBHnsJ">1986</a></p>
<p><em>We’ve all come up with a joke about “negative productivity”. You start the day with, say, a thousand lines of crappy code and end the day with 300 lines of clean code–thereby having produced -700 lines of code for the day.</em></p>
<p>From comp.software-eng <a href="https://groups.google.com/g/net.lang.c/c/xyfbw2tpuQ8/m/aZp2DuBBHnsJ">1989</a></p>
<h3 id="thought-terminating-cliché">Thought-terminating cliché</h3>
<p>Clean code is so divisive in some places online that it’s become a “thought-terminating cliché,” a term used by <a href="https://www.robertjaylifton.com/">Robert Jay Lifton</a> in his 1961 book, A Study of “Brainwashing” in China. It’s “thought-terminating” because someone utters the phrase, and the knives instantly come out on both sides — very little can be said above the noise. We should end this petty squabble and lean more on Michael Feathers’ definition: “Clean code looks like it was written by someone who cares.” This means clean code can be written in any language using any methodology.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/cliche_huebbfad1edfa8e198fe68a27ac6a615ca_93143_600x0_resize_q75_catmullrom.jpg" width="600" height="318"/></p>
	
</div>
<h3 id="casey-muratori">Casey Muratori</h3>
<p>A hot spot in the “clean code is bad code” movement is Casey Muratori’s February 2023 <a href="https://www.youtube.com/watch?v=tD5NrevFtbU">video</a> and <a href="https://www.computerenhance.com/p/clean-code-horrible-performance">blog post</a>, <em>“Clean” Code: Horrible Performance</em>. He uses the phrase “clean code” more than twenty-five times in the post, each dripping with derision and contempt. He presents two versions of a numerical calculation. The first version is OOP, which he says is “clean code,” while the second is a simpler C function with a lookup table. The second version runs 25 times faster than the first after he optimizes it with AVX (x86 SIMD instructions).</p>
<p>Casey’s optimized version is most certainly “clean code,” and he should have said as much in the post. His version solves the problem while being minimal, elegant, and fast. However, perhaps confusingly, the OOP version is also clean code in the same positive sense, but only if the slower speed is acceptable in your use case.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/horrible_huebbfad1edfa8e198fe68a27ac6a615ca_47040_600x0_resize_q75_catmullrom.jpg" width="600" height="219"/></p>
	
</div>
<p>The OOP version is wordier but straight out of an introductory OOP class. It’s the minimal OOP solution: an abstract base class with two virtual methods and four concrete classes that implement those two methods, and that’s it. This is clean code, but heavily into the OOP style.</p>
<h3 id="performance">Performance</h3>
<p>Performance is the biggest difference between the two implementations. The optimized version is 25 times faster than the OOP one. Casey puts this performance gap into “iPhone terms,” saying that using the slower version is like forcing yourself to use a really old phone, wiping out “12 years of hardware evolution”.</p>
<p>To him, this means you should never use the OOP version. To me, however, it’s not as definitive. I had a 12-year-old phone, I had one 12 years ago, and it was blazing fast at the time. So I know that level of speed can do useful things. Let’s look at the performance numbers; the cycle counts are from Casey and the other two rows I calculated:</p>
<table>
<thead>
<tr>
<th></th>
<th>OOP</th>
<th>AVX</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cycles to process one shape</td>
<td>44.3 cycles</td>
<td>1.8 cycles</td>
</tr>
<tr>
<td>Time to process one shape at 3GHz</td>
<td>14.75 nanoseconds</td>
<td>0.6 nanoseconds</td>
</tr>
<tr>
<td>Shapes processed in one millisecond</td>
<td>67,797</td>
<td>1,670,000</td>
</tr>
</tbody>
</table>
<p>There are three main reasons why the OOP version is slower than the optimized version:</p>
<ol>
<li>The only way the CPU can process large amounts of data efficiently is if the data is stored in a dense linear array. His clean code implementation did not set up memory this way, so it was doomed to poor performance from the start.</li>
<li>Virtual functions should only be used if the work done inside the virtual function is large compared to the cost of calling the virtual function. His virtual functions were tiny: the largest one contained just two multiplications.</li>
<li>In the optimized version, he uses <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> (SIMD) instructions. These cannot be used in the OOP version because the code is spread out in different classes; there is no tight inner loop to optimize.</li>
</ol>
<h3 id="memory-layout">Memory Layout</h3>
<p>Memory layout is the most important factor here. In his fast version, the loop iterates over a <code>shape_union *Shapes</code>, which is a dense contiguous array of memory that looks like this:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/contiguous_huebbfad1edfa8e198fe68a27ac6a615ca_23818_600x0_resize_q75_catmullrom.jpg" width="600" height="96"/></p>
	
</div>
<p>This is what you want. Each blue circle is one of his <code>shape_union</code> objects. The object contains one <code>u32</code> and two <code>f32</code> variables, so the size of <code>shape_union</code> is 94 bytes, no extra padding should be needed. In this array, we have 94 bytes related to the first shape followed by 94 bytes related to the second shape, and so on – a dense contiguous array of data. Life is good; the CPU is happy.</p>
<p>In the clean code version, on the other hand, the loop iterates over a <code>shape_base **Shapes</code>. This is an array of pointers to shapes. Here is a first attempt to visualize this version:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/pointers-1_huebbfad1edfa8e198fe68a27ac6a615ca_30437_600x0_resize_q75_catmullrom.jpg" width="600" height="161"/></p>
	
</div>
<p>However, this is a very misleading illustration. It implies the shape objects are also neatly organized in memory alongside the main array, but nothing about the type <code>shape_base **Shapes</code> implies or enforces this layout.</p>
<p>Casey didn’t share his allocation code, but most likely, the shape objects were allocated from the heap, which means they could be anywhere in memory, so this is a more accurate depiction of his clean code version:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/pointers-2_huebbfad1edfa8e198fe68a27ac6a615ca_55687_600x0_resize_q75_catmullrom.jpg" width="600" height="332"/></p>
	
</div>
<p>The code is clean, but the data is messy! Objects allocated on the heap are abstractions. For less performance-critical code, we can pretend access to those objects is free, but for low-level performance-critical code, jumping around to random locations in memory is extremely expensive, the CPU hates doing that, so we cannot ignore the cost.</p>
<p>If you think this mess of arrows is an exaggeration because the heap will “probably” give you contiguous allocations, you are in for a nasty surprise. In real applications, the shapes were most likely created at different times, which will scatter their layout. Worse, though, much more scrambling will occur if the array of pointers is sorted, filtered, or altered in any way after creation. The final result is almost certainly going to resemble the above mess.</p>
<p>Nothing we do after this point can undo the damage caused by our scattered memory layout, but let’s look at the virtual functions as well since they are also a problem:</p>
<h3 id="virtual-functions">Virtual Functions</h3>
<div><pre tabindex="0"><code data-lang="C++"><span><span>    <span>// Square
</span></span></span><span><span><span></span>    <span>virtual</span> f32 Area() {<span>return</span> Side * Side;}
</span></span><span><span>    <span>virtual</span> u32 CornerCount() {<span>return</span> 4;}
</span></span><span><span>
</span></span><span><span>    <span>/// Rectangle
</span></span></span><span><span><span></span>    <span>virtual</span> f32 Area() {<span>return</span> Width * Height;}
</span></span><span><span>    <span>virtual</span> u32 CornerCount() {<span>return</span> 4;}
</span></span><span><span>
</span></span><span><span>    <span>// Triangle:
</span></span></span><span><span><span></span>    <span>virtual</span> f32 Area() {<span>return</span> 0.5f * Base * Height;}
</span></span><span><span>    <span>virtual</span> u32 CornerCount() {<span>return</span> 3;}
</span></span><span><span>
</span></span><span><span>    <span>// Circle:
</span></span></span><span><span><span></span>    <span>virtual</span> f32 Area() {<span>return</span> Pi32 * Radius * Radius;}
</span></span><span><span>    <span>virtual</span> u32 CornerCount() {<span>return</span> 0;}
</span></span></code></pre></div><p>C++ prides itself on having “zero-cost abstractions,” but virtual functions are not zero-cost. At runtime, the executable has to figure out which concrete method to call using a hidden virtual pointer (<code>vptr</code>) and a hidden virtual table (<code>vtable</code>). It uses these things to “dynamically dispatch” the appropriate method. The overhead of a virtual function call will swamp the work done if the amount of work is too small.</p>
<p>Casey’s virtual functions are close to as small as you can get. The <code>CornerCount()</code> functions contain zero arithmetic operations, they just return a constant. While the <code>Square::Area()</code> and <code>Rectangle::Area()</code> contain one multiplication, and <code>Triangle::Area()</code> and <code>Circle::Area()</code> contain two multiplications. All of them are too tiny to be efficient virtual functions. This flatbed truck is a depiction of a virtual function call whose overhead is larger than the amount of work it’s doing:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/truck_huebbfad1edfa8e198fe68a27ac6a615ca_118975_600x0_resize_q75_catmullrom.jpg" width="600" height="489"/></p><p>
A virtual function that&#39;s not doing much work.
</p>
	
</div>
<h3 id="flexibility-of-oop">Flexibility of OOP</h3>
<p>If the optimized version was better in every way, the story would end here, just do it the optimized way every time. However the OOP version provides one significant advantage. The way the optimized version gets its dense array of data is this <code>shape_union</code> struct:</p>
<div><pre tabindex="0"><code data-lang="C++"><span><span><span>enum</span> <span>shape_type</span> : u32
</span></span><span><span>{
</span></span><span><span>    Shape_Square,
</span></span><span><span>    Shape_Rectangle,
</span></span><span><span>    Shape_Triangle,
</span></span><span><span>    Shape_Circle,
</span></span><span><span>
</span></span><span><span>    Shape_Count,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>struct</span> <span>shape_union</span>
</span></span><span><span>{
</span></span><span><span>    shape_type Type;
</span></span><span><span>    f32 Width;
</span></span><span><span>    f32 Height;
</span></span><span><span>};
</span></span></code></pre></div><p>The <code>shape_union</code> struct dictates that each shape is defined by only a <code>Width</code> and <code>Height</code>, however in the OOP version each concrete shape class contained slightly different data:</p>
<table>
<thead>
<tr>
<th>Shape</th>
<th>OOP</th>
<th>AVX</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>square</code></td>
<td><code>Side</code></td>
<td><code>Width</code> and <code>Height</code></td>
</tr>
<tr>
<td><code>rectangle</code></td>
<td><code>Width</code> and <code>Height</code></td>
<td><code>Width</code> and <code>Height</code></td>
</tr>
<tr>
<td><code>triangle</code></td>
<td><code>Base</code> and <code>Height</code></td>
<td><code>Width</code> and <code>Height</code></td>
</tr>
<tr>
<td><code>rectangle</code></td>
<td><code>Radius</code></td>
<td><code>Width</code> and <code>Height</code></td>
</tr>
</tbody>
</table>
<p>Given the speedup obtained, if you only need these four shapes, this slight muddying of the data model is a reasonable price to pay, but it hints at the advantage of the OOP approach: every shape can contain totally different data and implement totally different algorithms. If you are going to add new shapes that require novel data and novel algorithms, only the OOP version can easily handle that. Maybe you need to add polygons with N sides, or curve patches, or a shape swept along a spline, or 3D shapes.</p>
<p>A clean solution has to first and foremost be a solution. If the optimized version 100% solves your problem, then great. But if you are going to need to support a panoply of different shapes, the OOP version has some strong advantages. The ultimate solution might be a mix of the two: maximally fast for simple shapes, but make it possible to support complex shapes. Use the right tool for the job.</p>
<h3 id="performance-requirements-and-analysis">Performance Requirements and Analysis</h3>
<p>Now let’s dive into performance. Whether the OOP version is fast enough depends entirely on your use case. Imagine two hypothetical games, one complex 3D game that requires processing 1 million shapes per frame, and one simple mobile puzzle game that requires processing 100 shapes per frame:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/two-games_huebbfad1edfa8e198fe68a27ac6a615ca_154914_600x0_resize_q75_catmullrom.jpg" width="600" height="375"/></p><p>
Hypothetical games: 1 million shapes vs. 100 shapes
</p>
	
</div>
<p>The performance of the 3D game:</p>
<table>
<thead>
<tr>
<th></th>
<th>OOP</th>
<th>AVX</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shapes to process</td>
<td>1,000,000</td>
<td>1,000,000</td>
</tr>
<tr>
<td>Time to process 1M shapes</td>
<td>14.75 milliseconds</td>
<td>0.6 milliseconds</td>
</tr>
<tr>
<td>Percent of 60Hz (16.7ms) frame</td>
<td>88%</td>
<td>3.6%</td>
</tr>
</tbody>
</table>
<p>There’s no way we could afford to burn 88% of our frame processing shapes, even if we used a separate thread. But 3.6% sounds reasonable. So this is a huge win for the AVX version. With the OOP version we basically do not have a game, we cannot ship it, but with the AVX version we have a chance. The optimization saves our bacon in this case.</p>
<p>How about the puzzle version:</p>
<table>
<thead>
<tr>
<th></th>
<th>OOP</th>
<th>AVX</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shapes to process</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>Time to process 100 shapes</td>
<td>1.5 microsecond</td>
<td>0.06 microseconds</td>
</tr>
<tr>
<td>Percent of 60Hz (16.7ms) frame</td>
<td>0.01%</td>
<td>0.0004%</td>
</tr>
</tbody>
</table>
<p>As you’d expect 0.0004% is still 25x faster than 0.01%, but in this case 0.01% is almost certainly fast enough. That means we only burn one-thousandth of the frame to do the shape processing. Let’s look at it another way, how many shapes can we process in a fixed amount of time. I’ll arbitrarily use 1 millisecond as our “budget,” setting budgets is a good practice to get into:</p>
<table>
<thead>
<tr>
<th>Shapes in 1 millisecond</th>
<th>OOP</th>
<th>AVX</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>1,000</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>10,000</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>100,000</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>1,000,000</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>10,000,000</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>This table summarizes that there’s a range of timescales where the
OOP version performs fine, up to 10,000 shapes. But if you need to process 100,000 or 1,000,000 shapes in a millisecond, you absolutely need the AVX version. And then it points out neither can do 10,000,000 shapes in a millisecond.</p>
<p>This is all hypothetical. You need to understand your application and its requirements. Don’t be scared away from using OOP if it meets your needs, but don’t mindlessly use OOP either. Very often a mix of approaches is the best. Many programs start with OOP at a high level, where N is small, but then filters into dense linear arrays when N is large. For example, maybe you have at most 64 characters on screen in your game, so an object per character is fine, but if you are going to draw a million meshes than OOP would be a very bad choice there.</p>
<p>Casey worked at <a href="https://www.radgametools.com/">RAD Game Tools</a> for many years. If you are making a “shape processing” library for game developers you might have no idea how many shapes they will process. In that case, providing the optimized version for your users might make more sense. And if you need to support additional shapes, maybe provide both a fast version and a more flexible one: give people a choice.</p>

<p>Casey’s Horrible Performance article concludes by railing against “the clean code rules”:</p>
<ul>
<li>The rules <em>simply aren’t acceptable</em>.</li>
<li>The rules <em>are almost all horrible for performance, and you shouldn’t do them</em>.</li>
<li>The rules <em>need to stop being said unless they are accompanied by a big old asterisk that says your code will get 15 times slower</em>.</li>
</ul>
<p>He’s completely right and completely wrong at the same time. He’s right that if you need to process hundreds of thousands of shapes in a millisecond, you are totally and utterly hosed if you use the OOP version: it is simply too slow for that. You must use the optimized version in that case. But he’s completely wrong that the OOP version has “horrible performance” for all possible requirements. It can process tens of thousands of shapes per millisecond. If that’s all you need, or if you need fewer, it might be 100% acceptable to you.</p>
<p>OOP, in this case, is like a chainsaw. It’s a tool that works well in many situations but works poorly in other cases. Casey’s shrill insistence that “clean code” performs horribly across the board is similar to a surgeon using a chainsaw to remove a patient’s appendix.</p>
<p>When the surgeon makes a huge mess and kills the patient, he stands up on the blood-spattered operating room table and gives a passionate speech about how chainsaws should never be used for any purpose ever, by anyone. Meanwhile, millions of people worldwide productively use chainsaws every day, just like millions of developers successfully use OOP. A chainsaw has a lot of uses, but performing appendectomies is not one of them, so don’t use it for that, and don’t use OOP where you need maximally efficient inner loops. This chart summarizes our findings:</p>
<table>
<thead>
<tr>
<th>OOP</th>
<th>Okay?</th>
<th>Chainsaw</th>
<th>Okay?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nanoseconds</td>
<td>❌</td>
<td>Abdominal Surgery</td>
<td>❌</td>
</tr>
<tr>
<td>Microseconds</td>
<td>✅</td>
<td>Tree Limb</td>
<td>✅</td>
</tr>
<tr>
<td>Milliseconds</td>
<td>✅</td>
<td>Small Tree</td>
<td>✅</td>
</tr>
<tr>
<td>Seconds</td>
<td>✅</td>
<td>Large Tree</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h3 id="even-more-overhead">Even more overhead</h3>
<p>The previous table showed that the “clean code overhead” was 42.5 cycles, 14.5 nanoseconds on a 3GHz machine. But let’s go crazy with this next table. Let’s assume the overhead of our clean code, or whatever methodology we use, is 100 nanoseconds. A huge amount of overhead, 300 times longer than a clock tick. This might be even slower than an interpreted language like Python or Javascript, but it doesn’t matter what the source of the overhead is. This is the damage that 100 nanoseconds will do:</p>
<table>
<thead>
<tr>
<th>Duration of Loop Body</th>
<th>Amount of Overhead</th>
<th>Descriptive Term</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 nanoseconds</td>
<td>5000%</td>
<td>Crazy huge</td>
</tr>
<tr>
<td>2 microseconds</td>
<td>5%</td>
<td>Relatively small</td>
</tr>
<tr>
<td>2 milliseconds</td>
<td>0.005%</td>
<td>Impossible to measure</td>
</tr>
<tr>
<td>2 seconds</td>
<td>0.000005%</td>
<td>Impossible to measure</td>
</tr>
</tbody>
</table>
<p>The impact of 100 nanoseconds disappears quickly as we go lower in the table because this chart depicts nine orders of magnitude of durations. To state the obvious, two seconds are 1,000,000,000 times longer than two nanoseconds. Well, duh, but our hunter-gatherer brains weren’t built to think about durations of time that span nine orders of magnitude. If you work mostly in one of these timescales, it’s easy to forget the others even exist, let alone be facile in thinking about them.</p>
<p>The above chart gets at the heart of every disagreement about the performance implications of clean code, which I’ve seen ricocheting around X and YouTube for the last year. Inevitably, one person is thinking about the first row while the other person is thinking about one of the other rows, but neither discloses the time scale they are dealing with, and hilarity ensues.</p>
<p>Here’s the same chart but to make it more relatable we’ll use a little story. Imagine you are packing your bags for a trip, and it takes you 50 minutes to pack your bags. Here’s the amount of overhead, the amount of time spent packing, relative to the length of the trip:</p>
<table>
<thead>
<tr>
<th>Trip Duration</th>
<th>Natural Units</th>
<th>Amount of Overhead</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 minute</td>
<td>1 minute</td>
<td>5000%</td>
</tr>
<tr>
<td>1,000 minutes</td>
<td>16.57 hours</td>
<td>5%</td>
</tr>
<tr>
<td>1 million minutes</td>
<td>1.9 years</td>
<td>0.005%</td>
</tr>
<tr>
<td>1 billion minutes</td>
<td>1903 years</td>
<td>0.000005%</td>
</tr>
</tbody>
</table>
<p>Hopefully it’s clear why 50 minutes of overhead has negligible impact on a trip that lasts for 1903 years! This is the same impact 100ns of overhead has if the unit of work is two seconds.</p>
<p>The concept of “overhead” is common to many disciplines; much skull time has been devoted to thinking about it. People worry about overhead in fields as diverse as operations research, supply chain management, systems engineering, chemical engineering, etc. It goes like this: there’s some work we want to do, but we can’t do it all at once, so we divide that work into batches. However, there is some overhead related to each batch. Given all this, how big should the batches be?</p>
<p>How are the size of these important resources chosen:</p>
<ul>
<li>Disk blocks</li>
<li>Network packets</li>
<li>Virtual memory pages</li>
<li>Caches and cache lines</li>
<li>I/O buffers</li>
</ul>
<p>How about shipping containers, the ones carried by ships, trucks and trains, not Docker containers. In all cases, there’s overhead associated with each unit of work, so we carefully size the unit of work relative to the overhead to strike a good balance between efficiency, latency, and any other concerns.</p>
<p>How big should bites of your sandwich be? If you chewed and swallowed after every cubic millimeter of rye bread, you’d exhibit horrible eating performance, so instead, we choose a bite-size that’s, well, bite-sized. If you only need to do 1.8 nanoseconds of real work, you cannot tolerate essentially any overhead, but if you are doing even a microsecond’s worth of work at a time, those bites are a thousand times bigger, so the overhead is proportionally far less.</p>
<h3 id="video-games">Video games</h3>
<p>Casey worked at <a href="https://www.radgametools.com/">RAD Game Tools</a>, which sells libraries used in “thousands and thousands” of shipping games. A hyper-fixation on performance can be warranted inside game engines or game libraries. But engines and libraries stand in contrast to “the game code,” which is often not performance-critical. Instead of running millions of times, game code might run just once at one specific point in the game.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/gta_huebbfad1edfa8e198fe68a27ac6a615ca_125135_600x0_resize_q75_catmullrom.jpg" width="600" height="325"/></p><p>
Rockstar expects to release GTA 6 in Fall 2025
</p>
	
</div>
<p>Rockstar’s Advanced Game Engine (<a href="https://en.wikipedia.org/wiki/Rockstar_Advanced_Game_Engine">RAGE</a>) has been used to power ten popular games over the last two decades, including the hotly anticipated <a href="https://www.rockstargames.com/VI">Grand Theft Auto VI</a> that’s been under development for years, due out in 2025. However, most of the 2,000+ developers making GTA 6 are not working on the engine; they are working on the code, art, or design related to the missions the player will advance through in the single-player campaign. Since there is so much game code to write, and it’s generally not performance-critical, developers often move the game code to a scripting language.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/guitar-hero_huebbfad1edfa8e198fe68a27ac6a615ca_125657_600x0_resize_q75_catmullrom.jpg" width="600" height="417"/></p><p>
Guitar Hero franchise grossed $2 billion within four years of release.
</p>
	
</div>
<p>I was the lead programmer on the original <a href="https://en.wikipedia.org/wiki/Guitar_Hero">Guitar Hero</a> for PlayStation 2 in 2005, and that’s how we did it. About two-thirds of the game was written in C++ for speed, but one-third was in a proprietary scripting language. <a href="https://virzoom.com/author/emalafeew/">Eric Malafeew</a>, the Chief Architect and Engineering Lead, invented the language and tenderly nurtured its development. It looked similar to Lisp and was a simple text file anyone could edit without the need to recompile the game.</p>
<p>For instance, the C++ code would emit an event when the song ended, and a script hook would trigger animations and sounds to explode the track. This way, designers and artists could edit the script without a programmer’s involvement. This flexibility was critical to iterating quickly: the entire game was developed in nine months, start to finish. Take that, Rockstar.</p>
<p>You can find similar pairings of fast and slow languages everywhere in the modern computing landscape, far beyond games. For instance, your web browser is probably written in C++, but almost every website you visit is powered by Javascript, a much slower language. The <a href="https://v8.dev/">V8 Javascript Engine</a> alone has nearly two million lines of C++, but it can run scripts from hundreds of millions of different websites, none of which need to have a C++ programmer on staff. This division of labor allowed millions of people to create websites: if every website had to be written in C++, the web would be a very different place.</p>
<h3 id="python">Python</h3>
<p>The Python ecosystem is another place where a mix of programming languages, and thus differing degrees of overhead, is incredibly effective. Below are some possible dependencies for a machine-learning application written in Python.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/dependencies_huebbfad1edfa8e198fe68a27ac6a615ca_55646_600x0_resize_q75_catmullrom.jpg" width="600" height="470"/></p><p>
The dependencies of a Machine Learning application written in Python.
</p>
	
</div>
<p>Combined, these dependencies contain millions of lines of C/C++, Rust, and even Fortran code, much of which is heavily optimized for speed. The existence of layers written in different languages is an amazingly effective and productive arrangement. Splitting responsibilities into layers allows large numbers of people to tackle ambitious problem domains concurrently because they focus their job, maybe their entire career, on one particular layer. I admire and respect the people working on every dependency in this chart, all layers are important.</p>
<h3 id="mixture-of-optimization-levels">Mixture of Optimization Levels</h3>
<p>Imagine a world where every bit of code everywhere had to be hyper-optimized. Everything had to be written in C or assembly and was carefully engineered for maximum speed. Everything would be super fast! The chart below depicts that world. The Y-axis is the log of the amount of overhead, while the X-axis is the log of the number of operations performed with that amount of overhead. This chart shows us doing quadrillions of computations, and the overhead is never more than a nanosecond:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/optimized_huebbfad1edfa8e198fe68a27ac6a615ca_142237_600x0_resize_q75_catmullrom.jpg" width="600" height="410"/></p><p>
Everything is maximally optimized.
</p>
	
</div>
<p>The above might be possible for a small high-performance library, such as a core neural network kernel, but it’s impossible to achieve this level of uniform optimization for a sprawling codebase; it would be way too much effort. Instead consider a program written in a high-level language like Python without optimized libraries. Everything is in “pure Python,” so the overhead of every operation is large. We do far fewer operations because it just wouldn’t be tractable to do zillions of operations in pure Python:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/pure-python_huebbfad1edfa8e198fe68a27ac6a615ca_113640_600x0_resize_q75_catmullrom.jpg" width="600" height="429"/></p><p>
Program written in Pure-python or any &#34;slow&#34; language.
</p>
	
</div>
<p>The next plot is what’s common in the real-world for large systems, which is generally what you want. An application was written in Python or some other high-level language using optimized lower-level libraries. Since the X-axis is log, there are many orders of magnitude more fast operations even though it’s only a bit wider:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/blended_huebbfad1edfa8e198fe68a27ac6a615ca_139522_600x0_resize_q75_catmullrom.jpg" width="600" height="402"/></p><p>
A program written with a blend of languages and styles.
</p>
	
</div>
<p>This is a healthy system. Wherever needed, we implement computations in faster languages or with more optimized techniques, but we don’t needlessly optimize the whole world. We keep the higher-level code accessible to a wider audience of software engineers, where changes can be made quickly. We constantly re-evaluate slower code and promote it to faster code whenever needed, whether by ourselves or by adopting a library someone else carefully optimized for us.</p>
<h3 id="diversity-in-the-time-domain">Diversity in the Time Domain</h3>
<p>There’s tremendous diversity in the software industry, in the same way there is in the construction industry. Construction workers build sheds, houses, townhouses, apartment buildings, shopping malls, gleaming office towers, stadiums, bridges, nuclear power plants, and launchpads for rockets to Mars. All of these things are useful in their own way.</p>
<p>In software, the diversity is less visible. To the untrained eye, all programmers do roughly the same thing: typing on our keyboards and staring at the screen. But the software we are developing does vary drastically. Here are some of the projects I’ve personally worked on over the last thirty years and the time scales that were involved:</p>
<table>
<thead>
<tr>
<th>Problem Domain</th>
<th>Update Frequency</th>
<th>Cycle time</th>
</tr>
</thead>
<tbody>
<tr>
<td>LED Ceiling Tracker</td>
<td>3000Hz</td>
<td>300us</td>
</tr>
<tr>
<td>Haptic Device</td>
<td>1000Hz</td>
<td>1ms</td>
</tr>
<tr>
<td>Graphics (Console game)</td>
<td>60Hz</td>
<td>16.7ms</td>
</tr>
<tr>
<td>Graphics (VR)</td>
<td>120Hz</td>
<td>8.3ms</td>
</tr>
<tr>
<td>Responsive Button Press</td>
<td>Once</td>
<td>100ms</td>
</tr>
<tr>
<td>Natural language ML task</td>
<td>Continually</td>
<td>10 seconds</td>
</tr>
<tr>
<td>Point cloud and spherical image processor</td>
<td>Once a week</td>
<td>Days</td>
</tr>
</tbody>
</table>
<p>Again, this is nine orders of magnitude of cycle times. I once talked to a woman on a plane who was a video editor. She saw me writing code and asked about it. I asked her about video editing. We agreed that video editing was very technical and complicated, but that software was markedly different because there was no bottom.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/timeline_huebbfad1edfa8e198fe68a27ac6a615ca_103301_600x0_resize_q75_catmullrom.jpg" width="600" height="303"/></p><p>
Timeline for one reel of Mission: Impossible - Rogue Nation (2015)
</p>
	
</div>
<p>Lets see how deep software goes. If you want to read about the AVX instructions that Casey used in his fast version, crack open Intel’s <a href="https://cdrdv2.intel.com/v1/dl/getContent/671200">5,000-page PDF</a> on the x86 instruction set, a little nighttime reading:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/intel_huebbfad1edfa8e198fe68a27ac6a615ca_59622_600x0_resize_q75_catmullrom.jpg" width="600" height="412"/></p><p>
Read about AVX in Intel&#39;s x86 instruction set manual.
</p>
	
</div>
<p>And when you’re done with that, start reading about transistors, fabrication design, photolithography, etching, and doping. Then, move on to how we mine the raw materials.</p>
<p>In the other direction, upwards, if you use AWS or any cloud vendor, they have billions of lines of code that run on hundreds of thousands of computers, each one of which has all the full complexity of a single machine running regular software. Meanwhile, if you are writing a large application that runs in the cloud, you are piling things higher still, building on top of the whole sordid affair.</p>
<p>The idea of cooperating layers at different levels of abstraction predates Computer Science —  it’s embedded in reality itself. There are hundreds of academic fields at a large University, but here are eight of them roughly arranged into layers:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/reality_huebbfad1edfa8e198fe68a27ac6a615ca_55983_600x0_resize_q75_catmullrom.jpg" width="600" height="472"/></p><p>
Layers of academic fields studying reality.
</p>
	
</div>
<p>As with software, a higher layer can reach way down to any lower dependency: any of these fields, except perhaps for Politics, can do Math. The lowest levels here, Math and Physics, have a reputation for being conceptually difficult and technically challenging, like working on a game engine or the Linux kernel, but interesting, important, and difficult work is done in all of these layers.</p>
<h3 id="natural-language-programming">Natural Language Programming</h3>
<p>As we speak, Artificial Intelligence is rapidly reshaping the computing landscape. It will allow people to “program” in natural languages, like English or any human language, potentially expanding who can be a programmer to the entire world. While all the traditional software layers will still exist underneath, the conceptual model of people writing “code” in the future might be something like this:</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/the-future_huebbfad1edfa8e198fe68a27ac6a615ca_41676_600x0_resize_q75_catmullrom.jpg" width="600" height="471"/></p><p>
Conceptual model for natural language programming.
</p>
	
</div>
<p>If you cringe at how much computation a single line of Python can invoke, you’ll faint when you see how much compute and energy these large neural networks will burn. The total energy available worldwide will be the limiting factor when everyone can expend trillions of CPU cycles just asking for the weather. As you’d expect, though, virtually all of those cycles will be running in hyper-optimized code, eventually in hyper-optimized hardware as well.</p>
<p>Each layer is critically important in a tall stack of dependencies. Imagine the grand opening of a Las Vegas hotel with gleaming marble floors, oceans of high-tech gaming machines, and a fancy theater with an aging pop star in residence. Now, imagine every toilet in the building is overflowing. We need every layer to work efficiently and be free of security vulnerabilities. Achieving that will take tremendous effort forever.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/tools_huebbfad1edfa8e198fe68a27ac6a615ca_97953_600x0_resize_q75_catmullrom.jpg" width="600" height="375"/></p><p>
Humans are tool makers as much as tool users.
</p>
	
</div>
<p>However, Object-Oriented Programming isn’t a layer; it’s a tool. When I was discussing Casey’s optimization post on X, Uncle Bob himself <a href="https://twitter.com/unclebobmartin/status/1786058278545281233">chimed into our thread</a>, saying don’t use clean code if it’s too slow for your needs. He wrote, “It is generally true that any tool you use must be worth using. The benefit must exceed the cost.”</p>
<h3 id="functional-programming">Functional Programming</h3>







<div>
	<p><img src="https://tobeva.com/articles/beyond/sicp_huebbfad1edfa8e198fe68a27ac6a615ca_74181_600x0_resize_q75_catmullrom.jpg" width="600" height="246"/></p><p>
The famous SICP uses Scheme, a Lisp variant to teach FP.
</p>
	
</div>
<p>Years after writing Clean Code, Uncle Bob had an epiphany reading the famous MIT book Structure and Interpretation of Computer Programs (SICP) by Harold Abelson, Gerald Sussman, and his wife, Julie Sussman. The book uses Scheme, a variant of Lisp, as its teaching language. Uncle Bob was so taken in by the book he’s spent much of the last decade programming in Clojure, a Lisp dialect that runs on the JVM. Conveniently, any JVM language can interoperate with Java, his previous go-to language.</p>
<p>Uncle Bob hasn’t denounced OOP but says FP and OOP (and even procedural) are valid approaches to writing software. He says use whichever makes sense for the problem you are trying to solve, a sane and pragmatic stance that doesn’t require slagging someone’s life’s work.</p>
<h3 id="physical-bits">Physical Bits</h3>
<p>Software development is a game of intense cooperation between you and millions of strangers you will never meet. We interface through a giant codebase we’ve been building for eighty years. There is room for everyone, whether you join late and write “code” in English or have spent decades perfecting hand-tuning your assembly one instruction at a time, we need it all.</p>







<div>
	<p><img src="https://tobeva.com/articles/beyond/brooks_huebbfad1edfa8e198fe68a27ac6a615ca_94945_600x0_resize_q75_catmullrom.jpg" width="600" height="261"/></p><p>
Frederick P. Brooks Jr. Computer Science Building at UNC-Chapel Hill.
</p>
	
</div>
<p>When I worked as a Research Engineer at UNC-Chapel Hill, <a href="https://amturing.acm.org/award_winners/brooks_1002187.cfm">Fred Brooks</a> randomly popped into meetings and offered sage advice. He was a kind and insightful person. In <a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month"><em>The Mythical Man-Month</em></a>, he wrote, “The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination.”</p>
<p>Of course, the <a href="https://amturing.acm.org/award_winners/brooks_1002187.cfm">Turing Award winner</a> was right, but there is more. We first build castles in the air, in our heads, but then we encode them into bits. Not ethereal abstract bits, not platonic bits, but real physical bits: the orientation of magnetic domains on a hard drive, electrical charges in floating-gate transistors in an SSD, tiny capacitors in RAM, optical pulses on a fiber optic cable.</p>
<p>At any given time, like right now, you could combine every physical bit of software on the planet, place them end-to-end, in a dense contiguous array, and then interpret the result as a single gigantic integer. One number representing the sum total of all software humans have created. This leads to two intriguing questions. How large will this number ultimately grow? And what was the previous high score?</p>
<h3 id="video">YouTube Video</h3>
<p>
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/VrH8dPJZA0E?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" title="YouTube video"></iframe>
    </p>

</div>


        </main>
      </div>
    </div>
  </div></div>
  </body>
</html>
