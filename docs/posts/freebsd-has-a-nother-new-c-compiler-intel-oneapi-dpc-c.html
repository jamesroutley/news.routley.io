<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://briancallahan.net/blog/20240306.html">Original</a>
    <h1>FreeBSD has a(nother) new C compiler: Intel oneAPI DPC&#43;&#43;/C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page">
	<a name="top"></a>
	<div id="main">
	    
	    <p>academic, developer, with an eye towards a brighter techno-social life</p>
	    <hr/>
		
	    <hr/>
	</div>
<h5 id="prev"><a href="https://briancallahan.net/blog/20240122.html">[prev]</a></h5>
<h5 id="next">[next]</h5>
    <h2 id="title">2024-03-06</h2>
<p><a href="https://briancallahan.net/blog/20240101.html" target="_blank">A few months ago</a>, we got <a href="https://www.oracle.com/application-development/developerstudio/" target="_blank">Oracle Developer Studio</a> to run on and output native binaries for <a href="https://www.freebsd.org/" target="_blank">FreeBSD</a>. Today, let&#39;s get another proprietary compiler going on FreeBSD: the <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html" target="_blank">Intel oneAPI DPC++/C++ Compiler</a>. The latest version of this compiler as of this blog post is 2024.0.2, and this is the version we will get running on FreeBSD. This is the new Intel compiler that uses the <a href="https://clang.llvm.org/" target="_blank">Clang</a> frontend from the <a href="https://llvm.org/" target="_blank">LLVM</a> project as its frontend, in contrast to the old version of the Intel compiler, which I believe used the <a href="https://www.edg.com/" target="_blank">Edison Design Group</a> frontend. What makes the new Intel compiler interesting is both the Clang frontend, which should just work on FreeBSD as Clang is the built-in compiler for FreeBSD, and the backend, which is Intel&#39;s custom and proprietary backend.</p>
<p>As mentioned <a href="https://briancallahan.net/blog/20240101.html" target="_blank">previously</a>, a FreeBSD <a href="https://www.freshports.org/lang/icc/" target="_blank">port</a> of the old Intel C++ Compiler was created. It is still in the ports tree, but it only works on i386 and is version 8.1 of the compiler, <a href="https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler#Release_history" target="_blank">released in September 2004</a>. This update is a long time coming.</p>
<p>Let&#39;s get started.</p>
<h4>Setting up the Linuxulator</h4>
<p>Like with Oracle Developer Studio, it comes as Linux binaries; the Intel compiler is partially open source as far as I understand it. That means we will need to set up the <a href="https://wiki.freebsd.org/Linuxulator" target="_blank">Linuxulator</a>. I am using <a href="https://www.freebsd.org/releases/14.0R/announce/" target="_blank">FreeBSD 14.0-RELEASE</a>, the <a href="https://download.freebsd.org/releases/amd64/amd64/ISO-IMAGES/14.0/" target="_blank">amd64</a> flavor, so I am going to follow the <a href="https://docs.freebsd.org/en/books/handbook/linuxemu/" target="_blank">FreeBSD Handbook</a>, installing the CentOS 7 base and libelf packages. The commands you need are:</p>
<pre># sysrc linux_enable=&#34;YES&#34;
# service linux start
# pkg install linux_base-c7 linux-c7-elfutils-libelf
</pre>
<p>And that&#39;s it. The CentOS 7 libraries, though old, are enough for the Intel compiler to work.</p>
<h4>Installing the compiler</h4>
<p>First, I installed some tools that we will need. The installer script needs the GNU <a href="https://www.gnu.org/software/coreutils/" target="_blank">df</a>, <a href="https://www.gnu.org/software/tar/" target="_blank">tar</a>, and <a href="https://www.gnu.org/software/bash/">bash</a>. We will need to install these:</p>
<pre># pkg install bash coreutils gtar
</pre>
<p>I then needed to make sure GNU df is found first and gtar is also found first, and that they are named <code>df</code> and <code>tar</code>. I did that by running:</p>
<pre>$ mkdir ~/bin
$ cd ~/bin
$ cp /usr/local/bin/gdf df
$ cp /usr/local/bin/gtar tar
$ export PATH=~/bin:$PATH
</pre>
<p>Now the installer will not complain.</p>
<p>Let&#39;s download and run the installer now. I want to install the compiler to <code>/opt/intel</code> so I will make sure to run the script as root:</p>
<pre>$ cd
$ fetch https://registrationcenter-download.intel.com/akdlm/IRC_NAS/bb99984f-370f-413d-bbec-38928d2458f2/l_dpcpp-cpp-compiler_p_2024.0.2.29_offline.sh
$ sudo bash l_dpcpp-cpp-compiler_p_2024.0.2.29_offline.sh -a -s --eula accept --ignore-errors
</pre>
<p>...but eventually I gave up; while the installation completes, because the installer cannot find <a href="https://gcc.gnu.org/" target="_blank">G++</a> it does not install all the programs, most notably the <code>icx</code> and <code>icpx</code> compilers. This is a failing on Intel&#39;s part: I have to imagine the reason the installer is looking for G++ is because it thinks without it, you don&#39;t have the necessary headers and libraries. But this is untrue on FreeBSD as those things come installed by default. Installing the <code>gcc</code> package does not fix things, so Intel should improve their installation program to fix things. Even so, there is a <code>--ignore-errors</code> flag, and I think that flag should ignore if G++ is missing and simply install everything anyway.</p>
<p>There is a workaround: I installed the compiler using the same command on my WSL environment on Windows. I was then able to bundle the resulting <code>/opt</code> directory into a tarball and move and extract the tarball on the FreeBSD machine. This worked fine, and now I have the compiler installed to <code>/opt/intel</code>. I also removed the <code>~/bin</code> directory as that was only needed for installation and we didn&#39;t install it from the provided installer after all.</p>
<h4>Using the compiler</h4>
<p>If I run <code>/opt/intel/oneapi/compiler/latest/bin/icx --version</code>, I get back:</p>
<pre>Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231213)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /opt/intel/oneapi/compiler/2024.0/bin/compiler
Configuration file: /opt/intel/oneapi/compiler/2024.0/bin/compiler/../icx.cfg
</pre>
<p>This definitely looks like Clang. For comparison, if I run <code>cc --version</code>, I get back:</p>
<pre>FreeBSD clang version 16.0.6 (https://github.com/llvm/llvm-project.git llvmorg-16.0.6-0-g7cbf1a259152)
Target: x86_64-unknown-freebsd14.0
Thread model: posix
InstalledDir: /usr/bin
</pre>
<p>This makes me wonder something: if Intel didn&#39;t do all that much modification, could we convince <code>icx</code> that it is targeting FreeBSD? On Clang, we could do this with the <code>-target</code> flag.</p>
<p>Indeed, if I run <code>icx -target x86_64-unknown-freebsd14.0 --version</code>, I get back this:</p>
<pre>Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231213)
Target: x86_64-unknown-freebsd14.0
Thread model: posix
InstalledDir: /opt/intel/oneapi/compiler/2024.0/bin/compiler
Configuration file: /opt/intel/oneapi/compiler/2024.0/bin/compiler/../icx.cfg
</pre>
<p>Yup, look at that. Now <code>icx</code> believes it is targeting FreeBSD. This somewhat indicates that Intel could very simply and trivially provide binaries for at least FreeBSD, but probably all the BSDs, if they wanted to.</p>
<p>Let&#39;s try to compile this hello world program:</p>
<pre>#include &lt;stdio.h&gt;

int main(void) { puts(&#34;Hello&#34;); return 0; }
</pre>
<p>If we compile it with <code>/opt/intel/oneapi/compiler/latest/bin/icx -v hello.c</code>, we see:</p>
<pre>Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231213)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /opt/intel/oneapi/compiler/2024.0/bin/compiler
Configuration file: /opt/intel/oneapi/compiler/2024.0/bin/compiler/../icx.cfg
 &#34;/opt/intel/oneapi/compiler/2024.0/bin/compiler/clang&#34; -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -dumpdir a- -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name hello.c -mrelocation-model static -fveclib=SVML -mframe-pointer=none -menable-no-infs -menable-no-nans -fapprox-func -funsafe-math-optimizations -fno-signed-zeros -mreassociate -freciprocal-math -fdenormal-fp-math=preserve-sign,preserve-sign -ffp-contract=fast -fno-rounding-math -ffast-math -ffinite-math-only -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -mllvm -x86-enable-unaligned-vector-move=true -tune-cpu generic -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/brian -resource-dir /opt/intel/oneapi/compiler/2024.0/lib/clang/17 -internal-isystem /opt/intel/oneapi/compiler/2024.0/bin/compiler/../../opt/compiler/include -internal-isystem /opt/intel/oneapi/compiler/2024.0/lib/clang/17/include -internal-isystem /usr/local/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -O2 -fdebug-compilation-dir=/home/brian -ferror-limit 19 -fheinous-gnu-extensions -fgnuc-version=4.2.1 -fcolor-diagnostics -vectorize-loops -vectorize-slp -D__GCC_HAVE_DWARF2_CFI_ASM=1 -fintel-compatibility -fintel-libirc-allowed -mllvm -disable-hir-generate-mkl-call -mllvm -loopopt=1 -floopopt-pipeline=light -mllvm -intel-abi-compatible=true -o /tmp/icx-7df38f729d/hello-6860a3.o -x c hello.c
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory &#34;/include&#34;
#include &#34;...&#34; search starts here:
#include &lt;...&gt; search starts here:
 /opt/intel/oneapi/compiler/2024.0/bin/compiler/../../opt/compiler/include
 /opt/intel/oneapi/compiler/2024.0/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
 &#34;/usr/bin/ld&#34; --hash-style=gnu --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o a.out /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/crtbegin.o -L/opt/intel/oneapi/compiler/2024.0/bin/compiler/../../lib -L/opt/intel/oneapi/compiler/2024.0/bin/compiler/../../lib -L/opt/intel/oneapi/compiler/2024.0/lib/clang/17/lib/x86_64-unknown-linux-gnu -L/opt/intel/oneapi/compiler/2024.0/bin/compiler/../../lib -L/lib/../lib64 -L/usr/lib/../lib64 -L/opt/intel/oneapi/compiler/2024.0/bin/compiler/../../lib -L/opt/intel/oneapi/compiler/2024.0/bin/compiler/../../opt/compiler/lib -L/lib -L/usr/lib /tmp/icx-7df38f729d/hello-6860a3.o -Bstatic -lsvml -Bdynamic -Bstatic -lirng -Bdynamic -Bstatic -limf -Bdynamic -lm -lgcc --as-needed -lgcc_s --no-as-needed -Bstatic -lirc -Bdynamic -ldl -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed -Bstatic -lirc_s -Bdynamic /usr/lib/crtend.o /usr/lib/crtn.o
</pre>
<p>That&#39;s close. The compilation might be fine, but the linking is definitely not fine. Fortunately, we know how to fix it.</p>
<h4>Fixing up the Intel compiler</h4>
<p>Similarly to Oracle Developer Studio, the Intel compilers need a small wrapper program to help them along. You could get away with a shell script, but I will use <a href="https://dlang.org/" target="_blank">D</a> to write the wrapper programs. Unlike Oracle Developer Studio, we don&#39;t need to manipulate the preprocessor defines as the <code>-target</code> flag does that for us. Changing the target also changes the linker invocation to be correct. The wrapper program looks like this:</p>
<pre>import std.process;

int main(string[] args) {
    string[] av;

    av ~= &#34;/opt/intel/oneapi/compiler/latest/bin/icx&#34;;
    av ~= &#34;-target&#34;;
    version (FreeBSD_14) av ~= &#34;x86_64-unknown-freebsd14.0&#34;;
    else version (FreeBSD_13) av ~= &#34;x86_64-unknown-freebsd13.0&#34;;
    av ~= &#34;-fno-builtin&#34;;

    foreach (i; 1 .. args.length)
        av ~= args[i];

    return spawnProcess(av).wait;
}
</pre>
<p>Save it as <code>icx.d</code> and then all we need to do is compile it with <a href="https://wiki.dlang.org/LDC" target="_blank">LDC</a> and we&#39;ll be good:</p>
<pre>$ ldc2 -O icx.d
</pre>
<p>That will create a binary named <code>icx</code>. I put it in <code>/usr/bin</code> but you could put it in <code>/usr/local/bin</code> if you were going to make this into a port or something.</p>
<p>Similar needs to be done for the <code>icpx</code> wrapper:</p>
<pre>import std.process;

int main(string[] args) {
    string[] av;

    av ~= &#34;/opt/intel/oneapi/compiler/latest/bin/icpx&#34;;
    av ~= &#34;-target&#34;;
    version (FreeBSD_14) av ~= &#34;x86_64-unknown-freebsd14.0&#34;;
    else version (FreeBSD_13) av ~= &#34;x86_64-unknown-freebsd13.0&#34;;
    av ~= &#34;-fno-builtin&#34;;

    foreach (i; 1 .. args.length)
        av ~= args[i];

    return spawnProcess(av).wait;
}
</pre>
<p>Save it as <code>icpx.d</code> and run:</p>
<pre>$ ldc2 -O icpx.d
</pre>
<p>And you will have yourself an <code>icpx</code> binary.</p>
<h4>Why the <code>-fno-builtin</code>?</h4>
<p>When you change the target <code>icx</code> is compiling for, it greatly changes the linker invocation. This actually makes sense, as the Linux libraries actually depend on glibc-specific features. For example, anything more than trivial programs will give you linker errors saying you are missing functions such as <a href="https://codebrowser.dev/glibc/glibc/debug/vsnprintf_chk.c.html" target="_blank"><code>__vsnprintf_chk</code></a>. This is a bit unfortunate; when I created a library with those functions and linked it in, everything worked fine. So again, Intel could provide a fully working compiler and support libraries for all the BSDs if they so choose to. To circumvent the need to use Intel&#39;s support libraries, you add <code>-fno-builtin</code>.</p>
<h4>The first Intel compiler-built FreeBSD kernel?</h4>
<p>As a test, I installed the FreeBSD 14.0-RELEASE source code on my machine and built a kernel with:</p>
<pre># cd /usr/src
# CC=icx COMPILER_TYPE=clang make buildkernel
</pre>
<p>And then I waited around for a little bit, but it did in fact complete the build. When I run <code>readelf -x .comment /usr/obj/usr/src/amd64.amd64/sys/GENERIC/kernel</code>, I see the comment I am expecting: <code>Intel(R) oneAPI DPC++/C++ Compiler 2024.0.2 (2024.0.2.20231223)</code>. The <code>icx</code> built kernel is about 3% larger than the kernel that came installed on the system.</p>
<p>I then ran <code>make installkernel</code> and once confirming my new kernel was in fact installed, I rebooted the machine. To my absolute astonishment, it booted just fine and put me into my X environment.</p>
<p>In a hilarious twist, the only thing that appears to have been miscompiled is the Linuxulator, as I get a bunch of these messages in my dmesg:</p>
<pre>kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linux.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linux.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linux64.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linux64.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 108
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/fdescfs.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linprocfs.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linprocfs.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linsysfs.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linsysfs.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linprocfs.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linprocfs.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 310
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/linux_common.ko - unsupported file type
KLD linsysfs.ko: depends on linux_common - not available or version mismatch
linker_load_file: /boot/kernel/linsysfs.ko - unsupported file type
kldload: unexpected relocation type 42, symbol index 108
link_elf_obj: symbol __stack_chk_guard undefined
linker_load_file: /boot/kernel/fdescfs.ko - unsupported file type
</pre>
<p>Of course, there could be more things that are miscompiled, but only the Linuxulator is what triggered as bad on my system.</p>
<h4>C++</h4>
<p>I did not test the C++ compiler as heavily, but everything I did throw at it compiled without issue. I would be surprised if <code>icpx</code> would fail to compile anything <code>clang++</code> could compile.</p>
<h4>Conclusion</h4>
<p>The Intel oneAPI DPC++/C++ will run just fine on FreeBSD. It is certainly production-quality for userland programs. It is nearly acceptable as a kernel compiler; it might in fact already be acceptable, the problem could be in my wrapper program. It could be immediately improved by Intel actually supporting FreeBSD with the support library and native compiler binaries; this is actually quite easy, but Intel may lack the will to do so.</p>
<p>In any event, we can definitely add the Intel compiler to compilers that can output native binaries for FreeBSD, and likely all the BSDs. I think that&#39;s neat.</p>
<p><a href="#top"><img alt="Top" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAICAYAAADJEc7MAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wkWDyUKJxzXegAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAUklEQVQY02Ocd/j/fwY0kGjDwMhACPz//5/h////DPMO//8PYxODWXAZOP8Iw39k22F8uBg2G7Gx0cWYGMgEWJ2aaMPAiO5UDOcTGxjogUe2UwHwdJDZUucW5QAAAABJRU5ErkJggg=="/></a></p>
<a href="https://briancallahan.net/blog/feed.xml"><img alt="RSS" src="https://briancallahan.net/blog/media/pic_rss.gif"/></a>
	</div>
  </body>
</html>
