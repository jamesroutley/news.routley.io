<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/connet-dev/connet">Original</a>
    <h1>Show HN: connet â€“ A P2P reverse proxy with NAT traversal</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><a href="https://github.com/connet-dev/connet/releases"><img src="https://camo.githubusercontent.com/df25c17145bddf87cb00c2a9762d74830414cd76ed94c2be20a368d19a7ac568/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f636f6e6e65742d6465762f636f6e6e65742e7376673f6c6162656c3d72656c65617365" alt="GitHub release" data-canonical-src="https://img.shields.io/github/tag/connet-dev/connet.svg?label=release"/></a>
<a href="https://pkg.go.dev/github.com/connet-dev/connet" rel="nofollow"><img src="https://camo.githubusercontent.com/faf6dafdf3e1950cf45f514794a7d876272cb2e024e078031a060804dc9903b6/68747470733a2f2f706b672e676f2e6465762f62616467652f6769746875622e636f6d2f636f6e6e65742d6465762f636f6e6e65742e737667" alt="Go Reference" data-canonical-src="https://pkg.go.dev/badge/github.com/connet-dev/connet.svg"/></a>
<a href="https://goreportcard.com/report/github.com/connet-dev/connet" rel="nofollow"><img src="https://camo.githubusercontent.com/e56f5ac420daa4759007a553ba7d2fdc3edcbd5eeac393e54c23f63c357ae9cb/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f6769746875622e636f6d2f636f6e6e65742d6465762f636f6e6e6574" alt="Go Report Card" data-canonical-src="https://goreportcard.com/badge/github.com/connet-dev/connet"/></a>
<a href="https://github.com/connet-dev/connet/blob/main/LICENSE"><img src="https://camo.githubusercontent.com/3c4e4408478701f5dc2c2102ed85eaed99dbfc1278b259e31072a051d05f780d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d417061636865322e302d677265656e2e737667" alt="Apache2.0 licensed" data-canonical-src="https://img.shields.io/badge/license-Apache2.0-green.svg"/></a></p>
<p dir="auto"><code>connet</code> is a peer-to-peer reverse proxy for NAT traversal. It is inspired by ngrok, frp, rathole and others.</p>
<p dir="auto"><code>connet</code> helps expose a service running on a device to another device on the internet. Unlike the others,
the <code>connet</code> client runs on both the device that exposes the service (called <code>destination</code> in connet&#39;s terms)
and the device that wants to access the service (called <code>source</code>). This means that communication between <code>connet</code>
clients is never public and visible to the rest of the internet, and in many cases peers can communicate directly.</p>
<blockquote>
<p dir="auto"><strong>Status</strong> <code>connet</code> is currently alpha software. We expect some issues and its APIs are subject to change.</p>
</blockquote>

<ul dir="auto">
<li><strong>Peer-to-peer communication</strong> Because you run the <code>connet</code> client on both the <code>destination</code> and the <code>source</code>, the server
is only used for sharing configuration. In many cases clients can communicate directly, which enables better privacy and
performance.</li>
<li><strong>Relay support</strong> There are cases when clients are unable to find a path to communicate directly. In such cases, they
can use a relay server to maintain connectivity.</li>
<li><strong>Security</strong> Everything is private, encrypted with TLS. Public server and client certificates are exchanges between peers
and are required and verified to establish connectivity. Clients and relays need to present a mandatory token when communicating
with the control server, allowing tight control over who can use <code>connet</code>.</li>
<li><strong>Embeddable</strong> In case you want <code>connet</code> running as part of another (golang) program (as opposed to a separate executable),
<code>connet</code> has a well defined api for running both the client and the server.</li>
</ul>

<section data-identity="09128bff-a88f-466f-b8b7-1266de46e593" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div data-json="{&#34;data&#34;:&#34;flowchart LR\n    subgraph Server\n    C(Control Server)\n    R(Relay Server)\n    C -.-&amp;gt;|Relay Info| R\n    end\n    subgraph Client Source\n    S[Source] --&amp;gt;|Exchange Direct and Relay Info| C(Control Server)\n    SC(Client) -..-&amp;gt; S\n    end\n    subgraph Client Destination\n    D[Destination] --&amp;gt;|Exchange Direct and Relay Info| C(Control Server)\n    D -..-&amp;gt; DC(Server)\n    end\n    S ---|Direct Connection| D\n    S --&amp;gt;|Relay Connection| R\n    R --&amp;gt;|Relay Connection| D\n&#34;}" data-plain="flowchart LR
    subgraph Server
    C(Control Server)
    R(Relay Server)
    C -.-&gt;|Relay Info| R
    end
    subgraph Client Source
    S[Source] --&gt;|Exchange Direct and Relay Info| C(Control Server)
    SC(Client) -..-&gt; S
    end
    subgraph Client Destination
    D[Destination] --&gt;|Exchange Direct and Relay Info| C(Control Server)
    D -..-&gt; DC(Server)
    end
    S ---|Direct Connection| D
    S --&gt;|Relay Connection| R
    R --&gt;|Relay Connection| D
" dir="auto">
    <div dir="auto">
      <pre lang="mermaid" aria-label="Raw mermaid code">flowchart LR
    subgraph Server
    C(Control Server)
    R(Relay Server)
    C -.-&gt;|Relay Info| R
    end
    subgraph Client Source
    S[Source] --&gt;|Exchange Direct and Relay Info| C(Control Server)
    SC(Client) -..-&gt; S
    end
    subgraph Client Destination
    D[Destination] --&gt;|Exchange Direct and Relay Info| C(Control Server)
    D -..-&gt; DC(Server)
    end
    S ---|Direct Connection| D
    S --&gt;|Relay Connection| R
    R --&gt;|Relay Connection| D
</pre>
    </div>
  </div>
  <span role="presentation">
    <span data-view-component="true">
  <svg style="box-sizing: content-box; color: var(--color-icon-primary);" width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" data-view-component="true">
    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-opacity="0.25" stroke-width="2" vector-effect="non-scaling-stroke" fill="none"></circle>
    <path d="M15 8a7.002 7.002 0 00-7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"></path>
</svg>    <span>Loading</span>
</span>
  </span>
</section>

<p dir="auto">For all communication <code>connet</code> uses the QUIC protocol, which is build on top of UDP.</p>

<p dir="auto">Latest builds of <code>connet</code> can be acquired from our <a href="https://github.com/connet-dev/connet/releases">releases</a> page.
If you are using <a href="https://nixos.org" rel="nofollow">NixOS</a>, check also the <a href="#NixOS">NixOS</a> section.</p>
<p dir="auto">To get started with <code>connet</code>, you&#39;ll need 3 devices:</p>
<ul dir="auto">
<li>Server which your clients can communicate with. In most cases, this server will have a public IP and be directly
accessible by clients. A VPS instance at one of the many cloud providers goes a long way here.</li>
<li>Device <code>D</code> that has the <code>destination</code> service you want to connect to, running at port <code>3000</code>.</li>
<li>Device <code>S</code> (aka <code>source</code>) which you want to connect to the service, at port <code>8000</code>.</li>
</ul>

<p dir="auto">In the setup above, start <code>connet server --config server.toml</code> with the following <code>server.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[server]
tokens = [&#34;client-d-token&#34;, &#34;client-s-token&#34;]
cert-file = &#34;cert.pem&#34;
key-file = &#34;key.pem&#34;"><pre>[<span>server</span>]
<span>tokens</span> = [<span><span>&#34;</span>client-d-token<span>&#34;</span></span>, <span><span>&#34;</span>client-s-token<span>&#34;</span></span>]
<span>cert-file</span> = <span><span>&#34;</span>cert.pem<span>&#34;</span></span>
<span>key-file</span> = <span><span>&#34;</span>key.pem<span>&#34;</span></span></pre></div>

<p dir="auto">To run a <code>connet</code> server, you&#39;ll need a TLS certificate. You have a few options to create such certificate:</p>
<ul dir="auto">
<li><strong>Recommended</strong> use an <a href="https://acmeclients.com/" rel="nofollow">ACME client</a> to provision one for you. We&#39;ve had good experiences
running <a href="https://go-acme.github.io/lego/" rel="nofollow">lego</a>.</li>
<li>Buy a TLS certificate from a Certificate Authority like verisign, namecheap, etc.</li>
<li>Use a self-signed TLS certificate, an option most appropriate for testing.</li>
</ul>
<p dir="auto">To create a self-signed certificate, you can use openssl. Alternatively, you can use a tool like
<a href="https://github.com/jsha/minica">minica</a>. When using self-signed certificate, you&#39;ll need your clients (and relays)
trusting the server&#39;s certificate. Copying the certificate (or CA) public key to the clients and using <code>server-cas</code>
configuration option is the easiest way to achieve this.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Client D (aka the <code>destination</code>)</h3><a id="user-content-client-d-aka-the-destination" aria-label="Permalink: Client D (aka the destination)" href="#client-d-aka-the-destination"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Then, on device <code>D</code> run <code>connet --config client-d.toml</code> with the following <code>client-d.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[client]
token = &#34;client-d-token&#34;
server-addr = &#34;SERVER_IP:19190&#34;
server-cas = &#34;cert.pem&#34;

[client.destinations.serviceA]
addr = &#34;:3000&#34;"><pre>[<span>client</span>]
<span>token</span> = <span><span>&#34;</span>client-d-token<span>&#34;</span></span>
<span>server-addr</span> = <span><span>&#34;</span>SERVER_IP:19190<span>&#34;</span></span>
<span>server-cas</span> = <span><span>&#34;</span>cert.pem<span>&#34;</span></span>

[<span>client</span>.<span>destinations</span>.<span>serviceA</span>]
<span>addr</span> = <span><span>&#34;</span>:3000<span>&#34;</span></span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Client S (aka the <code>source</code>)</h3><a id="user-content-client-s-aka-the-source" aria-label="Permalink: Client S (aka the source)" href="#client-s-aka-the-source"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">On device <code>S</code> run <code>connet --config client-s.toml</code> with the following <code>client-s.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[client]
token = &#34;client-s-token&#34;
server-addr = &#34;SERVER_IP:19190&#34;
server-cas = &#34;cert.pem&#34;

[client.sources.serviceA]
addr = &#34;:8000&#34;"><pre>[<span>client</span>]
<span>token</span> = <span><span>&#34;</span>client-s-token<span>&#34;</span></span>
<span>server-addr</span> = <span><span>&#34;</span>SERVER_IP:19190<span>&#34;</span></span>
<span>server-cas</span> = <span><span>&#34;</span>cert.pem<span>&#34;</span></span>

[<span>client</span>.<span>sources</span>.<span>serviceA</span>]
<span>addr</span> = <span><span>&#34;</span>:8000<span>&#34;</span></span></pre></div>

<p dir="auto">You can use both a toml config file as well as command line when running <code>connet</code>. If you use both a config file and
command line options, the latter takes precence, overriding any config file options. For simplicity, command line options
only support a single <code>destination</code> or <code>source</code> configuration.</p>

<p dir="auto">To run in client mode, use <code>connet --config client-config.toml</code> command. Here is the full client <code>client-config.toml</code>
configuration spec:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[client]
token = &#34;client-token-1&#34; # the token which the client uses to authenticate against the control server
token-file = &#34;path/to/relay/token&#34; # a file that contains the token, one of token or token-file is required

server-addr = &#34;localhost:19190&#34; # the control server address to connect to
server-cas = &#34;path/to/cert.pem&#34; # the control server certificate
direct-addr = &#34;:19192&#34; # at what address this client listens for direct connections

[client.destinations.serviceX]
addr = &#34;localhost:3000&#34; # where this destination connects to, required
route = &#34;any&#34; # what kind of routes to use, `any` will use both `direct` and `relay`

[client.destinations.serviceY]
addr = &#34;192.168.1.100:8000&#34; # multiple destinations can be defined, they are matched by name at the server
route = &#34;direct&#34; # force only direct communication between clients

[client.sources.serviceX] # matches destinations.serviceX
addr = &#34;:8000&#34; # the address at which to listen for incoming connections to be forwarded
route = &#34;relay&#34; # the kind of route to use

[client.sources.serviceY] # both sources and destinations can be defined in a single file
addr = &#34;:8001&#34; # again, mulitple sources can be defined
route = &#34;direct&#34; # force only direct communication between clients, even if other end allows any"><pre>[<span>client</span>]
<span>token</span> = <span><span>&#34;</span>client-token-1<span>&#34;</span></span> <span><span>#</span> the token which the client uses to authenticate against the control server</span>
<span>token-file</span> = <span><span>&#34;</span>path/to/relay/token<span>&#34;</span></span> <span><span>#</span> a file that contains the token, one of token or token-file is required</span>

<span>server-addr</span> = <span><span>&#34;</span>localhost:19190<span>&#34;</span></span> <span><span>#</span> the control server address to connect to</span>
<span>server-cas</span> = <span><span>&#34;</span>path/to/cert.pem<span>&#34;</span></span> <span><span>#</span> the control server certificate</span>
<span>direct-addr</span> = <span><span>&#34;</span>:19192<span>&#34;</span></span> <span><span>#</span> at what address this client listens for direct connections</span>

[<span>client</span>.<span>destinations</span>.<span>serviceX</span>]
<span>addr</span> = <span><span>&#34;</span>localhost:3000<span>&#34;</span></span> <span><span>#</span> where this destination connects to, required</span>
<span>route</span> = <span><span>&#34;</span>any<span>&#34;</span></span> <span><span>#</span> what kind of routes to use, `any` will use both `direct` and `relay`</span>

[<span>client</span>.<span>destinations</span>.<span>serviceY</span>]
<span>addr</span> = <span><span>&#34;</span>192.168.1.100:8000<span>&#34;</span></span> <span><span>#</span> multiple destinations can be defined, they are matched by name at the server</span>
<span>route</span> = <span><span>&#34;</span>direct<span>&#34;</span></span> <span><span>#</span> force only direct communication between clients</span>

[<span>client</span>.<span>sources</span>.<span>serviceX</span>] <span><span>#</span> matches destinations.serviceX</span>
<span>addr</span> = <span><span>&#34;</span>:8000<span>&#34;</span></span> <span><span>#</span> the address at which to listen for incoming connections to be forwarded</span>
<span>route</span> = <span><span>&#34;</span>relay<span>&#34;</span></span> <span><span>#</span> the kind of route to use</span>

[<span>client</span>.<span>sources</span>.<span>serviceY</span>] <span><span>#</span> both sources and destinations can be defined in a single file</span>
<span>addr</span> = <span><span>&#34;</span>:8001<span>&#34;</span></span> <span><span>#</span> again, mulitple sources can be defined</span>
<span>route</span> = <span><span>&#34;</span>direct<span>&#34;</span></span> <span><span>#</span> force only direct communication between clients, even if other end allows any</span></pre></div>

<p dir="auto">To run in server mode (e.g. running both control and a relay server), use <code>connet server --config server-config.toml</code> command.
Here is the full server <code>server-config.toml</code> configuration specification:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[server]
tokens = [&#34;client-token-1&#34;, &#34;client-token-n&#34;] # set of recognized client tokens
tokens-file = &#34;path/to/client/tokens&#34; # a file that contains a list of client tokens
# one of tokens or tokens-file is required

addr = &#34;:19190&#34; # the address at which the control server will listen for connections, default to :19190
cert-file = &#34;path/to/cert.pem&#34; # the server certificate file, in pem format
key-file = &#34;path/to/key.pem&#34; # the server certificate private key file

relay-addr = &#34;:19191&#34; # the address at which the relay will listen for connectsion, defaults to :19191
relay-hostname = &#34;localhost&#34; # the public hostname (e.g. domain, ip address) which will be advertised to clients, defaults to localhost

store-dir = &#34;path/to/server-store&#34; # where does this server persist runtime information, defaults to a /tmp subdirectory"><pre>[<span>server</span>]
<span>tokens</span> = [<span><span>&#34;</span>client-token-1<span>&#34;</span></span>, <span><span>&#34;</span>client-token-n<span>&#34;</span></span>] <span><span>#</span> set of recognized client tokens</span>
<span>tokens-file</span> = <span><span>&#34;</span>path/to/client/tokens<span>&#34;</span></span> <span><span>#</span> a file that contains a list of client tokens</span>
<span><span>#</span> one of tokens or tokens-file is required</span>

<span>addr</span> = <span><span>&#34;</span>:19190<span>&#34;</span></span> <span><span>#</span> the address at which the control server will listen for connections, default to :19190</span>
<span>cert-file</span> = <span><span>&#34;</span>path/to/cert.pem<span>&#34;</span></span> <span><span>#</span> the server certificate file, in pem format</span>
<span>key-file</span> = <span><span>&#34;</span>path/to/key.pem<span>&#34;</span></span> <span><span>#</span> the server certificate private key file</span>

<span>relay-addr</span> = <span><span>&#34;</span>:19191<span>&#34;</span></span> <span><span>#</span> the address at which the relay will listen for connectsion, defaults to :19191</span>
<span>relay-hostname</span> = <span><span>&#34;</span>localhost<span>&#34;</span></span> <span><span>#</span> the public hostname (e.g. domain, ip address) which will be advertised to clients, defaults to localhost</span>

<span>store-dir</span> = <span><span>&#34;</span>path/to/server-store<span>&#34;</span></span> <span><span>#</span> where does this server persist runtime information, defaults to a /tmp subdirectory</span></pre></div>

<p dir="auto">To run in control server mode, use <code>connet control --config control-config.toml</code> command. Here is the full control server
<code>control-config.toml</code> configuration specification:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[control]
client-tokens = [&#34;client-token-1&#34;, &#34;client-token-n&#34;] # set of recognized client tokens
client-tokens-file = &#34;path/to/client/tokens&#34; # a file that contains a list of client tokens
# one of client-tokens or client-tokens-file is required

relay-tokens = [&#34;relay-token-1&#34;, &#34;relay-token-n&#34;] # set of recognized relay tokens
relay-tokens-file = &#34;path/to/relay/token&#34; # a file that contains a list of relay tokens
# one of relay-tokens or relay-tokens-file is necessary when connecting relays

addr = &#34;:19190&#34; # the address at which the control server will listen for connections, default to :19190
cert-file = &#34;path/to/cert.pem&#34; # the server certificate file, in pem format
key-file = &#34;path/to/key.pem&#34; # the server certificate private key file

store-dir = &#34;path/to/control-store&#34; # where does this control server persist runtime information, defaults to a /tmp subdirectory"><pre>[<span>control</span>]
<span>client-tokens</span> = [<span><span>&#34;</span>client-token-1<span>&#34;</span></span>, <span><span>&#34;</span>client-token-n<span>&#34;</span></span>] <span><span>#</span> set of recognized client tokens</span>
<span>client-tokens-file</span> = <span><span>&#34;</span>path/to/client/tokens<span>&#34;</span></span> <span><span>#</span> a file that contains a list of client tokens</span>
<span><span>#</span> one of client-tokens or client-tokens-file is required</span>

<span>relay-tokens</span> = [<span><span>&#34;</span>relay-token-1<span>&#34;</span></span>, <span><span>&#34;</span>relay-token-n<span>&#34;</span></span>] <span><span>#</span> set of recognized relay tokens</span>
<span>relay-tokens-file</span> = <span><span>&#34;</span>path/to/relay/token<span>&#34;</span></span> <span><span>#</span> a file that contains a list of relay tokens</span>
<span><span>#</span> one of relay-tokens or relay-tokens-file is necessary when connecting relays</span>

<span>addr</span> = <span><span>&#34;</span>:19190<span>&#34;</span></span> <span><span>#</span> the address at which the control server will listen for connections, default to :19190</span>
<span>cert-file</span> = <span><span>&#34;</span>path/to/cert.pem<span>&#34;</span></span> <span><span>#</span> the server certificate file, in pem format</span>
<span>key-file</span> = <span><span>&#34;</span>path/to/key.pem<span>&#34;</span></span> <span><span>#</span> the server certificate private key file</span>

<span>store-dir</span> = <span><span>&#34;</span>path/to/control-store<span>&#34;</span></span> <span><span>#</span> where does this control server persist runtime information, defaults to a /tmp subdirectory</span></pre></div>

<p dir="auto">To run in relay server mode, use <code>connet relay --config relay-config.toml</code> command. Here is the full relay server
<code>relay-config.toml</code> configuration specification:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[relay]
token = &#34;relay-token-1&#34; # the token which the relay server uses to authenticate against the control server
token-file = &#34;path/to/relay/token&#34; # a file that contains the token, one of token or token-file is required

addr = &#34;:19191&#34; # the address at which the relay will listen for connectsion, defaults to :19191
hostname = &#34;localhost&#34; # the public hostname (e.g. domain, ip address) which will be advertised to clients, defaults to localhost

control-addr = &#34;localhost:19190&#34; # the control server address to connect to, defaults to localhost:19191
control-cas = &#34;path/to/ca/file.pem&#34; # the public certificate root of the control server, no default, required when using self-signed certs

store-dir = &#34;path/to/relay-store&#34; # where does this relay persist runtime information, defaults to a /tmp subdirectory"><pre>[<span>relay</span>]
<span>token</span> = <span><span>&#34;</span>relay-token-1<span>&#34;</span></span> <span><span>#</span> the token which the relay server uses to authenticate against the control server</span>
<span>token-file</span> = <span><span>&#34;</span>path/to/relay/token<span>&#34;</span></span> <span><span>#</span> a file that contains the token, one of token or token-file is required</span>

<span>addr</span> = <span><span>&#34;</span>:19191<span>&#34;</span></span> <span><span>#</span> the address at which the relay will listen for connectsion, defaults to :19191</span>
<span>hostname</span> = <span><span>&#34;</span>localhost<span>&#34;</span></span> <span><span>#</span> the public hostname (e.g. domain, ip address) which will be advertised to clients, defaults to localhost</span>

<span>control-addr</span> = <span><span>&#34;</span>localhost:19190<span>&#34;</span></span> <span><span>#</span> the control server address to connect to, defaults to localhost:19191</span>
<span>control-cas</span> = <span><span>&#34;</span>path/to/ca/file.pem<span>&#34;</span></span> <span><span>#</span> the public certificate root of the control server, no default, required when using self-signed certs</span>

<span>store-dir</span> = <span><span>&#34;</span>path/to/relay-store<span>&#34;</span></span> <span><span>#</span> where does this relay persist runtime information, defaults to a /tmp subdirectory</span></pre></div>

<p dir="auto"><code>connet</code> servers (both control and relay servers) store runtime state on the file system. If you don&#39;t explicitly specify
<code>store-dir</code>, they will use a new subdirectory in <code>/tmp</code> by default, which means that every time they restart they&#39;ll loose
any state and identity. To prevent this, you can specify an explicit <code>store-dir</code> location, which can be reused between runs.</p>

<p dir="auto">At the root of the config file, you can configure logging (<code>connet</code> uses slog internally):</p>
<div dir="auto" data-snippet-clipboard-copy-content="log-level = &#34;info&#34; # supports debug, info, warn, error, defaults to info
log-format = &#34;text&#34; # supports text and json, defaults to text"><pre><span>log-level</span> = <span><span>&#34;</span>info<span>&#34;</span></span> <span><span>#</span> supports debug, info, warn, error, defaults to info</span>
<span>log-format</span> = <span><span>&#34;</span>text<span>&#34;</span></span> <span><span>#</span> supports text and json, defaults to text</span></pre></div>

<p dir="auto">On some systems, if you might see the following line in the logs:</p>
<div data-snippet-clipboard-copy-content="failed to sufficiently increase receive buffer size (was: 208 kiB, wanted: 7168 kiB, got: 416 kiB). See https://github.com/quic-go/quic-go/wiki/UDP-Buffer-Sizes for details."><pre><code>failed to sufficiently increase receive buffer size (was: 208 kiB, wanted: 7168 kiB, got: 416 kiB). See https://github.com/quic-go/quic-go/wiki/UDP-Buffer-Sizes for details.
</code></pre></div>
<p dir="auto">In which case, we recommend visiting the <a href="https://github.com/quic-go/quic-go/wiki/UDP-Buffer-Sizes">wiki page</a> and applying the recommended changes.</p>

<p dir="auto">TBD</p>

<p dir="auto">To configure the client as a service:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# flake.nix
{
  inputs = {
    # ...
    connet.url = &#34;github.com/connet-dev/connet&#34;;
  };
  outputs = { connet, ... }: {
    nixosConfigurations.example = nixpkgs.lib.nixosSystem {
      system = &#34;x86_64-linux&#34;;
      modules = [
        # ...
        connet.nixosModules.default
        {
          services.connet = {
            enable = true;
            package = connet.packages.&#34;x86_64-linux&#34;.default;
            tokenFile = &#34;/run/keys/connet.token&#34;;
            serverAddr = &#34;localhost:19190&#34;;
            sources.example.addr = &#34;:9998&#34;;
          };
        }
      ];
    };
  };
}"><pre><span># flake.nix</span>
<span>{</span>
  <span><span>inputs</span></span> <span>=</span> <span>{</span>
    <span># ...</span>
    <span><span>connet</span><span>.</span><span>url</span></span> <span>=</span> <span>&#34;github.com/connet-dev/connet&#34;</span><span>;</span>
  <span>}</span><span>;</span>
  <span><span>outputs</span></span> <span>=</span> <span>{</span> <span>connet</span><span>,</span> ... <span>}</span>: <span>{</span>
    <span><span>nixosConfigurations</span><span>.</span><span>example</span></span> <span>=</span> <span>nixpkgs</span><span>.</span><span><span>lib</span><span>.</span><span>nixosSystem</span></span> <span>{</span>
      <span><span>system</span></span> <span>=</span> <span>&#34;x86_64-linux&#34;</span><span>;</span>
      <span><span>modules</span></span> <span>=</span> <span>[</span>
        <span># ...</span>
        <span>connet</span><span>.</span><span><span>nixosModules</span><span>.</span><span>default</span></span>
        <span>{</span>
          <span><span>services</span><span>.</span><span>connet</span></span> <span>=</span> <span>{</span>
            <span><span>enable</span></span> <span>=</span> <span>true</span><span>;</span>
            <span><span>package</span></span> <span>=</span> <span>connet</span><span>.</span><span><span>packages</span><span>.</span><span>&#34;x86_64-linux&#34;</span><span>.</span><span>default</span></span><span>;</span>
            <span><span>tokenFile</span></span> <span>=</span> <span>&#34;/run/keys/connet.token&#34;</span><span>;</span>
            <span><span>serverAddr</span></span> <span>=</span> <span>&#34;localhost:19190&#34;</span><span>;</span>
            <span><span>sources</span><span>.</span><span>example</span><span>.</span><span>addr</span></span> <span>=</span> <span>&#34;:9998&#34;</span><span>;</span>
          <span>}</span><span>;</span>
        <span>}</span>
      <span>]</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span></pre></div>

<p dir="auto">TBD</p>

<p dir="auto">If you want to use <code>connet</code>, but you don&#39;t want to run the server yourself, we have also built a hosted service
at <a href="https://connet.dev" rel="nofollow">connet.dev</a>. It is free when clients connect directly, builds upon the open source components
by adding account management and it is one of the easiest way to start.</p>

<ul>
<li> UDP support</li>
</ul>
</article></div></div>
  </body>
</html>
