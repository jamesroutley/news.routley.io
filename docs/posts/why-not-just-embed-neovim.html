<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/zed-decoded-vim">Original</a>
    <h1>Why not just embed Neovim?</h1>
    
    <div id="readability-page-1" class="page"><div><article><header></header><p>Usually when I tell people that I&#39;ve switched to Zed as my main editor, after something like 15 years of using Vim, the first question they ask is: don&#39;t you miss Vim? Then I tell them: Zed has a Vim mode. I don&#39;t think I would&#39;ve or could&#39;ve switched if it didn&#39;t.</p>
<p>Then, surprisingly often, there are follow-up question that sound something like this: a Vim mode? Did you know that Neovim is embeddable? Why doesn&#39;t Zed just embed Neovim?</p>
<p>So in this Zed Decoded episode, let&#39;s dig into Zed&#39;s Vim mode and find some answers to these questions.</p>
<!-- -->
<div><div><div><p><b>Companion Video</b>: <!-- -->Why not just embed Neovim?</p><p>This post comes with a 1hr companion video, in which Thorsten talks to Conrad, who worked a lot on Zed&#39;s Vim mode in the last few months and improved it tremendously. Together Thorsten and Conrad explore Zed&#39;s Vim mode, what&#39;s tricky about implementing it, why we don&#39;t embed Neovim and how we do use Neovim.</p><p>Watch the video here:<!-- --> <a href="https://youtu.be/Ys8-KkzH5Rc">https://youtu.be/Ys8-KkzH5Rc</a></p></div><p><img src="https://zed.dev/img/post/zed-decoded-vim/thumbnail.jpg" width="230" height="150"/></p></div></div>
<h2 id="zeds-vim-mode"><span data-br=":R57brrrqbf9la:" data-brr="1">Zed&#39;s Vim mode</span></h2>
<p>First things first: Zed has Vim mode. You can enable it by adding the following to your Zed settings:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="json" data-theme="light-plus"><code data-language="json" data-theme="light-plus"><span data-line=""><span>{</span></span>
<span data-line=""><span>  &#34;vim_mode&#34;</span><span>: </span><span>true</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>Once you add that and save your settings, you&#39;ll see your cursor change into a block, which means you&#39;re ready to explore Zed&#39;s Vim mode:</p>
<ul>
<li><code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> are ready to go.</li>
<li>You can use motions like <code>w</code>, <code>W</code>, <code>e</code>, <code>E</code>, <code>b</code>, <code>B</code>, <code>{</code>, <code>}</code>.</li>
<li>There&#39;s also <code>f</code> and <code>t</code> and <code>;</code> and <code>,</code>.</li>
<li>Use <code>v</code>, <code>V</code>, and <code>ctrl-v</code> to enter different visual modes.</li>
<li>There are a lot of <code>g</code> commands, such as <code>gg</code>, <code>gn</code>, <code>gx</code>, <code>gt</code>.</li>
</ul>
<p>But Zed&#39;s Vim mode doesn&#39;t just support the standard motions and operators:</p>
<ul>
<li>Basic parts of <a href="https://github.com/tpope/vim-surround">vim-surround</a> already work: you can use <code>cs&#34;&#39;</code> to change surrounding <code>&#34;</code> into <code>&#39;</code>, or <code>ds[</code> to delete surrounding <code>[</code>. Even the vim-surround kung-fu monster combo of <code>ysiw&#34;</code> works.</li>
<li>Code comments can be toggled with <code>gcc</code> in normal mode and <code>gc</code> in visual mode.</li>
<li>Many of Vim&#39;s &#34;window management&#34; keybindings starting with <code>ctrl-w</code> have <a href="https://github.com/zed-industries/zed/blob/ec95a33d8cfc2ccbf59764d8cd00a779bdb63928/assets/keymaps/vim.json#L287-L337">equivalents in Zed&#39;s Vim mode</a>.</li>
<li>Some more advanced Vim features also work. Try searching for the word under the cursor with <code>*</code>, change the next occurrence with <code>cgn</code>, and then repeat with <code>.</code>.</li>
<li>Buffer-local marks (<code>&#39;a</code> to <code>&#39;z</code>) and some builtin marks (<code>&#39;&lt;</code>,<code>&#39;&gt;</code>,<code>&#39;[</code>,<code>&#39;]</code>, <code>&#39;{</code>, <code>&#39;}</code> and <code>^</code>) work.</li>
<li>Basic support for named registers has <a href="https://github.com/zed-industries/zed/pull/12895">just landed on our <code>main</code> branch</a> and will be in the next <a href="https://zed.dev/releases/preview">Preview release of Zed</a>.</li>
</ul>
<p>There is <em>a lot</em> in Zed&#39;s Vim mode. The <a href="https://zed.dev/docs/vim">official docs page on the Vim mode</a> give you a good overview of what&#39;s possible and what can be configured. You can also read through the <a href="https://github.com/zed-industries/zed/blob/ec95a33d8cfc2ccbf59764d8cd00a779bdb63928/assets/keymaps/vim.json">default Vim keybindings</a> to see which motions and operators are supported.</p>
<p>But it&#39;s not complete yet. Not yet, anyway. Some big things are missing, such as registers and macros, and there&#39;s a long tail of operators and motions that still need to be added. Our versions of the jumplist and changelist also need some tweaking to make them more Vim-like and consistent.</p>
<p>The good news is that it is and has been steadily improving. <a href="https://github.com/zed-industries/zed/pull/11507">Basic support for marks has been added last month</a>, <a href="https://github.com/zed-industries/zed/pull/9400">surrounds landed in the month before that</a>, <a href="https://github.com/zed-industries/zed/pull/9982"><code>gn</code> and <code>cgn</code> were also merged two months ago</a>. Conrad alone merged <a href="https://github.com/zed-industries/zed/commits/main/crates/vim">more than 20 PRs into Zed&#39;s <code>vim</code> crate</a> in the last two months.</p>
<p>And, wow, witnessing the improvements and participating in some of them was eye-opening.</p>
<h2 id="operator-by-operator-count-by-count"><span data-br=":Rg7brrrqbf9la:" data-brr="1">Operator by operator, count by count</span></h2>
<p>As a long-time Vim user I already knew quite a bit about Vim and as a new Zed developer working on its Vim mode, I half-expected there to be arcane Vim operators and motions that need to be implemented. I knew that there&#39;s <em>a lot of stuff in Vim</em>, but was still surprised by <em>oh wow, there is a lot of stuff in Vim</em> — operators, and motions, and modifiers, and combinations of all of them — and how many things that I would&#39;ve considered to be rarely used features are widely used.</p>
<p>Did you know, for example, that <code>gs</code> in Vim stands for &#34;goto sleep&#34; and makes Vim, well, go to sleep for N seconds? Yes, that came up in our issue tracker, when we naively thought that <code>gs</code> wasn&#39;t taken yet as a keybinding.</p>
<p>Or, maybe you already knew <code>z.</code>, which is similar to <code>zz</code>, and centers the current line. But did you know that it takes a count? Yup: you can do <code>5z.</code>, which centers line 5. I didn&#39;t know that.</p>
<p>You surely know <code>i</code>, though, the command that takes Vim into insert-mode and probably the second thing a new Vim user learns after <code>:q</code>. But did you know that <a href="https://github.com/zed-industries/zed/issues/9383"><code>i</code> <em>takes a count too</em>?</a> You can use <code>5ifoobar&lt;esc&gt;</code> to insert <code>foobar</code> 5 times. And, yes, <code>a</code> takes a count too.</p>
<p>Talking about counts: have you ever sat down and pondered the difference between <code>5dj</code> and <code>d5j</code>? We did, <a href="https://youtu.be/Ys8-KkzH5Rc">in the companion video</a>, and Conrad did more than ponder when implementing counts for more operators.</p>
<p>Or, let me ask you this: would you suspect that there are people using <code>r</code> and <code>R</code> — both trigger replace mode — in their daily Vim workflow? Let alone that these Vim users would <a href="https://github.com/zed-industries/zed/issues/4440#issuecomment-2006962062">put money where their issue-opening mouth is and pay $500 to whoever implements <code>r</code> and <code>R</code>?</a>. I certainly didn&#39;t. I mean, I knew about <code>R</code> but I thought that, surely, no one <em>really</em> ever uses it.</p>
<p>Or the <code>.</code> command, everybody&#39;s Vim darling. A simple command, a single <code>.</code>, that does a simple thing, right? It just repeats what you did last. Except that doesn&#39;t quite capture it: it only repeats the last <em>change to a buffer</em>, not navigation. But it also doesn&#39;t repeat a completion action, for example, that did change the buffer. When put like that, it sounds obvious — &#34;yes, uh-huh, that&#39;s what <code>.</code> does, I knew that&#34; — but it&#39;s really easy to hit your toes on these subtle details when you&#39;re trying to build a generic <code>.</code> command.</p>
<h2 id="different-foundations"><span data-br=":Ro7brrrqbf9la:" data-brr="1">Different foundations</span></h2>
<p>Why am I telling you about these surprising operators and combinations? To share a realization: when you&#39;re trying to build a Vim mode that&#39;s as complete as possible and you keep bumping into these subtleties, you realize that Vim and Zed sit on different foundations.</p>
<p>Vim, for example, addresses characters in the buffer. Zed, on the other hand, addresses the slots <em>between characters</em>.</p>
<p>That&#39;s the difference between the cursor in <code>abc</code> sitting on the <code>b</code> (Vim) or sitting between <code>a</code> and <code>b</code> (Zed). As you can imagine, the ripple effects of an invariant like that turn into waves five abstraction layers up.</p>
<p>Consider how both editors handle newlines: Vim distinguishes between the end of the line and the last character in the line. In practice that means you can, for example, create a visual selection until the end of the line with <code>v$</code> and then additionally select the newline character by hitting <code>l</code>, so that a deletion with <code>d</code> would then delete the complete line, but it looked like you only ever had the first line selected.</p>
<p>In non-Vim-mode Zed you can do a similar thing and select until the end of the line. That selection, though, doesn&#39;t include the newline as long as your cursor stays on that line. As soon as you select the newline character, your cursor pops down to the next line.</p>
<p>In Zed&#39;s Vim mode we try to address (or: work around) these differences as much as possible to make the Vim mode as Vim-like as possible. To quote <a href="https://zed.dev/docs/vim">our documentation on the Vim mode</a>:</p>
<blockquote>
<p>Vim mode in Zed is supposed to primarily &#34;do what you expect&#34;: it mostly tries to copy Vim exactly</p>
</blockquote>
<p>That&#39;s not only hard and tricky work (see <a href="https://github.com/zed-industries/zed/issues/6900">this issue</a> to get an impression of which edge cases are involved), but there is also a limitation, a ceiling to this effort: we don&#39;t want to throw away Zed&#39;s foundations. There&#39;s a lot attached to them.</p>
<h2 id="thats-why-its-not-embedded"><span data-br=":R117brrrqbf9la:" data-brr="1">That&#39;s why it&#39;s not embedded</span></h2>
<p>See, if you were to embed Neovim into Zed, you&#39;d end up doing exactly that: you would throw away Zed&#39;s foundations and replace them with Neovim.</p>
<p>But these foundations — <a href="https://zed.dev/blog/zed-decoded-rope-sumtree">the data structures to represent text</a>, the <a href="https://zed.dev/blog/crdts">CRDTs</a>, the <a href="https://zed.dev/blog/120fps">render pipeline</a>, the <a href="https://zed.dev/blog/zed-decoded-async-rust">custom Async Rust runtime</a> — are what make Zed <em>Zed</em>: a high-performance, collaborative text editor. Or, to use the phrase from the CRDT blog post: the CRDTs, the Rope, the SumTree, the text models — that&#39;s Zed&#39;s DNA. Zed was <a href="https://zed.dev/blog/we-have-to-start-over">built on the realization that you can&#39;t just add collaboration on top</a>, it needs to be built-in, from the ground up.</p>
<p>If we were to put Neovim into Zed, we&#39;d have to throw this DNA away when Vim mode is enabled — which we don&#39;t want — or port the DNA over to Neovim. (Cue the animation of someone doing gene splicing, with lots of sweat on their forehead.) That means, we&#39;d have to do a lot of things twice: once in Zed and once in the embedded Neovim. Build CRDTs twice, build multi-buffers that multiple people can edit at the same time twice, and so on.</p>
<p>Building these things once is already hard. It&#39;s a lot of work that&#39;s hard to get right. Building it twice in two different codebases is... well, at least twice as hard.</p>
<p>So, there you have it. That&#39;s why we don&#39;t just embed Neovim into Zed. Instead, we built a Vim mode inside Zed. And that, I personally think, is more interesting than just embedding Vim.</p>
<h2 id="vim-and-zed-melded"><span data-br=":R177brrrqbf9la:" data-brr="1">Vim and Zed, melded</span></h2>
<p>Since Zed&#39;s Vim mode sits on top of Zed&#39;s foundation, what you get is a combination of both. When Vim mode is enabled, you can still use almost everything that&#39;s available in non-Vim-mode Zed.</p>
<p>For example: you can use <code>gl</code> to create an additional cursor that sits on top of the next occurrence of the current word. Or use <code>gL</code> to do the same but backwards. Use either one, then hit <code>&lt;esc&gt;</code>, and you&#39;re left with multiple cursors, but <em>in Vim normal mode</em>, with every motion and operator we have available.</p>
<p>Or, try this: use <code>]x</code> and <code>[x</code> to select a Treesitter syntax node. These selections you can also combine with multi-cursors. So if you have a Treesitter node selected, hit <code>gl</code> and it will create another cursor on a node that looks the same.</p>
<p><figure><video loop="" muted="" controls="" playsinline=""><source src="/img/post/zed-decoded-vim/vim_zed_combined.mp4" type="video/webm; codecs=&#34;vp8.0, vorbis&#34;"/><source src="/img/post/zed-decoded-vim/vim_zed_combined.mp4" type="video/mp4; codecs=&#34;avc1.4D401E, mp4a.40.2&#34;"/></video><figcaption>Recording of me doing exactly that</figcaption></figure></p>
<p>Or hit <code>:</code>. That not only opens the Zed command palette, there&#39;s also bindings and shortcuts for common commands such as <code>:w</code>. <code>:E[xplore]</code> opens the project panel, <code>:te[rm]</code> the terminal, and so on.</p>
<p><code>g]</code> and <code>g[</code> navigate between diagnostic errors, <code>]c</code> and <code>[c</code> between git changes. <code>gs</code> opens the symbol outline in the current file, <code>gS</code> does the same, but globally for the project. <code>g.</code> opens code actions. Take a look at the <a href="https://zed.dev/docs/vim#zed-specific-features">Zed-specific features</a> of the Vim mode to find out what else you can do in Zed&#39;s Vim mode. If something&#39;s missing you can always fallback to <code>cmd-</code> shortcuts or open the command palette, find a command, and create a custom binding.</p>
<p>Here, for example, are some bindings that I have in my Zed <code>keymaps.json</code> and that I use in the Vim mode:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="json" data-theme="light-plus"><code data-language="json" data-theme="light-plus"><span data-line=""><span>[</span></span>
<span data-line=""><span>  {</span></span>
<span data-line=""><span>    &#34;context&#34;</span><span>: </span><span>&#34;EmptyPane || SharedScreen || vim_operator == none &amp;&amp; !VimWaiting &amp;&amp; vim_mode != insert&#34;</span><span>,</span></span>
<span data-line=""><span>    &#34;bindings&#34;</span><span>: {</span></span>
<span data-line=""><span>      &#34;, f b&#34;</span><span>: </span><span>&#34;tab_switcher::Toggle&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;, f i&#34;</span><span>: </span><span>&#34;file_finder::Toggle&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;, f o&#34;</span><span>: </span><span>&#34;projects::OpenRecent&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;, r l&#34;</span><span>: </span><span>&#34;task::Rerun&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;, r e&#34;</span><span>: [</span><span>&#34;task::Rerun&#34;</span><span>, { </span><span>&#34;reevaluate_context&#34;</span><span>: </span><span>true</span><span> }],</span></span>
<span data-line=""><span>      &#34;ctrl-s&#34;</span><span>: </span><span>&#34;projects::OpenRecent&#34;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  },</span></span>
<span data-line=""><span>  {</span></span>
<span data-line=""><span>    &#34;context&#34;</span><span>: </span><span>&#34;Editor &amp;&amp; VimControl &amp;&amp; !VimWaiting &amp;&amp; !menu&#34;</span><span>,</span></span>
<span data-line=""><span>    &#34;bindings&#34;</span><span>: {</span></span>
<span data-line=""><span>      &#34;g shift-r&#34;</span><span>: </span><span>&#34;editor::FindAllReferences&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;g a&#34;</span><span>: </span><span>&#34;editor::ToggleCodeActions&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;g r&#34;</span><span>: </span><span>&#34;editor::Rename&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;space w&#34;</span><span>: </span><span>&#34;workspace::Save&#34;</span><span>,</span></span>
<span data-line=""><span>      &#34;, g b&#34;</span><span>: </span><span>&#34;editor::ToggleGitBlame&#34;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>]</span></span></code></pre></div></figure>
<h2 id="neovim-at-last"><span data-br=":R1g7brrrqbf9la:" data-brr="1">Neovim... at last</span></h2>
<p>Now that you know why we won&#39;t embed Neovim and what advantages that might have, let me send you home with something really neat that you can share with other programmer friends over drinks: we <em>do</em> use Neovim in Zed, but we use it <em>in our tests</em>.</p>
<p>In the <a href="https://youtu.be/Ys8-KkzH5Rc">companion video</a>, Conrad explains how it works in detail, so here&#39;s the short version.</p>
<p>All of Zed&#39;s Vim mode is contained within a single crate, <code>vim</code>, and in that one, <a href="https://github.com/zed-industries/zed/blob/a965dd62ead42a1624b229c262bef4c1fb4a3ec8/crates/vim/src/normal/search.rs#L653-L661">some tests</a> look like this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>#[gpui::test]</span></span>
<span data-line=""><span>async</span><span> fn</span><span> test_visual_star_hash</span><span>(</span><span>cx</span><span>: &amp;</span><span>mut</span><span> gpui</span><span>::</span><span>TestAppContext</span><span>) {</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> cx</span><span> = </span><span>NeovimBackedTestContext</span><span>::</span><span>new</span><span>(</span><span>cx</span><span>).</span><span>await</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    cx</span><span>.</span><span>set_shared_state</span><span>(</span><span>&#34;ˇa.c. abcd a.c. abcd&#34;</span><span>).</span><span>await</span><span>;</span></span>
<span data-line=""><span>    cx</span><span>.</span><span>simulate_shared_keystrokes</span><span>(</span><span>&#34;v 3 l *&#34;</span><span>).</span><span>await</span><span>;</span></span>
<span data-line=""><span>    cx</span><span>.</span><span>shared_state</span><span>().</span><span>await</span><span>.</span><span>assert_eq</span><span>(</span><span>&#34;a.c. abcd ˇa.c. abcd&#34;</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>The interesting bit here is <code>NeovimBackedTestContext::new()</code>: that causes the test to run a headless Neovim instance, send the initial state to it, and then simulate the keystrokes. The final state produced is then saved to a JSON file and against <em>that</em> state we test Zed&#39;s Vim implementation.</p>
<p>In other words: we use a headless Neovim in tests to produce <a href="https://softwareengineering.stackexchange.com/questions/358786/what-are-golden-files">&#34;golden files&#34;</a> against which we check what Zed&#39;s Vim mode produced with the same keystrokes.</p>
<p>Pretty neat, right?</p><hr/></article></div></div>
  </body>
</html>
