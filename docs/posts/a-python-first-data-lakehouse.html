<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bauplanlabs.com/blog/everything-as-python">Original</a>
    <h1>A Python-first data lakehouse</h1>
    
    <div id="readability-page-1" class="page"><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><blockquote><p><em>“Good design is actually a lot harder to notice than poor design, in part because good designs fit our needs so well that the design is invisible”.</em> Donald A. Norman, The Design of Everyday Things.</p></blockquote><p>Despite AI eating the world and data becoming one of the most important things for every company on the planet, but getting models from prototype to production is still pretty problematic. According to <!--$--><a href="https://hbr.org/2022/10/why-your-company-needs-data-product-managers" rel="noopener">HBR</a><!--/$-->, fewer than 1 in 5 models ever make it into production. And when they do, it often takes weeks or months.</p><p>Good data scientists have a special skill set in data manipulation, math, statistics and machine learning. Great data scientists are also very aware of the business problem and the business need. In my experience, the closer data scientists are to the problem, the more impact they create.</p><p>Now, in many cases, that closeness has to extend all the way into production which means that data scientists must be involved with software development. Most real-world ML projects today, like recommendation engines or RAG systems, require a working understanding of software engineering and its best practices (incidentally, these use cases are often the most valuable because they impact final users directly).</p><p>Now, what is the problem with that? Well, these kinds of applications require real software and infrastructure expertise, and while most data scientists know enough Python to explore data and build models, they’re usually less comfortable with the rest: distributed systems, cloud environments, CI/CD, testing frameworks, data lakes, and the messy reality of production-grade software.</p><p>When asked, countless companies end up telling us the same story: data scientists produced a working prototype on a Jupyter notebook, but it is unclear what happens next.</p><p>Historically, the industry has defaulted to one of two options — neither of them ideal.</p><p><strong>Option 1 - Ship the notebook and YOLO.</strong> Some of the most well-established early platforms for data science, like Databricks or Domino Labs, solved this problem by essentially allowing data scientists to ship their Jupyter notebooks directly to prod.</p><p>This makes things kind of quick but very fragile. Jupyter notebooks are <!--$--><a href="https://leomurta.github.io/papers/pimentel2019a.pdf" rel="noopener">notoriously brittle</a><!--/$--> things, that break execution order, hide state, and make reproducibility a gamble.</p><p><strong>Option 2 - Hand it off to DevOps.</strong> The other option is to have data science produce prototypes that can be on Notebooks and then have a devops team whose job is to refactor those into an application that runs in production.  This process makes things less fragile, but it is slow and very expensive.</p><p>As a manager, I’ll add this: I don’t really like either of them because they both silos data people even more, instead of fostering processes where software engineering best practices are followed across organizations and create inefficient <!--$--><a href="https://arxiv.org/abs/2303.11761" rel="noopener">team topologies</a><!--/$--> with diluted ownership.</p><p>Today, we want to show you a different path, one that avoids both the fragility of productionized notebooks and the complexity of cross-team handoffs.</p><p>We’ll walk through a complete prototype-to-production workflow using two Python-first tools:</p><ul><li data-preset-tag="p"><p><!--$--><a href="https://github.com/marimo-team/marimo" rel="noopener"><strong>marimo</strong></a><!--/$--> — a modern open-source notebook, stored as Python files, that keeps the flexibility of Jupyter but adds reproducibility, maintainability, and reusability.</p></li><li data-preset-tag="p"><p><!--$--><a href="https://docs.bauplanlabs.com/en/latest/" rel="noopener"><strong>bauplan</strong></a><!--/$--> — a cloud data platform designed for Pythonic workflows over S3, with built-in data versioning, declarative environments, and function execution.</p></li></ul><p>The core intuition here is that both tools are <strong>code-first</strong>, which means they speak the same language: Python.</p><p>That gives us composability “for free”: your prototype code does not need to be rewritten to go into production. We’ll show you how that works.</p><p>Prefer to run the code yourself?</p><p>Check out the <!--$--><a href="https://github.com/BauplanLabs/examples/tree/main/14-marimo" rel="noopener">repo</a><!--/$-->, get a free API key from <!--$--><a href="https://accounts.bauplanlabs.com/sign-up" rel="noopener">the Bauplan sandbox</a><!--/$-->, and follow along.</p><h2>Iterating in a Notebook with marimo</h2><p>In this example, we will clean and analyze a sample of the <!--$--><a href="https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page" rel="noopener">NYC taxi dataset</a><!--/$-->. The data we’re working with isn’t sitting on our laptop. It lives in an S3 bucket — just like it would in a real production environment.</p><p>Now enter <strong>marimo</strong>, a new kind of notebook. It <em>looks</em> like Jupyter, but behaves like a script. That means:</p><ul><li data-preset-tag="p"><p>Execution order is enforced</p></li><li data-preset-tag="p"><p>Variables are scoped properly</p></li><li data-preset-tag="p"><p>Code is cleanly structured and reusable</p></li></ul><p>To run your marimo notebook just type:</p><div><div><div><div><div><div aria-labelledby="/example.py-:Rb8sj7b8m:-tab" id="/example.py-:Rb8sj7b8m:-tab-panel" role="tabpanel"><div aria-autocomplete="list" aria-label="Code Editor for example.py" aria-multiline="true" role="textbox" tabindex="0" translate="no"><pre><span>uv</span> <span>run</span> <span>marimo</span> <span>edit</span> <span>taxi_notebook</span>.<span>py</span></pre></div></div></div></div></div></div></div><p>We’ll get the data from two separate tables:</p><ul><li data-preset-tag="p"><p><code>taxi_trips_sample</code>: trips over a fixed time window</p></li><li data-preset-tag="p"><p><code>zones</code>: metadata about NYC neighborhoods across <!--$--><a href="https://www.youtube.com/watch?v=ny6hwUOFvlw" rel="noopener">all five boroughs</a><!--/$-->.</p></li></ul><p>We will see what these table are in a minute, for now let’s not be too formal and adopt the following definition:</p><p>“A table is a thing with columns and rows, and you can apply filters to it.”</p><p>Let’s start with defining our dependencies at the top:</p><p><img alt="" height="161" src="https://framerusercontent.com/images/1scdNYjmECAHtzS4Oh0fKfE8CRo.png" srcset="https://framerusercontent.com/images/1scdNYjmECAHtzS4Oh0fKfE8CRo.png?scale-down-to=512 512w,https://framerusercontent.com/images/1scdNYjmECAHtzS4Oh0fKfE8CRo.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/1scdNYjmECAHtzS4Oh0fKfE8CRo.png 1737w" width="868" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/></p><p>Then we use Bauplan’s Python SDK to connect to our data catalog and load the tables as Polars DataFrames:</p><p><img alt="" height="364" src="https://framerusercontent.com/images/Ymp7ts7M3Dvzhs9UXTIhCuo0FYs.png" srcset="https://framerusercontent.com/images/Ymp7ts7M3Dvzhs9UXTIhCuo0FYs.png?scale-down-to=512 512w,https://framerusercontent.com/images/Ymp7ts7M3Dvzhs9UXTIhCuo0FYs.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/Ymp7ts7M3Dvzhs9UXTIhCuo0FYs.png 1745w" width="872" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/></p><p>Let’s unpack what’s happening under the hood. When we call <code>bauplan.client.scan()</code>, Bauplan:</p><ul><li data-preset-tag="p"><p>Fetches the data from S3</p></li><li data-preset-tag="p"><p>Avoids redundant reads via smart caching</p></li><li data-preset-tag="p"><p>Streams large datasets efficiently</p></li><li data-preset-tag="p"><p>Handles the data versioning in a <strong>data branch (see below)</strong></p></li></ul><p>We define our first transformation: a join between the two datasets. Wrapped as a Python function, it returns a new DataFrame — which we inspect visually using marimo’s built-in tools:</p><p><img alt="" height="91" src="https://framerusercontent.com/images/K5W1Vm9SfCANHo7kBgEgDTJtQc.png" srcset="https://framerusercontent.com/images/K5W1Vm9SfCANHo7kBgEgDTJtQc.png?scale-down-to=512 512w,https://framerusercontent.com/images/K5W1Vm9SfCANHo7kBgEgDTJtQc.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/K5W1Vm9SfCANHo7kBgEgDTJtQc.png 1956w" width="978" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/><img alt="" height="329" src="https://framerusercontent.com/images/AAp7SGaIuJFyIsjiURbC9GzVjQ.png" srcset="https://framerusercontent.com/images/AAp7SGaIuJFyIsjiURbC9GzVjQ.png?scale-down-to=512 512w,https://framerusercontent.com/images/AAp7SGaIuJFyIsjiURbC9GzVjQ.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/AAp7SGaIuJFyIsjiURbC9GzVjQ.png 1943w" width="971" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/></p><p>Next, we define a second transformation that cleans up the data and computes some aggregates, again, as a plain Python function.</p><p><img alt="" height="507" src="https://framerusercontent.com/images/taquw01l7OoU3KkOicm1bSTESMg.png" srcset="https://framerusercontent.com/images/taquw01l7OoU3KkOicm1bSTESMg.png?scale-down-to=512 512w,https://framerusercontent.com/images/taquw01l7OoU3KkOicm1bSTESMg.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/taquw01l7OoU3KkOicm1bSTESMg.png?scale-down-to=2048 2048w,https://framerusercontent.com/images/taquw01l7OoU3KkOicm1bSTESMg.png 2221w" width="1110" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/></p><p>Still looks like a notebook, right? But here’s the key difference. marimo notebooks are <strong>just Python scripts,</strong> so every function you define can be reused outside the notebook, including inside a Bauplan pipeline.</p><h2>Building a production pipeline with Bauplan</h2><p>While it is easy to blame data folks for not being good at software, the truth is, as we noted <!--$--><a href="https://arxiv.org/pdf/2404.13682" rel="noopener">elsewhere</a><!--/$-->, that the sheer quantity of tools needed to run data workloads in Python in production is astounding. Python data pipelines in the cloud are <!--$--><a href="https://www.youtube.com/shorts/d1wlYcG4Q5o" target="_blank" rel="noopener">Rube Goldberg machines</a><!--/$--> of storage, file formats, table formats, containers, environments, orchestration and so on.</p><p>Below, the things you need to run a data pipeline in your production cloud environment.</p><figure><table><tbody><tr><th><p><strong>Component</strong></p></th><th><p><strong>Tools</strong></p></th></tr><tr><td><p>Data storage</p></td><td><p>S3</p></td></tr><tr><td><p>File formats</p></td><td><p>parquet, csv, avro…</p></td></tr><tr><td><p>Table formats</p></td><td><p>Hive, Iceberg, Delta, Hudi…</p></td></tr><tr><td><p>Code</p></td><td><p>Git, github, bitbucket…</p></td></tr><tr><td><p>Environments</p></td><td><p>pip, uv, Docker, ECR, ECS…</p></td></tr><tr><td><p>Runtime</p></td><td><p>Kubernetes, EKS…</p></td></tr><tr><td><p>Orchestrators</p></td><td><p>Airflow, Dagster, Prefect, Orchestra, Temporal, DBOS…</p></td></tr></tbody></table></figure><p>Bauplan is designed to solve this problem and provide a much simpler developer experience. It’s a Python-first, dead-simple data lakehouse that abstracts away production infrastructure, while keeping everything in code.</p><p>Here’s how it works:</p><ul><li data-preset-tag="p"><p><strong>Data are just tables</strong> — with columns, filters, schemas, and versioning, built-in on your S3. We can use those tables in our Python code declaratively.</p></li><li data-preset-tag="p"><p><strong>DAGs are just functions chained together</strong> — parents feed children, like in the notebook logic illustrated above.</p></li><li data-preset-tag="p"><p><strong>Infra is just decorators</strong> — all dependencies are declared in the code, so there are no Dockerfiles or Terraform scripts.</p></li><li data-preset-tag="p"><p><strong>Runtime is optimized, serverless Python</strong> — fast cold starts, built-in scaling, no setup required.</p></li><li data-preset-tag="p"><p><strong>Data is versioned like Git</strong> — versioning is built-in so every table, model, and result lives in a Git-like branch of our data lake.</p></li></ul><p>The last point might need a little more explanation. In Bauplan, we don’t just version your code, we version your <strong>data</strong> too. Every operation on the data lake lives inside a <strong>branch</strong>, just like Git. As a consequence, we can prototype, test new logic, or tweak filters on production data without affecting downstream production systems.</p><div><div><div><div><div><div aria-labelledby="/example.sh-:Rb9lj7b8m:-tab" id="/example.sh-:Rb9lj7b8m:-tab-panel" role="tabpanel"><div aria-autocomplete="list" aria-label="Code Editor for example.sh" aria-multiline="true" role="textbox" tabindex="0" translate="no"><pre>bauplan checkout <span>--branch</span></pre></div></div></div></div></div></div></div><p>When we imported data into polars dataframes in the section above, you may recall that <code>bauplan.client.scan()</code> requires a branch as input. That is because you’re not just performing a scan on a table in S3: you’re scanning a specific version of that table.</p><p>This model turns out to be extremely useful in the process we are describing because it enables:</p><ul><li data-preset-tag="p"><p>Safe experimentation</p></li><li data-preset-tag="p"><p>Collaborative workflows</p></li><li data-preset-tag="p"><p>Reproducibility by default</p></li></ul><p>Here’s where it gets good: because both Bauplan and marimo are truly Pythonic, we can take those exact same functions we wrote while prototyping in our notebook and run them in production without any refactoring.</p><p>All we need to do is wrap the two functions in Bauplan decorators, whose semantics is pretty obvious even for beginners. We start by importing the function we wrote in our notebook <code>join_taxi_tables</code> and wrap it in a Bauplan model. We define the input tables, columns, filters, and dependencies using simple Python.</p><div><div><div><div><div><div aria-labelledby="/example.py-:Rb9sj7b8m:-tab" id="/example.py-:Rb9sj7b8m:-tab-panel" role="tabpanel"><div aria-autocomplete="list" aria-label="Code Editor for example.py" aria-multiline="true" role="textbox" tabindex="0" translate="no"><pre><span>import</span> <span>bauplan</span>

@<span>bauplan</span>.<span>model</span><span>(</span><span>)</span>
@<span>bauplan</span>.<span>python</span><span>(</span><span>&#39;3.11&#39;</span><span>,</span> <span>pip</span>=<span>{</span><span>&#39;polars&#39;</span>: <span>&#39;1.30.0&#39;</span><span>,</span> <span>&#39;marimo&#39;</span>: <span>&#39;0.13.14&#39;</span><span>}</span><span>)</span>
<span>def</span> <span>trips_and_zones</span><span>(</span>
    <span>trips</span>=<span>bauplan</span>.<span>Model</span><span>(</span>
        <span>&#39;taxi_fhvhv&#39;</span><span>,</span>
        <span>columns</span>=<span>[</span><span>&#39;pickup_datetime&#39;</span><span>,</span> <span>&#39;PULocationID&#39;</span><span>,</span> <span>&#39;trip_miles&#39;</span><span>]</span><span>,</span>
        <span>filter</span>=<span>&#34;pickup_datetime &gt;= &#39;2022-01-01T00:00:00-05:00&#39; AND pickup_datetime &lt; &#39;2023-01-01T00:00:00-05:00&#39;&#34;</span>
    <span>)</span><span>,</span>
    <span>zones</span>=<span>bauplan</span>.<span>Model</span><span>(</span>
        <span>&#39;taxi_zones&#39;</span><span>,</span>
        <span>columns</span>=<span>[</span><span>&#39;LocationID&#39;</span><span>,</span> <span>&#39;Zone&#39;</span><span>]</span>
    <span>)</span><span>,</span>
<span>)</span>:
    
    <span>import</span> <span>polars</span> <span>as</span> <span>pl</span>
    
    <span>from</span> <span>your_notebook</span> <span>import</span> <span>join_taxi_tables</span>

    
    
    <span>return</span> <span>join_taxi_tables</span><span>(</span><span>pl</span>.<span>from_arrow</span><span>(</span><span>trips</span><span>)</span><span>,</span> <span>pl</span>.<span>from_arrow</span><span>(</span><span>zones</span><span>)</span><span>)</span>.<span>to_arrow</span><span>(</span><span>)</span> </pre></div></div></div></div></div></div></div><p>Then, we define a second function <code>stats_by_taxi_zones</code> to compute our stats. This second function takes the output of the first function as input and writes the result back to the data lake, thanks to the <code>materialization_strategy</code> parameter being set to <code>REPLACE</code>:</p><div><div><div><div><div><div aria-labelledby="/example.py-:Rb9uj7b8m:-tab" id="/example.py-:Rb9uj7b8m:-tab-panel" role="tabpanel"><div aria-autocomplete="list" aria-label="Code Editor for example.py" aria-multiline="true" role="textbox" tabindex="0" translate="no"><pre>@<span>bauplan</span>.<span>model</span><span>(</span><span>materialization_strategy</span>=<span>&#39;REPLACE&#39;</span><span>)</span>
@<span>bauplan</span>.<span>python</span><span>(</span><span>&#39;3.11&#39;</span><span>,</span> <span>pip</span>=<span>{</span><span>&#39;polars&#39;</span>: <span>&#39;1.30.0&#39;</span><span>,</span> <span>&#39;marimo&#39;</span>: <span>&#39;0.13.14&#39;</span><span>}</span><span>)</span>
<span>def</span> <span>stats_by_taxi_zones</span><span>(</span>
    <span>data</span>=<span>bauplan</span>.<span>Model</span><span>(</span><span>&#39;trips_and_zones&#39;</span><span>)</span>
<span>)</span>:
    
    <span>import</span> <span>polars</span> <span>as</span> <span>pl</span>
    
    <span>from</span> <span>your_notebook</span> <span>import</span> <span>compute_stats_by_zone</span>
    
    
    <span>return</span> <span>compute_stats_by_zone</span><span>(</span><span>pl</span>.<span>from_arrow</span><span>(</span><span>data</span><span>)</span><span>)</span>.<span>to_arrow</span><span>(</span><span>)</span> </pre></div></div></div></div></div></div></div><p>Both functions live in a Python file and they run as fully containerized functions in the cloud. Running the pipeline in the cloud becomes as easy as launching a local script: just use the <code>bauplan run</code> command:</p><p><img alt="" height="495" src="https://framerusercontent.com/images/PukZy8PEyDMhtGS2U3at49eATI.png" srcset="https://framerusercontent.com/images/PukZy8PEyDMhtGS2U3at49eATI.png?scale-down-to=512 512w,https://framerusercontent.com/images/PukZy8PEyDMhtGS2U3at49eATI.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/PukZy8PEyDMhtGS2U3at49eATI.png 2000w" width="1000" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 810px) and (max-width: 1199px) 100vw, (max-width: 809px) 100vw"/></p><p>A couple of notes on what happens:</p><ul><li data-preset-tag="p"><p>The parent function (<code>trips_and_zones</code>) uses the same data as the notebook, but now applies a full-year filter, because we’re in the cloud and we are not limited by local memory.</p></li><li data-preset-tag="p"><p>The marimo functions are reused <em>as is:</em> they’re just Python functions, imported like any other module.</p></li><li data-preset-tag="p"><p>You’re free to use Pandas, Polars, or anything else. Bauplan doesn’t care as long as one can pip install it (in real deployments, this include your own private packages as well!).</p></li><li data-preset-tag="p"><p>Best of all, the output of the DAG is saved to your branch. You can share it with other developers or with our PM for feedback, validate the logic, and when ready, merge it back to main.</p></li></ul><p>The main point is that we don’t have to worry about any infrastructure and we don’t have to refactor our notebook into jobs.</p><p>So, what happens if we update the function <code>stats_by_taxi_zones</code> in the notebook and change <code>median</code> to <code>mean</code> and re-run it? Nothing new to learn, really. We just save the notebook and go again:</p><p>Our production-grade data pipeline just updated itself.</p><p>Bauplan + marimo show that going from prototype to production doesn’t have to be painful. No handoffs. No rewrites. No YAML jungles or container rabbit holes. Just Python — in notebooks, in pipelines, in production.</p><p>That said, there are still a few rough edges we’re working on.</p><p>One common question: <em>how do I map the setup cell in marimo to Bauplan’s decorators?</em> Today, you copy the package list into a <code>@bauplan.python(...)</code> decorator. It works, but we agree — it’s not ideal.</p><p>We’re actively building support for <strong>shared, declarative environments</strong> scoped to folders or DAGs, so that your dependency setup can be reused across tools — notebook or not — without duplication.</p><h2>Try It Yourself</h2><p>Clone the <!--$--><a href="https://github.com/BauplanLabs/examples/tree/main/14-marimo" target="_blank" rel="noopener">Github repo</a><!--/$-->, and start hacking!</p><p><!--$--><a href="https://www.bauplanlabs.com/#join" rel="noopener">Try Bauplan</a><!--/$-->, it&#39;s free!</p><p><!--$--><a href="https://github.com/marimo-team/marimo" target="_blank" rel="noopener">Try Marimo</a><!--/$-->, it&#39;s open source!</p></div></div>
  </body>
</html>
