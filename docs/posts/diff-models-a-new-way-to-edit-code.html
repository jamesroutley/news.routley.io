<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://carper.ai/diff-models-a-new-way-to-edit-code/">Original</a>
    <h1>Diff Models – A New Way to Edit Code</h1>
    
    <div id="readability-page-1" class="page"><div>
					
<p><a href="http://carper.ai/">CarperAI</a> is releasing a series of diff models—models trained to predict a code diff, trained on millions of commits scraped from GitHub. We are releasing 3 models of different sizes, all fine-tuned from Salesforce’s <a href="https://github.com/salesforce/CodeGen">CodeGen</a> code synthesis models:</p>



<ul>
<li><a href="https://huggingface.co/CarperAI/diff-codegen-350m-v2">diff-codegen-350m</a></li>



<li><a href="https://huggingface.co/CarperAI/diff-codegen-2b-v2">diff-codegen-2b</a></li>



<li><a href="https://huggingface.co/CarperAI/diff-codegen-6b-v2">diff-codegen-6b</a></li>
</ul>



<p>The dataset of diffs we scraped to train these models will be released separately in the near future. We hope these models will be useful for suggesting intelligent changes to existing code, controllable through a specific commit message describing the change. We will continue to iterate on our diff models, so stay tuned for further releases.</p>



<p><strong><em>Read on for more details on how the models were trained, with benchmark results!</em></strong></p>



<h2>Introduction</h2>



<p>A diff model is an autoregressive language model trained on edits to a piece of text, formatted in <a href="https://en.wikipedia.org/wiki/Diff#Unified_format"><strong>Unified Diff Format</strong></a><strong>. </strong>These diff models can suggest, given a section of text and a description of the desired change, an intelligent change to the text that fits the description, marking the lines added, changed, and deleted in diff format. The primary use case for these models is for suggesting changes to code—as such, the models we are releasing are fine-tuned versions of models already trained on code datasets.</p>



<p>In comparison to few-shot prompting of normal code generation models, diff models are specialized for suggesting intelligent changes to existing code, particularly longer pieces of code and where a change is required to follow some natural language text description (provided in the form of a commit message).</p>



<p>Prior work by Microsoft Research (<a href="https://arxiv.org/abs/2203.09095">Li et al., 2022</a>) and OpenAI (Ray and McCandlish 2020<sup>1</sup>; <a href="https://arxiv.org/abs/2206.08896">Lehman et al. 2022</a>) identified the potential for diffs as a source of rich data on how to make changes to code, and trained models on diffs, but did not release any diff models or publish an analysis of how to obtain good performance.</p>



<p><sup>1</sup> Alex Ray and Sam McCandlish, OpenAI. Independent contribution: Training diff models, 2020.</p>



<h2>A Diff Dataset</h2>



<p>Our dataset for this fine-tune consists of commits from GitHub, obtained using the <a href="https://cloud.google.com/blog/topics/public-datasets/github-on-bigquery-analyze-all-the-open-source-code">Google BigQuery Public Dataset</a>, a public up to date snapshot of a huge number of open-source GitHub repositories. We took this dataset and filtered using BigQuery on the number of stars in the repository to exclude repos with less than 100 stars, and further restricted the query to only repositories with open-source non-copyleft licenses (e.g. MIT, Apache, etc) and commits with more than 10 characters in the commit message. We also restricted ourselves to a list of 22 popular programming, scripting, and markup languages, including Python, HTML, Bash scripts, SQL, C++, etc. This resulted in a dataset of 19 million commits after filtering.</p>



<p>At this point we had the commit hashes, repository names, and other metadata for the commits we wanted in our dataset. We then ran `git clone` on every repository in our dataset and used a Python script to obtain the raw code files before the diff is applied, together with the diff itself in <a href="https://en.wikipedia.org/wiki/Diff#Unified_format">Unified Diff Format</a>. These were processed into <a href="https://parquet.apache.org/">Apache Parquet</a> format using <a href="https://www.dask.org/">Dask</a> with <a href="https://arrow.apache.org/docs/python/">Apache Arrow</a> to efficiently get it into a dataframe format, with one row per <em>file</em> changed (e.g. if a diff affected multiple files it was split up), and included only rows where each file + diff was short enough to fit into the context of the language model. </p>



<p>From there, we processed the dataset into EleutherAI’s <a href="https://github.com/EleutherAI/lm_dataformat"><em>lm_dataformat</em></a>, a utility to create compressed data files for efficient language model training. The final format of the data seen by the language model consisted of the filename changed by the diff, the file before changes, the commit message, and the diff itself, all concatenated together with delineating tags in between:</p>



<pre><code><code>&lt;<span>NME<span>&gt;</span> {filename}</span></code>
<code>&lt;<span>BEF<span>&gt;</span> {file_before_changes}</span></code>
<code>&lt;<span>MSG<span>&gt;</span> {commit_message}</span></code>
<code>&lt;<span>DFF&gt; {diff}</span></code></code></pre>



<p>The model is then typically prompted with everything up to <code>&lt;DFF&gt;</code>, but you can also optionally include the section heading of the unified diff format immediately after <code><code>&lt;</code>DFF<code>&gt;</code></code>, which specifies which lines exactly the model should change. For example, appending <code>@@ -1,3 +1,9 @@</code> after the diff tag would instruct the model to change the file at line 1, adding 9 - 3 = 6 lines. We do not add these four tags as special tokens, since we prioritized leaving the tokenizer unchanged.</p>



<p>The final dataset consisted of 1.4 million files from 19 million commits, which resulted in 1.086 billion tokens after tokenizing with a <a href="https://github.com/salesforce/CodeGen/blob/main/jaxformer/hf/sample.py#L84">modified GPT-2 tokenizer</a> to include whitespace tokens—an average of 888 tokens per sample.</p>



<h2>Fine-tuning CodeGen</h2>



<p>The model suite we worked with as a base was <a href="https://arxiv.org/abs/2203.13474">Salesforce’s CodeGen</a> series of models, which are decoder-only transformer language models trained to predict the next token in a sequence. These models were first pre-trained on <a href="https://arxiv.org/abs/2101.00027">The Pile</a>, an 800GB dataset of diverse text released by EleutherAI, and then further trained on a large dataset of permissively licensed code from GitHub BigQuery in 6 programming languages, before finally being trained on Python only code from the same source. Note that the code in these pre-training datasets will inevitably overlap to some degree with our diff dataset, although they do not contain diffs. </p>



<p>Salesforce have released variants of their models at 4 scales (350M, 2B, 6B, and 16B parameters) with 3 variants at each scale corresponding to the 3 different stages of pre-training described above. We chose to fine-tune the “mono” variants at each model scale, meaning the version trained on Python only code in addition to multi-language code.</p>



<p>In order to fine-tune these models on our diff dataset, we used <a href="https://github.com/huggingface/transformers/blob/main/examples/pytorch/language-modeling/run_clm.py">HuggingFace’s standard fine-tuning script</a> with slight modifications to customize to CodeGen’s architecture, using the default hyperparameters and without freezing any layers. To pre-process the data we concatenated each sample (file with changes) together in the format described above and cut it into chunks of 2048 tokens (the context length of the CodeGen models). We then fine-tuned all of the model sizes with this dataset as an initial trial run and baseline for further experiments. For all fine-tuning experiments in this post, we used 64 Nvidia A100 GPUs—we thank <a href="https://stability.ai/">Stability AI</a> for access to their compute resources!</p>



<p>To test a range of hyperparameters, we did a 12 run sweep with the 350m model across a range of learning rates and batch sizes, and settled on a learning rate of 3e-5 and a batch size of 1024 samples.</p>



<h3>Token Masking</h3>



<p>We then experimented with masking tokens in the loss computation, as described in the <a href="https://arxiv.org/abs/2206.08896">ELM paper</a>. Specifically, we include only the tokens in the diff (including the tag <code><code>&lt;</code>DFF<code>&gt;</code></code>) in the loss, which is intended to encourage the model to predict the diff and not memorize the file and commit message. For example, we expect that filenames in <code><code>&lt;</code>NME<code>&gt;</code></code> and file contexts in <code><code><code>&lt;</code>BEF<code>&gt;</code></code></code> are given by the prompt, while <code><code><code>&lt;</code>DFF<code>&gt;</code></code></code> is the only goal in the diff generation. Therefore, it is natural to ignore unrelated prediction targets and exclude tokens before <code><code><code>&lt;</code>DFF<code>&gt;</code></code></code> in the computation of the loss function. We fine-tuned the full suite of models with this modification to compare the results across model scale.</p>



<h3>File Truncation</h3>



<p>We also experimented with different ways of truncating the file before changes to fit more of it into the context length. Without any truncation, roughly half of the files in the original dataset fit into the 2048 context length, for a total of 1.086 billion tokens. If we crop the file before changes to only contain the lines in the diff file, we can then fit 95% of the original dataset in the context, for a total of 2.181 billion tokens (see Figure 1). We hoped that including the extra data at the cost of some context in the file being changed would improve the model’s performance. However, we found that this experiment resulted in a model significantly worse than without truncation, likely because being able to see an entire class/function that a change relies on is important for modelling.</p>



<figure><img decoding="async" data-attachment-id="1818" data-permalink="https://carper.ai/diff-models-a-new-way-to-edit-code/imgonline-com-ua-twotoone-8gxvfts88cphnn/" data-orig-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?fit=1147%2C413&amp;ssl=1" data-orig-size="1147,413" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="imgonline-com-ua-twotoone-8gxvFTs88CphNn" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?fit=300%2C108&amp;ssl=1" data-large-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?fit=1024%2C369&amp;ssl=1" src="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?resize=1080%2C390&amp;ssl=1" alt="" width="1080" height="390" data-recalc-dims="1" data-lazy-srcset="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?resize=1080%2C390&amp;ssl=1 1167w, https://carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn-980x353.jpg 980w, https://carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn-480x173.jpg 480w" data-lazy-sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1167px, 100vw" data-lazy-src="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/imgonline-com-ua-twotoone-8gxvFTs88CphNn.jpg?resize=1080%2C390&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption>Figure 1: <em>Histograms of the samples in the dataset, ordered by length of file in tokens on the x-axis. (left) The baseline dataset, showing that the 2048 context length of our language models cuts off around 50% of the files. (right) The result of truncating the code file before changes to only contain lines altered by the diff and surrounding context.</em><br/></figcaption></figure>



<h2>Results</h2>



<p>To evaluate our models, we test their bug fixing capabilities on two tasks: <a href="https://arxiv.org/pdf/2206.08896.pdf#page=7">4-Parity</a>, a simple toy benchmark where the model is required to fix basic bugs in a Python function to calculate the parity of a 4-bit sequence, and a more complex dataset of many synthetic and real Python bugs scraped from GitHub repositories by <a href="https://github.com/eth-sri/learning-real-bug-detector">He et al. (2022)</a>. These benchmarks provide a simple testbed for whether diff LLMs can make multiple coordinated and effective changes to code.</p>



<p>For 4-Parity, we generate completions using a prompt consisting of the original function followed by the commit message <code><code><code>&lt;</code>MSG<code>&gt;</code></code> # Fixed bug<code><code>s</code></code></code>. We generate 3200 completions for each model, apply the resulting diff patches to the original function, execute the generated code and report the % of the generations where the generated 4-Parity function is correct across all test cases, at the best model temperature from <code>{0.7, 0.8. 0.9}</code>. We report results across 1-5 bugs synthetically introduced to the original function.</p>



<p>For the latter task of real Python bugs, we filter the dataset down to 1000 bugs across several bug fixing problems (e.g. a wrong binary operator and incorrect variable name problem), where we generate a diff for each bug and measure the exact string match accuracy between the generated function after applying the diff, and the correct (bug-free) function. The commit message for this task is <code>Fix {bug_class}</code>, where the bug class might be, for example, “incorrect binary operator”. Note that in this case we do not execute the generated code to test it, since these bugs are scraped from many different GitHub repositories and execution would be impractical.</p>



<p>The results from 4-Parity, shown in Figure 2, demonstrate that our diff models can perform basic bug fixing at comparable skill to the prompted CodeGen models. There is a clear performance increase with scale, and the 350M diff model performs better at the bug fixing task. We can also see that the loss masking approach described above results in significantly better diff models on this task.</p>



<figure><img decoding="async" width="1024" height="735" data-attachment-id="1820" data-permalink="https://carper.ai/diff-models-a-new-way-to-edit-code/4-parity/" data-orig-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/4-parity.png?fit=5189%2C3727&amp;ssl=1" data-orig-size="5189,3727" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="4-parity" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/4-parity.png?fit=300%2C215&amp;ssl=1" data-large-file="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/4-parity.png?fit=1024%2C735&amp;ssl=1" src="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/4-parity.png?resize=1024%2C735&amp;ssl=1" alt="" data-recalc-dims="1" data-lazy-srcset="https://carper.ai/wp-content/uploads/2023/01/4-parity-980x704.png 980w, https://carper.ai/wp-content/uploads/2023/01/4-parity-480x345.png 480w" data-lazy-sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" data-lazy-src="https://i0.wp.com/carper.ai/wp-content/uploads/2023/01/4-parity.png?resize=1024%2C735&amp;is-pending-load=1#038;ssl=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/><figcaption><em>Figure 2: Results from evaluating our diff models on the simple 4-Parity bug fixing task. Note the log scale y-axis. The x-axis is the number of progressively introduced bugs in the 4-Parity function. The bolded lines show our best diff models, while the dot-dash lines show the CodeGen models we used as a starting point, and the baseline models are trained without loss masking.</em></figcaption></figure>



<p>Table 1 shows the results from our diff models on the synthetic + real bugs benchmark, using the <em>pass@k</em> metric with <em>k = 1</em> (defined as the fraction of problems solved when the model generates <em>k</em> code samples per problem. We can see that the masked diff models perform slightly better</p>



<figure><table><tbody><tr><td data-align="center">Model</td><td data-align="center">pass@1 - Synthetic + Real Bugs</td></tr><tr><td data-align="center">Baseline Diff 350M</td><td data-align="center">0.9%</td></tr><tr><td data-align="center">Baseline Diff 2B</td><td data-align="center">1.9%</td></tr><tr><td data-align="center">Baseline Diff 6B</td><td data-align="center">2.3%</td></tr><tr><td data-align="center">Masked Diff 350M</td><td data-align="center">1.7%</td></tr><tr><td data-align="center">Masked Diff 2B</td><td data-align="center">3.9%</td></tr><tr><td data-align="center">Masked Diff 6B</td><td data-align="center">4.8%</td></tr><tr><td data-align="center">CodeGen 350M</td><td data-align="center">2.0%</td></tr><tr><td data-align="center">CodeGen 2B</td><td data-align="center">3.8%</td></tr><tr><td data-align="center">CodeGen 6B</td><td data-align="center">4.5%</td></tr></tbody></table><figcaption>Table 1: Pass@1 (<a href="https://arxiv.org/abs/2107.03374">Chen et al., 2021</a>) on the real + synthetic bugs benchmark (<a href="https://github.com/eth-sri/learning-real-bug-detector">He et al., 2022</a>). </figcaption></figure>



<p>Qualitatively, we also evaluated the accuracy of the line numbers in the generated diff hunk, and noticed that the larger scale models do very well at accurately generating line numbers which correspond to the lines which the diff below actually changes. This opens the door to prompting the model with specific line numbers to change, add, or remove, allowing for more control over the code generation in comparison with a non-diff model.</p>



<p>We also noticed that diff models (especially the 2B and 6B) tend to do better when prompted with longer code generation tasks (such as fixing bugs in a large function, and that varying the prompt induces greater diversity in generated code in comparison with the normal CodeGen models.</p>



<p>In further work, we hope to examine in greater detail the enhanced diversity and localised mutation abilities that diff models offer over standard code generation models, across many model scales.</p>



<h2><strong>Accelerated Inference with Triton and FasterTransformer</strong></h2>



<p>We also investigated the use of Nvidia’s <a href="https://github.com/NVIDIA/FasterTransformer">FasterTransformer</a> (FT) framework with the <a href="https://developer.nvidia.com/nvidia-triton-inference-server">Triton Inference Server</a> using an FT backend to achieve significantly accelerated inference. FasterTransformer is a collection of fused CUDA kernels optimized for inference, written in C++. The Triton Inference Server is an optimized system for serving large language models at scale, in both multi-GPU and multi-node setups using Docker containers.</p>



<p>Converting the CodeGen models to FT involved significant technical work, since CodeGen is not supported natively in FT. We first converted the CodeGen weights to GPT-J format via <a href="https://gist.github.com/moyix/7896575befbe1b99162ccfec8d135566">a linear algebra trick</a>, since GPT-J has a very similar architecture, building on Brendan Dolan-Gavitt’s work with the <a href="https://github.com/fauxpilot/fauxpilot">Fauxpilot</a> framework. From there, we used the FT script to convert the GPT-J HuggingFace checkpoint into FT’s format, which can be run with the Triton server. We struggled to get this to run on our cluster (which does not use Docker), but eventually succeeded and achieved a significant speedup on inference of our models—in some cases up to an order of magnitude faster.</p>



<figure><table><tbody><tr><td data-align="center">Model</td><td data-align="center">Time: HuggingFace Transformers</td><td data-align="center">Time: FasterTransformer + Triton Inference Server</td></tr><tr><td data-align="center">CodeGen 350m</td><td data-align="center">5m 44s</td><td data-align="center">31s</td></tr><tr><td data-align="center">CodeGen 2B</td><td data-align="center">9m 38s</td><td data-align="center">1m 27s</td></tr><tr><td data-align="center">CodeGen 6B</td><td data-align="center">10m 45s</td><td data-align="center">2m 9s</td></tr></tbody></table><figcaption>Table 2: Time benchmark results for the base CodeGen models on the 4-Parity task described above, comparing HuggingFace Transformers inference speed with FasterTransformer using the Triton Inference Server.</figcaption></figure>



<p>Our scripts to convert and run these models with FasterTransformer and Triton are available in the <a href="https://github.com/CarperAI/OpenELM/tree/release/0.1.8">OpenELM library</a>.</p>



<p>We hope that this work inspires others to take our models and experiment with the potential of diff-based code generation!</p>



<p>To cite this blog post, please use the following entry:</p>



<blockquote>
<p>H. Bradley, H. Fan, H. Saini, R. Adithyan, S. Purohit, and J. Lehman. (Jan 2023). Diff Models - A New Way to Edit Code. CarperAI Blog. <a href="https://carper.ai/diff-model/" rel="nofollow">https://carper.ai/diff-model/</a>.</p>
</blockquote>



<p>Or</p>



<pre><code>@article{bradley2023diffmodels,
  title   = &#34;Diff Models - A New Way to Edit Code&#34;,
  author  = &#34;Bradley, Herbie and Fan, Honglu and Saini, Harry and Adithyan, Reshinth and Purohit, Shivanshu and Lehman, Joel&#34;,
  journal = &#34;CarperAI Blog&#34;,
  year    = &#34;2023&#34;,
  month   = &#34;Jan&#34;,
  url     = &#34;https://carper.ai/diff-model/&#34;
}</code></pre>



<h3>Acknowledgements</h3>



<p>The CarperAI diff models team consisted of Herbie Bradley, Honglu Fan, Harry Saini, Reshinth Adithyan, Shivanshu Purohit, and Joel Lehman.</p>



<p>We thank Stability AI for providing compute resources.</p>

					</div></div>
  </body>
</html>
