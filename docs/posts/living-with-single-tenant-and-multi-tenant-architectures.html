<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://medium.com/schibsted-engineering/living-with-single-tenant-and-multi-tenant-architectures-b2d7027db24e">Original</a>
    
    <div id="readability-page-1" class="page"><div><div><p id="9047">Ok, so in <em>Comments, </em>resources are shared. What does it mean? It means that each organization utilizes the same storage and operates on the same servers. As simple as that. With such an approach, each of the comments created in our database will have the newsroom‚Äôs id assigned to it. This is known as a multi-tenant approach.</p><pre><span id="7728"># comments table</span><span id="fa10">| id | message                     | newsroom             |</span></pre></div></div><div><p id="636d">I really like the urban analogy pictured below. We talk about the single-tenant approach when every family lives in their own house. They don‚Äôt share elevators, electric installations, staircases, etc. with other families. This is the opposite of living in an apartment building.</p></div><div><div><p id="8279">Let‚Äôs now cover a few topics which differentiate those two approaches. For each of them I will share some examples from our projects, how they affected our work and where the gotchas üé£ are. At the end of the article I will try to think about how I would design those systems if I had a chance o do it again from scratch. Yes, I heard about <a href="https://en.wikipedia.org/wiki/Second-system_effect" target="_blank" rel="noopener ugc nofollow">the second-system effect</a> but I‚Äôm too weak to resist üòÇ.</p><h2 id="7cd1">Data isolation</h2><p id="5144">Separate storage means that data from different tenants won‚Äôt interfere with each other. It also should protect us from unrestricted data access. I have been trying to find an endpoint in <em>Comments</em> that would allow me to do a small hack and access to data which I shouldn‚Äôt be able to. And I found it.</p><figure><div></div></figure><p id="9355">What is this request doing? As a user logged in to the <em>E24 </em>newsroom I voted on a comment identified by the number<code>3159602</code> . However, this comment is not assigned to <em>E24</em> but to <em>Bergens Tidende </em>üò®. Comments from all newsrooms are living together in one big table. <strong>As a user in organization A, I was able to manipulate data in organization B. </strong>This is not a big deal in <em>Comments </em>because our API is not public and user accounts are shared across all newsrooms. Other systems might be much more concerned about data integrity. To mitigate such danger you would need to implement additional logic which restricts users from performing such actions. Developers make mistakes, there is always a chance that üêõ will be introduced.</p><p id="cea0"><strong>Application code in <em>Live </em>is tenant agnostic.</strong> It means that you will neither find any references to tenants in the code nor any conditional expressions with their identifiers. This reduces the likelihood of introducing bugs mentioned a few lines earlier.</p><p id="4094">Here is another example of code that isn‚Äôt tenant agnostic and it is once again from the <em>Comments</em> project.</p><figure><div></div></figure><p id="8a3b">The second argument of the method is <code>newsroomId</code> . You could find many more places where this additional argument is required. In <em>Live</em> you won‚Äôt find any.</p><h2 id="d55b">Tooling changes</h2><p id="ce51">During the last two years we spent quite some time migrating our projects from some platforms to others. Let‚Äôs list a few of them</p><ol><li id="426f">From Sumo Logic to Datadog as an observability solution.</li><li id="c502">From an in-house tool for provisioning to Terraform.</li><li id="1c6b">From one Redis provider to another.</li><li id="bd5f">From Heroku to Convox as a hosting solution.</li></ol><p id="bf6e">What do you think, which system did we spend more time on? It was of course the single-tenant system. <strong>We have more manual work to do like copying configuration snippets, URLs, encrypting secrets, etc.</strong> This is simply because we had many more servers and databases.</p><h2 id="4201">Resilience</h2><p id="5201">At the beginning of <em>Comments,</em> when the system was in its infancy, one of the newsrooms wanted to prepare something special for their readers. It was during NHL playoffs üèí, and they wanted to increase user interactions. So they placed our widgets in multiple places on the index site (which we call the front page). As you can expect we started receiving an enormous amount of traffic on which we weren&#39;t prepared for. Usually, our widget is only placed on article pages.<strong> This sudden increase in the amount of traffic ended up killing our database üî•.</strong> As the NHL games are being played at night when we are sleeping, comments across all Schibsted brands were down for a few hours. And what would be happening during a DDoS attack in a single-tenant system? Only one of the tenants would be affected whereas the rest of them would be operating as usual.</p><p id="30e7">Since we are talking about taking services down, let‚Äôs talk a little bit about <strong>recovery</strong>. How many of you have truly fully automated recovery procedures in place? Many things can go wrong when deploying a new version of a service: There can be a bug in the application code, a mistake in the database schema migration, or a mismatch in the DNS configuration. Quite often something unexpected happens, which you are not fully prepared for. In such a scenario, you need to take manual action to fix the problem. Would you like to revert the change on one database or on a <em>number of tenant</em> databases? In a system that is like <em>Live</em> you need to put some additional thought into disaster recovery and be prepared for it.</p><h2 id="b303">Adding a new tenant</h2><p id="1001">In an ideal world adding a new organization in a multi-tenant (<em>Comments</em>) setup would only require extending the application configuration with an entry related to a new one. Maybe you would update your infrastructure by changing the autoscaling policy or you will just spawn a few new server instances. A single-tenant (<em>Live</em>) architecture would require one more step, and this step is related to infrastructure. You probably would need to add a new set of variables for each microservice, add new entries in your DNS configuration and update your monitoring dashboards. Sadly, the real world is usually more complex. Adding a new tenant in <em>Comments </em>doesn‚Äôt really require much less work than in <em>Live. </em><strong>Our application configuration is not centralized, it‚Äôs scattered among microservices.</strong> We need to apply changes in each of our repositories. They‚Äôre mainly related to preparing database schema migrations to add new records related to the new organization.</p><p id="6263">Let‚Äôs imagine a situation that you are supporting a dozen tenants and at some point, your PM approaches you with a request of adding 50 new ones to your system. This scenario is exactly what happened this summer üòÖ. <strong>We needed to prepare <em>Comments</em> and <em>Live </em>to support 50 new newsrooms.</strong> For <em>Live </em>we supported 12 at that time. Spawning 50 new deployments (which in microservice architecture it means a lot of servers) would have cost us a lot ü§ë! We needed to take a hybrid approach. We gathered those new newsrooms under one deployment. These were smaller newsrooms, local ones, from which we didn‚Äôt expect big traffic. When going with a single-tenant architecture you need to ask yourself the question: Is it possible that at some point in time the interest in your product will be so high that everybody will want to use it?</p><p id="0ea1">I also feel obliged to say one more thing. Both products are built using the microservice architecture. Adding new tenants to <em>Comments </em>could take some time if you had to do this manually. Luckily, we have a simple CLI tool that does all the updates in our repositories. <strong>I strongly suggest you centralize the application configuration in the early stages.</strong> It can be a separate service with GUI or just a JSON file stored in S3.</p><h2 id="9ca5">Canary deployments (big features)</h2><p id="8f5a">We are really happy with our current hosting solution which is Heroku, but during the summer we wanted to try something new. We quickly prepared Terraform configuration files and our CI/CD pipeline to support the new provider. It wouldn‚Äôt be wise to move all of our infrastructure to a new hosting in one go. We decided to pick one of the newsrooms in <em>Live</em> for which we were observing low traffic and simply deployed it there. The risk wasn‚Äôt big as deployments for <em>Live</em> are isolated.</p><p id="5667">Another interesting case where a single-tenant architecture can be helpful is when you are developing a big non-backwards compatible feature. We are currently working on such a thing in <em>Live</em>. During the release we will need to shut down the database and perform risky updates on it. We will start with a smaller tenant and gradually roll it out to others, fingers crossed ü§û.</p><h2 id="1d23">Business intelligence</h2><p id="5828">Our PM and clients often ask for all kinds of interesting data üíæ from our systems. Having one big relational database gives us the possibility to leverage the power of SQL and provide interesting insights in a blink of an eye. So this is how it‚Äôs done for <em>Comments</em>. For <em>Live</em> we needed to prepare a separate service that is responsible for gathering data from all of our databases. We needed to invest some time in building it and it doesn‚Äôt offer as much flexibility as a raw SQL solution.</p><h2 id="4d98"><strong>Reverse proxy</strong></h2><p id="60f5">To have one entry point for the system where each organization lives on a separate infrastructure per you will need to have a reverse proxy. That‚Äôs one additional component in your infrastructure. For <em>Live</em> we use Fastly both as a CDN and a reverse proxy. Using its domain-specific language we can implement the following logic:</p><figure><div></div><figcaption>Reverse proxy pseudocode.</figcaption></figure><p id="ce95">As a secondary solution we use Cloudfront together with a Lambda@Edge which is taking care of redirects.</p><h2 id="4309"><strong>Performance</strong></h2><p id="56ff">One of the first thoughts when developers think about a single-tenant architecture is that it is a more performant solution. Tenants won‚Äôt be sharing any resources between them so they will have more resources for themselves, right? And a thought came to me üí°. Would you prefer to have 20 shared instances or 2 instances per tenant, let‚Äôs say when supporting ten of them? I think 20 shared instances would help you distribute potential traffic spikes and autoscaling for them wouldn‚Äôt need to be aggressive. Response times should be the same for all and servers should be used much more efficiently. I would love to hear your opinions on that üëÇ. I know that I mentioned the NHL playoffs case but that was an extreme example and the <em>Comments</em> project was still in its early stages.</p><p id="df2c"><strong>Go with a multi-tenant architecture but with separate namespaces in the databases.</strong> This will allow you to have a tenant-agnostic application code. You won‚Äôt need to pass a tenant identifier around the codebase because you will have data isolation for free. It means less of conditional statements and no need for access checks to prevent cross-tenant actions. Much less ops work is also an advantage. If you are afraid that your relational database won‚Äôt keep up I can assure you that relational databases are more powerful than you think (Postgres FTW üöÄ, more about that in an upcoming article where I compared Redis, Dynamodb and Postgres). Focus more on optimizing your queries and models as well as on automatic reverts of different moving parts and a centralized configuration.</p></div></div></div>
  </body>
</html>
