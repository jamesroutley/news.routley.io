<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-06-29-improve-git-monorepo-performance-with-a-file-system-monitor/">Original</a>
    <h1>Improve Git monorepo performance with a file system monitor</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div>
    


<main role="main" id="post-65874">
  
<p>If you have a monorepo, you’ve probably already felt the pain of slow Git commands, such as <code><a href="https://git-scm.com/docs/git-status">git status</a></code> and <code><a href="https://git-scm.com/docs/git-add">git add</a></code>. These commands are slow because they need to search the entire worktree looking for changes. When the worktree is very large, Git needs to do a lot of work.</p>
<p>The Git file system monitor (FSMonitor) feature can speed up these commands by reducing the size of the search, and this can greatly reduce the pain of working in large worktrees. For example, this chart shows status times dropping to under a second on three different large worktrees when FSMonitor is enabled!</p>
<p><img src="https://github.blog/wp-content/uploads/2022/06/mono-1.png?resize=1024%2C419" alt="" width="1024" height="419" srcset="https://github.blog/wp-content/uploads/2022/06/mono-1.png?resize=1024%2C419?w=1200 1200w, https://github.blog/wp-content/uploads/2022/06/mono-1.png?resize=1024%2C419?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-1.png?resize=1024%2C419?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-1.png?resize=1024%2C419?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy" data-recalc-dims="1"/></p>
<p>In this article, I want to talk about the new builtin FSMonitor <code>git fsmonitor--daemon</code> added in Git version 2.37.0. This is easy to set up and use since it is “in the box” and does not require any third-party tooling nor additional software. It only requires a config change to enable it. It is currently available on macOS and Windows.</p>
<p>To enable the new builtin FSMonitor, just set <code><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corefsmonitor">core.fsmonitor</a></code> to <code>true</code>. A daemon will be started automatically in the background by the next Git command.</p>
<p>FSMonitor works well with <code><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-coreuntrackedCache">core.untrackedcache</a></code>, so we’ll also turn it on for the FSMonitor test runs. We’ll talk more about the untracked-cache later.</p>
<pre><code>$ time git status
On branch main
Your branch is up to date with &#39;origin/main&#39;.

It took 5.25 seconds to enumerate untracked files. &#39;status -uno&#39;
may speed it up, but you have to be careful not to forget to add
new files yourself (see &#39;git help status&#39;).
nothing to commit, working tree clean

real    0m17.941s
user    0m0.031s
sys     0m0.046s

$ git config core.fsmonitor true
$ git config core.untrackedcache true

$ time git status
On branch main
Your branch is up to date with &#39;origin/main&#39;.

It took 6.37 seconds to enumerate untracked files. &#39;status -uno&#39;
may speed it up, but you have to be careful not to forget to add
new files yourself (see &#39;git help status&#39;).
nothing to commit, working tree clean

real    0m19.767s
user    0m0.000s
sys     0m0.078s

$ time git status
On branch main
Your branch is up to date with &#39;origin/main&#39;.

nothing to commit, working tree clean

real    0m1.063s
user    0m0.000s
sys     0m0.093s

$ git fsmonitor--daemon status
fsmonitor-daemon is watching &#39;C:/work/chromium&#39;
</code></pre>
<p>_Note that when the daemon first starts up, it needs to synchronize with the state of the index, so the next <code>git status</code> command may be just as slow (or slightly slower) than before, but subsequent commands should be much faster.</p>
<p>In this article, I’ll introduce the new builtin FSMonitor feature and explain how it improves performance on very large worktrees.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>How FSMonitor improves performance</strong></p>
<p>Git has a “What changed while I wasn’t looking?” problem. That is, when you run a command that operates on the worktree, such as <code>git status</code>, it has to <em>discover</em> what has changed relative to the index. It does this by searching the entire worktree. Whether you immediately run it again or run it again tomorrow, it has to <em>rediscover</em> all of that same information by searching again. Whether you edit zero, one, or a million files in the mean time, the next <code>git status</code> command has to do the same amount of work to rediscover what (if anything) has changed.</p>
<p>The cost of this search is relatively fixed and is based upon the number of files (and directories) present in the worktree. In a monorepo, there might be millions of files in the worktree, so this search can be very expensive.</p>
<p>What we really need is a way to focus on the changed files without searching the entire worktree.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>How FSMonitor works</strong></p>
<p>FSMonitor is a long-running daemon or service process.</p>
<ul>
<li>It registers with the operating system to receive change notification events on files and directories.</li>
<li>It adds the pathnames of those files and directories to an in-memory, time-sorted queue.</li>
<li>It listens for IPC connections from client processes, such as <code>git status</code>.</li>
<li>It responds to client requests for a list of files and directories that have been modified recently.</li>
</ul>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-replace.png?resize=1009%2C782" alt="" width="1009" height="782" srcset="https://github.blog/wp-content/uploads/2022/06/mono-replace.png?resize=1009%2C782?w=1009 1009w, https://github.blog/wp-content/uploads/2022/06/mono-replace.png?resize=1009%2C782?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-replace.png?resize=1009%2C782?w=768 768w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>FSMonitor must continuously watch the worktree to have a complete view of all file system changes, especially ones that happen between Git commands. So it must be a long-running daemon or service process and not associated with an individual Git command instance. And thus, it cannot be a traditional Git hook (child) process. This design does allow it to service multiple (possibly concurrent) Git commands.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>FSMonitor Synchronization</strong></p>
<p>FSMonitor has the concept of a “token”:</p>
<ul>
<li>A token is an opaque string defined by FSMonitor and can be thought of as a globally unique sequence number or timestamp.</li>
<li>FSMonitor creates a new token whenever file system events happen.</li>
<li>FSMonitor groups file system changes into sets by these ordered tokens.</li>
<li>A Git client command sends a (previously generated) token to FSMonitor to request the list of pathnames that have changed, since FSMonitor created that token.</li>
<li>FSMonitor includes the current token in every response. The response contains the list of pathnames that changed between the sent and received tokens.</li>
</ul>
<p><code>git status</code> writes the received token into the index with other FSMonitor data before it exits. The next <code>git status</code> command reads the previous token (along with the other FSMonitor data) and asks FSMonitor what changed since the previous token.</p>
<p>Earlier, I said a token is like a timestamp, but it also includes other fields to prevent incomplete responses:</p>
<ul>
<li>The FSMonitor process id (PID): This identifies the daemon instance that created the token. If the PID in a client’s request token does not match the currently running daemon, we must assume that the client is asking for data on file system events generated before the current daemon instance was started.</li>
<li>A file system synchronization id (SID): This identifies the most recent synchronization with the file system. The operating system may drop file system notification events during heavy load. The daemon itself may get overloaded, fall behind, and drop events. Either way, events were dropped, and there is a gap in our event data. When this happens, the daemon must “declare bankruptcy” and (conceptually) restart with a new SID. If the SID in a client’s request token does not match the daemon’s curent SID, we must assume that the client is asking for data spanning such a resync.</li>
</ul>
<p>In both cases, a normal response from the daemon would be incomplete because of gaps in the data. Instead, the daemon responds with a trivial (“assume everything was changed”) response and a new token. This will cause the current Git client command to do a regular scan of the worktree (as if FSMonitor were not enabled), but let future client commands be fast again.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>Types of files in your worktree</strong></p>
<p>When <code>git status</code> examines the worktree, it looks for tracked, untracked, and ignored files.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-3.png?resize=1024%2C591" alt="" width="1024" height="591" srcset="https://github.blog/wp-content/uploads/2022/06/mono-3.png?resize=1024%2C591?w=1043 1043w, https://github.blog/wp-content/uploads/2022/06/mono-3.png?resize=1024%2C591?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-3.png?resize=1024%2C591?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-3.png?resize=1024%2C591?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Tracked files are files under version control. These are files that Git knows about. These are files that Git will create in your worktree when you do a <code>git checkout</code>. The file in the worktree may or may not match the version listed in the index. When different, we say that there is an unstaged change. (This is independent of whether the staged version matches the version referenced in the HEAD commit.)</p>
<p>Untracked files are just that: untracked. They are not under version control. Git does not know about them. They may be temporary files or new source files that you have not yet told Git to care about (using <code>git add</code>).</p>
<p>Ignored files are a special class of untracked files. These are usually temporary files or compiler-generated files. While Git will ignore them in commands like <code>git add</code>, Git will see them while searching the worktree and possibly slow it down.</p>
<p>Normally, <code>git status</code> does not print ignored files, but we’ll turn it on for this example so that we can see all four types of files.</p>
<pre><code>$ git status --ignored
On branch master
Changes to be committed:
  (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage)
    modified:   README

Changes not staged for commit:
  (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)
  (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory)
    modified:   README
    modified:   main.c

Untracked files:
  (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed)
    new-file.c

Ignored files:
  (use &#34;git add -f &lt;file&gt;...&#34; to include in what will be committed)
    new-file.obj
</code></pre>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>The expensive worktree searches</strong></p>
<p>During the worktree search, Git treats tracked and untracked files in two distinct phases. I’ll talk about each phase in detail in later sections.</p>
<ol>
<li>In “refresh_index,” Git looks for unstaged changes. That is, changes to tracked files that have not been staged (added) to the index. This potentially requires looking at each tracked file in the worktree and comparing its contents with the index version.</li>
<li>In “untracked,” Git searches the worktree for untracked files and filters out tracked and ignored files. This potentially requires completely searching each subdirectory in the worktree.</li>
</ol>
<p>There is a third phase where Git compares the index and the HEAD commit to look for staged changes, but this phase is very fast, because it is inspecting internal data structures that are designed for this comparision. It avoids the significant number of system calls that are required to inspect the worktree, so we won’t worry about it here.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>A detailed example</strong></p>
<p>The chart in the introduction showed status times before and after FSMonitor was enabled. Let’s revisit that chart and fill in some details.</p>
<p>I collected performance data for <code>git status</code> on worktrees from three large repositories. There were no modified files, and <code>git status</code> was clean.</p>
<ol>
<li>The <a href="https://github.com/chromium/chromium.git">Chromium</a> repository contains about 400K files and 33K directories.</li>
<li>A synthetic repository containing 1M files and 111K directories.</li>
<li>A synthetic repository containing 2M files and 111K directories.</li>
</ol>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-4.png?resize=1024%2C325" alt="" width="1024" height="325" srcset="https://github.blog/wp-content/uploads/2022/06/mono-4.png?resize=1024%2C325?w=1200 1200w, https://github.blog/wp-content/uploads/2022/06/mono-4.png?resize=1024%2C325?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-4.png?resize=1024%2C325?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-4.png?resize=1024%2C325?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Here we can see that when FSMonitor is not present, the commands took from 17 to 85 seconds. However, when FSMonitor was enabled the commands took less than 1 second.</p>
<p>Each bar shows the total run time of the <code>git status</code> commands. Within each bar, the total time is divided into parts based on <a href="https://devblogs.microsoft.com/devops/a-deep-dive-into-git-performance-using-trace2/">performance data gathered by Git’s trace2 library</a> to highlight the important or expensive steps within the commands.</p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>refresh_index</strong>
<p><strong>with Preload</strong>
   </p></td>
<td><strong>Untracked</strong>
<p>
<strong>without Untracked-Cache</strong>
   </p></td>
<td><strong>Remainder</strong>
   </td>
<td><strong>Total</strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>12.3s
   </td>
<td>5.1s
   </td>
<td>0.16s
   </td>
<td>17.6s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>30.2s
   </td>
<td>10.5s
   </td>
<td>0.36s
   </td>
<td>41.1s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>73.2s
   </td>
<td>11.2s
   </td>
<td>0.64s
   </td>
<td>85.1s
   </td>
</tr>
</tbody></table></div>
<p>The top three bars are without FSMonitor. We can see that most of the time was spent in the <code>refresh_index</code> and <code>untracked</code> columns. I’ll explain what these are in a minute. In the <code>remainder</code> column, I’ve subtracted those two from the total run time. This portion barely shows up on these bars, so the key to speeding up <code>git status</code> is to attack those two phases.</p>
<p>The bottom three bars on the above chart have FSMonitor and the untracked-cache enabled. They show a dramatic performance improvement. On this chart these bars are barely visible, so let’s zoom in on them.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-5.png?resize=1024%2C325" alt="" width="1024" height="325" srcset="https://github.blog/wp-content/uploads/2022/06/mono-5.png?resize=1024%2C325?w=1200 1200w, https://github.blog/wp-content/uploads/2022/06/mono-5.png?resize=1024%2C325?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-5.png?resize=1024%2C325?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-5.png?resize=1024%2C325?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>This chart rescales the FSMonitor bars by 100X. The <code>refresh_index</code> and <code>untracked</code> columns are still present but greatly reduced thanks to FSMonitor.</p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>refresh_index</strong>
<p><strong>with FSMonitor</strong>
   </p></td>
<td><strong>Untracked</strong>
<p>
<strong>with FSMonitor</strong></p>
<p>
<strong>and Untracked-Cache</strong>
   </p></td>
<td><strong>Remainder</strong>
   </td>
<td><strong>Total</strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>0.024s
   </td>
<td>0.519s
   </td>
<td>0.284s
   </td>
<td>0.827s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>0.050s
   </td>
<td>0.112s
   </td>
<td>0.428s
   </td>
<td>0.590s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>0.096s
   </td>
<td>0.082s
   </td>
<td>0.572s
   </td>
<td>0.750s
   </td>
</tr>
</tbody></table></div>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>This is bigger than just status</strong></p>
<p>So far I’ve only talked about <code>git status</code>, since it is the command that we probably use the most and are always thinking about when talking about performance relative to the state and size of the worktree. But it is just one of many affected commands:</p>
<ul>
<li><code>git diff</code> does the same search, but uses the changed files it finds to print a difference in the worktree and your index.</li>
<li><code>git add .</code> does the same search, but it stages each changed file it finds.</li>
<li><code>git restore</code> and <code>git checkout</code> do the same search to decide the files to be replaced.</li>
</ul>
<p>So, for simplicity, I’ll just talk about <code>git status</code>, but keep in mind that this approach benefits many other commands, since the cost of actually staging, overwriting, or reporting the change is relatively trivial by comparison — the real performance cost in these commands (as the above charts show) is the time it takes to simply <em>find</em> the changed files in the worktree.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>Phase 1: refresh_index</strong></p>
<p>The index contains an “index entry” with information for each tracked file. The <code>git ls-files</code> command can show us what that list looks like. I’ll truncate the output to only show a couple of files. In a monorepo, this list might contain millions of entries.</p>
<pre><code>$ git ls-files --stage --debug
[...]
100644 7ce4f05bae8120d9fa258e854a8669f6ea9cb7b1 0   README.md
  ctime: 1646085519:36302551
  mtime: 1646085519:36302551
  dev: 16777220 ino: 180738404
  uid: 502  gid: 20
  size: 3639    flags: 0
[...]
100644 5f1623baadde79a0771e7601dcea3c8f2b989ed9 0   Makefile
  ctime: 1648154224:994917866
  mtime: 1648154224:994917866
  dev: 16777221 ino: 182328550
  uid: 502  gid: 20
  size: 110149  flags: 0
[...]
</code></pre>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Scanning tracked files for unstaged changes</strong></p>
<p>Let’s assume at the beginning of <code>refresh_index</code> that all index entries are “unmarked” — meaning that we don’t know yet whether or not the worktree file contains an unstaged change. And we “mark” an index entry when we know the answer (either way).</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-6.png?resize=739%2C897" alt="" width="739" height="897" srcset="https://github.blog/wp-content/uploads/2022/06/mono-6.png?resize=739%2C897?w=739 739w, https://github.blog/wp-content/uploads/2022/06/mono-6.png?resize=739%2C897?w=247 247w" sizes="(max-width: 739px) 100vw, 739px" data-recalc-dims="1"/></p>
<p>To determine if an individual tracked file has an unstaged change, it must be “scanned”. That is, Git must read, clean, hash the current contents of the file, and compare the computed hash value with the hash value stored in the index. If the hashes are the same, we mark the index entry as “valid”. If they are different, we mark it as an unstaged change.</p>
<p>In theory, <code>refresh_index</code> must repeat this for each tracked file in the index.</p>
<p>As you can see, each individual file that we have to scan will take time and if we have to do a “full scan”, it will be very slow, especially if we have to do it for millions of files. For example, on the Chromium worktree, when I forced a full scan it took almost an hour.</p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>Full Scan</strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>3072s
   </td>
</tr>
</tbody></table></div>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>refresh_index shortcuts</strong></p>
<p>Since doing a full scan of the worktree is so expensive, Git has developed various shortcuts to avoid scanning whenever possible to increase the performance of <code>refresh_index</code>.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-7.png?resize=671%2C962" alt="" width="671" height="962" srcset="https://github.blog/wp-content/uploads/2022/06/mono-7.png?resize=671%2C962?w=671 671w, https://github.blog/wp-content/uploads/2022/06/mono-7.png?resize=671%2C962?w=209 209w" sizes="(max-width: 671px) 100vw, 671px" data-recalc-dims="1"/></p>
<p>For discussion purposes, I’m going to describe them here as independent steps rather than somewhat intertwined steps. And I’m going to start from the bottom, because the goal of each shortcut is to look at unmarked index entries, mark them if they can, and make less work for the next (more expensive) step. So in a perfect world, the final “full scan” would have nothing to do, because all of the index entries have already been marked, and there are no unmarked entries remaining.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-8.png?resize=1024%2C364" alt="" width="1024" height="364" srcset="https://github.blog/wp-content/uploads/2022/06/mono-8.png?resize=1024%2C364?w=1200 1200w, https://github.blog/wp-content/uploads/2022/06/mono-8.png?resize=1024%2C364?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-8.png?resize=1024%2C364?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-8.png?resize=1024%2C364?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>In the above chart, we can see the cummulative effects of these shortcuts.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Shortcut: refresh_index with lstat()</strong></p>
<p><a href="https://github.com/git/git/commit/711cf3a026a539f68ab647e012f145a03e12a5e7">The “lstat() shortcut” was created very early</a> in the Git project.</p>
<p>To avoid actually scanning every tracked file on every <code>git status</code> command, Git relies on a file’s last modification time (mtime) to tell when a file was last changed. File mtimes are updated when files are created or edited. We can read the mtime using the <code>lstat()</code> system call.</p>
<p>When Git does a <code>git checkout</code> or <code>git add</code>, it writes each worktree file’s current mtime into its index entry. These serve as the reference mtimes for future <code>git status</code> commands.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-9.png?resize=760%2C550" alt="" width="760" height="550" srcset="https://github.blog/wp-content/uploads/2022/06/mono-9.png?resize=760%2C550?w=760 760w, https://github.blog/wp-content/uploads/2022/06/mono-9.png?resize=760%2C550?w=300 300w" sizes="(max-width: 760px) 100vw, 760px" data-recalc-dims="1"/></p>
<p>Then, during a later <code>git status</code>, Git checks the current mtime against the reference mtime (for each unmarked file). If they are identical, Git knows that the file content hasn’t changed and marks the index entry valid (so that the next step will avoid it). If the mtimes are different, this step leaves the index entry unmarked for the next step.</p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>refresh_index with <code>lstat()</code></strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>26.9s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>66.9s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>136.6s
   </td>
</tr>
</tbody></table></div>
<p>The above table shows the time in seconds taken to call <code>lstat()</code> on every file in the worktree. For the Chromium worktree, we’ve cut the time of <code>refresh_index</code> from 50 minutes to 27 seconds.</p>
<p>Using mtimes is much faster than always scanning each file, but Git still has to <code>lstat()</code> every tracked file during the search, and that can still be very slow when there are millions of files.</p>
<p>In this experiment, there were no modifications in the worktree, and the index was up to date, so this step marked all of the index entries as valid and the “scan all unmarked” step had nothing to do. So the time reported here is essentially just the time to call <code>lstat()</code> in a loop.</p>
<p>This is better than before, but even though we are only doing an <code>lstat()</code>, <code>git status</code> is still spending more than 26 seconds in this step. We can do better.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Shortcut: refresh_index with preload</strong></p>
<p><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corepreloadIndex">The core.preloadindex config option</a> is an optional feature in Git. <a href="https://github.com/git/git/commit/671c9b7e315db89081cc69f83a8f405e4aca37bc">The option was introduced</a> in version 1.6 and was enabled by default in 2.1.0 on platforms that support threading.</p>
<p>This step partitions the index into equal-sized chunks and distributes it to multiple threads. Each thread does the <code>lstat()</code> shortcut on their partition. And like before, index entries with different mtimes are left unmarked for the next step in the process.</p>
<p>The preload step does not change the amount of file scanning that we need to do in the final step, it just distributes the <code>lstat()</code> calls across all of your cores.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-10.png?resize=1024%2C853" alt="" width="1024" height="853" srcset="https://github.blog/wp-content/uploads/2022/06/mono-10.png?resize=1024%2C853?w=1212 1212w, https://github.blog/wp-content/uploads/2022/06/mono-10.png?resize=1024%2C853?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-10.png?resize=1024%2C853?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-10.png?resize=1024%2C853?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>refresh_index with Preload</strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>12.3s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>30.2s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>73.2s
   </td>
</tr>
</tbody></table></div>
<p>With the preload shortcut <code>git status</code> is about twice as fast on my 4-core Windows laptop, but it is still expensive.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Shortcut: refresh_index with FSMonitor</strong></p>
<p>When FSMonitor is enabled:</p>
<ol>
<li>The <code>git fsmonitor--daemon</code> is started in the background and listens for file system change notification events from the operating system for files within the worktree. This includes file creations, deletions, and modifications. If the daemon gets an event for a file, that file probably has an updated mtime. Said another way, if a file mtime changes, the daemon will get an event for it.</li>
<li>The FSMonitor index extension is added to the index to keep track of FSMonitor and <code>git status</code> data between <code>git status</code> commands. The extension contains an FSMonitor token and a bitmap listing the files that were marked valid by the previous <code>git status</code> command (and relative to that token).</li>
<li>The next <code>git status</code> command will use this bitmap to initialize the marked state of the index entries. That is, the previous Git command saved the marked state of the index entries in the bitmap and this command restores them — rather than initializing them all as unmarked.</li>
<li>It will then ask the daemon for a list of files that have had file system events <em>since</em> the token and <em>unmark</em> each of them. FSMonitor tells us the exact set of files that have been modified in some way since the last command, so those are the only files that we should need to visit.</li>
</ol>
<p>At this point, all of the unchanged files should be marked valid. Only files that may have changed should be unmarked. This sets up the next shortcut step to have very little to do.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-11.png?resize=800%2C1042" alt="" width="800" height="1042" srcset="https://github.blog/wp-content/uploads/2022/06/mono-11.png?resize=800%2C1042?w=800 800w, https://github.blog/wp-content/uploads/2022/06/mono-11.png?resize=800%2C1042?w=230 230w, https://github.blog/wp-content/uploads/2022/06/mono-11.png?resize=800%2C1042?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-11.png?resize=800%2C1042?w=786 786w" sizes="(max-width: 800px) 100vw, 800px" data-recalc-dims="1"/></p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>Query FSMonitor</strong>
   </td>
<td><strong>refresh_index with FSMonitor</strong>
   </td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>0.017s
   </td>
<td>0.024s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>0.002s
   </td>
<td>0.050s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>0.002s
   </td>
<td>0.096s
   </td>
</tr>
</tbody></table></div>
<p>This table shows that <code>refresh_index</code> is now very fast since we don’t need to any searching. And the time to request the list of files over IPC is well worth the complex setup.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>Phase 2: untracked</strong></p>
<p>The “untracked” phase is a search for anything in the worktree that Git does not know about. These are files and directories that are not under version control. This requires a full search of the worktree.</p>
<p>Conceptually, this looks like:</p>
<ol>
<li>A full recursive enumeration of every directory in the worktree.</li>
<li>Build a complete list of the pathnames of every file and directory within the worktree.</li>
<li>Take each found pathname and do a binary search in the index for a corresponding index entry. If one is found, the pathname can be omitted from the list, because it refers to a tracked file.
<ol>
<li>On case insensitive systems, such as Windows and macOS, a case insensitive hash table must be constructed from the case sensitive index entries and used to lookup the pathnames instead of the binary search.</li>
</ol>
</li>
<li>Take each remaining pathname and apply <code>.gitignore</code> pattern matching rules. If a match is found, then the pathname is an ignored file and is omitted from the list. This pattern matching can be very expensive if there are lots of rules.</li>
<li>The final resulting list is the set of untracked files.</li>
</ol>
<p>This search can be very expensive on monorepos and frequently leads to the following advice message:</p>
<pre><code>$ git status
On branch main
Your branch is up to date with &#39;origin/main&#39;.

It took 5.12 seconds to enumerate untracked files. &#39;status -uno&#39;
may speed it up, but you have to be careful not to forget to add
new files yourself (see &#39;git help status&#39;).
nothing to commit, working tree clean
</code></pre>
<p>Normally, the complete discovery of the set of untracked files must be repeated for each command unless the <code>[core.untrackedcache](https://git-scm.com/docs/git-config#Documentation/git-config.txt-coreuntrackedCache)</code> feature is enabled.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>The untracked-cache</strong></p>
<p>The untracked-cache feature adds an extension to the index that remembers the results of the untracked search. This includes a record for each subdirectory, its mtime, and a list of the untracked files within it.</p>
<p>With the untracked-cache enabled, Git still needs to <code>lstat()</code> every directory in the worktree to confirm that the cached record is still valid.</p>
<p>If the mtimes match:</p>
<ul>
<li>Git avoids calling <code>opendir()</code> and <code>readdir()</code> to enumerate the files within the directory,</li>
<li>and just uses the existing list of untracked files from the cache record.</li>
</ul>
<p>If the mtimes don’t match:</p>
<ul>
<li>Git needs to invalidate the untracked-cache entry.</li>
<li>Actually open and read the directory contents.</li>
<li>Call <code>lstat()</code> on each file or subdirectory within the directory to determine if it is a file or directory and possibly invalidate untracked-cache entries for any subdirectories.</li>
<li>Use the file pathname to do tracked file filtering.</li>
<li>Use the file pathname to do ignored file filtering</li>
<li>Update the list of untracked files in the untracked-cache entry.</li>
</ul>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>How FSMonitor helps the untracked-cache</strong></p>
<p>When FSMonitor is also enabled, we can avoid the <code>lstat()</code> calls, because FSMonitor tells us the set of directories that may have an updated mtime, so we don’t need to search for them.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/06/mono-12.png?resize=1024%2C381" alt="" width="1024" height="381" srcset="https://github.blog/wp-content/uploads/2022/06/mono-12.png?resize=1024%2C381?w=1200 1200w, https://github.blog/wp-content/uploads/2022/06/mono-12.png?resize=1024%2C381?w=300 300w, https://github.blog/wp-content/uploads/2022/06/mono-12.png?resize=1024%2C381?w=768 768w, https://github.blog/wp-content/uploads/2022/06/mono-12.png?resize=1024%2C381?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<div><table>
<tbody><tr>
<td><strong>Worktree</strong>
   </td>
<td><strong>Files</strong>
   </td>
<td><strong>Untracked</strong>
<p><strong>without Untracked-Cache</strong>
   </p></td>
<td><strong>Untracked</strong>
<p>
<strong>with Untracked-Cache</strong>
   </p></td>
<td><strong>Untracked</strong>
<p>
<strong>with Untracked-Cache</strong></p>
<p>
<strong>and FSMonitor</strong>
   </p></td>
</tr>
<tr>
<td>Chromium
   </td>
<td>393K
   </td>
<td>5.1s
   </td>
<td>2.3s
   </td>
<td>0.83s
   </td>
</tr>
<tr>
<td>Synthetic 1M
   </td>
<td>1M
   </td>
<td>10.5s
   </td>
<td>6.3s
   </td>
<td>0.59s
   </td>
</tr>
<tr>
<td>Synthetic 2M
   </td>
<td>2M
   </td>
<td>11.2s
   </td>
<td>6.6s
   </td>
<td>0.75s
   </td>
</tr>
</tbody></table></div>
<p>By itself, the untracked-cache feature gives roughly a 2X speed up in the search for untracked files. Use both the untracked-cache and FSMonitor, and we see a 10X speedup.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>A note about ignored files</strong></p>
<p>You can improve Git performance by not storing temporary files, such as compiler intermediate files, inside your worktree.</p>
<p>During the untracked search, Git first eliminates the tracked files from the candidate untracked list using the index. Git then uses the <code>.gitignore</code> pattern matching rules to eliminate the ignored files. Git’s performance will suffer if there are many rules and/or many temporary files.</p>
<p>For example, if there is a <code>*.o</code> for every source file and they are stored next to their source files, then every build will delete and recreate one or more object files and cause the mtime on their parent directories to change. Those mtime changes will cause <code>git status</code> to invalidate the corresponding untracked-cache entries and have to re-read and re-filter those directories — even if no source files actually changed. A large number of such temporary and uninteresting files can greatly affect the performance of these Git commands.</p>
<p>Keeping build artifacts out of your worktree is part of the <a href="https://github.com/microsoft/git/blob/HEAD/contrib/scalar/docs/philosophy.md">philosophy</a> of the <a href="https://devblogs.microsoft.com/devops/introducing-scalar/">Scalar Project</a>. Scalar introduced Git tooling to help you keep your worktree in <code><a href="https://github.com/microsoft/scalar/blob/master/docs/faq.md#why-does-scalar-clone-create-a-reposrc-folder">&lt;repo-name&gt;/src/</a></code> to make it easier for you to put these other files in <code>&lt;repo-name&gt;/bin/</code> or <code>&lt;repo-name&gt;/packages/</code>, for example.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>A note about sparse checkout</strong></p>
<p>So far, we’ve talked about optimizations to make Git work smarter and faster on worktree-related operations by caching data in the index and in various index extensions. Future commands are faster, because they don’t have to rediscover everything and therefore can avoid repeating unnecessary or redundant work. But we can only push that so far.</p>
<p>The <a href="https://git-scm.com/docs/git-sparse-checkout">Git sparse checkout</a> feature approaches worktree performance from another angle. With it, you can ask Git to <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/">only populate the files that you need</a>. The parts that you don’t need are simply not present. For example, if you only need 10% of the worktree to do your work, why populate the other 90% and force Git to search through them on every command?</p>
<p>Sparse checkout speeds the search for unstaged changes in <code>refresh_index</code> because:</p>
<ol>
<li>Since the unneeded files are not actually present on disk, they cannot have unstaged changes. So <code>refresh_index</code> can completely ignore them.</li>
<li>The index entries for unneeded files are pre-marked during <code>git checkout</code> with the <code>skip-worktree</code> bit, so they are never in an “unmarked” state. So those index entries are excluded from all of the <code>refresh_index</code> loops.</li>
</ol>
<p>Sparse checkout speeds the search for untracked files because:</p>
<ol>
<li>Since Git doesn’t know whether a directory contains untracked files until it searches it, the search for untracked files must visit every directory present in the worktree. Sparse checkout lets us avoid creating entire sub-trees or “cones” from the worktree. So there are fewer directories to visit.</li>
<li>The untracked-cache does not need to create, save, and restore untracked-cache entries for the unpopulated directories. So reading and writing the untracked-cache extension in the index is faster.</li>
</ol>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>External file system monitors</strong></p>
<p>So far we have only talked about Git’s builtin FSMonitor feature. Clients use the <a href="https://github.com/git/git/commit/861794b60d3a61822daf59bbde39a2a2e362738d">simple IPC</a> interface to communicate directly with <code>git fsmonitor--daemon</code> over a Unix domain socket or named pipe.</p>
<p>However, <a href="https://github.com/git/git/commit/883e248b8a0fd88773cb902ab8e91273eb147d07">Git added support</a> for an <a href="https://github.blog/2018-04-05-git-217-released/#speeding-up-status-with-watchman">external file system monitor</a> in version 2.16.0 using the <code>core.fsmonitor</code> hook. Here, clients communicate with a proxy child helper process through the hook interface, and it communicates with an external file system monitor process.</p>
<p>Conceptually, both types of file system monitors are identical. They include a long-running process that listens to the file system for changes and are able to respond to client requests for a list of recently changed files and directories. The response from both are used identically to update and modify the <code>refresh_index</code> and <code>untracked</code> searches. The only difference is in how the client talks to the service or daemon.</p>
<p>The original hook interface was useful, because it allowed Git to work with existing off-the-shelf tools and allowed the basic concepts within Git to be proven relatively quickly, confirm correct operation, and get a quick speed up.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Hook protocol versions</strong></p>
<p>The original 2.16.0 version of the hook API used protocol version 1. It was a timestamp-based query. The client would send a timestamp value, expressed as nanoseconds since January 1, 1970, and expect a list of the files that had changed since that timestamp.</p>
<p>Protocol version 1 has several race conditions and should not be used anymore. Protocol version 2 was <a href="https://github.com/git/git/commit/c9a33e5e5d7e124feb86ccff08ea466faff53b26">added in 2.26.0</a> to address these problems.</p>
<p><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corefsmonitorHookVersion">Protocol version 2</a> is based upon opaque tokens provided by the external file system monitor process. Clients make token-based queries that are relative to a previously issued token. Instead of making absolute requests, clients ask what has changed since their last request. The format and content of the token is defined by the external file system monitor, such as Watchman, and is treated as an opaque string by Git client commands.</p>
<p>The hook protocol is not used by the builtin FSMonitor.</p>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Using Watchman and the sample hook script</strong></p>
<p><a href="https://facebook.github.io/watchman/">Watchman</a> is a popular external file system monitor tool and a <a href="https://github.com/git/git/blob/master/templates/hooks--fsmonitor-watchman.sample">Watchman-compatible hook script</a> is included with Git and copied into new worktrees during <code>git init</code>.</p>
<p>To enable it:</p>
<ol>
<li><a href="https://facebook.github.io/watchman/docs/install.html">Install</a> Watchman on your system.</li>
<li>Tell Watchman to watch your worktree:</li>
</ol>
<pre><code>$ watchman watch .
{
    &#34;version&#34;: &#34;2022.01.31.00&#34;,
    &#34;watch&#34;: &#34;/Users/jeffhost/work/chromium&#34;,
    &#34;watcher&#34;: &#34;fsevents&#34;
}

</code></pre>
<ol>
<li>Install the sample hook script to teach Git how to talk to Watchman:</li>
</ol>
<pre><code>$ cp .git/hooks/fsmonitor-watchman.sample .git/hooks/query-watchman

</code></pre>
<ol>
<li>Tell Git to use the hook:</li>
</ol>
<pre><code>$ git config core.fsmonitor .git/hooks/query-watchman
</code></pre>
<h3 id=""> <a href="#" aria-label=" "></a></h3>
<p><strong>Using Watchman with a custom hook</strong></p>
<p>The hook interface is not limited to running shell or Perl scripts. The included sample hook script is just an example implementation. Engineers at Dropbox described how they were able to <a href="https://dropbox.tech/application/speeding-up-a-git-monorepo-at-dropbox-with--200-lines-of-code">speed up Git</a> with a custom hook executable.</p>
<h2 id=""> <a href="#" aria-label=" "></a></h2>
<p><strong>Final Remarks</strong></p>
<p>In this article, we have seen how a file system monitor can speed up commands like <code>git status</code> by solving the “discovery” problem and eliminating the need to search the worktree for changes in every command. This greatly reduces the pain of working with monorepos.</p>
<p>This feature was created in two efforts:</p>
<ol>
<li>First, Git was taught to work with existing off-the-shelf tools, like Watchman. This allowed the basic concepts to be proven relatively quickly. And for users who already use Watchman for other purposes, it allows Git to efficiently interoperate with them.</li>
<li>Second, we brought the feature “in the box” to reduce the setup complexity and third-party dependencies, which some users may find useful. It also lets us consider adding Git-specific features that a generic monitoring tool might not want, such as understanding ignored files and omitting them from the service’s response.</li>
</ol>
<p>Having both options available lets users choose the best solution for their needs.</p>
<p>Regardless of which type of file system monitor you use, it will help make your monorepos more usable.</p>

      
  </main>


  </div>
</div></div>
  </body>
</html>
