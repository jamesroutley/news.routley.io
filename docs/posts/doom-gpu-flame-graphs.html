<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brendangregg.com/blog/2025-05-01/doom-gpu-flame-graphs.html">Original</a>
    <h1>Doom GPU Flame Graphs</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://www.brendangregg.com/blog/2024-10-29/ai-flame-graphs.html">AI Flame Graphs</a> are now <a href="https://github.com/intel/iaprof">open source</a> and include Intel Battlemage GPU support, which means it can also generate full-stack GPU flame graphs for providing new insights into gaming performance, especially when coupled with <a href="https://www.brendangregg.com/flamescope.html">FlameScope</a> (an older open source project of mine). Here&#39;s an example of GZDoom, and I&#39;ll start with flame scopes for both CPU and GPU utilization, with details annotated:</p>

<center><a href="https://www.brendangregg.com/blog/images/2025/flamescopes1.png"><img src="https://www.brendangregg.com/blog/images/2025/flamescopes1.png" width="700"/></a></center>

<p>(Here are the raw <a href="https://www.brendangregg.com/blog/images/2025/cpu_flamescope.png">CPU</a> and <a href="https://www.brendangregg.com/blog/images/2025/gpu_flamescope.png">GPU</a> versions.) FlameScope shows a subsecond-offset heatmap of profile samples, where each column is one second (in this example, made up of 50 x 20ms blocks) and the color depth represents the number of samples, revealing variance and perturbation that you can select to generate a flame graph just for that time range. Update: the row size can be ajusted (it is limited by the sample rate captured in the profile), e.g., you could generate 60 rows to match 60fps games.</p>

<p>Putting these CPU and GPU flame scopes side by side has enabled your eyes to do pattern matching to solve what would otherwise be a time-consuming task of performance correlation. The gaps in the GPU flame scope on the right – where the GPU was not doing much work – match the heavier periods of CPU work on the left.</p>

<h2>CPU Analysis</h2>

<p>FlameScope lets us click on the interesting periods. By selecting one of the CPU shader compilation stripes we get the flame graph just for that range:</p>

<center><a href="https://www.brendangregg.com/blog/images/2025/cpuflamegraph_shader1.png"><img src="https://www.brendangregg.com/blog/images/2025/cpuflamegraph_shader1.png" width="700"/></a></center>

<p>This is brilliant, and we can see exactly why the CPUs were busy for about 180 ms (the vertical length of the red stripe): it&#39;s doing compilation of GPU shaders and some NIR preprocessing (optimizations to the <a href="https://docs.mesa3d.org/nir/index.html">NIR intermediate representation</a> that Mesa uses internally). If you are new to flame graphs, you look for the widest towers and optimize them first. Here is the <a href="https://www.brendangregg.com/blog/images/2025/cpu_flamegraph.svg">interactive SVG</a>.</p>

<p>CPU flame graphs and CPU flame scope aren&#39;t new (from <a href="https://www.brendangregg.com/flamegraphs.html">2011</a> and <a href="https://www.brendangregg.com/flamescope.html">2018</a>, both open source). What is new is full-stack <strong>GPU</strong> flame graphs and <strong>GPU</strong> flame scope.</p>

<h2>GPU Analysis</h2>

<div><center><img src="https://www.brendangregg.com/blog/images/2025/gpuflamescope_highlight.png" width="118"/></center></div>

<p>Interesting details can also be selected in the GPU FlameScope for generating GPU flame graphs.
This example selects the &#34;room 3&#34; range, which is a room in the Doom map that contains hundreds of enemies.
The <SPAN color="#00bb00">green</SPAN> frames are the actual instructions running on the GPU, <SPAN color="#008888">aqua</SPAN> shows the source for these functions, and <SPAN color="#bb0000">red</SPAN> (C) and <SPAN color="#888800">yellow</SPAN> (C++) show the CPU code paths that initiated the GPU programs. The <SPAN color="#808080">gray</SPAN> &#34;-&#34; frames just help highlight the boundary between CPU and GPU code. (This is similar to what I described in the <a href="https://www.brendangregg.com/blog/2024-10-29/ai-flame-graphs.html">AI flame graphs</a> post, which included extra frames for kernel code.) The x-axis is proportional to cost, so you look for the widest things and find ways to reduce them.</p>

<center><p><a href="https://www.brendangregg.com/blog/images/2025/gpuflamegraph_title.png"><img src="https://www.brendangregg.com/blog/images/2025/gpuflamegraph_title.png" width="700"/></a>
</p></center>

<p>I&#39;ve included the <a href="https://www.brendangregg.com/blog/images/2025/gpu_flamegraph.svg">interactive SVG</a> version of this flame graph so you can mouse-over elements and click to zoom. (<a href="https://www.brendangregg.com/blog/images/2025/gpu_flamegraph.png">PNG</a> version.)</p>

<p>The GPU flame graph is split between stalls coming from rendering walls (41.4%), postprocessing effects (35.7%), stenciling (17.2%), and sprites (4.95%). The CPU stacks are further differentiated by the individual shaders that are causing stalls, along with the reasons for those stalls.</p>

<h2>GZDoom</h2>

<p>We picked <a href="https://zdoom.org/index">GZDoom</a> to try since it&#39;s an open source version of a well known game that runs on Linux (our profiler does not support Windows yet). Intel Battlemage makes light work of GZDoom, however, and since the GPU profile is stall-based we weren&#39;t getting many samples. We could have switched to a more modern and GPU-demanding game, but didn&#39;t have any great open source ideas, so I figured we&#39;d just make GZDoom more demanding. We built GPU demanding maps for GZDoom (I can&#39;t believe I have found a work-related reason to be using <a href="https://slade.mancubus.net/index.php?page=about">Slade</a>), and also set some Battlemage tunables to limit resources, magnifying the utilization of remaining resources.</p>

<center><a href="https://www.brendangregg.com/blog/images/2025/gzdoom_screenshot.jpg"><img src="https://www.brendangregg.com/blog/images/2025/gzdoom_screenshot.jpg" width="400"/></a></center>

<p>Our GZDoom test map has three rooms: room 1 is empty, room 2 is filled with torches, and room 3 is open with a large skybox and filled with enemies, including spawnpoints for Sergeants. This gave us a few different workloads to examine by walking between the rooms.</p>

<h2>Using iaprof: Intel&#39;s open source accelerator profiler</h2>

<p>The AI Flame Graph project is pioneering work, and has needed various changes to graphics compilers, libraries, and kernel drivers, not just the code but also how they are built. Since Intel has its own public cloud (the <a href="https://www.intel.com/content/www/us/en/developer/tools/tiber/ai-cloud.html">Intel® Tiber™ AI Cloud</a>) we can fix the software stack in advance so that for customers it &#34;just works.&#34; Check the <a href="https://github.com/intel/iaprof/releases">available releases</a>. It currently supports the Intel Max Series GPU.</p>

<p>If you aren&#39;t on the Intel cloud, or you wish to try this with Intel Battlemage, then it can require a lot of work to get the system ready to be profiled. Requirements include:</p>

<ul>
<li>A Linux system with superuser (root) access, so that eBPF and Intel eustalls can be used.</li>
<li>A newer Linux kernel with the latest Intel GPU drivers. For Intel Battlemage this means Linux 6.15+ with the Xe driver; For the Intel Max Series GPU it&#39;s Linux 5.15 with the i915 driver.</li>
<li>The Linux kernel built with Intel driver-specific eustall and eudebug interfaces (see the <a href="https://github.com/intel/iaprof/blob/main/README.md">github docs</a> for details). Some of these modifications are upstreamed in the latest versions of Linux and others are currently in progress. (These interfaces are made available by default on the Intel® Tiber™ AI Cloud.)
<div><center><img src="https://www.brendangregg.com/blog/images/2025/gzdoom_difficulty-crop.jpg" width="250"/></center></div></li>
<li>All system libraries or programs that are being profiled need to include frame pointers so that the full stacks are visible, including Intel&#39;s oneAPI and graphics libraries. For this example, GZDoom itself needed to be compiled with frame pointers and also all libraries used by GZDoom (glibc, etc.). This is getting easier in the lastest versions of Fedora and Ubuntu (e.g., Ubuntu 24.04 LTS) which are shipping system libraries with <a href="https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html">frame pointers</a> by default. But I&#39;d expect there will be applications and dependencies that don&#39;t have frame pointers yet, and need recompilation. If your flame graph has areas that are very short, one or two frames deep, this is why.</li>
</ul>

<p>If you are new to custom kernel builds and library tinkering, then getting this all working may feel like Nightmare! difficulty. Over time things will improve and gradually get easier: check the <a href="https://github.com/intel/iaprof/blob/main/README.md">github docs</a>. Intel can also develop a much easier version of this tool as part of a broader product offering and get it working on more than just Linux and Battlemage (either watch this space or, if you have an Intel rep, ask them to make it a priority).</p>

<p>Once you have it all working, you can run the <tt>iaprof</tt> command to profile the GPU. E.g.:</p>

<pre>git clone --recursive https://github.com/intel/iaprof
cd iaprof
make deps
make
sudo <b>iaprof record</b> &gt; profile.txt
cat profile.txt | iaprof flame &gt; flame.svg
</pre>

<p><tt>iaprof</tt> is modeled on the Linux <tt>perf</tt> command. (Maybe one day it&#39;ll become included in <tt>perf</tt> directly.) Thanks to Gabriel Muñoz for getting the work done to get this open sourced.</p>

<h2>FAQ and Future Work</h2>

<p>From the launch of AI flame graphs last year, I can guess what FAQ #1 will be: “What about NVIDIA?”. They do have flame graphs in Nsight Graphics for GPU workloads, although their flame graphs are currently shallow as it is GPU code only, and onerous to use as I believe it requires an interposer; on the plus side they have click-to-source. The new GPU profiling method we&#39;ve been developing allows for easy, everything, anytime profiling, like you expect from CPU profilers.</p>

<p>Future work will include github releases, more hardware support, and overhead reduction. We&#39;re the first to use eustalls in this way, and we need to add more optimization to reach our target of &lt;5% overhead, especially with the i915 driver.</p>

<h2>Conclusion</h2>

<p>We&#39;ve open sourced <a href="https://www.brendangregg.com/blog/2024-10-29/ai-flame-graphs.html">AI flame graphs</a> and tested it on new hardware, Intel Battlemage, and a non-AI workload: GZDoom (gaming). It&#39;s great to see a view of both CPU and GPU resources down to millisecond resolution, where we can see visual patterns in the flame scope heat maps that can be selected to produce flame graphs to show the code. We applied these new tools to GZDoom and explained GPU pauses by selecting the corresponding CPU burst and reading the flame graph, as well as GPU code use for arbitrary time windows.</p>

<p>While we have <a href="https://github.com/intel/iaprof">open sourced</a> this, getting it all running requires Intel hardware and Linux kernel and library tinkering – which can be a lot of work. (Actually playing Doom on Nightmare! difficulty may be easier.) This will get better over time. We look forward to seeing if anyone can fight their way through this work in the meantime and what new performance issues they can solve.</p>

<p>Authors: Brendan Gregg, Ben Olson, Brandon Kammerdiener, Gabriel Muñoz.</p>

</div></div>
  </body>
</html>
