<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iczelia.net/posts/snake-polyglot/">Original</a>
    <h1>This game is a single 13 KiB file that runs on Windows, Linux and in the Browser</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p>Not that long ago I became aware of Justine Tunney’s <a href="https://github.com/jart/cosmopolitan">cosmopolitan libc</a> project. It’s a toolkit that allows you to compile C source code into a single binary that runs natively on multiple operating systems, including Windows, Linux, various flavours of BSD, even including booters.</p>
<p>Unfortunately, back then the project didn’t seem to support GUI interfaces and produces quite swollen binaries. Hence I decided to take a stab at a similar (simpler? harder? up to you to decide) challenge: create a video game (&lt;16 KiB) that runs natively on Windows, Linux and in the Browser, all from a single source file.</p>
<h2 id="the-game">The Game<a href="#the-game" arialabel="Anchor">⌗</a> </h2>
<p>It’s a pretty standard Snake game with the same rules and interface on all platforms. You control a snake that grows longer as it eats food, and the goal is to avoid running into walls. The snake is controlled using either the arrow keys or WASD keys. It can be terminated via <code>ESC</code> (if permissible by the platform), reset via <code>R</code>, and paused via <code>P</code>. Spacebar starts the game.</p>
<p>The game keeps track of your score. Each piece of food eaten increases your score by 10 points, except yellow fruit (which spawns with a 15% chance) that gives you 20 points. Fruit spawns at a fixed rate and despawns after a certain time if not eaten. The despawn timer is proportional to the speed of the snake at the time of spawning, which itself is proportional to the snake’s length.</p>
<p>Once ten fruit are eaten, the game proceeds to the next level, randomizing the walls’ layout. The maze is created as to ensure that there is always a path from the snake’s head to any piece of food. The initial placement of the snake is also randomized, but always in a position that has at least five empty tiles in the direction the snake is facing.</p>
<p><a href="https://iczelia.net/static/snake/snake.com"><strong>Download the game here (13,772 bytes)</strong></a>.</p>
<h2 id="the-polyglot">The Polyglot<a href="#the-polyglot" arialabel="Anchor">⌗</a> </h2>
<p>I implemented the game three times in total: once in C for the i686 Visual C platform using WinAPI, once in C for the x86_64 Linux platform using clang and X11, and once in JavaScript for the browser using HTML5 Canvas. Each implementation is around 3-5 KiB in size when compiled/minified.</p>
<p>The Windows implementation was produced using a compressing script that prepends a decompressing stub. This stub has a quite unusual PE header that has many freely controllable bytes after the <code>MZ</code> signature. This allows us to place a shell script there that skips over the remainder of the file, rendering the (valid) PE executable runnable on Windows while also making the entire file a valid shell script, that will do (thus far) nothing on Linux.</p>
<p>Because the PE file is so awkward, we rely on Windows’ apphelp mechanism. Without compatibility mode, executing for the first time will yield the message:</p>
<blockquote>
<p>“The application was unable to start correctly (0xc0000005). Click OK to close the application.”</p>
</blockquote>
<p>Which should disappear after re-running.</p>
<p>The Linux implementation was produced using a similar approach; we use <code>lzma</code> for decompression and a small shell dropper that extracts the compressed ELF64 binary and runs it, skipping over the head and the tail of the file.</p>
<p>The HTML version is also packed and abuses the fact that browsers will happily process all the benign garbage at the start of the file before reaching the actual HTML content. Then we make it invisible/unobtrusive through a bit of CSS magic.</p>
<p>Finally, we concatenate all three files together in such an order that each platform will pick the correct part of the file to execute. The final file is exactly 13,312 bytes in size.</p>
<h2 id="technical-details">Technical Details<a href="#technical-details" arialabel="Anchor">⌗</a> </h2>

      </div></div></div>
  </body>
</html>
