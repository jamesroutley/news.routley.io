<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mattkeeter.com/blog/2025-01-20-guided/">Original</a>
    <h1>Guided by the beauty of our test suite</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<!-- End header -->
<h2>Guided by the beauty of our test suite</h2>





<p>This is a story about making software better.</p>
<p>Last summer, I published <a href="https://www.mattkeeter.com/projects/raven">Raven</a>, an independent implementation
of the <a href="https://wiki.xxiivv.com/site/uxn.html">Uxn CPU</a> and
<a href="https://wiki.xxiivv.com/site/varvara.html">Varavara ordinator</a>.
In short, this is a <strong>fictional computer</strong> designed for cross-platform
portability: programs targetting it can be run on any platform that implements
the specification.</p>
<p>Here&#39;s my implementation running the
<a href="https://wiki.xxiivv.com/site/catclock.html">catclock demo</a>:</p>
<p><img src="https://www.mattkeeter.com/blog/2025-01-20-guided/catclock.png" alt="An application window showing a cat holding a clock"/></p>
<p>Earlier this week, a kind contributor opened a
<a href="https://github.com/mkeeter/raven/pull/4">few</a>
<a href="https://github.com/mkeeter/raven/pull/5">PRs</a> to make the system work
better with <a href="https://github.com/gardenappl/svitlyna/">their image viewer</a>.
They also complimented the performance of the system, saying</p>
<blockquote>
<p>I can happily say that with this fix, svitlyna runs almost 50% faster than
with uxn11, and that&#39;s on AMD64, meaning this is running without optimized
assembly. I&#39;m really impressed!</p>
</blockquote>
<p>Given the appreciative words, I was well motivated to review their PRs!</p>
<p>I hadn&#39;t touched the code since July of 2024, so it took me a little while to
get up to speed.  I had previously done ad-hoc testing while deeply immersed in
the system; coming back months later, it was hard to touch the code and remain
confident that I hadn&#39;t introduced any new issues.</p>
<p>Over the long weekend, I set up <strong>infrastructure</strong> to alleviate this lack of
confidence, and I&#39;d like to tell you about it.  Some of it is table stakes (CI
testing on PRs), but there are also a few more exotic tricks (fuzzing and
statically preventing panics).</p>
<h3>Github CI</h3>
<p>This one is pretty basic: I set up a Github Actions job to run on pull requests.
I won&#39;t bore you with the
<a href="https://github.com/mkeeter/raven/blob/main/.github/workflows/check.yml">entire YAML file</a>,
but it does a typical set of checks:</p>
<ul>
<li>Build and test across all native platforms (macOS, Linux, Windows)</li>
<li>Confirm that the WebAssembly build completes without errors</li>
<li>Run Clippy on all platforms</li>
<li>Make sure that the code is <code>rustfmt</code> clean</li>
</ul>
<p>There were two surprises here.  The first surprise was the sad state of Github&#39;s
Windows runners, which were nearly 10x slower than the Mac and Linux runners:</p>
<p><img src="https://www.mattkeeter.com/blog/2025-01-20-guided/times.png" alt="Screenshot of a test matrix in Github actions.  Linux completes in 19s, macOS 15s, and Windows in 2m 20s"/></p>
<p><a href="https://bsky.app/profile/mattkeeter.com/post/3lg2bamqotk2h">Complaining on Bluesky</a>
revealed this to be a common issue, so I don&#39;t think I&#39;m doing anything wrong
here.</p>
<p>The second surprise was that the <code>ubuntu-24.04-arm</code> runner was extremely
unreliable!  For example, here&#39;s
<a href="https://github.com/mkeeter/raven/actions/runs/12849839590/job/35828859229">Clippy segfaulting (?!)</a>.
Rerunning the job succeeds – and
<code>aarch64-unknown-linux-gnu</code> is a
<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Tier 1</a>
target – so I&#39;d put my money on the job runners being at fault.</p>
<p>The ARM runners are very new, having entered
<a href="https://github.com/orgs/community/discussions/148648">&#34;public preview&#34;</a> only
two weeks ago, so I disabled that target and moved on.</p>
<h3>Actual snapshot testing</h3>
<p>The Varvara specification includes a <a href="https://wiki.xxiivv.com/site/varvara.html#screen"><code>Screen</code> device</a>,
which lets you draw pixels into the window.  It&#39;s a surprisingly complex device,
because it supports automatically drawing entire
<a href="https://en.wikipedia.org/wiki/Sprite_(computer_graphics)">sprites</a> (this makes
more sense once you learn that the platform is
<a href="https://100r.co/site/6502_assembly.html">inspired by the NES</a>).</p>
<p><img src="https://www.mattkeeter.com/blog/2025-01-20-guided/screen_bounds.png" alt="Picture of a test render showing grid, a set of circular patterns, and a woman&#39;s face reflected in four directions"/></p>
<p>I added automatic tests which run the system for some number of cycles, then
capture the state of the screen and compare it with a known-good image saved in
the repository.
The test passes if the image is identical, and fails with a visual comparison
otherwise.</p>
<p>To exercise more of the system, the test also performs mouse and keyboard
interactions while running. When I first added these interactions, a few of the
tests failed, because the mouse and keyboard changed the visual state of the
system!  This turned out to be a good demonstration of the failure rendering
(click for full resolution):</p>
<p><a href="https://www.mattkeeter.com/blog/2025-01-20-guided/piano_fail@2x.png"><img src="https://www.mattkeeter.com/blog/2025-01-20-guided/piano_fail.png" alt="Screenshot of three panes.  The left and right show a piano and waveform; the center shows red pixels where the left and right differ"/></a></p>
<p>If the new image is actually correct – as it was in this situation – then
deleting the previous known-good image will cause it to be regenerated on the
next run.</p>
<h3>Statically proving the absense of panics</h3>
<p>In my previous writeup, I bragged that the VM implementation is
<a href="https://www.mattkeeter.com/projects/raven#panics">completely free of panics</a>.
Unfortunately, I had to check this property by hand, by disassembling the
executable and scanning through the implementation of <code>Uxn::run</code>.</p>
<p>As part of the robustification process, I borrowed a trick from
<a href="https://docs.rs/no-panic"><code>no-panic</code></a>
to prove the absence of panics at compile time.  This strategy was new to me
(though well-known in the Rust community), so let me show you what it looks
like:</p>
<pre><code>#[inline(never)]
pub fn div_no_panic(data: &amp;[u8]) {
    // Define a struct which calls a non-existent function when dropped
    struct NoPanic;
    extern &#34;C&#34; {
        #[link_name = &#34;div_may_panic&#34;]
        fn trigger() -&gt; !;
    }
    impl ::core::ops::Drop for NoPanic {
        fn drop(&amp;mut self) {
            unsafe {
                trigger();
            }
        }
    }

    // Build an instance of that struct
    let guard = NoPanic;

    // Perform the possibly-panicking operations
    let mut ram = UxnRam::new();
    let mut vm = Uxn::new(&amp;mut ram, Backend::Interpreter);
    let _ = vm.reset(data);
    let pc = 0x100;
    for d in data {
        vm.stack.push(Value::Byte(*d));
        vm.ret.push(Value::Byte(*d));
    }
    vm.div(pc);

    // If we didn&#39;t panic, then forget the guard (skipping its drop function)
    core::mem::forget(guard);
}
</code></pre>
<p>Panics in Rust perform <a href="https://doc.rust-lang.org/nomicon/unwinding.html">&#34;unwinding&#34;</a>:
when a panic occurs, destructors are called for all objects.  In this code, the
destructor for <code>NoPanic</code> calls an <code>extern &#34;C&#34;</code> function named <code>div_may_panic</code>.
Unfortunately, this function doesn&#39;t exist!</p>
<p>Normally, this would fail at link time with an error, because the linker can&#39;t
resolve the external function.  However, if there are no panic paths, a set of
optimizations becomes possible:</p>
<ul>
<li>If there are no panics, then <code>core::mem::forget(guard)</code> is always called</li>
<li>If we always <code>forget</code> the guard, then <code>NoPanic::drop</code> is never called</li>
<li>If <code>NoPanic::drop</code> is never called, then it doesn&#39;t need to be in the binary</li>
<li>If <code>NoPanic::drop</code> is not included, then we never link against <code>div_may_panic</code></li>
</ul>
<p>In other words, this will fail with a linker error if the compiler believes that
the code may panic.  The test may have false positives – building without
optimization will fail, because the compiler is less aggressive – so I only
build these test in release mode.</p>
<p>The <code>div_no_panic</code> function needs to be instantiated, which we do with a small
test:</p>
<pre><code>#[test]
fn div() {
    let data = std::hint::black_box(&amp;[]);
    div_no_panic(data);
}
</code></pre>
<p>This test also stops the compiler from getting too clever with optimizations:
passing a <code>black_box</code> object into the function means that the VM may be
initialized with <em>any values</em> for its data and stacks.</p>
<p>Without the <code>black_box</code>, the compiler is smart enough to notice that the data
and stacks are all zeros; combined with aggressive inlining, we end up checking
the much weaker condition of &#34;this operation can&#39;t panic with a zero-initialized
VM&#34;, instead of &#34;this operation can&#39;t panic with a VM in any state&#34;.</p>
<p>As an example, division is defined as <code>a.checked_div(b).unwrap_or(0)</code>.  If I
instead write <code>a / b</code>, it can panic when <code>b == 0</code>.  Sure enough, this leads to a
linker error:</p>
<pre><code>= note: ld: Undefined symbols:
    _div_may_panic, referenced from:
        raven_uxn::test::no_panic::div::no_panic::h04b990e75bc12e0c in raven_uxn-f210ab979edece52.raven_uxn.e5df65eeb70bd9b5-cgu.03.rcgu.o
        raven_uxn::test::no_panic::div::no_panic::h686d8f2cdb0db704 in raven_uxn-f210ab979edece52.raven_uxn.e5df65eeb70bd9b5-cgu.03.rcgu.o
        raven_uxn::test::no_panic::div::no_panic::h8383a3b65857da3c in raven_uxn-f210ab979edece52.raven_uxn.e5df65eeb70bd9b5-cgu.03.rcgu.o
        raven_uxn::test::no_panic::div::no_panic::h87538c337282e2a2 in raven_uxn-f210ab979edece52.raven_uxn.e5df65eeb70bd9b5-cgu.03.rcgu.o
        raven_uxn::test::no_panic::div::no_panic::hcf7507c29ba59298 in raven_uxn-f210ab979edece52.raven_uxn.e5df65eeb70bd9b5-cgu.03.rcgu.o
  clang: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>It&#39;s not exactly beautiful, but it works well enough.  The custom link name
tells me which operation is responsible for the failure, making it easier to
track down.</p>
<p>I ended up writing a
<a href="https://github.com/mkeeter/raven/blob/e184deea52ebe9447d491e53c190a9c698e94a2c/raven-uxn/src/lib.rs#L2123-L2270">bunch of macros</a>
to check that every single opcode function is
panic-free.  Theoretically, I could have just tested
<a href="https://github.com/mkeeter/raven/blob/e184deea52ebe9447d491e53c190a9c698e94a2c/raven-uxn/src/lib.rs#L531-L792"><code>Uxn::op</code></a>,
which dispatches to opcode functions based on a <code>u8</code> argument; unfortunately,
even though each individual opcode function is panic-free, the optimizer
couldn&#39;t prove the same of <code>Uxn::op</code>.  Being subject to the whims of the
compiler is a definite downside to this trick!</p>
<p>Having panic-free code checked at compile time is a somewhat exotic tool, but is
helpful for high-assurance systems.  At work, my colleagues and I use a
<a href="https://github.com/oxidecomputer/hubris/blob/master/sys/userlib/src/lib.rs#L1533-L1545">similar strategy</a>
to assert that no panics are present in critical parts of our embedded system,
e.g. <a href="https://github.com/oxidecomputer/hubris/commit/8437fbd30aa129bb6e6fb66fe274be719c62ee8b">the supervisor task</a>.</p>
<h3>Fuzzing</h3>
<p>The Uxn CPU implementation in Raven comes in two flavors:</p>
<ul>
<li>The baseline interpreter is written in 100% safe Rust and is guaranteed
panic-free
(as discussed above)</li>
<li>The &#34;native&#34; interpreter uses hand-written assembly to run about 30% faster,
see in <a href="https://www.mattkeeter.com/blog/2024-07-12-interpreter/">&#34;Beating the compiler&#34;</a> for an
explanation of how this works</li>
</ul>
<p>These two implementations <em>should</em> both be faithful to the Uxn specification,
and behave identically.  However, when testing
<a href="https://github.com/gardenappl/svitlyna/">svitlyna</a> (an image viewer), I found
that they diverged: the baseline interpreter worked fine, but the native
interpreter failed to load any images!</p>
<p>This failure meant that I could not admire the sample image of a cat, which is
obviously an intolerable situation:</p>
<p><img src="https://www.mattkeeter.com/blog/2025-01-20-guided/cat.png" alt="Picture a cat in a macOS window titled &#39;Varvara&#39;"/></p>
<p>Divergence between the baseline and native interpreters had always been a fear
of mine, and I already had
<a href="https://github.com/mkeeter/raven/blob/e184deea52ebe9447d491e53c190a9c698e94a2c/raven-uxn/src/native/mod.rs#L138-L579">hundreds of lines of unit tests</a>
to compare between them.  These unit tests ran simple instruction sequences and
confirmed that both interpreters ended up in identical states.</p>
<p>Obviously, they weren&#39;t sufficient, so I pulled out a bigger hammer:
<a href="https://github.com/rust-fuzz/cargo-fuzz"><code>cargo-fuzz</code></a></p>
<p>In <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzz testing</a>,
we provide a random input to the system and check whether it behaves correctly.
Sufficiently advanced fuzzing libraries will actually monitor the code paths
(using debugging infrastructure), and are smart about mutating the input to
fully explore the program&#39;s state space.</p>
<p>For my interpreter, the random input is a ROM, which is just a slice of bytes.
The correctness check compares the machine state between baseline and native
interpreters after the program terminates.  &#34;Machine state&#34; is comprised of RAM
(64 KiB), data and return stacks (<code>u8</code> index plus 256 bytes each), and device
memory (256 bytes); all 66306 bytes must be identical!</p>
<p>It&#39;s easy for the fuzzer to discover (and get stuck in) infinite loops, so the
test harness also bails out after hitting some max instruction count.</p>
<p>When the fuzzer finds a case that <em>doesn&#39;t</em> match, the test harness saves the
failing input and pretty-prints the opcode sequence. For example, it may tell me
that <code>ADDk SFT2kr SWP2r EQU2r SWP2r LDR2kr SFT2kr</code> fails; <code>cargo fuzz tmin</code> then
reduces the test case to <code>EQU2r SWP2r</code>.</p>
<p>The fuzzer found <strong>three opcodes</strong> where the interpreters produced different
results.  The first two were straight-forward typos in my assembly
implementations:</p>
<pre><code>--- a/raven-uxn/src/native/aarch64.s
+++ b/raven-uxn/src/native/aarch64.s
@@ -874,9 +874,9 @@
_NIP2r:
    ldrb w9, [x2, x3]
    rpop
    ldrb w10, [x2, x3]
    rpop
    strb w9, [x2, x3]
-    sub x11, x1, #1
+    sub x11, x3, #1
     and x11, x11, #0xff
-    strb w10, [x2, x31]
+    strb w10, [x2, x11]
     next

@@ -885,7 +885,7 @@
 _SWP2r:
    ldrb w11, [x2, x3]  ; get the top byte
    rpeek w12, x9, 2    ; get the second-from-top byte
    strb w11, [x2, x9]  ; do the swap!
    strb w12, [x2, x3]

     rpeek w11, x9, 1
-    rpeek w12, x10, 2
+    rpeek w12, x10, 3

     strb w11, [x2, x10]
     strb w12, [x2, x9]
</code></pre>
<p>The third discrepancy, however, was <em>interesting</em>, because it was correct in
assembly and incorrect in Rust!</p>
<p>The <code>SFT</code> opcode reads a byte from the stack and splits it into two nibbles (4
bits each).  It then reads another byte from the stack and shifts it right
(controlled by the first nibble) then left (controlled by the second nibble).
It&#39;s a one-size-fits-all instruction for power-of-two division, multiplication,
and masking of low bits.</p>
<p>In Rust, I implemented it as follows:</p>
<pre><code>    #[inline]
    pub fn sft(&amp;mut self, pc: u16) {
        let shift = self.stack.pop_byte();
        let shr = u32::from(shift &amp; 0xF);
        let shl = u32::from(shift &gt;&gt; 4);
        let v = self.stack.pop_byte();
        self.stack.push(v.wrapping_shr(shr).wrapping_shl(shl));
    }
</code></pre>
<p>Your eyes may be drawn to <code>wrapping_shr</code> and <code>wrapping_shl</code>; what&#39;s wrong with
<code>&lt;&lt;</code> and <code>&gt;&gt;</code>?  This was part of my strategy for eliminating panics, because
it&#39;s illegal to shift an integer by more than its width!</p>
<p>For example, want to calculate <code>1u8 &lt;&lt; 8</code>?  Right to jail, right away.
<code>15u16 &gt;&gt; 18</code>?  Believe it or not, jail.  We have the best numerical operators
in the world, <a href="https://www.youtube.com/watch?v=eiyfwZVAzGw">because of jail</a>.</p>
<p>(To be pedantic, this will panic in debug builds and be Undefined Behavior in
release builds; you <em>should</em> turn on <code>overflow-checks</code> in release builds to make
it panic there as well)</p>
<p>To suss out the intended behavior, I looked at the reference implementation:</p>
<pre><code>case 0x1f: /* SFT  */
    t=T;n=N;
    SET(2,-1) T = n &gt;&gt; (t &amp; 0xf) &lt;&lt; (t &gt;&gt; 4);
    break;
</code></pre>
<p>In this case, <code>n</code> is a <code>Uint16</code>, and the maximum shift is 15, so this is all
legal (hooray!).  More importantly, it defines our semantics: we should shift in
zeros if the right-shift exceeds 8 bits, and discard bits that overflow when
shifting left.</p>
<p>This is what I <em>thought</em> I was doing with <code>wrapping_shr</code> and <code>wrapping_shl</code>.
Unfortunately, the &#34;wrapping&#34; in those function names applies to the <em>shift
amount</em>, not the shifted value!  Specifically, if the shift amount is larger
than the maximum valid shift, invalid bits are masked in the shift amount.</p>
<p>(<a href="https://www.reddit.com/r/rust/comments/yltnda/on_the_weird_behavior_of_wrapping_shl/">I&#39;m not the only person confused about this</a>)</p>
<p>It turns out that <code>unbounded_shl</code> and <code>unbounded_shr</code> have the desired
semantics, but they&#39;re
<a href="https://github.com/rust-lang/rust/issues/129375">still experimental and nightly-only</a>.
In the meantime, I can write the expression using <code>checked</code> shifts:</p>
<pre><code>    v.checked_shr(shr).unwrap_or(0).checked_shl(shl).unwrap_or(0)
</code></pre>
<p>In assembly, I was using <code>w</code>-sized registers (32 bits) for all operands, so it
was already doing the right thing:</p>
<pre><code>_SFT:
    ldrb w10, [x0, x1] ; load the shift amount
    pop                ; pop the shift amount from the stack
    ldrb w11, [x0, x1] ; load the value to be shifted
    lsr w12, w10, 4    ; calculate left shift amount
    and w10, w10, #0xf ; calculate right shift amount
    lsr w11, w11, w10  ; do the right shift
    lsl w11, w11, w12  ; do the left shift
    strb w11, [x0, x1] ; write the value back
    next
</code></pre>
<p>With these three opcodes fixed, I ran the fuzzer with 8 threads for 15-20
minutes.  My laptop got <em>very warm</em>, but it failed to find any further issues!</p>
<h2>Wrapping up</h2>
<p>I don&#39;t have any immediate plans for Raven, but next time I&#39;m inclined to touch
it, I&#39;ll be starting from a more solid foundation. For example, fuzz testing
means it&#39;s possible for me (or someone else!) to contribute an <code>x86-64</code> assembly
backend with relative confidence!</p>
<p>Software is never perfect, and there are only so many hours in the day, but I
found it rewarding to refine this small project into a microcosm of engineering
rigor. I appreciate the tools and infrastructure that let me create robust and
correct systems: Rust, <code>cargo fuzz</code> / <code>libFuzzer</code>, even (<em>sigh</em>) Github Actions.</p>
<p>My baseline interpreter is now (1) written in 100% safe Rust, (2) guaranteed not
to panic, no matter the inputs, and (3) up to 50% faster than the reference
implementation in C.  Even better, 2/3 of those properties are guaranteed at
compile time and checked in CI, so they shouldn&#39;t regress!</p>
<p>Finally, the title of this post is
<a href="https://www.youtube.com/watch?v=JTTC_fD598A">a reference to a song by Leonard Cohen</a>,
which is well worth your time.</p>

<!-- Begin footer -->
</div></div>
  </body>
</html>
