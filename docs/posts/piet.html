<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dangermouse.net/esoteric/piet.html">Original</a>
    <h1>Piet</h1>
    
    <div id="readability-page-1" class="page">

<hr/>

<p>
<img src="https://www.dangermouse.net/esoteric/piet/Mondrian.jpg" width="158" height="168" alt="Composition with Red, Yellow and Blue by Piet Mondrian"/></p>
<h2>Introduction</h2>
<p>
Piet is a programming language in which programs look like abstract paintings. The language is named after
<a href="http://www.ibiblio.org/wm/paint/auth/mondrian/">Piet Mondrian</a>, who pioneered the field of geometric abstract
art. I would have liked to call the language Mondrian, but
<a href="https://link.springer.com/chapter/10.1007/3-540-45337-7_9">someone beat me to it</a> with a rather mundane-looking
scripting language. Oh well, we can&#39;t all be esoteric language writers I suppose.
</p><p>
<i>Notes:</i>
</p>
<ul>
<li>I wrote the Piet specification a long time ago, and the language has taken on a bit of a life of its own, with a small
community of coders writing Piet programs, interpreters, IDEs, and even compilers. I have not written any &#34;authoritative&#34; interpreter, and the
different ones available sometimes interpret the specification slightly differently.</li>
<li>Over the years I have tended to field questions about the spec with &#34;whatever you think makes the most sense&#34;, rather than any definitive clarification - thus the slightly different versions out there. I have now added some clarifications to this specification to address some of the questions I have been asked over the years. Hopefully they are sensible and most implementations will already be compliant, but it&#39;s possible some do not comply. <i>Caveat emptor</i>.</li>
<li>Some people like to use Piet to set puzzles in various competitions. This web page and the linked resources can help you solve those puzzles, if you have a reasonable grasp of computer coding. If you do not, or it looks too difficult, I suggest asking some of your friends who may be computer programmers to help you. Please do not email to ask me for help. Although I wish you the best in solving your puzzle, I do not have time to help everyone in this situation.</li>
</ul>

<h2>Design Principles</h2>
<ul>
<li>Program code will be in the form of abstract art.</li>
</ul>

<h2>Language Concepts</h2>
<h3>Colours</h3>
<table>
	<tbody><tr>
		<td>#FFC0C0</td>
		<td>#FFFFC0</td>
		<td>#C0FFC0</td>
		<td>#C0FFFF</td>
		<td>#C0C0FF</td>
		<td>#FFC0FF</td>
	</tr>
	<tr>
		<td>#FF0000</td>
		<td>#FFFF00</td>
		<td>#00FF00</td>
		<td>#00FFFF</td>
		<td>#0000FF</td>
		<td>#FF00FF</td>
	</tr>
	<tr>
		<td>#C00000</td>
		<td>#C0C000</td>
		<td>#00C000</td>
		<td>#00C0C0</td>
		<td>#0000C0</td>
		<td>#C000C0</td>
	</tr>
	<tr>
		<td colspan="3">#FFFFFF white</td>
		<td colspan="3"><SPAN color="#FFFFFF">#000000 black</SPAN></td>
	</tr>
</tbody></table>
<p>
Piet uses 20 distinct colours, as shown in the table at right.
The 18 colours in the first 3 rows of the table are related cyclically in the following two ways:
</p>
<ul>
<li><b>Hue Cycle:</b> red -&gt; yellow -&gt; green -&gt; cyan -&gt; blue -&gt; magenta -&gt; red
</li><li><b>Lightness Cycle:</b> light -&gt; normal -&gt; dark -&gt; light
</li></ul>
<p>
Note that &#34;light&#34; is considered to be one step &#34;darker&#34; than &#34;dark&#34;, and vice versa. White and black do not fall into
either cycle.
</p><p>
Additional colours (such as orange, brown) may be used, though their effect is implementation-dependent. In the simplest
case, non-standard colours are treated by the language interpreter as the same as white, so may be used freely wherever
white is used. (Another possibility is that they are treated the same as black.)
</p>

<h3>Codels</h3>
<p>
Piet code takes the form of graphics made up of the recognised colours. Individual pixels of colour are significant in the
language, so it is common for programs to be enlarged for viewing so that the details are easily visible. In such enlarged
programs, the term &#34;codel&#34; is used to mean a block of colour equivalent to a single pixel of code, to avoid confusion with
the actual pixels of the enlarged graphic, of which many may make up one codel.
</p>

<h3>Colour Blocks</h3>
<p>
The basic unit of Piet code is the colour block. A colour block is a contiguous block of any number of codels of one colour,
bounded by blocks of other colours or by the edge of the program graphic. Blocks of colour adjacent only diagonally are not
considered contiguous. A colour block may be any shape and may have &#34;holes&#34; of other colours inside it, which are not considered
part of the block.
</p>

<h3>Stack</h3>
<p>
Piet uses a <i><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a></i> for storage of all data values. Data values exist only as integers, though they may be read in or
printed as <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> character values with appropriate commands.
</p><p>
The stack is notionally infinitely deep, but implementations may elect to provide a finite maximum stack size. If a finite stack overflows, it should be treated as a runtime error, and handling this will be implementation dependent.
</p>

<h3>Program Execution</h3>
<table>
	<tbody><tr>
		<th>DP</th><th>CC</th><th>Codel chosen</th>
	</tr>
	<tr>
		<td rowspan="2">right</td><td>left</td><td>uppermost</td>
	</tr>
	<tr>
		<td>right</td><td>lowermost</td>
	</tr>
	<tr>
		<td rowspan="2">down</td><td>left</td><td>rightmost</td>
	</tr>
	<tr>
		<td>right</td><td>leftmost</td>
	</tr>
	<tr>
		<td rowspan="2">left</td><td>left</td><td>lowermost</td>
	</tr>
	<tr>
		<td>right</td><td>uppermost</td>
	</tr>
	<tr>
		<td rowspan="2">up</td><td>left</td><td>leftmost</td>
	</tr>
	<tr>
		<td>right</td><td>rightmost</td>
	</tr>
</tbody></table>
<p>
The Piet language interpreter begins executing a program in the colour block which includes the upper left codel of the program.
The interpreter maintains a <em>Direction Pointer</em> (DP), initially pointing to the right. The DP may point either right,
left, down or up. The interpreter also maintains a <em>Codel Chooser</em> (CC), initially pointing left. The CC may point
either left or right. The directions of the DP and CC will often change during program execution.
</p><p>
As it executes the program, the interpreter traverses the colour blocks of the program under the following rules:
</p>
<ol>
<li>The interpreter finds the edge of the current colour block which is furthest in the direction of the DP. (This edge may be disjoint if the block is of a complex shape.)</li>
<li>The interpreter finds the codel of the current colour block on that edge which is furthest to the CC&#39;s direction of the DP&#39;s direction of travel. (Visualise this as standing on the program and walking in the direction of the DP; see table at right.)</li>
<li>The interpreter travels from that codel into the colour block containing the codel immediately in the direction of the DP.</li>
</ol>
<p>
The interpreter continues doing this until the program terminates.
</p>

<h2>Syntax Elements</h2>
<h3>Numbers</h3>
<p>
Each non-black, non-white colour block in a Piet program represents an integer equal to the number of codels in that block.
Note that non-positive integers cannot be represented, although they can be constructed with operators. When the interpreter
encounters a number, it does not necessarily do anything with it. In particular, it is not automatically pushed on to the
stack - there is an explicit command for that (see below).
</p><p>
The maximum size of integers is notionally infinite, though implementations may implement a finite maximum integer size. An integer overflow is
a runtime error, and handling this will be implementation dependent.
</p>

<h3>Black Blocks and Edges</h3>
<p>
Black colour blocks and the edges of the program restrict program flow. If the Piet interpreter attempts to move into a black block
or off an edge, it is stopped and the CC is toggled. The interpreter then attempts to move from its current block again. If it fails
a second time, the DP is moved clockwise one step. These attempts are repeated, with the CC and DP being changed between alternate
attempts. If after eight attempts the interpreter cannot leave its current colour block, there is no way out and the program terminates.
</p>

<h3>White Blocks</h3>
<p>
White colour blocks are &#34;free&#34; zones through which the interpreter passes unhindered. If it moves from a colour block into a white
area, the interpreter &#34;slides&#34; through the white codels in the direction of the DP until it reaches a non-white colour block.
If the interpreter slides into a black block or an edge, it is considered restricted (see above), otherwise it moves into the
colour block so encountered. Sliding across white blocks into a new colour does not cause a command to be executed (see below). In this way,
white blocks can be used to change the current colour without executing a command, which is very useful for coding loops.
</p><p>
Sliding across white blocks takes the interpreter in a <i>straight line</i> until it hits a coloured pixel or edge. It does not use the procedure
described above for determining where the interpreter emerges from non-white coloured blocks.
</p><p>
<i>Precisely what happens when the interpeter slides across a white block and hits a black block or an edge was not clear in the original
specification. My interpretation follows from a literal reading of the above text:</i>
</p>
<ul>
<li>The interpreter &#34;slides&#34; across the white block in a straight line.</li>
<li>If it hits a restriction, the CC is toggled. Since this results in no difference in where the interpreter is trying to go, the DP is immediately stepped clockwise.</li>
<li>The interpreter now begins sliding from its current white codel, in the new direction of the DP, until it either enters a coloured block or encounters another restriction.</li>
<li>Each time the interpreter hits a restriction while within the white block, it toggles the CC and steps the DP clockwise, then tries to slide again. This process repeats until the interpreter either enters a coloured block (where execution then continues); or until the interpreter begins retracing its route. If it retraces its route entirely within a white block, there is no way out of the white block and execution should terminate.</li>
</ul>

<h3>Commands</h3>
<table>
	<tbody><tr>
		<th> </th><th colspan="3">Lightness change</th>
	</tr>
	<tr>
		<th>Hue change</th><th>None</th><th>1 Darker</th><th>2 Darker</th>
	</tr>
	<tr>
		<th>None</th><td> </td><td>push</td><td>pop</td>
	</tr>
	<tr>
		<th>1 Step</th><td>add</td><td>subtract</td><td>multiply</td>
	</tr>
	<tr>
		<th>2 Steps</th><td>divide</td><td>mod</td><td>not</td>
	</tr>
	<tr>
		<th>3 Steps</th><td>greater</td><td>pointer</td><td>switch</td>
	</tr>
	<tr>
		<th>4 Steps</th><td>duplicate</td><td>roll</td><td>in(number)</td>
	</tr>
	<tr>
		<th>5 Steps</th><td>in(char)</td><td>out(number)</td><td>out(char)</td>
	</tr>
</tbody></table>
<p>
Commands are defined by the transition of colour from one colour block to the next as the interpreter travels through the
program. The number of steps along the Hue Cycle and Lightness Cycle in each transition determine the command executed, as shown
in the table at right. If the transition between colour blocks occurs via a slide across a white block, no command is executed.
The individual commands are explained below.
</p>
<ul>
<li><b>push:</b> Pushes the value of the colour block just exited on to the stack. Note that values of colour blocks are
not automatically pushed on to the stack - this push operation must be explicitly carried out.</li>
<li><b>pop:</b> Pops the top value off the stack and discards it.</li>
<li><b>add:</b> Pops the top two values off the stack, adds them, and pushes the result back on the stack.</li>
<li><b>subtract:</b> Pops the top two values off the stack, calculates the second top value minus the top value,
and pushes the result back on the stack.</li>
<li><b>multiply:</b> Pops the top two values off the stack, multiplies them, and pushes the result back on the stack.</li>
<li><b>divide:</b> Pops the top two values off the stack, calculates the integer division of the second top value by the top value, and pushes the result back on the stack. If a divide by zero occurs, it is handled as an implementation-dependent error, though simply ignoring the command is recommended.</li>
<li><b>mod:</b> Pops the top two values off the stack, calculates the second top value <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a> the top value, and pushes the result back on the stack. The result has the same sign as the divisor (the top value). If the top value is zero, this is a divide by zero error, which is handled as an implementation-dependent error, though simply ignoring the command is recommended. (<i>See note below.</i>)</li>
<li><b>not:</b> Replaces the top value of the stack with 0 if it is non-zero, and 1 if it is zero.</li>
<li><b>greater:</b> Pops the top two values off the stack, and pushes 1 on to the stack if the second top value is
greater than the top value, and pushes 0 if it is not greater.</li>
<li><b>pointer:</b> Pops the top value off the stack and rotates the DP clockwise that many steps (anticlockwise if negative).</li>
<li><b>switch:</b> Pops the top value off the stack and toggles the CC that many times (the absolute value of that many times if negative).</li>
<li><b>duplicate:</b> Pushes a copy of the top value on the stack on to the stack.</li>
<li><b>roll:</b> Pops the top two values off the stack and &#34;rolls&#34; the remaining stack entries to a depth equal to the second value popped, by a number of rolls equal to the first value popped. A single roll to depth <i>n</i> is defined as burying the top value on the stack <i>n</i> deep and bringing all values above it up by 1 place. A negative number of rolls rolls in the opposite direction. A negative depth is an error and the command is ignored. If a roll is greater than an implementation-dependent maximum stack depth, it is handled as an implementation-dependent error, though simply ignoring the command is recommended.</li>
<li><b>in:</b> Reads a value from STDIN as either a number or character, depending on the particular incarnation of this command and pushes it on to the stack. If no input is waiting on STDIN, this is an error and the command is ignored. If an integer read does not receive an integer value, this is an error and the command is ignored.</li>
<li><b>out:</b> Pops the top value off the stack and prints it to STDOUT as either a number or character, depending
on the particular incarnation of this command.</li>
</ul>
<p>
Any operations which cannot be performed (such as popping values when not enough are on the stack) are simply ignored, and processing continues with the next command.
</p><p>
<i>Note on the mod command:</i> In the original specification of Piet the result of a modulo operation with a negative dividend (the second top value popped off the stack) was not explicitly defined. I assumed that everyone would assume that the result of (<i>p</i> mod <i>q</i>) would always be equal to ((<i>p</i> + <i>Nq</i>) mod <i>q</i>) for any integer <i>N</i>. So:
</p>
<ul>
<li>5 mod 3 = 2</li>
<li>2 mod 3 = 2</li>
<li>-1 mod 3 = 2</li>
<li>-4 mod 3 = 2</li>
</ul>
<p>
The mod command is thus identical to <i>floored division</i> in Wikipedia&#39;s page on the <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulus operation</a>.
</p>

<h2>Sample Programs and Resources</h2>
<ul>
<li><a href="https://www.dangermouse.net/esoteric/piet/samples.html">Sample programs</a>
</li><li><a href="https://www.dangermouse.net/esoteric/piet/tools.html">Third-party Piet interpreters and development tools</a>
</li></ul>
<p>
<a href="https://www.patreon.com/dmmaus">Support me on Patreon <img src="https://www.dangermouse.net/patreon_16x16.png" width="16" height="16"/></a>
</p>
<hr/>
<a href="https://www.dangermouse.net/">Home</a> | <a href="https://www.dangermouse.net/esoteric/">Esoteric Programming Languages</a></div>
  </body>
</html>
