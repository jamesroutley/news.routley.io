<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danluu.com/monorepo/">Original</a>
    <h1>Advantages of Monorepos (2015)</h1>
    
    <div id="readability-page-1" class="page"><i><b><a href="https://patreon.com/danluu">I&#39;m trying some experimental tiers on Patreon</a></b> to see if I can get to <a href="https://twitter.com/danluu/status/1456346963691991041">substack-like levels of financial support for this blog without moving to substack</a>!</i> <hr/> <strong>Advantages of monorepos</strong> <p>Here&#39;s a conversation I keep having:</p> <blockquote> <p><strong>Someone</strong>: Did you hear that Facebook/Google uses a giant monorepo? WTF!</p> </blockquote> <p>“[reasons]” is pretty long, so I&#39;m writing this down in order to avoid repeating the same conversation over and over again.</p>  <h3 id="simplified-organization">Simplified organization</h3> <p>With multiple repos, you typically either have one project per repo, or an umbrella of related projects per repo, but that forces you to define what a “project” is for your particular team or company, and it sometimes forces you to split and merge repos for reasons that are pure overhead. For example, having to split a project because it&#39;s too big or has too much history for your VCS is not optimal.</p> <p>With a monorepo, projects can be organized and grouped together in whatever way you find to be most logically consistent, and not just because your version control system forces you to organize things in a particular way. Using a single repo also reduces overhead from managing dependencies.</p> <p>A side effect of the simplified organization is that it&#39;s easier to navigate projects. The monorepos I&#39;ve used let you essentially navigate as if everything is on a networked file system, re-using the idiom that&#39;s used to navigate within projects. Multi repo setups usually have two separate levels of navigation -- the filesystem idiom that&#39;s used inside projects, and then a meta-level for navigating between projects.</p> <p>A side effect of that side effect is that, with monorepos, it&#39;s often the case that it&#39;s very easy to get a dev environment set up to run builds and tests. If you expect to be able to navigate between projects with the equivalent of <code>cd</code>, you also expect to be able to do <code>cd; make</code>. Since it seems weird for that to not work, it usually works, and whatever tooling effort is necessary to make it work gets done. While it&#39;s technically possible to get that kind of ease in multiple repos, it&#39;s not as natural, which means that the necessary work isn&#39;t done as often.</p> <h3 id="simplified-dependencies">Simplified dependencies</h3> <p>This probably goes without saying, but with multiple repos, you need to have some way of specifying and versioning dependencies between them. That sounds like it ought to be straightforward, but in practice, most solutions are cumbersome and involve a lot of overhead.</p> <p>With a monorepo, it&#39;s easy to have one universal version number for all projects. Since atomic cross-project commits are possible (though these tend to split into many parts for practical reasons at large companies), the repository can always be in a consistent state -- at commit #X, all project builds should work. Dependencies still need to be specified in the build system, but whether that&#39;s a make Makefiles or bazel BUILD files, those can be checked into version control like everything else. And since there&#39;s just one version number, the Makefiles or BUILD files or whatever you choose don&#39;t need to specify version numbers.</p> <h3 id="tooling">Tooling</h3> <p>The simplification of navigation and dependencies makes it much easier to write tools. Instead of having tools that must understand relationships between repositories, as well as the nature of files within repositories, tools basically just need to be able to read files (including some file format that specifies dependencies between units within the repo).</p> <p>This sounds like a trivial thing but, <a href="https://github.com/chrisvana/repobuild/wiki/Motivation">take this example by Christopher Van Arsdale</a> on how easy builds can become:</p> <blockquote> <p><a href="http://bazel.io/">The build system inside of Google</a> makes it incredibly easy to build software using large modular blocks of code. You want a crawler? Add a few lines here. You need an RSS parser? Add a few more lines. A large distributed, fault tolerant datastore? Sure, add a few more lines. These are building blocks and services that are shared by many projects, and easy to integrate. … This sort of Lego-like development process does not happen as cleanly in the open source world. … As a result of this state of affairs (more speculation), there is a complexity barrier in open source that has not changed significantly in the last few years. This creates a gap between what is easily obtainable at a company like Google versus a[n] open sourced project.</p> </blockquote> <p>The system that Arsdale is referring to is so convenient that, before it was open sourced, ex-Google engineers at <a href="https://facebook.github.io/buck/">Facebook</a> and <a href="https://pantsbuild.github.io/">Twitter</a> wrote their own versions of bazel in order to get the same benefits.</p> <p>It&#39;s theoretically possible to create a build system that makes building anything, with any dependencies, simple without having a monorepo, but it&#39;s more effort, enough effort that I&#39;ve never seen a system that does it seamlessly. Maven and sbt are pretty nice, in a way, but it&#39;s not uncommon to lose a lot of time tracking down and fixing version dependency issues. Systems like rbenv and virtualenv try to sidestep the problem, but they result in a proliferation of development environments. Using a monorepo where HEAD always points to a consistent and valid version removes the problem of tracking multiple repo versions entirely.</p> <p>Build systems aren&#39;t the only thing that benefit from running on a mono repo. Just for example, static analysis can run across project boundaries without any extra work. Many other things, like cross-project integration testing and <a href="https://github.com/google/codesearch">code search</a> are also greatly simplified.</p> <h3 id="cross-project-changes">Cross-project changes</h3> <p>With lots of repos, making cross-repo changes is painful. It typically involves tedious manual coordination across each repo or hack-y scripts. And even if the scripts work, there&#39;s the overhead of correctly updating cross-repo version dependencies. Refactoring an API that&#39;s used across tens of active internal projects will probably a good chunk of a day. Refactoring an API that&#39;s used across thousands of active internal projects is hopeless.</p> <p>With a monorepo, you just <a href="http://research.google.com/pubs/pub41342.html">refactor the API and all of its callers</a> in one commit. That&#39;s not always trivial, but it&#39;s much easier than it would be with lots of small repos. I&#39;ve seen APIs with thousands of usages across hundreds of projects get refactored and with a monorepo setup it&#39;s so easy that it&#39;s no one even thinks twice.</p> <p>Most people now consider it absurd to use a version control system like CVS, RCS, or ClearCase, where it&#39;s impossible to do a single atomic commit across multiple files, forcing people to either manually look at timestamps and commit messages or keep meta information around to determine if some particular set of cross-file changes are “really” atomic. SVN, hg, git, etc solve the problem of atomic cross-file changes; monorepos solve the same problem across projects.</p> <p>This isn&#39;t just useful for large-scale API refactorings. David Turner, who worked on twitter&#39;s migration from many repos to a monorepo gives this example of a small cross-cutting change and the overhead of having to do releases for those:</p> <blockquote> <p>I needed to update [Project A], but to do that, I needed my colleague to fix one of its dependencies, [Project B]. The colleague, in turn, needed to fix [Project C]. If I had had to wait for C to do a release, and then B, before I could fix and deploy A, I might still be waiting. But since everything&#39;s in one repo, my colleague could make his change and commit, and then I could immediately make my change.</p> <p>I guess I could do that if everything were linked by git versions, but my colleague would still have had to do two commits. And there&#39;s always the temptation to just pick a version and &#34;stabilize&#34; (meaning, stagnate). That&#39;s fine if you just have one project, but when you have a web of projects with interdependencies, it&#39;s not so good.</p> <p>[In the other direction,] Forcing <em>dependees</em> to update is actually another benefit of a monorepo.</p> </blockquote> <p>It&#39;s not just that making cross-project changes is easier, tracking them is easier, too. To do the equivalent of <code>git bisect</code> across multiple repos, you must be disciplined about using another tool to track meta information, and most projects simply don&#39;t do that. Even if they do, you now have two really different tools where one would have sufficed.</p> <p>Ironically, there&#39;s a sense in which this benefit decreases as the company gets larger. At Twitter, which isn&#39;t exactly small, David Turner got a lot of value out of being able to ship cross-project changes. But at a Google-sized company, large commits can be large enough that it makes sense to split them into many smaller commits for a variety of reasons, which necessitates tooling that can effectively split up large conceptually atomic changes into many non-atomic commits.</p> <h3 id="mercurial-and-git-are-awesome-it-s-true">Mercurial and git are awesome; it&#39;s true</h3> <p>The most common response I&#39;ve gotten to these points is that switching to either git or hg from either CVS or SVN is a huge productivity win. That&#39;s true. But a lot of that is because git and hg are superior in multiple respects (e.g., better merging), not because having small repos is better per se.</p> <p>In fact, Twitter has been patching git and <a href="https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/">Facebook has been patching Mercurial</a> in order to support giant monorepos.</p> <h3 id="downsides">Downsides</h3> <p>Of course, there are downsides to using a monorepo. I&#39;m not going to discuss them because the downsides are already widely discussed. Monorepos aren&#39;t strictly superior to manyrepos. They&#39;re not strictly worse, either. My point isn&#39;t that you should definitely switch to a monorepo; it&#39;s merely that using a monorepo isn&#39;t totally unreasonable, that folks at places like Google, Facebook, Twitter, Digital Ocean, and Etsy might have good reasons for preferring a monorepo over hundreds or thousands or tens of thousands of smaller repos.</p> <h3 id="other-discussion">Other discussion</h3> <p><a href="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">Gregory</a> <a href="http://gregoryszorc.com/blog/2015/02/17/lost-productivity-due-to-non-unified-repositories/">Szorc</a>. <a href="https://developers.facebooklive.com/videos/561/big-code-developer-infrastructure-at-facebook-s-scale">Face</a><a href="https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/">book</a>. <a href="http://bitquabit.com/post/unorthodocs-abandon-your-dvcs-and-return-to-sanity/">Benjamin Pollack</a> (one of the co-creators of Kiln). <a href="https://qafoo.com/resources/presentations/froscon_2015/monorepos.html">Benjamin Eberlei</a>. <a href="http://blog.rocketpoweredjetpants.com/2015/04/monorepo-one-source-code-repository-to.html">Simon Stewart</a>. <a href="https://www.digitalocean.com/company/blog/taming-your-go-dependencies/">Digital Ocean</a>. <a href="http://www.infoq.com/presentations/Development-at-Google">Goo</a><a href="https://www.youtube.com/watch?v=W71BTkUbdqE">gle</a>. <a href="http://git-merge.com/videos/scaling-git-at-twitter-wilhelm-bierbaum.html">Twitter</a>. <a href="http://www.reddit.com/r/programming/comments/1unehr/scaling_mercurial_at_facebook/cek9nkq">thedufer</a>. <a href="http://paulhammant.com/categories.html#trunk_based_development">Paul Hammant</a>.</p> <p><small> Thanks to Kamal Marhubi, David Turner, and Leah Hanson for extensive discussion on this topic. At least half of the ideas here come from them. Also, thanks to Leah Hanson, Mindy Preston, Chris Ball, Daniel Espeset, Joe Wilder, Nicolas Grilly, Giovanni Gherdovich, Paul Hammant, and Simon Thulbourn for finding typos and other mistakes in this post. </small></p>   </div>
  </body>
</html>
