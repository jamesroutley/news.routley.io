<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adam.nels.onl//blog/maybe-everything-is-a-coroutine/">Original</a>
    <h1>Maybe Everything Is a Coroutine</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <p>I was inspired, after reading the excellent blog post <a href="https://without.boats/blog/let-futures-be-futures/">Let Futures Be
Futures</a>, by the author&#39;s
thought experiment of a language in which all functions are coroutines and this
is used to express asynchronicity: async functions can yield a type called
<code>Pending</code> when awaiting some async action, while pure, synchronous functions can
yield <code>Never</code>, indicating that they never yield at all.</p>
<p>The more I thought about this, the more I realized that a strongly-typed
language in which <em>every function is a coroutine</em> could actually have a lot of
nice properties. I&#39;ve come up with a design with several cool features,
including:</p>
<ul>
<li>A type system in which coroutines are basically state machines</li>
<li>A typed (algebraic) effect system based on coroutines
<ul>
<li>Functions can be generic over effects and purity</li>
<li>Effects can be &#34;intercepted&#34; by a caller and faked</li>
</ul>
</li>
<li>A powerful exception system based on simple sum types
<ul>
<li>An exception pass-through system that feels like a saner, generic version
of checked exceptions</li>
<li>Common Lisp-style resumable conditions</li>
</ul>
</li>
<li>Immutable data structures and pure-by-default functions, but with the ability
to use mutation in algorithms, by keeping all mutation in a function&#39;s scope
and using coroutines to control state</li>
</ul>
<p>How does it work? There are three key features: <em>sequence types</em>, the <em>coroutine
for loop</em>, and the <em>pass operator</em>.</p>
<h2 id="sequence-types">Sequence Types</h2>
<p>Ordinary functions have <em>argument types</em> and a <em>return type</em>:</p>
<pre><code>fib(n: Int) -&gt; Int
</code></pre>
<p>In this everything-is-a-coroutine language, instead of a return type, every
function has a <em>sequence type</em>. This is a sum type describing every type that
the function can yield and every type that it can be resumed with after a yield.</p>
<p>For example, a coroutine version of <code>fib</code> that, instead of returning the <code>n</code>th
Fibonacci number, yields an infinite sequence of the Fibonacci numbers:</p>
<pre><code>fib() -&gt; Int()
</code></pre>
<p>The <code>()</code> means that, after the coroutine yields an <code>Int</code>, it can be <em>resumed</em>
with no arguments. Because there is no base case (no branch that cannot be
resumed), this coroutine must be infinite; it continues until the caller chooses
not to resume it.</p>
<p>Consider instead a coroutine that yields a <em>finite</em> sequence of <code>Int</code>s:</p>
<pre><code>factors(n: Int) -&gt; Int() | Void
</code></pre>
<p>This sequence type has two <em>cases</em>: either it emits an <code>Int</code> and can be resumed
with no arguments, or it emits nothing and cannot be resumed.</p>
<p>Notice the syntax of <code>Void</code>: a type with no parentheses is a valid sequence
type. This means that the ordinary function <code>fib(n: Int) -&gt; Int</code> is a valid
coroutine as wellâ€”it yields <code>Int</code> once, then cannot be resumed. Pure functions
are a subset of coroutines!</p>
<p>These strongly-typed coroutines are essentially state machines. Let&#39;s define an
additional piece of syntax: a <em>symbol</em> <code>:foo</code> is a unique singleton object whose
type is also <code>:foo</code>. Using symbols, we can define a simple state machine for
a door:</p>
<pre><code>door() -&gt;
  | :open(:close)
  | :closed(:open | :lock)
  | :locked(:unlock)
</code></pre>
<p>Each state accepts only a specific set of actions. An open door can only be
closed; a locked door can only be unlocked; a closed door can be opened or
locked.</p>
<h2 id="coroutine-for-loop">Coroutine For Loop</h2>
<p>But how do we <em>use</em> these coroutines? The syntax for basic function calls
remains the same; if a coroutine has only no-resume types in its sequence type,
then it can be used directly as an argument or assigned to a variable.</p>
<p>For more complex coroutines, there is a for loop syntax. Consider the door state
machine from before; this is an example of a for loop that uses it:</p>
<pre><code>for (door()) {
  | :locked -&gt;
    continue(:unlock)
  | :closed -&gt;
    continue(:open)
  | :open -&gt;
    break
}
</code></pre>
<p>This loop pattern-matches on the values yielded by <code>door</code>. The branches use the
familiar keywords <code>continue</code> and <code>break</code>, but <code>continue</code> takes arguments now: it
resumes <code>for</code>&#39;s coroutine with new arguments, which must match the argument type
of the current branch of the sequence type. The loop does not end until it
encounters a <code>break</code>.</p>
<p>We can add some conveniences for the common case of coroutines that yield a list
of values without any resume arguments. <code>continue()</code> is inferred at the end of
blocks whose resume type is <code>()</code>,  <code>break</code> is inferred at the end of blocks with
no resume type, <code>Void</code> branches can be omitted, and wildcard matches are assumed
to not match <code>Void</code>.</p>
<pre><code>def someNumbers() -&gt; Int() | Void {
  yield 1
  yield 2
  yield 3
}

var total
for (someNumbers()) { n -&gt;
  total += n
}
</code></pre>
<h2 id="the-pass-operator">The Pass Operator</h2>
<p>Extending this coroutine syntax to support algebraic effects and error handling
is straightforward. Errors can be yielded as ordinary values, which usually do
not resume:</p>
<pre><code>divide(divisor: Int, dividend: Int) -&gt; DivideByZeroError | Int
</code></pre>
<p>Algebraic effects can be yielded, presumably all the way up to the main
function, which will then resume with a response to the given effect. These get
complex, but I&#39;ll introduce syntax sugar to deal with these huge signatures
later.</p>
<pre><code>readFile(filename: String) -&gt;
  | IOFileStat(FileError | FileInfo)
  | IOFileRead(FileError | Bytes)
  | FileError
  | Bytes
</code></pre>
<p>But actually <em>using</em> effects and errors with the mechanisms we already have (for
loops and <code>yield</code>) would be extremely cumbersome. It would look a lot like Go:
manually checking for error states or effects everywhere, just to <code>yield</code> them
to the next level in the stack.</p>
<pre><code>readConfigJson(filename: String) -&gt;
  | IOFileStat(FileError | FileInfo)
  | IOFileRead(FileError | Bytes)
  | FileError
  | JsonParseError
  | JsonFormatError
  | ConfigFile
{
  for (readFile(filename)) {
    | IOFileStat a -&gt; continue(yield a)
    | IOFileRead a -&gt; continue(yield a)
    | FileError e -&gt; yield e
    | Bytes data -&gt;
      // borrowing some Scala syntax
      parseJson(data) match {
        | JsonParseError e -&gt; yield e
        | JsonValue json -&gt; yield parseConfigFile(json)
      }
  }
}
</code></pre>
<p>The common pattern here is <code>a -&gt; continue(yield a)</code> (for branches that resume)
and <code>e -&gt; yield e</code> (for branches that don&#39;t). This pattern is so common in this
style of code that it deserves its own piece of syntax sugar: the <em>pass
operator</em>, <code>^</code>.</p>
<p>Placing <code>^</code> before an expression causes any value yielded by that expression
that can be directly yielded (as <code>continue (yield a)</code> or just <code>yield a</code>) to be
yielded. In other words, it causes any types contained in the function&#39;s
sequence type to be <em>passed through</em> from this expression to the caller.</p>
<p>This greatly simplifies the example function:</p>
<pre><code>readConfigJson(filename: String) -&gt;
  | IOFileStat(FileError | FileInfo)
  | IOFileRead(FileError | Bytes)
  | FileError
  | JsonParseError
  | JsonFormatError
  | ConfigFile
{
  val data = ^readFile(filename)
  val json = ^parseJson(data)
  yield parseConfigFile(json)
}
</code></pre>
<p>The sequence type is still a mess, though. And there&#39;s another problem: what if
a function yields a bunch of effect types, but also a type that you want to
capture in a variable... that also happens to be in your function&#39;s sequence
type?</p>
<p>Here are some changes that solve these problems:</p>
<ul>
<li>The keyword <code>infer Type</code> can be used in any branch of the sequence type; its
type is inferred as all subtypes of <code>Type</code> that are yielded by the function.
Values passed through by the <code>^</code> operator are included in this inference.
<ul>
<li><code>infer Type(*)</code> also infers the resume arguments; this can infer multiple
branches.</li>
</ul>
</li>
<li>The <code>^</code> operator can occur in front of sequence type branches. This causes <code>^</code>
in the function body to only pass through types that also have a <code>^</code> in front
of them in the sequence type.</li>
<li>A block or keyword, like <code>nopass</code>, could prevent a type from being passed
through; this would work like a catch block, ensuring the function can handle
a specific yielded type.</li>
</ul>
<p>With these changes, and assuming that supertypes <code>FileIO</code> and <code>Error</code> exist, the function becomes even simpler!</p>
<pre><code>readConfigJson(filename: String) -&gt; ^infer IOFile(*) | ^infer Error | ConfigFile {
  val data = ^readFile(filename)
  val json = ^parseJson(data)
  yield parseConfigFile(json)
}
</code></pre>
<h2 id="putting-it-all-together">Putting it All Together</h2>
<p>These three key features are a surprisingly solid core for a language, but they
aren&#39;t a full language on their own. They could fit into several different
language designs, but, in my opinion, the ideal language built on this
foundation would have:</p>
<ul>
<li>Strict functional purity outside of algebraic effects and mutable local
variables. You can only perform side effects by yielding effect objects from
<code>main</code>.
<ul>
<li>Mutable local variables can still allow for efficient mutable data
structures, thanks to coroutines. A mutable, resizeable array type can
exist, but it cannot be yielded, passed as an argument, or stored in
a struct. Structures of these arrays can then be manipulated by passing
a coroutine into a function, then using actions yielded by that coroutine
to manipulate the arrays defined in that function&#39;s scope.</li>
</ul>
</li>
<li>Immutable, nominally-typed structs with subtyping.</li>
<li>A generic tuple type, allowing for tuples-with-symbols message passing a la
Erlang, but strongly typed.</li>
<li>Full higher-order generics. This allows functions to be generic over purity
and generic over checked exceptions, two qualities that are very rarely found
in type systems.</li>
<li>Type aliases for sequence types, which can include multiple branches. The
syntax for this would likely use <code>(*)</code>. For example, you can define <code>type Ints -&gt; Int() | Void</code>â€”the <code>-&gt;</code> indicates that it&#39;s a sequence typeâ€”and then use
it like this: <code>someFunction() -&gt; Ints(*)</code>.
<ul>
<li>Using these types, functions can take sequence arguments. For example,
<code>sum(seq -&gt; Ints(*)) -&gt; Int</code> is a sum function over a finite sequence of
<code>Int</code>. It can be called with <code>sum(someFunction())</code>, and the <em>entire
sequence</em> returned by <code>someFunction</code> will be passed in to <code>sum</code>.</li>
<li>A syntax for standalone sequences should also exist, basically the
coroutine equivalent of an
<a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE">IIFE</a>. For
example, <code>-&gt; { yield 1 }</code> would be a sequence of type <code>-&gt; Int</code> by default,
but could also be explicitly typed: <code>-&gt; Int() | Void { yield 1 }</code>.</li>
<li>Sequence literals could be written with square brackets: <code>[1, 2, 3]</code> would
be syntax sugar for <code>-&gt; Int() | Void { yield 1; yield 2; yield 3 }</code>.</li>
</ul>
</li>
</ul>
<p>I have no idea when I&#39;ll find the time to actually work on this, but I&#39;d like to
see this language come together. I feel like this everything-is-a-coroutine type
system has a lot of potential as a new architecture for functional programming.</p>

    </div></div>
  </body>
</html>
