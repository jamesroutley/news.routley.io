<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://madebyevan.com/algos/crdt-fractional-indexing/">Original</a>
    <h1>CRDT: Fractional Indexing</h1>
    
    <div id="readability-page-1" class="page"><div>
      <section>
        

  

  
  <p>
    Collaborative peer-to-peer applications sometimes need to operate on sequences of objects with a consistent order
    across all peers. For example, a peer-to-peer photo album application might need to sync the order in which photos
    appear in an album. The algorithm presented here is one way to do this. It comes from a family of algorithms called
    <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDTs</a>, which I will not describe
    here. Unlike <a href="https://madebyevan.com/figma/realtime-editing-of-ordered-sequences/">my original article about this technique</a>,
    the algorithm presented here uses random offsets to avoid requiring a central server, and works in true peer-to-peer
    scenarios. Compared to <a href="https://madebyevan.com/algos/crdt-tree-based-indexing/">tree-based indexing</a>, fractional indexing is
    simpler but doesn&#39;t prevent interleaving of concurrently-inserted runs, which makes it inappropriate for textual
    data.
  </p>
  <p>
    <b><i>The algorithm:</i></b>
  </p>
  <ul>
    <li>
      <p>
        Each object is given a fractional position between 0 and 1 (exclusive). The object order is determined by
        sorting the objects by their positions (using object id as a tie-breaker).
      </p>
    </li>
    <li>
      <p>To insert an object between two other objects, set its position to a fraction in between the two other objects&#39;
        positions. To insert before any other object, substitute 0 for the first object&#39;s position. To insert after
        before any other object, substitute 1 for the second object&#39;s position.</p>
    </li>
    <li>
      <p>
        To prevent two peers from generating the same fraction (with high probability), add a random offset to the end
        of the fraction during each insert operation.
      </p>
    </li>
  </ul>
  <p>
    You can use any conflict-resolution strategy for syncing the fractional positions to other peers. The demo below
    assigns each write a timestamp and uses last-writer-wins to resolve conflicts, with the identifier of the peer that
    originally did the write as a tie-breaker.
  </p>
  <p>
    Fractional positions should be represented using arbitrary-precision decimals so that they don&#39;t run out of
    precision. Floating-point numbers are insufficient. For example, averaging a number with another number can only be
    done around 50 times with 64-bit floating-point numbers before the numbers become equal.
  </p>
  <p>
    Below is a demo of what this looks like in practice. Each quadrant represents a peer, and peers send messages to
    each other with a simulated network delay. Click <code>+</code> to insert new objects, <code>Ã—</code> to
    delete existing objects, and drag objects to reorder them. Click <code>Undo</code> or <code>Redo</code> for a given
    peer to rewind or playback that peer&#39;s local edits. Temporarily disable the simulated network with the pause button
    to construct simultaneous editing scenarios. You can use your browser&#39;s &#34;view source&#34; feature to view the source
    code for this demo:
  </p>

  </section>
  <canvas></canvas>
  <section>

    <p>
      This technique has the following benefits and drawbacks:
    </p>
    <p>
      <b>Benefits:</b>
    </p>
    <ul>
      <li>
        <p>It&#39;s easy to understand and implement.</p>
      </li>
      <li>
        <p>It doesn&#39;t require &#34;tombstones&#34; (i.e. preserving old object positions). Objects can be reordered any number
          of times without leaving any additional information behind. Deleted objects are allowed to be forgotten
          without disrupting the order of the remaining objects.</p>
      </li>
    </ul>
    <p>
      <b>Drawbacks:</b>
    </p>
    <ul>
      <li>
        <p>Index length can become long in pathological scenarios. This is typically harmless in practice because it
          happens rarely with human inputs.</p>
      </li>
      <li>
        <p>The edge case of averaging between two identical fractional positions doesn&#39;t work (since they are equal).
          This case is unlikely to happen in practice due to the randomized jitter that&#39;s added when generating new
          positions.</p>
      </li>
      <li>
        <p>If two peers both simultaneously insert a run of objects at the same location, the resulting objects may be
          interleaved. So this algorithm is not appropriate in situations where object adjacency is critical (e.g.
          using this to order photos in an album would be appropriate, but using this to order characters in a text
          document would not be appropriate).</p>
      </li>
    </ul>

    
    

      </section>
    </div></div>
  </body>
</html>
