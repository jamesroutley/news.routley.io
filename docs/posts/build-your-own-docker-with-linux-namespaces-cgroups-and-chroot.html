<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://akashrajpurohit.com/blog/build-your-own-docker-with-linux-namespaces-cgroups-and-chroot-handson-guide/">Original</a>
    <h1>Build your own Docker with Linux namespaces, cgroups, and chroot</h1>
    
    <div id="readability-page-1" class="page"><article>
            
  
<p>Containerization has transformed the world of software development and deployment. <a href="https://www.docker.com/" target="_blank" rel="noopener nofollow noreferrer">Docker<span> ‚ÜóÔ∏è</span></a>, a leading containerization platform, leverages Linux <a href="https://akashrajpurohit.com/blog/linux-namespaces-isolating-your-system-for-enhanced-security-and-performance/">namespaces</a>, <a href="https://akashrajpurohit.com/blog/linux-control-groups-finetuning-resource-allocation-for-optimal-system-performance/">cgroups</a>, and <a href="https://akashrajpurohit.com/blog/how-to-create-a-restricted-environment-with-the-linux-chroot-command/">chroot</a> to provide robust isolation, resource management, and security.</p>
<p>In this hands-on guide, we‚Äôll skip the theory (<em>go through the attached links above if you want to learn more about the mentioned topics</em>) and jump straight into the practical implementation.</p>
<div>
  <p><span>üôÖüèª‚Äç‚ôÇÔ∏è</span></p><div>
    
    <div>
      <p>Before we delve into building our own Docker-like environment using namespaces, cgroups, and chroot, it‚Äôs important to clarify that this hands-on guide is not intended to replace docker and its functionality.</p><p>Docker have features such as layered images, networking, container orchestration, and extensive tooling that make it a powerful and versatile solution for deploying applications.</p><p>The purpose of this guide is to offer an educational exploration of the foundational technologies that form the core of Docker. By building a basic container environment from scratch, we aim to gain a deeper understanding of how these underlying technologies work together to enable containerization.</p>
    </div>
  </div>
</div>

<h2 id="step-1-setting-up-the-namespace"><a aria-hidden="" tabindex="-1" href="#step-1-setting-up-the-namespace"><span></span></a>Step 1: Setting Up the Namespace</h2>
<p>To create an isolated environment, we start by setting up a new namespace. We use the <code>unshare</code> command, specifying different namespaces <code>(--uts, --pid, --net, --mount, and --ipc)</code>, which provide separate instances of system identifiers and resources for our container.</p>
<pre tabindex="0"><code><span><span>unshare</span><span> </span><span>--uts</span><span> </span><span>--pid</span><span> </span><span>--net</span><span> </span><span>--mount</span><span> </span><span>--ipc</span><span> </span><span>--fork</span></span></code></pre>
<h2 id="step-2-configuring-the-cgroups"><a aria-hidden="" tabindex="-1" href="#step-2-configuring-the-cgroups"><span></span></a>Step 2: Configuring the cgroups</h2>
<p>Cgroups (control groups) help manage resource allocation and control the usage of system resources by our containerized processes.</p>
<p>We create a new cgroup for our container and assign CPU quota limits to restrict its resource usage.</p>
<pre tabindex="0"><code><span><span>mkdir</span><span> </span><span>/sys/fs/cgroup/cpu/container1</span></span>
<span><span>echo</span><span> </span><span>100000</span><span> </span><span>&gt;</span><span> </span><span>/sys/fs/cgroup/cpu/container1/cpu.cfs_quota_us</span></span>
<span><span>echo</span><span> </span><span>0</span><span> </span><span>&gt;</span><span> </span><span>/sys/fs/cgroup/cpu/container1/tasks</span></span>
<span><span>echo</span><span> </span><span>$$</span><span> </span><span>&gt;</span><span> </span><span>/sys/fs/cgroup/cpu/container1/tasks</span></span></code></pre>
<p>On the third line we write the value <code>0</code> to the tasks file within the <code>/sys/fs/cgroup/cpu/container1/</code> directory. The tasks file is used to control which processes are assigned to a particular cgroup.</p>
<p>By writing <code>0</code> to this file, we are removing any previously assigned processes from the cgroup. This ensures that no processes are initially assigned to the container1 cgroup.</p>
<p>On the fourth line we write the value of <code>$$</code> to the tasks file within the <code>/sys/fs/cgroup/cpu/container1/</code> directory.</p>
<p><code>$$</code> is a special shell variable that represents the process ID (PID) of the current shell or script. By this, we are assigning the current process (the shell or script) to the container1 cgroup.</p>
<p>This ensures that any subsequent child processes spawned by the shell or script will also be part of the container1 cgroup, and their resource usage will be subject to the specified CPU quota limits.</p>
<h2 id="step-3-building-the-root-file-system"><a aria-hidden="" tabindex="-1" href="#step-3-building-the-root-file-system"><span></span></a>Step 3: Building the Root File System</h2>
<p>To create the file system for our container, we use <code>debootstrap</code> to set up a minimal Ubuntu environment within a directory named <code>&#34;ubuntu-rootfs&#34;</code>. This serves as the root file system for our container.</p>
<pre tabindex="0"><code><span><span>debootstrap</span><span> </span><span>focal</span><span> </span><span>./ubuntu-rootfs</span><span> </span><span>http://archive.ubuntu.com/ubuntu/</span></span></code></pre>
<h2 id="step-4-mounting-and-chrooting-into-the-container"><a aria-hidden="" tabindex="-1" href="#step-4-mounting-and-chrooting-into-the-container"><span></span></a>Step 4: Mounting and Chrooting into the Container</h2>
<p>We mount essential file systems, such as <code>/proc</code>, <code>/sys</code>, and <code>/dev</code>, within our container‚Äôs root file system. Then, we use the chroot command to change the root directory to our container‚Äôs file system.</p>
<pre tabindex="0"><code><span><span>mount</span><span> </span><span>-t</span><span> </span><span>proc</span><span> </span><span>none</span><span> </span><span>./ubuntu-rootfs/proc</span></span>
<span><span>mount</span><span> </span><span>-t</span><span> </span><span>sysfs</span><span> </span><span>none</span><span> </span><span>./ubuntu-rootfs/sys</span></span>
<span><span>mount</span><span> </span><span>-o</span><span> </span><span>bind</span><span> </span><span>/dev</span><span> </span><span>./ubuntu-rootfs/dev</span></span>
<span><span>chroot</span><span> </span><span>./ubuntu-rootfs</span><span> </span><span>/bin/bash</span></span></code></pre>
<p>The first command mounts the <code>proc</code> filesystem into the <code>./ubuntu-rootfs/proc</code> directory. The <code>proc</code> filesystem provides information about processes and system resources in a virtual file format.</p>
<p>Mounting the <code>proc</code> filesystem in the specified directory allows processes within the <code>./ubuntu-rootfs/</code> environment to access and interact with the system‚Äôs process-related information.</p>
<p>The next command mounts the <code>sysfs</code> filesystem into the <code>./ubuntu-rootfs/sys</code> directory. The sysfs filesystem provides information about devices, drivers, and other kernel-related information in a hierarchical format.</p>
<p>Mounting the <code>sysfs</code> filesystem in the specified directory enables processes within the <code>./ubuntu-rootfs/</code> environment to access and interact with system-related information exposed through the <code>sysfs</code> interface.</p>
<p>Finally we bind the <code>/dev</code> directory to the <code>./ubuntu-rootfs/dev</code> directory. The <code>/dev</code> directory contains device files that represent physical and virtual devices on the system.</p>
<p>By binding the <code>/dev</code> directory to the <code>./ubuntu-rootfs/dev</code> directory, any device files accessed within the <code>./ubuntu-rootfs/</code> environment will be redirected to the corresponding devices on the host system.</p>
<p>This ensures that the processes running within the <code>./ubuntu-rootfs/</code> environment can interact with the necessary devices as if they were directly accessing them on the host system.</p>
<h2 id="step-5-running-applications-within-the-container"><a aria-hidden="" tabindex="-1" href="#step-5-running-applications-within-the-container"><span></span></a>Step 5: Running Applications within the Container</h2>
<p>Now that our container environment is set up, we can install and run applications within it. In this example, we install Nginx web server to demonstrate how applications behave within the container.</p>
<pre tabindex="0"><code><span><span>(</span><span>container</span><span>) $ apt update</span></span>
<span><span>(</span><span>container</span><span>) $ apt install nginx</span></span>
<span><span>(</span><span>container</span><span>) $ service nginx start</span></span></code></pre>

<p>By taking a hands-on approach and exploring the code and command examples, we‚Äôve gained a practical understanding of building our own Docker-like environment using Linux namespaces, cgroups, and chroot.</p>
<p>Of course docker containerization is lot more than what we just explored above but these fundamentals empowers us to create isolated and efficient environments for our applications.</p>
  

          </article></div>
  </body>
</html>
