<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.alicemaz.com/writing/program.html">Original</a>
    <h1>How I think when I think about programming</h1>
    
    <div id="readability-page-1" class="page"><div>


<figure>
<img src="https://www.alicemaz.com/writing/assets/img/writing/program/title.jpg"/>
<figcaption>a schematic overview of charles babbage&#39;s analytical engine</figcaption>
</figure>

<p>
this is a post I&#39;ve wanted to write for some time.
in it, I attempt to explain, on a very basic level, how I think about programming.
my hope is to give newer programmers some background knowledge and bigger-picture context.
to help give form and structure to what is often presented as just a bunch of shit to remember
</p>

<p>
I don&#39;t attempt to teach programming per se.
I don&#39;t cover all the details needed to write a program that compiles and runs.
there are very many guides for that.
I don&#39;t discuss computer science, nor do I get into type theory, though both of these topics can serve as a highly eluciditory basis for understanding programming.
I talk about &#34;fundamentals&#34; a lot, but my fundamentals aren&#39;t a set of overarching theories.
just a bag of tools
</p>

<p>
my goal is to impart some general heuristics about how to think about programming for the subset of people who happen to think like me
</p>

<p>
I got started programming by just messing around.
making tiny modifications to existing javascript twitter bots to fashion my own, with a &#34;fuck it, whatever works&#34; kind of attitude.
gradually my modifications got more ambitious, and after a couple months I could write the programs myself.
a couple months after that, I found someone doing freelance webdev willing to take me on as a junior partner.
and then from there I just kinda learned on the job
</p>

<p>
I generally consider theory to be useful background knowledge but fastidious study a poor substitute for firsthand experience.
I &#34;learn with my hands,&#34; is the way I&#39;ve always put it.
it has its upsides and downsides
</p>

<p>
getting up to &#34;working knowledge&#34; on something is usually trivial for me.
I can speedrun in weeks what might take others months, or months what could take them years.
I just bang my head on the problem until it (the problem, ideally) breaks
</p>

<p>
on the other hand, it means that I usually power through things in manic bursts.
I easily get bored once progress becomes more incremental, when patience and diligence pay higher dividends than brashness and force.
I go back and forth on whether I can and should train myself to be more disciplined, or if I am just a natural crosspollinator-type human and should just embrace it
</p>

<p>
anyway, if this description of how I learn feels familiar to you, it is likely that the way I think about this stuff will be useful.
if you learn better in a formal classroom setting, or with guided mentorship, or through diligent study, or by leaning on carefully composed theoretical foundations, then it&#39;s possible the only value this post can provide is a voyeur&#39;s glimpse into how the fauves live
</p>

<p>
I&#39;ve given bits and pieces of these lectures to at least a dozen people who&#39;ve come to me at various times for advice about how to get started with programming.
I deliver a rundown of the fundamental abstractions used in imperative programming.
then I give a glimpse above, at abstractions that can be constructed out of them, and a peek below, at what they themselves abstract over
</p>

<p>
&#34;abstraction&#34; in mathematics means to use a higher-level concept that carries fewer assumptions but covers a broader superset of cases.
complexity is removed for the sake of generalizability.
&#34;abstraction&#34; in programming means to paper over the underlying workings of a system with shorthands or conveniences.
complexity is added so you can pretend it isn&#39;t there.
no matter how you dress it up, when you&#39;re using a computer, you are always somewhere in the jenga pagoda
</p>


master the fundamentals, understand how they&#39;re composed into abstractions, and you can pick almost anything up as you go.
I&#39;ve gotten hired for jobs where I didn&#39;t know the language I&#39;d be writing, expecting to learn it on their dime in the first couple days.
it&#39;s easy once you stop seeing syntax and features like &#34;so what does this thing do...&#34; and start seeing &#34;ah, this is what they call that.&#34;
not a ubiquitous skill in software, but not an uncommon one


<p>
the volume of software in existence is massive.
hundreds of ecosystems, thousands of tools, millions of libraries.
if you tried to learn them all as individual things, it would be impossible.
but they&#39;re all built out of the same basic parts
</p>

<p>
I remember when I first started programming, looking at job postings and seeing dozens of languages, tools, acronyms, jargon rattled off as necessary requirements.
java c# php perl js ajax ruby go mysql postgres angular react agile scrum aws azure.
it was daunting!
I barely knew one thing, how was I going to learn 10 or 15, just to get started working?
</p>

<p>
now I roll my eyes at these lists.
I know what they all are, I&#39;ve dabbled in many, I can easily learn any of them to professional proficiency.
a lot of them are particular cases of general things, a lot of them are different words for the same thing, a lot of them are just bullshit.
but all of them can be comprehended at a glance and learned by doing
</p>

<p>
learning a new technology, for an experienced programmer, usually doesn&#39;t look like concerted study, thwarted attempts, struggle and triumph.
it looks like reading a three-paragraph summary of it, coding in or against it based on vibes, checking documentation for syntax, and bitching about how dumb the guy who designed it must have been
</p>

<p>
the title of the post is &#34;how I think about programming,&#34; not &#34;how you should think about programming.&#34;
therefore I will brook no criticism.
I&#39;m a strong believer in learning styles, and I think people should naturally adopt what is most comfortable.
if everything that follows rings false, we probably just have different perspectives
</p>

<p>
the material should be reasonably accessible to anyone who possesses general familiarity with a curlybrackets language.
I admit sometimes I may move too fast, and other times I may get bogged down in detail.
I do my best to explicitly introduce technical terminology before making it load-bearing.
but pedagogy is hard, and unless you&#39;re constantly working with new learners, it&#39;s very difficult to keep in mind all the little quirks and customs that you&#39;ve come to take for granted
</p>

<p>
if this post feels valuable, but parts are inaccessible, it may be worth revisiting as you gain more experience.
I&#39;m trying to bridge gaps between concepts, more than I am trying to actually teach the concepts themselves.
form, rather than content
</p>

<p>
I&#39;ve been programming for about six years now.
before that, I cooked pancakes for a living.
don&#39;t believe anyone who says you need a fancy degree, specialized training, or exposure since childhood to code.
you can pick up programming just by being clever and stubborn
</p>

<p>‚ùß</p>

<h2>kata one</h2>
<h3>variables, flow control, scope, functions</h3>

<p>
the first set of basics are assignment, flow control, and scope.
all examples are in c unless otherwise stated.
don&#39;t be scared if you&#39;re used to python or js.
c is very easy to write.
it&#39;s only hard to write correctly
</p>

<p>
assignment is conceptually very simple.
you are storing a value in some named piece of storage:
</p>
<pre><code>int a = 2;
</code></pre>
<p>
here, the value 2 is being stored in <code>a</code>, an integer variable.
you can access the value via the name you&#39;ve given your storage:
</p>
<pre><code>printf(&#34;%d\n&#34;, a); // prints 2
</code></pre>
<p>
and you can use it for further assignments:
</p>
<pre><code>int b = 3;
b = b + a; // b is now 5
</code></pre>
<p>
the algebraically confusing second line is not an equation.
the value of <code>a</code>, then 2, is loaded out of its storage space, and added to the value of <code>b</code>.
the sum is stored back in the space <code>b</code>, replacing the 3 that used to be there
</p>

<p>
the thing to remember is that <code>a</code> and <code>b</code> are not objects.
they are names of boxes in which we deposit objects
</p>

<p>
normally a program proceeds top to bottom, line by line, executing each statement and moving on to the next.
it does this forever, until it encounters a statement that tells it to stop, or a kind of error that forces it to stop.
but a program that can only proceed or halt cannot do much that is really interesting
</p>

<p>
programs become truly expressive once you have a way to change the future order of execution based on some present state.
mechanisms that do this are called control-flow constructs, and the two most common are branches and loops
</p>

<p>
this is a branch:
</p>
<pre><code>if(a &gt; 2) {
    a = 3;
}
else {
    a = 4;
}
</code></pre>

<p>
the condition is checked, and based on the result, one of two different blocks will be executed.
the code in the blocks can be arbitrarily complex.
you can have several conditions checked in sequence, or more complicated constructs with fallthrough rules, but they are computationally equivalent
</p>

<p>
this is a loop:
</p>
<pre><code>int a = 0;
do {
    a++;
} while(a &lt; 10);
</code></pre>

<p>
the block is executed once unconditionally, then the condition is checked, and based on the result, the block will either be run again, or flow will proceed past the loop to continue as normal.
depending on what condition you set, the loop can execute arbitrarily many times, possibly indefinitely.
there are other loop forms that check the condition at the top, or lack a condition and force you to explicitly abort inside a nested branch, but they are computationally equivalent
</p>

<p>
in c, coherent units of execution are grouped together in blocks.
blocks are self-contained, enclosed in curlybrackets, and can have their own isolated storage space.
when the end of a block is reached, program flow continues in the context it was contained in.
in this way, blocks are nested inside each other, ultimately all nested in the <code>main</code> function.
a block can access storage areas from its outer containers, but once execution moves outside of a block, all of that block&#39;s storage is lost, though changes it made to outside storage is kept
</p>

<p>
the area of influence a block has, including storage it owns and storage it can access, is called its scope.
a block that has a name and can be invoked from somewhere else and passed information is called a function
</p>

<pre><code>int timestwo(int n) {
    int x = n * 2;
    return x;
}

for(int i = 0; i &lt; 10; i++) {
    int x = timestwo(i);
    printf(&#34;%d\n&#34;, x);
}
</code></pre>
<p>
here, the increasing values of <code>i</code> generated by the <code>for</code> loop are passed in as an argument to the function <code>int timestwo(int)</code>.
an <code>x</code> is calculated inside the scope of the function and returned to its caller.
it then is assigned to <code>x</code> outside, a completely different storage location which just happens to share a name.
the storage that was internal to <code>int timestwo(int)</code> is now gone
</p>

<p>
it&#39;s worth noting that other languages, notably javascript, have a somewhat different notion of scope than c.
the point I would make is that scope, like many things in programming, is a convention, not a fact of reality.
most of the rules don&#39;t really &#34;mean&#34; anything on a deep level.
they don&#39;t transcend the contexts in which they were implemented
</p>

<p>
type theorists, computer scientists, and category theorists would have a very different view on such an assertion.
but that isn&#39;t relevant to us right now.
we fuck around and find out
</p>

<p>
learn the rules, how to play within their bounds, and how any when to break them.
existentially meaningless but internally consistent is the way to approach.
if you obsess over what everything &#34;really means,&#34; you will get lost.
this is useful for navigating many systems designed by humans besides programming languages
</p>

<p>‚ùß</p>

<h2>digression one</h2>
<h3>what is &#34;kata&#34;</h3>

<p>
I like to think of basic programming concepts as akin to martial arts kata.
those of us who tried karate as kids probably remember going in expecting to be doing flips and flying kicks from day one.
we were instead instructed to perform the same punch, over and over, without variation.
this is kata: the most elementary building block of technique
</p>

<p>
kata is, I think, the secret to how you actually get good at programming.
learning the big fancy stuff‚Äîbaroque libraries, sprawling plugin ecosystems, towering frameworks‚Äîto a very deep level is the province of domain specialists.
I respect what they do when they&#39;re good at it, but it is not how I work
</p>

<p>
the way I see it, to be really good, you don&#39;t need to study any particular big thing.
you need to practice and understand the small things, over and over, until they&#39;re second nature.
a 100ms lag time on an interface is the limit below which response will feel instantaneous.
you want to be able to work that fast with the absolute basics.
fast enough that you don&#39;t have to think about them at all
</p>

<p>
there is a wonderful quote by bruce lee that I love to deploy whenever appropriate:
</p>

<blockquote>Before I learned the art, a punch was just a punch, and a kick, just a kick. After I learned the art, a punch was no longer a punch, a kick, no longer a kick. Now that I understand the art, a punch is just a punch and a kick is just a kick.</blockquote>

<p>
before you understand a field, you are mired in sameness.
everything is opaque and undifferentiated.
as you learn more, you begin to distinguish elements, group them into classes, construct a taxonomy.
when you really, deeply understand something, it gets harder to hold to such strict distinctions, but easier to feel.
you can discuss and build models, but you hold those models as contingent and insufficient
</p>

<p>
there is something deep in the tension between analysis and synthesis that goes way beyond this topic.
I feel like that tension is one of the really important ideas about thought, people, cultures, the world.
I can&#39;t really articulate the weight of it properly.
it&#39;s just a feeling
</p>

<p>
having only holism, you are a rube, a sitting duck.
you know not.
armed with reason, the ability to categorize, to distinguish and dissect, you are dangerous, a weapon.
you think you know, but you still don&#39;t.
it is essential to relearn holism with a grounding in reason to be able to move past this, to feel the world without turning what you touch into ash
</p>

<p>
there&#39;s a stereotype that a scholar-bureaucrat adheres to confucian doctrine in his working years, then indulges in daoism upon retiring.
it is probably true that pushing past petty analysis makes it harder to tolerate bullshit, to be a cog in an ugly system, to accept duty and sacrifice.
but it also makes you frighteningly effective at work, for those things you do deem valuable enough to work on
</p>

<p>
that is the higher goal I&#39;m setting here, for this one little field, that itself has remarkably little to say about life.
don&#39;t get stuck in the models.
see past them.
and then you can see, a kick is just a kick
</p>

<p>‚ùß</p>

<h2>memory semantics one</h2>
<h3>stack and heap</h3>

<p>
we&#39;ve been talking about variables in terms of placing values into boxes that we access with convenient names.
the place where all those boxes reside is called memory
</p>

<p>
memory has no inherent structure or meaning to it.
it is a very long series of one-byte (eight binary bits, max value 255) boxes, numbered starting from 0, all the way up into the billions.
all meaning that the sequences of bytes in memory contain is imposed by the programmer, and thus the programs they write and run on top of
</p>

<p>
when a program is started, the operating system provides it with the illusion that it is the only program on the machine.
its address space starts from the special 0 address‚Äîunwritable and used as a standard null value‚Äîand nothing else tramples upon its preserve
</p>

<p>
it needn&#39;t be this way: msdos famously passed full control of all memory to any program, meaning everything ran as root and multitasking didn&#39;t exist.
but unix-style virtual memory allows each program to arrange its own memory however it sees fit while protecting other programs and the os from misbehavior.
by convention, usually memory has a handful of read-only sections, plus two major writable sections, called stack and heap
</p>

<p>
the stack is a last-in, first-out queue that starts at the last address in memory, and grows downward, toward the lower addresses.
every time you call a function, one stack frame is added on top of the stack.
a stack frame is a chunk of space where one function&#39;s arguments and internal storage live.
when a function returns, its stack frame is disregarded, and the new top of the stack is once again the function that originally called it
</p>

<p>
the heap starts from somewhere after the 0 address and grows up toward higher addresses.
it is persistent storage, controlled by the programmer directly, and unrelated to where in the function stack you are.
you directly ask the operating system for a chunk of memory of a specific size via the function <code>malloc</code>:
</p>
<pre><code>int *a = malloc(sizeof(int) * 16);
</code></pre>
<p>
here, enough space for 16 integers is allocated.
each integer is multiple bytes, needed to store numbers larger than 255.
our chunk of memory is called a &#34;buffer,&#34; and malloc returns a pointer to its first byte
</p>

<p>
unless released, our buffer will persist for the entire life of the program.
when we&#39;re done with it, we tell the operating system, so it can recycle the space back into the pool it allocates memory from:
</p>
<pre><code>free(a);
</code></pre>

<p>
the reason why stack and heap grow in opposite directions (towards each other) is so programs have use of all memory available to them if they need to allocate much more on one than the other
</p>

<p>‚ùß</p>

<h2>kata two</h2>
<h3>indirection and recursion</h3>

<p>
as we&#39;ve seen, every location in memory has an address, and the named boxes we&#39;ve been storing data in are really just pieces of memory.
we can take any of our boxes and get the address its storage starts at as a value we can then store somewhere else:
</p>
<pre><code>int i = 3;
int *p = &amp;i;
</code></pre>
<p>
the asterisk in the type of <code>p</code> indicates that this variable stores a pointer, ie a memory address.
the ampersand is the address-of operator, returning the address of the storage used by a variable
</p>

<p>
the address can then be dereferenced, ie the pointer can be followed and the value at the address it points to retrieved:
</p>
<pre><code>printf(&#34;%p: %d\n&#34;, p, *p); // prints something like &#34;0x7ffd12bd3958: 3&#34;
</code></pre>

<p>
the function <code>malloc</code> returns the type <code>void *</code>, that is, a pointer that could point to anything.
traversing pointers to use or manipulate values stored at their address is often called &#34;indirection&#34; because it is an indirect mechanism of data access
</p>

<p>
pointers can nest arbitrarily deep.
you can have pointers to pointers, and so on, forming large, abstract graphs.
the don&#39;t truly &#34;nest.&#34;
fundamentally pointers are just numbers, stored in memory, like large integers.
it&#39;s only because they&#39;re interpreted as memory addresses that they have any meaning
</p>

<p>
because strings in c are just continuous series of characters, a collection of strings may be represented by the double pointer <code>char **</code>.
it&#39;s useful to use double pointers to resizable containers so functions can reallocate storage implicitly when needed without breaking references.
complex objects are typically represented by structures that point to structures which themselves point to structures.
and so on
</p>

<p>
recursion is the idea of a function calling itself, effecting sequential repeated execution in a manner not unlike a loop.
the classic examples of this are the factorial and fibonacci functions, where any result depends on all previous results of the same calculation.
this allows them to be expressed succinctly and naturally (albeit often horrifically inefficiently) via recursion:
</p>
<pre><code>int factorial(int n) {
    if(n == 0) {
        return 1;
    }
    else {
        return n * factorial(n - 1);
    }
}
</code></pre>

<p>
here, if you were to call <code>factorial(5)</code>, the function would fall into the <code>else</code> branch, and attempt to calculate <code>5 * factorial(4)</code>.
this would necessitate another call into the function, and another, until hitting the &#34;base case&#34; of <code>n == 0</code>.
then a series of returns effectively unwind all the function calls made thus far, producing the result 120
</p>

<p>
clever use of recursion allows you to iterate in much more complex ways than a simple loop.
it is much easier, for instance, to continuously subdivide a group to perform some task on the subsets with recursion than with looping.
various means of sorting collections, or searching for items in complicated nested hierarchies, are naturally suited to being subdivided or accumulated in this manner
</p>

<p>
things get even more interesting in a language with first-class functions.
that is, functions that can be assigned to variables, passed as values, and constructed at runtime (crucially, capturing the environments in which they are constructed).
c has the first two properties but not the third.
moreover, its syntax for function pointers is notoriously cumbersome, and the language is just not suited for this kind of programming.
javascript, being at its core the worst dialect of scheme, has all the necessary features
</p>

<p>
in a language with first-class functions, you can easily construct functions that accept and apply other functions as arguments, recursively.
these, being functions of functions, are called higher-order functions
</p>

<p>
hofs allow you to very simply express concepts like &#34;apply this operation to all members of a list,&#34; &#34;remove all members from the list that fail some boolean test,&#34; or &#34;combine all the elements of a list into a result using some specified operation.&#34;
there are various reasons one would want to do this, but the most obvious is they allow iteration that depends on the structure of what is being iterated over, in a way that doesn&#39;t require explicitly tracking position or mutating existing data
</p>

<p>
these functions are also &#34;pure,&#34; meaning they operate data-in, data-out, with no side effects.
this makes it very easy to chain operations together into pipelines, and even to regard those pipelines as objects in their own right.
stream programming, which regards the pipelines as the units of concern, and data merely as what flows through them, offers a drastically different perspective on what&#39;s really &#34;happening&#34; in a program
</p>

<p>
it is absolutely essential to have an intuitive grasp on indirection and recursion.
this is perhaps the most important factor distinguishing a clumsy programmer from a deft one.
indirection and recursion are harder at first than storage and flow because their usage forms conceptual graph structures that you must be able to see in your head to manipulate and traverse
</p>

<p>
remember, the golden rule is to know the basics so well that you shift from conscious thought to reflex action.
it took me a long time after learning about these concepts before I could properly feel them.
there&#39;s no shortcut around repeated exposure
</p>

<p>‚ùß</p>

<h2>memory semantics two</h2>
<h3>structs, arrays, enums</h3>

<p>
a struct is a blueprint for a composite datatype, consisting of a series of named fields of particular types:
</p>
<pre><code>struct User {
    char *username;
    int pin;
    bool active;
};

struct User user = { &#34;alice&#34;, 1234, true };
</code></pre>

<p>
on the surface, a struct is a way of grouping together several variables into one structure that can be accessed and passed around as a unit.
underneath, a struct is just a buffer.
it is just enough space for the sum of its field sizes, allocated contiguously in memory.
every type you include in a struct must have a fixed size known at compile time.
this means that the struct itself is of a fixed size
</p>

<p>
because all field sizes are known in advance, you can access struct fields by fixed offsets.
the struct itself can be reduced to a pointer to its first field, or, equivalently, the memory address of the start of the buffer.
you can use this plus the offsets to access particular fields:
</p>
<pre><code>assert(user.pin == &amp;user + sizeof(char *)); // true
</code></pre>

<p>
it&#39;s worth noting the word &#34;struct&#34; is pulling double duty.
it may refer either to the definition of the fields that constitute the type.
or it may refer to an instantiation of that definition, a particular buffer somewhere in memory.
the definition is just a blueprint for making any number of separate buffers
</p>

<p>
a struct is very conceptually similar to a tuple, an idea more common in functional programming, which is just a specific sequence of datatypes without any field names.
in fact, some languages only have tuples, and provide a struct-like record syntax that desugars to simple tuple member access
</p>

<p>
an array is a series of boxes all of the same datatype, backed by a single buffer (which is, as always, contiguous in memory):
a series of integers can be represented by an int array.
strings in c are represented by an array of chars, terminated by a null symbol
</p>

<pre><code>int evens[] = { 2, 4, 6, 8 };
char name[] = { &#39;a&#39;, &#39;l&#39;, &#39;i&#39;, &#39;c&#39;, &#39;e&#39;, &#39;\0&#39; };
</code></pre>

<p>
an array can be reduced to a pointer to its first element, ie the start of the buffer.
with this, you can do pointer math to access arbitrary elements.
because every slot is the same size, an item is just an offset multiplied by the slot size:
</p>
<pre><code>assert(evens[3] == evens + 3 * sizeof(int)); // true
</code></pre>

<p>
arrays are not the same concept as lists, although people will sometimes refer to them offhand as that.
a list is a noncontinguous series of boxes, each of which contains a value and a pointer to the next box:
</p>
<pre><code>struct Node {
    int x;
    struct Node *next;
};
</code></pre>
<p>
the last box in the list points to the null address to indicate the end.
lists are convenient if you want to add new items without having to reallocate existing storage, because you just have to fix up some pointers.
to access any particular item, however, you have to traverse pointers from the start until you find it
</p>

<p>
if you change both fields in such a struct to void pointers, you get the humble cons cell, the famously versatile lisp primitive:
</p>
<pre><code>struct Cons {
    void *car;
    void *cdr;
};
</code></pre>
<p>
cons cells are flexible enough to construct essentially arbitrary data structures.
the elegance of lisp comes from the fact that it represents its own code with cons cells, which are in and of themselves working parse trees.
because lisp can manipulate and run lisp code as easily as it can manipulate any data, the language is perhaps uniquely suited for metaprogramming
</p>

<p>
enums are a way of representing a very simple set of mutually exclusive choices, where any enum value is one of those choices:
</p>
<pre><code>enum Color {
    Red,
    Green,
    Blue,
};
</code></pre>
<p>
underneath, an enum is represented as a single integer.
there is a more complex construct, called the union, which can represent choices between two different concrete datatypes, which may include structs.
a common pattern, called a tagged union, combines the two, using an enum to indicate which struct variant a union represents
</p>

<p>
to step back from c, it should be appreciated that these concepts represent something more fundamental than some language&#39;s arbitrary mechanism for declaring datatypes.
a struct or tuple represents a collection of different types grouped together in a particular order.
a tagged union, or equivalently an enum that can carry a value (as it can in some languages), represents a mutually exclusive choice between different types.
these are called product types and sum types respectively, and can be nested recursively to make types of arbitrary complexity
</p>

<p>
to wit, our c types in haskell:
</p>
<pre><code>data User = User { username :: String
                 , pin :: Int
                 , active :: Bool
                 }

data List = Node { x :: Int
                 , next :: Node
                 } | Nil

data Cons a b = Cons a b

data Color = Red | Green | Blue
</code></pre>

<p>‚ùß</p>

<h2>paradigms</h2>
<h3>imperative and oop</h3>

<p>
the point of all that was to show the simple primitives that everything builds on top of.
variables, functions, arrays, structs, loops, branches, pointers, and recursion.
whatever complicated concepts you encounter in higher-level languages, they are more or less composed of these basic elements.
often quite literally: the primary implementation language for higher-level languages is c.
understanding what building blocks an author had to work with often makes it much easier to draw conclusions about how their work is likely put together
</p>

<p>
with this in mind, we will explore how to assemble a stripped-down version of the core abstractions of another style of programming, using our simple imperative toolbox
</p>

<p>
object-oriented programming is a paradigm that is easily accessible to imperative programmers because most of the popular languages for it now can be summed up as &#34;imperative programming plus some extra stuff.&#34;
there is no reason why it had to be this way.
if languages like simula, smalltalk, and eiffel (especially eiffel, google &#34;design by contract&#34; sometime) had become the foundation of modern oop, we would be having a very different conversation right now.
but, as it turned out, these first oop languages ended up serving as sources of ideas for languages otherwise grounded in the imperative paradigm
</p>

<p>
all mainstream object-oriented programming derives from c++.
c++ was created as the successor to a language called &#34;c with classes&#34; and might itself be appropriately named &#34;c with everything not in c.&#34;
c++ is not a strict superset of c, but most reasonable c programs are valid c++ as well
</p>

<p>
java descends directly from c++, originally written to replace it in contexts where it was too unwieldy, and adopts its curlybrackets syntax and many of its basic assumptions.
javascript was heavily inspired by scheme, but had a curlybrackets syntax bolted onto it, and now has oop-friendly class-based inheritance syntax to hide its more unique prototype-based internals.
c#, don&#39;t let the name fool you, is microsoft java.
objective c was the only language in common use that followed the spirit of smalltalk, but it was criticized and eventually deprecated in part because people found it &#34;too weird&#34;
</p>

<p>
if you are a new programmer, don&#39;t feel you have to understand any of the previous three paragraphs.
it is more an apologia for the sweeping generalizations I&#39;m about to make
</p>

<p>
there was a period in the 90s and 00s when java was the standard teaching language for intro cs students.
this was always contentious and criticized, and I think that taking oop abstractions as a baseline truth, rather than grounding yourself in the kata I&#39;ve presented, is a mistake.
I usually deliver this example of oop abstractions built from imperative fundamentals as a corrective to people with &#34;everything&#39;s an object&#34; brainworms.
the object abstraction is totalizing in oop, but once you slice it open and flip it inside out, it&#39;s easier to see as a simple organizational tool
</p>

<p>
going between seeing objects as organization schemes and objects as objects is kind of like watching the optical illusion dancer gif spin one way or the other.
declarative programming, functional programming, continuation-passing style, and various other formalisms have this same kind of feel, once you know them well.
you can think in them, or about them, at will, and feel that shift in your perception as you go from one to the other
</p>

<p>
fundamentally, an object is a... thing... that bundles state (variables) and functionality (functions) together.
a class is a blueprint for a type of object, describing what state variables it has, and what functions, called methods, can operate on that state.
and then an object is a concrete instantiation of that class, with its own storage, independent from all others
</p>

<p>
no outside entities can read from or write to an object&#39;s internal state.
it is, as the parlance goes, encapsulated.
methods are the sole means of access or mutation.
the point of all this is to force all stateful computation through a small set of gatekeeper functions, implemented all in one place, so the program is easier to refactor (rearrange) and reason about
</p>

<p>
unfortunately, we don&#39;t have anything like classes or methods in our imperative language.
we only have structs and functions
</p>

<p>
oop examples are always like, corporate database stuff, or cars for some reason, so I&#39;m consciously fighting that impulse:
</p>
<pre><code>typedef struct Android Android;
struct Android {
    char *name;
    char *secret_name;
    unsigned int kills;
    bool on_mission;
};
</code></pre>
<p>
the typedef is just cute syntax to let us write the type as <code>Android</code> instead of <code>struct Android</code>
</p>

<p>
then with that struct definition, we can initialize new instances of such a struct:
</p>
<pre><code>Android a_two = { &#34;A2&#34;, &#34;No2&#34;, 972, true };
</code></pre>
<p>
again, a struct is nothing special.
it&#39;s syntax for reserving the correct amount of space for a series of variables, accessing fields via pointer offsets, and some compile-time type safety checks
</p>

<p>
if we want to frequently make androids, and especially if we want to persist them and pass them around, we may want a function that does the setup for us:
</p>
<pre><code>Android* make_android(char *name, char *secret_name) {
    Android *a = malloc(sizeof(Android));

    a-&gt;name = name;
    a-&gt;secret_name = secret_name;
    a-&gt;kills = 0;
    a-&gt;on_mission = false;

    return a;
}

Android *two_b = make_android(&#34;2B&#34;, &#34;2E&#34;);
Android *nine_s = make_android(&#34;9S&#34;, NULL);
</code></pre>
<p>
when you want to make a new android, you just pass in its names.
the rest is standard and only needs to be written once
</p>

<p>
note that <code>a_two</code> is a stack-allocated struct, which means it will go out of scope when the block it was created in is exited.
<code>two_b</code> and <code>nine_s</code> are stack-allocated pointers to heap-allocated structs.
they can be accessed as long as a copy of the pointer is retained somewhere and are never deallocated unless explicitly freed.
the strings likewise never scope out.
their data is compiled directly into the binary, and the char pointers are just the address where that data resides
</p>

<p>
struct data can be modified anywhere with no constraints:
</p>
<pre><code>// send 2B on a mission
two_b-&gt;on_mission = true;

// 2B scores a kill
two_b-&gt;kills++;
</code></pre>
<p>
this can make it hard to track down bugs, if your program is passing around pointers to these structs and mutating their contents anywhere.
it becomes a thousand times worse if concurrency is involved because then things might get changed in the middle of other things using them
</p>

<p>
one solution to this is to be very strict with ourselves that we&#39;ll never touch struct data except in special functions written for this purpose.
this gives us one place to put correctness checks so we never forget them, and one place to put debug logging when trying to diagnose a problem
</p>

<p>
we only need to write each function once.
we have them accept a pointer to a struct, and then we modify whichever struct is given to us:
</p>
<pre><code>int go_on_mission(Android *a) {
    if(a-&gt;on_mission) {
        fprintf(stderr, &#34;%s is already on a mission!\n&#34;, a-&gt;name);
        return 1;
    }

    a-&gt;on_mission = true;
    return 0;
}

void score_kill(Android *a, bool was_friendly) {
    if(was_friendly) {
        printf(&#34;redacting combat logs...\n&#34;);
    }
    else {
        a-&gt;kills++;
    }
}

go_on_mission(two_b);
score_kill(two_b, false);
</code></pre>

<p>
we have now invented the basics of object-oriented programming.
by enshrining our formalism in the language, we can stop viewing it as a handful of conventions employed when working with structs and functions.
we can instead roll all the pieces into a single abstraction, hide the details under syntax, and think of the <em>abstraction</em> as the agent:
</p>
<pre><code>class android {
    string name;
    string secret_name;
    unsigned int kills;
    bool on_mission;

    public:
        android(string name, string secret_name) {
            this-&gt;name = name;
            this-&gt;secret_name = secret_name;
            this-&gt;kills = 0;
            this-&gt;on_mission = false;
        }

        int go_on_mission() {
            if(this-&gt;on_mission) {
                fprintf(stderr, &#34;%s is already on a mission!\n&#34;, this-&gt;name.c_str());
                return 1;
            }

            this-&gt;on_mission = true;
            return 0;
        }

        void score_kill(bool was_friendly) {
            if(was_friendly) {
                printf(&#34;redacting combat logs... %d corrected kills\n&#34;, this-&gt;kills);
            }
            else {
                this-&gt;kills++;
            }
        }
};

android *two_b = new android(&#34;2B&#34;, &#34;2E&#34;);

two_b-&gt;go_on_mission();
two_b-&gt;score_kill(false);
</code></pre>

<p>
the above code is c++.
despite that, there is nothing truly new.
all the functionality is, from a user&#39;s perspective, largely the same as the preceding snippets of c
</p>

<p>
the c++ class contains both the fields of our c struct and the functions we wrote that accept a pointer to the struct as a parameter.
the c++ function <code>android</code> is a constructor, and identical to the c function <code>make_android</code>, except the heap allocation is now implicit.
the class constructor is invoked implicitly via the <code>new</code> keyword
</p>

<p>
the functions <code>go_on_mission</code> and <code>score_kill</code> likewise are the same, except now they are methods.
they still take a pointer as their first argument!
but this argument is hidden from the function signature, and its value is accessed by the <code>this</code> identifier
</p>

<p>
and finally, because the data fields are not marked <code>public</code> like the methods, nothing outside of the class can access them.
if we were to write something like <code>two_b-&gt;kills</code>, it would result in a compiler error
</p>

<p>
there is so, so much more in oop, but none of it is truly fundamental.
I don&#39;t mean to pick on the paradigm, but for various reasons it tends to be the worst in terms of making simple things complicated.
java, in particular, became in the 00s a way to deskill programming and render the programmer fungible, and so accumulated slogans and stereotypes meant to make it easier to cycle engineers through projects
</p>

<p>
inheritance, interfaces, and abstract classes are ways to add more methods to things implicitly.
operator overloading, generics, (subtype) polymorphism, overrides, and reflection are ways to make functions more flexible or mess with function dispatch.
there is an entire cult of &#34;design patterns&#34; drawn from an ominously named book people just call &#34;gang of four&#34; that has an entire eldritch taxonomy of things your enterprise company boss wants you to memorize for half of an entry-level tech salary.
visitor patter, observer pattern, decorator pattern, singleton, factory beans factory factory
</p>

<p>
you do not need to learn any of this shit unless a client is paying you for it.
and even then, consider it an occupational hazard
</p>

<p>
all these details are not really important, and if you are already familiar with oop, this may be horribly long-winded.
my actual point is this: there is nothing special about the object abstraction.
it&#39;s just built up out of our fundamental kata.
but when you come up with an abstraction, and you roll it up to be watertight, it lets you stop thinking about the details underneath.
none of what we do as programmers would work if we had to think about the implementation details of everything all the time
</p>

<p>
the danger is that people who come along later may not know what happens underneath.
they come to think in terms of the abstraction alone.
so when the abstraction fails them, as it always inevitably does, they don&#39;t have the context to even understand what is happening
</p>

<p>
oop is the worst culprit of this kind of thinking because objects present themselves as literal objects.
it is very seductive to see them as real things that actually exist.
people come to think in the metaphor and the metaphor becomes real
</p>

<p>
I wanted to do a similar construction of functional programming.
start with simple recursion, build up to maps and folds, restrict ourselves to single-assignment (immutability).
but it would be another tour like this, and I hope I&#39;ve made my point.
no abstraction is magic, they are almost always conceptually very simple, and it can all be learned, easily, if you know the basics
</p>

<p>
the last thing I will say about oop is, if you absolutely must niche into it, go for c++, not java.
java engineers are made to be replaceable.
learn template metaprogramming and give yourself job security until you die
</p>

<p>‚ùß</p>

<h2>digression two</h2>
<h3>odds and ends</h3>

<p>
before getting into the last major technical section, I wanted to share some practical advice on a variety of topics in no particular order.
in other words, I want to ramble
</p>

<p>
I said this is not a tutorial on how to program.
so, how the hell do you learn to program?
</p>

<p>
first, I would say pick a language and stick with it until you are at least at an intermediate level.
some are better than others, but in the long run it doesn&#39;t matter.
there is an idea held by some that starting with java ruins you, or starting with basic ruins you, or whatever.
this is <em>not</em> true, <em>unless</em> you niche into it and refuse to broaden your understanding as you broaden your experience
</p>

<p>
the most important thing I want to get across with this entire article is that &#34;programming&#34; is nothing special.
it&#39;s a form of applied abstract symbol manipulation.
different programming languages do the same things in different ways, and once you get good, you can move fluidly between them.
if you have a faculty, whether innate or acquired, for abstract symbol manipulation, you can learn to program
</p>

<p>
an important collorary to this is that if you can learn to program, you can learn tons of other things just as easily.
there are thousands of opinionated programmers online who every day insist on presenting themselves as living counterexamples to this assertion, but nevertheless I am resolute.
the only reason why programming is so commonly self-taught is because it is a system that is unusually suited to trial and error by people with no specialized knowledge or specialized equipment.
once you master your learning style, as long as you are bright and curious and determined, <em>you can learn anything</em>
</p>

<p>
so, get reasonably good at one language before branching out.
but, do branch out!
when you know a language, you think in terms of that language.
once you know several in one paradigm, you think in terms of the paradigm.
once you know the paradigms, you can just think in programming
</p>

<p>
this attitude does not come for free.
you need to be able to actively relate material across the conceptual gaps, or you will be stuck in these specialized silos like so many people are.
this is how college teaches you to think: in terms of tracks and prerequisites
</p>

<p>
maybe some people really do think best like this.
maybe most!
I don&#39;t want to make any normative claims.
but if you have stuck with my bullshit this long, we are probably enough alike that I can be a bit presumptuous
</p>

<p>
the way I catalog knowledge is more like one big graph.
giant, sprawling, with no organization to it, interlinked loosely in some places and tightly in others.
when I encounter new topics, I never really worry if I &#34;don&#39;t get&#34; most of it.
I just look for ways I can relate it back to my graph.
if I read a text outside of my depth and barely understand it, it still lays groundwork, a skeleton structure that I can later flesh out with more material
</p>

<p>
I think the root of creativity is not inventing novel ideas out of nothing, but simply drawing novel edges on a large graph.
I think a lot of adult loss of neuroplasticity, adult retreat to conservatism, adult inability to enjoy new art or music, all these various hatreds of newness are just people who decided to stop learning, to stop adapting, and thus lost the ability to do so
</p>

<p>
I think the &#34;software engineer&#34; sans specialty is gradually losing ground and will be relegated to low status clerical labor within our lifetimes.
tooling has made great strides toward the deskilling of rote implementation and maintenance work, and human-in-the-loop systems may well finish the job.
the world will always need more crud apps and saas platforms, and it gets easier for the average dev to 80/20 their way to something serviceable enough every day.
many professional programmers actually contribute negative value to their orgs.
it&#39;s just, in a large enough company, it&#39;s hard to tell who they are, and no one has incentive to care anyway
</p>

<p>
but that&#39;s for making more versions of things that basically already exist.
for new things, for science and art and novel engineering, I think the norms surrounding programming will become more like writing.
a tool of expression, a tool you use to <em>enact</em> your knowledge about some procedural or scientific topic.
the means, not the end
</p>

<p>
it can already be used this way, of course, even if the majority of code now written is shitwork.
code is not the next mass literacy.
most people will never learn, although they may learn just enough to stumble through running the machines that others invented.
my expectation, or maybe my hope, is that it can at least be the next latin, the next classical chinese.
a tool for a minority, but a large minority, to express their wills in a way that transcends their native culture
</p>

<p>
the 21st century will have two lingae francae.
english, to say.
and code, to do
</p>

<p>
I think the future belongs to people who can use code to gain leverage on the world and to create new things that are more than just software.
I think being a domain expert who can program well will be more valuable than a great programmer with no other talents, or a specialist who is incompetent in software.
I think being a great programmer, but also able to work across multiple fields, bridge gaps, draw novel inferences, is and will continue to be a superpower
</p>

<p>
so be good to your graph
</p>

<p>
anyway.
the overarching theme I have been trying to impart with the kata idea is simple: feedback, response.
the tighter you make the feedback-response loop, the faster you can work, the faster you can think, the more natural and effortless everything feels.
the exact same principle applies to debugging
</p>

<p>
no one really teaches you how to debug.
you just kind of have to figure it out.
this is a shame, because debugging is conceptually pretty simple
</p>

<p>
I think what happens is people learn to program, work by themselves on programs small enough to keep in their heads, and can get by debugging most things just by thinking really hard.
then, eventually, they get a job working on a large codebase, or their projects get too big for them to track, or attract contributors, and they are suddenly forced to sink or swim.
they then throw together the basic principles of debugging from scratch to solve their problem and then forget they ever didn&#39;t know it
</p>

<p>
there is a <a href="https://danluu.com/teach-debugging/">remarkable story</a> by dan luu that I think about often, about a computer engineering class.
this was infamous as a weed-out class, separating the men from the boys, and was feared for its legendary difficulty.
the author breezed through most of it on talent, while students failed left and right at each turn, until the class final which overwhelmed him as well.
struggling into the night before the deadline, making no progress, eventually it turned out the only real challenge was to invent debugging.
in effect, the kids who realized in time you could systematically test every connection to find the one that needed to be fixed, passed.
the rest failed.
no one had ever taught them to do this
</p>

<p>
there are all kinds of fancy tools for debugging, and many of them are quite good, but the basic principle is again: feedback, response.
for this, the easiest place to start without having to learn anything new is the humble print statement
</p>

<p>
my first &#34;real&#34; job, after writing little crud toys in the single-digit-thousands of lines of codes, was a 1.5 million line, 15-year-old, object-oriented perl codebase.
if that means nothing to you, know that everyone else winced.
printf was my best friend.
just put that shit anywhere.
print the value that&#39;s changing but shouldn&#39;t, that should change but doesn&#39;t, just scatter prints until you find where it happens.
when you find it, print more
</p>

<p>
change stuff just to see what changes as a result.
and you can see if it changes by printing it.
imagine you are the world&#39;s dumbest scientist.
you don&#39;t need a strong hypothesis if you can run a new experiment every 20 seconds.
feedback, response
</p>

<p>
don&#39;t try to analyze code if it feels overwhelming.
the most important skill you learn on your first big codebase is how to <em>not</em> read code that <em>isn&#39;t</em> important.
just relax, focus on the one thing you care about, and do anything that gives you more information about it
</p>

<p>
if building and running the code takes too long, try and find a simpler case that produces the same error.
print stack traces so you can see where things are coming from.
just iterate, focus on getting more information, faster, and narrowing your focus.
feedback, response
</p>

<p>
use version control.
that means use git.
you can develop niche opinions about weird version control systems when you are old and wizened.
(hopefully by that time the pijul rewrite will be usable, and we can share a beer over that...)
</p>

<p>
git is very simple.
in your code directory, <code>git init</code> makes a repository.
<code>git add FILENAME</code> stages a file for commit, ie does nothing but you have to do it anyway.
<code>git commit</code> creates a new commit with your staged files, which is like a checkpoint of where you&#39;re at.
<code>git remote add origin URL</code> sets up the place where your repository get stored for safekeeping/sharing.
<code>git push origin BRANCH</code> where branch is probably <code>main</code> or <code>master</code> puts your repository on the internet.
if you ever have problems, copy the <em>entire project directory</em> somewhere for safekeeping before you fuck around with it.
you now know more about version control than the typical cs undergrad who didn&#39;t just self-teach already
</p>

<p>
version control is a gamechanger for various reasons and I don&#39;t understand how nontechnicals live without it.
you have backups of everything, files are error-checked for consistency, you can see when changes were made, you can describe why you made those changes, you can experiment with changes and back them out trivially.
use it
</p>

<p>
text editors.
you can learn vim or emacs if you want.
I use vim and would die without it.
but honestly at this point sublimetext and vscode are fine and don&#39;t have the same steep learning curve.
people rag on ides partly out of elitism and partly because ides used to be horrible monolithic corporate shit.
sublimetext and vscode are fine
</p>

<p>
use linux.
ok, ok, you can use osx if you really insist, but don&#39;t blame me when getting software to work is annoying.
don&#39;t use windows, you&#39;re making your life hell for no reason.
in software, we distinguish between normal places, and &#34;windows shops.&#34;
everything important targets linux first, so everything on windows is completely different, and almost always inferior
</p>

<p>
as for what distro, ubuntu is fine.
I could bitch endlessly about it, but if you&#39;re new to unix, ubuntu is fine.
you can develop strong opinions about linux distros much earlier than you can about version control, don&#39;t worry
</p>

<p>
this is not to say linux is strictly the best os for everything.
linux sucks for most people.
telling designers to get off osx or non-tech business guys to get off windows is nonsense.
their platforms work better for them, they have mass adoption, they have all the best tools for those workflows.
switching would give them a vastly inferior experience, for what, bragging rights?
among people they don&#39;t have any reason to want to impress?
but for software work, linux is just the best.
there&#39;s no debate here
</p>

<p>
learn the command line.
it&#39;s a fucking pain in the ass to get started, everything is inscrutable because all this stuff was thrown together by a group of guys in the 70s at one company for one machine, not expecting it to be the basis of all modern computing.
the original unix clock ran at 60hz and would have rolled over after 2.5 years if they hadn&#39;t changed it, that&#39;s how far ahead they were thinking.
sorry, this is just how it is.
the command line is too useful to neglect
</p>

<p>
the best way to learn to program, I think, is by coming up with some small project that seems tractable and figuring out whatever you need to solve it.
this is easier said than done, because new programmers have the hardest time of anyone at thinking up things to attempt and judging whether they&#39;re doable.
once you are are good at programming, you will have literally hundreds of ideas of things to do but lack the time to do more than two or three at once.
so enjoy it while it lasts
</p>

<p>
javascript or python are probably the most reasonable beginner languages.
they both have their quirks, but they have a wealth of learning material, and most importantly, comprehensive library support for anything you might want to do.
following examples in a book to make the console print sunny or cloudy based on random number rolls bores most people to tears.
you want to build something that you enjoy, that makes you feel like you&#39;ve created something of value, no matter how silly or small.
and then just build up from there.
feedback, response
</p>

<p>‚ùß</p>

<h2>kata three</h2>
<h3>registers, jumps, calling convention</h3>

<p>
it was fun to take apart the object-oriented paradigm and see how someone raised in its bosom may be seduced by it abstractions.
unfortunately, we have been seduced as well.
objects, methods, inheritance, and design patterns are not real things.
but neither are variables, loops, structs, or functions.
it&#39;s abstractions all the way down
</p>

<p>
programming languages are a set of techniques provided for the benefit of the human programmer.
but to run them, they must be compiled to machine code, which is nothing but a long sequence of binary digits.
interpreting these number streams is famously difficult for humans, though not impossible.
programmers who wrote raw binary or could read coredumps in hex are part of the lore of the field.
our culture-heroes
</p>

<p>
a set of human-readable mnemonics for machine code, plus a handful of simple labor-saving shortcuts, is called an assembly language.
assembly was one of the first inventions for making programming more efficient for human operators, before compilers and before high-level languages.
examples in assembly suffice to demonstrate what is &#34;really&#34; going on underneath the code, to further develop intuitions on what is possible in computers, and to develop more flexibility in adapting to new systems
</p>

<p>
I firmly believe every high-level programmer worth their salt needs to understand c, and every c programmer needs to understand assembly.
the mediocre dive into their abstraction and make a career out of it and it alone, shutting their eyes to anything outside their walled garden.
but to actually be good, you need to know what&#39;s happening underneath your feet
</p>

<p>
machine code is not the last abstraction in the pile.
but below there you get into hardware engineering, and below that electrical engineering.
these abstractions are not airtight either.
but they&#39;re outside my paygrade.
google &#34;rowhammer attack&#34; or &#34;spectre attack&#34; or &#34;acoustic cryptanalysis&#34; sometime if you want to peer into the void
</p>

<p>
on a basic level, a computer can be thought of as a cpu that executes instructions, a set of boxes called registers that hold one value each, and a long, homogeneous series of bytes that constitute main memory
</p>

<p>
&#34;arrays&#34; are a shorthand for manipulating sections of memory that happen to be laid out in a particular way.
&#34;structs&#34; are likewise a convention imposed on homogenous and undifferentiated memory.
&#34;stack&#34; and &#34;heap&#34; are conventions.
&#34;buffers&#34; are conventions too: malloc and free get sections of memory from the operating system, and annotate them with metadata, but writing outside of them is exploitable, not impossible.
even &#34;code&#34; is just bytes in memory
</p>

<p>
when you invoke a program, an operating system program called the loader puts all its data into memory.
the program has an entrypoint, which is an address to start interpreting code from.
instructions are executed in sequence, one after the other, with the current execution address being stored as a value in a register called the instruction pointer (<code>ip</code>) or program counter (<code>pc</code>).
the cpu executes whatever is pointed at and moves the pointer to the next instruction.
branch instructions simply modify the <code>ip</code> register, indirectly causing the cpu to execute instructions somewhere else instead
</p>

<p>
the distinction between &#34;code&#34; and &#34;data&#34; is arbitrary, only enforced as a safety mechanism after a series of famous exploits that revolved around tricking programs into executing user-supplied data as code.
taking control of the instruction pointer is the same as taking control of the entire program.
it&#39;s all just bytes in memory
</p>

<p>
revisiting our original c examples, we can see how some simple operations compile (with optimizations disabled) down to assembly:
</p>
<pre><code>int a = 2;
int b = 3;
b = b + a; // b is now 5
</code></pre>
<p>
corresponding to:
</p>
<pre><code>40110b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
401112:   c7 45 f4 03 00 00 00    mov    DWORD PTR [rbp-0xc],0x3
401119:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
40111c:   03 45 f8                add    eax,DWORD PTR [rbp-0x8]
40111f:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
</code></pre>
<p>
there is a lot new here to understand
</p>

<p>
values in assembly are typically rendered in hexadecimal, for human convenience.
hex is a base-16 counting system, with digits ranging 0-9 followed by a-f.
that is, 0x9 is 9, 0xa is 10, 0xf is 15, and 0x10 is 16.
the 0x prefix is a convention indicating what counting system we&#39;re using.
hex is convenient because a digit represents exactly four bits, so two digits is always a byte
</p>

<p>
the numbers in the first column are addresses.
just the number of bytes from some fixed 0 address, much like main memory.
the second column with individual hex digit pairs is the exact machine code in the binary.
note the third line has three bytes in the second column and an address ending in 19.
the address on the next line ends in 1c, three bytes higher
</p>

<p>
the third and fourth columns are mnemonics for the machine code.
there&#39;s only two kinds of instruction in this simple example, <code>mov</code> and <code>add</code>
</p>

<p>
<code>mov</code> is an entire spectrum of instructions that (contrary to the name) copy data from one location to another.
in this syntax, the destination is to the left of the comma, much as the assigned variable in c is to the left of the equals.
the first two lines move the hardcoded values 2 and 3 into particular locations on the stack, identified by offsets from the base pointer, <code>rbp</code>, a register that contains the address of the bottom of the current stack frame
</p>

<p>
the third line copies the value of <code>b</code> into a general-purpose register called <code>eax</code>.
the reason for this is <code>add</code> can only operate on a register.
the next line adds the value of <code>a</code> into the <code>eax</code> register, and the final line copies that value back to <code>b</code> on the stack
</p>

<p>
aside from the instructions themselves, we also use three different kinds of operands.
the source operands on lines one three and five are <code>0x2</code>, <code>DWORD PTR [rbp-0xc]</code>, and <code>eax</code> respectively.
the first is an immediate, ie the number <code>0x2</code> simply represents the value 2.
the second is an indirect memory access: indirect in the exact same way as indirection.
an address is calculated as an offset from the base pointer and dereferenced to produce a value.
the third is a register name, and the value is retrieved from that register
</p>

<p>
and finally, note that this and all assembly examples are in what&#39;s called intel syntax.
there is an alternate syntax called at&amp;t that looks rather different, and has operands in the opposite order.
but it is just a way to display machine code for human convenience.
the machine code bytes are exactly the same
</p>

<p>
blocks and higher-level flow-control constructs don&#39;t exist in assembly.
all flow control compiles down to simple jumps:
</p>
<pre><code>if(a &gt; 2) {
    a = 3;
}
else {
    a = 4;
}
</code></pre>
<p>
corresponding to:
</p>
<pre><code>401119:   83 7d f8 02             cmp    DWORD PTR [rbp-0x8],0x2
40111d:   0f 8e 0c 00 00 00       jle    40112f <main+0x2f>
401123:   c7 45 f8 03 00 00 00    mov    DWORD PTR [rbp-0x8],0x3
40112a:   e9 07 00 00 00          jmp    401136 <main+0x36>
40112f:   c7 45 f8 04 00 00 00    mov    DWORD PTR [rbp-0x8],0x4
</main+0x36></main+0x2f></code></pre>

<p>
here, on the first line, a comparison is performed between the value in <code>a</code> and the number 2.
this comparison sets a bit in a special register called the status register, which is evaluated by the <code>jle</code> instruction.
<code>jle</code> is a conditional jump, &#34;jump if less or equal,&#34; which skips to the assignment of 4 on the last line of the assembly.
if the jump is not taken, ie if <code>a</code>&#39;s value is greater than 2, control simply proceeds to the next line.
the assignment of 3 is performed, and then an unconditional jump skips past the assignment of 4
</p>

<p>
a loop looks roughly similar:
</p>
<pre><code>int a = 0;
do {
    a++;
} while(a &lt; 10);
</code></pre>
<p>
corresponding to:
</p>
<pre><code>40110b:   c7 45 f8 00 00 00 00    mov    DWORD PTR [rbp-0x8],0x0
401112:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
401115:   83 c0 01                add    eax,0x1 
401118:   89 45 f8                mov    DWORD PTR [rbp-0x8],eax
40111b:   83 7d f8 0a             cmp    DWORD PTR [rbp-0x8],0xa
40111f:   0f 8c ed ff ff ff       jl     401112 <main+0x12>
</main+0x12></code></pre>
<p>
the loop begins on line two, and three instructions perform the add, and a comparision and conditional jump determine whether to repeat the action.
a while loop, by contrast, would perform the comparison up top and jump past the end if it failed
</p>

<p>
it is worth noting that c actually has a jump of its own, called <code>goto</code>.
it is unfairly maligned
</p>

<p>
the last thing to understand here is that the function, just like the branch or the loop, is just another kind of jump:
</p>
<pre><code>int timestwo(int n) {
    int x = n * 2;
    return x;
}

int a = 5;
int x = timestwo(a);
</code></pre>
<p>
corresponding to:
</p>
<pre><code>40112f:	c7 45 f8 05 00 00 00 	mov    DWORD PTR [rbp-0x8],0x5
401136:	8b 7d f8             	mov    edi,DWORD PTR [rbp-0x8]
401139:	e8 c2 ff ff ff       	call   401100 <timestwo>
40113e:	89 45 f4             	mov    DWORD PTR [rbp-0xc],eax
</timestwo></code></pre>
<p>
the main block is straightforward.
5 is stored on the stack, then copied to the register <code>edi</code> for argument passing, and then our <code>timestwo</code> function is called.
<code>call</code> is a special kind of unconditional jump that first pushes a return address onto the stack
</p>

<p>
and this is the assembly for the <code>timestwo</code> function, in its entirety, including setup/teardown I&#39;ve been skipping:
</p>
<pre><code>401100:	55                   	push   rbp
401101:	48 89 e5             	mov    rbp,rsp
401104:	89 7d fc             	mov    DWORD PTR [rbp-0x4],edi
401107:	8b 45 fc             	mov    eax,DWORD PTR [rbp-0x4]
40110a:	c1 e0 01             	shl    eax,0x1
40110d:	89 45 f8             	mov    DWORD PTR [rbp-0x8],eax
401110:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
401113:	5d                   	pop    rbp
401114:	c3                   	ret    
</code></pre>

<p>
the first thing a function does is store the current base pointer on the stack and reset the base pointer to the current stack pointer.
it then copies the value in <code>edi</code> to the stack.
in other words, function arguments are just normal stack variables.
so far, this has all been standard setup for a function to execute.
how this is done is basically arbitrary, as long as everything does it the same way.
the set of steps taken to set up and tear down a function call on a particular platform is known as its &#34;calling convention&#34;
</p>

<p>
from there, the actual computation proceeds.
the multiplication by 2 is performed by a left shift operator, moving all bits to the left by one, effectively doubling the number.
that is, multiplication by 2 in decimal is equivalent to multiplication by 10 in binary.
the result is moved into <code>eax</code>, the register used for a function&#39;s single return value.
and then the caller&#39;s base pointer is restored to <code>rbp</code> and the address stored on the stack is popped and jumped back to with <code>ret</code>
</p>

<p>
as an aside, every function call adds a stack frame, and if you run out of space, the program will either preemptively crash, or attempt to write past its bounds and be killed by the operating system with an error like &#34;segmentation violation.&#34;
overrunning the stack space is called a stack overflow, and in general invalid memory access is called a segfault.
but, interestingly, some functional programming languages have a feature called tail-call optimization.
these languages can detect that some recursive sequences don&#39;t actually <em>need</em> their stack frames, and optimize them to a simple loop.
a series of jumps modifying a value in a register.
it&#39;s all just jumps
</p>

<p>
this has been a lot of information to dump.
if there is any section of this rather long post that is ok not to grasp, it&#39;s this one.
but with this knowledge of the underlying systems, we can demystify the abstractions above, and also understand why certain things work the way they do
</p>

<p>
a machine register typically holds a single machine word.
on x64 this is a qword, which is eight bytes.
sometimes programmers from higher-level languages wonder if you can return a struct, or an array, or multiple values in c.
this makes it obvious why you cannot: a register is used, so the only possible return is a single value.
if a higher-level language wants to return something special, it probably returns a pointer and fixes up some things behind the scenes, just as <code>call</code> and <code>ret</code> fix up things of their own
</p>

<p>
it also explains why data does not persist on the stack, and why arguments are primitive values or pointers, and why the maximum addressable memory of a system is determined by its word size.
again, I hammer one of my central points: it&#39;s not about understanding the particular details of a particular system.
it&#39;s about simultaneously being able to think in terms of an abstraction which is inherently meaningless, and look beyond it at lower abstractions which are themselves meaningless
</p>

<p>
to not get trapped in the web, but to glide over it, as the spider, and in due time spin your own
</p>

<p>‚ùß</p>

<h2>further reading</h2>

<p>
I said in a previous section that javascript or python are fine starting languages.
<a href="https://eloquentjavascript.net/">eloquent javascript</a> seems like a decent enough resource for the former.
it doesn&#39;t assume any existing knowledge, and I particularly like how it goes out of its way to provide background information.
I don&#39;t know any python resources to recommend them offhand
</p>

<p>
another path is the classic of mit students of yore: <a href="https://web.mit.edu/alexmv/6.037/sicp.pdf">sicp</a>.
sicp starts you in a simple dialect of scheme and has you off and programming in under an hour.
the book is a classic, so you can google &#34;sicp scheme&#34; to find a myriad of easy to install execution environments for it.
scheme&#39;s core syntax can be learned in an afternoon.
the material it presents is accessible, yet deceptively advanced.
it tries to follow an approach like I do, of starting with basics and building concepts up out of those simple pieces
</p>

<p>
scheme was replaced by java as the primary teaching language because of perceptions that scheme was &#34;useless&#34; and that languages used in industry were more &#34;practical.&#34;
you will probably never have to write scheme in a job.
but my point, as always, is that you must be able to generalize concepts across boundaries.
if you can&#39;t do that, then just learn what you need to eat and try to stay afloat
</p>

<p>
for a certain type of person, c is a perfectly fine language to start with.
if you go that route, there is still no better resource than <a href="https://kremlin.cc/k&amp;r.pdf">k&amp;r</a>.
I don&#39;t recommend starting with c unless you&#39;re strongly drawn to it, but if you are, don&#39;t let anyone talk you out of it
</p>

<p>
I think most people want to learn top-down, making useful things that amuse them, picking up fundamentals as they go.
for them, javascript or python.
but some people don&#39;t care about seeing immediate results, and are more gratified by understanding the system from the start, and will learn higher-level concepts when they need to.
for them, scheme or c
</p>

<p>
if you want to learn about type theory, <a href="https://theswissbay.ch/pdf/Gentoomen%20Library/Maths/Comp%20Sci%20Math/Benjamin_C._Pierce-Types_and_Programming_Languages-The_MIT_Press%282002%29.pdf">tapl</a> is a great intro.
it starts with maybe the simplest programming language on earth, the untyped lambda calculus, and builds up types brick by brick on top of that foundation
</p>

<p>
if you want to learn operating systems, my favorite resource is <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">ostep</a>.
broadly it&#39;s structured around the tentpole topics of virtualization, concurrency, and persistence, and goes into extensive technical detail on all of them
</p>

<p>
if you want to learn cs fundamentals, I don&#39;t have a book in mind but you can google &#34;algorithms and data structures&#34; and find something probably.
honestly I just learned that stuff as I went, and I&#39;d only bother to cram it if I needed to pass a meme whiteboard interview
</p>

<p>
neither do I have a text in mind on formal grammers and parsing them, but this is a topic that ought to be understood by more working programmers than it is.
you don&#39;t need to be able to implement an efficient parser (until suddenly you do), but you should understand the chomsky hierarchy and its correspondence to computational complexity
</p>

<p>
I also can&#39;t recommend anything for ops or infosec, though I can&#39;t imagine learning these topics in any way except by doing them
</p>

<p>
as for hands on material, by far my favorite thing to recommend is <a href="https://microcorruption.com">microcorruption</a>.
it has you writing exploits for a 16-bit microcontroller, giving you a grand tour through low-level hacker shit, set up perfectly to teach it.
the final test is fiendish, and will make you do more work than even feels reasonable, but the feeling of conquest when you beat it is unmatched
</p>

<p>
I also very much like <a href="https://cryptopals.com/">cryptopals</a>, which walks you through breaking practical cryptosystems in a long series of challenges.
many of these will require you to write a lot of code, and to think very hard, but other than reasonable cleverness and a bit of algebra, there are no real prereqs to tackle these
</p>

<p>
a lot of people enjoy <a href="https://adventofcode.com/">advent of code</a>, an annual series of 25 toy problems to solve in code, with answer-checking on the site.
the 2021 challenges are available to play still.
this is how I learned a good deal of cs fundamentals: by having to reinvent basic algorithms and data structures to cope with problems designed to be computationally intractable any other way.
I found the challenges fun before I had the background knowledge to know how to solve them, but tedious after.
I suspect the only reason to do these if you know cs is to compete on time or pad a github for job applications
</p>

<p>
the last fun code thing I like is <a href="https://github.com/jherskow/nand2tetris/raw/master/nand2tetris%20BOOK.pdf">nand2tetris</a>, which starts you at an even lower level than I finished on.
you build the jenga pagoda level by level, starting by putting together boolean logic out of nand gates, then an adder and flash memory, a toy cpu, an assembler for a basic assembly language, a compiler for a simple oop language, and then finally programs in that language you build with your compiler.
depending on how much you already know about compilers, the later stages can get tedious, but it&#39;s fine to start at the beginning and quit when you get bored
</p>

<p>
there is a whole host of cultural material I could link, but I will limit myself as best I can.
if you are an outsider to software, and get good at it, there is still a complex signalling game to be played so that people know you&#39;re good at it.
I used to think this was not the case, because acceptance seemed to come very naturally and easily to me, but I didn&#39;t understand then that acting like you&#39;re not playing a signalling game is part of the game
</p>

<p>
there&#39;s a lot to digest if you want to look like you &#34;belong,&#34; and this isn&#39;t something I can guide you through.
it&#39;s not strictly necessary to participate in tech culture or open source, but it does make getting hired easier.
I don&#39;t know how to tell people how to break into tech because the first job is the hardest to get and every &#34;non-traditional&#34; path is different and impossible to follow exactly.
I can&#39;t say &#34;here is how to do it.&#34;
the best I can offer is &#34;here is how to be the kind of person something like it can happen to&#34;
</p>

<p>
the important thing to remember is that it&#39;s not enough to be valuable.
you must be legibly valuable.
this trips up people who are not used to cultivating an appearance
</p>

<p>
but to link three cultural gems, chosen for their merit and by my love for them, rather than base utility: the most important far is esr&#39;s <a href="http://www.catb.org/~esr/faqs/hacker-howto.html">hacker howto</a>.
a short tour of the culture and the spirit of the work, it is a classic, and I believe the core of it will never become obselete.
the attitude of curiosity, tenaciousness, freedom, and boredom he espouses is truly the golden path
</p>

<p>
the second is dijkstra&#39;s classic lecture <a href="https://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html">on the cruelty of really teaching computer science</a>.
dijkstra is always erudite and a purist at heart.
here he presents a very different vision of programming than what most of us practice, one grounded in formal methods and mathematics.
I suspect he would have nothing but contempt for my primitive and slovenly ways.
read him to expand your mind
</p>

<p>
and the third is <a href="https://web.stanford.edu/class/cs81n/command.txt">in the beginning there was the command line</a> by neal stephenson.
a sprawling nonfiction tour through old school computing and then-modern operating systems, but also much more.
the difference between tools that feel powerful and tools that are powerful.
the things that are hidden away from most people, behind a curtain that we are preparing to sneak behind.
the proper attitude to take when designing a world
</p>

<p>
I hope this post proves valuable to some.
feel free to shower me with love or hate via twitter or email.
if you&#39;re reading this because I linked it to you personally, I believe you can do it.
but whether I linked it or not, may fortune be with you in all your endeavors
</p>




</div></div>
  </body>
</html>
