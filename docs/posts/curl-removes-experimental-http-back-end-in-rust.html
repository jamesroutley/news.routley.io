<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://daniel.haxx.se/blog/2024/12/21/dropping-hyper/">Original</a>
    <h1>Curl removes experimental HTTP back end in Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>The ride is coming to an end. The experiment is done. We tried, but we admit defeat.</p>



<p>Four years ago we started adding <a href="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/" data-type="link" data-id="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/">support for an alternative HTTP backend in curl</a>. It would use a library written in rust, called <a href="https://hyper.rs/">hyper</a>. The idea was to introduce an alternative implementation of HTTP internals that you could make curl/libcurl use instead of the native implementation.</p>



<p>This new backend that used a library written in rust would enable users to run a product where a larger piece of the total code than otherwise would be written in a memory-safe language: rust. Memory-safety being all the rage these days.</p>



<p>The initial work was generously sponsored by <a href="https://www.abetterinternet.org/">ISRG</a>, the organization behind such excellent efforts such as Letâ€™s Encrypt, which believes strongly in this concept. I cooperated intensely with Sean McArthur, the lead developer of hyper. We made it work.</p>



<p>We have shipped hyper support in curl labeled EXPERIMENTAL for several years by now, hoping to attract attention and trigger the experimental spirit in users out there. Seeing so many people seem to want more memory-safety, surely the users would come?</p>



<h2>95% of the work is the easy part</h2>



<p>I mean that we took it perhaps 95% of the way and <em>almost</em> the entire test suite ran identically independently of which backend we built curl to use. The final few percent would however turn out to be friction enough to now eventually make us admit defeat, give up and instead yank it all out again.</p>



<p>There simply were no users asking for it and there were almost no developers interested or knowledgeable enough to work on it. libcurl is written in C, hyper is written in rust and there is a C binding glue layer in between. It takes someone who is interested and good at both languages to dig in, understand the architectures, the challenges and the protocols to drive this all the way through.</p>



<p>But with no user demand, why do it?</p>



<p>It seems quite clear that rust users use hyper but few of them want to work on making it work for a C project like curl, and among existing curl users there is virtually no interest in hyper. The overlap in the Venn diagram of the two universes is not big enough.</p>



<p>With no expectation of seeing this work completed in the short to medium length term, the cost of keeping the hyper code is simply deemed too high. We gain code agility and reduce complexity by trimming this off.</p>



<h2>We improved</h2>



<p>While the experiment itself is deemed a failure, I think we learned from it and improved curl in the process. We had to rethink and reassess several implementation details when we aligned HTTP behavior with hyper. libcurl parses and handles HTTP stricter now. Better.</p>



<p>I also believe that hyper benefited from this journey and gained experiences and input from us that led to improvements in their end and in their HTTP library. Which then by extension have benefited the hyper users.</p>



<p>When we started this, even rust itself was not ready and over this time rust has improved and it is today a better language and it is better prepared to offer something like this. For us or for other projects.</p>



<h2>Backends</h2>



<p>With this <em>amputation</em> we are back to no separate HTTP/1 backends. We only provide the single native implementation.</p>



<p>I am not against revisiting the topic and the idea of providing alternative backends for HTTP/1 in the future, but I think we should proceed a little different next time. We also have a better internal architecture now to build on than what we had in 2020 when this attempt started.</p>



<h2>Less rust (for now?)</h2>



<p>Before this step, we supported three different backends backed up by libraries written in rust. Now we are down to two: rustls (for TLS) and quiche (for QUIC and HTTP/3). Both of them are still marked experimental.</p>



<p>These two backends use better internal APIs in curl and are hooked into libcurl in a cleaner way that makes them easier to support and less of burden to maintain over time.</p>



<p>Of course nothing prevents us from adding support for more and other rust libraries in the future. libcurl is a protocol engine using a plethora of different backends for many different protocols and services hooked into its core. Virtually all of those backends <em>could</em> be provided by a rust library.</p>



<h2>Thanks</h2>



<p>A big thank you go to Sean and all others who helped us take it as far as we did. You are great. Nothing of this should put any shade on you.</p>



<h2>When</h2>



<p>The hyper backend code has been removed in git as of December 21. There will be no traces left of it in the curl 8.12.0 release coming in February 2025.</p>
	</div></div>
  </body>
</html>
