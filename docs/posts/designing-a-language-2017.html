<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cs.lmu.edu/~ray/notes/languagedesignnotes/">Original</a>
    <h1>Designing a Language (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <section><img src="https://cs.lmu.edu/~ray/images/languagedesignscribe.png"/></section>

<p>So, you want to design your own language? Of course you do. Or perhaps you are taking a class and are being forced to create a programming language under penalty of a bad grade. What kinds of things do you need to know?</p>

<h2>Designing a Language</h2>

<p>Of course you want to design (and implement!) your own programming language! It‚Äôs fun. It‚Äôs creative. It‚Äôs empowering.</p>

<p>How do we do it? In a nutshell, the process is iterative, cycling between four phases:</p>

<p><img src="https://cs.lmu.edu/~ray/images/languagedesign.png%20" alt="languagedesign.png"/></p>
<p>Doing the phases over and over is important; for example, while writing the compiler, you may be like ‚Äúwoah this is impossible‚Äù and then realize ‚Äúoh shoot this part of the language wasn‚Äôt designed right!‚Äù</p>

<h2>Prerequisites</h2>

<p>It helps to be experienced. If you‚Äôre not, that‚Äôs okay, actually‚Äîyou might get lucky!</p>

<p>But don‚Äôt mistake creativity for luck that shows up without pre-existing knowledge. The most creative people are those with a <em>lot</em> of knowledge and experience. So you should still study and practice!</p>

<p>Your success as a language designer will be massively aided by knowledge in three main areas:</p>

<ol>
<li><b>Programming Paradigms</b>. You should know a number of different ways that computations can be structured. These include: <span>imperative</span> <span>declarative</span> <span>structured</span> <span>object-oriented</span> <span>functional</span> <span>applicative</span> <span>concatenative</span> <span>logic</span> <span>protocol-oriented</span> <span>aspect-oriented</span> <span>array</span> <span>event-driven</span> <span>dataflow</span> <span>agent-based</span> etc.<p>See Wikipedia‚Äôs <a href="https://en.wikipedia.org/wiki/Programming_paradigm">list of programming paradigms</a>.</p>
</li>

<li><b>Programming Language Concepts</b>. You should have a good sense of most, if not all, of the following things: Sequencing, conditional execution, iteration, recursion, functional decomposition, modularity, synchronization, metaprogramming, binding, scope, extent, volatility, subtyping, pattern matching, type inference, closures, prototypes, introspection, instrumentation, annotations, decorators, memoization, traits, streams, monads, actors, mailboxes, comprehensions, continuations, wildcards, promises, regular expressions, proxies, transactional memory, inheritance, polymorphism, parameter modes, type classes, generics, reflection, concurrency, parallelism, distribution, persistence, transactions, garbage collection, and many more terms.<p>I‚Äôm working on a <a href="https://github.com/rtoal/plang-glossary">glossary</a> of such terms that may be helpful to review.</p>

</li><li><b>Existing ProgrammingLanguages</b>. It‚Äôs nice to have a feel for a variety of languages. Here are a few that are good to be familiar with (and the reasons why they are good to study):
<ul>
<li><b>Python</b>, for basic imperative programming and scripting
</li><li><b>Smalltalk</b>, for OOP done beautifully
</li><li><b>JavaScript</b>, for event-driven features, async, and promises
</li><li><b>Io</b>, for ideas on building up everything from a minimal semantics
</li><li><b>Julia</b>, for multiple dispatch
</li><li><b>Clojure</b>, <b>Racket</b>, <b>Scheme</b>, and <b>Common Lisp</b>, for Lispiness (macros, etc.)
</li><li><b>Standard ML</b>, <b>OCaml</b>, <b>F#</b>, and <b>Elm</b>, for Hindley-Milner typing and more
</li><li><b>Haskell</b>, for typeclasses and functional purity
</li><li><b>eToys</b>, <b>Scratch</b>, <b>Snap!</b>, and <b>GP</b> for the blocks approach
</li><li><b>Java</b> and <b>C#</b>, for being enterprisey
</li><li><b>Kotlin</b>, <b>Ceylon</b>, and <b>Scala</b>, as examples of evolving Java
</li><li><b>Erlang</b> and <b>Elixir</b>, for expressing concurrent processes in a distributed fashion
</li><li><b>Fortran</b>, <b>Chapel</b>, and <b>Parasail</b>, for expressing muticore and parallel programming
</li><li><b>PureScript</b>, <b>TypeScript</b>, and <b>ClojureScript</b>, as examples of evolving JavaScript
</li><li><b>C</b>, because it is the quintessential systems language</li>
<li><b>C++</b>, <b>Rust</b>, <b>Zig</b>, and <b>Odin</b> for making systems programming less painful and more secure
</li><li><b>Go</b> and <b>Swift</b>, for more examples of modern, but generally mainline, ideas
</li><li><b>J</b> and <b>K</b>, for array programming
</li><li><b>Idris</b>, for dependent typing
</li><li><b>Prolog</b> and <b>Mercury</b>, for logic programming
</li><li><b>Forth</b> and <b>Factor</b>, for concatenative programming
</li><li><b>Quipper</b>, because it‚Äôs a language for quantum computing
</li><li><b>Brainfuck</b>, <b>Malbolge</b>, <b>LOLCODE</b>, <b>Whitespace</b>, and other classic esoterics
</li><li><b>GolfScript</b>, <b>CJam</b>, <b>Pyth</b>, <b>Jelly</b>, and other golfing languages, because this gives you a good sense of putting power into small syntactic constructs
</li><li><b>Piet</b> and <b>Hexagony</b>, for, well, check them out....
</li></ul>
<p>Also check out <a href="http://rtoal.github.io/ple/overviews.html">this mini-encyclopedia of 70 languages</a>.</p>
<p>Here are some excellent cross-language comparisons that help you to hone your understanding of how different syntaxes can express the same ideas:</p>
<ul>
  <li><a href="http://rigaux.org/language-study/syntax-across-languages.html">Syntax Across Languages</a>
  </li><li><a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages">Wikipedia Programming Language Comparisons</a>
  </li><li><a href="http://hyperpolyglot.org/">Hyperpolyglot</a>
</li></ul>
<p>These are really good too:</p>
<ul>
  <li><a href="http://codegolf.stackexchange.com/questions/44680">Showcase of Languages</a>
  </li><li><a href="http://codegolf.stackexchange.com/questions/48476">Languages Through the Years</a>
</li></ul>
</li></ol>

<h2>Getting Ready</h2>

<p>Remember, many people have designed languages before you. They made mistakes. They came up with brilliant ideas. Many were wildly successful. Some never made it big. Some people have brought in years of research on how people think and learn to come up with principles for language (and environment) design.</p>

<p>You should learn form their experiences.</p>

<p>Study classic papers. Read web essays. Visit online courses. Here is a small sampling of things to study and places to look for more information:</p>
<ul>
<li><a href="http://web.eecs.umich.edu/~bchandra/courses/papers/Hoare_Hints.pdf">Hints on Programming Language Design</a> by Tony Hoare
</li><li><a href="http://worrydream.com/#!/LearnableProgramming">Learnable Programming</a> by Bret Victor
</li><li><a href="http://paulgraham.com/langdes.html">Five Questions about Language Design</a> by Paul Graham
</li><li>For early classic papers, check out the massive bibliography of <a href="http://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=1093&amp;context=cs_techreports">this paper</a>
</li><li>Also look at the papers from <a href="http://www.cs.tufts.edu/comp/150PLD/schedule.html">Kathleen Fisher‚Äôs Programming Language Design class</a>
</li></ul>

<p>Think about the future:</p>

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/8pTEmbeENF4" frameborder="0" allowfullscreen=""></iframe></p>

<p>And understand that traditional, mainstream programming languages, are not at all the epitome of computational expression. Languages can be much more:</p>

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/prIwpKL57dM" frameborder="0" allowfullscreen=""></iframe></p>

<h2>Getting Started</h2>

<p>Ready to strike out on your own? Here are some things to think about, in the form of a, you guessed it, a checklist:</p>
<ul>
<li>Do you have a specific audience in mind? Artists? Graphic designers? AI researchers? Numeric and Scientific nerds? Natural language types? Game developers? Machine learning people? Animators? High performance folks? System programmers? Or do you want a general purpose language? Or do you just want to do what <em>you</em> want?</li>
<li>Understand the audience that the language is designed for, and what kinds of things they want to create with it (or problems they want to solve with it).</li>
<li>Determine if your language is to be (1) a reasonable, usable language or (2) an esoteric/joke/golfing language.</li>
<li>Determine if it is to be pragmatic, idealistic, researchy, or evil.
</li><li>Determine whether you want your language firmly in one camp‚ÄîOO, functional, logic, concatenative, plain-imperative‚Äîor be a multiparadigm symphony. Or a multiparadigm cacophony.
</li><li>Determine whether it is to be built on a single characteristic building block (a <em>crystallization of style</em>) or one with a huge variety of syntactic forms for multiple semantic aspects (an <em>agglutination of features</em>).
</li><li>Determine your concurrency model. Do you want all your programs to be single-threaded and sequential? Or are you looking for something event-driven and async? Or multithreaded? Or distributed?</li>
</ul>

<h2>Choosing a Starter Set of Features</h2>

<p>Come up with a list of capabilities, or features. Make sure they enable programmers to express their creations by following the suggestions and principles in the <a href="http://worrydream.com/#!/LearnableProgramming">Learnable Programming</a> essay, including:</p>
<ul>
  <li>Make meaning transparent
  </li><li>Explain in context
  </li><li>Make flow and time tangible and visible
  </li><li>Show the data, and avoid hidden state
  </li><li>Use metaphor
  </li><li>Allow easy decomposition and recomposition
  </li><li>Allow the programmer to write readable code‚Äîyou <em>do</em> support mentioning parameter names in calls, right?
</li></ul>

<div><p><b>Exercise</b>: Skim the Learnable Programming essay. Or, better, read the whole thing </p><s>if</s><p> when you have time.
</p></div>
<p>What kind of questions might you have here? Here are some totally random ideas:</p>
<ul>
<li>If your language supports functions:
  <ul>
  <li>Must you pass the exact number of arguments the function expects?
  </li><li>Can you specify parameter names in the call?
  </li><li>Do you have rest parameters? optional parameters? keyword parameters? default parameters?
  </li><li>Are the parameters typed?
  </li><li>Can parameters be modified? Are they passed by value, value-result, reference, name, etc?
  </li><li>Are arguments evaluated L-R, R-L, in parallel, or in arbitrary order?
  </li><li>How does a function return a value? Can it return zero or more values or just one?
  </li><li>Are functions first-class? If so, do you use deep binding or shallow binding?
  </li><li>Is recursion allowed?
  </li><li>Can you test functions for equality?
  </li><li>Can functions be anonymous?
  </li></ul>
</li><li>What is your type system like?
  <ul>
  <li>Static vs. dynamic, strong vs. weak, manifest vs. implicit?
  </li><li>Do you distinguish primitive types from reference types?
  </li><li>Do you have all those different numeric types based on bit size? What about decimals and ratios?
  </li><li>Do you have a separate character type? A separate boolean type?
  </li><li>Can you get the type of an expression at runtime?
  </li><li>Are types objects?
  </li><li>Do you have supertypes and subtypes? Multiple-inheritance? If so, how do you handle name collisions?
  </li><li>Are types the same as classes? Can you add new types?
  </li><li>Do you have both sum and product types?
  </li><li>Do functions have a type?
  </li><li>Are there pointer types?
  </li><li>Are there parameterized types? If so, are they (mostly) covariant, contravariant, or invariant?
  </li><li>Any dependent types?
  </li></ul>
</li><li>What do your expressions look like?
  <ul>
  <li>And does your runtime follow eager or lazy evaluation? Or both?
  </li><li>Do you have only prefix, only postfix, only infix, or a wild mix of operators?
  </li><li>Can you overload operators? If so, how?
  </li><li>Can you change the precedence of operators? Even the built-in ones? At runtime?
  </li><li>How much type inference do you have?
  </li><li>Can you mark variables as mutable or immutable?
  </li><li>Are your variables bound or assigned? Can they be assigned more than once?
  </li><li>Do you have destructuring and/or pattern matching?
  </li><li>How do you determine scope? Do you implicitly or explicitly import into inner scopes?
  </li><li>Are there keywords that define access like <code>public</code>, <code>private</code>, and <code>protected</code>, or are there conventions, like in Go, where capitalized entities are implicitly exportable and lower-cased entities are private?
  </li><li>Is there a <code>let</code>-expression for super-local scopes?
  </li><li>Is shadowing allowed?
  </li><li>Do you have anything like JavaScript‚Äôs <code>this</code> expression?
  </li></ul>
</li><li>How do you express control flow?
  <ul>
  <li>Do you like expression-orientation or do you have real statements?
  </li><li>How do you express sequential flow vs. nondeterministic flow vs. parallel flow?
  </li><li>If you have nondeterminism, how do you ensure fairness?
  </li><li>Must guards in a multiway selection be executed in any particular order?
  </li><li>Do you have short-circuit operators? Iterator objects? Generators?
  </li><li>Do you have all the loops: (1) forever, (2) n times, (3) while/until a condition, (4) through a numeric range (with an optional step size), or (5) through a collection?
  </li><li>Do you have <code>break</code> and <code>continue</code>? Anything like Ruby‚Äôs <code>retry</code> and <code>redo</code>?
  </li><li>Do you have exceptions? Or do you need Go-style constructs? Or do you have nullables everywhere?
  </li><li>Do you have a timer for sleeping, delaying execution, or running on intervals?
  </li><li>Can I haz <code>goto</code>?
  </li></ul>
</li><li>How do you support concurrency?
  <ul>
  <li>Threads, or events?
  </li><li>Shared memory only? Message passing only? Or both? If shared memory, is it mutable? If so, do you have locks, higher-level synchronization devices, or some kind of transactional memory?
  </li><li>Do you support different levels of granularity of concurrency?
  </li><li>Are tasks spawned implicitly when their enclosing block begins, or do they require explicit invocation?
  </li><li>Do tasks die when the enclosing block or spawning task terminates? Or does the spawner wait for all internal tasks to terminate?
  </li><li>Do taks know who started them?
  </li><li>If an asynchronous task is launched, how is a result obtained? Callback, promise, or some other mechanism?
  </li><li>Is message passing done via named channels, named processes, or bulletin board?
  </li><li>Is message passing always synchronous, asynchronous, or both?
  </li><li>Is there timed or conditional synchronization mechanisms?
  </li><li>Can tasks detect their own state?
  </li></ul>
</li><li>How meta are you?
  <ul>
  <li>Can a program get a list of its global variables, loaded classes, top-level functions, etc.? Can a class get a list of its fields, methods, constructors, superclass(es), subclasses, etc.? Can a function get its parameters, locals, return types, etc.?
  </li><li>Can a function find out who called it?
  </li><li>Can a variable be read or set via its name (a string) only? Can a function or method be invoked by its name (a string) only? Can new variables or types or functions be created at run time, given only their name and some indication of how they should look?
  </li><li>Does the language have a macro system? If so, is it string-based or AST-based?
  </li><li>Is it possible to unquote within a macro?
  </li><li>Are macros hygienic? What syntactic devices are provided to explicitly capture in- scope variables, if any?
  </li></ul>
</li></ul>

<blockquote><b>What did I just read?</b><p>Feeling like only about 20% of the questions above made any sense? Feeling like that vocabulary came out of nowhere? That‚Äôs fine for now. Learning about programming languages can be a never-ending lifelong journey, but you can use the questions you don‚Äôt quite understand now as a place to start some research.</p><p>Oh, I have a <a href="https://github.com/rtoal/plang-glossary/blob/main/README.md">glossary</a> you might find helpful.</p></blockquote>

<h2>From Features To Abstract Syntax</h2>

<p>When you have a good idea of your language features, you‚Äôll want to figure out a good way to organize them, structurally. This is known as your language‚Äôs <dfn>abstract syntax</dfn>. In an abstract syntax we don‚Äôt worry much about punctuation and parentheses and such microscopic details. We are interested in the overall structure. Here‚Äôs a look at abstract syntax trees in JavaScript:</p>

<p><iframe width="560" height="315" src="https://www.youtube.com/embed/4OWdhor5btU?si=kytoL6z6AlxLZ8Pl" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p>

<p>When defining your language, you will want to specify exactly what the AST Nodes are, how they are related to each other, and what their properties are. For JavaScript, the AST Node types come from a specification called <a href="https://github.com/estree/estree">EsTree</a>. I&#39;ve summarized the main interfaces here:</p>

<pre><code>Program sourceType:[&#34;script&#34;|&#34;module&#34;] body:[Statement|ModuleDeclaration]
Statement
    Declaration
        FunctionDeclaration(Function) id:Identifier
        VariableDeclaration declarations:[VariableDeclarator] kind:(&#34;var&#34;|&#34;let&#34;|&#34;const&#34;)
        ClassDeclaration(Class) id:Identifier
    EmptyStatement
    DebuggerStatement
    ExpressionStatement expression:Expression
    BlockStatement body:[Statement]
    ReturnStatement argument:Expression?
    LabeledStatement label:Identifier body:Statement
    BreakStatement label:Identifier?
    ContinueStatement label:Identifier?
    IfStatement test:Expression consequent:Statement alternate:Statement?
    SwitchStatement discriminant:Expression cases:[SwitchCase]
    WhileStatement test:Expression body:Statement
    DoWhileStatement body:Statement test:Expression
    ForStatement init:(VariableDeclaration|Expression)? test:Expression? update:Expression? body:Statement
    ForInStatement left:(VariableDeclaration|Pattern) right:Expression body:Statement
        ForOfStatement await:boolean
    ThrowStatement argument:Expression
    TryStatement block:BlockStatement handler:CatchClause? finalizer:BlockStatement?
    WithStatement object:Expression body:Statement
Function id:Identifier? params:[Pattern] body:BlockStatement generator:bool async:bool
VariableDeclarator id:Pattern init:Expression?
SwitchCase test:Expression? consequent:[Statement]
CatchClause param:(Pattern?) body:BlockStatement
Expression
    ThisExpression
    Identifier(Pattern) name:string
    Literal value:(string|bool|number|Regexp|bigint)?
        RegExpLiteral regex:{pattern:string flags:string}
        BigIntLiteral bigint:string
    ArrayExpression elements:[(Expression|SpreadElement)?]
    ObjectExpression properties:[Property|SpreadElement]
    FunctionExpression(Function)
    ArrowFunctionExpression(Function) body:(BlockStatement|Expression) expression:bool
    UnaryExpression operator:UnaryOperator prefix:bool argument:Expression
    UpdateExpression operator:UpdateOperator argument:expression prefix:bool
    BinaryExpression operator:BinaryOperator left:Expression right:Expression
    AssignmentExpression operator:AssignmentOperator left:Pattern right:Expression
    LogicalExpression operator:LogicalOperator left:Expression right:Expression
    MemberExpression(ChainElement) object:(Expression|Super) property:Expression computed:bool
    ChainExpression expression:ChainElement 
    ConditionalExpression test:Expression consequent:Expression alternate:Expression
    CallExpression(ChainElement) callee:(Expression|Super) arguments:[(Expression|SpreadElement)]
    YieldExpression argument:Expression? delegate:bool
    TemplateLiteral quasis:[TemplateElement] expressions:[Expression]
    TaggedTemplateExpression tag:Expression quasi:TemplateLiteral
    NewExpression
    SequenceExpression expressions:[Expression]
    ClassExpression(Class)
    AwaitExpression argument:Expression
    ImportExpression source:Expression
    MetaProperty meta:Identifier property:Identifier
Class id:Identifier? superClass:Expression? body:ClassBody
ClassBody body:[MethodDefinition]
MethodDefinition key:Expression value:FunctionExpression kind:(&#34;constructor&#34;|&#34;method&#34;|&#34;get&#34;|&#34;set&#34;) computed:bool static:bool
SpreadElement argument:Expression
Property key:Expression value:Expression kind:(&#34;init&#34;|&#34;get&#34;|&#34;set&#34;) method:bool shorthand:bool computed:bool
    AssignmentProperty value:Pattern kind:&#34;init&#34; method:false
Pattern
    ObjectPattern properties:[AssignmentProperty|RestElement]
    ArrayPattern elements:[Pattern?]
    RestElement argument:Pattern
    AssignmentPattern left:Pattern right:Expression
Super
TemplateElement tail:boolean value:{cooked:string? raw:string}
ChainElement optional:boolean
enum UnaryOperator {&#34;-&#34;|&#34;+&#34;|&#34;!&#34;|&#34;~&#34;|&#34;typeof&#34;|&#34;void&#34;|&#34;delete&#34;}
enum UpdateOperator {&#34;++&#34;|&#34;--&#34;}
enum BinaryOperator {&#34;==&#34;|&#34;!=&#34;|&#34;===&#34;|&#34;!==&#34;|&#34;&lt;&#34;|&#34;&lt;=&#34;|&#34;&gt;&#34;|&#34;&gt;=&#34;|&#34;&lt;&lt;&#34;|&#34;&gt;&gt;&#34;|&#34;&gt;&gt;&gt;&#34;|&#34;+&#34;|&#34;-&#34;|&#34;*&#34;|&#34;/&#34;|&#34;%&#34;|&#34;**&#34;|&#34;|&#34;|&#34;^&#34;|&#34;&amp;&#34;|&#34;in&#34;|&#34;instanceof&#34;}
enum AssignmentOperator {&#34;=&#34;|&#34;+=&#34;|&#34;-=&#34;|&#34;*=&#34;|&#34;/=&#34;|&#34;%=&#34;|&#34;**=&#34;|&#34;&lt;&lt;=&#34;|&#34;&gt;&gt;=&#34;|&#34;&gt;&gt;&gt;=&#34;|&#34;|=&#34;|&#34;^=&#34;|&#34;&amp;=&#34;}
enum LogicalOperator {&#34;||&#34;|&#34;&amp;&amp;&#34;|&#34;??&#34;}
ModuleDeclaration
    ImportDeclaration specifiers:[ImportSpecifier|ImportDefaultSpecifier|ImportNamespaceSpecifier] source:Literal
    ExportNamedDeclaration declaration:Declaration? specifiers:[ExportSpecifier] source:Literal?
    ExportDefaultDeclaration declaration:(Declaration|Expression)
    ExportAllDeclaration source:Literal exported:(Identifier?)
ModuleSpecifier local:Identifier
    ImportSpecifier imported:Identifier
    ImportDefaultSpecifier
    ImportNamespaceSpecifier
    ExportSpecifier exported:Identifier
</code></pre>
<p>I‚Äôve built an interactive application for you to explore AST generation. Please <a href="https://rtoal.github.io/js-ast/">try it out!</a>.</p>

<p><b>Exercise</b>: Please try it out.
</p>
<blockquote><strong>Too much detail?</strong><p>You may notice that the EsTree specification has a lot more detail than the hand-drawn ASTs in the video above. This is okay. The specification is used to build actual compilers and interpreters, while for hand-drawn ASTs we just like to give the big picture and can take some ‚Äúshortcuts.‚Äù</p></blockquote>

<h2>From Abstract Syntax to Concrete Syntax</h2>

<p>Now it‚Äôs time to think about what your language will really look like! Remember that design is creative and iterative, so you will want to begin, like all artists do, with sketches:</p>
<ul>
<li>Sketch programs or program fragments in your language.
</li><li>Sketch fragments that are <em>not</em> in your language.
</li><li>Come up with a nice, consistent, syntactic theme.
</li></ul>

<p>Do a lot of experimentation here! You will probably want to put creative effort into designing languages people like to use! What kind of syntax issues do they deal with? Dozens, actually, and we can‚Äôt cover them all. But how about a taste of just a few. We‚Äôll peek at just a few issues that sometimes generate strong opinions.</p>

<h3>Overall Phrase Structure</h3>

<p>You will need to adopt a scheme for showing structure. The popular approaches are: Curly-brace (JavaScript, Java, C++, C#), Terminal-end (Ruby, Ada), Nested parentheses (Lisp, Clojure, Racket), Indentation (Python), Blocks (EToys, Scratch, Snap!), Pictures (Piet), Other (Haskell, Erlang, Prolog).</p>

<p>The important idea here is that a single abstract syntax can be realized with many different <dfn>concrete syntaxes</dfn>. A concrete syntax specifies exactly which strings of characters make up structurally valid programs. For example, the AST:</p>

<p><img src="https://cs.lmu.edu/~ray/images/little-ast.png%20" alt="little-ast.png"/></p>
<p>represents each of the following (and more!):</p>

<pre><code>while y - 5 == 3:
    print(x * (3 + y))
</code></pre>
<pre><code>while y - 5 == 3 {
  print(x * (3 + y))
}
</code></pre>
<pre><code>while y - 5 == 3 loop
  print(x * (3 + y))
end
</code></pre>
<pre><code>(while (= (- y 5) 3)
    (print (* x (+ 3 y))))
</code></pre>
<p><b>Exercise</b>: The last syntax is used in Clojure, Lisp, Scheme and others. Note that in some ways, this <strong>IS</strong> the abstract syntax. How so?
</p>
<p><b>Exercise</b>: Here is another: <code>y 5 - 3 == [x 3 y + * print] while</code>. Do you know of, or can you find, any languages which have that kind of syntax?
</p>
<p>In addition to structure, your choice of keywords, operators, punctuation (or lack thereof) are part of your design. Here‚Äôs an abstract syntax:</p>

<p><img src="https://cs.lmu.edu/~ray/images/ikiast.png%20" alt="ikiast.png"/></p>
<p>Let‚Äôs try out a few things:</p>

<pre><code>program:
    var x, y: integer
    while y - 5 == 3:
        var y: integer
        get(x)
        get(y)
        x = 2 * (3 + y)
    put(5)
</code></pre>
<pre><code>int x, y;
while y - 5 = 3 {
    int y;
    STDIN -&gt; x;
    STDIN -&gt; y;
    x &lt;- 2 * (3 + y);
}
STDOUT &lt;- 5;
</code></pre>
<pre><code>COMMENT THIS LOOKS LIKE OLD CODE
DECLARE INT X.
DECLARE INT Y.
WHILE DIFFERENCE OF Y AND 5 IS 3 LOOP:
    DECLARE INT Y.
    READ FROM STDIN INTO X.
    READ FROM STDIN INTO Y.
    MOVE PRODUCT OF 2 AND (SUM OF 3 AND Y) INTO X.
END LOOP.
WRITE 5 TO STDOUT.
</code></pre>
<pre><code>(program
  (declare x int)
  (declare y int)
  (while (= (- y 5) 3)
    (define (y int))
    (read x y)
    (assign x (* 2 (+ 3 y)))
  )
  (write 5)
)
</code></pre>
<p><b>Exercise</b>: Play around and sketch a few more.
</p>
<h3>Delimiters</h3>

<p>How to separate one construct from another is a really big issue in syntax design, believe it or not. We can identify two main classes of languages: those in which newlines are significant and those in which they are not.</p>

<h4>‚ÄúInsignificant‚Äù Newlines</h4>

<p>In many languages, newlines are just like any other whitespace character (except for minor exceptions such as single-line comments and single-line string literals. Then, unless you have an S-Expression-based syntax as in LISP, Scheme, and Clojure, you‚Äôll need semicolons to terminate (or separate) statements. This means you <em>can</em> (but shouldn‚Äôt) write code like:</p>

<pre><code>#define ZERO 0
    unsigned  gcd(   unsigned   int  // Euclid&#39;s algorithm
      x,unsigned   y) {   while ( /* hello */  x&gt;   ZERO
   ){unsigned temp=x;x=y   %x;y  = temp ;}return

   y ;}
</code><img src="https://cs.lmu.edu/~ray/images/c-logo32.png"/></pre>
<h4>‚ÄúSignificant‚Äù Newlines</h4>

<p>Where you place your newlines matters greatly in, let‚Äôs see, Assembly languages, Python, Ruby, JavaScript, Elm, Haskell, Go, Swift, and yes, many others. The rules can get pretty technical.</p>

<p><strong>Python</strong> scripts are defined as sequences of <dfn>logical lines</dfn>, delimited by the token NEWLINE. A statement may not cross logical lines, except in the case of <dfn>compound statements</dfn> in which each constituent <dfn>simple statement</dfn> ends with a NEWLINE. Logical lines are made up of one or more physical lines according to line joining rules. Lines are <em>implicitly</em> jointed within parentheses, brackets, or braces; lines can be <em>explicitly</em> joined by ending with a backslash. These rules are somewhat exclusive of comments and string literals.</p>

<p><strong>Ruby</strong> looks at the end of each line and says ‚Äúwell if up to here it looks like we‚Äôve completed a statement the we have.‚Äù  This means you have to be careful where you break lines:</p>

<pre><code>puts 5
  + 3
puts 5 +
  3
</code><img src="https://cs.lmu.edu/~ray/images/ruby-logo32.png"/></pre>
<p>prints 5 then 8.</p>

<p><b>Exercise</b>: Why?
</p>
<h4>‚ÄúPossibly Significant‚Äù Newlines</h4>

<p>JavaScript requires most statements to be terminated by semicolons, but the <em>compiler will put one in for you if it looks like you might have missed one</em>. The rules by which this <dfn>automatic semicolon insertion</dfn> (ASI) is done have to be learned and they might be hard to remember.</p>

<blockquote data-lang="en"><p lang="en" dir="ltr">[God creating JavaScript]</p>‚Äî Neckbeard Hacker (@NeckbeardHacker) <a href="https://twitter.com/NeckbeardHacker/status/768475375399755776">August 24, 2016</a></blockquote>


<p>If you are going to be a serious JavaScript programmer, you need to learning the rules of ASI <strong>whether you choose to use semicolons or not</strong>.</p>

<p><b>Exercise</b>: Research the famous <a href="http://www.ecma-international.org/ecma-262/9.0/index.html#sec-rules-of-automatic-semicolon-insertion">Rules of Automatic Semicolon Insertion</a>. Which statements are supposed to be terminated by a semicolon? When is a semicolon inserted? Give four examples of how writing JavaScript in a &#34;free-form&#34; manner is impossible because of semicolon insertion.
</p>

<p>Some people feel very strongly whether to use or not to use semicolons:</p>

<p><img src="https://cs.lmu.edu/~ray/images/zzzzing.png%20" alt="zzzzing.png"/></p>
<h3>Function Calls</h3>

<p>Most programming languages have functions. Seriously. But there are a lot of ways to work them into your design. Basic questions include: Must functions have exactly one argument, or zero or more arguments? Parens or no parens? Positional or keyword arguments? Argument labels? If no arguments, can we omit parentheses?</p>

<p>You can play around and see what you can come up with:</p>

<ul>
<li><code>push(myStack, 55)</code></li>
<li><code>push myStack 55</code></li>
<li><code>[push myStack 55]</code></li>
<li><code>(push myStack 55)</code></li>
<li><code>push(on: myStack, theValue: 55)</code></li>
<li><code>push(theValue: 55, on: myStack)</code></li>
<li><code>push on:myStack theValue:55</code></li>
<li><code>push({ on: myStack, theValue: 55 })</code></li>
<li><code>push { on: myStack, theValue: 55 }</code></li>
<li><code>push({ theValue: 55, on: myStack })</code></li>
</ul>
<p>You might want to consider an ultra-low precedence function application, like they have in Haskell and F#:</p>
<ul>
<li><code>sum (filter even (map square a))</code></li>
<li><code>sum $ filter even $ map square $ a</code></li>
<li><code>sum &lt;| filter even &lt;| map square &lt;| a</code></li>
<li><code>a |&gt; filter even |&gt; map square |&gt; sum</code></li>
</ul>

<p>The flip side of function calls is function definitions. You‚Äôre likely familiar with default parameters, and rest parameters. Python has cool mechanisms for requiring arguments to be positional or keyword, based on the definition. Examples:</p>
<ul>
<li><code>def sqrt(x, /)</code></li>
<li><code>def line(*, x1, x2, y1, y2, width, style, color)</code></li>
<li><code>def f(a, b, /, c, d, *, e, f)</code></li>
</ul>

<h3>Syntactic Sugar</h3>

<p><dfn>Syntactic sugar</dfn> refers to forms in a language that make certain things easier to express, but can be considered surface translations of more basic forms.</p>

<p>This is best understood by example. There are zillions of examples out there. Here are a few. (<strong>Disclaimer</strong>: Some of these are just examples I made up and are not part of any real language.)</p>

<table aria-label="desugaring">
<tbody><tr><th>Construct</th><th>Desugared Form</th><th>Description
</th></tr><tr><td><code>x += n</code></td><td><code>x = x + n</code></td><td>Compound assignment

</td></tr><tr><td><code>a + b</code></td><td><code>operator+(a, b)</code> <i>or</i></td><td>Common in languages that allow overloading

</td></tr><tr><td><code>a[i]</code></td><td><code>*(a + i)</code></td><td>(C, C++ pointer arithmetic) And <code>i[a]</code> works too!

</td></tr><tr><td><code>p -&gt; x</code></td><td><code>(*p).x</code></td><td>(C, C++) Field of struct being pointed to

</td></tr><tr><td><code>f</code></td><td><code>f()</code></td><td>Some languages let you leave off parentheses in calls with no arguments

</td></tr><tr><td><code>f x</code></td><td><code>f(x)</code> <i>or</i></td><td>Some languages let you leave off parentheses in calls with one argument

</td></tr><tr><td><code>x op y</code></td><td><code>op(x, y)</code> <i>or</i></td><td>Some languages let you leave off parentheses in calls with two arguments

</td></tr><tr><td><code>let¬†x=E1¬†in¬†E2</code></td><td><code>(x =&gt; E2)(E1)</code></td><td>Let-expression (in functional languages)</td></tr>

<tr><td><code>(E1 ; E2)</code></td><td><code>(() =&gt; E2)(E1)</code></td><td>Expression sequencing (in eager functional languages)</td></tr>

<tr><td><code>r = [s</code></td><td><code>r = []</code></td><td>List comprehension

</td></tr><tr><td><code>x orelse y</code></td><td><code>if x then x else y</code></td><td>(Standard ML) short-circuit disjunction

</td></tr><tr><td><code>x¬†andalso¬†y</code></td><td><code>if¬†x¬†then¬†y¬†else¬†x</code></td><td>(Standard ML) short-circuit conjunction

</td></tr><tr><td><code>[x, y, z]</code></td><td><code>x :: y :: z :: nil</code></td><td>Lists in Standard ML

</td></tr><tr><td><code>&#34;a${x}b&#34;</code></td><td><code>&#34;a&#34; + x + &#34;b&#34;</code></td><td>String interpolation
</td></tr></tbody></table>

<p><b>Exercise</b>: Find some more examples.
</p>
<p>When the sugared form is completely gratuitous or actually makes the code <em>less</em> readable, you sometimes hear the term <dfn>syntactic syrup</dfn> or <dfn>syntactic saccharin</dfn>.</p>

<h3>Syntactic Salt</h3>

<p>Here‚Äôs the definition from <a href="http://www.outpost9.com/reference/jargon/jargon_toc.html">The New Hacker‚Äôs Dictionary</a>:</p>

<blockquote>The opposite of syntactic sugar, a feature designed to make it harder to write bad code.
Specifically, syntactic salt is a hoop the programmer must jump through just to prove that he knows what‚Äôs going on, rather than to express a program action. Some programmers consider required type declarations to be syntactic salt. A requirement to write ‚Äú<code>end if</code>‚Äù, ‚Äú<code>end while</code>‚Äù, ‚Äú<code>end do</code>‚Äù, etc. to terminate the last block controlled by a control construct (as opposed to just ‚Äú<code>end</code>‚Äù) would definitely be syntactic salt. Syntactic salt is like the real thing in that it tends to raise hackers‚Äô blood pressures in an unhealthy way.</blockquote>

<h3>Candygrammars</h3>

<p>Some people love verbose code, because explicit is better than implicit. But if you are language designer, be pragmatic: there is such a thing as code that is too verbose. What about trying to make the code like human language? Here‚Äôs an example in Hypertalk (taken from Wikipedia):</p>

<pre><code>on mouseDown
  answer file &#34;Please select a text file to open.&#34;
  if it is empty then exit mouseDown
  put it into filePath
  if there is a file filePath then
    open file filePath
    read from file filePath until return
    put it into cd fld &#34;some field&#34;
    close file filePath
    set the textStyle of character 1 to 10 of card field &#34;some field&#34; to bold
  end if
end mouseDown
</code></pre>
<p>And here‚Äôs an example from a language that some students developed, and regretted:</p>

<pre><code>to get the truth value prime of whole number n:
    return no if n &lt; 2
    for each d in 3 to n - 1 by 2:
        return no if d divides n
    end
    return yes
end
for each k in 1 to 100:
    write k if prime(k)
end
</code></pre>
<p>In practice this kind of verbosity is worse than it sounds. Here‚Äôs what the New Hacker‚Äôs Dictionary has to say about this:</p>

<blockquote>
<strong>candygrammar /n./</strong> A programming-language grammar that is mostly syntactic sugar; the term is also a play on ‚Äúcandygram.‚Äù COBOL, Apple‚Äôs Hypertalk language, and a lot of the so-called ‚Äú4GL‚Äù database languages share this property. The usual intent of such designs is that they be as English-like as possible, on the theory that they will then be easier for unskilled people to program. This intention comes to grief on the reality that syntax isn‚Äôt what makes programming hard; it‚Äôs the mental effort and organization required to specify an algorithm precisely that costs. Thus the invariable result is that candygrammar languages are just as difficult to program in as terser ones, and far more painful for the experienced hacker.
</blockquote>

<h3>Terseness</h3>

<p>Some languages pride themselves on doing a whole lot with few characters:</p>

<p>An example from Ruby (do you see what this does?):</p>

<pre><code>c = Hash.new 0
ARGF.each {|l| l.scan(/[A-Z&#39;]+/i).map {|w| c[w.downcase] += 1}}
c.keys.sort.each {|w| puts &#34;#{w}, #{c[w]}&#34;}
</code><img src="https://cs.lmu.edu/~ray/images/ruby-logo32.png"/></pre>
<p>An example from APL (The 99 bottles of beer program taken from Rosetta Code):</p>

<pre><code>bob  ‚Üê  { (‚çï‚çµ), &#39; bottle&#39;, (1=‚çµ)‚Üì&#39;s of beer&#39;}
bobw ‚Üê  {(bob ‚çµ) , &#39; on the wall&#39;}
beer ‚Üê  { (bobw ‚çµ) , &#39;, &#39;, (bob ‚çµ) , &#39;; take one down and pass it around, &#39;, bobw ‚çµ-1}
‚Üëbeer¬® ‚åΩ(1-‚éïIO)+‚ç≥99
</code><img src="https://cs.lmu.edu/~ray/images/apl-logo32.png"/></pre>
<p>Here‚Äôs APL again, with an expression to find all the prime numbers up to R:</p>

<pre><code>(~R‚àäR‚àò.√óR)/R‚Üê1‚Üì‚ç≥R
</code><img src="https://cs.lmu.edu/~ray/images/apl-logo32.png"/></pre>
<p>Some people love terse, concise code, because it says only what it needs and reduces the cognitive load, leaving you with less useless noisy syntax to learn. But if you are language designer, be pragmatic: there is such a thing as code that is too terse. Unless...that‚Äôs your goal....</p>

<h3>Golfing Languages</h3>

<p>Golfing languages take terseness to the next level. A golfing language is a kind of <a href="https://esolangs.org/wiki/Esoteric_programming_language">esoteric programming language</a> (a non-practical language created to experiment with weird ideas, be hard to program in, or be humorous) that allows programs to be written in an insanely small number of characters (or bytes).</p>

<p>Here are some CJam programs:</p>

<ul>
  <li><code>&#34;Hello, world!&#34;</code></li>
  <li><code>5{&#34;Hello, world&#34;oNo}*</code></li>
  <li><code>0X{_2$+}A*]N*</code></li>
  <li><code>l~@-@@-mh</code></li>
  <li><code>1{_B&lt;}{_&#39;**N+o)}w;</code></li>
</ul>
  
<p>Here are some Pyth programs (taken from the documentation):</p>

<ul>
<li><code>&#34;Hello, world!</code></li>
<li><code>FNrZhTN</code></li>
<li><code>FNUhTN</code></li>
<li><code>VhTN</code></li>
<li><code>K1FNr1hQ=K*KN;K</code></li>
<li><code>.!Q</code></li>
<li><code>WtQ=Q?%Q2h*Q3/Q2Q</code></li>
<li><code>A(Z1;VhhTGA(H+GH</code></li>
</ul>

<p><b>Exercise</b>: Find a bunch more examples of CJam and Pyth programs. Try them out. You can run them both at <a href="https://tio.run/">TIO</a>. For Pyth, there‚Äôs also <a href="https://pyth-docker.azurewebsites.net/">a hosted interpreter with a Cheat Sheet</a>.
</p>
<p><b>Exercise</b>: Try out <a href="https://github.com/tomtheisen/stax">Stax</a>.
</p>
<h2>Defining Your Language</h2>

<p>Traditionally, real world language definitions come in three main flavors:</p>
<ul>
<li>An official document, with a mix of formal notation and informal descriptions (Very common)
</li><li>An official document, with 100% of the definition specified in a formal notation (Very rare)
</li><li>A ‚Äúreference implementation,‚Äù namely a compiler or interpreter, so that the language ‚Äúdefinition‚Äù is simply ‚Äúwhatever this program does‚Äù (Typical for some scripting languages). An advantage if this approach is that there are never any compiler bugs!
</li></ul>

<p><b>Exercise</b>: Why exactly is a reference implementation compiler by definition bug-free? If being bug-free is so great, why don‚Äôt all languages do this? What are the downsides?
</p>
<p>An official definition will have three parts:</p>

<table aria-description="three-part-language-definition">
<tbody><tr><th rowspan="2">Syntax (Structure)</th><th colspan="2">Semantics (Meaning)</th></tr>
<tr><th>Statics</th><th>Dynamics</th></tr>
<tr>
<td>What are the structural entities (e.g., declarations, expressions, statements, modules) and how do they fit together, perhaps with punctuation?</td>
<td>What are the non-structural rules that define a legal program (e.g., type checks, argument-parameter matching rules, visibility rules, etc.)?</td>
<td>What does a program do? What effects do each of the forms of a well-structured, legal program have on the run-time environment?</td>
</tr>
</tbody></table>

<p>Why are there three parts instead of two (i.e., just syntax and semantics)? Here‚Äôs why. While everyone might agree that the following is <em>structurally</em> malformed:</p>

<pre><code>#&lt;include &gt; stdio.h
main() int }
    printf[&#34;Hello, world!\n&#34;);]
{
</code></pre>
<p>the following program looks good in terms of ‚Äústructure‚Äù but it‚Äôs actually <em>meaningless</em> since it violates a <strong>contextual rule</strong> that says identifiers must be declared before use:</p>

<pre><code>int main() {
    printf(&#34;%d\n&#34;, x);
}
</code></pre>
<p>We say the latter program has <dfn>static semantic errors</dfn> because they can be detected by a compiler before the program is ever run. This is in contrast to a dynamic semantic error, which can only be detected at run time.</p>

<p><b>Example</b>: You‚Äôve probably heard the distinction between ‚Äústatic‚Äù and ‚Äúdynamic‚Äù before. Perhaps you know that ‚Äústatic typing‚Äù involves type checking is done <em>prior to</em> program execution and ‚Äúdynamic typing‚Äù involves checking <em>during</em> program execution. Most languages do a little of both, but one or the other usually predominates. Sometimes you get a good deal of both: in TypeScript for example, you have a set of static types which is much larger and completely different than the eight dynamic types. Fun.
</p>
<h3>Defining the Syntax</h3>

<p>Let‚Äòs see how we would formally specify the syntax for the simple language <a href="https://cs.lmu.edu/~ray/notes/astro/">Astro</a>. Assume we‚Äôve gone through the first two design phases, and we‚Äôve sketched out a program that shows all the features:</p>

<pre><code>// A simple program in Astro

radius = 55.2 * (-cos(2.8E-20) + 89) % 21;    // assignment statement
the_area = œÄ * radius ** 2;                   // a built-in identifier
print hypot(2.28, 3 - radius) / the_area;     // print statement
</code></pre>
<p>Next, we put our ideas into words. A first pass: ‚ÄúPrograms are structured as a sequence of one or more statements, each of which is an assignment or print statement, with expressions formed with numbers, variables, function calls, and the usual arithmetic operators, which can have parentheses when needed. Comments look like the slash-slash comments of C-like languages.‚Äù</p> 

<p>Natural language isn‚Äôt super precise, so let‚Äôs try to tighten this up. Let‚Äôs get started defining programs, statements, and expressions:</p>

<pre>Program     = Statement+
Statement   = id &#34;=&#34; Exp &#34;;&#34;
            | print Exp &#34;;&#34;
Exp         = numeral
            | id
            | id &#34;(&#34; (Exp (&#34;,&#34; Exp)*)? &#34;)&#34; 
            | &#34;-&#34; Exp
            | Exp (&#34;+&#34; | &#34;-&#34; | &#34;*&#34; | &#34;/&#34; | &#34;%&#34; | &#34;**&#34;) Exp
            | &#34;(&#34; Exp &#34;)&#34;
</pre>

<p>An <dfn>identifier</dfn> is the computer science word for a <em>name</em> you attach to an <dfn>entity</dfn> (a variable, constant, function, type, parameter, or similar thing). Let‚Äôs decree that Astro identifiers begin with a letter, and can have letters, digits, and underscores (examples: <code>x</code>, <code>last_attempt</code>, <code>p1</code>, <code>p2</code>, <code>overTheLimit</code>, <code>bot8675309_jEnNy</code>). We will call letters, digits, and underscores <dfn>identifier characters</dfn> (<code>idchar</code>s). But let‚Äôs also decree that <code>print</code> is not allowed to be an identifier (so we don‚Äôt confuse people)!</p>

<p>This means we have to carefully define the <code>print</code> keyword very carefully. It‚Äôs not just the five letters p, r, i, n, and t. If it were then the program:</p>
<pre>    printy;
</pre>
<p>would be legal! It would be the five characters spelling print followed by a legal expression, namely the identifer $y$. We want the word <code>print</code> to not bleed into any following characters that might be part of an expression. In other words, <code>print</code> must not be immediately followed by an identifier character. And, we have to explicitly exclude <code>print</code> from our category of identifiers. Both things are necessary. Let‚Äôs use the <code>~</code> symbol in our notation to exclude things:</p>

<pre>print       = &#34;print&#34; ~idchar
idchar      = letter | digit | &#34;_&#34;
id          = ~print letter idchar*
</pre>

<p><b>Exercise</b>: Make sure you understand how this definition ensures that ‚Äúprinty‚Äù is an identifier and not <code>print</code> followed by the identifier <code>y</code>.
</p>
<p>Now time for numerals. We‚Äôll keep things in decimal only (no worries about hex or binary), and use the times-ten-to-the notation from popular programming languages:</p>

<pre>numeral     = digit+ (&#34;.&#34; digit+)? ((&#34;E&#34; | &#34;e&#34;) (&#34;+&#34; | &#34;-&#34;)? digit+)?
</pre>

<p>Looking good. But what about things like <code>letter</code> and <code>digit</code>? Should we define these? Nah, let‚Äôs say that in our definition schema that these things are built-in. Let‚Äôs in fact ‚Äúbuild in‚Äù all of the following:</p>
<ul>
<li><code>letter</code>, for any Unicode letter</li>
<li><code>digit</code>, for <code>&#34;0&#34;..&#34;9&#34;</code></li>
<li><code>alnum</code>, for <code>letter | digit</code></li>
<li><code>upper</code>, for any Unicode uppercase letter</li>
<li><code>lower</code>, for any Unicode lowercase letter</li>
<li><code>hexDigit</code>, for <code>digit | &#34;a&#34;..&#34;f&#34; | &#34;A&#34;..&#34;F&#34;</code></li>
<li><code>any</code>, for any Unicode character at all</li>
</ul>

<h4>Lexical vs. Phrase Syntax</h4>

<p>Did you notice that some of our syntax categories (Program, Statement, Exp) were capitalized and others (id, numeral, letter, digit) were not? Why did we do this?</p>

<p>The latter things are very primitive. They can not have internal spaces. We call these <dfn>tokens</dfn>. Think of these as basic ‚Äúwords‚Äù. The former, called <dfn>phrases</dfn> are more complex. Think of them as sentences. They are made up of tokens <strong>that can be separated by spaces</strong>. Tokens and phrases are very different, so we should denote them differently.</p>

<p><b>Exercise</b>: Is capitalization a good convention for distinguishing tokens from phrases? Is it biased against languages that don‚Äôt distinguish capital and small letters?
</p>
<p>So what are spaces‚Äîthose characters that can separate tokens from each other? We‚Äôll take them to be any Unicode space character. But we also want to separate tokens with comments. Let‚Äôs define how tokens should look in our language, and <em>add</em> them to the special <code>space</code> category:</p>

<pre>space      += &#34;//&#34; (~&#34;\n&#34; any)*
</pre>

<p><b>Exercise</b>: Explain why this reads as ‚Äúa comment starts with two slashes and goes to the end of the line.‚Äù
</p>
<p>Let‚Äôs take a deeper look into how the lexical and phrase syntaxes differ. As a specific example, this program:</p>
<pre>  print( // ‚øáüåø
420 );
</pre>
<p>is made up of these characters:</p>
<p>
<span>SPACE</span>
<span>SPACE</span>
<span>LATIN¬†SMALL¬†LETTER¬†P</span>
<span>LATIN¬†SMALL¬†LETTER¬†R</span>
<span>LATIN¬†SMALL¬†LETTER¬†I</span>
<span>LATIN¬†SMALL¬†LETTER¬†N</span>
<span>LATIN¬†SMALL¬†LETTER¬†T</span>
<span>LEFT PARENTHESIS</span>
<span>TAB</span>
<span>SOLIDUS</span>
<span>SOLIDUS</span>
<span>SPACE</span>
<span>KANGXI¬†RADICAL¬†HEMP</span>
<span>HERB</span>
<span>LINEFEED</span>
<span>DIGIT¬†FOUR</span>
<span>DIGIT¬†TWO</span>
<span>DIGIT¬†ZERO</span>
<span>SPACE</span>
<span>RIGHT PARENTHESIS</span>
<span>SEMICOLON</span>
</p>

<p>Following the lexical syntax, skipping the spaces (and comments), we get the <dfn>token stream</dfn>:</p>

<p>
<code>print</code>
<code>(</code>
<code>num(420)</code>
<code>)</code>
<code>;</code>
</p>

<p>Following the phrase syntax, we can uncover the underlying <dfn>parse tree</dfn>:</p>

<p><img src="https://cs.lmu.edu/~ray/images/420parsetree.png%20" alt="420parsetree.png"/></p>
<p>A very important thing to note: <strong>The frontier of the parse tree is the token stream</strong>.</p>

<p><b>Exercise</b>: Repeat this phrase to yourself five times: The frontier of the parse tree is the token stream.
</p>
<blockquote><b>The parse tree ends at tokens, not characters</b></blockquote>

<p>Another term for ‚Äúparse tree‚Äù is <dfn>concrete syntax tree</dfn> (CST).</p>

<h4>Ambiguity</h4>

<p>How are we doing so far? We are able to distinguish well-structured Astro programs from all other Unicode strings. But there are some things we haven‚Äôt dealt with yet. For one, we have some strings with multiple structural forms. For example, the phrase <code>9-3*7</code> can be <dfn>parsed</dfn> in two ways:</p>

<p><img src="https://cs.lmu.edu/~ray/images/ambiguity.png%20" alt="ambiguity.png"/></p>
<p>Having more than one parse tree for a given input string means that our syntax description is <dfn>ambiguous</dfn>. It‚Äôs possible to handle this particular kind of ambiguity in the syntax. Here‚Äôs how.</p>

<h4>Precedence</h4>
    
<p>We can create rules that force certain operators to be applied before others; that is, the <dfn>precedence</dfn> of operators can be enforced in our syntax definition. To do so, we define additional syntactic categories. We say:</p>

<ul>
  <li>An expression is a sequence of one or more <dfn>terms</dfn>, separated by additive operators.</li>
  <li>A term is a sequence of one or more <dfn>factors</dfn>, separated by multiplicative operators.</li>
  <li>A factor is made up of <dfn>primaries</dfn>, separated by exponentiation operators, or a factor can just be a negated primary.</li>
  <li>A primary is the most basic expression possible: either a simple identfier, a numeral, a call, or a parenthesized expression. Parentheses allow unlimited nesting.</li>
</ul>

<p>So let‚Äôs revise our syntax specification:</p>

<pre>Exp         = Term ( (&#34;+&#34; | &#34;-&#34;) Term )*
Term        = Factor ( (&#34;*&#34; | &#34;/&#34; | &#34;%&#34;) Factor )*
Factor      = Primary ( &#34;**&#34; Primary )*
            | &#34;-&#34; Primary
Primary     = numeral | id | id &#34;(&#34; (Exp (&#34;,&#34; Exp)*)? &#34;)&#34; | &#34;(&#34; Exp &#34;)&#34;
</pre>

<p>Great! Now there is one and only one parse tree for that previously problematic expression:</p>

<p><img src="https://cs.lmu.edu/~ray/images/nonambiguity.png%20" alt="nonambiguity.png"/></p>
<p>Note that the new syntax has forced the binary operators into a precedence hierarchy!</p>
<ul>
<li><code>+</code> and <code>-</code> have the lowest precedence.</li>
<li><code>*</code>, <code>/</code>, and <code>/</code> have the next higher precedence.</li>
<li><code>**</code> has the highest precedence.</li>
</ul>
<p>Of course, you can think of parenthesized expressions as being done before anything else, though we don‚Äôt usually think of these as operators.</p>

<p><b>Exercise</b>: Precedence is usually a concept that applies only to binary operators, but they way in which unary operators mix with binary operators does need to be addressed. For instance, how should<code>-3**2</code> be parsed? In Python exponentiation precedes negation, like <code>-(3**2)</code>. In Elm, negation precedes exponentiation, like <code>(-3)**2</code>. Astro follows JavaScript and simply does not allow this expression (forcing programmers to use parentheses in this case)! Show how this is done.
</p>
<p><b>Exercise</b>: Our specification does not allow <code>-3**2</code> as an expression, but it does allow <code>-3+2</code> and <code>-3*2</code>. Why did we care only enough to ensure negation did not mix with exponentiation, but we were fine with it mixing with addition and multiplication?
</p>
<h4>Associativity</h4>

<p>Wait, we are not done with structuring our operators just yet. The way things stand now, the parse tree for <code>3-8-5</code> looks pretty flat:</p>

<p><img src="https://cs.lmu.edu/~ray/images/flatexpression.png%20" alt="flatexpression.png"/></p>
<p>It doesn‚Äôt suggest whether we mean to compute <code>(3-8)-5</code> (which would be -10) or <code>3-(8-5)</code> (which would be 0). We can give a syntax that makes this clear. In our design, let‚Äôs make the additive and multiplicative operators <dfn>left-associative</dfn> and the exponentiation operator <dfn>right-associative</dfn>:</p>

<pre>Exp         = Exp (&#34;+&#34; | &#34;-&#34;) Term
            | Term
Term        = Term (&#34;*&#34; | &#34;/&#34; | &#34;%&#34;) Factor
            | Factor
Factor      = Primary &#34;**&#34; Factor
            | &#34;-&#34; Primary
            | Primary
</pre>

<p>How the heck does this work? Study these parse trees, and hopefully the insight will come to you! (Hint: remember the syntax is <em>designed</em> to force the tree to ‚Äúcome out‚Äù a certain way.</p>

<p><img src="https://cs.lmu.edu/~ray/images/associativity.png%20" alt="associativity.png"/></p>
<p><b>Exercise</b>: Study this until you understand it well.
</p>
<h4>Grammars</h4>

<p>The notation we‚Äôve been using to precisely describe our syntax is a kind of a <dfn>grammar</dfn>. In fact, it is very close to a specific kind of grammar called an <dfn>Ohm Grammar</dfn>. Ohm requires a bit more ceremony than what we‚Äôve been using so far. We‚Äôll just jump right in and extend our work so far to a complete and working Ohm grammar:</p>

<p><span>astro.ohm</span></p><pre><code>Astro {
  Program     = Statement+
  Statement   = id &#34;=&#34; Exp &#34;;&#34;                         --assignment
              | print Exp &#34;;&#34;                          --print
  Exp         = Exp (&#34;+&#34; | &#34;-&#34;) Term                   --binary
              | Term
  Term        = Term (&#34;*&#34; | &#34;/&#34; | &#34;%&#34;) Factor          --binary
              | Factor
  Factor      = Primary &#34;**&#34; Factor                    --binary
              | &#34;-&#34; Primary                            --negation
              | Primary
  Primary     = id &#34;(&#34; ListOf&lt;Exp, &#34;,&#34;&gt; &#34;)&#34;            --call
              | numeral                                --num
              | id                                     --id
              | &#34;(&#34; Exp &#34;)&#34;                            --parens

  numeral     = digit+ (&#34;.&#34; digit+)? ((&#34;E&#34; | &#34;e&#34;) (&#34;+&#34; | &#34;-&#34;)? digit+)?
  print       = &#34;print&#34; ~idchar
  idchar      = letter | digit | &#34;_&#34;
  id          = ~print letter idchar*
  space      += &#34;//&#34; (~&#34;\n&#34; any)*                      --comment
}
</code></pre>
<p>When you are <strong>designing</strong> your language, you will build up your grammar iteratively, from increasingly more complex examples, and test the grammar as you go. Tools will help you here! If you are using Ohm, and you should, take advantage of the use the <a href="https://ohmlang.github.io/editor/">Ohm Editor</a>. This is an amazing tool for <a href="http://web.cs.ucla.edu/~todd/theses/warth_dissertation.pdf">experimenting with programming languages</a>.</p>

<p><img src="https://cs.lmu.edu/~ray/images/ohm-editor-arith-screenshot.png" width="100%" alt="Ohm Editor Screenshot"/></p>
  
<p>In the upper left panel, design your grammar. You can load/save from your browser‚Äôs local storage, and even publish gists to GitHub. In the lower left panel, enter test cases: both tests you want to succeed (thumbs up) and those you want to fail (thumbs down). The right panel is an interactive concrete syntax tree for the currently selected test case.</p>
  
<p>This tool will save you a lot of time.</p>
  
<p>It is an essential component of your language design toolbox.</p>

<blockquote><strong>How essential is it?</strong><p>Unless your language is trivial, tools like the Ohm Editor are very important! Design is an iterative process, and creativity is enabled and enhanced with immediate feedback. So you should design with tools that allow you to experiment and test your ideas.</p><p>That said, it is true that in practice, many production-level compilers do not use Ohm or related tools like ANTLR, Bison, etc.‚Äîthey do everything by hand. But developers that go this route will write their grammar tests concurrently with their design.</p></blockquote>
  
<p>CLASSWORK</p><blockquote>Let‚Äôs do a code-along with the Ohm Editor for developing the Astro grammar. During the code-along, note how examples are done first, and note how we will evolve from the basics to more complex features, bringing in notions such as a precedence and associativity where needed.<p>During the code-along, bits of Ohm will be introduced as needed. In a subsequence course unit, we will cover Ohm in detail.</p>
</blockquote>
<h3>Defining the Statics</h3>

<p>Question: Does the grammar we defined above for Astro capture the following (desirable) rule:</p>

<p>‚ÄúYou can only use an identifier if it has been previously assigned to.‚Äù</p>

<p>Answer: It does not.</p>

<p><b>Exercise</b>: Show that it does not. Hint: Is <code>print x;</code> a legal program according to the grammar?
</p>
<p><b>Exercise</b>: Show how to capture the rule in a grammar. Hint: Do not be frustrated if you cannot.
</p>
<p>Enforcing this rule requires knowledge of <dfn>context</dfn>. That is, the syntactic rule for producing expressions such as calls and arithmetic operations would need to somehow know which identifiers appeared on the left hand side of some previous assignment statement. This turns out to be so hard that even designers of real programming languages omit enforcement of contextual rules from the grammar! In fact, while the official grammar for Java will not derive this program:</p>

<pre><code>class A {2 / == {{;
</code></pre>
<p>and report a <dfn>syntax error</dfn>, a Java compiler will say that this program:</p>

<pre><code>class A {int x = y;}
</code></pre>
<p><em>is</em> structurally well formed according to the <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-19.html">official syntax of the Java language</a>! The compilation unit consists of a type declaration that is a class declaration whose body consists of a field declaration with a type, a name, and an initializing expression which is an identifier. But we know this program is not legal, since the identifier <var>y</var> has not been declared. It‚Äôs not only Java that has grammars overspecifying things: pretty much every programming language uses a grammar to define structural rules only, and specifies contextual rules in prose, or in a separate semantic definition.</p>

<p>For Astro, we will ‚Äúdefine‚Äù the following contextual rules:</p>
<ol>
  <li>The following identifiers are built-in:
    <ul>
      <li><code>œÄ</code>, a number</li>
      <li><code>sqrt</code>, a function of exactly one argument</li>
      <li><code>sin</code>, a function of exactly one argument</li>
      <li><code>cos</code>, a function of exactly one argument</li>
      <li><code>hypot</code>, a function of exactly two arguments</li>
    </ul>
  </li>
  <li>An identifier cannot be used in an expression unless it is one of the built-in identifiers or has been previously assigned to.</li>
  <li>All function calls must accept the proper number of arguments.</li>
  <li>The built-in identifiers cannot be assigned to.</li>
  <li>Identifiers declared as functions can only be called, not used in any other context. Identifiers declared as numbers cannot be called.</li>
</ol>

<p>For more complex languages, the statics definition (contextual rules) can be quite large. Here are some things that might appear:</p>

<ul>
  <li>Identifiers have to be declared before they are used.
  </li><li>Identifiers may not be used in a place where they may have not yet been initialized.
  </li><li>Identifier declarations must be unique within a scope, unless a language provides overloading.
  </li><li>All expressions must be used according to their type.</li>
  <li>Identifiers must be used according to (1) their <b>scope</b>, (2) their <b>access modifiers</b> (private, protected, package, public, whitelist, blacklist, ...), and (3) any other meta-level attributes (enumerable, configurable, writable, deletable, callable, ...).
  </li><li>Arguments must match up with parameters in terms of number, order, name, mode, and type.
  </li><li><code>break</code> and <code>continue</code> statements may only appear in a loop. <code>return</code> statements may only appear in a function it‚Äôs <em>possible</em> to encode these restrictions in the grammar, but it would be ugly).
  </li><li>All paths through a function must have a return.
  </li><li>All possible matches in a pattern match expression, or a switch statement, must be covered.
  </li><li>When inheriting from a base class with abstract methods, or implementing an interface, all abstract methods must be implemented, or the derived class must be declared abstract.
  </li><li>All declared local variables must be subsequently read, and declared private functions must be called.
</li></ul>
  
<h3>Defining the Dynamics</h3>

<p>The dynamics for most programming languages are given in prose. If you language is simple enough, a formal semantic definition is possible. For the sample languages in this course, Astro and Bella are given both informal and formal semantic definitions. We‚Äôll not be studying formal semantics at this time, but feel free to study the definitions on your own.</p>

<h2>Prototyping</h2>

<p>During your language design, you will want to whip up a simple interpreter to at the very least make sure your design is reasonable. You may wish to developer your interpreter in parallel with your language design.</p>

<p>Ohm was designed for prototyping programming languages, so it is a natural choice. The Ohm Editor, as we just saw, helps you design the syntax. To write an actual interpreter, we‚Äôll have to go much deeper into Ohm. We‚Äôll be doing this in our next unit of study in this course, which is, indeed, a deep study of <a href="https://cs.lmu.edu/~ray/notes/introohm/">Ohm</a>.</p>

<h2>Examples</h2>

<p>Many well-known programming languages have published, formal definitions. You can find them by searching the web.</p>

<p>For this class, we will be studying five little languages crafted especially to help you in your stufy of language design and implementation. We will be studying them in order, building upon previous languages and learning new things as we progress. This will allow us to introduce the huge topic of language processing in a practical setting, writing real compilers for real languages. The languages are Astro, Bella, Carlos, Dax, and Ekko.</p>

<h3>Astro</h3>
<p><img src="https://cs.lmu.edu/~ray/images/astrologo.png" alt="Astro logo" height="160"/></p><p>We all begin as a white belt in every new endeavor. We will start, then, with a very simple, almost trivial, language. All it has are numbers, arithmetic operators, variables, and a few pre-defined constants and functions. Here‚Äôs an example program:</p>

<pre>// A simple program in Astro
rAd1uS = 55.2 * (-cos(2.8E-20) + 89) % 21;
the_area = œÄ * rAd1uS ** 2;
print(hypot(2.28, 3 - rAd1uS) / the_area);    // woohoo üëª
</pre>

<p>There are only two kinds of statements: assignments and print statements. Expressions include numbers, variables, function calls, arithmetic expressions with <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, and <code>**</code>, and can be parenthesized. We will cover the <a href="https://cs.lmu.edu/~ray/notes/astro/">official definition of the language</a>, and use the language to motivate a formal study of syntax.</p>

<p>When studying this language, we‚Äôll learn about the separation of context-free syntax from contextual rules. Contextual rules include such things as: having to match the number of arguments in a call with the number of defined parameters, rudimentary type checking, and not allowing assignments to read-only variables.</p>

<p>As Astro will be our first language, we will use it as a case study to learn the amazing <a href="https://ohmjs.org/">Ohm Language Library</a> to build an <a href="https://github.com/rtoal/astro-interpreter">interpreter</a>. The details of how the interpreter is constructed are covered in the <a href="https://cs.lmu.edu/~ray/notes/introohm/">course notes on Ohm</a>.</p>

<h3>Bella</h3>
<p><img src="https://cs.lmu.edu/~ray/images/bellalogo.png" alt="Bella logo" height="128"/></p><p>Our second language has a few things Astro does not: a richer set of operators, variable declarations, and user-defined functions. The contextual rules for Bella are much richer than that of Astro, since we now have actual declarations, and scope! Here‚Äôs an example program:</p>

<pre>let dozen = 12;
print dozen % 3 ** 1;
function gcd(x, y) = y == 0 ? x : gcd(y, x % y);
while dozen &gt;= 3 || (gcd(1, 10) != 5) {
  dozen = dozen - 2.75E+19 ** 1 ** 3;
}
</pre>

<p>We will first look at the <a href="https://cs.lmu.edu/~ray/notes/bella/">official specification</a>, introducing all sorts of interesting concepts. Then we‚Äôll study a real, actual <a href="https://cs.lmu.edu/~ray/notes/bellacompiler/">Bella compiler</a>. Here we learn about designing and architecting a compiler, building the components (analyzer, optimizer, and generator), and getting 100% test coverage. The compiler source code is on <a href="https://github.com/rtoal/bella">GitHub</a>.</p>

<h3>Carlos</h3>
<p><img src="https://cs.lmu.edu/~ray/images/carlos-logo.png" alt="Carlos logo"/></p><p>In our third language, we encounter arrays, structs, and optionals: our first language that is basically useful. If you are taking the compiler course for which these notes were written, Carlos is a good example of the minimal language complexity you will need for your term project.</p>

<pre>const languageName = &#34;Carlos&#34;;

function greeting() {
  return random([&#34;Welcome&#34;, &#34;„Åì„Çì„Å´„Å°„ÅØ&#34;, &#34;Bienvenido&#34;]);
}

print(&#34;üëãüëãüëã&#34;);
repeat 5 {
  print(greeting() + &#34; &#34; + languageName);
}
</pre>

<p>We‚Äôll be visiting the language‚Äôs <a href="https://cs.lmu.edu/~ray/notes/carlos/">official specification</a> and a <a href="https://github.com/rtoal/carlos-lang">compiler on GitHub</a>. The compiler (of course!) uses the Ohm Language Library.</p>
<p>There‚Äôs no separate page of notes describing the compiler. After studying the Astro and Bella compilers, you‚Äôll be able to find your way around the code on GitHub (there‚Äôs documentation). And don‚Äôt worry, it‚Äôs development and usage will be covered in class, and the teaching staff can help you with any questions you might have.</p>

<h3>Dax</h3>
<p><img src="https://cs.lmu.edu/~ray/images/daxlogo.png" alt="Dax logo" height="180"/></p><p>Language number four is a functional language, that is, a language with no assignments! The only bindings of names to entities happens when passing arguments to parameters, though there is that famous <code>let</code> declaration which nicely sugars a function call: it‚Äôs nicer to say <code>let x = 5 in x * y end</code> than <code>{x =&gt; x * y}(5)</code>.</p>

<p>Here‚Äôs a sample program to get the feel for the language:</p>

<pre>let
  gcd = {x =&gt; {y ==&gt; y == 0 ? x : gcd y (x % y)}};
  z = 5
in
  [1, 3, z] |&gt; filter {x =&gt; x &gt; 2} |&gt; map {x =&gt; x ** 2} |&gt; print
  then
  &#34;hello&#34; |&gt; substring 2 5 |&gt; print
  then
  print (gcd 33 99)   // This is fine, you don&#39;t HAVE to use |&gt;
end
</pre>

<p>If you have not yet seen languages with the awesome <code>|&gt;</code> operator, here‚Äôs your chance to be wowed.</p>

<p>We will discuss the <a href="https://cs.lmu.edu/~ray/notes/dax/">language design</a> and <a href="https://cs.lmu.edu/~ray/notes/daxcompiler/">compiler</a> later in the course.</p>

<h3>Ekko</h3>
<p><img src="https://cs.lmu.edu/~ray/images/ekkologo.png" alt="Ekko logo" height="160"/></p><p>Our fifth language, Ekko (starting with E like Erlang and Elixir, which greatly influence it), is a kind of experimental language that deals quite a lot with <strong>time</strong>.</p>

<p>Ekko mixes styles of asynchronous programming from JavaScript and the distributed process-orientation of Erlang and Elixir: Ekko‚Äôs <code>future</code> objects are based on JS promises, and its processes communicate via messages as in Erlang. There‚Äôs also quite a bit more temporal goodness, including timeout calls, value histories with time travel (influenced by older versions of Elm), and even explicit parallelism.</p>

<h2>More Examples</h2>

<p>Students in previous iterations of the course have designed and implemented their own languages. Here‚Äôs a sampling of language over the past decade or so. (Please note that there is a very wide variety of quality in these examples. They are presented here without any evaluative commentary as to whether they are suitable building blocks for one‚Äôs own project.)</p>

<ul>
  <li><a href="https://github.com/gabrielle-barnes/blvd">Blvd</a></li>
  <li><a href="https://github.com/CSaltx/Sous">Sous</a></li>
  <li><a href="https://github.com/bryanardon/River">River</a></li>
  <li><a href="https://github.com/conda-language/rat">Rat</a></li>
  <li><a href="https://github.com/AidanEsposito/Cod-CMSI-3802">Cod</a></li>
  <li><a href="https://github.com/Gray-V/GLHF">GLHF</a></li>
  <li><a href="https://github.com/TyValencia/BuildLang">BuildLang</a></li>
  <li><a href="https://github.com/breeatoomey/Banana">Banana</a></li>
  <li><a href="https://github.com/arikanev/Pyth-on-Point">Pyth-on-Point</a></li>
  <li><a href="https://github.com/yuevan10284/Dino-Programming-Language">Dino</a></li>
  <li><a href="https://github.com/anikambhatnagar/Sanscript">Sanscript</a></li>
  <li><a href="https://github.com/jmendo15/Kis">Kis</a></li>
  <li><a href="https://github.com/BryMad/yalle">YALL*E</a></li>
  <li><a href="https://github.com/Un3qual/jazz">Jazz</a></li>
  <li><a href="https://github.com/kvperez/Barista">Barista</a></li>
  <li><a href="https://github.com/dhuang2130/LangY">LangY</a></li>
  <li><a href="https://github.com/david518yang/MODE">MODE</a></li>
  <li><a href="https://github.com/abemo/bang">Bang</a></li>
  <li><a href=" https://github.com/BradyAmundson/Squishi">Squishi</a></li>
  <li><a href="https://github.com/connorsavage/SussyScript">SussyScript</a></li>
  <li><a href="https://github.com/RosettaYH/CoffeeMaker">CoffeeMaker</a></li>
  <li><a href="https://github.com/alex-armknecht/YeeHaw">YeeHaw</a></li>
  <li><a href="https://github.com/djacosta-01/Gullienne">Gullienne</a></li>
  <li><a href="https://github.com/StatusSin/Electric-Script">ElectricScript</a></li>
  <li><a href="https://github.com/troywh/Barista">Barista</a></li>
  <li><a href="https://github.com/claytoncb/Shrek--">Shrek--</a></li>
  <li><a href="https://github.com/QingwenZeng123/ChineseBaozi">Chinese Baozi</a></li>
  <li><a href="https://github.com/azabloud/icedCoffee">IcedCoffee</a></li>
  <li><a href="https://github.com/bryauk123/chloe">Chloe</a></li>
  <li><a href="https://github.com/cplant27/T.O.A.L.">T.O.A.L.</a></li>
  <li><a href="https://github.com/jasoncd31/PiratesCode">Pirates Code</a></li>
  <li><a href="https://github.com/bsteenbergen/leg">Leg</a></li>
  <li><a href="https://github.com/mhanna15/kobe">Kobe</a></li>
  <li><a href="https://github.com/etorlic/Cringe--">Cringe--</a></li>
  <li><a href="https://github.com/sureena888/bismath">Bismath</a></li>
  <li><a href="https://github.com/Jgonz156/Plumb">Plumb</a></li>
  <li><a href="https://github.com/naratheman/PokerScript">PokerScript</a></li>
  <li><a href="https://github.com/ImperatorSmugleaf/pandemonium">Pandemonium</a></li>
  <li><a href="https://github.com/irrelevantusername/easi">Easi</a></li>
  <li><a href="https://github.com/drwwoob/Palet">Palet</a></li>
  <li><a href="https://github.com/Willr2001/VikingScript">VikingScript</a></li>
  <li><a href="https://github.com/MichaelReza/Speare">Speare</a></li>
  <li><a href="https://github.com/krezaey/ahtohallan">Ahtohallan</a></li>
  <li><a href="https://github.com/brandonholmes/vinescript">VineScript</a></li>
  <li><a href="https://github.com/mmikol/BigMamasKitchen">Big Mama‚Äôs Kitchen</a></li>
  <li><a href="https://github.com/meganmrichardson/Medley">Medley</a></li>
  <li><a href="https://github.com/Booker-M/Custom">Custom</a></li>
  <li><a href="https://github.com/Dsackler/lemonScript">LemonScript</a></li>
  <li><a href="https://github.com/Ulq1517/Aegis">Aegis</a></li>
  <li><a href="https://github.com/cpon00/midi-chlorian">Midi-Cholorian</a></li>
  <li><a href="https://github.com/Kmarinsh/quotecodequote">qcq</a></li>
  <li><a href="https://github.com/breelynbetts/HYPER">HYPER!</a></li>
  <li><a href="https://github.com/laurenlindsey1/realhotgirlscript">RealHotGirlScript</a></li>
  <li><a href="https://github.com/wdibi/Pivot">Pivot</a></li>
  <li><a href="https://github.com/jennashea/snekql">SnekQL</a></li>
  <li><a href="https://github.com/jmaiocco/respecc">Respec++</a></li>
  <li><a href="https://github.com/hardlyfivefeet/r0b0p">r0b0p</a></li>
  <li><a href="https://github.com/adamhirata/uwuScript">uwuScript</a></li>
  <li><a href="https://github.com/pawvascript/pawvascript">PawvaScript</a></li>
  <li><a href="https://github.com/benjaminjkern/cuttlefishlang">Cuttlefish</a></li>
  <li><a href="https://github.com/mpeglerg/Inkling">Inkling</a></li>
  <li><a href="https://github.com/dmoini/casper">Casper</a></li>
  <li><a href="https://github.com/jlopez616/stonescript">StoneScript</a></li>
  <li><a href="https://github.com/cristalinanguyen/FUZZ">FUZZ++</a></li>
  <li><a href="https://github.com/BlakeCrowther/Goof3">Goof3</a></li>
  <li><a href="https://github.com/samsavv/Scriptofino">Scriptofino</a></li>
  <li><a href="https://github.com/brettderham/101Script">101Script</a></li>
  <li><a href="https://github.com/jtorre39/jen">Jen</a>
  </li><li><a href="https://github.com/eileenchoe/olive">Olive</a>
  </li><li><a href="https://github.com/CapnSquirrel/nebula">Nebula</a>
  </li><li><a href="https://github.com/joeymichaelmartinez/J4">J4</a>
  </li><li><a href="https://github.com/johns/alula">Alula</a>
  </li><li><a href="https://github.com/BenProtus/Pycante">Pycante</a>
  </li><li><a href="https://github.com/sashadmitrieva96/whiteboard">Whiteboard</a>
  </li><li><a href="https://github.com/AndreaCarver/favascript">Favascript</a>
  </li><li><a href="https://github.com/cpetrosi/Queen">Queen</a>
  </li><li><a href="https://github.com/NAnguiano/memescript">MemeScript</a>
  </li><li><a href="https://github.com/ronyaguilar09/SKRT">Skrt</a>
  </li><li><a href="https://github.com/j-woodlee/JCaml">JCaml</a>
  </li><li><a href="https://github.com/mpmcauley/Boozie">Boozie</a>
  </li><li><a href="https://github.com/SirSeim/Deeg">Deeg</a>
  </li><li><a href="https://github.com/ronaldooeee/AvaJava">AvaJava</a>
  </li><li><a href="https://github.com/Tohoma/yah">Yah</a>
  </li><li><a href="https://github.com/cbillingham/roo">Roo</a>
  </li><li><a href="https://github.com/ranneyd/agate">Agate</a>
  </li><li><a href="https://github.com/ajohn104/AboveAverageScript">AboveAverageScript</a>
  </li><li><a href="https://github.com/alexschneider/teascript">TeaScript</a>
  </li><li><a href="https://github.com/akrs/YACBL">YACBL</a>
  </li><li><a href="https://github.com/andyjwon/yoda-lang">Yoda</a>
  </li><li><a href="https://github.com/jcrawley/spitfire">Spitfire</a>
  </li><li><a href="https://github.com/thathalfkorean/cmsi488">Derpodile</a>
  </li><li><a href="https://github.com/r2d32/GollumScript">GollumScript</a>
  </li><li><a href="https://github.com/waverill7/Singularity">Singularity</a>
  </li><li><a href="https://github.com/AuthorOfTheSurf/kobra-script">KobraScript</a>
  </li><li><a href="https://github.com/offDaCharts/min">Min</a>
</li></ul>

<h2>Recall Practice</h2><p>Here are some questions useful for your spaced repetition learning. Many of the answers are not found on this page. Some will have popped up in lecture. Others will require you to do your own research.</p>
<ol>
<li>What are the four phases of programming language design? <p>(1) Working out the desired context (audience, purpose, scope), (2) sketching example programs, (3) formalizing the syntax and semantics, and (4) prototyping.</p></li>
<li>Name five programming language paradigms. <p>A few are: imperative, declarative, structured, object-oriented, functional, applicative, concatenative, logic, protocol-oriented, aspect-oriented, array, event-driven, dataflow, agent-based. There are others</p></li>
<li>What were the four big ideas in programming languages mentioned in Bret Victor‚Äôs <em>Future of Programming</em> talk? <p>(1) Direct manipulation of data rather than showing the code, (2) Goals and constraints rather than procedures, (3) Spatial representation of code rather than textual representations, and (4) Concurrent computation rather than sequential</p>
</li><li>What language did Alan Kay feature in his Programming Languages video? <p>eToys</p></li>
<li>What are some things to decide upon while undertaking language design? <p>The audience, the purpose, the scope, the problem domain it is target to, whether it is reasonable or esoteric, whether it has a simple foundation or favors pragmatism, its concurrency model.</p></li>
<li>In what essay did Bret Victor lay out several principles that languages and programming enviroments should follow to aid their users‚Äô learning? <p>Learnable Programming</p></li>
<li>What is abstract syntax? <p>The structure of a program without regard to the specific syntax used to represent it.</p></li>
<li>What is the name of the specification of JavaScript‚Äôs abstract syntax? <p>ESTree</p></li>
<li>At what web address can you find and interactive JavaScript AST builder? <p>https://rtoal.github.io/js-ast/</p></li>
<li>What are five approaches of showing (concrete) syntactic structure in popular programming languages? <p>Curly braces, indentation, terminal-ends, parentheses, postfix</p></li>
<li>What is an example of a programming language for which newlines are significant? <p>Answers include Python and Ruby</p></li>
<li>What is syntactic sugar? <p>Syntax within a programming language that is designed to make certain phrases more clear, concise, or elegant than the basic forms defined in the language.</p></li>
<li>What is syntactic salt? <p>Syntax within a programming language that is designed to make certain phrases more confusing, verbose, or awkward than the basic forms defined in the language.</p></li>
<li>What is a candygrammar? <p>A syntax that looks sweet and natural language-like that appears good but turns out to be bad for you.</p></li>
<li>What is a golfing language? <p>A language designed to be as terse as possible, often for the purpose of helping you win shortest-possible code challenges.</p></li>
<li>What are some examples of golfing languages? <p>CJam, Pyth, Stax, GolfScript, 05Ab1E</p></li>
<li>What are three styles of programming language definition? <p>Informal, formal, and executable</p></li>
<li>What is the difference between syntax and semantics? <p>Syntax deals with program structure. Semantics deals with program meaning.</p></li>
<li>What is the difference between a language‚Äôs <strong>statics</strong> and its <strong>dynamics</strong>? <p>Statics refers to the rules that can be checked at compile time. Dynamics refers to the rules that can only be checked at run-time.</p></li>
<li>What are syntax definitions generally split into lexical and phrase syntaxes? <p>Lexical syntax defines how invidividual characters are grouped in to words (tokens), while phrase syntax defines how these tokens are combined to form larger structures.</p></li>
<li>What is a parse tree? <p>A tree that describes the syntactic structure of a program as defined by the language‚Äôs syntax.</p></li>
<li>The frontier of the parse tree is the program‚Äôs __________. <p>Token stream</p></li>
<li>A parse tree is also called a __________. <p>Concrete syntax tree</p></li>
<li>What does it mean for a syntactic specificiation to be ambiguous? <p>There exists at least on program that has more than one parse tree.</p></li>
<li>What attributes of operators are generally used to disambiguate a syntactic specification? <p>Precedence and associativity</p></li>
<li>What tool is provided by the authors of the Ohm library to help you prototype a new language design? <p>The Ohm Editor</p></li>
<li>What was the title of Alex Warth‚Äôs dissertation? <p>Experimenting with Programming Languages</p></li>
<li>What are some examples of legality rules that are considered too hard to be captured in a grammar and are thus typically defined within a program‚Äôs static semantics? <p>You can only use an identifier if it has been previously assigned to, all function calls must accept the proper number of arguments, the built-in identifiers cannot be assigned to, identifiers declared as functions can only be called, not used in any other context, identifiers declared as numbers cannot be called, type checking, access checking (private, public), declared identifiers must be initialized or must be read. (There are many more.)</p></li>
<li>What example programming languages have been designed for this course? <p>Astro, Bella, Carlos, Dax, Ekko</p></li>
</ol>

<h2>Summary</h2><div><p>We‚Äôve covered:</p><ul><li>The cycle of language design phases</li><li>What to know before undertaking language design</li><li>Pointers to excellent articles and essays about language design</li><li>Two videos (one by Alan Kay, one by Bret Victor) on languages and language design</li><li>How to begin the language design process</li><li>Questions to ask while designing your language</li><li>Concepts and features to think about when sketching during design</li><li>Abstract Syntax</li><li>Concrete Syntax</li><li>The use of the Ohm Editor in language prototyping</li><li>(Formal) Language Definition</li><li>Brief notes on five example languages</li></ul></div>      </div>
    </div></div>
  </body>
</html>
