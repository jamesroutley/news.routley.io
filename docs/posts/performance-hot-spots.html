<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2022/04/12/performance-hot-spots.html">Original</a>
    <h1>Performance Hot Spots</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><strong>My code was running too slow.</strong> I tried changing some things. I short-circuited some loops. I manually garbage-collected some objects. I even changed some lists to tuples, because an old piece of Python folklore passed down through the ages says that “tuples are faster than lists”. <strong>But nothing worked.</strong></p>

<p>It didn’t work because none of the changes were made at the <strong><em>hot spots</em></strong>. Hot spots are places in the code where an inordinate amount of execution time is spent. Code doesn’t always have hot spots, but they aren’t rare.</p>

<p>There are several <strong>methods for detecting hot spots</strong> in common use.</p>

<ol>
  <li>Experience</li>
  <li>Instinct</li>
  <li>Guesswork</li>
  <li>Clairvoyance</li>
  <li>Hunches</li>
  <li>Superstition</li>
  <li>Gut</li>
  <li>Trial and error</li>
  <li>Measurement</li>
</ol>

<p><strong>Measurement is the only reliable method for finding hot spots.</strong> The other methods range from mostly ineffective to stupid and counterproductive. Working on performance without measuring is like cutting your own hair without a mirror. Believe me, I’ve done both.</p>

<p>I measured my code with a <strong>profiler</strong>, and here’s what I saw:</p>

<p><img src="https://www.apple.com/assets/2022-04-12-performance-hot-spots/before.png" alt="img"/></p>

<p>Can you guess where the problem is? That’s right, it’s the <strong>red box</strong>. According to the <strong>callgraph</strong>, a whopping <em>76% of execution time</em> is getting spent in that box and its sub-boxes.</p>

<p>This isn’t an uncommon situation, and it isn’t always indicative of a problem. It could be that the red box is executing some <strong>critical computation</strong>, the hard core of what the app actually “does”, and the rest of the code is just <strong>dispatching fluff</strong>. In that case, it would seem that most of the work getting done is work that has to get done, and that’s good.</p>

<p>But that isn’t what’s going on in my code. Looking closer at that red box, I can see that it’s a <strong>Python library function</strong>, namely <code>copy.deepcopy</code>. <strong>76% of execution time is spent deepcopying! Whoops!</strong> So much time is spent deepcopying that the profiler looked into that function’s innards; the green box is something called <code>_deepcopy_list</code>.</p>

<p>This is a <strong>performance bottleneck</strong>, and it’s a problem. It’s also an <strong>opportunity</strong>. It means that I can go in and change just a few lines of code and get a big performance improvement. And indeed that was accomplished in <a href="https://github.com/nickdrozd/busy-beaver-stuff/commit/9aed37844f5067bd4c91fbe3f9ae1ec853e3f60c">a single commit</a>. It was just a matter of doing the copying a little smarter. No need to think about system design or algorithms or any other difficult stuff, which is great.</p>

<p>Here what the profiler showed afterwards:</p>

<p><img src="https://www.apple.com/assets/2022-04-12-performance-hot-spots/after.png" alt="img"/></p>

<p>That is a <strong>healthier-looking callgraph</strong>. More green and yellow boxes indicate that the load is being spread around more. There’s still a red box, but instead of some crummy builtin, it’s a function called <code>Machine.run</code>. This is part of the core functionality, so the red box is not so concerning.</p>



<p>The general principles of profiling apply to any language, but the specific instructions vary. I’ll tell you how I do it in <strong>Python</strong>. I do it the same way every time and I don’t have a great insight into how the tools work. These are the <strong>incantations</strong> that have been passed down to me.</p>

<p>The profiling library is called <code>yappi</code>. It works by wrapping the <code>main</code> function, or the toplevel entrypoint or whatever:</p>

<figure><pre><code data-lang="python"><span>import</span> <span>yappi</span>

<span>yappi</span><span>.</span><span>set_clock_type</span><span>(</span><span>&#39;cpu&#39;</span><span>)</span>
<span>yappi</span><span>.</span><span>start</span><span>()</span>

<span>try</span><span>:</span>
  <span>main_or_toplevel_entrypoint_or_whatever</span><span>()</span>

<span>finally</span><span>:</span>
  <span>stats</span> <span>=</span> <span>yappi</span><span>.</span><span>get_func_stats</span><span>()</span>
  <span>stats</span><span>.</span><span>save</span><span>(</span><span>&#39;yappi.callgrind&#39;</span><span>,</span> <span>type</span> <span>=</span> <span>&#39;callgrind&#39;</span><span>)</span></code></pre></figure>

<p>Run that, then convert the profiling data into <strong>Graphviz</strong> format with <code>gprof2dot</code>:</p>

<figure><pre><code data-lang="shell">gprof2dot yappi.callgrind <span>-f</span> callgrind <span>--colour-nodes-by-selftime</span> | dot <span>-T</span> png <span>-o</span> yappi.png</code></pre></figure>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
