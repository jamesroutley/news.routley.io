<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joseprupi.github.io/misc/2023/08/19/playing_with_genetic_algorithms_in_python.html">Original</a>
    <h1>Playing with genetic algorithms in Python</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>A long long time ago I was young and going to school to attend a Computer Science program. It was so long ago that the data structures course was done in C++ and Java was shown to us as the new kid on the block.</p>

<p>Something I learned in CS that sticked in my head were Genetic Algorithms. I guess the reason was that GA were one of the first (and few) applied things I saw in CS and it seemed to me a simple, intuitive and brilliant idea. Today I was bored at home and I decided to play a little bit with it.</p>

<p><a href="https://en.wikipedia.org/wiki/Genetic_algorithm">GAs</a> are a search technique that is inspired in biological evolution and genetic mutations which are used to purge certain parts of the search space. This is done encoding the nodes in the space into a genetic representation and using a fitness function to evaluate them.</p>

<p>I started implementing a useless but I think illustrative example of GAs which is generating a sequence of random bits and then search for it. Plotting it as an $nxn$ matrix makes it is easier to  visualize and debug the process.</p>

<div><div><pre><code><span>img</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>2</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>15</span><span>,</span><span>15</span><span>))</span>
<span>plt</span><span>.</span><span>imshow</span><span>(</span><span>img</span><span>,</span> <span>cmap</span><span>=</span><span>plt</span><span>.</span><span>cm</span><span>.</span><span>gray</span><span>)</span>
<span>plt</span><span>.</span><span>show</span><span>()</span>
</code></pre></div></div>

<p><img src="https://joseprupi.github.io/assets/random_array.png" alt="image"/></p>

<p>This is a 15x15 array, so 225 bits and therefore a space of 2^225 possible combinations. Next I define the fitness function which is nothing more than the amount of bits of the image have the same value. In Numpy it would be:</p>

<div><div><pre><code><span>def</span> <span>score</span><span>(</span><span>matrix1</span><span>,</span> <span>matrix2</span><span>):</span>
    <span>return</span> <span>(</span><span>matrix1</span> <span>==</span> <span>matrix2</span><span>).</span><span>sum</span><span>()</span>
</code></pre></div></div>

<p>The genetic algorithm implementation per se (the fitness function, crossover and mutation) is implemented below, where the parameters <strong>population</strong> is the initial population and <strong>mutations</strong> are the percentage of mutated bits.</p>

<div><div><pre><code>
<span>def</span> <span>ga</span><span>(</span><span>array</span><span>,</span> <span>population</span><span>,</span> <span>mutations</span><span>):</span>

    <span>def</span> <span>score</span><span>(</span><span>matrix1</span><span>,</span> <span>matrix2</span><span>):</span>
        <span>return</span> <span>(</span><span>matrix1</span> <span>==</span> <span>matrix2</span><span>).</span><span>sum</span><span>()</span>

    <span>rows</span> <span>=</span> <span>array</span><span>.</span><span>shape</span><span>[</span><span>0</span><span>]</span>
    <span>columns</span> <span>=</span> <span>array</span><span>.</span><span>shape</span><span>[</span><span>1</span><span>]</span>
    <span>mid</span> <span>=</span> <span>rows</span><span>//</span><span>2</span>

    <span>mem</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>2</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>2</span> <span>*</span> <span>population</span><span>,</span> <span>rows</span><span>,</span> <span>columns</span><span>))</span>
    <span>scores</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>2</span> <span>*</span> <span>population</span><span>))</span>
    <span>bottom</span> <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>len</span><span>(</span><span>mem</span><span>)))</span>

    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1000000</span><span>):</span>
        
        <span># When initialized bottom will contain a set of random individuals. Later it will be
</span>        <span># the bottom of the list of individuals sorted by score
</span>        <span>for</span> <span>k</span> <span>in</span> <span>bottom</span><span>:</span>
            <span>scores</span><span>[</span><span>k</span><span>]</span> <span>=</span> <span>score</span><span>(</span><span>mem</span><span>[</span><span>k</span><span>],</span> <span>array</span><span>)</span>

        <span># Check if the solution has been found
</span>        <span>max_score</span> <span>=</span> <span>np</span><span>.</span><span>argmax</span><span>(</span><span>scores</span><span>)</span>
        <span>if</span> <span>scores</span><span>[</span><span>max_score</span><span>]</span> <span>==</span> <span>rows</span> <span>*</span> <span>columns</span><span>:</span>
            <span>print</span><span>(</span><span>i</span><span>)</span>
            <span>plt</span><span>.</span><span>imshow</span><span>(</span><span>mem</span><span>[</span><span>max_score</span><span>],</span> <span>cmap</span><span>=</span><span>plt</span><span>.</span><span>cm</span><span>.</span><span>gray</span><span>)</span>  <span># use appropriate colormap here
</span>            <span>plt</span><span>.</span><span>show</span><span>()</span>
            <span>break</span>

        <span># Select the population of individuals according to the score function
</span>        <span>top_n_scores</span> <span>=</span> <span>np</span><span>.</span><span>argpartition</span><span>(</span><span>scores</span><span>,</span> <span>population</span><span>)</span>
        <span>top</span> <span>=</span> <span>top_n_scores</span><span>[</span><span>population</span><span>:]</span>
        <span>bottom</span> <span>=</span> <span>top_n_scores</span><span>[:</span><span>population</span><span>]</span>

        <span># Create #population new elements from the crossover and mutation
</span>        <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>population</span><span>):</span>
            
            <span># Crossover -&gt; Select parents from the top individuals
</span>            <span>#
</span>            <span># I tried this with random.choice or just picking a random position from the list and
</span>            <span># the next one. The result is the same for both but way faster
</span>            <span># with the latter option.
</span>            <span># The reason it still works might be either because of the randomization of the initial 
</span>            <span># population or maybe the implementation of argpartition? or both?
</span>            <span>r</span> <span>=</span> <span>random</span><span>.</span><span>randrange</span><span>(</span><span>len</span><span>(</span><span>top</span><span>))</span>  
            <span>idx</span> <span>=</span> <span>[</span><span>r</span><span>,</span> <span>(</span><span>r</span><span>+</span><span>1</span><span>)</span><span>%</span><span>len</span><span>(</span><span>top</span><span>)]</span>
            <span>parents</span> <span>=</span> <span>[</span><span>top</span><span>[</span><span>idx</span><span>[</span><span>0</span><span>]],</span><span>top</span><span>[</span><span>idx</span><span>[</span><span>1</span><span>]]]</span>
            
            <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>0</span><span>:</span><span>mid</span><span>]</span> <span>=</span> <span>mem</span><span>[</span><span>parents</span><span>[</span><span>0</span><span>]][</span><span>0</span><span>:</span><span>mid</span><span>]</span>
            <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>-</span><span>(</span><span>mid</span><span>+</span><span>1</span><span>):]</span> <span>=</span> <span>mem</span><span>[</span><span>parents</span><span>[</span><span>1</span><span>]][</span><span>-</span><span>(</span><span>mid</span><span>+</span><span>1</span><span>):]</span>

            <span># Mutation -&gt; Mutate the bits
</span>            <span>#
</span>            <span># The random choice of the bits to mutate is the most costly of the implementation
</span>            <span># It seems there has to be some way to speed up this 
</span>            <span>idx</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>([</span><span>0</span><span>,</span><span>1</span><span>],</span> <span>p</span><span>=</span><span>[(</span><span>1</span><span>-</span><span>mutations</span><span>),</span> <span>mutations</span><span>],</span><span>size</span><span>=</span><span>(</span><span>rows</span><span>,</span><span>columns</span><span>))</span>
            <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]]</span> <span>=</span> <span>abs</span><span>(</span><span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]]</span> <span>-</span> <span>idx</span><span>)</span>

</code></pre></div></div>
<p>With some manual testing and trial error I ended up with an initial population of 500 and a mutation of 0.5% as the fastest way to find the array of bits, which finishes in approximately 160 iterations and 3 seconds in my computer. Even the experiment not making sense seems pretty good to me taking into account that the space is 2^225 and it can be implemented with few lines of code.</p>

<p>The entire implementation can be found <a href="https://github.com/joseprupi/ga/blob/master/test.ipynb">here</a></p>

<p>Next I wanted to try something more useful, solving mastermind with 6 colors and 4 pegs, the original game had to be solved with 12 moves.</p>

<p>The implementation is similar to the previous one, mostly changing the score function. To count the number of evaluated choices I memoize the score function.</p>

<p>My best approach is a population of 2, and mutate 1 out of 4 pegs, with an average of ~36 evaluateed choices, so three times more than what would be the 12 choices of the original game. Something interesting is that with only crossover and mutation the information regarding the pegs with the correct color but not in the correct spot does not seem to be relevant.</p>

<p>The entire implementation can be found <a href="https://github.com/joseprupi/ga/blob/master/mastermind.ipynb">here</a></p>

<div><div><pre><code>
<span>def</span> <span>ga</span><span>(</span><span>array</span><span>,</span> <span>population</span><span>,</span> <span>mutations</span><span>):</span>

    <span>score_memoization</span> <span>=</span> <span>{}</span>

    <span>def</span> <span>score</span><span>(</span><span>board</span><span>,</span> <span>choice</span><span>):</span>
        
        <span>key</span> <span>=</span> <span>tuple</span><span>(</span><span>choice</span><span>)</span>
        
        <span>if</span> <span>key</span> <span>in</span> <span>score_memoization</span><span>:</span>
            <span>return</span> <span>score_memoization</span><span>[</span><span>key</span><span>]</span>

        <span>tmp_board</span> <span>=</span> <span>board</span><span>.</span><span>copy</span><span>()</span>

        <span>in_place</span> <span>=</span> <span>0</span>
        <span>in_place_list</span> <span>=</span> <span>set</span><span>()</span>
        <span>same_color</span> <span>=</span> <span>0</span>

        <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>choice</span><span>)):</span>
            <span>if</span> <span>choice</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>board</span><span>[</span><span>i</span><span>]:</span>
                <span>in_place</span> <span>+=</span> <span>1</span>
                <span>in_place_list</span><span>.</span><span>add</span><span>(</span><span>i</span><span>)</span>
                <span>tmp_board</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>-</span><span>1</span>

        <span>for</span> <span>i</span><span>,</span><span>c</span> <span>in</span> <span>enumerate</span><span>(</span><span>choice</span><span>):</span>
            <span>if</span> <span>i</span> <span>not</span> <span>in</span> <span>in_place_list</span> <span>and</span> <span>c</span> <span>in</span> <span>tmp_board</span><span>:</span>
                <span>same_color</span> <span>+=</span> <span>1</span>

        <span># In correct place and correct color
</span>        <span>#score = (2 * in_place) + same_color
</span>        
        <span># Only in correct place
</span>        <span>score</span> <span>=</span> <span>in_place</span>

        <span>score_memoization</span><span>[</span><span>key</span><span>]</span> <span>=</span> <span>score</span>

        <span>return</span> <span>score</span>

    <span>mid</span> <span>=</span> <span>4</span><span>//</span><span>2</span>

    <span>mem</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>randint</span><span>(</span><span>6</span><span>,</span> <span>size</span><span>=</span><span>(</span><span>2</span> <span>*</span> <span>population</span><span>,</span> <span>4</span><span>))</span>
    <span>scores</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>((</span><span>2</span> <span>*</span> <span>population</span><span>))</span>
    <span>bottom</span> <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>len</span><span>(</span><span>mem</span><span>)))</span>

    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1000000</span><span>):</span>
        
        <span># When initialized bottom will contain a set of random individuals. Later it will be
</span>        <span># the bottom of the list of individuals sorted by score
</span>        <span>for</span> <span>k</span> <span>in</span> <span>bottom</span><span>:</span>
            <span>scores</span><span>[</span><span>k</span><span>]</span> <span>=</span> <span>score</span><span>(</span><span>array</span><span>,</span> <span>mem</span><span>[</span><span>k</span><span>])</span>

        <span># Check if the solution has been found
</span>        <span>max_score</span> <span>=</span> <span>np</span><span>.</span><span>argmax</span><span>(</span><span>scores</span><span>)</span>
        <span>if</span> <span>scores</span><span>[</span><span>max_score</span><span>]</span> <span>==</span> <span>8</span><span>:</span>
            <span>return</span> <span>i</span><span>,</span> <span>len</span><span>(</span><span>score_memoization</span><span>)</span>

        <span># Select the population of individuals according to the score function
</span>        <span>top_n_scores</span> <span>=</span> <span>np</span><span>.</span><span>argpartition</span><span>(</span><span>scores</span><span>,</span> <span>population</span><span>)</span>
        <span>top</span> <span>=</span> <span>top_n_scores</span><span>[</span><span>population</span><span>:]</span>
        <span>bottom</span> <span>=</span> <span>top_n_scores</span><span>[:</span><span>population</span><span>]</span>

        <span># Create #population new elements from the crossover and mutation
</span>        <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>population</span><span>):</span>

            <span># Crossover -&gt; Select parents from the top individuals
</span>            <span>#
</span>            <span># I tried this with random.choice or just picking a random position from the list and
</span>            <span># the next one. The result is the same for both but way faster
</span>            <span># with the latter option.
</span>            <span># The reason it still works might be either because of the randomization of the initial 
</span>            <span># population or maybe the implementation of argpartition? or both?
</span>            
            <span>r</span> <span>=</span> <span>random</span><span>.</span><span>randrange</span><span>(</span><span>len</span><span>(</span><span>top</span><span>))</span>  
            <span>idx</span> <span>=</span> <span>[</span><span>r</span><span>,</span> <span>(</span><span>r</span><span>+</span><span>1</span><span>)</span><span>%</span><span>len</span><span>(</span><span>top</span><span>)]</span>
            <span>parents</span> <span>=</span> <span>[</span><span>top</span><span>[</span><span>idx</span><span>[</span><span>0</span><span>]],</span><span>top</span><span>[</span><span>idx</span><span>[</span><span>1</span><span>]]]</span>
            
            <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>0</span><span>:</span><span>mid</span><span>]</span> <span>=</span> <span>mem</span><span>[</span><span>parents</span><span>[</span><span>0</span><span>]][</span><span>0</span><span>:</span><span>mid</span><span>]</span>
            <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>-</span><span>(</span><span>mid</span><span>):]</span> <span>=</span> <span>mem</span><span>[</span><span>parents</span><span>[</span><span>1</span><span>]][</span><span>-</span><span>(</span><span>mid</span><span>):]</span>

            <span># Mutation -&gt; Mutate the bits
</span>            <span>#
</span>            <span># The random choice of the bits to mutate is the most costly of the implementation
</span>            <span># It seems there has to be some way to speed up this 
</span>            <span>idx</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>choice</span><span>([</span><span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>],</span> <span>p</span><span>=</span><span>[(</span><span>1</span><span>-</span><span>mutations</span><span>),</span> <span>mutations</span><span>/</span><span>6</span><span>,</span><span>mutations</span><span>/</span><span>6</span><span>,</span><span>mutations</span><span>/</span><span>6</span><span>,</span><span>mutations</span><span>/</span><span>6</span><span>,</span><span>mutations</span><span>/</span><span>6</span><span>,</span><span>mutations</span><span>/</span><span>6</span><span>],</span><span>size</span><span>=</span><span>(</span><span>4</span><span>))</span>

            <span>for</span> <span>k</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>idx</span><span>)):</span>
                <span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>k</span><span>]</span> <span>=</span> <span>(</span><span>mem</span><span>[</span><span>bottom</span><span>[</span><span>j</span><span>]][</span><span>k</span><span>]</span> <span>+</span> <span>idx</span><span>[</span><span>k</span><span>])</span><span>%</span><span>6</span>
</code></pre></div></div>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
