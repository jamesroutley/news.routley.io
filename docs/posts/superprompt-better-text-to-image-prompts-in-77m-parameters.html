<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brianfitzgerald.xyz/prompt-augmentation/">Original</a>
    <h1>SuperPrompt: Better Text to Image Prompts in 77M Parameters</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container" itemprop="articleBody"><p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/penguin_lq-14792ba26622077382696ed39eea336c.png" width="1024" height="1024"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/penguin_hq-0d6e5c03dd4bfdb54c52c25421bdd1ce.png" width="1024" height="1024"/></p>
<p><em>Left: Drawbench prompt &#34;A rainbow penguin in a tuxedo&#34;. Right: SDXL output with SuperPrompt applied to the same input prompt.</em></p>
<p><strong>TL;DR</strong>: I&#39;ve trained a 77M T5 model to expand prompts, and it meets or exceeds existing 1B+ parameter LLMs in quality and prompt alignment.</p>
<p>When DALL-E 3 was released, I was a) really impressed, and b) struck by how obviously good an idea the prompt augmentation it uses was. To that end, I&#39;ve spent some time over the last few months playing around with some various approaches to emulate that functionality.</p>
<p>When viewed from a more general perspective, the problem of &#34;take a user&#39;s intent, and generate an image that looks better than it would otherwise&#34;, without tuning the T2I model itself, has some interesting potential upsides:</p>
<ul>
<li>When tuning a model for aesthetics, it&#39;s very easy to overfit in strange ways; for example, biasing towards heavily saturated imagery, or smoothing out details; this leads to a model that can&#39;t reproduce those qualities when you want them to. An initial upsampling step leaves the original model intact but potentially gives the same benefits.</li>
<li>Large models have biases, that are notoriously hard to remove or tune. OpenAI partially solves this with the ChatGPT system prompt, which has lots of instruction related to content policy, protecting IP, etc. Changing a system prompt is much cheaper than tuning a T2I model!</li>
<li>Eventually, more T2I models will get better at following text prompts, like DALL-E 3 is; however, a lot of users (myself included) will still want to prompt for simple things like &#34;a dog in a bucket hat&#34;, whereas the model is conditioned to generate images with captions like &#34;A cute, fluffy dog wearing a colorful bucket hat. The dog is sitting in a sunny garden, surrounded by vibrant flowers. The hat is tilted slightly to one side, adding a playful touch to the dog&#39;s appearance.&#34; Just asking for a &#34;a dog in a bucket hat&#34; leaves a lot of potential detail and fidelity on the table!</li>
</ul>
<p>So here are the approaches I tried:</p>
<h3 id="clip-augmentation">CLIP augmentation<a href="#clip-augmentation" aria-label="Direct link to CLIP augmentation" title="Direct link to CLIP augmentation">​</a></h3>
<p>The idea here is that the existing model (in my experiments, SDXL 1.0) is conditioned on CLIP text embeddings; and within a CLIP embedding space, the existing prompt, and a better prettier prompt, both exist - so I&#39;d train a ~20M parameter MLP to convert the CLIP embeddings (unpooled, as is used in the diffusion model) from an worse looking prompt to a nicer one. For the dataset, I&#39;d use the DiffusionDB prompt dataset, and use Llama2 to rewrite the prompts to remove any descriptors that might improve the fidelity of the image.</p>
<table><thead><tr><th>Input</th><th>Target</th></tr></thead><tbody><tr><td>beautiful porcelain biomechanical cyborg woman, close - up, sharp focus, studio light (...)</td><td>porcelain cyborg woman</td></tr><tr><td>two scientists wearing red high fashion hazmat suits in a glowing geometric nebula wormhole tunnel	(...)</td><td>two scientists wearing red hazmat suits in a tunnel</td></tr></tbody></table>
<p><em>Example rows from the dataset.</em></p>
<p>This didn&#39;t work; I tried a number of things, from various model architectures / configs to different datasets and augmentation pipelines. The model would get frustratingly close at times; I&#39;d watch it generate a much nicer or more coherent scene for one sample and totally whiff it with the next. I think there&#39;s potentially a solution here, but it might require some very sensitive hyperparameter tuning to avoid overfitting or model collapse. The existence of aesthetic predictors and other classifiers built atop CLIP implies that this should be possible, though such models don&#39;t have to account for the biases that the diffusion model contains towards the text encoder.</p>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_5_1_baseline-7b40b05a45f453d0f71cc54202d6f42d.png" width="1024" height="1024"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_5_1_clip_aug-ee3f58a30b8eb680c1c343a4754ac44e.png" width="1024" height="1024"/></p>
<p><em>Left: baseline with prompt &#34;A yellow colored giraffe&#34; from <a href="https://docs.google.com/spreadsheets/d/1y7nAbmR4FREi6npB1u-Bo3GFdwdOPYJc617rBOxIRHY/edit#gid=0" target="_blank" rel="noopener noreferrer">Drawbench</a>. Right: SDXL output with CLIP-augmented text embeddings.</em></p>
<h3 id="u-net-augmentation">U-Net augmentation<a href="#u-net-augmentation" aria-label="Direct link to U-Net augmentation" title="Direct link to U-Net augmentation">​</a></h3>
<p>Thinking about why the CLIP augmenter didn&#39;t work, I wondered if it might be easier to instead augment the latent during certain steps of the denoising process. Taking a page from SD Ultimate Upscale - which uses a secondary U-net to upscale a latent - I tried training a latent augmenter, while performing inference on prompts from the same DiffusionDB dataset.</p>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_7_1_baseline-831ee2914173c48b1ba9068a7f159dce.png" width="1024" height="1024"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_7_1_baseline3-41f356dc48aa89bd13ffb5a954a0fe8d.png" width="1024" height="1024"/></p>
<p><em>Left: baseline with prompt &#34;A white sheep driving a red car&#34; . Right: SDXL output with Unet augmentation pass before sampling.</em></p>
<p>This <em>did</em> seem to work, though the U-net was fairly big - about 800M parameters, which is nearly the size of the smallest LLMs; and the results were still not great. It felt like the improvement in quality wasn&#39;t really worth how big the model was; as is often the case in ML, it&#39;s likely there <em>is</em> a way to get this to work well - though it might require a dataset or training regime that is radically different from what I tried. I spent a few weeks fiddling with this, before finally realizing I wasn&#39;t really making progress; and anyways, this approach has a few serious downsides:</p>
<ul>
<li>When VAE or model architecture changes happen, the model would have to be at best tuned heavily, and at worst, trained again from scratch.</li>
<li>The model needs lots of data to train, as we&#39;re training a U-net from scratch. Decent quality output only started to appear after about 100k steps, and the model was still improving at 200k steps. Besides cost, this is also a fairly large-scale aesthetic dataset; even <a href="https://huggingface.co/datasets/yuvalkirstain/pickapic_v1" target="_blank" rel="noopener noreferrer">Pick-a-Pic</a> which is ~600k samples would likely not be large enough.</li>
</ul>
<p>You know what doesn&#39;t have these issues? Language models.</p>
<h3 id="tinyllama">TinyLlama<a href="#tinyllama" aria-label="Direct link to TinyLlama" title="Direct link to TinyLlama">​</a></h3>
<p>As I was working on this, the first few TinyLlama Instruct checkpoints had been released. It seemed like a good fit; take the existing prompt dataset, reformat it to be compatible with Axolotl, and tune. Fortunately, this worked, almost immediately!</p>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/sheep_lq-c0e4856e4a368cd34be5af18c5507443.jpg" width="768" height="768"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/sheep_hq-9a7af1b5670c41fa683e9068788be1d0.jpg" width="768" height="768"/></p>
<p><em>Left: generated with the prompt &#34;A white sheep driving a red car&#34; . Right: generated with the upsampled prompt &#34;a fluffy white sheep confidently drives a shiny red car along a scenic country road&#34;.</em></p>
<p>In fact - without any tuning the instruct model did a pretty good job of expanding prompts. However, thinking back to earlier projects like MagicPrompt, and how well that model performs with a fifth of the parameters (200M in GPT-2 vs 1B), it&#39;s actually a lot less impressive. To that end, I started looking at options for going smaller.</p>
<h3 id="sequence-to-sequence">Sequence to Sequence<a href="#sequence-to-sequence" aria-label="Direct link to Sequence to Sequence" title="Direct link to Sequence to Sequence">​</a></h3>
<p>The smallest T5 model available is 22 million parameters; for BERT, about 8 million. These are <em>absurdly</em> tiny for 2024 language model standards; roughly the same size as the MLP layers we used above! After writing some <a href="https://github.com/brianfitzgerald/smolmodels" target="_blank" rel="noopener noreferrer">basic training code</a>, I fine-tuned a 77M T5 model using the same augmented DiffusionDB dataset as above, and got prompts like:</p>
<blockquote>
<p>a fleet, 8 k, starships, oil painting, detailed, cyberpunk colour palette, composition, lighting, masterpiece, by adrian ghenie and jenny saville and zhang jingna</p>
</blockquote>
<p>Promising - though not perfect. Cue more hyperparameter tuning, fixing implementation details in my training script, etc - before finally digging into. While this dataset was large - about 5 million rows - I was beginning to suspect that the augmentations and the quality of the data itself was limiting things; it included lots of prompts like this:</p>
<blockquote>
<p>mount epic mechanical dragons steamscale incinerator screenshot world of warcraft mounts worldboss, art gta 5 cover, official fanart behance hd artstation by jesper ejsing, by rhads, makoto shinkai and lois van baarle, ilya kuvshinov, ossdraws, that looks like it is from borderlands and by feng zhu and loish and laurie greasley</p>
</blockquote>
<p>and this:</p>
<blockquote>
<p>gundam head, v - fin, octane render, soft light, mekka, behance, vector, highly detailed illustration, realistic, black and gold metal design, dribbble. com, by secondsyndicate studio,</p>
</blockquote>
<p>Which are <em>nearly entirely</em> adjectives, and when filtered by the LLM, return maybe 1-2 words out of a 30-40 word prompt. This means that the model would have to associate lots of adjectives to relatively few subjects / nouns. So I tried a different strategy - generating synthetic hyper-detailed prompts following the upsampling prompt in the <a href="https://cdn.openai.com/papers/dall-e-3.pdf" target="_blank" rel="noopener noreferrer">DALL-E 3 paper</a>, and the <a href="https://huggingface.co/datasets/nateraw/parti-prompts" target="_blank" rel="noopener noreferrer">PartiPrompts dataset</a>. Cue another training run on flan-T5-small, and we get prompts like:</p>
<blockquote>
<p>The storefront of &#34;Hello World&#34; is painted in vibrant shades of orange and yellow, with the words &#34;Hello World&#34; written in bold, cursive letters across the front. The storefront is surrounded by a bustling cityscape, with skyscrapers and neon signs lining the walls. The storefront is surrounded by a sea of people, all gazing up at the sky with a sense of excitement and excitement.</p>
</blockquote>
<blockquote>
<p>In the tranquil expanse of a picturesque countryside, where rolling green hills meet the azure sky, a fluffy white sheep confidently takes the helm of a shiny red car, navigating its way along a winding road with an air of determined curiosity and adventurous spirit.</p>
</blockquote>
<p>Amazing! And the resulting images look great too.</p>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_7_1_t5-fe6ad55e4bcca005bd40be9f6d87e0d4.png" width="512" height="512"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/8_7_1_t5_2-0762a0c32169f0ff20296424088c7fb8.png" width="512" height="512"/></p>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/helloworld-b6b2b2c5d1b672906f36e719e1ef6be0.png" width="1024" height="1024"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/helloworld2-143432c31799799e1977ec791841d905.png" width="512" height="512"/></p>
<p>The trained model is now available on my HuggingFace page - download it <a href="https://huggingface.co/roborovski/superprompt-v1" target="_blank" rel="noopener noreferrer">here</a>, and try adding it to your pipeline with the Transformers library, like so:</p>
<div><div><pre tabindex="0"><code><span><span>from</span><span> transformers </span><span>import</span><span> T5Tokenizer</span><span>,</span><span> T5ForConditionalGeneration</span><br/></span><span><span></span><br/></span><span><span>tokenizer </span><span>=</span><span> T5Tokenizer</span><span>.</span><span>from_pretrained</span><span>(</span><span>&#34;google/flan-t5-small&#34;</span><span>)</span><span></span><br/></span><span><span>model </span><span>=</span><span> T5ForConditionalGeneration</span><span>.</span><span>from_pretrained</span><span>(</span><span>&#34;roborovksi/superprompt-v1&#34;</span><span>,</span><span> device_map</span><span>=</span><span>&#34;auto&#34;</span><span>)</span><span></span><br/></span><span><span></span><br/></span><span><span>input_text </span><span>=</span><span> </span><span>&#34;Expand the following prompt to add more detail: A storefront with &#39;Text to Image&#39; written on it.&#34;</span><span></span><br/></span><span><span>output </span><span>=</span><span> model</span><span>.</span><span>generate</span><span>(</span><span>tokenizer</span><span>(</span><span>input_text</span><span>,</span><span> return_tensors</span><span>=</span><span>&#34;pt&#34;</span><span>)</span><span>.</span><span>input_ids</span><span>.</span><span>to</span><span>(</span><span>&#34;cuda&#34;</span><span>)</span><span>)</span><br/></span></code></pre></div></div>
<p>I&#39;ll also be publishing a ComfyUI custom node, and some more variant models, soon.</p>
<h3 id="takeaways">Takeaways<a href="#takeaways" aria-label="Direct link to Takeaways" title="Direct link to Takeaways">​</a></h3>
<p>The data is the most important thing. No model architecture, especially with smaller models, can correct for data that is fundamentally flawed in some way. I could have saved myself lots of time hopping between different model architectures and tweaking hyperparameters if I&#39;d started with a cleaner, smaller dataset, and started with the simplest approach first. Again - something I&#39;ve learned many times over, but it&#39;s still all too easy to reach for a shiny new architecture instead of reviewing data.</p>
<p>Taking a very general problem like this and tackling it by training models is a tough process, but I always learn a lot by doing so; and hopefully you learned something from this post, or use the resulting model to generate better images.</p>
<h3 id="evaluation-and-notes">Evaluation and Notes<a href="#evaluation-and-notes" aria-label="Direct link to Evaluation and Notes" title="Direct link to Evaluation and Notes">​</a></h3>
<ul>
<li>Evaluation results are below; both were gathered on the <a href="https://docs.google.com/spreadsheets/d/1y7nAbmR4FREi6npB1u-Bo3GFdwdOPYJc617rBOxIRHY/edit#gid=0" target="_blank" rel="noopener noreferrer">Drawbench</a> dataset. This uses the CLIP distance of the generated image with SDXL, at 40 steps and the Euler sampler, from the original prompt as the metric. You can see how wide of a gulf there is between the U-net and CLIP aug methods, and the LLM-based methods.</li>
</ul>
<p><img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/clip_distance-e8e554004413b3f8fd3b91f7650d0d6a.png" width="1009" height="547"/>
<img decoding="async" loading="lazy" src="https://brianfitzgerald.xyz/assets/images/clip_distance_category-c408df8bfb92001ff56bc27e95bbe97c.png" width="1589" height="490"/></p>
<ul>
<li>With T5 fine-tuning, the common recommendation is to use Adafactor as an optimizer. Suprisingly, I found that AdamW worked better in my experiments; I suspect this is more to do with learning rate schedule, which I kept both longer and less aggressive than the recommended defaults, which meant that the aggressive beta updating Adafactor is meant to combat don&#39;t appear in my experiments.</li>
<li>You can find the rest of the code for prompt upsampling, and the other experiments in <a href="https://github.com/brianfitzgerald/superprompt" target="_blank" rel="noopener noreferrer">this repo</a>. Be warned, it&#39;s not very clean!</li>
<li>I filtered Drawbench for any overlap with my augmented dataset, and performed a basic deduplication (n-gram overlap) on the augmented dataset prior to training. The model only works in English, but shouldn&#39;t be hard to adapt to other languages. It also has a tendency to repeat itself when generating for long enough but I didn&#39;t observe this happening at or below the 77-token limit for SDXL prompts.</li>
</ul>
<p><em>Disclaimer: I work at Stability AI, but all work mentioned here is a personal side project and isn&#39;t affiliated with Stability in any way.</em></p></div></div>
  </body>
</html>
