<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lucymcphail.com/posts/emacs-packages-i-like/">Original</a>
    <h1>Emacs packages I like</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      

<p><strong>July 29, 2024</strong> on <a href="https://lucymcphail.com/posts/">Lucy McPhail&#39;s blog</a></p>
<p>During the time I’ve been using Emacs, a handful of packages have stood out to me as being particularly useful, reliable, and generally enjoyable to use. A few of them in particular, I like enough to write about :)</p>

<p>One of the first things I see when I start a new Emacs session is my colour theme, so we may as well start there. My theme of choice has been one of Protesilaos Stavrou’s <a rel="noopener" target="_blank" href="https://protesilaos.com/emacs/modus-themes">Modus themes</a> for almost as long as I’ve been using Emacs, and I’ve yet to find anything else that shares Prot’s attention to detail. The themes are designed with accessible readability in mind, so the contrast between the background and foreground colours is always high. On top of that, variants of both the dark and light themes are included which are optimised for users with red-green or blue-yellow colour deficiency.</p>
<p>Colours alone don’t make an Emacs theme though, and it’s everything else about the Modus themes that really shines. The highlighting is well thought out, with colours being used only where they’re useful; the coverage of third-party packages is great; and there are a staggering number of customisation options. They’re an unapologetically usable set of themes, and I love them for it.</p>

<p>Lots of things in Emacs use the built-in <code>completing-read</code> function to get user input while completing from a list of candidates. The default behaviour is to provide an input field with bash-like tab-completions, but sometimes it’s nicer to show the list of candidates on screen and filter it with a fuzzy finder. Daniel Mendler’s <a rel="noopener" target="_blank" href="https://github.com/minad/vertico">vertico</a>, for ‘VERTical Interactive COmpletion’, adds the first of these features, orderless and adds the second. For example, enabling <code>vertico-mode</code> will turn this:</p>
<pre><code><span>Find file: ~/src/some-project/█
</span></code></pre>
<p>into this:</p>
<pre><code><span>*/7    Find file: ~/src/some-project/█
</span><span>Cargo.lock
</span><span>Cargo.toml
</span><span>LICENSE
</span><span>README.md
</span><span>src/
</span><span>target/
</span><span>.gitignore
</span></code></pre>
<p>where the list of files gets filtered down as you type. The benefit of vertico’s approach, using the <code>completing-read</code> mechanism instead of redefining each function, is that is plays nicely with other parts of Emacs. For example, Omar Antolín Camarena’s <a rel="noopener" target="_blank" href="https://github.com/oantolin/orderless">orderless</a> defines a <em>completion style</em> which tells Emacs how to filter and sort candidates, and vertico will use that ordering with no extra configuration. Orderless is a great companion to vertico, as it sorts completions based on how recently they were last used, and filters them fuzzily based on the input string (for example typing <code>car lo</code> will match <code>Cargo.lock</code>), making vertico act like the fuzzy finders in more modern editors. <a rel="noopener" target="_blank" href="https://github.com/minad/marginalia">Marginalia</a>, another of Daniel’s packages, improves vertico once again by showing extra details beside each candidate where possible: for example, showing file details in the file picker or function docstrings in <code>M-x</code>. For very minimal setup, these three packages vastly improve the completion experience in Emacs.</p>

<p>Emacs’ built-in <code>project</code> package is a neat little feature that works right out of the box, but it’s far too useful not to mention here. It adds a handful of helpful functions for dealing with projects (which it automatically detects by looking for version controlled directories), of which I have a few favourites:</p>
<ul>
<li><code>C-x p p</code>: switch to a different project</li>
<li><code>C-x p f</code>: find files in project</li>
<li><code>C-x p c</code>: run <code>compile</code> in the project root</li>
<li><code>C-x p g</code>: project-wide grep</li>
<li><code>C-x p !</code>: execute a shell command from the project root</li>
</ul>
<p>In particular, <code>C-x p f</code> in combination with vertico is a great fuzzy file finder, similar to Quick Open in Visual Studio Code or <code>fzf</code>/telescope in (neo)vim.</p>
<p>Complementing <code>project</code>, <a rel="noopener" target="_blank" href="https://magit.vc/">Magit</a> is one of the best Git frontends I’ve ever used anywhere, let alone for Emacs. As a testament to just how good it is, its developer, Jonas Bernoulli, started a Kickstarter campaign in 2017 asking for CHF 55 thousand to develop Magit full time for an entire year. He raised almost CHF 73 thousand. As a result, Magit is perhaps the most feature-complete Git frontend beside the Git command-line. It aims to look similar to the output of Git itself, but everything in a Magit buffer is actionable. You can stage and unstage files by pressing <code>s</code> and <code>u</code> in the status window, or rebase onto a particular commit by pressing <code>r</code> with the cursor on that commit in the log. Even if you don’t use Emacs for anything else, I still think Magit is worth a try on its own.</p>

<p>LSP is a relatively new addition to my setup compared to everything else here, since I was content with using keyword completion and tags for the features I needed – that is, until I tried <code>rust-analyzer</code>, and now writing Rust doesn’t feel the same without it. In Emacs, <a rel="noopener" target="_blank" href="https://github.com/emacs-lsp/lsp-mode"><code>lsp-mode</code></a> and <a rel="noopener" target="_blank" href="https://github.com/joaotavora/eglot"><code>eglot</code></a> seem to be the two most popular LSP implementations, the latter of which is included in Emacs 29 onwards. While <code>lsp-mode</code> seems to be the more feature-rich of the two, <code>eglot</code> takes an approach similar to Vertico of being minimal and building on core Emacs features wherever possible. As well as, in my opinion, feeling more responsive than <code>lsp-mode</code>, it also means any configuration you may already have for <code>flymake</code> or <code>completion-at-point-functions</code> will work identically with LSP features. In particular, <a rel="noopener" target="_blank" href="https://github.com/minad/corfu">Corfu</a> (once again from Daniel Mendler) works perfectly with <code>eglot</code> out of the box. I really don’t have much else to say about <code>eglot</code>; it just seems to work whenever needed, and stay out of the way when it isn’t.</p>

<hr/>


    </div></div>
  </body>
</html>
