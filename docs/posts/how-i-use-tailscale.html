<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chameth.com/how-i-use-tailscale/">Original</a>
    <h1>How I use Tailscale</h1>
    
    <div id="readability-page-1" class="page"><div>
          <figure>
            <picture>
              <source srcset="/how-i-use-tailscale/logo.avif" type="image/avif"/>
              <source srcset="/how-i-use-tailscale/logo.webp" type="image/webp"/>
              <img src="https://debamitro.github.io/how-i-use-tailscale/logo.png" alt="The Tailscale logo: a 3x3 grid of dots, with the middle row and bottom middle dot in white, forming a T shape" loading="lazy" width="500" height="494"/>
            </picture>
            <figcaption>The Tailscale logo</figcaption>
          </figure>
          <p>
            I’ve been using <a href="https://tailscale.com/">Tailscale</a> for around four years to connect my disparate
            devices, servers and apps together. I wanted to talk a bit about how I use it, some cool features you might
            not know about, and some stumbling blocks I encountered.
          </p>
          <p>
            I’m not sure Tailscale needs an introduction for the likely audience of this blog, but I’ll give one anyway.
            Tailscale is basically a WireGuard
            orchestration service, with lots of nice features sprinkled on top. It’s a subscription product, but it has
            an insanely generous free tier that covers basically anything you’d ever want to do as an individual. They
            also open source all their client software, and there’s a third party control server implementation called
            <a href="https://github.com/juanfont/headscale">Headscale</a> if you want to avoid the hosted system
            entirely.
          </p>
          <h3>Basic connectivity</h3>
          <p>
            At its core, Tailscale lets you easily connect from one device to another, even if they’re not directly
            exposed to the Internet. You install the Tailscale client wherever you like (on your phone, computer,
            servers, Raspberry Pi, etc), authenticate the machine with the control server, and it can then talk to all
            the other machines on the tailnet using their private Tailscale IP addresses.
          </p>
          <p>
            That isn’t anything revolutionary: it’s the basic premise behind VPNs. But Tailscale makes it so easy. You
            don’t have to bother with any networking configuration. You don’t have to distribute keys. You just install
            the client, and login.
          </p>
          <p>
            For example, my <a href="https://debamitro.github.io/home-automation-without-megacorps/">home automation service</a> runs on a
            Raspberry Pi that sits behind two different routers. I installed Tailscale on it, logged in, and immediately I could SSH into it from my computer or my phone even when they’re on
            different networks.
          </p>
          <p>
            Speaking of SSH, Tailscale has special support for it whereby it handles any incoming connection to port 22
            from the Tailscale network, and deals with authentication itself. No public keys or passwords: if you’re
            logged into Tailscale you can be logged into the machine. This is particularly handy when you SSH from a
            phone, as proper credential management is a bit of a nightmare there.
          </p>
          <p>
            Exposing entire machines is just the start, though. If you run multiple services on the machine you need to
            remember which port they’re all on. Yuck. Instead, you can expose individual services as their own node on a
            tailnet. There are lots of options for doing so: there’s
            <a href="https://tailscale.com/kb/1282/docker">an official Docker image</a>, a
            <a href="https://pkg.go.dev/tailscale.com/tsnet">Go library</a>, and many third-party tools (such as my own
            <a href="https://github.com/csmith/centauri">Centauri</a> and
            <a href="https://github.com/csmith/tsp">tsp</a>).
          </p>
          <h3>Not just a VPN</h3>
          <p>
            Exposing individual services wouldn’t be much use if you still had to remember their IP addresses. For a
            long time I manually added DNS entries for Tailscale nodes, allowing me to connect to
            <code>http://grafana/</code> instead of <code>http://100.73.190.100</code>. Recently I switched to
            Tailscale’s <a href="https://tailscale.com/kb/1081/magicdns">MagicDNS</a>, though, which takes care of that
            for you. Every machine on the tailnet gets an automatic DNS entry based on its name.
          </p>
          <p>
            I initially shied off of this because it changes the DNS resolver on every machine it’s installed on, and it
            all seemed a bit too “magic” for me. I got fed up with manually adding DNS entries though, so I spent a bit of time learning about it and got
            over my knee-jerk “what on earth is going on?!” reaction. The DNS controls also let you force a specific
            upstream DNS server. I use <a href="https://nextdns.io">NextDNS</a> everywhere, so having Tailscale
            automatically configure this for me on all my devices was a bonus.
          </p>
          <p>
            As well as the short names, you can resolve nodes on the tailnet using a slightly longer form:
            <code>machine.your-tailnet.ts.net</code>. The “your-tailnet” bit is randomly generated, and you can reroll
            it in the control panel to find a fun one. But why waste time say lot word, when few word do trick? Because
            Tailscale can make these addresses globally routable, and issue TLS certs for them too.
          </p>
          <p>
            Say you’re developing something on your local machine, and want to get feedback from someone. You can use
            Tailscale’s “funnel” feature to expose it publicly:
          </p>
          <pre><code>tailscale funnel <span>127.0</span>.0.1:8080
</code></pre>
          <p>
            With no other options, this will expose the service over HTTPS on port 443. You can then invite people to
            visit <code>https://machine.your-tailnet.ts.net</code> and they’ll connect through to port 8080 on your
            machine. They don’t even need Tailscale installed. I don’t use this terribly often, but it’s a great
            quality-of-life improvement on the occasions I do want to share something.
          </p>
          <p>
            Tailscale also has a “serve” command, which does much the same but only exposes it over your tailnet. This
            is how you’d use the Tailscale Docker image to expose a normal service onto your tailnet, but it’s also
            useful for similar development scenarios. Occasionally I’ll want to test something on my phone, and rather
            than make sure it’s connected to the right Wi-Fi network, recompiling the app to not bind to localhost,
            figuring out my machine’s IP, and so on, and so forth, I just run <code>tailscale serve</code> and access it
            over Tailscale.
          </p>
          <h3>Authentication, two ways</h3>
          <p>
            One of my minor frustrations with Tailscale was how cumbersome the authentication process was. I logged in
            using GitHub, and every time I tried to login to Tailscale, I had to bounce through the GitHub OAuth flow
            and then select which organisation I wanted to use. Even if I was logged in to GitHub, it still shows the
            permission page every time. It’s not a dealbreaker, but it’s definitely not smooth. This is what it looks
            like:
          </p>
          <figure>
            <picture>
              <source srcset="auth.avif" type="image/avif"/>
              <source srcset="auth.webp" type="image/webp"/>
              <img src="https://debamitro.github.io/blog/making-videos-with-media-recorder/auth.png" alt="Screenshots of the Tailscale/GitHub login flow: (1) The Tailscale login form (2) The GitHub login form (3) GitHub permissions screen (4) Tailscale tailnet selection screen" loading="lazy" width="2000" height="647"/>
            </picture>
            <figcaption>Logging in to Tailscale with a GitHub account</figcaption>
          </figure>
          <p>
            Tailscale have since added the ability to sign in with a custom OIDC provider, so I set up a
            <a href="https://www.keycloak.org/">KeyCloak</a> instance, and my login flow now looks like this:
          </p>
          <figure>
            <picture>
              <source srcset="keycloak.avif" type="image/avif"/>
              <source srcset="keycloak.webp" type="image/webp"/>
              <img src="https://debamitro.github.io/blog/making-videos-with-media-recorder/keycloak.png" alt="Screenshots of the Tailscale/KeyCloak login flow: (1) The Tailscale login form (2) The KeyCloak login form" loading="lazy" width="1145" height="647"/>
            </picture>
            <figcaption>Logging in to Tailscale with KeyCloak as an OIDC provider</figcaption>
          </figure>
          <p>
            It’s a significantly shorter flow, and because KeyCloak is entirely under my control I can configure how
            long I stay logged in for. It also reduces my reliance on third parties: if GitHub goes down, or decides to
            ban my account or something, I can still
            access Tailscale.
          </p>
          <p>
            That’s how you log in to Tailscale, but Tailscale can also assist with logging in to other services. If you
            connect to a HTTP service over Tailscale, it will add in the following headers:
          </p>
          <pre><code>


</code></pre>
          <p>
            A lot of software has support for accepting login credentials provided by a reverse proxy, which is
            basically what’s happening here. For example, I run a Grafana instance that’s only exposed over Tailscale.
            Its config (set in environment variables) is:
          </p>
          <pre><code><span>GF_USERS_AUTO_ASSIGN_ORG</span><span>:</span> <span>&#34;true&#34;</span>
<span>GF_USERS_AUTO_ASSIGN_ORG_ROLE</span><span>:</span> <span>&#34;Admin&#34;</span>
<span>GF_AUTH_PROXY_ENABLED</span><span>:</span> <span>&#34;true&#34;</span>
<span>GF_AUTH_PROXY_HEADER_NAME</span><span>:</span> <span>&#34;Tailscale-User-Login&#34;</span>
<span>GF_AUTH_PROXY_HEADER_PROPERTY</span><span>:</span> <span>&#34;email&#34;</span>
<span>GF_AUTH_PROXY_AUTO_SIGN_UP</span><span>:</span> <span>&#34;true&#34;</span>
</code></pre>
          <p>
            So anyone who presents a <code>Tailscale-User-Login</code> header gets an admin account created with that as
            their e-mail address. It’s super convenient, but obviously make sure it’s <em>only</em> exposed via
            Tailscale if you do that!
          </p>
          <p>
            Other services I run that support this include
            <a href="https://miniflux.app/docs/configuration.html#auth-proxy-header">Miniflux</a> (an RSS reader),
            <a href="https://bayang.github.io/jelu-web/configuration/#configuring-proxy-authentication">Jelu</a> (a book
            tracker), <a href="https://linkding.link/options/#ld_enable_auth_proxy">Linkding</a> (a bookmark manager),
            and <a href="https://manual.seafile.com/latest/config/remote_user/">Seafile</a> (a file storage system). If
            you’re hosting something yourself, look out for “proxy auth” or “remote users” in the documentation or
            configuration. It’s amazingly convenient to be able to access things without entering credentials.
          </p>
          <h3>ACLs, tags and mistakes</h3>
          <p>
            For a long time I didn’t bother with any kind of ACLs within my Tailscale network. Every machine could
            access every other machine. Then one day a thought hit me. The default Tailscale SSH config re-prompts you
            for user authentication, but I’d disabled that by tweaking the config… That means anyone with access to any
            of my machines (or who managed to get Tailscale credentials out of one of my apps) would be able to SSH into
            anywhere else on my network. Even as root! Compromising a small bit of my network would immediately lead to
            a complete take-over. What’s the point in defence-in-depth if you roll out a red carpet over the drawbridge
            for any attackers?
          </p>
          <p>
            The first and most obvious fix for this was to restrict root access over SSH. I changed my Tailscale ACL to
            prompt for reauthentication for root access, but still allow regular SSH unprompted:
          </p>
          <pre><code><span>{</span>
  <span>&#34;ssh&#34;</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>&#34;action&#34;</span><span>:</span> <span>&#34;accept&#34;</span><span>,</span>
      <span>&#34;src&#34;</span><span>:</span>    <span>[</span><span>&#34;autogroup:member&#34;</span><span>]</span><span>,</span>
      <span>&#34;dst&#34;</span><span>:</span>    <span>[</span><span>&#34;autogroup:self&#34;</span><span>]</span><span>,</span>
      <span>&#34;users&#34;</span><span>:</span>  <span>[</span><span>&#34;autogroup:nonroot&#34;</span><span>]</span><span>,</span>
    <span>}</span><span>,</span>
    <span>{</span>
      <span>&#34;action&#34;</span><span>:</span> <span>&#34;check&#34;</span><span>,</span>
      <span>&#34;src&#34;</span><span>:</span>    <span>[</span><span>&#34;autogroup:member&#34;</span><span>]</span><span>,</span>
      <span>&#34;dst&#34;</span><span>:</span>    <span>[</span><span>&#34;autogroup:self&#34;</span><span>]</span><span>,</span>
      <span>&#34;users&#34;</span><span>:</span>  <span>[</span><span>&#34;root&#34;</span><span>]</span><span>,</span>
    <span>}</span><span>,</span>
  <span>]</span><span>,</span>
<span>}</span>
</code></pre>
          <p>
            This still didn’t sit right with me, though. Why should a random webserver be able to (theoretically) SSH
            into my desktop computer unchallenged? Tailscale allows you to do more advanced ACLs by applying tags to
            devices. I dutifully created a bunch of tags, and went through and tagged every device: <code>user</code>,
            <code>server</code>, <code>app</code>, <code>container</code>, and so on. This, it turns out, was a mistake.
            I could no longer SSH to anywhere. If I’d read the docs properly, I might have noticed how they describe
            tags:
          </p>
          <blockquote>
            <p>
              Tailscale tags are how you authenticate and identify non-user devices, such as servers and ephemeral
              nodes. They serve two primary purposes: to provide an identity to non-user devices and to let you manage
              access control policies based on purpose.
            </p>
          </blockquote>
          <p>
            By applying a nice <code>user</code> tag to all of my devices (computer, phone, tablet and so on), I’d
            effectively removed my own identity from them. They no longer counted for the
            <code>autogroup:member</code> source in the SSH config. Whoops. And it’s not easy to fix either:
          </p>
          <blockquote>
            <p>
              You cannot remove all tags from a device. A device with a tag-based identity must have at least one tag.
            </p>
          </blockquote>
          <p>
            So I’d have to remove all the affected devices, then re-add them. At the time I wanted to roll back
            <em>all</em> the tags, which would mean reconnecting dozens of nodes to the Tailnet. I did end up doing
            that, but I also took it as an opportunity to switch to KeyCloak as I mentioned earlier. Setting everything
            up again was a bit less painful when it wasn’t just correcting a dumb mistake.
          </p>
          <p>
            I now have a much more sensible tag setup: servers are tagged <code>server</code>, apps are tagged
            <code>app</code>, and a few special apps are tagged <code>integration</code>. I then use Tailscale’s grants
            to limit access within the tailnet:
          </p>
          <pre><code><span>{</span>
  <span>&#34;grants&#34;</span><span>:</span> <span>[</span>
    <span>{</span>
      
      <span>&#34;src&#34;</span><span>:</span> <span>[</span><span>&#34;autogroup:member&#34;</span><span>]</span><span>,</span>
      <span>&#34;dst&#34;</span><span>:</span> <span>[</span><span>&#34;*&#34;</span><span>]</span><span>,</span>
      <span>&#34;ip&#34;</span><span>:</span>  <span>[</span><span>&#34;*&#34;</span><span>]</span><span>,</span>
    <span>}</span><span>,</span>
    <span>{</span>
      
      <span>&#34;src&#34;</span><span>:</span> <span>[</span><span>&#34;tag:server&#34;</span><span>,</span> <span>&#34;tag:integration&#34;</span><span>]</span><span>,</span>
      <span>&#34;dst&#34;</span><span>:</span> <span>[</span><span>&#34;tag:integration&#34;</span><span>,</span> <span>&#34;tag:app&#34;</span><span>]</span><span>,</span>
      <span>&#34;ip&#34;</span><span>:</span>  <span>[</span><span>&#34;*&#34;</span><span>]</span><span>,</span>
    <span>}</span><span>,</span>
  <span>]</span><span>,</span>
<span>}</span>
</code></pre>
          <p>
            This stops anyone but a user device from accessing servers, and stops plain apps from accessing anything at
            all. So for example my Grafana instance is tagged as an <code>app</code>; it doesn’t connect out over
            Tailscale for anything, it only exposes its interface over Tailscale. My home automation software is tagged
            as an <code>integration</code>, as it reaches out to other services over Tailscale (e.g., to push metrics it
            receives from devices).
          </p>
          <p>
            You could go even further and limit which specific machines talk to which others, but I think this tier
            system sets reasonable boundaries for my use without getting too much in the way.
          </p>
          <h3>Even more</h3>
          <p>
            There are lots of other cool features offered by Tailscale that I’ve not covered: exit nodes (allowing you
            to route normal Internet traffic over Tailscale; very handy when you’re behind a router you don’t trust, or
            if you want to appear as being in another country for totally legitimate reasons); Tailscale lock (a system
            where existing nodes have to verify any new ones, guarding against both unauthorised access and Tailscale
            themselves inserting nodes into your network); file sharing, and more I’ve probably forgotten.
          </p>
          <p>
            As I mentioned before, an awful lot is available on the free personal plan. It’s definitely worth checking
            out if you manage servers, or self-host anything. I can’t imagine going back to managing servers and private
            apps without Tailscale, and I’m excited to see what else they do going forward.
          </p>
          
          
        </div></div>
  </body>
</html>
