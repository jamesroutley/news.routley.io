<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery-part-2/">Original</a>
    <h1>A One-Part Serialized Mystery, Part 2: The Benchmarks</h1>
    
    <div id="readability-page-1" class="page"><section>
            
<p>I <a href="https://frantic.im/rnd/one-part-serialized-mystery">wrote recently</a> about switching the types of the primary keys in
the database for an <a href="https://gitlab.com/nebkor/ww">in-progress web app</a> I&#39;m building. At that time,
I&#39;d not yet done any benchmarking, but had reason to believe that using <a href="https://github.com/ulid/spec">sortable primary
keys</a> would yield some possibly-significant gains in performance, in
both time and space. I&#39;d also read accounts of regret that databases had not used ULIDs (instead of
<a href="https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)">UUIDs</a>) from the
get-go, so I decided it couldn&#39;t hurt to switch to them before I had any actual data in my DB.</p>
<p>And that was correct: it didn&#39;t hurt performance, but it also didn&#39;t help much either. I&#39;ve spent a
bunch of time now doing comparative benchmarks between ULIDs and UUIDs, and as I explain below, the
anticipated space savings did not materialize, and the initial speed-ups I got were merely
augmenting what was already more than fast enough into slightly more fasterer than that. Of course,
of course, and as always, the real treasure was the friends we made along the way etc., etc. So come
along on a brief journey of discovery!</p>

<p>ULIDs have a slight edge over UUIDv4s when used as primary keys, but the best primany keys are
simple integers if you can get away with it. With my final DB schema and import/benchmarking code,
there was no difference in terms of time taken or space used when using ULIDs vs UUIDs as primary
keys.</p>
<p>However, with my initial database layout and import code, ULIDs resulted in about 5% less space and
took only about 2/3rds as much time as when using UUIDs (5.7 vs 9.8 seconds). The same space and
time results held whether or not <a href="https://www.sqlite.org/withoutrowid.html"><code>without rowid</code></a> was
specified on table creation, which was counter to expectation, though I now understand why; I&#39;ll
explain at the end.</p>

<p>My benchmark is pretty simple: starting from an empty database, do the following things:</p>
<ol>
<li>insert 10,000 randomly chosen movies (title and year of release, from between 1965 and 2023) into
the database</li>
<li>create 1,000 random users</li>
<li>for each user, randomly select around 100 movies from the 10,000 available and put them on their list of
things to watch</li>
</ol>
<p>Only that last part is significant, and is where I got my <a href="https://gitlab.com/nebkor/ww/-/blob/897fd993ceaf9c77433d44f8d68009eb466ac3aa/src/bin/import_users.rs#L47-58">timing
information</a>
from.</p>
<p>The table that keeps track of what users want to watch was defined like this:</p>
<pre data-lang="sql"><code data-lang="sql"><span>create table </span><span>if not exists </span><span>witch_watch</span><span> (
</span><span>  id blob not </span><span>null </span><span>primary key</span><span>,
</span><span>  witch blob not </span><span>null</span><span>, </span><span>-- &#34;user&#34;
</span><span>  watch blob not </span><span>null</span><span>, </span><span>-- &#34;thing to watch&#34;
</span><span>  [...]
</span><span>  </span><span>foreign key</span><span> (witch) </span><span>references</span><span> witches (id) </span><span>on delete cascade on update</span><span> no action,
</span><span>  </span><span>foreign key</span><span> (watch) </span><span>references</span><span> watches (id) </span><span>on delete cascade on update</span><span> no action
</span><span>);
</span><span>[...]
</span><span>create index </span><span>if not exists ww_witch_dex on </span><span>witch_watch</span><span> (witch);
</span><span>create index </span><span>if not exists ww_watch_dex on </span><span>witch_watch</span><span> (watch);
</span></code></pre>
<p>The kind of queries I&#39;m trying to optimize with those indices is &#34;what movies does a certain user
want to watch?&#34; and &#34;what users want to watch a certain movie?&#34;. The IDs are 16-byte blobs; an
entire row in the table is less than 100 bytes.</p>
<h2 id="a-digression-on-sqlite-and-performance">A digression on SQLite and performance</h2>
<p>I&#39;ve mentioned once or twice before that I&#39;m using <a href="https://www.sqlite.org/index.html">SQLite</a> for
this project. Any time I need a database, my first reach is for SQLite:</p>
<ul>
<li>the database is a single file, along with a couple temp files that live alongside it, simplifying
management</li>
<li>there&#39;s no network involved between the client and the database; a connection to the database is
a pointer to an object that lives in the same process as the host program; this means that read
queries return data back in just a <a href="https://www.youtube.com/watch?v=qPfAQY_RahA">few
<em>microseconds</em></a></li>
<li>it scales vertically extremely well; it can handle database sizes of many terabytes</li>
<li>it&#39;s one of the most widely-installed pieces of software in the world; there&#39;s at least one
sqlite database on every smartphone, and there&#39;s a robust ecosystem of <a href="https://litestream.io/">useful
extensions</a> and other bits of complimentary code freely available</li>
</ul>
<p>And, it&#39;s extremely performant. When using the <a href="https://www.sqlite.org/wal.html">WAL journal mode</a>
and the <a href="https://www.sqlite.org/pragma.html#pragma_synchronous">recommended durability setting</a> for
WAL mode, along with all other production-appropriate settings, I got almost 20,000 <em>writes</em> per
second. There were multiple concurrent writers, and each write was a
transaction that inserted about 100 rows at a time. I had <a href="https://gitlab.com/nebkor/ww/-/blob/4c44aa12b081c777c82192755ac85d1fe0f5bdca/src/bin/import_users.rs#L143-145">retry
logic</a>
in case a transaction failed due to the DB being locked by another writer, but that never happened:
each write was just too fast.</p>

<p>The reason I had hoped that ULIDs would help with keeping the sizes of the indexes down was the
possibility of using <a href="https://www.sqlite.org/withoutrowid.html#benefits_of_without_rowid_tables">clustered
indexes</a>. To paraphrase
that link:</p>
<blockquote>
<p>In an ordinary SQLite table, the PRIMARY KEY is really just a UNIQUE index. The key used to look
up records on disk is the rowid. [...]any other kind of PRIMARY KEYs, including &#34;INT PRIMARY KEY&#34;
are just unique indexes in an ordinary rowid table.</p>
<p>...</p>
<p>Consider querying this table to find the number of occurrences of the word &#34;xsync&#34;.:
SELECT cnt FROM wordcount WHERE word=&#39;xsync&#39;;</p>
<p>This query first has to search the index B-Tree looking for any entry that contains the matching
value for &#34;word&#34;. When an entry is found in the index, the rowid is extracted and used to search
the main table. Then the &#34;cnt&#34; value is read out of the main table and returned. Hence, two
separate binary searches are required to fulfill the request.</p>
<p>A WITHOUT ROWID table uses a different data design for the equivalent table. [in those tables],
there is only a single B-Tree...  Because there is only a single B-Tree, the text of the &#34;word&#34;
column is only stored once in the database. Furthermore, querying the &#34;cnt&#34; value for a specific
&#34;word&#34; only involves a single binary search into the main B-Tree, since the &#34;cnt&#34; value can be
retrieved directly from the record found by that first search and without the need to do a second
binary search on the rowid.</p>
<p>Thus, in some cases, a WITHOUT ROWID table can use about half the amount of disk space and can
operate nearly twice as fast. Of course, in a real-world schema, there will typically be secondary
indices and/or UNIQUE constraints, and the situation is more complicated. But even then, there can
often be space and performance advantages to using WITHOUT ROWID on tables that have non-integer
or composite PRIMARY KEYs.</p>
</blockquote>
<p>sorry what was that about secondary indices i didn&#39;t quite catch that</p>
<p>HALF the disk space, <em>and</em> TWICE as fast?? Yes, sign me up, please!</p>
<h2 id="sorry-the-best-i-can-do-is-all-the-disk-space">Sorry, the best I can do is all the disk space</h2>
<p>There are some <a href="https://www.sqlite.org/withoutrowid.html#when_to_use_without_rowid">guidelines</a>
about when to use <code>without rowid</code>:</p>
<blockquote>
<p>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or
composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</p>
<p>[...]</p>
<p>WITHOUT ROWID tables work best when individual rows are not too large. A good rule-of-thumb is
that the average size of a single row in a WITHOUT ROWID table should be less than about 1/20th
the size of a database page. That means that rows should not contain more than ... about 200 bytes
each for 4KiB page size.</p>
</blockquote>
<p>As I mentioned, each row in that table was less than 100 bytes, so comfortably within the given
heuristic. In order to test this out, all I had to do was change the table creation statement to:</p>
<pre data-lang="sql"><code data-lang="sql"><span>create table </span><span>if not exists </span><span>witch_watch</span><span> (
</span><span>  id blob not </span><span>null </span><span>primary key</span><span>,
</span><span>  witch blob not </span><span>null</span><span>, </span><span>-- &#34;user&#34;
</span><span>  watch blob not </span><span>null</span><span>, </span><span>-- &#34;thing to watch&#34;
</span><span>  [...]
</span><span>  </span><span>foreign key</span><span> (witch) </span><span>references</span><span> witches (id) </span><span>on delete cascade on update</span><span> no action,
</span><span>  </span><span>foreign key</span><span> (watch) </span><span>references</span><span> watches (id) </span><span>on delete cascade on update</span><span> no action
</span><span>) without rowid;
</span></code></pre>
<p>So I did.</p>
<p>Imagine my surprise when it took nearly 20% longer to run, and the total size on disk was nearly 5%
larger. Using random UUIDs was even slower, so there&#39;s still a relative speed win for ULIDs, but it
was still an overall loss to go without the rowid. Maybe it was time to think outside the box?</p>
<h2 id="schema-husbandry">Schema husbandry</h2>
<p>I had several goals with this whole benchmarking endeavor. One, of course, was to get performance
data on ULIDs vs. UUIDs, at the very least so that I could write about it when I publicly had said I
would. But another, and actually-more-important goal, was to optimize the design of my database and
software, especially as it came to size on disk (my most-potentially-scarce computing resource;
network and CPU are not problems until you get <em>very</em> large, and you would have long ago
bottlenecked on storage if you weren&#39;t careful).</p>
<p>So it was Cool and Fine to take advantage of the new capabilities that ULIDs offered if those new
capabilities resulted in better resource use. Every table in my original, UUID-based schema had had
a <code>created_at</code> column, stored as a 64-bit signed offset from the <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX
epoch</a>. Because ULIDs encode their creation time, I could
remove that column from every table that used ULIDs as their primary key. <a href="https://gitlab.com/nebkor/ww/-/commit/5782651aa691125f11a80e241f14c681dda7a7c1">Doing
so</a> dropped the
overall DB size by 5-10% compared to UUID-based tables with a <code>created_at</code> column. This advantage
was unique to ULIDs as opposed to UUIDv4s, and so using the latter with a schema that excludude a
&#34;created at&#34; column was giving an unrealistic edge to UUIDs, but for my benchmarks, I was interested
in isolating their effect on index sizes, so it was OK.</p>
<p>I also realized that for the <code>watch_quests</code> table, no explicit ID needed to be added; there were
already two <code>UNIQUE</code> constraints for each row, that would together uniquely identify that row: the
ID of the user that wanted to watch something, and the ID of the thing they wanted to watch. Primary
keys don&#39;t need to be a single column; when two or more columns in a table are used as a primary
key, it&#39;s called a &#34;composite key&#34;. You may recall from the &#34;when should you use <code>without rowid</code>&#34;
section that composite keys were one such situation where it may be beneficial. Surely this would
help!</p>
<pre data-lang="sql"><code data-lang="sql"><span>create table </span><span>if not exists </span><span>witch_watch</span><span> (
</span><span>  witch blob not </span><span>null</span><span>,
</span><span>  watch blob not </span><span>null</span><span>,
</span><span>  [...]
</span><span>  </span><span>primary key</span><span> (witch, watch)
</span><span>) without rowid;
</span></code></pre>
<p>&#34;witch&#34; and &#34;watch&#34; are still foreign keys</p>
<p>And, it did, a little. I also took a more critical eye to that table as a whole, and realized I
could <a href="https://gitlab.com/nebkor/ww/-/commit/0e016552ab6c66d5fdd82704b6277bd857c94188?view=parallel#f1043d50a0244c34e4d056fe96659145d03b549b_34_34">tidy up the
DB</a>
a little more, and remove one more redundant field; this helped a little bit, too.</p>
<p>But overall, things were still looking like ULIDs had no real inherent advantage over UUIDs in the
context of clustered indexes, given the schema I was using, when it came to disk space. For sure,
ULIDs continued to enjoy an advantage in insertion speed, but as I tightened up my code for
inserting these values for this benchmark, the marginal advantage there kept shrinking. Ultimately,
this advantage completely shrank as I made the schema and code more optimal, but that&#39;s getting
slightly ahead of things. I had to this point achieved almost the final form, but one more change
had to be made.</p>

<p>In the course of writing this post, I had a minor epiphany, which is that the reason for the
regressed performance when using <code>without rowid</code> was that the secondary indices needed to point to
the entries in the table, using the primary key of the table as the target. So when there was a ULID
or UUID primary key, the indexes looked like, eg, this:</p>
<pre data-lang="text"><code data-lang="text"><span>16-byte blob -&gt; 16-byte blob
</span></code></pre>
<p>left side is a user id or watch id, and right side is the id of a row in the
quests table</p>
<p>But, in the case that there was a <code>rowid</code> primary key in the <code>watch_quest</code> table, the index entries for,
eg, <code>user</code> to &#34;watch quest&#34; would look like:</p>
<pre data-lang="text"><code data-lang="text"><span>16-byte blob -&gt; 8-byte number (rowid)
</span></code></pre>
<p>The astute among you may note that 8 is only half of 16, and if you recall that there are two
secondary indexes that look like that, the total number of secondary index bytes is 64 in the
<code>without rowid</code> case, and only 48 in the case that there is a rowid.</p>
<p>There&#39;s also a bit of cautious wisdom about performance implications of the implementation that
backs the <code>without rowid</code> tables:</p>
<blockquote>
<p>WITHOUT ROWID tables are implemented using ordinary B-Trees with content stored on both leaves and
intermediate nodes. Storing content in intermediate nodes causes each intermediate node entry to
take up more space on the page and thus reduces the fan-out, increasing the search cost.</p>
</blockquote>
<p>the fan-out when using <code>without rowid</code> was about 20% lower than when using the rowids, and it seems
like this was slowing things down.</p>
<p>Thinking on it some more, there&#39;s really no real reason to give this table a distinct and robust
identity for its rows; the real identity is carried by its combination of <code>(user, watch)</code> columns,
but even then, the value of distinct identity for these rows is low. If that&#39;s the case, which it
is, then why give it an explicit primary key at all? The program and the users don&#39;t need to worry
about the primary key for that table. It would also eliminate an entire index (an
automatically-generated &#34;primary key to rowid&#34; index), resulting in the ultimate space savings.</p>
<p>So, <a href="https://gitlab.com/nebkor/ww/-/commit/2c7990ff09106fa2a9ec30974bbc377b44082082">that&#39;s what I
did</a>:</p>
<pre data-lang="sql"><code data-lang="sql"><span>-- table of what people want to watch
</span><span>create table </span><span>if not exists </span><span>watch_quests</span><span> (
</span><span>  user blob not </span><span>null</span><span>,
</span><span>  watch blob not </span><span>null</span><span>,
</span><span>  priority </span><span>int</span><span>, </span><span>-- 1-5 how much do you want to watch it
</span><span>  public </span><span>boolean </span><span>not </span><span>null </span><span>default </span><span>true</span><span>,
</span><span>  watched </span><span>boolean </span><span>not </span><span>null </span><span>default </span><span>false</span><span>,
</span><span>  when_watched </span><span>int</span><span>,
</span><span>  created_at </span><span>int </span><span>not </span><span>null </span><span>default</span><span> (unixepoch()),
</span><span>  last_updated </span><span>int </span><span>not </span><span>null </span><span>default</span><span> (unixepoch()),
</span><span>  </span><span>foreign key</span><span> (user) </span><span>references</span><span> users (id) </span><span>on delete cascade on update</span><span> no action,
</span><span>  </span><span>foreign key</span><span> (watch) </span><span>references</span><span> watches (id) </span><span>on delete cascade on update</span><span> no action
</span><span>);
</span><span>
</span><span>create index </span><span>if not exists quests_user_dex on </span><span>watch_quests</span><span> (user);
</span><span>create index </span><span>if not exists quests_watch_dex on </span><span>watch_quests</span><span> (watch);
</span></code></pre>
<p>There&#39;s the full and final schema.</p>
<p>In the default benchmark, with 1,000 users each saving about 100 things to watch, that schema change
dropped the total size on disk about 25% (from 17 megabytes to 13), and the percentage of the total
database consumed by the indexes of the <code>watch_quests</code> table went from 51% to 43% (that means the
indexes went from being about 8.6MB to 5.6MB, 35% less than when using a composite primary key).</p>
<pre data-lang="text"><code data-lang="text"><span>*** Indices of table WATCH_QUESTS *********************************************
</span><span>
</span><span>Percentage of total database......................  43.3%
</span><span>Average fanout.................................... 106.00
</span></code></pre>
<p>It also dropped the total time to insert the 100k records from &gt;6 seconds to just 5; I ran the
benchmark multiple times and got the same results, then tried running it with 2,000 users saving 200
movies (4x the previous benchmark), and the results held uncannily:</p>
<pre data-lang="text"><code data-lang="text"><span>$ cargo run --release --bin import_users -- -d ~/movies.db -u 2000 -m 200
</span><span>[...]
</span><span>Added 398119 quests in 20.818506 seconds
</span></code></pre>
<p>20k writes/second, baby</p>
<p>Just for kicks, I tried it with UUID-based IDs, and the time and space characteristics were finally
completely indistinguishable. This pleased me; real-world perf with ULIDs would be better than with
UUIDs with a production schema that included <code>created_at</code> columns, and UUIDs would obligate columns
like that if you wanted to keep track of, you know, when things were created. Ironically, by moving
to implicit integer rowid primary keys for the <code>watch_quests</code> table, I had to make sure that there
was a <code>created_at</code> column for it. Still a win, though!</p>
<h2 id="next-steps-with-ids">Next steps with IDs</h2>
<p>This project is supposed to be more than just a testbed for learning about databases and web
frameworks and sortable unique identifiers; it&#39;s supposed to be an actual thing that my wife and I
can use for ourselves and with our friends. I even made a snazzy logo!</p>
<p><img src="https://proclamations.nebcorp-hias.com/rnd/one-part-serialized-mystery-part-2/./what2watch_logo.png" alt="what to watch" title="what to watch logo; an eyeball filled with static, and with a red iris, looking down at you"/></p>
<p>The gods, it seems, have other plans.</p>
<p>Namely, it bothers me that ID generation is not done inside the database itself. Aside from being a
generally bad idea, this lead to at least one frustrating debug session where I was inserting one ID
but reporting back another. SQLite doesn&#39;t have native support for this, but it does have good
native support for <a href="https://www.sqlite.org/loadext.html">loading shared libraries as plugins</a> in
order to add functionality to it, and so my next step is to write one of those, and remove the ID
generation logic from the application.</p>
<p>Doing so would also allow me to address an underlying error in the way the application generates
them. The <a href="https://github.com/ulid/spec">ULID spec</a> contains the following note about IDs generated
within the same millisecond:</p>
<blockquote>
<p>When generating a ULID within the same millisecond, we can provide some guarantees regarding sort
order. Namely, if the same millisecond is detected, the random component is incremented by 1 bit
in the least significant bit position (with carrying).</p>
</blockquote>
<p>I don&#39;t do that, because doing so requires a single ID factory, and I don&#39;t want to
have to thread that through the web app backend code. On the other hand, I <em>do</em> want to have a
single ID factory inside the database, which an extension plugin would provide.</p>
<p>Then I&#39;ll get back to the web app.</p>

<p>OK, well, here we are, at the end of yet another three-thousand-word meeting that could have been an
email; sorry about that, and thanks for sticking with it until the end! As usual, it was hard to not
just keep adding more commentary and footnotes and explication, and I give myself a &#39;C+&#39; there, at
best.  At least there are only four footnotes.</p>
<p>Still, I read and watched a lot of different things in the course of doing this work. Obviously the
SQLite project was critical, and every time I need to consult their documentation, I appreciate it
more (aside from the software itself, of course!). Towards the end of the this work, right as I was
starting to write this post, I discovered this <a href="https://www.youtube.com/playlist?list=PLWENznQwkAoxww-cDEfIJ-uuPDfFwbeiJ">series of
videos</a> about SQLite, from
<a href="https://github.com/mycelial">Mycelial</a>, who are &#34;a maker of local-first software development
libraries&#34;. I&#39;m a huge fan of <a href="https://www.inkandswitch.com/local-first/">local-first software</a>, and
one of the reasons I initially chose SQLite was for its suitability for that paradigm. Thank you,
SQLite and Mycelial!</p>
<p>Good bye :)</p>
<hr/>





        </section></div>
  </body>
</html>
