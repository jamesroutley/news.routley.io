<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dubroy.com/blog/garbage-collection-is-useful/">Original</a>
    <h1>devlog: garbage collection is useful</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
		<div>
			
			<p><small>November 14, 2025
            </small></p><p>A long time ago, I spent a few years working on garbage collection in the J9 Java VM. And even though I’ve since done mostly done higher-level stuff, having a deeper knowledge of GC has continued to come in useful.</p>
<p>Yesterday, it was an insight from one of my favourite GC papers, <a href="https://web.eecs.umich.edu/~weimerw/2012-4610/reading/bacon-garbage.pdf">A Unified Theory of Garbage Collection</a>, which helped me solve a tricky problem.</p>
<h2>ohm’s incremental parsing</h2>
<p>I’m working with a team that’s using <a href="https://ohmjs.org">Ohm</a> to parse text documents and render a rich text version in <a href="https://prosemirror.net">ProseMirror</a>. The goal is bidirectional updates: changes in ProseMirror should propagate to the text version, and vice versa.</p>
<p>Ohm supports incremental parsing, which means that if you parse some text and then make a small edit, it can quickly reparse by reusing portions of the previous result.</p>
<p>It also supports limited form of incremental transforms. You can define an <em>attribute</em>, which is kind of like a memoized visitor, and the attribute value for a given node will only need to be recalculated if the edit affected one of its subtrees. So you can easily implement a form of persistent data structure, where each new value (e.g., an AST) shares a bunch of structure with the previous one.</p>
<h2>the problem</h2>
<p>Using this machinery, I tried making an <code>pmNodes</code> attribute that produced a ProseMirror document for a given input. When the text document is edited, it produces a new tree which shares a bunch of nodes with the previous one.</p>
<figure>
    <img src="https://dubroy.com/blog/images/prosemirror-gc.png"/>
    <figcaption>The `pmNodes` tree before and after an edit.</figcaption>
</figure>

<p>Then, my plan was to construct a ProseMirror transaction that would turn the old tree into the new one. To do that, it’s helpful to know which nodes appeared in the old document, but not the new one.</p>
<p>My first implementation of this was equivalent to tracing garbage collection — after each edit, I walked the entire document, and recorded all the nodes in a Set. The difference between the sets told me which nodes had died.</p>
<p>But this kind of defeats the purpose of incrementality — if you have a long document and make a small edit, we should be able to process <em>without</em> visiting every node in the document.</p>
<h2>the solution</h2>
<p>Then I remembered <a href="https://web.eecs.umich.edu/~weimerw/2012-4610/reading/bacon-garbage.pdf">A Unified Theory of Garbage Collection</a>, a 2004 OOPSLA paper by some former colleagues of mine:</p>
<blockquote>
<p>Tracing and reference counting are uniformly viewed as being fundamentally different approaches to garbage collection that possess very distinct performance properties. We have implemented highperformance collectors of both types, and in the process observed that the more we optimized them, the more similarly they behaved — that they seem to share some deep structure.</p>
<p>We present a formulation of the two algorithms that shows that they are in fact duals of each other. Intuitively, the difference is that tracing operates on live objects, or “matter”, while reference counting operates on dead objects, or “anti-matter”. For every operation performed by the tracing collector, there is a precisely corresponding anti-operation performed by the reference counting collector.</p>
</blockquote>
<p>This was the answer I needed! Rather than visiting all the live objects, I wanted to only visit the dead ones, and reference counting would let me do that.</p>
<p>So I added a way of maintaining a reference count for all the nodes in the doc. When we produce a new document, we decrement the reference count of the old root node (it will always be 0 afterwards). So we recursively decrement the ref count of its children, and so on. This gives me exactly what I wanted — a way to find all the nodes that were <em>not</em> reused, without having to visit most of the nodes in the doc.</p>
		</div>	</div></div>
  </body>
</html>
