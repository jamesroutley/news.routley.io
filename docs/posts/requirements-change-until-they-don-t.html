<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/requirements-change-until-they-dont/">Original</a>
    <h1>Requirements change until they don&#39;t</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                April 24, 2025
                
                
            </date>
            

            

            
            <h2>
                Requirements, phase changes, and formal methods.
            </h2>
            

            

            
            
            <p>Recently I got a question on formal methods<sup id="fnref:fs"><a href="#fn:fs">1</a></sup>: how does it help to mathematically model systems when the system requirements are constantly changing? It doesn&#39;t make sense to spend a lot of time proving a design works, and then deliver the product and find out it&#39;s not at all what the client needs. As the saying goes, the hard part is &#34;building the right thing&#34;, not &#34;building the thing right&#34;.</p>
<p>One possible response: &#34;why write tests&#34;? You shouldn&#39;t write tests, <em>especially</em> <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank">lots of unit tests ahead of time</a>, if you might just throw them all away when the requirements change.</p>
<p>This is a bad response because we all know the difference between writing tests and formal methods: testing is <em>easy</em> and FM is <em>hard</em>. Testing requires low cost for moderate correctness, FM requires high(ish) cost for high correctness. And when requirements are constantly changing, &#34;high(ish) cost&#34; isn&#39;t affordable and &#34;high correctness&#34; isn&#39;t worthwhile, because a kinda-okay solution that solves a customer&#39;s problem is infinitely better than a solid solution that doesn&#39;t.</p>
<p>But eventually you get something that solves the problem, and what then?</p>
<p>Most of us don&#39;t work for Google, we can&#39;t axe features and products <a href="https://killedbygoogle.com/" target="_blank">on a whim</a>. If the client is happy with your solution, you are expected to support it. It should work when your customers run into new edge cases, or migrate all their computers to the next OS version, or expand into a market with shoddy internet. It should work when 10x as many customers are using 10x as many features. It should work when <a href="https://www.hillelwayne.com/post/feature-interaction/" target="_blank">you add new features that come into conflict</a>. </p>
<p>And just as importantly, <em>it should never stop solving their problem</em>. Canonical example: your feature involves processing requested tasks synchronously. At scale, this doesn&#39;t work, so to improve latency you make it asynchronous. Now it&#39;s eventually consistent, but your customers were depending on it being always consistent. Now it no longer does what they need, and has stopped solving their problems.</p>
<p>Every successful requirement met spawns a new requirement: &#34;keep this working&#34;. That requirement is permanent, or close enough to decide our long-term strategy. It takes active investment to keep a feature behaving the same as the world around it changes.</p>
<p>(Is this all a pretentious of way of saying &#34;software maintenance is hard?&#34; Maybe!)</p>
<h3>Phase changes</h3>

<p>In physics there&#39;s a concept of a <a href="https://en.wikipedia.org/wiki/Phase_transition" target="_blank">phase transition</a>. To raise the temperature of a gram of liquid water by 1° C, you have to add 4.184 joules of energy.<sup id="fnref:calorie"><a href="#fn:calorie">2</a></sup> This continues until you raise it to 100°C, then it stops. After you&#39;ve added two <em>thousand</em> joules to that gram, it suddenly turns into steam. The energy of the system changes continuously but the form, or phase, changes discretely.</p>
<p><img alt="Phase_diagram_of_water_simplified.svg.png (from above link)" src="https://assets.buttondown.email/images/31676a33-be6a-4c6d-a96f-425723dcb0d5.png?w=960&amp;fit=max"/></p>

<p>Software isn&#39;t physics but the idea works as a metaphor. A certain architecture handles a certain level of load, and past that you need a new architecture. Or a bunch of similar features are independently hardcoded until the system becomes too messy to understand, you remodel the internals into something unified and extendable. etc etc etc. It&#39;s doesn&#39;t have to be totally discrete phase transition, but there&#39;s definitely a &#34;before&#34; and &#34;after&#34; in the system form. </p>
<p>Phase changes tend to lead to more intricacy/complexity in the system, meaning it&#39;s likely that a phase change will introduce new bugs into existing behaviors. Take the synchronous vs asynchronous case. A very simple toy model of synchronous updates would be <code>Set(key, val)</code>, which updates <code>data[key]</code> to <code>val</code>.<sup id="fnref:tla"><a href="#fn:tla">3</a></sup> A model of asynchronous updates would be <code>AsyncSet(key, val, priority)</code> adds a <code>(key, val, priority, server_time())</code> tuple to a <code>tasks</code> set, and then another process asynchronously pulls a tuple (ordered by highest priority, then earliest time) and calls <code>Set(key, val)</code>. Here are some properties the client may need preserved as a requirement: </p>
<ul>
<li>If <code>AsyncSet(key, val, _, _)</code> is called, then <em>eventually</em> <code>db[key] = val</code> (possibly violated if higher-priority tasks keep coming in)</li>
<li>If someone calls <code>AsyncSet(key1, val1, low)</code> and then <code>AsyncSet(key2, val2, low)</code>, they should see the first update and then the second (linearizability, possibly violated if the requests go to different servers with different clock times)</li>
<li>If someone calls <code>AsyncSet(key, val, _)</code> and <em>immediately</em> reads <code>db[key]</code> they should get <code>val</code> (obviously violated, though the client may accept a <em>slightly</em> weaker property)</li>
</ul>
<p>If the new system doesn&#39;t satisfy an existing customer requirement, it&#39;s prudent to fix the bug <em>before</em> releasing the new system. The customer doesn&#39;t notice or care that your system underwent a phase change. They&#39;ll just see that one day your product solves their problems, and the next day it suddenly doesn&#39;t. </p>
<p>This is one of the most common applications of formal methods. Both of those systems, and every one of those properties, is formally specifiable in a specification language. We can then automatically check that the new system satisfies the existing properties, and from there do things like <a href="https://arxiv.org/abs/2006.00915" target="_blank">automatically generate test suites</a>. This does take a lot of work, so if your requirements are constantly changing, FM may not be worth the investment. But eventually requirements <em>stop</em> changing, and then you&#39;re stuck with them forever. That&#39;s where models shine.</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            





        </div></div>
  </body>
</html>
