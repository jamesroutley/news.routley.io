<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/quote-unquote-macros/">Original</a>
    <h1>Quote-unquote &#34;macros&#34;</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>You’ve probably seen this Python 101 thing before:</p>
<div><pre tabindex="0"><code data-lang="python"><span>@memoized</span>
<span>def</span> <span>fib</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;=</span> <span>1</span><span>:</span>
        <span>return</span> <span>n</span>
    <span>return</span> <span>fib</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fib</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>)</span>
</code></pre></div><p>Leaving aside <a href="https://ianthehenry.com/posts/fibonacci/">the absurdity of computing Fibonacci numbers recursively</a>, it’s a common first introduction to Python <a href="https://docs.python.org/3/glossary.html#term-decorator">decorators</a> and higher-order functions. <code>fib</code> is just a function, and <code>memoized</code> takes that function and returns a <em>new</em> function (or something with a <code>__call__</code> method) that, you know, memoizes the result.</p>
<p>Python’s decorators give us a nice <em>notation</em> for writing this, but we could write the same thing in any dynamic language with first-class functions. Like JavaScript:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>const</span> <span>memoized</span> <span>=</span> <span>(</span><span>f</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>results</span> <span>=</span> <span>new</span> <span>Map</span><span>();</span>
  <span>return</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>results</span><span>.</span><span>has</span><span>(</span><span>x</span><span>))</span> <span>{</span>
      <span>return</span> <span>results</span><span>.</span><span>get</span><span>(</span><span>x</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>const</span> <span>result</span> <span>=</span> <span>f</span><span>(</span><span>x</span><span>);</span>
      <span>results</span><span>.</span><span>set</span><span>(</span><span>x</span><span>,</span> <span>result</span><span>);</span>
      <span>return</span> <span>result</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> <span>fib</span> <span>=</span> <span>(</span><span>n</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>n</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>fib</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fib</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>);</span>
<span>}</span>

<span>fib</span> <span>=</span> <span>memoized</span><span>(</span><span>fib</span><span>);</span>
</code></pre></div><p>And we’ll just gloss over, like, value equality and variadic functions and the memory leak this will cause.</p>
<p>Is this <em>useful?</em> Probably not, but that’s not the point. The point is that it’s a simple concrete example of an abstract idea – higher-order functions, or decorators, or basic metaprogramming. It’s <em>pedantically</em> useful, even if it’s not <em>practically</em> useful.</p>
<p>So now let’s talk about macros.</p>
<p>We could use macros to implement something like Python’s decorators – a better <em>notation</em> for doing something that we can already do without them. And this is great! Within limits, this is great. But that’s not what this blog post is about.</p>
<p>Instead, I want to talk about something that you can’t really do without macros. A new expressive power that macros enable, something more than just notational freedom.</p>
<p>So bear with me for a moment, because I know this is a little silly. But let’s consider the following alternative memoization scheme:</p>
<pre tabindex="0"><code data-lang="janet">(defn dumb-example [x]
  (while (some-complicated-stuff-happens)
    (pretend-like-this-function-is-big))

  (def result (memoize (do-something-very-expensive x)))

  (do-more-interesting-work))
</code></pre><p>Instead of memoizing a function to return a new memoized function, I want to memoize an <em>expression</em>. The <code>memoized</code> examples we saw earlier took place on the <em>callee</em> side – the function declaration – but here I want the memoization to happen on the <em>caller</em> side – at the function invocation.</p>
<p>I want it to be the case that this function only <em>actually</em> calls <code>do-something-very-expensive</code> once per unique value of <code>x</code>, even across separate invocations of <code>dumb-example</code>. And if you can stop wondering <em>why</em> you’d want to do this, think for a moment about <em>how</em> you would do this. How could you even write this in JavaScript?</p>
<p>We’ll simplify it a little: instead of worrying about arbitrary expressions, let’s assume that this is always a function call with a single argument, like we did before:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>const</span> <span>dumbExample</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>while</span> <span>(</span><span>someComplicatedStuffHappens</span><span>())</span> <span>{</span>
        <span>pretendLikeThisFunctionIsBig</span><span>();</span>
    <span>}</span>

    <span>const</span> <span>result</span> <span>=</span> <span>memoize</span><span>(</span><span>doSomethingVeryExpensive</span><span>,</span> <span>x</span><span>);</span>

    <span>doMoreInterestingWork</span><span>();</span>
<span>}</span>
</code></pre></div><p>How do you implement <code>memoize</code>?</p>
<p>I <em>think</em> that you basically can’t, in JavaScript. Or, more accurately: I can’t think of a way to do it.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<p>You can easily implement something very <em>similar</em>:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>const</span> <span>resultMap</span> <span>=</span> <span>new</span> <span>Map</span><span>();</span>
<span>const</span> <span>dumbExample</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>while</span> <span>(</span><span>someComplicatedStuffHappens</span><span>())</span> <span>{</span>
        <span>pretendLikeThisFunctionIsBig</span><span>();</span>
    <span>}</span>

    <span>const</span> <span>result</span> <span>=</span> <span>memoize</span><span>(</span><span>resultMap</span><span>,</span> <span>doSomethingVeryExpensive</span><span>,</span> <span>x</span><span>);</span>

    <span>doMoreInterestingWork</span><span>();</span>
<span>}</span>
</code></pre></div><p>If you can manually find a place to hoist the memoization dictionary. And, you know, in practice this would be completely fine. But it wouldn’t teach us anything new.</p>
<p>The problem is that we need some place to store the results that’s somehow tied to this <em>callsite</em>. Not the function, not the program containing the function, but this particular invocation of <code>memoize</code>.</p>
<p>And macros let us do exactly that: a macro will let us allocate, at <em>compile time</em>, a dictionary of results which we can then reference at <em>runtime</em>.</p>
<p>Which would have been a very surprising statement to me, a few years ago. Before I started writing Janet, <a href="https://ianthehenry.com/posts/janet-game/the-problem-with-macros/">I thought that macros were <em>syntactic</em> transformations</a>. And in some languages – Rust or OCaml, say – that’s exactly what they are. Syntactic transformations, AST twisters, token shufflers. Still very useful! But you can’t write a purely syntactic macro that admits per-callsite memoization.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>
<p>But in <a href="https://janet-lang.org/">Janet</a>, and some other lisp-family languages, macros are so much more than syntactic transformations. They’re ways to execute code – any code – and dynamically generate new functions – any functions – which will become our eventual program. Let’s take a look:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro memoize [[f &amp; args]]
  (def results @{})
  ~(let [f ,f
         args [,;args]
         memoization-key [f args]]
    (if (has-key? ,results memoization-key)
      (in ,results memoization-key)
      (let [result (f ;args)]
        (put ,results memoization-key result)
        result))))

(memoize (+ 1 2))
</code></pre>
<p>Set aside the horrific hygiene crimes in this macro definition, and just think about <code>results</code>. We allocated that <em>at compile time</em>, during macro expansion. Just one table! And then we <code>unquote</code>d multiple references to it into our macro expansion.</p>
<p>And this <em>absolutely does not work</em>.</p>
<p>It doesn’t work because <code>unquote</code> puts this table into the abstract syntax tree of our function, and tables, when they’re interpreted as abstract syntax trees and evaluated by Janet, create new tables. The empty table <code>@{}</code> is just how Janet represents the abstract syntax tree for an empty table literal.</p>
<p>So if we look at the macro expansion for our call:</p>
<pre tabindex="0"><code data-lang="janet">(let [f +
      args [1 2]
      memoization-key [f args]]
  (if (has-key? @{} memoization-key)
    (in @{} memoization-key)
    (let [result (f (splice args))]
      (put @{} memoization-key result)
      result)))
</code></pre><p>We’re allocating a brand new table every time we reference it! We didn’t put “a reference to the table we allocated at compile time” into the function. We put “the abstract syntax tree of a table literal” into our function. It doesn’t matter that every one of those tables in the abstract syntax tree is actually the <em>same</em> table. When Janet’s <code>compile</code> function sees a table – any table – it interprets that as “allocate a new table.”</p>
<p>So we need some way to say “no no no, this value isn’t an abstract syntax tree; it’s just a value. I just want a literal reference to this exact table that I allocated at compile time; I don’t want you to interpret it as an abstract syntax tree at all.”</p>
<p>And you can do that, by quoting the table:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro memoize [[f &amp; args]]
  (def results @{})
  ~(let [f ,f
         args [,;args]
         memoization-key [f args]]
    (if (has-key? &#39;,results memoization-key)
      (in &#39;,results memoization-key)
      (let [result (f ;args)]
        (put &#39;,results memoization-key result)
        result))))

(memoize (+ 1 2))
</code></pre><p>We still unquote <code>results</code>, but we unquote it inside a <code>quote</code> form. We quote-unquote the table.</p>
<p>And this works! Every time this macro invocation appears, it will expand to an abstract syntax tree like this:</p>
<pre tabindex="0"><code data-lang="janet">(let [f +
      args [1 2]
      memoization-key [f args]]
  (if (has-key? (quote @{}) memoization-key)
    (in (quote @{}) memoization-key)
    (let [result (f (splice args))]
      (put (quote @{}) memoization-key result)
      result)))
</code></pre><p>And, well, you can’t see this when we print it out like this, but every one of those tables is still the same table. Maybe this is an easier way to visualize what’s happening:</p>
<pre tabindex="0"><code data-lang="janet">(let [f +
      args [1 2]
      memoization-key [f args]]
  (if (has-key? (quote &lt;pointer-to-our-one-table&gt;) memoization-key)
    (in (quote &lt;pointer-to-our-one-table&gt;) memoization-key)
    (let [result (f (splice args))]
      (put (quote &lt;pointer-to-our-one-table&gt;) memoization-key result)
      result)))
</code></pre><p>And any time Janet evaluates <code>(quote _)</code>, it doesn’t look at the thing being quoted. It just returns it. Even if it’s a reference-style, mutable value like it is here.</p>

<p>This was a very long way to point out a pretty simple thing, but I wanted to write this post because <em>I wish that I’d understood this sooner</em>. It took a long time before <code>quote</code> “clicked” for me. I was <em>using</em> <code>quote</code> to write macros long before I actually understood how it worked, but I was not using it to its fullest.</p>
<p>If you’d asked me two years ago, I probably would have said that <code>quote</code> “returns the abstract syntax tree representing its argument.” <code>(+ 1 2)</code> is <code>3</code>, and <code>&#39;(+ 1 2)</code> is the abstract syntax tree <code>[&#39;+ 1 2]</code> that represents that function call.</p>
<p>And while this seems <em>kinda</em> right, it’s just not. <code>quote</code> doesn’t “return the abstract syntax tree” of anything. <code>quote</code> returns <em>whatever you hand it</em>. The abstract syntax tree <code>[&#39;+ 1 2]</code> came from the Janet <em>parser</em>. The parser created that; <code>quote</code> had nothing to do with it. <code>quote</code> just forwarded it along.</p>
<p>Even the fact that I’m using <code>&#39;+</code> to mean “the symbol that is just the plus sign” is a little funny. Maybe it’s easier to think of this as the abstract syntax tree <code>[(symbol &#34;+&#34;) 1 2]</code>. The symbol, once again, came from the parser, not the <code>quote</code>. But I’m just so used to thinking of <code>&#39;+</code> as “the way you write a symbol literal.”</p>
<p>Anyway, we can observe this property of <code>quote</code> in a much simpler – albeit stranger – scenario. What does this function do?</p>
<pre tabindex="0"><code data-lang="janet">(defn foo []
  (def x @{})
  (put x (length x) true)
  x)
</code></pre><p>It’s not a trick question; it does what you’d expect:</p>
<pre tabindex="0"><code>repl:1:&gt; (foo)
@{0 true}
repl:2:&gt; (foo)
@{0 true}
repl:2:&gt; (foo)
@{0 true}
</code></pre><p>But what about <em>this</em> one?</p>
<pre tabindex="0"><code data-lang="janet">(defn foo []
  (def x &#39;@{})
  (put x (length x) true)
  x)
</code></pre><p>It’s… well, it’s not a trick question either, but this definitely would have confused me earlier in my Janet career:</p>
<pre tabindex="0"><code>repl:1:&gt; (foo)
@{0 true}
repl:2:&gt; (foo)
@{0 true 1 true}
repl:3:&gt; (foo)
@{0 true 1 true 2 true}
repl:4:&gt; (foo)
@{0 true 1 true 2 true 3 true}
</code></pre><p>It’s the same table every time, because there was only ever one table in the first place: the table that the Janet <em>parser</em> allocated to represent the abstract syntax tree of the characters <code>@{}</code>.</p>
<p>And we’re mutating it.</p>
<p>Neat.</p>
<p>Is this useful? Well… it’s sort of like a <code>static</code> storage qualifier…? But… but no. It’s not really useful. I struggle to even think of a situation where you would want a per-callsite <code>(memoize)</code>, and in any case it would be <em>easier</em> to write that particular macro without using quote-unquote at all:</p>
<pre tabindex="0"><code data-lang="janet">(defmacro memoize [form]
  (def results @{})
  (defn memoize-call [f &amp; args]
    (def memoization-key [f args])
    (if (has-key? results memoization-key)
      (in results memoization-key)
      (let [result (f ;args)]
        (put results memoization-key result)
        result)))
  ~(,memoize-call ,;form))
</code></pre><p>In this version we allocate a single closure at compile time, and insert a reference to <em>that</em> into the expanded form. The closure refers to the shared table, and we no longer have to think about gensym, or argument evaluation order, or quote-unquoting, or anything else. We’re back in the safe land of writing normal code with values and closures, instead of the weird upside-down world of writing quasiquoted code with abstract syntax trees and evaluation rules.</p>
<p><em>But</em>. Using quote-unquote to pass values from compile time to runtime is still a <em>generally</em> useful technique. You can’t always write a closure like this – sometimes you really do need to produce an AST with a reference to a mutable value you allocated at compile time.</p>
<p>The problem is, it’s useful in situations that don’t really fit into a blog post. I’ve been spending some time recently rewriting the <a href="https://bauble.studio/">Bauble</a> compiler, now that I actually know Janet, and this quote-unquote pattern comes up in just about every nontrivial macro I write. These are macros that produce Janet code that you can evaluate to construct a GLSL AST, but some amount of evaluation happens at macro expansion time, and the result of that ahead-of-time evaluation gets quote-unquoted into the intermediate Janet code.</p>
<p>I’ve also used quote-unquote in conjunction with mutable values allocated at compile-time (like what we saw here) in <a href="https://ianthehenry.com/posts/my-kind-of-repl/">Judge</a>, my inline snapshot testing framework, to ensure that every assertion you <em>write</em> actually runs by the time a test completes.</p>
<p>But, well, those are big and complicated and hard to explain and talk about, and I just wanted to point out how I underestimated <code>quote</code> for so long, in case you’ve been balancing your parentheses under the same misconception.</p>
</div>
</article></div>
  </body>
</html>
