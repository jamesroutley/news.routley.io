<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://silly.business/blog/running-miniflux-in-k3s-and-narrating-it-in-org-for-questionable-reasons/">Original</a>
    <h1>Running Miniflux in k3s and Narrating it in Org for Questionable Reasons</h1>
    
    <div id="readability-page-1" class="page"><div>
  
<p>
My day jobs have entailed occasional interaction with Kubernetes for a long time, and I&#39;ve been an accidental participant in the &#34;hobby&#34; of self-hosting since high school so I have been meaning to incorporate <code>k3s</code> somewhere in my stack for a long time to encourage me to stay fresh with some of the aspects of the tools I use professionally that I don&#39;t always encounter day-to-day.</p>
<p>
<code>k3s</code> is a Kubernetes distribution in a single binary. The installer <a href="https://docs.k3s.io/quick-start">from their website</a> downloads the server binary to <code>/usr/local/bin</code> and then configures and starts it as a <code>systemd</code> service. It then installs <code>kubectl</code>, along with a couple other helper programs, and configures them to point to the new server at <code>localhost</code>.</p>
<p>
The containers are all <code>containerd</code> containers so if you are running <code>docker</code> or <code>podman</code> on the same system, the containers inside <code>k3s</code> are all isolated and don&#39;t pollute <code>docker ps</code>. Aside from a few extra virtual network devices, the new <code>.service</code> file, and the extra binaries, the new host is unchanged, and I&#39;m still able to run normal services alongside my new Kubernetes node.</p>
<p>
After running the install line on a brand new Debian host, I wanted to set up an example service to validate the installation. I chose to install <a href="https://miniflux.app/">Miniflux</a> since that&#39;s my favorite RSS feed reader and I didn&#39;t currently have an instance running. I have done the Miniflux installation a few times now, and one of the things I like about Miniflux is that it&#39;s about as simple as it gets. It&#39;s just a binary, so you just put it where it goes (<code>/usr/local/bin</code>) and write a <code>.service</code> file and you&#39;re off. Except, oh that&#39;s right, Miniflux uses Postgres to store state.</p>
<p>
This drives me nuts! Why can&#39;t it use sqlite?? That would be so perfect and so easy to deploy! Anyway, I assume there&#39;s a good reason, but it means I have to keep Postgres around. That makes <code>miniflux</code> a good candidate for being the proof of concept for my new k3s cluster. It&#39;s a relatively simple service, but not one that is completely trivial, either.</p>
<div id="outline-container-headline-1">
<h2 id="headline-1">
Configuring the Service
</h2>
<div id="outline-text-headline-1">
<p>As efficient as any good engineer, I wanted to avoid handwriting as much YAML as I could while also learning how to adapt a self-hosted service to run in <code>k3s</code>. Most projects like Miniflux are small community affairs which do not offer Kubernetes configuration or something like an Operator. However, a lot of projects offer a Docker Compose configuration, and suggestion that you run your service using Docker Compose.</p>
<p>
This is useful to me because <code>podman</code> has a command <code>podman kube generate</code> that lets you generate Kubernetes definitions from <code>podman</code> objects (containers, pods, volumes, etc).</p>
<div id="outline-container-headline-2">
<h3 id="headline-2">
Generating the Kubernetes Pod definition from the Docker Compose file  
</h3>
<div id="outline-text-headline-2">
<p>The first step is fetching the Miniflux source, editing the <code>docker-compose.yaml</code> according to the Miniflux installation instructions to select admin and database credentials, and then running <code>podman compose up -d</code>.</p>
<p>
Then, I ran <code>podman kube generate --service pod_miniflux</code> to generate most of the configuration I would need for <code>k3s</code>. </p>
<p>
For later comparison, this is what that output looks like:</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  <span># Save the output of this file and use kubectl create -f to import</span>
</span></span><span><span>  <span># it into Kubernetes.</span>
</span></span><span><span>  <span>#</span>
</span></span><span><span>  <span># Created with podman-5.4.2</span>
</span></span><span><span>
</span></span><span><span>  <span># NOTE: The namespace sharing for a pod has been modified by the user and is not the same as the</span>
</span></span><span><span>  <span># default settings for kubernetes. This can lead to unexpected behavior when running the generated</span>
</span></span><span><span>  <span># kube yaml in a kubernetes cluster.</span>
</span></span><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>Service</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>creationTimestamp</span><span>:</span> <span>&#34;2026-01-04T20:36:42Z&#34;</span>
</span></span><span><span>    <span>labels</span><span>:</span>
</span></span><span><span>      <span>app</span><span>:</span> <span>podminiflux</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>podminiflux</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>ports</span><span>:</span>
</span></span><span><span>    - <span>name</span><span>:</span> <span>&#34;8080&#34;</span>
</span></span><span><span>      <span>nodePort</span><span>:</span> <span>31462</span>
</span></span><span><span>      <span>port</span><span>:</span> <span>8080</span>
</span></span><span><span>      <span>targetPort</span><span>:</span> <span>8080</span>
</span></span><span><span>    <span>selector</span><span>:</span>
</span></span><span><span>      <span>app</span><span>:</span> <span>podminiflux</span>
</span></span><span><span>    <span>type</span><span>:</span> <span>NodePort</span>
</span></span><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>Pod</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>annotations</span><span>:</span>
</span></span><span><span>      <span>io.kubernetes.cri-o.SandboxID/minifluxdb1</span><span>:</span> <span>0a359571a6d6b2b0db840eb377f2ae39a3375562ead5e9ba1fe0789ec78bdac5</span>
</span></span><span><span>      <span>io.kubernetes.cri-o.SandboxID/minifluxminiflux1</span><span>:</span> <span>0a359571a6d6b2b0db840eb377f2ae39a3375562ead5e9ba1fe0789ec78bdac5</span>
</span></span><span><span>    <span>creationTimestamp</span><span>:</span> <span>&#34;2026-01-04T20:36:42Z&#34;</span>
</span></span><span><span>    <span>labels</span><span>:</span>
</span></span><span><span>      <span>app</span><span>:</span> <span>podminiflux</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>podminiflux</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>containers</span><span>:</span>
</span></span><span><span>    - <span>args</span><span>:</span>
</span></span><span><span>      - <span>postgres</span>
</span></span><span><span>      <span>env</span><span>:</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_PASSWORD</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>Very-Secret-DB-Password</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_DB</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>miniflux</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_USER</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>miniflux</span>
</span></span><span><span>      <span>image</span><span>:</span> <span>docker.io/library/postgres:18</span>
</span></span><span><span>      <span>name</span><span>:</span> <span>minifluxdb1</span>
</span></span><span><span>      <span>volumeMounts</span><span>:</span>
</span></span><span><span>      - <span>mountPath</span><span>:</span> <span>/var/lib/postgresql</span>
</span></span><span><span>        <span>name</span><span>:</span> <span>miniflux-db-pvc</span>
</span></span><span><span>    - <span>env</span><span>:</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>RUN_MIGRATIONS</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>&#34;1&#34;</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>CREATE_ADMIN</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>&#34;1&#34;</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>ADMIN_USERNAME</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>ian</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>ADMIN_PASSWORD</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>My-Secret-Admin-Password1</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>DATABASE_URL</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>postgres://miniflux:Very-Secret-DB-Password@db/miniflux?sslmode=disable</span>
</span></span><span><span>      <span>image</span><span>:</span> <span>docker.io/miniflux/miniflux:latest</span>
</span></span><span><span>      <span>name</span><span>:</span> <span>minifluxminiflux1</span>
</span></span><span><span>      <span>ports</span><span>:</span>
</span></span><span><span>      - <span>containerPort</span><span>:</span> <span>8080</span>
</span></span><span><span>      <span>securityContext</span><span>:</span>
</span></span><span><span>        <span>runAsNonRoot</span><span>:</span> <span>true</span>
</span></span><span><span>    <span>volumes</span><span>:</span>
</span></span><span><span>    - <span>name</span><span>:</span> <span>miniflux-db-pvc</span>
</span></span><span><span>      <span>persistentVolumeClaim</span><span>:</span>
</span></span><span><span>        <span>claimName</span><span>:</span> <span>miniflux-db</span></span></span></code></pre></div>
</div>
<p>
It&#39;s not useful as a finished product, but it&#39;s a good starting point.</p>
</div>
</div>
<div id="outline-container-headline-3">
<h3 id="headline-3">
Defining the Kubernetes Objects
</h3>
<div id="outline-text-headline-3">
<p>To be deployed, Miniflux needs:</p>
<ol>
<li>The <code>Pod</code> definition based on above.</li>
<li>A <code>Service</code> definition based on above, to expose the <code>Pods</code> to the cluster and local network.</li>
<li>A <code>Secrets</code> definition for the passwords</li>
<li>A <code>PersistentVolumeClaim</code> for the volume that the database data inhabits.</li>
<li>An <code>Ingress</code> to tell the service listening on <code>:80</code> and <code>:443</code> (in Kubernetes this is the Ingress Controller and in k3s the choice of Ingress Controller is Traefik) to forward traffic to the <code>Service</code> when the correct hostname is requested on those ports.</li>
</ol>
<p>Since Kubernetes objects are defined declaratively, these 5 YAML objects can be stored in my systems journals repository in a single Org file or under an Org heading, which can then be executed to deploy or redeploy the entire service.</p>
<p>
I love this because, although there is potentially more work up-front, in the future I can have all of the configuration, automation, and commentary in the same files in the location where I keep those things for all of my systems, and in a format that is more robust and executable than some of my more manual deployments. Jump to Saving and Applying the Configuration below if you are more interested in this than in the Kubernetes configuration.</p>
<p>
Here are the final configurations, in the mostly arbitrary order from above:</p>
<div id="outline-container-headline-4">
<h4 id="headline-4">
Pod Definition
</h4>
<div id="outline-text-headline-4">
<p>The final Pod definition isn&#39;t much different from the one that <code>podman</code> spit out. I removed stuttering from some names and moved the hard-coded secrets to the <code>Secrets</code> object.</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>Pod</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>labels</span><span>:</span>
</span></span><span><span>      <span>app.kubernetes.io/name</span><span>:</span> <span>miniflux</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>miniflux</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>containers</span><span>:</span>
</span></span><span><span>    - <span>name</span><span>:</span> <span>db</span>
</span></span><span><span>      <span>args</span><span>:</span>
</span></span><span><span>      - <span>postgres</span>
</span></span><span><span>      <span>env</span><span>:</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_DB</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>miniflux</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_USER</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>miniflux</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>POSTGRES_PASSWORD</span>
</span></span><span><span>        <span>valueFrom</span><span>:</span>
</span></span><span><span>          <span>secretKeyRef</span><span>:</span>
</span></span><span><span>            <span>name</span><span>:</span> <span>miniflux-secrets</span>
</span></span><span><span>            <span>key</span><span>:</span> <span>database-password</span>
</span></span><span><span>      <span>image</span><span>:</span> <span>docker.io/library/postgres:18</span>
</span></span><span><span>      <span>volumeMounts</span><span>:</span>
</span></span><span><span>      - <span>mountPath</span><span>:</span> <span>/var/lib/postgresql</span>
</span></span><span><span>        <span>name</span><span>:</span> <span>miniflux-db</span>
</span></span><span><span>    - <span>name</span><span>:</span> <span>app</span>
</span></span><span><span>      <span>env</span><span>:</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>ADMIN_PASSWORD</span>
</span></span><span><span>        <span>valueFrom</span><span>:</span>
</span></span><span><span>          <span>secretKeyRef</span><span>:</span>
</span></span><span><span>            <span>name</span><span>:</span> <span>miniflux-secrets</span>
</span></span><span><span>            <span>key</span><span>:</span> <span>admin-password</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>DATABASE_URL</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>postgres://miniflux:$POSTGRES_PASSWORD@localhost/miniflux?sslmode=disable</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>RUN_MIGRATIONS</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>&#34;1&#34;</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>CREATE_ADMIN</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>&#34;1&#34;</span>
</span></span><span><span>      - <span>name</span><span>:</span> <span>ADMIN_USERNAME</span>
</span></span><span><span>        <span>value</span><span>:</span> <span>&#34;ian&#34;</span>
</span></span><span><span>      <span>image</span><span>:</span> <span>docker.io/miniflux/miniflux:latest</span>
</span></span><span><span>      <span>ports</span><span>:</span>
</span></span><span><span>      - <span>containerPort</span><span>:</span> <span>8080</span>
</span></span><span><span>      <span>securityContext</span><span>:</span>
</span></span><span><span>        <span>runAsNonRoot</span><span>:</span> <span>true</span>
</span></span><span><span>    <span>volumes</span><span>:</span>
</span></span><span><span>    - <span>name</span><span>:</span> <span>miniflux-db</span>
</span></span><span><span>      <span>persistentVolumeClaim</span><span>:</span>
</span></span><span><span>        <span>claimName</span><span>:</span> <span>miniflux-db-pvc</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-5">
<h4 id="headline-5">
Service
</h4>
<div id="outline-text-headline-5">
<p>The service definition is pretty close too. I changed the type to a <code>LoadBalancer</code> after reading some of the <code>k3s</code> docs and changed some ports based on personal taste:</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>Service</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>miniflux-service</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>type</span><span>:</span> <span>LoadBalancer</span>
</span></span><span><span>    <span>selector</span><span>:</span>
</span></span><span><span>      <span>app.kubernetes.io/name</span><span>:</span> <span>miniflux</span>
</span></span><span><span>    <span>ports</span><span>:</span>
</span></span><span><span>    - <span>protocol</span><span>:</span> <span>TCP</span>
</span></span><span><span>      <span>port</span><span>:</span> <span>8111</span>
</span></span><span><span>      <span>targetPort</span><span>:</span> <span>8080</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-6">
<h4 id="headline-6">
Storage
</h4>
<div id="outline-text-headline-6">
<p>Postgres needs persistent storage, which means it claims a volume with <code>volumeMounts</code> above. That claim needs a <code>PersistentVolumeClaim</code> which is defined here:</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>PersistentVolumeClaim</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>miniflux-db-pvc</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>accessModes</span><span>:</span>
</span></span><span><span>      - <span>ReadWriteOnce</span>
</span></span><span><span>    <span>storageClassName</span><span>:</span> <span>local-path</span>
</span></span><span><span>    <span>resources</span><span>:</span>
</span></span><span><span>      <span>requests</span><span>:</span>
</span></span><span><span>        <span>storage</span><span>:</span> <span>1Gi</span></span></span></code></pre></div>
</div>
<p>
<code>podman kube generate $VOLUMENAME</code> generated most of this, but I needed to remove the <code>podman</code> annotation and add the <code>storageClassName</code> line to make it compatible with <code>k3s</code>.</p>
</div>
</div>
<div id="outline-container-headline-7">
<h4 id="headline-7">
Secrets
</h4>
<div id="outline-text-headline-7">
<p>Kubernetes allows secrets to be managed through their own object, defined in their own file. They are base64 encoded in the file, but exposed in the pods in plain text. This allows me to use <code>org-crypt</code> to quickly encrypt/decrypt the Org heading containing <code>secrets.yaml</code> with my GPG key and store the secrets encrypted at rest.</p>
<p>
In plain text, the <code>Secrets</code> definition looks like this: </p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>    ---
</span></span><span><span>    <span>apiVersion</span><span>:</span> <span>v1</span>
</span></span><span><span>    <span>kind</span><span>:</span> <span>Secret</span>
</span></span><span><span>    <span>metadata</span><span>:</span>
</span></span><span><span>      <span>name</span><span>:</span> <span>miniflux-secrets</span>
</span></span><span><span>    <span>type</span><span>:</span> <span>Opaque</span>
</span></span><span><span>    <span>data</span><span>:</span>
</span></span><span><span>      <span>admin-password</span><span>:</span> <span>SS1CZXQtWW91LVRoaW5rLVlvdXJlLUNsZXZlcg==</span>
</span></span><span><span>      <span>database-password</span><span>:</span> <span>bmljZS10cnktYnV0LUknbS1ub3Qtc3R1cGlk</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-8">
<h4 id="headline-8">
Ingress
</h4>
<div id="outline-text-headline-8">
<p>The <code>Ingress</code> definition provides the link from Traefik listening on <code>80</code> and <code>443</code> to the <code>Service</code> inside the cluster. However, if we define the <code>Ingress</code> on <code>k3s</code> immediately after installing vanilla <code>k3s</code>, the <code>Ingress</code> will present a self-signed certificate.</p>
<div id="outline-container-headline-9">
<h5 id="headline-9">
Let&#39;s Encrypt Certificate Issuance
</h5>
<div id="outline-text-headline-9">
<p>I would like services to be assigned Let&#39;s Encrypt certificates automatically, because I have been spoiled by the functionality of <a href="https://caddyserver.com/">Caddy</a>. This requires a one-time task to set up automated certificate issuance for any new Services or Deployments that I put in my cluster. After this I will be able to issue a certificate for an Ingress by adding an annotation to that object.</p>
<p>
The Kubernetes object that provides this functionality is a <code>ClusterIssuer</code>. <code>Certificate Manager</code> appears to be the standard implementation for my use-case and it can be installed thusly:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>  kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.19.2/cert-manager.yaml</span></span></code></pre></div>
</div>
<p>
and then configured with yet another YAML document, which can be found in many examples and merely needs the email field filled in, and then applied:</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  <span>apiVersion</span><span>:</span> <span>cert-manager.io/v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>ClusterIssuer</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>letsencrypt</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>acme</span><span>:</span>
</span></span><span><span>      <span>email</span><span>:</span> <span><a href="https://silly.business/cdn-cgi/l/email-protection" data-cfemail="81ece4c1f2e8ededf8afe3f4f2e8efe4f2f2">[email protected]</a></span>
</span></span><span><span>      <span>server</span><span>:</span> <span>https://acme-v02.api.letsencrypt.org/directory</span>
</span></span><span><span>      <span>privateKeySecretRef</span><span>:</span>
</span></span><span><span>        <span>name</span><span>:</span> <span>letsencrypt</span>
</span></span><span><span>      <span>solvers</span><span>:</span>
</span></span><span><span>      - <span>http01</span><span>:</span>
</span></span><span><span>          <span>ingress</span><span>:</span>
</span></span><span><span>            <span>class</span><span>:</span> <span>traefik</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-10">
<h5 id="headline-10">
The Ingress Configuration
</h5>
<div id="outline-text-headline-10">
<p>Once the <code>ClusterIssuer</code> has been defined, I can define my Ingress.</p>
<div>
<div><pre tabindex="0"><code data-lang="yaml"><span><span>  ---
</span></span><span><span>  <span>apiVersion</span><span>:</span> <span>networking.k8s.io/v1</span>
</span></span><span><span>  <span>kind</span><span>:</span> <span>Ingress</span>
</span></span><span><span>  <span>metadata</span><span>:</span>
</span></span><span><span>    <span>name</span><span>:</span> <span>miniflux-ingress</span>
</span></span><span><span>    <span>annotations</span><span>:</span>
</span></span><span><span>      <span>cert-manager.io/cluster-issuer</span><span>:</span> <span>letsencrypt</span>
</span></span><span><span>      <span>kubernetes.io/ingress.class</span><span>:</span> <span>traefik</span>
</span></span><span><span>  <span>spec</span><span>:</span>
</span></span><span><span>    <span>rules</span><span>:</span>
</span></span><span><span>      - <span>host</span><span>:</span> <span>news.example.com</span>
</span></span><span><span>        <span>http</span><span>:</span>
</span></span><span><span>          <span>paths</span><span>:</span>
</span></span><span><span>            - <span>path</span><span>:</span> <span>/</span>
</span></span><span><span>              <span>pathType</span><span>:</span> <span>Prefix</span>
</span></span><span><span>              <span>backend</span><span>:</span>
</span></span><span><span>                <span>service</span><span>:</span>
</span></span><span><span>                  <span>name</span><span>:</span> <span>miniflux-service</span>
</span></span><span><span>                  <span>port</span><span>:</span>
</span></span><span><span>                    <span>number</span><span>:</span> <span>8111</span>
</span></span><span><span>    <span>tls</span><span>:</span>
</span></span><span><span>      - <span>hosts</span><span>:</span>
</span></span><span><span>          - <span>news.example.com</span>
</span></span><span><span>        <span>secretName</span><span>:</span> <span>miniflux-tls</span></span></span></code></pre></div>
</div>
<p>
The <code>cert-manager.io/cluster-issuer</code> annotation tells the <code>ClusterIssuer</code> to contact Let&#39;s Encrypt to issue a certificate for the hostname defined in the <code>tls</code> section.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11">
<h3 id="headline-11">
Saving and Applying the Configuration
</h3>
<div id="outline-text-headline-11">
<p>
I have defined each of these documents as part of source code blocks in an Org file dedicated to the server on which <code>k3s</code> was installed. The first part of the document combines notes about how to use the file, as well as automation to set up <code>kubectl</code> and decrypt any secrets and extract the code stored within the file to their final destinations</p>
<div>
<div><pre tabindex="0"><code data-lang="org"><span><span>  #+TITLE: Ian&#39;s Self Host Stack
</span></span><span><span>  #+PROPERTY: header-args: :tangle no
</span></span><span><span>  #+PROPERTY: header-args:yaml :eval never
</span></span><span><span>
</span></span><span><span>  This is a living, executable document, representing the desired state of my home services and infrastructure.
</span></span><span><span>  Run <span>=org-babel-execute-buffer=</span> with <span>=kubectl=</span> installed and configured to set up everything.
</span></span><span><span>
</span></span><span><span>  The document assumes a bare Linux server (anything that can run <span>=k3s=</span>) configured in <span>=~/.ssh/config=</span> under the <span>~Host~</span> <span>=relay=</span> with keys set up and <span>~curl~</span> installed.
</span></span><span><span>
</span></span><span><span>  When the buffer is executed, the following code will decrypt any encrypted sections and tangle the file:
</span></span><span><span><span>  #+begin_src </span><span>emacs-lisp</span><span> :results none
</span></span></span><span><span>      <span>(</span><span>progn</span>
</span></span><span><span>        <span>(</span><span>org-decrypt-entries</span><span>)</span>
</span></span><span><span>        <span>(</span><span>org-babel-tangle-file</span> <span>(</span><span>buffer-file-name</span><span>))</span>
</span></span><span><span>        <span>(</span><span>org-encrypt-entries</span><span>))</span>
</span></span><span><span><span>  #+end_src</span>
</span></span><span><span>
</span></span><span><span>  Then it will copy the <span>=kubectl=</span> config file into place (overwrites <span>=~/.kube/config=</span> ⚠) &amp; point it to the correct hostname.
</span></span><span><span>
</span></span><span><span><span>  #+begin_src </span><span>fish</span><span> :results none
</span></span></span><span><span>    <span>scp</span> relay:/etc/rancher/k3s/k3s.yaml ~/.kube/config
</span></span><span><span>    <span>sed</span> <span>-i</span> <span>&#39;s/127.0.0.1/relay.local/g&#39;</span> ~/.kube/config
</span></span><span><span><span>  #+end_src</span></span></span></code></pre></div>
</div>
<p>
Under each heading I can define the parts of the server I want to configure, and Kubernetes makes this very straightforward as I can define a heading with a property that applies <code>:tangle filename.yaml</code> to all of the child blocks:</p>
<div>
<div><pre tabindex="0"><code data-lang="org"><span><span>  <span>* </span>Services
</span></span><span><span>  ** Miniflux
</span></span><span><span><span>  :PROPERTIES:
</span></span></span><span><span><span>  :header-args:yaml: :tangle /tmp/miniflux.yaml
</span></span></span><span><span><span>  :END:</span>
</span></span><span><span>
</span></span><span><span>  [[<span>https://miniflux.app</span>][<span>Miniflux</span>]] is a news feed (RSS/Atom) reader.</span></span></code></pre></div>
</div>
<p>
It can also include the <code>kubectl apply</code> calls since their order does not matter:</p>
<div>
<div><pre tabindex="0"><code data-lang="org"><span><span><span>  #+begin_src </span><span>fish</span><span>
</span></span></span><span><span>    <span>kubectl</span> get namespace miniflux <span>||</span> <span>kubectl</span> create namespace miniflux
</span></span><span><span><span>  #+end_src</span>
</span></span><span><span>
</span></span><span><span>  #+RESULTS:
</span></span><span><span>  : NAME       STATUS   AGE
</span></span><span><span>  : miniflux   Active   3h5m
</span></span><span><span>
</span></span><span><span><span>  #+begin_src </span><span>fish</span><span>
</span></span></span><span><span>    <span>kubectl</span> apply <span>-f</span> /tmp/miniflux.yaml <span>-n</span> miniflux
</span></span><span><span><span>  #+end_src</span></span></span></code></pre></div>
</div>
<p>
In practice, this allows me to call <code>org-babel-execute-subtree</code> to redeploy Miniflux, or <code>org-babel-execute-buffer</code> to completely redeploy all of my services and the Kubernetes configuration itself.</p>
<p>
Here is a screenshot of how this document appears (with some headings collapsed) in Emacs with my configuration in light mode:</p>
<p>
<img src="https://silly.business/blog/running-miniflux-in-k3s-and-narrating-it-in-org-for-questionable-reasons/Screenshot_20260104_141559.png" alt="Screenshot_20260104_141559.png" title="Screenshot_20260104_141559.png"/></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-12">
<h2 id="headline-12">
Reflections on the Old Way and the New Way
</h2>
<div id="outline-text-headline-12">
<p>Until now I have just run Miniflux as a traditional Unix service, along with Postgres running as a traditional Unix service, on an LTS distribution, the &#34;old fashioned way.&#34;  Other than my penchant for accidentally deleting the database, this has been extremely low maintenance. Rewriting the configuration into YAML was definitely more effort, and for questionable gain.</p>
<p>
When using Caddy as a reverse proxy, Miniflux can  be set up with a single <code>.service</code> file and about four lines of <code>Caddyfile</code> configuration, plus the Postgres database. I can set that all up manually in about 15 minutes, maybe a little longer if I&#39;m also watching TV. It&#39;s not hard.</p>
<p>
Caddy itself is also very easy to deploy, and it gives the user the same functionality as all of the configuration in the <code>Ingress</code> and the <code>ClusterIssuer</code>, much of it by default with no extra configuration (particularly the Let&#39;s Encrypt stuff, which Caddy completely automates).</p>
<p>
From that perspective, this is massive overkill and a lot more effort, and Traefik must be configured through Kubernetes verbs if I want to use it as the reverse proxy for all of my services, which is likely going to be more difficult than updating a <code>Caddyfile</code>. These are the downsides.</p>
<p>
But here are some benefits of using <code>k3s</code> too:</p>
<ol>
<li>A lot of the config above isn&#39;t unique to Miniflux, or Traefik, and if k3s chooses a new Ingress Controller (or switches over to the newer <code>Gateway</code> API), reconfiguration should be minimal and anything I need to learn will be useful repeatedly.</li>
<li>Kubernetes&#39;s declarative style works <em>immensely</em> well with Org Mode for literate configuration. This is a really huge win, as the same thing -can- be achieved with traditional tools but an Org document containing Kubernetes config can be reorganized more freely than a traditional literate script because Kubernetes is declarative. This is a light-bulb moment for me, and I will have to revisit this idea.</li>
<li>The deployment is now completely automated and documented, without writing anything extra. I can use <code>git</code> to move around the repo containing this file, and to track changes, and execute the file to stand up all of the infrastructure on any system where I have <code>kubectl</code> configured. Every deployment I add will follow the same pattern, as well, which aids in one of the hardest tasks of the long-term solo self-hoster: remembering <em>what</em>, <em>why</em>, and <em>how</em>, you have configured your services over the course of years.</li>
<li>Every deployment gets its own versions of their dependencies and runs in its own namespace. This isolation is extremely nice when you have an ever-growing list of heterogeneous services which may have conflicting dependencies. In the past I have been afraid to run certain services without a VM or a physical host due to the number of dependencies they have, for fear of conflicting configurations. This will be much easier with Kubernetes.</li>
</ol>
</div>
</div>
<div id="outline-container-headline-13">
<h2 id="headline-13">
Conclusions
</h2>
<div id="outline-text-headline-13">
<ul>
<li><code>k3s</code> is a good, self-contained product for standing up a Kubernetes node &amp; server for minimal fuss</li>
<li><code>podman kube generate</code> is a very good and cool tool for bridging the gap from Docker Compose to Kubernetes, and <code>podman compose</code> is good and cool too.</li>
<li>YAML definitions and Org Mode are awesome together</li>
<li>Kubernetes is, in fact, as complicated as its reputation implies</li>
<li>Time will tell if this was worth the investment for a small-time operator like me, aside from the educational aspect.</li>
</ul>
</div>
</div>
<p id="outline-container-headline-14">
<h2 id="headline-14">
Footnotes
</h2>
</p>


</div></div>
  </body>
</html>
