<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tomasp.net/techdims/">Original</a>
    <h1>Technical dimensions of programming systems</h1>
    
    <div id="readability-page-1" class="page"><article>
    <section data-class="catalogue nobullet" data-file="catalogue" data-id="index" data-title="Catalogue of technical dimensions">

<p>Technical dimensions break down discussion about
programming systems along various specific &#34;axes&#34;. The dimensions identify
a range of possible design choices, characterized by two extreme points
in the design space.</p>
<p><a href="#image=catalogue,nest"><img src="https://tomasp.net/techdims/img/nest.png" alt="A diagram showing programming systems with two dimensions"/></a></p>
<p>The dimensions are not quantitative, but they allow comparison.
The extreme points do not represent &#34;good&#34; and &#34;bad&#34; designs, merely different trade-offs.
The set of dimensions provides a map of the design space of programming systems (see diagram).
Past and present systems serve as landmarks, but the map also reveals unexplored
or overlooked possibilities.</p>
<p>The 23 technical dimensions are grouped into 7 clusters or topics of interest.
Each cluster consists of individual dimensions, examples that capture a particular
well-known value (or a combination of values), remarks and relations to other dimensions.
We do not expect the catalogue to be exhaustive for all aspects of programming systems,
past and future, and welcome follow-up work expanding the list.</p>

</section>
<section data-class="frameset catalogue" data-file="catalogue" data-id="list" data-title="Catalogue of technical dimensions">







</section>
<section data-class="noborder" data-file="catalogue" data-id="nest" data-title="An illustration of the technical dimensions framework">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/nest.png" alt="A diagram showing programming systems with two dimensions"/></p>
<p><strong>Illustration of technical dimensions.</strong> The diagram shows a number of sample programming
systems, positioned according to two hypothetical dimensions. Viewed as programming systems,
text-based programming languages with debugger, editor and build tools are grouped
in one region.</p>
</blockquote>
</section>
<section data-class="welcome nobullet" data-file="index" data-id="welcome" data-title="Technical dimensions of programming systems">

<blockquote>
<p>by <a href="https://programmingmadecomplicated.wordpress.com/">Joel Jakubovic</a>, <a href="https://alarmingdevelopment.org/">Jonathan Edwards</a> and <a href="https://tomasp.net">Tomas Petricek</a></p>
</blockquote>
<p><a href="#image=index,smalltalk-76"><img src="https://tomasp.net/techdims/img/smalltalk-76.png" alt="A screenshot of the Smalltalk 76 programming environment"/></a></p>
<p>Programming is done in a stateful environment, by interacting with a system through a
graphical user interface. The stateful, interactive and graphical environment is more
important than the programming language(s) used through it. Yet, most research focuses on comparing and
studying <em>programming languages</em> and only little has been said about <em>programming systems</em>.</p>
<p>Technical dimensions is a framework that captures the characteristics of programming
systems. It makes it possible to compare programming systems, better understand them,
and to find interesting new points in the design space of programming systems.
We created technical dimensions to help designers of programming systems to evaluate,
compare and guide their work and, ultimately, stand on the shoulders of giants.</p>
<h2>Where to start to learn more</h2>
<ul>
<li>
Want to delve into the details and analyse your system?</li>
<li>
Want to explore our framework by example?</li>
<li>
Want to see how this helps us understand programming systems?</li>
<li>
Read about our motivation, methodology and evaluation?</li>
</ul>
<h2>Related papers and documents</h2>
<ul>
<li>
Read our ‹Programming› 2023 paper in a conventional format</li>
<li>
Check out tutorial slides with a structured summary of dimensions</li>
</ul>
</section>
<section data-file="index" data-id="smalltalk-76" data-title="Smalltalk 76 programming environment">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/smalltalk-76.png" alt="A screenshot of the Smalltalk 76 programming environment"/></p>
<p><strong>Smalltalk 76 programming environment.</strong> An example of a stateful programming environment with
rich graphical user interface. In Smalltalk, the developer environment is a part of an executing
program and the state of the program can be edited through object browser.</p>
</blockquote>
</section>
<section data-class="nobullet" data-file="index" data-id="navigation" data-title="Where to go to learn more">
<div>
<ul>
<li>
Want to delve into the details and analyse your system?</li>
<li>
Want to explore our framework by example?</li>
<li>
Want to see how this helps us understand programming systems?</li>
<li>
Read about our motivation, methodology and evaluation?</li>
<li>
Want to the Technical dimensions welcome page?</li>
</ul>
</div>
</section>
<section data-file="index" data-id="matrix-intro" data-title="Summary matrix of systems and dimensions">

<p>The matrix shows the differences between <a href="#top=systems,intro;left=systems,index;footer=index,navigation">good old programming systems</a>
along the dimensions identified by our framework. For conciseness, the table shows only one
row for each cluster of dimensions, which consists of multiple separate dimensions each.</p>
<p>The header colors are used to mark systems that are similar (in an informal sense)
for a given dimension. Icons indicate a speficic characteristics and should help you
find connections between systems. You can click on the header to go to a relevant
paper section, but note that not all cases are discussed in the paper.</p>
</section>
<section data-class="matrix" data-file="index" data-id="matrix-body" data-title="Detailed matrix of systems and dimensions">

<h2>Select systems and dimensions to compare in the table</h2>

<div>
<div>

<p><label>LISP machines</label><label>Smalltalk</label><label>UNIX</label><label>Spreadsheets</label><label>Web platform</label><label>Hypercard</label><label>Boxer</label><label>Notebooks</label><label>Haskell</label>
</p></div>
<div>

<p><label>Interaction</label><label>Notation</label><label>Conceptual structure</label><label>Customizability</label><label>Complexity</label><label>Errors</label><label>Adoptability</label>
</p></div>
</div>
</section>
<section data-class="bibliography" data-file="paper" data-id="references" data-title="Paper">

<ol>
<li><span><span>1</span></span><a name="DotCom" id="DotCom"> Ankerson, Megan Sapnar. 2018. <em>Dot-Com Design: The Rise of a Usable,Social, Commercial Web</em>. NYU Press.</a></li>
<li><span><span>2</span></span><a name="OpenAuthorial" id="OpenAuthorial"> Basman, Antranig, Clayton Lewis, and Colin Clark. 2018. “The OpenAuthorial Principle: Supporting Networks of Authors in CreatingExternalisable Designs.” In <em>Proceedings of the 2018 ACM SIGPLANInternational Symposium on New Ideas, New Paradigms, and Reflections onProgramming and Software</em>, 29–43.</a></li>
<li><span><span>3</span></span><a name="Externalize" id="Externalize"> Basman, Antranig, L. Church, C. Klokmose, and Colin B. D. Clark. 2016.“Software and How It Lives on: Embedding Live Programs in the WorldAround Them.” In <em>PPIG</em>.</a></li>
<li><span><span>4</span></span><a name="NotYetCraft" id="NotYetCraft"> Basman, Antranig. 2016. “Building Software Is Not (yet) a Craft.” In<em>Proceedings of the 27th Annual Workshop of the Psychology ofProgramming Interest Group, PPIG 2016, Cambridge, UK, September 7-10,2016</em>, edited by Luke Church, 32. Psychology of Programming InterestGroup. </a><a href="http://ppig.org/library/paper/building-software-not-yet-craft">http://ppig.org/library/paper/building-software-not-yet-craft</a>.</li>
<li><span><span>5</span></span><a name="Infusion" id="Infusion"> Basman, Antranig. 2021. “Infusion Framework and Components.” 2021.</a><a href="https://fluidproject.org/infusion.html">https://fluidproject.org/infusion.html</a>.</li>
<li><span><span>6</span></span><a name="APIdesign" id="APIdesign"> Bloch, Joshua. 2007. “How to Design a Good API and Why It Matters.”2007.</a><a href="http://www.cs.bc.edu/~muller/teaching/cs102/s06/lib/pdf/api-design">http://www.cs.bc.edu/~muller/teaching/cs102/s06/lib/pdf/api-design</a>.</li>
<li><span><span>7</span></span><a name="Varv" id="Varv"> Borowski, Marcel, Luke Murray, Rolf Bagge, Janus Bager Kristensen,Arvind Satyanarayan, and Clemens Nylandsted Klokmose. 2022. “Varv:Reprogrammable Interactive Software as a Declarative Data Structure.” In<em>CHI Conference on Human Factors in Computing Systems</em>. CHI ’22. NewYork, NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/3491102.3502064">https://doi.org/10.1145/3491102.3502064</a>.</li>
<li><span><span>8</span></span><a name="brooks95aristo" id="brooks95aristo"> Brooks, FP. 1995. “Aristocracy, Democracy and System Design.” In <em>TheMythical Man Month: Essays on Software Engineering</em>. Addison-Wesley.</a></li>
<li><span><span>9</span></span><a name="MMM" id="MMM"> Brooks, Frederick P. 1978. <em>The Mythical Man-Month: Essays on Softw</em>.1st ed. USA: Addison-Wesley Longman Publishing Co., Inc.</a></li>
<li><span><span>10</span></span><a name="Chang" id="Chang"> Chang, Hasok. 2004. <em>Inventing Temperature: Measurement and ScientificProgress</em>. Oxford: Oxford University Press.</a></li>
<li><span><span>11</span></span><a name="ChaosMonkey" id="ChaosMonkey"> Chang, Michael Alan, Bredan Tschaen, Theophilus Benson, and Laurent Vanbever. 2015a. “Chaos Monkey: Increasing SDN Reliability ThroughSystematic Network Destruction.” In <em>Proceedings of the 2015 ACMConference on Special Interest Group on Data Communication</em>, 371–72.SIGCOMM ’15. New York, NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/2785956.2790038">https://doi.org/10.1145/2785956.2790038</a>.</li>
<li><span><span>12</span></span><a name="10.1145/2829988.2790038" id="10.1145/2829988.2790038"> Chang, Michael Alan, Bredan Tschaen, Theophilus Benson, and Laurent Vanbever. 2015b. “Chaos Monkey: Increasing SDN Reliability Through SystematicNetwork Destruction.” <em>SIGCOMM Comput. Commun. Rev.</em> 45 (4): 371–72.</a><a href="https://doi.org/10.1145/2829988.2790038">https://doi.org/10.1145/2829988.2790038</a>.</li>
<li><span><span>13</span></span><a name="DarkErrors" id="DarkErrors"> Chisa, Ellen. 2020. “Introduction: Error Rail and Match with <code>DB::get</code>.”2020. </a><a href="https://youtu.be/NRMmy9ZzA-o">https://youtu.be/NRMmy9ZzA-o</a>.</li>
<li><span><span>14</span></span><a name="CodaWeb" id="CodaWeb"> Coda. 2022. “Coda: The Doc That Brings It All Together.”</a><a href="https://coda.io">https://coda.io</a>.</li>
<li><span><span>15</span></span><a name="WhatIsSuccess" id="WhatIsSuccess"> Czaplicki, Evan. 2018. 2018.</a><a href="https://www.youtube.com/watch?v=uGlzRt-FYto">https://www.youtube.com/watch?v=uGlzRt-FYto</a>.</li>
<li><span><span>16</span></span><a name="EvProgSys" id="EvProgSys"> Edwards, Jonathan, Stephen Kell, Tomas Petricek, and Luke Church. 2019.“Evaluating Programming Systems Design.” In <em>Proceedings of 30th AnnualWorkshop of Psychology of Programming Interest Group</em>. PPIG 2019.Newcastle, UK.</a></li>
<li><span><span>17</span></span><a name="10.1145/1094811.1094851" id="10.1145/1094811.1094851"> Edwards, Jonathan. 2005a. “Subtext: Uncovering the Simplicity ofProgramming.” In <em>Proceedings of the 20th Annual ACM SIGPLAN Conferenceon Object-Oriented Programming, Systems, Languages, and Applications</em>,505–18. OOPSLA ’05. New York, NY, USA: Association for ComputingMachinery. </a><a href="https://doi.org/10.1145/1094811.1094851">https://doi.org/10.1145/1094811.1094851</a>.</li>
<li><span><span>18</span></span><a name="Subtext" id="Subtext"> Edwards, Jonathan. 2005b. “Subtext: Uncovering the Simplicity of Programming.”<em>SIGPLAN Not.</em> 40 (10): 505–18.</a><a href="https://doi.org/10.1145/1103845.1094851">https://doi.org/10.1145/1103845.1094851</a>.</li>
<li><span><span>19</span></span><a name="ProgProgLang" id="ProgProgLang"> Felleisen, Matthias, Robert Bruce Findler, Matthew Flatt, ShriramKrishnamurthi, Eli Barzilay, Jay McCarthy, and Sam Tobin-Hochstadt.2018. “A Programmable Programming Language.” <em>Commun. ACM</em> 61 (3):62–71. </a><a href="https://doi.org/10.1145/3127323">https://doi.org/10.1145/3127323</a>.</li>
<li><span><span>20</span></span><a name="Tyranny" id="Tyranny"> Feyerabend, Paul. 2011. The Tyranny of Science, Cambridge: Polity Press. ISBN 0745651895</a></li>
<li><span><span>21</span></span><a name="MalfunctioningSW" id="MalfunctioningSW"> Floridi, Luciano, Nir Fresco, and Giuseppe Primiero. 2015. “OnMalfunctioning Software.” <em>Synthese</em> 192 (4): 1199–1220.</a></li>
<li><span><span>22</span></span><a name="LispIntro" id="LispIntro"> Foderaro, John. 1991. “LISP: Introduction.” <em>Commun. ACM</em> 34 (9): 27.</a><a href="https://doi.org/10.1145/114669.114670">https://doi.org/10.1145/114669.114670</a>.</li>
<li><span><span>23</span></span><a name="DSLs" id="DSLs"> Fowler, Martin. 2010. <em>Domain-Specific Languages</em>. Pearson Education.</a></li>
<li><span><span>24</span></span><a name="Miscomputation" id="Miscomputation"> Fresco, Nir, and Giuseppe Primiero. 2013. “Miscomputation.” <em>Philosophy&amp; Technology</em> 26 (3): 253–72.</a></li>
<li><span><span>25</span></span><a name="FullBrain" id="FullBrain"> Fry, Christopher. 1997. “Programming on an Already Full Brain.” <em>Commun.ACM</em> 40 (4): 55–64. </a><a href="https://doi.org/10.1145/248448.248459">https://doi.org/10.1145/248448.248459</a>.</li>
<li><span><span>26</span></span><a name="SwStudies" id="SwStudies"> Fuller, Matthew et al. 2008. <em>Software Studies: A Lexicon</em>. Mit Press.</a></li>
<li><span><span>27</span></span><a name="WIB" id="WIB"> Gabriel, Richard P. 1991. “Worse Is Better.” 1991.</a><a href="https://www.dreamsongs.com/WorseIsBetter.html">https://www.dreamsongs.com/WorseIsBetter.html</a>.</li>
<li><span><span>28</span></span><a name="DesignedAsDesigner" id="DesignedAsDesigner"> Gabriel, Richard P. 2008. “Designed as Designer.” In <em>Proceedings of the 23rd ACMSIGPLAN Conference on Object-Oriented Programming Systems Languages andApplications</em>, 617–32. OOPSLA ’08. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/1449764.1449813">https://doi.org/10.1145/1449764.1449813</a>.</li>
<li><span><span>29</span></span><a name="PLrev" id="PLrev"> Gabriel, Richard P. 2012. “The Structure of a Programming Language Revolution.” In<em>Proceedings of the ACM International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software</em>, 195–214.Onward! 2012. New York, NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/2384592.2384611">https://doi.org/10.1145/2384592.2384611</a>.</li>
<li><span><span>30</span></span><a name="DesPats" id="DesPats"> Gamma, Erich, Richard Helm, Ralph E. Johnson, and John Vlissides. 1995.<em>Design Patterns: Elements of Reusable Object-Oriented Software</em>.Reading, Mass: Addison-Wesley.</a></li>
<li><span><span>31</span></span><a name="GlideWeb" id="GlideWeb"> Glide. 2022. “Glide: Create Apps and Websites Without Code.”</a><a href="https://www.glideapps.com">https://www.glideapps.com</a>.</li>
<li><span><span>32</span></span><a name="ExceptionHandling" id="ExceptionHandling"> Goodenough, John B. 1975. “Exception Handling: Issues and a ProposedNotation.” <em>Commun. ACM</em> 18 (12): 683–96.</a><a href="https://doi.org/10.1145/361227.361230">https://doi.org/10.1145/361227.361230</a>.</li>
<li><span><span>33</span></span><a name="Java" id="Java"> Gosling, James, Bill Joy, Guy Steele, and Gilad Bracha. 2000. <em>The JavaLanguage Specification</em>. Addison-Wesley Professional.</a></li>
<li><span><span>34</span></span><a name="VisiCalc" id="VisiCalc"> Grad, Burton. 2007. “The Creation and the Demise of VisiCalc.” <em>IEEEAnnals of the History of Computing</em> 29 (3): 20–31.</a><a href="https://doi.org/10.1109/MAHC.2007.4338439">https://doi.org/10.1109/MAHC.2007.4338439</a>.</li>
<li><span><span>35</span></span><a name="CogDims" id="CogDims"> Green, T. R. G., and M. Petre. 1996. “Usability Analysis of VisualProgramming Environments: A ‘Cognitive Dimensions’ Framework.” <em>JOURNALOF VISUAL LANGUAGES AND COMPUTING</em> 7: 131–74.</a></li>
<li><span><span>36</span></span><a name="PBEExcel" id="PBEExcel"> Gulwani, Sumit, William R Harris, and Rishabh Singh. 2012. “SpreadsheetData Manipulation Using Examples.” <em>Communications of the ACM</em> 55 (8):97–105.</a></li>
<li><span><span>37</span></span><a name="Hancock2003" id="Hancock2003"> Hancock, C., and M. Resnick. 2003. “Real-Time Programming and the BigIdeas of Computational Literacy.” PhD thesis, Massachusetts Institute ofTechnology. </a><a href="https://dspace.mit.edu/handle/1721.1/61549">https://dspace.mit.edu/handle/1721.1/61549</a>.</li>
<li><span><span>38</span></span><a name="SnS" id="SnS"> Hempel, Brian, Justin Lubin, and Ravi Chugh. 2019.“Sketch-n-Sketch: Output-DirectedProgramming for SVG.” In <em>Proceedings of the 32nd Annual ACM Symposiumon User Interface Software and Technology</em>, 281–92. UIST ’19. New York,NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/3332165.3347925">https://doi.org/10.1145/3332165.3347925</a>.</li>
<li><span><span>39</span></span><a name="LIVE20" id="LIVE20"> Hempel, Brian, and Roly Perera. 2020. “LIVE Workshop.” 2020.</a><a href="https://liveprog.org/live-2020/">https://liveprog.org/live-2020/</a>.</li>
<li><span><span>40</span></span><a name="LIVE21" id="LIVE21"> Hempel, Brian, and Sam Lau. 2021. “LIVE Workshop.” 2021.</a><a href="https://liveprog.org/live-2021/">https://liveprog.org/live-2021/</a>.</li>
<li><span><span>41</span></span><a name="SelfSustaining2010" id="SelfSustaining2010"> Hirschfeld, Robert, Hidehiko Masuhara, and Kim Rose, eds. 2010.<em>Workshop on Self-Sustaining Systems, S3 2010, Tokyo, Japan, September27-28, 2010</em>. ACM. </a><a href="https://doi.org/10.1145/1942793">https://doi.org/10.1145/1942793</a>.</li>
<li><span><span>42</span></span><a name="SelfSustaining2008" id="SelfSustaining2008"> Hirschfeld, Robert, and Kim Rose, eds. 2008. <em>Self-Sustaining Systems,First Workshop, S3 2008, Potsdam, Germany, May 15-16, 2008, RevisedSelected Papers</em>. Vol. 5146. Lecture Notes in Computer Science.Springer. </a><a href="https://doi.org/10.1007/978-3-540-89275-5">https://doi.org/10.1007/978-3-540-89275-5</a>.</li>
<li><span><span>43</span></span><a name="STdesign" id="STdesign"> Ingalls, Daniel. 1981. “Design Principles Behind Smalltalk.” 1981.</a><a href="https://archive.org/details/byte-magazine-1981-08/page/n299/mode/2up">https://archive.org/details/byte-magazine-1981-08/page/n299/mode/2up</a>.</li>
<li><span><span>44</span></span><a name="PersonalDynMedia" id="PersonalDynMedia"> Kay, A., and A. Goldberg. 1977. “Personal Dynamic Media.” <em>Computer</em> 10(3): 31–41. </a><a href="https://doi.org/10.1109/C-M.1977.217672">https://doi.org/10.1109/C-M.1977.217672</a>.</li>
<li><span><span>45</span></span><a name="Mythical" id="Mythical"> Kell, Stephen. 2009. “The Mythical Matched Modules: Overcoming theTyranny of Inflexible Software Construction.” In <em>OOPSLA Companion</em>.</a></li>
<li><span><span>46</span></span><a name="KellOS" id="KellOS"> Kell, Stephen. 2013. “The Operating System: Should There Be One?” In <em>Proceedingsof the Seventh Workshop on Programming Languages and Operating Systems</em>.PLOS ’13. New York, NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/2525528.2525534">https://doi.org/10.1145/2525528.2525534</a>.</li>
<li><span><span>47</span></span><a name="KellComm" id="KellComm"> Kell, Stephen. 2017. “Some Were Meant for C: The Endurance of an UnmanageableLanguage.” In <em>Proceedings of the 2017 ACM SIGPLAN InternationalSymposium on New Ideas, New Paradigms, and Reflections on Programmingand Software</em>, 229–45. Onward! 2017. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/3133850.3133867">https://doi.org/10.1145/3133850.3133867</a>.</li>
<li><span><span>48</span></span><a name="AspectJ" id="AspectJ"> Kiczales, Gregor, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm,and William G. Griswold. 2001. “An Overview of AspectJ.” In <em>ECOOP2001 - Object-Oriented Programming, 15th European Conference, Budapest,Hungary, June 18-22, 2001, Proceedings</em>, edited by Jørgen LindskovKnudsen, 2072:327–53. Lecture Notes in Computer Science. Springer.</a><a href="https://doi.org/10.1007/3-540-45337-7\_18"></a><a href="https://doi.org/10.1007/3-540-45337-7\\18">https://doi.org/10.1007/3-540-45337-7\\18</a>.</li>
<li><span><span>49</span></span><a name="PaperTools" id="PaperTools"> Klein, Ursula. 2003. <em>Experiments, Models, Paper Tools: Cultures ofOrganic Chemistry in the Nineteenth Century</em>. Stanford, CA: StanfordUniversity Press. </a><a href="http://www.sup.org/books/title/?id=1917">http://www.sup.org/books/title/?id=1917</a>.</li>
<li><span><span>50</span></span><a name="Webstrates" id="Webstrates"> Klokmose, Clemens N., James R. Eagan, Siemen Baader, Wendy Mackay, andMichel Beaudouin-Lafon. 2015. “Webstrates: Shareable Dynamic Media.” In<em>Proceedings of the 28th Annual ACM Symposium on User Interface Software&amp; Technology</em>, 280–90. UIST ’15. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/2807442.2807446">https://doi.org/10.1145/2807442.2807446</a>.</li>
<li><span><span>51</span></span><a name="Jupyter" id="Jupyter"> Kluyver, Thomas, Benjamin Ragan-Kelley, Fernando Pérez, Brian Granger,Matthias Bussonnier, Jonathan Frederic, Kyle Kelley, et al. n.d.“Jupyter Notebooks—a Publishing Format for Reproducible ComputationalWorkflows.” <em>Positioning and Power in Academic Publishing: Players,Agents and Agendas</em>, 87.</a></li>
<li><span><span>52</span></span><a name="LiterateProg" id="LiterateProg"> Knuth, Donald Ervin. 1984. “Literate Programming.” <em>The ComputerJournal</em> 27 (2): 97–111.</a></li>
<li><span><span>53</span></span><a name="LabView" id="LabView"> Kodosky, Jeffrey. 2020. “LabVIEW.” <em>Proc. ACM Program. Lang.</em> 4 (HOPL).</a><a href="https://doi.org/10.1145/3386328">https://doi.org/10.1145/3386328</a>.</li>
<li><span><span>54</span></span><a name="Kuhn" id="Kuhn"> Kuhn, Thomas S. 1970. University of Chicago Press.</a></li>
<li><span><span>55</span></span><a href="https://uist.acm.org/uist2021/author-guide.html">https://uist.acm.org/uist2021/author-guide.html</a>.</li>
<li><span><span>56</span></span><a name="SPEPrograms" id="SPEPrograms"> Lehman, Meir M. 1980. “Programs, Life Cycles, and Laws of SoftwareEvolution.” <em>Proceedings of the IEEE</em> 68 (9): 1060–76.</a></li>
<li><span><span>57</span></span><a name="Hackers" id="Hackers"> Levy, Steven. 1984. <em>Hackers: Heroes of the Computer Revolution</em>. USA:Doubleday.</a></li>
<li><span><span>58</span></span><a name="PBE" id="PBE"> Lieberman, H. 2001. <em>Your Wish Is My Command:Programming by Example</em>. Morgan Kaufmann.</a></li>
<li><span><span>59</span></span><a name="Wildcard" id="Wildcard"> Litt, Geoffrey, Daniel Jackson, Tyler Millis, and Jessica Quaye. 2020.“End-User Software Customization by Direct Manipulation of TabularData.” In <em>Proceedings of the 2020 ACM SIGPLAN International Symposiumon New Ideas, New Paradigms, and Reflections on Programming andSoftware</em>, 18–33. Onward! 2020. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/3426428.3426914">https://doi.org/10.1145/3426428.3426914</a>.</li>
<li><span><span>60</span></span><a name="GHC" id="GHC"> Marlow, Simon, and Simon Peyton-Jones. 2012. <em>The Glasgow HaskellCompiler</em>. Edited by A. Brown and G. Wilson. The Architecture of OpenSource Applications. CreativeCommons. </a><a href="http://www.aosabook.org">http://www.aosabook.org</a>.</li>
<li><span><span>61</span></span><a name="LISP15" id="LISP15"> McCarthy, John. 1962. <em>LISP 1.5 Programmer’s Manual</em>. The MIT Press.</a></li>
<li><span><span>62</span></span><a name="SocioPLT" id="SocioPLT"> Meyerovich, Leo A., and Ariel S. Rabkin. 2012. “Socio-PLT: Principlesfor Programming Language Adoption.” In <em>Proceedings of the ACMInternational Symposium on New Ideas, New Paradigms, and Reflections onProgramming and Software</em>, 39–54. Onward! 2012. New York, NY, USA:Association for Computing Machinery.</a><a href="https://doi.org/10.1145/2384592.2384597">https://doi.org/10.1145/2384592.2384597</a>.</li>
<li><span><span>63</span></span><a name="HyperCard" id="HyperCard"> Michel, Stephen L. 1989. <em>Hypercard: The Complete Reference</em>. Berkeley:Osborne McGraw-Hill.</a></li>
<li><span><span>64</span></span><a name="LSP" id="LSP"> Microsoft. 2022. “Language Server Protocol.”</a><a href="https://microsoft.github.io/language-server-protocol/">https://microsoft.github.io/language-server-protocol/</a>.</li>
<li><span><span>65</span></span><a name="Antifragile" id="Antifragile"> Monperrus, Martin. 2017. “Principles of Antifragile Software.” In<em>Companion to the First International Conference on the Art, Science andEngineering of Programming</em>. Programming ’17. New York, NY, USA:Association for Computing Machinery.</a><a href="https://doi.org/10.1145/3079368.3079412">https://doi.org/10.1145/3079368.3079412</a>.</li>
<li><span><span>66</span></span><a name="TedNelson" id="TedNelson"> Nelson, T. H. 1965. “Complex Information Processing: A File Structurefor the Complex, the Changing and the Indeterminate.” In <em>Proceedings ofthe 1965 20th National Conference</em>, 84–100. ACM ’65. New York, NY, USA:Association for Computing Machinery.</a><a href="https://doi.org/10.1145/800197.806036">https://doi.org/10.1145/800197.806036</a>.</li>
<li><span><span>67</span></span><a name="PoMoProNotes" id="PoMoProNotes"> Noble, James, and Robert Biddle. 2004. “Notes on Notes on PostmodernProgramming.” <em>SIGPLAN Not.</em> 39 (12): 40–56.</a><a href="https://doi.org/10.1145/1052883.1052890">https://doi.org/10.1145/1052883.1052890</a>.</li>
<li><span><span>68</span></span><a name="Norman" id="Norman"> Norman, Donald A. 2002. <em>The Design of Everyday Things</em>. USA: BasicBooks, Inc.</a></li>
<li><span><span>69</span></span><a name="EvUISR" id="EvUISR"> Olsen, Dan R. 2007. “Evaluating User Interface Systems Research.” In<em>Proceedings of the 20th Annual ACM Symposium on User Interface Softwareand Technology</em>, 251–58. UIST ’07. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/1294211.1294256">https://doi.org/10.1145/1294211.1294256</a>.</li>
<li><span><span>70</span></span><a name="Hazel" id="Hazel"> Omar, Cyrus, Ian Voysey, Michael Hilton, Joshua Sunshine, Claire LeGoues, Jonathan Aldrich, and Matthew A. Hammer. 2017.“Toward Semantic Foundations for ProgramEditors.” In <em>2nd Summit on Advances in Programming Languages(SNAPL 2017)</em>, edited by Benjamin S. Lerner, Rastislav Bodík, andShriram Krishnamurthi, 71:11:1–12. Leibniz International Proceedings inInformatics (LIPIcs). Dagstuhl, Germany: SchlossDagstuhl–Leibniz-Zentrum fuer Informatik.</a><a href="https://doi.org/10.4230/LIPIcs.SNAPL.2017.11">https://doi.org/10.4230/LIPIcs.SNAPL.2017.11</a>.</li>
<li><span><span>71</span></span><a name="Euphemism" id="Euphemism"> Parnas, David Lorge. 1985. “Software Aspects of Strategic DefenseSystems.” </a><a href="http://web.stanford.edu/class/cs99r/readings/parnas1.pdf">http://web.stanford.edu/class/cs99r/readings/parnas1.pdf</a>.</li>
<li><span><span>72</span></span><a name="NakedObjects" id="NakedObjects"> Pawson, Richard. 2004. “Naked Objects.” PhD thesis, Trinity College,University of Dublin.</a></li>
<li><span><span>73</span></span><a name="Alg58" id="Alg58"> Perlis, A. J., and K. Samelson. 1958. “Preliminary Report: InternationalAlgebraic Language.” <em>Commun. ACM</em> 1 (12): 8–22.</a><a href="https://doi.org/10.1145/377924.594925">https://doi.org/10.1145/377924.594925</a>.</li>
<li><span><span>74</span></span><a name="Irony" id="Irony"> Petit Emmanuel J. 2013. Irony: Irony or, the Self-Critical Opacity of Postmodern Architecture. Yale University Press</a></li>
<li><span><span>75</span></span><a name="ComplementaryBasic" id="ComplementaryBasic"> Petricek, Tomas, and Joel Jakubovic. 2021. “Complementary Science ofInteractive Programming Systems.” In <em>History and Philosophy ofComputing</em>.</a></li>
<li><span><span>76</span></span><a name="LivingWithErrors" id="LivingWithErrors"> Petricek, Tomas. 2017. “Miscomputation in Software: Learning to Livewith Errors.” <em>Art Sci. Eng. Program.</em> 1 (2): 14.</a><a href="https://doi.org/10.22152/programming-journal.org/2017/1/14">https://doi.org/10.22152/programming-journal.org/2017/1/14</a>.</li>
<li><span><span>77</span></span><a name="COLAs" id="COLAs"> Piumarta, Ian. 2006. “Accessible Language-Based Environments ofRecursive Theories.” 2006.</a><a href="http://www.vpri.org/pdf/rn2006001a_colaswp.pdf">http://www.vpri.org/pdf/rn2006001a_colaswp.pdf</a>.</li>
<li><span><span>78</span></span><a name="Cathedral" id="Cathedral"> Raymond, Eric S., and Bob Young. 2001. <em>The Cathedral &amp; the Bazaar:Musings on Linux and Open Source by an Accidental Revolutionary</em>.O’Reilly.</a></li>
<li><span><span>79</span></span><a name="HumanError" id="HumanError"> Reason, James. 1990. <em>Human Error</em>. Cambridge university press.</a></li>
<li><span><span>80</span></span><a name="SweImpact" id="SweImpact"> Ryder, Barbara G., Mary Lou Soffa, and Margaret Burnett. 2005. “TheImpact of Software Engineering Research on Modern ProgrammingLanguages.” <em>ACM Trans. Softw. Eng. Methodol.</em> 14 (4): 431–77.</a><a href="https://doi.org/10.1145/1101815.1101818">https://doi.org/10.1145/1101815.1101818</a>.</li>
<li><span><span>81</span></span><a name="DirectManip" id="DirectManip"> Shneiderman. 1983. “Direct Manipulation: A Step Beyond ProgrammingLanguages.” <em>Computer</em> 16 (8): 57–69.</a><a href="https://doi.org/10.1109/MC.1983.1654471">https://doi.org/10.1109/MC.1983.1654471</a>.</li>
<li><span><span>82</span></span><a name="MemMod" id="MemMod"> Sitaker, Kragen Javier. 2016. “The Memory Models That UnderlieProgramming Languages.” 2016.</a><a href="http://canonical.org/~kragen/memory-models/">http://canonical.org/~kragen/memory-models/</a>.</li>
<li><span><span>83</span></span><a name="NextGen" id="NextGen"> Smaragdakis, Yannis. 2019. “Next-Paradigm Programming Languages: WhatWill They Look Like and What Changes Will They Bring?” In <em>Proceedingsof the 2019 ACM SIGPLAN International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software</em>, 187–97. Onward!2019. New York, NY, USA: Association for Computing Machinery.</a><a href="https://doi.org/10.1145/3359591.3359739">https://doi.org/10.1145/3359591.3359739</a>.</li>
<li><span><span>84</span></span><a name="PRinPLs" id="PRinPLs"> Smith, Brian Cantwell. 1982. “Procedural Reflection in ProgrammingLanguages.” PhD thesis, Massachusetts Institute of Technology.</a><a href="https://dspace.mit.edu/handle/1721.1/15961">https://dspace.mit.edu/handle/1721.1/15961</a>.</li>
<li><span><span>85</span></span><a name="Pygmalion" id="Pygmalion"> Smith, D. C. 1975. “Pygmalion: A Creative Programming Environment.” In.</a></li>
<li><span><span>86</span></span><a name="CommonLisp" id="CommonLisp"> Steele, G., and S. E. Fahlman. 1990. <em>Common LISP: The Language</em>. HPTechnologies. Elsevier Science.</a><a href="https://books.google.cz/books?id=FYoOIWuoXUIC">https://books.google.cz/books?id=FYoOIWuoXUIC</a>.</li>
<li><span><span>87</span></span><a name="LispEvolve" id="LispEvolve"> Steele, Guy L., and Richard P. Gabriel. 1993. “The Evolution of Lisp.”In <em>The Second ACM SIGPLAN Conference on History of ProgrammingLanguages</em>, 231–70. HOPL-II. New York, NY, USA: Association forComputing Machinery. </a><a href="https://doi.org/10.1145/154766.155373">https://doi.org/10.1145/154766.155373</a>.</li>
<li><span><span>88</span></span><a name="Liveness" id="Liveness"> Tanimoto, Steven L. 2013. “A Perspective on the Evolution of LiveProgramming.” In <em>Proceedings of the 1st International Workshop on LiveProgramming</em>, 31–34. LIVE ’13. San Francisco, California: IEEE Press.</a></li>
<li><span><span>89</span></span><a name="TcherDiss" id="TcherDiss"> Tchernavskij, Philip. 2019. “Designing and Programming MalleableSoftware.” PhD thesis, Université Paris-Saclay, École doctorale nº580Sciences et Technologies de l’Information et de la Communication (STIC).</a></li>
<li><span><span>90</span></span><a name="Pilot" id="Pilot"> Teitelman, Warren. 1966. “PILOT: A Step Toward Man-Computer Symbiosis.”PhD thesis, MIT.</a></li>
<li><span><span>91</span></span><a name="Interlisp" id="Interlisp"> Teitelman, Warren. 1974. “Interlisp Reference Manual.” Xerox PARC. </a><a href="http://www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_1974.pdf">http://www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_1974.pdf</a></li>
<li><span><span>92</span></span><a name="Live13" id="Live13"> Ungar, David, and Randall B. Smith. 2013. “The Thing on the Screen IsSupposed to Be the Actual Thing.” 2013.</a><a href="http://davidungar.net/Live2013/Live_2013.html">http://davidungar.net/Live2013/Live_2013.html</a>.</li>
<li><span><span>93</span></span><a name="BretVictor" id="BretVictor"> Victor, Bret. 2012. “Learnable Programming.” 2012.</a><a href="http://worrydream.com/#!/LearnableProgramming">http://worrydream.com/#!/LearnableProgramming</a>.</li>
<li><span><span>94</span></span><a name="Perl" id="Perl"> Wall, Larry. 1999. “Perl, the First Postmodern Computer Language.” 1999.</a><a href="http://www.wall.org//~larry/pm.html">http://www.wall.org//~larry/pm.html</a>.</li>
<li><span><span>95</span></span><a name="LispCurse" id="LispCurse"> Winestock, Rudolf. 2011. “The Lisp Curse.” 2011.</a><a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">http://www.winestockwebdesign.com/Essays/Lisp_Curse.html</a>.</li>
<li><span><span>96</span></span><a name="Mathematica" id="Mathematica"> Wolfram, Stephen. 1991. <em>Mathematica: A System for Doing Mathematics byComputer (2nd Ed.)</em>. USA: Addison Wesley Longman Publishing Co., Inc.</a></li>
<li><span><span>97</span></span><a name="VisiCalc2" id="VisiCalc2"> Zynda, Melissa Rodriguez. 2013. “The First Killer App: A History ofSpreadsheets.” <em>Interactions</em> 20 (5): 68–72.</a><a href="https://doi.org/10.1145/2509224">https://doi.org/10.1145/2509224</a>.</li>
<li><span><span>98</span></span><a name="Eclipse" id="Eclipse"> desRivieres, J., and J. Wiegand. 2004. “Eclipse: A Platform forIntegrating Development Tools.” <em>IBM Systems Journal</em> 43 (2): 371–83.</a><a href="https://doi.org/10.1147/sj.432.0371">https://doi.org/10.1147/sj.432.0371</a>.</li>
<li><span><span>99</span></span><a name="Boxer" id="Boxer"> diSessa, A. A, and H. Abelson. 1986. “Boxer: A ReconstructibleComputational Medium.” <em>Commun. ACM</em> 29 (9): 859–68.</a><a href="https://doi.org/10.1145/6592.6595">https://doi.org/10.1145/6592.6595</a>.</li>
<li><span><span>100</span></span><a name="BoxerDesign" id="BoxerDesign"> diSessa, Andrea A. 1985. “A Principled Design for an IntegratedComputational Environment.” <em>Human–Computer Interaction</em> 1 (1): 1–47.</a><a href="https://doi.org/10.1207/s15327051hci0101\_1"></a><a href="https://doi.org/10.1207/s15327051hci0101\\1">https://doi.org/10.1207/s15327051hci0101\\1</a>.</li>
<li><span><span>101</span></span><a name="ReplitWeb" id="ReplitWeb"> repl.it. 2022. “Replit: The Collaborative Browser-Based IDE.”</a><a href="https://replit.com">https://replit.com</a>.</li>
<li><span><span>102</span></span><a name="DarkWeb" id="DarkWeb"> team, Dark language. 2022. “Dark Lang.” </a><a href="https://darklang.com">https://darklang.com</a>.</li>
</ol>
</section>
<section data-file="paper" data-id="index" data-title="Technical dimensions of programming systems">

<h2>Abstract</h2>
<p>Programming requires much more than just writing code in a programming language. It is usually done in the context of a stateful environment, by interacting with a system through a graphical user interface. Yet, this wide space of possibilities lacks a common structure for navigation. Work on programming systems fails to form a coherent body of research, making it hard to improve on past work and advance the state of the art.</p>
<p>In computer science, much has been said and done to allow comparison of <em>programming languages</em>, yet no similar theory exists for <em>programming systems</em>; we believe that programming systems deserve a theory too. We present a framework of <em>technical dimensions</em> which capture the underlying characteristics of programming systems and provide a means for conceptualizing and comparing them.</p>
<p>We identify technical dimensions by examining past influential programming systems and reviewing their design principles, technical capabilities, and styles of user interaction. Technical dimensions capture characteristics that may be studied, compared and advanced independently. This makes it possible to talk about programming systems in a way that can be shared and constructively debated rather than relying solely on personal impressions.</p>
<p>Our framework is derived using a qualitative analysis of past programming systems. We outline two concrete ways of using our framework. First, we show how it can analyze a recently developed novel programming system. Then, we use it to identify an interesting unexplored point in the design space of programming systems.</p>
<p>Much research effort focuses on building programming systems that are easier to use, accessible to non-experts, moldable and/or powerful, but such efforts are disconnected. They are informal, guided by the personal vision of their authors and thus are only evaluable and comparable on the basis of individual experience using them. By providing foundations for more systematic research, we can help programming systems researchers to stand, at last, on the shoulders of giants.</p>
</section>
<section data-class="paper-anchor nobullet" data-file="paper" data-id="toc" data-title="Table of contents">

<h2>Introduction</h2>
<ul>
<li><a href="#*=.;right=paper,introduction!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,problem!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,contributions!"><i></i>!</a></li>
</ul>
<h2>Related work</h2>
<ul>
<li><a href="#*=.;right=paper,related-work!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,lang-to-sys!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,prog-sys!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,knonw-chars!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,methodology!"><i></i>!</a></li>
</ul>
<h2>Programming systems</h2>
<ul>
<li><a href="#*=.;right=paper,programming-systems!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,l-type!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,o-type!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,a-type!"><i></i>!</a></li>
</ul>
<h2>Evaluation</h2>
<ul>
<li><a href="#*=.;right=paper,evaluation!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,dark-evaluation!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,dark-dims!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,exploring-the-design-space!"><i></i>!</a></li>
</ul>
<h2>Conclusions</h2>
<ul>
<li><a href="#*=.;right=paper,conclusions!"><i></i>!</a></li>
</ul>
<h2>Appendices</h2>
<ul>
<li><a href="#*=.;right=paper,making-dimensions-quantitative!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,self-sustainability!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,notational-diversity!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,future-work!"><i></i>!</a></li>
</ul>
</section>
<section data-class="doc" data-file="paper" data-id="introduction" data-title="Introduction">
<blockquote>
<p>A systematic presentation removes ideas from the ground that made them grow and arranges them in an artificial pattern.</p>
<p>Paul Feyerabend, <em>The Tyranny of Science</em> <a href="#*=.;right=paper,references" title=" Feyerabend, Paul. 2011. The Tyranny of Science, Cambridge: Polity Press. ISBN 0745651895">20</a></p>
</blockquote>

<blockquote>
<p>Irony is said to allow the artist to continue his creative production while immersed in a sociocultural context of which he is critical.</p>
<p>Emmanuel Petit, <em>Irony; or, the Self-Critical Opacity of Postmodernist Architecture</em> <a href="#*=.;right=paper,references" title=" Petit Emmanuel J. 2013. Irony: Irony or, the Self-Critical Opacity of Postmodern Architecture. Yale University Press">74</a></p>
</blockquote>

<p>Many forms of software have been developed to enable programming. The classic form consists of a <em>programming language</em>, a text editor to enter source code, and a compiler to turn it into an executable program. Instances of this form are differentiated by the syntax and semantics of the language, along with the implementation techniques in the compiler or runtime environment. Since the advent of graphical user interfaces (GUIs), programming languages can be found embedded within graphical environments that increasingly define how programmers work with the language—for instance, by directly supporting debugging or refactoring. Beyond this, the rise of GUIs also permits diverse visual forms of programming, including visual languages and GUI-based end-user programming tools.</p>
<p>This paper advocates a shift of attention from <em>programming languages</em> to the more general notion of &#34;software that enables programming&#34;---in other words, <em>programming systems</em>.</p>
<p><strong>Definition: Programming system.</strong>
<em>A programming system is an integrated and complete set of tools sufficient for creating, modifying, and executing programs. These will include notations for structuring programs and data, facilities for running and debugging programs, and interfaces for performing all of these tasks. Facilities for testing, analysis, packaging, or version control may also be present. Notations include programming languages and interfaces include text editors, but are not limited to these.</em></p>
<p>This notion covers classic programming languages together with their editors, debuggers, compilers, and other tools. Yet it is intentionally broad enough to accommodate image-based programming environments like Smalltalk, operating systems like UNIX, and hypermedia authoring systems like Hypercard, in addition to various other examples we will mention.</p>
</section>
<section data-file="paper" data-id="problem" data-title="The problem">

<p>There is a growing interest in broader forms of <em>programming systems</em>, both in the programming research community and in industry. Researchers are studying topics such as <em>programming experience</em> and <em>live programming</em> that require considering not just the <em>language</em>, but further aspects of a given system. At the same time, commercial companies are building new programming environments like Replit <a href="#*=.;right=paper,references" title=" repl.it. 2022. “Replit: The Collaborative Browser-Based IDE.”https://replit.com.">101</a> or low-code tools like Dark <a href="#*=.;right=paper,references" title=" team, Dark language. 2022. “Dark Lang.” https://darklang.com.">102</a> and Glide. <a href="#*=.;right=paper,references" title=" Glide. 2022. “Glide: Create Apps and Websites Without Code.”https://www.glideapps.com.">31</a> Yet, such topics remain at the sidelines of mainstream programming research. While <em>programming languages</em> are a well-established concept, analysed and compared in a common vocabulary, no similar foundation exists for the wider range of <em>programming systems</em>.</p>
<p>The academic research on programming suffers from this lack of common vocabulary. While we may thoroughly assess programming <em>languages</em>, as soon as we add interaction or graphics into the picture, evaluation beyond subjective &#34;coolness&#34; becomes fraught with difficulty. The same difficulty in the context of user interface systems has been analyzed by Olsen. <a href="#*=.;right=paper,references" title=" Olsen, Dan R. 2007. “Evaluating User Interface Systems Research.” InProceedings of the 20th Annual ACM Symposium on User Interface Softwareand Technology, 251–58. UIST ’07. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/1294211.1294256.">69</a> Moreover, when designing new systems, inspiration is often drawn from the same few standalone sources of ideas. These might be influential past systems like Smalltalk, programmable end-user applications like spreadsheets, or motivational illustrations like those of Bret Victor. <a href="#*=.;right=paper,references" title=" Victor, Bret. 2012. “Learnable Programming.” 2012.http://worrydream.com/#!/LearnableProgramming.">93</a></p>
<p>Instead of forming a solid body of work, the ideas that emerge are difficult to relate to each other. The research methods used to study programming systems lack the rigorous structure of programming language research methods. They tend to rely on singleton examples, which demonstrate their author&#39;s ideas, but are inadequate methods for comparing new ideas with the work of others. This makes it hard to build on top and thereby advance the state of the art.</p>
<p>Studying <em>programming systems</em> is not merely about taking a programming language and looking at the tools that surround it. It presents a <em>paradigm shift</em> to a perspective that is, at least partly, <em>incommensurable</em> with that of languages. When studying programming languages, everything that matters is in the program code; when studying programming systems, everything that matters is in the <em>interaction</em> between the programmer and the system. As documented by Gabriel, <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 2012. “The Structure of a Programming Language Revolution.” InProceedings of the ACM International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software, 195–214.Onward! 2012. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2384592.2384611.">29</a> looking at a <em>system</em> from a <em>language</em> perspective makes it impossible to think about concepts that arise from interaction with a system, but are not reflected in the language. Thus, we must proceed with some caution. As we will see, when we talk about Lisp as a programming system, we mean something very different from a parenthesis-heavy programming language!</p>
</section>
<section data-class="doc" data-file="paper" data-id="contributions" data-title="Contributions">

<p>We propose a common language as an initial step towards a more progressive research on programming systems. Our set of <em>technical dimensions</em> seeks to break down the holistic view of systems along various specific &#34;axes&#34;. The dimensions identify a range of possible design choices, characterized by two extreme points in the design space. They are not quantitative, but they allow comparison by locating systems on a common axis. We do not intend for the extreme points to represent &#34;good&#34; or &#34;bad&#34; designs; we expect any position to be a result of design trade-offs. At this early stage in the life of such a framework, we encourage agreement on descriptions of systems first in order to settle any normative judgements later.</p>
<p><a href="#image=paper,plot-figure0"><img src="https://tomasp.net/techdims/img/paper/plot-figure0.png" alt=""/></a></p>
<p>The set of dimensions can be understood as a map of the design space of programming systems (see diagram). Past and present systems will serve as landmarks, and with enough of them, we may reveal unexplored or overlooked possibilities. So far, the field has not been able to establish a virtuous cycle of feedback; it is hard for practitioners to situate their work in the context of others&#39; so that subsequent work can improve on it. Our aim is to provide foundations for the study of programming systems that would allow such development.</p>
<h2>Main contributions</h2>
<p>The main contributions of this project are organized as follows:</p>
<ol>
<li>In <a href="#*=.;right=programming-systems">Programming systems</a>, we characterize what a programming system is and review landmark programming systems of the past that are used as examples throughout this paper, as well as to delineate our notion of a programming system.</li>
<li>The <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index">Catalogue of technical dimensions</a> presents the dimensions in detail, organised into related clusters: <em>interaction</em>, <em>notation</em>, <em>conceptual structure</em>, <em>customizability</em>, <em>complexity</em>, <em>errors</em>, and <em>adoptability</em>. For each dimension, we give examples that illustrate the range of values along its axis.</li>
<li>In <a href="#*=.;right=evaluation">Evaluation</a>, we sketch two ways of using the technical dimensions framework. We first use it to evaluate a recent interesting programming system Dark and then use it to identify an unexplored point in the design space and envision a potential novel programming system.</li>
</ol>
</section>
<section data-file="paper" data-id="plot-figure0" data-title="The design space of programming systems">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/paper/plot-figure0.png" alt="Programming systems positioned in a common two-dimensional space"/></p>
<p><strong>Programming systems positioned in a common two-dimensional space.</strong>
One 2-dimensional slice of the space of possible systems, examined in more detail in
<a href="#footer=index,navigation;left=paper,toc;right=paper,exploring-the-design-space;top=paper,index">Exploring the design space</a>,
showing a set of example programming systems (or system families) measured against <em>self-sustainability</em> and <em>notational diversity</em>,
revealing an absence of systems with a high degree of both.</p>
<p>The numerical scores on each axis are generated systematically
by a method described in <a href="#footer=index,navigation;left=paper,toc;right=paper,making-dimensions-quantitative;top=paper,index">Making dimensions quantitative</a>.
While these results are plausible, they are not definitive as the method could be developed a lot further in future work
(see <a href="#footer=index,navigation;left=paper,toc;right=paper,future-work;top=paper,index">Remarks and future work</a>).</p>
</blockquote>
</section>
<section data-file="paper" data-id="related-work" data-title="Related work">

<p>While we do have new ideas to propose, part of our contribution is integrating a wide range of <em>existing</em> concepts under a common umbrella. This work is spread out across different domains, but each part connects to programming systems or focuses on a specific characteristic they may have.</p>

</section>
<section data-file="paper" data-id="lang-to-sys" data-title="From languages to systems">

<p>Our approach lies between a narrow focus on programming languages and a broad focus on programming as a socio-political and cultural subject. Our concept of a programming system is technical in scope, although we acknowledge the technical side often has important social implications as in the case of the <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/adoptability,index">Adoptability</a> dimension. This contrasts with the more socio-political focus found in Tchernavskij <a href="#*=.;right=paper,references" title=" Tchernavskij, Philip. 2019. “Designing and Programming MalleableSoftware.” PhD thesis, Université Paris-Saclay, École doctorale nº580Sciences et Technologies de l’Information et de la Communication (STIC).">89</a> or in software studies <a href="#*=.;right=paper,references" title=" Fuller, Matthew et al. 2008. Software Studies: A Lexicon. Mit Press.">26</a>. It overlaps with Kell&#39;s conceptualization of UNIX, Smalltalk, and Operating Systems generally, <a href="#*=.;right=paper,references" title=" Kell, Stephen. 2013. “The Operating System: Should There Be One?” In Proceedingsof the Seventh Workshop on Programming Languages and Operating Systems.PLOS ’13. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2525528.2525534.">46</a> and we have ensured that UNIX has a place in our framework.</p>
<p>The distinction between more narrow <em>programming languages</em> and broader <em>programming systems</em> is more subtle. Richard Gabriel noted an invisible paradigm shift from the study of &#34;systems&#34; to the study of &#34;languages&#34; in computer science, <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 2012. “The Structure of a Programming Language Revolution.” InProceedings of the ACM International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software, 195–214.Onward! 2012. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2384592.2384611.">29</a> and this observation informs our distinction here. One consequence of the change is that a <em>language</em> is often formally specified apart from any specific implementations, while <em>systems</em> resist formal specification and are often <em>defined by</em> an implementation. We recognize programming language implementations as a <em>small region</em> of the space of possible systems, at least as far as interaction and notations might go. Hence we refer to the <em>interactive programming system</em> aspects of languages, such as text editing and command-line workflow.</p>
</section>
<section data-file="paper" data-id="prog-sys" data-title="Programming systems research">

<p>There is renewed interest in programming systems in the form of non-traditional programming tools:</p>
<ul>
<li>Computational notebooks such as Jupyter <a href="#*=.;right=paper,references" title=" Kluyver, Thomas, Benjamin Ragan-Kelley, Fernando Pérez, Brian Granger,Matthias Bussonnier, Jonathan Frederic, Kyle Kelley, et al. n.d.“Jupyter Notebooks—a Publishing Format for Reproducible ComputationalWorkflows.” Positioning and Power in Academic Publishing: Players,Agents and Agendas, 87.">51</a> facilitate data analysis by combining code snippets with text and visual output. They are backed by stateful &#34;kernels&#34; and used interactively.</li>
<li>&#34;Low code&#34; end-user programming systems allow application development (mostly) through a GUI. One example is Coda, <a href="#*=.;right=paper,references" title=" Coda. 2022. “Coda: The Doc That Brings It All Together.”https://coda.io.">14</a> which combines tables, formulas, and scripts to enable non-technical people to build &#34;applications as documents&#34;.</li>
<li>Domain-specific programming systems such as Dark, <a href="#*=.;right=paper,references" title=" team, Dark language. 2022. “Dark Lang.” https://darklang.com.">102</a> which claims a &#34;holistic&#34; programming experience for cloud API services. This includes a language, a direct manipulation editor, and near-instantaneous building and deployment.</li>
<li>Even for general purpose programming with conventional tools, systems like Replit <a href="#*=.;right=paper,references" title=" repl.it. 2022. “Replit: The Collaborative Browser-Based IDE.”https://replit.com.">101</a> have demonstrated the benefits of integrating all needed languages, tools, and user interfaces into a seamless experience, available from the browser, that requires no setup.</li>
</ul>
<p>Research that follows the programming systems perspective can be found in a number of research venues. Those include Human-Computer Interaction conferences such as <a href="https://uist.acm.org/">UIST</a> (ACM Symposium on User Interface Software and Technology) and <a href="https://conferences.computer.org/VLHCC/">VL/HCC</a> (IEEE Symposium on Visual Languages and Human-Centric Computing). However, work in those often emphasizes the user experience over technical description. Programming systems are often presented in workshops such as <a href="https://liveprog.org/">LIVE</a> and <a href="https://2021.programming-conference.org/home/px-2021">PX</a> (Programming eXperience). However, work in those venues is often limited to the authors&#39; individual perspectives and suffers from the aforementioned difficulty of comparing to other systems.</p>
<p>Concrete examples of systems appear throughout the paper. Recent systems which motivated some of our dimensions include Subtext, <a href="#*=.;right=paper,references" title=" Edwards, Jonathan. 2005b. “Subtext: Uncovering the Simplicity of Programming.”SIGPLAN Not. 40 (10): 505–18.https://doi.org/10.1145/1103845.1094851.">18</a> which combines code with its live execution in a single editable representation; Sketch-n-sketch, <a href="#*=.;right=paper,references" title=" Hempel, Brian, Justin Lubin, and Ravi Chugh. 2019.“Sketch-n-Sketch: Output-DirectedProgramming for SVG.” In Proceedings of the 32nd Annual ACM Symposiumon User Interface Software and Technology, 281–92. UIST ’19. New York,NY, USA: Association for Computing Machinery.https://doi.org/10.1145/3332165.3347925.">38</a> which can synthesize code by direct manipulation of its outputs; Hazel, <a href="#*=.;right=paper,references" title=" Omar, Cyrus, Ian Voysey, Michael Hilton, Joshua Sunshine, Claire LeGoues, Jonathan Aldrich, and Matthew A. Hammer. 2017.“Toward Semantic Foundations for ProgramEditors.” In 2nd Summit on Advances in Programming Languages(SNAPL 2017), edited by Benjamin S. Lerner, Rastislav Bodík, andShriram Krishnamurthi, 71:11:1–12. Leibniz International Proceedings inInformatics (LIPIcs). Dagstuhl, Germany: SchlossDagstuhl–Leibniz-Zentrum fuer Informatik.https://doi.org/10.4230/LIPIcs.SNAPL.2017.11.">70</a> a live functional programming environment with typed holes to enable execution of incomplete or ill-typed programs; and Webstrates, <a href="#*=.;right=paper,references" title=" Klokmose, Clemens N., James R. Eagan, Siemen Baader, Wendy Mackay, andMichel Beaudouin-Lafon. 2015. “Webstrates: Shareable Dynamic Media.” InProceedings of the 28th Annual ACM Symposium on User Interface Software&amp; Technology, 280–90. UIST ’15. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/2807442.2807446.">50</a> which extends Web pages with real-time sharing of state.</p>
</section>
<section data-file="paper" data-id="knonw-chars" data-title="Already-known characteristics">

<p>There are several existing projects identifying characteristics of programming systems. Some revolve around a single one, such as levels of liveness, <a href="#*=.;right=paper,references" title=" Tanimoto, Steven L. 2013. “A Perspective on the Evolution of LiveProgramming.” In Proceedings of the 1st International Workshop on LiveProgramming, 31–34. LIVE ’13. San Francisco, California: IEEE Press.">88</a> or plurality and communicativity. <a href="#*=.;right=paper,references" title=" Kell, Stephen. 2017. “Some Were Meant for C: The Endurance of an UnmanageableLanguage.” In Proceedings of the 2017 ACM SIGPLAN InternationalSymposium on New Ideas, New Paradigms, and Reflections on Programmingand Software, 229–45. Onward! 2017. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/3133850.3133867.">47</a> Others propose an entire collection. <em>Memory Models of Programming Languages</em> <a href="#*=.;right=paper,references" title=" Sitaker, Kragen Javier. 2016. “The Memory Models That UnderlieProgramming Languages.” 2016.http://canonical.org/~kragen/memory-models/.">82</a> identifies the &#34;everything is an X&#34; metaphors underlying many programming languages; the <em>Design Principles of Smalltalk</em> <a href="#*=.;right=paper,references" title=" Ingalls, Daniel. 1981. “Design Principles Behind Smalltalk.” 1981.https://archive.org/details/byte-magazine-1981-08/page/n299/mode/2up.">43</a> documents the philosophical goals and dicta used in the design of Smalltalk; the &#34;Gang of Four&#34; <em>Design Patterns</em> <a href="#*=.;right=paper,references" title=" Gamma, Erich, Richard Helm, Ralph E. Johnson, and John Vlissides. 1995.Design Patterns: Elements of Reusable Object-Oriented Software.Reading, Mass: Addison-Wesley.">30</a> catalogues specific implementation tactics; and the <em>Cognitive Dimensions of Notation</em> <a href="#*=.;right=paper,references" title=" Green, T. R. G., and M. Petre. 1996. “Usability Analysis of VisualProgramming Environments: A ‘Cognitive Dimensions’ Framework.” JOURNALOF VISUAL LANGUAGES AND COMPUTING 7: 131–74.">35</a> introduces a common vocabulary for software&#39;s <em>notational surface</em> and for identifying their trade-offs.</p>
<p>The latter two directly influence our proposal. Firstly, the Cognitive Dimensions are a set of qualitative properties which can be used to analyze <em>notations</em>. We are extending this approach to the &#34;rest&#34; of a system, beyond its notation, with <em>Technical</em> Dimensions. Secondly, our individual dimensions naturally fall under larger <em>clusters</em> that we present in a regular format, similar to the presentation of the classic Design Patterns. As for characteristics identified by others, part of our contribution is to integrate them under a common umbrella: the existing concepts of liveness, pluralism, and uniformity metaphors (&#34;everything is an X&#34;) become dimensions in our framework.</p>
</section>
<section data-file="paper" data-id="methodology" data-title="Methodology">

<p>We follow the attitude of <em>Evaluating Programming Systems</em> <a href="#*=.;right=paper,references" title=" Edwards, Jonathan, Stephen Kell, Tomas Petricek, and Luke Church. 2019.“Evaluating Programming Systems Design.” In Proceedings of 30th AnnualWorkshop of Psychology of Programming Interest Group. PPIG 2019.Newcastle, UK.">16</a> in distinguishing our work from HCI methods and empirical evaluation. We are generally concerned with characteristics that are not obviously amenable to statistical analysis (e.g. mining software repositories) or experimental methods like controlled user studies, so numerical quantities are generally not featured.</p>
<p>Similar development seems to be taking place in HCI research focused on user interfaces. The UIST guidelines <a href="#*=.;right=paper,references" title=" Kumar, Ranjitha, and Michael Nebeling. 2021. “UIST 2021 - Author Guide.”2021. https://uist.acm.org/uist2021/author-guide.html.">55</a> instruct authors to evaluate system contributions holistically, and the community has developed heuristics for such evaluation, such as <em>Evaluating User Interface Systems Research</em>. <a href="#*=.;right=paper,references" title=" Olsen, Dan R. 2007. “Evaluating User Interface Systems Research.” InProceedings of the 20th Annual ACM Symposium on User Interface Softwareand Technology, 251–58. UIST ’07. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/1294211.1294256.">69</a> Our set of dimensions offers similar heuristics for identifying interesting aspects of programming systems, though they focus more on underlying technical properties than the surface interface.</p>
<p>Finally, we believe that the aforementioned paradigm shift from programming systems to programming languages has hidden many ideas about programming that are worthwhile recovering and developing further. <a href="#*=.;right=paper,references" title=" Petricek, Tomas, and Joel Jakubovic. 2021. “Complementary Science ofInteractive Programming Systems.” In History and Philosophy ofComputing.">75</a> Thus our approach is related to the idea of <em>complementary science</em> developed by Chang <a href="#*=.;right=paper,references" title=" Chang, Hasok. 2004. Inventing Temperature: Measurement and ScientificProgress. Oxford: Oxford University Press.">10</a> in the context of history and philosophy of science. Chang argues that even in disciplines like physics, superseded or falsified theories may still contain interesting ideas worth documenting. In the field of programming, where past systems are discarded for many reasons besides empirical failure, Chang&#39;s <em>complementary science</em> approach seems particularly suitable.</p>
<h2>Programming systems deserve a theory too!</h2>
<p>In short, while there is a theory for programming languages, programming <em>systems</em> deserve a theory too. It should apply from the small scale of language implementations to the vast scale of operating systems. It should be possible to analyse the common and unique features of different systems, to reveal new possibilities, and to build on past work in an effective manner. In Kuhnian terms, <a href="#*=.;right=paper,references" title=" Kuhn, Thomas S. 1970. University of Chicago Press.">54</a> it should enable a body of &#34;normal science&#34;: filling in the map of the space of possible systems, thereby forming a knowledge repository for future designers.</p>
</section>
<section data-file="paper" data-id="programming-systems" data-title="Programming systems">

<p>We introduce the notion of a <em>programming system</em> through a number of example systems. We draw them from three broad reference classes:</p>
<ul>
<li><p>Software ecosystems built around a text-based programming <em>language</em>. They consist of a set of tools such as compilers, debuggers, and profilers. These tools may exist as separate command-line programs, or within an Integrated Development Environment.</p></li>
<li><p>Those that resemble an <em>operating system</em> (OS) in that they structure the execution environment and encompass the resources of an entire machine (physical or virtual). They provide a common interface for communication, both between the user and the computer, and between programs themselves.</p></li>
<li><p>Programmable <em>applications</em>, typically optimized for a specific domain, offering a limited degree of programmability which may be increased with newer versions.</p></li>
</ul>
<p>It must be noted that our selection of systems is not meant to be exhaustive; there will be many past and present systems that we are not aware of or do not know much about, and we obviously cannot cover programming systems that have not been created yet. With that caveat, we will proceed to detail some systems under the above grouping. This will provide an intuition for the notion of a programming system and establish a collection of go-to examples for the rest of the paper.</p>
</section>
<section data-file="paper" data-id="l-type" data-title="Systems based around languages">

<p>Text-based programming languages sit within programming systems whose boundaries are not explicitly defined. To speak of a programming system, we need to consider a language with, at minimum, an editor and a compiler or interpreter. However, the exact boundaries are a design choice that significantly affects our analysis.</p>
<h2>Java with the Eclipse ecosystem</h2>
<p>Java <a href="#*=.;right=paper,references" title=" Gosling, James, Bill Joy, Guy Steele, and Gilad Bracha. 2000. The JavaLanguage Specification. Addison-Wesley Professional.">33</a> cannot be viewed as a programming system on its own, but it is one if we consider it as embedded in an ecosystem of tools. There are multiple ways to delineate this, resulting in different analyses. A minimalistic programming system would consist of a text editor to write Java code and a command line compiler. A more realistic system is Java as embedded in the Eclipse IDE. <a href="#*=.;right=paper,references" title=" desRivieres, J., and J. Wiegand. 2004. “Eclipse: A Platform forIntegrating Development Tools.” IBM Systems Journal 43 (2): 371–83.https://doi.org/10.1147/sj.432.0371.">98</a> The programming systems view allows us to see all there is beyond the textual code. In the case of Eclipse, this includes the debugger, refactoring tools, testing and modelling tools, GUI designers, and so on. This delineation yields a programming system that is powerful and convenient, but has a large number of concepts and secondary notations.</p>
<h2>Haskell tools ecosystem</h2>
<p>Haskell is an even more language-focused programming system. It is used through the command-line GHC compiler <a href="#*=.;right=paper,references" title=" Marlow, Simon, and Simon Peyton-Jones. 2012. The Glasgow HaskellCompiler. Edited by A. Brown and G. Wilson. The Architecture of OpenSource Applications. CreativeCommons. http://www.aosabook.org.">60</a> and GHCi REPL, alongside a text editor that provides features like syntax highlighting and auto-completion. Any editor that supports the Language Server Protocol <a href="#*=.;right=paper,references" title=" Microsoft. 2022. “Language Server Protocol.”https://microsoft.github.io/language-server-protocol/.">64</a> will suffice to complete the programming system.</p>
<p>Haskell is mathematically rooted and relies on mathematical intuition for understanding many of its concepts. This background is also reflected in the notations it uses. In addition to the concrete language syntax for writing code, the ecosystem also uses an informal mathematical notation for writing about Haskell (e.g. in academic papers or on the whiteboard). This provides an additional tool for manipulating Haskell programs. Experiments on paper can provide a kind of rapid feedback that other systems may provide through live programming.</p>
<h2>From REPLs to notebooks</h2>
<p>A different kind of developer ecosystem that evolved around a programming language is the Jupyter notebook platform. <a href="#*=.;right=paper,references" title=" Kluyver, Thomas, Benjamin Ragan-Kelley, Fernando Pérez, Brian Granger,Matthias Bussonnier, Jonathan Frederic, Kyle Kelley, et al. n.d.“Jupyter Notebooks—a Publishing Format for Reproducible ComputationalWorkflows.” Positioning and Power in Academic Publishing: Players,Agents and Agendas, 87.">51</a> In Jupyter, data scientists write scripts divided into notebook cells, execute them interactively and see the resulting data and visualizations directly in the notebook itself. This brings together the REPL, which dates back to conversational implementations of Lisp in the 1960s, with literate programming <a href="#*=.;right=paper,references" title=" Knuth, Donald Ervin. 1984. “Literate Programming.” The ComputerJournal 27 (2): 97–111.">52</a> used in the late 1980s in Mathematica 1.0. <a href="#*=.;right=paper,references" title=" Wolfram, Stephen. 1991. Mathematica: A System for Doing Mathematics byComputer (2nd Ed.). USA: Addison Wesley Longman Publishing Co., Inc.">96</a></p>
<p>As a programming system, Jupyter has a number of interesting characteristics. The primary outcome of programming is the notebook itself, rather than a separate application to be compiled and run. The code lives in a document format, interleaved with other notations. Code is written in small parts that are executed quickly, offering the user more rapid feedback than in conventional programming. A notebook can be seen as a trace of how the result has been obtained, yet one often problematic feature of notebooks is that some allow the user to run code blocks out-of-order. The code manipulates mutable state that exists in a &#34;kernel&#34; running in the background. Thus, retracing one&#39;s steps in a notebook is more subtle than in, say, Common Lisp, <a href="#*=.;right=paper,references" title=" Steele, G., and S. E. Fahlman. 1990. Common LISP: The Language. HPTechnologies. Elsevier Science.https://books.google.cz/books?id=FYoOIWuoXUIC.">86</a> where the <code>dribble</code> function would directly record the user&#39;s session to a file.</p>
</section>
<section data-file="paper" data-id="o-type" data-title="OS-like programming systems">

<p>&#34;OS-likes&#34; begin from the 1960s when it became possible to interact one-on-one with a computer. First, time-sharing systems enabled interactive shared use of a computer via a teletype; smaller computers such as the PDP-1 and PDP-8 provided similar direct interaction, while 1970s workstations such as the Alto and Lisp Machines added graphical displays and mouse input. These <em>OS-like</em> systems stand out as having the totalising scope of <em>operating systems</em>, whether or not they are ordinarily seen as taking this role.</p>
<h2>MacLisp and Interlisp</h2>
<p>LISP 1.5 <a href="#*=.;right=paper,references" title=" McCarthy, John. 1962. LISP 1.5 Programmer’s Manual. The MIT Press.">61</a> arrived before the rise of interactive computers, but the existence of an interpreter and the absence of declarations made it natural to use Lisp interactively, with the first such implementations appearing in the early 1960s. Two branches of the Lisp family, <a href="#*=.;right=paper,references" title=" Steele, Guy L., and Richard P. Gabriel. 1993. “The Evolution of Lisp.”In The Second ACM SIGPLAN Conference on History of ProgrammingLanguages, 231–70. HOPL-II. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/154766.155373.">87</a> MacLisp and the later Interlisp, embraced the interactive &#34;conversational&#34; way of working, first through a teletype and later using the screen and keyboard.</p>
<p>Both MacLisp and Interlisp adopted the idea of <em>persistent address space</em>. Both program code and program state were preserved when powering off the system, and could be accessed and modified interactively as well as programmatically using the <em>same means</em>. Lisp Machines embraced the idea that the machine runs continually and saves the state to disk when needed. Today, this is widely seen in cloud-based services like Google Docs and online IDEs. Another idea pioneered in MacLisp and Interlisp was the use of <em>structure editors</em>. These let programmers work with Lisp data structures not as sequences of characters, but as nested lists. In Interlisp, the programmer would use commands such as <code>*P</code> to print the current expression, or <code>*(2 (X Y))</code> to replace its second element with the argument <code>(X Y)</code>. The PILOT system <a href="#*=.;right=paper,references" title=" Teitelman, Warren. 1966. “PILOT: A Step Toward Man-Computer Symbiosis.”PhD thesis, MIT.">90</a> offered even more sophisticated conversational features. For typographical errors and other slips, it would offer an automatic fix for the user to interactively accept, modifying the program in memory and resuming execution.</p>
<h2>Smalltalk</h2>
<p>Smalltalk appeared in the 1970s with a distinct ambition of providing &#34;dynamic media which can be used by human beings of all ages&#34;. <a href="#*=.;right=paper,references" title=" Kay, A., and A. Goldberg. 1977. “Personal Dynamic Media.” Computer 10(3): 31–41. https://doi.org/10.1109/C-M.1977.217672.">44</a> The authors saw computers as <em>meta-media</em> that could become a range of other media for education, discourse, creative arts, simulation and other applications not yet invented. Smalltalk was designed for single-user workstations with a graphical display, and pioneered this display not just for applications but also for programming itself. In Smalltalk 72, one wrote code in the bottom half of the screen using a structure editor controlled by a mouse, and menus to edit definitions. In Smalltalk-76 and later, this had switched to text editing embedded in a <em>class browser</em> for navigating through classes and their methods.</p>
<p>Similarly to Lisp systems, Smalltalk adopts the persistent address space model of programming where all objects remain in memory, but based on <em>objects</em> and <em>message passing</em> rather than <em>lists</em>. Any changes made to the system state by programming or execution are preserved when the computer is turned off. Lastly, the fact that much of the Smalltalk environment is implemented in itself makes it possible to extensively modify the system from within.</p>
<p>We include Lisp and Smalltalk in the OS-likes because they function as operating systems in many ways. On specialized machines, like the Xerox Alto and Lisp machines, the user started their machine directly in the Lisp or Smalltalk environment and was able to do everything they needed from <em>within</em> the system. Nowadays, however, this experience is associated with UNIX and its descendants on a vast range of commodity machines.</p>
<h2>UNIX</h2>
<p>UNIX illustrates the fact that many aspects of programming systems are shaped by their intended target audience. Built for computer hackers, <a href="#*=.;right=paper,references" title=" Levy, Steven. 1984. Hackers: Heroes of the Computer Revolution. USA:Doubleday.">57</a> its abstractions and interface are close to the machine. Although historically linked to the C language, UNIX developed a language-agnostic set of abstractions that make it possible to use multiple programming languages in a single system. While everything is an object in Smalltalk, the ontology of the UNIX system consists of files, memory, executable programs, and running processes. Note the explicit &#34;stage&#34; distinction here: UNIX distinguishes between volatile <em>memory</em> structures, which are lost when the system is shut down, and non-volatile <em>disk</em> structures that are preserved. This distinction between types of memory is considered, by Lisp and Smalltalk, to be an implementation detail to be abstracted over by their persistent address space. Still, this did not prevent the UNIX ontology from supporting a pluralistic ecosystem of different languages and tools.</p>
<h2>Early and modern Web</h2>
<p>The Web evolved <a href="#*=.;right=paper,references" title=" Ankerson, Megan Sapnar. 2018. Dot-Com Design: The Rise of a Usable,Social, Commercial Web. NYU Press.">1</a> from a system for sharing and organizing information to a <em>programming system</em>. Today, it consists of a wide range of server-side programming tools, JavaScript and languages that compile to it, and notations like HTML and CSS. As a programming system, the &#34;modern 2020s web&#34; is reasonably distinct from the &#34;early 1990s web&#34;. In the early web, JavaScript code was distributed in a form that made it easy to copy and re-use existing scripts, which led to enthusiastic adoption by non-experts—recalling the birth of microcomputers like Commodore 64 with BASIC a decade earlier.</p>
<p>In the &#34;modern web&#34;, multiple programming languages treat JavaScript as a compilation target, and JavaScript is also used as a language on the server-side. This web is no longer simple enough to encourage copy-and-paste remixing of code from different sites. However, it does come with advanced developer tools that provide functionality resembling early interactive programming systems like Lisp and Smalltalk. The <em>Document Object Model (DOM)</em> structure created by a web page is transparent, accessible to the user and modifiable through the built-in browser inspector tools. Third-party code to modify the DOM can be injected via extensions. The DOM almost resembles the tree/graph model of Smalltalk and Lisp images, lacking the key persistence property. This limitation, however, is being addressed by Webstrates. <a href="#*=.;right=paper,references" title=" Klokmose, Clemens N., James R. Eagan, Siemen Baader, Wendy Mackay, andMichel Beaudouin-Lafon. 2015. “Webstrates: Shareable Dynamic Media.” InProceedings of the 28th Annual ACM Symposium on User Interface Software&amp; Technology, 280–90. UIST ’15. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/2807442.2807446.">50</a></p>
</section>
<section data-file="paper" data-id="a-type" data-title="Application-focused systems">

<p>The previously discussed programming systems were either universal, not focusing on any particular kind of application, or targeted at broad fields, such as Artificial Intelligence and symbolic data manipulation in Lisp&#39;s case. In contrast, the following examples focus on more narrow kinds of applications that need to be built. Many support programming based on rich interactions with specialized visual and textual notations.</p>
<h2>Spreadsheets</h2>
<p>The first spreadsheets became available in 1979 in VisiCalc <a href="#*=.;right=paper,references" title=" Grad, Burton. 2007. “The Creation and the Demise of VisiCalc.” IEEEAnnals of the History of Computing 29 (3): 20–31.https://doi.org/10.1109/MAHC.2007.4338439.">34</a> <a href="#*=.;right=paper,references" title=" Zynda, Melissa Rodriguez. 2013. “The First Killer App: A History ofSpreadsheets.” Interactions 20 (5): 68–72.https://doi.org/10.1145/2509224.">97</a> and helped analysts perform budget calculations. As programming systems, spreadsheets are notable for their programming substrate (a two-dimensional grid) and evaluation model (automatic re-evaluation). The programmability of spreadsheets developed over time, acquiring features that made them into powerful programming systems in a way VisiCalc was not. The final step was the 1993 inclusion of <em>macros</em> in Excel, later further extended with <em>Visual Basic for Applications</em>.</p>
<h2>Graphical &#34;languages&#34;</h2>
<p>Efforts to support programming without relying on textual code can only be called &#34;languages&#34; in a metaphorical sense. In these programming systems, programs are made out of graphical structures as in LabView <a href="#*=.;right=paper,references" title=" Kodosky, Jeffrey. 2020. “LabVIEW.” Proc. ACM Program. Lang. 4 (HOPL).https://doi.org/10.1145/3386328.">53</a> or Programming-By-Example. <a href="#*=.;right=paper,references" title=" Lieberman, H. 2001. Your Wish Is My Command:Programming by Example. Morgan Kaufmann.">58</a></p>
<h2>HyperCard</h2>
<p>While spreadsheets were designed to solve problems in a specific application area, HyperCard <a href="#*=.;right=paper,references" title=" Michel, Stephen L. 1989. Hypercard: The Complete Reference. Berkeley:Osborne McGraw-Hill.">63</a> was designed around a particular application format. Programs are &#34;stacks of cards&#34; containing multimedia components and controls such as buttons. These controls can be programmed with pre-defined operations like &#34;navigate to another card&#34;, or via the HyperTalk scripting language for anything more sophisticated.</p>
<p>As a programming system, HyperCard is interesting for a couple of reasons. It effectively combines visual and textual notation. Programs appear the same way during editing as they do during execution. Most notably, HyperCard supports gradual progression from the &#34;user&#34; role to &#34;developer&#34;: a user may first use stacks, then go on to edit the visual aspects or choose pre-defined logic until, eventually, they learn to program in HyperTalk.</p>
</section>
<section data-class="nobullet" data-file="paper" data-id="evaluation" data-title="Evaluation">

<p>The technical dimensions should be evaluated on the basis of how useful they are for designing and analysing programming systems. To that end, this section demonstrates two uses of the framework. First, we use the dimensions to analyze the recent programming system Dark, <a href="#*=.;right=paper,references" title=" team, Dark language. 2022. “Dark Lang.” https://darklang.com.">102</a> explaining how it relates to past work and how it contributes to the state of the art. Second, we use technical dimensions to identify a new unexplored point in the design space of programming systems and envision a new design that could emerge from the analysis.</p>
<ul>
<li><a href="#*=.;right=paper,dark-evaluation!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,dark-dims!"><i></i>!</a></li>
<li><a href="#*=.;right=paper,exploring-the-design-space!"><i></i>!</a></li>
</ul>
</section>
<section data-file="paper" data-id="dark-annotated" data-title="Dark programming system">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/paper/dark-annotated.png" alt="A screenshot of the Dark programming system"/></p>
<p><strong>A screenshot of the Dark programming system.</strong>
The screenshot shows a simple web service in Dark consisting of two HTTP endpoints (1, 2), a database (3), and a worker (4)
(<a href="https://medium.com/@wilk/dark-lang-an-uncommon-step-towards-the-future-of-programming-921cf7f38baf">image source</a>)</p>
</blockquote>
</section>
<section data-class="doc dark" data-file="paper" data-id="dark-evaluation" data-title="Evaluating the Dark programming system">

<p>Dark is a programming system for building &#34;serverless backends&#34;, i.e. services that are used by web and mobile applications. It aims to make building such services easier by &#34;removing accidental complexity&#34; (see <a href="https://roadmap.darklang.com/goals-of-dark-v2.html">Goals of Dark v2</a>) resulting from the large number of systems typically involved in their deployment and operation. This includes infrastructure for orchestration, scaling, logging, monitoring and versioning. Dark provides integrated tooling for development and is described as <em>deployless</em>, meaning that deploying code to production is instantaneous.</p>
<p><a href="#image=paper,dark-annotated"><img src="https://tomasp.net/techdims/img/paper/dark-annotated.png" alt=""/></a></p>
<p>Dark illustrates the need for the broader perspective of programming systems. Of course, it contains a programming language, which is inspired by OCaml and F#. But Dark&#39;s distinguishing feature is that it eliminates the many secondary systems needed for deployment of modern cloud-based services. Those exist outside of a typical programming language, yet form a major part of the complexity of the overall development process.</p>
<p>With technical dimensions, we can go beyond the &#34;sales pitch&#34;, look behind the scenes, and better understand the interesting technical aspects of Dark as a programming system. The table below summarises the more detailed analysis that follows. Two clear benefits of such an analysis are:</p>
<ol>
<li>It provides a list of topics to investigate when examining a programming system such as Dark.</li>
<li>It give us a common vocabulary for these topics that can be used to compare Dark with other systems on the same terms.</li>
</ol>
<h2>Positioning Dark in the design space</h2>
<p>The following table provides a concise summary of where Dark lies on its distinguishing dimensions. For brevity, dimensions where Dark does not differ from ordinary programming are omitted.
A more detailed discussion can be found in the <a href="#*=.;right=paper,dark-dims">Dimensional analysis of Dark</a>.</p>
<table>
<tbody><tr><td colspan="2">Interaction</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/interaction,modes-of-interaction">Modes of interaction</a></td><td>Single integrated mode comprises development, debugging and operation (&#34;deployless&#34;))</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/interaction,feedback-loops">Feedback loops </a></td><td> Code editing is triggered either by user or by unsupported HTTP request and changes are deployed automatically, allowing for <em>immediate feedback</em></td></tr>
<tr><td colspan="2">Errors</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/errors,error-response">Error response </a></td><td> When an unsupported HTTP request is received, programmer can write handler code using data from the request in the process)</td></tr>
<tr><td colspan="2">Conceptual structure</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/conceptual-structure,integrity-openness">Conceptual integrity versus openness </a></td><td> Abstractions at the domain specific high-level and the functional low-level are both carefully designed for conceptual integrity.</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/conceptual-structure,composability">Composability </a></td><td> User applications are composed from high-level primitives; the low-level uses composable functional abstractions (records, pipelines).)</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/conceptual-structure,convenience">Convenience </a></td><td> Powerful high-level domain-specific abstractions are provided (HTTP, database, workers); core functional libraries exist for the low-level.) </td></tr>
<tr><td colspan="2">Adoptability</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/adoptability,learnability">Learnability </a></td><td> High-level concepts will be immediately familiar to the target audience; low-level language has the usual learning curve of basic functional programming)</td></tr>
<tr><td colspan="2">Notation</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/notation,notational-structure">Notational structure </a></td><td> Graphical notation for high-level concepts is complemented by structure editor for low-level code) </td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/notation,uniformity-of-notations">Uniformity of notations </a></td><td> Common notational structures are used for database and code, enabling the same editing construct for sequential structures (records, pipelines, tables))</td></tr>
<tr><td colspan="2">Complexity</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/complexity,factoring">Factoring of complexity </a></td><td> Cloud infrastructure (deployment, orchestration, etc.) is provided by the Dark platform that is invisible to the programmer, but also cannot be modified)</td></tr>
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/complexity,automation">Level of automation </a></td><td> Current implementation provides basic infrastructure, but a higher degree of automation in the platform can be provided in the future, e.g. for scalability) </td></tr>
<tr><td colspan="2">Customizability</td></tr>	
<tr><td><a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/customizability,staging">Staging of customization </a></td><td> System can be modified while running and changes are persisted, but they have to be made in the Dark editor, which is distinct from the running service)</td></tr>
</tbody></table>
<h2>Technical innovations of Dark</h2>
<p>This analysis reveals a number of interesting aspects of the Dark programming system. The first is the tight integration of different <em>modes of interaction</em> which collapses a heterogeneous stack of technologies, makes Dark <em>learnable</em>, and allows quick feedback from deployed services. The second is the use of <em>error response</em> to guide the development of HTTP handlers. Thanks to the technical dimensions framework, each of these can be more precisely described. It is also possible to see how they may be supported in other programming systems. The framework also points to possible alternatives (and perhaps improvements) such as building a more self-sustainable system that has similar characteristics to Dark, but allows greater flexibility in modifying the platform from within itself.</p>
</section>
<section data-file="paper" data-id="dark-dims" data-title="Dimensional analysis of Dark">

<h2>Modes of interaction and feedback loops</h2>
<p>Conventional <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/interaction,modes-of-interaction">modes of interaction</a> include running, editing and debugging. For modern web services, running refers to operation in a cloud-based environment that typically comes with further kinds of feedback (logging and monitoring). The key design decision of Dark is to integrate all these different modes of interaction into a single one. This tight integration allows Dark to provide a more immediate <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/interaction,feedback-loops">feedback loop</a> where code changes become immediately available not just to the developer, but also to external users. The integrated mode of interaction is reminiscent of the image-based environment in Smalltalk; Dark advances the state of art by using this model in a multi-user, cloud-based context.</p>
<h2>Feedback loops and error response</h2>
<p>The integration of development and operation also makes it possible to use <em>errors</em> occurring during operation to drive development. Specifically, when a Dark service receives a request that is not supported, the user can build a handler <a href="#*=.;right=paper,references" title=" Chisa, Ellen. 2020. “Introduction: Error Rail and Match with .”2020. https://youtu.be/NRMmy9ZzA-o.">13</a> to provide a response—taking advantage of the live data that was sent as part of the request. In terms of our dimensions, this is a kind of <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/errors,error-response">error response</a> that was pioneered by the PILOT system for Lisp. <a href="#*=.;right=paper,references" title=" Teitelman, Warren. 1966. “PILOT: A Step Toward Man-Computer Symbiosis.”PhD thesis, MIT.">90</a> Dark does this not just to respond to errors, but also as the primary development mechanism, which we might call <em>Error-Driven Development.</em> This way, Dark users can construct programs with respect to sample input values.</p>
<h2>Conceptual structure and learnability</h2>
<p>Dark programs are expressed using high-level concepts that are specific to the domain of server-side web programming: HTTP request handlers, databases, workers and scheduled jobs. These are designed to reduce accidental complexity and aim for high <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/conceptual-structure,integrity-openness">conceptual integrity</a>.  At the level of code, Dark uses a general-purpose functional language that emphasizes certain concepts, especially records and pipelines. The high-level concepts contribute to <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/adoptability,learnability">learnability</a> of the system, because they are highly domain-specific and will already be familiar to its intended users.</p>
<h2>Notational structure and uniformity</h2>
<p>Dark uses a combination of graphical editor and code. The two aspects of the notation follow the <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/notation,complementing-notations">complementing notations</a> pattern. The windowed interface is used to work with the high-level concepts and code is used for working with low-level concepts. At the high level, code is structured in freely positionable boxes on a 2D surface. Unlike Boxer, <a href="#*=.;right=paper,references" title=" diSessa, A. A, and H. Abelson. 1986. “Boxer: A ReconstructibleComputational Medium.” Commun. ACM 29 (9): 859–68.https://doi.org/10.1145/6592.6595.">99</a> these boxes do not nest and the space cannot be used for other content (say, for comments, architectural illustrations or other media). Code at the low level is manipulated using a syntax-aware structure editor, showing inferred types and computed live values for pure functions. It also provides special editing support for records and pipelines, allowing users to add fields and steps respectively.</p>
<h2>Factoring of complexity and automation</h2>
<p>One of the advertised goals of Dark is to remove accidental complexity. This is achieved by collapsing the heterogeneous stack of technologies that are typically required for development, cloud deployment, orchestration and operation. Dark hides this via <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/complexity,factoring">factoring of complexity</a>. The advanced infrastructure is provided by the Dark platform and is hidden from the user. The infrastructure is programmed explicitly and there is no need for sophisticated <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/complexity,automation">automation</a>. This factoring of functionality that was previously coded manually follows a similar pattern as the development of garbage collection in high-level programming languages.</p>
<h2>Customizability</h2>
<p>The Dark platform makes a clear distinction between the platform itself and the user application, so <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/customizability,self-sustainability">self-sustainability</a> is not an objective. The strict division between the platform and user (related to its aforementioned <em>factoring of complexity</em>) means that changes to Dark require modifying the platform source code itself, which is available under a license that solely allows using it for the purpose of contributing. Similarly, applications themselves are developed by modifying and adding code, requiring destructive access to it—so <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/customizability,addressing">additive authoring</a> is not exhibited at either level. Thanks to the integration of execution and development, persistent changes may be made during execution (c.f. <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/customizability,staging">staging of customization</a> but this is done through the Dark editor, which is separate from the running service.</p>
</section>
<section data-class="doc" data-file="paper" data-id="exploring-the-design-space" data-title="Exploring the design space">

<p>With a little work, technical dimensions can let us see patterns or gaps in the design space by plotting their values on a simple scatterplot. Here, we will look at two dimensions, <em>notational diversity</em> (this is simply <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/notation,uniformity-of-notations">uniformity of notations</a>, but flipped in the opposite direction) and <a href="#footer=index,navigation;left=catalogue,list;top=catalogue,index;right=dimensions/customizability,self-sustainability">self-sustainability</a>, for the following programming systems: Haskell, Jupyter notebooks, Boxer, HyperCard, the Web, spreadsheets, Lisp, Smalltalk, UNIX, and COLAs. <a href="#*=.;right=paper,references" title=" Piumarta, Ian. 2006. “Accessible Language-Based Environments ofRecursive Theories.” 2006.http://www.vpri.org/pdf/rn2006001a_colaswp.pdf.">77</a></p>
<p>While our choice to describe dimensions as qualitative concepts was necessary for coming up with them, <em>some</em> way of generating numbers is clearly necessary for visualizing their relationships like this. For simplicity, we adopt the following scheme. For each dimension, we distill the main idea into several yes/no questions (as discussed <a href="#*=.;right=paper,making-dimensions-quantitative">in the appendix</a>) that capture enough of the distinctions we observe between the systems we wish to plot. Then, for each system, we add up the number of &#34;yes&#34; answers and obtain a plausible score for the dimension.</p>
<p><a href="#image=paper,plot-figure0"><img src="https://tomasp.net/techdims/img/paper/plot-figure0.png" alt=""/></a></p>
<p>The diagram (click for a <a href="#image=paper,plot-figure0">bigger version</a>) shows the results we obtained with our sets of questions. It shows that application-focused systems span a range of notational diversity, but only within fairly low self-sustainability. The <a href="#*=.;right=paper,o-type">OS-likes</a> cluster in an &#34;island&#34; at the right, sharing identical notational diversity and near-identical self-sustainability.</p>
<p>There is also a conspicuous blank space at the top-right, representing an unexplored combination of high values on both dimensions. With other pairs of dimensions, we might take this as evidence of an oppositional relationship, such that more of one inherently means less of the other (perhaps looking for a single new dimension that describes this better.) In this case, though, there is no obvious conflict between having many notations and being able to change a system from within. Therefore, we interpret the gap as a new opportunity to try out: combine the self-sustainability of COLAs with the notational diversity of Boxer and Web development. In fact, this is more or less the forthcoming dissertation of the primary author.</p>
</section>
<section data-file="paper" data-id="conclusions" data-title="Conclusions and acknowledgments">

<p>There is a renewed interest in developing new programming systems. Such systems go beyond the simple model of code written in a programming language using a more or less sophisticated text editor. They combine textual and visual notations, create programs through rich graphical interactions, and challenge accepted assumptions about program editing, execution and debugging. Despite the growing number of novel programming systems, it remains difficult to evaluate the design of programming systems and see how they improve over work done in the past. To address the issue, we proposed a framework of “technical dimensions” that captures essential characteristics of programming systems in a qualitative but rigorous way.</p>
<p>The framework of technical dimensions puts the vast variety of programming systems, past and present, on a common footing of commensurability. This is crucial to enable the strengths of each to be identified and, if possible, combined by designers of the next generation of programming systems. As more and more systems are assessed in the framework, a picture of the space of possibilities will gradually emerge. Some regions will be conspicuously empty, indicating unrealized possibilities that could be worth trying. In this way, a domain of &#34;normal science&#34; is created for the design of programming systems.</p>
<h2>Acknowledgments</h2>
<p>We particularly thank Richard Gabriel for shepherding our submission to the 2021 <em>Pattern Languages of Programming</em> (PLoP) conference. We thank the participants of the PLoP Writers&#39; Workshop for their feedback, as well as others who have proofread or otherwise given input on the ideas at different stages. These include Luke Church, Filipe Correia, Thomas Green, Brian Hempel, Clemens Klokmose, Geoffery Litt, Mariana Mărășoiu, Stefan Marr, Michael Weiss, and Rebecca and Allen Wirfs-Brock. We also thank the attendees of our Programming 2021 Conversation Starters session and our Programming 2022 tutorial/workshop entitled &#34;Methodology Of Programming Systems&#34; (MOPS).</p>
<p>This work was partially supported by the project of Czech Science Foundation no. 23-06506S.</p>
</section>
<section data-class="doc" data-file="paper" data-id="making-dimensions-quantitative" data-title="Making dimensions quantitative">

<p><a href="#image=paper,plot-figure0"><img src="https://tomasp.net/techdims/img/paper/plot-figure0.png" alt=""/></a></p>
<p>To generate numerical co-ordinates for <em>self-sustainability</em> and <em>notational diversity</em>, we split both dimensions into a small number of yes/no questions and counted the &#34;yes&#34; answers for each system. We came up with the questions informally, with the goal of achieving three things:</p>
<ol>
<li>To capture the basic ideas or features of the dimension</li>
<li>To make prior impressions more precise (i.e. to roughly match where we intuitively felt certain key systems fit, but provide precision and possible surprises for systems we were not as confident about.)</li>
<li>To be the fewest in number necessary to attain the above</li>
</ol>
<p>The following sections discuss the questions, along with a brief rationale for each question. This also raises a number of points for future work that we discuss below.</p>

</section>
<section data-class="appendix" data-file="paper" data-id="self-sustainability" data-title="Quantifying self-sustainability">

<h2>Questions</h2>
<ol>
<li><strong>Can you add new items to system namespaces without a restart?</strong> The canonical example of this is in JavaScript, where &#34;built-in&#34; classes like <code>Array</code> or <code>Object</code> can be augmented at will (and destructively modified, but that would be a separate point). Concretely, if a user wishes to make a new <code>sum</code> operation available to all Arrays, they are not <em>prevented</em> from straightforwardly adding the method to the Array prototype as if it were just an ordinary object (which it is). Having to re-compile or even restart the system would mean that this cannot be meaningfully achieved from within the system. Conversely, being able to do this means that even &#34;built-in&#34; namespaces are modifiable by ordinary programs, which indicates less of a implementation level vs. user level divide and seems important for self-sustainability.</li>
<li><strong>Can programs generate programs and execute them?</strong> This property, related to &#34;code as data&#34; or the presence of an <code>eval()</code> function, is a key requirement of self-sustainability. Otherwise, re-programming the system, beyond selecting from a predefined list of behaviors, will require editing an external representation and restarting it. If users can type text inside the system then they will be able to write code---yet this code will be inert unless the system can interpret internal data structures as programs and actually execute them.</li>
<li><strong>Are changes persistent enough to encourage indefinite evolution?</strong> If initial tinkering or later progress can be reset by accidentally closing a window, or preserved only through a convoluted process, then this discourages any long-term improvement of a system from within. For example, when developing a JavaScript application with web browser developer tools, it is possible to run arbitrary JavaScript in the console, yet these changes apply only to the running instance. After tinkering in the console with the advantage of concrete system state, one must still go back to the source code file and make the corresponding changes manually. When the page is refreshed to load the updated code, it starts from a fresh initial state. This means it is not worth using the <em>running</em> system for any programming beyond tinkering.</li>
<li><strong>Can you reprogram low-level infrastructure within the running system?</strong> This is a hopefully faithful summary of how the COLAs work aims to go beyond Lisp and Smalltalk in this dimension.</li>
<li><strong>Can the user interface be arbitrarily changed from within the system?</strong> Whether classed as &#34;low-level infrastructure&#34; or not, the visual and interactive aspects of a system are a significant part of it. As such, they need to be as open to re-programming as any other part of it to classify as truly self-sustainable.</li>
</ol>
<h2>System evaluation</h2>
<table>
<tbody><tr><th>Question</th><th>Haskell</th><th>Jupyter</th><th>HyperCard</th><th>Subtext</th>
  <th>Spreadsheets</th><th>Boxer</th><th>Web</th><th>UNIX</th><th>Smalltalk</th>
  <th>Lisp</th><th>COLAs</th></tr>
<tr><td> 1 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td></tr>
<tr><td> 2 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td></tr>
<tr><td> 3 </td><td>  </td><td>  </td><td> <i></i> </td><td>  </td><td> <i></i> </td><td> <i></i> </td><td>  </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td></tr>
<tr><td> 4 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td> <i></i> </td></tr>
<tr><td> 5 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td> <i></i> </td><td> <i></i> </td><td> <i></i> </td><td> <i></i></td></tr>
<tr><td> Total </td><td> 0 </td><td> 0 </td><td> 1 </td><td> 0 </td><td> 1 </td><td> 1 </td><td> 2 </td><td> 4 </td><td> 4 </td><td> 4 </td><td> 5 </td></tr>
</tbody></table>
</section>
<section data-class="appendix" data-file="paper" data-id="notational-diversity" data-title="Quantifying notational diversity">

<h2>Questions</h2>
<ol>
<li><strong>Are there multiple syntaxes for textual notation?</strong> Obviously, having more than one textual notation should count for notational diversity. However, for this dimension we want to take into account notations beyond the strictly textual, so we do not want this to be the only relevant question. Ideally, things should be weighted so that having a wide diversity of notations within some <em>narrow class</em> is not mistaken for notational diversity in a more global sense. We want to reflect that UNIX, with its vast array of different languages for different situations, can never be as notationally diverse as a system with many languages <em>and</em> many graphical notations, for example.</li>
<li><strong>Does the system make use of GUI elements?</strong> This is a focused class of non-textual notations that many of our example systems exhibit.</li>
<li><strong>Is it possible to view and edit data as tree structures?</strong> Tree structures are common in programming, but they are usually worked with as text in some way. A few of our examples provide a graphical notation for this common data structure, so this is one way they can be differentiated from the rest.</li>
<li><strong>Does the system allow freeform arrangement and sizing of data items?</strong> We still felt Boxer and spreadsheets exhibited something not covered by the previous three questions, which is this. Within their respective constraints of rendering trees as nested boxes and single-level grids, they both provide for notational variation that can be useful to the user&#39;s context. These systems <em>could</em> have decided to keep boxes neatly placed or cells all the same size, but the fact that they allow these to vary scores an additional point for notational diversity.</li>
</ol>
<h2>System evaluation</h2>
<table>
<tbody><tr><th>Question</th><th>Haskell</th><th>Jupyter</th><th>HyperCard</th><th>Subtext</th>
  <th>Spreadsheets</th><th>Boxer</th><th>Web</th><th>UNIX</th><th>Smalltalk</th>
  <th>Lisp</th><th>COLAs</th></tr>
<tr><td> 1 </td><td></td><td></td><td></td><td></td><td></td><td></td><td><i></i></td><td><i></i></td><td></td><td></td><td><i></i></td></tr>
<tr><td>2 </td><td></td><td><i></i></td><td><i></i></td><td><i></i></td><td><i></i></td><td><i></i></td><td><i></i></td><td></td><td><i></i></td><td></td><td></td></tr>
<tr><td>3 </td><td></td><td></td><td></td><td><i></i></td><td></td><td><i></i></td><td><i></i></td><td></td><td></td><td><i></i></td><td></td></tr>
<tr><td>4 </td><td></td><td></td><td></td><td></td><td><i></i></td><td><i></i></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td> Total </td><td> 0 </td><td> 1 </td><td> 1 </td><td> 2 </td><td> 2 </td><td> 3 </td><td> 3 </td><td> 1 </td><td> 1 </td><td> 1 </td><td> 1 </td></tr>
</tbody></table>
</section>
<section data-file="paper" data-id="future-work" data-title="Remarks and future work">

<p>This task of quantifying dimensions forced us to drill down and decide on more crisp definitions of what they should be. We recommend it as a useful exercise even in the absence of a goal like generating a graph.</p>
<p>It is worth clarifying the meaning of what we have done here. It must not be overlooked that this settling down on one particular definition does not replace or obsolete the general qualitative descriptions of the dimensions that we start with. Clearly, there are far too many sources of variation in our process to consider our results here as final, objective, the single correct definition of these dimensions, or anything in this vein. Each of these sources of variation suggests future work for interested parties:</p>
<h2>Quantification goals</h2>
<p>We sought numbers to generate a graph that roughly matched our own intuitive placement of several example systems. In other words, we were trying to make those intuitions more precise along with the dimensions themselves. An entirely different approach would be to have no &#34;anchor&#34; at all, and to take whatever answers a given definition produces as ground truth. However, this would demand more detail for answering questions and generating them in the first place.</p>
<h2>Question generation</h2>
<p>We generated our questions informally and stopped when it seemed like there were enough to make the important distinctions between example points. There is huge room for variation here, though it seems particularly hard to generate questions in any rigorous manner. Perhaps we could take our <em>self-sustainability</em> questions to be drawn from a large set of &#34;actions you can perform while the system is running&#34;, which could be parametrized more easily. Similarly, our <em>notational diversity</em> questions tried to take into account a few classes of notations—a more sophisticated approach might be to just count the notations in a wide range of classes.</p>
<h2>Answering the questions</h2>
<p>We answered our questions by coming to a consensus on what made sense to the three of us. Others may disagree with these answers, and tracing the source of disagreement could yield insights for different questions that both parties would answer identically. Useful information could also be obtained from getting many different people to answer the questions and seeing how much variation there is.</p>
<h2>What is &#34;Lisp&#34;, anyway?</h2>
<p>The final major source of variation would be the labels we have assigned to example points. In some cases (Boxer), there really is only one system; in others (spreadsheets) there are several different <em>products</em> with different names, yet which are still similar enough to plausibly analyze as the same thing; in still others (Lisp) we&#39;re treating a family of related systems as a cohesive point in the design space. It is understandable if some think this elides too many important distinctions. In this case, they could propose splits into different systems or sub-families, or even suggest how these families should be treated as blobs within various sub-spaces.</p>
</section>
<section data-class="progsys" data-file="systems" data-id="intro" data-title="Good old programming systems">

<p>A <em>programming system</em> is an integrated set of tools sufficient for creating, modifying, and executing programs.
The classic kind of programming system consists of a <em>programming language</em> with a text editor and a compiler, but
programming systems can also be built around interactive graphical user interfaces, provide various degree of
integration between the runtime execution environment and leverage graphical notations.
Our notion accomodates examples from three broad classes of systems.</p>
<ul>
<li>
<p><em><i></i> <strong>Systems based around languages</strong>.</em>
Software ecosystems built around a text-based programming <em>language</em>. They consist of a set of tools such as compilers, debuggers, and profilers, accessible either through a command-line or a development environment.
<a href="#footer=index,navigation;left=paper,toc;right=paper,l-type;top=paper,index">Read more in the paper...</a></p>
</li>
<li>
<p><em><i></i> <strong>OS-like programming systems</strong>.</em>
Those that resemble an operating system in that they control both the execution environment and the resources of an entire machine. They provide a common interface for communication between programs and with the user.
<a href="#footer=index,navigation;left=paper,toc;right=paper,o-type;top=paper,index">Read more in the paper...</a></p>
</li>
<li>
<p><em><i></i> <strong>Application-focused systems</strong>.</em>
Programmable <em>applications</em>, typically optimized for a specific domain, offering a limited degree of programmability, which may be increased with newer versions.
<a href="#footer=index,navigation;left=paper,toc;right=paper,a-type;top=paper,index">Read more in the paper...</a></p>
</li>
</ul>
<p>This page provides a brief overview of nine &#34;Good Old Programming Systems&#34; that feature as examples
in our discussion. For each of the system, you can look at its characteristics, also available
in the <a href="#left=index,matrix-intro;big=index,matrix-body;footer=index,navigation">comparison matrix</a>
and references sections of the <a href="#top=catalogue,index;left=catalogue,list;footer=index,navigation">catalogue of technical dimensions</a>
where the system is discussed.</p>
</section>
<section data-class="systems frameset" data-file="systems" data-id="index" data-title="Good old programming systems">









</section>
<section data-class="dimensions-adoptability-anchor nobullet" data-file="dimensions/adoptability" data-id="summary" data-title="Adoptability">

<p>How does the system facilitate or obstruct adoption by both individuals and communities?</p>
<h2>Dimensions</h2>
<ul>
<li>
What is the attitude towards the learning curve and what is the target audience?</li>
<li>
What are the social and economic factors that make the system the way it is?</li>
</ul>
</section>
<section data-file="dimensions/adoptability" data-id="index" data-title="Adoptability">

<p><strong>How does the system facilitate or obstruct adoption by both individuals and communities?</strong></p>
<p>We consider adoption by individuals as the dimension of <em>Learnability</em>, and adoption by communities as the dimension of <em>Sociability</em>.
For more information, refer to the two primary dimensions of this cluster.</p>

</section>
<section data-file="dimensions/adoptability" data-id="learnability" data-title="Dimension: Learnability">

<p>Mainstream software development technologies require substantial effort to learn. Systems can be made easier to learn in several ways:</p>
<div>
<ul>
<li>Specializing to a specific application domain.</li>
<li>Specializing to simple small-scale needs.</li>
<li>Leveraging the background knowledge, skills, and terminologies of specific communities.</li>
<li>Supporting learning with staged levels of complexity and assistive development tools <a href="#*=.;right=paper,references" title=" Fry, Christopher. 1997. “Programming on an Already Full Brain.” Commun.ACM 40 (4): 55–64. https://doi.org/10.1145/248448.248459.">25</a>. Better <a href="#*=.;right=dimensions/interaction,feedback-loops">Feedback Loops</a> can help.</li>
<li>Collapsing heterogeneous technology stacks into simpler unified systems. This relates to the dimensions under <a href="#*=.;right=dimensions/conceptual-structure,index">Conceptual structure</a>.</li>
</ul>
</div>
<h2>Early programming languages</h2>
<p>FORTRAN was a breakthrough in programming because it specialized to scientific computing and leveraged the background knowledge of scientists about mathematical formulas. COBOL instead specialized to business data processing and embraced the business community by eschewing mathematics in favor of plain English.</p>
<p>LOGO was the first language explicitly designed for teaching children. Later BASIC and Pascal were designed for teaching then-standard programming concepts at the University level. BASIC and Pascal had second careers on micropocessors in the 90&#39;s. These microprocessor programming systems were notable for being complete solutions integrating everything necessary, and so became home schools for a generation of programmers. More recently languages like Racket, Pyret, and Grace have supported learning by revealing progressive levels of complexity in stages. Scratch returned to Logo&#39;s vision of teaching children with a graphical programming environment emphasizing playfulness rather than generality.</p>
<h2>Focus on programmer-friendliness</h2>
<p>Some programming languages have consciously prioritized the programmer&#39;s experience of learning and using them. Ruby calls itself <em>a programmer&#39;s best friend</em> by focusing on simplicity and elegance. Elm targets the more specialized but still fairly broad domain of web applications while focusing on simplicity and programmer-friendliness. It forgoes capabilities that would lead to run-time crashes. It also tries hard to make error messages clear and actionable.</p>
<h2>Beyond programming languages</h2>
<p>If we look beyond programming languages <em>per se</em>, we find programmable systems with better learnability. The best example is spreadsheets, which offer a specialized computing environment that is simpler and more intuitive. The visual metaphor of a grid leverages human perceptual skills. Moving all programming into declarative formulas and attributes greatly simplifies both creation and understanding. Research on Live Programming <a href="#*=.;right=paper,references" title=" Hancock, C., and M. Resnick. 2003. “Real-Time Programming and the BigIdeas of Computational Literacy.” PhD thesis, Massachusetts Institute ofTechnology. https://dspace.mit.edu/handle/1721.1/61549.">37</a> <a href="#*=.;right=paper,references" title=" Victor, Bret. 2012. “Learnable Programming.” 2012.http://worrydream.com/#!/LearnableProgramming.">93</a> has sought to incorporate these benefits into general purpose programming, but with limited success to date.</p>
<p>HyperCard and Flash were both programming systems that found widespread adoption by non-experts. Like spreadsheets they had an organizing visual metaphor (cards and timelines respectively). They both made it easy for beginners to get started. Hypercard had layers of complexity intended to facilitate gradual mastery.</p>
<h2>Smalltalk and Lisp machines</h2>
<p>Smalltalk and Lisp machines were complex but unified. After overcoming the initial learning curve, their environments provided a complete solution for building entire application systems of arbitrary complexity without having to learn other technologies. Boxer <a href="#*=.;right=paper,references" title=" diSessa, Andrea A. 1985. “A Principled Design for an IntegratedComputational Environment.” Human–Computer Interaction 1 (1): 1–47.https://doi.org/10.1207/s15327051hci0101\\1.">100</a> is notable for providing a general-purpose programming environment—albeit for small-scale applications—along with an organizing visual metaphor like that of spreadsheets.</p>
</section>
<section data-file="dimensions/adoptability" data-id="sociability" data-title="Dimension: Sociability">

<p>Over time, especially in the internet era, social issues have come to dominate programming. Much programming technology is now developed by open-source communities, and all programming technologies are now embedded in social media communities of their users. Therefore, technical decisions that impact socialibilty can be decisive <a href="#*=.;right=paper,references" title=" Meyerovich, Leo A., and Ariel S. Rabkin. 2012. “Socio-PLT: Principlesfor Programming Language Adoption.” In Proceedings of the ACMInternational Symposium on New Ideas, New Paradigms, and Reflections onProgramming and Software, 39–54. Onward! 2012. New York, NY, USA:Association for Computing Machinery.https://doi.org/10.1145/2384592.2384597.">62</a>. These include:</p>
<ul>
<li>Compatibility: easy integration into standard technology stacks, allowing incremental adoption, and also easy exit if needed. This dynamic was discussed in the classic essay <em>Worse is Better</em> <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 1991. “Worse Is Better.” 1991.https://www.dreamsongs.com/WorseIsBetter.html.">27</a> about how UNIX beat Lisp.</li>
<li>Developing with an open source methodology reaps volunteer labor and fosters a user community of enthusiasts. The technical advantages of open source development were first popularized in the essay <em>The Cathedral and the Bazaar</em> <a href="#*=.;right=paper,references" title=" Raymond, Eric S., and Bob Young. 2001. The Cathedral &amp; the Bazaar:Musings on Linux and Open Source by an Accidental Revolutionary.O’Reilly.">78</a>, which observed that &#34;given enough eyeballs, all bugs are shallow&#34;. Open source has become the standard for software development tools, even those developed within large corporations.</li>
<li>Easy sharing of code via package repositories or open exchanges. Prior to the open-source era, commercial marketplaces were important, like VBX components for VisualBasic. Sharing is impeded when languages lack standard libraries, leading to competing dialects, like Scheme <a href="#*=.;right=paper,references" title=" Winestock, Rudolf. 2011. “The Lisp Curse.” 2011.http://www.winestockwebdesign.com/Essays/Lisp_Curse.html.">95</a>.</li>
<li>Dedicated social media communities can be fostered by using them to provide technical support. Volunteer technical support, like volunteer code contributions, can multiply the impact of core developers. In some cases, social media like Stack Exchange has even come to replace documentation.</li>
</ul>
<p>One could argue that socialibilty is not purely a <em>technical</em> dimension, as it includes aspects of product management. Rather, we believe that sociability is a pervasive cross-cutting concern that cannot be <em>separated</em> from the technical.</p>
<h2>Programming system community</h2>
<p>The tenor of the online community around a programming system can be its most public attribute. Even before social media, Flash developed a vibrant community of amateurs sharing code and tips. The Elm language invested much effort in creating a welcoming community from the outset <a href="#*=.;right=paper,references" title=" Czaplicki, Evan. 2018. 2018.https://www.youtube.com/watch?v=uGlzRt-FYto.">15</a>. Attempts to reform older communities have introduced Codes of Conduct, but not without controversy.</p>
<p>On the other hand, a cloistered community that turns its back on the wider world can give its members strong feelings of belonging and purpose. Examples are Smalltalk, Racket, Clojure, and Haskell. These communities bear some resemblance to cults, with guru-like leaders, and fierce group cohesion.</p>
<h2>Economic sustainability</h2>
<p>The economic sustainability of a programming system can be even more important than strictly social and technical issues. Adopting a technology is a costly investment in terms of time, money, and foregone opportunities. Everyone feels safer investing in a technology backed by large corporations that are not going away, or in technologies that have such widespread adoption that they are guaranteed to persist. A vibrant and mature open-source community backing a technology also makes it safer.</p>
<h2>Conflict with learnability</h2>
<p>Unfortunately, sociability is often in conflict with learnability. Compatibility leads to ever increasing historical baggage for new learners to master. Large internet corporations have invested mainly in technologies relevant to their expert staff and high-end needs. Open-source communities have mainly flourished around technologies for expert programmers &#34;scratching their own itch&#34;. While there has been a flow of venture funding into &#34;no-code&#34; and &#34;low-code&#34; programming systems, it is not clear how they can become economically and socially sustainable. By and large, the internet era has seen the ascendancy of expert programmers and the eclipsing of programming systems for &#34;the rest of us&#34;.</p>
</section>
<section data-class="dimensions-complexity-anchor nobullet" data-file="dimensions/complexity" data-id="summary" data-title="Complexity">

<p>How does the system structure complexity and what level of detail is required?</p>
<h2>Dimensions</h2>
<ul>
<li>
What programming details are hidden in reusable components and how?</li>
<li>
What part of program logic does not need to be explicitly specified?</li>
</ul>
<h2>Examples and remarks</h2>
<ul>
<li><a href="#*=.;right=dimensions/complexity,notations!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/complexity,dsls!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/complexity,pbe!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/complexity,next-level!"><i></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/complexity" data-id="index" data-title="Complexity">

<p><strong>How does the system structure complexity and what level of detail is required?</strong></p>
<p>There is a massive gap between the level of detail required by a computer, which executes a sequence of low-level instructions, and the human description of a program in higher-level terms. To bridge this gap, a programming system needs to deal with the complexity inherent in going from a high-level description to low-level instructions.</p>
<p>Ever since the 1940s, programmers have envisioned that &#34;automatic programming&#34; will allow higher-level programming. This did not necessarily mean full automation. In fact, the first &#34;automatic programming&#34; systems referred to higher-level programming languages with a compiler (or an interpreter) that expanded the high-level code into detailed instructions.</p>
<p>Most programming systems use <em>factoring of complexity</em> and encapsulate some of the details that need to be specified into components that can be reused by the programmer. The details may be encapsulated in a library, or filled in by a compiler or interpreter. Such factoring may also be reflected in the conceptual structure of the system (See <a href="#*=.;right=dimensions/conceptual-structure,flattening-factoring">flattening and factoring</a>). However, a system may also fully <em>automate</em> some aspects of programming. In those cases, a general-purpose algorithm solves a whole class of problems, which then do not need to be coded explicitly. Think of planning the execution of SQL queries, or of the inference engine supporting a logic programming language like Prolog.</p>
<h2>Relations</h2>
<p><a href="#*=.;right=dimensions/conceptual-structure,index"><i></i>Conceptual structure</a> In many cases, the factoring of complexity follows the conceptual structure of the programming system.</p>
<p><a href="#*=.;right=dimensions/conceptual-structure,flattening-factoring"><i></i>Flattening and factoring</a> One typically automates the thing at the lowest level in one&#39;s factoring (by making the lowest level a thing that exists outside of the program—in a system or a library)</p>
</section>
<section data-file="dimensions/complexity" data-id="notations" data-title="Remark: Notations">

<p>Even when working at a high level, programming involves manipulating some program notation. In high-level functional or imperative programming languages, the programmer writes code that typically has clear operational meaning, even when some of the complexity is relegated to a library implementation or a runtime.</p>
<p>When using declarative programming systems like SQL, Prolog or Datalog, the meaning of a program is still unambiguous, but it is not defined operationally—there is a (more or less deterministic) inference engine that solves the problem based on the provided description.</p>
<p>Finally, systems based on <em>programming by example</em> step even further away from having clear operational meaning—the program may be simply a collection of sample inputs and outputs, from which a (possibly non-deterministic) engine infers the concrete steps of execution.</p>
</section>
<section data-file="dimensions/complexity" data-id="factoring" data-title="Dimension: Factoring of complexity">

<p>The basic mechanism for dealing with complexity is <em>factoring</em> it. Given a program, the more domain-specific aspects of the logic are specified explicitly, whereas the more mundane and technical aspects of the logic are left to a reusable component.</p>
<p>Often, this reusable component is just a library. Yet in the case of higher-level programming languages, the reusable component may include a part of a language runtime such as a memory allocator or a garbage collector. In case of declarative languages or programming by example, the reusable component is a general purpose inference engine.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/complexity" data-id="automation" data-title="Dimension: Level of automation">

<p>Factoring of complexity shields the programmer from some details, but those details still need to be explicitly programmed. Depending on the customizability of the system, this programming may or may not be accessible, but it is always there. For example, a function used in a spreadsheet formula is implemented in the spreadsheet system.</p>
<p>A programming system with higher <em>level of automation</em> requires more than simply factoring code into reusable components. It uses a mechanism where some details of the operational meaning of a program are never explicitly specified, but are inferred automatically by the system. This is the approach of <em>programming by example</em> and <em>machine learning</em>, where behaviour is specified through examples. In some cases, deciding whether a feature is <em>automation</em> or merely <em>factoring of complexity</em> is less clear: garbage collection can be seen as either a simple case of automation, or a sophisticated case of factoring complexity.</p>
<p>There is also an interesting (and perhaps inevitable) trade-off. The higher the level of automation, the less explicit the operational meaning of a program. This has a wide range of implications. Smaragdakis <a href="#*=.;right=paper,references" title=" Smaragdakis, Yannis. 2019. “Next-Paradigm Programming Languages: WhatWill They Look Like and What Changes Will They Bring?” In Proceedingsof the 2019 ACM SIGPLAN International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software, 187–97. Onward!2019. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/3359591.3359739.">83</a> notes, for example, that this means the implementation can significantly change the performance of a program.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/complexity" data-id="dsls" data-title="Example: Domain-specific languages">

<p>Domain-specific languages <a href="#*=.;right=paper,references" title=" Fowler, Martin. 2010. Domain-Specific Languages. Pearson Education.">23</a> provide an example of factoring of complexity that does not involve automation. In this case, programming is done at two levels. At the lower level, an (often more experienced) programmer develops a domain-specific language, which lets a (typically less experienced) programmer easily solve problems in a particular domain: say, modelling of financial contracts, or specifying interactive user interfaces.</p>
<p>The domain-specific language provides primitives that can be composed, but each primitive and each form of composition has explicitly programmed and unambiguous operational meaning. The user of the domain-specific language can think in the higher-level concepts it provides, and this conceptual structure can be analysed using the dimensions in <a href="#*=.;right=dimensions/conceptual-structure,index">Conceptual structure</a>. As long as these concepts are clear, the user does not need to be concerned with the details of how exactly the resulting programs run.</p>
</section>
<section data-file="dimensions/complexity" data-id="pbe" data-title="Example: Programming by example">

<p>An interesting case of automation is <em>programming by example</em>. <a href="#*=.;right=paper,references" title=" Lieberman, H. 2001. Your Wish Is My Command:Programming by Example. Morgan Kaufmann.">58</a> In this case, the user does not provide even a declarative specification of the program behavior, but instead specifies sample inputs and outputs. A more or less sophisticated algorithm then attempts to infer the relationship between the inputs and the outputs. This may, for example, be done through program synthesis where an algorithm composes a transformation using a (small) number of pre-defined operations. Programming by example is often very accessible and has been used in spreadsheet applications. <a href="#*=.;right=paper,references" title=" Gulwani, Sumit, William R Harris, and Rishabh Singh. 2012. “SpreadsheetData Manipulation Using Examples.” Communications of the ACM 55 (8):97–105.">36</a></p>
</section>
<section data-file="dimensions/complexity" data-id="next-level" data-title="Example: Next level automation">

<p>Throughout history, programmers have always hoped for the next level of &#34;automatic programming&#34;. As observed by Parnas, <a href="#*=.;right=paper,references" title=" Parnas, David Lorge. 1985. “Software Aspects of Strategic DefenseSystems.” http://web.stanford.edu/class/cs99r/readings/parnas1.pdf.">71</a> &#34;automatic programming has always been a euphemism for programming in a higher-level language than was then available to the programmer&#34;.</p>
<p>We may speculate whether Deep Learning will enable the next step of automation. However, this would not be different in principle from existing developments. We can see any level of automation as using <em>artificial intelligence</em> methods. This is the case for declarative languages or constraint-based languages—where the inference engine implements a traditional AI method (GOFAI, i.e., Good Old Fashioned AI).</p>
</section>
<section data-class="dimensions-conceptual-structure-anchor nobullet" data-file="dimensions/conceptual-structure" data-id="summary" data-title="Conceptual structure">

<p>How is meaning constructed? How are internal and external incentives balanced?</p>
<h2>Dimensions</h2>
<ul>
<li>
Does the system present as elegantly designed or pragmatically improvised?</li>
<li>
What are the primitives? How can they be combined to achieve novel behaviors?</li>
<li>
Which wheels do users not need to reinvent?</li>
<li>
How much is common structure explicitly marked as such?</li>
</ul>
<h2>Examples and remarks</h2>
<ul>
<li><a href="#*=.;right=dimensions/conceptual-structure,example-integrity!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/conceptual-structure,example-openness!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/conceptual-structure,flattening-factoring!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/conceptual-structure,end-of-history!"><i></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/conceptual-structure" data-id="index" data-title="Conceptual structure">

<p><strong>How is meaning constructed? How are internal and external incentives balanced?</strong></p>
<p>For more information, refer to the primary technical dimension of this cluster and its two extreme ends:</p>

<h2>References</h2>
<ul>
<li>How to Design a Good API and Why it Matters <a href="#*=.;right=paper,references" title=" Bloch, Joshua. 2007. “How to Design a Good API and Why It Matters.”2007.http://www.cs.bc.edu/~muller/teaching/cs102/s06/lib/pdf/api-design.">6</a></li>
</ul>
</section>
<section data-file="dimensions/conceptual-structure" data-id="integrity-openness" data-title="Dimension: Conceptual integrity versus openness">

<p>The evolution of programming systems has led away from <em>conceptual integrity</em> towards an intricate ecosystem of specialized technologies and industry standards. Any attempt to unify parts of this ecosystem into a coherent whole will create <em>incompatibility</em> with the remaining parts, which becomes a major barrier to adoption. Designers seeking adoption are pushed to focus on localized incremental improvements that stay within the boundaries established by existing practice. This creates a tension between how highly they can afford to value conceptual elegance, and how open they are to the pressures imposed by society. We will turn to both of these opposite ends---<em>integrity</em> and <em>openness</em>---in more detail.</p>
<h2>Related examples</h2>

</section>
<section data-class="doc" data-file="dimensions/conceptual-structure" data-id="example-integrity" data-title="Example: Conceptual integrity">

<blockquote>
<p>I will contend that Conceptual Integrity is the most important consideration in system design. It is better to have a system omit certain anomalous features and improvements, but to reflect one set of design ideas, than to have one that contains many good but independent and uncoordinated ideas.</p>
<p>Fred Brooks, <em>Aristocracy, Democracy and System Design</em> <a href="#*=.;right=paper,references" title=" Brooks, FP. 1995. “Aristocracy, Democracy and System Design.” In TheMythical Man Month: Essays on Software Engineering. Addison-Wesley.">8</a></p>
</blockquote>

<blockquote>
<p>Conceptual integrity arises not (simply) from one mind or from a small number of agreeing resonant minds, but from sometimes hidden co-authors and the thing designed itself.</p>
<p>Richard Gabriel, <em>Designed As Designer</em> <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 2008. “Designed as Designer.” In Proceedings of the 23rd ACMSIGPLAN Conference on Object-Oriented Programming Systems Languages andApplications, 617–32. OOPSLA ’08. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/1449764.1449813.">28</a></p>
</blockquote>
<p>Conceptual integrity strives to reduce complexity at the source; it employs <em>unified concepts</em> that may <em>compose orthogonally</em> to generate diversity. Perhaps the apotheosis of this approach can be found in early Smalltalk and Lisp machines, which were complete programming systems built around a single language. They incorporated capabilities commonly provided <em>outside</em> the programming language by operating systems and databases. Everything was done in one language, and so everything was represented with the datatypes of that language. Likewise the libraries and idioms of the language were applicable in all contexts. Having a <em>lingua franca</em> avoided much of the friction and impedance mismatches inherent to multi-language systems. A similar drive exists in the Python programming language, which follows the principle that “There should be one—and preferably only one—obvious way to do it” in order to promote community consensus on a single coherent style.</p>
<h2>Memory models of programming langauges</h2>
<p>In addition to Smalltalk and Lisp, many programming languages focus on one kind of data structure. As pointed out by Kragen Javier Sitaker: <a href="#*=.;right=paper,references" title=" Sitaker, Kragen Javier. 2016. “The Memory Models That UnderlieProgramming Languages.” 2016.http://canonical.org/~kragen/memory-models/.">82</a></p>
<div>
<ul>
<li>In COBOL, data consists of nested records as in a business form.</li>
<li>In Fortran, data consists of parallel arrays.</li>
<li>In SQL, data is a set of relations with key constraints.</li>
<li>In scripting languages like Python, Ruby, and Lua, much data takes the form of string-indexed hash tables.</li>
</ul>
</div>
<p>Finally, many languages are <em>imperative</em>, staying close to the hardware model of addressable memory, lightly abstracted into primitive values and references into mutable arrays and structures. On the other hand, <em>functional</em> languages hide references and treat everything as immutable structured values. This conceptual simplification benefits certain kinds of programming, but can be counterproductive when an imperative approach is more natural, such as in external input/output.</p>
</section>
<section data-file="dimensions/conceptual-structure" data-id="example-openness" data-title="Example: Conceptual openness">

<h2>Perl, contra Python</h2>
<p>In contrast to Python&#39;s outlook, Perl proclaims “There is more than one way to do it” and considers itself “the first postmodern programming language”. <a href="#*=.;right=paper,references" title=" Wall, Larry. 1999. “Perl, the First Postmodern Computer Language.” 1999.http://www.wall.org//~larry/pm.html.">94</a> “Perl doesn&#39;t have any agenda at all, other than to be maximally useful to the maximal number of people. To be the duct tape of the Internet, and of everything else.” The Perl way is to accept the status quo of evolved chaos and build upon it using duct tape and ingenuity. Taken to the extreme, a programming system becomes no longer a <em>system</em>, properly speaking, but rather a <em>toolkit for improvising</em> assemblages of <em>found</em> software. Perl can be seen as championing the values of <em>pluralism</em>, <em>compatibility</em>, or <em>conceptual openness</em> over conceptual integrity. This philosophy has been called <em>Postmodern Programming</em>. <a href="#*=.;right=paper,references" title=" Noble, James, and Robert Biddle. 2004. “Notes on Notes on PostmodernProgramming.” SIGPLAN Not. 39 (12): 40–56.https://doi.org/10.1145/1052883.1052890.">67</a></p>
<h2>C++, contra Smalltalk</h2>
<p>Another case is that of C++, which added to C the Object-Oriented concepts developed by Smalltalk while remaining 100% compatible with C, down to the level of ABI and performance. This strategy was enormously successful for adoption, but came with the tradeoff of enormous complexity compared to languages designed from scratch for OO, like Smalltalk, Ruby, and Java.</p>
<h2>Worse, contra Better</h2>
<p>Richard Gabriel first described this dilemma in his influential 1991 essay <em>Worse is Better</em> <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 1991. “Worse Is Better.” 1991.https://www.dreamsongs.com/WorseIsBetter.html.">27</a> analyzing the defeat of Lisp by UNIX and C. Because UNIX and C were so easy to port to new hardware, they were “the ultimate computer viruses” despite providing only “about 50%--80% of what you want from an operating system and programming language”. Their conceptual openness meant that they adapted easily to the evolving conditions of the external world. The tradeoff was decreased conceptual integrity, such as the undefined behaviours of C, the junkyard of working directories, and the proliferation of special purpose programming languages to provide a complete development environment.</p>
<h2>UNIX and Files</h2>
<p>Many programming languages and systems impose structure at a &#34;fine granularity&#34;: that of individual variables and other data and code structures. Conversely, systems like UNIX and the Web impose fewer restrictions on how programmers represent things. UNIX insists only on a basic infrastructure of &#34;large objects&#34;, <a href="#*=.;right=paper,references" title=" Kell, Stephen. 2013. “The Operating System: Should There Be One?” In Proceedingsof the Seventh Workshop on Programming Languages and Operating Systems.PLOS ’13. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2525528.2525534.">46</a> delegating all fine-grained structure to client programs. This scores many points for conceptual openness. <em>Files</em> provide a universal API for reading and writing byte streams, a low-level construct containing so many degrees of freedom that it can support a wide variety of formats and ecosystems. <em>Processes</em> similarly provide a thin abstraction over machine-level memory and processors.</p>
<p>Concepual integrity is necessarily sacrificed for such openness; while &#34;everything is a file&#34; gestures at integrity, in the vein of Smalltalk&#39;s &#34;everything is an object&#34;, exceptions proliferate. Directories are special kinds of files with special operations, hardware device files require special <code>ioctl</code> operations, and many commands expect files containing newline separators. Additionally, because client programs must supply their <em>own</em> structure for fine-grained data and code, they are given little in the way of mutual compatibility. As a result, they tend to evolve into competing silos of duplicated infrastructure. <a href="#*=.;right=paper,references" title=" Kell, Stephen. 2013. “The Operating System: Should There Be One?” In Proceedingsof the Seventh Workshop on Programming Languages and Operating Systems.PLOS ’13. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2525528.2525534.">46</a> <a href="#*=.;right=paper,references" title=" Kell, Stephen. 2009. “The Mythical Matched Modules: Overcoming theTyranny of Inflexible Software Construction.” In OOPSLA Companion.">45</a></p>
<h2>The Web</h2>
<p>Web HTTP endpoints, meanwhile, have proven to be an even more adaptable and viral abstraction than UNIX files. They operate at a similar level of abstraction as files, but support richer content and encompass internet-wide interactions between autonomous systems. In a sense, HTTP GET and PUT have become the &#34;subroutine calls&#34; of an internet-scale programming system. Perhaps the most salient thing about the Web is that its usefulness came as such a surprise to everyone involved in designing or competing with it. It is likely that, by staying close to the existing practice of transferring files, the Web gained a competitive edge over more ambitious and less familiar hypertext projects like Xanadu. <a href="#*=.;right=paper,references" title=" Nelson, T. H. 1965. “Complex Information Processing: A File Structurefor the Complex, the Changing and the Indeterminate.” In Proceedings ofthe 1965 20th National Conference, 84–100. ACM ’65. New York, NY, USA:Association for Computing Machinery.https://doi.org/10.1145/800197.806036.">66</a></p>
<p>The choice between compatibility and integrity correlates with the personality traits of <em>pragmatism</em> and <em>idealism</em>. It is pragmatic to accept the status quo of technology and make the best of it. Conversely, idealists are willing to fight convention and risk rejection in order to attain higher goals. We can wonder which came first: the design decision or the personality trait? Do Lisp and Haskell teach people to think more abstractly and coherently, or do they filter for those with a pre-existing condition? Likewise, perhaps  introverted developers prefer the cloisters of Smalltalk or Lisp to the adventurous &#34;Wild West&#34; of the Web.</p>
</section>
<section data-file="dimensions/conceptual-structure" data-id="composability" data-title="Dimension: Composability">

<p>In short, <em>you can get anywhere by putting together a number of smaller steps.</em> There exist building blocks which span a range of useful combinations.
Composability is, in a sense, key to the notion of &#34;programmability&#34; and every programmable system will have some level of composability (e.g. in the scripting language.)</p>
<h2>UNIX</h2>
<p>UNIX shell commands are a standard example of composability. The base set of primitive commands can be augmented by programming command executables in other languages. Given some primitives, one can &#34;pipe&#34; one&#39;s output to another&#39;s input (<code>|</code>), sequence (<code>;</code> or <code>&amp;&amp;</code>), select via conditions, and repeat with loop constructs, enabling full imperative programming. Furthermore, command compositions can be packaged into a named &#34;script&#34; which follows the same interface as primitive commands, and named subprograms within a script can also be defined.</p>
<h2>HyperCard</h2>
<p>In <em>HyperCard</em>, the <em>Authoring Environment</em> is <em>non</em>-composable for programming buttons: there is simply a set of predefined behaviors to choose from. Full scriptability is available only in the <em>Programming Environment</em>.</p>
<h2>Haskell</h2>
<p>The <em>Haskell type system</em>, as well as that of other functional programming languages, exhibits high composability. New types can be defined in terms of existing ones in several ways. These include records, discriminated unions, function types and recursive constructs (e.g. to define a <code>List</code> as either a <code>Nil</code> or a combination of element plus other list.) The C programming language also has some means of composing types that are analogous in some ways, such as structs, unions, enums and indeed even function pointers. For every type, there is also a corresponding &#34;pointer&#34; type. It lacks, however, the recursive constructs permitted in Haskell types.</p>
</section>
<section data-file="dimensions/conceptual-structure" data-id="convenience" data-title="Dimension: Convenience">

<p>In short, <em>you can get to X, Y or Z via one single step.</em> There are ready-made solutions to specific problems, not necessarily generalizable or composable. Convenience often manifests as &#34;canonical&#34; solutions and utilities in the form of an expansive standard library.</p>
<h2>Composability and convenience</h2>
<p>Composability without convenience is a set of atoms or gears; theoretically, anything one wants could be built out of them, but one must do that work. This situation has been criticized as the <em>Lisp Curse</em>. <a href="#*=.;right=paper,references" title=" Winestock, Rudolf. 2011. “The Lisp Curse.” 2011.http://www.winestockwebdesign.com/Essays/Lisp_Curse.html.">95</a></p>
<p>Composability <em>with</em> convenience is a set of convenient specific tools <em>along with</em> enough components to construct new ones. The specific tools themselves could be transparently composed of these building blocks, but this is not essential. They save users the time and effort it would take to &#34;roll their own&#34; solutions to common tasks.</p>
<h2>UNIX shell</h2>
<p>For example, let us turn to a convenience factor of <em>UNIX</em> shell commands, having already discussed their composability above. Observe that it would be possible, in principle, to pass all information to a program via standard input. Yet in actual practice, for convenience, there is a standard interface of <em>command-line arguments</em> instead, separate from anything the program takes through standard input. Most programming systems similarly exhibit both composability and convenience, providing templates, standard libraries, or otherwise pre-packaged solutions, which can nevertheless be used programmatially as part of larger operations.</p>
</section>
<section data-file="dimensions/conceptual-structure" data-id="commonality" data-title="Dimension: Commonality">

<p>Humans can see Arrays, Strings, Dicts and Sets all have a “size”, but the software needs to be <em>told</em> that they are the “same”. Commonality like this can be factored out into an explicit structure (a “Collection” class), analogous to database <em>normalization</em>. This way, an entity&#39;s size can be queried without reference to its particular details: if <code>c</code> is declared to be a Collection, then one can straightforwardly access <code>c.size</code>.</p>
<p>Alternatively, it can be left implicit. This is less upfront work, but permits instances to <em>diverge</em>, analogous to <em>redundancy</em> in databases. For example, Arrays and Strings might end up with “length”, while Dict and Set call it “size”. This means that, to query the size of an entity, it is necessary to perform a case split according to its concrete type, solely to funnel the diverging paths back to the commonality they represent:</p>
<pre><code>if (entity is Array or String)  size := entity.length
else if (entity is Dict or Set) size := entity.size
</code></pre>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/conceptual-structure" data-id="flattening-factoring" data-title="Examples: Flattening and factoring">

<p>Data structures usually have several &#34;moving parts&#34; that can vary independently. For example, a simple pair of “vehicle type” and “color” might have all combinations of (Car, Van, Train) and (Red, Blue). In this <em>factored</em> representation, we can programmatically change the color directly: <code>pair.second = Red</code> or <code>vehicle.colour = Red</code>.</p>
<p>In some contexts, such as class names, a system might only permit such multi-dimensional structure as an <em>exhaustive enumeration</em>: RedCar, BlueCar, RedVan, BlueVan, RedTrain, BlueTrain, etc. The system sees a flat list of atoms, even though a human can see the sub-structure encoded in the string. In this world, we cannot simply “change the color to Red” programmatically; we would need to case-split as follows:</p>
<pre><code>if (type is BlueCar) type := RedCar
else if (type is BlueVan) type := RedVan
else if (type is BlueTrain) type := RedTrain
</code></pre>
<p>The <em>commonality</em> between RedCar, RedVan, BlueCar, and so on has been <em>flattened</em>. There is implicit structure here that remains <em>un-factored</em>, similar to how numbers can be expressed as singular expressions (16) or as factor products (2,2,2,2). <em>Factoring</em> this commonality gives us the original design, where there is a pair of values from different sets.</p>
<p>In <em>relational databases</em>, there is an opposition between <em>normalization</em> and <em>redundancy</em>. In order to fit multi-table data into a <em>flat</em> table structure, data needs to be duplicated into redundant copies. When data is <em>factored</em> into small tables as much as possible, such that there is only one place each piece of data &#34;lives&#34;, the database is in <em>normal form</em> or <em>normalized</em>. Redundancy is useful for read-only processes, because there is no need to join different tables together based on common keys. Writing, however, becomes risky; in order to modify one thing, it must be synchronized to the multiple places it is stored. This makes highly normalized databases optimized for writes over reads.</p>
</section>
<section data-file="dimensions/conceptual-structure" data-id="end-of-history" data-title="Remark: The end of history?">

<p>Today we live in a highly developed world of software technology. It is estimated that 41,000 person years have been invested into Linux. We describe software development technologies in terms of <em>stacks</em> of specialized tools, each of which might capitalize over 100 person-years of development. Programming systems have become programming ecosystems: not designed, but evolved. How can we noticeably improve programming in the face of the overwhelming edifice of existing technology? There are strong incentives to focus on localized incremental improvements that don’t cross the established boundaries.</p>
<p>The history of computing is one of cycles of evolution and revolution. Successive cycles were dominated in turn by mainframes, minicomputers, workstations, personal computers, and the Web. Each transition built a whole new technology ecosystem replacing or on top of the previous. The last revolution, the Web, was 25 years ago, with the result that many people have never experienced a disruptive platform transition. Has history stopped, or are we just stuck in a long cycle, with increasingly pent-up pressures for change? If it is the latter, then incompatible ideas now spurned may yet flourish.</p>
</section>
<section data-class="dimensions-customizability-anchor nobullet" data-file="dimensions/customizability" data-id="summary" data-title="Customizability">

<p>Once a program exists in the system, how can it be extended and modified?</p>
<h2>Dimensions</h2>
<ul>
<li>
Must we customize running programs differently to inert ones? Do these changes last beyond termination?</li>
<li>
Which portions of the system’s state can be referenced and transferred to/from it? How far can the system’s behavior be changed by adding expressions?</li>
<li>
How far can the system’s behavior be changed from within?</li>
</ul>
</section>
<section data-file="dimensions/customizability" data-id="index" data-title="Customizability">

<p><strong>Once a program exists in the system, how can it be extended and modified?</strong></p>
<p>Programming is a gradual process. We start either from nothing, or from an existing program, and gradually extend and refine it until it serves a given purpose. Programs created using different programming systems can be refined to different extents, in different ways, at different stages of their existence.
Consider three examples:</p>
<ol>
<li>First, a program in a conventional programming language like Java can be refined only by modifying its source code. However, you may be able to do so by just adding new code, such as a new interface implementation.</li>
<li>Second, a spreadsheet can be modified at any time by modifying the formulas or data it contains. There is no separate programming phase. However, you have to modify the formulas directly in the cell—there is no way of modifying it by specifying a change in a way that is external to the cell.</li>
<li>Third, a <em>self-sustaining</em> programming system, such as Smalltalk, does not make an explicit distinction between &#34;programming&#34; and &#34;using&#34; phases, and it can be modified and extended via itself. It gives developers the power to experiment with the system and, in principle, replace it with a better system from within.</li>
</ol>
<h2>References</h2>
<p>In addition to the examples discussed in text, the proceedings of self-sustaining systems workshops <a href="#*=.;right=paper,references" title=" Hirschfeld, Robert, and Kim Rose, eds. 2008. Self-Sustaining Systems,First Workshop, S3 2008, Potsdam, Germany, May 15-16, 2008, RevisedSelected Papers. Vol. 5146. Lecture Notes in Computer Science.Springer. https://doi.org/10.1007/978-3-540-89275-5.">42</a> <a href="#*=.;right=paper,references" title=" Hirschfeld, Robert, Hidehiko Masuhara, and Kim Rose, eds. 2010.Workshop on Self-Sustaining Systems, S3 2010, Tokyo, Japan, September27-28, 2010. ACM. https://doi.org/10.1145/1942793.">41</a> provide numerous examples of systems and languages that are able to bootstrap, implement, modify, and maintain themselves; Gabriel&#39;s analysis of programming language revolutions <a href="#*=.;right=paper,references" title=" Gabriel, Richard P. 2012. “The Structure of a Programming Language Revolution.” InProceedings of the ACM International Symposium on New Ideas, NewParadigms, and Reflections on Programming and Software, 195–214.Onward! 2012. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2384592.2384611.">29</a> uses <em>advising</em> in PILOT, related Lisp mechanisms, and &#34;mixins&#34; in OOP to illustrate the difference between the &#34;languages&#34; and &#34;systems&#34; paradigms.</p>
<h2>Relations</h2>
<p><a href="#*=.;right=dimensions/conceptual-structure,flattening-factoring"><i></i>Flattening and factoring</a> Related in that &#34;customizability&#34; is a form of creating new programs from existing ones; factoring repetitive aspects into a reusable standard component library facilitates the same thing.</p>
<p><a href="#*=.;right=dimensions/interaction,index"><i></i>Interaction</a> This determines whether there are separate stages for running and writing programs and may thus influence what kind of customization is possible.</p>
</section>
<section data-file="dimensions/customizability" data-id="staging" data-title="Dimension: Staging of customization">

<p>For systems that distinguish between different stages, such as writing source code versus running a program, customization methods may be different for each stage. In traditional programming languages, customization is done by modifying or adding source code at the programming stage, but there is no (automatically provided) way of customizing the created programs once they are running.</p>
<p>There are a number of interesting questions related to staging of customization. First, what is the notation used for customization? This may be the notation in which a program was initially created, but a system may also use a secondary notation for customization (consider Emacs using Emacs Lisp). For systems with a stage distinction, an important question is whether such changes are <em>persistent</em>.</p>
<h2>Smalltalk, Interlisp and similar</h2>
<p>In image-based programming systems, there is generally no strict distinction between stages and so a program can be customized during execution in the same way as during development. The program image includes the programming environment. Users of a program can open this, navigate to a suitable object or a class (which serve as the <em>addressable extension points</em>) and modify that. Lisp-based systems such as <em>Interlisp</em> follow a similar model. Changes made directly to the image are persistent. The PILOT system for Lisp <a href="#*=.;right=paper,references" title=" Teitelman, Warren. 1966. “PILOT: A Step Toward Man-Computer Symbiosis.”PhD thesis, MIT.">90</a> offers an interactive way of correcting errors when a program fails during execution. Such corrections are then applied to the image and are thus persistent.</p>
<h2>Document Object Model (DOM) and Webstrates</h2>
<p>In the context of Web programming, there is traditionally a stage distinction between programming (writing the code and markup) and running (displaying a page). However, the DOM can also be modified by browser Developer Tools—either manually, by running scripts in a console, or by using a userscript manager such as Greasemonkey. Such changes are not persistent in the default browser state, but are made so by Webstrates <a href="#*=.;right=paper,references" title=" Klokmose, Clemens N., James R. Eagan, Siemen Baader, Wendy Mackay, andMichel Beaudouin-Lafon. 2015. “Webstrates: Shareable Dynamic Media.” InProceedings of the 28th Annual ACM Symposium on User Interface Software&amp; Technology, 280–90. UIST ’15. New York, NY, USA: Association forComputing Machinery. https://doi.org/10.1145/2807442.2807446.">50</a> which synchronize the DOM between the server and the client. This makes the DOM collaborative, but not (automatically) <em>live</em> because of the complexities this implies for event handling.</p>
</section>
<section data-file="dimensions/customizability" data-id="addressing" data-title="Dimension: Addressing and externalizability">

<p>Programs in all programming systems have a representation that may be exposed through notation such as source code. When customizing a program, an interesting question is whether a customization needs to be done by modifying the original representation, or whether it can be done by <em>adding</em> something alongside the original structure.</p>
<p>In order to support customization through addition, a programming system needs a number of characteristics introduced by Basman et al. <a href="#*=.;right=paper,references" title=" Basman, Antranig, L. Church, C. Klokmose, and Colin B. D. Clark. 2016.“Software and How It Lives on: Embedding Live Programs in the WorldAround Them.” In PPIG.">3</a> <a href="#*=.;right=paper,references" title=" Basman, Antranig, Clayton Lewis, and Colin Clark. 2018. “The OpenAuthorial Principle: Supporting Networks of Authors in CreatingExternalisable Designs.” In Proceedings of the 2018 ACM SIGPLANInternational Symposium on New Ideas, New Paradigms, and Reflections onProgramming and Software, 29–43.">2</a> First, the system needs to support <em>addressing</em>: the ability to refer to a part of the program representation from the outside. Next, <em>externalizability</em> means that a piece of addressed state can be exhaustively transferred between the system and the outside world.</p>
<p>Finally, <em>additive authoring</em> requires that system behaviours can be <em>changed</em> by simply <em>adding</em> a new expression containing addresses—in other words, anything can be <em>overriden</em> without being <em>erased</em>. Of particular importance is how addresses are specified and what extension points in the program they can refer to. The system may offer an automatic mechanism that makes certain parts of a program addressable, or this task may be delegated to the programmer.</p>
<h2>Cascading Style Sheets (CSS)</h2>
<p>CSS is a prime example of additive authoring within the Web programming system. It provides rich addressability mechanisms that are partly automatic (when referring to tag names) and partly manual (when using element IDs and class names). Given a web page, it is possible to modify almost any aspect of its appearance by simply <em>adding</em> additional rules to a CSS file. The Infusion project <a href="#*=.;right=paper,references" title=" Basman, Antranig. 2021. “Infusion Framework and Components.” 2021.https://fluidproject.org/infusion.html.">5</a> offers similar customizability mechanisms, but for behaviour rather than just styling. There is also the recent programming system Varv, <a href="#*=.;right=paper,references" title=" Borowski, Marcel, Luke Murray, Rolf Bagge, Janus Bager Kristensen,Arvind Satyanarayan, and Clemens Nylandsted Klokmose. 2022. “Varv:Reprogrammable Interactive Software as a Declarative Data Structure.” InCHI Conference on Human Factors in Computing Systems. CHI ’22. NewYork, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/3491102.3502064.">7</a> which embodies additive authoring as a core principle.</p>
<h2>Object Oriented Programming (OOP) and Aspect Oriented Programming (AOP)</h2>
<p>In conventional programming languages, customization is done by modifying the code itself. OOP and AOP make it possible to do so by adding code independently of existing program code. In OOP, this requires manual definition of extension points, i.e. interfaces and abstract methods. Functionality can then be added to a system by defining a new class (although injecting the new class into existing code without modification requires some form of configuration such as a dependency injection container). AOP systems such as AspectJ <a href="#*=.;right=paper,references" title=" Kiczales, Gregor, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm,and William G. Griswold. 2001. “An Overview of AspectJ.” In ECOOP2001 - Object-Oriented Programming, 15th European Conference, Budapest,Hungary, June 18-22, 2001, Proceedings, edited by Jørgen LindskovKnudsen, 2072:327–53. Lecture Notes in Computer Science. Springer.https://doi.org/10.1007/3-540-45337-7\\18.">48</a> provides a richer addressing mechanism. In particular, it makes it possible to add functionality to the invocation of a specific method (among other options) by using the <em>method call pointcut</em>. This functionality is similar to <em>advising</em> in Pilot <a href="#*=.;right=paper,references" title=" Teitelman, Warren. 1966. “PILOT: A Step Toward Man-Computer Symbiosis.”PhD thesis, MIT.">90</a>.</p>
</section>
<section data-file="dimensions/customizability" data-id="self-sustainability" data-title="Dimension: Self-sustainability">

<p>For most programming languages, programming systems, and ordinary software applications, if one wants to customize beyond a certain point, one must go beyond the facilities provided in the system itself. Most programming systems maintain a clear distinction between the <em>user level</em>, where the system is used, and <em>implementation level</em>, where the source code of the system itself resides. If the user level does not expose control over some property or feature, then one is forced to go to the implementation level. In the common case this will be a completely different language or system, with an associated learning cost. It is also likely to be lower-level—lacking expressive functions, features or abstractions of the user level—which makes for a more tedious programming experience.</p>
<h2>Progressively evolvable systems</h2>
<p>It is possible, however, to carefully design systems to expose deeper aspects of their implementation <em>at the user level</em>, relaxing the formerly strict division between these levels. For example, in the research system <em>3-Lisp</em>, <a href="#*=.;right=paper,references" title=" Smith, Brian Cantwell. 1982. “Procedural Reflection in ProgrammingLanguages.” PhD thesis, Massachusetts Institute of Technology.https://dspace.mit.edu/handle/1721.1/15961.">84</a> ordinarily built-in functions like the conditional <code>if</code> and error handling <code>catch</code> are implemented in 3-Lisp code at the user level.</p>
<p>The degree to which a system&#39;s inner workings are accessible to the user level, we call <em>self-sustainability</em>. At the maximal degree of this dimension would reside &#34;stem cell&#34;-like systems: those which can be progressively evolved to arbitrary behavior without having to &#34;step outside&#34; of the system to a lower implementation level. In a sense, any difference between these systems would be merely a difference in initial state, since any could be turned into any other.</p>
<h2>Minimal customizability</h2>
<p>The other end, of minimal self-sustainability, corresponds to minimal customizability: beyond the transient run-time state changes that make up the user level of any piece of software, the user cannot change anything without dropping down to the means of implementation of the system. This would resemble a traditional end-user &#34;application&#34; focused on a narrow domain with no means to do anything else.</p>
<h2>Self-describing systems</h2>
<p>The terms &#34;self-describing&#34; or &#34;self-implementing&#34; have been used for this property, but they can invite confusion: how can a thing describe itself? Instead, a system that can <em>sustain itself</em> is an easier concept to grasp. The examples that we see of high self-sustainability all tend to be <em>Operating System-like</em>. UNIX is widely established as an operating system, while Smalltalk and Lisp have been branded differently. Nevertheless, all three have shipped as the operating systems of custom hardware, and have similar responsibilities. Specifically: they support the execution of &#34;programs&#34;; they define an interface for accessing and modifying state; they provide standard libraries of common functionality; they define how programs can communicate with each other; they provide a user interface.</p>
<h2>UNIX</h2>
<p>Self-sustainability of UNIX is owed to the combination of two factors. First, the system is implemented in binary files (via ELF, Executable and Linkable Format) and text files (for configuration). Second, these files are part of the user-facing filesystem, so users can replace and modify parts of the system using UNIX file interfaces.</p>
<h2>Smalltalk and Combined Object Lambda Architectures</h2>
<p>Self-sustainability in Smalltalk is similar to UNIX, but at a finer granularity and with less emphasis on whether things reside in volatile (process) or non-volatile (file) storage. The analogous points are that (1) the system is implemented as objects with methods containing Smalltalk code, and (2) these are modifiable using the class browser and code editor. Combined Object Lambda Architectures, or COLAs, <a href="#*=.;right=paper,references" title=" Piumarta, Ian. 2006. “Accessible Language-Based Environments ofRecursive Theories.” 2006.http://www.vpri.org/pdf/rn2006001a_colaswp.pdf.">77</a> are a theoretical system design to improve on the self-sustainability of Smalltalk. This is achieved by generalizing the object model to support relationships beyond classes.</p>
</section>
<section data-class="dimensions-errors-anchor nobullet" data-file="dimensions/errors" data-id="summary" data-title="Errors">

<p>What does the system consider to be an error? How are they prevented and handled?</p>
<h2>Dimensions</h2>
<ul>
<li>
What errors can be detected in which feedback loops, and how?</li>
<li>
How does the system respond when an error is detected?</li>
</ul>
<h2>Examples and remarks</h2>
<ul>
<li><a href="#*=.;right=dimensions/errors,static-typing!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/errors,tdd-repl-live!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/errors,latent-errors!"><i></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/errors" data-id="index" data-title="Interaction">

<p><strong>What does the system consider to be an error? How are they prevented and handled?</strong></p>
<p>A computer system is not aware of human intentions. There will always be human mistakes that the system cannot recognize as errors. Despite this, there are many that it <em>can</em> recognize, and its design will determine <em>which</em> human mistakes can become detectable program errors. This revolves around several questions: What can cause an error? Which ones can be prevented from happening? How should the system react to errors?</p>
<p>Following the standard literature on errors, <a href="#*=.;right=paper,references" title=" Reason, James. 1990. Human Error. Cambridge university press.">79</a> we distinguish four kinds of errors: slips, lapses, mistakes and failures. A <em>slip</em> is an error caused by transient human attention failure, such as a typo in the source code. A <em>lapse</em> is similar but caused by memory failure, such as an incorrectly remembered method name. A <em>mistake</em> is a logical error such as bad design of an algorithm. Finally, a <em>failure</em> is a system error caused by the system itself that the programmer has no control over, e.g. a hardware or a virtual machine failure.</p>
<h2>References</h2>
<p>The most common error handling mechanism in conventional programming languages is exception handling. The modern form of exception handling has been described by Goodenough; <a href="#*=.;right=paper,references" title=" Goodenough, John B. 1975. “Exception Handling: Issues and a ProposedNotation.” Commun. ACM 18 (12): 683–96.https://doi.org/10.1145/361227.361230.">32</a> Ryder et al. <a href="#*=.;right=paper,references" title=" Ryder, Barbara G., Mary Lou Soffa, and Margaret Burnett. 2005. “TheImpact of Software Engineering Research on Modern ProgrammingLanguages.” ACM Trans. Softw. Eng. Methodol. 14 (4): 431–77.https://doi.org/10.1145/1101815.1101818.">80</a> documents the history and influences of Software Engineering on exception handling. The concept of <em>antifragile software</em> <a href="#*=.;right=paper,references" title=" Monperrus, Martin. 2017. “Principles of Antifragile Software.” InCompanion to the First International Conference on the Art, Science andEngineering of Programming. Programming ’17. New York, NY, USA:Association for Computing Machinery.https://doi.org/10.1145/3079368.3079412.">65</a> goes further by suggesting that software could improve in response to errors. Work on Chaos Engineering <a href="#*=.;right=paper,references" title=" Chang, Michael Alan, Bredan Tschaen, Theophilus Benson, and Laurent Vanbever. 2015a. “Chaos Monkey: Increasing SDN Reliability ThroughSystematic Network Destruction.” In Proceedings of the 2015 ACMConference on Special Interest Group on Data Communication, 371–72.SIGCOMM ’15. New York, NY, USA: Association for Computing Machinery.https://doi.org/10.1145/2785956.2790038.">11</a> is a step in this direction.</p>
<p>Reason <a href="#*=.;right=paper,references" title=" Reason, James. 1990. Human Error. Cambridge university press.">79</a> analyses errors in the context of human errors and develops a classification of errors that we adopt. In the context of computing, errors or <em>miscomputation</em> has been analysed from a philosophical perspective. <a href="#*=.;right=paper,references" title=" Fresco, Nir, and Giuseppe Primiero. 2013. “Miscomputation.” Philosophy&amp; Technology 26 (3): 253–72.">24</a> <a href="#*=.;right=paper,references" title=" Floridi, Luciano, Nir Fresco, and Giuseppe Primiero. 2015. “OnMalfunctioning Software.” Synthese 192 (4): 1199–1220.">21</a> Notably, attitudes and approaches to errors also differ for different programming subcultures. <a href="#*=.;right=paper,references" title=" Petricek, Tomas. 2017. “Miscomputation in Software: Learning to Livewith Errors.” Art Sci. Eng. Program. 1 (2): 14.https://doi.org/10.22152/programming-journal.org/2017/1/14.">76</a></p>
<h2>Relations</h2>
<p><a href="#*=.;right=dimensions/interaction,feedback-loops"><i></i>Feedback loops</a> Error detection always happens as part of an individual feedback loop. The feedback loops thus determine the structure at which error detection can happen.</p>
<p><a href="#*=.;right=dimensions/complexity,automation"><i></i>Levels of automation</a> A semi-automatic error recovery system (such as DWIM) implements a form of automation. The concept of antifragile software <a href="#*=.;right=paper,references" title=" Monperrus, Martin. 2017. “Principles of Antifragile Software.” InCompanion to the First International Conference on the Art, Science andEngineering of Programming. Programming ’17. New York, NY, USA:Association for Computing Machinery.https://doi.org/10.1145/3079368.3079412.">65</a> is a more sophisticated example of error recovery through automation.</p>
<p><a href="#*=.;right=dimensions/notation,expression-geography"><i></i>Expression geography</a> In an expression geography where small changes in notation lead to valid but differently behaved programs, a slip or lapse is more likely to lead to an error that is difficult to detect through standard mechanisms.</p>
</section>
<section data-file="dimensions/errors" data-id="error-detection" data-title="Dimension: Error detection">

<p>Errors can be identified in any of the <em>feedback loops</em> that the system implements. This can be done either by a human or the system itself, depending on the nature of the feedback loop.</p>
<p>Consider three examples:</p>
<ol>
<li>First, in live programming systems, the programmer immediately sees the result of their code changes. Error detection is done by a human and the system can assist this by visualizing as many consequences of a code change as possible.</li>
<li>Second, in a system with a static checking feedback loop (such as syntax checks, static type systems), potential errors are reported as the result of the analysis.</li>
<li>Third, errors can be detected when the developed software is run, either when it is tested by the programmer (manually or through automated testing) or when it is run by a user.</li>
</ol>
<p>Error detection in different feedback loops is suitable for detecting different kinds of errors. Many slips and lapses can be detected by the static checking feedback loop, although this is not always the case. For example, consider a &#34;compact&#34; <em>expression geography</em> where small changes in code may result in large changes of behaviour. This makes it easier for slips and lapses to produce hard to detect errors. Mistakes are easier to detect through a live feedback loop, but they can also be partly detected by more advanced static checking.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/errors" data-id="static-typing" data-title="Example: Static typing">

<p>In statically typed programming languages like Haskell and Java, types are used to capture some information about the intent of the programmer. The type checker ensures code matches the lightweight specification given using types. In such systems, types and implementation serve as two descriptions of programmer&#39;s intent that need to align; what varies is the extent to which types can capture intent and the way in which the two are constructed; that is, which of the two comes first.</p>
</section>
<section data-file="dimensions/errors" data-id="tdd-repl-live" data-title="Examples: TDD, REPL and live coding">

<p>Whereas static typing aims to detect errors without executing code, approaches based on immediate feedback typically aim to execute (a portion of) the code and let the programmer see the error immediately. This can be done in a variety of ways.</p>
<p>In case of <em>test-driven development</em>, tests play the role of specification (much like types) against which the implementation is checked. Such systems may provide more or less immediate feedback, depending on when tests are executed (automatically in the background, or manually).</p>
<p>Systems equipped with a read-eval-print loop (REPL) let programmers run code on-the-fly and inspect results. For successful error detection, the results need to be easily observable: a printed output is more helpful than a hidden change of system state.</p>
<p>Finally, in live coding systems, code is executed immediately and the programmer&#39;s ability to recognize errors depends on the extent to which the system state is observable. In live coded music, for example, you <em>hear</em> that your code is not what you wanted, providing an easy-to-use immediate error detection mechanism.</p>
</section>
<section data-file="dimensions/errors" data-id="latent-errors" data-title="Remark: Eliminating latent errors">

<p>A common aim of error detection is to prevent <em>latent errors</em>, i.e. errors that occured at some <em>earlier</em> point during execution, but only manifest themselves through an unexpected behaviour later on. For example, we might dereference the wrong memory address and store a junk value to a database; we will only find out upon accessing the database.</p>
<p>Latent errors can be prevented differently in different feedback loops. In a live feedback loop, this can be done by visualizing effects that would normally remain hidden. When running software, latent errors can be prevented through a mechanism that detects errors as early as possible (e.g. initializing pointers to <code>null</code> and stopping if they are dereferenced.)</p>
<h2>Elm and time-travel debugging</h2>
<p>One notable mechanism for identifying latent errors is the concept of <em>time-travel debugging</em> popularized by the Elm programming language. In time-travel debugging, the programmer is able to step back through time and see what execution steps were taken prior to a certain point. This makes it possible to break execution when a latent error manifests, but then retrace the execution back to the actual source of the error.</p>
</section>
<section data-file="dimensions/errors" data-id="error-response" data-title="Dimension: Error response">

<p>When an error is detected, there are a number of typical ways in which the system can respond. The following applies to systems that provide some kind of error detection during execution.</p>
<ul>
<li>It may attempt to automatically recover from the error as best as possible. This may be feasible for simpler errors (slips and lapses), but also for certain mistakes (a mistake in an algorithm&#39;s concurrency logic may often be resolved by restarting the code.)</li>
<li>It may proceed as if the error did not happen. This can eliminate expensive checks, but may lead to latent errors later.</li>
<li>It may ask a human how to resolve the issue. This can be done interactively, by entering into a mode where the code can be corrected, or non-interactively by stopping the system.</li>
</ul>
<p>Orthogonally to the above options, a system may also have a way to recover from latent errors by tracing back through the execution in order to find the root cause. It may also have a mechanism for undoing all actions that occurred in the meantime, e.g. through transactional processing.</p>
<h2>Interlisp and Do What I Mean (DWIM)</h2>
<p>Interlisp&#39;s <a href="#*=.;right=paper,references" title=" Teitelman, Warren. 1974. “Interlisp Reference Manual.” Xerox PARC. http://www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_1974.pdf">91</a> DWIM facility attempts to automatically correct slips and lapses, especially misspellings and unbalanced parentheses. When Interlisp encounters an error, such as a reference to an undefined symbol, it invokes DWIM. In this case, DWIM then searches for similarly named symbols frequently used by the current user. If it finds one, it invokes the symbol automatically, corrects the source code and notifies the user. In more complex cases where DWIM cannot correct the error automatically, it starts an interaction with the user and lets them correct it manually.</p>
</section>
<section data-class="dimensions-interaction-anchor nobullet" data-file="dimensions/interaction" data-id="summary" data-title="Interaction">

<p>How do users manifest their ideas, evaluate the result, and generate new ideas in response?</p>
<h2>Dimensions</h2>
<ul>
<li>
What are the gulfs of execution and evaluation and how are they related?</li>
<li>
Which sets of feedback loops only occur together?</li>
<li>
How do we go from abstractions to concrete examples and vice versa?</li>
</ul>
<h2>Examples</h2>
<ul>
<li><a href="#*=.;right=dimensions/interaction,immediate-feedback!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/interaction,direct-manipulation!"><i></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/interaction" data-id="index" data-title="Interaction">

<p><strong>How do users manifest their ideas, evaluate the result, and generate new ideas in response?</strong></p>
<p>An essential aspect of programming systems is how the user interacts with them when creating programs. Take the standard form of statically typed, compiled languages with straightforward library linking: here, programmers write their code in a text editor, invoke the compiler, and read through error messages they get. After fixing the code to pass compilation, a similar process might happen with runtime errors.</p>
<p>Other forms are yet possible. On the one hand, some typical interactions like compilation or execution of a program  may not be perceptible at all. On the other hand, the system may provide various interfaces to support the plethora of other interactions that are often important in programming, such as looking up documentation, managing dependencies, refactoring or pair programming.</p>
<p>We focus on the interactions where programmer interacts with the system to construct a program with a desired behavior. To analyze those, we use the concepts of <em>gulf of execution</em> and <em>gulf of evaluation</em> from <em>The Design of Everyday Things</em> <a href="#*=.;right=paper,references" title=" Norman, Donald A. 2002. The Design of Everyday Things. USA: BasicBooks, Inc.">68</a>.</p>
<h2>Relations</h2>
<p><a href="#*=.;right=dimensions/errors,index"><i></i>Errors</a> A longer evaluation gulf delays the detection of errors. A longer execution gulf can increase the <em>likelihood</em> of errors (e.g. writing a lot of code or taking a long time to write it). By turning runtime bugs into statically detected bugs, the combined evaluation gulfs can be reduced.</p>
<p><a href="#*=.;right=dimensions/adoptability,index"><i></i>Adoptability</a> The <em>execution</em> gulf is concerned with software using and programming in general. The time taken to realize an idea in software is affected by the user&#39;s familiarity and the system&#39;s <a href="#*=.;right=dimensions/adoptability,learnability">learnability</a>.</p>
<p><a href="#*=.;right=dimensions/notation,index"><i></i>Notation</a> <a href="#*=.;right=dimensions/interaction,feedback-loops">Feedback loops</a> are related to <a href="#*=.;right=dimensions/notation,notational-structure">notational structure</a>. In a system with multiple notations, each notation may have different associated feedback loops. The motto <em>&#34;The thing on the screen is supposed to be the actual thing&#34;</em> <a href="#*=.;right=paper,references" title=" Pawson, Richard. 2004. “Naked Objects.” PhD thesis, Trinity College,University of Dublin.">72</a>, adopted in the context of live programming, relates <em>liveness</em> to a direct connection between <a href="#*=.;right=dimensions/notation,surface-internal-notation">surface and internal notations</a>. The idea is that interactable objects should be equipped with faithful behavior, instead of being intangible shadows cast by the hidden <em>real</em> object.</p>
</section>
<section data-class="doc" data-file="dimensions/interaction" data-id="feedback-loops" data-title="Dimension: Feedback loops">

<p>In using a system, one first has some idea and attempts to make it exist in the software; the gap between the user&#39;s goal and the means to execute the goal is known as the <em>gulf of execution</em>. Then, one compares the result actually achieved to the original goal in mind; this crosses the <em>gulf of evaluation</em>. These two activities comprise the <em>feedback loop</em> through which a user gradually realises their desires in the imagination, or refines those desires to find out &#34;what they actually want&#34;.</p>
<p>A system must contain at least one such feedback loop, but may contain several at different levels or specialized to certain domains. For each of them, we can separate the gulf of execution and evaluation as independent legs of the journey, with possibly different manners and speeds of crossing them.</p>
<p><a href="#image=dimensions/interaction,feedback-loops-diagram"><img src="https://tomasp.net/techdims/img/paper/feedback-loops.png" alt=""/></a></p>
<h2>Statically checked languages</h2>
<p>For example, we can analyze statically checked <em>programming languages</em> (e.g. Java, Haskell) into several feedback loops (see illustration):</p>
<ol>
<li><p>Programmers often think about design details and calculations on a whiteboard or notebook, even before writing code. This <em>supplementary medium</em> has its own feedback loop, even though this is often not automatic.</p></li>
<li>
<p>The code is written and is then put through the static checker. An error sends the user back to writing code. In the case of success, they are &#34;allowed&#34; to run the program, leading into cycle 3.</p>
<ul>
<li>The execution gulf comprises multiple cycles of the supplementary medium, plus whatever overhead is needed to invoke the compiler (such as build systems).</li>
<li>The evaluation gulf is essentially the waiting period before static errors or a successful termination are observed. Hence this is bounded by some function of the length of the code (the same cannot be said for the following cycle 3.)</li>
</ul>
</li>
<li>
<p>With a runnable program, the user now evaluates the <em>runtime</em> behavior. Runtime errors can send the user back to writing code to be checked, or to tweak dynamically loaded data files in a similar cycle.</p>
<ul>
<li>The execution gulf here may include multiple iterations of cycle 2, each with its own nested cycle 1.</li>
<li><p>The <em>evaluation</em> gulf here is theoretically unbounded; one may have to wait a very long time, or create very specific conditions, to rule out certain bugs (like race conditions) or simply to consider the program as fit for purpose.</p></li>
<li><p>By imposing <em>static checks</em>, some bugs can be pushed earlier to the evaluation stage of cycle 2, reducing the likely size of the cycle 3 <em>evaluation</em> gulf.</p></li>
<li><p>On the other hand, this can make it harder to write statically valid code, which may increase the number of level-2 cycles, thus increasing the total <em>execution</em> gulf at level 3.</p></li>
<li>Depending on how these balance out, the total top-level feedback loop may grow longer or shorter.</li>
</ul>
</li>
</ol>
<h2>Related examples</h2>

</section>
<section data-class="noborder" data-file="dimensions/interaction" data-id="feedback-loops-diagram" data-title="Illustration of nested feedback loops">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/paper/feedback-loops.png" alt="A diagram showing nested feedback loops of a programming system"/></p>
<p><strong>The nested feedback loops of a statically-checked programming language.</strong> Programmer may
write ideas on a paper or a whiteboard first and have it checked manually, then implement
idea in code and have it checked by a type checker and, finally, run it and observe the runtime
behaviour.</p>
</blockquote>
</section>
<section data-file="dimensions/interaction" data-id="immediate-feedback" data-title="Example: Immediate feedback">

<p>The specific case where the <em>evaluation</em> gulf is minimized to be imperceptible is known as <em>immediate feedback</em>. Once the user has caused some change to the system, its effects (including errors) are immediately visible. This is a key ingredient of <em>liveness</em>, though it is not sufficient on its own. (See <a href="#*=.;right=dimensions/interaction,index">Relations</a>)</p>
<p>The ease of achieving immediate feedback is obviously constrained by the computational load of the user&#39;s effects on the system, and the system&#39;s performance on such tasks. However, such &#34;loading time&#34; is not the only way feedback can be delayed: a common situation is where the user has to manually ask for (or &#34;poll&#34;) the relevant state of the system after their actions, even if the system finished the task quickly. Here, the feedback could be described as <em>immediate upon demand</em> yet not <em>automatically demanded</em>. For convenience, we choose to include the latter criterion—automatic demand of result—in our definition of immediate feedback.</p>
<h2>Read-eval-print-loop</h2>
<p>In a <em>REPL</em> or <em>shell</em>, there is a <em>main</em> cycle of typing commands and seeing their output, and a <em>secondary</em> cycle of typing and checking the command line itself. The output of commands can be immediate, but usually reflects only part of the total effects or even none at all. The user must manually issue further commands afterwards, to check the relevant state bit by bit.</p>
<p>The secondary cycle, like all typing, provides immediate feedback in the form of character &#34;echo&#34;, but things like syntax errors generally only get reported <em>after</em> the entire line is submitted. This evaluation gulf has been reduced in the JavaScript console of web browsers, where the line is &#34;run&#34; in a limited manner on every keystroke. Simple commands without side-effects (detected via some conservative over-approximation), such as calls to pure functions, can give instantly previewed results—though partially typed expressions and syntax errors will not trigger previews.</p>
</section>
<section data-file="dimensions/interaction" data-id="direct-manipulation" data-title="Example: Direct manipulation">

<p>Direct manipulation <a href="#*=.;right=paper,references" title=" Shneiderman. 1983. “Direct Manipulation: A Step Beyond ProgrammingLanguages.” Computer 16 (8): 57–69.https://doi.org/10.1109/MC.1983.1654471.">81</a> is a special case of an immediate feedback loop. The user sees and interacts with an artefact in a way that is as similar as possible to real life; this typically includes dragging with a cursor or finger in order to physically move a visual item, and is limited by the particular haptic technology in use.</p>
<p>Naturally, because moving real things with one&#39;s hands does not involve any waiting for the object to &#34;catch up&#34;, direct manipulation is necessarily an immediate-feedback cycle.
If, on the other hand, one were to move a figure on screen by typing new co-ordinates in a text box, then this could still give <em>immediate feedback</em> (if the update appears instant and automatic) but would <em>not</em> be an example of direct manipulation.</p>
<h2>Spreadsheets</h2>
<p><em>Spreadsheets</em> contain a feedback loop for direct manipulation of values and formatting, as in any other WYSIWYG application. Here, there is feedback for every character typed and every change of style. This is not the case in the other loop for formula editing and formula invocation. There, we see a larger execution gulf for designing and typing formulas, where feedback is only given upon committing the formula by pressing enter. This makes it an &#34;immediate feedback&#34; loop only <em>on-demand</em>, as defined above.</p>
</section>
<section data-file="dimensions/interaction" data-id="modes-of-interaction" data-title="Dimension: Modes of interaction">

<p>The possible interactions in a programming system are typically structured so that interactions, and the associated feedback loops, are only available in certain <em>modes</em>. For example, when creating a new project, the user may be able to configure the project through a conversational interface like <code>npm init</code> in modern JavaScript. Such interactions are no longer available once the project is created. This idea of interaction modes goes beyond just programming systems, appearing in software engineering methodologies. In particular, having a separate <em>implementation</em> and <em>maintenance</em> phase would be an example of two modes.</p>
<h2>Editing versus debugging</h2>
<p>A good example is the distinction between <em>editing</em> and <em>debugging</em> mode. When debugging a program, the user can modify the program state and get (more) immediate feedback on what individual operations do. In some systems, one can even modify the program itself during debugging. Such feedback loops are not available outside of debugging mode.</p>
<h2>Lisp systems</h2>
<p>Lisp systems sometimes distinguish between <em>interpreted</em> and <em>compiled</em> mode. The two modes do not differ just in the efficiency of code execution, but also in the interactions they enable. In the interpreted mode, code can be tested interactively and errors may be corrected during the code execution (see <em>Error response</em>). In the compiled mode, the program can only be tested as a whole. The same two modes also exist, for example, in some Haskell systems where the REPL uses an interpreter (GHCi) distinct from the compiler (GHC).</p>
<h2>Jupyter notebooks</h2>
<p>A programming system may also unify modes that are typically distinct. The Jupyter notebook environment does not have a distinct debugging mode; the user runs blocks of code and receives the result. The single mode can be used to quickly try things out, and to generate the final result, partly playing the role of both debugging and editing modes. However, even Jupyter notebooks distinguish between editing a document and running code.</p>
</section>
<section data-file="dimensions/interaction" data-id="abstraction-construction" data-title="Dimension: Abstraction construction">

<p>A necessary activity in programming is going between abstract schemas and concrete instances. Abstractions can be constructed from concrete examples, first principles or through other methods. A part of the process may happen in the programmer&#39;s mind: they think of concrete cases and come up with an abstract concept, which they then directly encode in the system. Alternatively, a system can support these different methods directly.</p>
<p>One option is to construct abstractions <em>from first principles</em>. Here, the programmer starts by defining an abstract entity such as an interface in object-oriented programming languages. To do this, they have to think what the required abstraction will be (in the mind) and then encode it (in the system).</p>
<p>Another option is to construct abstractions <em>from concrete cases</em>. Here, the programmer uses the system to solve one or more concrete problems and, when they are satisfied, the system guides them in creating an abstraction based on their concrete case(s). In a programming language IDE this manifests as the &#34;extract function&#34; refactor, whereas in other systems we see approaches like macro recording.</p>
<h2>Pygmalion</h2>
<p>In Pygmalion <a href="#*=.;right=paper,references" title=" Smith, D. C. 1975. “Pygmalion: A Creative Programming Environment.” In.">85</a>, all programming is done by manipulating concrete icons that represent concrete things. To create an abstraction, you can use &#34;Remember mode&#34;, which records the operations done on icons and makes it possible to bind this recording to a new icon.</p>
<h2>Jupyter notebook</h2>
<p>In Jupyter notebooks, you are inclined to work with concrete things, because you see previews after individual cells. This discourages creating abstractions, because then you would not be able to look inside at such a fine grained level.</p>
<h2>Spreadsheets</h2>
<p>Up until the recent introduction of lambda expressions into Excel, spreadsheets have been relentlessly concrete, without any way to abstract and reuse patterns of computation other than copy-and-paste.</p>
</section>
<section data-class="dimensions-notation-anchor nobullet" data-file="dimensions/notation" data-id="summary" data-title="Notation">

<p>How are the different textual and visual programming notations related?</p>
<h2>Dimensions</h2>
<ul>
<li>
What notations are used to program the system and how are they related?</li>
<li>
What is the connection between what a user sees and what a computer program sees?</li>
<li>
Is one notation more important than others?</li>
<li>
Do similar expressions encode similar programs?</li>
<li>
Does the notation use a small or a large number of basic concepts?</li>
</ul>
<h2>Examples</h2>
<ul>
<li><a href="#*=.;right=dimensions/notation,overlapping-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/notation,complementing-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=dimensions/notation,explicit-implicit-structure!"><i></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/notation" data-id="index" data-title="Notation">

<p><strong>How are the different textual and visual programming notations related?</strong></p>
<p>Programming is always done through some form of notation. We consider notations in the most general sense and include any structured gesture using textual or visual notation. Textual notations primarily include  programming languages, but also things like configuration files. Visual notations include graphical programming languages. Other kinds of structured gestures include user interfaces for constructing visual elements used in the system.</p>
<h2>References</h2>
<p><em>Cognitive Dimensions of Notation</em> <a href="#*=.;right=paper,references" title=" Green, T. R. G., and M. Petre. 1996. “Usability Analysis of VisualProgramming Environments: A ‘Cognitive Dimensions’ Framework.” JOURNALOF VISUAL LANGUAGES AND COMPUTING 7: 131–74.">35</a> provide a comprehensive framework for analysing individual notations, while our focus here is on how multiple notations are related and how they are structured. It is worth noting that the Cognitive Dimensions also define <em>secondary notation</em>, but in a different sense to ours. For them, secondary notation refers to whether a notation allows including redundant information such as color or comments for readability purposes.</p>
<p>The importance of notations in the practice of science, more generally, has been studied as &#34;paper tools&#34;. <a href="#*=.;right=paper,references" title=" Klein, Ursula. 2003. Experiments, Models, Paper Tools: Cultures ofOrganic Chemistry in the Nineteenth Century. Stanford, CA: StanfordUniversity Press. http://www.sup.org/books/title/?id=1917.">49</a> These are formula-like entities which can be manipulated by humans in lieu of experimentation, such as the aforementioned mathematical notation in Haskell: a &#34;paper tool&#34; for experimentation on a whiteboard. Programming notations are similar, but they are a way of communicating with a machine; the experimentation does not happen on paper alone.</p>
<h2>Relations</h2>
<p><a href="#*=.;right=dimensions/interaction,index"><i></i>Interaction</a> The feedback loops that exist in a programming system are typically associated with individual notations. Different notations may also have different feedback loops.</p>
<p><a href="#*=.;right=dimensions/adoptability,index"><i></i>Adoptability</a> Notational structure can affect learnability. In particular, complementing notations may require (possibly different) users to master multiple notations. Overlapping notations may improve learnability by allowing the user to edit the program in one way (perhaps visually) and see the effect in the other notation (such as code.)</p>
<p><a href="#*=.;right=dimensions/errors,index"><i></i>Errors</a> A process that merely records user actions in a sequence (such as text editing) will, in particular, record any <em>errors</em> the user makes and defer their handling to later use of the data, keeping the errors <em>latent</em>. A process which instead treats user actions as edits to a structure, with constraints and correctness rules, will be able to catch errors at the moment they are introduced and ensure the data coming out is error-free.</p>
</section>
<section data-file="dimensions/notation" data-id="notational-structure" data-title="Dimension: Notational structure">

<p>In practice, most programming systems use multiple notations. Different notations can play different roles in the system.</p>
<p>On the one hand, multiple <a href="#*=.;right=dimensions/notation,overlapping-notations">overlapping notations</a> can be provided as different ways of programming the same aspects of the system. In this case, each notation may be more suitable to different kinds of users, but may have certain limitations (for example, a visual notation may have a limited expressive power).</p>
<p>On the other hand, multiple <a href="#*=.;right=dimensions/notation,complementing-notation">complementing notations</a> may be used as the means for programming different aspects of the system. In this case, programming the system requires using multiple notations, but each notation may be more suitable for the task at hand; think of how HTML describes document structure while JavaScript specifies its behavior.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/notation" data-id="overlapping-notations" data-title="Example: Overlapping notations">

<p>A programming system may provide multiple notations for programming the same aspect of the system. This is typically motivated by an attempt to offer easy ways of completing different tasks: say, a textual notation for defining abstractions and a visual notation for specifying concrete structures. The crucial issue in this kind of arrangement is <em>synchronizing</em> the different notations; if they have different characteristics, this may not be a straightforward mapping.</p>
<p>For example, source code may allow more elaborate abstraction mechanisms like  loops, which will appear as visible repetition in the visual notation. What should such a system do when the user edits a single object that resulted from such repetition? Similarly, textual notation may allow incomplete expressions that do not have an equivalent in the visual notation. For programming systems that use <em>overlapping notations</em>, we need to describe how the notations are synchronized.</p>
<h2>Sketch-n-Sketch</h2>
<p>Sketch-n-Sketch <a href="#*=.;right=paper,references" title=" Hempel, Brian, Justin Lubin, and Ravi Chugh. 2019.“Sketch-n-Sketch: Output-DirectedProgramming for SVG.” In Proceedings of the 32nd Annual ACM Symposiumon User Interface Software and Technology, 281–92. UIST ’19. New York,NY, USA: Association for Computing Machinery.https://doi.org/10.1145/3332165.3347925.">38</a> employs overlapping notations for creating and editing SVG and HTML documents. The user edits documents in an interface with a split-screen structure that shows source code on the left and displayed visual output on the right. They can edit both of these and changes are propagated to the other view. The code can use abstraction mechanisms (such as functions) which are not completely visible in the visual editor (an issue we return to in <a href="#*=.;right=dimensions/notation,expression-geography">expression geography</a>). Sketch-n-Sketch can be seen as an example of a <em>projectional editor</em>. (Technically, traditional projectional editors usually work more directly with the abstract syntax tree of a programming language.)</p>
<h2>UML Round-tripping</h2>
<p>Another example of a programming system that utilizes the <em>overlapping notations</em> structure are UML design tools that display the program both as source code and as a UML diagram. Edits in one result in automatic update of the other. An example is the <a href="https://www.mindprod.com/jgloss/togetherj.html">Together/J system</a>. To solve the issue of notation synchronization, such systems often need to store additional information in the textual notation, typically using a special kind of code comment. In this example, after the user re-arranges classes in UML diagrams, the new locations need to be updated in the code.</p>
</section>
<section data-file="dimensions/notation" data-id="complementing-notations" data-title="Example: Complementing notations">

<p>A programming system may also provide multiple complementing notations for programming different aspects of its world. Again, this is typically  motivated by the aim to make specifying certain aspects of programming easier, but it is more suitable when the different aspects can be more clearly separated.</p>
<p>The key issue for systems with complementing notations is how the different notations are connected. The user may need to use both notations at the same time, or they may need to progress from one to the next level when solving increasingly complex problems. In the latter case, the learnability of progressing from one level to the next is a major concern.</p>
<h2>Spreadsheets and HyperCard</h2>
<p>In Excel, there are three different complementing notations that allow users to specify aspects of increasing complexity: (i) the visual grid, (ii) formula language and (iii) a macro language such as Visual Basic for Applications. The notations are largely independent and have different degrees of expressive power. Entering values in a grid cannot be used for specifying new computations, but it can be used to adapt or run a computation, for example when entering different alternatives in What-If Scenario Analysis. More complex tasks can be achieved using formulas and macros.</p>
<p>A user gradually learns more advanced notations, but experience with a previous notation does not help with mastering the next one. The approach optimizes for easy learnability at one level, but introduces a hurdle for users to surmount in order to get to the second level. The notational structure of <em>HyperCard</em> is similar and consists of (i) visual design of cards, (ii) visual programming (via the GUI) with a limited number of operations and (iii) HyperTalk for arbitrary scripting.</p>
<h2>Boxer and Jupyter</h2>
<p>Boxer <a href="#*=.;right=paper,references" title=" diSessa, A. A, and H. Abelson. 1986. “Boxer: A ReconstructibleComputational Medium.” Commun. ACM 29 (9): 859–68.https://doi.org/10.1145/6592.6595.">99</a> uses <em>complementing notations</em> in that it combines a visual notation (the layout of the document and the boxes of which it consists) with textual notation (the code in the boxes). Here, the textual notation is always nested within the visual. The case of Jupyter notebooks is similar. The document structure is graphical; code and visual outputs are nested as editable cells in the document. This arrangement is common in many other systems such as Flash or Visual Basic, which both combine visual notation with textual code, although one is not nested in the other.</p>
</section>
<section data-file="dimensions/notation" data-id="surface-internal-notation" data-title="Dimension: Surface and internal notation">

<p>All programming systems build up structures in memory, which we can consider as an <em>internal notation</em> not usually visible to the user. Even though such structures might be revealed in a debugger, they are hidden during normal operation. What the user interacts with instead is the <em>surface notation</em>, typically one of text or shapes on a screen. Every interaction with the surface notation alters the internal notation in some way, and the nature of this connection is worth examining in more detail. To do this, we illustrate with a simplified binary choice for the form of these notations.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/notation" data-id="explicit-implicit-structure" data-title="Example: Explicit versus implicit structure">

<p>Let us partition notations into two families. Notations with <em>implicit structure</em> present as a sequence of items, such as textual characters or audio signal amplitudes. Those with <em>explicit structure</em> present as a tree or graph without an obvious order, such as shapes in a vector graphics editor. These two types of notations can be transformed into each other: the implicit structure contained in a string can be <em>parsed</em> into an explicit syntax tree, and an explicit document structure might be <em>rendered</em> into a sequence of characters with the same implicit structure.</p>
<p>Now consider an interface to enter a personal name made up of a forename and a surname. For the surface notation, there could be a single text field to hold the names separated with a space; here, the sub-structure is implicit in the string. Alternatively, there could be two fields where the names are entered separately, and their separation is explicit. A similar choice exists for the internal notation built up in memory: is it a single string, or two separate strings?</p>
<p>We can see that these choices give four combinations. More interestingly, they exhibit unique characters owing to two key asymmetries. Firstly, surface notation is mostly used by humans, while the internal notation is mostly used by the computer. Secondly, and most significantly, computer programs can only work with explicit structure, while humans can understand both explicit and implicit structure. Because of the practical consequences of this asymmetry, we will examine the combinations with emphasis on the <em>internal</em> notation first.</p>
<h2>Related examples</h2>

</section>
<section data-file="dimensions/notation" data-id="one-string-in-memory" data-title="Examples: One string in memory">

<p>The simplest case here would be with implicit structure in the surface notation, i.e. a single text box for the full name. Edits to the surface are straightforwardly mirrored interally and persisted to disk. This corresponds to <em>text editing</em>. We can generalize this to an idea of <em>sequence editing</em> if we view the fundamental act as <em>recording</em> events to a list over time. For text, these are key presses; for an audio editing interface they would be samples of sound amplitude.</p>
<p>In the other case, with two text boxes, we have <em>sequence rendering</em>. The information about the separation of the two strings, present in the interface, is not quite &#34;thrown away&#34; but is made <em>implicit</em> as a space character in the string. This combination corresponds to Visual Basic generating code from GUI forms, video editors combining multiple clips and effects into a single stream, and 3D renderers turning scene graphs into pixels. Another example is line-based diff tools, which provide side-by-side views and related interfaces, yet must ultimately forward the user&#39;s changes to the underlying text file.</p>
<p>Critically, in both of these cases, a computer program can only manipulate the stored sequences <em>as</em> sequences; that is, by inserting, removing, or serially reading. The appealing feature here is that these operations are simple to implement and may be re-usable across many types of sequences. However, any further structure is implicit and, to work with it programmatically, a user must write a program to <em>parse</em> it into something explicit. Furthermore, errors introduced at this stage may simply be <em>recorded</em> into the sequence, only to be discovered much later in an attempt to use the data.</p>
</section>
<section data-file="dimensions/notation" data-id="two-strings-in-memory" data-title="Examples: Two strings in memory">

<p>With two text boxes, both notations match, so there is not much work to do. As with sequence editing, edits on the surface can be mirrored to the internal notation. This corresponds to vector graphics editors and 3D modelling tools, as well as <em>structure editors</em> for programming languages. For this reason we call this combination <em>structure editing</em>.</p>
<p>With a single text field, we have <em>structure recovery.</em> Parsing needs to happen each time the input changes. This style is found in the DOM inspector in browser developer tools, where HTML can be edited as text to make changes to the document tree structure. More generally, this is the mode found in compilers and interpreters which accept program source text yet internally work on tree and graph structures. It is also possible to do a sort of structure editing this way, where the experience is made to resemble text editing but the output is explicitly structured.</p>
<p>In both of these cases, in order to write programs to transform, analyze, or otherwise work with the digital artefact the user has created, one can trivially navigate the stored structure instead of parsing it for every use. Parsing is either done away with altogether or is reduced to a transient process that happens during editing; this means errors can be caught at the moment they are introduced instead of remaining latent.</p>
</section>
<section data-file="dimensions/notation" data-id="primary-secondary-notations" data-title="Dimension: Primary and secondary notations">

<p>In practice, most programming systems use multiple notations. Even in systems based on traditional programming languages, the <em>primary notation</em> of the language is often supported by <em>secondary notations</em> such as annotations encoded in comments and build tool configuration files. However, it is possible for multiple notations to be primary, especially if they are <em>overlapping</em> as defined earlier.</p>
<h2>Programming languages</h2>
<p>Programming systems built around traditional programming languages typically have further notations or structured gestures associated with them. The primary notation in UNIX is the C programming language. Yet this is enclosed in a programming <em>system</em> providing a multi-step mechanism for running C code via the terminal, assisted by secondary notations such as shell scripts.</p>
<p>Some programming systems attempt to integrate tools that normally rely on secondary notations into the system itself, reducing the number of secondary notations that the programmer needs to master. For example, in the Smalltalk descendant Pharo, versioning and package management is done from within Pharo, removing the need for secondary notation such as <code>git</code> commands and dependency configuration files. (The tool for versioning and package management in Pharo can still be seen as an <em>internal</em> domain-specific language and thus as a secondary notation, but its basic structure is <em>shared</em> with other notations in the Pharo system.)</p>
<h2>Haskell</h2>
<p>In Haskell, the primary notation is the programming language, but there are also a number of secondary notations. Those include package managers (e.g. the <code>cabal.project</code> file) or configuration files for Haskell build tools. More interestingly, there is also an informal mathematical notation associated with Haskell that is used when programmers discuss programs on a whiteboard or in academic publications. The idea of having such a mathematical notation dates back to the <em>Report on Algol 58</em> \cite{Alg58}, which explicitly defined a &#34;publication language&#34; for &#34;stating and communicating problems&#34; using Greek letters and subscripts.</p>
</section>
<section data-file="dimensions/notation" data-id="expression-geography" data-title="Dimension: Expression geography">

<p>A crucial feature of a notation is the relationship between the structure of the notation and the structure of the behavior it encodes. Most importantly, do <em>similar expressions</em> in a particular notation represent <em>similar behavior</em>? (See Basman&#39;s <a href="#*=.;right=paper,references" title=" Basman, Antranig. 2016. “Building Software Is Not (yet) a Craft.” InProceedings of the 27th Annual Workshop of the Psychology ofProgramming Interest Group, PPIG 2016, Cambridge, UK, September 7-10,2016, edited by Luke Church, 32. Psychology of Programming InterestGroup. http://ppig.org/library/paper/building-software-not-yet-craft.">4</a> similar discussion of &#34;density&#34;.) Visual notations may provide a more or less direct mapping. On the one hand, similar-looking code in a block language may mean very different things. On the other hand, similar looking design of two HyperCard cards will result in similar looking cards—the mapping between the notation and the logic is much more direct.</p>
<h2>C/C++ expression language</h2>
<p>In textual notations, this may easily not be the case. Consider the two C conditionals:</p>
<ul>
<li><code>if (x==1) { ... }</code> evaluates the Boolean expression <code>x==1</code> to determine whether <code>x</code> equals <code>1</code>, running the code block if the condition holds.</li>
<li><code>if (x=1) { ... }</code> <em>assigns</em> <code>1</code> to the variable <code>x</code>. In C, assignment is an expression <em>returning</em> the assigned value, so the result <code>1</code> is interpreted as <code>true</code> and the block of code is <em>always</em> executed.</li>
</ul>
<p>A notation can be designed to map better to the logic behind it, for example, by requiring the user to write <code>1==x</code>. This solves the above problem as <code>1</code> is a literal rather than a variable, so it cannot be assigned to (<code>1=x</code> is a compile error).</p>
</section>
<section data-file="dimensions/notation" data-id="uniformity-of-notations" data-title="Dimension: Uniformity of notations">

<p>One common concern with notations is the extent to which they are uniform. A uniform notation can express a wide range of things using just a small number of concepts.</p>
<p>The primary example here is S-expressions from Lisp. An S-expression is either an atom or a pair of S-expressions written <code>(s1 . s2)</code>. By convention, an S-expression <code>(s1 . (s2 . (s3 . nil)))</code> represents a list, written as <code>(s1 s2 s3)</code>. In Lisp, uniformity of notations is closely linked to uniformity of representation. (Notations generally are closely linked to representation in that the notation may mirror the structures used for program representation. Basman et al. <a href="#*=.;right=paper,references" title=" Basman, Antranig, L. Church, C. Klokmose, and Colin B. D. Clark. 2016.“Software and How It Lives on: Embedding Live Programs in the WorldAround Them.” In PPIG.">3</a> refer to this as a distinction between &#34;dead&#34; notation and &#34;live&#34; representation forms.) In the idealized model of LISP 1.5, the data structures represented by an S-expression are what exists in memory. In real-world Lisp systems, the representation in memory is more complex. A programming system can also take a very different approach and fully separate the notation from the in-memory representation.</p>
<h2>Lisp systems</h2>
<p>In Lisp, source code is represented in memory as S-expressions, which can be manipulated by Lisp primitives. In addition, Lisp systems have robust macro processing as part of their semantics: expanding a macro revises the list structure of the code that uses the macro. Combining these makes it possible to define extensions to the system in Lisp, with syntax indistinguishable from Lisp. Moreover, it is possible to write a program that constructs another Lisp program and not only run it interpretively (using the <code>eval</code> function) but compile it at runtime (using the <code>compile</code> function) and execute it. Many domain-specific languages, as well as prototypes of new programming languages (such as Scheme), were implemented this way. Lisp the language is, in this sense, a &#34;programmable programming language&#34;. <a href="#*=.;right=paper,references" title=" Foderaro, John. 1991. “LISP: Introduction.” Commun. ACM 34 (9): 27.https://doi.org/10.1145/114669.114670.">22</a> <a href="#*=.;right=paper,references" title=" Felleisen, Matthias, Robert Bruce Findler, Matthew Flatt, ShriramKrishnamurthi, Eli Barzilay, Jay McCarthy, and Sam Tobin-Hochstadt.2018. “A Programmable Programming Language.” Commun. ACM 61 (3):62–71. https://doi.org/10.1145/3127323.">19</a></p>
</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-dm, interaction-open, interaction-principles, interaction-concrete" data-file="systems/boxer" data-id="dims-interaction" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-pointer&#39; title=&#39;System supports some kind of direct manipulation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-eye&#39; title=&#39;Abstractions are constructed from concrete examples&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Direct manipulation for graphical elements with REPL-like code execution.
Abstraction via messages sent to boxes and using ports to reuse concrete boxes.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>System supports some kind of direct manipulation</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li><li><i></i>Abstractions are constructed from concrete examples</li></ul>
</section>
<section data-characteristics="notations-complementing, notations, notations-uniform, notations-graphical" data-file="systems/boxer" data-id="dims-notation" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars&#39; title=&#39;The system notation is uniform&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-image&#39; title=&#39;Notations include some graphical notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Complementing graphical notation (boxes) with source code in LISP.
Everything is a box (graphical) or a list (code). Tree-based document model.</p>
<ul><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is uniform</li><li><i></i>Notations include some graphical notation</li></ul>
</section>
<section data-characteristics="concepts-minimal, concepts-domain, concepts-noncomposable" data-file="systems/boxer" data-id="dims-conceptual-structure" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-flask&#39; title=&#39;There are suitable domain-specific concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link-slash&#39; title=&#39;The concepts cannot be composed&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Limited number of domain-specific concepts (box, graphical output).
Composability at code level, but not at a higher level (only via ports).</p>
<ul><li><i></i>There is only a small number of concepts</li><li><i></i>There are suitable domain-specific concepts</li><li><i></i>The concepts cannot be composed</li></ul>
</section>
<section data-characteristics="custom-closed, concepts-large" data-file="systems/boxer" data-id="dims-customizability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-square-xmark&#39; title=&#39;The system itself is closed and not (easily) modifiable&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Image-based system, editable during execution, but system itself cannot be modified.
Adding only appends boxes and cannot modify existing ones.</p>
<ul><li><i></i>The system itself is closed and not (easily) modifiable</li><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/boxer" data-id="dims-complexity" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-receipt&#39; title=&#39;The complexity is structured using domain-specific notions (grid, UI elements, boxes)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-satellite-dish&#39; title=&#39;A large amount of system complexity is hidden or externalized&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Basic factoring via language and box abstractions (ports). System automates user-interface
handling; high-level language and DSLs offer basic automation (garbage collection, turtle graphics).</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>The complexity is structured using domain-specific notions (grid, UI elements, boxes)</li><li><i></i>A large amount of system complexity is hidden or externalized</li></ul>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/boxer" data-id="dims-errors" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-point-up&#39; title=&#39;The system provides immediate feedback, allowing immediate error response&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Slips detected at runtime, no support for checking lapses and mistakes.
Evaluation offers immediate feedback, making quick error correction possible.</p>
<ul><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>The system provides immediate feedback, allowing immediate error response</li></ul>
</section>
<section data-characteristics="adoptability-minimal, adoptability-nonexperts, adoptability-unified" data-file="systems/boxer" data-id="dims-adoptability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-minimize&#39; title=&#39;The system is general purpose, but targets simple, small, specific needs&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-user&#39; title=&#39;The system can (also) be used used by non-experts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-table-cells-large&#39; title=&#39;The system has a unified design, providing value after the intial learning period&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Simple and minimal design supports learnability. Unified design makes knowledge reusable.
System is closed from external world and has only limited community and available packages or examples.</p>
<ul><li><i></i>The system is general purpose, but targets simple, small, specific needs</li><li><i></i>The system can (also) be used used by non-experts</li><li><i></i>The system has a unified design, providing value after the intial learning period</li></ul>
</section>
<section data-class="systems-boxer-anchor sysdet" data-file="systems/boxer" data-id="summary" data-title="Boxer">

<p><a href="#image=systems/boxer,screen"><img src="https://tomasp.net/techdims/img/sys/boxer.gif" alt=""/></a></p>
<p>Boxer is an educational software environment that integrates text editing, programming and interactive
graphics in a document-based environment structured as nested boxes. This is used to combine multiple
notations (in different boxes), including code, interactive graphics and visual outputs.</p>
<p>Boxer is designed to let non-experts explore and inspect program logic. To do so, it
introduced the idea of naive realism, i.e., the document displays everything there is.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/boxer,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-boxer:paper,a-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-boxer:dimensions/notation,complementing-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-boxer:dimensions/adoptability,learnability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/boxer" data-id="screen" data-title="Boxer in educational context">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/boxer.gif" alt="Boxer screenshot"/></p>
<p><strong>Boxer screenshot.</strong> Boxer in the educational context, showing a simple program to draw a star using the built-in Turtle graphics
(<a href="https://www.mathed.page/t-and-m/turtle-and-mouse.html">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/boxer" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-multi, interaction-closed, interaction-principles" data-file="systems/haskell" data-id="dims-interaction" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-forward&#39; title=&#39;There are multiple modes of interaction such as compilation vs. execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock&#39; title=&#39;Astractions are closed and inaccessible for exploration&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Separate editing, compilation and execution modes with feedback at each level.
Abstractions from first-principles (functions, type classes) are opaque during execution.</p>
<ul><li><i></i>There are multiple modes of interaction such as compilation vs. execution</li><li><i></i>Astractions are closed and inaccessible for exploration</li><li><i></i>Abstractions are constructed from the first principles</li></ul>
</section>
<section data-characteristics="notations-primary, notations-complementing" data-file="systems/haskell" data-id="dims-notation" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-trophy&#39; title=&#39;The system has a single primary notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Primary source code notation with secondary infrastructure notations, edited as text.
Rich mostly explicit language with variety of extensions.</p>
<ul><li><i></i>The system has a single primary notation</li><li><i></i>Notations include multiple complementing notation</li></ul>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/haskell" data-id="dims-conceptual-structure" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-plug&#39; title=&#39;The system provides an explicit method for capturing commondality&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link&#39; title=&#39;Complex concepts can be composed from simple ones&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-fist&#39; title=&#39;The systme does not aim for convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Small number of unified concepts (functions, expressions) at odds with outside world.
Composability at expression and type level. Limited set of convenience tools. Type classes for commonality.</p>
<ul><li><i></i>The system provides an explicit method for capturing commondality</li><li><i></i>There is only a small number of concepts</li><li><i></i>Complex concepts can be composed from simple ones</li><li><i></i>The systme does not aim for convenience</li></ul>
</section>
<section data-characteristics="custom-oss, custom-stages, custom-additive" data-file="systems/haskell" data-id="dims-customizability" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-code-pull-request&#39; title=&#39;System source can be modified (open source) and has community support&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-flag-checkered&#39; title=&#39;There is an explicit stage distinction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file-circle-plus&#39; title=&#39;System can be modified by adding to it (additive authoring)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Language is fixed, but can theoretically be modified as open-source project with community.
Programs cannot modify themselves nor the system. Type classes allow extensibility at compile-time.</p>
<ul><li><i></i>System source can be modified (open source) and has community support</li><li><i></i>There is an explicit stage distinction</li><li><i></i>System can be modified by adding to it (additive authoring)</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/haskell" data-id="dims-complexity" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-building-columns&#39; title=&#39;There is a rich support for structuring of complexity (such as FP or OOP)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Complexity factored using math-inspired type class hierarchies with type system support.
Automates memory management (GC) and evaluation order (laziness).</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>There is a rich support for structuring of complexity (such as FP or OOP)</li></ul>
</section>
<section data-characteristics="errors-static, errors-code" data-file="systems/haskell" data-id="dims-errors" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-person-military-pointing&#39; title=&#39;Errors are detected before execution, e.g. through static type checking&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-code&#39; title=&#39;Errors have to be code in a separate stage, e.g. by modifying code based on an error message&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Strict error checking eliminates lapes and slips and some mistakes at compile time.
Error correction done in text editor, based on non-trivial error messages.</p>
<ul><li><i></i>Errors are detected before execution, e.g. through static type checking</li><li><i></i>Errors have to be code in a separate stage, e.g. by modifying code based on an error message</li></ul>
</section>
<section data-characteristics="adoptability-background, adoptability-unified, adoptability-community, adoptability-packages" data-file="systems/haskell" data-id="dims-adoptability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-infinity&#39; title=&#39;The users need to have advanced background knowledge&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-table-cells-large&#39; title=&#39;The system has a unified design, providing value after the intial learning period&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-boxes-packing&#39; title=&#39;There is an easy way sharing of packages in the community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Learning requires background knowledge (mathematics), but is supported by community and uniform design.
Closed ecosystem, but with community and diversity of packages.</p>
<ul><li><i></i>The users need to have advanced background knowledge</li><li><i></i>The system has a unified design, providing value after the intial learning period</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li><li><i></i>There is an easy way sharing of packages in the community</li></ul>
</section>
<section data-class="systems-haskell-anchor sysdet" data-file="systems/haskell" data-id="summary" data-title="Haskell">

<p><a href="#image=systems/haskell,screen"><img src="https://tomasp.net/techdims/img/sys/haskell.png" alt=""/></a></p>
<p>Haskell is a mathematically-oriented programming language and an example of a typical command-line
oriented programming system built around a single language. It is used through a text editor,
typically with background type checking to prevent errors early. Programs are compiled into executable
that is then run and cannot be modified at runtime.</p>
<p>Haskell is emphasizes a high degree of composability that often relies on prior familiarity with
mathematical concepts, which makes it a powerful system, but arguably limits its adoption.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/haskell,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-haskell:paper,l-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-haskell:dimensions/interaction,feedback-loops!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-haskell:dimensions/interaction,modes-of-interaction!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-haskell:dimensions/notation,primary-secondary-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-haskell:dimensions/conceptual-structure,composability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-haskell:dimensions/errors,error-detection!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-haskell:dimensions/adoptability,sociability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/haskell" data-id="screen" data-title="Haskell setup based on the xmonad interface">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/haskell.png" alt="Haskell screenshot"/></p>
<p><strong>Haskell screenshot.</strong> A sample setup leveraging the (Haskell-implemented) xmonad desktop manager for Linux showing text editor and a command line interface for access to tools
(<a href="https://github.com/liskin/dotfiles/tree/home/.xmonad">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/haskell" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-dm, interaction-open, interaction-principles, interaction-concrete" data-file="systems/hypercard" data-id="dims-interaction" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-pointer&#39; title=&#39;System supports some kind of direct manipulation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-eye&#39; title=&#39;Abstractions are constructed from concrete examples&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Direct manipulation for user interface; programmatic scripting with execution feedback loop.
Abstractions on card level using shared backgrounds and transclusion.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>System supports some kind of direct manipulation</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li><li><i></i>Abstractions are constructed from concrete examples</li></ul>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/hypercard" data-id="dims-notation" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars-staggered&#39; title=&#39;The system notation is non-uniform&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-image&#39; title=&#39;Notations include some graphical notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Complementing graphical notation (user interface) with source code in Hypertalk.
Variety of controls and langauge features with tight expression geography in user interface.</p>
<ul><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is non-uniform</li><li><i></i>Notations include some graphical notation</li></ul>
</section>
<section data-characteristics="concepts-minimal, concepts-diverse, concepts-noncomposable, concepts-convenient" data-file="systems/hypercard" data-id="dims-conceptual-structure" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-shapes&#39; title=&#39;There is a wide range of diverse concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link-slash&#39; title=&#39;The concepts cannot be composed&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-toolbox&#39; title=&#39;The system offers a high built-in convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Limited number of domain-specific concepts (cards, user interface elements, scripts).
Partial composability at script level, but limited at card level. Convenient for the given domain.</p>
<ul><li><i></i>There is only a small number of concepts</li><li><i></i>There is a wide range of diverse concepts</li><li><i></i>The concepts cannot be composed</li><li><i></i>The system offers a high built-in convenience</li></ul>
</section>
<section data-characteristics="concepts-large, custom-closed" data-file="systems/hypercard" data-id="dims-customizability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-square-xmark&#39; title=&#39;The system itself is closed and not (easily) modifiable&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Cards are editable during execution, but system itself cannot be modified.
Adding only appends new content, but cannot modify existing ones.</p>
<ul><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li><li><i></i>The system itself is closed and not (easily) modifiable</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/hypercard" data-id="dims-complexity" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-receipt&#39; title=&#39;The complexity is structured using domain-specific notions (grid, UI elements, boxes)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-satellite-dish&#39; title=&#39;A large amount of system complexity is hidden or externalized&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Basic factoring via language and card abstractions. Underlying system automates user-interface
handling; high-level scripting language offers basic automation (garbage collection).</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>The complexity is structured using domain-specific notions (grid, UI elements, boxes)</li><li><i></i>A large amount of system complexity is hidden or externalized</li></ul>
</section>
<section data-characteristics="errors-static, errors-dynamic, errors-code" data-file="systems/hypercard" data-id="dims-errors" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-person-military-pointing&#39; title=&#39;Errors are detected before execution, e.g. through static type checking&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-code&#39; title=&#39;Errors have to be code in a separate stage, e.g. by modifying code based on an error message&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>High-level structure prevents many errors by construction. Script slips checked at runtime.
Correction done in code based on an error message.</p>
<ul><li><i></i>Errors are detected before execution, e.g. through static type checking</li><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>Errors have to be code in a separate stage, e.g. by modifying code based on an error message</li></ul>
</section>
<section data-characteristics="adoptability-minimal, adoptability-nonexperts, adoptability-community" data-file="systems/hypercard" data-id="dims-adoptability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-minimize&#39; title=&#39;The system is general purpose, but targets simple, small, specific needs&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-user&#39; title=&#39;The system can (also) be used used by non-experts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Focus on specific domain (hypermedia) and graphical interface supports learning. End-users can
progresively become programmers. Closed from external world, but active community sharing examples.</p>
<ul><li><i></i>The system is general purpose, but targets simple, small, specific needs</li><li><i></i>The system can (also) be used used by non-experts</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-hypercard-anchor sysdet" data-file="systems/hypercard" data-id="summary" data-title="Hypercard">

<p><a href="#image=systems/hypercard,screen"><img src="https://tomasp.net/techdims/img/sys/hypercard.jpg" alt=""/></a></p>
<p>Hypercard is a user-friendly general-purpose programming system built around the simple
hypertext abstraction of linked cards. It combines graphical interface with scription,
allowing a smooth progression from end-user to creator.</p>
<p>Hypercard is interesting in how it combines programming and using in a single unified
interface that combines multiple complementing notations and how the interface and
simple, yet flexible, programming model support adoption.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/hypercard,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-hypercard:paper,a-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-hypercard:dimensions/notation,complementing-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-hypercard:dimensions/conceptual-structure,composability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-hypercard:dimensions/adoptability,learnability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/hypercard" data-id="screen" data-title="Button configuration in Hypercard">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/hypercard.jpg" alt="Hypercard screenshot"/></p>
<p><strong>Hypercard screenshot.</strong> User interface for specifying properties and actions associated with a button in Hypercard
(<a href="http://basalgangster.macgui.com/RetroMacComputing/The_Long_View/Entries/2010/10/23_HyperCard.html">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/hypercard" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-open, interaction-principles" data-file="systems/lisp-machines" data-id="dims-interaction" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Integrated execution and editing mode, giving feedback at runtime.
Abstractions constructed using functions are accessible as data.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li></ul>
</section>
<section data-characteristics="notations-primary, notations, notations-uniform" data-file="systems/lisp-machines" data-id="dims-notation" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-trophy&#39; title=&#39;The system has a single primary notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars&#39; title=&#39;The system notation is uniform&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Very uniform notation with code and data represented as S-expressions
and edited either as text or using structure editor. Use of domain-specific languages.</p>
<ul><li><i></i>The system has a single primary notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is uniform</li></ul>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/lisp-machines" data-id="dims-conceptual-structure" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-plug&#39; title=&#39;The system provides an explicit method for capturing commondality&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link&#39; title=&#39;Complex concepts can be composed from simple ones&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-fist&#39; title=&#39;The systme does not aim for convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Small number of unified concepts (&#34;everything is a list&#34;) at odds with outside world.
Allows for composability, but lacks convenience (&#34;Lisp curse&#34;).</p>
<ul><li><i></i>The system provides an explicit method for capturing commondality</li><li><i></i>There is only a small number of concepts</li><li><i></i>Complex concepts can be composed from simple ones</li><li><i></i>The systme does not aim for convenience</li></ul>
</section>
<section data-characteristics="concepts-large, custom-runtime, custom-addressing, custom-additive, custom-sustainable" data-file="systems/lisp-machines" data-id="dims-customizability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-car-on&#39; title=&#39;The system can be modified while it is running&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-list-ol&#39; title=&#39;Addressing mechanism that allows referring to structures within the system&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file-circle-plus&#39; title=&#39;System can be modified by adding to it (additive authoring)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-arrows-spin&#39; title=&#39;The system is self-sustainable and can be modified from within itself&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>System can be customized at runtime. Much of the system is written in itself and can be
modified from within itself. Addressing can be done via &#34;advising&#34;.</p>
<ul><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li><li><i></i>The system can be modified while it is running</li><li><i></i>Addressing mechanism that allows referring to structures within the system</li><li><i></i>System can be modified by adding to it (additive authoring)</li><li><i></i>The system is self-sustainable and can be modified from within itself</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/lisp-machines" data-id="dims-complexity" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-building-columns&#39; title=&#39;There is a rich support for structuring of complexity (such as FP or OOP)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Optional but common factoring mechanisms include functions, CLOS and domain-specific languages.
Basic automation (garbage collection) with more in the context of AI research.</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>There is a rich support for structuring of complexity (such as FP or OOP)</li></ul>
</section>
<section data-characteristics="errors-dynamic, errors-recovery, errors-interactive" data-file="systems/lisp-machines" data-id="dims-errors" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-truck-fast&#39; title=&#39;The system provides some kind of automatic error recovery&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bug-slash&#39; title=&#39;Errors can be corrected interactively in a debugger (or editor) at runtime&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Errors detected at runtime and can be corrected immediately in interactive editor/debugger.
More checking can be done via reflection and code analysis.</p>
<ul><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>The system provides some kind of automatic error recovery</li><li><i></i>Errors can be corrected interactively in a debugger (or editor) at runtime</li></ul>
</section>
<section data-characteristics="adoptability-unified, adoptability-community" data-file="systems/lisp-machines" data-id="dims-adoptability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-table-cells-large&#39; title=&#39;The system has a unified design, providing value after the intial learning period&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Steep learning curve, but uniform design makes understanding reusable. Designed for programmers.
Active community, but closed from the external world and limited packages available.</p>
<ul><li><i></i>The system has a unified design, providing value after the intial learning period</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-lisp-machines-anchor sysdet" data-file="systems/lisp-machines" data-id="summary" data-title="Lisp machines">

<p><a href="#image=systems/lisp-machines,screen"><img src="https://tomasp.net/techdims/img/sys/lisp-genera.gif" alt="Lisp machines screenshot"/></a></p>
<p>Lisp machines are general-purpose computers designed to run Lisp. They generally run a version of
operating-system like Lisp that evolved from MacLisp and Interlisp.</p>
<p>Lisp machines use a persistent image-based model with all data and code existing in memory
(in theory, at least) in the form of addressable and uniform S-expressions.
This allows self-sustainability and interactive error-response.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/lisp-machines,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-lisp-machines:paper,o-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/interaction,modes-of-interaction!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/notation,uniformity-of-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/conceptual-structure,example-integrity!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/conceptual-structure,example-openness!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/customizability,staging!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/errors,error-response!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/adoptability,learnability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-lisp-machines:dimensions/adoptability,sociability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/lisp-machines" data-id="screen" data-title="Source-oriented debugging in the Genera system for Lisp machines">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/lisp-genera.gif" alt="Lisp machines screenshot"/></p>
<p><strong>Lisp machines screenshot.</strong> Source-oriented debugging in the Genera system for Lisp machines
(<a href="https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/index.html">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/lisp-machines" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-open, interaction-principles, interaction-concrete" data-file="systems/notebooks" data-id="dims-interaction" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-eye&#39; title=&#39;Abstractions are constructed from concrete examples&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Feedback and execution at cell level.
Programmatic abstractions are possible, but manual approach by copying or modifying code is common.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li><li><i></i>Abstractions are constructed from concrete examples</li></ul>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/notebooks" data-id="dims-notation" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars-staggered&#39; title=&#39;The system notation is non-uniform&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-image&#39; title=&#39;Notations include some graphical notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Literate programming with code, text and outputs, embedded in a notebook as complementing notations.
Document model where notebook is a list of cells.</p>
<ul><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is non-uniform</li><li><i></i>Notations include some graphical notation</li></ul>
</section>
<section data-characteristics="concepts-large, concepts-diverse, concepts-noncomposable, concepts-convenient" data-file="systems/notebooks" data-id="dims-conceptual-structure" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-shapes&#39; title=&#39;There is a wide range of diverse concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link-slash&#39; title=&#39;The concepts cannot be composed&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-toolbox&#39; title=&#39;The system offers a high built-in convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Notebook and cells as &#34;large&#34; concepts with code notions (Python) as &#34;small&#34; concepts.
Composability primarily at code level, but not notebook level. Convenient libraries and tools.</p>
<ul><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li><li><i></i>There is a wide range of diverse concepts</li><li><i></i>The concepts cannot be composed</li><li><i></i>The system offers a high built-in convenience</li></ul>
</section>
<section data-characteristics="custom-oss, custom-closed" data-file="systems/notebooks" data-id="dims-customizability" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-code-pull-request&#39; title=&#39;System source can be modified (open source) and has community support&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-square-xmark&#39; title=&#39;The system itself is closed and not (easily) modifiable&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>System is fixed, but can theoretically be modified as open-source project with community.
Programs cannot modify themselves, notebook or system at runtime.</p>
<ul><li><i></i>System source can be modified (open source) and has community support</li><li><i></i>The system itself is closed and not (easily) modifiable</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/notebooks" data-id="dims-complexity" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-receipt&#39; title=&#39;The complexity is structured using domain-specific notions (grid, UI elements, boxes)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-satellite-dish&#39; title=&#39;A large amount of system complexity is hidden or externalized&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Complexity relegated to complex libraries (pandas, ML libraries, etc.) created outside the system.
Basic language automation (GC) but no automatic recomputation in standard Jupyter setup.</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>The complexity is structured using domain-specific notions (grid, UI elements, boxes)</li><li><i></i>A large amount of system complexity is hidden or externalized</li></ul>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/notebooks" data-id="dims-errors" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-point-up&#39; title=&#39;The system provides immediate feedback, allowing immediate error response&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Slips caught at runtime. Limited checking of lapses or domain-specific mistakes.
REPL-evaluation provides quick feedback, making quick error correction possible.</p>
<ul><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>The system provides immediate feedback, allowing immediate error response</li></ul>
</section>
<section data-characteristics="adoptability-domain, adoptability-nonexperts, adoptability-worse, adoptability-packages, adoptability-community" data-file="systems/notebooks" data-id="dims-adoptability" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-clapperboard&#39; title=&#39;The system is focused on a specific application domain&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-user&#39; title=&#39;The system can (also) be used used by non-experts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-globe&#39; title=&#39;The system is compatible with a wide range of external systems and concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-boxes-packing&#39; title=&#39;There is an easy way sharing of packages in the community&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Learnability is supported by focus on a specific domain, graphical interface and community.
Notebooks can import a range of community packages and integrate with external systems.</p>
<ul><li><i></i>The system is focused on a specific application domain</li><li><i></i>The system can (also) be used used by non-experts</li><li><i></i>The system is compatible with a wide range of external systems and concepts</li><li><i></i>There is an easy way sharing of packages in the community</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-notebooks-anchor sysdet" data-file="systems/notebooks" data-id="summary" data-title="Notebooks">

<p><a href="#image=systems/notebooks,screen"><img src="https://tomasp.net/techdims/img/sys/ipython.png" alt=""/></a></p>
<p>Notebook systems such as Jupyter and IPython are literate programming systems built around one or
more programming languages (Python, Julia). They structure code in cells and utilize a REPL
to let user interactively execute parts of code. This provides quick, but not &#34;live&#34; feedback.</p>
<p>Notebooks typically rely on rich external libraries for complex tasks. Code in notebooks tends to
use fewer abstractions. The system is optimized for a specific domain and cannot be easily modified.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/notebooks,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-notebooks:paper,l-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-notebooks:dimensions/interaction,modes-of-interaction!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-notebooks:dimensions/interaction,abstraction-construction!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-notebooks:dimensions/notation,complementing-notations!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/notebooks" data-id="screen" data-title="Literate programming in IPython notebook">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/ipython.png" alt="IPython notebook screenshot"/></p>
<p><strong>IPython notebook screenshot.</strong> A sample computational notebook in IPython (predecessor of Jupyter Notebooks), showing an interleaving of text, mathematical formulas, code and graphical outputs produced by the code
(<a href="https://ipython.org/index.html">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/notebooks" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-open, interaction-principles" data-file="systems/smalltalk" data-id="dims-interaction" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Integrated execution and editing mode, giving feedback at runtime.
Abstractions constructed using objects are accessible via a browser.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li></ul>
</section>
<section data-characteristics="notations-primary, notations, notations-uniform" data-file="systems/smalltalk" data-id="dims-notation" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-trophy&#39; title=&#39;The system has a single primary notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars&#39; title=&#39;The system notation is uniform&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Primary source code notation with graphical structure editor for object structure.
Secondary overlapping notations can be developed in-system. Small language.</p>
<ul><li><i></i>The system has a single primary notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is uniform</li></ul>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/smalltalk" data-id="dims-conceptual-structure" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-plug&#39; title=&#39;The system provides an explicit method for capturing commondality&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link&#39; title=&#39;Complex concepts can be composed from simple ones&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-fist&#39; title=&#39;The systme does not aim for convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Small number of unified concepts (&#34;everything is an object&#34;) at odds with outside world.
Everything is composed from small number of primitives, but limits convenience. Structural commonality.</p>
<ul><li><i></i>The system provides an explicit method for capturing commondality</li><li><i></i>There is only a small number of concepts</li><li><i></i>Complex concepts can be composed from simple ones</li><li><i></i>The systme does not aim for convenience</li></ul>
</section>
<section data-characteristics="custom-runtime, custom-addressing, custom-additive, custom-sustainable" data-file="systems/smalltalk" data-id="dims-customizability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-car-on&#39; title=&#39;The system can be modified while it is running&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-list-ol&#39; title=&#39;Addressing mechanism that allows referring to structures within the system&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file-circle-plus&#39; title=&#39;System can be modified by adding to it (additive authoring)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-arrows-spin&#39; title=&#39;The system is self-sustainable and can be modified from within itself&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>System can be customized at runtime. Much of the system is written in itself and can be
modified from within itself. Extensibility achieved via object-oriented programming.</p>
<ul><li><i></i>The system can be modified while it is running</li><li><i></i>Addressing mechanism that allows referring to structures within the system</li><li><i></i>System can be modified by adding to it (additive authoring)</li><li><i></i>The system is self-sustainable and can be modified from within itself</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/smalltalk" data-id="dims-complexity" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-building-columns&#39; title=&#39;There is a rich support for structuring of complexity (such as FP or OOP)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Factoring using a rich class-based system covering system and application-level features.
Basic automation (garbage collection) with more possible through libraries &amp; via reflection.</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>There is a rich support for structuring of complexity (such as FP or OOP)</li></ul>
</section>
<section data-characteristics="errors-dynamic, errors-interactive" data-file="systems/smalltalk" data-id="dims-errors" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bug-slash&#39; title=&#39;Errors can be corrected interactively in a debugger (or editor) at runtime&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Errors detected at runtime and can be corrected immediately in interactive editor/debugger.
Further detection possible via engineering testing tools.</p>
<ul><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>Errors can be corrected interactively in a debugger (or editor) at runtime</li></ul>
</section>
<section data-characteristics="adoptability-unified, adoptability-nonexperts, adoptability-community" data-file="systems/smalltalk" data-id="dims-adoptability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-table-cells-large&#39; title=&#39;The system has a unified design, providing value after the intial learning period&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-user&#39; title=&#39;The system can (also) be used used by non-experts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Steep learning curve, but uniform design makes understanding reusable. End-users can progressively become programmers.
Active community, but closed world and limited packages.</p>
<ul><li><i></i>The system has a unified design, providing value after the intial learning period</li><li><i></i>The system can (also) be used used by non-experts</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-smalltalk-anchor sysdet" data-file="systems/smalltalk" data-id="summary" data-title="Smalltalk">

<p><a href="#image=systems/smalltalk,screen"><img src="https://tomasp.net/techdims/img/sys/smalltalk-78.png" alt=""/></a></p>
<p>Smalltalk was developed as a communication system for &#34;personal dynamic medium&#34; that could be owned by
everyone and could &#34;handle virtually all of its owner’s information-related needs.&#34; As such, it is
highly adaptable and customizable from within itself.</p>
<p>It is based on a small and coherent programming model based on object-oriented programming, embedded
in an image-based persistent interactive programming environment that makes it possible to explore,
modify and debug the living system at all times.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/smalltalk,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-smalltalk:paper,o-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-smalltalk:dimensions/notation,primary-secondary-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/conceptual-structure,example-integrity!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/conceptual-structure,example-openness!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/customizability,staging!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/customizability,self-sustainability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/adoptability,learnability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-smalltalk:dimensions/adoptability,sociability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/smalltalk" data-id="screen" data-title="Screenshot of Smalltalk-78 emulation running in the Smalltalk Zoo">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/smalltalk-78.png" alt="Smalltalk 78 screenshot"/></p>
<p><strong>Smalltalk 78 screenshot.</strong> Screenshot of Smalltalk-78 emulation running in the Smalltalk Zoo, developed by the <a href="https://computerhistory.org/blog/introducing-the-smalltalk-zoo-48-years-of-smalltalk-history-at-chm/">Computer History Museum</a>. The screenshot illustrates a part of a Smalltalk demo given to Steve Jobs by the Smalltalk developers
(<a href="https://computerhistory.org/blog/introducing-the-smalltalk-zoo-48-years-of-smalltalk-history-at-chm/">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/smalltalk" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-single, interaction-live, interaction-dm, interaction-open, interaction-concrete" data-file="systems/spreadsheets" data-id="dims-interaction" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-chess-board&#39; title=&#39;There is only a single mode of interaction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-rotate-right&#39; title=&#39;System provides some kind of live feedback&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-pointer&#39; title=&#39;System supports some kind of direct manipulation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-eye&#39; title=&#39;Abstractions are constructed from concrete examples&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Live update when editing. Formulas are always accessible.
Abstraction by generalizing from concrete computation (drag down) or using macros.</p>
<ul><li><i></i>There is only a single mode of interaction</li><li><i></i>System provides some kind of live feedback</li><li><i></i>System supports some kind of direct manipulation</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from concrete examples</li></ul>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/spreadsheets" data-id="dims-notation" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-puzzle-piece&#39; title=&#39;The system supports some kind of structure editing&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars-staggered&#39; title=&#39;The system notation is non-uniform&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-image&#39; title=&#39;Notations include some graphical notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Complementing notations with graphical grid, formulas and macros, allowing gradually richer interactions.
Different non-uniform notation at each level.</p>
<ul><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system supports some kind of structure editing</li><li><i></i>The system notation is non-uniform</li><li><i></i>Notations include some graphical notation</li></ul>
</section>
<section data-characteristics="concepts-minimal, concepts-composable, concepts-convenient" data-file="systems/spreadsheets" data-id="dims-conceptual-structure" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-gem&#39; title=&#39;There is only a small number of concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link&#39; title=&#39;Complex concepts can be composed from simple ones&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-toolbox&#39; title=&#39;The system offers a high built-in convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Limited number of domain-specific concepts (sheet, formula, macro).
Computation can be composed and formulas constructed using many convenient built-ins. Structural commonality.</p>
<ul><li><i></i>There is only a small number of concepts</li><li><i></i>Complex concepts can be composed from simple ones</li><li><i></i>The system offers a high built-in convenience</li></ul>
</section>
<section data-characteristics="custom-closed, concepts-large" data-file="systems/spreadsheets" data-id="dims-customizability" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-square-xmark&#39; title=&#39;The system itself is closed and not (easily) modifiable&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Documents are editable during execution, but system itself cannot be modified.
Adding only appends computations, but cannot modify existing ones.</p>
<ul><li><i></i>The system itself is closed and not (easily) modifiable</li><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li></ul>
</section>
<section data-characteristics="complexity-fancy, complexity-domain" data-file="systems/spreadsheets" data-id="dims-complexity" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-wand-magic-sparkles&#39; title=&#39;The system offers some kind of more advanced automation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-receipt&#39; title=&#39;The complexity is structured using domain-specific notions (grid, UI elements, boxes)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Fixed structure of formulas and grid. High-level language for formulas with automated re-computation.
Programming-by-example provides next-step automation.</p>
<ul><li><i></i>The system offers some kind of more advanced automation</li><li><i></i>The complexity is structured using domain-specific notions (grid, UI elements, boxes)</li></ul>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/spreadsheets" data-id="dims-errors" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-person-running&#39; title=&#39;Errors are detected at runtime during program execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-hand-point-up&#39; title=&#39;The system provides immediate feedback, allowing immediate error response&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Slips caught at runtime, but no support for checking lapses or mistakes.
Provides immediate feedback, making quick error correction possible.</p>
<ul><li><i></i>Errors are detected at runtime during program execution</li><li><i></i>The system provides immediate feedback, allowing immediate error response</li></ul>
</section>
<section data-characteristics="adoptability-domain, adoptability-nonexperts, adoptability-minimal" data-file="systems/spreadsheets" data-id="dims-adoptability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-clapperboard&#39; title=&#39;The system is focused on a specific application domain&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-user&#39; title=&#39;The system can (also) be used used by non-experts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-minimize&#39; title=&#39;The system is general purpose, but targets simple, small, specific needs&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Domain-focus on specific needs and graphical interface supports learning. End-users can progressively become programmers.
No packaging mechanism, but wide range of samples and community available.</p>
<ul><li><i></i>The system is focused on a specific application domain</li><li><i></i>The system can (also) be used used by non-experts</li><li><i></i>The system is general purpose, but targets simple, small, specific needs</li></ul>
</section>
<section data-class="systems-spreadsheets-anchor sysdet" data-file="systems/spreadsheets" data-id="summary" data-title="Spreadsheets">

<p><a href="#image=systems/spreadsheets,screen"><img src="https://tomasp.net/techdims/img/sys/visicalc.png" alt=""/></a></p>
<p>Spreadsheets are focused on working with tabular data, but allow a great degree of programmability
in this context.</p>
<p>As programming systems, spreadsheets feature a unique programming substrate (two-dimensional grid)
and evaluation model with automatic (live) recomputation. They allow construction of abstractions
from concrete computations and have been extended with plurality of notations and novel styles of
programming, such as programming by example.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/spreadsheets,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-spreadsheets:paper,a-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-spreadsheets:dimensions/interaction,abstraction-construction!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-spreadsheets:dimensions/interaction,direct-manipulation!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-spreadsheets:dimensions/notation,complementing-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-spreadsheets:dimensions/complexity,pbe!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/spreadsheets" data-id="screen" data-title="A screenshot of VisiCalc">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/visicalc.png" alt="VisiCalc screenshot"/></p>
<p><strong>VisiCalc screenshot.</strong> VisiCalc was the first spreadsheet computer program, developed for Apple II in 1979. The screenshot shows a spreadsheet performing a simple computation
(<a href="https://en.wikipedia.org/wiki/VisiCalc">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/spreadsheets" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-multi, interaction-repl, interaction-closed, interaction-principles, interaction-concrete" data-file="systems/unix" data-id="dims-interaction" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-forward&#39; title=&#39;There are multiple modes of interaction such as compilation vs. execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock&#39; title=&#39;Astractions are closed and inaccessible for exploration&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-eye&#39; title=&#39;Abstractions are constructed from concrete examples&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Edit, build and execution modes with feedback in each step.
Abstractions include files, memory and processes. Shell allows going from concrete to abstract.</p>
<ul><li><i></i>There are multiple modes of interaction such as compilation vs. execution</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>Astractions are closed and inaccessible for exploration</li><li><i></i>Abstractions are constructed from the first principles</li><li><i></i>Abstractions are constructed from concrete examples</li></ul>
</section>
<section data-characteristics="notations-primary, notations-complementing, notations-nonuniform, notations-concise" data-file="systems/unix" data-id="dims-notation" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-trophy&#39; title=&#39;The system has a single primary notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars-staggered&#39; title=&#39;The system notation is non-uniform&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bug&#39; title=&#39;There is a concise error-prone notation&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Primary notation (the C language) with variety of secondary (file system, shell scripts),
all edited via text editor. Admits concise but error-prone notations.</p>
<ul><li><i></i>The system has a single primary notation</li><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system notation is non-uniform</li><li><i></i>There is a concise error-prone notation</li></ul>
</section>
<section data-characteristics="concepts-large, concepts-composable, concepts-convenient" data-file="systems/unix" data-id="dims-conceptual-structure" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-link&#39; title=&#39;Complex concepts can be composed from simple ones&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-toolbox&#39; title=&#39;The system offers a high built-in convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Files provide &#34;large&#34; common concepts, but details are open.
Scripting based on small composable tools. Standard libraries and tools offer convenience.</p>
<ul><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li><li><i></i>Complex concepts can be composed from simple ones</li><li><i></i>The system offers a high built-in convenience</li></ul>
</section>
<section data-characteristics="custom-stages, custom-additive, custom-sustainable" data-file="systems/unix" data-id="dims-customizability" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-flag-checkered&#39; title=&#39;There is an explicit stage distinction&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file-circle-plus&#39; title=&#39;System can be modified by adding to it (additive authoring)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-arrows-spin&#39; title=&#39;The system is self-sustainable and can be modified from within itself&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Explicit stage distinction between execution and building, but system is written using its
own notation (C language) and can be modified and rebuilt from within itself. Limited
modifiability at runtime.</p>
<ul><li><i></i>There is an explicit stage distinction</li><li><i></i>System can be modified by adding to it (additive authoring)</li><li><i></i>The system is self-sustainable and can be modified from within itself</li></ul>
</section>
<section data-characteristics="complexity-manual, complexity-lowlevel" data-file="systems/unix" data-id="dims-complexity" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-wrench&#39; title=&#39;There is no support for automation and all operations are manual&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-gears&#39; title=&#39;The system provides basic low level infrastructure (such as files, protocolos)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Defines low-level infrastructure (hardware abstractions) and large object structure (files, processes);
small-scale factoring and automation left to the user and/or application.</p>
<ul><li><i></i>There is no support for automation and all operations are manual</li><li><i></i>The system provides basic low level infrastructure (such as files, protocolos)</li></ul>
</section>
<section data-characteristics="errors-shootfoot, errors-custom" data-file="systems/unix" data-id="dims-errors" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-gun&#39; title=&#39;There is no (or very little) automatic error checking&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-person-rays&#39; title=&#39;It is possible to provide custom erorr detection or correction mechanism&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Error detection left to the system user. Low-level primitives make it possible to
automate detection and response via custom mechanisms.</p>
<ul><li><i></i>There is no (or very little) automatic error checking</li><li><i></i>It is possible to provide custom erorr detection or correction mechanism</li></ul>
</section>
<section data-characteristics="adoptability-background, adoptability-worse, adoptability-community" data-file="systems/unix" data-id="dims-adoptability" data-shade="shade2" data-title="&lt;div class=&#39;shade2&#39;&gt;&lt;i class=&#39;fa fa-infinity&#39; title=&#39;The users need to have advanced background knowledge&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-globe&#39; title=&#39;The system is compatible with a wide range of external systems and concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Requires background knowledge (system-level), but supported by active community.
Openness allows integration with the external world; diversity of packages available.</p>
<ul><li><i></i>The users need to have advanced background knowledge</li><li><i></i>The system is compatible with a wide range of external systems and concepts</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-unix-anchor sysdet" data-file="systems/unix" data-id="summary" data-title="UNIX">

<p><a href="#image=systems/unix,screen"><img src="https://tomasp.net/techdims/img/sys/unix-6.png" alt=""/></a></p>
<p>UNIX can be seen as a programming system, consisting of the OS-level abstractions such as files
and processes, and associated tools including the C language, its compiler, shell and command line
tools.</p>
<p>The high-level abstractions support a pluralistic open ecosystem which has, arguably, been a
key to its wide-spread success. The system can be also modified from within itself, albeit with
an explicit stage distinction (compilation).</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/unix,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-unix:paper,o-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-unix:dimensions/notation,primary-secondary-notations!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/notation,expression-geography!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/conceptual-structure,composability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/conceptual-structure,convenience!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/conceptual-structure,example-openness!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/customizability,self-sustainability!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-unix:dimensions/adoptability,sociability!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/unix" data-id="screen" data-title="Version 6 UNIX running in a PDP-11 emulator">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/unix-6.png" alt="UNIX 6 screenshot"/></p>
<p><strong>UNIX screenshot.</strong> Version 6 Unix running in the SIMH PDP-11 emulator. This was the first widely distributed version of UNIX, released in 1975
(<a href="https://en.wikipedia.org/wiki/Version_6_Unix">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/unix" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>
<section data-characteristics="interaction-multi, interaction-repl, interaction-live, interaction-closed, interaction-open, interaction-principles" data-file="systems/web" data-id="dims-interaction" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-forward&#39; title=&#39;There are multiple modes of interaction such as compilation vs. execution&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-circle-play&#39; title=&#39;System supports REPL (or similar) feedback loop&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-rotate-right&#39; title=&#39;System provides some kind of live feedback&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock&#39; title=&#39;Astractions are closed and inaccessible for exploration&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-lock-open&#39; title=&#39;Abstractions are transparent and can be explored&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-subscript&#39; title=&#39;Abstractions are constructed from the first principles&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Edit and refresh mode with state visible in DOM browser and live developer tools.
Code abstractions are closed, but style abstractions more transparent.</p>
<ul><li><i></i>There are multiple modes of interaction such as compilation vs. execution</li><li><i></i>System supports REPL (or similar) feedback loop</li><li><i></i>System provides some kind of live feedback</li><li><i></i>Astractions are closed and inaccessible for exploration</li><li><i></i>Abstractions are transparent and can be explored</li><li><i></i>Abstractions are constructed from the first principles</li></ul>
</section>
<section data-characteristics="notations-complementing, notations-nonuniform" data-file="systems/web" data-id="dims-notation" data-shade="shade3" data-title="&lt;div class=&#39;shade3&#39;&gt;&lt;i class=&#39;fa fa-handshake&#39; title=&#39;Notations include multiple complementing notation&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bars-staggered&#39; title=&#39;The system notation is non-uniform&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Diversity of text-based highly non-uniform notations (HTML, JavaScript, CSS) with limited structure editing for debugging (DOM).</p>
<ul><li><i></i>Notations include multiple complementing notation</li><li><i></i>The system notation is non-uniform</li></ul>
</section>
<section data-characteristics="concepts-large, concepts-diverse, concepts-domain, concepts-convenient" data-file="systems/web" data-id="dims-conceptual-structure" data-shade="shade1" data-title="&lt;div class=&#39;shade1&#39;&gt;&lt;i class=&#39;fa fa-file&#39; title=&#39;The system has abstractions for large concepts (files, pages, etc.)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-shapes&#39; title=&#39;There is a wide range of diverse concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-flask&#39; title=&#39;There are suitable domain-specific concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-toolbox&#39; title=&#39;The system offers a high built-in convenience&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Improvised mix of open &#34;large&#34; concepts (HTTP) and specific ones (DOM).
Many convenient libraries and tools with low commonality and varying composability.</p>
<ul><li><i></i>The system has abstractions for large concepts (files, pages, etc.)</li><li><i></i>There is a wide range of diverse concepts</li><li><i></i>There are suitable domain-specific concepts</li><li><i></i>The system offers a high built-in convenience</li></ul>
</section>
<section data-characteristics="custom-runtime, custom-closed, custom-addressing, custom-additive" data-file="systems/web" data-id="dims-customizability" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-car-on&#39; title=&#39;The system can be modified while it is running&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-square-xmark&#39; title=&#39;The system itself is closed and not (easily) modifiable&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-list-ol&#39; title=&#39;Addressing mechanism that allows referring to structures within the system&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-file-circle-plus&#39; title=&#39;System can be modified by adding to it (additive authoring)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Basic infrastructure (browser, protocols) are fixed. Individual applications can have
a large degree of modifiability (via dynamic scripting). CSS provides powerful addressing.</p>
<ul><li><i></i>The system can be modified while it is running</li><li><i></i>The system itself is closed and not (easily) modifiable</li><li><i></i>Addressing mechanism that allows referring to structures within the system</li><li><i></i>System can be modified by adding to it (additive authoring)</li></ul>
</section>
<section data-characteristics="complexity-gc, complexity-rich, complexity-lowlevel, complexity-domain" data-file="systems/web" data-id="dims-complexity" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-recycle&#39; title=&#39;The system offers basic automation, such as language with a garbage collector&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-building-columns&#39; title=&#39;There is a rich support for structuring of complexity (such as FP or OOP)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-gears&#39; title=&#39;The system provides basic low level infrastructure (such as files, protocolos)&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-receipt&#39; title=&#39;The complexity is structured using domain-specific notions (grid, UI elements, boxes)&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Factoring via high-level languages (JavaScript), rule-based systems (CSS) and standard interfaces
(W3C specifications). Automation at basic level (garbage collection) and in declarative domains (CSS).</p>
<ul><li><i></i>The system offers basic automation, such as language with a garbage collector</li><li><i></i>There is a rich support for structuring of complexity (such as FP or OOP)</li><li><i></i>The system provides basic low level infrastructure (such as files, protocolos)</li><li><i></i>The complexity is structured using domain-specific notions (grid, UI elements, boxes)</li></ul>
</section>
<section data-characteristics="errors-custom, errors-recovery, errors-code, errors-interactive" data-file="systems/web" data-id="dims-errors" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-person-rays&#39; title=&#39;It is possible to provide custom erorr detection or correction mechanism&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-truck-fast&#39; title=&#39;The system provides some kind of automatic error recovery&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-code&#39; title=&#39;Errors have to be code in a separate stage, e.g. by modifying code based on an error message&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-bug-slash&#39; title=&#39;Errors can be corrected interactively in a debugger (or editor) at runtime&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Generally aims to do the best thing possible (automatic recovery) on errors.
Direct error correction can be done in browser tools, but not permanent.</p>
<ul><li><i></i>It is possible to provide custom erorr detection or correction mechanism</li><li><i></i>The system provides some kind of automatic error recovery</li><li><i></i>Errors have to be code in a separate stage, e.g. by modifying code based on an error message</li><li><i></i>Errors can be corrected interactively in a debugger (or editor) at runtime</li></ul>
</section>
<section data-characteristics="adoptability-worse, adoptability-packages, adoptability-community" data-file="systems/web" data-id="dims-adoptability" data-shade="shade4" data-title="&lt;div class=&#39;shade4&#39;&gt;&lt;i class=&#39;fa fa-globe&#39; title=&#39;The system is compatible with a wide range of external systems and concepts&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-boxes-packing&#39; title=&#39;There is an easy way sharing of packages in the community&#39;&gt;&lt;/i&gt;&lt;i class=&#39;fa fa-podcast&#39; title=&#39;The sytem has (or had) some kind of active and vibrant community&#39;&gt;&lt;/i&gt;&lt;/div&gt;">
<p>Web has a diversity of technologies; learnability is mainly achieved through community.
The diversified web ecosystem allows for the integration with external systems.</p>
<ul><li><i></i>The system is compatible with a wide range of external systems and concepts</li><li><i></i>There is an easy way sharing of packages in the community</li><li><i></i>The sytem has (or had) some kind of active and vibrant community</li></ul>
</section>
<section data-class="systems-web-anchor sysdet" data-file="systems/web" data-id="summary" data-title="Web platform">

<p><a href="#image=systems/web,screen"><img src="https://tomasp.net/techdims/img/sys/web-ie5.png" alt=""/></a></p>
<p>The web evolved from an information sharing platform to a complex and pluralistic programming system
that relies on an unprecedented diversity of tools including langauges for server-side and client-side
programming, CSS, compilers to JavaScript and browsers with their debugging tools.</p>
<p>Web provides open high-level abstractions such as resources, end-points and protocols that enable
interoperation between very different sub-systems. It includes interesting specific components, such
as the Document Object Model (DOM) and Cascading Style Sheets (CSS) language that can serve as
inspiration for different thinking about programming.</p>
<h2>Summary</h2>
<ul>
<li><a href="#*=.;right=systems/web,overview"><i></i>Technical dimensions summary</a></li>
<li><a href="#*=.;right=systems-web:paper,o-type!"><i></i>!</a></li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="#*=.;right=systems-web:dimensions/notation,explicit-implicit-structure!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-web:dimensions/conceptual-structure,example-openness!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-web:dimensions/customizability,staging!"><i></i>!</a></li>
<li><a href="#*=.;right=systems-web:dimensions/customizability,addressing!"><i></i>!</a></li>
</ul>
</section>
<section data-file="systems/web" data-id="screen" data-title="A web page opening a pop-up window in Internet Explorer 5">
<blockquote>
<p><img src="https://tomasp.net/techdims/img/sys/web-ie5.png" alt="Web platform screenshot"/></p>
<p><strong>Web platform screenshot.</strong> A simple page that opens a pop-up window and contains a JavaScript coding error, running in Internet Explorer 5 on Windows 98.
(<a href="https://tomasp.net/blog/2021/popup-from-hell/">source</a>).</p>
</blockquote>
</section>
<section data-class="dimlist" data-file="systems/web" data-id="overview" data-title="Technical dimensions summary">

<h3>Interaction</h3>

<h3>Notation</h3>

<h3>Conceptual structure</h3>

<h3>Customizability</h3>

<h3>Complexity</h3>

<h3>Errors</h3>

<h3>Adoptability</h3>

</section>

  </article></div>
  </body>
</html>
