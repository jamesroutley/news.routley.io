<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davidamos.dev/the-right-way-to-compare-floats-in-python/">Original</a>
    <h1>How to compare floats in Python</h1>
    
    <div id="readability-page-1" class="page"><section>
<p>Floating-point numbers are a fast and efficient way to store and work with numbers, but they come with a range of pitfalls that have surely stumped many fledgling programmers — perhaps some experienced programmers, too! The classic example demonstrating the pitfalls of floats goes like this:</p><pre><code>&gt;&gt;&gt; 0.1 + 0.2 == 0.3
False</code></pre><p>Seeing this for the first time can be disorienting. But don&#39;t throw your computer in the trash bin. This behavior is correct!</p><p>This article will show you why floating-point errors like the one above are common, why they make sense, and what you can do to deal with them in Python.</p><figure><iframe width="200" height="113" src="https://www.youtube.com/embed/EYh35NrYkog?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></figure><h2 id="your-computer-is-a-liar-sort-of">Your Computer is a Liar (Sort Of)</h2><p>You&#39;ve seen that <code>0.1 + 0.2</code> is not equal to <code>0.3</code> but the madness doesn&#39;t stop there. Here are some more confounding examples:</p><pre><code>&gt;&gt;&gt; 0.2 + 0.2 + 0.2 == 0.6
False

&gt;&gt;&gt; 1.3 + 2.0 == 3.3
False

&gt;&gt;&gt; 1.2 + 2.4 + 3.6 == 7.2
False</code></pre><p>The issue isn&#39;t restricted to equality comparisons, either:</p><pre><code>&gt;&gt;&gt; 0.1 + 0.2 &lt;= 0.3
False

&gt;&gt;&gt; 10.4 + 20.8 &gt; 31.2
True

&gt;&gt;&gt; 0.8 - 0.1 &gt; 0.7
True</code></pre><p>So what&#39;s going on? Is your computer lying to you? It sure looks like it, but there&#39;s more going on beneath the surface.</p><p>When you type the number <code>0.1</code> into the Python interpreter, it gets stored in memory as a floating-point number. There&#39;s a conversion that takes place when this happens. <code>0.1</code> is a decimal in base 10, but floating-point numbers are stored in binary. In other words, <code>0.1</code> gets converted from base 10 to base 2.</p><p>The resulting binary number may not accurately represent the original base 10 number. <code>0.1</code> is one example. The binary representation is \(0.0\overline{0011}\). That is, <code>0.1</code> is an infinitely repeating decimal when written in base 2. The same thing happens when you write the fraction ⅓ as a decimal in base 10. You end up with the infinitely repeating decimal \(0.\overline{33}\).</p><p>Computer memory is finite, so the infinitely repeating binary fraction representation of <code>0.1</code> gets rounded to a finite fraction. The value of this number depends on your computer&#39;s architecture (32-bit vs. 64-bit). One way to see the floating-point value that gets stored for <code>0.1</code> is to use the <code>.as_integer_ratio()</code> method for floats to get the numerator and denominator of the floating-point representation:</p><pre><code>&gt;&gt;&gt; numerator, denominator = (0.1).as_integer_ratio()
&gt;&gt;&gt; f&#34;0.1 ≈ {numerator} / {denominator}&#34;
&#39;0.1 ≈ 3602879701896397 / 36028797018963968&#39;</code></pre><p>Now use <code>format()</code> to show the fraction accurate to 55 decimal places:</p><pre><code>&gt;&gt;&gt; format(numerator / denominator, &#34;.55f&#34;)
&#39;0.1000000000000000055511151231257827021181583404541015625&#39;</code></pre><p>So <code>0.1</code> gets rounded to a number slightly larger than its true value.</p><p>This error, known as <strong>floating-point representation error</strong>, happens way more often than you might realize.</p><h2 id="representation-error-is-really-common">Representation Error is <em>Really</em> Common</h2><p>There are three reasons that a number gets rounded when represented as a floating-point number:</p><ol><li>The number has more significant digits than floating points allow.</li><li>The number is irrational.</li><li>The number is rational but has a non-terminating binary representation.</li></ol><p>64-bit floating-point numbers are good for about 16 or 17 significant digits. Any number with more significant digits gets rounded. Irrational numbers, like π and <em>e</em>, can&#39;t be represented by any terminating fraction in any integer base. So again, no matter what, irrational numbers will get rounded when stored as floats.</p><p>These two situations create an infinite set of numbers that can&#39;t be exactly represented as a floating-point number. But unless you&#39;re a chemist dealing with tiny numbers, or a physicist dealing with astronomically large numbers, you&#39;re unlikely to run into these problems.</p><p>What about non-terminating rational numbers, like <code>0.1</code> in base 2? This is where you&#39;ll encounter most of your floating-point woes, and thanks to the math that determines whether or not a fraction terminates, you&#39;ll brush up against representation error more often than you think.</p><p>In base 10, a fraction <strong>terminates</strong> if its denominator is a product of powers of <a href="https://en.wikipedia.org/wiki/Integer_factorization">prime factors</a> of 10. The two prime factors of 10 are 2 and 5, so fractions like ½, ¼, ⅕, ⅛, and ⅒ all terminate, but ⅓, ⅐, and ⅑ do not. In base 2, however, there is only one prime factor: 2. So only fractions whose denominator is a power of 2 terminate. As a result, fractions like ⅓, ⅕, ⅙, ⅐, ⅑, and ⅒ are all non-terminating when expressed in binary.</p><p>You can now understand the original example in this article. <code>0.1</code>, <code>0.2</code>, and <code>0.3</code> all get rounded when converted to floating-point numbers:</p><pre><code>&gt;&gt;&gt; # -----------vvvv  Display with 17 significant digits
&gt;&gt;&gt; format(0.1, &#34;.17g&#34;)
&#39;0.10000000000000001&#39;

&gt;&gt;&gt; format(0.2, &#34;.17g&#34;)
&#39;0.20000000000000001&#39;

&gt;&gt;&gt; format(0.3, &#34;.17g&#34;)
&#39;0.29999999999999999&#39;</code></pre><p>When <code>0.1</code> and <code>0.2</code> are added, the result is a number slightly larger than <code>0.3</code>:</p><pre><code>&gt;&gt;&gt; 0.1 + 0.2
0.30000000000000004</code></pre><p>Since <code>0.1 + 0.2</code> is slightly larger than<code>0.3</code> and <code>0.3</code> gets represented by a number slightly smaller than itself, the expression <code>0.1 + 0.2 == 0.3</code> evaluates to <code>False</code>.</p><div><p>❗</p><p>Floating-point representation error is something every programmer in every language needs to be aware of and know how to handle. <strong>It&#39;s not specific to Python</strong>. You can see the result of printing <code>0.1 + 0.2</code> in many different languages over at Erik Wiffin&#39;s aptly named website <a href="https://0.30000000000000004.com/">0.30000000000000004.com</a>.</p></div><h2 id="how-to-compare-floats-in-python">How To Compare Floats in Python</h2><p>So, how do you deal with floating-point representation errors when comparing floats in Python? The trick is to avoid checking for equality. Never use <code>==</code>, <code>&gt;=</code>, or <code>&lt;=</code> with floats. Use the <a href="https://docs.python.org/3/library/math.html#math.isclose"><code>math.isclose()</code></a> function instead:</p><pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.isclose(0.1 + 0.2, 0.3)
True</code></pre><p><code>math.isclose()</code> checks if the first argument is acceptably close to the second argument. But what exactly does that mean? The key idea is to examine the <strong>distance</strong> between the first argument and the second argument, which is equivalent to the absolute value of the difference of the values:</p><pre><code>&gt;&gt;&gt; a = 0.1 + 0.2
&gt;&gt;&gt; b = 0.3
&gt;&gt;&gt; abs(a - b)
5.551115123125783e-17</code></pre><p>If <code>abs(a - b)</code> is smaller than some percentage of the larger of <code>a</code> or <code>b</code>, then <code>a</code> is considered sufficiently close to <code>b</code> to be &#34;equal&#34; to <code>b</code>. This percentage is called the <strong>relative tolerance.</strong> You can specify the relative tolerance with the <code>rel_tol</code> keyword argument of <code>math.isclose()</code> which defaults to <code>1e-9</code>. In other words, if <code>abs(a - b)</code> is less than <code>1e-9 * max(abs(a), abs(b))</code>, then <code>a</code> and <code>b</code> are considered &#34;close&#34; to each other. This guarantees that <code>a</code> and <code>b</code> are equal to about nine decimal places.</p><p>You can change the relative tolerance if you need to:</p><pre><code>&gt;&gt;&gt; math.isclose(0.1 + 0.2, 0.3, rel_tol=1e-20)
False</code></pre><p>Of course, the relative tolerance depends on constraints set by the problem you&#39;re solving. For most everyday applications, however, the default relative tolerance should suffice.</p><p>There&#39;s a problem if one of <code>a</code> or <code>b</code> is zero and <code>rel_tol</code> is less than one, however. In that case, no matter how close the nonzero value is to zero, the relative tolerance guarantees that the check for closeness will always fail. In this case, using an absolute tolerance works as a fallback:</p><pre><code>&gt;&gt;&gt; # Relative check fails!
&gt;&gt;&gt; # ---------------vvvv  Relative tolerance
&gt;&gt;&gt; # ----------------------vvvvv  max(0, 1e-10)
&gt;&gt;&gt; abs(0 - 1e-10) &lt; 1e-9 * 1e-10
False

&gt;&gt;&gt; # Absolute check works!
&gt;&gt;&gt; # ---------------vvvv  Absolute tolerance
&gt;&gt;&gt; abs(0 - 1e-10) &lt; 1e-9
True</code></pre><p><code>math.isclose()</code> will do this check for you automatically. The <code>abs_tol</code> keyword argument determines the absolute tolerance. However, <code>abs_tol</code> defaults to <code>0.0</code>So you&#39;ll need to set this manually if you need to check how close a value is to zero.</p><p>All in all, <code>math.isclose()</code> returns the result of the following comparison, which combines the relative and absolute tests into a single expression:</p><pre><code>abs(a - b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code></pre><p><code>math.isclose()</code> was introduced in <a href="https://peps.python.org/pep-0485/">PEP 485</a> and has been available since Python 3.5.</p><h2 id="when-should-you-use-mathisclose">When Should You Use <code>math.isclose()</code>?</h2><p>In general, you should use <code>math.isclose()</code> whenever you need to compare floating-point values. Replace <code>==</code> with <code>math.isclose()</code>:</p><pre><code>&gt;&gt;&gt; # Don&#39;t do this:
&gt;&gt;&gt; 0.1 + 0.2 == 0.3
False

&gt;&gt;&gt; # Do this instead:
&gt;&gt;&gt; math.isclose(0.1 + 0.2, 0.3)
True</code></pre><p>You also need to be careful with <code>&gt;=</code> and <code>&lt;=</code> comparisons. Handle the equality separately using <code>math.isclose()</code> and then check the strict comparison:</p><pre><code>&gt;&gt;&gt; a, b, c = 0.1, 0.2, 0.3

&gt;&gt;&gt; # Don&#39;t do this:
&gt;&gt;&gt; a + b &lt;= c
False

&gt;&gt;&gt; # Do this instead:
&gt;&gt;&gt; math.isclose(a + b, c) or (a + b &lt; c)
True</code></pre><p>Various alternatives to <code>math.isclose()</code> exist. If you use NumPy, you can leverage <code><a href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html">numpy.allclose()</a></code> and <code><a href="https://numpy.org/doc/stable/reference/generated/numpy.isclose.html">numpy.isclose()</a></code>:</p><pre><code>&gt;&gt;&gt; import numpy as np

&gt;&gt;&gt; # Use numpy.allclose() to check if two arrays are equal
&gt;&gt;&gt; # to each other within a tolerance.
&gt;&gt;&gt; np.allclose([1e10, 1e-7], [1.00001e10, 1e-8])
False

&gt;&gt;&gt; np.allclose([1e10, 1e-8], [1.00001e10, 1e-9])
True

&gt;&gt;&gt; # Use numpy.isclose() to check if the elements of two arrays
&gt;&gt;&gt; # are equal to each other within a tolerance
&gt;&gt;&gt; np.isclose([1e10, 1e-7], [1.00001e10, 1e-8])
array([ True, False])

&gt;&gt;&gt; np.isclose([1e10, 1e-8], [1.00001e10, 1e-9])
array([ True, True])
</code></pre><p>Keep in mind that the default relative and absolute tolerances are not the same as <code>math.isclose()</code>. The default relative tolerance for both <code>numpy.allclose()</code> and <code>numpy.isclose()</code> is <code>1e-05</code> and the default absolute tolerance for both is <code>1e-08</code>.</p><p><code>math.isclose()</code> is especially useful for unit tests, although there are some alternatives. Python&#39;s built-in <code>unittest</code> module has a <code><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual">unittest.TestCase.assertAlmostEqual()</a></code> method. However, that method only uses an absolute difference test. It&#39;s also an assertion, meaning that failures raise an <code>AssertionError</code>, making it unsuitable for comparisons in your business logic.</p><p>A great alternative to <code>math.isclose()</code> for unit testing is the <code><a href="https://docs.pytest.org/en/latest/reference/reference.html?highlight=approx#pytest-approx">pytest.approx()</a></code> function from the <a href="https://docs.pytest.org/en/7.1.x/"><code>pytest</code> package</a>. Unlike <code>math.isclose()</code>, <code>pytest.approx()</code> only takes one argument — namely, the value you expect:</p><pre><code>&gt;&gt;&gt; import pytest
&gt;&gt;&gt; 0.1 + 0.2 == pytest.approx(0.3)
True</code></pre><p><code>pytest.approx()</code> has <code>rel_tol</code> and <code>abs_tol</code> keyword arguments for setting the relative and absolute tolerances. The default values are different from <code>math.isclose()</code>, however. <code>rel_tol</code> has a default value of <code>1e-6</code> and <code>abs_tol</code> has a default value of <code>1e-12</code>.</p><p>If the argument passed to <code>pytest.approx()</code> is array-like, meaning it&#39;s a Python iterable like a list or a tuple, or even a NumPy array, then <code>pytest.approx()</code> behaves similar to <code>numpy.allclose()</code> and returns whether or not the two arrays are equal within the tolerances:</p><pre><code>&gt;&gt;&gt; import numpy as np                                                          
&gt;&gt;&gt; np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == pytest.approx(np.array([0.3, 0.6])) 
True</code></pre><p><code>pytest.approx()</code> will even work with dictionary values:</p><pre><code>&gt;&gt;&gt; {&#39;a&#39;: 0.1 + 0.2, &#39;b&#39;: 0.2 + 0.4} == pytest.approx({&#39;a&#39;: 0.3, &#39;b&#39;: 0.6})
True</code></pre><p>Floating-point numbers are great for working with numbers whenever absolute precision isn&#39;t needed. They are fast and memory efficient. But if you do need precision, then there are some alternatives to floats that you should consider.</p><h2 id="floating-point-alternatives-that-are-precise">Floating-Point Alternatives That Are Precise</h2><p>There are two built-in numeric types in Python that offer full precision for situations where floats are inadequate: <code>Decimal</code> and <code>Fraction</code>.</p><h3 id="the-decimal-type">The <code>Decimal</code> Type</h3><p>The <code><a href="https://docs.python.org/3/library/decimal.html#decimal-objects">Decimal</a></code><a href="https://docs.python.org/3/library/decimal.html#decimal-objects"> type</a> can store decimal values exactly with as much precision as you need. By default, <code>Decimal</code> preserves 28 significant figures, but you can change this to whatever you need to suit the specific problem you&#39;re solving:</p><pre><code>&gt;&gt;&gt; # Import the Decimal type from the decimal module
&gt;&gt;&gt; from decimal import Decimal

&gt;&gt;&gt; # Values are represented exactly so no rounding error occurs
&gt;&gt;&gt; Decimal(&#34;0.1&#34;) + Decimal(&#34;0.2&#34;) == Decimal(&#34;0.3&#34;)
True

&gt;&gt;&gt; # By default 28 significant figures are preserved
&gt;&gt;&gt; Decimal(1) / Decimal(7)
Decimal(&#39;0.1428571428571428571428571429&#39;)

&gt;&gt;&gt; # You can change the significant figures if needed
&gt;&gt;&gt; from decimal import getcontext
&gt;&gt;&gt; getcontext().prec = 6  # Use 6 significant figures
&gt;&gt;&gt; Decimal(1) / Decimal(7)
Decimal(&#39;0.142857&#39;)</code></pre><p>You can read more about the <code>Decimal</code> type in the <a href="https://docs.python.org/3/library/decimal.html">Python docs</a>.</p><h3 id="the-fraction-type">The <code>Fraction</code> Type</h3><p>Another alternative to floating-point numbers is the <a href="https://docs.python.org/3/library/fractions.html#fractions.Fraction"><code>Fraction</code> type</a>. <code>Fraction</code> can store rational numbers exactly and overcomes representation error issues encountered by floating-point numbers:</p><pre><code>&gt;&gt;&gt; # import the Fraction type from the fractions module
&gt;&gt;&gt; from fractions import Fraction

&gt;&gt;&gt; # Instantiate a Fraction with a numerator and denominator
&gt;&gt;&gt; Fraction(1, 10)
Fraction(1, 10)

&gt;&gt;&gt; # Values are represented exactly so no rounding error occurs
&gt;&gt;&gt; Fraction(1, 10) + Fraction(2, 10) == Fraction(3, 10)
True</code></pre><p>Both <code>Fraction</code> and <code>Decimal</code> offer numerous benefits over standard floating-point values. However, these benefits come at a price: reduced speed and higher memory consumption. If you don&#39;t need absolute precision, you&#39;re better off sticking with floats. But for things like financial and mission-critical applications, the tradeoffs incurred by <code>Fraction</code> and <code>Decimal</code> may be worthwhile.</p><h2 id="conclusion">Conclusion</h2><p>Floating-point values are both a blessing and a curse. They offer fast arithmetic operations and efficient memory use at the cost of inaccurate representation. In this article, you learned:</p><ul><li>Why floating-point numbers are imprecise</li><li>Why floating-point representation error is common</li><li>How to correctly compare floating-point values in Python</li><li>How to  represent numbers precisely using Python&#39;s <code>Fraction</code> and <code>Decimal</code> types</li></ul><p>If you learned something new, then there might be even more that you don&#39;t know about numbers in Python. For example, did you know the <code>int</code> type isn&#39;t the only integer type in Python? Find out what the other integer type is and other little-known facts about numbers in my article <a href="https://davidamos.dev/three-things-you-might-not-know-about-numbers-in-python/">3 Things You Might Not Know About Numbers in Python</a>.</p><figure><a href="https://davidamos.dev/three-things-you-might-not-know-about-numbers-in-python/"><div><p>3 Things You Might Not Know About Numbers in Python</p><p>If you’ve written anything in Python, you’ve probably used a number in one of your programs. But there’s more to numbers than just their raw values.</p><p><img src="https://davidamos.dev/favicon.png" alt=""/><span>David Amos</span></p></div><p><img src="https://images.unsplash.com/photo-1467663802424-21ff675548c4?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDJ8fG51bWJlciUyMGZyYWN0YXxlbnwwfHx8fDE2NDEyOTQ0Njc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt=""/></p></a></figure><h2 id="additional-resources">Additional Resources</h2><ul><li><a href="https://docs.python.org/3/tutorial/floatingpoint.html">Floating-Point Arithmetic: Issues and Limitations</a></li><li><a href="https://floating-point-gui.de/">The Floating-Point Guide</a></li><li><a href="https://www.lahey.com/float.htm">The Perils of Floating Point</a></li><li><a href="https://0.30000000000000004.com/">Floating-Point Math</a></li><li><a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></li><li><a href="https://realpython.com/python-rounding/">How to Round Numbers in Python</a></li></ul><p><em>Thanks to Brian Okken for helping catch an issue with one of the <code>pytest.approx()</code> examples.</em></p> <hr/><p><em>Want to take your Python skills to the next level? I offer private one-on-one coaching for Python programming and technical writing. <a href="https://davidamos.dev/coaching">Click here</a> to learn more.</em></p>
</section></div>
  </body>
</html>
