<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/2021/12/01/realtime-row-level-security-in-postgresql">Original</a>
    <h1>Realtime Postgres Row Level Security</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p>Realtime is a server that listens to changes in your PostgreSQL database and broadcasts the changes to clients through a websocket connection.</p><p>Today, we&#39;re announcing security improvements to Realtime, where database changes will be broadcast to authenticated users, respecting the same PostgreSQL policies that you use for Row Level Security.</p><h2 id="demo">Demo</h2><iframe width="640" height="385" src="https://www.youtube-nocookie.com/embed/zHvatf2wySI" frameborder="1" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h2 id="overview">Overview</h2><p>Since the first commit of Realtime server back in <a href="https://github.com/supabase/realtime/commit/175f649784147af80acfc9ff5be9d160285c76ea">September 2019</a>,
we&#39;ve worked hard to improve its usability and scalability. </p><p>Until now, Realtime did not adhere to RLS policies and instead broadcast all database changes to all clients.
The unsafe nature of this behavior is the reason why Realtime has been an opt-in feature, and a key reason why we are still in Beta.</p><p>As more developers rely on Realtime to receive and send database changes in their apps and services,
security has become a primary concern for us and others in the community who wish to build secure systems with Realtime.</p><p>Supabase projects have supported Row Level Security (RLS) for API authorization since our <a href="https://supabase.io/blog/2020/08/05/supabase-auth">Auth launch</a>.
In that time, it has quickly become the recommended way to implement authorization.</p><p>As we were evaluating possible solutions to improve Realtime security, we looked to our Auth implementation as inspiration for a cohesive security system.</p><p>Today, we&#39;re updating Realtime to respect PostgreSQL RLS policies, so you can define your security rules once and have them automatically apply everywhere!</p><p>Before diving deeper into our Realtime RLS implementation, let&#39;s briefly cover how RLS works in PostgreSQL.</p><h2 id="row-level-security-primer">Row Level Security Primer</h2><p>When you need to control access to individual rows of data, PostgreSQL has you covered with <a href="https://www.postgresql.org/docs/current/ddl-rowsecurity.html">Row Level Security (RLS) policies</a>.
An RLS policy is a snippet of SQL filtering which users have the authority to create/read/update/delete rows in a table.</p><p>For example, the following policy would allow users to select their own rows in a todos table:</p><pre><div><pre><code><span>create</span><span> policy todo_select_policy 
</span><span>    </span><span>on</span><span> todos </span><span>for</span><span> </span><span>select</span><span> 
</span><span>    </span><span>using</span><span> ( auth.uid() </span><span>=</span><span> user_id );
</span>
</code></pre></div></pre><p>which is equivalent to adding</p><pre><div><pre><code><span>select</span><span> </span><span>*</span><span>
</span><span></span><span>from</span><span> todos
</span><span></span><span>where</span><span> auth.uid() </span><span>=</span><span> todos.user_id; </span><span>-- Policy is implicitly added.</span><span>
</span>
</code></pre></div></pre><p>to queries.</p><p>Check out the <a href="https://supabase.com/docs/guides/auth/row-level-security">Row Level Security guide</a> for more info on how to use RLS with your project.</p><h2 id="realtime-design">Realtime Design</h2><p>Our Realtime server receives and decodes binary changes from PostgreSQL logical replication, converts those changes to JSON, and broadcasts them to all connected clients.</p><h3 id="challenge-for-rls">Challenge for RLS</h3><p>The challenge, when applying row level security to the replication stream is that the visibility of a row may be different for each user subscribed to a database table.</p><p>We recognized that to fully secure Realtime in accordance with row level security, a row&#39;s visibility must be checked separately for each user on every change.
However, this quickly becomes a performance bottleneck when the number of changes, or number of subscribers, is large.</p><p>Since we can&#39;t control the number of subscribers or the number of changed records, we instead focused on making the security check for each user on every change as fast as possible.</p><h3 id="implementation-overview">Implementation Overview</h3><p>With these challenges in mind, we upstreamed the security responsibility to the database. Write Ahead Log Realtime Unified Security (WALRUS) exposes a PostgreSQL
function that Realtime server invokes with database changes.</p><h3 id="walrus-implementation">WALRUS Implementation</h3><p><a href="https://github.com/supabase/walrus">WALRUS</a> inspects each record in the replication change to:</p><ul><li>Identify the source table (e.g. <code>public.notes</code>).</li><li>Identify the change&#39;s action (INSERT/UPDATE/DELETE/TRUNCATE*).</li><li>Query the <code>subscription</code> table to determine the connected users who are actively subscribed to the source table. The <code>subscription</code> table is kept up to date by the Realtime server and tracks all connected users and the tables they are currently subscribed to.</li><li>For each subscriber:<ul><li>Assume the identity of the subscriber.</li><li>Query the source table to see if the record is visible to that subscriber.</li></ul></li><li>Report the list of subscribers who are authorized to view the record back to Realtime server.</li></ul><p><small>*Realtime server does not broadcast TRUNCATE changes</small></p><p><strong>Efficiently Query to Check Access</strong></p><p>To maximize throughput, the query used to evaluate if a row is visible to a subscriber always queries using the tables primary key.</p><p>For example:</p><pre><div><pre><code><span>select</span><span> </span><span>exists</span><span>(</span><span>select</span><span> </span><span>1</span><span> </span><span>from</span><span> some_table </span><span>where</span><span> id </span><span>=</span><span> </span><span>806</span><span>);
</span>
</code></pre></div></pre><p>When more than one subscriber exists, the query is wrapped in a <a href="https://www.postgresql.org/docs/13/sql-prepare.html">prepared statement</a> to remove the cost of the PostgreSQL
query planner on subsequent calls. The query planner time is frequently 2-3x execution time for simple queries, so this immediately multiplies throughput in the most common cases!</p><pre><div><pre><code><span>&#34;Planning Time: 0.099 ms&#34;
</span>&#34;Execution Time: 0.051 ms&#34;

</code></pre></div></pre><p><strong>Colocation</strong></p><p>Colocating the security engine with subscriber data inside PostgreSQL  allows us to avoid significant overhead when applying RLS policies.
Namely, network round-trip latency and I/O bottlenecks are removed while connection overhead is reduced relative to testing each record&#39;s visibility by polling the database from a separate process.
Instead, the SQL function only consumes a single connection and performs no network I/O.</p><h3 id="performance">Performance</h3><p>The throughput performance of the database server is best measured in terms of record processing time. As the number of subscribers to a table grows, the time required to process each record,
and the resultant processing time also grows.</p><p><img src="https://supabase.com/images/blog/launch-week-three/realtime-row-level-security-in-postgresql/supabase-realtime-processing-per-subscription.png" alt="supabase-realtime-processing-per-subscription"/></p><h2 id="best-practices-for-performance">Best Practices for Performance</h2><p>To get the most out of Realtime row level security, follow these guidelines:</p><h3 id="disable-for-public-tables">Disable for public tables</h3><p>If your data is insensitive or publicly available, such as stock prices listed under NASDAQ, then don&#39;t enable row level security!</p><p>The fastest security policy is one that doesn&#39;t exist :)</p><h3 id="optimize-your-policies">Optimize your policies</h3><p>If you do need row level security, make sure that your policies are fast.</p><p>Remember that your policy is executed <em>each</em> time a query touches the table that the policy is applied to. If your policy is slow, all access to that table will be slow.
Avoid joins within RLS policies when you can, and make sure all filter conditions use an index.</p><p>Additionally, keep in mind that if you use joins within an RLS policy, any RLS policies on the tables you&#39;re joining to will also be executed in turn, adding to the overall overhead.</p><h3 id="small-primary-keys">Small primary keys</h3><p>Keep your primary keys small and efficient.</p><p>Use single column primary keys with a fixed field size (integer, uuid, etc.) over text or multi-column indexes.</p><h2 id="next-steps">Next Steps</h2><p>Realtime RLS is available today on all existing and new Supabase projects. To get started, upgrade your Supabase JavaScript client to version v1.23.0
and launch your new PostgreSQL database today: <a href="https://database.new">database.new</a></p><h2 id="credits">Credits</h2><p>Authored by:</p><ul><li><a href="https://github.com/olirice">Oliver Rice</a></li><li><a href="https://github.com/w3b6x9">Wen Bo Xie</a></li></ul></div></div></article></div>
  </body>
</html>
