<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ai.meta.com/blog/self-supervised-learning-the-dark-matter-of-intelligence/">Original</a>
    <h1>Self-supervised learning: The dark matter of intelligence (2021)</h1>
    
    <div id="readability-page-1" class="page"><div><p>In recent years, the AI field has made tremendous progress in developing AI systems that can learn from massive amounts of carefully labeled data. This paradigm of supervised learning has a proven track record for training specialist models that perform extremely well on the task they were trained to do. Unfortunately, there’s a limit to how far the field of AI can go with supervised learning alone. </p><p>Supervised learning is a bottleneck for building more intelligent generalist models that can do multiple tasks and acquire new skills without massive amounts of labeled data. Practically speaking, it’s impossible to label everything in the world. There are also some tasks for which there’s simply not enough labeled data, such as training translation systems for low-resource languages. If AI systems can glean a deeper, more nuanced understanding of reality beyond what’s specified in the training data set, they’ll be more useful and ultimately bring AI closer to human-level intelligence. </p><p>As babies, we learn how the world works largely by observation. We form generalized predictive models about objects in the world by learning concepts such as object permanence and gravity. Later in life, we observe the world, act on it, observe again, and build hypotheses to explain how our actions change our environment by trial and error. </p><p>A working hypothesis is that generalized knowledge about the world, or common sense, forms the bulk of biological intelligence in both humans and animals. This common sense ability is taken for granted in humans and animals, but has remained an open challenge in AI research since its inception. In a way, common sense is the dark matter of artificial intelligence. </p><p>Common sense helps people learn new skills without requiring massive amounts of teaching for every single task. For example, if we show just a few drawings of cows to small children, they’ll eventually be able to recognize any cow they see. By contrast, AI systems trained with supervised learning require many examples of cow images and might still fail to classify cows in unusual situations, such as lying on a beach. How is it that humans can learn to drive a car in about 20 hours of practice with very little supervision, while fully autonomous driving still eludes our best AI systems trained with thousands of hours of data from human drivers? The short answer is that humans rely on their previously acquired background knowledge of how the world works. </p><p>How do we get machines to do the same?</p><p><img src="https://scontent-iad3-1.xx.fbcdn.net/v/t39.2365-6/152694956_207655794383548_8489544025025665441_n.png?_nc_cat=102&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=pJx8xa60PiAAX9BY7fX&amp;_nc_ht=scontent-iad3-1.xx&amp;oh=00_AfAZTNWXVK5Wj4C3eg4BqbCMlF6xaH6upsSaLQ_Za9UznQ&amp;oe=6522F5B1" alt=""/></p><p>We believe that self-supervised learning (SSL) is one of the most promising ways to build such background knowledge and approximate a form of common sense in AI systems.</p><p>Self-supervised learning enables AI systems to learn from orders of magnitude more data, which is important to recognize and understand patterns of more subtle, less common representations of the world. Self-supervised learning has long had great success in advancing the field of natural language processing (NLP), including the <a href="https://ronan.collobert.com/pub/matos/2008_nlp_icml.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>Collobert-Weston 2008 model</span></a>, <a href="https://arxiv.org/pdf/1301.3781.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>Word2Vec</span></a>, <a href="https://nlp.stanford.edu/pubs/glove.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>GloVE</span></a>, <a href="https://arxiv.org/pdf/1607.01759.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>fastText</span></a>, and, more recently, <a href="https://arxiv.org/pdf/1810.04805.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>BERT</span></a>, <a href="https://arxiv.org/pdf/1907.11692.pdf" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>RoBERTa</span></a>, <a href="https://ai.facebook.com/blog/-xlm-r-state-of-the-art-cross-lingual-understanding-through-self-supervision/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>XLM-R</span></a>, and others. Systems pretrained this way yield considerably higher performance than when solely trained in a supervised manner. </p><p> Our latest research project <a href="https://ai.facebook.com/blog/seer-the-start-of-a-more-powerful-flexible-and-accessible-era-for-computer-vision" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>SEER</span></a> leverages SwAV and other methods to pretrain a large network on a billion random unlabeled images, yielding top accuracy on a diverse set of vision tasks. This progress demonstrates that <a href="https://arxiv.org/pdf/2103.01988.pdf?fbclid=IwAR2pqhYda6MV9r2b3Afx_0eKUiZhX-Es6Pa_FbLOqH8fglQzO2kY3yKxZE8" target="_blank" data-lnfb-mode="ie"><u>self-supervised learning can excel at CV tasks in complex, real-world settings as well</u></a>. </p><p>Today, we’re sharing details on why self-supervised learning may be helpful in unlocking the dark matter of intelligence — and the next frontier of AI. We’re also highlighting what we believe are some of the most promising new directions of energy-based models for prediction in the presence of uncertainty, joint embedding methods and latent-variable architectures for self-supervised learning and reasoning in AI systems. </p><p>Self-supervised learning obtains supervisory signals from the data itself, often leveraging the underlying structure in the data. The general technique of self-supervised learning is to predict any unobserved or hidden part (or property) of the input from any observed or unhidden part of the input. For example, as is common in NLP, we can hide part of a sentence and predict the hidden words from the remaining words. We can also predict past or future frames in a video (hidden data) from current ones (observed data). Since self-supervised learning uses the structure of the data itself, it can make use of a variety of supervisory signals across co-occurring modalities (e.g., video and audio) and across large data sets — all without relying on labels.</p><p><img src="https://scontent-iad3-1.xx.fbcdn.net/v/t39.2365-6/148954125_461761118405979_2035914075893596810_n.png?_nc_cat=107&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=bY12gpB3nI4AX8DtBOD&amp;_nc_ht=scontent-iad3-1.xx&amp;oh=00_AfCvRT7xySz4tk0iu36rWH0epTNzAdVR9yMz0d_2c1Zpkw&amp;oe=65231399" alt=""/></p><div><p>In self-supervised learning, the system is trained to predict hidden parts of the input (in gray) from visible parts of the input (in green).</p></div><p>As a result of the supervisory signals that inform self-supervised learning, the term “self-supervised learning” is more accepted than the previously used term “unsupervised learning.” Unsupervised learning is an ill-defined and misleading term that suggests that the learning uses no supervision at all. In fact, self-supervised learning is not unsupervised, as it uses far more feedback signals than standard supervised and reinforcement learning methods do. </p><p>Self-supervised learning has had a particularly profound impact on NLP, allowing us to train models such as BERT, RoBERTa, XLM-R, and others on large unlabeled text data sets and then use these models for downstream tasks. These models are pretrained in a self-supervised phase and then fine-tuned for a particular task, such as classifying the topic of a text. In the self-supervised pretraining phase, the system is shown a short text (typically 1,000 words) in which some of the words have been masked or replaced. The system is trained to predict the words that were masked or replaced. In doing so, the system learns to represent the meaning of the text so that it can do a good job at filling in “correct” words, or those that make sense in the context.</p><p>Predicting missing parts of the input is one of the more standard tasks for SSL pretraining. To complete a sentence such as “The (blank) chases the (blank) in the savanna,” the system must learn that lions or cheetahs can chase antelope or wildebeests, but that cats chase mice in the kitchen, not the savanna. As a consequence of the training, the system learns to represent the meaning of words, the syntactic role of words, and the meaning of entire texts. </p><p> These techniques, however, can’t be easily extended to new domains, such as CV. Despite promising early results, SSL has not yet brought about the same improvements in computer vision that we have seen in NLP (though this will change). </p><p>The main reason is that it is considerably more difficult to represent uncertainty in the prediction for images than it is for words. When the missing word cannot be predicted exactly (is it “lion” or “cheetah”?), the system can associate a score or a probability to all possible words in the vocabulary: high score for “lion,” “cheetah,” and a few other predators, and low scores for all other words in the vocabulary. </p><p>Training models at this scale also required a model architecture that was efficient in terms of both runtime and memory, without compromising on accuracy. Fortunately, a recent innovation by FAIR in the realm of architecture design led to a new model family called <a href="https://arxiv.org/abs/2003.13678" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>RegNets</span></a> that perfectly fit these needs. RegNet models are ConvNets capable of scaling to billions or potentially even trillions of parameters, and can be optimized to fit different runtime and memory limitations.</p><p> But we do not know how to efficiently represent uncertainty when we predict missing frames in a video or missing patches in an image. We cannot list all possible video frames and associate a score to each of them, because there is an infinite number of them. While this problem has limited the performance improvement from SSL in vision, new techniques SSL techniques such as SwAV are starting to beat accuracy records in vision tasks. This is best demonstrated by the SEER system that uses a large convolutional network trained with billions of examples. </p><p><img src="https://scontent-iad3-1.xx.fbcdn.net/v/t39.2365-6/148662482_469317657771087_6509708649537324681_n.png?_nc_cat=110&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=pdmXmz1tvqsAX8-mrcg&amp;_nc_ht=scontent-iad3-1.xx&amp;oh=00_AfDU_eIcp2ETI93URpc9hQ3yjqUYrwDvJSPi3NSeprSPgA&amp;oe=65230C49" alt=""/></p><p> To better understand this challenge, we first need to understand the prediction uncertainty and the way it’s modeled in NLP compared with CV. In NLP, predicting the missing words involves computing a prediction score for every possible word in the vocabulary. While the vocabulary itself is large and predicting a missing word involves some uncertainty, it’s possible to produce a list of all the possible words in the vocabulary together with a probability estimate of the words’ appearance at that location. Typical machine learning systems do so by treating the prediction problem as a classification problem and computing scores for each outcome using a giant so-called softmax layer, which transforms raw scores into a probability distribution over words. With this technique, the uncertainty of the prediction is represented by a probability distribution over all possible outcomes, provided that there is a finite number of possible outcomes. </p><p>In CV, on the other hand, the analogous task of predicting “missing” frames in a video, missing patches in an image, or missing segment in a speech signal involves a prediction of high-dimensional continuous objects rather than discrete outcomes. There are an infinite number of possible video frames that can plausibly follow a given video clip. It is not possible to explicitly represent all the possible video frames and associate a prediction score to them. In fact, we may never have techniques to represent suitable probability distributions over high-dimensional continuous spaces, such as the set of all possible video frames. </p><p>This seems like an intractable problem.</p><p>There is a way to think about SSL within the unified framework of an energy-based model (EBM). An EBM is a trainable system that, given two inputs, x and y, tells us how incompatible they are with each other. For example, x could be a short video clip, and y another proposed video clip. The machine would tell us to what extent y is a good continuation for x. To indicate the incompatibility between x and y, the machine produces a single number, called an energy. If the energy is low, x and y are deemed compatible; if it is high, they are deemed incompatible. </p><p><img src="https://scontent-iad3-2.xx.fbcdn.net/v/t39.2365-6/157272588_1389905731371138_8776386318723848066_n.png?_nc_cat=103&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=w6Ar2la-WJEAX_5-ukY&amp;_nc_ht=scontent-iad3-2.xx&amp;oh=00_AfCVyXp7r0vHoJYc12MOFczcMNixZlndZysdJt75B3Mf7g&amp;oe=6523116E" alt=""/></p><div><p>An energy-based model (EBM) measures the compatibility between an observation x and a proposed prediction y. If x and y are compatible, the energy is a small number; if they are incompatible, the energy is a larger number.</p></div><p>Training an EBM consists of two parts: (1) showing it examples of x and y that are compatible and training it to produce a low energy, and (2) finding a way to ensure that for a particular x, the y values that are incompatible with x produce a higher energy than the y values that are compatible with x. Part one is simple, but part two is where the difficulty lies. </p><p>For image recognition, our model takes two images, x and y, as inputs. If x and y are slightly distorted versions of the same image, the model is trained to produce a low energy on its output. For example, x could be a photo of a car, and y a photo of the same car that was taken from a slightly different location at a different time of day, so that the car in y is shifted, rotated, larger, smaller, and displaying slightly different colors and shadows than the car in x. </p><h3>Joint embedding, Siamese networks</h3><p> A particular well-suited deep learning architecture to do so is the so-called Siamese networks or joint embedding architecture. The idea goes back to papers from Geoff Hinton’s lab and Yann LeCun’s group in the early 1990s (<a href="https://www.nature.com/articles/355161a0" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>here</span></a> and <a href="https://www.worldscientific.com/doi/abs/10.1142/S0218001493000339" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>here</span></a>) and mid-2000s (<a href="https://proceedings.neurips.cc/paper/2004/hash/42fe880812925e520249e808937738d2-Abstract.html" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>here</span></a>, <a href="https://ieeexplore.ieee.org/abstract/document/1467314" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>here</span></a>, and <a href="https://ieeexplore.ieee.org/abstract/document/1640964" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>here</span></a>). It was relatively ignored for a long time but has enjoyed a revival since late 2019. A joint embedding architecture is composed of two identical (or almost identical) copies of the same network. One network is fed with x and the other with y. The networks produce output vectors called embeddings, which represent x and y. A third module, joining the networks at the head, computes the energy as the distance between the two embedding vectors. When the model is shown distorted versions of the same image, the parameters of the networks can easily be adjusted so that their outputs move closer together. This will ensure that the network will produce nearly identical representations (or embedding) of an object, regardless of the particular view of that object. </p><p><img src="https://scontent-iad3-2.xx.fbcdn.net/v/t39.2365-6/149794655_780907256142255_4794526832594825319_n.jpg?_nc_cat=105&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=VLf2jMXSsuQAX_pSWo8&amp;_nc_ht=scontent-iad3-2.xx&amp;oh=00_AfDa_rn_jf1urtL_ArVvZGAQaeohEfSZjqDo_24fWW-dLA&amp;oe=65230B35" alt=""/></p><div><p>Joint embedding architecture. The function C at the top produces a scalar energy that measures the distance between the representation vectors (embeddings) produced by two identical twin networks sharing the same parameters (w). When x and y are slightly different versions of the same image, the system is trained to produce a low energy, which forces the model to produce similar embedding vectors for the two images. The difficult part is to train the model so that it produces high energy (i.e., different embeddings) for images that are different.</p></div><p>The difficulty is to make sure that the networks produce high energy, i.e. different embedding vectors, when x and y are different images. Without a specific way to do so, the two networks could happily ignore their inputs and always produce identical output embeddings. This phenomenon is called a collapse. When a collapse occurs, the energy is not higher for nonmatching x and y than it is for matching x and y. </p><p>There are two categories of techniques to avoid collapse: contrastive methods and regularization methods.</p><h3>Contrastive energy-based SSL </h3><p>Contrastive methods are based on the simple idea of constructing pairs of x and y that are not compatible, and adjusting the parameters of the model so that the corresponding output energy is large. </p><p><img src="https://scontent-iad3-1.xx.fbcdn.net/v/t39.2365-6/127784209_262471582050413_7179678990272222350_n.gif?_nc_cat=104&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=60iCzPquolkAX93xU_j&amp;_nc_ht=scontent-iad3-1.xx&amp;oh=00_AfC2oG-qigxTVA48-d3frqrgbTa0-rLofuBNBrXmnp-Ndw&amp;oe=65230447" alt=""/></p><div><p>Training an EBM with a contrastive method consists in simultaneously pushing down on the energy of compatible (x,y) pairs from the training set, indicated by the blue dots, and pushing up on the energy of well chosen (x,y) pairs that are incompatible, symbolized by the green dots. In this simple example, x and y are both scalars, but in real situations, x and y could be an image or a video with millions of dimensions. Coming up with incompatible pairs that will shape the energy in suitable ways is challenging and expensive computationally. </p></div><p>The method used to train NLP systems by masking or substituting some input words belongs to the category of contrastive methods. But they don’t use the joint embedding architecture. Instead, they use a predictive architecture in which the model directly produces a prediction for y. One starts for a complete segment of text y, then corrupts it, e.g., by masking some words to produce the observation x. The corrupted input is fed to a large neural network that is trained to reproduce the original text y. An uncorrupted text will be reconstructed as itself (low reconstruction error), while a corrupted text will be reconstructed as an uncorrupted version of itself (large reconstruction error). If one interprets the reconstruction error as an energy, it will have the desired property: low energy for “clean” text and higher energy for “corrupted” text. </p><p>The general technique of training a model to restore a corrupted version of an input is called denoising auto-encoder. While early forms of this idea go back to the 1980s, it was <a href="https://dl.acm.org/doi/abs/10.1145/1390156.1390294" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>revived in 2008</span></a> by Pascal Vincent and colleagues at the University of Montréal, introduced in the context of NLP by <a href="https://www.jmlr.org/papers/v12/collobert11a.html" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>Collobert and Weston</span></a>, and popularized by the <a href="https://arxiv.org/abs/1810.04805" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>BERT paper</span></a> from our friends at Google.</p><p><img src="https://scontent-iad3-1.xx.fbcdn.net/v/t39.2365-6/155526762_897797787644739_8022451761586606565_n.png?_nc_cat=108&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=DKakaVTcPHgAX_Qsmu4&amp;_nc_ht=scontent-iad3-1.xx&amp;oh=00_AfCfbBqEM7MXIzwNixgm8KfcC6MFbEgdXocWwYdwwzOe1w&amp;oe=65232796" alt=""/></p><div><p>A masked language model, which is an instance of denoising auto-encoder, itself an instance of contrastive self-supervised learning. Variable y is a text segment; x is a version of the text in which some words have been masked. The network is trained to reconstruct the uncorrupted text.</p></div><p>As we pointed out earlier, a predictive architecture of this type can produce only a single prediction for a given input. Since the model must be able to predict multiple possible outcomes, the prediction is not a single set of words but a series of scores for every word in the vocabulary for each missing word location. </p><p>But we cannot use this trick for images because we cannot enumerate all possible images. Is there a solution to this problem? The short answer is no. There are interesting ideas in this direction, but they have not yet led to results that are as good as joint embedding architectures. One interesting avenue is latent-variable predictive architectures. </p><p><img src="https://scontent-iad3-2.xx.fbcdn.net/v/t39.2365-6/151779454_861787841053485_9032472471565149785_n.jpg?_nc_cat=106&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=75O6JveTH2cAX8WqI43&amp;_nc_ht=scontent-iad3-2.xx&amp;oh=00_AfAaOrT26bCFx5qtfKdqd3uez3r3MePPdPbXI5enNRZXYg&amp;oe=652314C3" alt=""/></p><div><p>A latent-variable predictive architecture. Given an observation x, the model must be able to produce a set of multiple compatible predictions symbolized by an S-shaped ribbon in the diagram. As the latent variable z varies within a set, symbolized by a gray square, the output varies over the set of plausible predictions. </p></div><p>Latent-variable predictive models contain an extra input variable (z). It is called latent because its value is never observed. With a properly trained model, as the latent variable varies over a given set, the output prediction varies over the set of plausible predictions compatible with the input x. </p><p>Latent-variable models can be trained with contrastive methods. A good example of this is a generative adversarial network (GAN). The critic (or discriminator) can be seen as computing an energy indicating whether the input y looks good. The generator network is trained to produce contrastive samples to which the critic is trained to associate high energy.</p><p>But contrastive methods have a major issue: They are very inefficient to train. In high-dimensional spaces such as images, there are many ways one image can be different from another. Finding a set of contrastive images that cover all the ways they can differ from a given image is a nearly impossible task. To paraphrase Leo Tolstoy’s Anna Karenina: “Happy families are all alike; every unhappy family is unhappy in its own way.” This applies to any family of high-dimensional objects, it seems. </p><p>What if it were possible to make sure the energy of incompatible pairs is higher than that of compatible pairs without explicitly pushing up on the energy of many incompatible pairs?</p><h3>Non-contrastive energy-based SSL</h3><p>Non-contrastive methods applied to joint embedding architectures is possibly the hottest topic in SSL for vision at the moment. The domain is still largely unexplored, but it seems very promising. </p><p>Non-contrastive methods for joint-embedding include <a href="https://openaccess.thecvf.com/content_ICCV_2019/html/Caron_Unsupervised_Pre-Training_of_Image_Features_on_Non-Curated_Data_ICCV_2019_paper.html" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>DeeperCluster</span></a>, <a href="https://arxiv.org/abs/1912.03330" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>ClusterFit</span></a>, <a href="https://arxiv.org/abs/2003.04297" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>MoCo-v2</span></a>, <a href="https://arxiv.org/abs/2006.09882" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>SwAV</span></a>, <a href="https://arxiv.org/abs/2011.10566" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>SimSiam</span></a>, Barlow Twins, <a href="https://arxiv.org/abs/2006.07733" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>BYOL</span></a> from DeepMind, and a few others. They use various tricks, such as computing virtual target embeddings for groups of similar images (DeeperCluster, SwAV, SimSiam) or making the two joint embedding architectures slightly different through the architecture or the parameter vector (BYOL, MoCo). Barlow Twins tries to minimize the redundancy between the individual components of the embedding vectors. </p><p>Perhaps a better alternative in the long run will be to devise non-contrastive methods with latent-variable predictive models. The main obstacle is that they require a way to minimize the capacity of the latent variable. The volume of the set over which the latent variable can vary limits the volume of outputs that take low energy. By minimizing this volume, one automatically shapes the energy in the right way. </p><p>A successful example of such a method is the <a href="https://arxiv.org/abs/1312.6114" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>Variational Auto-Encoder</span></a> (VAE), in which the latent variable is made “fuzzy”, which limits its capacity. But VAE have not yet been shown to produce good representations for downstream visual tasks. Another successful example is <a href="https://www.nature.com/articles/381607a0" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>sparse modeling</span></a>, but its use has been limited to simple architectures. No perfect recipe seems to exist to limit the capacity of latent variables. </p><p> The challenge of the next few years may be to devise non-contrastive methods for latent-variable energy-based model that successfully produce good representations of image, video, speech, and other signals and yield top performance in downstream supervised tasks without requiring large amounts of labeled data. </p><p>Most recently, we’ve <a href="https://ai.facebook.com/blog/seer-the-start-of-a-more-powerful-flexible-and-accessible-era-for-computer-vision" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>created and open sourced</span></a> a new billion-parameter self-supervised CV model called SEER that’s proven to work efficiently with complex, high-dimensional image data. It is based on the SwAV method applied to a convolutional network architecture (ConvNet) and can be trained from a vast number of random images without any metadata or annotations. The ConvNet is large enough to capture and learn every visual concept from this large and complex data. After pretraining on a billion random, unlabeled and uncurated public Instagram images, and supervised fine-tuning on ImageNet, <a href="https://arxiv.org/pdf/2103.01988.pdf?fbclid=IwAR2pqhYda6MV9r2b3Afx_0eKUiZhX-Es6Pa_FbLOqH8fglQzO2kY3yKxZE8" target="_blank" data-lnfb-mode="ie"><u>SEER outperformed the most advanced, state-of-the-art self-supervised systems, reaching 84.2 percent top-1 accuracy on ImageNet</u></a>. </p><p>These results show that we can bring the self-supervised learning paradigm shift to computer vision. </p><p>At Facebook, we’re not just advancing self-supervised learning techniques <a href="https://ai.facebook.com/blog/advances-in-content-understanding-self-supervision-to-protect-people/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>across many domains</span></a> through fundamental, <a href="https://ai.facebook.com/blog/advances-in-content-understanding-self-supervision-to-protect-people/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>open scientific research</span></a>, but we’re also applying this leading-edge work in production to quickly improve the accuracy of content understanding systems in our products that keep people safe on our platforms. </p><p> Self-supervision research, like our pretrained language model <a href="https://github.com/facebookresearch/XLM?fbclid=IwAR2Gqz_1SBcEXAVowtEOqRvN9Iveaci6Jwdvdy8yHDnlyjnfm91ZDREK6Rs" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank" data-lnfb-mode="ie"><span>XLM</span></a>, is accelerating important applications at Facebook today — including <a href="https://ai.facebook.com/blog/how-ai-is-getting-better-at-detecting-hate-speech/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>proactive detection of hate speech</span></a>. And we’ve deployed <a href="https://ai.facebook.com/blog/-xlm-r-state-of-the-art-cross-lingual-understanding-through-self-supervision/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>XLM-R</span></a>, a model that leverages our <a href="https://ai.facebook.com/blog/roberta-an-optimized-method-for-pretraining-self-supervised-nlp-systems/" data-ms="{&#34;creative&#34;:&#34;link&#34;,&#34;creative_detail&#34;:&#34;link&#34;,&#34;create_type&#34;:&#34;link&#34;,&#34;create_type_detail&#34;:&#34;link&#34;}" target="_blank"><span>RoBERTa</span></a> architecture, to improve our hate speech classifiers in multiple languages across Facebook and Instagram.This will enable hate speech detection even in languages for which there is very little training data. </p><p> We’re encouraged by the progress of self-supervision in recent years, though there’s still a long way to go until this method can help us uncover the dark matter of AI intelligence. Self-supervision is one step on the path to human-level intelligence, but there are surely many steps that lie behind this one. Long-term progress will be cumulative. That’s why we’re committed to working collaboratively with the broader AI community to achieve our goal of, one day, building machines with human-level intelligence. Our research has been made publicly available and published at top conferences. And we’ve organized workshops and released libraries to help accelerate the research in this area. </p></div></div>
  </body>
</html>
