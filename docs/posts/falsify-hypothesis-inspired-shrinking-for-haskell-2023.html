<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.well-typed.com/blog/2023/04/falsify/">Original</a>
    <h1>Falsify: Hypothesis-Inspired Shrinking for Haskell (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
          <p>Consider this <code>falsify</code> property test that tries to verify the (obviously false) property
that all elements of all lists of up to 10 binary digits are the same (we will explain the details below;
hopefully the intent is clear):</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>prop_list ::</span> <span>Property</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>prop_list <span>=</span> <span>do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    n  <span>&lt;-</span> gen <span>$</span> Gen.integral <span>$</span> Range.between (<span>0</span>, <span>10</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    xs <span>&lt;-</span> gen <span>$</span> replicateM n <span>$</span> Gen.int <span>$</span> Range.between (<span>0</span>, <span>1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    assert <span>$</span> P.pairwise P.eq <span>.$</span> (<span>&#34;xs&#34;</span>, xs)</span></code></pre></div>
<p>we might get a counter-example such as this:</p>
<pre><code>failed after 9 shrinks
(xs !! 0) /= (xs !! 1)
xs     : [0,1]
xs !! 0: 0
xs !! 1: 1</code></pre>
<p>More interesting than the counter-example itself is how <code>falsify</code> <em>arrived</em>
at that counter-example; if we look at the shrink history (<code>--falsify-verbose</code>),
we see that the list shrunk as follows:</p>
<pre><code>   [1,1,0,1,0,1]
~&gt; [1,1,0]       -- shrink the list length
~&gt; [0,1,0]       -- shrink an element of the list
~&gt; [0,1]         -- shrink the list length again</code></pre>
<p>The test runner is able to go back and forth between shrinking the length and the list, and
shrinking elements <em>in</em> the list. That is, we have integrated shrinking (like in
<code>hedgehog</code>: we do not specify a separate generator and shrinker), which is
<em>internal</em>: works across monadic bind. The Python
<a href="https://hypothesis.works/">Hypothesis</a> library showed the world how to achieve
this. In this blog post we will introduce <a href="http://hackage.haskell.org/package/falsify">falsify</a>, a new
library that provides property based testing in Haskell and has an approach to
shrinking that is inspired by <code>Hypothesis</code>. As we shall see, however, the details
are quite different.</p>
<!-- more -->
<h2 id="background">Background</h2>
<p>In this first section we will discuss some of the background behind <code>falsify</code>;
the next section will be a more tutorial-style introduction on how to use
it. This section is not meant to an exhaustive discussion of the theory behind
<code>falsify</code>, or how the theory differs from that of <code>Hypothesis</code>; both of those
topics will be covered in a paper, currently under review. However, a basic
understanding of these principles will help to use the library more effectively,
and so that will be our goal in this first section.</p>
<h3 id="unit-testing-versus-property-based-testing">Unit testing versus property based testing</h3>
<p>In unit testing (for example using <a href="http://hackage.haskell.org/package/tasty-hunit">tasty-hunit</a>), a test
for a function <code>f</code> might look something like this:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>test ::</span> <span>Assertion</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>test <span>=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    unless (f input <span>==</span> expected) <span>$</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      assertFailure <span>&#34;not equal&#34;</span></span></code></pre></div>
<p>That is, we apply <code>f</code> to specific <code>input</code>, and then verify that we get an
<code>expected</code> result. By contrast, in property based testing, we do not specify a
specific input, but instead <em>generate</em> a random input using some generator
<code>genInput</code>, and then verify that the input and the output are related by some
<em>property</em> <code>prop</code>:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>test_property ::</span> <span>Property</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>test_property <span>=</span> <span>do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    input <span>&lt;-</span> gen <span>$</span> genInput</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    unless (prop input (f input)) <span>$</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      testFailed <span>&#34;property not satisfied&#34;</span></span></code></pre></div>
<p>This blog post is not intended as an introduction to property-based testing;
merely observe that <em>generation</em> of input values is a critical ingredient in
property based testing. However, if you are not familiar with the topic, or not
yet convinced that you should be using it, I can highly recommend watching
<a href="https://www.youtube.com/watch?v=V8v-1PnFisU">Testing the Hard Stuff and Staying Sane</a>, and then reading
<a href="https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf">How to Specify It!: A Guide to Writing Properties of Pure
Functions</a>, both by the world’s foremost property-based
testing guru John Hughes.</p>
<h3 id="the-importance-of-shrinking">The importance of shrinking</h3>
<p>Suppose we want to test the (false) property that for all numbers <code>x</code> and <code>y</code>,
<code>x - y == y - x</code>:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>prop_shrinking ::</span> <span>Property</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>prop_shrinking <span>=</span> <span>do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    x <span>&lt;-</span> gen <span>$</span> Gen.int <span>$</span> Range.between (<span>0</span>, <span>99</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    y <span>&lt;-</span> gen <span>$</span> Gen.int <span>$</span> Range.between (<span>0</span>, <span>99</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    unless (x <span>-</span> y <span>==</span> y <span>-</span> x) <span>$</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      testFailed <span>&#34;property not satisfied&#34;</span></span></code></pre></div>
<p>Since the property is false, we will get a counter-example. Without shrinking,
one such a counter-example might be</p>
<pre><code>x = 38
y = 23</code></pre>
<p>However, although that is indeed a counter-example to the property, it’s not a
great counter-example. Why these specific numbers? Is there something special
about them? To quote John Hughes in <a href="https://link.springer.com/chapter/10.1007/978-3-319-30936-1_9">Experiences with QuickCheck: Testing the
Hard Stuff and Staying Sane</a>:</p>
<blockquote>
Random tests contain a great deal of junk—that is their purpose! Junk provokes
unexpected behaviour and tests scenarios that the developer would never think
of. But tests usually fail because of just a few features of the test case.
Debugging a test that is 90% irrelevant is a nightmare; presenting the
developer with a test where <em>every part is known to be relevant</em> to the failure,
simplifies the debugging task enormously.
</blockquote>
<p>(emphasis mine). For our example, the numbers 38 and 23 are not particularly
relevant to the failure; with shrinking, however, the counter-example we will
get is</p>
<pre><code>x = 0
y = 1</code></pre>
<p>Indeed, this is the <em>only</em> counter-example we will ever get: <code>0</code> is the smallest
number possible (“least amount of detail”), and the only thing that is relevant
about the second number is that it’s not equal to the first.</p>
<h3 id="parsing-versus-generation">Parsing versus generation</h3>
<p>Generation of inputs relies on pseudo-random number generators (PRNGs). The
typical interface to a PRNGs is something like this:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>nextSample ::</span> <span>PRNG</span> <span>-&gt;</span> (<span>Word</span>, <span>PRNG</span>)</span></code></pre></div>
<p>Given such an interface, we might define the type of generators as</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Gen</span> a <span>=</span> <span>Gen</span> (<span>PRNG</span> <span>-&gt;</span> (a, <span>PRNG</span>))</span></code></pre></div>
<p>This covers generation, but not shrinking. The traditional approach in
<a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> to shrinking is to pair a generator with a
shrinking function, a function of type</p>

<p>This works, but it’s not without its problems; see my blog post <a href="https://www.well-typed.com/blog/2019/05/integrated-shrinking/">Integrated
versus Manual Shrinking</a> for an in-depth discussion.
The key insight of the <code>Hypothesis</code> library is that instead of shrinking generated
<em>values</em>, we instead shrink the <em>samples produced by the PRNG</em>. Suppose we
unfold a PRNG to a stream of random samples:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>unfoldLinear ::</span> <span>PRNG</span> <span>-&gt;</span> [<span>Word</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>unfoldLinear prng <span>=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> (s, prng&#39;) <span>=</span> next prng</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>in</span> s <span>:</span> unfoldLinear prng&#39;</span></code></pre></div>
<p>Then we can shift our perspective: rather than thinking of <em>generating</em> random
values from a PRNG we instead <em>parse</em> this stream of random samples:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Parser</span> a <span>=</span> <span>Parser</span> ([<span>Word</span>] <span>-&gt;</span> (a, [<span>Word</span>])</span></code></pre></div>
<p>Instead of having a separate shrinking function, we now simply shrink the list
of samples, and then re-run the parser. This is the <code>Hypothesis</code> approach in a
nutshell; parsers of course need to ensure that the produced value shrinks as
the samples are shrunk. For example, here is a very simple (proof of concept)
generator for <code>Bool</code>:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>parseBool ::</span> <span>Parser</span> <span>Bool</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>parseBool <span>=</span> <span>Parser</span> <span>$</span> \(s<span>:</span>ss) <span>-&gt;</span> (</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span>if</span> s <span>&gt;=</span> <span>maxBound</span> <span>`div`</span> <span>2</span> <span>then</span> <span>True</span> <span>else</span> <span>False</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  , ss</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
<p>Assuming that the sample is chosen uniformly in the full <code>Word</code> range, this
parser will choose uniformly between <code>True</code> and <code>False</code>; and as the sample
is shrunk towards zero, the boolean will shrink towards <code>False</code>.</p>
<h3 id="streams-versus-trees">Streams versus trees</h3>
<p>If you look at the <a href="https://hackage.haskell.org/package/QuickCheck/docs/src/Test.QuickCheck.Gen.html#Gen">definition of <code>Gen</code> in <code>QuickCheck</code></a>,
you will see it’s actually different to the definition we showed above:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Gen</span> a <span>=</span> <span>Gen</span> (<span>PRNG</span> <span>-&gt;</span> a)</span></code></pre></div>
<p>Like our definition above, this generator takes a PRNG as input, <em>but it does
not return an updated PRNG</em>. This might seem confusing: suppose we are
generating two numbers, as in our example above; how do we ensure those two
numbers are generated from different PRNGs?</p>
<p>To solve this problem, we will need a PRNG that in addition to <code>next</code>, also
provides a way to <em>split</em> the PRNG into two new PRNGs:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>next  ::</span> <span>PRNG</span> <span>-&gt;</span> (<span>Word</span>, <span>PRNG</span>)  <span>-- as before</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>split ::</span> <span>PRNG</span> <span>-&gt;</span> (<span>PRNG</span>, <span>PRNG</span>)  <span>-- new</span></span></code></pre></div>
<p>Then to run two generators, we first split the PRNG:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>both ::</span> <span>QcGen</span> a <span>-&gt;</span> <span>QcGen</span> b <span>-&gt;</span> <span>QcGen</span> (a, b)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>both (<span>QcGen</span> g1) (<span>QcGen</span> g2) <span>=</span> <span>QcGen</span> <span>$</span> \prng <span>-&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> (l, r) <span>=</span> split prng</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span>in</span> (g1 l, g2 r)</span></code></pre></div>
<p>The advantage of this approach is <em>laziness</em>: we can produce the second value of
type <code>b</code> without generating the value of type <code>a</code> first. Indeed, if we never
demand the value of <code>a</code>, we will not generate it at all! This is of critical
importance if we have generators for infinite values; for example, it is what
enables us to <a href="#generating-functions">Generate Functions</a>.</p>
<h3 id="the-falsify-definition-of-gen">The <code>falsify</code> definition of <code>Gen</code></h3>
<p>If we apply the insight from <code>Hypothesis</code> (that is, parse samples rather than
generate using PRNGs) to this new setting where <em>splitting</em> PRNGs is a
fundamental operation, we arrive at the definition of <code>Gen</code> in <code>falsify</code>. First,
unfolding a PRNG does not give us an infinite <em>stream</em> of samples, but rather an
infinite <em>tree</em> of samples:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>STree</span> <span>=</span> <span>STree</span> <span>Word</span> <span>STree</span> <span>STree</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span>unfold ::</span> <span>PRNG</span> <span>-&gt;</span> <span>STree</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>unfold prng <span>=</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span>let</span> (s, _) <span>=</span> next  prng</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        (l, r) <span>=</span> split prng</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span>in</span> <span>STree</span> s (unfold l) (unfold r)</span></code></pre></div>
<p>A generator is then a function that takes a part of a sample tree, parses it,
and produces a value and an updated sample tree:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Gen</span> a <span>=</span> <span>Gen</span> (<span>STree</span> <span>-&gt;</span> (a, [<span>STree</span>]))</span></code></pre></div>
<p>This does not reintroduce dependencies between generators: each generator
will be run against a different subtree, and update only that subtree. For
example, here is how we might run two generators:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>both ::</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> b <span>-&gt;</span> <span>Gen</span> (a, b)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>both (<span>Gen</span> g1) (<span>Gen</span> g2) <span>=</span> <span>Gen</span> <span>$</span> \(<span>STree</span> s l r) <span>-&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> (a, ls) <span>=</span> g1 l</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        (b, rs) <span>=</span> g2 r</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span>in</span> ( (a, b)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>       ,    [<span>STree</span> s l&#39; r  <span>|</span> l&#39; <span>&lt;-</span> ls]</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>         <span>++</span> [<span>STree</span> s l  r&#39; <span>|</span> r&#39; <span>&lt;-</span> rs]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>       )</span></code></pre></div>
<p>Note that we are focussing on the core concepts here, and are glossing over
various details. In particular, the <a href="https://github.com/well-typed/falsify/blob/45c6d5c3b2e3b284456b6e87f74c988da3e43194/lib/src/Test/Falsify/Internal/SampleTree.hs#L44-L63">actual definition</a>
in <code>falsify</code> has an additional constructor <code>Minimal</code>, which is a finite
representation of the infinite tree that is zero everywhere. This is a key
component in making this work with infinite data structures; see upcoming paper
for an in-depth discussion. Users of the library however generally do not need
to be aware of this (indeed, the sample tree abstraction is not part of the
public API).</p>
<h3 id="consequences-of-using-sample-trees">Consequences of using sample trees</h3>
<p>Arguably all of the key differences between <code>Hypothesis</code> and <code>falsify</code> stem from
the difference in representation of samples: a linear <em>stream</em> in <code>Hypothesis</code>
and an infinite <em>tree</em> in <code>falsify</code>. In this section we will discuss two
consequences of this choice.</p>
<h4 id="shrinking-the-sample-tree">Shrinking the sample tree</h4>
<p>First, we need to decide how to shrink a sample tree. In <code>Hypothesis</code>, the sample
stream (known as a “choice sequence”) is subjected all kinds of passes (15 and
counting, according to <a href="https://2020.ecoop.org/details/ecoop-2020-papers/13/Test-Case-Reduction-via-Test-Case-Generation-Insights-From-the-Hypothesis-Reducer">Test-Case Reduction via Test-Case Generation: Insights
from the Hypothesis Reducer</a>), which shrink the sample stream
according to lexicographical ordering; for example:</p>
<pre><code>..¸ x, ..        &lt; .., x&#39;, ..       -- shrink an element (x&#39; &lt; x)
.., x, y, z, ..  &lt; .., x, z, ..     -- drop an element from the stream
.., x, y, z, ..  &lt; .., y, z, x, ..  -- sort part of the stream (y &lt; z &lt; x)</code></pre>
<p>When we are dealing with infinite sample trees, such a total ordering does not
exist. For example, consider the following two trees:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>tree1 <span>=</span> <span>STree</span> <span>..</span>         tree2 <span>=</span> <span>STree</span> <span>..</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>         (<span>STree</span> <span>1</span> <span>..</span>)              (<span>STree</span> <span>2</span> <span>..</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>         (<span>STree</span> <span>4</span> <span>..</span>)              (<span>STree</span> <span>3</span> <span>..</span>)</span></code></pre></div>
<p>Sample <code>1</code> in <code>tree1</code> is <em>less</em> than the corresponding sample <code>2</code> in <code>tree2</code>,
but sample <code>4</code> in <code>tree1</code> is <em>greater</em> than the corresponding sample <code>3</code> in
<code>tree2</code>. Hence, we have neither <code>tree1 &lt; tree2</code> nor <code>tree2 &lt; tree1</code>: these two
trees are incomparable. Instead, <code>falsify</code> works with a partial ordering;
instead of the multitude of shrinking passes of <code>Hypothesis</code>, <code>falsify</code> has
precisely <em>one</em> pass<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>: shrink an individual sample in the tree.</p>
<h4 id="distributing-samples-to-parsers">Distributing samples to parsers</h4>
<p>When we have a stream of values that we need to use for multiple parsers, we
need to decide which samples go to which parser. In <code>Hypothesis</code>, this
essentially happens on a first-come-first-served basis: any samples left unused
by the first parser will be used by the next. As discussed, <code>falsify</code> parsers do
not return “samples left unused”. Instead, the sample tree is split each time we
compose parsers, like we did in <code>both</code>, shown above. In practice, this happens
primarily when using applicative <code>&lt;*&gt;</code> or monadic <code>&gt;&gt;=</code>.</p>
<h4 id="predictability">Predictability</h4>
<p>These two differences are rather technical in nature; how do they affect users?
Suppose we have a generator that produces a list and then a number:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>listThenNum ::</span> <span>Gen</span> ([<span>Bool</span>], <span>Int</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>listThenNum <span>=</span> <span>do</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    xs <span>&lt;-</span> Gen.list <span>..</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    n  <span>&lt;-</span> Gen.int  <span>..</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span>return</span> (xs, n)</span></code></pre></div>
<p>If we are using a stream of samples, <code>Hypothesis</code> style, and then drop a random
sample from that stream, the generator for <code>int</code> might suddenly be run against
an entirely <em>different</em> sample; it might <em>increase</em> in value! Similarly, if we
run that <code>int</code> generator against the first sample left over by the <code>list</code>
generator, and if that list generator uses fewer samples as it shrinks, we might
also run <code>int</code> against an unrelated sample, and its value might again increase.</p>
<p>This is not <em>necessarily</em> a problem; after all, we can then start to decrease
that new <code>int</code> value again. However, that is <em>only</em> possible if the generated
value with the larger <code>int</code> is still a counter-example to whatever property is
being tested. If that is not the case, then we might not be able to shrink the
list, and we might end up with a non-minimal counter-example. That can make
debugging more difficult (we haven’t gotten rid of all the “junk”), and it can
be difficult for users to understand <em>why</em> this might not shrink any further;
even if the library offers facilities for showing why shrinking stopped (for
example, showing which shrunk examples were rejected; verbose mode in
<code>falsify</code>), it can still be quite puzzling why the library is trying to
<em>increase</em> a value during shrinking.</p>
<p>Neither of these problems can arise in <code>falsify</code>: it never drops samples at all
(instead, only shrinking individual samples), and since monadic bind splits the
sample tree, we are guaranteed that the behaviour of <code>int</code> is entirely
unaffected by the behaviour of <code>list</code>. This makes the shrinking behaviour in
<code>falsify</code> more predictable and easier to understand.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h3 id="monadic-bind">Monadic bind</h3>
<p>We mentioned above that <code>QuickCheck</code>’s approach to shrinking has its problems,
without going into detail about what those problems are. Instead, we referred to
the blogpost <a href="https://www.well-typed.com/blog/2019/05/integrated-shrinking/">Integrated versus Manual Shrinking</a>; this
blog post discusses not only the problems in <code>QuickCheck</code>, but also shows one
alternative approach, known as <em>integrated</em> shrinking, used by <a href="http://www.quviq.com/products/">QuviQ
QuickCheck</a> and made popular in the Haskell
world by the library <a href="http://hackage.haskell.org/package/hedgehog">hedgehog</a>.</p>
<p>The problem with integrated shrinking is that it does not work across monadic
bind. The linked blogpost explains this in great detail, but the essence of
the problem is not hard to see. Consider the type of monadic bind:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;=) ::</span> <span>Gen</span> a <span>-&gt;</span> (a <span>-&gt;</span> <span>Gen</span> b) <span>-&gt;</span> <span>Gen</span> b</span></code></pre></div>
<p>We <em>cannot</em> shrink the right hand side of <code>(&gt;&gt;=)</code> independent from the left hand
side, because the right hand side <em>is not a generator</em>. We only have a generator
once we apply the supplied function to the result of the first generator. This
means that we cannot shrink these two generators independently: if, after
shrinking the right hand side, we go back and then shrink the left hand side, we
get an entirely different generator, and the shrinking we did previously is just
wasted.</p>
<p>In practice what this means is that once we start shrinking the right hand side,
we will never go back anymore and shrink the left hand side. In the example from
the introduction we first generated a list length, and then the elements of the
list:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>prop_list ::</span> <span>Property</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>prop_list <span>=</span> <span>do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    n  <span>&lt;-</span> gen <span>$</span> Gen.integral <span>$</span> Range.between (<span>0</span>, <span>10</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    xs <span>&lt;-</span> gen <span>$</span> replicateM n <span>$</span> Gen.int <span>$</span> Range.between (<span>0</span>, <span>1</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    assert <span>$</span> P.pairwise P.eq <span>.$</span> (<span>&#34;xs&#34;</span>, xs)</span></code></pre></div>
<p>With integrated shrinking, once we start shrinking elements from the list, we
will never go back anymore and shrink the list length. With internal shrinking,
however, we <em>can</em> go back and forth across monadic bind. This is the <em>raison
d’être</em> of internal shrinking: it doesn’t matter that we cannot shrink the two
generators independently, <em>because we are not shrinking generators</em>! Instead, we
just shrink the samples that feed <em>into</em> those generators.</p>
<h3 id="selective-functors">Selective functors</h3>
<p>It is important to understand the limitations of internal shrinking: it is
certaintly not a silver bullet. For example, consider this combinator that takes
two generators, flips a coin (generates a boolean, shrinking towards <code>True</code>),
and then executes one of the two generators:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>choose ::</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a <span>-- Suboptimal definition</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>choose g g&#39; <span>=</span> <span>do</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    b <span>&lt;-</span> Gen.bool <span>True</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span>if</span> b <span>then</span> g <span>else</span> g&#39;</span></code></pre></div>
<p>This combinator works, but it’s not optimal. Suppose the initial value of <code>b</code> is
<code>False</code>, and so we use <code>g&#39;</code>; and let’s suppose furthermore that we spend some
time shrinking the sample tree using <code>g&#39;</code>. Consider what happens if <code>b</code> now
shrinks to <code>True</code>. When this happens we will now run <code>g</code> <em>against the sample
tree as it was left after shrinking with <code>g&#39;</code></em>. Although we <em>can</em> do that, it
very much depends on the specific details of <code>g</code> and <code>g&#39;</code> whether it’s <em>useful</em>
to do it, and we will certainly lose the <a href="#predictability">predictability we discussed
above</a>.</p>
<p>We could try to make the two generators shrink independent from each other by
simply running <em>both</em> of them, and using the boolean only to choose which
result we want. After all, Haskell is lazy, and so this should be fine:</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>choose ::</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a <span>-- Bad definition!</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>choose g g&#39; <span>=</span> <span>do</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    x <span>&lt;-</span> g</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    y <span>&lt;-</span> g&#39;</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    b <span>&lt;-</span> Gen.bool <span>True</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>$</span> <span>if</span> b <span>then</span> x <span>else</span> y</span></code></pre></div>
<p>While is is true that <em>generation</em> using this definition of <code>choose</code> will work
just fine (and laziness ensures that we will in fact only run whatever generator
is used), this combinator <em>shrinks</em> very poorly. The problem is that if we
generate a value but they don’t use it, the (part of) the sample tree that we
used to produce that value is irrelevant, and so by definition we can always
replace it by the sample tree that is zero <em>everywhere</em>. This means that if we
later want to switch to that generator, we will <em>only</em> be able to do so if the
absolute <em>minimum</em> value that the generator can produce happens to work for
whatever property we’re testing. This is an important lesson to remember:</p>
<blockquote>
<strong>Do not generate values and then discard them: such values will always shrink
to their minimum. (Instead, don’t generate the value at all.)</strong>
</blockquote>
<p>To solve this problem, we need to make it visible to the library when we need a
generator and when we do not, so that we it can avoid shrinking that part of the
sample tree while the generator is not in use. Selectively omitting effects is
precisely what <a href="https://dl.acm.org/doi/10.1145/3341694">selective applicative functors</a> give us. A
detailed discussion of this topic would take us well outside the scope of this
blog post; in the remainder of this section we will discuss the basics only.</p>
<p><code>Gen</code> is a selective functor, which means that it is an instance of
<a href="http://hackage.haskell.org/package/selective">Selective</a>, which has a single method called <code>select</code>:</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span>select ::</span> <span>Gen</span> (<span>Either</span> a b) <span>-&gt;</span> <span>Gen</span> (a <span>-&gt;</span> b) <span>-&gt;</span> <span>Gen</span> b</span></code></pre></div>
<p>The intuition is that we run the first generator; if that produces <code>Left a</code>, we
run the second generator to get a <code>b</code>; if the first generator produces <code>Right b</code>, we skip the second generator completely. Like for applicative <code>&lt;*&gt;</code> and
monadic <code>(&gt;&gt;=)</code>, the two generators are run against different subtrees of the
sample tree, but the critical difference is that we will not try to shrink the
right subtree for the second generator unless that generator is used.</p>
<p>If that all sounds a bit abstract, perhaps suffices to say that any selective
functor supports</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span>ifS ::</span> <span>Selective</span> f <span>=&gt;</span> f <span>Bool</span> <span>-&gt;</span> f a <span>-&gt;</span> f a <span>-&gt;</span> f a</span></code></pre></div>
<p>which we can use to implement <code>choose</code> in a way that avoids reusing the sample
tree of the first generator for the second:</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span>choose ::</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>choose <span>=</span> ifS (bool <span>True</span>)</span></code></pre></div>
<p>Indeed, this is precisely the <a href="https://hackage.haskell.org/package/falsify/docs/src/Test.Falsify.Reexported.Generator.Compound.html#choose">definition in the <code>falsify</code> library
itself</a>.</p>
<h2 id="tutorial">Tutorial</h2>
<p>With the background out of the way, let’s now consider how to actually use the
library. Probably the easiest way to get started is to use the <code>tasty</code>
integration. Here is a minimal template to get you started:</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>Main</span> (main) <span>where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Test.Tasty</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Test.Tasty.Falsify</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>main <span>=</span> defaultMain <span>$</span> testGroup <span>&#34;MyTestSuite&#34;</span> [</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>      testProperty <span>&#34;myFirstProperty&#34;</span> prop_myFirstProperty</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span>prop_myFirstProperty ::</span> <span>Property</span> ()</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>prop_myFirstProperty <span>=</span> <span>return</span> ()</span></code></pre></div>
<p>This depends on <a href="http://hackage.haskell.org/package/tasty">tasty</a> package, as well as
<a href="http://hackage.haskell.org/package/falsify">falsify</a> of course. If you want, you can also use the
<a href="http://hackage.haskell.org/package/falsify/docs/Test-Falsify-Interactive.html">Test.Falsify.Interactive</a> module to experiment with
<code>falsify</code> in <code>ghci</code>.</p>
<h3 id="getting-started">Getting started</h3>
<p>Suppose we want to test that if we multiply a number by two, the result must
be even. Here’s how we could do it:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span>prop_multiply2_even ::</span> <span>Property</span> ()</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>prop_multiply2_even <span>=</span> <span>do</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    x <span>&lt;-</span> gen <span>$</span> Gen.int <span>$</span> Range.withOrigin (<span>-</span><span>100</span>, <span>100</span>) <span>0</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    unless (<span>even</span> (x <span>*</span> <span>2</span>)) <span>$</span> testFailed <span>&#34;not even&#34;</span></span></code></pre></div>
<p>Some observations:</p>
<ul>
<li><code>Property</code> is a monad, so the usual combinators (such as
<a href="https://hackage.haskell.org/package/base/docs/Control-Monad.html#v:unless">unless</a>) for monads are available</li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:gen">gen</a> runs a generator, and adds the output of the generator
to the test log. (The test log is only shown when the property fails.)</li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:int">Gen.int</a> is an alias for
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:integral">Gen.integral</a>, which can produce values for any
<a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Integral">Integral</a> type. There is no analogue of <code>QuickCheck</code>’s
<a href="https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck.html#t:Arbitrary">Arbitrary</a> class in <code>falsify</code>: like in <code>hedgehog</code>
and in <code>Hypothesis</code>, every generator must be explicitly specified. For a
justification of this choice, see Jacob Stanley’s excellent Lambda Jam 2017
presentation <a href="https://www.youtube.com/watch?v=AIv_9T0xKEo">Gens N’ Roses: Appetite for Reduction</a>
(Jacob is the author of <code>hedgehog</code>).</li>
<li>The specified <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Range.html#t:Range">Range</a> tells the generator two things:
in which range to produce a value, and how to shrink that value. In our
example, <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Range.html#v:withOrigin">withOrigin</a> takes an “origin” as explicit
value (here, 0), and the generator will shrink towards that origin.</li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testFailed">testFailed</a> is the primitive way to make a test
fail, but we shall see a better way momentarily.</li>
</ul>
<h3 id="predicates">Predicates</h3>
<p>Suppose we mistakingly think we need to multiply a number by <em>three</em> to get
a even number:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span>prop_multiply3_even ::</span> <span>Property</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>prop_multiply3_even <span>=</span> <span>do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    x <span>&lt;-</span> gen <span>$</span> Gen.int <span>$</span> Range.withOrigin (<span>-</span><span>100</span>, <span>100</span>) <span>0</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    unless (<span>even</span> (x <span>*</span> <span>3</span>)) <span>$</span> testFailed <span>&#34;not even&#34;</span></span></code></pre></div>
<p>If we run this test, we will get a counter-example:</p>
<pre><code>multiply3_even: FAIL
  failed after 14 shrinks
  not even
  Logs for failed test run:
  generated 1 at CallStack (from HasCallStack):
    gen, called at demo/Demo/Blogpost.hs:217:10 in main:Demo.Blogpost</code></pre>
<p>This counter-example is not awful: it gives us the counter-example (1), and that
counter-example is minimal. We can however do much better; the idiomatic way in
<code>falsify</code> to test properties of values is to use a
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Predicate.html#t:Predicate">Predicate</a>. A predicate of type</p>

<p>is essentially a function</p>
<div id="cb36"><pre><code><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>a <span>-&gt;</span> b <span>-&gt;</span> c <span>-&gt;</span> <span>..</span> <span>-&gt;</span> <span>Bool</span></span></code></pre></div>
<p>but in such a way that it can produce a meaningful message if the predicate
is not satisfied. Here’s how we might use it for our example:</p>
<div id="cb37"><pre><code><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span>prop_multiply3_even_pred ::</span> <span>Property</span> ()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>prop_multiply3_even_pred <span>=</span> <span>do</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    x <span>&lt;-</span> gen <span>$</span> Gen.int <span>$</span> Range.withOrigin (<span>-</span><span>100</span>, <span>100</span>) <span>0</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    assert <span>$</span> P.even <span>`P.dot`</span> P.fn (<span>&#34;multiply3&#34;</span>, (<span>*</span> <span>3</span>)) <span>.$</span> (<span>&#34;x&#34;</span>, x)</span></code></pre></div>
<p>Some comments:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Predicate.html#v:even">P.even</a>, like <code>even</code> from the prelude. is a predicate that
checks its argument is even</li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Predicate.html#v:dot">P.dot</a>, like <code>(.)</code> from the prelude, composes a predicate
with a function. In addition to the function itself, you also specify the
<em>name</em> of the function, so that that name can be used in error messages.</li>
<li>[(.<eq env="math">)][docs:falsify:dollar], like `(</eq>)` from the prelude, applies a predicate
to a named argument.</li>
</ul>
<p>The use of predicates is not required, but can be very helpful indeed. For our
running example, this will produce this test failure message instead:</p>
<pre><code>multiply3_even_pred: FAIL
  failed after 2 successful tests and 13 shrinks
  not (even (multiply3 x))
  x          : 1
  multiply3 x: 3</code></pre>
<h3 id="ranges-labelling">Ranges, Labelling</h3>
<p>We saw the use of <code>withOrigin</code> already, and earlier in this blog post we
used <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Range.html#v:between">between</a>; a generator such as</p>
<div id="cb39"><pre><code><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>Gen.integral <span>$</span> Range.between (<span>10</span>, <span>100</span>)</span></code></pre></div>
<p>will produce a value between 10 and 100 (inclusive), shrinking towards 10;
it is also possibly to flip the two bounds to shrink towards 100 instead.</p>
<p>The other very useful <code>Range</code> constructor is <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Range.html#v:skewedBy">skewedBy</a>.
A generator such as</p>
<div id="cb40"><pre><code><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Gen.integral <span>$</span> Range.skewedBy <span>5</span> (<span>0</span>, <span>100</span>)</span></code></pre></div>
<p>will produce values between (0, 100), like <code>between</code> does, but skewed towards
zero; a negative skew value will instead skew towards 100 (but still shrink
towards zero). As an example use case, suppose that for a certain property we
need a list of <code>Int</code> and an <code>Int</code>, and sometimes that separate <code>Int</code> should be a
member of the list, sometimes not:</p>
<div id="cb41"><pre><code><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span>prop_skew ::</span> <span>Double</span> <span>-&gt;</span> <span>Property</span> ()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>prop_skew skew <span>=</span> <span>do</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    xs <span>&lt;-</span> gen <span>$</span> Gen.list rangeListLen <span>$</span> Gen.integral rangeValues</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    x  <span>&lt;-</span> gen <span>$</span> Gen.integral rangeValues</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    collect <span>&#34;elem&#34;</span> [x <span>`elem`</span> xs]</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    rangeListLen,<span> rangeValues ::</span> <span>Range</span> <span>Word</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    rangeListLen <span>=</span> Range.between (<span>0</span>, <span>10</span>)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    rangeValues  <span>=</span> Range.skewedBy skew (<span>0</span>, <span>100</span>)</span></code></pre></div>
<p>This example is a property that always passes, but we use
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:collect">collect</a> to collect some statistics; specifically, in
what percentage of the tests <code>x</code> is an element of <code>xs</code>. If we run this with
a skew of 0, we might see something like:</p>
<pre><code>100000 successful tests

Label &#34;elem&#34;:
   94.6320% False
    5.3680% True</code></pre>
<p>In only 5% of cases the element appears in the list. There are various ways in
which we could change that distribution of test data, but the simplest way is
simply to generate more values towards the lower end of the range; if we run
the test with a skew of 5 we get</p>
<pre><code>Label &#34;elem&#34;:
   41.8710% False
   58.1290% True</code></pre>
<h3 id="generators">Generators</h3>
<p>Nearly all generators are built using <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:prim">prim</a> as their basic
building block, which returns the next sample from the sample tree. Higher-level
generators split into two categories: “simple” (non-compound) generators that produce a value given some arguments, and generator <em>combinators</em> that take generators as input and produce new generators. Some important examples in the first category are:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:integral">integral</a>, which we discussed already</li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:bool">bool</a>, which produces a <code>Bool</code>, shrinking towards a choice
of <code>True</code> or <code>False</code></li>
<li><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:elem">elem</a>, which picks a random element from a list, and
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:shuffle">shuffle</a>, which shuffles a list</li>
<li>etc.</li>
</ul>
<p>The library also offers a number of <em>generator combinators</em>; here we list the
most important ones:</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:choose">choose</a> we saw when we discussed <a href="#selective-functors">Selective
functors</a>, and chooses (uniformly) between two
generators, shrinking towards the first.</p></li>
<li><p><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:list">list</a> takes a range for the list length and a generator
and produces a list of values. Unlike the simple “pick a length and then call
<code>replicateM</code>” approach from the <a href="#teaser">example from the introduction</a>, this
generator can drop elements anywhere in the list (it does this by using the
combinator <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:mark">mark</a> to mark elements in the list; as the
marks shrink towards “drop”, the element is removed, up to the specified
<code>Range</code>).</p></li>
<li><p><a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:frequency">frequency</a>, similar to the like-named function in
<code>QuickCheck</code>, takes a list of generators and frequencies, and chooses a
generator according to the specified frequency. This is another way in which
we can tweak the distribution of test data.</p>
<p>The implementation of <code>frequency</code> ensures that the generators can shrink
indepedently from each other. This <em>could</em> be defined just using <code>Selective</code>,
but for improved performance it makes use of a low-level combinator called
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:perturb">perturb</a>; see also
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:bindIntegral">bindIntegral</a>, which generalizes <code>Selective</code>
<a href="https://hackage.haskell.org/package/selective/docs/Control-Selective-Multi.html#v:bindS">bindS</a>, and has significantly better performance than
<code>bindS</code>.</p></li>
</ul>
<h3 id="generating-functions">Generating functions</h3>
<p>One of the most impressive aspects of <code>QuickCheck</code> is that it can generate, show
and shrink functions. This is due to a functional pearl by Koen Claessen called
<a href="https://dl.acm.org/doi/10.1145/2364506.2364516">Shrinking and showing functions</a>; the presentation is
<a href="https://www.youtube.com/watch?v=CH8UQJiv9Q4">available on YouTube</a> and is well worth a watch. We
have adapted the <code>QuickCheck</code> approach (and simplified it slightly) to <code>falsify</code>;
the generator is called <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:fun">fun</a>. Here is an example
(<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:Fn">Fn</a> is a pattern synonym; you will essentially always need it
when generating functions):</p>
<div id="cb44"><pre><code><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span>prop_fn1 ::</span> <span>Property</span> ()</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>prop_fn1 <span>=</span> <span>do</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span>Fn</span> (<span>f ::</span> [<span>Int</span>] <span>-&gt;</span> <span>Bool</span>) <span>&lt;-</span> gen <span>$</span> Gen.fun <span>$</span> Gen.bool <span>False</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    assert <span>$</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>         P.eq</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>         <span>`P.on`</span> P.fn (<span>&#34;f&#34;</span>, f)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>      <span>.$</span> (<span>&#34;x&#34;</span>, [<span>1</span>, <span>2</span>, <span>3</span>])</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>      <span>.$</span> (<span>&#34;y&#34;</span>, [<span>4</span>, <span>5</span>, <span>6</span>])</span></code></pre></div>
<p>This property says that for any function <code>f :: [Int] -&gt; Bool</code>, if we apply that
function to the list <code>[1, 2, 3]</code> we must get the same result as when we apply
it to the list <code>[4, 5, 6]</code>. Of course, that is not true, and when we run this
test, <code>falsify</code> will give us a counter-example:</p>
<pre><code>failed after 53 shrinks
(f x) /= (f y)
x  : [1,2,3]
y  : [4,5,6]
f x: True
f y: False

Logs for failed test run:
generated {[1,2,3]-&gt;True, _-&gt;False} at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:244:32 in main:Demo.Blogpost</code></pre>
<p>Notice the counter-example we get: a function that returns <code>True</code> for the list
<code>[1, 2, 3]</code>, and <code>False</code> everywhere else.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> It truly is quite astonishing that this
works: <em>we</em> can see that the list <code>[1, 2, 3]</code> is special by inspecting the
source code, but of course <code>falsify</code> (or indeed, <code>QuickCheck</code>; this is not
unique to <code>falsify</code>) cannot! Instead, <code>falsify</code> will generate a random
infinitely large description of functions from <code>[Int] -&gt; Bool</code>, that covers
<em>all</em> possible input lists, and then start shrinking this description, throwing
away values for inputs it doesn’t need, until a minimal test case remains. Truly
a testament to the power of laziness in Haskell.</p>
<p>For a more realistic example, let’s port an example from Koen Claessen’s
presentation to <code>falsify</code>. This example is testing the (wrong) property that for
all functions <code>f</code> and predicates <code>p</code>,</p>
<pre><code>map f . filter p == filter p . map f</code></pre>
<p>In <code>falsify</code>, we might express this as:</p>
<div id="cb47"><pre><code><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span>prop_mapFilter ::</span> <span>Property</span> ()</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>prop_mapFilter <span>=</span> <span>do</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span>Fn</span> (<span>f ::</span> <span>Int</span> <span>-&gt;</span> <span>Int</span>)  <span>&lt;-</span> gen <span>$</span> Gen.fun genInt</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span>Fn</span> (<span>p ::</span> <span>Int</span> <span>-&gt;</span> <span>Bool</span>) <span>&lt;-</span> gen <span>$</span> Gen.fun genBool</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span>    xs ::</span> [<span>Int</span>] <span>&lt;-</span> gen <span>$</span> Gen.list (Range.between (<span>0</span>, <span>100</span>)) genInt</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    assert <span>$</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>       P.eq</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>      <span>`P.split`</span> (P.fn (<span>&#34;map f&#34;</span>, <span>map</span> f), P.fn (<span>&#34;filter p&#34;</span>, <span>filter</span> p))</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>      <span>`P.split`</span> (P.fn (<span>&#34;filter p&#34;</span>, <span>filter</span> p), P.fn (<span>&#34;map f&#34;</span>, <span>map</span> f))</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>      <span>.$</span> (<span>&#34;xs&#34;</span>, xs)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>      <span>.$</span> (<span>&#34;xs&#34;</span>, xs)</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span>    genInt ::</span> <span>Gen</span> <span>Int</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    genInt <span>=</span> Gen.int <span>$</span> Range.between (<span>0</span>, <span>100</span>)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span>    genBool ::</span> <span>Gen</span> <span>Bool</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>    genBool <span>=</span> Gen.bool <span>False</span></span></code></pre></div>
<p>We generate a <em>random</em> function <code>f</code>, a <em>random</em> predicate <code>p</code>, a random list
<code>xs</code>, and then assert the property; and of course, <code>falsify</code> will happily give
us a counter-example:</p>
<pre><code>failed after 25 shrinks
(map f (filter p xs)) /= (filter p (map f xs))
xs                 : [96]
xs                 : [96]
filter p xs        : [96]
map f xs           : [0]
map f (filter p xs): [0]
filter p (map f xs): []

Logs for failed test run:
generated {_-&gt;0} at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:254:30 in main:Demo.Blogpost
generated {96-&gt;True, _-&gt;False} at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:255:30 in main:Demo.Blogpost
generated [96] at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:256:20 in main:Demo.Blogpost</code></pre>
<p>It generated a function that maps anything to <code>0</code>, a predicate that is
<code>True</code> for <code>96</code> and <code>False</code> for everything else, and a list containing only the
value <code>96</code>; this is indeed a nice counter-example, as the output from the
<code>assert</code> explains.</p>
<p>Side note: in an ideal world that value <code>96</code> would be shrunk too. However, this
would require shrinking <em>both</em> the <code>96</code> in the generated list <em>and</em> the <code>96</code> in
the generated predicate <em>at the same time</em>. Like <code>QuickCheck</code>, <code>falsify</code> never
takes more than one shrink step at once, to ensure that shrinking is <code>O(n)</code> and
avoid exponential explosion. Section <a href="https://www.well-typed.com/blog/2019/01/qsm-in-depth/#dependencies-between-commands">Dependencies between commands</a>
of my blog post “An in-depth look at <code>quickcheck-state-machine</code>” discusses this
kind of problem in the context of <code>quickcheck-state-machine</code>.</p>
<h3 id="testing-shrinking">Testing shrinking</h3>
<p>When we use internal (or indeed, integrated) shrinking, we don’t write a
separate shrinking function, but that doesn’t mean we cannot get shrinking
wrong. Shrinking <em>never</em> truly comes for free! As a simple example, consider
writing a generator that produces any value below a given maximum
(essentially, a more limited form of <code>integral</code>). A first attempt might be:</p>
<div id="cb49"><pre><code><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span>below ::</span> <span>Word64</span> <span>-&gt;</span> <span>Gen</span> <span>Word64</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>below n <span>=</span> (<span>`mod`</span> n) <span>&lt;$&gt;</span> Gen.prim</span></code></pre></div>
<p>While this generator does in fact produce values in the range <code>0 &lt;= x &lt; n</code>, it
does not shrink very well! As the value produced <code>prim</code> shrinks, the value
produced by <code>below</code> will cycle. We can discover this by writing a property that
tests the shrinking behaviour of <code>below</code>, using
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testShrinkingOfGen">testShrinkingOfGen</a>:</p>
<div id="cb50"><pre><code><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span>prop_below_shrinking ::</span> <span>Property</span> ()</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>prop_below_shrinking <span>=</span> <span>do</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    n <span>&lt;-</span> gen <span>$</span> Gen.integral <span>$</span> Range.between (<span>1</span>, <span>1</span>_000)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    testShrinkingOfGen P.ge <span>$</span> below n</span></code></pre></div>
<p>This property will fail:</p>
<pre><code>failed after 4 successful tests and 14 shrinks
original &lt; shrunk
original: 0
shrunk  : 1

Logs for failed test run:
generated 2 at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:281:10 in main:Demo.Blogpost</code></pre>
<p>In addition to testing individual shrinking steps, we can also test that for
particular property and generator, we can generate a particular <em>minimum</em> using
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testMinimum">testMinimum</a>. Let’s consider the naive list generator
from the introduction one more time:</p>
<div id="cb52"><pre><code><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span>naiveList ::</span> <span>Range</span> <span>Int</span> <span>-&gt;</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> [a]</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>naiveList r g <span>=</span> <span>do</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    n  <span>&lt;-</span> Gen.integral r</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    replicateM n g</span></code></pre></div>
<p>Suppose we want to verify that if we use this generator to test the (false)
property that “all elements of all lists are always equal” we should <em>always</em>
get either <code>[0, 1]</code> or <code>[1, 0]</code> as a counter-example; after all, those are
the two minimal counter-examples. We could test this as follows:</p>
<div id="cb53"><pre><code><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span>prop_naiveList_minimum ::</span> <span>Property</span> ()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>prop_naiveList_minimum <span>=</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    testMinimum (P.elem <span>.$</span> (<span>&#34;expected&#34;</span>, [[<span>0</span>,<span>1</span>], [<span>1</span>,<span>0</span>]])) <span>$</span> <span>do</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>      xs <span>&lt;-</span> gen <span>$</span> naiveList</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>                    (Range.between (<span>0</span>, <span>10</span>))</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>                    (Gen.int (Range.between (<span>0</span>, <span>1</span>)))</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>      <span>case</span> P.eval <span>$</span> P.pairwise P.eq <span>.$</span> (<span>&#34;xs&#34;</span>, xs) <span>of</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> _   <span>-&gt;</span> testFailed xs</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>        <span>Right</span> () <span>-&gt;</span> <span>return</span> ()</span></code></pre></div>
<p>The counter-example reported by <code>falsify</code> is (somewhat shortened):</p>
<pre><code>naiveList_minimum: FAIL
  failed after 0 shrinks
  minimum `notElem` expected
  minimum : [0,0,1]
  expected: [[0,1],[1,0]]

Logs for failed test run:
generated [0,0,1] at CallStack (from HasCallStack):
  gen, called at demo/Demo/Blogpost.hs:294:13 in main:Demo.Blogpost

Logs for rejected potential next shrinks:

** Rejected run 0
generated [] at CallStack (from HasCallStack):

** Rejected run 3
generated [0] at CallStack (from HasCallStack):

** Rejected run 4
generated [0,0] at CallStack (from HasCallStack):

** Rejected run 8
generated [0,0,0] at CallStack (from HasCallStack):</code></pre>
<p>This is telling us that the minimum value it produced was <code>[0, 0, 1]</code>, instead
of one of the two lists that we expected. It also tells us what shrink steps
were rejected (because they weren’t counter-examples). This is informative,
because _none of those shrink steps is <code>[0, 1]</code>: the naive list generator,
unlike the real one (which does pass this property) cannot drop elements from
the start of the list.</p>
<p>The <code>falsify</code> test suite uses
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testShrinkingOfGen">testShrinkingOfGen</a> (and its generalization
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testShrinking">testShrinking</a>) as well as
<a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Property.html#v:testMinimum">testMinimum</a> extensively to test <code>falsify</code>’s own
generators.</p>
<h3 id="compatibility">Compatibility</h3>
<p>Finally, <code>falsify</code> offers two combinators <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:shrinkWith">shrinkWith</a>
and <a href="https://hackage.haskell.org/package/falsify/docs/Test-Falsify-Generator.html#v:fromShrinkTree">fromShrinkTree</a> which provide compatibility
with <code>QuickCheck</code> style shrinking</p>
<div id="cb55"><pre><code><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span>shrinkWith ::</span> (a <span>-&gt;</span> [a]) <span>-&gt;</span> <span>Gen</span> a <span>-&gt;</span> <span>Gen</span> a</span></code></pre></div>
<p>and <code>hedgehog</code> style shrinking</p>
<div id="cb56"><pre><code><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span>fromShrinkTree ::</span> <span>Tree</span> a <span>-&gt;</span> <span>Gen</span> a</span></code></pre></div>
<p>respectively. The implementation of these combinators depends on a minor
generalization of the sample tree representation; the details are discussed
in the paper.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Shrinking is an essential component of any approach to property based testing.
In the Haskell world, two libraries offered two competing approaches to
shrinking: <em>manual</em> shrinking offered by <code>QuickCheck</code>, where users are entirely
responsible for writing shrinkers for their generators, and <em>integrated</em>
shrinking, offered by <code>hedgehog</code>. Integrated shrinking is nice, but does not work
well with monadic bind. The Python <code>Hypothesis</code> library taught us how we can have
“internal” shrinking: like in integrated shrinking, we do not write a separate
generator and shrinker, but unlike in integrated shrinking, this approach <em>does</em>
work across monadic bind.</p>
<p>The Haskell <code>falsify</code> library takes the core ideas of <code>Hypothesis</code> and applies
them in the context of Haskell. As we have seen, however, the actual details of
how these two libraries work differ quite significantly. The <code>falsify</code> approach is
more suitable to Haskell where we might deal with infinite data structures,
provides the user with more predictable shrinking, and provides the user with
tools for controlling generator independence (through the use of selective
functors).</p>


        </div>
      </div></div>
  </body>
</html>
