<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ossia.io/posts/minimum-viable/">Original</a>
    <h1>Minimum Viable Declarative GUI in C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
          <article id="main">
  <header>
    <h2>Minimum viable declarative GUI in C++</h2>
    <p>Dev  •  Mar 22, 2022  •  Jean-Michaël Celerier</p>
  </header>

  <section>
    

<p>Here is the code of a minimal GUI toolkit for defining declarative UIs:</p>

<figure><pre><code data-lang="cpp"><span>// That&#39;s it. That&#39;s the toolkit.</span></code></pre></figure>

<p>Well, this plus some extremely routine parts of “ISO/IEC JTC1 SC22 WG21 N 4860 - Programming Languages : C++”, such as… strings… variable declarations… struct definitions… enums… ints… and a couple others. Code so post-modern it circled back to <a href="https://gist.github.com/bkaradzic/2e39896bc7d8c34e042b">orthodoxy</a>.</p>

<p>So, here is how one uses the C++ language plus this, uh, toolkit to declare a simple item, say, a text label:</p>

<figure><pre><code data-lang="cpp"><span>struct</span> <span>{</span>
  <span>const</span> <span>char</span><span>*</span> <span>my_label</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
<span>}</span> <span>my_ui</span><span>;</span></code></pre></figure>

<p>Believe me, dear reader, that is actually enough user code to be able to show the following UI:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/ui-minimal.png" alt="The UI"/></p>

<p>By user code, I mean that all the “nice” UI work can be done in, say, <code>foo.hpp</code>:</p>

<figure><pre><code data-lang="cpp"><span>#pragma once
</span><span>constexpr</span> <span>struct</span> <span>{</span>
  <span>const</span> <span>char</span><span>*</span> <span>my_label</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
<span>}</span> <span>my_ui</span><span>;</span></code></pre></figure>

<p>without requiring any custom header. Some yet-unknown .cpp file will include <code>foo.hpp</code>, and, no matter what the content of <code>my_ui</code> is, will execute a nice user interface from it. Anyone will be able to create independent libraries which will render UIs according to whatever platform-specific intricacies there are, but the actual UI code will be entirely independent from anything: peak separation of concerns is achieved.</p>

<h2 id="advanced-ui">Advanced UI</h2>

<p>The code above can be trivially extended to showing not one, but TWO labels:</p>

<figure><pre><code data-lang="cpp"><span>struct</span> <span>{</span>
  <span>const</span> <span>char</span><span>*</span> <span>my_label</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
  <span>const</span> <span>char</span><span>*</span> <span>other_label</span> <span>=</span> <span>&#34;bar&#34;</span><span>;</span>
<span>}</span> <span>my_ui</span><span>;</span></code></pre></figure>

<p>The result:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/ui-advanced.png" alt="The UI"/></p>

<p>Now, one notices how the visual position of the labels in the UI has the good taste of matching 
the one in the code: the language provides us with a native primitive for ordering disjoint things, so why not just use it ?</p>

<p>Of course, just putting elements in a vertical row may not be sufficient for <em>every</em>  UI on earth.</p>

<p>Let’s declare that our UI embraces horizontality instead, in the simplest way possible that I could find:</p>

<figure><pre><code data-lang="cpp"><span>struct</span> <span>{</span>
  <span>enum</span> <span>{</span> <span>hbox</span> <span>};</span> 
  <span>const</span> <span>char</span><span>*</span> <span>my_label</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
  <span>const</span> <span>char</span><span>*</span> <span>other_label</span> <span>=</span> <span>&#34;bar&#34;</span><span>;</span>
<span>}</span> <span>my_ui</span><span>;</span></code></pre></figure>

<p>And we get:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/hbox.png" alt="The UI"/></p>

<h2 id="nested-ui">Nested UI</h2>

<p>We may want to imbricate multiple things:</p>

<figure><pre><code data-lang="cpp"><span>struct</span> <span>{</span>
  <span>enum</span> <span>{</span> <span>hbox</span> <span>};</span> 

  <span>struct</span> <span>{</span>
    <span>enum</span> <span>{</span> <span>vbox</span> <span>};</span> 
    <span>const</span> <span>char</span><span>*</span> <span>a</span> <span>=</span> <span>&#34;foo&#34;</span><span>;</span>
    <span>const</span> <span>char</span><span>*</span> <span>b</span> <span>=</span> <span>&#34;bar&#34;</span><span>;</span>
  <span>}</span> <span>group1</span><span>;</span>
  
  <span>struct</span> <span>{</span>
    <span>enum</span> <span>{</span> <span>vbox</span> <span>};</span> 
    <span>const</span> <span>char</span><span>*</span> <span>a</span> <span>=</span> <span>&#34;quz&#34;</span><span>;</span>
    <span>const</span> <span>char</span><span>*</span> <span>b</span> <span>=</span> <span>&#34;qux&#34;</span><span>;</span>
  <span>}</span> <span>group2</span><span>;</span>
<span>}</span> <span>my_ui</span><span>;</span></code></pre></figure>

<p>Gives:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/quad.png" alt="The UI"/></p>

<p>We may want to go a bit deeper:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/complete.gif" alt="The UI"/></p>

<p>The controls are pointers to simple structs which define a couple of metadatas in the way mentioned in the <a href="https://ossia.io/posts/reflection">reflection</a> blogpost.</p>

<p>A nice thing here is that unlike many frameworks, there’s not much memory to leak, as 
the very structure of C++ structs is used to define the hierarchical UI.</p>

<p>Of course, there has to be a rendering framework somewhere: the nice thing is that the UI code has no dependency on the actual framework.
Instead, some separate glue code will transmute our declarative UI definition. Thus, which framework exactly mostly does not matter,
for a large amount of potential UIs.</p>

<p>To give an example, the screenshots above were taken with a first prototype of renderer which generates QML / QtQuick code (and runs it).</p>


<p>Here is the exact same UI specification, but rendered with <a href="https://github.com/Immediate-Mode-UI/Nuklear">Nuklear</a> instead, which is a fairly different UI paradigm code-wise:</p>

<p><img src="https://ossia.io/assets/blog/mvp-ui/nuklear.gif" alt="The UI"/></p>

<p>I have spent an hour on it without prior knowledge of the library and did not find how to do splitters and group boxes well with it, but I’m sure there is a way !</p>

<p>Meanwhile… t r e e s.</p>

<p>The binding from this kind of UI specification to Nuklear holds in a ~200 lines <a href="https://github.com/celtera/avendish/blob/main/include/avnd/binding/ui/nuklear_layout_ui.hpp">(fairly dirty) file</a>.</p>

<p>Here is the core loop, for reference:</p>

<figure><pre><code data-lang="cpp"><span>void</span> <span>recurseItem</span><span>(</span><span>const</span> <span>auto</span><span>&amp;</span> <span>item</span><span>)</span>
<span>{</span>
  <span>avnd</span><span>::</span><span>for_each_field_ref</span><span>(</span><span>item</span><span>,</span> <span>[</span><span>this</span><span>]</span> <span>(</span><span>auto</span><span>&amp;</span> <span>child</span><span>)</span> <span>{</span>
    <span>this</span><span>-&gt;</span><span>createItem</span><span>(</span><span>child</span><span>);</span>      
  <span>});</span>
<span>}</span>

<span>template</span><span>&lt;</span><span>typename</span> <span>Item</span><span>&gt;</span>
<span>void</span> <span>createItem</span><span>(</span><span>const</span> <span>Item</span><span>&amp;</span> <span>item</span><span>)</span>
<span>{</span>
  <span>constexpr</span> <span>int</span> <span>child_count</span> <span>=</span> <span>boost</span><span>::</span><span>pfr</span><span>::</span><span>tuple_size_v</span><span>&lt;</span><span>Item</span><span>&gt;</span><span>;</span>
  <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>spacing</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>nk_label</span><span>(</span><span>ctx</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>NK_TEXT_LEFT</span><span>);</span>
  <span>}</span>
  <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>hbox</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>nk_layout_row_dynamic</span><span>(</span><span>ctx</span><span>,</span> <span>row_height</span><span>,</span> <span>child_count</span><span>);</span>
    <span>recurseItem</span><span>(</span><span>item</span><span>);</span>
  <span>}</span>
  <span>else</span> <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>vbox</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>recurseItem</span><span>(</span><span>item</span><span>);</span>
  <span>}</span>
  <span>else</span> <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>split</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>if</span> <span>(</span><span>nk_tree_push</span><span>(</span><span>ctx</span><span>,</span> <span>NK_TREE_TAB</span><span>,</span> <span>&#34;Split&#34;</span><span>,</span> <span>NK_MINIMIZED</span><span>))</span> <span>{</span>
      <span>recurseItem</span><span>(</span><span>item</span><span>);</span>
      <span>nk_tree_pop</span><span>(</span><span>ctx</span><span>);</span>
    <span>}</span>
  <span>}</span>
  <span>else</span> <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>group</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>if</span> <span>(</span><span>nk_tree_push</span><span>(</span><span>ctx</span><span>,</span> <span>NK_TREE_TAB</span><span>,</span> <span>c_str</span><span>(</span><span>Item</span><span>::</span><span>name</span><span>()),</span> <span>NK_MINIMIZED</span><span>))</span> <span>{</span>
      <span>recurseItem</span><span>(</span><span>item</span><span>);</span>
      <span>nk_tree_pop</span><span>(</span><span>ctx</span><span>);</span>
    <span>}</span>
  <span>}</span>
  <span>else</span> <span>if</span> <span>constexpr</span><span>(</span><span>requires</span> <span>{</span> <span>item</span><span>.</span><span>tabs</span><span>;</span> <span>})</span>
  <span>{</span>
    <span>createTabs</span><span>(</span><span>item</span><span>);</span>
  <span>}</span> 
  <span>else</span>
  <span>{</span>
    <span>// Normal widget</span>
    <span>createWidget</span><span>(</span><span>item</span><span>);</span>
  <span>}</span>
<span>}</span></code></pre></figure>



<p><em>Glory to the post-library era and to declarative, struct &amp; enum-based specification !</em></p>

<p>The only remaining step is to integrate it with score’s internal widget set and there will finally be a
way to specify audio and media plug-ins in a way entirely independent from any host app or framework, with zero-cost abstractions.</p>

<p>Here is the example plug-in showcased above, done in two ways:</p>

<ul>
  <li>First version really only uses zero dependencies to show the sausage-making <a href="https://github.com/celtera/avendish/blob/main/examples/Ui.hpp">https://github.com/celtera/avendish/blob/main/examples/Ui.hpp</a>.</li>
  <li>Second version use some helpers macros: <a href="https://github.com/celtera/avendish/blob/main/examples/Helpers/Ui.hpp">https://github.com/celtera/avendish/blob/main/examples/Helpers/Ui.hpp</a>. I don’t find them super convincing, but the nice thing is that the “public API” can be prototyped without issues ; as many distinct versions can exist concurrently. In the end, they pretty much won’t exist in the binary as things can be made constexpr fairly extensively: the whole layout object can be constexpr for instance.</li>
</ul>

<p>A few small additional things may be useful:</p>

<ul>
  <li>An API for loading images, for instance to render pretty SVG background à la VCVRack.</li>
  <li>Maybe investigating reactive properties. I have some ideas for those, which may actually fit in these margins :-)</li>
</ul>

<p>This work can be tried with the <a href="https://github.com/celtera/avendish">avendish</a> library.</p>

  </section>
  <section>
       
        <a href="https://ossia.io/posts/ossia-score-3/">← <strong>Introducing ossia score 3</strong></a>
        

        

        
</section>

</article>


    </div></div>
  </body>
</html>
