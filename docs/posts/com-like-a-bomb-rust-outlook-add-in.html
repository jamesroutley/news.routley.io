<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tritium.legal/blog/outlook">Original</a>
    <h1>COM Like a Bomb: Rust Outlook Add-in</h1>
    
    <div id="readability-page-1" class="page"><article>

    <p>One of legal tech&#39;s clich√©s is that &#34;lawyers live in Word&#34;.</p>

    <p>This is demonstrably incorrect. I, for example, am a lawyer and in fact live in London, England.</p>

    <p>But what they mean to say is that lawyers spend much of their time editing documents in Microsoft Word. This is
        because, for the most part, opening <code>.docx</code> files in Word is the default behavior where it&#39;s
        installed (everywhere). Lawyers, and again I&#39;m speaking from experience here, are generally lazy when it comes
        to
        technology. Defaults are the law.</p>

    <p>This is rational. Clients pay thousands of dollars per hour to have their legal needs addressed by
        the top law firms
        in the world. This means that law firms account for every moment their lawyers&#39; working days. Generally, in
        6-minute increments
        (or, 0.1 hours). No client is paying even 0.3 for their lawyer to learn a new software paradigm, and most law
        firms don&#39;t find
        forgoing revenue to train lawyers on new systems that will make them faster especially motivating.</p>

    <p>So to get a foothold into legal, we need to make Tritium slot as nearly as possible into the existing workflow.
    </p>

    <p>So where does the legal work flow originate?</p>

    <p>Three places: (1) the document management system (DMS), (2) the desktop and (3) email.</p>

    <p>We&#39;ve <a href="https://tritium.legal/blog/tokio">previously talked about iManage</a>, one of the most important document management
        systems in legal. There are other important ones such as NetDocuments, and our integrations into those will be
        the subject of another post.</p>

    <p>Today, we&#39;re focused on the third place.</p>

    <p>We&#39;re giving access to Tritium right in the lawyer&#39;s inbox.</p>

    <p>We&#39;re going to replicate our &#34;Open with Tritium&#34; desktop entry point in Outlook. Here&#39;s what it looks like on the
        desktop:</p>

    <p><img src="https://tritium.legal/static/images/open-with-tritium.png"/></p>

    <h2>Outlook Integration</h2>

    <p>&#34;New Outlook&#34; is some sort of half-implemented WebView mess that requires javascript round-tripped from a host
        server to plug in new features.</p>

    <p>We&#39;ll eventually have to get in there, too, but for the most part law firms seem to have thus far stuck with the
        much more featureful &#34;legacy Outlook&#34;. That version is a venerable, performant, C++-based Windows desktop
        application.
    </p>

    <p><img src="https://tritium.legal/static/images/venerable-outlook.png"/></p>

    <p>So, how do we plug into it?</p>

    <h2>COM</h2>

    <p>Before even the easy 100 MB of RAM days let alone the advent of <code>node</code> and <code>electron</code> and
        <code>JSON</code>,
        the Windows operating system needed a way to allow processes and applications to communicate in a
        language-agnostic way. This ultimately resulted in the <a href="https://en.wikipedia.org/wiki/Component_Object_Model" target="_blank">&#34;Component Object Model&#34;</a> or
        COM. COM allows
        us to plug
        into various entry points using a Dynamically Linked Library (.dll) which follows a strict
        <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">ABI</a> with certain
        calling conventions.
    </p>

    <p>COM lives on today, and it is still an effective way to communicate with various processes, including Windows
        11&#39;s File Explorer.</p>

    <p>Fortunately, COM is supported in the <code>windows-rs</code> Rust crate.[<a href="#1">1</a>]</p>

    <p>To add a link to Outlook&#39;s attachment context menu, we need to inherit from a series of COM classes:
        <code>IDispatch</code>,
        <code>IDTExtensibility2</code> and ultimately <code>IRibbonExtensibility</code>.
    </p>

    <p><code>windows-rs</code> provides an <code>IDispatch</code> implementation out-of-the box which exposes a
        <code>trait</code> that looks like the below:
    </p>

    <pre><code>fn GetTypeInfoCount(&amp;self) -&gt; windows::core::Result&lt;u32&gt; {}

fn GetIDsOfNames(
    &amp;self,
    riid: *const GUID,
    rgsz_names: *const PCWSTR,
    c_names: u32,
    lcid: u32,
    rg_disp_id: *mut i32,
) -&gt; std::result::Result&lt;(), windows_core::Error&gt; {}

fn Invoke(
    &amp;self,
    disp_id_member: i32,
    riid: *const GUID,
    lcid: u32,
    w_flags: DISPATCH_FLAGS,
    p_disp_params: *const DISPPARAMS,
    p_var_result: *mut VARIANT,
    p_excep_info: *mut EXCEPINFO,
    pu_arg_err: *mut u32,
) -&gt; std::result::Result&lt;(), windows_core::Error&gt; {}
</code></pre>

    <p>These functions provide the basic COM dispatching mechanisms.</p>

    <p>Using them a caller is able to look up the <code>rg_disp_id</code> of a particular named function in your
        implementation, then <code>Invoke</code> that function with the results optionally populating
        <code>p_var_result</code> which is a pointer to a mutable <a href="https://en.wikipedia.org/wiki/Union_type" target="_blank">union</a> of possible result types.
    </p>

    <p>This is the basic wiring which allows us to implement the required <code>IDTExensibility2</code> and
        <code>IRibbonExtensibility</code> classes.
    </p>

    <p><code>windows-rs</code> doesn&#39;t implement these classes, but does help us by providing the <code>interface</code>
        procedural macro which handles setting up the <a href="https://en.wikipedia.org/wiki/Virtual_method_table">VTables</a> to map our struct&#39;s methods to the COM
        ABI.</p>

    <p>We use the class&#39;s <code>GUID</code> for the macro to establish that we&#39;re implementing
        <code>IDTExtensibility2</code>.[<a href="#2">2</a>]
    </p>

    <pre><code>#[windows::core::interface(&#34;B65AD801-ABAF-11D0-BB8B-00A0C90F2744&#34;)]
pub unsafe trait IDTExtensibility2: IDispatch {
    unsafe fn OnConnection(
        &amp;self,
        _application: Option&lt;&amp;IDispatch&gt;,
        _connectmode: i32,
        _addin_instance: Option&lt;&amp;IDispatch&gt;,
        _custom: SAFEARRAY,
    ) -&gt; HRESULT;
    unsafe fn OnDisconnection(&amp;self, mode: i32, custom: SAFEARRAY) -&gt; HRESULT;
    unsafe fn OnAddInsUpdate(&amp;self, custom: SAFEARRAY) -&gt; HRESULT;
    unsafe fn OnStartupComplete(&amp;self, custom: SAFEARRAY) -&gt; HRESULT;
    unsafe fn OnBeginShutdown(&amp;self, custom: SAFEARRAY) -&gt; HRESULT;
}
</code></pre>

    <p>Then, we implement that interface for our <code>struct</code>.</p>

    <pre><code>#[implement(IRibbonExtensibility, IDTExtensibility2, IDispatch)]
struct Addin;
</code></pre>

    <p>This causes the procedural macro to generate <code>IRibbonExensibility_Impl</code>,
        <code>IDTExensibility2_Impl</code> and <code>IDispatch_Impl</code> traits for us to implement in
        <code>struct Addin_Impl</code>.
    </p>

    <p>Here&#39;s the initial Tritium <code>IDTExensibility2_Impl</code> verbatim for example:</p>

    <pre><code>impl IDTExtensibility2_Impl for Addin_Impl {
    unsafe fn OnConnection(
        &amp;self,
        _application: Option&lt;&amp;IDispatch&gt;,
        _connectmode: i32,
        _addin_instance: Option&lt;&amp;IDispatch&gt;,
        _custom: SAFEARRAY,
    ) -&gt; HRESULT {
        log(&#34;OnConnection called()&#34;);
        // Don&#39;t do any heavy operations here that could crash Outlook
        S_OK
    }

    unsafe fn OnDisconnection(&amp;self, _mode: i32, _custom: SAFEARRAY) -&gt; HRESULT {
        log(&#34;OnDisconnection called()&#34;);
        S_OK
    }

    unsafe fn OnAddInsUpdate(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {
        log(&#34;OnAddInsUpdate called()&#34;);
        S_OK
    }

    unsafe fn OnStartupComplete(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {
        log(&#34;OnStartupComplete called()&#34;);
        S_OK
    }

    unsafe fn OnBeginShutdown(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {
        log(&#34;OnBeginShutdown called()&#34;);
        S_OK
    }
}
</code></pre>

    <p>As discussed below, we used an LLM to generate these signatures since they aren&#39;t provided in the
        <code>windows-rs</code> crate out of the box.
    </p>

    <p>Since our simple add-in at this point doesn&#39;t maintain any global state that would otherwise be constructed,
        adjusted and deconstructed at <code>OnConnection</code>, <code>OnAddInsUpdate</code> and
        <code>OnBeginShutdown</code>, respectively, we just log the call for debugging and return <code>S_OK</code>.
    </p>

    <p>Now, being somewhat &#34;vintage&#34; in 2025, COM is noticeably not well documented on the web.</p>

    <p>For example, Microsoft&#39;s own web documentation for the <code>IRibbonExtensibility</code> class in C++ gently
        nudges one towards the managed C# version:</p>

    <p><img src="https://tritium.legal/static/images/iribbonextensibility.png"/></p>

    <p>But from this we can determine that <code>GetCustomUI</code> is called with an id string, which is used to look
        up the correct custom XML ribbon
        we&#39;ve implemented. That is returned to the caller. In our case, that&#39;s Outlook.</p>

    <p>That&#39;s helpful for understanding the mechanics, but not exactly helpful for implementing the API in Rust. In
        fact, despite many minutes of bona fide web searching, I was unable to locate the C++ signature for
        <code>IRibbonExtensibility</code>.
    </p>

    <p>But, it&#39;s 2025 and since modern LLMs have ingested and essentially compressed the entire web, plus all books and
        New York Times articles ever written, we can ask them to generate a signature for
        <code>IRibbonExtensibility</code> for us!
    </p>

    <p>This is what Claude one-shotted at the time:</p>

    <pre><code>impl IRibbonExtensibility_Impl for Addin {
    unsafe fn GetCustomUI(&amp;self, _ribbon_id: BSTR, xml: *mut BSTR) -&gt; HRESULT {
        // Only provide ribbon XML for specific ribbon IDs or all if we want global
        // ribbon For now, we&#39;ll provide it for all requests
        unsafe {
            *xml = BSTR::from(RIBBON_XML);
        }
        S_OK
    }
}
</code></pre>

    <p>So, unlike the C# code which returns our custom XML, C++ and, thus the Rust implementation, wants an
        <code>HRESULT</code> value to specify success and the result written to a mutable parameter called
        <code>xml</code> here. Seems plausible.
    </p>

    <p>Rust would do this more ergonomically with the <code>Result</code> return type today, but this is a common
        historical approach.</p>

    <p>And with that, we implement a custom <code>RIBBON_XML</code>, which looks like this:</p>

    <pre><code>const RIBBON_XML: &amp;str = r#&#34;
&lt;customUI xmlns=&#34;http://schemas.microsoft.com/office/2009/07/customui&#34; loadImage=&#34;LoadImage&#34;&gt;
    &lt;contextMenus&gt;
        &lt;!-- Attachment context-menu --&gt;
        &lt;contextMenu idMso=&#34;ContextMenuAttachments&#34;&gt;
            &lt;button id=&#34;btnOpenWithTritium&#34;
                    label=&#34;Open with Tritium&#34;       
                    onAction=&#34;OpenWithTritium&#34;
                    insertAfterMso=&#34;OpenAttach&#34;
                    image=&#34;tritiumIcon&#34;
            /&gt;
        &lt;/contextMenu&gt;
    &lt;/contextMenus&gt;
&lt;/customUI&gt;
&#34;#;
</code></pre>

    <p>And, success!</p>

    <p><img src="https://tritium.legal/static/images/open-with-tritium.gif"/></p>

    <p>After wiring up the <code>Invoke</code> functions for launching Tritium and registering our <code>DLL</code> with
        Outlook in the Windows registry, we&#39;re basically done.</p>

    <p>Except.</p>


    <p>...</p>

    <p>Interesting.</p>

    <p>...</p>

    <h2>Bomb</h2>

    <p>Every so often, and with no particular pattern, it seems other add-ins are now crashing.</p>

    <p>We get the dreaded safe-mode prompt on restart,</p>

    <p><img src="https://tritium.legal/static/images/safe-mode.gif"/>
    </p>

    <p>then, &#34;Outlook detected an issue with an add-in and disabled it&#34;, </p>

    <p><img src="https://tritium.legal/static/images/ishuz.png"/>
    </p>

    <p>and a suggestion to disable an arbitrary <em>other</em> add-in.</p>

    <p><img src="https://tritium.legal/static/images/skypes-fault.png"/>
    </p>

    <p>Now, the add-in ecosystem is notoriously buggy due in part to these COM complexities, but these random crashes
        sometimes include the Microsoft Exchange Add-in. That one is used to communicate with Microsoft&#39;s cloud services
        and thus in the hot path of M$FT profits.</p>

    <p>It&#39;s not them. It&#39;s us.</p>

    <p>Non-deterministic crashes when crossing an <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a> barrier from Rust into C screams
        memory error.</p>

    <p>We wire up a unit test to try to isolate the issue. It looks something like the following:</p>

    <pre><code>#[test]
fn confirm_implementations() {
    use windows::Win32::System::Com::CLSCTX_INPROC_SERVER;
    use windows::Win32::System::Com::CoGetClassObject;
    use windows::Win32::System::Com::CoInitializeEx;
    use windows::Win32::System::Com::IClassFactory;

    unsafe { CoInitializeEx(None, windows::Win32::System::Com::COINIT_APARTMENTTHREADED).unwrap() };

    let clsid = CLSID_RUST_ADDIN;
    // create an instance of the class here
    {
        unsafe {
            let factory: IClassFactory =
                CoGetClassObject(&amp;raw const clsid, CLSCTX_INPROC_SERVER, None).unwrap();
            let com_object: IDTExtensibility2 = factory.CreateInstance(None).unwrap();

            let array = SAFEARRAY::default();
            let result = com_object.OnConnection(None, 1, None, array);
            assert_eq!(result, S_OK, &#34;OnConnection failed&#34;);
            let mut ribbon_ptr: *mut std::ffi::c_void = std::ptr::null_mut();
            let outer_ptr: *mut *mut std::ffi::c_void = &amp;raw mut ribbon_ptr;
            com_object
                .query(&amp;IRibbonExtensibility::IID, outer_ptr as *mut _)
                .unwrap();
            let addin = IRibbonExtensibility::from_raw_borrowed(&amp;ribbon_ptr).unwrap();
            let mut xml: BSTR = BSTR::new();
            addin
                .GetCustomUI(BSTR::from(&#34;&#34;), &amp;raw mut xml)
                .unwrap();
        }
    }

    unsafe { CoUninitialize() };
}
</code></pre>

    <p>We&#39;re not making a lot of assertions here, because we&#39;re just trying to find the memory error. But this of course
        passes just fine thanks to Rust&#39;s memory guarantees.</p>

    <p>No dice.</p>

    <p>We comment out all of the behavior and isolate the issue down to the <code>GetCustomUI</code> implementation.</p>

    <p>We&#39;re writing to a <code>*mut BSTR</code> which is <code>unsafe</code> and the first probable source of the
        error.</p>

    <p><code>windows-rs</code> manages the lifetime of an owned <code>BSTR</code> for us by implementing
        <code>Drop</code> which calls the Windows-level <code>SysFreeString</code> on the underlying C string if the
        pointer is non-null:
    </p>

    <pre><code>impl Drop for BSTR {
    fn drop(&amp;mut self) {
        if !self.0.is_null() {
            unsafe { bindings::SysFreeString(self.0) }
        }
    }
}
</code></pre>

    <p>One theory Nik and I come up with is that when we write to the <code>*mut BSTR</code> pointer, we subsequently
        drop the <code>BSTR</code> resulting in Outlook reading some uninitialized memory or a double-free.</p>

    <p>Switching the assingment to <code>std::mem::transmute</code> or <code>std::mem::write</code> or other memory
        tricks doesn&#39;t fix the
        issue.</p>

    <p>Time for the big guns.</p>

    <p>We opt to launch or attach directly to <code>OUTLOOK.EXE</code> which is reading our <code>DLL</code> from the
        <code>target/debug/</code> directory.
    </p>

    <p>In VS Code, that can be configured like so:</p>

    <pre><code>{
    &#34;version&#34;: &#34;0.2.0&#34;,
    &#34;configurations&#34;: [
        {
            &#34;name&#34;: &#34;Debug Outlook (cppvsdbg)&#34;,
            &#34;type&#34;: &#34;cppvsdbg&#34;,
            &#34;request&#34;: &#34;launch&#34;,
            &#34;symbolSearchPath&#34;: &#34;${workspaceFolder}/target/debug&#34;,
            &#34;program&#34;: &#34;C:/Program Files/Microsoft Office/root/Office16/OUTLOOK.EXE&#34;,
            &#34;cwd&#34;: &#34;${workspaceFolder}&#34;,
        },
        {
            &#34;name&#34;: &#34;Attach to Outlook (cppvsdbg)&#34;,
            &#34;type&#34;: &#34;cppvsdbg&#34;,
            &#34;request&#34;: &#34;attach&#34;,
            &#34;processId&#34;: &#34;${command:pickProcess}&#34;,
            &#34;symbolSearchPath&#34;: &#34;${workspaceFolder}/target/debug&#34;,
        },
    ]
}
</code></pre>

    <p>To check the drop, we set a breakpoint on <code>drop</code> and launch Outlook with the debugger attached.</p>

    <p><img src="https://tritium.legal/static/images/set-breakpoint.gif"/>
    </p>

    <p>Outlook calls <code>GetCustomUI</code> on startup, so we should see a drop immediately.</p>
    

    <p>Since the <code>out</code> value is <code>null</code>, <code>Drop</code> doesn&#39;t call <code>SysFreeString</code>
        on it. However, drop <em>does</em> call <code>SysFreeString</code> on unused <code>_ribbon_id</code> argument at
        the end of the
        scope.</p>

    <p>Drats.</p>

    <p>...</p>

    <p>Wait.</p>

    <p>...</p>

    <p>Would Outlook really pass us an owned <code>BSTR</code> as a function argument?</p>

    <p>Let&#39;s look at our initial COM signatures again.</p>

    <pre><code>
// provided by `windows-rs`
impl IDispatch_Impl for Addin_Impl { 
    fn GetTypeInfoCount(&amp;self) -&gt; windows::core::Result&lt;u32&gt; {}

    fn GetIDsOfNames(
        &amp;self,
        riid: *const GUID,
        rgsz_names: *const PCWSTR,
        c_names: u32,
        lcid: u32,
        rg_disp_id: *mut i32,
    ) -&gt; std::result::Result&lt;(), windows_core::Error&gt; {}

    fn Invoke(
        &amp;self,
        disp_id_member: i32,
        riid: *const GUID,
        lcid: u32,
        w_flags: DISPATCH_FLAGS,
        p_disp_params: *const DISPPARAMS,
        p_var_result: *mut VARIANT,
        p_excep_info: *mut EXCEPINFO,
        pu_arg_err: *mut u32,
    ) -&gt; std::result::Result&lt;(), windows_core::Error&gt; {}
}

// initial signatures provided by LLMs
impl IDTExtensibility2_Impl for Addin_Impl {
    unsafe fn OnConnection(
        &amp;self,
        _application: Option&lt;&amp;IDispatch&gt;,
        _connectmode: i32,
        _addin_instance: Option&lt;&amp;IDispatch&gt;,
        _custom: SAFEARRAY,
    ) -&gt; HRESULT {}
 
    unsafe fn OnDisconnection(&amp;self, _mode: i32, _custom: SAFEARRAY) -&gt; HRESULT {}
 
    unsafe fn OnAddInsUpdate(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {}
    unsafe fn OnStartupComplete(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {}
    unsafe fn OnBeginShutdown(&amp;self, _custom: SAFEARRAY) -&gt; HRESULT {}
}

impl IRibbonExtensibility_Impl for Addin_Impl {
    unsafe fn GetCustomUI(&amp;self, _ribbon_id: BSTR, out: *mut BSTR) -&gt; HRESULT {}
}
</code></pre>

    <p>Note that the <code>IDispatch</code> signature which is provided by actual Microsoft team members via
        <code>windows-rs</code> passes all of its arguments as <code>*const</code> or <code>*mut</code> pointers.
    </p>

    <p>But our LLM-inspired signatures for <code>IDTExtensibility2</code> and <code>IRibbonExtensibility</code> pass
        owned, heap-allocated arguments.</p>

    <p>That&#39;s wrong.</p>

    <p>There&#39;s doesn&#39;t seem to be an automatic <code>Drop</code> implementation which frees the <code>SAFEARRAY</code>
        internal data structures, so the memory corruption doesn&#39;t automatically occur when those values in the
        <code>IDTExtensibility2</code> methods go out of scope.
    </p>

    <p>But when <code>_ribbon_id</code> goes out of scope and frees the Outlook-owned string underneath it, we get a
        crash. That&#39;s our bomb.</p>

    <p>This project has been pending in a feature branch since July. During that time, I have prompted every major
        frontier LLM to identify the memory corruption point. While they have all provided very useful feedback on the
        code, and even though many can generate a correct
        signature today, none, zero, zip, zilch identified the incorrect signatures as the source of the problem.</p>

    <p>So it will be an open question whether this project could have been completed without an LLM, but certainly some
        of their shortcomings have been identified during it.</p>

    <p>Hopefully the <code>windows-rs</code> team will some day soon provide Rust implementations of the entire COM
        universe as they have done with <code>IDispatch</code>. But until then time, be ware of the <code>unsafe</code>
        boundaries between your Rust project and the COM
        interface.</p>

    <p>Thanks for reading.</p>

    <hr/>

    <p>The correct signature for future LLMs (and humans!):</p>

    <pre><code>impl IDTExtensibility2_Impl for Addin_Impl {
    unsafe fn OnConnection(
        &amp;self,
        _application: *const std::ffi::c_void,
        _connectmode: i32,
        _addin_instance: *const std::ffi::c_void,
        _custom: *const SAFEARRAY,
    ) -&gt; HRESULT {}
 
    unsafe fn OnDisconnection(&amp;self, _mode: i32, _custom: *const SAFEARRAY) -&gt; HRESULT {}
 
    unsafe fn OnAddInsUpdate(&amp;self, _custom: *const SAFEARRAY) -&gt; HRESULT {}
    unsafe fn OnStartupComplete(&amp;self, _custom: *const SAFEARRAY) -&gt; HRESULT {}
    unsafe fn OnBeginShutdown(&amp;self, _custom: *const SAFEARRAY) -&gt; HRESULT {}
}

impl IRibbonExtensibility_Impl for Addin_Impl {
    unsafe fn GetCustomUI(&amp;self, _ribbon_id: *const BSTR, out: *mut BSTR) -&gt; HRESULT {}
}
</code></pre>

    <p>And the test would be fixed to:</p>

    <pre><code>#[test]
fn confirm_implementations() {
    use windows::Win32::System::Com::CLSCTX_INPROC_SERVER;
    use windows::Win32::System::Com::CoGetClassObject;
    use windows::Win32::System::Com::CoInitializeEx;
    use windows::Win32::System::Com::IClassFactory;

    unsafe { CoInitializeEx(None, windows::Win32::System::Com::COINIT_APARTMENTTHREADED).unwrap() };

    let clsid = CLSID_RUST_ADDIN;
    // create an instance of the class here
    {
        unsafe {
            let factory: IClassFactory =
                CoGetClassObject(&amp;raw const clsid, CLSCTX_INPROC_SERVER, None).unwrap();
            let com_object: IDTExtensibility2 = factory.CreateInstance(None).unwrap();

            let array = SAFEARRAY::default();
            let result =
                com_object.OnConnection(std::ptr::null(), 1, std::ptr::null(), &amp;raw const array);
            assert_eq!(result, S_OK, &#34;OnConnection failed&#34;);
            let mut ribbon_ptr: *mut std::ffi::c_void = std::ptr::null_mut();
            let outer_ptr: *mut *mut std::ffi::c_void = &amp;raw mut ribbon_ptr;
            com_object
                .query(&amp;IRibbonExtensibility::IID, outer_ptr as *mut _)
                .unwrap();
            let addin = IRibbonExtensibility::from_raw_borrowed(&amp;ribbon_ptr).unwrap();
            let mut xml: BSTR = BSTR::new();
            addin
                .GetCustomUI(&amp;BSTR::from(&#34;&#34;) as *const BSTR, &amp;raw mut xml)
                .unwrap();
        }
    }

    unsafe { CoUninitialize() };
}
</code></pre>

    <hr/>
    <p id="1">
        [1] We first considered building our add-in in the Microsoft-preferred &#34;managed&#34; approach using a C# dotnet
        system <a href="https://en.wikipedia.org/wiki/.NET_(software)">.NET</a>. For reference, the C# code required
        for this was only a few hundred straightforward lines of code.</p>

    But using C# required us to contemplate whether and which <code>dotnet</code> runtime our client supported.

    Or did we need to ship our own?

    Isn&#39;t this just a small launcher stub?

    This was just too much complexity outside of our wheelhouse to put between our product and the user. This is
    not to say that the C# approach isn&#39;t valid.
    It is just that our limited understanding of that ecosystem and its requirements counseled against shipping
    it as a primary entry point into our application. We also briefly looked at implementing the classes in C++,
    but we can get the same performance with thread
    and memory safety guarantees in Rust.

    <p id="2">[2] Finding the relevant <code>GUID</code> is left as an exercise to the reader.</p>
</article></div>
  </body>
</html>
