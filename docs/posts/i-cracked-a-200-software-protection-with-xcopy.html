<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ud2.rip/blog/enigma-protector/">Original</a>
    <h1>I cracked a $200 software protection with xcopy</h1>
    
    <div id="readability-page-1" class="page"><div><div><p><strong>disclaimer:</strong> this is educational security research only. i do not condone piracy. i purchased a legitimate license for this software and conducted this analysis on my own property. this writeup exists to document protection implementation flaws, not to enable theft. support developers - buy their software.</p>
<p><strong>github repo:</strong> <a href="https://github.com/vmfunc/enigma">vmfunc/enigma</a></p>
<h2 id="tldr">tl;dr</h2>
<p>i spent a day analyzing <a href="https://enigmaprotector.com/">enigma protector</a> - a $200 commercial software protection system used by thousands of vendors. RSA cryptographic signatures, hardware-bound licensing, anti-debugging, VM-based code obfuscation. serious enterprise security theater.</p>
<p>then i noticed the protected installer extracts a completely unprotected payload to disk.</p>
<pre tabindex="0"><code><span><span>xcopy</span><span> /E</span><span> &#34;C:\Program Files\...\product&#34;</span><span> .</span><span>\c</span><span>rack</span><span>\</span></span></code></pre>
<p>that’s the entire crack. copy the installed files. they run on any machine. no keygen needed, no binary patching, no cryptanalysis.</p>
<p><strong>$200 protection defeated by a command that shipped with DOS 3.2 in 1986.</strong></p>
<p>this is a case study in why threat modeling matters more than fancy cryptography, and why “military-grade encryption” means nothing when you leave the back door wide open.</p>
<hr/>
<h2 id="target-overview">target overview</h2>
<p><img src="https://www.ud2.rip/images/enigma/bassbully.png" alt="Bass Bully Premium VST3 - Landing Page Screenshot"/></p><p><strong>bass bully premium</strong> - a VST3 synthesizer plugin. protected by <strong><a href="https://enigmaprotector.com/">enigma protector</a></strong>, a commercial software protection system that costs <a href="https://enigmaprotector.com/en/order.html">$250+</a> and promises serious security.</p>
<p>from their marketing:</p>
<blockquote>
<p>“Enigma Protector is a powerful tool designed to protect executable files from illegal copying, hacking, modification and analysis.”</p>
</blockquote>
<p>we’ll see about that.</p>
<p>we have one known valid license:</p>
<pre tabindex="0"><code><span><span>Key:  GLUJ-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-V99KP3</span></span>
<span><span>HWID: 3148CC-XXXXXX</span></span>
<span><span>Name: Bass Bully</span></span></code></pre>
<p>our goal: understand the protection and build a proper crack</p>
<hr/>
<h2 id="static-analysis">static analysis</h2>

<p>first, let’s look at what we’re dealing with:</p>
<pre tabindex="0"><code><span><span>import</span><span> pefile</span></span>
<span></span>
<span><span>pe </span><span>=</span><span> pefile.PE(</span><span>r</span><span>&#34;</span><span>Bass Bully Premium_Installer_win64</span><span>.</span><span>exe</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>print</span><span>(</span><span>f</span><span>&#34;Machine:     </span><span>{</span><span>&#39;x64&#39;</span><span> if</span><span> pe.</span><span>FILE_HEADER</span><span>.Machine </span><span>==</span><span> 0x</span><span>8664</span><span> else</span><span> &#39;x86&#39;</span><span>}</span><span>&#34;</span><span>)</span></span>
<span><span>print</span><span>(</span><span>f</span><span>&#34;Sections:    </span><span>{</span><span>pe.</span><span>FILE_HEADER</span><span>.NumberOfSections</span><span>}</span><span>&#34;</span><span>)</span></span>
<span><span>print</span><span>(</span><span>f</span><span>&#34;Entry Point: 0x</span><span>{</span><span>pe.</span><span>OPTIONAL_HEADER</span><span>.AddressOfEntryPoint</span><span>:X</span><span>}</span><span>&#34;</span><span>)</span></span>
<span><span>print</span><span>(</span><span>f</span><span>&#34;Image Base:  0x</span><span>{</span><span>pe.</span><span>OPTIONAL_HEADER</span><span>.ImageBase</span><span>:X</span><span>}</span><span>&#34;</span><span>)</span></span></code></pre>
<pre tabindex="0"><code><span><span>Machine:     x64</span></span>
<span><span>Sections:    9</span></span>
<span><span>Entry Point: 0x16485D0</span></span>
<span><span>Image Base:  0x140000000</span></span></code></pre>
<p>that entry point is suspicious. <code>0x16485D0</code> is way into the binary.. typical of packed executables where the real entry point is hidden. normal programs start around <code>0x1000</code>.</p>
<h3 id="string-hunting">string hunting</h3>
<pre tabindex="0"><code><span><span>with</span><span> open</span><span>(pe_path, </span><span>&#39;rb&#39;</span><span>) </span><span>as</span><span> f:</span></span>
<span><span>    data </span><span>=</span><span> f.read()</span></span>
<span></span>
<span><span>for</span><span> target </span><span>in</span><span> [</span><span>b</span><span>&#39;Enigma Protector&#39;</span><span>, </span><span>b</span><span>&#39;enigmaprotector&#39;</span><span>]:</span></span>
<span><span>    offset </span><span>=</span><span> 0</span></span>
<span><span>    while</span><span> (idx </span><span>:=</span><span> data.find(target, offset)) </span><span>!=</span><span> -</span><span>1</span><span>:</span></span>
<span><span>        print</span><span>(</span><span>f</span><span>&#34;0x</span><span>{</span><span>idx</span><span>:08X</span><span>}</span><span>: </span><span>{</span><span>target.decode()</span><span>}</span><span>&#34;</span><span>)</span></span>
<span><span>        offset </span><span>=</span><span> idx </span><span>+</span><span> 1</span></span></code></pre>
<pre tabindex="0"><code><span><span>0x0040972B: Enigma Protector</span></span>
<span><span>0x00409746: Enigma Protector</span></span>
<span><span>0x00409786: Enigma Protector</span></span>
<span><span>0x00409BA8: Enigma Protector</span></span>
<span><span>0x00409BC3: Enigma Protector</span></span>
<span><span>0x0040A038: Enigma Protector</span></span>
<span><span>0x0040A053: Enigma Protector</span></span>
<span><span>0x004099BF: enigmaprotector</span></span>
<span><span>0x00409DDA: enigmaprotector</span></span></code></pre>
<p><strong>confirmed: enigma protector.</strong> now we know what we’re dealing with.</p>
<h3 id="what-about-the-network">what about the network?</h3>
<p>does this even phone home..?</p>
<pre tabindex="0"><code><span><span>imports </span><span>=</span><span> [entry.dll.decode() </span><span>for</span><span> entry </span><span>in</span><span> pe.</span><span>DIRECTORY_ENTRY_IMPORT</span><span>]</span></span></code></pre>
<pre tabindex="0"><code><span><span>kernel32.dll, user32.dll, advapi32.dll, oleaut32.dll, gdi32.dll,</span></span>
<span><span>shell32.dll, version.dll, ole32.dll, COMDLG32.dll, MSVCP140.dll, ...</span></span></code></pre>
<p>no <code>winhttp.dll</code>, <code>wininet.dll</code>, or <code>ws2_32.dll</code>. <strong>offline validation only.</strong> all crypto is local, so theoretically extractable.</p>
<p>this is good news!! online validation would require MITM or server emulation. offline means everything we need is in the binary.</p>
<hr/>
<h2 id="the-enigma-protector-internals">the enigma protector internals</h2>
<p>enigma protector is a commercial protection system that provides:</p>
<ol>
<li><strong>code virtualization</strong> - transforms x86/x64 into proprietary VM bytecode</li>
<li><strong>anti-debugging</strong> - <code>IsDebuggerPresent</code>, timing checks, hardware BP detection</li>
<li><strong>anti-tampering</strong> - CRC checks on packed sections</li>
<li><strong>registration API</strong> - HWID-bound licensing with RSA signatures</li>
</ol>
<p>you can read about all these features on their <a href="https://enigmaprotector.com/en/help.html">documentation page</a>. they’re pretty thorough about explaining what they protect against. they just didn’t think someone would… not use it on the payload.</p>
<p><img src="https://www.ud2.rip/images/enigma/figure_1.png" alt="The Enigma Protection and motivation for buying - diagram showing protection levels"/></p><h3 id="the-registration-api">the registration API</h3>
<p>according to enigma’s SDK, these functions are exposed:</p>
<pre tabindex="0"><code><span><span>int</span><span> EP_RegCheckKey</span><span>(</span><span>const</span><span> char*</span><span> name</span><span>, </span><span>const</span><span> char*</span><span> key</span><span>);</span></span>
<span><span>const</span><span> char*</span><span> EP_RegHardwareID</span><span>(</span><span>void</span><span>);</span></span>
<span><span>void</span><span> EP_RegSaveKey</span><span>(</span><span>const</span><span> char*</span><span> name</span><span>, </span><span>const</span><span> char*</span><span> key</span><span>);</span></span>
<span><span>void</span><span> EP_RegLoadKey</span><span>(</span><span>char*</span><span> name</span><span>, </span><span>char*</span><span> key</span><span>);</span></span></code></pre>
<p><strong>these aren’t normal exports</strong>; they’re resolved dynamically after enigma unpacks itself. you can’t just <code>GetProcAddress</code> them from outside. you have to either:</p>
<ul>
<li>hook them at runtime after unpacking</li>
<li>pattern scan the unpacked memory</li>
<li>be an absolute clown and just not use them in your payload (definitely not foreshadowing)</li>
</ul>
<h3 id="the-entry-point">the entry point</h3>
<p>using <a href="https://www.capstone-engine.org/">capstone</a> to disassemble the entry point:</p>
<pre tabindex="0"><code><span><span>from</span><span> capstone </span><span>import</span><span> Cs, </span><span>CS_ARCH_X86</span><span>, </span><span>CS_MODE_64</span></span>
<span></span>
<span><span>entry_rva </span><span>=</span><span> pe.</span><span>OPTIONAL_HEADER</span><span>.AddressOfEntryPoint</span></span>
<span><span>entry_offset </span><span>=</span><span> pe.get_offset_from_rva(entry_rva)</span></span>
<span></span>
<span><span>with</span><span> open</span><span>(pe_path, </span><span>&#39;rb&#39;</span><span>) </span><span>as</span><span> f:</span></span>
<span><span>    f.seek(entry_offset)</span></span>
<span><span>    code </span><span>=</span><span> f.read(</span><span>64</span><span>)</span></span>
<span></span>
<span><span>md </span><span>=</span><span> Cs(</span><span>CS_ARCH_X86</span><span>, </span><span>CS_MODE_64</span><span>)</span></span>
<span><span>base </span><span>=</span><span> pe.</span><span>OPTIONAL_HEADER</span><span>.ImageBase </span><span>+</span><span> entry_rva</span></span>
<span></span>
<span><span>for</span><span> insn </span><span>in</span><span> md.disasm(code, base):</span></span>
<span><span>    print</span><span>(</span><span>f</span><span>&#34;0x</span><span>{</span><span>insn.address</span><span>:X</span><span>}</span><span>: </span><span>{</span><span>insn.mnemonic</span><span>:8</span><span>}</span><span> {</span><span>insn.op_str</span><span>}</span><span>&#34;</span><span>)</span></span></code></pre>
<pre tabindex="0"><code><span><span>0x1416485D0</span><span>: </span><span>jmp</span><span>      0x1416485da</span><span>      ; skip garbage bytes</span></span>
<span><span>0x1416485D2</span><span>: </span><span>add</span><span>      byte</span><span> ptr [</span><span>rsi</span><span> + </span><span>0x40</span><span>], </span><span>dl</span></span>
<span><span>0x1416485D8</span><span>: </span><span>add</span><span>      byte</span><span> ptr [</span><span>rax</span><span>], </span><span>al</span></span>
<span><span>0x1416485DA</span><span>: </span><span>push</span><span>     rax</span><span>              ; real code starts here</span></span>
<span><span>0x1416485DB</span><span>: </span><span>push</span><span>     rcx</span></span>
<span><span>0x1416485DC</span><span>: </span><span>push</span><span>     rdx</span></span>
<span><span>0x1416485DD</span><span>: </span><span>push</span><span>     rbx</span></span>
<span><span>0x1416485DE</span><span>: </span><span>push</span><span>     rbp</span></span>
<span><span>0x1416485DF</span><span>: </span><span>push</span><span>     rsi</span></span>
<span><span>0x1416485E0</span><span>: </span><span>push</span><span>     rdi</span></span>
<span><span>0x1416485E1</span><span>: </span><span>push</span><span>     r8</span></span>
<span><span>0x1416485E3</span><span>: </span><span>push</span><span>     r9</span></span></code></pre>
<p>the jmp-over-garbage pattern is classic anti-disassembly. linear disassemblers will try to decode the garbage bytes between <code>jmp</code> and its target, producing nonsense. the real unpacker starts at <code>0x1416485DA</code> with a standard register preservation sequence before calling the enigma loader.</p>
<hr/>
<h2 id="phase-3-key-format-analysis">phase 3: key format analysis</h2>
<p>we have a known valid key. let’s understand its structure before we try to break it.</p>
<pre tabindex="0"><code><span><span>GLUJ-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX-V99KP3</span></span></code></pre>
<h3 id="structure-breakdown">structure breakdown</h3>
<ul>
<li>8 groups separated by dashes</li>
<li>groups 0-6: 4 characters each</li>
<li>group 7: 6 characters (larger - likely checksum/signature)</li>
<li>character set: 0-9, A-Z (base36)</li>
</ul>
<h3 id="base36-decoding">base36 decoding</h3>
<pre tabindex="0"><code><span><span>key </span><span>=</span><span> &#34;GLUJ-QE58-U3Z4-RQTJ-K7GJ-JXZ5-CVK5-V99KP3&#34;</span></span>
<span><span>groups </span><span>=</span><span> key.split(</span><span>&#39;-&#39;</span><span>)</span></span>
<span></span>
<span><span>for</span><span> i, group </span><span>in</span><span> enumerate</span><span>(groups):</span></span>
<span><span>    val </span><span>=</span><span> int</span><span>(group, </span><span>36</span><span>)</span></span>
<span><span>    bits </span><span>=</span><span> val.bit_length()</span></span>
<span><span>    print</span><span>(</span><span>f</span><span>&#34;[</span><span>{</span><span>i</span><span>}</span><span>] </span><span>{</span><span>group</span><span>:6</span><span>}</span><span> = </span><span>{</span><span>val</span><span>:10</span><span>}</span><span> (0x</span><span>{</span><span>val</span><span>:08X</span><span>}</span><span>) </span><span>{</span><span>bits</span><span>:2</span><span>}</span><span> bits&#34;</span><span>)</span></span></code></pre>
<pre tabindex="0"><code><span><span>[0] GLUJ   =     774811 (0x000BD29B) 20 bits</span></span>
<span><span>[1] QE58   =    1231388 (0x0012CA1C) 21 bits</span></span>
<span><span>[2] U3Z4   =    1404832 (0x00156FA0) 21 bits</span></span>
<span><span>[3] RQTJ   =    1294471 (0x0013C087) 21 bits</span></span>
<span><span>[4] K7GJ   =     942787 (0x000E62C3) 20 bits</span></span>
<span><span>[5] JXZ5   =     930497 (0x000E32C1) 20 bits</span></span>
<span><span>[6] CVK5   =     600773 (0x00092AC5) 20 bits</span></span>
<span><span>[7] V99KP3 = 1890014727 (0x70A75607) 31 bits  &lt;- significantly larger</span></span></code></pre>
<p>interesting. group 7 is way bigger than the others. that’s probably a truncated cryptographic signature.</p>
<h3 id="cryptographic-structure">cryptographic structure</h3>
<p>the key structure appears to be:</p>
<pre tabindex="0"><code><span><span>[    DATA: ~143 bits     ] [ SIGNATURE: 31 bits ]</span></span>
<span><span> Groups 0-6 (7 x ~20 bits)   Group 7 (truncated)</span></span></code></pre>
<p>enigma uses RSA for signing. the full signature would be much larger, but they truncate it to fit the key format. this means:</p>
<ol>
<li>public key is embedded in the protected binary</li>
<li>key validation = RSA signature verification</li>
<li>keygen would require extracting and factoring the RSA modulus</li>
</ol>
<p>RSA with small key sizes is <a href="https://en.wikipedia.org/wiki/RSA_numbers#RSA-155">technically factorable</a> with enough compute. but that’s a lot of work for… well, you’ll see.</p>
<h3 id="hwid-format">HWID format</h3>
<pre tabindex="0"><code><span><span>hwid </span><span>=</span><span> &#34;3148CC-059521&#34;</span></span>
<span><span>parts </span><span>=</span><span> hwid.split(</span><span>&#39;-&#39;</span><span>)</span></span>
<span><span># Two 24-bit values = 48 bits total hardware fingerprint</span></span></code></pre>
<p>HWID is derived from hardware characteristics (CPU ID, disk serial, MAC address, etc). the key is cryptographically bound to this value, so a key generated for one machine won’t work on another.</p>
<p>this is actually decent protection! if they used it properly! (they didn’t lmao)</p>
<hr/>
<h2 id="the-pivot">the pivot</h2>
<p>at this point i’m preparing to either factor the RSA key or do runtime hooking to bypass validation. then i thought: wait, what are we actually protecting here?</p>
<p>let me just check the installed VST real quick…</p>
<h3 id="analyzing-the-installed-vst">analyzing the installed VST</h3>
<pre tabindex="0"><code><span><span>vst_path </span><span>=</span><span> r</span><span>&#34;</span><span>C:</span><span>\P</span><span>rogram Files</span><span>\C</span><span>ommon Files</span><span>\V</span><span>ST3</span><span>\B</span><span>ass Bully VST</span><span>\B</span><span>ass Bully Premium</span><span>.</span><span>vst3</span><span>&#34;</span></span>
<span><span>vst_dll </span><span>=</span><span> vst_path </span><span>+</span><span> r</span><span>&#34;</span><span>\C</span><span>ontents</span><span>\x86</span><span>_64-win</span><span>\B</span><span>ass Bully Premium</span><span>.</span><span>vst3</span><span>&#34;</span></span>
<span><span>pe_vst </span><span>=</span><span> pefile.PE(vst_dll)</span></span>
<span></span>
<span><span>print</span><span>(</span><span>f</span><span>&#34;Size: </span><span>{</span><span>os.path.getsize(vst_dll)</span><span>:,</span><span>}</span><span> bytes&#34;</span><span>)</span></span>
<span><span>print</span><span>(</span><span>&#34;Imports:&#34;</span><span>)</span></span>
<span><span>for</span><span> entry </span><span>in</span><span> pe_vst.</span><span>DIRECTORY_ENTRY_IMPORT</span><span>:</span></span>
<span><span>    print</span><span>(</span><span>f</span><span>&#34;  </span><span>{</span><span>entry.dll.decode()</span><span>}</span><span>&#34;</span><span>)</span></span></code></pre>
<pre tabindex="0"><code><span><span>Size: 7,092,736 bytes</span></span>
<span><span>Imports:</span></span>
<span><span>  KERNEL32.dll</span></span>
<span><span>  USER32.dll</span></span>
<span><span>  GDI32.dll</span></span>
<span><span>  SHELL32.dll</span></span>
<span><span>  ole32.dll</span></span>
<span><span>  OLEAUT32.dll</span></span>
<span><span>  MSVCP140.dll</span></span>
<span><span>  WINMM.dll</span></span>
<span><span>  IMM32.dll</span></span>
<span><span>  dxgi.dll</span></span>
<span><span>  VCRUNTIME140.dll</span></span>
<span><span>  VCRUNTIME140_1.dll</span></span>
<span><span>  api-ms-win-crt-runtime-l1-1-0.dll</span></span>
<span><span>  ...</span></span></code></pre>
<p>wait. where are the enigma imports?</p>
<h3 id="hunting-for-protection">hunting for protection</h3>
<pre tabindex="0"><code><span><span>with</span><span> open</span><span>(vst_dll, </span><span>&#39;rb&#39;</span><span>) </span><span>as</span><span> f:</span></span>
<span><span>    data </span><span>=</span><span> f.read()</span></span>
<span></span>
<span><span>for</span><span> term </span><span>in</span><span> [</span><span>b</span><span>&#39;Enigma&#39;</span><span>, </span><span>b</span><span>&#39;EP_Reg&#39;</span><span>, </span><span>b</span><span>&#39;Registration&#39;</span><span>, </span><span>b</span><span>&#39;HWID&#39;</span><span>, </span><span>b</span><span>&#39;enigma&#39;</span><span>]:</span></span>
<span><span>    count </span><span>=</span><span> data.count(term)</span></span>
<span><span>    print</span><span>(</span><span>f</span><span>&#34;</span><span>{</span><span>term.decode()</span><span>:15</span><span>}</span><span> : </span><span>{</span><span>count</span><span>}</span><span> occurrences&#34;</span><span>)</span></span></code></pre>
<pre tabindex="0"><code><span><span>Enigma          : 0 occurrences</span></span>
<span><span>EP_Reg          : 0 occurrences</span></span>
<span><span>Registration    : 0 occurrences</span></span>
<span><span>HWID            : 0 occurrences</span></span>
<span><span>enigma          : 0 occurrences</span></span></code></pre>
<p><strong>zero.</strong></p>
<p>hold on.</p>
<pre tabindex="0"><code><span><span>$</span><span> strings</span><span> &#34;Bass Bully Premium.vst3&#34;</span><span> |</span><span> grep</span><span> -i</span><span> enigma</span></span>
<span><span>$</span><span> strings</span><span> &#34;Bass Bully Premium.vst3&#34;</span><span> |</span><span> grep</span><span> -i</span><span> regist</span></span></code></pre>
<p>nothing. no output… ?????????</p>
<p>you have got to be kidding me.</p>
<p><strong>the VST has absolutely no protection.</strong> it’s a clean <a href="https://juce.com/">JUCE framework</a> build. no enigma runtime. no license callbacks. no protection whatsoever.</p>
<p>they protected the installer. not the payload. THE INSTALLER. NOT THE ACTUAL PRODUCT.</p>
<p>i can’t even be mad. this is genuinely hilarious.</p>
<hr/>
<h2 id="the-vulnerability">the vulnerability</h2>
<p>here’s what’s happening:</p>
<pre tabindex="0"><code><span><span>+-------------------------------------------------------------------+</span></span>
<span><span>|                    ENIGMA PROTECTOR                               |</span></span>
<span><span>|  +--------------------------------------------------------------+ |</span></span>
<span><span>|  |  Installer.exe                                               | |</span></span>
<span><span>|  |  [x] RSA key verification                                    | |</span></span>
<span><span>|  |  [x] HWID binding                                            | |</span></span>
<span><span>|  |  [x] Anti-debug, anti-tamper                                 | |</span></span>
<span><span>|  |  [x] Code virtualization                                     | |</span></span>
<span><span>|  |                        |                                     | |</span></span>
<span><span>|  |                        v                                     | |</span></span>
<span><span>|  |  +--------------------------------------------------------+  | |</span></span>
<span><span>|  |  |  Payload (extracted on install)                        |  | |</span></span>
<span><span>|  |  |  - Bass Bully Premium.vst3  &lt;- ZERO PROTECTION lol     |  | |</span></span>
<span><span>|  |  |  - Bass Bully Premium.rom   &lt;- NOT EVEN ENCRYPTED      |  | |</span></span>
<span><span>|  |  +--------------------------------------------------------+  | |</span></span>
<span><span>|  +--------------------------------------------------------------+ |</span></span>
<span><span>+-------------------------------------------------------------------+</span></span></code></pre>
<p>the entire protection stack only controls whether the <strong>installer</strong> runs. once files hit disk, the protection is basically useless.</p>
<p>this is like putting a vault door on a tent.</p>
<h3 id="what-they-should-have-done">what they should have done</h3>
<p>enigma would have been effective if the VST itself checked the license:</p>
<pre tabindex="0"><code><span><span>bool</span><span> VST_Init</span><span>() {</span></span>
<span><span>    char</span><span> key[</span><span>256</span><span>], name[</span><span>256</span><span>];</span></span>
<span><span>    EP_RegLoadKey</span><span>(name, key);</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>!</span><span>EP_RegCheckKey</span><span>(name, key)) {</span></span>
<span><span>        ShowTrialNag</span><span>();</span></span>
<span><span>        return</span><span> false</span><span>;</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    CreateThread</span><span>(</span><span>NULL</span><span>, </span><span>0</span><span>, LicenseWatchdog, </span><span>NULL</span><span>, </span><span>0</span><span>, </span><span>NULL</span><span>);</span></span>
<span><span>    return</span><span> true</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>instead, the VST has no <code>EP_Reg*</code> calls. no license checks. no callbacks. nothing. it just… runs.</p>
<hr/>
<h2 id="the-crack">the crack</h2>
<p>the crack is embarrassingly simple. i spent hours analyzing RSA key formats for this…</p>
<h3 id="the-very-sophisticated-exploit">the very sophisticated exploit</h3>
<pre tabindex="0"><code><span><span>xcopy</span><span> /E</span><span> &#34;C:\Program Files\Common Files\VST3\Bass Bully VST&#34;</span><span> .</span><span>\c</span><span>rack</span><span>\</span></span>
<span><span>copy </span><span>&#34;C:\ProgramData\Bass Bully VST\Bass Bully Premium\*.rom&#34;</span><span> .</span><span>\c</span><span>rack</span><span>\</span></span></code></pre>
<p>that’s it. that’s the crack. copy the files. they work on any machine because there’s no license check in the actual product.</p>
<p>i wrote a python script to automate it because i have some self-respect:</p>
<pre tabindex="0"><code><span><span>#!/usr/bin/env python3</span></span>
<span><span>import</span><span> shutil</span></span>
<span><span>from</span><span> pathlib </span><span>import</span><span> Path</span></span>
<span></span>
<span><span>VST_SRC</span><span> =</span><span> Path(</span><span>r</span><span>&#34;</span><span>C:</span><span>\P</span><span>rogram Files</span><span>\C</span><span>ommon Files</span><span>\V</span><span>ST3</span><span>\B</span><span>ass Bully VST</span><span>\B</span><span>ass Bully Premium</span><span>.</span><span>vst3</span><span>&#34;</span><span>)</span></span>
<span><span>ROM_SRC</span><span> =</span><span> Path(</span><span>r</span><span>&#34;</span><span>C:</span><span>\P</span><span>rogramData</span><span>\B</span><span>ass Bully VST</span><span>\B</span><span>ass Bully Premium</span><span>\B</span><span>ass Bully Premium</span><span>.</span><span>rom</span><span>&#34;</span><span>)</span></span>
<span></span>
<span><span>def</span><span> extract</span><span>():</span></span>
<span><span>    out </span><span>=</span><span> Path(</span><span>&#34;crack_package&#34;</span><span>)</span></span>
<span><span>    out.mkdir(</span><span>exist_ok</span><span>=</span><span>True</span><span>)</span></span>
<span><span>    shutil.copytree(</span><span>VST_SRC</span><span>, out </span><span>/</span><span> &#34;Bass Bully Premium.vst3&#34;</span><span>, </span><span>dirs_exist_ok</span><span>=</span><span>True</span><span>)</span></span>
<span><span>    shutil.copy2(</span><span>ROM_SRC</span><span>, out </span><span>/</span><span> &#34;Bass Bully Premium.rom&#34;</span><span>)</span></span>
<span><span>    print</span><span>(</span><span>&#34;[+] done&#34;</span><span>)</span></span>
<span></span>
<span><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span><span>    extract()</span></span></code></pre>
<p>usage:</p>
<pre tabindex="0"><code><span><span>python</span><span> patcher.py</span></span></code></pre>
<p>load in fl studio. no registration. no nag. no nothing. because there’s no check.</p>
<hr/>
<h2 id="for-science-the-hook-approach">for science: the hook approach</h2>
<p>we also wrote a DLL that hooks enigma’s validation at runtime. completely unnecessary given the vulnerability, but i’d already done the research so here it is:</p>
<pre tabindex="0"><code><span><span>#include</span><span> &lt;windows.h&gt;</span></span>
<span><span>#include</span><span> &lt;detours.h&gt;</span></span>
<span></span>
<span><span>static</span><span> int</span><span> (WINAPI </span><span>*</span><span>Real_EP_RegCheckKey)(LPCSTR, LPCSTR) </span><span>=</span><span> NULL</span><span>;</span></span>
<span></span>
<span><span>int</span><span> WINAPI </span><span>Hooked_EP_RegCheckKey</span><span>(LPCSTR name, LPCSTR key) {</span></span>
<span><span>    return</span><span> 1</span><span>;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>BOOL APIENTRY </span><span>DllMain</span><span>(HMODULE hModule, DWORD reason, LPVOID lpReserved) {</span></span>
<span><span>    if</span><span> (reason </span><span>==</span><span> DLL_PROCESS_ATTACH) {</span></span>
<span><span>        Sleep</span><span>(</span><span>2000</span><span>);</span></span>
<span><span>        DetourTransactionBegin</span><span>();</span></span>
<span><span>        DetourUpdateThread</span><span>(</span><span>GetCurrentThread</span><span>());</span></span>
<span><span>        DetourAttach</span><span>(</span><span>&amp;</span><span>(PVOID</span><span>&amp;</span><span>)Real_EP_RegCheckKey, Hooked_EP_RegCheckKey);</span></span>
<span><span>        DetourTransactionCommit</span><span>();</span></span>
<span><span>    }</span></span>
<span><span>    return</span><span> TRUE;</span></span>
<span><span>}</span></span></code></pre>
<p>this approach works great. completely unnecessary. the payload has no protection.</p>
<p><img src="https://www.ud2.rip/images/enigma/Screenshot%202025-12-05%20161203.png" alt="Screenshot showing hook approach"/>
<img src="https://www.ud2.rip/images/enigma/Screenshot%202025-12-05%20161209.png" alt="Screenshot showing hook approach result"/></p><hr/>
<h2 id="lessons-learned">lessons learned</h2>
<h3 id="for-developers">for developers</h3>
<ol>
<li>
<p><strong>protect the payload, not the installer</strong> - if users need the installed files to run your software, those files need runtime protection</p>
</li>
<li>
<p><strong>defense in depth</strong> - don’t rely on a single layer. the VST should call <code>EP_RegCheckKey</code> on load</p>
</li>
<li>
<p><strong>threat model correctly</strong> - ask “what happens after installation?” if the answer is “nothing checks the license”, you have a problem</p>
</li>
<li>
<p><strong>periodic validation</strong> - one-time checks are trivially bypassed by file copying</p>
</li>
</ol>
<h3 id="for-reversers">for reversers</h3>
<ol>
<li>
<p><strong>always check the payload first</strong> - before diving into complex crypto, verify what you’re actually protecting</p>
</li>
<li>
<p><strong>the simplest attack wins</strong> - don’t factor RSA when <code>xcopy</code> works</p>
</li>
<li>
<p><strong>protection != security</strong> - expensive protection systems are worthless if applied incorrectly</p>
</li>
<li>
<p><strong>sometimes the crack writes itself</strong> - not every target requires sophisticated techniques</p>
</li>
</ol>
<hr/>
<h2 id="conclusion">conclusion</h2>
<p>enigma protector’s $250 protection was defeated by:</p>
<pre tabindex="0"><code><span><span>xcopy</span><span> /E</span><span> &#34;C:\Program Files\...&#34;</span><span> .</span><span>\c</span><span>rack</span><span>\</span></span></code></pre>
<p>the protection itself works fine - RSA signatures, HWID binding, anti-debug. but it only protects the installer. the payload runs completely unprotected.</p>
<p>250 dollars for a this…</p></div><!--    <div class="pb-6 pt-6 text-sm text-gray-700 text-gray-300">--><!--        <Link href={discussUrl(path)} rel="nofollow">--><!--            Discuss on Twitter--><!--        </Link>--><!--        {` • `}--><!--        <Link href={editUrl(filePath)}>View on GitHub</Link>--><!--    </div>--><!--    {SITE_METADATA.comments && (--><!--            <div--><!--                    class="pb-6 pt-6 text-center text-gray-700 text-gray-300"--><!--                    id="comment"--><!--            >--><!--                <Comments slug={slug}/>--><!--            </div>--><!--    )}--></div></div>
  </body>
</html>
