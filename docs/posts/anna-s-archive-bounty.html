<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timharding.co/blog/annas-archive/">Original</a>
    <h1>Anna&#39;s Archive Bounty</h1>
    
    <div id="readability-page-1" class="page"><div id="app"><div><main><div><article><div><p>On January 15, one of my friends pointed me to a <a href="https://annas-archive.org/blog/all-isbns.html" target="_blank" rel="noreferrer">bounty posting</a> I might be interested in. It comes from Anna&#39;s Archive, an open-source digital library that aims to catalog every book in existence. To guide their archival efforts, they were offering tiered compensation up to $6,000 for improvements to their ISBN visualizer that shows the distribution of books in various collections. That&#39;s a sure sight more than I&#39;m currently making as an #opentowork #newgrad, so I gave it a shot.</p><p>Now that it&#39;s done, you can check out the <a href="https://isbn.timharding.co/" target="_blank" rel="noreferrer">finished product</a> and the <a href="https://github.com/tim-harding/all-isbns" target="_blank" rel="noreferrer">source code</a>. What you&#39;ll find is a Google Maps-style map of ISBNs you can zoom, pan, and explore around in. Let&#39;s dive in.</p><h2 id="vue-and-svelte" tabindex="-1">Vue and Svelte <a href="#vue-and-svelte" aria-label="Permalink to &#34;Vue and Svelte&#34;">​</a></h2><p>One of my subgoals for this project was to try <a href="https://svelte.dev/" target="_blank" rel="noreferrer">Svelte</a>, having seen so many people rave about it. I ended up switching back to <a href="https://vuejs.org/" target="_blank" rel="noreferrer">Vue</a> about halfway through the project out of disappointment.</p><p>The first and biggest issue I couldn&#39;t get around was the tooling. LSPs in Neovim can be a bit fiddly to set up so this could just be skill issues, but after checking and re-checking the <a href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/configs.md#svelte" target="_blank" rel="noreferrer">lspconfig</a> instructions multiple times, I could not get completions working. Auto-formatting and syntax highlighting were also broken. I dealt with this for a while before giving up on a solution.</p><p>Granted, tooling for Vue isn&#39;t perfect either. Volar doesn&#39;t complete component imports in templates, for example, and renaming Vue files doesn&#39;t trigger automatic import updates. I had a difficult time getting Volar working with TypeScript properly as well, and it took multiple sessions of attempts to fully resolve. Part of my reticence to get Svelte working properly comes from knowing how long it already took for Vue. I&#39;m disinclined to go through that hassle twice.</p><p>Both frameworks are very similar overall, with single-file templates and proxy-based reactivity. However, everything that Svelte does, Vue does equally well or better. In particular, Vue reactive primitives greatly outshine Svelte runes. <code>$state</code>, <code>$derived</code>, and <code>$effect</code> simply don&#39;t offer the kind of control and flexibility that Vue does. While you can get by with the equivalent <code>ref</code>, <code>computed</code>, and <code>watchEffect</code>, I regularly find uses for <code>reactive</code>, <code>watch</code>, and <code>shallowRef</code>, with the rest coming in handy for niche situations. Vue also automatically proxys types like <code>Map</code> and <code>Set</code> that I often use, while Svelte supports a much more limited set of types for deep reactivity.</p><p>I ultimately abandoned Svelte because its reactivity wasn&#39;t picking up changes to a sparse array I was using for my image cache. Without the <code>{ deep: true }</code> option of <code>watch</code> to listen to the whole array or a way to bail out with a manual <code>triggerRef</code>, I didn&#39;t see how to handle my case. I guess you could have a <code>$state(false)</code> and toggle it to force updates, but why deal with kludgy things like that? Vue already has great APIs for all kinds of situations. Debugging flakey reactivity isn&#39;t worth whatever simplicity Svelte purportedly has.</p><p>I&#39;ll be sticking with Vue for the foreseeable future. The documentation is great, and tooling is too, aside from the Volar and TypeScript LSPs. It isn&#39;t perfect, but it&#39;s a sure sight better than React or any other framework I&#39;ve tried.</p><h2 id="data-processing" tabindex="-1">Data processing <a href="#data-processing" aria-label="Permalink to &#34;Data processing&#34;">​</a></h2><p>The ISBN data to visualize is a <a href="https://en.wikipedia.org/wiki/Bencode" target="_blank" rel="noreferrer">bencode</a> file that contains the list of ISBNs from each book collection. This needs to be converted into image data for the client. Since I&#39;m using Rust, the first issue is the lack of an existing, functioning bencode crate to work with, so I ended up <a href="https://github.com/tim-harding/bencode-rs" target="_blank" rel="noreferrer">writing one</a> myself using <a href="https://github.com/rust-bakery/nom" target="_blank" rel="noreferrer">nom</a>. Fortunately, the format is pretty easy to parse, so this only took a few hours.</p><p>After decoding the file, I extract the ISBNs into bitsets covering the two billion ISBN range. In this form, the full dataset consumes a little under 4 gigabytes. Clearly we can&#39;t be constantly schlepping that much data to the client on page load, so we need to process the data for on-demand streaming. This has two parts: mipmapping and tiling.</p><p>Mipmapping means storing the image as progressively smaller resolutions and only loading in higher resolutions when zoomed in close enough to see more detail. In this case, we render 7 levels of detail, each at half the resolution of the previous, from 50,000×40,000 down to 781×625.</p><p>Tiling means that we break the image into smaller pieces and only load the ones the user is currently zoomed in on. Each tile is 1,024×1,024. At the smallest mipmap level this is a single tile, and at the largest it comes to 1,960.</p><p>Taken together, mipmapping and tiling greatly reduce the data being sent down on initial load. At first we only send down a few tiles for the fully zoomed-out viewport. As the user zooms and pans around, we request more tiles based on what&#39;s onscreen.</p><p>Since the user will inspect individual ISBNs, using a lossy image format for the biggest mipmap level wasn&#39;t an option, so I serve PNGs instead. Still, since each ISBN is a boolean value of whether it&#39;s present or not, I was able to use single-bit color channels in PNG to serve essentially just compressed 2D bitmaps. How well this compresses varies, with the sparsest tiles taking just 220 bytes and most fitting under 5 kilobytes, which isn&#39;t bad for relatively high-entropy data.</p><h2 id="space-filling-curves" tabindex="-1">Space-filling curves <a href="#space-filling-curves" aria-label="Permalink to &#34;Space-filling curves&#34;">​</a></h2><p>One of requested visualization features was to offer multiple spatial layouts for the ISBNs. One would lay them out row-by-row, while another would arrange them for spatial locality of related ISBN ranges using something like a <a href="https://youtu.be/3s7h2MHQtxc?si=Ws_UxVacn_s3AkrV&amp;t=237" target="_blank" rel="noreferrer">Hilbert curve</a>.</p><p>Hilbert curves are straightforward, but they wouldn&#39;t quite work in this case since the ISBN range can&#39;t be factored into a perfect square. Instead, I implemented an alternative curve that works for any dimensions, using a <a href="https://lutanho.net/pic2html/draw_sfc.html" target="_blank" rel="noreferrer">pen and paper sketch</a> as my guide. Dear reader, this absolutely broke my brain and took me the better part of three days to get working.</p><p>I <em>should</em> have just padded the data to a square number and used a Hilbert curve. I was concerned that handling different viewport shapes and sizes would make the rendering and data loading more complex. In hindsight, it would have been much, much simpler, but I certainly didn&#39;t anticipate the difficulty of the route I actually took. The linked illustation I went off offers virtually no explanation of how the pieces fit together or why it works the way it does. I wound up having to reverse-engineer the technique from first principles after tying my brain into knots over all the edge cases.</p><p>As I learned from other submissions after the fact, <a href="https://github.com/jakubcerveny/gilbert?tab=readme-ov-file" target="_blank" rel="noreferrer">Gilbert Curves</a> would have been better-looking and easier. This algorithm builds on the one I used, greatly reducing the amount of cases to handle and choosing more aesthetic paths as a result. Although I&#39;m kicking myself for the amount of time I spent on this, I&#39;m glad to know about this alternative for future projects.</p><h2 id="tile-loading" tabindex="-1">Tile loading <a href="#tile-loading" aria-label="Permalink to &#34;Tile loading&#34;">​</a></h2><p>Tile loading involves six spaces. The first is isbn space, which is the full map area. It ranges from 0 to 1 on each axis. (0,0) is the top left, (1,1) is the bottom right. There is also isbn pixel space, which is the same size as the map, 50,000 by 40,000.</p><p>Viewport space is the canvas area. It also ranges from 0 to 1. Viewport pixel space is the physical dimensions of the canvas. The former is useful for converting to and from other spaces, while the latter is necessary to figure out where things are onscreen for tooltips and info overlays.</p><p>Mipmap space has different ranges depending on the desired mip level. The zeroth level space is in 0 to 1, the second is in 0 to 2, the third is in 0 to 4, and so on. This corresponds to the number of mipmap tiles on each axis. For example, the point (1.5, 0.5) is the center of the second tile of the first row.</p><p>To figure out which tiles to load, we first convert (0,0) and (1,1) from viewport space to isbn space. This gives us the bounds of the visible map area. We pick a mipmap level to use based on the ratio between canvas size and the visible area in isbn pixel space. Using the mipmap level, we then convert from isbn space to mipmap space. This gives us the range of mipmap tiles that are visible at the current zoom level.</p><p>With this in hand, we can iterate over the visible tiles and initiate requests for any we haven&#39;t seen yet. The only additional complexity here is caching.</p><h2 id="webgl-rendering" tabindex="-1">WebGL rendering <a href="#webgl-rendering" aria-label="Permalink to &#34;WebGL rendering&#34;">​</a></h2><p>My original map renderer used the canvas API. However, after trying my best to optimize, I found it unworkably slow. I assumed that it should be at least in the neighborhood of WebGL by drawing images on the GPU, but framerates were through the floor so that mustn&#39;t be the case. Rewriting the renderer with WebGL instantly turned the rendering to butter.</p><p>The renderer is nothing terribly special. Since each mip tile requires a different texture, we issue a separate draw call for each one, drawing onto a unit square piece of geometry that gets positioned in the vertex shader. A better solution is to index into a texture array in the fragment shader to reduce the number of draw calls, but I&#39;m not sure whether that&#39;s possible in WebGL. I&#39;m still waiting patiently for WebGPU to become widely available for things like that.</p><p>When choosing tiles to draw, we try to find a mipmap level with full coverage of the viewport area at the best detail level available. A better option would be to draw the lowest resolution mipmap level, then the next higher level, and so on until the current zoom level. This would degrade better when not all the data is loaded, or when some tiles fail to load at all. The issue here is that tiles are drawn with additive or subtractive blending to be able to compare different datasets, so this would result in brightening or darkening due to repeatedly painting the same areas. A better solution is to paint the tiles for each dataset opaquely to an offscreen texture before adding or multiplying the composited result into the canvas texture. Sadly, I didn&#39;t think of this until after the project deadline.</p><h2 id="signing-off" tabindex="-1">Signing off <a href="#signing-off" aria-label="Permalink to &#34;Signing off&#34;">​</a></h2><p>Ye who have read this far, thanks! I&#39;ll be trying to write and blog more in the coming months during my time at the <a href="https://www.recurse.com/" target="_blank" rel="noreferrer">Recurse Center</a>. Stay tuned.</p></div></article></div></main></div></div></div>
  </body>
</html>
