<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bastian.rieck.me/blog/posts/2022/server/">Original</a>
    <h1>Who&#39;s Attacking My Server?</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>One of the unexpected<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> outcomes of the Russian invasion in Ukraine is
a large increase in nefarious access attempts to servers under my
control, not necessarily appearing to arise from Russian IP addresses.
There are the usual attempts at brute-forcing SSH access, for
instance, but also a flurry of malevolent HTTP(S) requests, looking
for insecure WordPress installations etc. With my logs starting to get
clogged, I decided to improve security a little bit.</p>
<p><strong>Caveat lector</strong>: The tips in this article will help keep out some
obnoxious folks. They are not enough to fight professionals. If you
are running critical infrastructure, please use my advice only as a
starting point.</p>

<p>As a machine learning researcher, I know that I have different tools at
my disposal: I could monitor connections over a prolonged period of
time, categorise them as hostile or not, and train a <a href="https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)">transformer</a>
to detect hostile connections in real time. All this would take is
a long time for data collection and labelling, followed by a lot of GPU
hours. <em>Alternatively</em>, I could just do some simple pattern matching.
Feeling the disapproving gaze of the lords and ladies of deep learning
upon me, I nevertheless opted for pattern matching—at least for
now.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p>

<p>The best strategy to make a server secure is to minimise its <em>attack
surface</em>. That means cutting down the number of services that are
available or exposed to the internet. A classical configuration error is
to run a service listening on a <em>public interface</em> instead of
<code>localhost</code>. If you cannot disable the service, at least make sure that
it’s not publicly accessible.</p>
<p><strong>Containers.</strong> There’s also something to be said about using containers
or virtualisation—my needs for my server are too modest to make use of
this. If it works for you, make sure that the container is secure. It is
of no use to you if attackers can easily break into the container itself
because that already provides them with a foothold.</p>
<p>In my case, I only run two services that are publicly available, viz.
a webserver and SSH:</p>
<pre><code>~ % nmap taliesin.annwfn.net   
Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-12 08:00 CET
Nmap scan report for taliesin.annwfn.net (178.62.197.121)
Host is up (0.023s latency).
Not shown: 997 closed tcp ports (conn-refused)
PORT    STATE SERVICE
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https

Nmap done: 1 IP address (1 host up) scanned in 0.41 seconds
</code></pre>
<h2 id="webserver">Webserver</h2>
<p>The webserver—<code>nginx</code>—serves multiple virtual hosts, both for my own
needs and that of my friends. Websites are rather lightweight and do not
make use of additional servers, so there’s nothing to do here. I am also
running an <a href="https://owncloud.com">OwnCloud</a> instance for my family. This
requires using <code>php-fpm</code> and creating a separate pool that can only ever
access one base directory. This is probably too specific to my situation
and I won’t go into additional details here; see <a href="https://tkacz.pro/php-fpm-config-improvements/">this guide for more details</a>.</p>
<h2 id="ssh">SSH</h2>
<p>SSH, on the other hand, is a different beast: with <code>journalctl --follow</code>, I can observe failed login attempts in real time. There are
numerous users that are just attempting to brute-force their way into
the server. As a starting point, I decided to be a little bit more
severe in my <code>sshd</code> configuration:</p>
<pre><code>LoginGraceTime 30
PermitRootLogin no
MaxAuthTries 3

X11Forwarding no
PrintMotd no
</code></pre>
<p>This is not super strict yet, but it prevents <code>root</code> login altogether,
and reduces the wait time for a login to 30 seconds. Authentication
failures will be logged after <em>one</em> incorrect attempt;<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> this will turn
out to be relevant later on.</p>
<p>The other settings in <code>sshd_config</code> are sane defaults, in my opinion. If
you have a lot of users, you can also set <code>PermitEmptyPasswords no</code>.
I put all of these values in a <code>local.conf</code> file that is deployed to
<code>/etc/ssh/sshd_config.d/local.conf</code>.</p>
<p>There’s additional options that might be appropriate for your use case:
disabling password authentication altogether, preventing tunnelling, and
much more. However, I do not want to decrease the utility of my server
for my own users, so I tend to keep all of these extra settings.</p>
<h2 id="fail2ban">fail2ban</h2>
<p>Logging and preventing some services is all nice and good, but we need
one additional way to deter attackers. <a href="https://github.com/fail2ban/fail2ban"><code>fail2ban</code></a>
is a great tool that can scan all types of logs, look for authentication
failures or other nefarious incidents, and react accordingly. This is
a really powerful tool, and I’ve only started scratching its surface.</p>
<p>Our installation of <code>fail2ban</code> consists of multiple parts:</p>
<ol>
<li>A <code>fail2ban</code> server.</li>
<li>A global configuration file <code>fail2ban.conf</code>, which controls general
settings such as log verbosity.</li>
<li>A set of <em>filters</em> to detect authentication failures.</li>
<li>A set of <em>actions</em> to ‘ban’ and ‘unban’ IP addresses.</li>
<li>A set of <em>jails</em> that combine filters and actions.</li>
</ol>
<p>After installing <code>fail2ban</code>, I checked the global configuration
<code>/etc/fail2ban/fail2ban.conf</code>, but its defaults appear very good to me:
everything is logged into <code>/var/log/fail2ban.log</code> at an <code>INFO</code> verbosity
level. The default distribution of <code>fail2ban</code> comes with numerous
filters, to be found in <code>/etc/fail2ban/filter.d</code>. There is of course an
<code>sshd.conf</code> filter available—no need to parse log files manually.</p>
<p>Moreover, there is even a default jail for <code>sshd</code> available, and we just
have to enable it:</p>
<pre><code>$ cat /etc/fail2ban/jail.d/defaults-debian.conf 
[sshd]
enabled = true
</code></pre>
<p>After making sure that the service is enabled, we are good to go:</p>
<pre><code>$ systemctl status fail2ban
● fail2ban.service - Fail2Ban Service
     Loaded: loaded (/lib/systemd/system/fail2ban.service; enabled; vendor preset: enabled)
     Active: active (running) since [...] 
</code></pre>
<p>That’s it! <code>fail2ban</code> will now happily run along, screen your SSH logs,
and start banning and unbanning IP addresses automatically. Of course,
this is not an entirely-foolproof way of securing your server, but it
at least prevents brute-force break-in attempts, thus reducing the
attack surface.</p>

<p>I also wanted to know where the potential attackers are coming from.
Luckily, the <code>fail2ban</code> log output is relatively easy to parse, making
it possible to create a <code>.tsv</code> file: From this file, it is</p>
<pre><code>echo &#34;count\tip&#34;

awk &#39;($(NF-1) = /Ban/){print $NF}&#39; /tmp/fail2ban.log \
  | sort                                             \
  | jdresolve -                                      \
  | uniq -c                                          \
  | sort -n -r                                       \
  | sed -e &#39;s/^[ \t]*//&#39;                             \
  | sed -e &#39;s/ /\t/&#39;                                 \
  | head -n 100
</code></pre>
<p>This file can be read and processed, resulting in the following map of
attackers (updated automatically every hour; larger circles indicate
more attacks from a specific city or region):</p>
<div>
<figure><img src="https://bastian.rieck.me/images/naughty_users_map.svg" alt="Map of naughty users, attempting to break into the server" height="128"/>
</figure>

</div>

<p>I am quite happy with the setup at the moment. In the future, I am
considering additional measures to take: for instance, it would be
interesting to automatically start an <code>nmap</code> scan for all IP addresses
that are banned for longer than a few minutes. Going even further, I am
wondering whether it would be legal to try to <em>automatically</em> check for
known exploits, in order to ‘p0wn’ the wannabe-attacker and disable
their system instead.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> This is all idle speculation, though, since
both the legality and the practicality of such actions are questionable.</p>

<p>To answer the question of this post, I parsed the list I created above
and queried another IP address database. Here’s a partial answer about
the country the nefarious connection requests are originating from:</p>
<pre><code>China: 30
Hong Kong: 15
United States: 8
India: 6
Germany: 6
Singapore: 5
Viet Nam: 4
Netherlands: 3
Russian Federation: 2
Colombia: 2
United Kingdom: 2
Korea, Republic of: 2
Spain: 1
Brazil: 1
Argentina: 1
Japan: 1
Indonesia: 1
Ukraine: 1
Senegal: 1
Poland: 1
</code></pre>
<p>Interestingly, the connections from China are all created by a <em>single</em>
host, who is rather persistent in its brute-force attack, despite
getting banned for prolonged periods of time. I don’t know what to make
of this.</p>
<p>Stay safe, until next time!</p>
<p>(PS: If you are one of the persons trying to break into my server, please
stop. There’s nothing of interest here, and I have a <a href="https://bastian.rieck.me/research">day
job</a> that keeps me sufficiently occupied.)</p>


      </div></div>
  </body>
</html>
