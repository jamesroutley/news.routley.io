<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gws.phd/posts/fortran_wasm/">Original</a>
    <h1>Fortran on WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-content">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main id="quarto-document-content">





<video controls="" autoplay="" muted="" loop="" width="100%">
<source src="digits.webm" type="video/webm; codecs=vp9"/>
<source src="digits.mp4" type="video/mp4"/>
</video>
<figcaption>
<a href="#mnist">Digit classification</a> with machine learning, running in the browser using BLAS routines compiled to WebAssembly.
</figcaption>
<section id="introduction">

<p><span><a href="https://fortran-lang.org">Fortran</a></span><a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> is one of the oldest programming languages around. It first appeared in 1957, making it older than the C programming language, the Intel 4004 CPU, and even the IBM System/360 series of mainframe computers<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Fortran was created at a time when the byte had just been invented, and computers were still made of vacuum tubes and frustration.</p>
<div><p><sup>1</sup> The name is derived from <em>Formula Translator</em>. <span>Fortran</span> was originally stylised in all-caps, but modern Fortran has dropped it.</p><p><sup>2</sup> The System/360 was released around 1965. The 4004 around 1970. And <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R C</a> was published in 1978.</p><p><sup>3</sup> The argument goes that Fortran’s lack of aliasing and use of native arrays rather than pointer arithmetic allow the optimiser to generate more efficient output than an equivalent C program. However, there are also counter-arguments against this.</p></div><p>Over the years, Fortran has formed a rich history of use for computationally intensive scientific and engineering applications. It has powered the fluid dynamics of weather prediction and climate models, provided the condensed matter simulations for my <a href="https://gws.phd/docs/thesis_gws.pdf">PhD</a>, and is still considered by some to be more efficient than C for numerically heavy work<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. The syntax of modern Fortran is also surprisingly easy to get up and running with. This is not your parent’s <span>Fortran 77</span> code; most restrictions that make fixed‑form Fortran awful to use are no longer in place in modern Fortran.</p>
<p>In a clash of computational eras, this blog post is about compiling existing Fortran code for WebAssembly so that it can run in a web browser. I’ll describe the method we currently use for the <a href="https://github.com/r-wasm/webr">webR</a> project, compiling Fortran code using a patched version of <a href="https://llvm.org">LLVM</a>’s <code>flang-new</code> compiler<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>. The post also serves as a request for help. The method I describe unfortunately relies on a hack, and this hack means that I cannot contribute the changes back to LLVM without assistance from a more experienced compiler developer.</p>
<p><sup>4</sup> “LLVM” is not an acronym, it is the full name of the project.</p></section>
<section id="so-whats-the-problem">

<p>There are a surprising number of potential methods and toolchains available to compile Fortran to WebAssembly. Unfortunately, none of the available options are feature complete. Each method has its drawbacks, and none are a simple plug-and-play solution.</p>
<p>Back in 2020, the situation was summarised wonderfully by Christoph Honal’s article <a href="https://chrz.de/2020/04/21/fortran-in-the-browser/">FORTRAN in the Browser</a>. Even now, the article is worth reading and provides a nice background for this post. I personally owe a lot to Christoph’s article, particularly for its description of the <a href="https://dragonegg.llvm.org">Dragonegg</a> toolchain. Without that article, I would have given up on Fortran for WebAssembly a long time ago.</p>
<p>Our goal by the end of this post is to be able to compile a modern Fortran routine to WebAssembly that takes in some numerical arguments, computes the output of <a href="http://www.netlib.org/blas/">BLAS</a> and <a href="https://netlib.org/lapack/">LAPACK</a> routines<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>, and either returns the result or prints it to console. From what I remember, in 2020 none of the methods outlined in Christoph’s article could do this satisfactorily. Dragonegg and <code>f2c</code> both get close but have some drawbacks, as I’ll describe below.</p>
<div><p><sup>5</sup> LAPACK (Linear Algebra Package) is a popular library of routines used to numerically solve problems in linear algebra. It’s written in Fortran 90 and itself relies on a BLAS (Basic Linear Algebra Subprograms) library.</p><p><sup>6</sup> via <a href="https://pyodide.org/en/stable/">Pyodide</a> and <a href="https://github.com/r-wasm/webr">webR</a>.</p></div><p>Together, BLAS and LAPACK routines provide a powerful numerical platform. Running them in the browser opens the door for several higher-level programming environments that rely on them under the hood, such as SciPy or R<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>. The beauty of this approach is that it allows you to bring existing and extensively battle-tested tools and libraries to the web without having to rewrite them all in Rust or JavaScript.</p>
<p>Later, I’ll show an example of this with a machine learning demo that directly uses BLAS routines compiled from Fortran to WebAssembly. Rather than having to write fiddly linear algebra numerical algorithms in JavaScript, we can use reliable and efficient BLAS routines directly<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<p><sup>7</sup> Whilst running machine learning algorithms in a web browser will never be as efficient as using dedicated hardware, such as a GPU, I still think it’s a fun demo.</p><section id="compiler-round-up">
<h2 data-anchor-id="compiler-round-up">Compiler round-up</h2>
<p>Since <a href="https://chrz.de/2020/04/21/fortran-in-the-browser/">FORTRAN in the Browser</a> was published things have changed a little, particularly when it comes to the LLVM-based Fortran compilers. As far as I am aware, here’s a brief round-up of the current situation in 2024.</p>
<section id="the-f2c-utility">
<h3 data-anchor-id="the-f2c-utility">The <code>f2c</code> utility</h3>
<p>The <a href="https://en.wikipedia.org/wiki/F2c"><code>f2c</code></a> program converts <span>Fortran 77</span> to C code, which Emscripten can then compile into WebAssembly. This is the method that the <a href="https://pyodide.org/en/stable/">Pyodide</a> project uses to compile Python packages containing Fortran code. They say that this <a href="https://pyodide.org/en/0.25.0/project/roadmap.html#find-a-better-way-to-compile-fortran">“does not work very well”</a>. The tool doesn’t work with modern Fortran code, and even after conversion the result still throws fatal errors and requires extensive patching.</p>
</section>
<section id="lfortran">
<h3 data-anchor-id="lfortran">LFortran</h3>
<p>The LFortran compiler has made great strides over the last few years. In 2020, it was <a href="https://gitlab.com/lfortran/lfortran/-/issues/121">missing a lot of features</a> and only supported a very small subset of Fortran. Now it now supports a much wider range of language features and can be used to compile a reasonable amount of Fortran code. It can even compile to WebAssembly out of the box!<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p><sup>8</sup> Check out the LFortran demo at <a href="https://dev.lfortran.org">https://dev.lfortran.org</a>. While extremely impressive, note that the first thing I tried was changing <code>x ** 2</code> to <code>x ** 3</code> and saw that such a change is currently not supported by the code generator.</p><p>However, there are still some barriers that make using LFortran a little rough. The project is currently considered to be in alpha phase and the developers state that issues compiling real-world code are expected. While it can successfully compile some projects, such as <a href="https://github.com/fortran-lang/minpack">MINPACK</a>, the full Fortran specification is not yet supported and so many larger projects still cannot be compiled.</p>
<p>The LFortran developers are targeting full support for Fortran 2018, and its standout feature is an interactive Jupyter-like Fortran REPL. With a few more years of development, I expect that LFortran will be an excellent choice for compiling Fortran code for WebAssembly.</p>
</section>
<section id="dragonegg">
<h3 data-anchor-id="dragonegg">Dragonegg</h3>
<p><a href="https://dragonegg.llvm.org">Dragonegg</a> is a plugin for GCC that uses the GNU compilers as a frontend and emits LLVM IR. With this, LLVM can be used as the backend to produce WebAssembly output. The technique works, and it was the original method that I used to compile Fortran sources for the <a href="https://github.com/r-wasm/webr">webR</a> project.</p>
<p>However, there are some pretty serious drawbacks to this approach. Dragonegg requires a very old version of GCC and LLVM<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a>. For most users, this means setting up a virtual machine or Docker container to provide the necessary environment. The LLVM IR emitted by Dragonegg also needs some fairly nasty post-processing before LLVM can produce WebAssembly output. Take a look at the <a href="https://github.com/r-wasm/webr/blob/v0.1.0/tools/dragonegg/emfc.in">script originally used by webR</a> to get an idea of the extra processing required.</p>
<p><sup>9</sup> The latest supported versions are <code>gcc-4.8</code> and <code>llvm-3.3</code></p><p>Nevertheless, in 2020 this was the only real way to compile Fortran code for WebAssembly.</p>
</section>
<section id="classic-flang">
<h3 data-anchor-id="classic-flang">Classic flang</h3>
<p><a href="https://github.com/flang-compiler/flang">“Classic” Flang</a><a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a> is another Fortran compiler targeting LLVM, based on an open-sourced PGI/NVIDIA compiler <code>pgfortran</code>. Classic Flang never supported 32-bit output, so it is not an option for us since we’ll be using <code>wasm32</code> for our target architecture. This will likely be the case until browser support for 64-bit Wasm memory has improved<a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p>
<div><p><sup>10</sup> Previously, Flang or Flang-7.</p><p><sup>11</sup> At the time of writing Firefox, Chrome and Node supports <code>wasm64</code>, but locked behind a feature flag.</p></div><p>Even so, the project documentation itself suggests that choosing to use Classic Flang for a new project today is probably not a great idea:</p>
<blockquote>
<p>Classic Flang […] continues to be maintained, but the plan is to replace Classic Flang with the new Flang in the future.</p>
</blockquote>
</section>
<section id="llvm-flang">
<h3 data-anchor-id="llvm-flang">LLVM Flang</h3>
<p><a href="https://flang.llvm.org/docs/">“LLVM Flang”</a><a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a> is a full ground-up reimplementation of a Fortran frontend for LLVM. It was designed to replace Classic Flang, developed by much of the same team, and was accepted as part of the LLVM project as of LLVM 11. As such, the Flang sources can now be found in <a href="https://github.com/llvm/llvm-project/tree/main/flang">the official LLVM source tree</a>.</p>
<p><sup>12</sup> Also known as Flang, new Flang, or <code>flang-new</code>. Previously, F18.</p><p>Flang is not yet considered to be ready for production use, but its development is extremely active right now and pre-production versions of the <code>flang-new</code> compiler have been made available by the team. In recent years, the compiler has become very usable for compiling real-world Fortran code.</p>
<p>Currently, LLVM Flang cannot generate WebAssembly output out of the box. Despite this, we’ll soon see that with LLVM’s modular design it’s possible to use the Flang frontend with LLVM’s WebAssembly backend. With this, we can take advantage of all the development work put into the Flang frontend by the NVIDIA and PGI teams for our own purposes of compiling Fortran to WebAssembly.</p>
<p>This was also possible back in 2020, though it required larger patches to LLVM, injecting custom maths routines, and a multi-step compilation process. Now, due to the impressive development efforts in the <code>flang-new</code> frontend, creating a Fortran to WebAssembly compiler is possible with just a few small changes to LLVM’s source code.</p>
</section>
</section>
</section>
<section id="building-and-using-llvm-flang-for-webassembly">

<p>If one were interested in trying out LLVM Flang, they might grab an LLVM release using their package manager of choice. However, following that route will disappoint us, as a <code>flang-new</code> binary is not included<a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a>.</p>
<p><sup>13</sup> At least, not with LLVM v17.0.6 for macOS using <code>brew</code>.</p><div>
<p><span>[~/fortran]</span>brew install llvm</p>
<p><span>==&gt;</span> Downloading https://formulae.brew.sh/api/formula.jws.json</p>
<p>################################################################################ 100.0%</p>
<p><span>==&gt;</span> Downloading https://ghcr.io/v2/homebrew/core/llvm/manifests/17.0.6_1</p>
<p>################################################################################ 100.0%</p>
<p><span>==&gt;</span> Fetching llvm</p>
<p><span>==&gt;</span> Downloading https://ghcr.io/v2/homebrew/core/llvm/blobs/sha256:8d739bdfa4152</p>
<p>################################################################################ 100.0%</p>
<p><span>==&gt;</span> Installing llvm</p>
<p><span>==&gt;</span> Pouring llvm--17.0.6_1.arm64_sonoma.bottle.tar.gz</p>
<p><span>==&gt;</span> Summary</p>
<p>🍺  /opt/homebrew/Cellar/llvm/17.0.6_1: 7,207 files, 1.7GB</p>
<p><span>==&gt;</span> Checking for dependents of upgraded formulae...</p>
<p><span>==&gt;</span> No broken dependents to reinstall!</p>
<p><span>[~/fortran]</span>flang-new</p>
<p>zsh: command not found: flang-new</p>
</div>
<p>Since we will be modifying the LLVM Flang source in any case, we’ll have to compile from scratch. Let’s grab the LLVM v18.1.1 sources and start there instead. Feel free to follow along at home; I’ll try to provide all the commands and everything you need.<a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<p><sup>14</sup> I’m going to assume you’re familiar with <a href="https://emscripten.org">Emscripten</a> and have a version of that toolchain on your path. If not, and you want to play along, start with <a href="https://github.com/emscripten-core/emsdk">emsdk</a> to setup Emscripten on your machine, get comfortable with compiling C code for WebAssembly, then return here to continue.</p><div>
<p><span>[~/fortran]</span>git clone --depth=1 --branch=llvmorg-18.1.1 https://github.com/llvm/llvm-project.git</p>
<p>Cloning into &#39;llvm-project&#39;...</p>
<p>remote: Enumerating objects: 138937, done.</p>
<p>Receiving objects: 100% (138937/138937), 199.81 MiB | 11.36 MiB/s, done.</p>
<p>Note: switching to &#39;6009708b4367171ccdbf4b5905cb6a803753fe18&#39;.</p>
<p>Updating files: 100% (132077/132077), done.</p>
<p><span>[~/fortran]</span>cmake -G Ninja -S llvm-project/llvm -B build \</p>
<p>-DCMAKE_INSTALL_PREFIX=llvm-18.1.1 \</p>
<p>-DCMAKE_BUILD_TYPE=MinSizeRel \</p>
<p>-DLLVM_DEFAULT_TARGET_TRIPLE=&#34;wasm32-unknown-emscripten&#34; \</p>
<p>-DLLVM_TARGETS_TO_BUILD=&#34;WebAssembly&#34; \</p>
<p>-DLLVM_ENABLE_PROJECTS=&#34;clang;flang;mlir&#34;</p>
<p>-- The C compiler identification is AppleClang 15.0.0.15000100</p>
<p>-- Found assembler: /Library/Developer/CommandLineTools/usr/bin/cc</p>
<p>-- Detecting C compiler ABI info - done</p>
<p>-- Performing Test HAVE_POSIX_REGEX -- success</p>
<p>-- Configuring done (29.0s)</p>
<p>-- Generating done (2.9s)</p>
<p>-- Build files have been written to: fortran/build</p>
<p><span>[~/fortran]</span>cmake --build build</p>
<p>...</p>
<p>[6136/6136] Linking CXX executable bin/obj2yaml</p>
</div>
<p>Grab a cuppa<a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a>, this step uses a lot of resources and can take a <strong>very</strong> long time.</p>
<p><sup>15</sup> <strong>cuppa</strong> (/ˈkʌp.ə/): noun, informal, UK. A hot drink, usually tea or coffee.</p><section id="interlude-calling-fortran-subroutines-from-c">
<h2 data-anchor-id="interlude-calling-fortran-subroutines-from-c">Interlude — Calling Fortran subroutines from C</h2>
<p>While we wait for LLVM to build, start up a new terminal and we’ll remind ourselves how to compile and link a Fortran subroutine as part of a C program. The principles here will help us later when it comes to calling Fortran from JavaScript.</p>
<p>First, let’s write a simple subroutine that takes in three integer arguments: <code>x</code>, <code>y</code>, and <code>z</code>. It will set the value of <code>z</code> to the sum of <code>x</code> and <code>y</code>. Name our new subroutine <code>foo</code> and save the file containing your subroutine as <code>foo.f08</code>.</p>
<div>

<div id="cb1" data-filename="foo.f08"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>SUBROUTINE</span> foo(x, y, z)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span>IMPLICIT</span> <span>NONE</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>INTEGER</span>, <span>INTENT(IN)</span>  <span>::</span> x, y</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span>INTEGER</span>, <span>INTENT(OUT)</span> <span>::</span> z</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    z <span>=</span> x <span>+</span> y</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>END</span></span></code></pre></div>
</div>
<p>Notice how, generally, Fortran routines pass arguments by reference and we can declare how an argument will be used in the subroutine using <code>INTENT()</code>. Assuming you already have a traditional Fortran compiler like <code>gfortran</code> installed<a href="#fn16" id="fnref16" role="doc-noteref"><sup>16</sup></a>, compile the Fortran source into an object file.</p>
<p><sup>16</sup> You don’t <em>need</em> a native fortran compiler to follow along with the rest of the post, but if you’d like one you can get <code>gfortran</code> from your OS’s usual package manager as part of the GCC compiler suite. There’s also <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/fortran-compiler.html"><code>ifort</code></a>, if you’re on an Intel CPU.</p><div>
<p><span>[~/fortran]</span>gfortran -c foo.f08 -o foo.o</p>
<p><span>[~/fortran]</span>file foo.o</p>
<p>foo.o: Mach-O 64-bit object arm64</p>
<p><span>[~/fortran]</span>nm foo.o</p>
<p>0000000000000038 s EH_frame1</p>
<p>0000000000000000 T _foo_</p>
<p>0000000000000000 t ltmp0</p>
<p>0000000000000038 s ltmp1</p>
</div>
<p>I’m on an M1 macOS machine, so my resulting object is a Mach object for ARM. If you’re a Linux user, you should see something like <code>ELF 64-bit LSB shared object, x86-64</code>. I’ve also run <code>nm</code> to take a look at the names of the symbols in the object that the compiler has built. Keep an eye on the symbol for our subroutine — on my machine it’s named <code>_foo_</code>. The leading underscore is fairly standard, but the trailing underscore differs from what is usual for C procedures.</p>
<p>Let’s write a C program that calls our Fortran subroutine<a href="#fn17" id="fnref17" role="doc-noteref"><sup>17</sup></a>. Notice again how we pass the arguments by reference to the external symbol. Also, if your Fortran compiler added the trailing underscore, we’ll need to include it when we declare the symbol name in C.</p>
<p><sup>17</sup> Modern Fortran standards provide a Fortran module <a href="https://fortranwiki.org/fortran/show/iso_c_binding"><code>iso_c_binding</code></a> and a C header file <code>ISO_Fortran_binding.h</code> to improve C interoperability, but our code is going to be simple enough that we can do without those today.</p><div>

<div id="cb2" data-filename="main.c"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>extern</span> <span>void</span> foo_<span>(</span><span>int</span><span>*,</span> <span>int</span><span>*,</span> <span>int</span><span>*);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span>int</span> x <span>=</span> <span>1</span><span>,</span> y <span>=</span> <span>1</span><span>,</span> z<span>;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    foo_<span>(&amp;</span>x<span>,</span> <span>&amp;</span>y<span>,</span> <span>&amp;</span>z<span>);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    printf<span>(</span><span>&#34;</span><span>%d</span><span> + </span><span>%d</span><span> = </span><span>%d\n</span><span>&#34;</span><span>,</span> x<span>,</span> y<span>,</span> z<span>);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>0</span><span>;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
</div>
<p>Compile the C source using <code>gcc</code> or equivalent, and then run the resulting binary to observe a truly staggering level of numerical computation.</p>
<div>
<p><span>[~/fortran]</span>gcc main.c foo.o -o main</p>
<p><span>[~/fortran]</span>./main</p>
<p>1 + 1 = 2</p>
</div>
</section>
<section id="returning-to-llvm-flang">
<h2 data-anchor-id="returning-to-llvm-flang">Returning to LLVM Flang</h2>
<p>Once LLVM has finished compiling, the <code>flang-new</code> binary should be available in the directory <code>build/bin</code>. We can now run it and confirm that it has been set up to produce binaries for <code>wasm32</code> and Emscripten.</p>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new --version</p>
<p>flang-new version 18.1.1 (https://github.com/llvm/llvm-project.git dba2a75e9c7ef81fe84774ba5eee5e67e01d801a)</p>
<p>Target: wasm32-unknown-emscripten</p>
<p>Thread model: posix</p>
<p>InstalledDir: .../fortran/build/bin</p>
</div>
<p>Great! Let’s try compiling our Fortran subroutine using our freshly built compiler.</p>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c foo.f08 -o foo.o</p>
<p>error: fortran/llvm-project/flang/lib/Optimizer/CodeGen/Target.cpp:1162:</p>
<p>not yet implemented: target not implemented</p>
<p>LLVM ERROR: aborting</p>
</div>
<p>Ah, not so great. The <code>wasm32-unknown-emscripten</code> target triple unfortunately hasn’t been implemented yet in the <code>flang-new</code> compiler.</p>
<p>And so here comes our first patch to LLVM. We will implement the target by extending Flang’s list of known target specifics. The required changes, shown below as a diff, can be mostly deduced by looking at the other targets implemented in the file <code>flang/lib/Optimizer/CodeGen/Target.cpp</code>.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>diff --git a/flang/lib/Optimizer/CodeGen/Target.cpp b/flang/lib/Optimizer/CodeGen/Target.cpp</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>index 83e7fa9b440b..49e73ec48e0a 100644</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>--- a/flang/lib/Optimizer/CodeGen/Target.cpp</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>+++ b/flang/lib/Optimizer/CodeGen/Target.cpp</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>@@ -1109,6 +1109,44 @@ struct TargetLoongArch64 : public GenericTarget&lt;TargetLoongArch64&gt; {</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> };</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a> } // namespace</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span>+//===----------------------------------------------------------------------===//</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span>+// WebAssembly (wasm32) target specifics.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span>+//===----------------------------------------------------------------------===//</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span>+namespace {</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span>+struct TargetWasm32 : public GenericTarget&lt;TargetWasm32&gt; {</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span>+  using GenericTarget::GenericTarget;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span>+  static constexpr int defaultWidth = 32;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span>+  CodeGenSpecifics::Marshalling</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span>+  complexArgumentType(mlir::Location, mlir::Type eleTy) const override {</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span>+    assert(fir::isa_real(eleTy));</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span>+    CodeGenSpecifics::Marshalling marshal;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span>+    // Use a type that will be translated into LLVM as:</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span>+    // { t, t }   struct of 2 eleTy, byval, align 4</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span>+    auto structTy =</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span>+        mlir::TupleType::get(eleTy.getContext(), mlir::TypeRange{eleTy, eleTy});</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span>+    marshal.emplace_back(fir::ReferenceType::get(structTy),</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span>+                         AT{/*alignment=*/4, /*byval=*/true});</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span>+    return marshal;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span>+  }</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span>+  CodeGenSpecifics::Marshalling</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span>+  complexReturnType(mlir::Location loc, mlir::Type eleTy) const override {</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span>+    assert(fir::isa_real(eleTy));</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span>+    CodeGenSpecifics::Marshalling marshal;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span>+    // Use a type that will be translated into LLVM as:</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span>+    // { t, t }   struct of 2 eleTy, sret, align 4</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span>+    auto structTy = mlir::TupleType::get(eleTy.getContext(),</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span>+                                          mlir::TypeRange{eleTy, eleTy});</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span>+    marshal.emplace_back(fir::ReferenceType::get(structTy),</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span>+                          AT{/*alignment=*/4, /*byval=*/false, /*sret=*/true});</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span>+    return marshal;</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span>+  }</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span>+};</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span>+} // namespace</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a><span>+</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a> // Instantiate the overloaded target instance based on the triple value.</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a> // TODO: Add other targets to this file as needed.</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a> std::unique_ptr&lt;fir::CodeGenSpecifics&gt;</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a><span>@@ -1158,6 +1196,9 @@ fir::CodeGenSpecifics::get(mlir::MLIRContext *ctx, llvm::Triple &amp;&amp;trp,</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>   case llvm::Triple::ArchType::loongarch64:</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>     return std::make_unique&lt;TargetLoongArch64&gt;(ctx, std::move(trp),</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>                                                std::move(kindMap), dl);</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span>+  case llvm::Triple::ArchType::wasm32:</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a><span>+    return std::make_unique&lt;TargetWasm32&gt;(ctx, std::move(trp),</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a><span>+                                               std::move(kindMap), dl);</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>   TODO(mlir::UnknownLoc::get(ctx), &#34;target not implemented&#34;);</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a> }</span></code></pre></div>
<p>Save the contents of the above diff as the file <code>add-wasm32-target.diff</code>, and then apply it to the <code>llvm-project</code> directory using <code>git</code> or the <code>patch</code> utility. Then, rebuild LLVM Flang. It should be quicker to build the second time, as most generated objects are unaffected by the change.</p>
<div>
<p><span>[~/fortran]</span>patch -p1 -d llvm-project &lt; add-wasm32-target.diff</p>
<p><span>[~/fortran]</span>cmake --build build</p>
<p>...</p>
<p>[180/180] Generating ../../../../include/flang/ieee_arithmetic.mod</p>
</div>
<p>Once LLVM has been recompiled, try compiling our Fortran source once again.</p>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c foo.f08 -o foo.o</p>
<p><span>[~/fortran]</span>file foo.o</p>
<p>foo.o: WebAssembly (wasm) binary module version 0x1 (MVP)</p>
<p><span>[~/fortran]</span>llvm-nm foo.o</p>
<p>00000001 T foo_</p>
</div>
<p>Success! We can confirm this is a real WebAssembly object using the <code>file</code> utility, and <code>llvm-nm</code><a href="#fn18" id="fnref18" role="doc-noteref"><sup>18</sup></a> can see the <code>foo</code> symbol within, corresponding to our Fortran subroutine.</p>
<div><p><sup>18</sup> You might need to use a WebAssembly aware version of this tool from Emscripten. If you’re using <a href="https://github.com/emscripten-core/emsdk">emsdk</a>, ensure that <code>.../emsdk/upstream/bin/</code> is on your <code>$PATH</code>.</p><p><sup>19</sup> Here I’m using Node v18, but I think anything newer than Node v16 should work. Emscripten is bundled with a version of Node, but I like using <a href="https://github.com/nvm-sh/nvm">nvm</a> to manage my Node installations.</p></div><p>Let’s continue compiling our C function for WebAssembly using Emscripten and running it using Node<a href="#fn19" id="fnref19" role="doc-noteref"><sup>19</sup></a>. We should see the same output as with our native binary.</p>
<div>
<p><span>[~/fortran]</span>emcc main.c foo.o -o main.js</p>
<p><span>[~/fortran]</span>node main.js</p>
<p>1 + 1 = 2</p>
</div>
</section>
<section id="interlude-calling-a-fortran-routine-from-javascript">
<h2 data-anchor-id="interlude-calling-a-fortran-routine-from-javascript">Interlude — Calling a Fortran routine from JavaScript</h2>
<p>In the previous section we used a C program to call Fortran code, but we don’t technically need to do that. If we tell Emscripten about the Fortran subroutine, we can call it directly from JavaScript without writing any C code.</p>
<p>First, let’s link our Fortran object with Emscripten, producing a script that loads our WebAssembly binary into memory but does not execute any routines. In addition to our symbol <code>_foo_</code>, we’ll also export <code>_malloc</code> and <code>_free</code> so that we can use them from JavaScript<a href="#fn20" id="fnref20" role="doc-noteref"><sup>20</sup></a>.</p>
<p><sup>20</sup> See the <a href="https://emscripten.org/docs/tools_reference/settings_reference.html">Emscripten documentation</a> for more details about <code>emcc</code> command line options. By the way, if you’ve not used Emscripten much before you might see extra <code>cache:INFO</code> lines emitted during various steps in this post. They are nothing to worry about and can be ignored.</p><div>
<p><span>[~/fortran]</span>emcc foo.o -sEXPORTED_FUNCTIONS=_foo_,_malloc,_free -o foo.js</p>
<p>cache:INFO: generating system asset: symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json... (this will be cached in &#34;.../emsdk/upstream/emscripten/cache/symbol_lists/ae47d07bfa3321ac4dde96bd87821b4aa93f9a19.json&#34; for subsequent builds)</p>
<p>cache:INFO:  - ok</p>
<p><span>[~/fortran]</span>node foo.js</p>
<p><span>[~/fortran]</span></p>
</div>
<p>Notice that when we run the script <code>foo.js</code> directly… nothing happens.</p>
<p>Next, we’ll write a JavaScript file that loads <code>foo.js</code> and then calls our Fortran subroutine. We’ll need to allocate some memory to hold our integers <code>x</code>, <code>y</code> and <code>z</code> using the exported <code>_malloc()</code> function. We’ll also need to set our input arguments <code>x</code> and <code>y</code> to some integer values, and we can do that by setting values in the allocated WebAssembly memory through <code>Module.HEAPU32</code><a href="#fn21" id="fnref21" role="doc-noteref"><sup>21</sup></a>.</p>
<div>

<div id="cb4" data-filename="standalone.js"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>var</span> Module <span>=</span> <span>require</span>(<span>&#39;./foo.js&#39;</span>)<span>;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>setTimeout</span>(() <span>=&gt;</span> {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span>const</span> x <span>=</span> Module<span>.</span><span>_malloc</span>(<span>4</span>)<span>;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span>const</span> y <span>=</span> Module<span>.</span><span>_malloc</span>(<span>4</span>)<span>;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span>const</span> z <span>=</span> Module<span>.</span><span>_malloc</span>(<span>4</span>)<span>;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>HEAPU32</span>[x <span>/</span> <span>4</span>] <span>=</span> <span>123</span><span>;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>HEAPU32</span>[y <span>/</span> <span>4</span>] <span>=</span> <span>456</span><span>;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>_foo_</span>(x<span>,</span> y<span>,</span> z)<span>;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span>console</span><span>.</span><span>log</span>(<span>&#34;x = &#34;</span><span>,</span> Module<span>.</span><span>HEAP32</span>[x <span>/</span> <span>4</span>])<span>;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span>console</span><span>.</span><span>log</span>(<span>&#34;y = &#34;</span><span>,</span> Module<span>.</span><span>HEAP32</span>[y <span>/</span> <span>4</span>])<span>;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span>console</span><span>.</span><span>log</span>(<span>&#34;x + y = &#34;</span><span>,</span> Module<span>.</span><span>HEAP32</span>[z <span>/</span> <span>4</span>])<span>;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>_free</span>(x)<span>;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>_free</span>(y)<span>;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  Module<span>.</span><span>_free</span>(z)<span>;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>}<span>,</span> <span>100</span>)<span>;</span></span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>node standalone.js</p>
<p>x =  123</p>
<p>y =  456</p>
<p>x + y =  579</p>
</div>
<p>You should also be able to run the resulting WebAssembly binary in a web browser. Remove the line <code><span>var</span> Module <span>=</span> <span>require</span>(<span>&#39;./foo.js&#39;</span>)<span>;</span></code> from <code>standalone.js</code>, and instead load the script <code>foo.js</code> in your HTML.</p>
<div>

<div id="cb5" data-filename="index.html"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>&lt;</span><span>html</span><span>&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span>&lt;</span><span>head</span><span>&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span>&lt;</span><span>title</span><span>&gt;</span>Fortran Demo<span>&lt;/</span><span>title</span><span>&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span>&lt;/</span><span>head</span><span>&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span>&lt;</span><span>body</span><span>&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span>&lt;</span><span>script</span><span> src</span><span>=</span><span>&#34;foo.js&#34;</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span>&lt;</span><span>script</span><span> src</span><span>=</span><span>&#34;standalone.js&#34;</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span>&lt;/</span><span>body</span><span>&gt;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span>&lt;/</span><span>html</span><span>&gt;</span></span></code></pre></div>
</div>
<p>Spin up a local web server<a href="#fn22" id="fnref22" role="doc-noteref"><sup>22</sup></a>, visit the page, and the same output should be seen in the browser’s JavaScript console.</p>
<p><sup>22</sup> Something like <code>Rscript -e &#39;httpuv::runStaticServer()&#39;</code> or <code>python3 -m http.server</code> should work well.</p></section>
<section id="the-fortran-runtime-library-a-journey-to-hello-world">
<h2 data-anchor-id="the-fortran-runtime-library-a-journey-to-hello-world">The Fortran runtime library: A journey to “Hello, World!”</h2>
<p>The ubiquitous “Hello, World!” test program is the usual way to introduce a programming language, but I didn’t introduce Fortran using such a program above. As you’ll see, that was for a good reason. Let’s see what happens when we try to build a “Hello, World!” subroutine in Fortran and call it from C. As before, we’ll compile the Fortran object using <code>flang-new</code> and use Emscripten to compile and link the C code.</p>
<div>

<div id="cb6" data-filename="hello.f08"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>SUBROUTINE</span> hello()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>IMPLICIT</span> <span>NONE</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>PRINT</span> <span>*</span>, <span>&#34;Hello, World!&#34;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>END</span></span></code></pre></div>
</div>
<div>

<div id="cb7" data-filename="hello.c"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>extern</span> <span>void</span> hello_<span>();</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    hello_<span>();</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>0</span><span>;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c hello.f08 -o hello.o</p>
<p><span>[~/fortran]</span>emcc hello.c hello.o -o hello.js</p>
<p>wasm-ld: error: hello.o: undefined symbol: _FortranAioBeginExternalListOutput</p>
<p>wasm-ld: error: hello.o: undefined symbol: _FortranAioOutputAscii</p>
<p>wasm-ld: error: hello.o: undefined symbol: _FortranAioEndIoStatement</p>
<p>emcc: error: &#39;wasm-ld -o hello.wasm [...] --no-entry --stack-first --table-base=1&#39; failed (returned 1)</p>
</div>
<p>The build failed due to some missing symbols. This is a consequence of a more general issue in that we have not yet compiled the LLVM Fortran runtime library for WebAssembly. There are a bunch of library symbols that we’re currently missing, including some functions that are required to print output!<a href="#fn23" id="fnref23" role="doc-noteref"><sup>23</sup></a></p>
<p>Luckily, the runtime library is written in C++ as part of the LLVM source tree at <code>llvm-project/flang/runtime</code>. So, in principle, all we need to do is build the library using Emscripten’s <code>em++</code> compiler and then link to it whenever we’re using Fortran code in our WebAssembly program.</p>
<p>Here is a <code>Makefile</code> designed to make this step easy. Save it<a href="#fn24" id="fnref24" role="doc-noteref"><sup>24</sup></a> in the current directory and then run <code>make</code>. It should go ahead and use the version of Emscripten on your path to build a static Fortran runtime library at <code>build/flang/runtime/libFortranRuntime.a</code>.</p>
<p><sup>24</sup> Be sure to indent the rules in this file using tabs, not spaces.</p><div>

<div id="cb8" data-filename="Makefile"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>ROOT</span> <span>=</span><span> </span><span>$(</span><span>abspath</span><span> .</span><span>)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>SOURCE</span> <span>=</span><span> </span><span>$(</span><span>ROOT</span><span>)</span><span>/llvm-project</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>BUILD</span> <span>=</span><span> </span><span>$(</span><span>ROOT</span><span>)</span><span>/build</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_SOURCES</span> <span>:=</span><span> </span><span>$(</span><span>wildcard</span><span> </span><span>$(</span><span>SOURCE</span><span>)</span><span>/flang/runtime/*.cpp</span><span>)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_SOURCES</span> <span>+=</span><span> </span><span>$(</span><span>SOURCE</span><span>)</span><span>/flang/lib/Decimal/decimal-to-binary.cpp</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_SOURCES</span> <span>+=</span><span> </span><span>$(</span><span>SOURCE</span><span>)</span><span>/flang/lib/Decimal/binary-to-decimal.cpp</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_OBJECTS</span> <span>=</span><span> </span><span>$(</span><span>patsubst</span><span> </span><span>$(</span><span>SOURCE</span><span>)</span><span>/%</span><span>,</span><span>$(</span><span>BUILD</span><span>)</span><span>/%</span><span>,</span><span>$(</span><span>RUNTIME_SOURCES</span><span>:</span><span>.cpp</span><span>=</span><span>.o</span><span>))</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -I</span><span>$(</span><span>BUILD</span><span>)</span><span>/include -I</span><span>$(</span><span>BUILD</span><span>)</span><span>/tools/flang/runtime</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -I</span><span>$(</span><span>SOURCE</span><span>)</span><span>/flang/include -I</span><span>$(</span><span>SOURCE</span><span>)</span><span>/llvm/include</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -DFLANG_LITTLE_ENDIAN</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -fPIC -Wno-c++11-narrowing -fvisibility=hidden</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -DFE_UNDERFLOW=0 -DFE_OVERFLOW=0 -DFE_INEXACT=0</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span>RUNTIME_CXXFLAGS</span> <span>+=</span><span> -DFE_INVALID=0 -DFE_DIVBYZERO=0 -DFE_ALL_EXCEPT=0</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span>$(BUILD)/flang/runtime/libFortranRuntime.a:</span><span> </span><span>$(</span><span>RUNTIME_OBJECTS</span><span>)</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span>    </span><span>@</span><span>rm -f </span><span>$@</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    emar -rcs <span>$@</span> <span>$^</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span>$(BUILD)%.o :</span><span> </span><span>$(</span><span>SOURCE</span><span>)</span><span>%.cpp</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span>    </span><span>@</span><span>mkdir -p </span><span>$(</span><span>@D</span><span>)</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    em++ <span>$(</span><span>RUNTIME_CXXFLAGS</span><span>)</span> -o <span>$@</span> -c <span>$&lt;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span>.PHONY:</span><span> clean</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span>clean:</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span>    </span><span>@</span><span>rm </span><span>$(</span><span>RUNTIME_OBJECTS</span><span>)</span><span> </span><span>$(</span><span>BUILD</span><span>)</span><span>/flang/runtime/libFortranRuntime.a</span></span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>make</p>
<p>em++ .../ISO_Fortran_binding.o -c .../ISO_Fortran_binding.cpp</p>
<p>em++ .../allocatable.o -c .../allocatable.cpp</p>
<p>em++ .../array-constructor.o -c .../array-constructor.cpp</p>
<p>...</p>
<p>emar -rcs build/flang/runtime/libFortranRuntime.a .../binary-to-decimal.o</p>
<p><span>[~/fortran]</span>file build/flang/runtime/libFortranRuntime.a</p>
<p>build/flang/runtime/libFortranRuntime.a: current ar archive</p>
</div>
<p>Let’s try again, linking in our shiny new library as part of the Emscripten build step.</p>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c hello.f08 -o hello.o</p>
<p><span>[~/fortran]</span>emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o hello.js</p>
<p>wasm-ld: <span>warning:</span> function signature mismatch: _FortranAioOutputAscii</p>
<p>&gt;&gt;&gt; defined as (i32, i32, i64) -&gt; i32 in hello.o</p>
<p>&gt;&gt;&gt; defined as (i32, i32, i32) -&gt; i32 in build/flang/runtime/libFortranRuntime.a(io-api.o)</p>
</div>
<p>Success? Not quite. A warning is issued, letting us know about a signature mismatch. Emscripten has compiled the symbol <code>_FortranAioOutputAscii</code> to take three <code>i32</code> arguments<a href="#fn25" id="fnref25" role="doc-noteref"><sup>25</sup></a>. However, <code>flang-new</code> has compiled <code>hello.f08</code> with the expectation that the symbol takes two <code>i32</code> arguments and a single <code>i64</code> argument.</p>
<div><p><sup>25</sup> This is <a href="https://llvm.org/docs/LangRef.html#integer-type">LLVM IR notation</a>, meaning an integer of size 32 bits.</p><p><sup>26</sup> This continues to crop up when compiling R packages for webR. Package authors or vendored libraries may have used tools such as <code>f2c</code> that declare a Fortran <code>SUBROUTINE</code> to return an <code>int</code>, while other libraries might declare a Fortran <code>SUBROUTINE</code> to return <code>void</code>. Who is right? I’m not sure, as I understand it early Fortran did not have a standard interface to C. Personally, I think returning <code>void</code> makes most sense.</p></div><p>This is unfortunate. Despite being emitted as just a warning, if you try running the emitted program using Node you will see that the problem is catastrophic. WebAssembly, unlike a lot of target systems, absolutely requires that symbols defined over multiple compilation units have consistent function signatures, both in argument and return type<a href="#fn26" id="fnref26" role="doc-noteref"><sup>26</sup></a>.</p>
<div>
<p><span>[~/fortran]</span>node hello.js</p>
<p>.../fortran/hello.js:128</p>
<p>    throw ex;</p>
<p>    ^</p>
<p>RuntimeError: unreachable</p>
<p>  at wasm://wasm/001a0366:wasm-function[20]:0x15d9</p>
<p>  at removeRunDependency (/Users/georgestagg/fortran/hello.js:630:7)</p>

<p>Node.js v18.18.0</p>
</div>
<p>Rather than going over the debugging process that eventually leads us to what is going on here, let me point you directly to the cause of the problem. Take a look at this comment from the LLVM source:</p>
<div>
<div>
<pre><strong>flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h</strong></pre>
</div>
<div id="cb9" data-filename="flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>//===----------------------------------------------------------------------===//</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span>// Type builder models</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>//===----------------------------------------------------------------------===//</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>// </span><span>TODO</span><span>: all usages of sizeof in this file assume build ==  host == target.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>// This will need to be re-visited for cross compilation.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span>/// Return a function that returns the type signature model for the type `T`</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span>/// when provided an MLIRContext*. This allows one to translate C(++) function</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span>/// signatures from runtime header files to MLIR signatures into a static table</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span>/// at compile-time.</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span>///</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span>/// For example, when `T` is `int`, return a function that returns the MLIR</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span>/// standard type `i32` when `sizeof(int)` is 4.</span></span></code></pre></div>
</div>
<p>And therein lies the problem. For us, the host is different to the target, breaking assumptions in the LLVM source code. Surprisingly, this does not cause as much chaos as you might expect. From what I can tell, this machinery is used only to make the Fortran runtime library functions, written in C++, available to Fortran. There is a compile-time calculation using <code>sizeof()</code>, and since most of the sizes match anyway<a href="#fn27" id="fnref27" role="doc-noteref"><sup>27</sup></a> it mostly works fine.</p>
<p><sup>27</sup> The <a href="https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models">C data model</a> for the host and target defines how many bits certain fundamental C types are represented with. The specific sizes can differ based on the hardware architecture and your OS.</p><p>Unfortunately for us, assuming you’re following along on a modern 64-bit Unix-like system such as Linux or macOS, the sizes don’t match for the <code>long</code> data type. The result of <code>sizeof(long)</code> on our compiler’s host platform is 8 bytes (<code>i64</code>), but for the target platform of <code>wasm32-unknown-emscripten</code> the returned value should be 4 bytes (<code>i32</code>).</p>
<p>When we compile the Fortran runtime library C++ code using Emscripten, things are fine. The resulting symbols are compiled with signatures such that <code>long</code> arguments are <code>i32</code>. However, when we compile our Fortran code with <code>flang-new</code> the external library symbols are declared such that <code>long</code> arguments are <code>i64</code>. This difference leads to the inconsistent function signature warning and runtime failure.</p>
<p>Why did using <code>PRINT()</code> in our “Hello, World!” program invoke a function that takes an argument of type <code>long</code>? Well, in some implementations of Fortran there are so-called “hidden” arguments that are added whenever you pass a Fortran <code>CHARACTER</code> type to a function or subroutine. These extra arguments pass in the length of the strings. In the Fortran runtime library the hidden arguments are declared with type <code>size_t</code> which, following a chain of <code>typedef</code>s, ends up being the same as <code>unsigned long</code>. This hidden implicit argument is the one with inconsistent size.</p>
</section>
<section id="hacking-around-the-issue">
<h2 data-anchor-id="hacking-around-the-issue">Hacking around the issue</h2>
<p>Unfortunately, I don’t know enough about the LLVM or Flang internals to implement a real solution to this problem. Ideally, <code>flang-new</code> would emit the correct use of <code>i32</code> or <code>i64</code> for the target architecture and data model when cross-compiling, no matter the host architecture the compiler is running on.</p>
<p>Since I can’t solve this today, let’s hack around it for now. We’ll build a version of <code>flang-new</code> with the size of a <code>long</code> hard-coded to what we need for <code>wasm32</code> and Emscripten. We’ll also make some changes so that calls to <code>malloc()</code> from Fortran are emitted with an <code>i32</code> argument<a href="#fn28" id="fnref28" role="doc-noteref"><sup>28</sup></a>.</p>
<p><sup>28</sup> This additionally fixes dynamic allocation with <code>ALLOCATE()</code>, a feature introduced in Fortran 90.</p><p>The required patches are again shown as a diff below. If you’re following along, save it as a file named <code>force-4-byte-values.diff</code> and apply it to the <code>llvm-project</code> directory using <code>git</code> or the <code>patch</code> utility. Finally, recompile <code>flang-new</code> once more.</p>
<div>

<div id="cb10" data-filename="force-4-byte-values.diff"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>diff --git a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>index b3fe52f4b..c3c7326da 100644</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>--- a/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>+++ b/flang/include/flang/Optimizer/Builder/Runtime/RTBuilder.h</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span>@@ -146,7 +146,7 @@ constexpr TypeBuilderFunc getModel&lt;void **&gt;() {</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a> template &lt;&gt;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a> constexpr TypeBuilderFunc getModel&lt;long&gt;() {</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>   return [](mlir::MLIRContext *context) -&gt; mlir::Type {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>-    return mlir::IntegerType::get(context, 8 * sizeof(long));</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span>+    return mlir::IntegerType::get(context, 8 * 4);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>   };</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a> template &lt;&gt;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span>@@ -187,7 +187,7 @@ constexpr TypeBuilderFunc getModel&lt;long long *&gt;() {</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a> template &lt;&gt;</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a> constexpr TypeBuilderFunc getModel&lt;unsigned long&gt;() {</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>   return [](mlir::MLIRContext *context) -&gt; mlir::Type {</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span>-    return mlir::IntegerType::get(context, 8 * sizeof(unsigned long));</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span>+    return mlir::IntegerType::get(context, 8 * 4);</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>   };</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a> template &lt;&gt;</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span>diff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>index ba5946415..2931753a8 100644</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span>--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span>+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span>@@ -1225,7 +1225,7 @@ getMalloc(fir::AllocMemOp op, mlir::ConversionPatternRewriter &amp;rewriter) {</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>     return mlir::SymbolRefAttr::get(userMalloc);</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>   mlir::OpBuilder moduleBuilder(</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>       op-&gt;getParentOfType&lt;mlir::ModuleOp&gt;().getBodyRegion());</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span>-  auto indexType = mlir::IntegerType::get(op.getContext(), 64);</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span>+  auto indexType = mlir::IntegerType::get(op.getContext(), 32);</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>   auto mallocDecl = moduleBuilder.create&lt;mlir::LLVM::LLVMFuncOp&gt;(</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>       op.getLoc(), mallocName,</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>       mlir::LLVM::LLVMFunctionType::get(getLlvmPtrType(op.getContext()),</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span>@@ -1281,6 +1281,7 @@ struct AllocMemOpConversion : public FIROpConversion&lt;fir::AllocMemOp&gt; {</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>     mlir::Type heapTy = heap.getType();</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>     mlir::Location loc = heap.getLoc();</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>     auto ity = lowerTy().indexType();</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span>+    auto i32ty = mlir::IntegerType::get(rewriter.getContext(), 32);</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>     mlir::Type dataTy = fir::unwrapRefType(heapTy);</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>     mlir::Type llvmObjectTy = convertObjectType(dataTy);</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>     if (fir::isRecordWithTypeParameters(fir::unwrapSequenceType(dataTy)))</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a><span>@@ -1291,9 +1292,10 @@ struct AllocMemOpConversion : public FIROpConversion&lt;fir::AllocMemOp&gt; {</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>     for (mlir::Value opnd : adaptor.getOperands())</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>       size = rewriter.create&lt;mlir::LLVM::MulOp&gt;(</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>           loc, ity, size, integerCast(loc, rewriter, ity, opnd));</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a><span>+    auto size_i32 = integerCast(loc, rewriter, i32ty, size);</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>     heap-&gt;setAttr(&#34;callee&#34;, getMalloc(heap, rewriter));</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>     rewriter.replaceOpWithNewOp&lt;mlir::LLVM::CallOp&gt;(</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a><span>-        heap, ::getLlvmPtrType(heap.getContext()), size, heap-&gt;getAttrs());</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a><span>+        heap, ::getLlvmPtrType(heap.getContext()), size_i32, heap-&gt;getAttrs());</span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>     return mlir::success();</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>   }</span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>patch -p1 -d llvm-project &lt; force-4-byte-values.diff</p>
<p><span>[~/fortran]</span>cmake --build build</p>
<p>[0/60] Building CXX object tools/flang/lib/Lower/Runtime.cpp.o</p>
<p>...</p>
<p>[49/49] Generating ../../../../include/flang/ieee_arithmetic.f18.mod</p>
</div>
<p>Once LLVM has been rebuilt, try compiling our program once again. This time, it should compile without any warnings and successfully run under Node:</p>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c hello.f08 -o hello.o</p>
<p><span>[~/fortran]</span>emcc hello.c hello.o build/flang/runtime/libFortranRuntime.a -o hello.js</p><p><span>[~/fortran]</span>node hello.js</p>
<p> Hello, World!</p>
</div>
</section>
</section>
<section id="compiling-blas-and-lapack-for-webassembly">

<p>Now that we have a Fortran compiler that can output WebAssembly objects, let’s build some Fortran projects. <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> (Basic Linear Algebra Subprograms) is a set of low-level routines that perform many common operations in linear algebra, including tools for matrix and vector multiplication. They are a de facto standard in numerical computation, with several different implementations of the BLAS routines available. Some implementations have been tuned for use on certain hardware<a href="#fn29" id="fnref29" role="doc-noteref"><sup>29</sup></a>, others have been well optimised on account of being around for a long time — the original BLAS routines were released in 1979!</p>
<div><p><sup>29</sup> See, for example, the <a href="https://www.intel.com/content/www/us/en/docs/onemkl/get-started-guide/2024-0/overview.html">Intel Math Kernel Library</a>.</p><p><sup>30</sup> Considered to be in the public domain. The actual <a href="https://www.netlib.org/blas/#_licensing">licence terms</a> are short and say that it is a “freely-available software package”.</p></div><p>Let’s grab a copy of the latest release of the so-called “reference implementation” of BLAS<a href="#fn30" id="fnref30" role="doc-noteref"><sup>30</sup></a>, written in Fortran 90, and compile it using the patched LLVM we built above.</p>
<div>
<p><span>[~/fortran]</span>curl -L https://www.netlib.org/blas/blas-3.12.0.tgz &gt; blas-3.12.0.tgz</p>
<p>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>
<p>                                 Dload  Upload   Total   Spent    Left  Speed</p>
<p>100  323k  100  323k    0     0   317k      0  0:00:01  0:00:01 --:--:--  317k</p>
<p><span>[~/fortran]</span>tar xzf blas-3.12.0.tgz</p>
</div>
<p>We’ll need to modify <code>BLAS-3.12.0/make.inc</code> to tell it about our version of <code>flang-new</code> and the Emscripten tools. Modify the following settings, leaving the other lines in that file as they are, then build BLAS using <code>make</code>.</p>
<div>

<div id="cb11" data-filename="BLAS-3.12.0/make.inc"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>FC</span> <span>=</span><span> ../build/bin/flang-new</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>FFLAGS</span> <span>=</span><span> -O2</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>FFLAGS_NOOPT</span> <span>=</span><span> -O0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>AR</span> <span>=</span><span> emar</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span>RANLIB</span> <span>=</span><span> emranlib</span></span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>cd BLAS-3.12.0</p>
<p><span>[~/fortran/BLAS-3.12.0]</span>make</p>
<p>../build/bin/flang-new -O2  -c -o isamax.o isamax.f</p>
<p>../build/bin/flang-new -O2  -c -o sasum.o sasum.f</p>
<p>...</p>
<p>emar cr blas_LINUX.a isamax.o ... xerbla_array.o</p>
<p>emranlib blas_LINUX.a</p>
<p><span>[~/fortran/BLAS-3.12.0]</span>cd ..</p>
<p><span>[~/fortran]</span></p>
</div>
<p>That went pretty well! Let’s try using it in a Fortran subroutine compiled for WebAssembly. For fun, we’ll try working with double precision complex numbers. We’ll use the BLAS level 2 routine <a href="https://netlib.org/lapack/explore-html-3.6.1/dc/dc1/group__complex16__blas__level2_gafaeb2abd9fffa7442b938dc384aeaf47.html#gafaeb2abd9fffa7442b938dc384aeaf47"><code>ZGEMV()</code></a>, which performs the matrix-vector operation</p>
<p><span>\[\begin{equation}
\mathbf{y} \leftarrow \alpha\mathbf{A}\mathbf{x} + \beta\mathbf{y},
\end{equation}\]</span></p>
<p>where <span>\(\alpha\)</span> and <span>\(\beta\)</span> are scalar constants, <span>\(\mathbf{x}\)</span> and <span>\(\mathbf{y}\)</span> are vectors, and <span>\(\mathbf{A}\)</span> is a matrix. Our Fortran routine will take in <code>alpha</code>, <code>beta</code>, <code>A</code>, <code>X</code>, and <code>Y</code>, with a fixed parameter <code>N</code> so that <span>\(\mathbf{A}\)</span> is a square matrix with three rows and columns. The result is written back into <span>\(\mathbf{y}\)</span>, so we declare that <code>Y</code> is of intent <code>INOUT</code>.</p>
<div>

<div id="cb12" data-filename="bar.f08"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>SUBROUTINE</span> bar(alpha, A, X, beta, Y)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span>IMPLICIT</span> <span>NONE</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>INTEGER</span>, <span>PARAMETER</span> <span>::</span> N <span>=</span> <span>3</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>COMPLEX(KIND=8)</span>, <span>INTENT(IN)</span> <span>::</span> alpha, beta, A(N,N), X(N)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span>COMPLEX(KIND=8)</span>, <span>INTENT(INOUT)</span> <span>::</span> Y(N)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span>EXTERNAL</span> zgemv</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span>CALL</span> zgemv(<span>&#39;N&#39;</span>, N, N, alpha, A, N, X, <span>1</span>, beta, Y, <span>1</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span>END</span></span></code></pre></div>
</div>
<p>Notice how with some BLAS routines, <code>CHARACTER</code> strings of length one control configuration settings. Here, we pass <code>&#39;N&#39;</code> as the first argument. It is one of the reasons we spent time and care above building a version of <code>flang-new</code> that can deal with <code>CHARACTER</code> arguments and their hidden implicit length arguments for the <code>wasm32</code> target.</p>
<p>Next, we’ll write a C program to create some complex variables, send them to Fortran and BLAS for processing, and print the result. This will let us know both that passing double precision complex numbers to Fortran and calling BLAS routines works as expected.</p>
<div>

<div id="cb13" data-filename="bar.c"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;complex.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span>extern</span> <span>void</span> bar_<span>(</span><span>double</span> <span>complex</span><span>*,</span> <span>double</span> <span>complex</span><span>*,</span> <span>double</span> <span>complex</span><span>*,</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                 <span>double</span> <span>complex</span><span>*,</span> <span>double</span> <span>complex</span><span>*);</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span>int</span> main<span>()</span> <span>{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span>double</span> <span>complex</span> alpha <span>=</span> <span>1.</span><span>;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span>double</span> <span>complex</span> beta <span>=</span> <span>2.</span><span>*</span>I<span>;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span>double</span> <span>complex</span> A<span>[]</span> <span>=</span> <span>{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span>1.</span><span>*</span>I<span>,</span> <span>4.</span>  <span>,</span> <span>5.</span><span>,</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span>7.</span>  <span>,</span> <span>2.</span><span>*</span>I<span>,</span> <span>6.</span><span>,</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span>8.</span>  <span>,</span> <span>9.</span>  <span>,</span> <span>3.</span><span>*</span>I</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span>};</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span>double</span> <span>complex</span> X<span>[]</span> <span>=</span> <span>{</span> <span>0.</span><span>,</span> <span>1.</span><span>,</span> <span>2.</span> <span>};</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  <span>double</span> <span>complex</span> Y<span>[]</span> <span>=</span> <span>{</span> <span>3.</span><span>,</span> <span>4.</span><span>,</span> <span>5.</span> <span>};</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  bar_<span>(&amp;</span>alpha<span>,</span> A<span>,</span> X<span>,</span> <span>&amp;</span>beta<span>,</span> Y<span>);</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  printf<span>(</span><span>&#34;Y[0]: </span><span>%f</span><span> + </span><span>%f</span><span>i, Y[1]: </span><span>%f</span><span> + </span><span>%f</span><span>i, Y[2]: </span><span>%f</span><span> + </span><span>%f</span><span>i</span><span>\n</span><span>&#34;</span><span>,</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>         creal<span>(</span>Y<span>[</span><span>0</span><span>]),</span> cimag<span>(</span>Y<span>[</span><span>0</span><span>]),</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>         creal<span>(</span>Y<span>[</span><span>1</span><span>]),</span> cimag<span>(</span>Y<span>[</span><span>1</span><span>]),</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>         creal<span>(</span>Y<span>[</span><span>2</span><span>]),</span> cimag<span>(</span>Y<span>[</span><span>2</span><span>]));</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>0</span><span>;</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
</div>
<div>
<p><span>[~/fortran]</span>./build/bin/flang-new -c bar.f08 -o bar.o</p>
<p><span>[~/fortran]</span>emcc bar.c bar.o build/flang/runtime/libFortranRuntime.a BLAS-3.12.0/blas_LINUX.a -o bar.js</p>
<p><span>[~/fortran]</span>node bar.js</p>
<p>Y[0]: 23.000000 + 6.000000i, Y[1]: 18.000000 + 10.000000i, Y[2]: 6.000000 + 16.000000i</p>
</div>
<p>And there we have it: BLAS compiled from Fortran 90 sources and running under WebAssembly! To finish up, let’s confirm for ourselves that this output is correct<a href="#fn31" id="fnref31" role="doc-noteref"><sup>31</sup></a>,</p>
<p><sup>31</sup> Keeping in mind Fortran’s column-major array layout.</p><p><span>\[\begin{equation}
\begin{split}
\alpha\mathbf{A}\mathbf{x} &amp; + \beta\mathbf{y} \\[0.5em]
&amp; =
\begin{pmatrix}
  i &amp; 7 &amp; 8\\
  4 &amp; 2i &amp; 9\\
  5 &amp; 6 &amp; 3i
\end{pmatrix}
\cdot
\begin{pmatrix}
  0\\1\\2
\end{pmatrix}
+ 2i
\begin{pmatrix}
  3\\4\\5
\end{pmatrix}\\[0.5em]
&amp; =
\begin{pmatrix}
  23+6i\\18+10i\\6+16i
\end{pmatrix}.
\end{split}
\end{equation}\]</span></p>
<section id="mnist">
<h2 data-anchor-id="mnist">Example: A handwritten digit classifier</h2>
<p>The following demo uses a <a href="https://en.wikipedia.org/wiki/Multilayer_perceptron">multi-layer perceptron (MLP)</a> artificial neural network to classify hand-drawn digits. Try it out with your mouse or touchscreen! Just draw a digit from 0-9 in the box, and the classifier will try to label what digit you wrote. The relative probabilities according to the network are shown in a plot on the right.</p>

<p>It’s not a perfect model, but it works fairly well for me! The weights powering the model have been pre-trained using Python, but the classification is performed at runtime using JavaScript and WebAssembly, running in your browser right now.</p>
<p>With an MLP network, the classification process is essentially a repeated application of matrix-vector addition and multiplication. In this demo the heavy lifting is done by a single Fortran subroutine making use of the BLAS level 2 routine <a href="https://netlib.org/lapack/explore-html-3.6.1/d7/d15/group__double__blas__level2_gadd421a107a488d524859b4a64c1901a9.html"><code>DGEMV()</code></a>.</p>
</section>
<section id="building-lapack">
<h2 data-anchor-id="building-lapack">Building LAPACK</h2>
<p><a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">LAPACK</a> (Linear Algebra Package) is a software library for solving linear algebra problems numerically. It’s built upon BLAS and has similarly become a standard with many reimplementations designed for specific hardware or systems.</p>
<p>Let’s finish this post by also building the “reference implementation” of LAPACK<a href="#fn32" id="fnref32" role="doc-noteref"><sup>32</sup></a>.</p>
<p><sup>32</sup> Also available from <a href="https://www.netlib.org/lapack/">netlib</a>, released under a modified BSD licence.</p><div>
<p><span>[~/fortran]</span>curl -L https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.0.tar.gz &gt; lapack-3.12.0.tgz</p>
<p>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</p>
<p>                                 Dload  Upload   Total   Spent    Left  Speed</p>
<p>100 7747k    0 7747k    0     0  4117k      0 --:--:--  0:00:01 --:--:-- 6655k</p>
<p><span>[~/fortran]</span>tar xzf lapack-3.12.0.tgz</p>
</div>
<p>Similar to BLAS, we need to modify some configuration options to let LAPACK know about Emscripten and <code>flang-new</code>. Copy the file <code>lapack-3.12.0/make.inc.example</code> to <code>lapack-3.12.0/make.inc</code>, then make the following modifications. Be sure to replace <code>[...]</code> with the full path to the build directory on your machine<a href="#fn33" id="fnref33" role="doc-noteref"><sup>33</sup></a>, and leave the other options in the file as they are.</p>
<p><sup>33</sup> A relative path doesn’t work here. Alternatively, simply set the option to read <code>flang-new</code> and make it available on your <code>$PATH</code>.</p><div>

<div id="cb14" data-filename="lapack-3.12.0/make.inc"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>FC</span> <span>=</span><span> [...]/build/bin/flang-new</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>FFLAGS</span> <span>=</span><span> -O2</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>FFLAGS_DRV</span> <span>=</span><span> </span><span>$(</span><span>FFLAGS</span><span>)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span>FFLAGS_NOOPT</span> <span>=</span><span> -O0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>AR</span> <span>=</span><span> emar</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span>RANLIB</span> <span>=</span><span> emranlib</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span>TIMER</span> <span>=</span><span> INT_CPU_TIME</span></span></code></pre></div>
</div>
<p>Then, build LAPACK using the <code>make lib</code> command to create the WebAssembly static library <code>liblapack.a</code>.</p>
<div>
<p><span>[~/fortran]</span>cd lapack-3.12.0</p>
<p><span>[~/fortran/lapack-3.12.0]</span>make lib</p>
<p>make -C SRC</p>
<p>.../build/bin/flang-new -O2  -c -o sbdsvdx.o sbdsvdx.f</p>
<p>...</p>
<p>emar cr ../../libtmglib.a slatms.o ... dlarnd.o</p>
<p>emranlib ../../libtmglib.a</p>
<p><span>[~/fortran/lapack-3.12.0]</span>cd ..</p>
<p><span>[~/fortran]</span></p>
<p><span>[~/fortran]</span>file lapack-3.12.0/liblapack.a</p>
<p>lapack-3.12.0/liblapack.a: current ar archive</p>
</div>
<p>With this, LAPACK routines can be called in a similar way to the BLAS routine example in the previous section.</p>
</section>
<section id="example-polynomial-interpolation-with-linear-algebra">
<h2 data-anchor-id="example-polynomial-interpolation-with-linear-algebra">Example: Polynomial Interpolation with Linear Algebra</h2>
<p>The following demo finds interpolating polynomials for a set of points, demonstrating LAPACK routines running in your web browser.</p>
<p>Click the plot to add new points. An interpolating polynomial will be found to pass through all the points using <a href="https://en.wikipedia.org/wiki/Vandermonde_matrix">Vandermonde’s method</a><a href="#fn34" id="fnref34" role="doc-noteref"><sup>34</sup></a>. The linear algebra equation given by this method is then solved numerically in LAPACK using the <a href="https://netlib.org/lapack/explore-html-3.6.1/d7/d3b/group__double_g_esolve_ga1df516c81d3e902cca1fc79a7220b9cb.html#ga1df516c81d3e902cca1fc79a7220b9cb"><code>DGELS()</code></a> routine.</p>
<p><sup>34</sup>  It is always possible to find an <span>\(n-1\)</span> degree polynomial containing <span>\(n\)</span> data points exactly. However, when <span>\(n\)</span> is large the polynomial fluctuates wildly between successive data points. This problem is known as <a href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon">Runge’s phenomenon</a> and can be avoided by using <a href="https://en.wikipedia.org/wiki/Spline_interpolation">spline interpolation</a>.</p>
</section>
</section>
<section id="final-thoughts">

<p>If you followed along at home, you now have a version of LLVM Flang that can compile modern Fortran code into WebAsembly objects. As I mentioned earlier, while it’s always been possible to build numerical algorithms for the web using JavaScript, to me the beauty of this approach is it allows you to use powerful Fortran tools and libraries that already exist, avoiding time and effort rewriting large collections of numerical routines for the web.</p>
<p>It would be wonderful if WebAssembly could be officially supported by the <code>flang-new</code> compiler. It would certainly lessen the burden of maintaining a fork of LLVM for <a href="https://github.com/r-wasm/webr">webR</a> and its R packages. However, without some help and support from a more experienced compiler developer, we will need to continue using a patched version for now.</p>
<p>If you’re familiar with LLVM Flang and know a better route to fixing the issues described above in a way that works for all targets with cross-compilation, feel free to <a href="mailto:george@stagg.phd">email me</a>. I’d be very interested to hear.</p>
<p>If you’d like to experiment with compiling Fortran code for WebAssembly but can’t or don’t want to build LLVM Flang from scratch, we provide a Docker container with <a href="https://github.com/r-wasm/flang-wasm/pkgs/container/flang-wasm">a binary version of our patched LLVM Flang</a> in the GitHub container registry.</p>


</section>


</main> <!-- /main -->

</div></div>
  </body>
</html>
