<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nowotarski.info/http2-continuation-flood-technical-details/">Original</a>
    <h1>HTTP/2 Continuation Flood: Technical Details</h1>
    
    <div id="readability-page-1" class="page"><p><strong>tl;dr:</strong>
			Deep technical analysis of the <code>CONTINUATION</code> Flood: a class of vulnerabilities within numerous HTTP/2 protocol implementations. In many cases, it poses a more severe threat compared to the Rapid Reset: a single machine (and in certain instances, a mere single TCP connection or a handful of frames) has the potential to disrupt server availability, with consequences ranging from server crashes to substantial performance degradation. Remarkably, requests that constitute an attack are not visible in HTTP access logs. <strong>A simplified security advisory and list of affected projects can be found in: <a href="https://nowotarski.info/http2-continuation-flood/">HTTP/2 <code>CONTINUATION</code> Flood</a>.</strong>
		</p><section>
			
<p>In October 2023 I learnt about HTTP/2 Rapid Reset attack, dubbed <a href="https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps">“the largest DDoS attack to date”</a>. I didn’t have deep knowledge of HTTP/2 back then. I knew it’s basics like frames or HPACK but I was focusing more on <a href="https://nowotarski.info/http-chunk-extensions/">HTTP/1.1 protocol</a> and <a href="https://nowotarski.info/golang-textproto-reader/">programming languages</a> vulnerabilities. I decided to dedicate time to exploring HTTP/2 from a security analysis perspective after concluding my then-current research.</p>

<p>The main difference between HTTP/1.1 and HTTP/2 is that the later is a binary protocol and client and server exchange <em>frames</em> instead of text lines. There are many frame types, including some control frames that does not transmit data but rather allow configuration of an HTTP/2 session (like <code>SETTINGS</code> or <code>WINDOW_UPDATE</code>). To make this vulnerability easy to understand I need to present two frames: <code>HEADERS</code> frame and <code>CONTINUATION</code> frame. For those who would like to catch up, the best way to learn it is by reading <a href="https://datatracker.ietf.org/doc/html/rfc9204">RFC9204</a>.</p>

<p><img src="https://nowotarski.info/continuation_frames_light.svg"/>

</p>

<p><img src="https://nowotarski.info/continuation_frames_dark.svg"/>

</p>

<p><code>HEADERS</code> frames allow sending HTTP headers of, both, request and response. The headers are stored in field block fragment and are encoded using <code>HPACK</code>, encoding algorithm that allows compression of header data. It is using static and dynamic tables of commonly used headers and Huffman encoding for the rest of headers. As other frames, this one can have some flags set, along them:</p>
<ul>
<li><code>END_HEADERS</code>: when set, tells the counterparty that this frame contains all the headers they wanted to send,</li>
<li><code>END_STREAM</code>: when set, tells the counterparty that there will be no request/response body.</li>
</ul>
<p>The frames also have a maximum size, configured at the beginning of communication. If a received frame exceeds the allowed size the connection is dropped with a protocol error. So what happens if a single <code>HEADER</code> frame is not enough to store all the headers? It sends the frame with <code>END_HEADERS</code> flag unset and continues the stream of headers using <code>CONTINUATION</code> frame.</p>
<h2 id="continuation-frame"><code>CONTINUATION</code> frame</h2>
<p><code>CONTINUATION</code> frames are very similar to <code>HEADER</code> frames but they have just one flag: <code>END_HEADERS</code> which has the same function: when set the counterparty knows that more headers are coming in the following <code>CONTINUATION</code> frames.</p>
<p>To sum it up, if headers exceed a single frame allowed size they are split in a frame stream:</p>
<ul>
<li><code>HEADERS</code> (no <code>END_HEADERS</code> flag),</li>
<li><code>CONTINUATION</code> (no flags),</li>
<li><code>CONTINUATION</code> (no flags),</li>
<li>…</li>
<li><code>CONTINUATION</code> (<code>END_HEADERS</code> <strong>set</strong>),</li>
</ul>

<p><img src="https://nowotarski.info/continuation_good_light.svg"/>

</p>

<p><img src="https://nowotarski.info/continuation_good_dark.svg"/>

</p>
<p>After the last frame, either <code>DATA</code> frame is sent (contains request data) or HTTP/2 stream ends.</p>

<p>What if a client starts a new HTTP/2 stream and sends <code>HEADERS</code> and <code>CONTINUATION</code> frames but <code>END_HEADERS</code> flag is <strong>never</strong> set? This would create an infinite stream of headers that HTTP/2 server would need to parse and store in memory.</p>

<p><img src="https://nowotarski.info/continuation_bad_light.svg"/>

</p>

<p><img src="https://nowotarski.info/continuation_bad_dark.svg"/>

</p>
<p>In HTTP/1.1 world, servers are protected from infinite headers by two mechanisms:</p>
<ul>
<li>Header size limit: if headers list exceed the allowed size, the connection is dropped.</li>
<li>Request / headers timeouts: if the request/headers are not sent in timely manner, the connection is dropped.</li>
</ul>
<p>In the last couple of months I checked dozens of implementations and, somehow, these protections were not implemented (or implemented incorrectly) even in major HTTP/2 servers, most notably: Apache httpd, Envoy and many HTTP/2 packages or codecs. I can divide outcomes of the bugs related to this vulnerability in the following categories:</p>
<ul>
<li>CPU exhaustion. Reading the extra headers cause increased CPU usage, it results in slowness responding to other requests but in many cases it was just a matter of number of active HTTP/2 connections that are required to completely block the server from responding.</li>
<li>Out Of Memory crash using multiple connections. Headers from <code>CONTINUATION</code> frames are stored in memory but there is a headers list size limit. At the same time there is no headers timeout. This means that an attacker can send headers up to the limit and just wait. Each connection occupies memory indefinietly.</li>
<li>Out Of Memory crash using a <strong>single</strong> connection. Some implementations simply kept reading headers into memory until memory was full which forced the OS to kill the process.</li>
<li>Crash after a <strong>few frames sent</strong>. This is a special, most severe category. Just a few frames are required to crash the server because of implementation bugs when a connection is disconnected mid-<code>CONTINUATION</code> stream.</li>
</ul>
<p>No <code>END_HEADERS</code> flag means that a request is not properly closed. Requests of malicious client would not be saved to access log making this attack hard to debug: in many cases analyzing raw traffic bytes would be necessary to understand the nature of this vulnerability.</p>
<p>In next sections I will demonstrate cases above using real vulnerabilities found in production code.</p>
<h2 id="cpu-exhaustion-golang-case">CPU exhaustion: Golang case</h2>
<p>Golang was an example of the CPU exhaustion caused by <code>CONTINUATION</code> Flood. As many other implementations, Golang devs built an abstraction class called <code>http2MetaHeadersFrame</code> which encapsulates one <code>HEADERS</code> frame and zero or more <code>CONTINUATION</code> frames, and their HPACK decoder. Headers data is processed within a single call to <code>readMetaFrame</code> (<code>h2_bundle.go</code> from Go 1.21.3).</p>
<p>The HPACK decoder in Golang has multiple params and modes. One of them is <code>SetEmitEnabled</code> which enables or disables emitting of decoded headers. This is done to stop headers emission in case of errors or when the header size limit is reached.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>2926</span><span><span>func</span> <span>(</span><span>fr</span> <span>*</span><span>http2Framer</span><span>)</span> <span>readMetaFrame</span><span>(</span><span>hf</span> <span>*</span><span>http2HeadersFrame</span><span>)</span> <span>(</span><span>*</span><span>http2MetaHeadersFrame</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>2927</span><span>	<span>if</span> <span>fr</span><span>.</span><span>AllowIllegalReads</span> <span>{</span>
</span></span><span><span>2928</span><span>		<span>return</span> <span>nil</span><span>,</span> <span>errors</span><span>.</span><span>New</span><span>(</span><span>&#34;illegal use of AllowIllegalReads with ReadMetaHeaders&#34;</span><span>)</span>
</span></span><span><span>2929</span><span>	<span>}</span>
</span></span><span><span>2930</span><span>	<span>mh</span> <span>:=</span> <span>&amp;</span><span>http2MetaHeadersFrame</span><span>{</span>
</span></span><span><span>2931</span><span>		<span>http2HeadersFrame</span><span>:</span> <span>hf</span><span>,</span>
</span></span><span><span>2932</span><span>	<span>}</span>
</span></span><span><span>2933</span><span>	<span>var</span> <span>remainSize</span> <span>=</span> <span>fr</span><span>.</span><span>maxHeaderListSize</span><span>()</span>
</span></span><span><span>2934</span><span>	<span>var</span> <span>sawRegular</span> <span>bool</span>
</span></span><span><span>2935</span><span>
</span></span><span><span>2936</span><span>	<span>var</span> <span>invalid</span> <span>error</span> <span>// pseudo header field errors
</span></span></span><span><span>2937</span><span><span></span>	<span>hdec</span> <span>:=</span> <span>fr</span><span>.</span><span>ReadMetaHeaders</span>
</span></span><span><span>2938</span><span>	<span>hdec</span><span>.</span><span>SetEmitEnabled</span><span>(</span><span>true</span><span>)</span>
</span></span><span><span>2939</span><span>	<span>hdec</span><span>.</span><span>SetMaxStringLength</span><span>(</span><span>fr</span><span>.</span><span>maxHeaderStringLen</span><span>())</span></span></span></code></pre></div>
<p>Indeed, in the <code>SetEmitFunc</code> callback function there’s a logic that checks if the allowed size (<code>maxHeaderListSize</code>) has been reached and in this case <code>SetEmitEnabled(false)</code> is called.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>2940</span><span>	<span>hdec</span><span>.</span><span>SetEmitFunc</span><span>(</span><span>func</span><span>(</span><span>hf</span> <span>hpack</span><span>.</span><span>HeaderField</span><span>)</span> <span>{</span>
</span></span><span><span>2941</span><span>		<span>if</span> <span>http2VerboseLogs</span> <span>&amp;&amp;</span> <span>fr</span><span>.</span><span>logReads</span> <span>{</span>
</span></span><span><span>2942</span><span>			<span>fr</span><span>.</span><span>debugReadLoggerf</span><span>(</span><span>&#34;http2: decoded hpack field %+v&#34;</span><span>,</span> <span>hf</span><span>)</span>
</span></span><span><span>2943</span><span>		<span>}</span>
</span></span><span><span>2944</span><span>		<span>if</span> <span>!</span><span>httpguts</span><span>.</span><span>ValidHeaderFieldValue</span><span>(</span><span>hf</span><span>.</span><span>Value</span><span>)</span> <span>{</span>
</span></span><span><span>2945</span><span>			<span>// Don&#39;t include the value in the error, because it may be sensitive.
</span></span></span><span><span>2946</span><span><span></span>			<span>invalid</span> <span>=</span> <span>http2headerFieldValueError</span><span>(</span><span>hf</span><span>.</span><span>Name</span><span>)</span>
</span></span><span><span>2947</span><span>		<span>}</span>
</span></span><span><span>2948</span><span>		<span>isPseudo</span> <span>:=</span> <span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>hf</span><span>.</span><span>Name</span><span>,</span> <span>&#34;:&#34;</span><span>)</span>
</span></span><span><span>2949</span><span>		<span>if</span> <span>isPseudo</span> <span>{</span>
</span></span><span><span>2950</span><span>			<span>if</span> <span>sawRegular</span> <span>{</span>
</span></span><span><span>2951</span><span>				<span>invalid</span> <span>=</span> <span>http2errPseudoAfterRegular</span>
</span></span><span><span>2952</span><span>			<span>}</span>
</span></span><span><span>2953</span><span>		<span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>2954</span><span>			<span>sawRegular</span> <span>=</span> <span>true</span>
</span></span><span><span>2955</span><span>			<span>if</span> <span>!</span><span>http2validWireHeaderFieldName</span><span>(</span><span>hf</span><span>.</span><span>Name</span><span>)</span> <span>{</span>
</span></span><span><span>2956</span><span>				<span>invalid</span> <span>=</span> <span>http2headerFieldNameError</span><span>(</span><span>hf</span><span>.</span><span>Name</span><span>)</span>
</span></span><span><span>2957</span><span>			<span>}</span>
</span></span><span><span>2958</span><span>		<span>}</span>
</span></span><span><span>2959</span><span>
</span></span><span><span>2960</span><span>		<span>if</span> <span>invalid</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>2961</span><span>			<span>hdec</span><span>.</span><span>SetEmitEnabled</span><span>(</span><span>false</span><span>)</span>
</span></span><span><span>2962</span><span>			<span>return</span>
</span></span><span><span>2963</span><span>		<span>}</span>
</span></span><span><span>2964</span><span>
</span></span><span><span>2965</span><span>		<span>size</span> <span>:=</span> <span>hf</span><span>.</span><span>Size</span><span>()</span>
</span></span><span><span>2966</span><span>		<span>if</span> <span>size</span> <span>&gt;</span> <span>remainSize</span> <span>{</span>
</span></span><span><span>2967</span><span>			<span>hdec</span><span>.</span><span>SetEmitEnabled</span><span>(</span><span>false</span><span>)</span>
</span></span><span><span>2968</span><span>			<span>mh</span><span>.</span><span>Truncated</span> <span>=</span> <span>true</span>
</span></span><span><span>2969</span><span>			<span>return</span>
</span></span><span><span>2970</span><span>		<span>}</span>
</span></span><span><span>2971</span><span>		<span>remainSize</span> <span>-=</span> <span>size</span>
</span></span><span><span>2972</span><span>
</span></span><span><span>2973</span><span>		<span>mh</span><span>.</span><span>Fields</span> <span>=</span> <span>append</span><span>(</span><span>mh</span><span>.</span><span>Fields</span><span>,</span> <span>hf</span><span>)</span>
</span></span><span><span>2974</span><span>	<span>})</span>
</span></span><span><span>2975</span><span>	<span>// Lose reference to MetaHeadersFrame:
</span></span></span><span><span>2976</span><span><span></span>	<span>defer</span> <span>hdec</span><span>.</span><span>SetEmitFunc</span><span>(</span><span>func</span><span>(</span><span>hf</span> <span>hpack</span><span>.</span><span>HeaderField</span><span>)</span> <span>{})</span>
</span></span><span><span>2977</span><span>     
</span></span></code></pre></div>
<p>The following part of this function is responsible for actually feeding the HPACK decoder and it does so until <code>HeadersEnded()</code> returns <code>true</code> which happens only when <code>END_HEADERS</code> flag is set.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>2978</span><span>	<span>var</span> <span>hc</span> <span>http2headersOrContinuation</span> <span>=</span> <span>hf</span>
</span></span><span><span>2979</span><span>	<span>for</span> <span>{</span>
</span></span><span><span>2980</span><span>		<span>frag</span> <span>:=</span> <span>hc</span><span>.</span><span>HeaderBlockFragment</span><span>()</span>
</span></span><span><span>2981</span><span>		<span>if</span> <span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>hdec</span><span>.</span><span>Write</span><span>(</span><span>frag</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>2982</span><span>			<span>return</span> <span>nil</span><span>,</span> <span>http2ConnectionError</span><span>(</span><span>http2ErrCodeCompression</span><span>)</span>
</span></span><span><span>2983</span><span>		<span>}</span>
</span></span><span><span>2984</span><span>
</span></span><span><span>2985</span><span>		<span>if</span> <span>hc</span><span>.</span><span>HeadersEnded</span><span>()</span> <span>{</span>
</span></span><span><span>2986</span><span>			<span>break</span>
</span></span><span><span>2987</span><span>		<span>}</span>
</span></span><span><span>2988</span><span>		<span>if</span> <span>f</span><span>,</span> <span>err</span> <span>:=</span> <span>fr</span><span>.</span><span>ReadFrame</span><span>();</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>2989</span><span>			<span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>2990</span><span>		<span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>2991</span><span>			<span>hc</span> <span>=</span> <span>f</span><span>.(</span><span>*</span><span>http2ContinuationFrame</span><span>)</span> <span>// guaranteed by checkFrameOrder
</span></span></span><span><span>2992</span><span><span></span>		<span>}</span>
</span></span><span><span>2993</span><span>	<span>}</span>
</span></span><span><span>2994</span><span><span>// &lt;rest of this function irrelevant&gt;
</span></span></span></code></pre></div>
<p>The vulnerability may not be clear at the first sight: the decoder is properly configured to stop emitting headers once limit is reached. However, it will still decode headers written to it, just without emiting them. Given that the <em>feeding loop</em> above can only be stopped by <code>END_HEADERS</code> flag or an error from <code>ReadFrame</code> an attacker fully controls how long the HPACK decoder will receive new bytes. With no <code>END_HEADERS</code>, this function will never return and HPACK will keep decoding headers as long as the attacker sends them.</p>
<h2 id="out-of-memory---http-2-ruby-gem-case--">Out of Memory<!-- raw HTML omitted --></h2>
<p>Out of Memory are probably the most boring yet severe cases. There is nothing special about it: no strange logic, no interesting race condition and so on. The implementations that allow OOM simply did not limit the size of headers list built using <code>CONTINUATION</code> frames. Implementations without header timeout required just a single HTTP/2 connection to crash the server.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>In implementations with idle timeout it was often possible to send multiple HTTP/2 connections that occupied portions of RAM very close to the allowed per-connection limit and then sending the last <code>CONTINUATION</code> frame byte-by-byte every few seconds to keep the connection alive.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="reachable-assertion-crash-nodejs-special-case">Reachable Assertion crash: Node.js (special) case</h2>
<p>The last case I’d like to present is a <a href="https://cwe.mitre.org/data/definitions/617.html">Reachable Assertion</a> connected to <code>CONTINUATION</code> frames in Node.js. While it properly handles the infinite stream of <code>CONTINUATION</code> frames there was a data race bug occuring when connection was disconnected during the headers stream.</p>
<p>When I was running the exploit code I noticed that sometimes Node.js crashed with the following stack:</p>
<pre tabindex="0"><code>  #  node[3253]: virtual node::http2::Http2Session::~Http2Session() at ../src/node_http2.cc:534
  #  Assertion failed: (current_nghttp2_memory_) == (0)

----- Native stack trace -----

 1: 0xca5430 node::Abort() [node]
 2: 0xca54b0 node::errors::SetPrepareStackTraceCallback(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) [node]
 3: 0xce7156 node::http2::Http2Session::~Http2Session() [node]
 4: 0xce7192 node::http2::Http2Session::~Http2Session() [node]
 5: 0x106f01d v8::internal::GlobalHandles::InvokeFirstPassWeakCallbacks() [node]
 6: 0x10f3215 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::internal::GarbageCollectionReason, char const*) [node]
 7: 0x10f3d7c v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
 8: 0x10ca081 v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]
 9: 0x10cb215 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]
10: 0x10a8866 v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [node]
11: 0x15035f6 v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [node]
12: 0x7f41df699ef6 
Aborted (core dumped)
</code></pre><p>After several retries I correlated this crash to the exact moment when my HTTP/2 client disconnects from the Node.js server. This made sense because the <code>assert()</code> call was inside the <code>Http2Session</code> destructor. Let’s take a look at the code (Node.js v21.5.0):</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>528</span><span><span>Http2Session</span><span>::~</span><span>Http2Session</span><span>()</span> <span>{</span>
</span></span><span><span>529</span><span>  <span>CHECK</span><span>(</span><span>!</span><span>is_in_scope</span><span>());</span>
</span></span><span><span>530</span><span>  <span>Debug</span><span>(</span><span>this</span><span>,</span> <span>&#34;freeing nghttp2 session&#34;</span><span>);</span>
</span></span><span><span>531</span><span>  <span>// Explicitly reset session_ so the subsequent
</span></span></span><span><span>532</span><span><span></span>  <span>// current_nghttp2_memory_ check passes.
</span></span></span><span><span>533</span><span><span></span>  <span>session_</span><span>.</span><span>reset</span><span>();</span>
</span></span><span><span>534</span><span>  <span>CHECK_EQ</span><span>(</span><span>current_nghttp2_memory_</span><span>,</span> <span>0</span><span>);</span>
</span></span><span><span>535</span><span><span>}</span></span></span></code></pre></div>
<p>Node.js is embedding <a href="https://nghttp2.org/">nghttp2</a> library for HTTP/2 connections handling. <code>current_nghttp2_memory_</code> is used to track memory allocated by nghttp2 internals and the assertion in the destructor simply ensures that all nghttp2 artifacts are properly removed from memory which happens in <code>reset</code> method (line 533). The value is updated: increased and decreased in several places in the code, often in a nghttp2 callback functions.</p>
<p>There was no other option than to check nghttp2 internals and see who is to blame: Node.js by incorrectly calculating the memory usage, or nghttp2 by giving invalid data used in calculations. After quite a long investigation I couldn’t find anything wrong with calculations which pointed to a possibility of a race condition: <code>current_nghttp2_memory_</code> value was updated elsewhere, at the same time when <code>~Http2Session</code> was being executed.</p>
<p>I found an instance of this case: <code>reset()</code> and nghttp2 callback when <code>CONTINUATION</code> frame is parsed are executed together. When <code>CONTINUATION</code> frame arrives the following chain on events occur when state machine is in <a href="https://github.com/nghttp2/nghttp2/blob/48168eacdb7815375747cd01b886d65a5c4e0931/lib/nghttp2_session.c#L6892"><code>NGHTTP2_IB_EXPECT_CONTINUATION</code> state</a>:</p>
<ul>
<li>we go the happy path so state is changed to <code>NGHTTP2_IB_READ_HEADER_BLOCK</code>, from there it calls:</li>
<li><code>session_after_header_block_received</code> which calls:</li>
<li><code>session_call_on_frame_received</code> which calls:</li>
<li><code>on_frame_recv_callback</code>.</li>
</ul>
<p>The last one calls <code>OnFrameReceive</code> callback in Node.js and later: <code>HandleHeadersFrame</code> which does some memory counter update:
</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>1454</span><span>  <span>DecrementCurrentSessionMemory</span><span>(</span><span>stream</span><span>-&gt;</span><span>current_headers_length_</span><span>);</span>
</span></span><span><span>1455</span><span>  <span>stream</span><span>-&gt;</span><span>current_headers_length_</span> <span>=</span> <span>0</span><span>;</span></span></span></code></pre></div>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>746</span><span>  <span>void</span> <span>DecrementCurrentSessionMemory</span><span>(</span><span>uint64_t</span> <span>amount</span><span>)</span> <span>{</span>
</span></span><span><span>747</span><span>    <span>DCHECK_LE</span><span>(</span><span>amount</span><span>,</span> <span>current_session_memory_</span><span>);</span>
</span></span><span><span>748</span><span>    <span>current_session_memory_</span> <span>-=</span> <span>amount</span><span>;</span>
</span></span><span><span>749</span><span>  <span>}</span></span></span></code></pre></div>
<p>Now, when <code>HandleHeadersFrame</code> and <code>Http2Session::~Http2Session()</code> are executed at the same time it’s possible that they will update the <code>current_session_memory_</code> variable at the same time:</p>
<p><code>Http2Session::~Http2Session()</code>
</p><div><pre tabindex="0"><code data-lang="cpp"><span><span>529</span><span><span>CHECK</span><span>(</span><span>!</span><span>is_in_scope</span><span>());</span>
</span></span><span><span>530</span><span><span>Debug</span><span>(</span><span>this</span><span>,</span> <span>&#34;freeing nghttp2 session&#34;</span><span>);</span>
</span></span><span><span>531</span><span><span>// Explicitly reset session_ so the subsequent
</span></span></span><span><span>532</span><span><span>// current_nghttp2_memory_ check passes.
</span></span></span><span><span>533</span><span><span></span><span>session_</span><span>.</span><span>reset</span><span>();</span></span></span></code></pre></div>
<code>DecrementCurrentSessionMemory</code>:
<div><pre tabindex="0"><code data-lang="cpp"><span><span>747</span><span><span>DCHECK_LE</span><span>(</span><span>amount</span><span>,</span> <span>current_session_memory_</span><span>);</span>
</span></span><span><span>748</span><span><span>current_session_memory_</span> <span>-=</span> <span>amount</span><span>;</span></span></span></code></pre></div>
<code>Http2Session::~Http2Session()</code>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>534</span><span><span>CHECK_EQ</span><span>(</span><span>current_nghttp2_memory_</span><span>,</span> <span>0</span><span>);</span></span></span></code></pre></div>
<p>This is why <code>CHECK_EQ</code> fails as <code>current_nghttp2_memory_</code> value is negative.</p>

<p>There were a couple of HTTP/2 vulnerabilities in the past. In 2019, a batch of them was reported by Netflix and Google. They are listed in CERT/CC Vulnerability Note <a href="https://kb.cert.org/vuls/id/605641/">VU#605641</a> and the most similar are:</p>
<blockquote>
<p>CVE-2019-9516, also known as 0-Length Headers Leak</p>
<p>The attacker sends a stream of headers with a 0-length header name and 0-length header value, optionally Huffman encoded into 1-byte or greater headers. Some implementations allocate memory for these headers and keep the allocation alive until the session dies. This can consume excess memory, potentially leading to a denial of service.</p>
</blockquote>
<p><code>CONTINUATION</code> Flood is different than CVE-2019-9516 because rather than sending empty headers, an attacker sends many random headers up to the frame size limit configured by the server.</p>
<blockquote>
<p>CVE-2019-9518, also known as Empty Frame Flooding</p>
<p>The attacker sends a stream of frames with an empty payload and without the end-of-stream flag. These frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The peer spends time processing each frame disproportionate to attack bandwidth. This can consume excess CPU, potentially leading to a denial of service.</p>
</blockquote>
<p>CVE-2019-9518 is about sending empty frames. The <code>CONTINUATION</code> Flood consists of the largest possible frames that occupy memory and consume CPU cycles while being decoded.</p>
<p>In October 2023 the details of “Rapid Reset”, a zero day in HTTP/2 protocol, were published and the vulnerability was immedietly dubbed <a href="https://cloud.google.com/blog/products/identity-security/google-cloud-mitigated-largest-ddos-attack-peaking-above-398-million-rps">“the largest DDoS attack to date”</a>. The details of this attack are explained in Cloudflare’s <a href="https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack">article</a>, and while the severity of this vulnerability is different across many implementations, I think it’s important to list main points explaining why the new vulnerability seems to be more severe:</p>
<ul>
<li>Rapid Reset used a combination of <code>HEADERS</code> (with <code>END_STREAM</code> and <code>END_HEADERS</code> flags set) and <code>RST_STREAM</code> frames which means that standard mitigations like rate limiting could at least limit the damage. Also, the server admin would see a lot of inbound server requests and be alerted. <strong>During <code>CONTINUATION</code> Flood attack not a single request is made (no <code>END_HEADERS</code> flag)! Admins do not see any requests in the logs!</strong></li>
<li>In many implementations <strong>just one</strong> TCP connection was enough to crash the server (and in some cases with a very small amount of data sent) during the <code>CONTINUATION</code> Flood attack. On contrary, Rapid Reset was used in DDoS attacks (in most cases using a botnet was required for an attack to be successful).</li>
</ul>

<p>According to <a href="https://radar.cloudflare.com/adoption-and-usage">Cloudflare Radar</a> the HTTP/2 traffic accounts for around 60% of all human HTTP traffic (data excluding bots):</p>
<p><img src="https://nowotarski.info/cf_radar_http2.png" alt="HTTP/2 distribution stats"/></p>
<p>Given that Cloudflare Radar estimates HTTP traffic data above 70% of all internet transfer and significance of affected projects I believe that we can assume that large part of internet was affected by an easy-to-exploit vulnerability: in many cases just a single TCP connection was enough to crash the server. Don’t forget that HTTP runs not only websites but significant portion of APIs (RESTful APIs). Availability issues with important business and government APIs and websites could incur losses of millions of dollar. Or cause chaos, for example: Poland, the main supplier of heavy weapons to Ukraine which also operates the most important military hub near Ukraine border, <a href="https://www.euronews.com/2024/03/06/poland-experiences-increase-in-ddos-attacks-from-russia">experiences increase in DDoS attacks</a> originating from Russia.</p>
<p><img src="https://nowotarski.info/cf_radar_traffic.png" alt="HTTP/2 in total traffic"/></p>
<p>Had it been exploited in the wild, this would have been very hard to debug without proper HTTP/2 knowledge by the server administrators. This is due to the fact that none of malicious HTTP requests connected to this vulnerability is properly closed. The requests would not be visible in the server access logs and due to lack of advanced frame analytics in most of HTTP/2 servers this would have to be handled by manual, tedious raw connection data analysis.</p>
<p><strong>This vulnerability class posed a significant risk to the internet safety!</strong> Because of this I am glad that <a href="https://www.kb.cert.org/vuls/">CERT/CC</a> decided to open a Vulnerability Coordination case to track this issue after I reported it in January 2024. Working on a responsible disclosure of this vulnerability with technology giants and open source projects was a great experience. It would be impossible to check so many implementations by a single resesearcher so Vulnerability Coordination is irreplaceable tool for handling issues that affect multiple vendors. Other than opening the case, CERT/CC decided to publish a <a href="https://kb.cert.org/vuls/id/421644">Vulnerability Note</a> about this issue, which is quite rare: only a few notes are published each year. Thank you to Christopher Cullen for handling the issue on CERT/CC side.</p>

		</section></div>
  </body>
</html>
