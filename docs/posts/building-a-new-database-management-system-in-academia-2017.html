<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.cs.cmu.edu/~pavlo/blog/2017/03/building-a-new-database-management-system-in-academia.html">Original</a>
    <h1>Building a new database management system in academia (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
            <h2>TL;DR</h2>
<ul>
  <li> Yes, it is possible to build a new DBMS in academia. It&#39;s still hard. We found that using Postgres as a starting point was too slow for in-memory OLTP. The challenges in academia are slightly different than with a start-up.
</li></ul>

<p>I&#39;ve been on my grind the last couple of months. We had a successful demo of our system at CIDR in January. Somebody started a feud with me. I&#39;m looking past that and trying to maintain my flow.</p>
<p>Like other schools with large CS programs, CMU has a long-tradition of big software system projects that go on to have a life outside of the university (e.g., <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Mach_(kernel)">Mach</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Andrew_File_System">AFS</a>). To the best of my knowledge, there has not been a full-featured DBMS that has come out of CMU<sup><a href="#footnote-transarc">[1]</a></sup>. The closest would be Natassa Ailamaki&#39;s <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/sites.google.com&#39;);" href="https://sites.google.com/site/shoremt/">Shore-MT</a> project from when she was at CMU, but it is only an execution engine and storage manager (think InnoDB).</p>
<p>Although I am not ready to officially &#34;announce&#34; our <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/pelotondb.io&#39;);" href="http://pelotondb.io">DBMS</a> yet, I want to talk about what my group has been working on for the last two years. This is also how I plan to spend the next five years<sup><a href="#footnote-tenure">[2]</a></sup> of my life building this system. The problem with building an open-source DBMS is that the bar is high because there are already great existing systems (e.g., MySQL, Postgres). I want to avoid <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/dom.as&#39;);" href="https://dom.as/2012/06/26/memsql-rage/">harsh initial reactions</a> from making grandiose claims about its ability. The system&#39;s self-driving components are going to take a while (i.e., years) to get the research right.</p>
<h2>Strategies for Starting a New DBMS Project</h2>
<p>Few take on the task of writing a DBMS from scratch. Part of the reason is that there is just so much infrastructure that you need to have in order to create a system that is usable. Such components include a SQL parser, query optimizer, system catalogs, configuration files, networking support, and expression + type systems. This is even before you get to the other hard parts like concurrency control, query execution, and storage/recovery. I refer to all of the items in the first list as the &#34;front-end&#34; of a system. This is not sexy code to write. This is why most new DBMSs start with building on Postgres<sup><a href="#footnote-postgres">[3]</a></sup> by either forking it (e.g., <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/greenplum.org&#39;);" href="http://greenplum.org/">Greenplum</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.vertica.com&#39;);" href="https://www.vertica.com/">Vertica</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.pipelinedb.com&#39;);" href="https://www.pipelinedb.com/">PipelineDB</a>) or using its extension/hook APIs (e.g., <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.citusdata.com&#39;);" href="https://www.citusdata.com/product/community">CitusDB</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/vitessedata.com&#39;);" href="http://vitessedata.com/">Vitesse</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.timescaledb.com&#39;);" href="https://www.timescaledb.com/">TimescaleDB</a>). One could also try to create a new storage engine for MySQL, but these projects are notoriously never successful<sup><a href="#footnote-myrocks">[4]</a></sup> (see <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Falcon_(storage_engine)">Falcon</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.deepis.com&#39;);" href="http://www.deepis.com">DeepSQL</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.crunchbase.com&#39;);" href="https://www.crunchbase.com/organization/akiban#/entity">Akiban</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/InfiniDB">InfiniDB</a>). Another advantage of basing your new system off of an existing one is that you get to retain compatibility with some of the existing tools in a DBMS&#39;s ecosystem.</p>
<p>When we started the Peloton project we decided to fork Postgres and then cut out the parts that we wanted to rewrite. Postgres&#39; code is beautiful. It&#39;s well-documented. It&#39;s portable. It&#39;s a textbook implementation of a relational DBMS. But it is a bit dated and the overall architecture has some issues. The first problem that we encountered was that we had to convert it from ANSI-95 C to modern C++11 to make it work with our new storage manager. My PhD student <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.cs.cmu.edu&#39;);" href="http://www.cs.cmu.edu/~jarulraj/">Joy Arulraj</a> did this with some summer interns in about a month (see his <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/jarulraj/postgresql-cpp">C++ Postgres fork on Github</a>). We then spent another month converting its runtime architecture from a multi-process, shared-memory model to a single-process, multi-threaded model. We deemed that this was necessary to support better single-node scale-up now and eventually go distributed in the future. One surprising thing that we found was that using Postgres&#39; <tt>WIN32</tt> code is easier to convert to <tt>pthreads</tt> than the Linux-specific portions of the code.</p>
<p>At this point we had a functioning DBMS that could convert Postgres query plans into our system&#39;s plans and then execute them on our back-end engine. Our testing, however, showed that this conversion from the Postgres world to our system was a bottleneck when we tried to increase the number of concurrent transactions. For an OLAP system, using the Postgres front-end code is fine. This is because the system will spend most of its time processing long-running queries and not in the front-end. But if you want to build a DBMS that supports highly concurrent workloads with an in-memory database, then all of this legacy code is too slow.</p>
<p>We therefore tried to take out the slow parts from the front-end and keep as much as possible. But the problem with this approach is it is not easy to pull out Postgres&#39; individual components. For example, you can&#39;t just take out the query optimizer without bringing along the catalogs. If you take the catalog, then you have to include the storage manager, which then includes the lock manager, memory manager, and so on. This is well-known problem in database systems and was the motivation of the &#34;<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/dl.acm.org&#39;);" href="http://dl.acm.org/citation.cfm?id=671696">RISC-style</a>&#34; architectures. The <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/db.csail.mit.edu&#39;);" href="http://db.csail.mit.edu/sigmod09contest/">SIGMOD Programming Contest</a> originally started as a way to build up a repository of DBMS components that one could glue together to make a real system. There are also other attempts at making standalone components. For example, there are several query optimizer frameworks (<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/greenplum-db/gporca">Orca</a>) and generators (<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/web.cecs.pdx.edu&#39;);" href="http://web.cecs.pdx.edu/~len/Columbia/">Columbia</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/pages.cs.wisc.edu&#39;);" href="http://pages.cs.wisc.edu/~navin/research/apg.html">Opt++</a>).</p>
<p>After a few weeks of debating our options, we concluded that it would probably be the same amount of work to integrate these components into our system as it would be to just write our own (especially since some of these components are over 20 years old). Using them would also mean that there would be large parts of the system that we didn&#39;t have a complete understanding of and therefore it would be difficult to control when we start integrating the self-driving parts.</p>
<p>In 2016, we decided to bite the bullet and remove the rest of Postgres from our system. This means that we are re-writing all of the front-end components ourselves.</p>
<h2>Research Philosophy</h2>
<p>You may be asking what does everything I&#39;ve written so far have to do with research? One could argue that our journey just sounds like the growing pains of a start-up company building a DBMS. Furthermore, if I am claiming that the unique characteristic of our new DBMS is that it is <a onclick="javascript:pageTracker._trackPageview(&#39;/downloads/papers/2017/p42-pavlo-cidr17.pdf&#39;);" href="http://db.cs.cmu.edu/papers/2017/p42-pavlo-cidr17.pdf">autonomous</a>, why do I care whether it is not as fast as it could be if I kept the Postgres front-end? Why bother with building (yet) another DBMS?</p>
<p>Mike Stonebraker taught me that the best way to have the most impact in database research is to build a system that solves real-world problems for people. One could just write papers and then hope that somebody else picks up your ideas and implements them. I think that this is a rare occurrence relative to the number of academic papers that are published. It does happen though (see <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/fauna.com&#39;);" href="https://fauna.com/blog/distributed-acid-transaction-performance">Dan Abadi</a> and <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/roaringbitmap.org&#39;);" href="http://roaringbitmap.org/about/">Daniel Lemire</a>). Now for Mike, the best way to do this is to build an academic prototype, publish a paper, and then form a company that builds the real system. That&#39;s a bit risky for someone without tenure, but it can be done (<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/dbmsmusings.blogspot.com&#39;);" href="http://dbmsmusings.blogspot.com/2011/03/why-im-doing-start-up-pre-tenure.html">Dan Abadi strikes again</a>). </p>
<p>The way that my research group is designing and building our DBMS is through a step-by-step process. For every part of the system that we have to build, we will try to write a research paper about our approach. My inspiration for this comes from the <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/hyper-db.de&#39;);" href="http://hyper-db.de/index.html#publications">HyPer</a> DBMS project from the <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/db.in.tum.de&#39;);" href="https://db.in.tum.de/">TUM DB Group</a>. They have a lot of papers that describe the different parts of their system and all the problems that they had to solve. But I want to go a little deeper than just writing about only what we did. We will examine all of the state-of-the-art implementations in both academia and industry. This is through a combination of reading papers as well as reaching out to friends in industry and asking them how they implement certain things. We then perform experiments that evaluate the different approaches in Peloton and under a variety of workload scenarios. Then whatever one is the best is what we will use in our system.</p>
<p>One benefit of this style of research is that it makes us extremely unbiased. That is, unlike other papers that compare their new algorithm or method to other state-of-the-art implementations, we don&#39;t have any preference. We will <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/youtu.be&#39;);" href="https://youtu.be/brs0Ei0qo1o?t=1m11s">take whatever</a> just works. I will also add that we are doing more than just running existing implementations in a single platform; we also spend time to understand the algorithms carefully and come up with new techniques for overcoming bottlenecks. It does, however, mean that that it takes longer for us to run the experiments because we have to keep tweaking the system.</p>
<p>As an example of this, there are several papers and articles published in recent years on high-performance multi-version concurrency control (MVCC). These include the protocols used in <a onclick="javascript:pageTracker._trackPageview(&#39;/downloads/pvldb/vol5/p298_per-akelarson_vldb2012.pdf&#39;);" href="http://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">Microsoft Hekaton</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/downloads/https://db.in.tum.de/~muehlbau/papers/mvcc.pdf&#39;);" href="https://db.in.tum.de/~muehlbau/papers/mvcc.pdf">HyPer</a>, and <a onclick="javascript:pageTracker._trackPageview(&#39;/downloads/papers/2017/p781-wu.pdf&#39;);" href="http://highscalability.com/blog/2012/8/14/memsql-architecture-the-fast-mvcc-inmem-lockfree-codegen-and.html">MemSQL</a>. The problem, however, is that these articles don&#39;t always explain the reasoning behind why the developers made certain design decisions in their DBMS. Furthermore, there are also other aspects of the system that are <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/eng.uber.com&#39;);" href="https://eng.uber.com/mysql-migration/">highly dependent</a> on each other that are not evaluated thoroughly. I had a visiting PhD student (<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.comp.nus.edu.sg&#39;);" href="http://www.comp.nus.edu.sg/~yingjun/">Yingjun Wu</a>) implement all of them with some MS students and then we did a bake-off. I will discuss our recently published <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/db.cs.cmu.edu&#39;);" href="http://db.cs.cmu.edu/papers/2017/p781-wu.pdf">MVCC study</a> in my next blog post.</p>
<p>And the reason why we are spending this effort to make this system as fast as possible is to ensure that it is robust and nimble. This will allow the self-driving &#34;brain&#34; to quickly try out different configurations and optimizations, and then (hopefully) immediately get feedback as to whether its decisions were correct.</p>
<h2>Building a DBMS is Hard. Building One in Academia is Even Harder</h2>
<p>I recognize that the above agenda sounds too idealistic and thus some of you may think that such an approach to DBMS development is only possible in academia. I concede that academia provides the freedom for one to be more methodical about designing the system than what may be possible at a start-up or a large company. But it does not necessarily mean that our system is going to be better or that our job is somehow easier. Although I don&#39;t have (direct) financial pressures, building a new DBMS is still a daunting challenge. There are other problems that I have to deal with that a company does not. I don&#39;t get to spend all my time working on the system because I have to teach, write grant proposals, serve on program committees, write papers, and teach my students to <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/twitter.com&#39;);" href="https://twitter.com/CMUDB/status/769297624268767232">survive on the streets</a>.</p>
<!-- It is true that that building a DBMS is easier now than in previous decades. But there are still some challenges that are non-trivial to overcome, especially  -->

<h3>Developer Continuity</h3>
<p>Every tech company struggles with attracting good talent (except for possibly <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/twitter.com&#39;);" href="https://twitter.com/andy_pavlo/status/809488757745393664">Facebook</a>). I don&#39;t really have that problem since the admissions process sort of takes care of that for me. My <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/pelotondb.io&#39;);" href="http://pelotondb.io/people/">students</a> at CMU are awesome but they are only with me for a short amount of time. For undergrads and MS students, it&#39;s usually about two semesters. New students often lack knowledge about DBMS internals (that&#39;s okay, they&#39;re here to learn); it usually takes them about a semester to pick this up either from working on the system or by taking my <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/15721.courses.cs.cmu.edu&#39;);" href="http://15721.courses.cs.cmu.edu/spring2017/">advanced DB class</a>.
PhD students obviously stick around for longer but they are in graduate school to do research. I have to balance their time spent writing papers versus writing new features in the system. One thing that I require is that (almost) all of the code that they write for experiments has to be merged into the DBMS&#39;s master branch after they submit the paper for review.</p>
<p>I will admit that I haven&#39;t quite figured out how to manage this perpetual <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/tvtropes.org&#39;);" href="http://tvtropes.org/pmwiki/pmwiki.php/Main/RevolvingDoorBand">revolving door</a> for my team. Obviously writing a lot of tests and documentation is important, but this doesn&#39;t always happen. One way to solve this problem is to hire a full-time systems programmer, but it&#39;s hard to raise money to do this as a new professor. You can&#39;t use a regular NSF research grant to pay for a programmer. Instead there are <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/nsf.gov&#39;);" href="https://nsf.gov/funding/pgm_summ.jsp?pims_id=12810">infrastructure grants</a>.</p>
<h3>Lack of Workloads &amp; Testing Tools</h3>
<p>Every DBMS company creates their own framework and infrastructure for testing their DBMS. The workloads in these test suites are collected from users over time. But when you first start building a DBMS in academia, you do not have users. Thus, the only way to get real workloads is by signing NDAs. This is the standard practice in industry (often as part of a POC). I try to avoid NDAs for both myself and my students. They are always a huge time sink because things get messy when university lawyers start talking with company lawyers. They also make it tricky for us to discuss and share our research findings with others.</p>
<p>If you don&#39;t have customer workloads, then the next best option are synthetic workloads. The good news here is that there are several database benchmarks available. Most of them are specific to one system (<a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.postgresql.org&#39;);" href="https://www.postgresql.org/docs/current/static/pgbench.html">pgbench</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/dev.mysql.com&#39;);" href="https://dev.mysql.com/downloads/benchmarks.html">sysbench</a>) and contain only one workloads (usually some variant of TPC-C). Our <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/oltpbenchmark/oltpbench">OLTP-Bench</a> framework does include multiple workloads but it is meant for benchmarking performance. We have not found a tool that can provide comprehensive SQL testing. <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/anse1/sqlsmith">SQLsmith</a> is close to what we want but you have to provide your own schema. There are a lot of interesting ideas in SIGMOD&#39;s now defunct <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/dbtest2013.soe.ucsc.edu&#39;);" href="https://dbtest2013.soe.ucsc.edu/">DBTest</a> workshop, but there is little to no code available.</p>
<p>We are working on a new <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/cmu-db/peloton-test">SQL test suite</a> that we will release later in the year. It will use JDBC and Postgres&#39; SQL AST so it should be compatible with several other systems.</p>
<h3>Hardware</h3>
<p>Getting hardware for testing and benchmarking is not a problem like it used to be in previous decades. Computers are cheap. Every student also has their own laptop. This means that we only have to provide the students with monitors and keyboards at each desk in our lab. We then have some additional server machines for benchmarking. The one lesson that I have learned since starting the project is that a large percentage of students use a Mac laptop. This means that it is important that your DBMS can build on OSX even if you only intend to deploy it on Linux. We currently don&#39;t support OSX and instead provide a <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/cmu-db/peloton/wiki/Installation">Vagrant</a> file. Students tell me that they prefer developing directly in OSX. I should have made sure that we support OSX from the beginning of the project.</p>
<p>If you want to get exotic hardware (e.g., Infiniband, NVM), then you either have to write a simulator (bleh) or you have to know somebody at the company to ask for a donation. DBMS developers at the major companies get access to all kinds of new hardware earlier than the average person so that they they have time to make sure that their system is compatible (again, NDAs help with this).</p>
<h2>Other Academic Database System Projects</h2>
<p>I now want to briefly mention some of the other large-scale, multi-year DBMS projects that are going on right now in academia. The most famous academic DBMSs are Stonebraker&#39;s Ingres and Postgres projects. Mike always likes to say that you can build the first 90% of a DBMS in academia in just a few years, but then to build the remaining 10% of the system you need $5 million and several years. The next most famous is <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.monetdb.org&#39;);" href="https://www.monetdb.org/">MonetDB</a> by <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Peter_Boncz">Peter Boncz</a> and <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Martin_L._Kersten">Martin Kersten</a>. Peter then later built the X100 prototype based on his experiences with MonetDB that formed the basis of VectorWise<sup><a href="#footnote-vectorwise">[5]</a></sup>. Lastly, there is the previously stated <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.hyper-db.de&#39;);" href="http://www.hyper-db.de">TUM HyPer</a> DBMS. I consider HyPer to be one the state-of-the-art DBMS implementations right now.</p>
<p>There are a couple other academia-only DBMS projects that I am aware of right now. These are systems that are designed to support real-world applications and usecases, so I am excluding projects like <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/github.com&#39;);" href="https://github.com/stephentu/silo">Silo</a> that are only academic prototypes. I am also excluding systems like <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/databricks.com&#39;);" href="https://databricks.com/blog/2014/07/01/shark-spark-sql-hive-on-spark-and-the-future-of-sql-on-spark.html">Shark</a>, <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/blinkdb.org&#39;);" href="http://blinkdb.org/">BlinkDB</a>, and <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/hstore.cs.brown.edu&#39;);" href="http://hstore.cs.brown.edu">H-Store</a> where there are now companies actively involved in the commercial versions.</p>
<p>Note also that none of these projects listed below are based on Postgres. The last major academic system that I know that used Postgres was Berkeley&#39;s <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/telegraph.cs.berkeley.edu&#39;);" href="http://telegraph.cs.berkeley.edu/telegraphcq/v0.2/">TelegraphCQ</a> (which later became <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/en.wikipedia.org&#39;);" href="https://en.wikipedia.org/wiki/Truviso">Truviso</a>).</p>
<ul> 
    <li> <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/quickstep.io&#39;);" href="http://quickstep.io">Wisconsin Quickstep</a> — This is an in-memory database engine that supports hybrid data storage and fast vectorized execution by <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/pages.cs.wisc.edu&#39;);" href="http://pages.cs.wisc.edu/~jignesh/">Jignesh Patel</a>. Quickstep was acquired by Pivotal in 2015 and then became an <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/quickstep.incubator.apache.org&#39;);" href="http://quickstep.incubator.apache.org/">Apache incubator project</a> in 2016.

    </li><li> <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/deepdive.stanford.edu&#39;);" href="http://deepdive.stanford.edu/">Stanford DeepDive</a> — This is a DBMS for extracting structured features from unstructured or semi-structured databases. DeepDive is different than traditional systems because it is about writing queries that generate new data rather than ingesting/processing existing data. It has been used for several <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/deepdive.stanford.edu&#39;);" href="http://deepdive.stanford.edu/showcase/apps#memex">high-profile projects</a> that have had significant real world-impact. <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/cs.stanford.edu&#39;);" href="http://cs.stanford.edu/people/chrismre/">Chris Re</a> is awesome.

    </li><li> <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/myria.cs.washington.edu&#39;);" href="http://myria.cs.washington.edu/">Washington Myria</a> — Myria is a distributed, shared-nothing DBMS designed to run in the cloud as a service (but it can also run on premise). The system was originally developed by the <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/db.cs.washington.edu&#39;);" href="http://db.cs.washington.edu/">UW DB Group</a> to support scientists at their university. It is written from scratch entirely in Java. It uses a extensible query algebra that supports multiple data models.

    </li><li> <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/asterixdb.apache.org&#39;);" href="https://asterixdb.apache.org/">UCI AsterixDB</a> — This is another academic project that joined the <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.cs.uci.edu&#39;);" href="https://www.cs.uci.edu/asterixdb-becomes-official-apache-software-foundation-project/">Apache Software Foundation</a>. It is a distributed DBMS for the Hadoop ecosystem started by <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.ics.uci.edu&#39;);" href="https://www.ics.uci.edu/~mjcarey/">Mike Carey</a>. Couchbase <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.couchbase.com&#39;);" href="https://www.couchbase.com/press-releases/uc-san-diego-couchbase-collaborate-on-next-generation-query-language-for-big-data">announced in 2015</a> that they were using AsterixDB&#39;s <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/forward.ucsd.edu&#39;);" href="http://forward.ucsd.edu/sqlpp.html">SQL++</a> language as the basis for their new <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/www.couchbase.com&#39;);" href="https://www.couchbase.com/n1ql">N1QL</a> language (think SQL that supports JSON).

    </li><li> <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/macrobase.io&#39;);" href="https://macrobase.stanford.edu/">Stanford MacroBase</a> —
    This is a newer system started last year by <a onclick="javascript:pageTracker._trackPageview(&#39;/outgoing/bailis.org&#39;);" href="http://bailis.org/">Peter Bailis</a>
    (aka the &#34;<a onclick="javascript:pageTracker._trackPageview(&#39;/downloads/../../../images/blog/013/thelonious.jpg&#39;);" href="http://www.cs.cmu.edu/~pavlo/images/blog/013/thelonious.jpg">Thelonious Monk of Databases</a>&#34;). Like DeepDive,
    MacroBase is not a full DBMS but rather an execution engine for anomaly detection queries.

</li></ul>

<h3>Footnotes</h3>

        </div></div>
  </body>
</html>
