<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://laplab.me/posts/family-photos-vs-256-kb-ram/">Original</a>
    <h1>Family Photos vs 256 Kb RAM</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p><img src="https://laplab.me/img/inky-frame-banner.png" alt="Inky Frame"/></p>
<blockquote>
<p>Discussion on <a href="https://news.ycombinator.com/item?id=36154157">HackerNews</a> and <a href="https://lobste.rs/s/ugssfv/family_photos_vs_256_kb_ram">Lobsters</a>.</p>
</blockquote>
<p>A while ago I was thinking about making something nice for my wife as a present for the Valentine’s Day. My eye caught a rather cool-looking 7-color eInk display with Raspberry Pico W on board - <a href="https://shop.pimoroni.com/products/inky-frame-5-7?variant=40048398958675">Pimoroni Inky Frame</a>. From the first glance it looked quite polished with ready-to-use SDKs in Python and C++. I thought it would be interesting to make a dynamic family photo frame out of it, something that my wife could have on her table, with ability to switch photos from time to time with a press of a button.</p>
<p>I bought it on the same day. Oh boy, I did not know what I was getting myself into…</p>
<p><strong>Disclaimer:</strong> This is not a promotional post and there are no affiliate links in this article. I actually hate this device quite a bit! Read along to find out why.</p>
<h2 id="first-impressions">First impressions</h2>
<p><img src="https://laplab.me/img/inky-frame-packaging.png" alt="Inky Frame packaging"/></p>
<blockquote>
<p>Label on the packaging of Inky Frame. I think it looks fantastic! I have repurposed my box for other parcels, so this is from another buyer from the Pimoroni’s website.</p>
</blockquote>
<p>First hour with the device was actually quite nice. The packaging was on point, the frame itself felt well-built with some pirate-let’s-hack-this-together vibe. I liked it! However, for some reason, the battery pack did not work. This was not a big deal for me, because my wife’s table has a built-in USB power, which I intended to use with the frame. Pimoroni did send me a replacement battery pack free of charge, but that did not work either. Probably there is some fault in the board itself, I am not sure and again, I did not really care at the time. The way the frame is powered turned out to be extremely important later, but I did not know that yet.</p>
<h2 id="what-do-you-mean-a-single-photo-is-3mb">What do you mean a single photo is 3MB?</h2>
<p><img src="https://laplab.me/img/inky-frame-guiness.png" alt="Cat"/></p>
<blockquote>
<p>Chonky filesize for a chonky girl. This beauty is called Guinness, she is a lovely creature I had the pleasure to catsit for some time when I lived in Ireland.</p>
</blockquote>
<p>The frame itself includes an SD card slot. My original plan was to load all the photos onto it and read it into the Raspberry Pico W’s RAM on demand. Pico then would convert the image into the 7-color pallete and transfer it onto the eInk screen. Pimoroni did a great job with their SDK - it is an absolute beast of a library. It already includes the logic for decoding JPEG images and implements a very decent dithering from RBG color space into 7 colors of the eInk screen. There is even an example of an image gallery - problem solved, right?</p>
<p>Or so I thought. Example image gallery uses space images from the James Webb Space Telescope. There is an interesting property about these images apart from their beauty - they are mostly black, which allows them to compress pretty nicely. Some of them are only 8Kb, which comfortably fits into the 256Kb of RAM on Raspberry Pico W. Even after cutting for the size of the screen (600 x 448 pixels) some of my family photos were still at least 130Kb of JPEG. Which by all means should fit into the 256Kb of RAM, but it actually does not.</p>
<p>The thing is, the Pimoroni SDK itself does take a considerable portion of RAM. It provides an interface to “draw” on some internal buffer and then flush this buffer onto the screen. You cannot turn this buffer off, probably because writing the stream of bytes into the eInk screen directly is a very nich use case. From my experiments, we have around 130Kb of RAM to spare, which is too close to the photo size. My naive version coded in MicroPython ran of memory every half of the time I turned on the frame.</p>
<h2 id="hacking-a-solution-close-to-a-deadline">Hacking a solution close to a deadline</h2>
<p>I think it was like 12th of Febraury when I discovered the problem with the image size. I needed a solution, and fast, so I came up with a simplest one I could think of. If a single image does not fit into RAM, let’s cut it into multiple smaller ones and read it one-by-one. The process of adding a photo to the frame turned into:</p>
<ol>
<li>Open GIMP</li>
<li>Scale the image so that an interesting part of it fits 600 x 448 crop area</li>
<li>Cut the image to 600 x 448 size</li>
<li>Save it with the lowest possible quality</li>
<li>Run imagemagick incantation <code>convert input.jpeg -crop 75x56 +repage +adjoin output_%d.jpeg</code> to cut the image into 64 parts</li>
<li>Repeat</li>
</ol>
<p>I knew this would bite me in the future, but at the time I just rolled with it. The resulting images did not have the size of <code>130Kb / 64</code>, unfortunately. The smaller the image, the less context the compression algorithm has, so the resulting parts turned out to be around 18Kb each.</p>
<p>The Raspberry Pico W then read all 64 images from the SD card sequentially (which took at least 10 seconds in total) and put each of them in the corresponding part of the buffer. It worked. It was dog slow, but it worked.</p>
<p>There was one thing I did not fully understand though. For some reason, none of the code examples from Pimoroni contained any loops. I was expecting to see at least one loop in the image gallery example, because you need to check periodically if any of the buttons were pressed and change the image if they were. Again, I did not give much care to it because of the deadline, and just wrote a busy loop checking for button inputs. I did not care for power consumption either because of USB power, so it was good enough. As it would turn out later, I dodged stepping into an enourmous rabbit whole of undocumented behaviour by doing this. I mean, of course I did step into it later down the line, but at least not before the deadline.</p>
<p>Finally, I presented the photo frame backed by a hacky solution to my wife and she loved it! It did bring me a lot of joy to pass by her table each day and see that she changed a photo to a different one.</p>
<p>After roughly a month, the inevitable happened. My wife told me that the frame stopped working.</p>
<h2 id="designing-a-proper-solution">Designing a proper solution</h2>
<p><img src="https://laplab.me/img/inky-frame-back.png" alt="Back of Inky Frame"/></p>
<blockquote>
<p>The back of the Inky Frame with Raspberry Pico W soldered onto it - a brutal, but honest solution.</p>
</blockquote>
<p>Instead of debugging the problem and optimizing memory usage of my MicroPython code, I have done the expected and decided to rewrite the whole thing in C++. This was mainly because I do not have much experience with MicroPython and it is far easier for me to predict memory usage of C++ code. With MicroPython, I was calling <code>gc.collect()</code> everywhere in hope it would magically work.</p>
<p>I wanted to solve the problem of images randomly causing out-of-memory situations for good. For this to happen, I needed an image format which would have a stable size and still fit into the memory of Raspberry Pico W. The naive approach of just writing RGB values for all pixels clearly does not work. There are <code>600 * 480</code> pixels to describe and each of them requires 3 bytes - one for each of the RGB components. This results in <code>864Kb</code>, clearly exceeding Pico’s capabilities. However, the eInk screen cannot display full RGB range - it only has 7 colors. What if we encoded our image using only those colors? 7 colors means we need only 3 bits to describe each pixel. In total we have <code>600 * 480 * 3 / 8</code> bytes, which is <code>108Kb</code>. Even with Pimoroni SDK’s memory usage accounted, we would able to fit our image into RAM! A bonus to this solution is that we do not need to do any decoding on the Pico’s side. We can just read raw bytes from the file and interpret them as the color indexes.</p>
<p>The obvious problem with this approach is that know we need to do the encoding for it. Cropping and rescaling the image is pretty simple, but to get from RGB into the 7-color space, we also need to implement dithering, which was done by Pimoroni SDK. Luckily, the dithering logic is relatively simple and can be easily extracted from the SDK code. The only thing I could not get right away were precomputed thresholds for dithering. I took a simple approach and just printed them to console from the Raspberry Pico W running a program that only does just that.</p>
<p>With all the necessary data for encoding images, I had two paths in front of me:</p>
<ol>
<li>Write a Python script doing the encoding and call it after cropping/scaling the image in GIMP. This would work, but I will be the bottleneck for my wife to update photos on the frame</li>
<li>Create a web UI friendly to a non-technical person, which will do all the cropping, scaling and encoding</li>
</ol>
<p>I decided to go with route (2), because it allows my wife to select new photos when she wants to, edit them in the UI and then simply copy them to the SD card.</p>
<p>This turned out to be simpler than I thought! All the heavy lifting was done by the <a href="https://github.com/fengyuanchen/cropperjs">cropper.js</a>, which already implements drag-n-drop controls with crop and scale functionality. The only thing left for me to do was the encoding part, which was very simple to copy from C++ in Pimoroni SDK to vanilla Javascript. The resulting user flow is very straightforward: upload an image (to the browser, no data is sent to the server), edit it however you like and download the encoded image. I decided to publish it on my website for simplicity, so feel free to check it out <a href="https://laplab.me/crop/">here</a>. Feel free to explore the dithering logic in the <a href="https://laplab.me/crop/main.js">main.js</a> file, it is just a few lines of code really doing all the work:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>const</span> canvas = cropper.getCroppedCanvas({
</span></span><span><span>    width: 600,
</span></span><span><span>    height: 448,
</span></span><span><span>});
</span></span><span><span><span>const</span> rawPixels = canvas.getContext(<span>&#34;2d&#34;</span>).getImageData(0, 0, 600, 448).data;
</span></span><span><span><span>const</span> inkyPixels = <span>new</span> Uint8Array(600 * 448 * 3 / 8);
</span></span><span><span>
</span></span><span><span><span>function</span> setBitByIndex(index, value) {
</span></span><span><span>    <span>const</span> byteIndex = <span>Math</span>.floor(index / 8);
</span></span><span><span>    <span>const</span> bitIndex = index % 8;
</span></span><span><span>    inkyPixels[byteIndex] |= (value &lt;&lt; bitIndex);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>for</span> (<span>let</span> y = 0; y &lt; 448; y++) {
</span></span><span><span>    <span>for</span> (<span>let</span> x = 0; x &lt; 600; x++) {
</span></span><span><span>        <span>const</span> r_index = y * 600 * 4 + x * 4;
</span></span><span><span>        <span>const</span> r = rawPixels[r_index];
</span></span><span><span>        <span>const</span> g = rawPixels[r_index + 1];
</span></span><span><span>        <span>const</span> b = rawPixels[r_index + 2];
</span></span><span><span>
</span></span><span><span>        <span>// You do not ask what this is, I do not ask what this is,
</span></span></span><span><span><span></span>        <span>// everybody is happy.
</span></span></span><span><span><span></span>        <span>const</span> cacheKey = ((r &amp; 0xE0) &lt;&lt; 1) | ((g &amp; 0xE0) &gt;&gt; 2) | ((b &amp; 0xE0) &gt;&gt; 5);
</span></span><span><span>        <span>const</span> patternIndex = (x &amp; 0b11) | ((y &amp; 0b11) &lt;&lt; 2);
</span></span><span><span>        <span>const</span> color3Bit = candidateCache[cacheKey][dither16Pattern[patternIndex]];
</span></span><span><span>
</span></span><span><span>        <span>const</span> startBitIndex = y * 600 * 3 + x * 3;
</span></span><span><span>        setBitByIndex(startBitIndex, color3Bit &amp; 1);
</span></span><span><span>        setBitByIndex(startBitIndex + 1, (color3Bit &gt;&gt; 1) &amp; 1);
</span></span><span><span>        setBitByIndex(startBitIndex + 2, (color3Bit &gt;&gt; 2) &amp; 1);
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>After the image is encoded, I simply read the whole thing from the SD card into <code>108Kb</code> buffer on the Raspberry Pico W side and then copy it into the Pimoroni SDK’s eInk screen buffer. The whole thing is only a couple of functions, most of which is handling IO errors:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#define IMAGE_WIDTH 600
</span></span></span><span><span><span>#define IMAGE_HEIGHT 448
</span></span></span><span><span><span>#define IMAGE_SIZE ((IMAGE_WIDTH * IMAGE_HEIGHT * 3) / 8)
</span></span></span><span><span><span></span>
</span></span><span><span>InkyFrame inky;
</span></span><span><span>
</span></span><span><span><span>uint8_t</span> <span>extract_bit</span>(<span>const</span> <span>uint8_t</span>* bytes, size_t index) {
</span></span><span><span>    size_t byte_index = index / 8;
</span></span><span><span>    size_t bit_index = index % 8;
</span></span><span><span>    <span>return</span> (bytes[byte_index] &gt;&gt; bit_index) &amp; 1;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>void</span> <span>display_image</span>(<span>const</span> <span>char</span>* filename) {
</span></span><span><span>    FIL file;
</span></span><span><span>    res = f_open(&amp;file, filename, FA_READ);
</span></span><span><span>    <span>if</span> (res != FR_OK) {
</span></span><span><span>        printf(<span>&#34;[ERROR] Failed to open image &#39;%s&#39;, code: %d</span><span>\n</span><span>&#34;</span>, filename, res);
</span></span><span><span>        <span>return</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>uint8_t</span> buffer[IMAGE_SIZE];
</span></span><span><span>    size_t read = 0;
</span></span><span><span>    res = f_read(&amp;file, buffer, IMAGE_SIZE, &amp;read);
</span></span><span><span>    <span>if</span> (res != FR_OK) {
</span></span><span><span>        printf(<span>&#34;[ERROR] Failed to read contents of image &#39;%s&#39;, code: %d</span><span>\n</span><span>&#34;</span>, filename, res);
</span></span><span><span>        <span>return</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>if</span> (read != IMAGE_SIZE) {
</span></span><span><span>        printf(<span>&#34;[ERROR] Image &#39;%s&#39; has the wrong size, actual: %d, expected: %d</span><span>\n</span><span>&#34;</span>, filename, read, IMAGE_SIZE);
</span></span><span><span>        <span>return</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>for</span> (size_t y = 0; y &lt; IMAGE_HEIGHT; y++) {
</span></span><span><span>        <span>for</span> (size_t x = 0; x &lt; IMAGE_WIDTH; x++) {
</span></span><span><span>            size_t base = y * IMAGE_WIDTH * 3 + x * 3;
</span></span><span><span>            <span>uint8_t</span> color = extract_bit(buffer, base) | (extract_bit(buffer, base + 1) &lt;&lt; 1) | (extract_bit(buffer, base + 2) &lt;&lt; 2);
</span></span><span><span>            inky.set_pen(color);
</span></span><span><span>            inky.set_pixel(Point(x, y));
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    inky.update(<span>true</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>The only thing left to do was to implement some simple controls for switching to a different photo using buttons on the frame. Clearly, after inventing a custom image format and a whole frontend for it, this would be the easiest part, right? Right?..</p>
<h2 id="sweet-dreams-and-wake-ups">Sweet dreams and wake-ups</h2>
<p>Remember I told you that there are no loops in the examples to the Pimoroni SDK? Even the image gallery example just exited after displaying one image. This got me curious - wasn’t the image gallery supposed to react to the user inputs and, well, change the image? I tried to copy the same approach into my code and it did not work. As expected, the frame displayed a single image and immediately exited. Thinking that the problem must be on my side, I have tried to remove as much as possible from my code. In the end, it was just blinking with a LED, but it still did not work. Loosing my faith and sanity, I tried to copy the code from the example as is - it still did not work!</p>
<p>After I lurking around Pimoroni forums for some time, my eye caught a curious word mentioned in the context of Inky Frame - RTC. I assumed that RTC here probably means Real-time Clock. I remembered that Pimoroni SDK has a method <code>inky.sleep(NUMBER_OF_SECONDS)</code>, which curiously was always called just before the final <code>return</code> statement in the <code>main</code> function. I lurked around some more and found a phrase “RTC wake-up”. Sudden realization started to crawl in my head.</p>
<p>Real-time Clocks are usually external devices. External devices are powered by battery. No battery - no external device. No RTC - no wake-ups. No wake-ups - no code running. Since my battery pack did not work, the frame was powered by the USB the entire time.</p>
<p>I searched the forum for these specific keywords and, sure enough, there was a <a href="https://forums.pimoroni.com/t/inky-frame-battery-powered-photoframe-rtc-troubles/21901/2">thread about it</a>. Every time you ask the frame to <code>inky.sleep(..)</code>, Raspberry Pico W is fully powered down. Button presses and RTC on board can cause the Pico W to “wake up”, running the code from the top. No wonder there were no loops in the examples - the frame hardware provided the guarantee to run the code in a loop. But <em>only</em> if the battery was provided, which, of course, was not documented anywhere. Actually, none of this was documented anywhere. I literally pieced the whole thing from replies on Pimoroni forums and this is not okay for a product with a retail price of ~100$.</p>
<p>I <a href="https://mastodon.social/@laplab/110357944637183570">was not</a> happy to discover this. Running out of options, I implemented the busy loop again. A true <a href="https://grugbrain.dev/">Grug Brained Developer</a> move would be to implement the busy loop from the start, but we all have something to learn I guess.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I am pretty happy with how this project turned out. The new version written in C++ is stable and has been working good for over a month now with no issues. My wife can easily add new photos or remove old ones when she wants to. She grew fond of this little thing and it warms my heart.</p>
<p>Regarding the frame itself - I am honestly not sure who this product targets. The RAM of Raspberry Pico W is clearly no fit for modern photography. There is no external RAM chip on the board itself and no interface to stream the image into the chip. The screen is clearly not fit for any interactive purposes, because the update time is 30 seconds and it does not support partial updates. The only two use cases left are calendars (seriously?) and images from James Webb Space Telescope. If you go off the marketed path, then you are completely on your own, with no documentation and little hope that whatever you come up with fits into the device capabilities. One can say that this is “a true hacker spirit”. In my opinion, “a true hacker spirit” is reverse-engineering a chip which was made before you were born. This is just a poorly documented product with a limited potential.</p>

    </article></div>
  </body>
</html>
