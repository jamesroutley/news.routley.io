<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neuml.github.io/txtai/embeddings/query/">Original</a>
    <h1>Semantic Search with SQLite</h1>
    
    <div id="readability-page-1" class="page"><div data-md-component="container">
      
      
        
          
        
      
      <main data-md-component="main">
        <div>
          
            
              
              
            
            
              
              
            
          
          
            <div data-md-component="content">
              <article>
                
                  

  <a href="https://github.com/neuml/txtai/edit/master/docs/embeddings/query.md" title="Edit this page">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"></path></svg>
  </a>



<p><img alt="query" src="https://neuml.github.io/txtai/images/query.png#only-light"/>
<img alt="query" src="https://neuml.github.io/txtai/images/query-dark.png#only-dark"/></p>
<p>This section covers how to query data with txtai. The simplest way to search for data is building a natural language string with the desired content to find. txtai also supports querying with SQL. We&#39;ll cover both methods here.</p>
<h2 id="natural-language-queries">Natural language queries</h2>
<p>In the simplest case, the query is text and the results are index text that is most similar to the query text.</p>
<div><pre><span></span><code><span>embeddings</span><span>.</span><span>search</span><span>(</span><span>&#34;feel good story&#34;</span><span>)</span>
<span>embeddings</span><span>.</span><span>search</span><span>(</span><span>&#34;wildlife&#34;</span><span>)</span>
</code></pre></div>
<p>The queries above <a href="https://neuml.github.io/txtai/embeddings/methods#txtai.embeddings.base.Embeddings.search">search</a> the index for similarity matches on <code>feel good story</code> and <code>wildlife</code>. If content storage is enabled, a list of <code>{**query columns}</code> is returned. Otherwise, a list of <code>(id, score)</code> tuples are returned.</p>
<h2 id="sql">SQL</h2>
<p>txtai supports more complex queries with SQL. This is only supported if <a href="https://neuml.github.io/txtai/embeddings/configuration/#content">content storage</a> is enabled. txtai has a translation layer that analyzes input SQL statements and combines similarity results with content stored in a relational database.</p>
<p>SQL queries are run through <code>embeddings.search</code> like natural language queries but the examples below only show the SQL query for conciseness.</p>
<div><pre><span></span><code><span>embeddings</span><span>.</span><span>search</span><span>(</span><span>&#34;SQL query&#34;</span><span>)</span>
</code></pre></div>
<h3 id="similar-clause">Similar clause</h3>
<p>The similar clause is a txtai function that enables similarity searches with SQL.</p>
<div><pre><span></span><code><span>SELECT</span><span> </span><span>id</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>score</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>similar</span><span>(</span><span>&#39;feel good story&#39;</span><span>)</span><span></span>
<span>SELECT</span><span> </span><span>id</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>score</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>similar</span><span>(</span><span>&#39;feel good story&#39;</span><span>)</span><span></span>
</code></pre></div>
<p>The similar clause takes two arguments:</p>
<div><pre><span></span><code><span>similar</span><span>(</span><span>&#34;query&#34;</span><span>,</span><span> </span><span>&#34;number of candidates&#34;</span><span>)</span><span></span>
</code></pre></div>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>query</td>
<td>natural language query to run</td>
</tr>
<tr>
<td>number of candidates</td>
<td>number of candidate results to return</td>
</tr>
</tbody>
</table>
<p>The txtai query layer has to join results from two separate components, a relational store and a similarity index. With a similar clause, a similarity search is run and those ids are fed to the underlying database query.</p>
<p>The number of candidates should be larger than the desired number of results when applying additional filter clauses. This ensures that <code>limit</code> results are still returned after applying additional filters. If the number of candidates is not specified, it is defaulted as follows:</p>
<ul>
<li>For a single query filter clause, the default is the query limit</li>
<li>With multiple filtering clauses, the default is 10x the query limit</li>
</ul>
<h3 id="dynamic-columns">Dynamic columns</h3>
<p>Content can be indexed in multiple ways when content storage is enabled. <a href="https://neuml.github.io/txtai/embeddings/#index">Remember that input documents</a> take the form of <code>(id, data, tags)</code> tuples. If data is a string, then content is primarily filtered with similar clauses. If data is a dictionary, then all fields in the dictionary are indexed and searchable.</p>
<p>For example:</p>
<div><pre><span></span><code><span>embeddings</span><span>.</span><span>index</span><span>([(</span><span>0</span><span>,</span> <span>{</span><span>&#34;text&#34;</span><span>:</span> <span>&#34;text to index&#34;</span><span>,</span> <span>&#34;flag&#34;</span><span>:</span> <span>True</span><span>,</span>
                       <span>&#34;entry&#34;</span><span>:</span> <span>&#34;2022-01-01&#34;</span><span>},</span> <span>None</span><span>)])</span>
</code></pre></div>
<p>With the above input data, queries can now have more complex filters.</p>
<div><pre><span></span><code><span>SELECT</span><span> </span><span>text</span><span>,</span><span> </span><span>flag</span><span>,</span><span> </span><span>entry</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>similar</span><span>(</span><span>&#39;query&#39;</span><span>)</span><span> </span><span>AND</span><span> </span><span>flag</span><span> </span><span>=</span><span> </span><span>1</span><span></span>
<span>AND</span><span> </span><span>entry</span><span> </span><span>&gt;=</span><span> </span><span>&#39;2022-01-01&#39;</span><span></span>
</code></pre></div>
<p>txtai&#39;s query layer automatically detects columns and translates queries into a format that can be understood by the underlying database.</p>
<p>Nested dictionaries/JSON is supported and can be escaped with bracket statements.</p>
<div><pre><span></span><code><span>embeddings</span><span>.</span><span>index</span><span>([(</span><span>0</span><span>,</span> <span>{</span><span>&#34;text&#34;</span><span>:</span> <span>&#34;text to index&#34;</span><span>,</span>
                       <span>&#34;parent&#34;</span><span>:</span> <span>{</span><span>&#34;child element&#34;</span><span>:</span> <span>&#34;abc&#34;</span><span>}},</span> <span>None</span><span>)])</span>
</code></pre></div>
<div><pre><span></span><code><span>SELECT</span><span> </span><span>text</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>[</span><span>parent</span><span>.</span><span>child</span><span> </span><span>element</span><span>]</span><span> </span><span>=</span><span>&#39;abc&#39;</span><span></span>
</code></pre></div>
<p>Note the bracket statement escaping the nested column with spaces in the name.</p>
<h3 id="aggregation-queries">Aggregation queries</h3>
<p>The goal of txtai&#39;s query language is to closely support all functions in the underlying database engine. The main challenge is ensuring dynamic columns are properly escaped into the engines native query function. </p>
<p>Aggregation query examples.</p>
<div><pre><span></span><code><span>SELECT</span><span> </span><span>count</span><span>(</span><span>*</span><span>)</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>similar</span><span>(</span><span>&#39;feel good story&#39;</span><span>)</span><span> </span><span>AND</span><span> </span><span>score</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>.</span><span>15</span><span></span>
<span>SELECT</span><span> </span><span>max</span><span>(</span><span>length</span><span>(</span><span>text</span><span>))</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>WHERE</span><span> </span><span>similar</span><span>(</span><span>&#39;feel good story&#39;</span><span>)</span><span></span>
<span>AND</span><span> </span><span>score</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>.</span><span>15</span><span></span>
<span>SELECT</span><span> </span><span>count</span><span>(</span><span>*</span><span>),</span><span> </span><span>flag</span><span> </span><span>FROM</span><span> </span><span>txtai</span><span> </span><span>GROUP</span><span> </span><span>BY</span><span> </span><span>flag</span><span> </span><span>ORDER</span><span> </span><span>BY</span><span> </span><span>count</span><span>(</span><span>*</span><span>)</span><span> </span><span>DESC</span><span></span>
</code></pre></div>
<h2 id="binary-objects">Binary objects</h2>
<p>txtai has support for storing and retrieving binary objects. Binary objects can be retrieved as shown in the example below.</p>
<div><pre><span></span><code><span># Get an image</span>
<span>request</span> <span>=</span> <span>open</span><span>(</span><span>&#34;demo.gif&#34;</span><span>)</span>

<span># Insert record</span>
<span>embeddings</span><span>.</span><span>index</span><span>([(</span><span>&#34;txtai&#34;</span><span>,</span> <span>{</span><span>&#34;text&#34;</span><span>:</span> <span>&#34;txtai executes machine-learning workflows.&#34;</span><span>,</span>
                             <span>&#34;object&#34;</span><span>:</span> <span>request</span><span>.</span><span>read</span><span>()},</span> <span>None</span><span>)])</span>

<span># Query txtai and get associated object</span>
<span>query</span> <span>=</span> <span>&#34;select object from txtai where similar(&#39;machine learning&#39;) limit 1&#34;</span>
<span>result</span> <span>=</span> <span>embeddings</span><span>.</span><span>search</span><span>(</span><span>query</span><span>)[</span><span>0</span><span>][</span><span>&#34;object&#34;</span><span>]</span>
</code></pre></div>
<h2 id="custom-sql-functions">Custom SQL functions</h2>
<p>Custom, user-defined SQL functions extend selection, filtering and ordering clauses with additional logic. For example, the following snippet defines a function that translates text using a translation pipeline.</p>
<div><pre><span></span><code><span># Translation pipeline</span>
<span>translate</span> <span>=</span> <span>Translation</span><span>()</span>

<span># Create embeddings index</span>
<span>embeddings</span> <span>=</span> <span>Embeddings</span><span>({</span><span>&#34;path&#34;</span><span>:</span> <span>&#34;sentence-transformers/nli-mpnet-base-v2&#34;</span><span>,</span>
                         <span>&#34;content&#34;</span><span>:</span> <span>True</span><span>,</span>
                         <span>&#34;functions&#34;</span><span>:</span> <span>[</span><span>translate</span><span>]})</span>

<span># Run a search using a custom SQL function</span>
<span>embeddings</span><span>.</span><span>search</span><span>(</span><span>&#34;&#34;&#34;</span>
<span>select</span>
<span>  text,</span>
<span>  translation(text, &#39;de&#39;, null) &#39;text (DE)&#39;,</span>
<span>  translation(text, &#39;es&#39;, null) &#39;text (ES)&#39;,</span>
<span>  translation(text, &#39;fr&#39;, null) &#39;text (FR)&#39;</span>
<span>from txtai where similar(&#39;feel good story&#39;)</span>
<span>limit 1</span>
<span>&#34;&#34;&#34;</span><span>)</span>
</code></pre></div>
<h2 id="query-translation">Query translation</h2>
<p>Natural language queries with filters can be converted to txtai-compatible SQL statements with query translation. For example:</p>
<div><pre><span></span><code><span>embeddings</span><span>.</span><span>search</span><span>(</span><span>&#34;feel good story since yesterday&#34;</span><span>)</span>
</code></pre></div>
<p>can be converted to a SQL statement with a similar clause and date filter.</p>
<div><pre><span></span><code><span>select</span><span> </span><span>id</span><span>,</span><span> </span><span>text</span><span>,</span><span> </span><span>score</span><span> </span><span>from</span><span> </span><span>txtai</span><span> </span><span>where</span><span> </span><span>similar</span><span>(</span><span>&#39;feel good story&#39;</span><span>)</span><span> </span><span>and</span><span></span>
<span>entry</span><span> </span><span>&gt;=</span><span> </span><span>date</span><span>(</span><span>&#39;now&#39;</span><span>,</span><span> </span><span>&#39;-1 day&#39;</span><span>)</span><span></span>
</code></pre></div>
<p>This requires setting a <a href="https://neuml.github.io/txtai/embeddings/configuration#query">query translation model</a>. The default query translation model is <a href="https://huggingface.co/NeuML/t5-small-txtsql">t5-small-txtsql</a> but this can easily be finetuned to handle different use cases.</p>
<h2 id="combined-index-architecture">Combined index architecture</h2>
<p>When content storage is enabled, txtai becomes a dual storage engine. Content is stored in an underlying database (currently supports SQLite) along with an Approximate Nearest Neighbor (ANN) index. These components combine to deliver similarity search alongside traditional structured search.</p>
<p>The ANN index stores ids and vectors for each input element. When a natural language query is run, the query is translated into a vector and a similarity query finds the best matching ids. When a database is added into the mix, an additional step is applied. This step takes those ids and effectively inserts them as part of the underlying database query.</p>
<p>Dynamic columns are supported via the underlying engine. For SQLite, data is stored as JSON and dynamic columns are converted into <code>json_extract</code> clauses. This same concept can be expanded to other storage engines like PostgreSQL and could even work with NoSQL stores. </p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        
      
    </div></div>
  </body>
</html>
