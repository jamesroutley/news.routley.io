<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://backreference.org/2010/02/10/idiomatic-awk/">Original</a>
    <h1>Idiomatic Awk (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>Here we&#39;ll see some hints on how to write more idiomatic (and usually shorter and more efficient) awk programs. Many awk programs you’re likely to encounter, especially short ones, make large use of these notions.</p>
<h4>The power of conditions</h4>
<p>As a starting example, suppose you want to print all the records (normally lines) in a file that match some pattern (a kind of awk-grep, if you like). A reasonable first shot is usually something like</p>
<pre><strong>awk &#39;{if ($0 ~ /pattern/) print $0}&#39;</strong></pre>
<p>That works, but there are some things to note.</p>
<p>The first thing to note is that it is not structured according to awk’s definition of a program, which is</p>
<pre>condition { actions }</pre>
<p>Our program can clearly be rewritten using this form, since both the condition and the action are very clear:</p>
<pre><strong>awk &#39;$0 ~ /pattern/ {print $0}&#39;</strong></pre>
<p>Our next step in the perfect awk-ification of this program is to note that the <strong>/pattern/</strong> syntax is the same as <strong><nobr>$0 ~ /pattern/</nobr></strong>. That is, when awk sees a regular expression literal used as an expression, it implicitly applies it to $0, and returns true if there is a match. So now we have:</p>
<pre><strong>awk &#39;/pattern/ {print $0}&#39;</strong></pre>
<p>Now, let’s turn our attention to the action part (the stuff inside braces). <strong><nobr>print $0</nobr></strong> is redundant, since <strong>print</strong> alone, by default, prints $0.</p>
<pre><strong>awk &#39;/pattern/ {print}&#39;</strong></pre>
<p>But let&#39;s make another step. When it finds that a condition is true, and there are no associated actions, awk performs a <em>default action</em>, and that action (you guessed it) is <strong>print</strong> (which we already know is equivalent to <strong><nobr>print $0</nobr></strong>). Thus we can finally do this:</p>
<pre><strong>awk &#39;/pattern/&#39;</strong></pre>
<p>Now we have reduced the initial program to its simplest (and more idiomatic) form. In many cases, if all you want to do is print some records (lines), according to a condition, you can write awk programs composed only of a condition (although complex):</p>
<pre><strong>awk &#39;(NR%2 &amp;&amp; /pattern/) || (!(NR%2) &amp;&amp; /anotherpattern/)&#39;</strong></pre>
<p>That prints odd lines that match <strong>/pattern/</strong> and even lines that match <strong>/anotherpattern/</strong>. Naturally, if you don’t want to print $0 but instead do something else, then you’ll have to manually add a specific action to do what you want.</p>
<p>From the above, it follows that</p>
<pre><strong>awk 1</strong>
<strong>awk &#39;&#34;a&#34;&#39;</strong>   # single quotes are important!</pre>
<p>are two awk programs that just print their input unchanged, both &#34;1&#34; and the string &#34;a&#34; obviously being always-true conditions. This is not terribly useful by itself, but it can be used in combination with other code in a number of circumstances.</p>
<pre><strong>awk &#39;{sub(/pattern/, &#34;foobar&#34;)} 1&#39;</strong></pre>
<p>This tries to replace whatever matches <strong><nobr>/pattern/</nobr></strong> with &#34;foobar&#34;. But whether or not the substitution succeeds, the always-true condition &#34;1&#34; prints each line (you could even use 42, or 19, or any other nonzero value if you so prefer; 1 is just what people traditionally use). This results in a program that does the same job as </p>
<pre><strong>sed &#39;s/pattern/foobar/&#39;</strong></pre>
<p>Here are some examples of typical awk programs, using only conditions:</p>
<pre><strong>awk &#39;NR % 6&#39;</strong>            # prints all lines except lines 6,12,18...
<strong>awk &#39;NR &gt; 5&#39;</strong>            # prints from line 6 onwards (like tail -n +6, or sed &#39;1,5d&#39;)
<strong>awk &#39;$2 == &#34;foo&#34;&#39;</strong>       # prints lines where the second field is &#34;foo&#34;
<strong>awk &#39;NF &gt;= 6&#39;</strong>           # prints lines with 6 or more fields
<strong>awk &#39;/foo/ &amp;&amp; /bar/&#39;</strong>    # prints lines that match /foo/ and /bar/, in any order
<strong>awk &#39;/foo/ &amp;&amp; !/bar/&#39;</strong>   # prints lines that match /foo/ but not /bar/
<strong>awk &#39;/foo/ || /bar/&#39;</strong>    # prints lines that match /foo/ or /bar/ (like grep -e &#39;foo&#39; -e &#39;bar&#39;)
<strong>awk &#39;/foo/,/bar/&#39;</strong>       # prints from line matching /foo/ to line matching /bar/, inclusive
<strong>awk &#39;NF&#39;</strong>                # prints only nonempty lines (or: do not print empty lines, where NF==0)
<strong>awk &#39;NF--&#39;</strong>              # removes last field and prints the line
<strong>awk &#39;$0 = NR&#34; &#34;$0&#39;</strong>      # prepends line numbers (assignments are valid in conditions)
<strong>awk &#39;!a[$0]++&#39;</strong>          # suppresses duplicated lines! (figure out how it works)</pre>
<p>As an extreme example of the power of conditions, let&#39;s examine the following code:</p>
<pre><strong>awk &#39;ORS = NR % 5 ? FS : RS&#39;</strong></pre>
<p>You might also find it written with no spaces at all, especially in golf-ish contexts:</p>
<pre><strong>awk &#39;ORS=NR%5?FS:RS&#39;</strong></pre>
<p>Let&#39;s run it using some simple input:</p>
<pre>$ <strong>seq 1 30 | awk &#39;ORS=NR%5?FS:RS&#39;</strong>
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
26 27 28 29 30</pre>
<p>So what it does is columnate the input (in groups of five columns here, but just change the number 5 in the code to the number you want, or use a variable and pass the value using <strong>-v</strong>). Why does it work? Well, when awk prints an output record (line), the special variable <strong>ORS</strong>, as the name suggests, contains the separator to append to the line. By default, <strong>ORS</strong> is &#34;<strong>\n</strong>&#34;, ie a newline character. But here we are explicitly assigning a value to <strong>ORS</strong> depending on the outcome of the ternary operator. So if <strong><nobr>NR%5</nobr></strong> is zero (ie, we are at line 5, 10, 15, etc.), <strong>ORS</strong> gets the value of <strong>RS</strong> (which by default contains &#34;<strong>\n</strong>&#34;); otherwise <strong>ORS</strong> gets the value of <strong>FS</strong> (by default, a space). If <strong>RS</strong> and <strong>FS</strong> have their standard values, it can be rewritten like this:</p>
<pre><strong>awk &#39;ORS=NR%5?&#34; &#34;:&#34;\n&#34;&#39;</strong></pre>
<p>Overall, in the end the whole code is an assignment which, as we&#39;ve seen, is evaluated and returns the assigned value (so either the value of <strong>RS</strong> or <strong>FS</strong> here, <em>neither of which is nontrue</em>). Since we&#39;re having a true condition, the default action (<strong>print</strong>) is executed for every line, and as that is done, <strong>ORS</strong> either adds a newline or a space, depending on whether we are at column 5 or not.</p>
<p>Note that the ternary operator can be changed to yield different results; for example, this code</p>
<pre><strong>awk &#39;ORS=/foo$/?FS:RS&#39;</strong></pre>
<p>joins the following line to the current one if the current one ends in <strong>foo</strong>. You are encouraged to find your own variations.</p>
<h4>Self-assignments</h4>
<p>Let&#39;s take another relatively common task: replacing the delimiters. Your input fields are delimited, for example, by semicolons (or any other arbitrarily complex separator), and you want to change that to, say, commas. Armed with the knowledge you gathered in the first part of this article, you do</p>
<pre><strong>awk -v FS=&#39;;&#39; -v OFS=&#39;,&#39; 1</strong>   # doesn&#39;t work!</pre>
<p>but that doesn&#39;t work, and it outputs the input unchanged. The reason for this behavior is that <em>awk does not rebuild $0</em> (that is, replacing <strong>FS</strong> with <strong>OFS</strong>) <em>until some field is modified</em>. That might seem strange at first, but it makes sense (and is even useful) in many circumstances. One reason for this behavior is one of efficiency: if the input and output separator are the same, as it happens many times, replacing FS with OFS is pointless. And if you think about it, if awk really <em>always</em> replaced FS with OFS, a program as simple as</p>
<pre>$ <strong>echo &#39;foo;bar&#39; | awk -v FS=&#39;;&#39; -v OFS=&#39;,&#39; &#39;/foo/&#39;</strong></pre>
<p>would output</p>
<pre>foo,bar   # ????</pre>
<p>which violates the principle of least surprise and most certainly is not what one expects here.</p>
<p>So back to the original problem, you can now see a solution: to force recomputation of $0, just let awk think you&#39;ve changed a field, but without changing it:</p>
<pre><strong>awk -v FS=&#39;;&#39; -v OFS=&#39;,&#39; &#39;{$1=$1}1&#39;</strong></pre>
<p>The <strong><nobr>$1=$1</nobr></strong> bit is what confuses many people, who wonder what it&#39;s for. It&#39;s a typical awk idiom to force awk to rebuild $0 (usually to apply some <strong>OFS</strong>). </p>
<p><strong>Warning</strong>: useless information follows.</p>
<p>If you&#39;re sure that $1 will never be an empty string, you can even golf the code a bit more and <em>use the assignment as the condition</em>, so</p>
<pre><strong>awk -v FS=&#39;;&#39; -v OFS=&#39;,&#39; &#39;$1=$1&#39;</strong></pre>
<p>If you want to shorten it even more (and make it more cryptic) to impress your friends or whatever reason, you can move the assignments at the end to save the <strong>-v</strong> and remove some quotes:</p>
<pre><strong>awk &#39;$1=$1&#39; FS=\; OFS=,</strong></pre>
<p>That exploits an obscure feature of awk where any argument that has a &#34;<strong>=</strong>&#34; in it is treated as a variable assignment instead of a file to read (which, btw, makes it hard to persuade awk to operate on files whose name contains &#34;<strong>=</strong>&#34;. I&#39;m sure your life will never be the same now that you know this). Well, I did say that this was useless information, so let&#39;s get back to something more practical...</p>
<h4>Build strings with separators</h4>
<p>This is similar to the so-called <strong>fencepost problem</strong>. In many occasions you need to build a string using concatenation, starting from an empty string, and adding values as you go. The values should be separated by some separator (let&#39;s say, a semicolon for these examples). One might do this, in some loop:</p>
<pre><strong>string = string &#34;;&#34; somedata</strong></pre>
<p>but then <strong>string</strong> has an unwanted leading semicolon. Putting the semicolon after the variable has a similar problem. So a typical way to do this with awk is this:</p>
<pre><strong>string = string sep somedata; sep = &#34;;&#34;</strong></pre>
<p>This exploits the fact that awk variables start out containing the dual value empty string or zero, so the first time the code is executed, <strong>sep</strong> is empty (you can explicitly initialize it to the empty string in a BEGIN block, if you like, but it&#39;s redundant). Then it&#39;s set to a semicolon, and it will have that value from the second time the code is executed onwards. The result is that at the end <strong>string</strong> will have a neat list of values with the semicolons only where they should be.</p>
<p>As a practical example of this idiom, let&#39;s see how to transpose a matrix using awk:</p>
<pre>$ <strong>cat matrix.txt</strong>
a1;a2;a3;a4;a5
b1;b2;b3;b4;b5
c1;c2;c3;c4;c5
d1;d2;d3;d4;d5
$ <strong>awk -F\; &#39;{for(i=1;i&lt;=NF;i++)r[i]=r[i] sep $i;sep=FS}END{for(i=1;i&lt;=NF;i++)print r[i]}&#39; matrix.txt</strong>
a1;b1;c1;d1
a2;b2;c2;d2
a3;b3;c3;d3
a4;b4;c4;d4
a5;b5;c5;d5</pre>
<p>The idea here is to build an array <strong>r</strong> with <strong>NF</strong> elements (the number of columns in the original input), each of which will hold a line of the output. For each input line, every element of <strong>r</strong> has another &#34;column&#34; added. The variable <strong>sep</strong> is initially empty, then (after the first input line has been processed) it&#39;s set to semicolon. Of course, for more complex processing, an array of separators could be used.</p>
<h4>Two-file processing</h4>
<p>Another construct that is often used in awk is as follows:</p>
<pre>$ <strong>awk &#39;NR == FNR { # some actions; next} # other condition {# other actions}&#39; file1.txt file2.txt</strong></pre>
<p>This is used when processing two files. When processing more than one file, awk reads each file sequentially, one after another, in the order they are specified on the command line. The special variable <strong>NR</strong> stores the total number of input records read so far, regardless of how many files have been read. The value of <strong>NR</strong> starts at 1 and always increases until the program terminates. Another variable, <strong>FNR</strong>, stores the number of records read <em>from the current file being processed</em>. The value of <strong>FNR</strong> starts at 1, increases until the end of the current file is reached, then is set again to 1 as soon as the first line of the next file is read, and so on. So, the condition <strong>NR == FNR</strong> <em>is only true while awk is reading the first file</em>. Thus, in the program above, the actions indicated by <strong><nobr># some actions</nobr></strong> are executed when awk is reading the first file; the actions indicated by <strong><nobr># other actions</nobr></strong> are executed when awk is reading the second file, <em>if the condition in <strong><nobr># other condition</nobr></strong> is met</em>. The <strong>next</strong> at the end of the first action block is needed to prevent the condition in <strong><nobr># other condition</nobr></strong> from being evaluated, and the actions in <strong><nobr># other actions</nobr></strong> from being executed, while awk is reading the first file.</p>
<p>Probably, it all becomes much clearer with some examples. There are really many problems that involve two files that can be solved using this technique. Let&#39;s look at this:</p>
<pre># prints lines that are both in file1.txt and file2.txt (intersection)
$ <strong>awk &#39;NR == FNR{a[$0];next} $0 in a&#39; file1.txt file2.txt</strong></pre>
<p>Here we see another typical idiom: <strong><nobr>a[$0]</nobr></strong> alone has the only purpose of creating the array element indexed by $0, even if we don&#39;t assign any value to it. During the pass over the first file, all the lines seen are remembered as indexes of the array <strong>a</strong>. The pass over the second file just needs to check whether each line being read exists as an index in the array <strong>a</strong> (that&#39;s what the condition <strong><nobr>$0 in a</nobr></strong> does). If the condition is true, the line being read from <nobr>file2.txt</nobr> is printed (as we already know). In a very similar way, we can easily write the code to print the lines that appear <em>in only one of the two files</em>:</p>
<pre># prints lines that are only in file1.txt and not in file2.txt
$ <strong>awk &#39;NR == FNR{a[$0];next} !($0 in a)&#39; file2.txt file1.txt</strong></pre>
<p>Note the order of the arguments. <nobr>file2.txt</nobr> is given first. To print lines that are only in <nobr>file2.txt</nobr> and not in file1.txt, just reverse the order of the arguments.</p>
<p>Another example. Suppose we have a data file like this</p>
<pre>$ <strong>cat data.txt</strong>
20081010 1123 xxx
20081011 1234 def
20081012 0933 xyz
20081013 0512 abc
20081013 0717 def
...thousand of lines...</pre>
<p>where &#34;xxx&#34;, &#34;def&#34;, etc. are some kind of operation codes. We want to replace each operation code with its description. We have another file that maps operation codes to human readable descriptions, like this:</p>
<pre>$ <strong>cat map.txt</strong>
abc withdrawal
def payment
xyz deposit
xxx balance
...other codes...</pre>
<p>We can easily replace the opcodes in the data file with this simple awk program, that again uses the two-files idiom (and other idioms that were already introduced):</p>
<pre># use information from a map file to modify a data file
$ <strong>awk &#39;NR == FNR{a[$1]=$2;next} {$3=a[$3]}1&#39; map.txt data.txt</strong></pre>
<p>First, the array <strong>a</strong>, indexed by opcode, is populated with the human readable descriptions, read from the map file. Then, it is used during the reading of the data file to do the replacements. Each line of the data file is then printed after the substitution has been made.</p>
<p>Another case where the two-files idiom is useful is when you have to read the same file twice, the first time to get some information that can be correctly defined only by reading the whole file, and the second time to process the file using that information. For example, you want to replace each number in a list of numbers with its difference from the largest number in the list:</p>
<pre># replace each number with its difference from the maximum
$ <strong>awk &#39;NR == FNR{if($0 &gt; max) max = $0;next} {$0 = max - $0}1&#39; file.txt file.txt</strong></pre>
<p>Note that we specify <strong><nobr>file.txt file.txt</nobr></strong> on the command line, so the file will be read twice. This makes no difference to awk, which just thinks it has two files to read.</p>
<p>As with all other idioms, you are encouraged to find your own uses and variations.</p>
<p><strong>Caveat</strong>: all the programs that use the two-files idiom will not work correctly if the first file is empty (in that case, awk will execute the actions associated to <nobr>NR == FNR</nobr> while reading the second file). To correct that, you can reinforce the <nobr>NR == FNR</nobr> condition by adding a test that, for example, checks that also FILENAME is equal to <nobr>ARGV[1]</nobr>.</p>
							</div></div>
  </body>
</html>
