<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://theorangeduck.com/page/cubic-interpolation-quaternions">Original</a>
    <h1>Cubic Interpolation of Quaternion</h1>
    
    <div id="readability-page-1" class="page"><div>
					
					  



 
<h3>Created on April 25, 2023, 9:01 a.m.</h3>



<p>If you&#39;ve ever googled &#34;cubic interpolation of quaternions&#34; or looked up the &#34;SQUAD&#34; algorithm you&#39;d be forgiven for thinking that understanding how to do smooth, cubic interpolation of quaternions requires some really advanced mathematics.</p>

<p>But it really doesn&#39;t need to be that complicated. And if we understand well the algorithm for normal cubic interpolation (and more specifically, <a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline">Catmull-Rom</a> cubic interpolation), the quaternion version pretty much falls into our laps.</p>

<p>Whenever the subject of cubic interpolation and splines comes up it would be wrong of me not to recommend the absolute master-class that is Freya Holm√©r&#39;s <a href="https://www.youtube.com/watch?v=aVwxzDHniEw">spline</a> <a href="https://www.youtube.com/watch?v=jvPPXbo87ds">videos</a> - watching these should give you a great intuition not just about the process we are going to go through in this article, but about splines in general.</p>

<hr/>

<h2>Hermite Curve Interpolation</h2>

<p>Forget about quaternions for now. Instead, we&#39;re going to start with the following more simple problem: if we have two values at 0 and 1, and gradients for those values at 0 and 1, how can we produce a smooth interpolation which passes through those values with the given gradients?</p>

<p><img src="https://theorangeduck.com/media/uploads/cubic_interpolation_drawn.png" alt="cubic interpolation drawn"/></p>

<p>The solution is to fit a cubic polynomial function \( f \) to the two points and their gradients. In this case we have four constraints...</p>

<p>
\begin{align*}
f(0) &amp;= p_0 \\
f(1) &amp;= p_1 \\
f&#39;(0) &amp;= v_0 \\
f&#39;(1) &amp;= v_1 \\
\end{align*}
</p>

<p>...and four unknowns \( a \), \( b \), \( c \), and \( d \).</p>

<p>
\begin{align*}
f(x) &amp;= a\ x^3 + b\ x^2 + c\ x + d \\
f&#39;(x) &amp;= 3\ a\ x^2 + 2\ b\ x + c \\
\end{align*}
</p>

<p>So we just need to plug our different equations into each other and solve for \( a \), \( b \), \( c \), and \( d \).</p>

<p>First we solve for \( d \) using our first constraint \( f(0) = p_0 \)...</p>

<p>
\begin{align*}
p_0 &amp;= a\ 0 + b\ 0 + c\ 0 + d \\
d &amp;= p_0 \\
\end{align*}
</p>

<p>Then we solve for \( c \) using our third constraint \( f&#39;(0) = v_0 \)...</p>

<p>
\begin{align*}
v_0 &amp;= 3\ a\ 0 + 2\ b\ 0 + c \\
c &amp;= v_0 \\
\end{align*}
</p>

<p>Then we can solve for \( b \) using our other two constraints and our solutions for \( d \) and \( c \)...</p>

<p>
\begin{align*}
p_1 &amp;= a\ 1 + b\ 1 + c\ 1 + d \\
a &amp;= p_1 - b - v_0 - p_0 \\
&amp;\\
v_1 &amp;= 3\ a\ 1 + 2\ b\ 1 + c \\
v_1 &amp;= 3\ (p_1 - b - v_0 - p_0) + 2\ b + v_0 \\
v_1 &amp;= 3\ p_1 - 3\ b - 3\ v_0 - 3\ p_0 + 2\ b + v_0 \\
b &amp;= 3\ p_1 - 2\ v_0 - 3\ p_0 - v_1 \\
\end{align*}
</p>

<p>And finally we can solve for \( a \)...</p>

<p>
\begin{align*}
a &amp;= p_1 - b - v_0 - p_0 \\
a &amp;= p_1 - (3\ p_1 - 2\ v_0 - 3\ p_0 - v_1) - v_0 - p_0 \\
a &amp;= v_0 + 2\ p_0 + v_1 - 2\ p_1 \\
\end{align*}
</p>

<p>We can plot this cubic function to verify that it passes through the given points, and with the correct gradients:</p>

<p><img src="https://theorangeduck.com/media/uploads/cubic_interpolation_test.png" alt="cubic interpolation test"/></p>

<p>Nice! If we expand the cubic function with our values for \( a \), \( b \), \( c \), and \( d \) substituted, we can rearrange things such that our result is expressed in terms of \( p_0 \), \( p_1 \), \( v_0 \) and \( v_1 \) directly (rather than the polynomial coefficients):</p>
<p>
\begin{align*}
f(x) &amp;= (v_0 + 2\ p_0 + v_1 - 2\ p_1)\ x^3 + (3\ p_1 - 2\ v_0 - 3\ p_0 - v_1)\ x^2 + v_0\ x + p_0 \\
f(x) &amp;= v_0\ x^3 + 2\ p_0\ x^3 + v_1\ x^3 - 2\ p_1\ x^3 + 3\ p_1\ x^2 - 2\ v_0\ x^2 - 3\ p_0\ x^2 - v_1\ x^2 + v_0\ x + p_0 \\
f(x) &amp;= p_0\ (2\ x^3 - 3\ x^2 + 1) + p_1\ (3\ x^2 - 2\ x^3) + v_0\ (x^3 - 2\ x^2 + x) + v_1\ (x^3 - x^2) \\
\end{align*}
</p>

<p>This is useful because usually \( x \) is a scalar, while \( p_0 \), \( p_1 \), \( v_0 \) and \( v_1 \) can often be 3d vectors. For example, we can implement a version that works on 3d vectors in C++ as follows, where <code>x</code> is our interpolating value between 0 and 1:</p>

<pre><code data-language="C">vec3 hermite_basic(float x, vec3 p0, vec3 p1, vec3 v0, vec3 v1)
{  
    float w0 = 2*x*x*x - 3*x*x + 1;
    float w1 = 3*x*x - 2*x*x*x;
    float w2 = x*x*x - 2*x*x + x;
    float w3 = x*x*x - x*x;
    
    return w0*p0 + w1*p1 + w2*v0 + w3*v1;
}
</code></pre>

<p>(Aside: Notice how <code>w0</code> and <code>w1</code> are both versions of <a href="https://en.wikipedia.org/wiki/Smoothstep">smoothstep</a> - isn&#39;t that cool!)</p>

<p>Since we have the derivative of our cubic polynomial function, we can also compute the gradient/velocity of the interpolated result and get our function to output that too:</p>

<pre><code data-language="C">void hermite(
    vec3&amp; pos,
    vec3&amp; vel, 
    float x, 
    vec3 p0,
    vec3 p1, 
    vec3 v0,
    vec3 v1)
{
    float w0 = 2*x*x*x - 3*x*x + 1;
    float w1 = 3*x*x - 2*x*x*x;
    float w2 = x*x*x - 2*x*x + x;
    float w3 = x*x*x - x*x;
    
    float q0 = 6*x*x - 6*x;
    float q1 = 6*x - 6*x*x;
    float q2 = 3*x*x - 4*x + 1;
    float q3 = 3*x*x - 2*x;
    
    pos = w0*p0 + w1*p1 + w2*v0 + w3*v1;
    vel = q0*p0 + q1*p1 + q2*v0 + q3*v1;
}
</code></pre>

<p>Which looks something like this:</p>

<p><img src="https://theorangeduck.com/media/uploads/cubic_interpolation_full.png" alt="cubic interpolation full"/></p>

<p>One last adjustment to this formula is to effectively translate our points such that \( p_0 = 0 \). Then, once we have the interpolated value, translate it back up by adding the original value of \( p_0 \):</p>

<pre><code data-language="C">void hermite_alt(
    vec3&amp; pos,
    vec3&amp; vel, 
    float x, 
    vec3 p0,
    vec3 p1, 
    vec3 v0,
    vec3 v1)
{
    vec3 p1_sub_p0 = p1 - p0;

    float w1 = 3*x*x - 2*x*x*x;
    float w2 = x*x*x - 2*x*x + x;
    float w3 = x*x*x - x*x;
    
    float q1 = 6*x - 6*x*x;
    float q2 = 3*x*x - 4*x + 1;
    float q3 = 3*x*x - 2*x;
    
    pos = w1*p1_sub_p0 + w2*v0 + w3*v1 + p0;
    vel = q1*p1_sub_p0 + q2*v0 + q3*v1;
}
</code></pre>

<p>This might seem like a pointless extra step, but this formulation with the first point at zero actually simplifies things in a way which will be really useful when we start dealing with quaternions.</p>

<p>What we&#39;ve derived is called Hermite Cubic Interpolation, and is essentially the mathematics used for a single segment of a Hermite Spline, which will be a key part of doing cubic interpolation of quaternions.</p>

<hr/>

<h2>Catmull-Rom Cubic Interpolation</h2>

<p>If we have a series of points and their gradients/velocities, we can use the previous equation to make a smooth interpolation that passes through them. But what if we just have points? With no velocities or gradients associated with them? Can we still use Hermite Curve Interpolation?</p>

<p>Yes! The trick is to take four points instead of two, and to use the <a href="https://en.wikipedia.org/wiki/Finite_difference">central difference</a> to &#34;estimate&#34; a gradient/velocity to associate with each of the middle two points. Then, once we have these velocities we can use Hermite Curve Interpolation to interpolate the intermediate values.</p>

<p>In code it looks something like this:</p>

<pre><code data-language="C">void catmull_rom(
    vec3&amp; pos,
    vec3&amp; vel,
    float x,
    vec3 p0,
    vec3 p1, 
    vec3 p2,
    vec3 p3)
{
    vec3 v1 = ((p1 - p0) + (p2 - p1)) / 2;
    vec3 v2 = ((p2 - p1) + (p3 - p2)) / 2;
    return hermite(pos, vel, x, p1, p2, v1, v2);
}
</code></pre>

<p>You can see that we compute the central difference for these two middle points using the average of the forward and backward differences. Then, we pass these estimated velocities to our Hermite Curve Interpolation function to get the final interpolated value! The result is something like this:</p>

<p><img src="https://theorangeduck.com/media/uploads/catmull_rom_spline.png" alt="catmull rom spline"/></p>

<p>And that&#39;s how we use a Catmull-Rom spline to do cubic interpolation. Here is what it looks like in 3d:</p>



<hr/>

<h2>Quaternion Catmull-Rom Cubic Interpolation</h2>

<p>Now that we understand exactly what is going on (and what each different value and computation represents) we are ready to adapt our equations to work with quaternions instead of positions.</p>

<p>First we will tackle the Hermite Cubic Interpolation function, and there are a few changes we need to make to get this formula to work for quaternions:</p>

<ol>
<li>Instead of linear velocities, we need to use <a href="https://theorangeduck.com/page/exponential-map-angle-axis-angular-velocity">angular velocities</a>.</li>
<li>When we compute the difference between <code>p0</code> and <code>p1</code> to put <code>p0</code> at zero, we are instead going to take the quaternion difference.</li>
<li>Once we have this quaterion difference, we are going to convert it into the scaled-angle-axis space so that it makes sense to mix it with angular velocities.</li>
<li>Once we have added everything together, we need to convert the result back to a quaternion. And instead of adding back the original value of <code>p0</code> we will use quaternion multiplication.</li>
</ol>

<p>In code it looks like this:</p>

<pre><code data-language="C">void quat_hermite(
    quat&amp; rot,
    vec3&amp; vel, 
    float x, 
    quat r0,
    quat r1, 
    vec3 v0,
    vec3 v1)
{
    float w1 = 3*x*x - 2*x*x*x;
    float w2 = x*x*x - 2*x*x + x;
    float w3 = x*x*x - x*x;
    
    float q1 = 6*x - 6*x*x;
    float q2 = 3*x*x - 4*x + 1;
    float q3 = 3*x*x - 2*x;
    
    vec3 r1_sub_r0 = quat_to_scaled_angle_axis(quat_abs(quat_mul_inv(r1, r0)));   
    
    rot = quat_mul(quat_from_scaled_angle_axis(w1*r1_sub_r0 + w2*v0 + w3*v1), r0);
    vel = q1*r1_sub_r0 + q2*v0 + q3*v1;
}
</code></pre>

<p>Next, we can tackle our Catmull-Rom Cubic Interpolation function. This time there are fewer adjustments. All we really need to do is convert our velocity computations via finite difference, into angular velocity computations via finite difference (as described in my <a href="https://theorangeduck.com/page/exponential-map-angle-axis-angular-velocity">previous article</a> on angular velocity)...</p>

<pre><code data-language="C">void quat_catmull_rom(
    quat&amp; rot,
    vec3&amp; vel,
    float x,
    quat r0,
    quat r1, 
    quat r2,
    quat r3)
{
    vec3 r1_sub_r0 = quat_to_scaled_angle_axis(quat_abs(quat_mul_inv(r1, r0)));
    vec3 r2_sub_r1 = quat_to_scaled_angle_axis(quat_abs(quat_mul_inv(r2, r1)));
    vec3 r3_sub_r2 = quat_to_scaled_angle_axis(quat_abs(quat_mul_inv(r3, r2)));
  
    vec3 v1 = (r1_sub_r0 + r2_sub_r1) / 2;
    vec3 v2 = (r2_sub_r1 + r3_sub_r2) / 2;
    return quat_hermite(rot, vel, x, r1, r2, v1, v2);
}
</code></pre>

<p>And that&#39;s it! While some of these steps might not be 100% obvious without thinking about it a little, as long as you understand the relationship between angular velocities and quaternions, I don&#39;t think there is anything unexpected going on.</p>

<p>Here is what it looks like in our little 3d environment:</p>



<hr/>

<h2>Raw Quaternion Cubic Interpolation</h2>

<p>If you are interpolating a series of quaternions which are sequentially pretty similar to each other, and have been &#34;<a href="https://theorangeduck.com/page/joint-limits#unrolling">unrolled</a>&#34; so that there are no sudden 
discontinuities there is an even easier way to do cubic interpolation of quaternions, which is to just do the interpolation directly in the 4d quaternion space, treating the quaternions as 4d vectors, and re-normalize the result.</p>

<p>This can be faster and will produce practically identical results when your quaternions are similar. I see this as like <a href="http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/">the difference between using slerp and nlerp</a> for linear interpolation.</p>

<hr/>

<h2>Conclusion</h2>

<p>When it comes to animation data, I think most people believe that doing cubic interpolation of rotations is a waste of CPU cycles. Yes - sampling four poses is more expensive than two and the mathematics involved are more expensive too - but cubic interpolation <em>really can</em> make a visual difference - in particular when playing animation in slow-motion.</p>

<p>In addition, compared to linear interpolation, cubic interpolation gives velocities that change smoothly in-between frames, which can prevent aliasing effects when further processing the data. For example, sampling velocities for a motion-matching database via linear interpolation at a rate higher than the original animation data will produce consecutive entries with the same velocities - which can look like a bug when it comes to inspect the data and can affect the result of downstream algorithms such as PCA.</p>



<p>Here is another concrete example: while FIFA 21 has undoubtedly some of the best, most sophisticated, and most realistic animation in the world of video games, the linear interpolation between frames, and the velocity discontinuity this introduces during slow-mo is something that cannot be un-seen.</p>

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uUiTt3yHoz8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

<p>Edit: FIFA 23 on the other hand does use a similar technique to the one described here. I think the results speak for themselves!</p>

<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LtN6G06k4dY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

<p>Either way, I hope this post has shed some light on cubic interpolation of quaternions. And as always, thanks for reading!</p>






					
				</div></div>
  </body>
</html>
