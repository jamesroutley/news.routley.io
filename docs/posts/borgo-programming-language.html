<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borgo-lang.github.io/">Original</a>
    <h1>Borgo Programming Language</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    <section id="content">
                  <article data-slug="intro">
            <h2>
              Intro            </h2>

            <div>
              <p><img src="https://raw.githubusercontent.com/borgo-lang/borgo-lang.github.io/main/borgo.jpg" alt="Borgo sits between Go and Rust"/></p>

<p>Borgo is a new programming language that compiles to Go.</p>

<p>For a high-level overview of the features and instructions on running the
compiler locally, check the
<a href="https://github.com/borgo-lang/borgo#readme">README</a>.</p>

<p>This playground runs the compiler as a wasm binary and then sends the transpiled
go output to the official Go playground for execution.</p>
            </div>

            <pre data-example="&#34;use fmt\n\nenum NetworkState&lt;T&gt; {\n    Loading,\n    Failed(int),\n    Success(T),\n}\n\nstruct Response {\n    title: string,\n    duration: int,\n}\n\nfn main() {\n    let res = Response {\n        title: \&#34;Hello world\&#34;,\n        duration: 0,\n    }\n\n    let state = NetworkState.Success(res)\n\n    let msg = match state {\n        NetworkState.Loading =&gt; \&#34;still loading\&#34;,\n        NetworkState.Failed(code) =&gt; fmt.Sprintf(\&#34;Got error code: %d\&#34;, code),\n        NetworkState.Success(res) =&gt; res.title,\n    }\n\n    fmt.Println(msg)\n}&#34;">use fmt

enum NetworkState&lt;T&gt; {
    Loading,
    Failed(int),
    Success(T),
}

struct Response {
    title: string,
    duration: int,
}

fn main() {
    let res = Response {
        title: &#34;Hello world&#34;,
        duration: 0,
    }

    let state = NetworkState.Success(res)

    let msg = match state {
        NetworkState.Loading =&gt; &#34;still loading&#34;,
        NetworkState.Failed(code) =&gt; fmt.Sprintf(&#34;Got error code: %d&#34;, code),
        NetworkState.Success(res) =&gt; res.title,
    }

    fmt.Println(msg)
}</pre>
          </article>
                  <article data-slug="primitive-types">
            <h2>
              Primitive Types            </h2>

            <div>
              <p>Primitive types are the same as in Go.</p>

<p>Collections like slices and maps can be used without specifying the type of the
values.</p>

<p>For example, a slice of int elements would be declared as <code>[]int{1,2,3}</code> in Go,
whereas Borgo relies on type inference to determine the type, so you can just
write <code>[1, 2, 3]</code>.</p>

<p>Functions like <code>append()</code> and <code>len()</code> are available as methods.</p>

<p>Maps are initialized with the <code>Map.new()</code> function, which under the hood
compiles to a <code>map[K]V{}</code> expression, with the <code>K</code> and <code>V</code> types helpfully
filled in for you.</p>

<p>Borgo also has tuples! They work exactly like in Rust.</p>

<p>Multiline strings are defined by prefixing each line with <code>\\</code> like in Zig. This
has the benefit that no character needs escaping and allows more control over
whitespace.</p>
            </div>

            <pre data-example="&#34;use fmt\n\nfn main() {\n    let n = 1\n    let s = \&#34;hello\&#34;\n    let b = false\n\n    fmt.Println(\&#34;primitives: \&#34;, n, s, b)\n\n    let mut xs = [1,2,3]\n    fmt.Println(\&#34;slice:\&#34;, xs)\n\n    xs = xs.Append(10)\n    fmt.Println(\&#34;len after append:\&#34;, xs.Len())\n\n    let mut m = Map.new()\n    m.Insert(1, \&#34;alice\&#34;)\n    m.Insert(2, \&#34;bob\&#34;)\n\n    fmt.Println(\&#34;map:\&#34;, m)\n\n    let pair = (\&#34;hey\&#34;, true)\n    fmt.Println(\&#34;second element in tuple:\&#34;, pair.1)\n\n    let multi = \\\\a multi line\n        \\\\  string with unescaped \&#34;quotes\&#34;\n        \\\\ that ends here\n\n    fmt.Println(\&#34;multiline string:\&#34;, multi)\n}&#34;">use fmt

fn main() {
    let n = 1
    let s = &#34;hello&#34;
    let b = false

    fmt.Println(&#34;primitives: &#34;, n, s, b)

    let mut xs = [1,2,3]
    fmt.Println(&#34;slice:&#34;, xs)

    xs = xs.Append(10)
    fmt.Println(&#34;len after append:&#34;, xs.Len())

    let mut m = Map.new()
    m.Insert(1, &#34;alice&#34;)
    m.Insert(2, &#34;bob&#34;)

    fmt.Println(&#34;map:&#34;, m)

    let pair = (&#34;hey&#34;, true)
    fmt.Println(&#34;second element in tuple:&#34;, pair.1)

    let multi = \\a multi line
        \\  string with unescaped &#34;quotes&#34;
        \\ that ends here

    fmt.Println(&#34;multiline string:&#34;, multi)
}</pre>
          </article>
                  <article data-slug="control-flow">
            <h2>
              Control flow            </h2>

            <div>
              <p>Like in Go, the only values that can be iterated over are slices, maps, channels
and strings.</p>

<p>However, loops always iterate over a single value, which is the element in the
slice (contrary to Go, where using a single iteration variable gives you the
index of the element).</p>

<p>To iterate over <code>(index, element)</code> pairs call the <code>.enumerate()</code> method on
slices. This has no runtime cost, it just aids the compiler in generating the
correct code.</p>

<p>When iterating over maps, you should always destructure values with
<code>(key, value)</code> pairs instead of a single value.</p>

<p>Like in Rust, infinite loops use the <code>loop {}</code> construct whereas loops with
conditions use <code>while {}</code>.</p>

<p>Expressions like <code>if</code>, <code>match</code> and blocks return a value, so you can assign
their result to a variable.</p>
            </div>

            <pre data-example="&#34;use fmt\nuse math.rand\n\nfn main() {\n    let xs = [\&#34;a\&#34;, \&#34;b\&#34;, \&#34;c\&#34;]\n\n    fmt.Println(\&#34;For loop over slices\&#34;)\n    for letter in xs {\n        fmt.Println(letter)\n    }\n\n    fmt.Println(\&#34;Indexed for loop\&#34;)\n    for (index, letter) in xs.Enumerate() {\n        fmt.Println(index, letter)\n    }\n\n    let m = Map.new()\n    m.Insert(1, \&#34;alice\&#34;)\n    m.Insert(2, \&#34;bob\&#34;)\n\n    fmt.Println(\&#34;For loop over maps\&#34;)\n    for (key, value) in m {\n        fmt.Println(key, value)\n    }\n\n    fmt.Println(\&#34;Loop with no condition\&#34;)\n    loop {\n        let n = rand.Float64()\n        fmt.Println(\&#34;looping...\&#34;, n)\n\n        if n &gt; 0.75 {\n            break\n        }\n    }\n\n    fmt.Println(\&#34;While loop\&#34;)\n\n    let mut count = 0\n    while (count &lt; 5) {\n        fmt.Println(count)\n        count = count + 1\n    }\n\n    fmt.Println(\&#34;using if statements as expressions\&#34;)\n    fmt.Println(if 5 &gt; 3 { \&#34;ok\&#34; } else { \&#34;nope\&#34; })\n\n    let block_result = {\n        let a = 1\n        let b = 2\n        a + b\n    }\n\n    fmt.Println(\&#34;block result:\&#34;, block_result)\n}&#34;">use fmt
use math.rand

fn main() {
    let xs = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]

    fmt.Println(&#34;For loop over slices&#34;)
    for letter in xs {
        fmt.Println(letter)
    }

    fmt.Println(&#34;Indexed for loop&#34;)
    for (index, letter) in xs.Enumerate() {
        fmt.Println(index, letter)
    }

    let m = Map.new()
    m.Insert(1, &#34;alice&#34;)
    m.Insert(2, &#34;bob&#34;)

    fmt.Println(&#34;For loop over maps&#34;)
    for (key, value) in m {
        fmt.Println(key, value)
    }

    fmt.Println(&#34;Loop with no condition&#34;)
    loop {
        let n = rand.Float64()
        fmt.Println(&#34;looping...&#34;, n)

        if n &gt; 0.75 {
            break
        }
    }

    fmt.Println(&#34;While loop&#34;)

    let mut count = 0
    while (count &lt; 5) {
        fmt.Println(count)
        count = count + 1
    }

    fmt.Println(&#34;using if statements as expressions&#34;)
    fmt.Println(if 5 &gt; 3 { &#34;ok&#34; } else { &#34;nope&#34; })

    let block_result = {
        let a = 1
        let b = 2
        a + b
    }

    fmt.Println(&#34;block result:&#34;, block_result)
}</pre>
          </article>
                  <article data-slug="algebraic-data-types-and-pattern-matching">
            <h2>
              Algebraic data types and pattern matching            </h2>

            <div>
              <p>You can define algebraic data types with the <code>enum</code> keyword (pretty much like
Rust).</p>

<p>Pattern matches must be exhaustive, meaning the compiler will return an error
when a case is missing (try removing any case statement from the example and see
what happens!).</p>

<blockquote><p>For now, variants can only be defined as tuples and not as structs.</p>
</blockquote>            </div>

            <pre data-example="&#34;use fmt\nuse strings\n\n\nenum IpAddr {\n    V4(uint8, uint8, uint8, uint8),\n    V6(string),\n}\n\nfn isPrivate(ip: IpAddr) -&gt; bool {\n  match ip {\n    IpAddr.V4(a, b, _, _) =&gt; {\n        if a == 10 {\n            return true\n        }\n\n        if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {\n            return true\n        }\n\n        if a == 192 &amp;&amp; b == 168 {\n            return true\n        }\n\n        false\n    }\n\n    IpAddr.V6(s) =&gt; strings.HasPrefix(s, \&#34;fc00::\&#34;)\n  }\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn valueInCents(coin: Coin) -&gt; int {\n    match coin {\n        Coin.Penny =&gt; 1,\n        Coin.Nickel =&gt; 5,\n        Coin.Dime =&gt; 10,\n        Coin.Quarter =&gt; 25,\n    }\n}\n\nfn main() {\n    let home = IpAddr.V4(127, 0, 0, 1)\n    let loopback = IpAddr.V6(\&#34;::1\&#34;)\n    fmt.Println(\&#34;home ip is private: \&#34;, home, isPrivate(home))\n    fmt.Println(\&#34;loopback: \&#34;, loopback)\n\n    let cents = valueInCents(Coin.Nickel)\n    fmt.Println(\&#34;cents:\&#34;, cents)\n\n}&#34;">use fmt
use strings


enum IpAddr {
    V4(uint8, uint8, uint8, uint8),
    V6(string),
}

fn isPrivate(ip: IpAddr) -&gt; bool {
  match ip {
    IpAddr.V4(a, b, _, _) =&gt; {
        if a == 10 {
            return true
        }

        if a == 172 &amp;&amp; b &gt;= 16 &amp;&amp; b &lt;= 31 {
            return true
        }

        if a == 192 &amp;&amp; b == 168 {
            return true
        }

        false
    }

    IpAddr.V6(s) =&gt; strings.HasPrefix(s, &#34;fc00::&#34;)
  }
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valueInCents(coin: Coin) -&gt; int {
    match coin {
        Coin.Penny =&gt; 1,
        Coin.Nickel =&gt; 5,
        Coin.Dime =&gt; 10,
        Coin.Quarter =&gt; 25,
    }
}

fn main() {
    let home = IpAddr.V4(127, 0, 0, 1)
    let loopback = IpAddr.V6(&#34;::1&#34;)
    fmt.Println(&#34;home ip is private: &#34;, home, isPrivate(home))
    fmt.Println(&#34;loopback: &#34;, loopback)

    let cents = valueInCents(Coin.Nickel)
    fmt.Println(&#34;cents:&#34;, cents)

}</pre>
          </article>
                  <article data-slug="structs">
            <h2>
              Structs            </h2>

            <div>
              <p>Defining and instantiating structs is similar to Rust.</p>

<p>Contrary to Go, all struct fields must be initialized. See the section on <code>nil</code>
and zero values for more information.</p>
            </div>

            <pre data-example="&#34;use fmt\n\nstruct Person {\n    name: string,\n    hobbies: [Hobby],\n}\n\nenum Hobby {\n    SkyDiving,\n    StaringAtWall,\n    Other(string),\n}\n\nfn main() {\n    let mut p = Person {\n        name: \&#34;bob\&#34;,\n        hobbies: [Hobby.StaringAtWall, Hobby.Other(\&#34;sleep\&#34;)],\n    }\n\n    fmt.Println(\&#34;person:\&#34;, p)\n\n    p.hobbies = p.hobbies.Append(Hobby.SkyDiving)\n    fmt.Println(\&#34;with more hobbies:\&#34;, p)\n}&#34;">use fmt

struct Person {
    name: string,
    hobbies: [Hobby],
}

enum Hobby {
    SkyDiving,
    StaringAtWall,
    Other(string),
}

fn main() {
    let mut p = Person {
        name: &#34;bob&#34;,
        hobbies: [Hobby.StaringAtWall, Hobby.Other(&#34;sleep&#34;)],
    }

    fmt.Println(&#34;person:&#34;, p)

    p.hobbies = p.hobbies.Append(Hobby.SkyDiving)
    fmt.Println(&#34;with more hobbies:&#34;, p)
}</pre>
          </article>
                  <article data-slug="result-and-option">
            <h2>
              Result and Option            </h2>

            <div>
              <p>Sometimes it&#39;s helpful to deal with values that may or may not be there. This is
the idea behind the <code>Option&lt;T&gt;</code> type.</p>

<p>For example, to get an element out of a slice or a map, you can use the
<code>.get(index)</code> method that will force you to handle the case where the element
isn&#39;t there.</p>

<p>Other times you may want to return a value <em>or</em> an error. In those cases use
<code>Result&lt;T, E&gt;</code> to let the caller know that a function may return an error.</p>

<p>When you&#39;re sure that a value is <em>definitely</em> there, you can call <code>.unwrap()</code>.
Like in Rust, this is an unsafe operation and will panic.</p>

<p>A lot of methods are missing from both <code>Result</code> and <code>Option</code>, contributions to
the stdlib are welcome!</p>
            </div>

            <pre data-example="&#34;use fmt\n\nstruct Person {\n    name: string,\n    age: int\n}\n\nfn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {\n    if (age &lt; 18) {\n        return Err(\&#34;too young\&#34;)\n    }\n\n    if (age &gt; 98) {\n        return Err(\&#34;too old\&#34;)\n    }\n\n    Ok(Person { name, age })\n}\n\nfn main() {\n    let xs = [\&#34;a\&#34;, \&#34;b\&#34;, \&#34;c\&#34;]\n    let element = xs.Get(2) // Option&lt;string&gt;\n\n    match element {\n        Some(s) =&gt; fmt.Println(\&#34;ok, the element was found:\&#34;, s),\n        None =&gt; fmt.Println(\&#34;element not found\&#34;),\n    }\n\n    let result = validate(\&#34;alice\&#34;, 33) // Result&lt;Person, string&gt;\n\n    match result {\n        Ok(p) =&gt; fmt.Println(\&#34;got a person:\&#34;, p),\n        Err(e) =&gt; fmt.Println(\&#34;couldn&#39;t validate:\&#34;, e),\n    }\n}&#34;">use fmt

struct Person {
    name: string,
    age: int
}

fn validate(name: string, age: int) -&gt; Result&lt;Person, string&gt; {
    if (age &lt; 18) {
        return Err(&#34;too young&#34;)
    }

    if (age &gt; 98) {
        return Err(&#34;too old&#34;)
    }

    Ok(Person { name, age })
}

fn main() {
    let xs = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]
    let element = xs.Get(2) // Option&lt;string&gt;

    match element {
        Some(s) =&gt; fmt.Println(&#34;ok, the element was found:&#34;, s),
        None =&gt; fmt.Println(&#34;element not found&#34;),
    }

    let result = validate(&#34;alice&#34;, 33) // Result&lt;Person, string&gt;

    match result {
        Ok(p) =&gt; fmt.Println(&#34;got a person:&#34;, p),
        Err(e) =&gt; fmt.Println(&#34;couldn&#39;t validate:&#34;, e),
    }
}</pre>
          </article>
                  <article data-slug="interoperability-with-go">
            <h2>
              Interoperability with Go            </h2>

            <div>
              <p>One ambitious goal of this project is to be fully compatible with the existing
Go ecosystem.</p>

<p>You&#39;ve already seen how the <code>fmt</code> package was used in previous examples, but how
do we deal with functions that return multiple values?</p>

<p>This is where our trusty <code>Option</code> and <code>Result</code> types come in! The compiler will
handle the conversion <em>automatically</em> for you :)</p>

<p>A good mental model is to think of return types in Go functions as:</p>

<pre><code>when return type is    (T, bool)
it becomes             Option&lt;T&gt;

when return type is    (T, error)
it becomes             Result&lt;T, E&gt;
</code></pre>

<p>Let&#39;s take the <a href="https://pkg.go.dev/os#LookupEnv">os.LookupEnv</a> function as an
example:</p>

<pre><code>Go definition:
  func LookupEnv(key string) (string, bool)

becomes:
  fn LookupEnv(key: string) -&gt; Option&lt;string&gt;
</code></pre>

<p>Or the <a href="https://pkg.go.dev/os#Stat">os.Stat</a> function from the same package:</p>

<pre><code>Go definition:
  func Stat(name string) (FileInfo, error)

becomes:
  fn Stat(name: string) -&gt; Result&lt;FileInfo&gt;
</code></pre>

<blockquote><p><code>Result&lt;T&gt;</code> is short-hand for <code>Result&lt;T, error&gt;</code> where <code>error</code> is the standard
Go interface.</p>
</blockquote>
<p>With this simple convention, pretty much any Go package can be used in Borgo
code! All is needed is a package declaration, which is discussed in the next
section.</p>
            </div>

            <pre data-example="&#34;use fmt\nuse os\n\nfn main() {\n    let key = os.LookupEnv(\&#34;HOME\&#34;)\n\n    match key {\n        // Option&lt;T&gt;\n        Some(s) =&gt; fmt.Println(\&#34;home dir:\&#34;, s),\n        None =&gt; fmt.Println(\&#34;Not found in env\&#34;),\n    }\n\n    let info = os.Stat(\&#34;file-does-not-exist\&#34;)\n\n    match info {\n        // Result&lt;T, E&gt;\n        Ok(_) =&gt; fmt.Println(\&#34;The file exists\&#34;),\n        Err(err) =&gt; fmt.Println(\&#34;Got error reading file\&#34;, err),\n    }\n}&#34;">use fmt
use os

fn main() {
    let key = os.LookupEnv(&#34;HOME&#34;)

    match key {
        // Option&lt;T&gt;
        Some(s) =&gt; fmt.Println(&#34;home dir:&#34;, s),
        None =&gt; fmt.Println(&#34;Not found in env&#34;),
    }

    let info = os.Stat(&#34;file-does-not-exist&#34;)

    match info {
        // Result&lt;T, E&gt;
        Ok(_) =&gt; fmt.Println(&#34;The file exists&#34;),
        Err(err) =&gt; fmt.Println(&#34;Got error reading file&#34;, err),
    }
}</pre>
          </article>
                  <article data-slug="package-definitions">
            <h2>
              Package definitions            </h2>

            <div>
              <p>In order to use existing Go packages, Borgo needs to know what types and
functions they contain. This is done in declaration files, which serve a similar
purpose to what you might see in Typescript with <code>d.ts</code> files.</p>

<p>Only a small part of the Go stdlib is currently available for use in Borgo --
check the <a href="https://github.com/borgo-lang/borgo/tree/main/std">std/</a> folder for
more information.</p>

<p>The example on the right uses the <code>regexp</code> package from the Go standard library.
The relevant bindings are defined in <code>std/regexp/regexp.brg</code> (here&#39;s a snippet):</p>

<pre><code>struct Regexp { }

fn Compile  (expr: string) -&gt; Result&lt;*Regexp&gt; { EXT }

fn CompilePOSIX  (expr: string) -&gt; Result&lt;*Regexp&gt; { EXT }

fn MustCompile  (str: string) -&gt; *Regexp { EXT }

fn MustCompilePOSIX  (str: string) -&gt; *Regexp { EXT }

fn Match  (pattern: string, b: [byte]) -&gt; Result&lt;bool&gt; { EXT }

// ... other stuff
</code></pre>

<p>Writing such declarations by hand is a pain! There&#39;s no reason why this process
couldn&#39;t be automated though. The compiler comes with an <code>importer</code> tool that
parses a Go package and generates corresponding bindings to be used in Borgo.</p>
            </div>

            <pre data-example="&#34;use fmt\nuse regexp\n\nfn main() {\n    let validID = regexp.MustCompile(\&#34;^[a-z]+[[0-9]+]$\&#34;)\n\n    fmt.Println(validID.MatchString(\&#34;adam[23]\&#34;))\n    fmt.Println(validID.MatchString(\&#34;eve[7]\&#34;))\n}&#34;">use fmt
use regexp

fn main() {
    let validID = regexp.MustCompile(&#34;^[a-z]+[[0-9]+]$&#34;)

    fmt.Println(validID.MatchString(&#34;adam[23]&#34;))
    fmt.Println(validID.MatchString(&#34;eve[7]&#34;))
}</pre>
          </article>
                  <article data-slug="pointers-and-references">
            <h2>
              Pointers and References            </h2>

            <div>
              <p>Pointers and References work the same as in Go.</p>

<p>To dereference a pointer, use <code>foo.*</code> instead of <code>*foo</code> (like in Zig).</p>
            </div>

            <pre data-example="&#34;use fmt\n\nstruct Foo {\n    bar: int\n}\n\nstruct Bar {\n    foo: *Foo\n}\n\nfn main() {\n    let mut f = Foo { bar: 0 }\n    let b = Bar { foo: &amp;f }\n\n    f.bar = 99\n\n    fmt.Println(b.foo)\n\n    // pointer dereference\n    // In Go, this would be:   *b.foo = ...\n    b.foo.* = Foo { bar: 23 }\n\n    fmt.Println(b.foo)\n}&#34;">use fmt

struct Foo {
    bar: int
}

struct Bar {
    foo: *Foo
}

fn main() {
    let mut f = Foo { bar: 0 }
    let b = Bar { foo: &amp;f }

    f.bar = 99

    fmt.Println(b.foo)

    // pointer dereference
    // In Go, this would be:   *b.foo = ...
    b.foo.* = Foo { bar: 23 }

    fmt.Println(b.foo)
}</pre>
          </article>
                  <article data-slug="methods">
            <h2>
              Methods            </h2>

            <div>
              <p>To define methods on types, you can use <code>impl {}</code> blocks.</p>

<p>In Go, the method receiver must be specified at each function declaration. In
Borgo, this is specified only once at the beginning of the <code>impl</code> block
(<code>p: *Person</code>). All functions within the block will have that receiver.</p>

<p>It&#39;s also possible to declare static methods: functions can be declared with
dots in their name, so you can define a <code>Person.new</code> function like in the
example.</p>
            </div>

            <pre data-example="&#34;use fmt\n\nstruct Person {\n    name: string,\n    hours_slept: int,\n}\n\nfn Person.new(name: string) -&gt; Person {\n    Person {\n        name,\n        hours_slept: 0,\n    }\n}\n\nimpl (p: *Person) {\n    fn sleep() {\n        p.hours_slept = p.hours_slept + 1 \n    }\n\n    fn ready_for_work() -&gt; bool {\n        p.hours_slept &gt; 5\n    }\n\n    fn ready_to_party() -&gt; bool {\n        p.hours_slept &gt; 10\n    }\n}\n\nfn main() {\n    let mut p = Person.new(\&#34;alice\&#34;)\n\n    p.sleep()\n    p.sleep()\n\n    fmt.Println(\&#34;is ready:\&#34;, p.ready_for_work())\n}&#34;">use fmt

struct Person {
    name: string,
    hours_slept: int,
}

fn Person.new(name: string) -&gt; Person {
    Person {
        name,
        hours_slept: 0,
    }
}

impl (p: *Person) {
    fn sleep() {
        p.hours_slept = p.hours_slept + 1 
    }

    fn ready_for_work() -&gt; bool {
        p.hours_slept &gt; 5
    }

    fn ready_to_party() -&gt; bool {
        p.hours_slept &gt; 10
    }
}

fn main() {
    let mut p = Person.new(&#34;alice&#34;)

    p.sleep()
    p.sleep()

    fmt.Println(&#34;is ready:&#34;, p.ready_for_work())
}</pre>
          </article>
                  <article data-slug="interfaces">
            <h2>
              Interfaces            </h2>

            <div>
              <p>Interfaces in Borgo work the same as in Go, it&#39;s all duck typing.</p>

<p>If a type implements the methods declared by the interface, then the type is an
instance of that interface.</p>

<p>Embedded interfaces are also supported, just list out the other interfaces
<em>implied</em> by the one being defined (prefixed by <code>impl</code>). For example, the
<code>ReadWriter</code> interface from the <code>io</code> package can be defined as:</p>

<pre><code>interface ReadWriter {
    impl Reader
    impl Writer
}
</code></pre>

<blockquote><p><a href="https://go.dev/ref/spec#General_interfaces">type sets</a> are not supported.</p>
</blockquote>            </div>

            <pre data-example="&#34;use fmt\nuse math\n\ninterface geometry {\n    fn area() -&gt; float64\n    fn perim() -&gt; float64\n}\n\nstruct rect {\n    width: float64,\n    height: float64,\n}\n\nimpl (r: rect) {\n    fn area() -&gt; float64 {\n        r.width * r.height\n    }\n\n    fn perim() -&gt; float64 {\n        2 * r.width + 2 * r.height\n    }\n}\n\nstruct circle {\n    radius: float64,\n}\n\nimpl (c: circle) {\n    fn area() -&gt; float64 {\n        math.Pi * c.radius * c.radius\n    }\n\n    fn perim() -&gt; float64 {\n        2 * math.Pi * c.radius\n    }\n}\n\nfn measure(g: geometry) {\n    fmt.Println(g)\n    fmt.Println(g.area())\n    fmt.Println(g.perim())\n}\n\nfn main() {\n    let r = rect {\n        width: 3,\n        height: 4,\n    }\n\n    let c = circle { radius: 5 }\n\n    measure(r)\n    measure(c)\n}&#34;">use fmt
use math

interface geometry {
    fn area() -&gt; float64
    fn perim() -&gt; float64
}

struct rect {
    width: float64,
    height: float64,
}

impl (r: rect) {
    fn area() -&gt; float64 {
        r.width * r.height
    }

    fn perim() -&gt; float64 {
        2 * r.width + 2 * r.height
    }
}

struct circle {
    radius: float64,
}

impl (c: circle) {
    fn area() -&gt; float64 {
        math.Pi * c.radius * c.radius
    }

    fn perim() -&gt; float64 {
        2 * math.Pi * c.radius
    }
}

fn measure(g: geometry) {
    fmt.Println(g)
    fmt.Println(g.area())
    fmt.Println(g.perim())
}

fn main() {
    let r = rect {
        width: 3,
        height: 4,
    }

    let c = circle { radius: 5 }

    measure(r)
    measure(c)
}</pre>
          </article>
                  <article data-slug="error-handling">
            <h2>
              Error handling            </h2>

            <div>
              <p>In functions that return a <code>Result</code>, it&#39;s possible to propagate errors with the
<code>?</code> operator.</p>

<p>This is similar to what happens in Rust, refer to the section on
<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors">Propagating errors</a>
in the Rust book .</p>

<p>Currently the <code>?</code> operator only works with <code>Result</code>, but it will be extended to
also work with <code>Option</code>.</p>
            </div>

            <pre data-example="&#34;use fmt\nuse io\nuse os\n\nfn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {\n    let stat = os.Stat(src)?\n\n    if !stat.Mode().IsRegular() {\n        return Err(fmt.Errorf(\&#34;%s is not a regular file\&#34;, src))\n    }\n\n    let source = os.Open(src)?\n    defer source.Close()\n\n    let destination = os.Create(dst)?\n    defer destination.Close()\n\n    // ignore number of bytes copied\n    let _ = io.Copy(destination, source)?\n\n    Ok(())\n}\n\nfn copy_all_files(folder: string) -&gt; Result&lt;int, error&gt; {\n    let mut n = 0\n\n    for f in os.ReadDir(folder)? {\n        if !f.IsDir() {\n            let original = f.Name()\n            let new_name = fmt.Sprintf(\&#34;%s-copy\&#34;, original)\n\n            fmt.Println(\&#34;copying\&#34;, original, \&#34;to\&#34;, new_name)\n\n            copy_file(original, new_name)?\n            n = n + 1\n        }\n    }\n\n    Ok(n)\n}\n\nfn main() {\n    match copy_all_files(\&#34;.\&#34;) {\n        Ok(n) =&gt; fmt.Println(n, \&#34;files copied\&#34;),\n        Err(err) =&gt; fmt.Println(\&#34;Got error:\&#34;, err),\n    }\n}&#34;">use fmt
use io
use os

fn copy_file(src: string, dst: string) -&gt; Result&lt;(), error&gt; {
    let stat = os.Stat(src)?

    if !stat.Mode().IsRegular() {
        return Err(fmt.Errorf(&#34;%s is not a regular file&#34;, src))
    }

    let source = os.Open(src)?
    defer source.Close()

    let destination = os.Create(dst)?
    defer destination.Close()

    // ignore number of bytes copied
    let _ = io.Copy(destination, source)?

    Ok(())
}

fn copy_all_files(folder: string) -&gt; Result&lt;int, error&gt; {
    let mut n = 0

    for f in os.ReadDir(folder)? {
        if !f.IsDir() {
            let original = f.Name()
            let new_name = fmt.Sprintf(&#34;%s-copy&#34;, original)

            fmt.Println(&#34;copying&#34;, original, &#34;to&#34;, new_name)

            copy_file(original, new_name)?
            n = n + 1
        }
    }

    Ok(n)
}

fn main() {
    match copy_all_files(&#34;.&#34;) {
        Ok(n) =&gt; fmt.Println(n, &#34;files copied&#34;),
        Err(err) =&gt; fmt.Println(&#34;Got error:&#34;, err),
    }
}</pre>
          </article>
                  <article data-slug="zero-values-and-nil">
            <h2>
              Zero values and nil            </h2>

            <div>
              <p>In Borgo, you can&#39;t create <code>nil</code> values.</p>

<p>The concept of <code>null</code> references (or <code>nil</code> in this case) is being referred to as
&#34;The billion dollar mistake&#34; and modern languages are moving away from it with
types like <code>Option&lt;T&gt;</code>. Borgo tries to do the same.</p>

<p>You can still end up with null pointers if you&#39;re calling into existing Go code,
which is unfortunate. That should be solvable by writing better bindings, so
that functions that could return a null pointer, will instead return an
<code>Option&lt;*T&gt;</code>, forcing you to handle all cases.</p>

<p>In Go, it&#39;s common to see types not needing to be initialized, as their <em>zero
value</em> is ready to be used (ie. <code>sync.Mutex</code> or <code>sync.WaitGroup</code>). Borgo goes in
the opposite direction, requiring that all values are explicitely initialized.</p>

<p>You can use the built-in function <code>zeroValue()</code> whenever you need the <em>zero
value</em> of a type. While you won&#39;t need to provide a type annotation in all cases
(as the type can be inferred), it&#39;s probably clearer to annotate variables that
are initialized with <code>zeroValue()</code>.</p>

<p>As mentioned in a previous section, this also applies to struct fields, which
always need to be initialized.</p>
            </div>

            <pre data-example="&#34;use sync\nuse bytes\nuse fmt\n\nfn main() {\n     // in Go:\n     // var wg sync.WaitGroup\n     let wg: sync.WaitGroup = zeroValue()\n\n     // in Go:\n     // var b bytes.Buffer\n     let b: bytes.Buffer = zeroValue()\n\n     fmt.Println(\&#34;variables are initialized:\&#34;, wg, b)\n}&#34;">use sync
use bytes
use fmt

fn main() {
     // in Go:
     // var wg sync.WaitGroup
     let wg: sync.WaitGroup = zeroValue()

     // in Go:
     // var b bytes.Buffer
     let b: bytes.Buffer = zeroValue()

     fmt.Println(&#34;variables are initialized:&#34;, wg, b)
}</pre>
          </article>
                  <article data-slug="concurrency-goroutines">
            <h2>
              Concurrency (goroutines)            </h2>

            <div>
              <p>Borgo aims to support all concurrency primitives available in Go.</p>

<p>Use the <code>spawn</code> keyword (instead of <code>go</code>) to start a goroutine. The parameter
needs to be a function call.</p>

<p>Channels and <code>select {}</code> statements are discussed next.</p>
            </div>

            <pre data-example="&#34;use sync\nuse fmt\n\nstruct Counter {\n    count: int,\n    mu: sync.Mutex,\n}\n\nfn Counter.new() -&gt; Counter {\n    Counter { count: 0, mu: zeroValue() }\n}\n\nimpl (c: *Counter) {\n    fn Inc() {\n       c.mu.Lock() \n       c.count = c.count + 1\n       c.mu.Unlock() \n    }\n}\n\nfn main() {\n    let desired = 1000\n    let counter = Counter.new()\n\n    let wg: sync.WaitGroup = zeroValue()\n    wg.Add(desired)\n\n    let mut i = 0\n\n    while (i &lt; desired) {\n\n        // equivalent to:   go func() { ... }()\n        spawn (|| {\n            counter.Inc()\n            wg.Done()\n        })()\n\n        i = i + 1\n    }\n\n    wg.Wait()\n\n    fmt.Println(\&#34;Counter value:\&#34;, counter.count)\n}&#34;">use sync
use fmt

struct Counter {
    count: int,
    mu: sync.Mutex,
}

fn Counter.new() -&gt; Counter {
    Counter { count: 0, mu: zeroValue() }
}

impl (c: *Counter) {
    fn Inc() {
       c.mu.Lock() 
       c.count = c.count + 1
       c.mu.Unlock() 
    }
}

fn main() {
    let desired = 1000
    let counter = Counter.new()

    let wg: sync.WaitGroup = zeroValue()
    wg.Add(desired)

    let mut i = 0

    while (i &lt; desired) {

        // equivalent to:   go func() { ... }()
        spawn (|| {
            counter.Inc()
            wg.Done()
        })()

        i = i + 1
    }

    wg.Wait()

    fmt.Println(&#34;Counter value:&#34;, counter.count)
}</pre>
          </article>
                  <article data-slug="channels">
            <h2>
              Channels            </h2>

            <div>
              <p>Borgo doesn&#39;t provide any extra syntax to send/receive from channels.</p>

<p>You use <code>Channel.new()</code> to create a <code>Sender&lt;T&gt;</code> and <code>Receiver&lt;T&gt;</code>.These are
roughly equivalent to send-only and receive-only channels in Go and will compile
to raw channels in the final Go output.</p>

<p>With a <code>Sender&lt;T&gt;</code> you can call <code>send(value: T)</code> to send a value. With a
<code>Receiver&lt;T&gt;</code> you can call <code>recv() -&gt; T</code> to receive a value.</p>

<p>This design is somewhat inspired by the <code>sync::mspc::channel</code> module in the Rust
standard library.</p>
            </div>

            <pre data-example="&#34;use fmt\n\nfn main() {\n    let (sender, receiver) = Channel.new()\n\n    spawn (|| {\n        sender.Send(1)\n    })()\n\n    spawn (|| {\n        sender.Send(2)\n    })()\n\n    let msg = receiver.Recv()\n    let msg2 = receiver.Recv()\n\n    fmt.Println(msg + msg2)\n}&#34;">use fmt

fn main() {
    let (sender, receiver) = Channel.new()

    spawn (|| {
        sender.Send(1)
    })()

    spawn (|| {
        sender.Send(2)
    })()

    let msg = receiver.Recv()
    let msg2 = receiver.Recv()

    fmt.Println(msg + msg2)
}</pre>
          </article>
                  <article data-slug="select-statements">
            <h2>
              Select statements            </h2>

            <div>
              <p><code>select {}</code> works like in Go, however the syntax is slightly different.</p>

<pre><code>Reading from a channel

Go:    case x := &lt;- ch
Borgo: let x = ch.Recv() 


Sending to a channel

Go:    case ch &lt;- x
Borgo: ch.Send(x) 

Default case

Go:    default
Borgo: _
</code></pre>
            </div>

            <pre data-example="&#34;use fmt\nuse time\n\nfn main() {\n    let (tx1, rx1) = Channel.new()\n    let (tx2, rx2) = Channel.new()\n\n    // dummy done channel\n    let (_, done) = Channel.new()\n\n    spawn (|| {\n        tx1.Send(\&#34;a\&#34;)\n    })()\n\n    spawn (|| {\n        loop {\n            select {\n                // in Go:\n                //   case tx2 &lt;- \&#34;b\&#34;:\n                tx2.Send(\&#34;b\&#34;) =&gt; {\n                    fmt.Println(\&#34;sending b\&#34;)\n                    time.Sleep(1 * time.Second)\n                }\n\n                let _ = done.Recv() =&gt; return\n            }\n        }\n    })()\n\n    select {\n        // in Go:\n        //   case a := &lt;- rx1:\n        let a = rx1.Recv() =&gt; {\n            fmt.Println(\&#34;got\&#34;, a)\n        },\n\n        let b = rx2.Recv() =&gt; {\n            fmt.Println(\&#34;got\&#34;, b)\n        },\n    }\n}&#34;">use fmt
use time

fn main() {
    let (tx1, rx1) = Channel.new()
    let (tx2, rx2) = Channel.new()

    // dummy done channel
    let (_, done) = Channel.new()

    spawn (|| {
        tx1.Send(&#34;a&#34;)
    })()

    spawn (|| {
        loop {
            select {
                // in Go:
                //   case tx2 &lt;- &#34;b&#34;:
                tx2.Send(&#34;b&#34;) =&gt; {
                    fmt.Println(&#34;sending b&#34;)
                    time.Sleep(1 * time.Second)
                }

                let _ = done.Recv() =&gt; return
            }
        }
    })()

    select {
        // in Go:
        //   case a := &lt;- rx1:
        let a = rx1.Recv() =&gt; {
            fmt.Println(&#34;got&#34;, a)
        },

        let b = rx2.Recv() =&gt; {
            fmt.Println(&#34;got&#34;, b)
        },
    }
}</pre>
          </article>
            </section>

    <section>
      

      <div id="editor">
        <p>
          Loading compiler &amp; stdlib...
        </p>

        </div>

      <pre id="output"></pre>

      <pre id="errors"></pre>
    </section>
  </div></div>
  </body>
</html>
