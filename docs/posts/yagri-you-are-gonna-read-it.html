<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scottantipa.com/yagri">Original</a>
    <h1>YAGRI: You are gonna read it</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        
        <p><b>April, 2025</b></p>

        <p>
            YAGNI, or, <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">You aren&#39;t gonna need it</a>,
            is a standard piece of advice that warns against over engineering
            and building too many features too early. I think its great and saves you from wasting time, which
            can kill a project.
        </p>

        <p>
            However, there&#39;s an exception that I call YAGRI, or, &#34;You are gonna read it&#34;. It means that you shouldn&#39;t just store
            the minimum
            data required to satisfy the current product spec. You should also store data that you&#39;ll highly likely use (read),
            such as timestamps and contextual metadata.
        </p>

        <p>
            This problem tends to happen when a UI design shows that you only need to display a few specific bits of data to the
            user,
            so you only store those exact fields in the database. You&#39;ve satisfied the design and ship it. Then later you realize
            you&#39;re missing valuable information to help debug an issue, do internal analytics, etc.
        </p>

        <p>
            As an example, this commonly occurs when implementing a feature to let users delete something. The easy way
            is to just
            delete the row from the database, and maybe that&#39;s all that the current UI design call for.
            In this situation, regardless of the requested feature set, as engineers we should maintain good data standards
            and store:
        </p>
        <ul>
            <li>who deleted it</li>
            <li>how they deleted it (with what permission)</li>
            <li>when</li>
            <li>why (surrounding context, if possible)</li>
        </ul>

        <p>
            In general, these are some useful fields to store on almost any table:
        </p>
        <ul>
            <li>created_at</li>
            <li>updated_at</li>
            <li>deleted_at (soft deletes)</li>
            <li>created_by etc</li>
            <li>permission used during CRUD</li>
        </ul>

        <p>
            This practice will pay off with just a single instance of your boss popping into a meeting and going &#34;wait
            do we know why that thing was deleted, the customer is worried...&#34;.
            
        </p>
        <p>
            However, not every one of these fields that you store will end up serving a purpose. But maybe just a single
            field on a single table will save you one day, and that makes up for the costs of implementing a dozen others.
            Most of the apps we build, at the end of the day, are about storing data to keep track of facts.            
            It&#39;s quite possibly your most important job as an engineer to steward and maintain this data.
        </p>

        <p>
            Of course you can go too far in the other direction. You shouldnt just log everything.
            But I&#39;ve never heard someone complain about a table having too many timestamps.
        </p>
        </div></div>
  </body>
</html>
