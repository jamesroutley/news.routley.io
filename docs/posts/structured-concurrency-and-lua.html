<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/belm0/4c6d11f47ccd31a231cde04616d6bb22">Original</a>
    <h1>Structured concurrency and Lua</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-article_sc_and_lua_1-md">
      
      <div id="file-article_sc_and_lua_1-md-readme">
    <article itemprop="text">
<p dir="auto"><i>John Belmonte, 2022-Sep</i></p>
<p dir="auto">I&#39;ve started writing a toy structured concurrency implementation for the Lua programming language.  Some motivations:</p>
<ul dir="auto">
<li>use it as a simple introduction to structured concurrency from the perspective of Lua (this article)</li>
<li>learn the fundamental properties of structured concurrency and how to implement them</li>
<li>share code that could become the starting point for a real Lua library and framework</li>
</ul>
<p dir="auto">So what is structured concurrency?  For now, I&#39;ll just say that it&#39;s a programming paradigm that makes managing concurrency (arguably the hardest problem of computer science) an order of magnitude easier in many contexts.  It achieves this in ways that seem subtle to us-- clearly so, since it wasn&#39;t really discovered and applied until the late 2010&#39;s (just as control structures like functions, <code>if</code>, and <code>while</code> weren&#39;t introduced to languages until long after the first computer program).  Rather than start with a long explanation, however, I&#39;ll jump into a very simple example of structured concurrency in Lua.  From there, we&#39;ll build up the rationale, examples, and implementation in stages-- hopefully as a series of articles.</p>
<h2 dir="auto"><a id="user-content-a-first-look" aria-hidden="true" href="#a-first-look"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>a first look</h2>
<div dir="auto"><pre>trio <span>=</span> <span>require</span>(<span><span>&#39;</span>trio<span>&#39;</span></span>)

<span>function</span> <span>async_main</span>()
    <span><span>--</span> two parallel tasks that sleep for 2 and 3 seconds, respectively</span>
    <span>do</span>
        <span>local</span> nursery <span>&lt;</span>close<span>&gt;</span> <span>=</span> trio.<span>open_nursery</span>()
        nursery.<span>start_soon</span>(<span>function</span>()
            <span>print</span>(<span><span>&#39;</span>child 1 start<span>&#39;</span></span>)
            trio.<span>async_sleep</span>(<span>2</span>)
            <span>print</span>(<span><span>&#39;</span>child 1 end<span>&#39;</span></span>)
        <span>end</span>)
        nursery.<span>start_soon</span>(<span>function</span>()
            <span>print</span>(<span><span>&#39;</span>child 2 start<span>&#39;</span></span>)
            trio.<span>async_sleep</span>(<span>3</span>)
            <span>print</span>(<span><span>&#39;</span>child 2 end<span>&#39;</span></span>)
        <span>end</span>)
        <span>print</span>(<span><span>&#39;</span>waiting for child tasks<span>&#39;</span></span>)
    <span>end</span>
    <span>print</span>(<span><span>&#39;</span>done<span>&#39;</span></span>)
<span>end</span>

trio.<span>run</span>(async_main)  <span><span>--</span> launch the async event loop</span></pre></div>
<p dir="auto">A &#34;task&#34; is an independent thread of execution, and this example runs three of them concurrently:  one main and two spawned tasks.  For Lua, tasks are implemented with cooperative multitasking via coroutines.  However, rather than use the coroutine API directly, we&#39;re using a higher level API that applies a hierarchy to the set of tasks.  The lifetime of any spawned task is constrained by the containing code block, called a <em>nursery</em>.  The concluding &#34;done&#34; won&#39;t be printed until the nursery block, and hence both of its child tasks, have completed successfully.  Here is the program output:</p>
<pre><code>$ time lua example_1.lua
waiting for child tasks
child 2 start
child 1 start
child 1 end
child 2 end
done

real    0m3.126s
user    0m0.043s
sys     0m0.079s
</code></pre>
<p dir="auto">Since the child tasks run in parallel, and we&#39;re waiting for the slowest one to complete, the expected wall time is about 3 seconds, as confirmed here.  &#34;User&#34; time is nearly zero, since the CPU doesn&#39;t do any actual work (sleep is implemented by the appropriate OS call rather than a busy-wait).  Also interesting is that the &#34;waiting for child tasks&#34; message is printed before the children  begin.  This reflects the semantics of the nursery&#39;s <code>start_soon()</code> method which, as its name suggests, does not immediately execute the given function.  Rather, the task is queued-- to be picked up once the parent task yields execution.</p>
<p dir="auto">It may appear, at first, that structured concurrency is merely <code>fork</code>/<code>join</code>, which has existed for a long time.  However, structured concurrency is ensuring that 1) all tasks have well-defined parents, siblings, and children, and 2) the task hierarchy mirrors the structure of the code.  This has profound implications for managing concurrency.  For example, when a task is cancelled or has an error, the hierarchy suggests a natural way to clean up (cancel all descendants).  Moreover, since the task and code structure mirror each other, the code that spawned a task will never be out of scope when the child exits.  Exceptions and return values can thus be propagated to the caller, lending to natural use of the host language&#39;s built-in control structures (especially exception handling).  In the future, we&#39;ll delve into these and more aspects of structured concurrency.</p>
<p dir="auto">At the end of the example code is an administrative detail:  the <code>run()</code> function, which is handed another function to execute as the root task.  This is the bridge into the structured concurrency world, launching an event loop.</p>
<p dir="auto">A last thing to mention for this example is the use of Lua&#39;s relatively new feature of &#34;to-be-closed&#34; variables.  They allow the scope of each nursery to be carefully delineated-- important since that, in turn, defines our task hierarchy.  Additionally, the structured concurrency implementation will rely on these timely finalizers to achieve expected behavior regarding exceptions, cancellations, etc.</p>
<p dir="auto">(Function naming conventions:  any function prefixed by <code>open_</code> prefix expects to be held in a <code>&lt;close&gt;</code> variable;  any function with <code>async_</code> is expected to eventually yield execution, at least once.)</p>
<h2 dir="auto"><a id="user-content-worry-free-encapsulation" aria-hidden="true" href="#worry-free-encapsulation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>worry-free encapsulation</h2>
<p dir="auto">In a real program, we wouldn&#39;t write so much boilerplate to create some background tasks.  There might be a utility like <code>wait_all()</code>, which is useful when you have a heterogeneous set of tasks to run, just for their side effects.  The implementation:</p>
<div dir="auto"><pre><span>function</span> <span>async_wait_all</span>(...)
    <span>local</span> nursery <span>&lt;</span>close<span>&gt;</span> <span>=</span> trio.<span>open_nursery</span>()
    <span>for</span> _, f <span>in</span> <span>ipairs</span>({<span>...</span>}) <span>do</span>
        nursery.<span>start_soon</span>(f)
    <span>end</span>
<span>end</span></pre></div>
<p dir="auto">Then the &#34;main&#34; of the original example reduces to:</p>
<div dir="auto"><pre><span>function</span> <span>async_main</span>()
    <span>async_wait_all</span>(
        <span>function</span>() trio.<span>async_sleep</span>(<span>2</span>) <span>end</span>,
        <span>function</span>() trio.<span>async_sleep</span>(<span>3</span>) <span>end</span>))
    <span>print</span>(<span><span>&#39;</span>done<span>&#39;</span></span>)
<span>end</span></pre></div>
<p dir="auto">Note that the caller of <code>wait_all()</code> does not need to deal with nurseries or to-be-closed variables.  Moreover, with structured concurrency, he can be confident that tasks (again, Lua coroutines) will never leak out of such a call.  The concurrency details are completely encapsulated by the function.</p>
<p dir="auto">In the future, we&#39;ll cover how timeouts and cancellation can easily be applied to such calls (or any block of async code), despite the encapsulation, and without ad-hoc function parameters or forethought from library authors.</p>
<h2 dir="auto"><a id="user-content-can-you-do-more-than-sleep" aria-hidden="true" href="#can-you-do-more-than-sleep"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>can you do more than sleep?</h2>
<p dir="auto">So far we&#39;ve seen one &#34;blocking&#34; API call, or explicit way for a task to yield execution: <code>sleep()</code>.  (Note that having a nursery go out of scope is an <em>implicit</em> yield of execution, assuming there are pending child tasks.)  While programs with concurrency often sleep, they also need to do other things asynchronously, such as file or network I/O, as well as calling into any API itself using file or network I/O.</p>
<p dir="auto">Typically, a structured concurrency library (or any library implementing an asynchronous event loop) will offer basic async file and network I/O that is compatible with the framework.  That is the easy part.  The daunting challenge becomes (re)implementing popular prototcols and client/server libraries on top of that API.</p>
<p dir="auto">While async I/O isn&#39;t implemented yet, another common <em>awaitable</em> is: events.  These are single-use signals with a synchronous &#34;set&#34; method.  It&#39;s the primary means of communicating between tasks, and a building bock for higher-level synchronization primitives.  For (a very contrived) example:</p>
<div dir="auto"><pre><span>function</span> <span>async_event_example</span>()
    <span>do</span>
        <span><span>--</span> two child tasks wait for an event</span>
        <span>local</span> nursery <span>&lt;</span>close<span>&gt;</span> <span>=</span> trio.<span>open_nursery</span>()
        <span>local</span> event <span>=</span> trio.<span>Event</span>()
        nursery.<span>start_soon</span>(<span>function</span>()
            <span>print</span>(<span><span>&#39;</span>child 1 waiting<span>&#39;</span></span>)
            event.<span>async_wait</span>()
            <span>print</span>(<span><span>&#39;</span>child 1 got event<span>&#39;</span></span>)
        <span>end</span>)
        nursery.<span>start_soon</span>(<span>function</span>()
          <span>print</span>(<span><span>&#39;</span>child 2 waiting<span>&#39;</span></span>)
          event.<span>async_wait</span>()
          <span>print</span>(<span><span>&#39;</span>child 2 got event<span>&#39;</span></span>)
        <span>end</span>)
        trio.<span>async_sleep</span>(<span>1</span>)
        event.<span>set</span>()
        trio.<span>async_sleep</span>(<span>1</span>)
    <span>end</span>
    <span>print</span>(<span><span>&#39;</span>done<span>&#39;</span></span>)
<span>end</span></pre></div>
<pre><code>$ time lua example_2.lua
child 2 waiting
child 1 waiting
child 1 got event
child 2 got event
done

real    0m2.118s
user    0m0.042s
sys     0m0.066s
</code></pre>
<h2 dir="auto"><a id="user-content-implementation" aria-hidden="true" href="#implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>implementation</h2>
<p dir="auto">Along with this article, I&#39;m sharing a toy implementation of structured concurrency on Lua that just barely implements the examples here.  Refer to the <a href="#file-trio-lua">source code</a> for the significant caveats (in the form of TODO&#39;s).</p>
<p dir="auto">The module name, API, and implementation are inspired by <a href="https://github.com/python-trio/trio">Python Trio</a>, one of the first structured concurrency libraries.</p>
<p dir="auto">The module requires Lua 5.4.3 or newer, and fractional <code>time()</code> and thread <code>sleep()</code> functions which are not in the standard Lua build.  See the source for placeholder Unix implementations using <code>popen()</code>, which may need to be revised for your OS.</p>
<p dir="auto">As already mentioned, tasks are implemented with Lua coroutines.  The event loop uses the return value of <code>coroutine.resume()</code> to control task scheduling.  For example, to implement <code>async_sleep()</code>, the task yields the desired duration.  To pause until manually rescheduled later (for example, within the implementation of <code>Event</code>), the task yields a sentinel value.  As the library is built up, this coroutine protocol will be expanded to support propagating exceptions, cancellation, blocking on I/O events, etc.</p>
<h2 dir="auto"><a id="user-content-next-up--exceptions" aria-hidden="true" href="#next-up--exceptions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>next up:  exceptions</h2>
<p dir="auto">To demonstrate a limitation of the current implementation, let&#39;s try raising an exception from a child task:</p>
<div dir="auto"><pre>trio <span>=</span> <span>require</span>(<span><span>&#39;</span>trio<span>&#39;</span></span>)

<span>function</span> <span>async_error_example</span>()
    <span><span>--</span> child task raises an error</span>
    <span>do</span>
        <span>local</span> nursery <span>&lt;</span>close<span>&gt;</span> <span>=</span> trio.<span>open_nursery</span>()
        nursery.<span>start_soon</span>(<span>function</span>()
            trio.<span>async_sleep</span>(<span>1</span>)
            <span>error</span>(<span><span>&#39;</span>oops<span>&#39;</span></span>)
        <span>end</span>)
    <span>end</span>
    <span>print</span>(<span><span>&#39;</span>done<span>&#39;</span></span>)
<span>end</span>

trio.<span>run</span>(async_error_example)</pre></div>
<pre><code>$ lua example_3.lua
lua: ./trio.lua:140: example_3.lua:9: oops
stack traceback:
	[C]: in function &#39;assert&#39;
	./trio.lua:140: in function &#39;trio.run&#39;
	example_3.lua:15: in main chunk
	[C]: in ?
</code></pre>
<p dir="auto">This is not yet meeting the potential of structured concurrency, as the exception does not propagate into <code>async_error_example()</code> (which spawned the error-raising task), and rather originates from the implementation&#39;s event loop.  We&#39;ll tackle this in the next article!</p>
<hr/>
<p dir="auto">continue reading:  <strong><a href="https://gist.github.com/belm0/abbe9acb832eafa10dcbfd2b26eb74fc#file-article_sc_and_lua_2-md">Structured concurrency and Lua (part 2)</a></strong></p>
<hr/>
<p dir="auto">article Â© 2022 John Belmonte, all rights reserved</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
