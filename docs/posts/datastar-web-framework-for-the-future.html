<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrismalek.me/posts/data-star-first-impressions/">Original</a>
    <h1>Datastar: Web Framework for the Future?</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="tldr"><p><a href="#tldr">#
</a>TLDR</p></h2><p><a href="https://data-star.dev" target="_blank" rel="noopener noreferrer">Datastar
</a>is a new <a href="https://hypermedia.systems" target="_blank" rel="noopener noreferrer">hypermedia
</a>framework that makes building real-time web applications simpler and more efficient. It prioritizes server-side logic, uses ‚Äúsignals‚Äù for automatic UI updates, and leverages Server-Sent Events for lightning-fast performance. If you‚Äôre looking for a streamlined alternative to traditional JavaScript frameworks or HTMX, <a href="https://data-star.dev" target="_blank" rel="noopener noreferrer">Datastar
</a>is worth exploring.</p><p>However, it requires that you approach web development with a fresh perspective, embracing server-driven architecture and reactive programming.</p><h2 id="introduction"><p><a href="#introduction">#
</a>Introduction</p></h2><p>I‚Äôve been diving into <a href="https://hypermedia.systems" target="_blank" rel="noopener noreferrer">hypermedia
</a>lately looking at frameworks and libraries to build a new product and to help quickly create proof of concepts and web tools for clients.</p><p>HTMX at the time of writing was getting basically all the attention in the Hypermedia world. It demos really well and the examples are great. However, this article is NOT about HTMX.</p><p>I believe hypermedia and HTMX offer a promising direction, but when I tried to develop a new product using HTMX, I felt stuck due to challenges in figuring out the project structure, the HTML structure combined with excessive HTMX tags and realizing HTMX cannot handle the front-end interactively for which you have to bring in something like AlpineJS. (Did I mention I hate javascript?). HTMX is cool but I think before you start a new project with it you might want to look at <a href="https://data-star.dev" target="_blank" rel="noopener noreferrer">Datastar
</a>as well.</p><p>I had looked at Datastar in the past while evaluating HTMX but I did not grasp its potential over HTMX until I took a second look at started to feel some HTMX pain. Your results may vary.</p><h3 id="my-background"><p><a href="#my-background">##
</a>My Background</p></h3><p>First let‚Äôs understand my biased perspective. Everyone‚Äôs background is different and I think it is important to understand where I am coming from.</p><ul><li>I am an expert in the PeopleSoft ERP platform creating ‚Äúenterprise‚Äù applications<ul><li>PeopleSoft is a large ERP system that is used by many large organizations. It is a very powerful but a bit dated. Since it is the hub of most corporate data it is not going away anytime soon but SAAS apps are slowly chipping away at it.</li><li>I spent most of my time creating business CRUD applications that are used by business users and students.</li><li>These are always ‚Äúconfig‚Äù driven because PeopleSoft makes it easy to create setup/config tables and GUIs to manage the data. Think of PeopleSoft has one big ball of ‚Äúfeature flags‚Äù in the form of setup tables.</li><li>PeopleSoft completely abstracts the front-end away. You never worry about the front-end. The back-end controls the front-end. PeopleSoft was built 30 years ago and it‚Äôs meta-data architecture allowed the porting from a client-server architecture to a web architecture. Developers can deploy applications and never worry about JavaScript or even HTML and CSS at all. This is amazing.<ul><li>This has kept me away from the front-end for most of my career. I have always been a back-end developer <strong>but with PeopleSoft a back-end developer can easily deploy front-end user-facing applications.</strong> So I am used to handling and delivering solutions to clients that are 100% server-side but also user facing. You don‚Äôt need a front-end developer to deploy a PeopleSoft application.</li></ul></li><li>These applications contain some of the most sensitive corporate data from payroll, biographic data, student data, financial data, etc. You cannot ‚Äúmove fast and break things‚Äù in these applications. You have to be very careful with the data and the business logic.</li><li>In these applications, you cannot trust code running in the browser and your backend code must protect access to the data.</li></ul></li><li>I use Go for most of my side projects. I like the simplicity, speed and type safety of Go.</li></ul><h2 id="what-am-i-looking-for"><p><a href="#what-am-i-looking-for">#
</a>What Am I looking for?</p></h2><p>I have been looking for a framework or a set of libraries to build a new product that is modern and efficient. I had been looking at Hypermedia to do this.</p><p>My rough requirements are:</p><ul><li>A modern web framework that is efficient and can handle real-time updates.</li><li>A framework that can handle the front-end and the back-end but rely 100% on the back-end where possible.</li><li>A framework that can handle the front-end state and interactions.</li><li>Simplicity, Simplicity, Simplicity</li><li>A framework where I can use Go on the back-end.</li><li>Rapid development and prototyping</li><li>Avoid Javascript and NPM as much as possible or totally from a development perspective.<ul><li>Javascript makes me queezy ü§¢ and every time I see NPM I get a headache üòµ‚Äçüí´ and my instincts tell me to run away. I am not a fan of the JavaScript ecosystem.</li></ul></li><li>A ‚Äústable‚Äù platform that I can deploy something and just have it work for years without me worrying about it.</li><li>Rapid deployment to the cloud like Fly.io.</li><li>Freedom to use any CSS framework I want because those seem to change with the wind.</li><li>Avoid the split-team, JSON API approach of modern web apps where frontend and backend are disjointed.</li></ul><p>Previously I was looking at <a href="https://www.phoenixframework.org" target="_blank" rel="noopener noreferrer">Phoenix
</a>but did not want to shift to another language. If you google ‚Äúhypermedia‚Äù you will see a lot of articles about HTMX and it seems GitHub is full of projects using it. I think it is the most popular hypermedia library at the moment. I had looked hard at the <a href="https://github.com/jfyne/live" target="_blank" rel="noopener noreferrer">Live Golang Library
</a>.</p><h3 id="my-first-impressions-of-htmx"><p><a href="#my-first-impressions-of-htmx">##
</a>My First Impressions of HTMX</p></h3><p>Of course, I looked at HTMX and started to get excited about its potential. So I started to develop a real application after deploying some fairly simple ‚Äúweb tools‚Äù that my clients use for some one-off tasks.</p><p>I created some <strong>simple</strong> tools for myself and clients. I did not need any front-end state or interactions. I was just updating the UI with new HTML fragments from the server mostly as a result of field change or clicks. <strong>In these simple cases, HTMX handles those well.</strong></p><p>In my HTMX prototyping of a <strong>more complex</strong> application, the HTML code became a mess with HTMX tags for some parts that were non-trivial. I found myself struggling to understand the project structure and myriad of HTMX tags and how to manage the front-end and the back-end. I also needed some front-end functionality and state and HTMX is NOT designed to handle that. With HTMX you have to import AlpineJS and I broke out in hives because I hate JavaScript üò¢.</p><p><strong>It was when I got to the more complex parts of the application that I felt HTMX was sort of getting in the way.</strong> I was starting to a get a huge lint ball building up. My intuition told me I was headed in the wrong direction. I hit the pause button and started to look for alternatives because I felt I was working too hard and the code was getting too complex.</p><h2 id="revisiting-datastar-and-a-turning-point"><p><a href="#revisiting-datastar-and-a-turning-point">#
</a>Revisiting Datastar and a Turning Point</p></h2><p>I was busy working at client sites and I had put a pause on my research for HTMX alterntives or some non-trival TODO application examples. Then on my YouTube feed one day, I saw an <a href="https://www.youtube.com/watch?v=HbTFlUqELVc" target="_blank" rel="noopener noreferrer">interview with creator of Datastar
</a>, and it had me look again. If I had not had some experience with HTMX I would not have ‚Äúbeen ready‚Äù for that interview and understood some of the points he was making.</p><p>Here are some AI Generated main points of the interview. The ones I put in bold are the ones that got me to look again at Datastar:</p><ol><li>Delaney explores hypermedia beyond HTMX, focusing on real-time applications.</li><li>HTMX is seen as solving 1999‚Äôs hypermedia issues, but not pushing current boundaries.</li><li>Server-sent events (SSE) offer efficient real-time updates, surpassing traditional AJAX.</li><li><strong>Datastar, a modular alternative to HTMX, aims to simplify code and enhance performance.</strong></li><li>Game development‚Äôs efficiency can inspire web development‚Äôs speed and capability.</li><li><strong>SSE enables microsecond updates, challenging the limitations of polling in HTMX.</strong></li><li>The event-driven architecture is vital for scalable, efficient, real-time applications.</li><li><strong>Datastar‚Äôs declarative approach reduces complexity compared to HTMX.</strong></li><li><strong>Emphasizing server control, SSE can optimize and simplify web interactions.</strong></li><li>Delaney argues for a paradigm shift towards smarter use of hypermedia technology.</li></ol><p>I had looked at the <a href="https://data-star.dev" target="_blank" rel="noopener noreferrer">Datastar
</a>documention previously when I was evaluating HTMX. I probably found it from some discussions on Reddit. However, I previously struggled to grasp its purpose and found its documentation confusing and dense. <strong>Honestly, I think it was just over my head when I first read the Datastar docs</strong>. I was not ready to understand it. It claims to be a better alternative to HTMX and AlpineJS. Another thing that turned me off was the project did not have a huge amount of contributors. <strong>However, after watching the interview from the Datastar author, I realized he might have some serious insights and I should give it another look. He is also a contributor to HTMX.</strong></p><p>The two things that I originally found confusing about Datastar were:</p><ul><li>Use of SSE (Server-Sent Events) for real-time updates.<ul><li>I had no experience with SSE and didn‚Äôt understand how it could be used in a real-time application. I had some vague memories from reading about how they did not scale or they suffered from issues with the connection being dropped. I had not looked at them in years. I have zero experience with them.</li></ul></li><li>The concept of ‚Äúsignals‚Äù for reactive programming.<ul><li>I did not realize how this can drastically simplify your code.</li><li>The term <code>signal</code> was confusing and I just did NOT get it on the first read. I had no experience with reactive programming. It turns out <code>signals</code> can help me avoid a lot of front-end code and state management but I did not realize that at first.</li></ul></li></ul><p>That interview had me look at the <a href="https://data-star.dev/guide/getting_started" target="_blank" rel="noopener noreferrer">documentation
</a><strong>again</strong> which had undergone some updates. After I spent some time reading and re-reading the documentation and looking at the <a href="https://data-star.dev/examples/click_to_edit" target="_blank" rel="noopener noreferrer">examples
</a>then trying some ‚Äúhello world‚Äù examples on my own then the light bulb went off.</p><p><strong>Datastar might be the library I had been looking for. It looked promising after I started to peel off some onion layers.</strong></p><h2 id="what-is-datastar"><p><a href="#what-is-datastar">#
</a>What is Datastar?</p></h2><p>It seems the author <a href="https://github.com/delaneyj" target="_blank" rel="noopener noreferrer">delaneyj
</a>is taking some base primitives of HTMX and Hypermedia and making it easier to use and Datastar is his answer. Those are the claims at least. At the time of writing, I am still creating my first application with it. I am not ready to give a full review. But I am excited about the potential.</p><p>It seems that the Author is also a big fan of Go which helps me because any examples and libraries will have Go examples.</p><p>First let me clarify. I am not an expert in Datastar. I am just starting to learn it. <strong>I am also <em>NOT</em> a contributor or author to Datastar in any way.</strong> I am NOT taking any credit. I just want to spread the word about it as I don‚Äôt think it is getting the attention it deserves.</p><p>From my current understanding of Datastar, there are some key concepts that form the foundation of Datastar:</p><ul><li><strong>Signals</strong>: Reactive programming primitives that automatically update the UI when data changes.<ul><li>We will explore what the heck these are shortly.</li><li>You as the developer will decide what signals you want and put some special tags on the HTML elements that will trigger the server to send back updates to the signals. This will be associated with some sort of server state.</li></ul></li><li><strong>Server-Sent Events (SSE)</strong>: Efficient data streaming for real-time updates and page changes.<ul><li>These are just the repsonses sent back from the server to the client. They are just text over HTTP and are generally HTML fragments that update the UI. You can do many other things but let‚Äôs not get ahead of ourselves.</li></ul></li><li><strong>Actions</strong>: HTTP verbs (GET, POST, PUT, DELETE) that trigger server-side logic and UI updates.<ul><li>These are the HTML tags that you put on HTML elements that trigger the server to send back updates to the signals or new HTML fragments that update the UI.</li></ul></li><li><strong>Fragments</strong>: HTML snippets that update the UI based on server-side logic and user interactions.<ul><li>Your server side has to be structured to send back these HTML fragments that will update the UI.</li></ul></li></ul><p>You include the Datastar JavaScript library in your HTML and then you can start to use these concepts to build your application. You will also need to structure your server to handle the SSE requests and the GET/POST/PUT/DELETE requests.</p><p>Your backend choice does not matter.</p><h3 id="comparing-to-htmx"><p><a href="#comparing-to-htmx">##
</a>Comparing to HTMX</p></h3><p>I will mostly compare it to HTMX because that is the current perspective I have and HTMX is getting a ton of ink and attention.</p><ul><li><p>With HTMX to build a real application you need:</p><ul><li>Front End<ul><li>HTML</li><li>HTMX JavaScript and Tags to handle the triggers to backend updates</li><li><strong>AlpineJS</strong> (or other JavaScript framework) to handle front end logic and interactions and state.</li></ul></li><li>Backend<ul><li>HTML fragments that are that is dependent on your UX</li><li>Routes and Code to handle the GET/POST/PUT/DELETE</li></ul></li></ul></li><li><p>With Datastar to build a real application you need:</p><ul><li>Front End<ul><li>HTML</li><li>Datastar JavaScript to handle the triggers to backend updates and all the UI state and interactions.</li></ul></li><li>Backend<ul><li>HTML fragments that are dependent on your UX</li><li>Routes and Code to handle the GET/POST/PUT/DELETE</li><li>SSE routes to handle the updates to the signals</li></ul></li></ul></li></ul><p>So just from looking at the dependencies, Datastar gives you a single JavaScript library that can handle state on the front-end (signals) and making HTML attributes perform actions (GET/POST/PUT/DELETE) and handle the updates from the server. The server is 100% responsible for generating the HTML fragments and the updates to the signals.</p><ul><li>Datastar provides the benefits of HTMX and AlpineJS under a single library. You get the best of both worlds.</li><li>You can ditch much of what a front-end framework like React or Vue.js would provide and use Datastar. (Bold claim)</li><li>Your server is 100% responsible for generating HTML snippets and templates very similar to what you would do with HTMX.</li><li>It is back-end agnostic and can be used with Go, Node.js, PHP, etc. I prefer Go but it does NOT matter.</li><li>It relies heavily on Server-Sent Events (SSE) for real-time updates but after you pull the cover off of SSE it is just text HTTP responses with a some different headers.</li></ul><h3 id="what-is-a-signal-and-what-is-reactive-programming"><p><a href="#what-is-a-signal-and-what-is-reactive-programming">##
</a>What is a ‚ÄúSignal‚Äù and what is ‚ÄúReactive Programming‚Äù?</p></h3><p>I think one of the biggest things that I missed in my initial read of the docs was the concept of a <code>signal</code>. This was not invented by Datastar and I believe is implemented in Datastar using a library from another developer.</p><p>I‚Äôm sure I‚Äôm just behind the curve and you may already know what a <code>signal</code>. I‚Äôm going to try to explain it. <strong>Getting an fundamental understanding of what a signal represents and can do for you is what give Datastar its power.</strong> It makes creating user interfaces much simpler and more maintainable.</p><p>Before we talk about signals, let‚Äôs talk about <code>reactive programming</code> because they are related. Reactive programming makes your application code automatically ‚Äúreact‚Äù to changes in data and propagate those changes automatically through the application. Instead of telling the computer how to do things step-by-step, you tell it what should happen when data changes and the computer figures out how to do it. It allows you to define a relationship between data sources and data consumers. When the data source changes, the data consumer is automatically updated. In a non-reactive system, you would have to manually update the data consumer when the data source changes. This is generally in the form of ‚Äúon-change‚Äù Javascript events and functions to bind all the data and UI together.</p><p><em>Ok, Ok that is still too much jargon!!!!</em></p><h3 id="understanding-reactive-programming-via-spreadsheets"><p><a href="#understanding-reactive-programming-via-spreadsheets">##
</a>Understanding Reactive Programming via Spreadsheets</p></h3><p>I think the best way to understand reactive programming is to think about a spreadsheet.</p><ul><li>A spreadsheet application like Microsoft Excel or Google Sheets is the best example here.<ul><li>If you have any experience working with a complex spreadsheet in the engineering or financial realms, you have already worked with reactive programming.</li><li>I am NOT talking about using excel as a CSV viewer.</li><li>I am talking about using it as a tool to do calculations, and you ‚Äúbuild up layers‚Äù of intermediate calculations to get to a final result.<ul><li>Very often you have intermediate calculations you need for other calculations or just doing checks for mistakes. This leads to a series of calculations that are dependent on each other. This is represented in formulas in spreadsheet cells that reference other cells. For complex calculations, you can have a ‚Äúpipeline‚Äù or spiderweb of calculations that are dependent on each other.</li><li>I have an engineering degree and worked for engineering firms while in college and after college, I have used Excel for some very complex calculations and engineering modeling for HVAC cooling and plumbing systems. Excel is an great tool for this.</li></ul></li></ul></li></ul><p><strong>The amazing thing about Spreadsheets is that it is reactive.</strong> When you change a value in a cell, all the dependent cells are automatically updated. This is the essence of reactive programming. In you define the relationships between the ‚Äúcells‚Äù or data elements and the underlying framework progates changes when data changes. This is very powerful and can simplify your code and make it more maintainable.</p><p>Here is a rough schematic of that where the arrows represent the dependencies between cells:</p><p><img alt="diagram" id="kroki-1" src="https://chrismalek.me/_4184341436229191900.svg"/></p><p><strong>Datastar gives you some of these some of these same capabilities in a web application via the concept of a <code>signal</code>.</strong></p><p>I conceptually think of a Datastar <code>signal</code> as a link between ‚Äúcell‚Äù or HTML elements. I did not make this connection at first.</p><ul><li>In Datastar, signals are used to update the UI when the data changes.</li><li>It can also trigger back end posts/gets/puts/deletes.</li></ul><p><code>Signals</code> are part of the glue of a Datastar application. You place <code>signals</code> on the page and the UI can be automatically updated. See the <a href="https://data-star.dev/examples/model_binding" target="_blank" rel="noopener noreferrer">Model Binding Example
</a>and the <a href="https://data-star.dev/examples/signals_changed" target="_blank" rel="noopener noreferrer">Signals change example</a></p><p>The server can send down updates to the ‚Äúsignals‚Äù (spreadsheet cells contents) or even send down a new HTML fragment that update the UI. In spreadsheet terms, this would be like adding new cells, charts, etc from the server.</p><p>There is more you can do with signals. If you read the docs and still don‚Äôt understand, I would re-read them. I had to read them a few times to get it.</p><h2 id="actions---getspostsputsdeletes"><p><a href="#actions---getspostsputsdeletes">#
</a>Actions - GETS/POSTS/PUTS/DELETES</p></h2><p>When/if you start looking at HTMX you see that you can trigger <a href="https://data-star.dev/reference/action_plugins" target="_blank" rel="noopener noreferrer">actions
</a>on the server with a GET/POST/PUT/DELETE. This is the same in Datastar. You can trigger these actions with a signal.</p><p>HTMX and Datastar both trigger this server request to the server to update or get updated UI elements. The difference is that Datastar uses SSE to get the updates back to the client. I was scratching my head on this until I started reading more about it and looking at the examples.</p><p>SSE is very simple. It is just text which I maybe had read before but since I had no real experience doing development work I did not understand. I work daily with HTTP web services and have a firm grasp on how HTTP works.</p><p>You can add some ‚Äútags‚Äù to the HTML elements (button on click, input on change, etc) and then when the user interacts with the page, the server can send down updates to the signals.</p><p>From the <a href="https://data-star.dev/examples/click_to_edit" target="_blank" rel="noopener noreferrer">Datastar examples
</a>:</p><div><pre tabindex="0"><code data-lang="html"><span><span>
</span></span><span><span><span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;contact_1&#34;</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>label</span><span>&gt;</span>First Name: John<span>&lt;/</span><span>label</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>label</span><span>&gt;</span>Last Name: Doe<span>&lt;/</span><span>label</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>label</span><span>&gt;</span>Email: joe@blow.com<span>&lt;/</span><span>label</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;</span><span>div</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>button</span> <span>data-on-click</span><span>=</span><span>&#34;@get(&#39;/examples/click_to_edit/contact/1/edit&#39;)&#34;</span><span>&gt;</span>
</span></span><span><span>      Edit
</span></span><span><span>    <span>&lt;/</span><span>button</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>button</span> <span>data-on-click</span><span>=</span><span>&#34;@get(&#39;/examples/click_to_edit/contact/1/reset&#39;)&#34;</span><span>&gt;</span>
</span></span><span><span>      Reset
</span></span><span><span>    <span>&lt;/</span><span>button</span><span>&gt;</span>
</span></span><span><span>  <span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span><span><span><span>&lt;/</span><span>div</span><span>&gt;</span>
</span></span></code></pre></div><p>The Datastar Javascript library running in the browser connects to the server with a connection that is kept open (until the server closes it). The server can send down updates to the signals. The server can also send down new HTML fragments that update the UI.</p><p>Datastar and HTMX have a similar concept but Datastar is built out of the box to handle updating <strong>any</strong> part of the page using the ‚ÄúID‚Äù of the element. This is possible in HTMX but requires some extra work/tags.</p><p><strong>Basically, the Datastar ‚Äúactions‚Äù can do anything that HTMX can do.</strong></p><h3 id="understanding-sse---it-is-just-text"><p><a href="#understanding-sse---it-is-just-text">##
</a>Understanding SSE - It is just text</p></h3><p>First let‚Äôs quickly understand SSE. At we will see SSE is just text. It is not some magical protocol. It is just text over HTTP with some special headers and browsers support it out of the box.</p><p>Datastar leverages SSE and the Javascript library expects and interprets the responses from the server in a certain way. The server can send down updates to the signals or new HTML fragments that will update the UI. The server can also close the connection when it is done.</p><p>For the authoritative source, refer to the <a href="https://data-star.dev/reference/sse_events" target="_blank" rel="noopener noreferrer">Datastar SEE Reference</a></p><p>In Datastar, you add some ‚Äútags‚Äù to the HTML elements (button ‚Äúon click‚Äù, input ‚Äúon change‚Äù, etc) which causes the browser to send a request to the server to open an SSE connection. That connection stays open until the server closes it. The server can send down updates to the signals or new HTML fragments that will update the UI.</p><p>For most CRUD applications you will be sending down HTML fragments that will update the UI. Then close the connection. If you were making some sort of real-time dashboard you would keep the connection open and send down updates to the UI as the server finds changes in the data. The server might be monitoring a database or some other data source and sending down updates to the UI as they change.</p><p>Let‚Äôs first look at the simplest case that is most like the HTMX examples which is more inline with CRUD applications.</p><p>You will have some attribute on an HTML element that will trigger an SSE call to the server. For simplicity, let‚Äôs say it is a button click.</p><div><pre tabindex="0"><code data-lang="html"><span><span><span>&lt;</span><span>button</span> <span>id</span><span>=</span><span>&#34;button1&#34;</span> <span>data-on-click</span><span>=</span><span>&#34;@get(&#39;/example/buttonpress&#39;)&#34;</span><span>&gt;</span>
</span></span><span><span>  Click Me
</span></span><span><span><span>&lt;/</span><span>button</span><span>&gt;</span>
</span></span></code></pre></div><p>That triggers an HTTP call by the browser with the SSE header of <code>Accept: text/event-stream</code> to the server.</p><div><pre tabindex="0"><code data-lang="http"><span><span><span>GET</span> <span>/example/buttonpress</span> <span>HTTP</span><span>/</span><span>1.1</span>
</span></span><span><span><span>Host</span><span>:</span> <span>example.com</span>
</span></span><span><span><span>Accept</span><span>:</span> <span>text/event-stream</span>
</span></span><span><span><span>Cache-Control</span><span>:</span> <span>no-cache</span>
</span></span></code></pre></div><p>There are options to send extra data and Datastar will automatically send along any local signals on the page. This automatic signal sending is a feature of Datastar that is not in HTMX and I did not realize how powerful it can be. In the HTTP example above I am NOT showing any signals because they are not needed for this simple example.</p><ul><li>Here the browser will keep the connection open and listen for updates from the server.</li><li>The server can send down updates to the <code>signals</code> or new HTML fragments that will update the UI.<ul><li>In this example, we will focus on HTML Fragments</li><li>The server sends back a response with the <code>event</code> of <code>Datastar-merge-fragments</code> and the <code>data</code> of the new HTML fragment that will update the UI.<ul><li>In this case, the server ‚Äúknows‚Äù that its only job is to send back some HTML when the button in pressed and close the connection.</li></ul></li><li>The HTTP response will look like this:</li></ul></li></ul><div><pre tabindex="0"><code data-lang="http"><span><span><span>HTTP</span><span>/</span><span>1.1</span> <span>200</span> <span>OK</span>
</span></span><span><span><span>Content-Type</span><span>:</span> <span>text/event-stream</span>
</span></span><span><span><span>Cache-Control</span><span>:</span> <span>no-cache</span>
</span></span><span><span><span>Connection</span><span>:</span> <span>close</span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>data: fragments &lt;div id=&#34;button1&#34;&gt;Button Pressed and removed.&lt;/div&gt;
</span></span></code></pre></div><p>In the example above, the server sends back a new HTML fragment that will replace the button that was clicked. The Datastar JavaScript running in the browser will match the <code>ID</code> of the element and replace it with the new HTML fragment.</p><p>The server could have sent several fragments to update any part of the page. HTMX can do this but I think Datastar is built out of the box to handle this.</p><ul><li>What is an example of a case where the SSE connection is kept open and the server sends down updates to the signals?<ul><li>Imagine a case, where you have a web page that is tracking the location of a food delivery vehicle.</li><li>The server is monitoring the GPS location of the vehicle and sending down updates to the signals to update the location of the truck on the map. The server can also send down new HTML fragments that update the UI.</li><li>The browser keeps an SSE connection open and the server can send down updates.</li><li>The HTTP response from the server will look like the following where there is some time elapsed between each of those <code>event</code> and <code>data</code> pairs.</li></ul></li></ul><div><pre tabindex="0"><code data-lang="http"><span><span><span>HTTP</span><span>/</span><span>1.1</span> <span>200</span> <span>OK</span>
</span></span><span><span><span>Content-Type</span><span>:</span> <span>text/event-stream</span>
</span></span><span><span><span>Cache-Control</span><span>:</span> <span>no-cache</span>
</span></span><span><span><span>Connection</span><span>:</span> <span>keep-alive</span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>data: fragments &lt;div id=&#34;truckstatus&#34;&gt;The Truck is under a bridge&lt;/div&gt;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>data: fragments &lt;div id=&#34;truckstatus&#34;&gt;The truck is at Jersey Mikes and the driver is enjoying a sandwich&lt;/div&gt;
</span></span></code></pre></div><p>In HTMX you would have to implement polling which works but is not as efficient as SSE.</p><p>If you look at the <a href="https://data-star.dev/examples/progress_bar" target="_blank" rel="noopener noreferrer">Progress Bar Example
</a>you can see that there is an SEE endpoint there like this:</p><div><pre tabindex="0"><code data-lang="http"><span><span><span>GET https://data-star.dev/examples/progress_bar/data
</span></span></span></code></pre></div><p>It sends back a stream of updates to both the title and <code>div</code> with <code>id=&#34;progress_bar&#34;</code>. As the browser receives the updates, it updates the UI in real-time. The browser keeps an SSE connection open and the server can send down updates to the signals. The server can also send down new HTML fragments that update the UI.</p><div><pre tabindex="0"><code data-lang="http"><span><span><span>HTTP</span><span>/</span><span>1.1</span> <span>200</span> <span>OK</span>
</span></span><span><span><span>cache-control</span><span>:</span> <span>no-cache</span>
</span></span><span><span><span>connection</span><span>:</span> <span>keep-alive</span>
</span></span><span><span><span>content-type</span><span>:</span> <span>text/event-stream</span>
</span></span><span><span><span>date</span><span>:</span> <span>Thu, 16 Jan 2025 05:36:26 GMT</span>
</span></span><span><span><span>fly-request-id</span><span>:</span> <span>01JHPSSQHJMTZ82JYZXE5T43BM-sjc</span>
</span></span><span><span><span>server</span><span>:</span> <span>Fly/3f202fc64 (2025-01-13)</span>
</span></span><span><span><span>transfer-encoding</span><span>:</span> <span>chunked</span>
</span></span><span><span><span>via</span><span>:</span> <span>1.1 fly.io</span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>retry: 1000
</span></span><span><span>data: fragments &lt;div id=&#34;progress_bar&#34;&gt;&lt;svg width=&#34;200&#34; height=&#34;200&#34; viewbox=&#34;-25 -25 250 250&#34; style=&#34;transform: rotate(-90deg)&#34;&gt;&lt;circle r=&#34;90&#34; cx=&#34;100&#34; cy=&#34;100&#34; fill=&#34;transparent&#34; stroke=&#34;#e0e0e0&#34; stroke-width=&#34;16px&#34; stroke-dasharray=&#34;565.48px&#34; stroke-dashoffset=&#34;565px&#34;&gt;&lt;/circle&gt; &lt;circle r=&#34;90&#34; cx=&#34;100&#34; cy=&#34;100&#34; fill=&#34;transparent&#34; stroke=&#34;#6bdba7&#34; stroke-width=&#34;16px&#34; stroke-linecap=&#34;round&#34; stroke-dashoffset=&#34;559px&#34; stroke-dasharray=&#34;565.48px&#34;&gt;&lt;/circle&gt; &lt;text x=&#34;44px&#34; y=&#34;115px&#34; fill=&#34;#6bdba7&#34; font-size=&#34;52px&#34; font-weight=&#34;bold&#34; style=&#34;transform:rotate(90deg) translate(0px, -196px)&#34;&gt;1%&lt;/text&gt;&lt;/svg&gt;&lt;/div&gt;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>retry: 1000
</span></span><span><span>data: selector title
</span></span><span><span>data: fragments &lt;title&gt;1%&lt;/title&gt;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>event: Datastar-merge-fragments
</span></span><span><span>retry: 1000
</span></span><span><span>data: fragments &lt;div id=&#34;progress_bar&#34;&gt;&lt;svg width=&#34;200&#34; height=&#34;200&#34; viewbox=&#34;-25 -25 250 250&#34; style=&#34;transform: rotate(-90deg)&#34;&gt;&lt;circle r=&#34;90&#34; cx=&#34;100&#34; cy=&#34;100&#34; fill=&#34;transparent&#34; stroke=&#34;#e0e0e0&#34; stroke-width=&#34;16px&#34; stroke-dasharray=&#34;565.48px&#34; stroke-dashoffset=&#34;565px&#34;&gt;&lt;/circle&gt; &lt;circle r=&#34;90&#34; cx=&#34;100&#34; cy=&#34;100&#34; fill=&#34;transparent&#34; stroke=&#34;#6bdba7&#34; stroke-width=&#34;16px&#34; stroke-linecap=&#34;round&#34; stroke-dashoffset=&#34;554px&#34; stroke-dasharray=&#34;565.48px&#34;&gt;&lt;/circle&gt; &lt;text x=&#34;44px&#34; y=&#34;115px&#34; fill=&#34;#6bdba7&#34; font-size=&#34;52px&#34; font-weight=&#34;bold&#34; style=&#34;transform:rotate(90deg) translate(0px, -196px)&#34;&gt;2%&lt;/text&gt;&lt;/svg&gt;&lt;/div&gt;
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>...
</span></span></code></pre></div><h3 id="example-of-a-datastar-application"><p><a href="#example-of-a-datastar-application">##
</a>Example of a Datastar Application</p></h3><p>Let‚Äôs take a look at a high level of how a Datastar application might be structured. This is a very high level and I am still learning Datastar so don‚Äôt nitpick me if there are mistakes here.</p><p>Let‚Äôs imagine you have a page that allows you to track your food delivery.</p><ul><li>The driver has some application in his phone that reports up to a central server where they are.</li><li>There is a web page I can go to that will allow me to track the driver up until the order goes into ‚Äúdelivered‚Äù status.</li><li>That Datastar application might look like this:<ul><li>The browser sends a GET request to the server to get the initial page at <code>https://feedme.now/delivery/driver/location</code></li><li>The server sends back the full page HTML template.<ul><li>This page has some specific HTML tags that presents a button that allows you to start the status updates of how far the driver is from their house. The page will automatically update as the driver gets closer.</li></ul></li><li>The user presses the ‚ÄúTrack Driver‚Äù button and the browser sends a GET request to the server to open an SSE connection to <code>https://feedme.now/delivery/driver/location/_monitor</code> (This can be any URL)<ul><li>The browser will keep this SSE connection open until the server closes it.</li><li>The Datastar library is listening to those SSE events sent by the server.<ul><li>They could come all at once or trickle in over a few minutes.</li><li>Since this is a delivery driver tracking it will probably take several minutes for the driver to get to the house.</li></ul></li><li>In the simplest case, the server sends back ‚Äúhtml fragments‚Äù in the SSE event and Datastar figures out how to update the DOM.<ul><li>There will be an event every few minutes to update the UI with:<ul><li>The driver is 3 miles away.</li><li>The driver is 2 miles away.</li><li>The driver is 1 mile away.</li><li>The driver has entered your driveway</li><li>The food was delivered. {Close connection}</li></ul></li></ul></li></ul></li></ul></li></ul><p>The sequence diagram version of this follows.</p><p><img alt="diagram" id="kroki-9" src="https://chrismalek.me/_15370342953620332082.svg"/></p><h2 id="rethinking-web-development"><p><a href="#rethinking-web-development">#
</a>Rethinking Web Development</p></h2><p>If you‚Äôve done any web development in the past decade, it‚Äôs worth reconsidering how you approach projects and develop proof-of-concept ideas. You might be surprised at how much simpler and more maintainable your code can become. While having everything on the server is advantageous, it requires a different approach to project structure.</p><p>With Datastar, a significant portion of your application logic and state management can reside on the server. This shift in perspective may require you to rethink traditional web development paradigms.</p><p>Additional Considerations:</p><ul><li><strong>Project Structure:</strong> Carefully plan how you‚Äôll organize your server-side code to handle SSE connections, manage signals, and generate HTML fragments efficiently.</li><li><strong>State Management:</strong> Leverage Datastar‚Äôs signals to manage your application state primarily on the server. This can simplify your client-side code and reduce the need for complex frontend frameworks.</li><li><strong>Templating:</strong> Choose a templating engine that allows you to easily create and send dynamic HTML fragments. Consider using a template language that promotes code reusability and maintainability.</li><li><strong>Real-time Updates:</strong> Explore the power of SSE for real-time updates in your application. Think about how you can use real-time data to enhance the user experience.</li><li><strong>Security:</strong> As with any web application, security should be a top priority. Ensure that your server-side code is secure and protects sensitive data.</li></ul><p>By rethinking your approach to web development and embracing the capabilities of Datastar, you can create highly efficient, maintainable, and real-time applications.</p><h2 id="server-requirements"><p><a href="#server-requirements">#
</a>Server Requirements</p></h2><p>Your server-side setup will involve a few key components:</p><ul><li>An HTML templating system that‚Äôs organized to send HTML fragments for UI updates. This likely means breaking down your HTML into smaller, manageable chunks that can be generated and sent to the client.</li><li>The concept of ‚Äúroutes‚Äù is central to all web frameworks. A route maps a URL to a function that handles requests and sends responses.</li><li>In Datastar, you‚Äôll often need a route to handle the initial HTML request and another to handle SSE requests. There are multiple ways to structure this on your backend.</li></ul><p>The server must also handle SSE requests, GET/POST/PUT/DELETE requests, and send back the HTML fragments that update the UI.</p><h3 id="additional-considerations"><p><a href="#additional-considerations">##
</a>Additional Considerations</p></h3><ul><li><strong>SSE Endpoint:</strong> Establish a dedicated endpoint for handling SSE connections. This endpoint will be responsible for managing the persistent connections and sending updates to the client.</li><li><strong>Data Handling:</strong> Implement server-side logic to process incoming data, update signals, and generate the appropriate HTML fragments to send back to the client.</li><li><strong>Error Handling:</strong> Incorporate robust error handling to manage unexpected situations and ensure the stability of your application.</li><li><strong>Scalability:</strong> If you anticipate high traffic or require your application to scale, consider using a backend technology that can handle a large number of concurrent SSE connections efficiently.</li><li><strong>Deployment:</strong> Choose a deployment platform that supports SSE and can accommodate the requirements of your Datastar application.</li></ul><p>By carefully considering these server requirements, you can build a solid foundation for your Datastar application and ensure its performance, stability, and scalability.</p><h2 id="conclusion"><p><a href="#conclusion">#
</a>Conclusion</p></h2><p>Datastar offers a fresh approach to web development, streamlining real-time applications and minimizing front-end dependencies. While it demands a shift in perspective, its potential for simplicity, efficiency, and maintainability makes it worth exploring for modern developers. With its unified architecture and focus on server-driven logic, Datastar stands out as a promising alternative to traditional frameworks.</p><h2 id="further-reading"><p><a href="#further-reading">#
</a>Further Reading</p></h2><ul><li><a href="https://hypermedia.systems/book/contents/" target="_blank" rel="noopener noreferrer">Hypermedia Systems Books</a></li><li>Datastar <a href="https://data-star.dev/guide/getting_started" target="_blank" rel="noopener noreferrer">Getting Started
</a>and <a href="https://data-star.dev/reference/" target="_blank" rel="noopener noreferrer">Reference
</a>and <a href="https://data-star.dev/examples/" target="_blank" rel="noopener noreferrer">Examples</a></li></ul></div></div>
  </body>
</html>
