<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/formally-modeling-dreidel-the-sequel/">Original</a>
    <h1>Formally Modeling Dreidel, the Sequel</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <date>
                        
                            December 18, 2024
                        </date>
                
                
                
                    <h2>
                        2 model 2 dreidel
                    </h2>
                

                

                
                    
                        <p>Channukah&#39;s next week and that means my favorite pastime, complaining about how <a href="https://en.wikipedia.org/wiki/Dreidel#" target="_blank">Dreidel</a> is a bad game. Last year I formally modeled it in <a href="https://www.prismmodelchecker.org/" target="_blank">PRISM</a> to prove the game&#39;s not fun. But because I limited the model to only a small case, I couldn&#39;t prove the game was <em>truly</em> bad. </p>
<p>It&#39;s time to finish the job.</p>
<p><img alt="A flaming dreidel, from https://pixelsmerch.com/featured/flaming-dreidel-ilan-rosen.html" src="https://assets.buttondown.email/images/61233445-69a7-4fd4-a024-ee0dca0281c1.jpg?w=960&amp;fit=max"/></p>
<h2>The Story so far</h2>
<p>You can read the last year&#39;s newsletter <a href="https://buttondown.com/hillelwayne/archive/i-formally-modeled-dreidel-for-no-good-reason/" target="_blank">here</a> but here are the high-level notes.</p>
<h3>The Game of Dreidel</h3>
<ol>
<li>Every player starts with N pieces (usually chocolate coins). This is usually 10-15 pieces per player.</li>
<li>At the beginning of the game, and whenever the pot is empty, every play antes one coin into the pot.</li>
<li>
<p>Turns consist of spinning the dreidel. Outcomes are:</p>
<ul>
<li>נ (Nun): nothing happens.</li>
<li>ה (He): player takes half the pot, rounded up.</li>
<li>ג (Gimmel): player takes the whole pot, everybody antes.</li>
<li>ש (Shin): player adds one of their coins to the pot.</li>
</ul>
</li>
<li>
<p>If a player ever has zero coins, they are eliminated. Play continues until only one player remains.</p>
</li>
</ol>
<p>If you don&#39;t have a dreidel, you can instead use a four-sided die, but for the authentic experience you should wait eight seconds before looking at your roll.</p>
<h3>PRISM</h3>
<p><a href="https://www.prismmodelchecker.org/" target="_blank">PRISM</a> is a probabilistic modeling language, meaning you can encode a system with random chances of doing things and it can answer questions like &#34;on average, how many spins does it take before one player loses&#34; (64, for 4 players/10 coins) and &#34;what&#39;s the more likely to knock the first player out, shin or ante&#34; (ante is 2.4x more likely).  You can see last year&#39;s model <a href="https://gist.github.com/hwayne/f8724f0c83393c576b1e20ee4b76966d#file-01-dreidel-prism" target="_blank">here</a>.</p>
<p>The problem with PRISM is that it is absurdly inexpressive: it&#39;s a thin abstraction for writing giant <a href="https://en.wikipedia.org/wiki/Stochastic_matrix" target="_blank">stochastic matrices</a> and lacks basic affordances like lists or functions. I had to hardcode every possible roll for every player. This meant last year&#39;s model had two limits. First, it only handles four players, and I would have to write a new model for three or five players. Second, I made the game end as soon as one player <em>lost</em>:</p>
<div><pre><span></span><code>formula done = (p1=0) | (p2=0) | (p3=0) | (p4=0);
</code></pre></div>
<p>To fix both of these things, I thought I&#39;d have to treat PRISM as a compilation target, writing a program that took a player count and output the corresponding model. But then December got super busy and I ran out of time to write a program. Instead, I stuck with four hardcoded players and extended the old model to run until victory.</p>
<h2>The new model</h2>
<p>These are all changes to <a href="https://gist.github.com/hwayne/f8724f0c83393c576b1e20ee4b76966d#file-01-dreidel-prism" target="_blank">last year&#39;s model</a>.</p>
<p>First, instead of running until one player is out of money, we run until three players are out of money.</p>
<div><pre><span></span><code><span>- formula done = (p1=0) | (p2=0) | (p3=0) | (p4=0);</span>
<span>+ formula done = </span>
<span>+  ((p1=0) &amp; (p2=0) &amp; (p3=0)) |</span>
<span>+  ((p1=0) &amp; (p2=0) &amp; (p4=0)) |</span>
<span>+  ((p1=0) &amp; (p3=0) &amp; (p4=0)) |</span>
<span>+  ((p2=0) &amp; (p3=0) &amp; (p4=0));</span>
</code></pre></div>
<p>Next, we change the ante formula. Instead of adding four coins to the pot and subtracting a coin from each player, we add one coin for each player left. <code>min(p1, 1)</code> is 1 if player 1 is still in the game, and 0 otherwise. </p>
<div><pre><span></span><code><span>+ formula ante_left = min(p1, 1) + min(p2, 1) + min(p3, 1) + min(p4, 1);</span>
</code></pre></div>
<p>We also have to make sure anteing doesn&#39;t end a player with negative money. </p>
<div><pre><span></span><code><span>- [ante] (pot = 0) &amp; !done -&gt; (pot&#39;=pot+4) &amp; (p1&#39; = p1-1) &amp; (p2&#39; = p2-1) &amp; (p3&#39; = p3-1) &amp; (p4&#39; = p4-1);</span>
<span>+ [ante] (pot = 0) &amp; !done -&gt; (pot&#39;=pot+ante_left) &amp; (p1&#39; = max(p1-1, 0)) &amp; (p2&#39; = max(p2-1, 0)) &amp; (p3&#39; = max(p3-1, 0)) &amp; (p4&#39; = max(p4-1, 0));</span>
</code></pre></div>
<p>Finally, we have to add logic for a player being &#34;out&#34;. Instead of moving to the next player after each turn, we move to the next player still in the game. Also, if someone starts their turn without any coins (f.ex if they just anted their last coin), we just skip their turn. </p>
<div><pre><span></span><code><span>+ formula p1n = (p2 &gt; 0 ? 2 : p3 &gt; 0 ? 3 : 4);</span>

<span>+ [lost] ((pot != 0) &amp; !done &amp; (turn = 1) &amp; (p1 = 0)) -&gt; (turn&#39; = p1n);</span>
<span>- [spin] ((pot != 0) &amp; !done &amp; (turn = 1)) -&gt;</span>
<span>+ [spin] ((pot != 0) &amp; !done &amp; (turn = 1) &amp; (p1 != 0)) -&gt;</span>
<span> </span>   0.25: (p1&#39; = p1-1) 
<span> </span>          &amp; (pot&#39; = min(pot+1, maxval)) 
<span>-          &amp; (turn&#39; = 2) //shin</span>
<span>+          &amp; (turn&#39; = p1n) //shin</span>
</code></pre></div>
<p>We make similar changes for all of the other players. You can see the final model <a href="https://gist.github.com/hwayne/f8724f0c83393c576b1e20ee4b76966d#file-02-dreidel-prism" target="_blank">here</a>.</p>
<h3>Querying the model</h3>

<p>So now we have a full game of Dreidel that runs until the player ends. And now, <em>finally</em>, we can see the average number of spins a 4 player game will last.</p>
<div><pre><span></span><code>./prism<span> </span>dreidel.prism<span> </span>-const<span> </span><span>M</span><span>=</span><span>10</span><span> </span>-pf<span> </span><span>&#39;R=? [F done]&#39;</span><span> </span>
</code></pre></div>
<p>In English: each player starts with ten coins. <code>R=?</code> means &#34;expected value of the &#39;reward&#39;&#34;, where &#39;reward&#39; in this case means number of spins. <code>[F done]</code> weights the reward over all behaviors that reach (&#34;<strong>F</strong>inally&#34;) the <code>done</code> state.</p>
<div><pre><span></span><code>Result: 760.5607582661091
Time for model checking: 384.17 seconds.
</code></pre></div>
<p>So there&#39;s the number: 760 spins.<sup id="fnref:ben"><a href="#fn:ben">1</a></sup> At 8 seconds a spin, that&#39;s almost two hours for <em>one</em> game.</p>
<p>…Jesus, look at that runtime. Six minutes to test one query.</p>
<p>PRISM has over a hundred settings that affect model checking, with descriptions like &#34;Pareto curve threshold&#34; and &#34;Use Backwards Pseudo SOR&#34;. After looking through them all, I found this perfect combination of configurations that gets the runtime to a more manageable level: </p>
<div><pre><span></span><code>./prism dreidel.prism 
<span> </span>   -const M=10 
<span> </span>   -pf &#39;R=? [F done]&#39; 
<span>+   -heuristic speed</span>

Result: 760.816255997373
Time for model checking: 13.44 seconds.
</code></pre></div>
<p>Yes, that&#39;s a literal &#34;make it faster&#34; flag.</p>
<p>Anyway, that&#39;s only the &#34;average&#34; number of spins, weighted across all games. Dreidel has a very long tail. To find that out, we&#39;ll use a variation on our query:</p>
<div><pre><span></span><code>const C0; P=? [F &lt;=C0 done]
</code></pre></div>
<p><code>P=?</code> is the <strong>P</strong>robability something happens. <code>F &lt;=C0 done</code> means we <strong>F</strong>inally reach state <code>done</code> in at most <code>C0</code> steps. By passing in different values of <code>C0</code> we can get a sense of how long a game takes. Since &#34;steps&#34; includes passes and antes, this will overestimate the length of the game. But antes take time too and it should only &#34;pass&#34; on a player once per player, so this should still be a good metric for game length.</p>
<div><pre><span></span><code>./prism dreidel.prism 
    -const M=10 
    -const C0=1000:1000:5000
    -pf &#39;const C0; P=? [F &lt;=C0 done]&#39; 
    -heuristic speed

C0      Result
1000    0.6259953274918795
2000    0.9098575028069353
3000    0.9783122218576754
4000    0.994782069562932
5000    0.9987446018004976
</code></pre></div>
<p>A full 10% of games don&#39;t finish in 2000 steps, and 2% pass the 3000 step barrier. At 8 seconds a roll/ante, 3000 steps is over <strong>six hours</strong>.</p>
<p>Dreidel is a bad game.</p>
<h3>More fun properties</h3>
<p>As a sanity check, let&#39;s confirm last year&#39;s result, that it takes an average of 64ish spins before one player is out. In that model, we just needed to get the total reward. Now we instead want to get the reward until the first state where any of the players have zero coins. <sup id="fnref:co-safe"><a href="#fn:co-safe">2</a></sup></p>
<div><pre><span></span><code>./prism dreidel.prism 
    -const M=10 
    -pf &#39;R=? [F (p1=0 | p2=0 | p3=0 | p4=0)]&#39; 
    -heuristic speed

Result: 63.71310116083396
Time for model checking: 2.017 seconds.
</code></pre></div>
<p>Yep, looks good. With our new model we can also get the average point where two players are out and two players are left. PRISM&#39;s lack of abstraction makes expressing the condition directly a little painful, but we can cheat and look for the first state where <code>ante_left &lt;= 2</code>.<sup id="fnref:ante_left"><a href="#fn:ante_left">3</a></sup></p>
<div><pre><span></span><code>./prism dreidel.prism 
    -const M=10 
    -pf &#39;R=? [F (ante_left &lt;= 2)]&#39; 
    -heuristic speed

Result: 181.92839196680023
</code></pre></div>
<p>It takes twice as long to eliminate the second player as it takes to eliminate the first, and the remaining two players have to go for another 600 spins.</p>
<p>Dreidel is a bad game.</p>
<h2>The future</h2>
<p>There&#39;s two things I want to do next with this model. The first is script up something that can generate the PRISM model for me, so I can easily adjust the number of players to 3 or 5. The second is that PRISM has a <a href="https://www.prismmodelchecker.org/manual/PropertySpecification/Filters" target="_blank">filter-query</a> feature I don&#39;t understand but I <em>think</em> it could be used for things like &#34;if a player gets 75% of the pot, what&#39;s the probability they lose anyway&#34;. Otherwise you have to write wonky queries like <code>(P =? [F p1 = 30 &amp; (F p1 = 0)]) / (P =? [F p1 = 0])</code>.<sup id="fnref:lose"><a href="#fn:lose">4</a></sup> But I&#39;m out of time again, so this saga will have to conclude next year.</p>
<p>I&#39;m also faced with the terrible revelation that I might be the biggest non-academic user of PRISM.</p>
<hr/>
<h4><em>Logic for Programmers</em> Khanukah Sale</h4>
<p>Still going on! You can get <em>LFP</em> for <a href="https://leanpub.com/logic/c/hannukah-presents" target="_blank">40% off here</a> from now until the end of Xannukkah (Jan 2).<sup id="fnref:joke"><a href="#fn:joke">5</a></sup></p>
<h4>I&#39;m in the Raku Advent Calendar!</h4>
<p>My piece is called <a href="https://raku-advent.blog/2024/12/11/day-11-counting-up-concurrency/" target="_blank">counting up concurrencies</a>. It&#39;s about using Raku to do some combinatorics! Read the rest of the blog too, it&#39;s great</p>

                    
                

                
                    
                        <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
                    
                

            </div></div>
  </body>
</html>
