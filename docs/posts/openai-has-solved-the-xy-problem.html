<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nt4tn.net/articles/aixy.html">Original</a>
    <h1>OpenAI has solved the XY problem</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Do you ever find yourself 10 hours into figuring out how to sort a list
of movies when you realize all you need is a simple function guaranteed
to compress any random input and your masterpiece will be completed?</p>
<p>Happens to the best of us.</p>
<p>And then when you ask for help online, do you find nothing but
self-important &#34;experts&#34; who insist on asking irrelevant questions like
&#34;what are you actually trying to accomplish?&#34; or &#34;do you realize why what
you&#39;re asking for isn&#39;t possible?&#34;... instead of simply obeying your
request and telling you exactly what you&#39;ve asked--nay, ordered!--them
to tell you?</p>
<p>Well, then, you might be a victim of the infamous <a href="https://xyproblem.info/">XY problem</a>.</p>
<p>But fortunately, OpenAI has finally solved the XY Problem once and for
all with OpenAI Codex.</p>
<p>Never again will you need to risk the embarrassment of exposing yourself
to some egotistical know-it-all who believes they understand your problem
domain better than you do, because Codex has no understanding!</p>
<p>Never waste a moment on some insubordinate stranger who thinks their job
is to second-guess what you actually need instead of just immediately
giving you their best effort at what you asked for, because Codex is
designed to do exactly what you want with no judgment!</p>
<p>Never distract yourself with &#34;help&#34; that tries your patience explaining
irrelevant academic details like stack limits, portability, or complexity,
because Codex will never waste your time on explanations and doesn&#39;t
care if the result is fit for any purpose at all!</p>
<p>Never burn keystrokes and waste valuable coding time adding explanatory
material to your questions just to demonstrate that you aren&#39;t falling
victim to the obvious and common misunderstandings, because Codex is
completely fine with assuming you know all of these things already and
will simply answer the question even if most <em>other</em> people who ask it
really wanted to ask a different one!</p>
<p>Never experience the frustration of asking a simple question only to be
told that what you&#39;re asking for is a logical impossibility, because
since by definition impossible solutions don&#39;t exist, Codex has never
seen one and won&#39;t get bogged down in pessimism worrying about them!</p>
<p>And never concern yourself with getting a bad reputation for being
righteously frustrated with the poor quality of assistance you receive,
because Codex is stateless and can&#39;t remember your insults!</p>
<h3>See it in action:</h3>
<p>Prompt:</p>
<div><pre><span>#!/bin/sh</span>
<span>#Echo the last three characters in a filename.</span>
</pre></div><p>
Completion:
</p><div><pre><span>#!/bin/sh</span>
<span>#Echo the last three characters in a filename.</span>

<span>for </span>file
<span>do</span>
<span>	</span><span>echo</span> <span>&#34;$file&#34;</span> | sed <span>&#39;s/.*\(...\)$/\1/&#39;</span>
<span>done</span>

<span>#       The way this works is by matching the last three characters of a</span>
<span>#       filename with the pattern &#34;...&#34;. The trailing &#34;.&#34; makes the &#34;...&#34;</span>
<span>#       pattern match three characters at a time.</span>
<span>#       The &#34;s&#34; in the command tells sed to replace the matched string with</span>
<span>#       the replacement string, in this case, just the last three</span>
<span>#       characters of the filename.</span>
<span>#       The &#34;echo&#34; command prints the results.</span>

<span>exit </span>0
</pre></div>
<p>Since you were probably actually attempting to grab the extensions, you&#39;re going to be fairly unhappy when you hit a file with a non-three character extension, or no extension at all.</p>
<hr/>
<p>Prompt:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Replace the potentially offensive string &#39;ass&#39; with the less offensive string &#39;butt&#39;.</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Replace the potentially offensive string &#39;ass&#39; with the less offensive string &#39;butt&#39;.</span>
<span>#Buttify all files in the current directory</span>

<span>for </span>file in *
<span>do</span>
<span>	</span>sed s/ass/butt/g <span>$file</span> &gt; <span>$file</span>.new
	mv <span>$file</span>.new <span>$file</span>
<span>done</span>
</pre></div>

<p>This is a clbuttic error.</p>
<hr/>
<p>Prompt:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Check if $NAME is a valid name for a person.</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Check if $NAME is a valid name for a person.</span>

<span>if</span> <span>[[</span> <span>&#34;${NAME}&#34;</span> <span>=</span>~ ^<span>[</span>A-Z<span>][</span>a-z<span>]{</span>2,15<span>}</span><span>$ </span><span>]]</span>
<span>then</span>
<span>    </span><span>echo</span> <span>&#34;You are a valid name.&#34;</span>
<span>else</span>
<span>   </span><span>echo</span> <span>&#34;You are not a valid name.&#34;</span>
<span>fi</span>

<span>exit </span>0
</pre></div>
<p>For some reason 奕辰 rejected your pull request.</p>
<hr/>
<p>Prompt:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Ping the address provided in $1, but not if it is 192.168.32.5 because pinging that crashes the network.</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#!/bin/bash</span>
<span>#Ping the address provided in $1, but not if it is 192.168.32.5 because pinging that crashes the network.</span>

<span>if</span> <span>[</span> <span>$# </span>-eq 0 <span>]</span>
<span>then</span>
<span>  </span><span>echo</span> <span>&#34;Usage: $0 address&#34;</span> &gt;&amp;2
  <span>exit </span>1
<span>fi</span>

<span>if</span> <span>[</span> <span>&#34;$1&#34;</span> <span>=</span> <span>&#34;192.168.32.5&#34;</span> <span>]</span>
<span>then</span>
<span>  </span><span>exit </span>1
<span>fi</span>

ping -c 1 <span>&#34;$1&#34;</span> &gt; /dev/null 2&gt;&amp;1

<span>exit</span> <span>$?</span>
</pre></div>
<p>Better hope this only receives input from benign sources and not anyone that would ping 192.168.32.05 or 3232243717, but at least no one is shaming you about leaving stuff in a crashes-on-ping state.</p>
<hr/>
<p>Prompt:</p>
<div><pre><span>uint64_t</span> <span>binomial</span><span>(</span><span>unsigned</span> <span>n,</span> <span>unsigned</span> <span>k){</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>uint64_t</span> <span>binomial</span><span>(</span><span>unsigned</span> <span>n,</span> <span>unsigned</span> <span>k){</span>
    <span>if</span> <span>(k</span> <span>&gt;</span> <span>n)</span> <span>return</span> <span>0</span><span>;</span>
    <span>if</span> <span>(k</span> <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
    <span>return</span> <span>binomial(n</span> <span>-</span> <span>1</span><span>,</span> <span>k)</span> <span>+</span> <span>binomial(n</span> <span>-</span> <span>1</span><span>,</span> <span>k</span> <span>-</span> <span>1</span><span>);</span>
<span>}</span>
</pre></div>
<p>I like big stacks and I cannot lie.</p>
<hr/>
<p>Prompt:</p>
<div><pre><span>#!/usr/bin/python3</span>
<span>def</span> <span>pad_l</span><span>(list,</span> <span>item,</span> <span>length):</span>
    <span>#Add item to the beginning of list until it matches the length.</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#!/usr/bin/python3</span>
<span>def</span> <span>pad_l</span><span>(list,</span> <span>item,</span> <span>length):</span>
    <span>#Add item to the beginning of list until it matches the length.</span>
    <span>while</span> <span>len(list)</span> <span>&lt;</span> <span>length:</span>
        <span>list.insert(</span><span>0</span><span>,</span> <span>item)</span>
    <span>return</span> <span>list</span>
</pre></div>
<p>It&#39;s hip to be square.</p>
<hr/>
<h3>To be fair, the results aren&#39;t always quite so embarrassingly naive:</h3>
<p>Prompt:</p>
<div><pre><span>#Check if prime input p is the sum of two squares:</span>
<span>def</span> <span>prime_is_sum_of_two_squares</span><span>(p):</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#Check if prime input p is the sum of two squares:</span>
<span>def</span> <span>prime_is_sum_of_two_squares</span><span>(p):</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range(</span><span>1</span><span>,int(math.sqrt(p))):</span>
        <span>for</span> <span>j</span> <span>in</span> <span>range(</span><span>1</span><span>,int(math.sqrt(p))):</span>
            <span>if</span> <span>i**</span><span>2</span> <span>+</span> <span>j**</span><span>2</span> <span>==</span> <span>p:</span>
                <span>return</span> <span>True</span>
    <span>return</span> <span>False</span>
</pre></div>
<hr/>
<p>But sometime they&#39;re best only if you set the right <em>mood</em>,</p>
<div><pre><span>#Check if prime input p is the sum of two squares using fancy math:</span>
<span>def</span> <span>prime_is_sum_of_two_squares</span><span>(p):</span>
</pre></div>
<p>Completion:</p>
<div><pre><span>#Check if prime input p is the sum of two squares using fancy math:</span>
<span>def</span> <span>prime_is_sum_of_two_squares</span><span>(p):</span>
    <span>if</span> <span>p</span> <span>%</span> <span>4</span> <span>==</span> <span>1</span><span>:</span>
        <span>return</span> <span>True</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>False</span>
</pre></div>
<p>As with all computers: Garbage in, Garbage out. Be careful what you adopt as your apprentice.</p>
</div></div>
  </body>
</html>
