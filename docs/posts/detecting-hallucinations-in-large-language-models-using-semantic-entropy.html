<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nature.com/articles/s41586-024-07421-0">Original</a>
    <h1>Detecting hallucinations in large language models using semantic entropy</h1>
    
    <div id="readability-page-1" class="page"><div id="Sec5-content"><p>Semantic entropy as a strategy for overcoming confabulation builds on probabilistic tools for uncertainty estimation. It can be applied directly to any LLM or similar foundation model without requiring any modifications to the architecture. Our ‘discrete’ variant of semantic uncertainty can be applied even when the predicted probabilities for the generations are not available, for example, because access to the internals of the model is limited.</p><p>In this section we introduce background on probabilistic methods and uncertainty in machine learning, discuss how it applies to language models and then discuss our contribution, semantic entropy, in detail.</p><h3 id="Sec6">Background</h3><h4 id="Sec7">Uncertainty and machine learning</h4><p>We aim to detect confabulations in LLMs, using the principle that the model will be uncertain about generations for which its output is going to be arbitrary.</p><p>One measure of uncertainty is the predictive entropy of the output distribution, which measures the information one has about the output given the input<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 25" title="Lindley, D. V. On a measure of the information provided by an experiment. Ann. Math. Stat. 27, 986–1005 (1956)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR25" id="ref-link-section-d268476881e1145">25</a></sup>. The predictive entropy (PE) for an input sentence <b>x</b> is the conditional entropy (<i>H</i>) of the output random variable <i>Y</i> with realization <i>y</i> given <b>x</b>,</p><div id="Equ1"><p><span>$${\rm{PE}}({\bf{x}})=H(Y| {\bf{x}})=-\sum _{y}P(\,y| {\bf{x}})\mathrm{ln}P(\,y| {\bf{x}}).$$</span></p><p>
                    (1)
                </p></div><p>A low predictive entropy indicates an output distribution which is heavily concentrated whereas a high predictive entropy indicates that many possible outputs are similarly likely.</p><h4 id="Sec8">Aleatoric and epistemic uncertainty</h4><p>We do not distinguish between aleatoric and epistemic uncertainty in our analysis. Researchers sometimes separate aleatoric uncertainty (uncertainty in the underlying data distribution) from epistemic uncertainty (caused by having only limited information)<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 46" title="Der Kiureghian, A. &amp; Ditlevsen, O. Aleatory or epistemic? Does it matter? Struct. Saf. 31, 105–112 (2009)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR46" id="ref-link-section-d268476881e1295">46</a></sup>. Further advances in uncertainty estimation which separate these kinds of uncertainty would enhance the potential for our semantic uncertainty approach by allowing extensions beyond entropy.</p><h4 id="Sec9">Joint probabilities of sequences of tokens</h4><p>Generative LLMs produce strings of text by selecting tokens in sequence. Each token is a wordpiece that often represents three or four characters (though especially common sequences and important words such as numbers typically get their own token). To compute entropies, we need access to the probabilities the LLM assigns to the generated sequence of tokens. The probability of the entire sequence, <b>s</b>, conditioned on the context, <b>x</b>, is the product of the conditional probabilities of new tokens given past tokens, whose resulting log-probability is <span>\(\log P({\bf{s}}| {\boldsymbol{x}})={\sum }_{i}\log P({s}_{i}| {{\bf{s}}}_{ &lt; i},{\boldsymbol{x}})\)</span>, where <i>s</i><sub><i>i</i></sub> is the <i>i</i>th output token and <b>s</b><sub>&lt;<i>i</i></sub> denotes the set of previous tokens.</p><h4 id="Sec10">Length normalization</h4><p>When comparing the log-probabilities of generated sequences, we use ‘length normalization’, that is, we use an arithmetic mean log-probability, <span>\(\frac{1}{N}{\sum }_{i}^{N}\log P({s}_{i}| {{\bf{s}}}_{ &lt; i},{\boldsymbol{x}})\)</span>, instead of the sum. In expectation, longer sequences have lower joint likelihoods because of the conditional independence of the token probabilities<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 47" title="Malinin, A. &amp; Gales, M. Uncertainty estimation in autoregressive structured prediction. In Proceedings of the International Conference on Learning Representations 
                  https://openreview.net/forum?id=jN5y-zb5Q7m
                  
                 (2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR47" id="ref-link-section-d268476881e1544">47</a></sup>. The joint likelihood of a sequence of length <i>N</i> shrinks exponentially in <i>N</i>. Its negative log-probability therefore grows linearly in <i>N</i>, so longer sentences tend to contribute more to entropy. We therefore interpret length-normalizing the log-probabilities when estimating the entropy as asserting that the expected uncertainty of generations is independent of sentence length. Length normalization has some empirical success<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 48" title="Murray, K. &amp; Chiang, D. Correcting length bias in neural machine translation. In Proc. Third Conference on Machine Translation (eds Bojar, O. et al.) 212–223 (Assoc. Comp. Linguistics, 2018)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR48" id="ref-link-section-d268476881e1558">48</a></sup>, including in our own preliminary experiments, but little theoretical justification in the literature.</p><h3 id="Sec11">Principles of semantic uncertainty</h3><p>If we naively calculate the predictive entropy directly from the probabilities of the generated sequence of tokens, we conflate the uncertainty of the model over the meaning of its answer with the uncertainty over the exact tokens used to express that meaning. For example, even if the model is confident in the meaning of a generation, there are still usually many different ways for phrasing that generation without changing its meaning. For the purposes of detecting confabulations, the uncertainty of the LLM over meanings is more important than the uncertainty over the exact tokens used to express those meanings.</p><p>Our semantic uncertainty method therefore seeks to estimate only the uncertainty the LLM has over the meaning of its generation, not the choice of words. To do this, we introduce an algorithm that clusters model generations by meaning and subsequently calculates semantic uncertainty. At a high level this involves three steps:</p><ol>
                  <li>
                    <span>1.</span>
                    
                      <p>Generation: sample output sequences of tokens from the predictive distribution of a LLM given a context <b>x</b>.</p>
                    
                  </li>
                  <li>
                    <span>2.</span>
                    
                      <p>Clustering: cluster sequences by their meaning using our clustering algorithm based on bidirectional entailment.</p>
                    
                  </li>
                  <li>
                    <span>3.</span>
                    
                      <p>Entropy estimation: estimate semantic entropy by summing probabilities of sequences that share a meaning following equation (<a data-track="click" data-track-label="link" data-track-action="equation anchor" href="https://olu.online/articles/s41586-024-07421-0#Equ2">2</a>) and compute their entropy.</p>
                    
                  </li>
                </ol><h4 id="Sec12">Generating a set of answers from the model</h4><p>Given some context <b>x</b> as input to the LLM, we sample <i>M</i> sequences, {<b>s</b><sup>(1)</sup>, …, <b>s</b><sup>(<i>M</i>)</sup>} and record their token probabilities, {<i>P</i>(<b>s</b><sup>(1)</sup><span>∣</span><b>x</b>), …, <i>P</i>(<b>s</b><sup>(<i>M</i>)</sup><span>∣</span><b>x</b>)}. We sample all our generations from a single model, varying only the random seed used for sampling from the token probabilities. We do not observe the method to be particularly sensitive to details of the sampling scheme. In our implementation, we sample at temperature 1 using nucleus sampling (<i>P</i> = 0.9) (ref. <sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 49" title="Holtzman, A., Buys, J., Du, L., Forbes, M. &amp; Choi, Y. The curious case of neural text degeneration. In Proceedings of the International Conference on Learning Representations 
                  https://openreview.net/forum?id=rygGQyrFvH
                  
                 (2020)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR49" id="ref-link-section-d268476881e1669">49</a></sup>) and top-<i>K</i> sampling (<i>K</i> = 50) (ref. <sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 50" title="Fan, A., Lewis, M. &amp; Dauphin, Y. Hierarchical neural story generation. In Proc. 56th Annual Meeting of the Association for Computational Linguistics (eds Gurevych, I. &amp; Miyao, Y.) 889–898 (Association for Computational Linguistics, 2018)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR50" id="ref-link-section-d268476881e1679">50</a></sup>). We also sample a single generation at low temperature (0.1) as an estimate of the ‘best generation’ of the model to the context, which we use to assess the accuracy of the model. (A lower sampling temperature increases the probability of sampling the most likely tokens).</p><h4 id="Sec13">Clustering by semantic equivalence</h4><p>To estimate semantic entropy we need to cluster generated outputs from the model into groups of outputs that mean the same thing as each other.</p><p>This can be described using ‘semantic equivalence’ which is the relation that holds between two sentences when they mean the same thing. We can formalize semantic equivalence mathematically. Let the space of tokens in a language be <span>\({\mathcal{T}}\)</span>. The space of all possible sequences of tokens of length <i>N</i> is then <span>\({{\mathcal{S}}}_{N}\equiv {{\mathcal{T}}}^{N}\)</span>. Note that <i>N</i> can be made arbitrarily large to accommodate whatever size of sentence one can imagine and one of the tokens can be a ‘padding’ token which occurs with certainty for each token after the end-of-sequence token. For some sentence <span>\({\bf{s}}\in {{\mathcal{S}}}_{N}\)</span>, composed of a sequence of tokens, <span>\({s}_{i}\in {\mathcal{T}}\)</span>, there is an associated meaning. Theories of meaning are contested<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 51" title="Speaks, J. in The Stanford Encyclopedia of Philosophy (ed. Zalta, E. N.) (Metaphysics Research Lab, Stanford Univ., 2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR51" id="ref-link-section-d268476881e1840">51</a></sup>. However, for specific models and deployment contexts many considerations can be set aside. Care should be taken comparing very different models and contexts.</p><p>Let us introduce a semantic equivalence relation, <i>E</i>( <span>⋅</span> , <span>⋅</span> ), which holds for any two sentences that mean the same thing—we will operationalize this presently. Recall that an equivalence relation is any reflexive, symmetric and transitive relation and that any equivalence relation on a set corresponds to a set of equivalence classes. Each semantic equivalence class captures outputs that can be considered to express the same meaning. That is, for the space of semantic equivalence classes <span>\({\mathcal{C}}\)</span> the sentences in the set <span>\(c\in {\mathcal{C}}\)</span> can be regarded in many settings as expressing a similar meaning such that <span>\(\forall {\bf{s}},{{\bf{s}}}^{{\prime} }\in c:E({\bf{s}},{{\bf{s}}}^{{\prime} })\)</span>. So we can build up these classes of semantically equivalent sentences by checking if new sentences share a meaning with any sentences we have already clustered and, if so, adding them into that class.</p><p>We operationalize <i>E</i>( <span>⋅</span> , <span>⋅</span> ) using the idea of bidirectional entailment, which has a long history in linguistics<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 52" title="Culicover, P. W. Paraphrase generation and information retrieval from stored text. Mech. Transl. Comput. Linguist. 11, 78–88 (1968)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR52" id="ref-link-section-d268476881e1976">52</a></sup> and natural language processing<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 28" title="Negri, M., Bentivogli, L., Mehdad, Y., Giampiccolo, D. &amp; Marchetti, A. Divide and conquer: crowdsourcing the creation of cross-lingual textual entailment corpora. In Proc. 2011 Conference on Empirical Methods in Natural Language Processing 670–679 (Association for Computational Linguistics, 2011)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR28" id="ref-link-section-d268476881e1980">28</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 53" title="Padó, S., Cer, D., Galley, M., Jurafsky, D. &amp; Manning, C. D. Measuring machine translation quality as semantic equivalence: a metric based on entailment features. Mach. Transl. 23, 181–193 (2009)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR53" id="ref-link-section-d268476881e1983">53</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 54" title="Androutsopoulos, I. &amp; Malakasiotis, P. A survey of paraphrasing and textual entailment methods. J. Artif. Intell. Res. 38, 135–187 (2010)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR54" id="ref-link-section-d268476881e1986">54</a></sup>. A sequence, <b>s</b>, means the same thing as a second sequence, <b>s</b>′, only if the sequences entail (that is, logically imply) each other. For example, ‘The capital of France is Paris’ entails ‘Paris is the capital of France’ and vice versa because they mean the same thing. (See later for a discussion of soft equivalence and cases in which bidirectional entailment does not guarantee equivalent meanings).</p><p>Importantly, we require that the sequences mean the same thing with respect to the context—key meaning is sometimes contained in the context. For example, ‘Paris’ does not entail ‘The capital of France is Paris’ because ‘Paris’ is not a declarative sentence without context. But in the context of the question ‘What is the capital of France?’, the one-word answer does entail the longer answer.</p><p>Detecting entailment has been the object of study of a great deal of research in NLI<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 55" title="MacCartney, B. Natural Language Inference (Stanford Univ., 2009)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR55" id="ref-link-section-d268476881e2003">55</a></sup>. We rely on language models to predict entailment, such as DeBERTa-Large-MNLI<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 56" title="He, P., Liu, X., Gao, J. &amp; Chen, W. Deberta: decoding-enhanced BERT with disentangled attention. In International Conference on Learning Representations 
                  https://openreview.net/forum?id=XPZIaotutsD
                  
                 (2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR56" id="ref-link-section-d268476881e2007">56</a></sup>, which has been trained to predict entailment, or general-purpose LLMs such as GPT-3.5 (ref. <sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 57" title="Brown, T. et al. Language models are few-shot learners. Adv. Neural Inf. Process. Syst. 33, 1877–1901 (2020)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR57" id="ref-link-section-d268476881e2011">57</a></sup>), which can predict entailment given suitable prompts.</p><p>We then cluster sentences according to whether they bidirectionally entail each other using the algorithm presented in Extended Data Fig. <a data-track="click" data-track-label="link" data-track-action="figure anchor" href="https://olu.online/articles/s41586-024-07421-0#Fig4">1</a>. Note that, to check if a sequence should be added to an existing cluster, it is sufficient to check if the sequence bidirectionally entails any of the existing sequences in that cluster (we arbitrarily pick the first one), given the transitivity of semantic equivalence. If a sequence does not share meaning with any existing cluster, we assign it its own cluster.</p><h4 id="Sec14">Computing the semantic entropy</h4><p>Having determined the classes of generated sequences that mean the same thing, we can estimate the likelihood that a sequence generated by the LLM belongs to a given class by computing the sum of the probabilities of all the possible sequences of tokens which can be considered to express the same meaning as</p><div id="Equ2"><p><span>$$P(c| {\boldsymbol{x}})=\sum _{{\bf{s}}\in c}P({\bf{s}}| {\boldsymbol{x}})=\sum _{{\bf{s}}\in c}\prod _{i}P({s}_{i}| {{\bf{s}}}_{ &lt; i},{\boldsymbol{x}}).$$</span></p><p>
                    (2)
                </p></div><p>Formally, this treats the output as a random variable whose event-space is the space of all possible meaning-classes, <i>C</i>, a sub-<i>σ</i>-algebra of the standard event-space <i>S</i>. We can then estimate the semantic entropy (SE) as the entropy over the meaning-distribution,</p><div id="Equ3"><p><span>$${\rm{SE}}(x)=-\sum _{c}P(c| {\boldsymbol{x}})\log P(c| {\boldsymbol{x}})$$</span></p><p>
                    (3)
                </p></div><div id="Equ4"><p><span>$$=-\sum _{c}\left(\left[\sum _{{\bf{s}}\in c}P({\bf{s}}| {\boldsymbol{x}})\right]\log \left[\sum _{{\bf{s}}\in c}P({\bf{s}}| {\boldsymbol{x}})\right]\right).$$</span></p><p>
                    (4)
                </p></div><p>There is a complication which prevents direct computation: we do not have access to every possible meaning-class <i>c</i>. Instead, we can only sample <i>c</i> from the sequence-generating distribution induced by the model. To handle this, we estimate the expectation in equation (<a data-track="click" data-track-label="link" data-track-action="equation anchor" href="https://olu.online/articles/s41586-024-07421-0#Equ3">3</a>) using a Rao–Blackwellized Monte Carlo integration over the semantic equivalence classes <i>C</i>,</p><div id="Equ5"><p><span>$$\begin{array}{r}{\rm{SE}}(x)\approx -\mathop{\sum }\limits_{i=1}^{| C| }P({C}_{i}| {\boldsymbol{x}})\log P({C}_{i}| {\boldsymbol{x}}),\end{array}$$</span></p><p>
                    (5)
                </p></div><p>where <span>\(P({C}_{i}| {\boldsymbol{x}})=\frac{P({c}_{i}| {\boldsymbol{x}})}{{\sum }_{c}P(c| {\boldsymbol{x}})}\)</span> estimates a categorical distribution over the cluster meanings, that is, ∑<sub><i>i</i></sub><i>P</i>(<i>C</i><sub><i>i</i></sub><span>∣</span><b>x</b>) = 1. Without this normalization step cluster ‘probabilities’ could exceed one because of length normalization, resulting in degeneracies. Equation (<a data-track="click" data-track-label="link" data-track-action="equation anchor" href="https://olu.online/articles/s41586-024-07421-0#Equ5">5</a>) is the estimator giving our main method that we refer to as semantic entropy throughout the text.</p><p>For scenarios in which the sequence probabilities are not available, we propose a variant of semantic entropy which we call ‘discrete’ semantic entropy. Discrete semantic entropy approximates <i>P</i>(<i>C</i><sub><i>i</i></sub><span>∣</span><b>x</b>) directly from the number of generations in each cluster, disregarding the token probabilities. That is, we approximate <i>P</i>(<i>C</i><sub><i>i</i></sub><span>∣</span><b>x</b>) as <span>\({\sum }_{1}^{M}\frac{{I}_{c={C}_{i}}}{M}\)</span>, the proportion of all the sampled answers which belong to that cluster. Effectively, this just assumes that each output that was actually generated was equally probable—estimating the underlying distribution as the categorical empirical distribution. In the limit of <i>M</i> the estimator converges to equation (<a data-track="click" data-track-label="link" data-track-action="equation anchor" href="https://olu.online/articles/s41586-024-07421-0#Equ5">5</a>) by the law of large numbers. We find that discrete semantic entropy results in similar performance empirically.</p><p>We provide a worked example of the computation of semantic entropy in Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">1</a>.</p><h3 id="Sec15">Detecting confabulations in QA and math</h3><p>Semantic entropy is designed to detect confabulations, that is, model outputs with arbitrary meaning. In our experiments, we use semantic uncertainty to predict model accuracy, demonstrating that confabulations make up a notable fraction of model mistakes. We further show that semantic uncertainty can be used to improve model accuracy by refusing to answer questions when semantic uncertainty is high. Last, semantic uncertainty can be used to give users a way to know when model generations are probably unreliable.</p><h4 id="Sec16">Tasks</h4><p>We use the datasets BioASQ<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 34" title="Tsatsaronis, G. et al. An overview of the BIOASQ large-scale biomedical semantic indexing and question answering competition. BMC Bioinformatics 16, 138 (2015)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR34" id="ref-link-section-d268476881e2878">34</a></sup>, SQuAD<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 33" title="Rajpurkar, P., Zhang, J., Lopyrev, K. &amp; Liang, P. SQuAD: 100,000+ questions for machine compression of text. In Proc. 2016 Conference on Empirical Methods in Natural Language Processing (eds Su, J., Duh, K. &amp; Carreras, X.) 2383–2392 (Association for Computational Linguistics, 2016)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR33" id="ref-link-section-d268476881e2882">33</a></sup>, TriviaQA<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 32" title="Joshi, M., Choi, E., Weld, D. S. &amp; Zettlemoyer, L. TriviaQA: a large scale distantly supervised challenge dataset for reading comprehension. In Proc. 55th Annual Meeting of the Association for Computational Linguistics 1601–1611 (Association for Computational Linguistics. 2017)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR32" id="ref-link-section-d268476881e2886">32</a></sup>, SVAMP<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 37" title="Patel, A., Bhattamishra, S. &amp; Goyal, N. Are NLP models really able to solve simple math word problems? In Proc. 2021 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (eds Toutanova, K. et al.) 2080–2094 (Assoc. Comp. Linguistics, 2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR37" id="ref-link-section-d268476881e2890">37</a></sup> and NQ-Open<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 35" title="Lee, K., Chang, M.-W. &amp; Toutanova, K. Latent retrieval for weakly supervised open domain question answering. In Proc. 57th Annual Meeting of the Association for Computational Linguistics 6086–6096 (Association for Computational Linguistics, 2019)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR35" id="ref-link-section-d268476881e2894">35</a></sup>. BioASQ is a life-sciences question-answering dataset based on the annual challenge of the same name. The specific dataset we use is based on the QA dataset from Task B of the 2023 BioASQ challenge (11B). SQuAD is a reading comprehension dataset whose context passages are drawn from Wikipedia and for which the answers to questions can be found in these passages. We use SQuAD 1.1 which excludes the unanswerable questions added in v.2.0 that are deliberately constructed to induce mistakes so they do not in practice cause confabulations to occur. TriviaQA is a trivia question-answering dataset. SVAMP is a word-problem maths dataset containing elementary-school mathematical reasoning tasks. NQ-Open is a dataset of realistic questions aggregated from Google Search which have been chosen to be answerable without reference to a source text. For each dataset, we use 400 train examples and 400 test examples randomly sampled from the original larger dataset. Note that only some of the methods require training, for example semantic entropy does not use the training data. If the datasets themselves are already split into train and test (or validation) samples, we sample our examples from within the corresponding split.</p><p>All these datasets are free-form, rather than multiple choice, because this better captures the opportunities created by LLMs to produce free-form sentences as answers. We refer to this default scenario as our ‘sentence-length’ experiments. In Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">7</a>, we also present results for confabulation detection in a ‘short-phrase’ scenario, in which we constrain model answers on these datasets to be as concise as possible.</p><p>To make the problems more difficult and induce confabulations, we do not provide the context passages for any of the datasets. When the context passages are provided, the accuracy rate is too high for these datasets for the latest generations of models to meaningfully study confabulations.</p><h4 id="Sec17">Models</h4><p>For sentence-length generations we use: Falcon<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 39" title="Penedo, G. et al. The RefinedWeb dataset for Falcon LLM: outperforming curated corpora with web data, and web data only. In Proc. 36th Conference on Neural Information Processing Systems (eds Oh, A. et al.) 79155–79172 (Curran Associates, 2023)" href="https://olu.online/articles/s41586-024-07421-0#ref-CR39" id="ref-link-section-d268476881e2915">39</a></sup> Instruct (7B and 40B), LLaMA 2 Chat<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 38" title="Touvron, H. et al. Llama 2: open foundation and fine-tuned chat models. Preprint at 
                  https://arxiv.org/abs/2307.09288
                  
                 (2023)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR38" id="ref-link-section-d268476881e2919">38</a></sup> (7B, 13B and 70B) and Mistral<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 40" title="Jiang, A. Q. et al. Mistral 7B. Preprint at 
                  https://arxiv.org/abs/2310.06825
                  
                 (2023)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR40" id="ref-link-section-d268476881e2923">40</a></sup> Instruct (7B).</p><h4 id="Sec18">Baselines</h4><p>In addition to reporting results for semantic entropy, discrete semantic entropy and naive entropy, we consider two strong baselines.</p><p>Embedding regression is a supervised baseline inspired by the <i>P</i>(IK) method<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Kadavath, S. et al. Language models (mostly) know what they know. Preprint at 
                  https://arxiv.org/abs/2207.05221
                  
                 (2022)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR24" id="ref-link-section-d268476881e2941">24</a></sup>. In that paper, the authors fine-tune their proprietary LLM on a dataset of questions to predict whether the model would have been correct. This requires access to a dataset of ground-truth answers to the questions. Rather than fine-tuning the entire LLM in this way, we simply take the final hidden units and train a logistic regression classifier to make the same prediction. By contrast to their method, this is much simpler because it does not require fine-tuning the entire language model, as well as being more reproducible because the solution to the logistic regression optimization problem is not as seed-dependent as the fine-tuning procedure. As expected, this supervised approach performs well in-distribution but fails when the distribution of questions is different from that on which the classifier is trained.</p><p>The second baseline we consider is the <i>P</i>(True) method<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Kadavath, S. et al. Language models (mostly) know what they know. Preprint at 
                  https://arxiv.org/abs/2207.05221
                  
                 (2022)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR24" id="ref-link-section-d268476881e2951">24</a></sup>, in which the model first samples <i>M</i> answers (identically to our semantic entropy approach) and then is prompted with the list of all answers generated followed by the highest probability answer and a question whether this answer is “(a) True” or “(b) False”. The confidence score is then taken to be the probability with which the LLM responds with ‘a’ to the multiple-choice question. The performance of this method is boosted with a few-shot prompt, in which up to 20 examples from the training set are randomly chosen, filled in as above, but then provided with the actual ground truth of whether the proposed answer was true or false. In this way, the method can be considered as supervised ‘in-context’ because it makes use of some ground-truth training labels but can be used without retraining the model. Because of context-size constraints, this method cannot fit a full 20 few-shot examples in the context when input questions are long or large numbers of generations are used. As a result, we sometimes have to reduce the number of few-shot examples to suit the context size and we note this in the <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">Supplementary Material</a>.</p><h4 id="Sec19">Entailment estimator</h4><p>Any NLI classification system could be used for our bidirectional entailment clustering algorithm. We consider two different kinds of entailment detector.</p><p>One option is to use an instruction-tuned LLM such as LLaMA 2, GPT-3.5 (Turbo 1106) or GPT-4 to predict entailment between generations. We use the following prompt:</p><blockquote><div>
                    <p>We are evaluating answers to the question {question}</p>
                    <p>Here are two possible answers:</p>
                    <p>Possible Answer 1: {text1}</p>
                    <p>Possible Answer 2: {text2}</p>
                    <p>Does Possible Answer 1 semantically entail Possible Answer 2? Respond with entailment, contradiction, or neutral.</p>
                  </div></blockquote><p>Alternatively, we consider using a language model trained for entailment prediction, specifically the DeBERTa-large model<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 56" title="He, P., Liu, X., Gao, J. &amp; Chen, W. Deberta: decoding-enhanced BERT with disentangled attention. In International Conference on Learning Representations 
                  https://openreview.net/forum?id=XPZIaotutsD
                  
                 (2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR56" id="ref-link-section-d268476881e2995">56</a></sup> fine-tuned on the NLI dataset MNLI<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 58" title="Williams, A., Nangia, N. &amp; Bowman, S. R. A broad-coverage challenge corpus for sentence understanding through inference. In Proc. 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (eds Walker, M. et al.) 1112–1122 (Assoc. Comp. Linguistics, 2018)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR58" id="ref-link-section-d268476881e2999">58</a></sup>. This builds on past work towards paraphrase identification based on embedding similarity<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 59" title="Yu, L., Hermann, K. M., Blunsom, P. &amp; Pulman, S. Deep learning for answer sentence selection. Preprint at 
                  https://arxiv.org/abs/1412.1632
                  
                 (2014)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR59" id="ref-link-section-d268476881e3003">59</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 60" title="Socher, R., Huang, E., Pennin, J., Manning, C. D. &amp; Ng, A. Dynamic pooling and unfolding recursive autoencoders for paraphrase detection. In Proceedings of the 24th Conference on Neural Information Processing Systems (eds Shawe-Taylor, J. et al.) (2011)" href="https://olu.online/articles/s41586-024-07421-0#ref-CR60" id="ref-link-section-d268476881e3006">60</a></sup> and BERT-style models<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 61" title="He, R., Ravula, A., Kanagal, B. &amp; Ainslie, J. Realformer: Transformer likes residual attention. In Findings of the Association for Computational Linguistics: ACL-IJCNLP 2021 (eds Zhong, C., et al.) 929–943 (Assoc. Comp. Linguistics, 2021)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR61" id="ref-link-section-d268476881e3010">61</a>,<a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 62" title="Tay, Y. et al. Charformer: fast character transformers via gradient-based subword tokenization. In Proceedings of the International Conference on Learning Representations 
                  https://openreview.net/forum?id=JtBRnrlOEFN
                  
                 (2022)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR62" id="ref-link-section-d268476881e3013">62</a></sup>. We template more simply, checking if DeBERTa predicts entailment between the concatenation of the question and one answer and the concatenation of the question and another answer. Note that DeBERTa-large is a relatively lightweight model with only 1.5B parameters which is much less powerful than most of the LLMs under study.</p><p>In Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">2</a>, we carefully evaluate the benefits and drawbacks of these methods for entailment prediction. We settle on using GPT-3.5 with the above prompt, as its entailment predictions agree well with human raters and lead to good confabulation detection performance.</p><p>In Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">3</a>, we provide a discussion of the computational cost and choosing the number of generations for reliable clustering.</p><h4 id="Sec20">Prompting templates</h4><p>We use a simple generation template for all sentence-length answer datasets:</p><blockquote><div>
                    <p>Answer the following question in a single brief but complete sentence.</p>
                    <p>Question: {question}</p>
                    <p>Answer:</p>
                  </div></blockquote><h4 id="Sec21">Metrics and accuracy measurements</h4><p>We use three main metrics to evaluate our method: AUROC, rejection accuracy and AURAC. Each of these is grounded in an automated factuality estimation measurement relative to the reference answers provided by the datasets that we use.</p>
                    <h3 id="FPar1">AUROC, rejection accuracy and AURAC</h3>
                    <p>First, we use the AUROC curve, which measures the reliability of a classifier accounting for both precision and recall. The AUROC can be interpreted as the probability that a randomly chosen correct answer has been assigned a higher confidence score than a randomly chosen incorrect answer. For a perfect classifier, this is 1.</p>
                    <p>Second, we compute the ‘rejection accuracy at <i>X</i>%’, which is the question-answering accuracy of the model on the most-confident <i>X</i>% of the inputs as identified by the respective uncertainty method. If an uncertainty method works well, predictions on the confident subset should be more accurate than predictions on the excluded subset and the rejection accuracy should increase as we reject more inputs.</p>
                    <p>To summarize this statistic we compute the AURAC—the total area enclosed by the accuracies at all cut-off percentages <i>X</i>%. This should increase towards 1 as given uncertainty method becomes more accurate and better at detecting likely-inaccurate responses but it is more sensitive to the overall accuracy of the model than the AUROC metric.</p>
                    <p>In Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">5</a>, we provide the unaggregated rejection accuracies for sentence-length generations.</p>
                  
                    <h3 id="FPar2">Assessing accuracy</h3>
                    <p>For the short-phrase-length generation setting presented in Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">7</a>, we simply assess the accuracy of the generations by checking if the F1 score of the commonly used SQuAD metric exceeds 0.5. There are limitations to such simple scoring rules<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 63" title="Kane, H., Kocyigit, Y., Abdalla, A., Ajanoh, P. &amp; Coulibali, M. Towards neural similarity evaluators. In Workshop on Document Intelligence at the 32nd conference on Neural Information Processing (2019)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR63" id="ref-link-section-d268476881e3098">63</a></sup> but this method is widely used in practice and its error is comparatively small on these standard datasets.</p>
                    <p>For our default scenario, the longer sentence-length generations, this measure fails, as the overlap between the short reference answer and our long model answer is invariably too small. For sentence-length generations, we therefore automatically determine whether an answer to the question is correct or incorrect by using GPT-4 to compare the given answer to the reference answer. We use the template:</p>
                    <blockquote><div>
                      <p>We are assessing the quality of answers to the following question: {question}</p>
                      <p>The expected answer is: {reference answer}</p>
                      <p>The proposed answer is: {predicted answer}</p>
                      <p>Within the context of the question, does the proposed answer mean the same as the expected answer? Respond only with yes or no.</p>
                    </div></blockquote>
                    <p>We make a small modification for datasets with several reference answers: line two becomes “The following are expected answers to this question:” and the final line asks “does the proposed answer mean the same as any of the expected answers?”.</p>
                    <p>In Supplementary Note <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">6</a>, we check the quality of our automated ground-truth evaluations against human judgement by hand. We find that GPT-4 gives the best results for determining model accuracy and thus use it in all our sentence-length experiments.</p>
                  <h3 id="Sec22">Detecting confabulations in biographies</h3><p>In this section we describe the application of semantic entropy to confabulation detection in longer model generations, specifically paragraph-length biographies.</p><p>We introduce a biography-generation dataset—FactualBio—available alongside this paper. FactualBio is a collection of biographies of individuals who are notable enough to have Wikipedia pages but not notable enough to have large amounts of detailed coverage, generated by GPT-4 (v.0613). To generate the dataset, we randomly sampled 21 individuals from the WikiBio dataset<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 64" title="Lebret, R., Grangier, D. &amp; Auli, M. Neural text generation from structured data with application to the biography domain. In Proc. 2016 Conference on Empirical Methods in Natural Language Processing (eds Su, J. et al.) 1203–1213 (Association for Computational Linguistics, 2016)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR64" id="ref-link-section-d268476881e3144">64</a></sup>. For each biography, we generated a list of factual claims contained in each biography using GPT-4, with 150 total factual claims (the total number is only coincidentally a round number). For each of these factual claims, we manually determined whether the claim was correct or incorrect. Out of 150 claims, 45 were incorrect. As before, we apply confabulation detection to detect incorrect model predictions, even though there may be model errors which are not confabulations.</p><h4 id="Sec23">Prompting and generation</h4><p>Given a paragraph-length piece of LLM-generated text, we apply the following sequence of steps:</p><ol>
                    <li>
                      <span>1.</span>
                      
                        <p>Automatically decompose the paragraph into specific factual claims using an LLM (not necessarily the same as the original).</p>
                      
                    </li>
                    <li>
                      <span>2.</span>
                      
                        <p>For each factual claim, use an LLM to automatically construct <i>Q</i> questions which might have produced that claim.</p>
                      
                    </li>
                    <li>
                      <span>3.</span>
                      
                        <p>For each question, prompt the original LLM to generate <i>M</i> answers.</p>
                      
                    </li>
                    <li>
                      <span>4.</span>
                      
                        <p>For each question, compute the semantic entropy of the answers, including the original factual claim.</p>
                      
                    </li>
                    <li>
                      <span>5.</span>
                      
                        <p>Average the semantic entropies over the questions to arrive at a score for the original factual claim.</p>
                      
                    </li>
                  </ol><p>We pursue this slightly indirect way of generating answers because we find that simply resampling each sentence creates variation unrelated to the uncertainty of the model about the factual claim, such as differences in paragraph structure.</p><p>We decompose the paragraph into factual claims using the following prompt:</p><blockquote><p>Please list the specific factual propositions included in the answer above. Be complete and do not leave any factual claims out. Provide each claim as a separate sentence in a separate bullet point.</p></blockquote><p>We found that we agreed with the decompositions in all cases in the dataset.</p><p>We then generate six questions for each of the facts from the decomposition. We generate these questions by prompting the model twice with the following:</p><blockquote><div>
                    <p>Following this text:</p>
                    <p>{text so far}</p>
                    <p>You see the sentence:</p>
                    <p>{proposition}</p>
                    <p>Generate a list of three questions, that might have generated the sentence in the context of the preceding original text, as well as their answers. Please do not use specific facts that appear in the follow-up sentence when formulating the question. Make the questions and answers diverse. Avoid yes-no questions. The answers should not be a full sentence and as short as possible, e.g. only a name, place, or thing. Use the format “1. {question} – {answer}”.</p>
                  </div></blockquote><p>These questions are not necessarily well-targeted and the difficulty of this step is the main source of errors in the procedure. We generate three questions with each prompt, as this encourages diversity of the questions, each question targeting a different aspect of the fact. However, we observed that the generated questions will sometimes miss obvious aspects of the fact. Executing the above prompt twice (for a total of six questions) can improve coverage. We also ask for brief answers because the current version of GPT-4 tends to give long, convoluted and highly hedged answers unless explicitly told not to.</p><p>Then, for each question, we generate three new answers using the following prompt:</p><blockquote><div>
                    <p>We are writing an answer to the question “{user question}”. So far we have written:</p>
                    <p>{text so far}</p>
                    <p>The next sentence should be the answer to the following question:</p>
                    <p>{question}</p>
                    <p>Please answer this question. Do not answer in a full sentence. Answer with as few words as possible, e.g. only a name, place, or thing.</p>
                  </div></blockquote><p>We then compute the semantic entropy over these answers plus the original factual claim. Including the original fact ensures that the estimator remains grounded in the original claim and helps detect situations in which the question has been interpreted completely differently from the original context. We make a small modification to handle the fact that GPT-4 generations often include refusals to answer questions. These refusals were not something we commonly observe in our experiments with LLaMA 2, Falcon or Mistral models. If more than half of the answers include one of the strings ‘not available’, ‘not provided’, ‘unknown’ or ‘unclear’ then we treat the semantic uncertainty as maximal.</p><p>We then average the semantic entropies for each question corresponding to the factual claim to get an entropy for this factual claim.</p><p>Despite the extra assumptions and complexity, we find that this method greatly outperforms the baselines.</p><h4 id="Sec24">Entailment estimator</h4><p>To compute semantic entailment between the original claim and regenerated answers, we rely on the DeBERTa entailment prediction model as we find empirically that DeBERTa predictions result in higher train-set AUROC than other methods. Because DeBERTa has slightly lower recall than GPT-3.5/4, we use a modified set-up for which we say the answers mean the same as each other if at least one of them entails the other and neither is seen to contradict the other—a kind of ‘non-defeating’ bidirectional entailment check rather than true bidirectional entailment. The good performance of DeBERTa in this scenario is not surprising as both factual claims and regenerated answers are relatively short. We refer to Supplementary Notes <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">2</a> and <a data-track="click" data-track-label="link" data-track-action="supplementary material anchor" href="https://olu.online/articles/s41586-024-07421-0#MOESM1">3</a> for ablations and experiments regarding our choice of entailment estimator for paragraph-length generations.</p><h4 id="Sec25">Baselines</h4><p>We implement two baselines. First, we implement a variant of the <i>P</i>(True) method, which is adapted to the new setting. For each factoid, we generate a question with answers in the same way as for semantic entropy. We then use the following prompt:</p><blockquote><div>
                    <p>Question: {question}</p>
                    <p>Here are some brainstormed ideas:</p>
                    <p>{list of regenerated answers}</p>
                    <p>Possible answer: {original answer}</p>
                    <p>Is the possible answer true? Respond with “yes” or “no”.</p>
                  </div></blockquote><p>As we cannot access the probabilities GPT-4 assigns to predicting ‘yes’ and ‘no’ as the next token, we approximate this using Monte Carlo samples. Concretely, we execute the above prompt ten times (at temperature 1) and then take the fraction of answers which was ‘yes’ as our unbiased Monte Carlo estimate of the token probability GPT-4 assigns to ‘yes’.</p><p>As a second, simpler, baseline we check if the model thinks the answer is true. We simply ask:</p><blockquote><div>
                    <p>Following this text:</p>
                    <p>{text so far}</p>
                    <p>You see this statement:</p>
                    <p>{proposition}</p>
                    <p>Is it likely that the statement is true? Respond with ‘yes’ or ‘no’.</p>
                  </div></blockquote><p>It is interesting that this method ought to perform very well if we think that the model has good ‘self-knowledge’ (that is, if “models mostly know what they don’t know”<sup><a data-track="click" data-track-action="reference anchor" data-track-label="link" data-test="citation-ref" aria-label="Reference 24" title="Kadavath, S. et al. Language models (mostly) know what they know. Preprint at 
                  https://arxiv.org/abs/2207.05221
                  
                 (2022)." href="https://olu.online/articles/s41586-024-07421-0#ref-CR24" id="ref-link-section-d268476881e3366">24</a></sup>) but in fact semantic entropy is much better at detecting confabulations.</p></div></div>
  </body>
</html>
