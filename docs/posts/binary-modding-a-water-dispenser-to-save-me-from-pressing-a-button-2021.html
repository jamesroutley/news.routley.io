<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://practicapp.com/binary-modding-a-watercooler/">Original</a>
    <h1>Binary modding a water dispenser to save me from pressing a button (2021)</h1>
    
    <div id="readability-page-1" class="page"><div id="main" role="main">
      <article>
 

  <div>
    <p>A few months ago, I decided that it‚Äôs time I started to become more responsible and to start drinking more water. Unfortunately, the tap water where I live has a very high calcium content, which makes it a lot better when filtered and cooled first.
To solve both issues, I picked up a second-hand professional water dispenser:</p>

<p><img src="https://practicapp.com/images/ion_watercooler.jpg" alt="ION 900 series water dispenser"/>
<em>ION 900 series water dispenser</em></p>

<p>This thing is <em>amazing</em>. It‚Äôs connected to the water supply, has power save features when it detects it‚Äôs in the dark for a while, the filter lasts for <em>years</em>, ‚Ä¶</p>

<p>Along with the cooler, I also bought thermally-isolated 1L bottles, which take about 50 seconds to fill. Unfortunately, you have to keep pressing the ‚Äúdispense cold water‚Äù-button while filling üòë.</p>

<p>Since I‚Äôm lazy and not very rational in my decision making, I decided it‚Äôs time to fix that!
<!--end_excerpt--></p>



<p>It‚Äôs pretty simple! The main part of the cooler is an insulated vat of chilled water (cooled by a compressor like in a fridge), through which the stainless steel tube of fresh filtered water flows:</p>
<p><img src="https://practicapp.com/images/ion_vat_top.jpg" alt="Water vat with the insulation removed" width="350"/>
  <img src="https://practicapp.com/images/ion_vat.jpg" alt="Water vat with the insulation removed" width="350"/>
</p>
<p><em>Water vat with the insulation removed</em></p>

<p>To control the water flow, it contains multiple 24VDC valves. Other than that, the cooler contains some temperature sensors, a stirring pump, a fan, ‚Ä¶</p>

<p>This all is controlled by the main PCB, containing an 8-bit PIC18F6527 microcontroller. In the front panel, there‚Äôs another PCB with a PIC16F630 to handle the LEDs and light sensor.</p>
<p><img src="https://practicapp.com/images/ion_pcb.jpg" alt="Main PCB" width="350"/>
  <img src="https://practicapp.com/images/ion_pcb_front.jpg" alt="Front panel PCB" width="350"/>
</p>
<p><em>The two PCBs in the water dispenser</em></p>


<p>To modify the code running on the microcontrollers, we first have to get our hands on a copy of the binary. Keen-eyed readers might have already spotted the ICSP headers on both PCBs, which can be connected directly to a PICkit in-circuit programmer!</p>

<p>When starting this project, my PICkit was still on order, so I implemented <a href="https://github.com/robbederks/watercooler/tree/master/arduino_dumper">a dumper based on the ICSP logic of the PIC-18 by using an Arduino</a>:</p>

<p><img src="https://practicapp.com/images/ion_arduino_dumper.jpg" alt="Arduino PIC dumping setup"/>
<em>Arduino PIC dumping setup, with external MOSFET to power the board</em></p>

<p>The resulting dumps can be found in the public GitHub repo of this project <a href="https://github.com/robbederks/watercooler">here</a>.</p>


<p>To be able to implement a new feature in this firmware, we first need to have an idea of what that binary is actually doing. Of course, having the binary doesn‚Äôt give you the source code,
but by disassembling it you get the assembly instructions and can even get an approximate version of the source code that might have produced this assembly.
For this, I used <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, a tool developed and open-sourced by the NSA. Luckily, Ghidra already supports the PIC-18 architecture. Opening up the binary and running all the standard analysis tool, the project contains a lot of detected functions which look a bit like this:
<img src="https://practicapp.com/images/screenshot_read_port_clean.png" alt="Clean function from the binary"/></p>

<p>On the left hand side of the screen, the binary data and disassembled instructions are shown, while on the right Ghidra has done it‚Äôs best decompilation effort:</p>

<figure><pre><code data-lang="c"><span>void</span> <span>FUN_CODE_0067d2</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>byte</span> <span>bVar1</span><span>;</span>
  <span>byte</span> <span>bVar2</span><span>;</span>
  <span>byte</span> <span>bVar3</span><span>;</span>

  <span>bVar3</span> <span>=</span> <span>DAT_DATA_0013</span><span>;</span>
  <span>write_sfr_1</span><span>(</span><span>TRISB</span><span>,</span><span>0x1f</span><span>);</span>
  <span>write_sfr_1</span><span>(</span><span>TRISE</span><span>,</span><span>0x80</span><span>);</span>
  <span>bVar1</span> <span>=</span> <span>read_sfr_1</span><span>(</span><span>PORTB</span><span>);</span>
  <span>bVar2</span> <span>=</span> <span>read_sfr_1</span><span>(</span><span>PORTE</span><span>);</span>
  <span>DAT_DATA_0013</span> <span>=</span> <span>DAT_DATA_0013</span> <span>|</span> <span>4</span><span>;</span>
  <span>if</span> <span>((</span><span>bVar1</span> <span>&amp;</span> <span>0x10</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>DAT_DATA_0013</span> <span>=</span> <span>bVar3</span> <span>&amp;</span> <span>0xfb</span><span>;</span>
  <span>}</span>
  <span>DAT_DATA_0000</span> <span>=</span> <span>bVar1</span> <span>&amp;</span> <span>0xf</span> <span>|</span> <span>bVar2</span> <span>&amp;</span> <span>0x80</span><span>;</span>
  <span>DAT_DATA_0001</span> <span>=</span> <span>0</span><span>;</span>
  <span>DAT_DATA_00bc</span> <span>=</span> <span>DAT_DATA_0000</span><span>;</span>
  <span>return</span><span>;</span>
<span>}</span></code></pre></figure>

<p>Since no debug symbols are present in this binary, all variables and functions have been given generic names like <code>FUN_CODE_0067d2</code>, <code>DAT_DATA_0013</code> and <code>bVar3</code>. Let‚Äôs explain a bit what these refer to:</p>

<ul>
  <li><code>FUN_CODE_0067d2</code>: This is a generated label referring to the detected function at address <code>0x67d2</code>. Since the PIC18 is based on the <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard architecture</a> with separate instruction an data memory spaces, Ghidra denotes this address as <code>CODE_0067d2</code> since it‚Äôs in the <code>CODE</code> memory space.</li>
  <li><code>DAT_DATA_0013</code>: This label denotes a 8-bit data variable located in the <code>DATA</code> memory space at address <code>0x0013</code>. The CPU in the PIC18 does not have <a href="https://en.wikipedia.org/wiki/Processor_register">general-purpose registers</a> (except for <code>WREG</code>), so it uses variables stored in data memory for most of its computations and function arguments. Since it re-uses most of these addresses so often, it‚Äôs really annoying to annotate the global variables used in the reverse engineered code.</li>
  <li><code>bVar3</code>: This denotes byte-sized variable number 3, used locally. Variables like these are inserted in the decompilation, but are not actually represented in the data memory anywhere.</li>
</ul>

<p>Looking at what this decompiled code of this function is doing, we can see that it sets the <code>TRISB</code> and <code>TRISE</code> registers, after which it reads out <code>PORTB</code> and <code>PORTE</code> and does some processing with it. Referencing the <a href="http://ww1.microchip.com/downloads/en/devicedoc/39646b.pdf">PIC18F6527 datasheet</a>, we can see that this sets the direction of the GPIO port B and E pins, after which it reads the values.</p>

<p>Using this knowledge, we can rename the labels used in the code and add some comments to make it a bit more readable:</p>

<figure><pre><code data-lang="c"><span>void</span> <span>read_port_b_e</span><span>(</span><span>void</span><span>)</span> <span>{</span>
  <span>byte</span> <span>port_b_value</span><span>;</span>
  <span>byte</span> <span>port_e_value</span><span>;</span>
  <span>byte</span> <span>tmp_flag</span><span>;</span>

  <span>tmp_flag</span> <span>=</span> <span>DAT_DATA_0013</span><span>;</span>

  <span>// Set certain port B and E pins as input</span>
  <span>write_sfr_1</span><span>(</span><span>TRISB</span><span>,</span><span>0x1f</span><span>);</span>
  <span>write_sfr_1</span><span>(</span><span>TRISE</span><span>,</span><span>0x80</span><span>);</span>

  <span>// Read the value of the ports</span>
  <span>port_b_value</span> <span>=</span> <span>read_sfr_1</span><span>(</span><span>PORTB</span><span>);</span>
  <span>port_e_value</span> <span>=</span> <span>read_sfr_1</span><span>(</span><span>PORTE</span><span>);</span>

  <span>// If pin B4 is low, clear a flag in `DAT_DATA_0013`</span>
  <span>DAT_DATA_0013</span> <span>=</span> <span>DAT_DATA_0013</span> <span>|</span> <span>4</span><span>;</span>
  <span>if</span> <span>((</span><span>port_b_value</span> <span>&amp;</span> <span>0x10</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>DAT_DATA_0013</span> <span>=</span> <span>tmp_flag</span> <span>&amp;</span> <span>0xfb</span><span>;</span>
  <span>}</span>

  <span>// DAT_DATA_0000 is the return value used by the calling functions</span>
  <span>DAT_DATA_0000</span> <span>=</span> <span>port_b_value</span> <span>&amp;</span> <span>0xf</span> <span>|</span> <span>port_e_value</span> <span>&amp;</span> <span>0x80</span><span>;</span>
  <span>DAT_DATA_0001</span> <span>=</span> <span>0</span><span>;</span>
  <span>DAT_DATA_00bc</span> <span>=</span> <span>DAT_DATA_0000</span><span>;</span>
  <span>return</span><span>;</span>
<span>}</span></code></pre></figure>

<p>By tracing the buttons on the front panel to the PIC on the main PCB, we find following connections:</p>
<ul>
  <li>Pin <code>B0</code>: Room temperature water dispense</li>
  <li>Pin <code>B1</code>: Cold water dispense</li>
</ul>

<p>We also find that this is the only function in the binary to reference <code>PORTB</code>, which makes us sure that this is the function which will be called to check the status of the front panel buttons.</p>

<p>Using this process, I decompiled and found most of the functions we‚Äôre interested in, under which for example:</p>
<ul>
  <li><code>beep()</code> at <code>0x7118</code>: Like the name suggests, calling this function with the desired duration in <code>DAT_DATA_0000</code> (LSB) and <code>DAT_DATA_0001</code> (MSB) makes the beeper beep!</li>
  <li><code>delay()</code> at <code>0x75c8</code>: Regular delay function, with the desired duration in <code>DAT_DATA_0000</code> (LSB) and <code>DAT_DATA_0001</code> (MSB)</li>
  <li><code>close_all_valves()</code> at <code>0x62e8</code>: Closes all dispensing valves</li>
  <li><code>dispense_cold_water()</code> at <code>0x6332</code>: Opens the inlet valve and the cold water dispensing valve</li>
  <li><code>handle_button_presses_and_dispense()</code> at <code>0x639c</code>: This function is called in the main program loop and checks the button state through <code>read_port_b_e</code> and calls the appropriate dispensing functions.</li>
</ul>

<p>The Ghidra project with all the labels I added can be found <a href="https://github.com/robbederks/watercooler/tree/master/ghidra">here</a>.</p>


<p>Ok, time to get our hands dirty and let‚Äôs see how we can add the hands-free functionality we want.</p>

<p>After some consideration, I settled on the following simple patches:</p>
<ul>
  <li>Replace the call to <code>read_port_b_e()</code> in the <code>handle_button_presses_and_dispense</code>-function with a call to my own <code>patch</code> function</li>
  <li>Have <code>patch()</code> call <code>read_port_b_e()</code>, and with the returned ‚Äúactual‚Äù button states perform the added function</li>
  <li>Return a ‚Äúfaked‚Äù button state based on this added logic</li>
</ul>


<p>I don‚Äôt like writing assembly, especially in cases like this when there is some trial-and-error going on.
Instead, I opted to download <a href="https://www.microchip.com/en-us/tools-resources/develop/mplab-xc-compilers">Microchip‚Äôs XC8 compiler</a> and use it to compile the binary patches straight from C code.</p>

<p>In the end, I settled on this code:</p>

<figure><pre><code data-lang="c"><span>// This is a patch to have a predefined amount of cold water</span>
<span>// dispensed when you press the &#34;room temp water&#34; button</span>
<span>// while holding the &#34;cold temp water&#34; button</span>

<span>// It hooks into the `dispense_room_temp_water()` function (since that&#39;s called first)</span>
<span>// and loops there for a predefined delay if there&#39;s also cold water dispensing.</span>

<span>#include</span> <span>&lt;xc.h&gt;</span><span>
#include</span> <span>&lt;stdint.h&gt;</span><span>
#include</span> <span>&lt;proc/pic18f6527.h&gt;</span><span>
</span>
<span>// Used pointers in the original code:</span>
<span>volatile</span> <span>uint8_t</span> <span>*</span><span>return_val_ptr</span> <span>=</span> <span>(</span><span>volatile</span> <span>uint8_t</span> <span>*</span><span>)</span><span>0x0000</span><span>;</span>
<span>volatile</span> <span>uint8_t</span> <span>*</span><span>beep_time_L_ptr</span> <span>=</span> <span>(</span><span>volatile</span> <span>uint8_t</span> <span>*</span><span>)</span><span>0x00be</span><span>;</span>
<span>volatile</span> <span>uint8_t</span> <span>*</span><span>beep_time_H_ptr</span> <span>=</span> <span>(</span><span>volatile</span> <span>uint8_t</span> <span>*</span><span>)</span><span>0x00bf</span><span>;</span>

<span>extern</span> <span>void</span> <span>read_port_b_e</span><span>(</span><span>void</span><span>)</span> <span>__at</span><span>(</span><span>0x67d2</span><span>);</span>
<span>extern</span> <span>void</span> <span>beep</span><span>(</span><span>void</span><span>)</span> <span>__at</span><span>(</span><span>0x7118</span><span>);</span>

<span>// Globals</span>
<span>uint32_t</span> <span>fake_dispensing_counter</span><span>;</span>
<span>uint8_t</span> <span>handsfree</span><span>;</span>

<span>#define INIT_MAGIC 0xA5A5
</span><span>volatile</span> <span>uint16_t</span> <span>init_checker</span><span>;</span>

<span>// Put the patch function at a known empty address</span>
<span>// to make it easy to find in the binary</span>
<span>void</span> <span>patch</span><span>()</span> <span>__at</span><span>(</span><span>0x8000</span><span>);</span>
<span>void</span> <span>patch</span><span>()</span> <span>{</span>
  <span>// We wrap the button readout function to be able to fake button presses</span>
  <span>// in the dispensing logic.</span>

  <span>// Init variables if not done so already.</span>
  <span>// Since this is in RAM, everything will have an unknown value at startup</span>
  <span>if</span> <span>(</span><span>init_checker</span> <span>!=</span> <span>INIT_MAGIC</span><span>)</span> <span>{</span>
    <span>fake_dispensing_counter</span> <span>=</span> <span>0</span><span>;</span>
    <span>handsfree</span> <span>=</span> <span>0</span><span>;</span>
    <span>init_checker</span> <span>=</span> <span>INIT_MAGIC</span><span>;</span>
  <span>}</span>

  <span>// Read real status</span>
  <span>read_port_b_e</span><span>();</span>

  <span>if</span> <span>(</span><span>fake_dispensing_counter</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>((</span><span>*</span><span>return_val_ptr</span><span>)</span> <span>&amp;</span> <span>0x3</span><span>)</span> <span>==</span> <span>0x3</span><span>)</span> <span>{</span>
    <span>// Pressing both buttons, so we start the fake dispense and beep.</span>
    <span>// This will dispense about 1L</span>
    <span>fake_dispensing_counter</span> <span>=</span> <span>0x20000</span><span>;</span>
    <span>handsfree</span> <span>=</span> <span>0U</span><span>;</span>

    <span>*</span><span>beep_time_L_ptr</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span> <span>0x05</span><span>;</span>
    <span>*</span><span>beep_time_H_ptr</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span> <span>0x01</span><span>;</span>
    <span>beep</span><span>();</span>
  <span>}</span>

  <span>if</span> <span>(</span><span>fake_dispensing_counter</span> <span>&gt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>((</span><span>handsfree</span> <span>==</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(((</span><span>*</span><span>return_val_ptr</span><span>)</span> <span>&amp;</span> <span>0x3</span><span>)</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
      <span>// We released the buttons</span>
      <span>handsfree</span> <span>=</span> <span>1U</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>((</span><span>handsfree</span> <span>!=</span> <span>0U</span><span>)</span> <span>&amp;&amp;</span> <span>(((</span><span>*</span><span>return_val_ptr</span><span>)</span> <span>&amp;</span> <span>0x3</span><span>)</span> <span>!=</span> <span>0</span><span>))</span> <span>{</span>
      <span>// We cancelled by pressing a button</span>
      <span>*</span><span>beep_time_L_ptr</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span> <span>0x05</span><span>;</span>
      <span>*</span><span>beep_time_H_ptr</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span> <span>0x00</span><span>;</span>
      <span>beep</span><span>();</span>

      <span>fake_dispensing_counter</span> <span>=</span> <span>0U</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>

    <span>// Fake only cold water button</span>
    <span>*</span><span>return_val_ptr</span> <span>=</span> <span>((</span><span>*</span><span>return_val_ptr</span> <span>&amp;</span> <span>0xf0</span><span>)</span> <span>|</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>1</span><span>));</span>

    <span>fake_dispensing_counter</span><span>--</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// xc8 does not generate .o files, so we need to have main()</span>
<span>void</span> <span>main</span><span>()</span> <span>__at</span><span>(</span><span>0x10</span><span>);</span>
<span>void</span> <span>main</span><span>()</span> <span>{</span>
  <span>patch</span><span>();</span>
<span>}</span></code></pre></figure>

<p>While writing and compiling something like this, there are a few caveats we need to be aware of, and work around.</p>

<p>First of all, there‚Äôs the issue that the functions will be packed into the smallest binary possible, with the function addresses being close to <code>0x0000</code>. To address this <em>(pun intended)</em>, we added the <code>__at(&lt;address&gt;)</code> directives to force the compiler to put the code in a certain memory location. Since the original code stops at <code>0x7692</code>, <code>0x8000</code> seemed like a nice spot to put our <code>patch()</code>.</p>

<p>Second issue we encounter is that we have to make the compiler aware to stay clear of the <code>DATA</code> variables used by the original code. In Ghidra, we can see that the original code only uses <code>DATA</code> variables with addresses below <code>0x100</code>, hence we call the compiler with the argument to reserve that area. This option is intended to be used for code that‚Äôs used with bootloaders, but comes in handy in our specific case as well. We invoke the compiler as such:</p>

<figure><pre><code data-lang="bash">xc8-cc <span>-mcpu</span><span>=</span>pic18f6527 <span>-opt</span><span>=</span>none <span>-mram</span><span>=</span>default,-0000-0100 <span>-o</span> out/hook hook.c</code></pre></figure>

<p>Finally, we need to be aware that we can‚Äôt rely on the global variables to be initialized with a known value. Initializing it globally in this code would result in the compiler generating some instructions to be run before <code>main()</code> is called, which we can‚Äôt very easily patch into the original binary. A more simple way was used, namely by dedicating a global <code>uint16_t</code> as a flag with a magic value to check the initialization status.</p>


<p>Opening up and analyzing the freshly compiled <code>hook</code> binary in Ghidra, we can see that our code is indeed in the intended locations, and that it only uses <code>DATA</code> variables over <code>0x100</code>, except when needed as arguments or return values. This is the decompiled version of the <code>patch()</code> function:</p>

<figure><pre><code data-lang="c"><span>byte</span> <span>FUN_CODE_008000</span><span>(</span><span>void</span><span>)</span>

<span>{</span>
  <span>bool</span> <span>bVar1</span><span>;</span>
  <span>byte</span> <span>bVar2</span><span>;</span>
  <span>bool</span> <span>bVar3</span><span>;</span>

  <span>if</span> <span>((</span><span>DAT_DATA_0105</span> <span>!=</span> <span>-</span><span>0x5b</span><span>)</span> <span>||</span> <span>(</span><span>bVar2</span> <span>=</span> <span>DAT_DATA_0106</span> <span>^</span> <span>0xa5</span><span>,</span> <span>bVar2</span> <span>!=</span> <span>0</span><span>))</span> <span>{</span>
    <span>DAT_DATA_0101</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0102</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0103</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0104</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0109</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
    <span>DAT_DATA_0106</span> <span>=</span> <span>0xa5</span><span>;</span>
    <span>bVar2</span> <span>=</span> <span>0xa5</span><span>;</span>
    <span>DAT_DATA_0105</span> <span>=</span> <span>-</span><span>0x5b</span><span>;</span>
  <span>}</span>
  <span>func_0x0067d2</span><span>(</span><span>bVar2</span><span>);</span>
  <span>if</span> <span>(((</span><span>DAT_DATA_0104</span> <span>|</span> <span>DAT_DATA_0103</span> <span>|</span> <span>DAT_DATA_0102</span> <span>|</span> <span>DAT_DATA_0101</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>&amp;&amp;</span>
     <span>((</span><span>bDATA0000</span> <span>&amp;</span> <span>3</span><span>)</span> <span>==</span> <span>3</span><span>))</span> <span>{</span>
    <span>DAT_DATA_0101</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0102</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0103</span> <span>=</span> <span>2</span><span>;</span>
    <span>DAT_DATA_0104</span> <span>=</span> <span>0</span><span>;</span>
    <span>DAT_DATA_0109</span> <span>=</span> <span>&#39;\0&#39;</span><span>;</span>
    <span>DAT_DATA_00be</span> <span>=</span> <span>5</span><span>;</span>
    <span>DAT_DATA_00bf</span> <span>=</span> <span>1</span><span>;</span>
    <span>func_0x007118</span><span>();</span>
  <span>}</span>
  <span>bVar2</span> <span>=</span> <span>DAT_DATA_0104</span> <span>|</span> <span>DAT_DATA_0103</span> <span>|</span> <span>DAT_DATA_0102</span> <span>|</span> <span>DAT_DATA_0101</span><span>;</span>
  <span>if</span> <span>(</span><span>bVar2</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
    <span>if</span> <span>((</span><span>DAT_DATA_0109</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>bDATA010e</span> <span>=</span> <span>bDATA0000</span> <span>&amp;</span> <span>3</span><span>,</span> <span>bDATA010e</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
      <span>DAT_DATA_0109</span> <span>=</span> <span>&#39;\x01&#39;</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>((</span><span>DAT_DATA_0109</span> <span>==</span> <span>&#39;\0&#39;</span><span>)</span> <span>||</span> <span>(</span><span>bDATA010e</span> <span>=</span> <span>bDATA0000</span> <span>&amp;</span> <span>3</span><span>,</span> <span>bDATA010e</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
      <span>bDATA0000</span> <span>=</span> <span>bDATA0000</span> <span>&amp;</span> <span>0xf0</span> <span>|</span> <span>2</span><span>;</span>
      <span>bVar3</span> <span>=</span> <span>DAT_DATA_0101</span> <span>!=</span> <span>0</span><span>;</span>
      <span>DAT_DATA_0101</span> <span>=</span> <span>DAT_DATA_0101</span> <span>-</span> <span>1</span><span>;</span>
      <span>bVar2</span> <span>=</span> <span>0</span><span>;</span>
      <span>bVar1</span> <span>=</span> <span>DAT_DATA_0102</span> <span>!=</span> <span>~</span><span>bVar3</span><span>;</span>
      <span>DAT_DATA_0102</span> <span>=</span> <span>DAT_DATA_0102</span> <span>-</span> <span>~</span><span>bVar3</span><span>;</span>
      <span>bVar3</span> <span>=</span> <span>DAT_DATA_0103</span> <span>!=</span> <span>~</span><span>bVar1</span><span>;</span>
      <span>DAT_DATA_0103</span> <span>=</span> <span>DAT_DATA_0103</span> <span>-</span> <span>~</span><span>bVar1</span><span>;</span>
      <span>DAT_DATA_0104</span> <span>=</span> <span>DAT_DATA_0104</span> <span>-</span> <span>~</span><span>bVar3</span><span>;</span>
    <span>}</span>
    <span>else</span> <span>{</span>
      <span>DAT_DATA_00be</span> <span>=</span> <span>5</span><span>;</span>
      <span>DAT_DATA_00bf</span> <span>=</span> <span>0</span><span>;</span>
      <span>func_0x007118</span><span>();</span>
      <span>DAT_DATA_0101</span> <span>=</span> <span>0</span><span>;</span>
      <span>DAT_DATA_0102</span> <span>=</span> <span>0</span><span>;</span>
      <span>DAT_DATA_0103</span> <span>=</span> <span>0</span><span>;</span>
      <span>bVar2</span> <span>=</span> <span>0</span><span>;</span>
      <span>DAT_DATA_0104</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>bVar2</span><span>;</span>
<span>}</span></code></pre></figure>


<p>Now that we have a binary version of the <code>patch()</code>, we can just copy that part of the binary over to the original code at address <code>0x8000</code>.
After this, there‚Äôs only one thing left: replacing the call in <code>handle_button_presses_and_dispense()</code> from <code>read_port_b_e()</code> at <code>0x67d2</code> to the new <code>patch()</code> function at <code>0x8000</code>.</p>

<p>To do this, we could do this by hand by recalculating and replacing the argument bytes in the <a href="http://technology.niagarac.on.ca/staff/mboldin/18F_Instruction_Set/CALL.html">CALL-instruction</a>, but Ghidra has a nice feature for this!
Right-clicking on the instruction you want to patch and selecting ‚ÄòPatch Instruction‚Äô allows you to edit the assembly line directly, and it‚Äôll automagically recalculate the binary representation. <em>How awesome!</em></p>

<p>
<img src="https://practicapp.com/images/ion_call.png"/></p>

<p>Export the binary from the Ghidra project, convert it to the right <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> format used by <a href="https://www.microchip.com/en-us/tools-resources/production/mplab-integrated-programming-environment">Microchip IPE</a> and we‚Äôre ready to flash!
By now my PICkit had arrived, which made easy work of flashing.</p>

<p><img src="https://practicapp.com/images/ion_pickit.jpg" alt="Flashing setup"/>
<em>I had a proper PICkit for flashing now!</em></p>


<p><em>Et voila!</em> A working patch for hands-free mode, complete with cancel functionality and annoying beeps!</p>

<blockquote data-conversation="none" data-theme="light"><p lang="en" dir="ltr">Added hands-free dispensing! Can even cancel the pour mid-way by pressing a button again.</p>‚Äî Robbe Derks (@robbederks) <a href="https://twitter.com/robbederks/status/1473333548119691264?ref_src=twsrc%5Etfw">December 21, 2021</a></blockquote>


<p>In the end, it took about 8 hours to get this project finished, which was spread out over multiple weeks. Considering that I usually fill my bottle once a day, and it takes about 50 seconds to do so, this will have a positive return-on-investment after only about 1.5 years!</p>


  </div>

  


</article>


    </div></div>
  </body>
</html>
