<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jetbrains.com/blog/2023/10/16/ai-graphics-at-jetbrains-story/">Original</a>
    <h1>AI Graphics at JetBrains</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
    <div>
    <div>
        <div>
            <div>
                                    <p><a href="https://blog.jetbrains.com/blog/">
                        <img src="https://blog.jetbrains.com/wp-content/uploads/2019/01/jetbrains_icon.svg" alt="Blog logo"/>
                    </a></p>
            </div>
            
        </div>
        
    </div>
</div>
                        <section data-clarity-region="article">
                <div>
                    				<p><a href="https://blog.jetbrains.com/blog/category/datalore/">Datalore</a>
			<a href="https://blog.jetbrains.com/blog/category/design-decisions/">Design decisions</a>
			<a href="https://blog.jetbrains.com/blog/category/desktopart/">DesktopArt</a>
			<a href="https://blog.jetbrains.com/blog/category/jetbrains/">JetBrains</a>
			<a href="https://blog.jetbrains.com/blog/category/pycharm/">PyCharm</a></p>                    <div>
                                                <div>
                            <p><img src="https://blog.jetbrains.com/wp-content/uploads/2023/10/photo_2023-07-13_15-58-17-e1696938091752-200x200.jpg" width="200" height="200" alt="Vladimir Sotnikov" loading="lazy"/>
                                                                                                                    <img src="https://blog.jetbrains.com/wp-content/uploads/2023/02/Olga_BVG-200x200.png" width="200" height="200" alt="Olga Andreevskikh" loading="lazy"/>
                                                                                                </p>
                            
                        </div>
                                            </div>
                    
<p>At JetBrains, we are constantly refining our approach to creating pieces of art for use as website elements and release graphics. Our mission is to free graphic designers from routine tasks so they can concentrate on their core competence – creativity. The history of internal tools for generating art at JetBrains starts about a decade ago. At first, we mainly used WebGL-based tools, which generated everything randomly in the browser on the fly (the interactive archive is available <strong><a href="https://cai.jetbrains.com/" target="_blank" rel="noopener">here</a></strong><span>). The images below were created with this approach.</span></p>
<p>Splash screens that were created using WebGL.</p>
<p>In 2020, we released our first <strong><a href="https://blog.jetbrains.com/blog/2020/09/29/intelligent-code-art/" target="_blank" rel="noopener">tool based on deep neural networks</a></strong><span>. Since then, everything has been generated in a K8s GPU cluster using PyCharm and Datalore for local and remote development. The browser is used only for input-output. With this approach based on neural networks, we’ve achieved a much higher degree of personalization, allowing us to cater to our designers’ needs, and we are constantly working to improve it.</span></p>
<p>Splash screens that were generated with neural networks.</p>

<p>CPPNs are among the simplest generative networks. They simply map pixel coordinates (x, y) to image colors (r, g, b). CPPNs are usually trained on specific images or sets of images. However, we found that randomly initialized CPPNs produce beautiful abstract patterns when the initialization is done correctly).</p>
<p>CPPN architecture: pixel coordinates are inputs, RGB values are outputs.</p>
<p>Using the usage data from an early internal version of the generator, we refined our algorithms to improve the visual quality. Aside from that, we also slightly extended the classical architecture of CPPNs by introducing multiple virtual parameters. Hence, our CPPNs now map (x, y, a, b, c, f) to (r, g, b). This simple change allows us to introduce an easy-to-use, although somewhat unpredictable, method for altering the image, as shown below.</p>
<p>By updating the virtual parameter (a), we’re slightly changing the picture.</p>
<p>These virtual parameters don’t have to be constant. For example, we can map the value of the virtual parameter f of each pixel to the distance from this pixel to the center of the image. This trick allows us to ensure the image has circular shapes. Or we could map f to the sum of the absolute values of the pixel’s coordinates, which will yield diamond-shaped patterns. This is where math actually meets art!</p>
<p>Different functions f(x,y) result in different image patterns.</p>
<p>To ensure that our randomly initialized CPPNs always produce beautiful designs, we trained a recommendation system to predict whether the given set of parameters will result in an image that looks good. We trained our algorithm from user feedback received during internal testing. The figure below shows two examples of images created by randomly initialized CPPNs and their corresponding “beautifulness” scores.</p>
<p>Predicting “beautifulness” scores of CPPN images.</p>

<p>Our CPPN-generated works of art really come to life when they are transformed into video graphics. By mapping virtual parameters (a, b, c) over any closed parametric curve (one that starts and ends at the same point), we can create seamlessly looped animations of any desired length!</p>
<p>Sample frames of a CPPN animation video.</p>
<p>The choice of a curve function is crucial. Animating virtual parameters over a plain circle is the most straightforward approach. However, it has a drawback: when the sign of a parameter changes (for example, from 0.01 to -0.01) while it has a low first derivative value (one that equals zero in the case of a circle trajectory), the result is usually a shaky animation. To account for this issue, we use <strong><a href="https://en.wikipedia.org/wiki/Lemniscate_of_Bernoulli" target="_blank" rel="noopener">Bernoulli’s lemniscate</a></strong><span> to ensure that the signs of the virtual parameters never change (see the image below). This solves the shaky animation problem, but introduces a new one. For most animation frames, one of the parameters is only incrementally updated, making the animation look too shallow. We addressed this by switching to a random spline function. The more complex the trajectories we used, the richer the animation looked!</span></p>
<p>Examples of CPPN curve functions.</p>

<p>There’s one more crucial detail: color correction. Our CPPNs – and therefore the resulting images – are randomly generated, but we need to ensure that each uses our brand colors. We tried a few different approaches to achieve this. The first iteration (<strong><a href="https://blog.jetbrains.com/blog/2020/09/29/intelligent-code-art/" target="_blank" rel="noopener">used in the 2020 releases</a></strong><span>) relied on SVG recoloring directly in the browser (using feColorMatrix and feComponentTransfer). This approach was quick – since the recoloring happened in the browser, we could update the palette without re-rendering the image on the server side. However, it was tricky to implement as some palettes are too complex for feColorMatrix and feComponentTransfer and it was generally unreliable. After extensive experimentation, we found that the resulting colors could differ depending on the browser and the operating system. Here is an example from our experiments in early 2020. On the left is a screenshot of a background of the earlier generator version made on a setup using Safari on macOS, and on the right is a screenshot of the same background but from a setup using Google Chrome on Ubuntu Linux. Notice the subtle brightness discrepancies. The more post-processing effects we applied, the more prominent they became.</span></p>
<p>An example of brightness discrepancies.</p>
<p>Another example is <strong><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feComponentTransfer" target="_blank" rel="noopener">MDN’s sample</a></strong><span> of feComponentTransfer. This time, both images were made on the same machine using Ubuntu Linux and Google Chrome, but in the top screenshot, hardware acceleration was disabled. There are prominent color discrepancies, especially between the Table lookup examples. Thus, despite being very quick, this approach to color correction was extremely inconsistent.</span></p>
<p>An example of color discrepancies.</p>
<p>Our current approach (in use since 2021) is more straightforward. We render source images in 32-bit grayscale, meaning that instead of RGB, our CPPNs return only a single luminance value. We then map each pixel to a lookup table with precomputed ideal RGB values. This approach is slower but produces pixel-perfect results.</p>
<p>An example of color correction using a grayscale image.</p>
<p><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2023/10/image9.png" alt="2020.1 splash screens" width="1200" height="800"/></p>
<p>2020.1 splash screens that used SVG recoloring.</p>
<p>When our current approach to color correction is used alongside the CPPN with virtual parameters and spline animation, the result is a video like this!</p>
<p><iframe loading="lazy" width="1200" height="800" src="https://www.youtube.com/embed/LyRNdWnbysg?si=9WMIbkeYIrVJ9ph9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p>
<p>Our CPPN-based generator is available <strong><a href="https://gradient-public.labs.jb.gg/" target="_blank" rel="noopener">here</a></strong><span>.</span></p>
<p>
    <a href="https://datalore.jetbrains.com/report/static/2jrFAfMBVhUsYW8njXgysC/9OuleGiEVhxqGen1GS9cjN" target="_blank" rel="noopener">Open Datalore notebook<br/>
</a></p>

<p>Stable Diffusion offers a high level of versatility and visual fidelity, making it a perfect backbone for our art generators. To make Stable Diffusion appropriate for use as a source of release graphics, we had to adhere to the following criteria:</p>
<ul>
<li>Images should follow the brand palette.</li>
<li>No artifacts or glitches (such as broken pixels) are allowed.</li>
<li>It should be easy to use a specific style (abstract smooth lines) out of the box.</li>
<li>It should require little to no prompting, meaning it should provide accessible and intuitive controls.</li>
</ul>
<p>Though there is always room for improvement, we’ve met all of these requirements. The latest images are <strong><a href="https://code2art.jetbrains.com/" target="_blank" rel="noopener">publicly available</a></strong><span>, and all of the technical details are below.</span></p>
<p>2023.1 splash screens created with Stable Diffusion.</p>
<p>To produce results that consistently met all of our criteria, we fine-tuned Stable Diffusion using various references provided by our designers. Below are some examples of images generated according to various styles.</p>
<p>Experimental styles obtained by fine-tuning Stable Diffusion.</p>
<p>Before diving into the technical details of the fine-tuning process, let’s look at the internals of Stable Diffusion. It essentially consists of three parts: the CLIP text encoder (a tiny transformer model used for encoding text into a multi-modal embedding space), a variational autoencoder that compresses and decompresses images to and from latent space, and the denoising UNet.</p>
<p>The architecture of Stable Diffusion. Image source: <a href="https://www.philschmid.de/stable-diffusion-inference-endpoints" target="_blank" rel="noopener">www.philschmid.de/stable-diffusion-inference-endpoints</a>.</p>
<p>The generation process is roughly as follows:</p>
<ol>
<li>We encode the prompt text into an embedding, which is a 77×768 floating-point array.</li>
<li>We randomly generate the latent representation of the image, which could be either pure Gaussian noise or a noised representation of an init image.</li>
<li>We repeatedly pass the encoded latent image and encoded text through the denoising UNet for a given number of steps.</li>
<li>After denoising the latent image, we pass it through the decoder, thus decompressing it into a standard RGB image.</li>
</ol>
<p><img decoding="async" loading="lazy" src="https://blog.jetbrains.com/wp-content/uploads/2023/10/image20.png" alt="The denoising process" width="1200" height="800"/></p>
<p>The denoising process. Image source: <a href="https://jalammar.github.io/illustrated-stable-diffusion/" target="_blank" rel="noopener">jalammar.github.io/illustrated-stable-diffusion/</a>.</p>
<p>Crucially for us, the great thing about Stable Diffusion is that it’s possible to fine-tune it with very little data and achieve great results! As a side effect, data-efficient fine-tuning methods are also computing-efficient, which makes it even better.</p>
<p>The most straightforward fine-tuning approach is textual inversion (p-tuning). We freeze all of the weights, such as UNet, VAE, and the text encoder (meaning we don’t update them during training), and only train one new word per embedding for the text encoder. Because we only train one new word per embedding, there are only 768 trainable parameters!</p>
<p>Outline of the text-embedding and inversion process. Image source: <a href="https://textual-inversion.github.io" target="_blank" rel="noopener">textual-inversion.github.io/</a>.</p>
<p>These custom embeddings are composable, meaning we could use up to 77 embeddings in a single prompt. On top of that, they are easy to train, taking ~2 hours on a single RTX 4090. Below is an example of the training process. Both of these images were generated using the prompt “digital art in the style of &lt;sculpture&gt;”, where “&lt;sculpture&gt;” is the new word embedding that we’re training. As we perform more training steps, the image evolves, and the new visual style becomes more and more pronounced.</p>
<p>The image generated with the textual inversion after 500 and 3000 training steps.</p>
<p>Another popular and efficient fine-tuning method is Low-Rank Adaptation, or simply LoRA. The key idea of LoRA is similar to textual inversion, only this time in addition to freezing the weights we also introduce new ones by adding small adapter layers to attention layers inside UNet.</p>
<p>Illustration of the LoRA method within one Transformer layer. Image source: <a href="https://adapterhub.ml/blog/2022/09/updates-in-adapter-transformers-v3-1/" target="_blank" rel="noopener">adapterhub.ml/blog/2022/09/updates-in-adapter-transformers-v3-1/</a>.</p>
<p>Compared to textual inversion, this approach makes it possible to capture more sophisticated patterns from the fine-tuning data (for example, “AI portrait” apps work by training adapter layers on the user’s face), but it uses slightly more resources and, most importantly, multiple LoRAs cannot be composed. In our specific use case, we found that LoRA is most effective when working with Stable Diffusion XL. By contrast, in earlier versions of Stable Diffusion (1.4, 1.5, or 2.1), textual inversion allows for more versatility.</p>
<p>The image generated with LoRA after 200 and 1000 training steps.</p>

<p>One of our criteria for using Stable Diffusion was the need to ensure that the generated images follow the color palette of some particular brand, and this is where CPPNs come to our aid! Before generating an image with Stable Diffusion, we generate an image with CPPN using our Gradient generator (described above), apply the desired colors with pixel-perfect accuracy, then encode it with VAE and mix it with Gaussian noise. UNet uses the resulting latent image as its starting point, thus preserving the original colors and composition.</p>
<p>CPPN → Stable Diffusion pipeline.</p>
<p>Once the CPPN image is ready, we can also edit it directly in the browser to achieve any shape and design we could ever imagine!</p>
<p>CPPN → Stable Diffusion pipeline with manually edited CPPN image.</p>
<p>Finally, once we have produced multiple images with our “CPPN → Stable Diffusion” pipeline, we can train another CPPN on those images and turn them into an animation, as described in the <em>CPPNs: Animation</em> section above! Here’s some example <strong><a href="https://www.shadertoy.com/view/DsBSW3" target="_blank" rel="noopener">GLSL code</a></strong><span>, along with some example videos:</span></p>
<p><iframe loading="lazy" width="1200" height="800" src="https://www.youtube.com/embed/videoseries?si=v2QZwkpQvh5LVSsW&amp;list=PLF5prDhdrZ1dcsmkL9AQqpkdeom7j4fLS" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe></p>
<p>The exploration and implementation of AI-powered graphics at JetBrains has been an adventure. Our tools have evolved and matured over the years, from our initial approach using WebGL-based random generation to our current use of CPPNs and Stable Diffusion to generate sleek and personalized designs. Moving forward, we anticipate greater levels of customization and versatility, and we are excited about the possibilities these technologies will unlock in the graphics generation field.</p>
<p>We hope this in-depth look into our AI art journey has been illuminating! We invite you to explore the examples we’ve provided (including our <strong><a href="https://cai.jetbrains.com/" target="_blank" rel="noopener">interactive archive</a></strong><span>) and share your feedback here in the comments or via <a href="mailto:cai@jetbrains.com">cai@jetbrains.com</a>. Please let us know what kinds of topics you would like to see from the Computational Arts team in the future!</span></p>
                    
                                                                                                                                                        <div>
                                <h4>Subscribe to Blog updates</h4>
                                
                            </div>
                            
                                                            </div>
                <a href="#"></a>
                
                
            </section>
                    
                </div></div>
  </body>
</html>
