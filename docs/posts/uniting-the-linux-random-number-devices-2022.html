<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/884875/">Original</a>
    <h1>Uniting the Linux random-number devices (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>LWN.net needs you!</b><p>Without subscribers, LWN would simply not exist.  Please consider
       <a href="https://lwn.net/subscribe/">signing up for a subscription</a> and helping
       to keep LWN publishing</p></div>
           </center>
           
<p>
Blocking in the kernel&#39;s random-number generator (RNG)—causing a process to
wait for &#34;enough&#34;
entropy to generate strong random numbers—has always been controversial.  It has also led to
various kinds of problems over the years, from timeouts and delays caused
by misuse in user-space
programs to deadlocks and other problems in the boot
process.  That behavior has undergone a number of changes over the last few
years and it looks possible that the last vestige of the difference between
merely &#34;good&#34; and &#34;cryptographic-strength&#34; random numbers may go away in some
upcoming kernel version.
</p>

<h4>Random history</h4>

<p>
The history of the kernel RNG is long and somewhat twisty; there are two
random-number devices in the kernel, <tt>/dev/random</tt> and 
<tt>/dev/urandom</tt>, that can be read in order to obtain the random
data.  <tt>/dev/urandom</tt> was always meant as the device for nearly
everything to use, as it does not block; it simply provides the best random
numbers that the kernel can provide
at the time it is read.
<tt>/dev/random</tt>, on the other hand, blocks 
whenever it does not have sufficient entropy to provide cryptographic-strength random
numbers.  That entropy comes from
sources like interrupt timing for various kinds of devices (e.g. disk,
keyboard, network) and hardware RNGs if they are available. 
<tt>/dev/urandom</tt> will log a warning message (once) if it is called before its
pool is initialized (from the <tt>random</tt> pool once it has been
initialized using gathered entropy), but it will provide output from its 
pseudorandom-number generator (PRNG) and never block.
</p>

<p>
In 2014, for Linux 3.17, the <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html"><tt>getrandom()</tt></a>
system call was added <a href="https://lwn.net/Articles/606141/">to provide a reliable
way</a> for user-space applications to 
request random numbers even in the face of file-descriptor exhaustion or
lack of access to the random devices (as might happen for an application
running in a container).
<tt>getrandom()</tt> was designed to use the <tt>urandom</tt> <i>pool</i>, but
only after it has been fully initialized from the <tt>random</tt> pool.
So, while reads to <tt>/dev/urandom</tt> do not block, calls to
<tt>getrandom()</tt> would until the requisite entropy is gathered.
<tt>getrandom()</tt> callers can choose to use the <tt>random</tt> pool via a flag, which makes
the call subject to the full entropy requirements for data coming from that pool.
</p>

<p>
In 2019, an unrelated change to the ext4 filesystem <a href="https://lwn.net/Articles/800509/">led to systems that would not boot</a> because it
reduced the number of interrupts being generated, so the <tt>urandom</tt>
pool did not get initialized and calls to <tt>getrandom()</tt> blocked.
Since those calls were made early in the boot process, the system never
came up to a point where enough entropy could be gathered, because the boot
process was waiting for <tt>getrandom()</tt> to return—thus a deadlock
resulted. 
The ext4 change was temporarily reverted for the 5.3 kernel and a <a href="https://lwn.net/Articles/802360/">more permanent solution</a> was added by Linus
Torvalds for 5.4.  It used <a href="https://lwn.net/Articles/642166/">CPU execution time jitter</a> as a source of
entropy to ensure that the <tt>random</tt> pool initialized within a
second or so.  That technique is somewhat controversial, even Torvalds is
somewhat skeptical of it, but it has been in place, and working as far as
anyone can tell, for several years now.
</p>

<p>
In 2020, the blocking nature of <tt>/dev/random</tt>  was <a href="https://lwn.net/Articles/808575/">changed</a> to behave like  <tt>getrandom()</tt>,
in that it would only block until it is initialized, once, and then 
would provide cryptographic-strength random numbers thereafter.  Andy Lutomirski, who
contributed the patches for that change, said: &#34;<q>Linux&#39;s CRNG
generates output that is good enough to use even for key generation. The
blocking pool is not stronger in any material way, and keeping it around
requires a lot of infrastructure of dubious value.</q>&#34;  Those patches
also added a <tt>GRND_INSECURE</tt> flag for <tt>getrandom()</tt> that
would return &#34;best effort&#34; random numbers even if the pool was not yet
initialized.
</p>

<p>
As can be seen, the lines between the two devices have become rather
blurrier over time. More of the history of the kernel RNG, going even
further back in time, can be found in
this <a href="https://lwn.net/Kernel/Index/#Random_numbers">LWN kernel index
entry</a>.  Given that the two devices have grown together, it is perhaps
no surprise that a new proposal, to effectively eliminate the distinction,
has been raised.
</p>

<h4>No random blocking (for long)</h4>

<p>
Jason A. Donenfeld, who <a href="https://lwn.net/ml/linux-kernel/20211130184315.258150-1-Jason@zx2c4.com/">stepped up
as a co-maintainer</a> of the kernel&#39;s RNG subsystem a few months back, has
been rather active in doing cleanups and making other changes to that code
of late.  On February 11, he <a href="https://lwn.net/ml/linux-kernel/20220211210757.612595-1-Jason@zx2c4.com/">posted</a>
an RFC—perhaps a &#34;<q>request for
grumbles</q>&#34; in truth—patch proposing the removal of the ability for
<tt>/dev/urandom</tt> to return data before the pool is initialized.  It would mean that
the kernel RNG subsystem would always block waiting to initialize, but always return
cryptographic-strength random numbers thereafter (unless the
<tt>GRND_INSECURE</tt> flag to <tt>getrandom()</tt> is used).  Because of
the changes made by Torvalds 
in 5.4, which Donenfeld calls the &#34;<q>Linus Jitter
Dance</q>&#34;, the maximum wait for initialization is minimal, so Donenfeld
suggested the change:
</p><blockquote>
So, given that the kernel has grown this mechanism for seeding itself
from nothing, and that this procedure happens pretty fast, maybe there&#39;s
no point any longer in having /dev/urandom give insecure bytes. In the
past we didn&#39;t want the boot process to deadlock, which was
understandable. But now, in the worst case, a second goes by, and the
problem is resolved. It seems like maybe we&#39;re finally at a point when
we can get rid of the infamous &#34;urandom read hole&#34;.
</blockquote>


<p>
There are some potential hurdles to doing so, however.  The jitter entropy
technique relies on differences in timing when running the same code, which
requires both a high-resolution CPU cycle counter and a CPU that appears to be
nondeterministic (due to caching, instruction reordering, speculation, and
so on).  There are some architectures that do not provide that, however, so
no entropy can be gathered that way.  Donenfeld noted that non-Amiga m68k
systems, two MIPS models (R6000 and R6000A), and, possibly, RISC-V would be
affected; he wondered if there were other similarly affected architectures out there.
He believes that the RISC-V code is not truly a problem, however, and no one
has yet spoken up to dispute that.
Meanwhile, setting those others aside might be the right approach:
</p><blockquote>
If my general analysis is correct, are these ancient platforms really
worth holding this back? I halfway expect to receive a few thrown
tomatoes, an angry fist, and a &#34;get off my lawn!&#34;, and if that&#39;s _all_ I
hear, I&#39;ll take a hint and we can forget I ever proposed this. As
mentioned, I do not intend to merge this unless there&#39;s broad consensus
about it. But on the off chance that people feel differently, perhaps
the Linus Jitter Dance is finally the solution to years of /dev/urandom
kvetching.
</blockquote>


<p>
The proposed patch was fairly small; it simply eliminated the
<tt>file_operations</tt> struct for <tt>/dev/urandom</tt> and reused the
one for <tt>/dev/random</tt> in its place, thus making the two devices
behave identically.  It also shorted out the
behavior of the <tt>GRND_INSECURE</tt> flag, but he later <a href="https://lwn.net/ml/linux-kernel/CAHmME9pkhqjLtwn2kt5SkSWBQ9UW+2WLGL9momZUmY3L2wDryQ@mail.gmail.com/">said</a>
that was something of a distraction.  The main intent of his proposal was
to do the following:
</p><blockquote>
Right now, we have:
<pre>/dev/random = getrandom(0)
/dev/urandom = getrandom(GRND_INSECURE)
</pre>
This proposal is to make that:
<pre>/dev/random = getrandom(0)
/dev/urandom = getrandom(0)
</pre>
</blockquote>


<p>
Torvalds had a <a href="https://lwn.net/ml/linux-kernel/CAHk-=wh+2jokbr4tpHA=ExebWKr=qp9RJ_uFrG2gYG4ChAjitg@mail.gmail.com/">positive
response</a>
to the RFC.  He said that the patch makes sense for architectures that have
a cycle counter; the jitter entropy change has been active for
two-and-a-half years without much complaint, so &#34;<q>I think we can call
that thing a success</q>&#34;.  There may have been a few complaints about it,
but: &#34;<q>Honestly, I think all the complaints would have been from the
theoretical posers that don&#39;t have any practical suggestions
anyway</q>&#34;.   Torvalds is known to have little patience for <a href="https://lwn.net/Articles/828705/">theoretical concerns about cryptography</a> (or
theoretical concerns about anything else, in truth). 
</p>

<p>
He did object to removing <tt>GRND_INSECURE</tt> for architectures that
cannot do the jitter dance, since it is a way for user space to work around
the lack of boot-time entropy, even if it is not at all secure:
</p><blockquote>
Those systems are arguably broken from a randomness standpoint - what
the h*ll are you supposed to do if there&#39;s nothing generating entropy
- but broken or not, I suspect they still exists. Those horrendous
MIPS things were quite common in embedded networking (routers, access
points - places that *should* care)
<p> [...] And almost nobody tests those broken platforms: even people who build
new kernels for those embedded networking things probably end up using
said kernels with an existing user space setup - where people have
some existing saved source of pseudo-entropy. So they might not ever
even trigger the &#34;first boot problem&#34; that tends to be the worst case.
</p></blockquote>


<p>
But, he said, he would be willing to apply the patch: &#34;<q>at some point &#39;worry
about broken platforms&#39; ends up being too weak an excuse not to just
apply it</q>&#34;. <a href="https://lwn.net/ml/linux-kernel/fcab986b-d0bd-c798-de17-266abcdc7da2@gentoo.org/">According to Joshua Kinard</a>, the two MIPS models in
question were from the 1980s, not ever used in systems, and the kernel test
for them in the random code &#34;<q>was probably added as a mental exercise following a
processor manual or such</q>&#34;.  Maciej W. Rozycki <a href="https://lwn.net/ml/linux-kernel/alpine.DEB.2.21.2202122309560.34636@angie.orcam.me.uk/">said</a>
that there may have been a few systems using those models, but no Linux
port was ever made for them.  That might mean that the only problem systems
are &#34;<q>some m68k
museum pieces</q>&#34;, Donenfeld <a href="https://lwn.net/ml/linux-kernel/CAHmME9ooEbgiv3DRk87ei+rUoVNMJthY7UuG_xCgm=kfMZAajw@mail.gmail.com/">said</a>. 
</p>

<p>
As Geert Uytterhoeven <a href="https://lwn.net/ml/linux-kernel/CAMuHMdXDj+BVCs4Syg39vjnHGKcwJnCgDxrGoOiEFM_T4ojwPg@mail.gmail.com/">pointed
out</a>, though, the cycle-counter code for the Linux generic architecture,
which is the default and starting point for new architectures, is hardwired
to return zero. &#34;<q>Several architectures do not implement get_cycles(), or implement it
with a variant that&#39;s very similar or identical to the generic
version.</q>&#34;  David Laight <a href="https://lwn.net/ml/linux-kernel/63afd299c8df4495b27456a7f92aec75@AcuMS.aculab.com/">added</a>
a few examples (old x86, nios2) of architectures where that is the case. 
</p>

<h4>But what about my NetHack machine?</h4>

<p>
Lutomirski had a more prosaic <a href="https://lwn.net/ml/linux-kernel/fbdd43e1-a305-48d1-8ccb-2deffcb715f7@www.fastmail.com/">complaint</a>:
</p><blockquote>
I dislike this patch for a reason that has nothing to do with
security. Somewhere there’s a Linux machine that boots straight to Nethack
in a glorious 50ms.  If Nethack gets 256 bits of amazing entropy from
/dev/urandom, then the machine’s owner has to play for real. If it repeats
the same game on occasion, the owner can be disappointed or amused. If it
gets a weak seed that can be brute forced, then the owner can have fun
brute forcing it.
<p>
If, on the other hand, it waits 750ms for enough jitter entropy to be
perfect, it’s a complete fail.  No one wants to wait 750ms to play
Nethack. 
</p></blockquote>


<p>
More seriously, he was concerned about devices like backup cameras or
light bulbs that need to boot &#34;immediately&#34;, and where the quality of the
random numbers may not truly be a problem.  The <tt>GRND_INSECURE</tt>
escape hatch is there for just that reason.  In a similar vein, Lennart
Poettering was <a href="https://lwn.net/ml/linux-kernel/YgoYnX97imub7KEB@gardel-login/">worried</a> that
systemd would have to wait one second to get a seed for its hash tables,
when it already has a mechanism to reseed the tables:
</p><blockquote>
So, systemd uses (potentially half-initialized) /dev/urandom for
seeding its hash tables. For that its kinda OK if the random values
have low entropy initially, as we&#39;ll automatically reseed when too
many hash collisions happen, and then use a newer (and thus hopefully
better) seed, again acquired through /dev/urandom. i.e. if the seeds
are initially not good enough to thwart hash collision attacks, once
the hash table are actually attacked we&#39;ll replace the seeds with
[something] better. For that all we need is that the random pool
eventually gets better, that&#39;s all.
</blockquote>


<p>
It turns out that systemd is <a href="https://lwn.net/ml/linux-kernel/Ygps2W6MfxKkP5eD@gardel-login/">already using
<tt>GRND_INSECURE</tt></a> on systems where it is available, so not
changing that behavior, as was originally proposed, would neatly fix Poettering&#39;s
concern.  Donenfeld was completely amenable to <a href="https://lwn.net/ml/linux-kernel/YgpjfncV+C9FEZDc@zx2c4.com/">pulling the disabling of
<tt>GRND_INSECURE</tt></a> from his patch; it is not really his
primary focus with the proposal, as noted.
</p>

<p>
Based on Torvalds&#39;s response, it would seem there are no huge barriers to
removing the final distinction between <tt>/dev/random</tt> and
<tt>/dev/urandom</tt>—other than the names, of course. If there are more
architectures that cannot use the jitter technique, though, that
distinction may live on, since Torvalds also thought there might be value
in keeping &#34;<q>the stupid stuff around as a &#39;doesn&#39;t hurt good platforms, might
help broken ones&#39;</q>&#34;.  The code removal would not be huge, so it does
not really provide much of a code simplification, Donenfeld said; it is
more a matter of being able to eliminate the endless debate about
which source of randomness to use on Linux.  To that end, it seems like a
worthwhile goal.
</p></div></div>
  </body>
</html>
