<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1039073/">Original</a>
    <h1>Upcoming Rust language features for kernel development</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
The
<a href="https://rust-for-linux.com/">
Rust for Linux</a> project has been good for Rust, Tyler Mandry, one of the
co-leads of Rust&#39;s language-design team, said. He
gave a talk at
<a href="https://kangrejos.com/">
Kangrejos 2025</a> covering upcoming Rust language features and thanking
the Rust for Linux developers for helping drive them forward. Afterward, Benno Lossin and Xiangfei Ding
went into more detail about their work on the three most important language
features for kernel development: field projections, in-place initialization, and arbitrary self types.
</p>

<p>
Many people have remarked that the development of new language features in Rust
can be quite slow, Mandry said. Partly, that can be attributed to the care the
Rust language team takes to avoid enshrining bad designs. But the biggest reason
is &#34;<q>alignment in attention</q>&#34;. The Rust project is driven by volunteers,
which means that if there are not people focusing on pushing a given feature or
group of related features forward, they languish. The Rust for Linux project has
actually been really helpful for addressing that, Mandry explained, because it
is something that a lot of people are excited about, and that focuses effort
onto the few specific things that the Linux kernel needs.
</p>

<p><a href="https://maryrosecook.com/Articles/1040419">
<img src="https://static.lwn.net/images/2025/tyler-mandry-kangrejos-small.png" alt="[Tyler Mandry]" title="Tyler Mandry"/>
</a></p><p>
Mandry then went through a whirlwind list of upcoming language features,
including
<a href="https://github.com/Skepfyr/rfcs/blob/extern-types-v2/text/3396-extern-types-v2.md">
types without known size information</a>,
<a href="https://github.com/joshtriplett/rfcs/blob/use/text/3680-use.md">
reference-counting improvements</a>,
<a href="https://internals.rust-lang.org/t/pre-pre-rfc-generic-effect-system-for-functions/22550?utm_source=chatgpt.com">
user-defined function modifiers of the same kind as <tt>const</tt></a>, and more.
At the end, he asked which of those were most
important to Rust for Linux, and how the assembled kernel developers would
prioritize them. Beyond the three features to be discussed later,
Lossin said that the project definitely wanted the ability to
write functions that can be evaluated at compile time (called
<a href="https://doc.rust-lang.org/std/keyword.const.html#compile-time-evaluable-functions">
<tt>const</tt>
functions</a> in Rust) in trait definitions.
Danilo Krummrich asked for
<a href="https://github.com/rust-lang/rust/issues/31844">
specialization</a>, which immediately
prompted an &#34;<q>Oh no!</q>&#34; from Lossin, due to the feature&#39;s nearly decade-long
history of causing problems for Rust&#39;s type system. Specialization would allow
two overlapping implementations for a single trait to exist, with the compiler
picking the more specific one. Matthew Maurer asked for some ability to control
what the compiler does on integer overflow.
</p>

<p>
Ultimately, Miguel Ojeda told Mandry that the priority should be on stabilizing the
unstable language features that Rust for Linux currently uses, followed by
language features that would change how the project structures its code, followed by
everything else. The next two talks went into much more detail about the current
status and future plans for some of those key language features.
</p>

<!-- middle-ad -->

<h4>Field projections</h4>

<p>
Field
projection refers to the idea of taking a pointer to a structure, and turning it
into a pointer to a field of the structure. Rust does already have this for the
built-in reference and pointer types, but it can&#39;t always be made to work for
user-defined smart-pointer types. Since the Rust for Linux developers would like
to have custom smart pointers to handle
<a href="https://maryrosecook.com/Articles/1034603/">
untrusted data</a>, reference counting,
external locking, and related kernel complications, they would benefit from a
general language feature allowing field projections for all pointer types using
the same syntax.
Lossin spoke about his work on the problem, which has been ongoing
since Kangrejos 2022. There has been &#34;<q>lots of progress</q>&#34; so far, but the
work is still in the design stage, with a few details left to work out.
</p>

<p>
The built-in field projections all have the same kind of type signature, Lossin
explained. For example, the code for
converting a reference to an object into a reference to one of its
fields and the code for
converting a raw pointer to an object into a raw pointer to one of its fields
look different, but have similar signatures:
</p>

<pre>    fn project_reference(r: &amp;MyStruct) -&gt; &amp;Field {
        &amp;r.field
    }

    unsafe fn project_pointer(r: *mut MyStruct) -&gt; *mut Field {
        unsafe { &amp;raw mut (*r).field }
    }

    // The equivalent C code would look like this:
    struct field *project(struct my *r) {
        return &amp;(r-&gt;field);
    }
</pre>

<p>
This example uses the relatively recent
<a href="https://github.com/rust-lang/rfcs/blob/master/text/2582-raw-reference-mir-operator.md">
raw borrow</a> syntax.
</p>

<p>
The
<a href="https://rust.docs.kernel.org/core/pin/struct.Pin.html">
<tt>Pin</tt></a> type throws a bit of a wrench into things.
The Rust
compiler is, by default, free to move structures around for performance reasons.
That doesn&#39;t work when the structure is being referenced from the C side, so the
<tt>Pin</tt> type is used to mark structures that shouldn&#39;t be moved.
Projecting a
<s><tt>Pin&lt;MyStruct&gt;</tt></s> <tt>Pin&lt;&amp;mut MyStruct&gt;</tt>
[Lossin sent LWN a correction: <tt>Pin</tt> is always used to wrap a pointer
type, not a structure directly]
might produce either a <tt>Pin&lt;&amp;mut Field&gt;</tt> or a
plain <tt>&amp;mut Field</tt> depending on whether the field is also of a type that
shouldn&#39;t be moved or not. So the most general possible signature for the field projection operation
would be something like this, Lossin said:
</p>

<pre>    Container&lt;&#39;a, Struct&gt; -&gt; Output&lt;&#39;a, Field&gt;
</pre>

<p>
That is, given some pointer type that wraps a structure and must be valid for
lifetime <tt>a</tt>, projecting a field gives a (possibly different) output
pointer type wrapping a field of that structure, valid for the same lifetime.
Lossin then gave an example of how supporting this could make fully implementing
read-copy-update (RCU)
support in the kernel&#39;s Rust bindings a lot easier.
</p>

<p><a href="https://maryrosecook.com/Articles/1040419#benno">
<img src="https://static.lwn.net/images/2025/benno-lossin-kangrejos-small.png" alt="[Benno Lossin]" title="Benno Lossin"/>
</a></p><p>
The RCU mechanism protects readers from concurrent writers, he explained, but it
doesn&#39;t protect writers from each other. It&#39;s somewhat common in the kernel, therefore,
to have a mutex protecting some data, with a frequently accessed
field of that data being protected by RCU. That way, readers rely on the RCU
lock (which is cheap), and writers synchronize with each other using the mutex.
Translating that interface to Rust poses problems: Rust doesn&#39;t allow any access
to the content inside a
<a href="https://rust.docs.kernel.org/kernel/sync/lock/mutex/type.Mutex.html">
<tt>Mutex</tt></a> without locking it first, so the
straightforward translation of this pattern wouldn&#39;t work. It would force Rust
readers to lock the mutex in order to read the RCU field, which would be an
unacceptable performance hit.
</p>

<p>
With generalized field projection in the language, though, the Rust for Linux
developers could write bindings that permit projecting a
<tt>&amp;Mutex&lt;MyStruct&gt;</tt> into an <tt>&amp;Rcu&lt;Field&gt;</tt> without holding
the lock. In driver code, attempting to read from the RCU-protected field
would look like a normal access, the same way it is in C — but the compiler
would still check that the other, non-RCU-protected data isn&#39;t touched without
holding the mutex.
</p>

<p>
Lossin ended by asking the assembled developers to keep an eye on
<a href="https://github.com/rust-lang/rust/pull/146307">the tracking issue</a>
for the feature, and provide feedback on it. Daniel Almeida asked whether
testing the feature outside the mainline kernel was really helpful; Ojeda
affirmed that it was, because that makes it easier to go to the Rust team and
make a case to stabilize the feature. The Rust for Linux project is trying not
to use any new unstable features (and to compile with a version of Rust equal to
or older than the version
packaged on Debian stable), so the feature needs to be completed and make it
into Debian 14 (expected in 2027) before it will be widely usable in kernel code.
</p>

<p>
Andreas Hindborg asked: &#34;<q>Can we have this yesterday, please?</q>&#34;, to general
amusement. The kernel&#39;s Rust bindings already feature a plethora of custom
pointers encoding various invariants; this feature, whenever it becomes
available to kernel code, may make them a good deal easier to use in driver code.
</p>

<h4>Arbitrary self types</h4>

<p>
Ding gave an update immediately afterward about another ergonomic language
feature for custom pointers: arbitrary self types. In Rust, a method on a type
can have a first argument that is an object of the type or that is a reference
to one.
Such a method can be called with the <tt>.method()</tt> syntax, instead of the
more general <tt>Type::function()</tt> syntax. But the proliferation of smart
pointers in kernel Rust code means that the programmer frequently does not have
a plain reference; often, they instead have a
<tt>Pin</tt>, an
<a href="https://rust.docs.kernel.org/kernel/sync/struct.Arc.html">
<tt>Arc</tt></a>,
or some other smart-pointer type.
</p>

<p>
The arbitrary self types proposal that Ding has been working on would let
programmers write methods that take smart pointers, instead of normal references:
</p>

<pre>    impl MyStruct {
        fn method(self: Pin&lt;&amp;mut MyStruct&gt;) {}
    }
</pre>

<p>
Unfortunately, adding this to the compiler has not proved to be straightforward.
The interaction with  Rust&#39;s existing
<a href="https://rust.docs.kernel.org/core/ops/trait.Deref.html">
<tt>Deref</tt> trait</a>, which makes custom smart pointers possible in the first
place, complicates the implementation because not all of the type information is
available while searching for matching methods. Currently, if the user has a
<tt>Pin&lt;&amp;mut MyStruct&gt;</tt> and they call a method on it, the compiler
will first look for a matching method for <tt>Pin</tt>. If one isn&#39;t found, it
will try to dereference the type, producing a <tt>&amp;mut MyStruct</tt>. That
type is checked for matching methods, and then
is dereferenced one final time, producing a <tt>MyStruct</tt>. That type will
finally have a matching method, or else the compiler will emit a type error.
</p>

<p><a href="https://maryrosecook.com/Articles/1040419#xiangfei">
<img src="https://static.lwn.net/images/2025/xiangfei-ding-kangrejos-small.png" alt="[Xiangfei Ding]" title="Xiangfei Ding"/>
</a></p><p>
By the time that procedure begins checking functions associated with
<tt>MyStruct</tt>, it will have already discarded information about the wrapping
types, which an implementation of arbitrary self types needs.
Ding spent a few minutes explaining the approaches for
rectifying the problem that he had tried and discarded, before focusing on the
current approach. He has added another trait — tentatively called
<tt>Receiver</tt> — that is used to mark types that can be used with arbitrary
self types. Then the compiler can try following the chain of <tt>Receiver</tt>
implementations before following the chain of <tt>Deref</tt> implementations.
That does mean that a pointer type will have to opt into being used as an arbitrary
self type, but Ding didn&#39;t see that as a downside. Letting the author of a
pointer type decide when it should support the new feature eliminates a lot of
concerns around accidentally introducing backward compatibility problems. For
the kernel, it doesn&#39;t really impose a barrier, because the Rust developers can
just add <tt>Receiver</tt> implementations as they run across cases that require
them.
</p>

<p>
Ojeda asked how long Ding thought it would take to finalize the arbitrary self
types feature; in particular, would it be ready within a year? Ding agreed that
a year was possible, although he would need support from the Rust language team
in order to make that happen. He wants to run
<a href="https://github.com/rust-lang/crater?tab=readme-ov-file#crater">
Crater</a>, the tool that the Rust
community uses to check whether compiler changes break any published Rust
libraries, against his change before submitting the code. Ojeda offered help with
obtaining a large build machine to do that, since Ding has had trouble previously
with the memory requirements to compile some packages during a Crater run.
</p>

<h4>In-place initialization</h4>

<p>
The other topic that Ding wanted to cover was his work on in-place
initialization. Like the other new language features being discussed, this
doesn&#39;t really enable new use cases, but it does make common kernel code
cleaner. Currently, Rust code in the kernel uses the
<a href="https://rust.docs.kernel.org/kernel/prelude/macro.pin_init.html">
<tt>pin_init!()</tt> macro</a>
to create structures that are fixed in place after initialization (by being
wrapped in <tt>Pin</tt>).
</p>

<p>
There&#39;s nothing wrong with <tt>pin_init!()</tt>: &#34;<q>We love <tt>pin_init!()</tt>! We
want to make a language feature out of it.</q>&#34; Adopting a language feature for
in-place initialization would also help with a handful of sharp edges outside
kernel code; it could make creating large
<a href="https://rust.docs.kernel.org/core/future/trait.Future.html">
<tt>Future</tt></a> values on the heap
more ergonomic, and let some traits become
<a href="https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility">
dyn-compatible</a>. The exact design of
this language feature was more up in the air; Ding covered three different
proposals for how it could work.
</p>

<p>
The simplest, proposed by Alice Ryhl and Lossin, would be to add a new
keyword, <tt>init</tt>, before a structure-initializing expression in order to ask
the compiler to automatically write an
implementation of the kernel&#39;s
<a href="https://rust.docs.kernel.org/kernel/prelude/trait.PinInit.html">
<tt>PinInit</tt> trait</a>. That has the nice
benefit of being a fairly minimal change to the language, although it would lock
in the use of the <tt>PinInit</tt> trait in its current form.
</p>

<p>
Another solution,
<a href="https://hackmd.io/@rust-lang-team/r1zNmpwwgl#In-place-initialization-via-outptrs">
proposed</a> by Taylor Cramer, would introduce a new type of
reference into the language. Rust&#39;s existing references can either be read from
(<tt>&amp;</tt>) or read from and written to (<tt>&amp;mut</tt>). This proposal
would add a third type, <tt>&amp;out</tt>, that can only be written to, not read
from. The only way to use an <tt>&amp;out</tt> reference would be to
either write to it, or use projection to break it apart into multiple
<tt>&amp;out</tt> references to various fields. Under this scheme, in-place
initialization would look like allocating space on the heap, and then returning
an <tt>&amp;out</tt> reference. The calling code could then fill it in however
it wants to, potentially passing off sub-parts to other functions. The compiler
would track that the <tt>&amp;out</tt> references
are all used before allowing the code to obtain a
normal <tt>&amp;mut</tt> reference to the heap allocation.
</p>

<p>
That proposal was considerably less polished than Ryhl and Lossin&#39;s approach,
however. Ding later told me that he, Mandry, and other compiler contributors at
Kangrejos were actually working on figuring out how it
would interact with some of the Rust compiler&#39;s internals in between talks that
day. By the end of the conference, they had a rough idea of how it could be
implemented, so a more detailed version of the out-pointer proposal may be
forthcoming shortly.
</p>

<p>
The final design, taking inspiration from C++, would be a form of guaranteed
optimization, where constructing a new value and then immediately moving it to
the heap causes it to be constructed on the heap in the first place. Ding was
less sure about the details of the final proposal; he suggested that the best
way forward might be to implement both the <tt>PinInit</tt> proposal and the
out-reference proposal, and see how well each approach works in practice.
</p>

<p>
Regardless of which approach ends up being chosen, it seems clear that Mandry&#39;s
point about the Rust for Linux project driving language improvement is
correct. While these features are in the early stages, adopting them could
significantly simplify code involving user-defined smart pointers, both within
and outside the kernel.
</p>

<p>
<b>Update:</b> Since the talks described in this article, the work on field
projection has received an update. Lossin wrote in to inform LWN that all fields
of all structures are now considered structurally pinned, so projecting a
<tt>Pin</tt> will now always produce a <tt>Pin&lt;&amp;mut Field&gt;</tt> or
similar value.
</p></div></div>
  </body>
</html>
