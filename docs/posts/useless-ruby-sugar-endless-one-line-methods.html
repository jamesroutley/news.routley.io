<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zverok.space/blog/2023-12-01-syntax-sugar5-endless-methods.html">Original</a>
    <h1>&#34;Useless Ruby sugar&#34;: Endless (one-line) methods</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <blockquote>
  <p>This is a part of a blog post series about “useless” (or: controversial) syntax elements that emerged in recent Ruby version. The goal of the series is not to defend (or criticize) the features, but to share a “thought framework” for analysis of their reasons, design, and effect the new syntax has on a code that uses it. See also <a href="https://zverok.space/blog/2023-10-02-syntax-sugar.html">intro/ToC post</a>.</p>
</blockquote>

<p>Today’s post covers the feature that was one of the most divisive in the community (sometimes even more so than <a href="https://zverok.space/blog/2023-10-20-syntax-sugar2-pattern-matching.html">numbered block parameters</a>): <strong>one-line method definitions</strong>.</p>

<h2 id="what">What</h2>

<p>The usual Ruby method is defined like this:</p>
<div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>args</span><span>)</span>
  <span>body</span>
<span>end</span>
</code></pre></div></div>

<p>Since <a href="https://rubyreferences.github.io/rubychanges/3.0.html#endless-method-definition">Ruby 3.0</a>, this alternative syntax is also allowed for methods consisting of exactly one statement:</p>

<div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>args</span><span>)</span> <span>=</span> <span>body</span>
</code></pre></div></div>

<h2 id="why">Why</h2>

<p>Ruby is one of the rare mainstream languages that doesn’t have C-like <code>{}</code> as its base code blocks wrapping punctuation. It also doesn’t use  significant whitespaces to designate where the code block ends, unlike Haskell or Python. (Almost) every construct ends with <code>end</code>, like in Pascal or Lua.</p>

<div><div><pre><code><span>if</span> <span>condition</span>
  <span># ...body...</span>
<span>end</span>

<span>items</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>item</span><span>|</span>
  <span># ...body...</span>
<span>end</span>

<span>class</span> <span>C</span>
  <span># ...</span>

  <span>def</span> <span>m</span>
    <span># ...</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>This is mostly OK to type, and a modern IDE might do that for you, but when the body and the header of the code block are tiny, the syntax might feel bulky (“feel bulky” is very imprecise here, but we’ll get to more concrete reasons soon).</p>

<p>Most of the code constructs have more compact versions, though—and not just mechanically compact, but expressing small and simple things a bit differently:</p>

<div><div><pre><code><span>return</span> <span>[]</span> <span>if</span> <span>denied?</span>

<span>items</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>item</span><span>|</span> <span>process</span><span>(</span><span>item</span><span>)</span> <span>}</span>

<span># Produce a body-less class, just to designate a new type of exception</span>
<span>MyError</span> <span>=</span> <span>Class</span><span>.</span><span>new</span><span>(</span><span>NetworkError</span><span>)</span>
</code></pre></div></div>

<p>…but not methods! There is only one way to write them.</p>

<p>One <em>could’ve</em> forced methods to fit into one line using <code>;</code>:</p>

<div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>args</span><span>);</span> <span>body</span><span>;</span> <span>end</span>
</code></pre></div></div>

<p>However, the views of the Ruby community developed in the way that using <code>;</code> is deemed bad taste: it is a sign that you are cramming too much—several logical <strong>phrases</strong>—into one line<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<blockquote>
  <p><strong>UPD:</strong> As it was pointed by several people in comments, this actually works without <code>;</code>:</p>

  <div><div><pre><code><span>def</span> <span>my_method</span><span>(</span><span>args</span><span>)</span> <span>body</span> <span>end</span>
</code></pre></div>  </div>

  <p>What can I say! Once in a while, I forget how to Ruby :) This does <em>not</em> make the argument invalid (this way of writing methods is still frowned upon and never used; and still, reads like “several phrases”), but it probably should’ve been centered around the community’s view at <code>;</code>.</p>
</blockquote>

<p>Many languages were forced to invent shortcuts for one-expression functions when function iteration became mainstream, going, in JS’s case, from <code>function(arg) { return val }</code> to <code>arg =&gt; val</code>. But Ruby already had code blocks for that, so no evolution for methods syntax was necessary<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<hr/>

<p>“But why would a <em>small syntax non-optimality</em> matter?”—one might ask. (And, depending on the mood, mention code golf as a main association for the “whether it can be put in one line” question.)</p>

<p>Throughout this series, I talk a lot about the comfort of a reader and the perception of the code as a continuous narrative. In this context, “how much of it fits in one page” matters. This doesn’t mean that cramming everything into tight subsequent paragraphs, like a serious book, is a good idea: code isn’t supposed to be primarily read paragraph-by-paragraph.</p>

<p>On the other hand, a two-words-per-line, twenty-words-per-page nursery rhyme-like layout means that one might need to scroll through dozens of pages to get “what’s this all about.”</p>

<p>I imagine a good code layout somewhat like an entertainment printed magazine: reasonably short articles, a lot of breathing space, pull quotes, lists, and schemas to emphasize and draw attention to various parts, removing small details to footnotes, and so on. (Of course, our layouting tools are different, but the effects to achieve are frequently the same.)</p>

<p>But the only pre-Ruby 3.0 syntax for methods turned many of them into nursery-rhyme style text:</p>

<div><div><pre><code><span># A small value object encapsulating a word in text-processing algorithm:</span>
<span>class</span> <span>Word</span>
  <span>attr_reader</span> <span>:text</span>

  <span>def</span> <span>initialize</span><span>(</span><span>text</span><span>)</span>
    <span>@text</span> <span>=</span> <span>text</span>
  <span>end</span>

  <span>def</span> <span>inspect</span>
    <span>&#34;#&lt;</span><span>#{</span><span>self</span><span>.</span><span>class</span><span>}</span><span> </span><span>#{</span><span>text</span><span>}</span><span>&gt;&#34;</span>
  <span>end</span>

  <span>def</span> <span>==</span><span>(</span><span>other</span><span>)</span>
    <span>other</span><span>.</span><span>is_a?</span><span>(</span><span>Word</span><span>)</span> <span>&amp;&amp;</span> <span>text</span> <span>==</span> <span>other</span><span>.</span><span>text</span>
  <span>end</span>

  <span>def</span> <span>&lt;</span><span>=&gt;</span><span>(</span><span>other</span><span>)</span>
    <span>text</span> <span>&lt;=&gt;</span> <span>other</span><span>.</span><span>text</span> <span>if</span> <span>other</span><span>.</span><span>is_a?</span><span>(</span><span>Word</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>punctuation?</span>
    <span>text</span><span>.</span><span>match?</span><span>(</span><span>/^[[:punct:]]+$/</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>capitalized?</span>
  <span># ...and so on, I just started!</span>
</code></pre></div></div>

<p>It might be a “value object” fully consisting of such small methods, like shown above<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>, or a few small methods in a larger object (<code>#inspect</code>, trivial predicates, <code>#to_h</code>, this kind of stuff), the problem stays the same: a page or several pages of context might be easily eaten by code with saying “Hello, my name is Jane”-level things.</p>

<p>An unspoken consequence of this situation is that people start to avoid “adding unnecessary (but useful!) stuff” like convenience methods or whole convenience objects because it was “just that small thing” in your head and two pages of code in reality.</p>

<p>So… Can those small helper methods become shorter?</p>

<h2 id="how">How</h2>

<p>The solution was born as an April’s Fool joke.</p>

<p>There is a long-standing tradition of proposing absurd features once a year (here are <a href="https://bugs.ruby-lang.org/issues?utf8=%E2%9C%93&amp;op%5Bstatus_id%5D=*&amp;f%5B%5D=issue_tags&amp;op%5Bissue_tags%5D=%3D&amp;v%5Bissue_tags%5D%5B%5D=joke">some</a> selected by a tag, but I think there were many more before). The proposal is frequently supplemented with a dead-serious justification; dedicated jokers frequently provide a patch to the language proving the change is possible. A good-natured discussion arises, with other tracker participants alternating between those who haven’t noticed the date or felt the absurdity and those who support the joke by discussing syntax details or submitting equally absurd counter-proposal.</p>

<p><a href="https://bugs.ruby-lang.org/issues/16746">Yusuke Endoh’s proposal of 2020</a>, though, was stated in an emphatically unserious tone:</p>

<blockquote>
  <p>Ruby syntax is full of “end”s. I’m paranoid that the ends end Ruby. I hope Ruby is endless.</p>

  <p>So, I’d like to propose a new method definition syntax.</p>

  <div><div><pre><code><span>def: </span><span>value</span><span>(</span><span>args</span><span>)</span> <span>=</span> <span>expression</span>
</code></pre></div>  </div>
</blockquote>

<p>What happened next was somewhat singular. Matz (Ruby’s BDFL) left a comment:</p>

<blockquote>
  <p>I totally agree with the idea <strong>seriously</strong> […] but don’t like the syntax.</p>
</blockquote>

<p>And so it happened.</p>

<p>A more natural syntax</p>

<div><div><pre><code><span>def</span> <span>value</span><span>(</span><span>args</span><span>)</span> <span>=</span> <span>expression</span>
</code></pre></div></div>

<p>was initially considered impossible, but stellar @nobu (Nobuyoshi Nakada) <a href="https://github.com/ruby/ruby/pull/2996">implemented it</a> in one night. (Apparently, this still required a lot of careful juggling with the parser: some limitations the new syntax brought were <a href="https://rubyreferences.github.io/rubychanges/3.1.html#inside-endless-method-definitions-method-calls-without-parenthesis-are-allowed">resolved</a> only in the next version, and some nasty quirks are still remaining and discussed below.)</p>

<p>So, there are times when a lighthearted joke might produce an important change to the language (and give it a goofy name: “endless method” is still its semi-official moniker, frequently used on the tracker, though <a href="https://docs.ruby-lang.org/en/3.2/syntax/methods_rdoc.html">in docs</a>, it is referred to as “shorthand method syntax”).</p>

<h2 id="irks-and-quirks">Irks and quirks</h2>

<p>One confusing and unintended problem with one-line methods is related to non-obvious parsing priorities:</p>

<div><div><pre><code><span>class</span> <span>Test</span>
  <span>def</span> <span>initialize</span><span>(</span><span>active</span><span>)</span>
    <span>@active</span> <span>=</span> <span>active</span>
  <span>end</span>

  <span>def</span> <span>invoke</span> <span>=</span> <span>puts</span> <span>&#34;works&#34;</span> <span>if</span> <span>@active</span>
<span>end</span>
<span># Trying to use it</span>
<span>Test</span><span>.</span><span>new</span><span>(</span><span>true</span><span>).</span><span>invoke</span>
</code></pre></div></div>

<p>Instead of printing <code>&#34;works&#34;</code> at the last line execution, this code will fail with a confusing message “ undefined method `invoke’”. That’s because of the aforementioned confusing parsing order:</p>
<div><div><pre><code><span># Expected:</span>
<span>def</span> <span>print</span> <span>=</span> <span>(</span><span>puts</span> <span>&#34;works&#34;</span> <span>if</span> <span>@active</span><span>)</span>

<span># Real:</span>
<span>(</span><span>def</span> <span>print</span> <span>=</span> <span>puts</span> <span>&#34;works&#34;</span><span>)</span> <span>if</span> <span>@active</span>
</code></pre></div></div>

<p>This is most definitely an unintended behavior, and one that apparently incredibly hard to fix, so the discussion is <a href="https://bugs.ruby-lang.org/issues/19392">still ongoing</a>.</p>

<p>As usual with syntax quirks, parentheses help!</p>

<div><div><pre><code><span># This will work as intended</span>
<span>def</span> <span>print</span> <span>=</span> <span>(</span><span>puts</span> <span>&#34;works&#34;</span> <span>if</span> <span>@active</span><span>)</span>
</code></pre></div></div>

<p>Another example of the parsing problem:</p>

<div><div><pre><code><span># valid</span>
<span>def</span> <span>initialize</span><span>(</span><span>one_value</span><span>)</span> <span>=</span> <span>@one_value</span> <span>=</span> <span>one_value</span>

<span># throws syntax error:</span>
<span>def</span> <span>initialize</span><span>(</span><span>two</span><span>,</span> <span>values</span><span>)</span> <span>=</span> <span>@two</span><span>,</span> <span>@values</span> <span>=</span> <span>two</span><span>,</span> <span>values</span>

<span># because it is parsed as</span>
<span>(</span><span>def</span> <span>initialize</span><span>(</span><span>two</span><span>,</span> <span>values</span><span>)</span> <span>=</span> <span>@two</span><span>),</span> <span>@values</span> <span>=</span> <span>two</span><span>,</span> <span>values</span>

<span># the remedy, again, is to put parentheses around:</span>
<span>def</span> <span>initialize</span><span>(</span><span>two</span><span>,</span> <span>values</span><span>)</span> <span>=</span> <span>(</span><span>@two</span><span>,</span> <span>@values</span> <span>=</span> <span>two</span><span>,</span> <span>values</span><span>)</span>
</code></pre></div></div>

<p>I have a small hope that a tectonic process of switching to a new parser, <a href="https://github.com/ruby/prism">Prism</a> (it is awesome, <a href="https://kddnewton.com/2023/06/12/rewriting-the-ruby-parser.html">read about it</a>), might help to fix the case eventually.</p>

<h2 id="consequences">Consequences</h2>

<p>One of the things frequently pointed out while criticizing a new syntax is that it makes one-statement methods “special,” in a sense that once you need a second statement, you’ll need to change the shape completely:</p>

<div><div><pre><code><span># You had this...</span>
<span>def</span> <span>owner_name</span> <span>=</span> <span>@user</span><span>.</span><span>name</span>

<span># ..but what if it becomes a tad more complicated?</span>
<span># We can&#39;t just insert a new line of code right above the existing one:</span>
<span># need to push code around, remove =, etc.</span>
<span>def</span> <span>owner_name</span>
  <span>default</span> <span>=</span> <span>I18n</span><span>.</span><span>t</span><span>(</span><span>&#39;that_thing.default_owner_name&#39;</span><span>)</span>

  <span>@user</span><span>&amp;</span><span>.</span><span>name</span> <span>||</span> <span>default</span>
<span>end</span>
</code></pre></div></div>

<p>This property of the syntax is not unusual for Ruby, though. A simple <code>objects.map { do_something }</code>, once you need a second statement inside the block, requires splitting into lines (and in many code styles, changing block wrapping syntax for multiline blocks<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>) and is generally <em>inconvenient</em>.</p>

<p>We can look at it not as an inconvenience, though, but as a <em>suggestivity</em> of the syntax. At the point when your small and elegant one-line method suddenly needs a second line, one might stop (for a brief microseconds, after all, we think and type pretty fast, we just <em>perceive</em> some things as unnecessary obstacles) and consider one of two scenarios: maybe there is a way to keep it a one-liner? For the method above, it could’ve probably been something like:</p>

<div><div><pre><code><span>DEFAULT_OWNER</span> <span>=</span> <span>I18n</span><span>.</span><span>t</span><span>(</span><span>&#39;that_thing.default_owner_name&#39;</span><span>)</span>

<span>def</span> <span>owner_name</span> <span>=</span> <span>@user</span><span>&amp;</span><span>.</span><span>name</span> <span>||</span> <span>DEFAULT_OWNER</span>
</code></pre></div></div>

<p>…which, depending on the case and the codebase, could represent a cleaner separation of concerns.</p>

<p>There might be another case when two or more statements are what really represents the method’s needs. In this case, those few strokes of “rewrite” are also useful: they allow to update an “internal model” of the method from “one phrase” to “several phrases” (and this might lead to adjusting the name, say).</p>

<p>The “one phrase perception” is a key here—and the main thing that the new syntax added: <strong>one-phrase methods</strong> that are written as such: just like trailing <code>if</code>. Because the “classic” method, even the smallest one:</p>
<div><div><pre><code><span>def</span> <span>size</span>
  <span>@objects</span><span>.</span><span>count</span>
<span>end</span>
</code></pre></div></div>
<p>…the internal voice would read: “There as a method <code>size</code>. It is calculated as <code>@objects.count</code>. That’s it.”</p>

<p>While the one-line one:</p>
<div><div><pre><code><span>def</span> <span>size</span> <span>=</span> <span>@objects</span><span>.</span><span>count</span>
</code></pre></div></div>

<p>…is read “The method <code>size</code> is <code>@objects.count</code>.”</p>

<p>The character count here is not that important. Heck, even, paradoxically, the line count is not! While the shorthand syntax is frequently dubbed “one-line method syntax,” this is perfectly valid code:</p>

<div><div><pre><code><span>Event</span> <span>=</span> <span>Data</span><span>.</span><span>define</span><span>(</span><span>:kind</span><span>,</span> <span>:context</span><span>,</span> <span>:timestamp</span><span>)</span>

<span>def</span> <span>event</span><span>(</span><span>kind</span><span>)</span> <span>=</span> <span>Event</span><span>.</span><span>new</span><span>(</span>
  <span>kind: </span><span>kind</span><span>.</span><span>to_sym</span><span>,</span>
  <span>context: </span><span>self</span><span>,</span>
  <span>timestamp: </span><span>Time</span><span>.</span><span>now</span>
<span>)</span>
</code></pre></div></div>

<p>This still reads as exactly one phrase: “<code>event</code> is a method that produces <code>Event</code> instances.”</p>

<p>On the other hand, in the code that makes good use of such “one-phrase” methods, one might consciously leave the one-expression method <em>multi-phrase</em>, emphasizing its non-triviality (and a general feeling of “here, stop and read”):</p>

<div><div><pre><code><span>def</span> <span>send_event</span><span>(</span><span>kind</span><span>,</span> <span>payload</span><span>)</span>
  <span>EventQueue</span><span>.</span><span>instance</span><span>.</span><span>push</span><span>(</span><span>Event</span><span>.</span><span>new</span><span>(</span><span>kind</span><span>:,</span> <span>**</span><span>payload</span><span>))</span>
<span>end</span>
</code></pre></div></div>

<p>So it is not about making all one-expression methods endless <em>mechanically</em>, but about a tool of thought, a tool of communication.</p>

<blockquote>
  <p>And here I’ll again repeat the convoluted yet expressive example from “<a href="https://zverok.space/blog/2023-11-03-syntax-sugar2-pattern-matching-fin.html#taking-it-further">Pattern Matching / Taking it further</a>,” where several new syntax features play together, to the effect of “multi-body pattern matching method”, with one-line method syntax bringing final touches to the structure:</p>
</blockquote>

<div><div><pre><code><span>def</span> <span>slice</span><span>(</span><span>*</span><span>)</span> <span>=</span> <span>case</span> <span>[</span><span>*</span><span>]</span>
<span>in</span> <span>[</span><span>Integer</span> <span>=&gt;</span> <span>index</span><span>]</span>
  <span>p</span><span>(</span><span>index</span><span>:)</span>
<span>in</span> <span>[</span><span>Range</span> <span>=&gt;</span> <span>range</span><span>]</span>
  <span>p</span><span>(</span><span>range</span><span>:)</span>
<span>in</span> <span>[</span><span>Integer</span> <span>=&gt;</span> <span>from</span><span>,</span> <span>Integer</span> <span>=&gt;</span> <span>to</span><span>]</span>
  <span>p</span><span>(</span><span>from</span><span>:,</span> <span>to</span><span>:)</span>
<span>end</span>

<span>slice</span><span>(</span><span>1</span><span>)</span>    <span># prints {:index=&gt;1}</span>
<span>slice</span><span>(</span><span>1</span><span>..</span><span>3</span><span>)</span> <span># prints {:range=&gt;1..3}</span>
<span>slice</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>)</span> <span># prints {:from=&gt;1, :to=&gt;3}</span>
</code></pre></div></div>

<p>And while I don’t expect using endless methods for multi-line, yet “logically one phrase” methods to have a large mind share anytime soon, having it as an expressive tool might adjust community outlooks with time.</p>

<div>
  <h3>A weekly postcard from Ukraine</h3>

  <p><em><strong>Please stop here for a moment.</strong> This is your weekly mid-text reminder that I am a living person from Ukraine, and a bit of useful related information.</em></p>

  <p><strong>One news item.</strong> Besides everything that happens on the frontline, a couple of days ago, Russians <a href="https://eng.obozrevatel.com/section-war/news-russian-forces-targeted-residential-buildings-in-thesumy-region-with-multiple-rocket-launchers-three-people-died-including-a-child-photo-29-11-2023.html">shelled</a> Seredina-Buda in the Sumy region, killing two adults and seven-years-old girl. To understand that better, I advise you to look at the town on a <a href="https://www.google.com/maps/place/%D0%A1%D0%B5%D1%80%D0%B5%D0%B4%D0%B8%D0%BD%D0%B0-%D0%91%D1%83%D0%B4%D0%B0,+%D0%A1%D1%83%D0%BC%D1%81%D1%8C%D0%BA%D0%B0+%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C,+41000/@49.9513545,27.1652341,6.13z/data=!4m6!3m5!1s0x412c6733c53b5325:0x9dea326f922bc4a3!8m2!3d52.1837429!4d34.0412051!16zL20vMGd0MmRw?entry=ttu">map</a> (and compare it to a <a href="https://deepstatemap.live/en#6/49.438/32.053">map</a> of active warfare). Russians constantly shell Northern parts of Ukraine to terrorize and in the hope of provoking “an unjustified attack on Russian soil.”</p>

  <p><strong>One piece of context.</strong> Last Saturday was a Holodomor Victims Remembrance Day. Here is the <a href="https://twitter.com/uaexplainers/status/1596109449579696129">Ukraine Explainers thread</a> giving an important context of <em>one of the previous</em> genocides Russians attempted upon our country.</p>

  <p><strong>One fundraiser.</strong> Finland-based Ukrainian game designer Sergey Mohov and his charity Polubotok Treasury have an <a href="https://twitter.com/krides/status/1727967054076969210">active fundraiser (with convenient donation options)</a> to help the Ukrainian Armed Forces. Please consider donating!</p>

  <p>Please proceed with the rest of the article.</p>
</div>

<h2 id="how-others-do-it">How others do it</h2>

<p>It goes without saying that in many functional (or, in our post-modern times, “functional-first”) languages, <code>name = expression</code> is the main way of defining them. (And how do <em>multi</em>-expression functions look in such languages is a separate question.) Haskell:</p>



<p>In the context of this article, it is more interesting, though, to look at how the problem is addressed in languages of the closer paradigms.</p>

<p>As was pointed out at the beginning, most mainstream languages nowadays use C-style <code>{}</code> to wrap their code blocks, and so the problem doesn’t manifest itself as pressing: you always can just write <code>header { body }</code> in one line as necessary, and the wrapping punctuation neither prohibits this nor takes too much space; it is also easy to mentally skip while reading as a phrase.</p>

<p>Even so, the <em>special</em> role of one-phrase methods is recognized, say, by <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods#expression-body-definitions">C#</a> and <a href="https://kotlinlang.org/docs/functions.html#single-expression-functions">Kotlin</a>:</p>

<div><div><pre><code><span>// regular function:</span>
<span>fun</span> <span>double</span><span>(</span><span>x</span><span>:</span> <span>Int</span><span>):</span> <span>Int</span> <span>{</span>
  <span>return</span> <span>x</span> <span>+</span> <span>x</span>
<span>}</span>

<span>// single-expression function:</span>
<span>fun</span> <span>double</span><span>(</span><span>x</span><span>:</span> <span>Int</span><span>):</span> <span>Int</span> <span>=</span> <span>x</span> <span>+</span> <span>x</span>
</code></pre></div></div>

<p>(For both languages, dropping parentheses <em>and</em> <code>return</code> clause, with a value implicitly returned by a single statement, seems to be a point of those shorthands.)</p>

<p>Another group is languages with significant whitespaces: many of them allow writing a short function body in the same line as the header, like Python:</p>
<div><div><pre><code><span># regular function:
</span><span>def</span> <span>is_even</span><span>(</span><span>x</span><span>):</span>
  <span>return</span> <span>x</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span>

<span># ...can be written this way:
</span><span>def</span> <span>is_even</span><span>(</span><span>x</span><span>):</span> <span>return</span> <span>x</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span>
</code></pre></div></div>
<p>…bringing both shortness and “it is just one phrase” effect (though Python’s mandatory <code>return</code> might sometimes feel redundant).</p>

<p><a href="https://docs.scala-lang.org/overviews/scala-book/methods-first-look.html">Scala</a> and <a href="https://nim-by-example.github.io/procs/">Nim</a> even use <code>=</code> as a symbol between the header and the body, which makes one-line method definitions look almost exactly like Ruby’s.</p>

<p>Julia, which is, like Ruby, one of a few languages with <code>end</code> keyword, <a href="https://docs.julialang.org/en/v1/manual/functions/">has</a> like Ruby, <code>=</code>-driven shorthand (yet, unlike in Ruby, it creates a value that is possible to pass around—see more about it below):</p>

<div><div><pre><code><span># regular</span>
<span>function</span><span> f</span><span>(</span><span>x</span><span>,</span><span>y</span><span>)</span>
  <span>x</span> <span>+</span> <span>y</span>
<span>end</span>
<span># shorthand:</span>
<span>f</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=</span> <span>x</span> <span>+</span> <span>y</span>
</code></pre></div></div>

<p>As a counter-example, some newer languages with <code>{}</code> in syntax and a default formatter in the toolbox, not only avoid special one-expression forms (without parentheses) but tend to set the default formatting rules to prohibit writing a short one-expression body with parentheses in one line. Here are corresponding discussions for <a href="https://github.com/golang/go/issues/4363">Go</a> and <a href="https://github.com/rust-lang/rustfmt/issues/262">Rust</a>, the latter stating in no unsure terms (emphasis mine):</p>

<blockquote>
  <p>Some people like to fit a whole function (decl and body) on one line. <strong>They are wrong</strong>, but we should support it as an option.</p>
</blockquote>

<h2 id="taking-it-further">Taking it further</h2>

<p>Quite a few Rubyists were displeased with the new syntax specifically due to usage of <code>=</code>, which is “too similar to assigning the value,” and therefore muddies the distinction between values and methods.</p>

<p>It would be fair to say that the strong distinction between “values” and “methods” is a fruit of strictly the imperative upbringing of the developer. Today, it isn’t necessary to take a full course of functional programming to be accustomed to the fact that, yes, you actually can put a function into a variable, and treat it as a data type. After all, the ubiquitous JS has it!</p>

<div><div><pre><code><span>// A definition!</span>
<span>function</span> <span>foo</span><span>()</span> <span>{</span> <span>return</span> <span>3</span> <span>}</span>
<span>// A variable!</span>
<span>foo</span> <span>=</span> <span>function</span><span>()</span> <span>{</span> <span>return</span> <span>3</span> <span>}</span>
</code></pre></div></div>

<p>(Though I admit, even for users of those languages, it sometimes requires a good mentor or a book to reveal the “function can be a value” idea. I met an experienced and productive Rubyist who felt “weird” to pass around a block of code that is passed to a method as <code>&amp;block</code>, and when they <em>needed</em> a functional value, they just used <code>-&gt; {}</code> lambdas.)</p>

<p>So using <code>=</code> to define a function is not an esoteric choice.</p>

<p>On the other hand, it might feel misleading!</p>

<p>As I <a href="https://zverok.space/blog/2022-01-13-it-evolves.html#taking-offense-for-method-references">explained some time ago</a>, Ruby doesn’t have a natural way to use a method as a value. The shortest you can do is to invoke <code>method(:method_name)</code> and it <em>creates</em> a <a href="https://docs.ruby-lang.org/en/3.2/Method.html">Method</a> object on the fly, which has both performance and reading penalties.</p>

<p>So, while in, say, C#, when you write an assignment-like definition:</p>
<div><div><pre><code><span>int</span> <span>multiply</span><span>(</span><span>int</span> <span>x</span><span>,</span> <span>int</span> <span>y</span><span>)</span> <span>=&gt;</span> <span>x</span><span>*</span><span>y</span><span>;</span>
<span>// you can do this:</span>
<span>var</span> <span>m</span> <span>=</span> <span>multiply</span><span>;</span>
<span>// or this:</span>
<span>call_something</span><span>(</span><span>multiply</span><span>);</span>
</code></pre></div></div>
<p>…so, you really have <em>assigned</em> some value. But in Ruby:</p>
<div><div><pre><code><span>def</span> <span>multyply</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span> <span>=</span> <span>x</span> <span>*</span> <span>y</span>

<span># No, this immediately attempts to call multiply, and fails</span>
<span># due to missing arguments.</span>
<span>m</span> <span>=</span> <span>multiply</span>
<span># That&#39;s the only way</span>
<span>m</span> <span>=</span> <span>method</span><span>(</span><span>:multiply</span><span>)</span>
</code></pre></div></div>
<p>…and “assignment-like syntax” feels less justified.</p>

<p>So I think: maybe, there is a possible future where everybody so <em>got used</em> to writing <code>def method(...) =</code> that the idea of method <em>values</em> becomes naturally necessary, and there might be one more attempt to bring them to the language.</p>

<h2 id="conclusions">Conclusions</h2>

<p>I fully expect at least some readers to catch on the “April Fools’ joke” theme and use it as proof of the “language awfulness” and “syntax features uselessness” (especially considering my honest covering of the implementation’s shortcomings).</p>

<p>But I didn’t come here to preach Ruby’s superiority (nor to expose its unworthiness).</p>

<p>My theme here is how the language changes in response to our understanding of what and how we want to say and how our understanding is adjusted by the language changes.</p>

<p>For programming languages, the process is as natural, inevitable, and perpetual as for the human ones.</p>

<p>Unlike human languages, many programming languages change not only in response to their factual usage but also in response to their inherent values. What draws me to Ruby is what I feel like its <em>inherent values</em>: <strong>phrase-level expressiveness for story-level clarity</strong>.</p>

<p>I am not saying that it is not the “only expressive language” (and not even “one of the most expressive ones”), and many of its design decisions with years became questionable. The only thing I am saying is that it is—for me—the language that <strong>consciously thinks</strong> this way and makes me think, too—and, hopefully, produce not the most mundane texts from those thoughts.</p>

<p>On this note, I have finished covering the last feature in the series I’ve planned. There would be one more post with some general conclusions and probably a bit of bonus content: a list of Ruby syntax elements that I actually don’t like (there are some!) and a list of those that could but haven’t (yet?) materialized.</p>

<p>But now December is upon us, and it means the upcoming Ruby release, which, in turn, means I need to work on this year’s <a href="https://rubyreferences.github.io/rubychanges/">changelog</a>, and it usually takes quite some time. This year, I plan to publish a few diary notes from this work—and then get to other topics, including the “useless sugar” series wrap-up, after the New Year.</p>

<p>You can subscribe to my <a href="https://zverok.substack.com/">Substack</a> to not miss it, or follow me on <a href="https://twitter.com/zverok">Twitter</a>.</p>

<hr/>

<p><strong>Thank you for reading. Please support Ukraine with your donations and lobbying for military and humanitarian help. <a href="https://war.ukraine.ua/">Here</a>, you’ll find a comprehensive information source and many links to state and private funds accepting donations.</strong></p>

<p><strong>If you don’t have time to process it all, donating to <a href="https://savelife.in.ua/en/">Come Back Alive</a> foundation is always a good choice.</strong></p>

<p><strong>If you’ve found the post (or some of my previous work) useful, I have a <a href="https://www.buymeacoffee.com/zverok">Buy Me A Coffee account</a> now. Till the end of the war, 100% of payments to it (if any) would be spent on my or my brothers’ necessary equipment or sent to one of the funds above.</strong></p>





  </div></div>
  </body>
</html>
