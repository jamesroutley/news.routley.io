<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/so-i-lost-my-openbsd-fde-password/">Original</a>
    <h1>So I lost my OpenBSD FDE password (2016)</h1>
    
    <div id="readability-page-1" class="page"><section>
            <!--kg-card-begin: markdown--><p>The other day I set up a new OpenBSD instance with a nice RAID array, encrypted with Full Disk Encryption. And promptly proceeded to forget part of the passphrase.</p>
<p>We know <a href="https://words.filippo.io/so-i-lost-the-password-of-my-nas/">things get interesting when I lose a password</a>.</p>
<p>I did a weak attempt at finding some public bruteforce tool, and found nothing. I say weak because somewhere in the back of my brain, I already wanted to take a peek at the OpenBSD FDE implementation.</p>
<p>Very little is documented, and while I do trust OpenBSD, I want to know how my data is encrypted. So this was the &#34;perfect&#34; occasion.</p>
<p>Hold on, because it will be a bumpy ride, straight into the OpenBSD core sources, following notes I took during the ~3 hours process.</p>

<h2 id="goals">Goals</h2>
<p>We need to extract enough info from the encrypted disk and rebuild enough of the decryption algorithm to be able to rapidly try many passphrases.</p>
<p>What this usually means in FDE is finding the details of the Key Derivation Function, and whatever mechanism is used to detect if the passphrase is correct or not.</p>
<h2 id="startingpoints">Starting points</h2>
<p>A prompt. A damn prompt.</p>
<pre><code># bioctl -c C -l sd3a softraid0
Passphrase:
softraid0: incorrect key or passphrase
</code></pre>
<p>We start chasing by looking at the <code>bioctl</code> and <code>softraid_crypto</code> implementations, Cmd-F&#39;ing &#34;Passphrase:&#34; and &#34;incorrect key or passphrase&#34;.</p>
<p><a href="https://github.com/openbsd/src/blob/master/sys/dev/softraid_crypto.c">https://github.com/openbsd/src/blob/master/sys/dev/softraid_crypto.c</a></p>
<p><a href="https://github.com/openbsd/src/blob/master/sbin/bioctl/bioctl.c">https://github.com/openbsd/src/blob/master/sbin/bioctl/bioctl.c</a></p>
<p>The first hit is promising.</p>
<pre><code>bio_kdf_derive(&amp;kdfinfo, &amp;kdfhint, &#34;Passphrase: &#34;, 0);
</code></pre>
<pre><code>void
bio_kdf_derive(struct sr_crypto_kdfinfo *kdfinfo, struct sr_crypto_kdf_pbkdf2
    *kdfhint, char* prompt, int verify)
	// [...]
	derive_key_pkcs(kdfhint-&gt;rounds,
	    kdfinfo-&gt;maskkey, sizeof(kdfinfo-&gt;maskkey),
	    kdfhint-&gt;salt, sizeof(kdfhint-&gt;salt), prompt, verify);
</code></pre>
<p><code>derive_key_pkcs</code> is a banal checking wrapper for <code>pkcs5_pbkdf2</code>, so <strong>we now know how the passphrase is derived</strong> into a key:</p>
<pre><code>kdfinfo-&gt;maskkey = pbkdf2(password, kdfhint-&gt;salt, kdfhint-&gt;rounds)
</code></pre>
<p>Let&#39;s chase <code>kdfhint</code>.</p>
<h2 id="passthesalt">Pass the salt</h2>
<p>The salt is certainly stored on the encrypted disk. The object must be populated by the lines just above the <code>bio_kdf_derive</code> call, because before that its memory is zeroed:</p>
<pre><code>		create.bc_opaque = &amp;kdfhint;
		create.bc_opaque_size = sizeof(kdfhint);
		create.bc_opaque_flags = BIOC_SOOUT;

		/* try to get KDF hint */
		if (ioctl(devh, BIOCCREATERAID, &amp;create))
			err(1, &#34;ioctl&#34;);
</code></pre>
<p>I tried a few leads here, including following the <code>BIOCCREATERAID</code> ioctl, but what got me somewhere was a code search for &#34;<code>bc_opaque</code>&#34;.</p>
<p><a href="https://github.com/openbsd/src/blob/5c7db75318f0a6ebd225896d55da47c7fcdd140d/sys/dev/softraid_crypto.c#L223-L225"><code>softraid_crypto.c</code> L223-L225</a></p>
<pre><code>		if (copyout(sd-&gt;mds.mdd_crypto.scr_meta-&gt;scm_kdfhint,
		    bc-&gt;bc_opaque, bc-&gt;bc_opaque_size))
			goto done;
</code></pre>
<p>It&#39;s copied from some deeper metadata object. This seems complex. Hmmm.</p>
<p>Let&#39;s try a new angle: what is the type of the <code>kdfhint</code>?</p>
<p><a href="https://github.com/openbsd/src/blob/5c7db75318f0a6ebd225896d55da47c7fcdd140d/sys/dev/softraidvar.h#L53-L62"><code>softraidvar.h</code> L53-L62</a></p>
<pre><code>/*
 * sr_crypto_genkdf is a generic hint for the KDF performed in userland and
 * is not interpreted by the kernel.
 */
struct sr_crypto_genkdf {
	u_int32_t	len;
	u_int32_t	type;
#define SR_CRYPTOKDFT_INVALID	0
#define SR_CRYPTOKDFT_PBKDF2	1
#define SR_CRYPTOKDFT_KEYDISK	2
};

/*
 * sr_crypto_genkdf_pbkdf2 is a hint for the PKCS#5 KDF performed in userland
 * and is not interpreted by the kernel.
 */
struct sr_crypto_kdf_pbkdf2 {
	u_int32_t	len;
	u_int32_t	type;
	u_int32_t	rounds;
	u_int8_t	salt[128];
};
</code></pre>
<p>Aha! If it&#39;s &#34;not interpreted by the kernel&#34;, then it must be verbatim in the disk metadata. We need to look at one.</p>
<h3 id="asimpleexample">A simple example</h3>
<p>To reproduce a case where we will know if we got it right, we make a small encrypted image, with passphrase &#34;password&#34;.</p>
<pre><code># dd if=/dev/zero of=file.img bs=1 count=1M
# vnconfig vnd0 file.img
# disklabel -E /dev/rvnd0c
Label editor (enter &#39;?&#39; for help at any prompt)
&gt; a a
offset: [0]
size: [2048]
FS type: [4.2BSD] RAID
&gt; w
&gt; q
No label changes.
# bioctl -c C -l /dev/vnd0a softraid0
New passphrase: password
Re-type passphrase: password
softraid0: CRYPTO volume attached as sd4
</code></pre>
<p>Here is the hexdump: <a href="https://gist.github.com/FiloSottile/8294e708396396d6b6d49c7c839b72ec">https://gist.github.com/FiloSottile/8294e708396396d6b6d49c7c839b72ec</a></p>
<p>We are looking for a <code>sr_crypto_kdf_pbkdf2</code> structure, which we can recognize because it starts with a <code>u_int32_t</code> length, followed by a <code>u_int32_t</code> type of value 1, followed by a <code>u_int32_t</code> number of rounds. There are many <code>01 00 00 00</code> (little endian!) around, but only one seems surrounded by two other <code>u_int32_t</code>:</p>
<pre><code>00002960  -- -- -- -- -- -- -- --  -- -- -- -- 8c 00 00 00  |..U...(zU.......|
00002970  01 00 00 00 00 20 00 00  50 1f db 08 97 6d 2c 40  |..... ..P....m,@|
00002980  63 fb ff 91 5e 6c 75 fc  b9 44 86 16 77 1f 6d 65  |c...^lu..D..w.me|
00002990  4d 64 f8 56 ab 11 83 c7  7b 01 ac a0 f2 69 51 83  |Md.V....{....iQ.|
000029a0  b3 41 df c4 83 21 7a ce  75 37 3d f8 80 4f 6d 36  |.A...!z.u7=..Om6|
000029b0  06 63 55 15 ff de 7d 7a  b1 ac dd 0c f8 41 63 bb  |.cU...}z.....Ac.|
000029c0  42 cc a6 85 4a b5 52 f4  50 ec 9f 05 3f 9d 8b 8d  |B...J.R.P...?...|
000029d0  64 fe 85 ba 8f ce 08 87  97 e2 8d 35 2c 9d 6a 2d  |d..........5,.j-|
000029e0  cb 8c e2 7e 72 65 7d 7e  56 76 87 89 e6 ba cc 49  |...~re}~Vv.....I|
000029f0  bd 84 43 ef e6 3e 07 d6  00 00 00 00 00 00 00 00  |..C..&gt;..........|
</code></pre>
<p>Indeed, the length field is <code>8c = 140 = 4 + 4 + 4 + 128</code>, and the rounds number 0x2000 is reasonable. <strong>We have our salt!</strong></p>
<h2 id="achecksumtocheckyourkey">A checksum to check your key</h2>
<p>While lurking this comment caught my eye:</p>
<pre><code>	/* Check that the key decrypted properly. */
	sr_crypto_calculate_check_hmac_sha1(sd-&gt;mds.mdd_crypto.scr_maskkey,
	    sizeof(sd-&gt;mds.mdd_crypto.scr_maskkey),
	    (u_int8_t *)sd-&gt;mds.mdd_crypto.scr_key,
	    sizeof(sd-&gt;mds.mdd_crypto.scr_key),
	    check_digest);
	if (memcmp(sd-&gt;mds.mdd_crypto.scr_meta-&gt;chk_hmac_sha1.sch_mac,
	    check_digest, sizeof(check_digest)) != 0) {
		...
	}
</code></pre>
<p>Apparently the correctness of the passphrase is checked by doing a HMAC of something, and comparing it with an expected value.</p>
<p>Let&#39;s see what this <code>chk_hmac_sha1</code> structure is.</p>
<pre><code>/*
 * Check that HMAC-SHA1_k(decrypted scm_key) == sch_mac, where
 * k = SHA1(masking key)
 */
struct sr_crypto_chk_hmac_sha1 {
	u_int8_t	sch_mac[20];
} __packed;
</code></pre>
<p>Oh, thanks, that makes things much easier. What the comment calls &#34;decrypted <code>scm_key</code>&#34; is called <code>scr_key</code> in the snippet above.</p>
<p><strong>We have our check algorithm</strong>:</p>
<p><code>HMAC-SHA1(k=SHA1(maskkey), scr_key) == sch_mac</code></p>
<h2 id="keyskeysthatencryptkeys">Keys, keys that encrypt keys</h2>
<p>Let&#39;s see how this <code>scr_key</code> is decrypted. Just above.</p>
<pre><code>	if (sr_crypto_decrypt((u_char *)sd-&gt;mds.mdd_crypto.scr_meta-&gt;scm_key,
	    (u_char *)sd-&gt;mds.mdd_crypto.scr_key,
	    sd-&gt;mds.mdd_crypto.scr_maskkey, sizeof(sd-&gt;mds.mdd_crypto.scr_key),
	    sd-&gt;mds.mdd_crypto.scr_meta-&gt;scm_mask_alg) == -1)
		goto out;
</code></pre>
<p><code>sr_crypto_decrypt</code> is just AES-ECB-256. So <strong>last piece of the algorithm</strong>:</p>
<pre><code>scr_key = AES-ECB-256_decrypt(k=maskkey, scm_key)
</code></pre>
<h2 id="hexdumpspelunking">Hexdump spelunking</h2>
<p>Now, it&#39;s a matter of finding <code>scm_key</code> and <code>sch_mac</code> in the disk image. Again, let&#39;s look at the data structures, starting with <code>chk_hmac_sha1</code>.</p>
<pre><code>	u_int32_t		scm_check_alg;	/* key chksum algorithm */
#define SR_CRYPTOC_HMAC_SHA1		1
	u_int32_t		scm_pad2;
	union {
		struct sr_crypto_chk_hmac_sha1	chk_hmac_sha1;
		u_int8_t			chk_reserved2[64];
	}			_scm_chk;
</code></pre>
<p>Sweet. We are looking for <code>01 00 00 00</code> (<code>scm_check_alg</code>), followed by <code>00 00 00 00</code> (<code>scm_pad2</code>), followed by 20 random bytes (SHA1). Sure enough, just after the salt, <strong>there&#39;s our check HMAC</strong>:</p>
<pre><code>00002a60  00 00 00 00 00 00 00 00  00 00 00 00 01 00 00 00  |................|
00002a70  00 00 00 00 26 e8 25 6f  86 8f cd 33 88 1c d4 f1  |....&amp;.%o...3....|
00002a80  1e 9d 2a 98 ca 21 2d 9c  00 00 00 00 00 00 00 00  |..*..!-.........|
00002a90  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre>
<p>Finally, we need to find the encrypted key, <code>scm_key</code>. This took me a while, until I realized the size of this encrypted blob:</p>
<pre><code>#define SR_CRYPTO_MAXKEYS	32	/* max keys per volume */
#define SR_CRYPTO_KEYBITS	512	/* AES-XTS with 2 * 256 bit keys */
#define SR_CRYPTO_KEYBYTES	(SR_CRYPTO_KEYBITS &gt;&gt; 3)

	u_int8_t		scr_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];

	/* symmetric keys used for disk encryption */
	u_int8_t		scm_key[SR_CRYPTO_MAXKEYS][SR_CRYPTO_KEYBYTES];
</code></pre>
<p><code>32 * 512/8 = 2048 = 0x800</code>, 0x800 bytes of random stuff. You can&#39;t really miss it in the hexdump. But where are the boundaries? Well, if we are lucky, the line where the big random blob starts (<code>00002160</code>) and the one where the salt starts (<code>00002960</code>) will be approximately... Yes! Exactly 0x800 bytes apart :)</p>
<p><strong>That random blob is all key material</strong>, followed by the PBKDF2 rounds and salt, and by the check HMAC.</p>

<h2 id="wrappingitup">Wrapping it up</h2>
<p>So now we found all the pieces to write some code and find out if our assumptions were correct:</p>
<pre><code>func main() {
    scmKey := decode(scmKey)
    salt := decode(salt)

    maskkey := pbkdf2.Key([]byte(&#34;password&#34;), salt, rounds, 32, sha1.New)

    // AES-ECB-256_decrypt(k=maskkey, scm_key) = scr_key
    a, err := aes.NewCipher(maskkey)
    if err != nil {
        log.Fatal(err)
    }
    for i := 0; i &lt; len(scmKey); i += a.BlockSize() {
        a.Decrypt(scmKey[i:i+a.BlockSize()], scmKey[i:i+a.BlockSize()])
    }

    // HMAC-SHA1(k=maskkey, scm_key) == sch_mac
    h := sha1.Sum(maskkey)
    mac := hmac.New(sha1.New, h[:])
    mac.Write(scmKey)
    expectedMAC := mac.Sum(nil)

    fmt.Print(hex.Dump(expectedMAC))
}
</code></pre>
<p>If we are right, this will output the same HMAC as in the last hexdump snippet. The first time I forgot to hash the <code>maskkey</code>, almost tore my hair out. But then...</p>
<pre><code>$ go build -i . &amp;&amp; ./openbsd-fde-crack
00000000  26 e8 25 6f 86 8f cd 33  88 1c d4 f1 1e 9d 2a 98  |&amp;.%o...3......*.|
00000010  ca 21 2d 9c                                       |.!-.|
</code></pre>
<p>Voil√†!</p>
<p>Now that we know how to extract the data and how to try passphrases against it, it will be trivial to write a bruteforce tool to recover the part of passphrase I forgot.</p>
<p>There&#39;s some code here, but don&#39;t expect a fire-and-forget tool, this post gives you enough information to figure out stuff on your own: <a href="https://github.com/FiloSottile/openbsd-fde-crack">https://github.com/FiloSottile/openbsd-fde-crack</a></p>
<p>To know what happens the next time I lose a password (sigh), <a href="https://twitter.com/FiloSottile">follow me on Twitter</a>.</p>
<p><strong>UPDATE</strong>: I found it! After fixing a bug or two in the brute force tool and almost losing hope, it found the right combination of forgotten word and (Italian) misspelling.</p>
<p><strong>UPDATE</strong>: I later found <a href="http://xn--thibaud-dya.fr/openbsd_softraid.html">a nice article documenting the entire system</a>. It also includes references to JohnTheRipper having a module for this. Well, this was more fun.</p>
<!--kg-card-end: markdown-->
        </section></div>
  </body>
</html>
