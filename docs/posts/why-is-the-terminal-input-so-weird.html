<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.warp.dev/blog/why-is-the-terminal-input-so-weird">Original</a>
    <h1>Why is the terminal input so weird?</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>This post is about why terminal-based input seems stuck in the 80s.  If you’ve ever banged your head against the wall trying to edit a command, read on…</p><p>‍</p><ul role="list"><li><a href="#problems-with-input-editing-in-the-terminal">Problems with input editing in the terminal</a></li><li><a href="#why-doesnt-the-terminal-have-ide-style-text-editing">Why doesn’t the terminal have IDE-style text editing?</a></li><li><a href="#how-terminal-input-works">How terminal input works</a></li><li><a href="#the-limits-of-tuis">The limits of TUIs</a></li><li><a href="#is-this-actually-a-problem">Is this actually a problem?</a></li><li><a href="#building-a-terminal-based-ide-style-editor">Building a terminal-based IDE-style editor</a></li><li><a href="#challenges">Challenges</a></li><li><a href="#wrap-up">Wrap up</a></li></ul><p>‍</p><p>We’ve all had this experience: you write a complex multi-line terminal command and realize you have a typo towards the start of it.  Maybe it’s a long curl command and the url is misspelled. Shit. You try pressing the up-arrow to move the cursor up a line so you can fix it.  Nothing happens (or even worse, maybe history entries start showing up :)). You know there’s some way of using the keyboard to get the cursor to the right place, but you can’t remember it.  </p><p>‍</p><p>Next you try using the mouse – a reasonable thought, since clicking to position the cursor works in pretty much every other text editing tool.  But of course it doesn’t work.  You click and nothing happens.  You double click instead, and try to select the text to delete it and re-enter it.  The selection highlighting shows up which makes you think it’s editable, so you start typing.  But instead of inserting characters at the selection, they are inserted at the end of the line.  WTF!!!  Finally you hit ctrl-c and start over, copy-pasting the old command line by line…</p><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/6375038ffe1bf77212ac9994_63745ffcd15e66f934e1bcf7_frustrated-meme.png" alt="frustrated meme - Protocommunications - Debate"/></p><figcaption><em>*long sigh*</em></figcaption></figure><p>‍</p><p><h3 id="problems-with-input-editing-in-the-terminal">Problems with input editing in the terminal</h3></p><p>There are numerous problems with input editing in today’s command-lines.  Mouse accessibility is broken, as described above.  So is multi-line editing.  In fact, the terminal input is in a lot of ways less powerful and user friendly than your typical &lt;textarea&gt; element on a web page, which is mouse-accessible, supports multi-line editing and has features like spell check built in.</p><p>‍</p><p>Compared to IDEs, the terminal is even further behind. For instance, my IDE</p><p>‍</p><ul role="list"><li>has syntax highlighting to help me understand where I am in a long block of code and whether that code is well formed.  </li><li>parses my code in real-time, providing inline documentation and the ability to quickly navigate to symbol definitions.</li><li>points out where parentheses, quotes, and the like start and end.</li><li>reformats code to a predefined standard (prettifies it).</li><li>helps me write code, using AI assistive features like in Github Copilot.</li><li>and much more…you get the point  </li></ul><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/6375038f335ded36835e8d00_637461b8bf1b54fe0ddefa44_image%2520(1).png" loading="lazy" alt=""/></p></figure><p>‍</p><p><h3 id="why-doesnt-the-terminal-have-ide-style-text-editing">Why doesn&#39;t the terminal have IDE-style text editing?</h3></p><p>Why is the terminal input so archaic? One theory could be that assistive features aren’t useful for command-entry.  But if you take Github stars as a gauge of usefulness, that’s clearly wrong, because some of the most starred Github projects of all time make terminal input better – e.g. completions through <a href="https://github.com/ohmyzsh/ohmyzsh">OhMyZsh</a> (&gt;150k stars) and command correction through <a href="https://github.com/nvbn/thefuck">thefuck</a> (&gt;75k stars).</p><p>‍</p><p>Instead, the main issue is that the technical architecture of the terminal makes it very hard to implement rich – or even “normal” – editing features like you’d find in an IDE.  </p><p>‍</p><p><h3 id="how-terminal-input-works">How terminal input works</h3></p><p>Some basics on terminal architecture: the mac/unix terminal is a native app that emulates an old-school physical terminal, like the <a href="https://en.wikipedia.org/wiki/VT100">vt100</a>.  These old terminals were very simple character input/output devices, and like them current terminals work one character at a time. Your terminal app accepts a character as input from the keyboard and writes it to a <a href="https://en.wikipedia.org/wiki/Pseudoterminal">pty</a>.  Going the other direction, the terminal reads characters from the pty and renders them on the screen.  </p><p>‍</p><p>On the other end of the pty is a shell (usually bash, zsh or fish) that interprets these characters and provides a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> interface.  Part of this REPL interface is a command editor, which contains a text buffer that the shell manages (this is a simplification, but it’s basically accurate).  </p><p>‍</p><p>At a high-level, the shell REPL works as follows:</p><p>‍</p><p><em>Read</em>:  </p><ul role="list"><li>During the read step, the user populates the shell&#39;s command buffer by typing characters, which are sent one at a time from the terminal to the shell.  </li><li>If the character is printable, the shell adds it to its internal buffer and echoes it back to the terminal, which displays it.  </li><li>If the character is a “control character” the shell interprets it to do things like moving the cursor, deleting text, and so on.  The shell adjusts its buffer in light of these changes, and also asks the terminal to adjust its rendering state by sending back its own control characters (e.g. it might ask the terminal to show the cursor at a different position).</li><li>At the end of the read process, the command buffer is ready to be executed.</li></ul><p><em>Eval</em>: </p><ul role="list"><li>When the user sends a newline character to the shell, the shell interprets the command and (usually) launches a binary (I say “usually” because some commands are so common like ls and cd that they are often “built-in” directly to the shell).  This is the evaluation step.  </li><li>This binary in turn also communicates with the terminal through the pty on a character by character basis.</li></ul><p><em>Print</em>: </p><ul role="list"><li>Whatever program the shell runs will usually write its own responses a character a time back to the pty, and the terminal will print them.  This is the print step.</li><li>Note that programs aren’t required to print anything, and some, like “cd” don’t.  They just do their thing and return.</li></ul><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/6375038f217fa56ed4b22ea3_637461dd63943d329aed7e8b_image%2520(2).png" loading="lazy" alt=""/></p></figure><p>‍</p><p>The shell can actually do more than just echo back characters during the read state.  It can also send back things like autosuggestions (the ghosted text that fish sends back to suggest a completion) or colored text as syntax highlighting.  It can react to control characters like “tab” to show completion lists below the current command.  But fundamentally, this UX is limited to characters and doesn’t support the mouse.</p><p>‍</p><p><h3 id="the-limits-of-tuis">The limit of TUIs</h3></p><p>So to reiterate: the shell manages all changes to the input buffer through a completely character oriented interface.  However, only in the terminal app layer is there the ability to do mouse handling and pixel-oriented graphics – things that are needed for features like IDE-style documentation and symbol lookup, as well as for “normal” things like clicking to put the cursor someplace.</p><p>In turn this means that anyone who has wanted to improve the terminal editing experience needs to do it at the shell level – and this is what some shells like fish try to do (as well how shell plugins like OhMyZsh work).  They can only do so much though, and, crucially, they can’t make terminal input work overall in a less “weird” way.</p><p>‍</p><p><h3 id="is-this-actually-a-problem">Is this actually a problem?</h3></p><p>Some developers will likely be strongly opposed to any graphical elements or mouse interactions in the terminal on principle.  But when I think of all the time wasted and hair-pulled when trying to work around the input weirdness in the terminal, I have to respectfully disagree. </p><p>‍</p><p>There’s good reason that IDE’s have become the preferred code editors, and those reasons apply equally well to editing terminal commands.  E.g.</p><p>‍</p><ul role="list"><li>IDEs support the mouse because for a lot of users and actions it can be more intuitive.</li><li>IDEs support graphical renderings (think of an overlay showing function documentation) because sometimes that’s a more efficient way of surfacing information.  </li><li>IDEs are similar to most of the other text editors developers use like GDocs and Word – and are thus easier for new developers to learn. </li></ul><p>I do however fully agree that the terminal needs to be <strong>fast, unbloated, and keyboard-first</strong> – I just don’t think that means it needs to be unintuitive, purely-character based, and keyboard-only.</p><p>‍</p><p><h3 id="building-a-terminal-based-ide-style-editor">Building a terminal-based IDE-style editor</h3></p><p>In <a href="http://www.warp.dev">Warp</a>, a Rust-based terminal, we have made a terminal input that works much more like an IDE.  This is technically challenging and is still a work in progress.  </p><p>‍</p><p>From a technical perspective, it required a major change from how terminals usually work: we built the command-editor into the terminal itself, rather than rely on the shell’s editor.  </p><p>‍</p><p>Moving the editor into the terminal allows for fixing the problems mentioned above: the editor can work more or less like it does in an IDE because it no longer has a character-only pty sitting between user interactions and the data model.  Instead, the input buffer lives in the terminal and is managed by a “normal” text editing UI in which we can implement any IDE-style feature.  </p><p>‍</p><p>So instead of the traditional REPL model referenced above, in Warp the REPL works like:</p><p>‍</p><p><em>Read</em>:  </p><ul role="list"><li>The user populates the input buffer entirely at the terminal layer.</li><li>As the user types characters, enters key navigation commands, uses the mouse, the Warp text editor updates its own internal buffer with the state of the next command to send to the shell.</li><li>Warp can implement any type of UI or event handling it wants in the course of the user entering the command - e.g. we can do auto-formatting, syntax highlighting, inline documentation, etc.</li></ul><p><em>Eval</em>: </p><ul role="list"><li>The user enters the newline character and Warp sends the entire command buffer to the shell for execution.</li></ul><p><em>Print</em>: </p><ul role="list"><li>Print basically works the same as in the normal REPL, although with one major difference – in Warp we understand which command is associated with which output and use that to render a “block” – you can read more on this in <a href="https://www.warp.dev/blog/how-warp-works">How Warp Works</a>.</li></ul><p>‍</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://assets-global.website-files.com/6221c6f68d6664279c408870/6375038fbc175dbd27bc9c99_637461f1397f1750feaf3d0c_image%2520(3).png" loading="lazy" alt=""/></p></figure><p>‍</p><p>By moving text editing into the terminal, we have been able to implement:</p><p>‍</p><ul role="list"><li><a href="https://docs.warp.dev/features/editor"><strong>A “normal” text editor</strong></a> - mouse accessible with all of the normal interactivity of something like VSCode, which is especially nice for editing long and multiline commands and also has some fancier features like autosuggestions, multi-cursor and selection support.</li><li><a href="https://docs.warp.dev/features/completions"><strong>IDE-style completions</strong></a> - built-in completions for hundreds of commands with a native, fuzzy-searchable completion menu.</li><li><strong>“</strong><a href="https://docs.warp.dev/features/editor/command-inspector"><strong>Command Inspector</strong></a><strong>”</strong> - a feature that allows users to surface a documentation popup for any command or flag in our completion engine.  </li><li><a href="https://docs.warp.dev/features/entry/workflows"><strong>Workflows</strong></a> - templatized, searchable, shareable command-snippets that take advantage of our native text editor for entering parameters and seeing their documentation.</li><li><a href="https://docs.warp.dev/features/editor/syntax-error-highlighting#what-is-error-underlining"><strong>Error underline</strong></a><strong> - </strong>highlighting of errors in commands as you type them so you can fix them before running</li><li><a href="https://docs.warp.dev/features/editor/syntax-error-highlighting#what-is-syntax-highlighting"><strong>Syntax highlighting and auto-parens</strong></a><strong> - </strong>colorized text for different parts of a command and shell syntax</li><li><a href="https://docs.warp.dev/features/editor/command-corrections"><strong>Command corrections</strong></a><strong> - </strong>a native implementation in Rust of using autosuggestions to fix fat-fingered commands (done in collaboration with <a href="https://github.com/nvbn/thefuck">thefuck</a>)</li><li><a href="https://docs.warp.dev/features/editor#soft-wrapping"><strong>Soft wrapping</strong></a><strong> - </strong>long commands automatically wrap to multiple lines without having to manually escape newlines</li></ul><p>‍</p><p>You can check out a quick video of these features in action <a href="https://www.youtube.com/watch?v=Uw7xQ3SD9P0">here</a>.</p><p>‍</p><p>And as a knock- on benefit of our approach, all of this works out of the box with zero configuration.  It also by default works over SSH – this is a big improvement because the shell editor configuration on remote machines is often quite different from your local setup, which causes a lot of user frustration and fat-fingering.</p><p>‍</p><p><h3 id="challenges">Challenges</h3></p><p>There are a few main sorts of challenges though with this architecture.</p><p>‍</p><p>First, we had to build an entire text editor from scratch in Rust.  Here we were helped early on by a collaboration with Nathan Sobo, the creator of Atom, who briefly worked at Warp.  The structure of the text editor is worth an entire technical post beyond this one.</p><p>‍</p><p>Second, in taking over text entry from the shell, we had to reimplement a lot of functionality that many shells provide out of the box.  Specifically, completions, history search, and soft-wrapping are all Warp custom implementations.  In addition to creating work for us, this can also create friction for our users, since their own custom shell configuration sometimes doesn’t work properly with Warp (for example, folks who have custom completions for bash or zsh can’t access them in Warp right now, although we are working to support this).</p><p>‍</p><p>Third, it’s actually tricky to hook into the shell’s state machine to properly run Warp’s REPL.  In order to make that work, we configure users’ shells to tell us more about what state they are in.  We also go into detail on how this works in <a href="https://www.warp.dev/blog/how-warp-works">How Warp Works.</a></p><p>‍</p><p><h3 id="wrap-up">Wrap up</h3></p><p>In summary, terminal input is weird.  It’s weird largely because there’s a character-only pipe sitting between the terminal and shell.  And going one step back, the weirdness comes from the whole historical division of terminal vs. shell, which is based on emulating a physical hardware setup that hasn’t been built since the 80s.  </p><p>‍</p><p>The weirdness is also fixable, but it takes a pretty big technical re-architecting that comes with a number of challenges.  We have started down this path at Warp, and so far the reaction has been super -positive, but there’s a long way to go.  We are also looking to expose APIs into our text editor so that the community can extend the initial functionality.</p><p>‍</p><p>Thanks for reading this, and we’d welcome any feedback on how you’d like terminal input to work!!</p></div></div></div></div>
  </body>
</html>
