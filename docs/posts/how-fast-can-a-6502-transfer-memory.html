<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://imapenguin.com/how-fast-can-a-6502-transfer-memory/">Original</a>
    <h1>How fast can a 6502 transfer memory?</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>The amazing <a href="https://twitter.com/gregnacu">Gregorio Naçu</a> posted the article title graphic this week to bring attention to the venerable 6502 processor and poke fun at Apple&#39;s M2 chip marketing slides. He&#39;s doing probably the <a href="http://c64os.com/">most ambitious single-person Commodore 64 project I know of</a> and has a fantastic blog.</p><p>Apple claims the new M2 chip has the following specs.</p><figure><img src="https://imapenguin.com/content/images/2022/06/image-6.png" alt="M2 features Image by Apple via Youtube" loading="lazy" width="970" height="544" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image-6.png 600w, https://imapenguin.com/content/images/2022/06/image-6.png 970w" sizes="(min-width: 720px) 720px"/><figcaption>M2 features Image by Apple via Youtube</figcaption></figure><p>We all know that these numbers are probably a little fluffy. Maybe a lot fluffy, and in practical applications, they are probably pretty far off. Benchmarking in a lab is fine, but the numbers rarely reflect real-world performance.</p><p><a href="https://www.tomsguide.com/news/apple-m2-chip">Tom&#39;s hardware does an excellent breakdown on this new chip</a>. It does look pretty neato! </p><h2 id="how-fast-is-a-6502">How fast is a 6502?</h2><p>After Gregorio posted this image earlier this week, it sparked a fair amount of discussion on the interwebs about the memory transfer speed of a 6502 processor.</p><p>The 6502 on Commodore machines shares the clock with the video chip. Since dual ported ram wasn&#39;t financially feasible at the time, they chose a memory access trick that allowed both the video chip and processor to access memory during a single clock cycle. I think it&#39;s the same on most Commodores, but on the VIC-20, the processor accesses the memory on the low part of the signal and the VIC chip on the high part. Maybe that&#39;s backward... anyhoo, you get the point.</p><figure><img src="https://imapenguin.com/content/images/2022/06/image.png" alt="" loading="lazy" width="687" height="411" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image.png 600w, https://imapenguin.com/content/images/2022/06/image.png 687w"/><figcaption>VIC-20 PAL Clock signal from the 6561</figcaption></figure><h2 id="memory-at-1mb-per-second">Memory at 1MB per second</h2><p>Going back to the slide, this 1Mhz memory bandwidth is what folks are questioning. </p><p>On every clock cycle, the 6502 reads memory from somewhere... the stack, registers, program counter, memory locations, etc. So at 1 Mhz, typical for Commodore machines, this 1MB per second bandwidth is probably accurate in a vacuum, where marketing people hang out. </p><figure><img src="https://imapenguin.com/content/images/2022/06/20d09557-8311-4239-91ec-6232d07102bd-2.png" alt="" loading="lazy" width="1070" height="602" srcset="https://imapenguin.com/content/images/size/w600/2022/06/20d09557-8311-4239-91ec-6232d07102bd-2.png 600w, https://imapenguin.com/content/images/size/w1000/2022/06/20d09557-8311-4239-91ec-6232d07102bd-2.png 1000w, https://imapenguin.com/content/images/2022/06/20d09557-8311-4239-91ec-6232d07102bd-2.png 1070w" sizes="(min-width: 720px) 720px"/><figcaption>Image by <a href="https://twitter.com/gregnacu">Gregorio Naçu</a> at c64os.com</figcaption></figure><p>It&#39;s important to note that <a href="https://twitter.com/gregnacu">Gregorio Naçu</a>&#39;s slide was a parody and not intended to be a hard numbers accurate kind of thing. Please remember that because if you don&#39;t, the rest of this discussion will ruffle your feathers. </p><p>We&#39;ll try some memory transfers to get an idea of what actual transfer speeds might look like using standard Commodore hardware. Other 6502-based platforms might be faster or slower, so I encourage you to try some tests of your own, and please let me know what you find.</p><p>Again, remember that transferring memory takes more clock cycles than just reading or writing...</p><p>Let&#39;s give this a go on the most popular 6502-based system of all time, the Commodore 64.</p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_1403.jpeg" alt="" loading="lazy" width="1000" height="750" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_1403.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_1403.jpeg 1000w" sizes="(min-width: 720px) 720px"/><figcaption>Everyone has a heads-up display for their Commodore 64 these days.</figcaption></figure><h2 id="the-transfer">The transfer</h2><p>We&#39;ll take a queue right from the venerable Rodney Zaks. </p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_4130.jpeg" alt="" loading="lazy" width="1000" height="842" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_4130.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_4130.jpeg 1000w" sizes="(min-width: 720px) 720px"/></figure><p>Incidentally, <a href="https://youtu.be/dG_oZV6s0Zg">Robin did a long video fixing this book&#39;s implementation</a> bug. I&#39;ll be using the revised version as I think it&#39;s a well-established example of doing a real-world block transfer. Sure there may be faster ways, but this is a realistic way, which is what we&#39;re going for.</p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_4131.jpeg" alt="" loading="lazy" width="1000" height="814" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_4131.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_4131.jpeg 1000w" sizes="(min-width: 720px) 720px"/></figure><p>You can read this excellent chapter on how this works, and Robin&#39;s video goes into it in great detail. Here&#39;s what we&#39;re going to do:</p><pre><code>source   = $0800
dest     = $4800
len      = $4000
from     = $fb
to       = $fd
tmpx     = $a6


copyr
         .block

         lda #&lt;source
         sta from
         lda #&gt;source
         sta from+1
         lda #&lt;dest
         sta to
         lda #&gt;dest
         sta to+1

         ldy #0
         ldx #&gt;len
         beq remain
next     lda (from),y
         sta (to),y
         iny
         bne next
         inc from+1
         inc to+1
         dex
         bne next
remain   ldx #&lt;len      
         beq done
nextr    lda (from),y
         sta (to),y
         iny
         dex
         bne nextr
done     rts

         .bend</code></pre><p>We can <a href="https://imapenguin.com/jiffies-in-assembly/">count jiffies on a Commodore</a> to give us an idea of how fast this copy takes. Sure there&#39;s a slight overhead in the setup, but I think it&#39;s marginal enough that we can ignore it for our purposes.</p><figure><img src="https://imapenguin.com/content/images/2022/06/image-5.png" alt="" loading="lazy" width="640" height="480" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image-5.png 600w, https://imapenguin.com/content/images/2022/06/image-5.png 640w"/><figcaption>$12(18) jiffies </figcaption></figure><p>Okay, that&#39;s pretty fast. Since that&#39;s 16k transferred, it works out to about 54.6 k per second.</p><p>Let&#39;s do a bunch of them and see what it comes out as.</p><p>We can call this pretty quickly 255 times and do the same math.</p><pre><code>         lda #$00
         sta $a2
         sta $a1
         sta $a0

         ldx #255
         stx tmpx
lp
         jsr copyr
         dec tmpx
         ldx tmpx
         bne lp

         lda $a0
         jsr printbyte
         lda $a1
         jsr printbyte
         lda $a2
         jsr printbyte</code></pre><figure><img src="https://imapenguin.com/content/images/2022/06/image-7.png" alt="" loading="lazy" width="640" height="480" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image-7.png 600w, https://imapenguin.com/content/images/2022/06/image-7.png 640w"/><figcaption>$1128(4392)</figcaption></figure><p>So at $1128 jiffies(4392) and 255 transfers of 16,384, we&#39;re seeing around 57K per second.</p><h2 id="grain-of-salt-yes-but-real-world-enough">Grain of salt, yes, but real-world enough.</h2><p>Yeah, there&#39;s some overhead in the setup and running of the transfer. We could probably make this loop a few percentage points faster. Maybe if we make it tight, we could get 15% better out of it. But the point was real-world uses, and this is a pretty good example of a tight but flexible loop to transfer. Let&#39;s not get TOO pedantic here. </p><p>What&#39;s important to note is that transferring memory takes several clock cycles per byte. If we count them, it&#39;s about a dozen cycles, which tracks roughly with our results. </p><p>The KIM-1 is arguably the most simple and pure 6502 platform, so it will be interesting to try and do memory transfers on it. </p><p>It IS clocked a little slower than a Commodore 64, so I expect it to transfer slightly slower. But it doesn&#39;t have to compete for access time as VIC-II &#34;badlines,&#34; so maybe it&#39;ll be pretty close. </p><p>Let&#39;s find out.</p><p>I don&#39;t own a &#34;real&#34; KIM-1, but I do own what is considered the best two clones. Today, let&#39;s use the <a href="https://www.corshamtech.com/">Corsham KIM-1 Clone</a>. I&#39;m going to call it a KIM-1 from here forward, mostly because I enjoy getting angry letters about this. You&#39;ve been warned.</p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_4132.jpeg" alt="" loading="lazy" width="1000" height="787" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_4132.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_4132.jpeg 1000w" sizes="(min-width: 720px) 720px"/></figure><h2 id="measuring-time">Measuring time</h2><p>The KIM-1 doesn&#39;t have a jiffy clock like the other Commodore machines. </p><p>The &#34;Application ports&#34; are easily accessible, so if we set a pin high when we start and set it low again when we finish, we can easily use an oscilloscope to measure the time.</p><p>With the expansion bus hooked up on my Corsham KIM board, the Application port A direction is set to output with. </p><figure><pre><code>	lda #$ff
	sta $1603</code></pre><figcaption>Set all ports out output</figcaption></figure><p>And then, we can toggle pin PA0 by setting it high or low. We&#39;ll use $FF and $0 for that for simplicity. </p><p><em>Side note: this is a non-standard location for this port, your KIM-1 or clone probably has it in the $1700 range. Check your documentation. </em></p><figure><img src="https://imapenguin.com/content/images/2022/06/image-4.png" alt="" loading="lazy" width="689" height="412" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image-4.png 600w, https://imapenguin.com/content/images/2022/06/image-4.png 689w"/></figure><p>16k in 262 Milliseconds is around 62.5k per second. Slightly faster than a Commodore 64 even though an NTSC Commodore 64 runs at a slightly higher clock speed (1.023MHz) than our KIM here.</p><p>Let&#39;s do this 255 times in a tight loop, ignoring the overhead of things like JSR, which takes a few clock cycles each loop. We&#39;re going for a ballpark here.</p><p>So our loop code then looks something like</p><pre><code>         lda #$ff
         sta $1603
         sta $1601 ;technically setting all pins high here
         		   ;could just use #$01


         ldx #255 
         stx tmpx
lp
         jsr copyr
         dec tmpx
         ldx tmpx
         bne lp
         
         lda #$00
         sta $1601


         brk</code></pre><p>Then if we probe it with an oscilloscope, we can measure the 1+ minute square wave.</p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_4129.jpeg" alt="" loading="lazy" width="1000" height="1334" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_4129.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_4129.jpeg 1000w" sizes="(min-width: 720px) 720px"/></figure><figure><img src="https://imapenguin.com/content/images/2022/06/image-1.png" alt="" loading="lazy" width="688" height="409" srcset="https://imapenguin.com/content/images/size/w600/2022/06/image-1.png 600w, https://imapenguin.com/content/images/2022/06/image-1.png 688w"/></figure><p>So 255 transfers of 16,384 bytes take 67 seconds. Or about 62k per second.</p><p>I happen to have a <a href="https://imapenguin.com/building-the-cerberus-2080/">Cerberus 2080 board</a>. As far as I know, mine is the only green one in the world.</p><figure><img src="https://imapenguin.com/content/images/2022/06/IMG_2197.jpeg" alt="" loading="lazy" width="1000" height="673" srcset="https://imapenguin.com/content/images/size/w600/2022/06/IMG_2197.jpeg 600w, https://imapenguin.com/content/images/2022/06/IMG_2197.jpeg 1000w" sizes="(min-width: 720px) 720px"/></figure><p>This has dual-ported RAM and can clock the brand new (yes, they still make them) WDC 65c02S processor at a blazing 8Mhz. Let&#39;s see what kind of results we get from it. </p><p>Again, we have a no jiffy clock problem, so I&#39;m going to skip right to the 4MB transfer, time it over the video capture, and have it show &#34;done&#34; on the screen when it finishes. Unlike the KIM-1, I don&#39;t have a straightforward way to time it with an I/O pin. It&#39;ll give us a good enough idea of where we are.</p><figure><div><video src="https://imapenguin.com/content/media/2022/06/cerberusmem.mp4" poster="https://img.spacergif.org/v1/800x600/0a/spacer.png" width="800" height="600" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>About 6.29 seconds</figcaption></figure><p>16,384 bytes 255 times took 6.29 seconds, so maxed out, a modern 6502 at 8MHz can do about 664.2k per second. Not too bad! </p><p>Sure, this was not a comprehensive set of tests. But in the real world, a 6502 can copy the entire contents of a Commodore 64&#39;s memory from one place to another in about a second. Pretty respectable, and it was pretty fast for the time. </p><h3 id="unrolling">Unrolling</h3><p>You could certainly use self modifying code and unroll this copy routine to get better performance at the price of flexibility and arguably understanding for the average casual 6502 assembly coder. </p><p>Again, this was not a &#34;how fast can we absolutely make it&#34; but an everyday use examination.</p><p>This copy can handle from one to 2<sup>16</sup> bytes and every number in between. And as my favorite Youtuber is fond of saying &#34;I know I know, but I didn&#39;t do that. Let the angry emails begin.&#34;</p><h3 id="reu">REU</h3><p>If you have an REU on your Commodore, that can theoretically swap out the memory at a byte per clock cycle. A true 1MB per second. I heard that games like <a href="https://www.protovision.games/games/sams_journey.php?language=en">Sam&#39;s Journey</a> make use of this feature quite a bit.</p><figure><div><video src="https://imapenguin.com/content/media/2022/06/sams.mp4" poster="https://img.spacergif.org/v1/640x480/0a/spacer.png" width="640" height="480" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Sam&#39;s Journey First Level</figcaption></figure><p>I&#39;d love to hear your thoughts on how you&#39;d approach this, pedantic, nit-picky, and otherwise. Bonus points if you demonstrate methods that show dramatically better results.</p><p>Whatever you do, be sure to have fun and don&#39;t take marketing slides too seriously.</p>
    </section></div>
  </body>
</html>
