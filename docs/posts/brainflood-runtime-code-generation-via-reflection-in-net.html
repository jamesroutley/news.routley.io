<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sbox.game/churchofmiku/brainflood/news/brainflood-compiling-via-reflection-8089c180">Original</a>
    <h1>BrainFlood: Runtime code generation via reflection in .NET</h1>
    
    <div id="readability-page-1" class="page"><div id="news-sections" b-rzd1zvawzs=""><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><div><p>Hi everyone. I wrote a <a href="https://en.wikipedia.org/wiki/Brainfuck">brainfuck</a> interpreter. It implements a few simple optimizations, but it&#39;s really nothing to write home about. I have benchmarked it against <a href="https://www.nayuki.io/page/optimizing-brainfuck-compiler">Nayuki&#39;s optimizing compiler</a> using Erik Bosman&#39;s Mandelbrot program. Here are the results:</p><figure b-l20o0naj7q=""><a href="https://cdn.sbox.game/upload/b/3288855b/4d1d/49d5/8716/2f759160fa59.png" target="_blank" b-l20o0naj7q=""><img data-zoomer="true" src="https://cdn.sbox.game/upload/b/3288855b/4d1d/49d5/8716/2f759160fa59.png" title="My interpreter takes 11.563 seconds. Nayuki&#39;s compiler takes 0.535 seconds." b-l20o0naj7q=""/></a></figure><p>Next, I wrote a compiler that can generate code at runtime. Here&#39;s the benchmark chart with it added:</p><figure b-l20o0naj7q=""><a href="https://cdn.sbox.game/upload/b/1d7e94f1/bc48/4390/a4ad/e42ae75dc05e.png" target="_blank" b-l20o0naj7q=""><img data-zoomer="true" src="https://cdn.sbox.game/upload/b/1d7e94f1/bc48/4390/a4ad/e42ae75dc05e.png" title="My compiler takes 1.22 seconds.? My interpreter takes 11.563 seconds. Nayuki&#39;s compiler takes 0.535 seconds. ?" b-l20o0naj7q=""/></a></figure><p>The technique used to build the compiler is completely absurd, but is (hopefully) safe, and is even able to work in S&amp;box&#39;s sandboxed environment! No native modules or <strong>System.Reflection.Emit</strong> needed! It can&#39;t make my simple brainfuck optimizations or .NET&#39;s JIT magically competitive with Nayuki and LLVM, but I&#39;d like to think it&#39;s an impressive result.</p></div></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><div><p>First, it may be useful to understand a few things about compilers. Beware that each of these topics could be their own blog post. If something is confusing, it might be a good idea to find a more in-depth resource to explain it. Also beware that I&#39;m a fairly knowledgeable hobbyist, but not an expert, especially on .NET. If you see something that&#39;s wrong feel free to yell at me.</p></div><pre>int x = 3 * 3 * 3 * 3 * 5 * 5;
// simplifies to:
int x = 2025;</pre><div><p>When the code is executed, it won&#39;t have to perform the multiplies. It will simply load <strong>2025</strong> into <strong>x</strong>.</p></div><pre>int Add(int x, int y) {
    return x + y;
}

int Add3(int x, int y, int z) {
    return Add(Add(x,y),z);
}

// the second function can be optimized to:
int Add3(int x, int y, int z) {
    return x + y + z;
}</pre><p>The real power of inlining isn&#39;t just that it saves time doing a call, it&#39;s that it can enable other optimizations. A function can be inlined, then constants in the resulting code can be folded:</p><pre>int Five() {
    return 5;
}

int Fifteen() {
    return Five()+Five()+Five();
}

// the second function can be optimized to:
int Fifteen() {
    return 15;
}</pre><pre>static T Min&lt;T&gt;(T a, T b) where T: IComparable {
    if (a.CompareTo(b)&lt;0) {
        return a;
    } else {
        return b;
    }
}</pre><div><p>If monomorphization is used, then calling this function with ints, floats, and strings would all generate separate code. In the separate code, the call to <strong>CompareTo</strong> can be devirtualized. Much like inlining, this can be used to enable other optimizations: Instead of just devirtualizing the call, it could be inlined.</p></div></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><p>Time for a bigger example!</p><pre>using System.Runtime.CompilerServices;

interface Number {
    static abstract int Eval();
}

class ConstDead : Number {
    public static int Eval() {
        return 0xDEAD;
    }
}

class ConstBeef : Number {
    public static int Eval() {
        return 0xBEEF;
    }
}

class Concat&lt;A,B&gt; : Number
    where A: Number
    where B: Number
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Eval() {
        return (A.Eval() &lt;&lt; 16) + B.Eval();
    }
}

class Example {
    int Run() {
        return Concat&lt;ConstDead,ConstBeef&gt;.Eval();
    }
}</pre><p>This combines a few ideas from the previous section: The three calls to Eval are monomorphically inlined and folded. If you throw this code in <a href="https://sharplab.io/">SharpLab</a>, you&#39;ll find that <strong>Example.Run()</strong> JIT compiles to two instructions:</p><pre>    L0000: mov eax, 0xdeadbeef
    L0005: ret</pre><pre>using System.Runtime.CompilerServices;

interface Number {
    int Eval();
}

struct ConstDead : Number {
    public int Eval() {
        return 0xDEAD;
    }
}

struct ConstBeef : Number {
    public int Eval() {
        return 0xBEEF;
    }
}

struct Concat&lt;A,B&gt; : Number
    where A: struct, Number
    where B: struct, Number
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Eval() {
        return (default(A).Eval() &lt;&lt; 16) + default(B).Eval();
    }
}

class Example {
    int Run() {
        return default(Concat&lt;ConstDead,ConstBeef&gt;).Eval();
    }
}</pre><p>By some miracle, the JIT is just smart enough to optimize this the same way as the static code. Presumably it helps that the structs are empty, but I&#39;m not sure whether it actually matters.</p></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><div><p>If you&#39;re familiar with brainfuck, you&#39;ll know it doesn&#39;t <strong>need</strong> to represent constants; however, they&#39;re really useful for some optimizations. My interpreter converts the brainfuck code into a bytecode which contains integer offsets. My compiler works by converting the bytecode into a disgusting ball of generic types. So I needed constants, and if I couldn&#39;t handle constants, the project was probably doomed anyway.</p></div><pre>interface Const {
    int Run();
}

// Single Hex Digits
struct D0 : Const { public int Run() =&gt; 0; }
struct D1 : Const { public int Run() =&gt; 1; }
struct D2 : Const { public int Run() =&gt; 2; }
// D3 - DD omitted
struct DE : Const { public int Run() =&gt; 0xE; }
struct DF : Const { public int Run() =&gt; 0xF; }

// Two Hex Digits
struct Num&lt;A,B&gt; : Const
    where A: struct, Const
    where B: struct, Const
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run() {
        return default(A).Run()&lt;&lt;4 | default(B).Run();
    }
}

// Negatives
struct Neg&lt;A&gt; : Const
    where A: struct, Const
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run() {
        return -default(A).Run();
    }
}</pre><p>With these building blocks, we can represent any integer constant. We can verify it works with Sharplab:</p><pre>class Example {
    int Run() {
        return default(Neg&lt;Num&lt;D2,DF&gt;&gt;).Run();
    }
}
// compiles to
    L0000: mov eax, 0xffffffd1
    L0005: ret</pre></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><p>As I mentioned before, the compiler consumes the interpreter&#39;s bytecode. The following instructions need to be converted:</p><ul><li>UpdateCell(offset, inc): Adds <strong>inc</strong> to the cell at <strong>offset</strong> from the current pointer.</li><li>UpdatePointer(offset): Modifies the current pointer by <strong>offset</strong>.</li><li>ZeroCell(offset): Sets the cell at <strong>offset</strong> from the current pointer to zero.</li><li>LoopStart(offset): Jumps forward to <strong>offset</strong> if the current cell is zero.</li><li>LoopEnd(offset): Jumps backward to <strong>offset</strong> if the current cell is nonzero.</li><li>OutputCell(offset): Writes the cell to output at <strong>offset</strong> from the current pointer.</li></ul><p>I define an Operation interface, and a struct for each instruction. Here&#39;s an example:</p><pre>interface Op {
    int Run(int index, byte[] data, Output output);
}

struct ZeroCell&lt;OFFSET,NEXT&gt; : Op
    where OFFSET: struct, Const
    where NEXT: struct, Op
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run(int index, byte[] data, Output output)
    {
        data[index + default(OFFSET).Run()] = 0;
        return default(NEXT).Run(index, data, output);
    }
}</pre><p>Most operations have a <strong>NEXT</strong> parameter, which allows us to chain them together. The final operation in a chain sets this to a <strong>Stop</strong> type, which does nothing.</p><pre>struct Stop : Op
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run(int index, byte[] data, Output output)
    {
        return index;
    }
}</pre><p>Instead of storing the current pointer in some state object, it is passed around and returned by each operation. My hope is that this will keep it in a register as much as possible, and avoid constantly loading and storing it.</p><pre>struct UpdatePointer&lt;OFFSET,NEXT&gt; : Op
    where OFFSET: struct, Const
    where NEXT: struct, Op
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run(int index, byte[] data, Output output)
    {
        index += default(OFFSET).Run();
        return default(NEXT).Run(index, data, output);
    }
}</pre><p>The LoopStart and LoopEnd instructions are converted into a single <strong>Loop</strong> type:</p><pre>struct Loop&lt;BODY,NEXT&gt; : Op
    where BODY: struct, Op
    where NEXT: struct, Op
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Run(int index, byte[] data, Output output)
    {
        var body = default(BODY);
        while (data[index] != 0) {
            output.CheckKill();
            index = body.Run(index, data, output);
        }
        return default(NEXT).Run(index, data, output);
    }
}</pre><div><p>Both <strong>BODY</strong> and <strong>NEXT</strong> are Operation chains. The call to <strong>output.CheckKill()</strong> tests whether we want to pre-emptively terminate the program, and throws an exception if we do. </p></div></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><div><p>So, we can convert a brainfuck program into a bunch of very unconventional C# code. But what about compiling at runtime? You were told it worked at runtime! Now Reflection will save the day! S&amp;box exposes a simplified reflection library, but it&#39;s enough for our purposes.</p></div><pre>    private static Type MakeGeneric(Type base_ty, Type[] args) {
        return TypeLibrary.GetType(base_ty).MakeGenericType(args);
    }

    private static Type GetDigit(int n) {
        switch (n) {
            case 0: return typeof(D0);
            case 1: return typeof(D1);
            case 2: return typeof(D2);
            case 3: return typeof(D3);
            case 4: return typeof(D4);
            case 5: return typeof(D5);
            case 6: return typeof(D6);
            case 7: return typeof(D7);
            case 8: return typeof(D8);
            case 9: return typeof(D9);
            case 0xA: return typeof(DA);
            case 0xB: return typeof(DB);
            case 0xC: return typeof(DC);
            case 0xD: return typeof(DD);
            case 0xE: return typeof(DE);
            case 0xF: return typeof(DF);
        }
        throw new Exception(&#34;die&#34;);
    }

    private static Type GenerateConst(int n) {
        if (n &lt; 0) {
            return MakeGeneric(typeof(Neg&lt;&gt;),[GenerateConst(-n)]);
        }
        if (n &lt; 16) {
            return GetDigit(n);
        } else if (n &lt; 256) {
            return MakeGeneric(typeof(Num&lt;,&gt;),[GetDigit(n&gt;&gt;4),GetDigit(n&amp;0xF)]);
        } else {
            throw new Exception(&#34;const too large &#34;+n);
        }
    }</pre><p>Building instructions is basically the same. You can take a look at the <a href="https://github.com/MDFL64/BrainFlood/blob/master/code/BrainFlood.cs#L67">full code</a>, if you want.</p></div></div>

		</div></section><section b-w12q7vm9hp=""><div b-w12q7vm9hp="">

		<div b-w12q7vm9hp=""><div b-yih7iustsx=""><p>Probably not. There are a ton of better ways to build a compiler. If you want to build one on .NET, and you aren&#39;t in a sandboxed jail, you should probably just use <strong>System.Reflection.Emit </strong>and save yourself most of the headache of hoping that the JIT will make sense of your insane garbage.</p><p>Because it&#39;s funny, and it&#39;s an opportunity to show off. I&#39;d like to credit rileyzzz and their very cool project <a href="https://sbox.game/rileyzzz/retrobox/news/dex-8601de05">DExTr</a> for some of the inspiration.</p><p>Brainfuck was really good for a prototype, given it&#39;s limited instruction set and very simple control-flow. But I really want to run webassembly. This is a much harder challenge. It will probably involve some real control-flow and data-flow analysis. It might not go anywhere. Stay tuned I guess. Maybe if I&#39;m successful we can see how much slower it is than DExTr.</p></div></div>

		</div></section></div></div>
  </body>
</html>
