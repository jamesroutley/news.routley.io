<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.landofcrispy.com/index.php/2021/01/06/clipboard-integration-between-tmux-nvim-zsh-x11-across-ssh-sessions/">Original</a>
    <h1>Clipboard integration between tmux, nvim, zsh, x11, across SSH sessions</h1>
    
    <div id="readability-page-1" class="page"><article id="post-11">
		
	
	<div>
		
<p>A long-time thorn in my side has been that several different applications in my typical workflow have independent concepts of clipboards that just don’t work well together; plus I often work with multiply nested SSH sessions, which adds another layer of difficulty.  A quick web search shows known solutions for integrating some combinations of the elements in my stack, but I wasn’t able to find an existing post with instructions on how to integrate everything seamlessly.  Finally I decided to sit down and get all my clipboards working how I’d like, and figured I’d share.</p>



<h2>The Components</h2>



<h3>tmux</h3>



<p>tmux is a core part of my workflow and provides a flexible multi-buffer clipboard to use.  It’s relatively easy to hook into its clipboard and it provides a set of command-line tools to manipulate its clipboard buffers.  For these reasons, most of my synchronization methods are based around tmux as a core, and will not function without a running tmux session.</p>



<p>tmux maintains a configurably-sized list of copy buffers.  By default, the copy buffer on top (the most recent one) is used for pasting, but any can be selected.  Buffers are named with an incrementing integer.</p>



<h3>nvim</h3>



<p>vim maintains a set of 10 copy registers that (sometimes) rotate when new text is yanked.  Register 0 corresponds to the most recent yanked text, and is shifted to register 1, 2, etc as more text is yanked.  This lines up well with the way that tmux handles buffers.</p>



<p>I use neovim for my workflow, and the vimscript here is made to work with neovim rather than vim.  I haven’t tested it with vim, but am aware of at least one relevant difference here (how SIGUSR1 is handled).  It’s likely the same script could be easily made to work with vim as well.</p>



<p>It’s worth noting that vim already has built-in integration with the X clipboard in the form of special registers, but this doesn’t handle the other cases here.</p>



<h3>zsh</h3>



<p>zsh’s line editor provides copy/paste functionality.  I use oh-my-zsh with its vim plugin which just calls the shell functions <code>clipcopy</code> and <code>clippaste</code>.  These functions can be easily overridden for integration.</p>



<h3>xclip</h3>



<p>The <code>xclip</code> utility provides easy access to the X11 clipboard.  However, there is no easy way to be notified when the clipboard changes, so a small bash daemon is used here to poll for changes.</p>



<h3>ssh</h3>



<p>I often have multiple levels of nested ssh+tmux sessions and it would be nice to have clipboard synchronized between them.  This will be discussed in more detail later.</p>



<h2>A word about security</h2>



<p>Clipboard synchronization in this manner is a great convenience, but one shouldn’t ignore possible security concerns.  Clipboards may often be used to store sensitive information, and it’s not ideal to have that pushed around to a bunch of different machines over ssh and stored in a potentially long-lived (in memory) buffer somewhere.</p>



<p>Additionally, there are attacks where an attacker can unexpectedly set a clipboard to malicious data containing escape sequences or malicious commands to run, with unexpected effects on paste.</p>



<p>One should always be wary of these concerns; but there are a few ways to mitigate them.  Firstly, do not synchronize clipboard with untrusted systems.  This method allows independently configuring which ssh sessions share clipboards.  Additionally, a ‘purge’ mechanism is included that wipes all historical clipboard buffers throughout the stack.</p>



<p>For additionally security, the automatic synchronization hooks can be left out of each step here.  The relevant commands can be triggered manually by keybinds to “move around” the clipboard to different applications and hosts (ie. by adding keybinds to move a clipboard “up” and “down” the SSH connection stack).  This is less seamless, but may be important if connecting clipboards to less trustworthy systems and using the clipboard for sensitive data.</p>



<h2>Starting out: Connecting tmux and nvim</h2>



<p>I started out by connecting in one component at a time.  The first two I chose were tmux and vim.  This integration consists of two parts: When a vim yank is executed, push a new tmux buffer; and when a tmux copy is executed, shift in a new vim copy register.  This way, buffer history is preserved, and the latest clipboard buffer is always synchronized.</p>



<h3>Syncing from vim to tmux</h3>



<p>Sending register contents from vim to tmux requires triggering a hook on yank inside vim.  It would be possible to do this via keybinds, but neovim provides an autocommand <code>TextYankPost</code> that is triggered after each yank.  This can be used to run a shell command and pipe in the yanked text.</p>



<p>The vimscript here can be added to your vim configuration, or in a separate file.</p>



<p>A small difficulty is in the way that vim handles storing registers.  Registers are either stored in character mode (which is not null-safe) or in line mode (which does not preserve whether or not there is a trailing newline).  So first, we need a function to return register contents that preserves as much as possible.  It returns a series of lines with a trailing newline marked with an empty entry.</p>



<pre><code>function! YankSyncGetRegLines(regname)
	return getreg(a:regname, 1, 1) + (getregtype(a:regname) ==# &#39;v&#39; ? [] : [&#39;&#39;])
endfunction</code></pre>



<p>Now we just need to call a shell command whenever something is yanked and pipe it to stdin:</p>



<pre><code>&#34; Look for script pushclip.sh in same directory as vim script
let s:sdir = fnamemodify(resolve(expand(&#39;&lt;sfile&gt;:p&#39;)), &#39;:h&#39;)
let s:ysshpush = s:sdir . &#39;/pushclip.sh&#39;
function! YankSyncPush(regname)
	if empty(a:regname)
		let contents = YankSyncGetRegLines(a:regname)
		call system(s:ysshpush, contents)
	endif
endfunction
augroup clipmgmt
	autocmd!
	autocmd TextYankPost * call YankSyncPush(v:event[&#39;regname&#39;])
augroup END</code></pre>



<p>The associated shell script <code>(pushclip.sh</code>) to load from stdin into a tmux buffer is pretty simple:</p>



<pre><code>#!/bin/bash
# Find a filename to use as a temp file
TEMPFILE=&#34;`tempfile 2&gt;/dev/null`&#34;
if [ $? -ne 0 ]; then
	TEMPFILE=&#34;/tmp/_clip_temp_yssh$USER&#34;
fi
# Save stdin to file
cat &gt; &#34;$TEMPFILE&#34;
# Load tmux buffer
tmux load-buffer &#34;$TEMPFILE&#34;
# Remove file
rm -f &#34;$TEMPFILE&#34;</code></pre>



<p>A word about temp files: Several components here use temporary files for brief periods of time to store clipboard data.  These may not always be necessary.  In fact, the above can become a one-liner: <code>tmux load-buffer -</code> .  But there will be more added to this script as more components are integrated, and sometimes temporary files make things easier to work with.</p>



<p>After setting this up, text yanked in vim will automatically be added as a tmux buffer.</p>



<h3>Syncing from tmux to vim</h3>



<p>Hooking into tmux copy mode can be done using keybinds in <code>tmux.conf</code>.  Very new versions of tmux include an option <code>copy-command</code> that can be used to do the same thing in a nicer way.  These keykinds are for vi mode.</p>



<pre><code>unbind-key -T copy-mode-vi y
bind-key -T copy-mode-vi y send-keys -X copy-selection-and-cancel \; run-shell -b ~/.userenv/clipboard/tmuxcopypush.sh
unbind-key -T copy-mode-vi Enter
bind-key -T copy-mode-vi Enter send-keys -X copy-selection-and-cancel \; run-shell -b ~/.userenv/clipboard/tmuxcopypush.sh
unbind-key -T copy-mode-vi A
bind-key -T copy-mode-vi A send-keys -X append-selection-and-cancel \; run-shell -b ~/.userenv/clipboard/tmuxcopypush.sh
unbind-key -T copy-mode-vi D
bind-key -T copy-mode-vi D send-keys -X copy-end-of-line \; run-shell -b ~/.userenv/clipboard/tmuxcopypush.sh
unbind-key -T copy-mode C-w
bind-key -T copy-mode C-w send-keys -X copy-selection-and-cancel \; run-shell -b ~/.userenv/clipboard/tmuxcopypush.sh</code></pre>



<p>Note that these keybinds reference <code>tmuxcopypush.sh</code> in <code>~/.userenv/clipboard</code>.  This is where I store the associated files for clipboard management; alter the paths to your desired location.</p>



<p>Next, vim needs to be notified that there is an updated clipboard.  neovim provides the <code>Signal</code> autocommand which can be used to hook into <code>SIGUSR1</code> and can be triggered externally by sending the signal.  This is not supported by vim or older versions of neovim (although I believe that vim may have an alternative).</p>



<p>The signal can be sent to running nvims with the following (saved as <code>updatevims.sh</code>):</p>



<pre><code># If nvim version is too old, it may crash on USR1, so don&#39;t try it
NVIM_VER=&#34;`nvim -v | grep &#39;^NVIM&#39; | head -n1 | cut -d &#39; &#39; -f 2`&#34;
if [[ &#34;$NVIM_VER&#34; &lt; &#34;v0.4&#34; ]]; then exit 0; fi

killall -USR1 -u `whoami` nvim &amp;&gt;/dev/null
exit 0</code></pre>



<p>Back in the vim config, when the signal is detected, call out to a shell command to get the latest clipboard buffer from tmux, then shift it into the register stack.  First check if the clipboard data has actually changed, and do nothing if it has not.  This can be important in several places to prevent clipboard-setting feedback loops.</p>



<pre><code>let s:ysshpull = s:sdir . &#39;/vimyanksyncpull.sh&#39;

&#34; Shifts register 0-&gt;1, 1-&gt;2, etc. then sets reg 0 to the given value
&#34; Expects a linewise list for newcontents
function! YankSyncShiftRegs(newcontents)
	for i in [9, 8, 7, 6, 5, 4, 3, 2, 1]
		let rtype = getregtype(i - 1)
		let rcontents = getreg(i - 1, 1, rtype ==# &#39;V&#39;)
		call setreg(i, rcontents, rtype)
	endfor
	&#34; If the new contents ends with a NL (empty list entry), remove the
	&#34; empty entry and setreg linewise.  Otherwise, setreg characterwise.
	if len(a:newcontents) == 0
		call setreg(0, [], &#39;cu&#39;)
	elseif empty(a:newcontents[-1])
		call setreg(0, a:newcontents[0:-2], &#39;lu&#39;)
	else
		call setreg(0, a:newcontents, &#39;cu&#39;)
	endif
endfunction

function! YankSyncPull()
	let newbuf = systemlist(s:ysshpull, &#39;&#39;, 1)
	if v:shell_error == 0
		let curcontents = YankSyncGetRegLines(0)
		if curcontents != newbuf
			call YankSyncShiftRegs(newbuf)
		endif
	endif
endfunction

augroup clipmgmt
	autocmd!
	autocmd TextYankPost * call YankSyncPush(v:event[&#39;regname&#39;])
	silent! autocmd Signal SIGUSR1 call YankSyncPull()
augroup END</code></pre>



<p>The script <code>vimyanksyncpull.sh</code> fundamentally just has to output the current clipboard contents.  A bit of extra logic is needed to handle edge cases.  Since <code>SIGUSR1</code> is shared as the notification mechanism between different things, we want to avoid getting nvim bogged down with spurious clipboard fetch requests, so only return a buffer if it was created within the last few seconds.  Also check to make sure it’s below a specified maximum size.  Return a nonzero exit status if no clipboard is available.</p>



<pre><code># buffer must have been created within this number of seconds
MAX_TIME_DIFF=3
# don&#39;t output if buffer too large
MAX_SIZE=100000000

csv=&#34;`tmux list-buffers -F &#39;#{buffer_created},#{buffer_size},#{buffer_name}&#39; | grep &#39;,buffer[0-9]&#39;`&#34;
if [ $? -ne 0 ]; then exit 1; fi
csv=&#34;`echo &#34;$csv&#34; | head -n1`&#34;
if [ -z &#34;$csv&#34; ]; then exit 1; fi

ctime=&#34;`echo &#34;$csv&#34; | cut -d , -f 1`&#34;
bsize=&#34;`echo &#34;$csv&#34; | cut -d , -f 2`&#34;
bname=&#34;`echo &#34;$csv&#34; | cut -d , -f 3-`&#34;
now=&#34;`date +%s`&#34;

if [ `expr $now - $ctime` -gt $MAX_TIME_DIFF ]; then exit 1; fi
if [ $bsize -gt $MAX_SIZE ]; then exit 1; fi

tmux show-buffer -b &#34;$bname&#34;</code></pre>



<p>The last remaining part is the script that tmux triggers on copy, <code>tmuxcopypush.sh</code>, referenced above in <code>tmux.conf</code>.  This currently just calls <code>updatevims.sh</code> but more will be added later.</p>



<pre><code>export MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34; # This line won&#39;t be included in further script clippings
&#34;$MYDIR/updatevims.sh&#34; &amp;&gt;/dev/null</code></pre>



<p>After reloading vim and tmux configuration, the integration between the two should be working.</p>



<h3>Loading historical buffers on vim startup</h3>



<p>The integration so far will push new tmux buffers to vim, but does not work for newly started vim sessions.  This hook in the vim config can take care of that:</p>



<pre><code>function! YankSyncPullAll()
	for i in [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
		let newbuf = systemlist(s:ysshgetbuf . &#39; &#39; . string(i), &#39;&#39;, 1)
		if v:shell_error == 0
			call YankSyncShiftRegs(newbuf)
		endif
	endfor
endfunction

augroup clipmgmt
	autocmd VimEnter * call YankSyncPullAll()
augroup END</code></pre>



<h2>Adding more sync targets: zsh and xclip</h2>



<h3>Integrating zsh</h3>



<p>With oh-my-zsh, connecting in an external clipboard involves overriding two builtin functions in zshrc:</p>



<pre><code>function clipcopy() {
	~/.userenv/clipboard/pushclip.sh
}
function clippaste() {
	~/.userenv/clipboard/getcopybuffer.sh
}</code></pre>



<p>There are 2 scripts here.  We already know about <code>pushclip.sh</code>, and we can derive <code>getcopybuffer.sh</code> from <code>vimyanksyncpull.sh</code>.  <code>getcopybuffer.sh</code> also supports returning older copy buffers with a nonzero argument.</p>



<pre><code>if [ $# -ne 1 ]; then
	N=0
else
	N=$1
fi

MAX_SIZE=100000000

# Find the name of the latest copy buffer, excluding named buffers
csv=&#34;`tmux list-buffers -F &#39;#{buffer_created},#{buffer_size},#{buffer_name}&#39; | grep &#39;,buffer[0-9]&#39;`&#34;
if [ $? -ne 0 ]; then exit 1; fi

# Get the request entry
headcount=`expr $N + 1`
csv=&#34;`echo &#34;$csv&#34; | head -n$headcount | tail -n1`&#34;
if [ -z &#34;$csv&#34; ]; then exit 1; fi

# Parse out components
ctime=&#34;`echo &#34;$csv&#34; | cut -d , -f 1`&#34;
bsize=&#34;`echo &#34;$csv&#34; | cut -d , -f 2`&#34;
bname=&#34;`echo &#34;$csv&#34; | cut -d , -f 3-`&#34;
if [ $bsize -gt $MAX_SIZE ]; then exit 2; fi

tmux show-buffer -b &#34;$bname&#34;
exit 0
</code></pre>



<h3>Integrating xclip</h3>



<p>X maintains an independent clipboard buffer, so integration is a bit more complicated than with zsh.  Pushing <em>to</em> X is easy – we just need to add a call to xclip to <code>pushclip.sh</code> and <code>tmuxcopypush.sh</code>.</p>



<p>To facilitate this, here’s a script <code>pushtogui.sh</code> that pulls the latest tmux buffer and sends it to xclip:</p>



<pre><code># make sure xclip exists
if ! command -v xclip &amp;&gt;/dev/null; then
	echo no xclip 1&gt;&amp;2
	exit 0
fi

# make sure $DISPLAY is set
if [ -z &#34;$DISPLAY&#34; ]; then
	echo no DISPLAY 1&gt;&amp;2
	exit 0
fi

MAXSIZE=10000000
MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34;

TEMPFILE=&#34;`tempfile 2&gt;/dev/null`&#34;
if [ $? -ne 0 ]; then
	TEMPFILE=&#34;/tmp/_clip_temppshgui_yssh$USER&#34;
fi

&#34;$MYDIR/getcopybuffer.sh&#34; 0 &gt; &#34;$TEMPFILE&#34;
if [ $? -ne 0 ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi
if [ -z &#34;`cat &#34;$TEMPFILE&#34;`&#34; ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi
if [ `cat &#34;$TEMPFILE&#34; | wc -c` -gt $MAXSIZE ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi

xclip -i &#34;$TEMPFILE&#34; -selection clipboard

rm -f &#34;$TEMPFILE&#34;</code></pre>



<p>Calls to this now need to be appended to <code>pushclip.sh</code> and <code>tmuxcopypush.sh</code>:</p>



<pre><code>&#34;$MYDIR/pushtogui.sh&#34;</code></pre>



<p>After that, pushing to X should work.</p>



<p>Pulling from X is a little more complicated and requires polling for a clipboard update.  This small daemon script <code>xclipwatchd_main.sh</code> should be running once in the background (a script to start it is in the repo).</p>



<pre><code>LOOP_DELAY=0.5
LOOP_DELAY_BIG=5
BIG_THRESHOLD=50000

TEMPFILE=&#34;/tmp/_clip_xcwatchd1_yssh$USER&#34;
TEMPFILE2=&#34;/tmp/_clip_xcwatchd2_yssh$USER&#34;
MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34;

update_clip() {
	fn=&#34;$1&#34;

	# make sure new contents do not equal current contents
	&#34;$MYDIR/getcopybuffer.sh&#34; 0 &gt; &#34;$TEMPFILE2&#34;
	cmp &#34;$fn&#34; &#34;$TEMPFILE2&#34; &amp;&gt;/dev/null
	if [ $? -ne 1 ]; then rm -f &#34;$TEMPFILE2&#34;; return; fi
	rm -f &#34;$TEMPFILE2&#34;

	# load new buffer into tmux and notify vims
	tmux load-buffer &#34;$fn&#34;
	&#34;$MYDIR/updatevims.sh&#34;
}

# make sure xclip exists
if ! command -v xclip &amp;&gt;/dev/null; then
	echo no xclip 1&gt;&amp;2
	exit 0
fi

# make sure $DISPLAY is set
if [ -z &#34;$DISPLAY&#34; ]; then
	echo no DISPLAY 1&gt;&amp;2
	exit 0
fi

xclip -o -selection clipboard &gt;&#34;$TEMPFILE&#34; 2&gt;/dev/null
if [ $? -ne 0 ]; then
	echo -n &#39;&#39; &gt; &#34;$TEMPFILE&#34;
fi
LSIZE=`cat &#34;$TEMPFILE&#34; | wc -c`
LHASH=&#34;`cat &#34;$TEMPFILE&#34; | md5sum | cut -d &#39; &#39; -f 1`&#34;
rm -f &#34;$TEMPFILE&#34;

# keep fetching clipboard until a change is found
# wait longer if last clip was longer
while [ 1 ]; do
	xclip -o -selection clipboard &gt;&#34;$TEMPFILE&#34; 2&gt;/dev/null
	if [ $? -ne 0 ]; then
		rm -f &#34;$TEMPFILE&#34;
		sleep $LOOP_DELAY_BIG
		continue
	fi
	CHASH=&#34;`cat &#34;$TEMPFILE&#34; | md5sum | cut -d &#39; &#39; -f 1`&#34;
	if [ &#34;$CHASH&#34; != &#34;$LHASH&#34; ]; then
		# clipboard changed
		LHASH=&#34;$CHASH&#34;
		LSIZE=`cat &#34;$TEMPFILE&#34; | wc -c`
		update_clip &#34;$TEMPFILE&#34;
	fi
	rm -f &#34;$TEMPFILE&#34;
	d=$LOOP_DELAY
	if [ $LSIZE -gt $BIG_THRESHOLD ]; then d=$LOOP_DELAY_BIG; fi
	sleep $d
done</code></pre>



<p>This script continuously loops and checks for a change in X clipboard contents.  When one is detected, after verifying that the clipboard is different from tmux’s buffer, it is pushed to tmux, and vims are notified.</p>



<h2>Integration across SSH</h2>



<p>This is the trickiest component, but also potentially the most useful.  I had the following requirements in mind:</p>



<ul><li>Integration should be practically seamless, such that anything copied into tmux, vim, etc. on one machine should be transparently moved to the other machines.</li><li>Integration should be out-of-band of the main tty to avoid lagging the interactive session.  The OSC 52 escape code allows for unidirectional clipboard transfer over a tty, which, in addition to being unidirectional, will lag the session for large clipboards.</li><li>Clipboards should be copied throughout the stack through both incoming and outgoing ssh connections.  This should work even with complex networks of SSH connections, where clipboard pushes on any machine should be propagated to the others.</li><li>Clipboards should NOT by synchronized over SSH by default, for security reasons.  Instead, they should require a specific ssh command to activate.</li><li>Transmitting data when unnecessary should be avoided where practical.</li><li>Setup of clipboard sync over ssh should be transparent and should work after configuration of my dotfiles on involved machines.</li><li>The communication mechanism should be secure and should not allow external access to the clipboard.</li></ul>



<h3>Approach</h3>



<p>With the above requirements, the initial apparent choice is tunneling over SSH.  Typically this is done with TCP sockets; but those would be difficult to use here for a few reasons.  However, SSH additionally supports UNIX file socket forwarding, which are great for this use case, and also makes it easier to secure.</p>



<p>A small shell-script daemon runs on each machine listening for clipboard updates on a UNIX socket in <code>~/.clipsync/</code>.  When an update is received, it is propagated both to local tmux etc and to other connected SSH sessions.</p>



<p>When propagating an update to other SSH sessions, it is necessary (to limit unnecessary data transfer) to not send data back to the host it originally came from, and also not send the same data multiple times to the same host in the case of multiple SSH connections between the hosts.  In lieu of a suitably reliable host identifier across hosts, a randomly generated one is used and is stored in <code>~/.clipsync/hostid</code>.</p>



<p>When a SSH connection is established, two tunnels are added on in opposite directions.  One allows the remote host to push clipboard updates to the local clipsyncd, and the other allows the local host to push clipboard updates to the remote clipsyncd.</p>



<h3>The clipsync daemon</h3>



<p>The main code for the daemon is stored in <code>clipsyncd_main.sh</code>:</p>



<pre><code>BASEDIR=&#34;$HOME/.clipsync&#34;
mkdir -p &#34;$BASEDIR&#34;
MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34;

TEMPFILE=&#34;/tmp/_clipsyncd_temp_yssh$USER&#34;
TEMPFILE2=&#34;/tmp/_clipsyncd_temp2_yssh$USER&#34;

handle_buf() {
	fn=&#34;$1&#34;
	srchost=&#34;$2&#34;

	# make sure new contents do not equal current contents
	&#34;$MYDIR/getcopybuffer.sh&#34; 0 &gt; &#34;$TEMPFILE&#34;
	S=$?
	if [ $S -ne 0 ] &amp;&amp; [ $S -ne 1 ]; then echo &#39;getcopybuffer.sh error&#39;; return; fi
	cmp &#34;$fn&#34; &#34;$TEMPFILE&#34; &amp;&gt;/dev/null
	if [ $? -ne 1 ]; then return; fi

	# load new buffer into tmux and notify vims
	tmux load-buffer &#34;$fn&#34;
	&#34;$MYDIR/updatevims.sh&#34; &amp;
	# push to gui
	&#34;$MYDIR/pushtogui.sh&#34; &amp;&gt;/dev/null &amp;

	# propagate tmux clipboard to other connected machines, excluding the source
	&#34;$MYDIR/clipsyncd_propagate.sh&#34; &#34;$srchost&#34; &amp;

}

while [ 1 ]; do
	rm -f &#34;$BASEDIR/clipsync.sock&#34;
	nc -l -U &#34;$BASEDIR/clipsync.sock&#34; &gt; &#34;$TEMPFILE&#34;
	if [ $? -eq 0 ]; then
		srchost=&#34;`head -n1 &#34;$TEMPFILE&#34;`&#34;
		bskip=&#34;`echo &#34;$srchost&#34; | wc -c`&#34;
		tail -c +`expr $bskip + 1` &#34;$TEMPFILE&#34; &gt; &#34;$TEMPFILE2&#34;
		handle_buf &#34;$TEMPFILE2&#34; &#34;$srchost&#34;
	fi
	rm -f &#34;$TEMPFILE&#34; &#34;$TEMPFILE2&#34;
done
</code></pre>



<p>This script uses netcat in a loop to listen for connections and handle them one at a time.  It’s worth noting that this can fail with rapid-fire clipboard updates.</p>



<p>After a client connects to the socket, it sends its own hostid, a newline, then the clipboard data.  On the receiving end, this is parsed out.  The clipboard data is synchronized with tmux, vim, and X, like we’ve already seen – and then a new script is called, <code>clipsyncd_propagate.sh</code>.</p>



<p>But before looking at that, here’s the client script <code>clipsyncdpush.sh</code>:</p>



<pre><code>localid=&#34;`cat ~/.clipsync/hostid`&#34;
NCOPT=&#34;&#34;
if [ `uname` != &#39;Darwin&#39; ]; then
	NCOPT=&#39;-N&#39;
fi
(echo &#34;$localid&#34; &amp;&amp; cat) | nc -U $NCOPT &#34;$1&#34;
exit $?</code></pre>



<p>This script expects the socket path as an argument.  It fetches the local hostid from file, and also includes support for Mac’s default netcat.</p>



<h3>The SSH tunnels</h3>



<p>To connect the clipsyncd sockets between machines, SSH tunnels are needed.  To do this, I’m using a wrapper around ssh <code>clipssh.sh</code>.</p>



<pre><code>localbasedir=&#34;$HOME/.clipsync&#34;

localid=&#34;`cat ~/.clipsync/hostid`&#34;
if [ $? -ne 0 ]; then
	echo &#39;clipssh: Initialization error - could not get local host id&#39; 1&gt;&amp;2
	exit 1
fi

echo &#39;clipssh: getting remote host info&#39; 1&gt;&amp;2
remoteinfo=&#34;`ssh &#34;$@&#34; &#39;cat &#34;$HOME/.clipsync/hostid&#34; &amp;&amp; echo &#34;$HOME/.clipsync&#34;&#39;`&#34;
if [ $? -ne 0 ]; then
	echo &#39;clipssh: Initialization error - could not get remote host info&#39; 1&gt;&amp;2
	exit 1
fi

remoteid=&#34;`echo &#34;$remoteinfo&#34; | head -n1`&#34;
remotebasedir=&#34;`echo &#34;$remoteinfo&#34; | head -n2 | tail -n1`&#34;
echo &#34;clipssh: remoteid=$remoteid remotebasedir=$remotebasedir&#34; 1&gt;&amp;2

sessid=&#34;`date +%s`${RANDOM}&#34;

tun_r=&#34;${remotebasedir}/sock_in/${localid}+${sessid}:${localbasedir}/clipsync.sock&#34;
tun_l=&#34;${localbasedir}/sock_out/${remoteid}+${sessid}:${remotebasedir}/clipsync.sock&#34;

echo &#34;clipssh: ssh -R $tun_r -L $tun_l $@&#34; 1&gt;&amp;2

ssh -R &#34;$tun_r&#34; -L &#34;$tun_l&#34; &#34;$@&#34;</code></pre>



<p>This script first fetches both the local and remote (over ssh) host ids, as they are needed for naming the tunneled socket filenames.  Then the actual SSH connection is established with the tunnels for the UNIX sockets.  Naming of the sockets is specific and important for the next step.</p>



<h3>Propagating clipboard updates</h3>



<p>The goal of update propagation is to send the clipboard data once to each connected host, even if there are multiple tunnels to that host.  It also needs to be able to handle and clean up after dead sockets.  The solution to this heavily leverages the filename of the tunneled sockets.</p>



<p>The filename of each tunneled socket consists of the remote hostid followed by an incrementing timestamp and then a randomized number.  This allows easily sorting to find unique hostids, and also allows sorting within each hostid to process old tunnel sockets first to make sure they get cleaned up.</p>



<p>The script <code>clipsyncd_propagate.sh</code> first finds a list of unique connected remote host ids, then processes each individually.  For each, sockets are processed from old to new and get removed if nonfunctional until it successfully connects and sends the clipboard data.</p>



<pre><code># argument is optional: host id to exclude
# fetches clipboard data from tmux

BASEDIR=&#34;$HOME/.clipsync&#34;
MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34;
localid=&#34;`cat ~/.clipsync/hostid`&#34;
excludeid=&#34;$1&#34;
MAXSIZE=10000000

listallsocks() {
	find &#34;$BASEDIR/sock_in&#34; &#34;$BASEDIR/sock_out&#34; -type s
}

listallhosts() {
	listallsocks | while read -r line; do
		bn=&#34;`basename &#34;$line&#34;`&#34;
		echo &#34;$bn&#34; | cut -d &#39;+&#39; -f 1
	done | sort | uniq
}

sendtohost() {
	host=&#34;$1&#34;
	#echo &#34;sendtohost $host&#34;
	if [ &#34;$host&#34; = &#34;$localid&#34; ]; then return; fi
	if [ ! -z &#34;$excludeid&#34; ] &amp;&amp; [ &#34;$host&#34; = &#34;$excludeid&#34; ]; then return; fi
	file=&#34;$2&#34;
	for sock in `listallsocks | grep -F &#34;/${host}+&#34; | sort`; do
		&#34;$MYDIR/clipsyncdpush.sh&#34; &#34;$sock&#34; &lt; &#34;$file&#34; &amp;&gt;/dev/null
		if [ $? -eq 0 ]; then
			break
		else
			# clean up old sockets we cant connect to
			rm -f &#34;$sock&#34;
		fi
	done
}

TEMPFILE=&#34;`tempfile 2&gt;/dev/null`&#34;
if [ $? -ne 0 ]; then
	TEMPFILE=&#34;/tmp/_clip_tempcsdp_yssh$USER&#34;
fi

&#34;$MYDIR/getcopybuffer.sh&#34; 0 &gt; &#34;$TEMPFILE&#34;
if [ $? -ne 0 ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi
if [ -z &#34;`cat &#34;$TEMPFILE&#34;`&#34; ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi
if [ `cat &#34;$TEMPFILE&#34; | wc -c` -gt $MAXSIZE ]; then rm -f &#34;$TEMPFILE&#34;; exit 0; fi

for h in `listallhosts`; do
	sendtohost &#34;$h&#34; &#34;$TEMPFILE&#34;
done

rm -f &#34;$TEMPFILE&#34;
exit 0</code></pre>



<h3>Tieing it in</h3>



<p>After the above is set up and the clipsync daemons running, each machine should be receiving any clipboard data sent to its clipsync socket; and the (tmux) clipboard on each machine should be able to be pushed through the stack using <code>clipsyncd_propagate.sh</code>, or to an individual socket with <code>clipsyncdpush.sh</code>.</p>



<p>Next, calls need to be added to <code>clipsyncd_propagate.sh</code> from each place where the local tmux clipboard can be updated.  Calls should be added just after the data is pushed into tmux.  So far, those files are: <code>pushclip.sh</code>, <code>tmuxcopypush.sh</code>, and <code>xclipwatchd_main.sh</code>.</p>



<p>Having to manually start <code>clipsyncd_main.sh</code> on each machine is annoying, so I also wanted to set it up to start automatically.  The daemon can only run once for each user, which is a bit tricky to ensure.  This quick script <code>start_clipsyncd.sh</code> checks if the process is already running (in a pretty non-ideal way) and starts it if not.</p>



<pre><code>pcount=`ps ux | grep -v grep | grep clipsyncd_main.sh | wc -l`
if [ $pcount -gt 2 ]; then exit; fi
MYDIR=&#34;$(realpath &#34;$(dirname &#34;$0&#34;)&#34;)&#34;
nohup &#34;$MYDIR/clipsyncd_main.sh&#34; &lt;/dev/null &gt;/dev/null 2&gt;&amp;1 &amp;
disown</code></pre>



<p>And I have tmux set up to start it when a new session is created (<code>tmux.conf</code>):</p>



<pre><code>set-hook -g session-created[0] &#39;run-shell -b ~/.userenv/clipboard/start_clipsyncd.sh&#39;</code></pre>



<p>And at this point, full clipboard synchronization should be working.</p>



<h2>Adding purge function</h2>



<p>As noted above, clipboards can be used to store sensitive data; and in these cases, it’s not good to leave such data in various clipboard history buffers for long periods of time.  To mitigate this, a “purge” function can be added to the clipboard synchronization stack to remove all current and historical clipboard buffers from local and connected machines (recursively).</p>



<p>This purging is triggered by pushing a sentinel value (of “!!!___PURGED___!!!”) through the clipboard stack.  The two applications that maintain historical buffers (tmux and vim) also need to detect this to wipe out their historical data.</p>



<p>First, the <code>purge_local.sh</code> script handles purging historical tmux buffers and pushing it to vim and X:</p>



<pre><code># Remove tmux buffers (only automatically named ones)
for bufname in `tmux list-buffers -F &#39;#{buffer_name}&#39; | grep &#39;^buffer[0-9]&#39;`; do
	tmux delete-buffer -b &#34;$bufname&#34;
done

# Add a tmux purge sentinel buffer to indicate a purge
echo -n &#39;!!!___PURGED___!!!&#39; | tmux load-buffer -

# Notify vims and gui
&#34;$MYDIR/updatevims.sh&#34;
&#34;$MYDIR/pushtogui.sh&#34; &amp;&gt;/dev/null</code></pre>



<p>Next, the vim script needs to be altered to detect this and handle it accordingly:</p>



<pre><code>function! YankSyncPurgeRegs(newcontents)
	for i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &#39;&#39;]
		call setreg(i, a:newcontents, &#39;c&#39;)
	endfor
endfunction

function! YankSyncPull()
	let newbuf = systemlist(s:ysshpull, &#39;&#39;, 1)
	if v:shell_error == 0
		if newbuf == [&#39;!!!___PURGED___!!!&#39;]
			call YankSyncPurgeRegs(newbuf)
		else
			let curcontents = YankSyncGetRegLines(0)
			if curcontents != newbuf
				call YankSyncShiftRegs(newbuf)
			endif
		endif
	endif
endfunction</code></pre>



<p>Here we’ve added a conditional to detect the sentinel value to <code>YankSyncPull()</code> and a new function <code>YankSyncPurgeRegs()</code> to clear out all numbered registers.</p>



<p>Now add a conditional to <code>clipsyncd_main.sh</code>to run a local purge when the sentinel value is received:</p>



<pre><code>if [ &#34;`cat &#34;$fn&#34;`&#34; = &#39;!!!___PURGED___!!!&#39; ]; then
	&#34;$MYDIR/purge_local.sh&#34;
else
	tmux load-buffer &#34;$fn&#34;
	&#34;$MYDIR/updatevims.sh&#34;
	&#34;$MYDIR/pushtogui.sh&#34; &amp;&gt;/dev/null
fi</code></pre>



<p>And, finally, a script to kick off the purge process, <code>purge.sh</code>:</p>



<pre><code>&#34;$MYDIR/purge_local.sh&#34;
&#34;$MYDIR/clipsyncd_propagate.sh&#34;</code></pre>



<p>At this point, when <code>purge.sh</code> is run, it should clear all clipboards locally and remotely.  A keybind can be set up to easily access this.</p>



<h2>Conclusion</h2>



<p>Integrating together all of these components turned out to be a bit more involved than most of the clipboard integration configurations I’ve seen.  It seems to work pretty well, but there are quite a few areas that could be improved.  If integrating many more components, it would likely be ideal to refactor this into a central process to manage clipboard synchronization; and, perhaps, implement some components in a different language like python (although one of my goals for this was to not depend on external languages).</p>



<p>There are a few parts of these files not included here for brevity, and a few alterations have been made (such as to execute some operations asynchronously for a snappier experience).  The full set of relevant scripts and configuration <a href="https://github.com/crispy1989/environment-crisp/tree/master/clipboard">can be found in my dotfiles repo here</a>.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

				
</article></div>
  </body>
</html>
