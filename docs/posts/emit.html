<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://re.factorcode.org/2024/10/emit.html">Original</a>
    <h1>Emit</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>One of the interesting aspects of a <a href="https://concatenative.org/wiki/view/Concatenative%20language">concatenative
language</a> like
<a href="https://factorcode.org">Factor</a> is that blocks of logic can be easily
extracted and easily reused since they apply logic to objects on the
<a href="https://docs.factorcode.org/content/article-stacks.html">stack</a>.</p>
<p>For example, if this was a word that operated on stack values:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>:</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    [ sqrt <span>* </span>] [ <span>swap </span>sqrt <span>+ </span>] <span>2bi </span><span>;
</span></span></span></code></pre></div><p>One change we could easily make is to extract and name the two pieces of logic:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>:</span> <span>calc-c</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>) </span>sqrt <span>* </span><span>;
</span></span></span><span><span><span>:</span> <span>calc-d</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>d</span> <span>) </span><span>swap </span>sqrt <span>+ </span><span>;
</span></span></span><span><span><span></span>
</span></span><span><span><span>:</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    [ calc-c ] [ calc-d ] <span>2bi </span><span>;
</span></span></span></code></pre></div><p>We could also convert it to operate on <a href="https://docs.factorcode.org/content/article-locals.html">local
variables</a>:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>::</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    a b sqrt <span>* </span>a sqrt b <span>+ </span><span>;
</span></span></span></code></pre></div><p>And extract those same two pieces of logic:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>::</span> <span>calc-c</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>) </span>a b sqrt <span>* </span><span>;
</span></span></span><span><span><span>::</span> <span>calc-d</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>d</span> <span>) </span>a sqrt b <span>+ </span><span>;
</span></span></span><span><span><span></span>
</span></span><span><span><span>::</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    a b calc-c a b calc-d <span>;
</span></span></span></code></pre></div><p>But, notice that we have to specify that the local variable <code>a</code> and <code>b</code>
have to be put back on the stack before we can call our <em>extracted</em> words that
make the computations.</p>
<h3 id="hypothetical-syntax">Hypothetical Syntax</h3>
<p>Today, someone on the <a href="https://discord.gg/QxJYZx3QDf">Factor Discord server</a>
asked about this very issue, wanting to have extractable pieces of logic that
would effectively be operating on nested local variables, wherever they are
used. Inspired by the goal of <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">don’t repeat
yourself</a> and the
convenience of extracting logic that operates on the data stack.</p>
<p>Specifically, they wanted to be able to take blocks of logic that operate on
named variables, and extract them in a similar manner to the logic blocks that
operate on the stack – offering this hypothetical syntax as the goal:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span>EMIT: calc-c <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>) </span>a b sqrt <span>* </span><span>;
</span></span></span><span><span><span></span>EMIT: calc-d <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>d</span> <span>) </span>a sqrt b <span>+ </span><span>;
</span></span></span><span><span><span></span>
</span></span><span><span><span>::</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    calc-c calc-d <span>;
</span></span></span></code></pre></div><p>Let’s try and build real syntax that allows this hypothetical syntax to work.</p>
<h3 id="building-the-syntax">Building the Syntax</h3>
<p>First, we make a tuple to hold a lazy variable binding:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>TUPLE:</span> <span>lazy</span> <span>token</span> <span>;
</span></span></span><span><span><span>C:</span> <span>&lt;lazy&gt;</span> <span>lazy</span>
</span></span></code></pre></div><p>Then, we need a way to generate temporary syntax words in a similar manner to
<a href="https://docs.factorcode.org/content/word-define-temp,words.html">temporary
words</a>:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>:</span> <span>define-temp-syntax</span> <span>( </span><span>quot</span> <span>-- </span><span>word</span> <span>)
</span></span></span><span><span><span></span>    [ gensym <span>dup </span>] <span>dip </span>define-syntax <span>;
</span></span></span></code></pre></div><p>We create temporary syntax words to convert each named references to lazy
variables:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>:</span> <span>make-lazy-vars</span> <span>( </span><span>names</span> <span>-- </span><span>words</span> <span>)
</span></span></span><span><span><span></span>    [ <span>dup </span>&#39;[ _ &lt;lazy&gt; <span>suffix! </span>] define-temp-syntax ] H{ } <span>map&gt;assoc </span><span>;
</span></span></span></code></pre></div><p>Given a
<a href="https://docs.factorcode.org/content/article-quotations.html">quotation</a> that
we have parsed in an <em>emit</em> description, we can build a word to replace all
these lazy variables by looking them up in the current <a href="https://docs.factorcode.org/content/word-manifest,vocabs.parser.html">vocabulary
manifest</a>:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>:</span> <span>replace-lazy-vars</span> <span>( </span><span>quot</span> <span>-- </span><span>quot&#39;</span> <span>)
</span></span></span><span><span><span></span>    [ <span>dup </span>lazy? [ token&gt;&gt; parse-word ] <span>when </span>] deep-map <span>;
</span></span></span></code></pre></div><p>And, finally, create our <em>emit</em> syntax word that parses a definition, making
lazy variables that are then replaced when the <em>emit</em> word is called in the
nested scope:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>SYNTAX: </span>EMIT:
</span></span><span><span>    scan-new-word scan-effect in&gt;&gt;
</span></span><span><span>    [ make-lazy-vars ] with-compilation-unit
</span></span><span><span>    [ parse-definition ] with-words
</span></span><span><span>    &#39;[ _ replace-lazy-vars <span>append! </span>] define-syntax <span>;
</span></span></span></code></pre></div><h3 id="using-the-syntax">Using the Syntax</h3>
<p>Now, let’s go back to our original example:</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span>EMIT: calc-c <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>) </span>a b sqrt <span>* </span><span>;
</span></span></span><span><span><span></span>EMIT: calc-d <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>d</span> <span>) </span>a sqrt b <span>+ </span><span>;
</span></span></span><span><span><span></span>
</span></span><span><span><span>::</span> <span>do-things</span> <span>( </span><span>a</span> <span>b</span> <span>-- </span><span>c</span> <span>d</span> <span>)
</span></span></span><span><span><span></span>    calc-c calc-d <span>;
</span></span></span></code></pre></div><p>Does it work?</p>
<div><pre tabindex="0"><code data-lang="factor"><span><span><span>IN:</span> <span>scratchpad</span> <span>1 2 </span>do-things
</span></span><span><span>
</span></span><span><span>--- Data stack:
</span></span><span><span><span>1.4142135623730951
</span></span></span><span><span><span>3.0
</span></span></span></code></pre></div><p>Yep! That’s kind of a neat thing to build.</p>
<p>I have added this syntax in the <a href="https://github.com/factor/factor/blob/master/extra/locals/lazy/lazy.factor">locals.lazy
vocabulary</a>,
if you want to try it out.</p>
<p>I’m not sure how useful it will be in general, but it is always fun to build
something new with <a href="https://factorcode.org">Factor</a>!</p>

</div></div>
  </body>
</html>
