<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/">Original</a>
    <h1>We found cryptography bugs in the elliptic library using Wycheproof</h1>
    
    <div id="readability-page-1" class="page"><div><p>Trail of Bits is publicly disclosing two vulnerabilities in <a href="https://www.npmjs.com/package/elliptic">elliptic</a>, a widely used JavaScript library for elliptic curve cryptography that is downloaded over 10 million times weekly and is used by close to 3,000 projects. These vulnerabilities, caused by missing modular reductions and a missing length check, could allow attackers to forge signatures or prevent valid signatures from being verified, respectively.</p><p>One vulnerability is still not fixed after a 90-day disclosure window that ended in October 2024. It remains unaddressed as of this publication.</p><p><img src="https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/wycheproof-1_hu_3649af0d86bc4e33.webp" alt="indutny/elliptic" width="1200" height="391" loading="lazy" decoding="async"/></p><p>I discovered these vulnerabilities using <a href="https://github.com/C2SP/wycheproof">Wycheproof</a>, a collection of test vectors designed to test various cryptographic algorithms against known vulnerabilities. If you’d like to learn more about how to use Wycheproof, check out <a href="https://appsec.guide/docs/crypto/wycheproof/">this guide I published</a>.</p><p>In this blog post, I’ll describe how I used Wycheproof to test the elliptic library, how the vulnerabilities I discovered work, and how they can enable signature forgery or prevent signature verification.</p><p><img src="https://blog.trailofbits.com/2025/11/18/we-found-cryptography-bugs-in-the-elliptic-library-using-wycheproof/wycheproof-2_hu_75239347734315cb.webp" alt="C2SP/wychproof" width="1200" height="600" loading="lazy" decoding="async"/></p><h2 id="methodology">Methodology</h2><p>During my internship at Trail of Bits, I wrote a <a href="https://appsec.guide/docs/crypto/wycheproof/">detailed guide</a> on using Wycheproof for <a href="https://appsec.guide/docs/crypto/">the new cryptographic testing chapter of the Testing Handbook</a>. I decided to use the elliptic library as a real-world case study for this guide, which allowed me to discover the vulnerabilities in question.</p><p>I wrote a Wycheproof testing harness for the elliptic package, as described in the guide. I then analyzed the source code covered by the various failing test cases provided by Wycheproof to classify them as false positives or real findings. With an understanding of why these test cases were failing, I then wrote proof-of-concept code for each bug. After confirming they were real findings, I began the coordinated disclosure process.</p><h2 id="findings">Findings</h2><p>In total, I identified five vulnerabilities, resulting in five CVEs. Three of the vulnerabilities were minor parsing issues. I disclosed those issues in a public pull request against the repository and subsequently requested CVE IDs to keep track of them.</p><p>Two of the issues were more severe. I disclosed them privately using the GitHub advisory feature. Here are some details on these vulnerabilities.</p><h3 id="cve-2024-48949-eddsa-signature-malleability">CVE-2024-48949: EdDSA signature malleability</h3><p>This issue stems from a missing out-of-bounds check, which is specified in the <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf#page=40">NIST FIPS 186-5</a> in section 7.8.2, “HashEdDSA Signature Verification”:</p><blockquote><p>Decode the first half of the signature as a point <code>R</code> and the second half of the signature as an integer <code>s</code>. Verify that the integer <code>s</code> is in the range of <code>0 ≤ s &lt; n</code>.</p></blockquote><p>In the elliptic library, the check that <code>s</code> is in the range of <code>0 ≤ s &lt; n</code>, to verify that it is not outside the order <code>n</code> of the generator point, is never performed. This vulnerability allows attackers to forge new valid signatures, <code>sig&#39;</code>, though only for a known signature and message pair, <code>(msg, sig)</code>.</p><p>$$
\begin{aligned}
\text{Signature} &amp;= (msg, sig) \\
sig &amp;= (R||s) \\
s&#39; \bmod n &amp;== s
\end{aligned}
$$</p><p>The following check needs to be implemented to prevent this forgery attack.</p><figure><pre tabindex="0"><code data-lang="javascript"><span><span><span>if</span> <span>(</span><span>sig</span><span>.</span><span>S</span><span>().</span><span>gte</span><span>(</span><span>sig</span><span>.</span><span>eddsa</span><span>.</span><span>curve</span><span>.</span><span>n</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>Forged signatures could break the consensus of protocols. Some protocols would correctly reject forged signature message pairs as invalid, while users of the elliptic library would accept them.</p><h3 id="cve-2024-48948-ecdsa-signature-verification-error-on-hashes-with-leading-zeros">CVE-2024-48948: ECDSA signature verification error on hashes with leading zeros</h3><p>The second issue involves the ECDSA implementation: valid signatures can fail the validation check.</p><p>These are the Wycheproof test cases that failed:</p><ul><li><code>[testvectors_v1/ecdsa_secp192r1_sha256_test.json][tc296]</code> special case hash</li><li><code>[testvectors_v1/ecdsa_secp224r1_sha256_test.json][tc296]</code> special case hash</li></ul><p>Both test cases failed due to a specifically crafted hash containing four leading zero bytes, resulting from hashing the hex string 343236343739373234 using SHA-256:</p><figure><pre tabindex="0"><code data-lang="text"><span><span>00000000690ed426ccf17803ebe2bd0884bcd58a1bb5e7477ead3645f356e7a9</span></span></code></pre></figure><p>We’ll use the secp192r1 curve test case to illustrate why the signature verification fails.</p><figure><pre tabindex="0"><code data-lang="c"><span><span><span>EC</span><span>.</span><span>prototype</span><span>.</span><span>verify</span> <span>=</span> <span>function</span> <span>verify</span><span>(</span><span>msg</span><span>,</span> <span>signature</span><span>,</span> <span>key</span><span>,</span> <span>enc</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>msg</span> <span>=</span> <span>this</span><span>.</span><span>_truncateToN</span><span>(</span><span>new</span> <span>BN</span><span>(</span><span>msg</span><span>,</span> <span>16</span><span>));</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span></span></span></code></pre></figure><p>The message must be hashed before it is parsed to the <code>verify</code> function call, which occurs outside the elliptic library. According to <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf#page=34">FIPS 186-5</a>, section 6.4.2, “ECDSA Signature Verification Algorithm,” the hash of the message must be adjusted based on the order <code>n</code> of the base point of the elliptic curve:</p><blockquote><p>If <code>log2(n) ≥ hashlen</code>, set <code>E = H</code>. Otherwise, set <code>E</code> equal to the leftmost <code>log2(n)</code> bits of <code>H</code>.</p></blockquote><p>To achieve this, the <code>_truncateToN</code> function is called, which performs the necessary adjustment. Before this function is called, the hashed message, <code>msg</code>, is converted from a hex string or array into a number object using <code>new</code> <code>BN(msg, 16)</code>.</p><figure><pre tabindex="0"><code data-lang="c"><span><span><span>EC</span><span>.</span><span>prototype</span><span>.</span><span>_truncateToN</span> <span>=</span> <span>function</span> <span>_truncateToN</span><span>(</span><span>msg</span><span>,</span> <span>truncOnly</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>var</span> <span>delta</span> <span>=</span> <span>msg</span><span>.</span><span>byteLength</span><span>()</span> <span>*</span> <span>8</span> <span>-</span> <span>this</span><span>.</span><span>n</span><span>.</span><span>bitLength</span><span>();</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>delta</span> <span>&gt;</span> <span>0</span><span>)</span>
</span></span><span><span>    <span>msg</span> <span>=</span> <span>msg</span><span>.</span><span>ushrn</span><span>(</span><span>delta</span><span>);</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>};</span></span></span></code></pre></figure><p>The delta variable calculates the difference between the size of the hash and the order <code>n</code> of the current generator for the curve. If <code>msg</code> occupies more bits than <code>n</code>, it is shifted by the difference. For this specific test case, we use secp192r1, which uses 192 bits, and SHA-256, which uses 256 bits. The hash should be shifted by 64 bits to the right to retain the leftmost 192 bits.</p><p>The issue in the elliptic library arises because the <code>new BN(msg, 16)</code> conversion removes leading zeros, resulting in a smaller hash that takes up fewer bytes.</p><figure><pre tabindex="0"><code data-lang="text"><span><span>690ed426ccf17803ebe2bd0884bcd58a1bb5e7477ead3645f356e7a9</span></span></code></pre></figure><p>During the delta calculation, <code>msg.byteLength()</code> then returns 28 bytes instead of 32.</p><figure><pre tabindex="0"><code data-lang="javascript"><span><span><span>EC</span><span>.</span><span>prototype</span><span>.</span><span>_truncateToN</span> <span>=</span> <span>function</span> <span>_truncateToN</span><span>(</span><span>msg</span><span>,</span> <span>truncOnly</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>var</span> <span>delta</span> <span>=</span> <span>msg</span><span>.</span><span>byteLength</span><span>()</span> <span>*</span> <span>8</span> <span>-</span> <span>this</span><span>.</span><span>n</span><span>.</span><span>bitLength</span><span>();</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>};</span></span></span></code></pre></figure><p>This miscalculation results in an incorrect delta of <code>32 = (288 - 192)</code> instead of <code>64 = (328 - 192)</code>. Consequently, the hashed message is not shifted correctly, causing verification to fail. This issue causes valid signatures to be rejected if the message hash contains enough leading zeros, with a probability of 2<sup>-32</sup>.</p><p>To fix this issue, an additional argument should be added to the verification function to allow the hash size to be parsed:</p><figure><pre tabindex="0"><code data-lang="javascript"><span><span><span>EC</span><span>.</span><span>prototype</span><span>.</span><span>verify</span> <span>=</span> <span>function</span> <span>verify</span><span>(</span><span>msg</span><span>,</span> <span>signature</span><span>,</span> <span>key</span><span>,</span> <span>enc</span><span>,</span> <span>msgSize</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>msg</span> <span>=</span> <span>this</span><span>.</span><span>_truncateToN</span><span>(</span><span>new</span> <span>BN</span><span>(</span><span>msg</span><span>,</span> <span>16</span><span>),</span> <span>undefined</span><span>,</span> <span>msgSize</span><span>);</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>EC</span><span>.</span><span>prototype</span><span>.</span><span>_truncateToN</span> <span>=</span> <span>function</span> <span>_truncateToN</span><span>(</span><span>msg</span><span>,</span> <span>truncOnly</span><span>,</span> <span>msgSize</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>var</span> <span>size</span> <span>=</span> <span>(</span><span>typeof</span> <span>msgSize</span> <span>===</span> <span>&#39;undefined&#39;</span><span>)</span> <span>?</span> <span>(</span><span>msg</span><span>.</span><span>byteLength</span><span>()</span> <span>*</span> <span>8</span><span>)</span> <span>:</span> <span>msgSize</span><span>;</span>
</span></span><span><span>  <span>var</span> <span>delta</span> <span>=</span> <span>size</span> <span>-</span> <span>this</span><span>.</span><span>n</span><span>.</span><span>bitLength</span><span>();</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>};</span></span></span></code></pre></figure><h2 id="on-the-importance-of-continuous-testing">On the importance of continuous testing</h2><p>These vulnerabilities serve as an example of why continuous testing is crucial for ensuring the security and correctness of widely used cryptographic tools. In particular, Wycheproof and other actively maintained sets of cryptographic test vectors are excellent tools for ensuring high-quality cryptography libraries. We recommend including these test vectors (and any other relevant ones) in your CI/CD pipeline so that they are rerun whenever a code change is made. This will ensure that your library is resilient against these specific cryptographic issues both now and in the future.</p><h2 id="coordinated-disclosure-timeline">Coordinated disclosure timeline</h2><p>For the disclosure process, we used GitHub’s integrated security advisory feature to privately disclose the vulnerabilities and used the <a href="https://github.com/github/securitylab/blob/main/docs/report-template.md">report template</a> as a template for the report structure.</p><p>July 9, 2024: We discovered failed test vectors during our run of Wycheproof against the elliptic library.</p><p>July 10, 2024: We confirmed that both the ECDSA and EdDSA module had issues and wrote proof-of-concept scripts and fixes to remedy them.</p><h3 id="for-cve-2024-48949">For CVE-2024-48949</h3><p>July 16, 2024: We disclosed the EdDSA signature malleability issue using the GitHub security advisory feature to the elliptic library maintainers and created a private pull request containing our proposed fix.</p><p>July 16, 2024: The elliptic library maintainers confirmed the existence of the EdDSA issue, merged our proposed <a href="https://github.com/indutny/elliptic/commit/7ac5360118f74eb02da73bdf9f24fd0c72ff5281">fix</a>, and created a new version without disclosing the issue publicly.</p><p>Oct 10, 2024: We requested a CVE ID from MITRE.</p><p>Oct 15, 2024: As 90 days had elapsed since our private disclosure, this vulnerability became public.</p><h3 id="for-cve-2024-48948">For CVE-2024-48948</h3><p>July 17, 2024: We disclosed the ECDSA signature verification issue using the GitHub security advisory feature to the elliptic library maintainers and created a private pull request containing our proposed fix.</p><p>July 23, 2024: We reached out to add an additional collaborator to the ECDSA GitHub advisory, but we received no response.</p><p>Aug 5, 2024: We reached out asking for confirmation of the ECDSA issue and again requested to add an additional collaborator to the GitHub advisory. We received no response.</p><p>Aug 14, 2024: We again reached out asking for confirmation of the ECDSA issue and again requested to add an additional collaborator to the GitHub advisory. We received no response.</p><p>Oct 10, 2024: We requested a CVE ID from MITRE.</p><p>Oct 13, 2024: Wycheproof test developer Daniel Bleichenbacher independently discovered and disclosed <a href="https://github.com/indutny/elliptic/issues/321">issue #321</a>, which is related to this discovery.</p><p>Oct 15, 2024: As 90 days had elapsed since our private disclosure, this vulnerability became public.</p></div></div>
  </body>
</html>
