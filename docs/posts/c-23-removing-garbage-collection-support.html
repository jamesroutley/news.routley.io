<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sandordargo.com/blog/2023/11/01/cpp23-garbage-collection">Original</a>
    <h1>C&#43;&#43;23: Removing garbage collection support</h1>
    
    <div id="readability-page-1" class="page"><div><p>If we go through the list of C++23 features, we can stumble upon the notion of garbage collection twice. Once among the language and once among the library features. Both entries refer to the same paper (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2186r2.html">P2186R2</a>): garbage collection (<em>GC</em> in short) support is getting removed from C++. Just to make it clear, it’s not getting deprecated, but it’s getting completely removed. As it’s an unimplemented and unsupported feature, removing it is a nice act of language cleanup. It also wouldn’t be surprising if you never heard about GC in C++.</p><p>The first surprise this paper might give you is the fact that it talks about Garbage Collection and C++. When I was learning about C++ in comparison with Java a long long time ago, one advantage of C++ was deterministic memory management due to the lack of garbage collection.</p><p>As it turns out, in 2008 a <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm">minimal support for garbage collection and reachability-based leak detection</a> was added to C++0x. This paper was based on two earlier ones, you’ll find the reference for those in the previously referenced one. Standard-conform garbage collectors should take into account <em>strict pointer safety</em>. In fact, there is no such garbage collectors in major standard libraries.</p><blockquote><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm">N2670</a>) introduced the <code>std::pointer_safety</code> enumeration with three enumerators: <code>relaxed</code>, <code>preferred</code>, <code>strict</code>. When <code>std::get_pointer_safety()</code> is called, an implementation will return a value indicating how it treats pointers that are not safely derived (see below).</p><ul><li><code>pointer_safety::relaxed</code> is returned if non-safely-derived pointers will be treated the same as pointers that are safely derived for the duration of the program</li><li><code>pointer_safety::preferred</code> is returned if non-safely-derived pointers will be treated also the same as safely-derived pointers, but at the same time, the implementation is allowed to hint that it’s desirable to avoid dereferencing such pointers</li><li><code>pointer_safety::strict</code> is returned if non-safely-derived pointers might be treated differently than pointers that are safely derived.</li></ul></blockquote><blockquote><p>A pointer value is a <em>safely-derived pointer</em> to a dynamic object only if it has pointer-to-object type and it is:</p><ul><li>the value returned by a call to the C++ standard library implementation of ::operator new(std::size_t); the result of taking the address of a subobject of an lvalue resulting from dereferencing a safely-derived pointer value;</li><li>the result of well-defined pointer arithmetic using a safely-derived pointer value;</li><li>the result of a well-defined pointer conversion of a safely-derived pointer value;</li><li>the result of a reinterpret_cast of a safely-derived pointer value;</li><li>the result of a reinterpret_cast of an integer representation of a safely-derived pointer value;</li><li>the value of an object whose value was copied from a traceable pointer object, where at the time of the copy the source object contained a copy of a safely-derived pointer value.</li></ul></blockquote><p>The standard lets implementations get away with basically any, even no-op implementations of GC and therefore it makes very little sense to have them in the standard. This doesn’t mean though that there haven’t been any successful garbage collectors for C++. The most often use case for GC implemented in C++ is having virtual machines written in C++ for other languages that are garbage collected. Different JavaScript VMs are like that and Lua as well.</p><p>But those garbage collectors also have their own set of requirements which are influenced much more by the language they help as their runtime than the C++ standard.</p><p>While <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2186r2.html">P2186R2</a> lists more concerns, I find it important to highlight two of them.</p><p>When you read above about <code>std::pointer_safety</code>, did you understand the difference between <code>relaxed</code> and <code>preferred</code>? If you did, please explain in the comments section. It’s totally unclear what well-behaved programs should do when they are given this information. It only brings confusion with any benefits.</p><p>The other problem is the definition of <em>safely-derived pointers</em>. In order to get a <em>safely-derived pointer</em>, you must use the global <code>::operator new</code> and there are no other implementation-defined ways to get such pointers. This is a problem because people often want to use other <code>new</code>s or want to avoid their usage completely to create objects in local arrays while avoiding heap usage.</p><p>As a consequence, garbage collection has been removed from C++23 with a great majority as well as pointer safety. The following names are removed from <code>std::</code></p><ul><li><code>declare_reachable</code></li><li><code>undeclare_reachable</code></li><li><code>declare_no_pointers</code></li><li><code>undeclare_no_pointers</code></li><li><code>get_pointer_safety</code></li><li><code>pointer_safety</code></li></ul><h2 id="conclusion">Conclusion</h2><p>Garbage collection and related features are being removed from C++23. If you are surprised to learn that the C++ standard had support for GC, you are not alone. It was unimplemented, confusing and pretty useless hence it’s removed. While there are existing garbage collectors, mostly for VMs written in C++ as a runtime for other languages, they are not impacted as they were not relying on the standard, exactly because of the reasons it’s getting removed.</p><p>A bit of simplification to the standard never hurts.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,</li><li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></li><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</li></ul><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p></div><div><div><p> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</p><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a>  </p></div></div></div>
  </body>
</html>
