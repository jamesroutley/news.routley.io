<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lesswrong.com/posts/D7PumeYTDPfBTp3i7/the-waluigi-effect-mega-post">Original</a>
    <h1>The Waluigi Effect</h1>
    
    <div id="readability-page-1" class="page"><div>
  
	
  
    <p>I recently started learning Rust by working through <a href="https://doc.rust-lang.org/book/">the online book for the Rust programming language</a>, and I appreciate it a lot!</p>

<p>(Why learn Rust? I dunno, I hear itâ€™s great for concurrency, type safety, and performance issues in distributed systems, and a lot of people in my Recurse batch are using Rust. So why not. Learning is always more fun with camaraderie.)</p>

<p>The Rust book explains the low-level nuances very thoroughly and socratically, and the documentation feels exceptional so far. The standard package manager / build tool, <code>cargo</code>, comes with a really nice command called <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html"><code>cargo doc</code></a> that generates the HTML documentation for a package and all its dependencies!</p>

<p>Of course, what works for me may not work well for you. My <strong>learning context</strong>:</p>
<ul>
  <li>my first languages were C and C++</li>
  <li>I tend to learn best visually or through text</li>
  <li>Iâ€™ve previously worked in Golang, another relatively young, concurrency-minded compiled language</li>
</ul>

<p>The Rust book is pretty chock full of explanations, and is more geared toward people with experience in another strongly typed language, so I love it but itâ€™s obviously not ideal for everyone. However, the official Rust website offers multiple <a href="https://www.rust-lang.org/learn">beginner learning resources</a> to cater to people whose learning style doesnâ€™t involve reading books, which I think is extra cool of them!</p>

<p>At the end of Chapter 3 of the Rust book, an innocuous example exercise was offered:</p>

<blockquote>
  <p>Convert temperatures between Fahrenheit and Celsius.</p>
</blockquote>

<p>My Python brain naively suggested that this would be a simple 5-line exercise, and of course was vastly wrong. I learned a lot more fun facts about Rust in the process than I had anticipated, and as usual, decided to lock in my learnings (at cost of 3x the labor) by writing up the process!</p>



<p>First, letâ€™s take in an input string describing a temperature in either Fahrenheit or Celsius. For simplicity, I just started with positive integer values.</p>

<h2 id="regexing-the-input">Regexing the input</h2>

<p>To match a positive integer followed by <code>F</code> or <code>C</code>, we might construct this regex:</p>

<p><code>\d+ [FC]</code></p>

<p>I figured I might as well make the space optional and match the <code>Â°</code> degree mark, in case I was pasting in a value from somewhere.</p>

<p><code>\d+ ?Â°?[FC]</code></p>

<p>Iâ€™m also going to match the start and end of the line, because I donâ€™t want to validate inputs with extra junk info. In other words, <code>10F</code> is valid, but <code>foo10Fbar</code> should not pass.</p>

<p><code>^\d+ ?Â°?[FC]$</code></p>

<p>Finally, Iâ€™m going to use named capture groups to match the numeric value and the <code>F</code>/<code>C</code> from the input string.</p>

<p><code>^(?P&lt;val&gt;\d+) ?Â°?(?P&lt;scale&gt;[FC])$</code></p>

<h3 id="lazy-static-compilation-for-regexes">Lazy static compilation for regexes</h3>

<p>You could just use the vanilla <a href="https://docs.rs/regex/1.7.1/regex/"><code>regex</code> library</a> to do the job.</p>

<p>However, the documentation included a helpful <a href="https://docs.rs/regex/1.7.1/regex/#example-avoid-compiling-the-same-regex-in-a-loop">heads up</a> about making sure that regexes only get statically compiled exactly once if youâ€™re passing them around, since regex compilation is quite expensive. (<a href="https://doc.rust-lang.org/std/keyword.static.html">Statics</a> are sort of like global variables.) I went this route since it seemed useful to know for future reference.</p>

<p>Thereâ€™s a <code>lazy_static</code> library that makes it simpler to declare lazily evaluated statics that are executed at runtime. In other words, it will make sure itâ€™s only compiled once the first time itâ€™s used, and the old value is globally reused thereafter.</p>

<p>For regexes specifically, there is also a <a href="https://docs.rs/lazy-regex/latest/lazy_regex/"><code>lazy_regex</code> library</a> which makes things even simpler. It provides a <code>regex!</code> macro that wraps up the lazy static initialization out of sight for you.</p>

<div><div><pre><code><span>let</span> <span>re</span> <span>=</span> <span>regex!</span><span>(</span><span>r&#34;^(\d+) ?Â°?([FC])$&#34;</span><span>);</span>
</code></pre></div></div>

<h2 id="validating--capturing-inputs">Validating &amp; capturing inputs</h2>

<p>First, here are some inputs that <strong>shouldnâ€™t</strong> match our regex.</p>

<div><div><pre><code><span>// Test inputs that shouldn&#39;t parse, but also shouldn&#39;t panic</span>
<span>for</span> <span>s</span> <span>in</span> <span>[</span><span>&#34;10&#34;</span><span>,</span> <span>&#34; 10&#34;</span><span>,</span> <span>&#34;10 &#34;</span><span>,</span> <span>&#34;10X&#34;</span><span>,</span> <span>&#34;foobar&#34;</span><span>,</span> <span>&#34;foo10Fbar&#34;</span><span>,</span> <span>&#34;30FFFF&#34;</span><span>]</span> <span>{</span>
    <span>assert_eq!</span><span>(</span><span>re</span><span>.is_match</span><span>(</span><span>s</span><span>),</span> <span>false</span><span>,</span> <span>&#34;&#39;{s}&#39; is not a valid input&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here are some valid inputs.</p>
<div><div><pre><code><span>// Test valid inputs</span>
<span>for</span> <span>s</span> <span>in</span> <span>[</span><span>&#34;10F&#34;</span><span>,</span> <span>&#34;10Â°F&#34;</span><span>,</span> <span>&#34;10 F&#34;</span><span>,</span> <span>&#34;10 Â°F&#34;</span><span>,</span> <span>&#34;10 C&#34;</span><span>]</span> <span>{</span>
    <span>assert_eq!</span><span>(</span><span>re</span><span>.is_match</span><span>(</span><span>s</span><span>),</span> <span>true</span><span>,</span> <span>&#34;failed to match &#39;{s}&#39;&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>We can then extract the captured matches and unwrap them.</p>
<ul>
  <li><code>captures</code> pulls out the groups that we put in parentheses in the regex.</li>
  <li><code>unwrap()</code> is a handler for a <code>Result</code> instance, which will either give us the value inside the <code>Result</code>, or panic if we received an error. Handy to not have to deal with errors you really shouldnâ€™t be getting, although in other cases, you might actually want to do something with that error other than crash the whole program.</li>
</ul>

<div><div><pre><code><span>// Test valid inputs</span>
<span>for</span> <span>s</span> <span>in</span> <span>[</span><span>&#34;10F&#34;</span><span>,</span> <span>&#34;10Â°F&#34;</span><span>,</span> <span>&#34;10 F&#34;</span><span>,</span> <span>&#34;10 Â°F&#34;</span><span>,</span> <span>&#34;10 C&#34;</span><span>]</span> <span>{</span>
    <span>assert_eq!</span><span>(</span><span>re</span><span>.is_match</span><span>(</span><span>s</span><span>),</span> <span>true</span><span>,</span> <span>&#34;failed to match &#39;{s}&#39;&#34;</span><span>);</span>
    <span>let</span> <span>cap</span> <span>=</span> <span>re</span><span>.captures</span><span>(</span><span>s</span><span>)</span><span>.unwrap</span><span>();</span>
    <span>println!</span><span>(</span><span>&#34;&#39;{s}&#39;</span><span>\t</span><span> captures: &#39;{}&#39;, &#39;{}&#39;&#34;</span><span>,</span> <span>&amp;</span><span>cap</span><span>[</span><span>&#34;val&#34;</span><span>],</span> <span>&amp;</span><span>cap</span><span>[</span><span>&#34;scale&#34;</span><span>]);</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>&#39;10F&#39;    captures: &#39;10&#39;, &#39;F&#39;
&#39;10Â°F&#39;	 captures: &#39;10&#39;, &#39;F&#39;
&#39;10 F&#39;	 captures: &#39;10&#39;, &#39;F&#39;
&#39;10 Â°F&#39;	 captures: &#39;10&#39;, &#39;F&#39;
&#39;10 C&#39;	 captures: &#39;10&#39;, &#39;C&#39;
</code></pre></div></div>



<p>Great, letâ€™s actually convert some temperatures now!</p>

<div><div><pre><code><span>let</span> <span>val</span><span>:</span> <span>u32</span> <span>=</span> <span>cap</span><span>[</span><span>&#34;val&#34;</span><span>]</span><span>.parse</span><span>()</span><span>.expect</span><span>(</span><span>&#34;Not a number!&#34;</span><span>);</span>
<span>// F -&gt; C</span>
<span>if</span> <span>cap</span><span>[</span><span>&#34;scale&#34;</span><span>]</span> <span>==</span> <span>&#34;F&#34;</span> <span>{</span>
  <span>let</span> <span>converted</span> <span>=</span> <span>(</span><span>val</span> <span>-</span> <span>32</span><span>)</span> <span>*</span> <span>5</span><span>/</span><span>9</span><span>;</span>
  <span>println!</span><span>(</span><span>&#34;{val}Â°F = {converted}Â°C&#34;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>Input an integer temperature value, e.g. &#39;50F&#39; or &#39;10C&#39;
&gt; 30F
thread &#39;main&#39; panicked at &#39;attempt to subtract with overflow&#39;, src/main.rs:42:25
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre></div></div>

<p>Oh no, overflow! Are we supposed to be using <a href="https://docs.rs/num/latest/num/trait.CheckedSub.html"><code>checked_sub</code></a> instead of normal subtraction?? ðŸ˜±</p>

<h2 id="oops-types-lets-handle-negative-values">Oops, types! Letâ€™s handle negative values.</h2>

<p>Those of you with keener eyes for type declarations may have noticed that I messed up twice:</p>
<ol>
  <li>By absent-mindedly using an unsigned int type, <code>u32</code>, which doesnâ€™t reflect that the Celsius and Fahrenheit scales can have negative values</li>
  <li>By procrastinating dealing with negative numeric values</li>
</ol>

<p>Nevertheless, I was overjoyed to bump into Rustâ€™s overflow safety system so soon, and look forward to a future glorious day when it will surely divert me from silly errors that, in a less safe language, might otherwise wreck my day in prod.</p>

<p>After changing the type declaration to <code>i32</code> signed ints and going back to update the regex (and test cases!) to handle negative values, everything works fine.</p>

<div><div><pre><code><span>let</span> <span>re</span> <span>=</span> <span>regex!</span><span>(</span><span>r&#34;^(?P&lt;val&gt;-?\d+) ?Â°?(?P&lt;scale&gt;[FC])$&#34;</span><span>);</span>
<span>let</span> <span>cap</span> <span>=</span> <span>re</span><span>.captures</span><span>(</span><span>&amp;</span><span>input</span><span>)</span><span>.unwrap</span><span>();</span>
<span>let</span> <span>val</span><span>:</span> <span>i32</span> <span>=</span> <span>cap</span><span>[</span><span>&#34;val&#34;</span><span>]</span><span>.parse</span><span>()</span><span>.expect</span><span>(</span><span>&#34;Not a number!&#34;</span><span>);</span>

<span>if</span> <span>cap</span><span>[</span><span>&#34;scale&#34;</span><span>]</span> <span>==</span> <span>&#34;F&#34;</span> <span>{</span>
  <span>// F -&gt; C</span>
  <span>let</span> <span>converted</span> <span>=</span> <span>(</span><span>val</span> <span>-</span> <span>32</span><span>)</span> <span>*</span> <span>5</span><span>/</span><span>9</span><span>;</span>
  <span>println!</span><span>(</span><span>&#34;{val}Â°F = {converted}Â°C&#34;</span><span>)</span>
<span>}</span> <span>else</span> <span>if</span> <span>cap</span><span>[</span><span>&#34;scale&#34;</span><span>]</span> <span>==</span> <span>&#34;C&#34;</span> <span>{</span>
  <span>// C -&gt; F</span>
  <span>let</span> <span>converted</span> <span>=</span> <span>val</span> <span>*</span> <span>9</span><span>/</span><span>5</span> <span>+</span> <span>32</span><span>;</span>
  <span>println!</span><span>(</span><span>&#34;{val}Â°C = {converted}Â°F&#34;</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code>Input an integer temperature value, e.g. &#39;-50F&#39; or &#39;10C&#39;
&gt; -61F
-61Â°F = -51Â°C
</code></pre></div></div>

<p>Note that -61Â°F is actually equivalent to -51.666â€¦C, which should round to -52Â°C. Since I never added float handling, weâ€™re getting these integer values through truncation rather than rounding. In other words, the decimal part is just getting chopped off. Letâ€™s go back and fix that now.</p>

<h2 id="float-handling">Float handling</h2>

<p>The updated regex:</p>

<p><code>^(?P&lt;val&gt;-?\d*\.?\d+) ?Â°?(?P&lt;scale&gt;[FC])$</code></p>

<p>Yeah, no one likes reading another personâ€™s regex. The key change: <code>\d*\.?</code>.</p>

<div><div><pre><code>&#39;.5C&#39;	 captures: &#39;0.5&#39;, &#39;C&#39;
&#39;0.5C&#39;	 captures: &#39;0.5&#39;, &#39;C&#39;
&#39;-1.5C&#39;	 captures: &#39;-1.5&#39;, &#39;C&#39;
</code></pre></div></div>

<p>I then went back and changed everything to floating point arithmetic, which I probably should have just done in the first place. I also looked up the <a href="https://doc.rust-lang.org/std/fmt/#precision">string formatting</a> rules for float precision, because who ever needs more than three sig figs.</p>

<div><div><pre><code>Input a temperature value, e.g. &#39;-50F&#39; or &#39;10.5C&#39;
&gt; -61F
-61Â°F = -51.667Â°C
</code></pre></div></div>

<h2 id="absolute-zero">Absolute zero</h2>

<p>You may notice that itâ€™s possible to input some temperatures which are definitionally impossible in real life.</p>

<div><div><pre><code>&gt; -9000F
-9000Â°F = -5017.778Â°C
</code></pre></div></div>

<p>Letâ€™s add checks for <a href="https://en.wikipedia.org/wiki/Absolute_zero">absolute zero</a>.</p>

<div><div><pre><code><span>const</span> <span>ABS_ZERO_C</span><span>:</span> <span>f64</span> <span>=</span> <span>-</span><span>273.15</span><span>;</span>
<span>const</span> <span>ABS_ZERO_F</span><span>:</span> <span>f64</span> <span>=</span> <span>-</span><span>459.67</span><span>;</span>
</code></pre></div></div>

<div><div><pre><code>&gt; -9000F
Value must be &gt;= absolute zero (-459.67Â°F)
</code></pre></div></div>

<h2 id="thats-all-i-can-think-of-for-now">Thatâ€™s all I can think of for now</h2>

<p>â€¦until I get into using Rust to compile juicy homemade CLI tools, which Iâ€™m very excited for! â€˜Til then, I shall delve further into the Rust book.</p>

  
</div></div>
  </body>
</html>
