<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2025-08-04-code-review-can-be-better/">Original</a>
    <h1>Code review can be better</h1>
    
    <div id="readability-page-1" class="page"><article id="blogpost">
  
  
  <div><p>Slightly unusual genre today: a <a href="https://github.com/tigerbeetle/tigerbeetle/pull/3129">negative
result</a> about our <a href="https://github.com/tigerbeetle/tigerbeetle/pull/2732"><code>git-review</code></a>
tool for a different take on code review process, which we decided to
shelve, at least for the time being.</p>
<p>A lot of people are unsatisfied with GitHub’s code review process.
One of the primary issues is that GitHub poorly supports stacked pull
requests and <a href="https://gist.github.com/thoughtpolice/9c45287550a56b2047c6311fbadebed2">interdiff
reviews</a>. While I also see interdiff as valuable, it’s not the reason
why I decided to experiment with <code>git-review</code>. I have two
other problems with GitHub, and with every single other code review
system, with the exception of <a href="https://www.janestreet.com/tech-talks/janestreet-code-review/">the
thing that Jane Street uses internally</a>:</p>
<ul>
<li>review state is not stored as a part of repository itself,</li>
<li>review is done via remote-first web-interface.</li>
</ul>
<h2 id="optimal-workflow"><a href="#optimal-workflow" aria-hidden="true">Optimal Workflow</a></h2>
<p>Let’s start with the second one.</p>
<p>By the way of analogy, I don’t use GitHub’s web editor to write code.
I clone a repository locally, and work in my editor, which is:</p>
<ul>
<li>fully local, memory/nvme latencies, no HTTP round-trips,</li>
<li>tailored to my specific odd workflow.</li>
</ul>
<p>When I review code, I like to pull the source branch locally. Then I
soft-reset the code to mere base, so that the code looks as if it was
written by me. Then I fire up magit, which allows me to effectively
navigate both through the diff, and through the actual code. And I even
use git staging area to mark files I’ve already reviewed:</p>
<p><img src="https://tigerbeetle.com/blog/2025-08-04-code-review-can-be-better/magit-review.webp" alt="code review in magit"/></p>
<p>Reviewing <em>code</em> rather than diff is so powerful: I can run
the tests, I can go to definition to get the context, I can try out my
refactoring suggestions in-place, with code completion and the other
affordances of my highly sophisticated code editor.</p>
<p>Alas, when I want to actually leave feedback on the PR, I have to
open the browser, navigate to the relevant line in the diff, and (after
waiting for several HTTP round-trips) type my suggestion into a text
area. For some reason, the text area also regularly lags for me,
especially on larger diffs.</p>
<p>Two things are wrong here. On the interface side, review feedback is
text related to the code. The most natural interface is to just leave
review comments as inline comments in the code, or even to fix the code
directly:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>// CR(matklad): Hm, this check seems imprecise to me.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>// Shouldn&#39;t we compare `replica.view` instead of `header.view` here?</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>if</span> (header<span>.</span>view <span>!=</span> view) <span>return</span>;</span></code></pre></div>
<p>And on the implementation side, because the data is stored in a
remote database, rather than in a local git repository, we get all those
latency-inducing round-trips (not to mention vendor lock in).</p>
<p>Thus, <a href="https://github.com/tigerbeetle/tigerbeetle/pull/2732"><code>git-review</code></a>
was born. The idea is simple:</p>
<ul>
<li>Code review is a single commit which sits on top of the PR
branch.</li>
<li>That commit adds a bunch of code comments with specific
markers.</li>
<li>Review process involves both the author and the reviewer modifying
this top commit (so, there’s a fair amount of
<code>git push --force-with-lease</code> involved).</li>
<li>The review concludes when all threads were marked as
<code>//? resolved</code> and an explicit revert commit is added on top
(such that review is preserved in the history).</li>
</ul>
<h2 id="the-devil-in-the-detail"><a href="#the-devil-in-the-detail" aria-hidden="true">The Devil in The Detail</a></h2>
<p>It didn’t exactly fail, but wasn’t a spectacular success. When it
comes to writing tools, I am a huge fan of getting-rich-quick schemes,
of writing 500 lines of <a href="https://matklad.github.io/2024/02/10/window-live-constant-time-grep.html">hacky,
use-case specific code</a> which works better for <em>that</em> use-case
than <a href="https://burntsushi.net/ripgrep/">something serious</a>. A
simple script for converting <em>your</em> <code>.md</code> to
<code>.html</code> <a href="https://tigerbeetle.com/blog/2025-02-27-why-we-designed-tigerbeetles-docs-from-scratch/">can
be cheaper to maintain</a> than a general purpose solution.</p>
<p>I had a hope that “code review is just a commit” would be the secret
to keep implementation complexity low. Sadly, the devil is in the
details in this particular case.</p>
<p>The basic idea, that reviewing is leaving comments in code, works as
well as I had expected (that is, it’s really, really awesome). But
modifying code under review turned out to be tricky. If a reviewer
requests a change, and you apply it to some deep commit, or even add a
new commit on top, you now have to solve mere conflicts with the review
comments themselves, as they are often added at the <a href="https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging">hunk</a>
boundaries. And then, while <code>--force-with-lease</code> is workable,
it also adds friction. There is an impedance mismatch here, where, for
code, we want very strong, hash-chained intentional sequence of
state-transitions, while for review we would be more happy with more lax
conflict-free merging rules. It <em>might</em> be solved with more
tooling to “push” and “pop” review comments on top of pristine review
branch, but that seems to push well beyond my 500 line limit.</p>
<p>Then, there’s a second change. It seems like <a href="https://lore.kernel.org/git/CAESOdVAspxUJKGAA58i0tvks4ZOfoGf1Aa5gPr0FXzdcywqUUw@mail.gmail.com/T/#u">upstream
git might be getting a Gerrit-style Change-Id</a> for tracking revisions
of a single commit over rebases. If that happens, we might actually get
first class support for per-commit interdiff review! But that would be
somewhat incompatible with <code>git-review</code> approach, which adds
an entire separate commit to the branch. But, perhaps, in the
<code>Change-Id</code> world, we could be adding review comments to the
commits themselves, and, rather that adding a revert at the conclusion
of review, instruct git to store all revisions of a particular
<code>Change-Id</code>.</p>
<p>Anyway, we are begrudgingly back to web-interface based code reviews
for now. Hopefully someone is inspired enough to fix this properly one
day!</p>
<p>If you’ve been thinking along similar lines, the following links are
worth checking out:</p>
<ul>
<li><a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki">Fossil</a>
is an SCM system which stores everything in the repository.</li>
<li><a href="https://gerrit-review.googlesource.com/Documentation/note-db.html">NoteDb</a>
backend for Gerrit. Gerrit started with tracking review state in a
separate database, but then moved storage into git.</li>
<li><a href="https://github.com/git-bug/git-bug">git-bug</a> uses git to
store information about issues.</li>
<li><a href="https://github.com/google/git-appraise">git-appraise</a>
uses git to store information about reviews.</li>
<li><a href="https://doc.dxuuu.xyz/prr/index.html">prr</a> which
implements in-editor review interface on top of GitHub’s Web API</li>
<li><a href="https://www.janestreet.com/tech-talks/janestreet-code-review/">How
Jane Street Does Code Review</a> shows that a better world is possible,
and that it is already here, just not everywhere.</li>
</ul>
  </div>
</article></div>
  </body>
</html>
