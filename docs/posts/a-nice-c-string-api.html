<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/mickjc750/str">Original</a>
    <h1>Show HN: A nice C string API</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">C String handling library inspired by Luca Sas. <a href="https://www.youtube.com/watch?v=QpAhX-gsHMs&amp;t=3009s" rel="nofollow">https://www.youtube.com/watch?v=QpAhX-gsHMs&amp;t=3009s</a></p>

<ol dir="auto">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#understanding-the-separate-purposes-of-strh-and-strbufh">Understanding the separate purposes of str.h and strbuf.h</a></li>
<li><a href="#strh">str.h</a></li>
<li><a href="#passing-a-str_t-to-printf">Passing a str_t to printf()</a></li>
<li><a href="#strh-functions">str.h functions</a></li>
<li><a href="#strbufh">strbuf.h</a></li>
<li><a href="#providing-an-allocator-for-strbufcreate">Providing an allocator for strbuf_create().</a></li>
<li><a href="#allocator-example">Allocator example</a></li>
<li><a href="#buffer-re-sizing">Buffer re-sizing</a></li>
<li><a href="#non-dynamic-buffers">non-dynamic buffers</a></li>
<li><a href="#printf-to-a-strbuf_t">printf to a strbuf_t</a></li>
<li><a href="#prnf-to-a-strbuft">prnf to a strbuf_t</a></li>
<li><a href="#strbufh-functions">strbuf.h functions</a></li>
</ol>

<h2 dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Introduction</h2>
<p dir="auto">This project aims to implement a convenient and intuitive approach to string handling, described in a talk by Luca Sas in the above mentioned YouTube video.</p>
<p dir="auto">The core ideas are:</p>
<ul dir="auto">
<li>Separating the ownership of a string (which can modify/build strings) from the access or view of strings (navigating/splitting/trimming).</li>
<li>Returning strings by value, to avoid pointers.</li>
<li>Ditching the requirement for null termination.</li>
</ul>


<p dir="auto">This project is provided in two main parts, <strong>str.h</strong> which provides a <strong>str_t</strong> type, and <strong>strbuf.c</strong> which provides a <strong>strbuf_t</strong> type.</p>
<p dir="auto">To understand this approach to string handling, and the purpose of each, it helps to think in terms of string ownership.</p>
<h2 dir="auto"><a id="user-content-str_t" aria-hidden="true" href="#str_t"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t</h2>
<p dir="auto"><strong>str_t</strong> doesn&#39;t own the string. It&#39;s just a view into a string, and can&#39;t be used to free it, and shouldn&#39;t be used to change it&#39;s characters. You can only change the range of the view, or split it into multiple views, or interpret a view as a number etc. <strong>str_t</strong> is intended for reading and parsing strings, not building them. As there is no null terminator requirement, binary strings including the full ascii set 0-255 can safely be worked with.
<strong>str.h</strong> does not depend on <strong>strbuf.h</strong>, and can be useful on it’s own.</p>

<h2 dir="auto"><a id="user-content-strbuf_t" aria-hidden="true" href="#strbuf_t"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>strbuf_t</h2>
<p dir="auto"><strong>strbuf_t</strong> DOES own the string, and contains the information needed to resize it, change it&#39;s contents, or free it. Dynamic memory allocation is not mandatory. The memory space can be as simple as a static buffer provided by the application. For a dynamic buffer, the application may either provide it&#39;s own allocator, or strbuf can default to using malloc/free.</p>

<p dir="auto">Whether or not you pass a <strong>str_t</strong> or a <strong>str_buf_t</strong> to your functions depends on the use case.</p>
<p dir="auto">If you wish to pass a string to a function which frees it, then you need to pass ownership along with it, so in that case a strbuf_t needs to be passed.</p>
<p dir="auto">If you only wish to provide a view into an existing string (read only), then a <strong>str_t</strong> can be passed.</p>

<h2 dir="auto"><a id="user-content-standard-used" aria-hidden="true" href="#standard-used"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Standard used</h2>
<p dir="auto">GCC - GNU99</p>

<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">Copy the source files <strong>str.h</strong>/<strong>str.c</strong> and optionally <strong>strbuf.h</strong>/<strong>strbuf.c</strong> into your project.
Add any desired options (described below) to your compiler flags (eg. -DSTRBUF_PROVIDE_PRINTF).
str.c requires linking against the maths library for interpreting float values. So either add -lm to your linker options, or -DSTR_NO_FLOAT to your compiler options if you don&#39;t need float conversion.
A list and explanation of options is included at the top of each header file for convenient copy &amp; pasting.</p>


<p dir="auto">str.h provides functions for navigating, reading, and interpreting portions of const char string data. It may be used standalone, and does not depend on <strong>strbuf.h</strong>.</p>
<p dir="auto">It does not store the underlying data itself, and is not intended to be used for modifying the data. The string data may be stored anywhere, string literals (the string pool), a dynamic buffer provided by strbuf.h, or a static buffer etc...</p>
<p dir="auto">str.h defines the following str_t type :</p>
<div data-snippet-clipboard-copy-content="typedef struct str_t
{
	const char* data;
	size_t size;
} str_t;"><pre><code>typedef struct str_t
{
	const char* data;
	size_t size;
} str_t;
</code></pre></div>
<p dir="auto">Note that this holds only:</p>
<ul dir="auto">
<li>A pointer to the beginning of the string</li>
<li>The size (in characters) of the string</li>
</ul>
<p dir="auto">Some operations may return an invalid str_t, in this case .data=NULL and .size==0. Operations which can cause an invalid str_t to be returned include:</p>
<ul dir="auto">
<li>Attempting to split a string using non-existent delimiter with <strong>str_pop_first_split()</strong> or <strong>str_pop_last_split()</strong></li>
<li>Requesting a substring range, which is entirely outside of the range of the input string.</li>
</ul>
<p dir="auto">Note that it is valid to have a str_t of length 0. In this case *data should never be de-referenced (as it points to something of size 0, ie non-existent).</p>


<p dir="auto">There are two macros defined for this <strong>PRIstr</strong> and <strong>PRIstrarg()</strong>, which make use if printf&#39;s dynamic precision to limit the number of characters read.</p>
<p dir="auto">Example usage:</p>
<div data-snippet-clipboard-copy-content="printf(&#34;The string is %&#34;PRIstr&#34;\n&#34;, PRIstrarg(mystring));"><pre><code>printf(&#34;The string is %&#34;PRIstr&#34;\n&#34;, PRIstrarg(mystring));
</code></pre></div>



<h2 dir="auto"><a id="user-content-str_t-cstrconst-char-c_str" aria-hidden="true" href="#str_t-cstrconst-char-c_str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t cstr(const char* c_str);</h2>
<p dir="auto">Return a str_t from a null terminated const char[] string. If the string provided is a string literal, then the macro <strong>cstr_SL(&#34;mystring&#34;)</strong> may be used instead of <strong>cstr(&#34;mystring&#34;)</strong> to avoid measuring the strings length at runtime (although either will work).</p>

<h2 dir="auto"><a id="user-content-char-str_to_cstrchar-dst-size_t-dst_size-str_t-str" aria-hidden="true" href="#char-str_to_cstrchar-dst-size_t-dst_size-str_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>char* str_to_cstr(char* dst, size_t dst_size, str_t str);</h2>
<p dir="auto">Write a str_t out to a null terminated char* buffer. The buffer and space available (including the terminator) must be provided by the caller.</p>

<h2 dir="auto"><a id="user-content-bool-str_is_validstr_t-str" aria-hidden="true" href="#bool-str_is_validstr_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>bool str_is_valid(str_t str);</h2>
<p dir="auto">Return true if the str_t is valid.</p>

<h2 dir="auto"><a id="user-content-bool-str_is_matchstr_t-str1-str_t-str2" aria-hidden="true" href="#bool-str_is_matchstr_t-str1-str_t-str2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>bool str_is_match(str_t str1, str_t str2);</h2>
<p dir="auto">Return true if the strings match. Also returns true if BOTH strings are invalid.</p>

<h2 dir="auto"><a id="user-content-bool-str_is_match_nocasestr_t-str1-str_t-str2" aria-hidden="true" href="#bool-str_is_match_nocasestr_t-str1-str_t-str2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>bool str_is_match_nocase(str_t str1, str_t str2);</h2>
<p dir="auto">Same as <strong>str_is_match()</strong> ignoring case.</p>

<h2 dir="auto"><a id="user-content-int-str_comparestr_t-str1-str_t-str2" aria-hidden="true" href="#int-str_comparestr_t-str1-str_t-str2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>int str_compare(str_t str1, str_t str2);</h2>
<p dir="auto">A replacement for strcmp(). Used for alphabetizing strings. May also be used instead of <strong>str_is_match()</strong>, although keep in mind that it will return 0 if it compares an invalid string to a valid string of length 0. (Where <strong>str_is_match()</strong> would return false if only one string is invalid.)</p>

<h2 dir="auto"><a id="user-content-str_t-str_substr_t-str-int-begin-int-end" aria-hidden="true" href="#str_t-str_substr_t-str-int-begin-int-end"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_sub(str_t str, int begin, int end);</h2>
<p dir="auto">Return the sub string indexed by <strong>begin</strong> to <strong>end</strong>, where <strong>end</strong> is non-inclusive.
Negative values may be used, and will index from the end of the string backwards.
The indexes are clipped to the strings length, so INT_MAX may be safely used to index the end of the string. If the requested range is entirely outside of the input string, then an invalid <strong>str_t</strong> is returned.</p>

<h2 dir="auto"><a id="user-content-str_t-str_trimstr_t-str-str_t-chars_to_trim" aria-hidden="true" href="#str_t-str_trimstr_t-str-str_t-chars_to_trim"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_trim(str_t str, str_t chars_to_trim);</h2>
<p dir="auto">Return a str_t with the start and end trimmed of all characters present in <strong>chars_to_trim</strong>.</p>

<h2 dir="auto"><a id="user-content-str_t-str_trim_startstr_t-str-str_t-chars_to_trim" aria-hidden="true" href="#str_t-str_trim_startstr_t-str-str_t-chars_to_trim"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_trim_start(str_t str, str_t chars_to_trim);</h2>
<p dir="auto">Return a str_t with the start trimmed of all characters present in <strong>chars_to_trim</strong>.</p>

<h2 dir="auto"><a id="user-content-str_t-str_trim_endstr_t-str-str_t-chars_to_trim" aria-hidden="true" href="#str_t-str_trim_endstr_t-str-str_t-chars_to_trim"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_trim_end(str_t str, str_t chars_to_trim);</h2>
<p dir="auto">Return a str_t with the end trimmed of all characters present in <strong>chars_to_trim</strong>.</p>

<h2 dir="auto"><a id="user-content-str_t-str_find_firststr_t-haystack-str_t-needle" aria-hidden="true" href="#str_t-str_find_firststr_t-haystack-str_t-needle"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_find_first(str_t haystack, str_t needle);</h2>
<p dir="auto">Return the <strong>str_t</strong> for the first occurrence of needle in haystack.
If the needle is not found, str_find_first() returns an invalid str_t.
If the needle is found, the returned str_t will match the contents of needle, only it will reference data within the haystack, and can be used with various strbuf.h functions as a means of specifying the position within the buffer.</p>
<p dir="auto">Some special cases to consider:</p>
<ul dir="auto">
<li>If <strong>needle</strong> is valid, and of length 0, it will always be found at the start of the string.</li>
<li>If <strong>needle</strong> is invalid, or if <strong>haystack</strong> is invalid, it will not be found.</li>
</ul>

<h2 dir="auto"><a id="user-content-str_t-str_find_laststr_t-haystack-str_t-needle" aria-hidden="true" href="#str_t-str_find_laststr_t-haystack-str_t-needle"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_find_last(str_t haystack, str_t needle);</h2>
<p dir="auto">Similar to str_find_first(), but returns the LAST occurrence of <strong>needle</strong> in <strong>haystack</strong>.</p>
<p dir="auto">Some special cases to consider:</p>
<ul dir="auto">
<li>If <strong>needle</strong> is valid, and of length 0, it will always be found at the end of <strong>haystack</strong>.</li>
<li>If <strong>needle</strong> is invalid, or if <strong>haystack</strong> is invalid, it will not be found.</li>
</ul>

<h2 dir="auto"><a id="user-content-str_t-str_pop_first_splitstr_t-str_ptr-str_t-delimiters" aria-hidden="true" href="#str_t-str_pop_first_splitstr_t-str_ptr-str_t-delimiters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_first_split(str_t* str_ptr, str_t delimiters);</h2>
<p dir="auto">Return a <strong>str_t</strong> representing the contents of the source string up to, but not including, any of characters in <strong>delimiters</strong>.
Additionally, the contents of the returned <strong>str_t</strong>, and the delimiter character itself is removed (popped) from the input string.
If no delimiter is found, the returned string is invalid, and should be tested with str_is_valid().</p>
<p dir="auto">Example usage:</p>
<div data-snippet-clipboard-copy-content="str_t date = cstr(&#34;2022/10/03&#34;);
str_t year  = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));
str_t month = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));
str_t day   = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));"><pre><code>str_t date = cstr(&#34;2022/10/03&#34;);
str_t year  = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));
str_t month = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));
str_t day   = str_pop_first_split(&amp;date, cstr(&#34;/&#34;));
</code></pre></div>

<h2 dir="auto"><a id="user-content-str_t-str_pop_last_splitstr_t-str_ptr-str_t-delimiters" aria-hidden="true" href="#str_t-str_pop_last_splitstr_t-str_ptr-str_t-delimiters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_last_split(str_t* str_ptr, str_t delimiters);</h2>
<p dir="auto">Same as <strong>str_pop_first_split()</strong> but searches from the end of the string backwards.</p>

<h2 dir="auto"><a id="user-content-str_t-str_pop_first_split_nocasestr_t-str_ptr-str_t-delimiters" aria-hidden="true" href="#str_t-str_pop_first_split_nocasestr_t-str_ptr-str_t-delimiters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_first_split_nocase(str_t* str_ptr, str_t delimiters);</h2>
<p dir="auto">Same as <strong>str_pop_first_split()</strong> but ignores the case of the delimiters</p>

<h2 dir="auto"><a id="user-content-str_t-str_pop_last_split_nocasestr_t-str_ptr-str_t-delimiters" aria-hidden="true" href="#str_t-str_pop_last_split_nocasestr_t-str_ptr-str_t-delimiters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_last_split_nocase(str_t* str_ptr, str_t delimiters);</h2>
<p dir="auto">Same as <strong>str_pop_last_split()</strong> but ignores the case of the delimiters</p>

<h2 dir="auto"><a id="user-content-str_t-str_pop_splitstr_t-str_ptr-int-index" aria-hidden="true" href="#str_t-str_pop_splitstr_t-str_ptr-int-index"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_split(str_t* str_ptr, int index);</h2>
<p dir="auto">Split a str_t at a specified index n.</p>
<ul dir="auto">
<li>
<p dir="auto">For n &gt;= 0
Return a str_t representing the first n characters of the source string.
Additionally the first n characters are removed (popped) from the start of the source string.</p>
</li>
<li>
<p dir="auto">For n &lt; 0
Return a str_t representing the last -n characters of the source string.
Additionally the last -n characters are removed (popped) from the end of the source string.</p>
</li>
</ul>
<p dir="auto">If the index is outside of the range of the source string, then an invalid str_t is returned and the source is unmodified</p>

<h2 dir="auto"><a id="user-content-char-str_pop_first_charstr_t-str_ptr" aria-hidden="true" href="#char-str_pop_first_charstr_t-str_ptr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>char str_pop_first_char(str_t* str_ptr);</h2>
<p dir="auto">Return the first char of str, and remove it from the str.
Returns 0 if there are no characters in str.
If str is known to contain at least one character, it is the equivalent of:</p>
<div data-snippet-clipboard-copy-content="str_pop_split(&amp;str, 1).data[0]"><pre><code>str_pop_split(&amp;str, 1).data[0]
</code></pre></div>
<p dir="auto">Only it avoids dereferencing a NULL pointer in the case where str_pop_split() would return an invalid str due to the str being empty.</p>

<h2 dir="auto"><a id="user-content-str_t-str_pop_linestr_t-str_ptr-char-eol" aria-hidden="true" href="#str_t-str_pop_linestr_t-str_ptr-char-eol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t str_pop_line(str_t* str_ptr, char* eol);</h2>
<p dir="auto">Returns a str_t representing the first line within the source string, not including the eol terminator.
The returned line and the terminator are removed (popped) from the source string.
If a line terminator is not found, an invalid str_t is returned and the source string is unmodified.</p>
<p dir="auto">If the source string already contains one or more lines:
Any mixture of (CR,LF,CRLF,LFCR) can be handled, a CRLF or LFCR sequence will always be interpreted as 1 line ending.
In this case eol may be NULL.</p>
<p dir="auto">If the source string is being appended to one character at a time, such as when gathering user input:
Any type of line ending can be handled by providing variable eol.
This variable stores the state of the eol discriminator, regarding if a future CR or LF needs to be ignored.
It&#39;s initial value should be 0.</p>

<h2 dir="auto"><a id="user-content-long-long-str_to_llstr_t-str" aria-hidden="true" href="#long-long-str_to_llstr_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>long long str_to_ll(str_t str);</h2>
<p dir="auto">Convert the ascii representation of the signed long long in <strong>str</strong>, into a long long value.
The input string is first  trimmed of any leading spaces, and may start with 0x or 0X for hex numbers, or 0b for binary numbers.</p>

<h2 dir="auto"><a id="user-content-unsigned-long-long-str_to_ullstr_t-str" aria-hidden="true" href="#unsigned-long-long-str_to_ullstr_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>unsigned long long str_to_ull(str_t str);</h2>
<p dir="auto">Same as <strong>str_to_ull()</strong> but converts to an unsigned value.</p>
<p dir="auto">The above <strong>str_to_ull</strong> and <strong>str_to_ll()</strong> are also cast to stdint.h types using macros.</p>
<div data-snippet-clipboard-copy-content="#define str_to_int(str)         ((int)str_to_ll(str))
#define str_to_int8_t(str)      ((int8_t)str_to_ll(str))
#define str_to_int16_t(str)     ((int16_t)str_to_ll(str))
#define str_to_int32_t(str)     ((int32_t)str_to_ll(str))
#define str_to_int64_t(str)     ((int64_t)str_to_ll(str))
#define str_to_unsigned(str)    ((unsigned)str_to_ull(str))
#define str_to_uint8_t(str)     ((uint8_t)str_to_ull(str))
#define str_to_uint16_t(str)    ((uint16_t)str_to_ull(str))
#define str_to_uint32_t(str)    ((uint32_t)str_to_ull(str))
#define str_to_uint64_t(str)    ((uint64_t)str_to_ull(str))"><pre><code>#define str_to_int(str)         ((int)str_to_ll(str))
#define str_to_int8_t(str)      ((int8_t)str_to_ll(str))
#define str_to_int16_t(str)     ((int16_t)str_to_ll(str))
#define str_to_int32_t(str)     ((int32_t)str_to_ll(str))
#define str_to_int64_t(str)     ((int64_t)str_to_ll(str))
#define str_to_unsigned(str)    ((unsigned)str_to_ull(str))
#define str_to_uint8_t(str)     ((uint8_t)str_to_ull(str))
#define str_to_uint16_t(str)    ((uint16_t)str_to_ull(str))
#define str_to_uint32_t(str)    ((uint32_t)str_to_ull(str))
#define str_to_uint64_t(str)    ((uint64_t)str_to_ull(str))
</code></pre></div>

<h2 dir="auto"><a id="user-content-double-str_to_floatstr_t-str" aria-hidden="true" href="#double-str_to_floatstr_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>double str_to_float(str_t str);</h2>
<p dir="auto">Convert the ascii representation of a floating point value in <strong>str</strong>, into a double.</p>
<p dir="auto">The default precision of this function is double, but <strong>str.h</strong> accepts the following defined symbols:</p>
<ul dir="auto">
<li>STR_NO_FLOAT - Do not provide floating point conversions.</li>
<li>STR_SUPPORT_FLOAT - Use float instead of double.</li>
<li>STR_SUPPORT_LONG_DOUBLE - Use long double instead of double.</li>
</ul>
<p dir="auto">These can be added to your compiler flags eg. -DSTR_SUPPORT_LONG_DOUBLE
This feature requires linking against the maths library, so linker options will need -lm, unless you define <strong>STR_NO_FLOAT</strong></p>


<p dir="auto">strbuf.h provides functions for allocating, building and storing strings.
Unlike the str_t type, a strbuf_t owns the string data, and contains all the information needed to modify it, resize it, or free it.</p>
<p dir="auto">While dynamic memory allocation is very useful, it is not mandatory (with one exception regarding strbuf_cat()).</p>
<p dir="auto">All strbuf functions maintain a null terminator at the end of the buffer, and the buffer may be accessed as a regular c string using mybuffer-&gt;cstr.</p>
<p dir="auto">str.h defines the following strbuf_t type :</p>
<div data-snippet-clipboard-copy-content="typedef struct strbuf_t
{
	size_t size;
	size_t capacity;
	strbuf_allocator_t allocator;
	char cstr[];
} strbuf_t;"><pre><code>typedef struct strbuf_t
{
	size_t size;
	size_t capacity;
	strbuf_allocator_t allocator;
	char cstr[];
} strbuf_t;
</code></pre></div>
<p dir="auto">This type is intended to be declared as a pointer (strbuf_t*), if the buffer is relocated in memory this pointer needs to change, therefore strbuf.h functions take the address of this pointer as an argument. While a pointer to a pointer may be confusing for some, in practice the source doesn&#39;t look too intimidating. Example:</p>
<div data-snippet-clipboard-copy-content="strbuf_t*	mybuffer;
mybuffer = strbuf_create(50, NULL);
strbuf_assign(&amp;mybuffer, cstr(&#34;Hello&#34;));"><pre><code>strbuf_t*	mybuffer;
mybuffer = strbuf_create(50, NULL);
strbuf_assign(&amp;mybuffer, cstr(&#34;Hello&#34;));
</code></pre></div>
<p dir="auto">As mybuffer is a pointer, members of the strbuf_t may be accessed using the arrow operator. Example:</p>
<div data-snippet-clipboard-copy-content="printf(&#34;The buffer contains %s\n&#34;, mybuffer-&gt;cstr);"><pre><code>printf(&#34;The buffer contains %s\n&#34;, mybuffer-&gt;cstr);
</code></pre></div>


<p dir="auto"><strong>strbuf_create()</strong> <em>may</em> be passed an allocator. If you just want strbuf_create() to use stdlib&#39;s malloc and free, then simply add -DSTRBUF_DEFAULT_ALLOCATOR_STDLIB to your compiler options, and pass a NULL to the allocator parameter of strbuf_create(). If you want to check that stdlib&#39;s allocation/resize actually succeeded, you can also add -DSTRBUF_ASSERT_DEFAULT_ALLOCATOR_STDLIB which uses regular assert() to check this.</p>
<p dir="auto">The following strbuf_allocator_t type is defined by strbuf.h</p>
<div data-snippet-clipboard-copy-content="typedef struct strbuf_allocator_t
{
	void* app_data;
	void* (*allocator)(struct strbuf_allocator_t* this_allocator, void* ptr_to_free, size_t size, const char* caller_filename, int caller_line);
} strbuf_allocator_t;"><pre><code>typedef struct strbuf_allocator_t
{
	void* app_data;
	void* (*allocator)(struct strbuf_allocator_t* this_allocator, void* ptr_to_free, size_t size, const char* caller_filename, int caller_line);
} strbuf_allocator_t;
</code></pre></div>
<h2 dir="auto"><a id="user-content-explanation" aria-hidden="true" href="#explanation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Explanation:</h2>

<p dir="auto">The address of the strbuf_allocator_t is passed to the allocator. If the allocator requires access to some implementation specific data to work (such as in the case of a temporary allocator), then *app_data may provide the address of this.</p>

<div data-snippet-clipboard-copy-content="void* (*allocator)(struct strbuf_allocator_t* this_allocator, void* ptr_to_free, size_t size, const char* caller_filename, int caller_line);"><pre><code>void* (*allocator)(struct strbuf_allocator_t* this_allocator, void* ptr_to_free, size_t size, const char* caller_filename, int caller_line);
</code></pre></div>
<p dir="auto">A pointer to the allocator function.</p>

<p dir="auto">The parameters to this function are:</p>
<div data-snippet-clipboard-copy-content="struct strbuf_allocator_t* this_allocator &lt;-- A pointer to the strbuf_allocator_t which may be used to access -&gt;app_data.
void* ptr_to_free                      &lt;-- Memory address to free OR reallocate.
size_t size                            &lt;-- Size of allocation, or new size of the reallocation, or 0 if memory is to be freed.
const char* caller_filename            &lt;-- usually /path/strbuf.c, this is to support allocators which track caller ID.
int caller_line                        &lt;-- The line within strbuf.c which called the allocator, this is also to support allocators which track caller ID."><pre><code>struct strbuf_allocator_t* this_allocator &lt;-- A pointer to the strbuf_allocator_t which may be used to access -&gt;app_data.
void* ptr_to_free                      &lt;-- Memory address to free OR reallocate.
size_t size                            &lt;-- Size of allocation, or new size of the reallocation, or 0 if memory is to be freed.
const char* caller_filename            &lt;-- usually /path/strbuf.c, this is to support allocators which track caller ID.
int caller_line                        &lt;-- The line within strbuf.c which called the allocator, this is also to support allocators which track caller ID.
</code></pre></div>


<p dir="auto">One for stdlib&#39;s realloc is provided under allocator_example/ Even though stdlib can be used as the default allocator in the case where the user doesn&#39;t wish to provide one, it is the simplest one to use for an example.</p>


<p dir="auto">The initial capacity of the buffer will be exactly as provided to strbuf_create(). If an operation needs to extend the buffer, the size will be rounded up by STRBUF_CAPACITY_GROW_STEP. The default value of this is 16, but this can be changed by defining it in a compiler flag ie. -DSTRBUF_CAPACITY_GROW_STEP=32</p>
<p dir="auto">The buffer capacity is never shrunk, unless strbuf_shrink() is called. In which case it will be reduced to the minimum possible.</p>


<p dir="auto">A function <strong>strbuf_create_fixed()</strong> is provided for initializing a strbuf_t* from a given memory space and size. In this case the capacity of the buffer will never change. If an operation is attempted on the buffer which requires more space than is available, this will result in an empty buffer. The capacity will be slightly less than the buffer size, as the memory must also hold a strbuf_t, and due to this the memory provided must also be suitably aligned with __ attribute __ ((aligned)). If the memory is not aligned, or is insufficient to hold event strbuf_t, then a NULL will be returned.</p>


<p dir="auto">To enable this feature, you must define the symbol STRBUF_PROVIDE_PRINTF, ideally by adding -DSTRBUF_PROVIDE_PRINTF to your compiler options</p>
<p dir="auto"><strong>strbuf.h</strong> will then define <strong>str_t strbuf_printf(strbuf_t** buf_ptr, const char* format, ...);</strong></p>
<p dir="auto">This uses vsnprintf() from stdio.h internally, to assign the formatted text output to the buffer provided.</p>


<p dir="auto">To enable this feature, you must define the symbol STRBUF_PROVIDE_PRNF.
This is an alternative text formatter available here <a href="https://github.com/mickjc750/prnf">https://github.com/mickjc750/prnf</a></p>
<p dir="auto"><strong>strbuf.h</strong> will then define <strong>str_t strbuf_prnf(strbuf_t** buf_ptr, const char* format, ...);</strong></p>



<h2 dir="auto"><a id="user-content-strbuf_t-strbuf_createsize_t-initial_capacity-strbuf_allocator_t-allocator" aria-hidden="true" href="#strbuf_t-strbuf_createsize_t-initial_capacity-strbuf_allocator_t-allocator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>strbuf_t* strbuf_create(size_t initial_capacity, strbuf_allocator_t* allocator);</h2>
<p dir="auto">Create and return the address of a strbuf_t.
If STRBUF_DEFAULT_ALLOCATOR_STDLIB is defined, then allocator may be NULL and malloc/free will be used.</p>

<h2 dir="auto"><a id="user-content-strbuf_t-strbuf_create_fixedvoid-addr-size_t-addr_size" aria-hidden="true" href="#strbuf_t-strbuf_create_fixedvoid-addr-size_t-addr_size"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>strbuf_t* strbuf_create_fixed(void* addr, size_t addr_size);</h2>
<p dir="auto">Create a new buffer with a fixed capacity from the given memory address. The address must be suitably aligned for a void*. This can be done in GCC by adding __ attribute __ ((aligned)) to the buffers declaration.</p>
<p dir="auto">addr_size is the size of the memory available <strong>(not the desired capacity)</strong> and must be &gt; sizeof(strbuf_t)+1.</p>
<p dir="auto">The resulting buffer capacity will be the given memory size -sizeof(strbuf_t)-1, and can be checked with buf-&gt;capacity. If the function fails due to bad alignment or insufficient size, a NULL will be returned.</p>
<p dir="auto">Example use:</p>
<div data-snippet-clipboard-copy-content="#define STATIC_BUFFER_SIZE	200

strbuf_t* buf;
static char static_buf[STATIC_BUFFER_SIZE] __attribute__ ((aligned));
buf = strbuf_create_fixed(static_buf, STATIC_BUFFER_SIZE);

strbuf_cat(&amp;buf, cstr(&#34;Hello&#34;));	// Use buffer

strbuf_destroy(&amp;buf);	// In this case doesn&#39;t free anything, affect is the same as buf=NULL;"><pre><code>#define STATIC_BUFFER_SIZE	200

strbuf_t* buf;
static char static_buf[STATIC_BUFFER_SIZE] __attribute__ ((aligned));
buf = strbuf_create_fixed(static_buf, STATIC_BUFFER_SIZE);

strbuf_cat(&amp;buf, cstr(&#34;Hello&#34;));	// Use buffer

strbuf_destroy(&amp;buf);	// In this case doesn&#39;t free anything, affect is the same as buf=NULL;
</code></pre></div>

<h2 dir="auto"><a id="user-content-str_t-strbuf_catstrbuf_t-buf_ptr-" aria-hidden="true" href="#str_t-strbuf_catstrbuf_t-buf_ptr-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_cat(strbuf_t** buf_ptr, ...);</h2>
<p dir="auto">This is a macro, which concatenates one or more str_t into a buffer, and returns the str_t of the buffer. The returned str_t is always valid.</p>
<p dir="auto">After performing some argument counting wizardry, it calls _strbuf_cat(strbuf_t** buf_ptr, int n_args, ...)</p>
<p dir="auto">If the allocator is dynamic, input arguments may be from the output buffer itself. In this case a temporary buffer is allocated to build the output.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_vcatstrbuf_t-buf_ptr-int-n_args-va_list-va" aria-hidden="true" href="#str_t-strbuf_vcatstrbuf_t-buf_ptr-int-n_args-va_list-va"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_vcat(strbuf_t** buf_ptr, int n_args, va_list va);</h2>
<p dir="auto">The non-variadic version of _strbuf_cat.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_append_charstrbuf_t-buf_ptr-char-c" aria-hidden="true" href="#str_t-strbuf_append_charstrbuf_t-buf_ptr-char-c"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append_char(strbuf_t** buf_ptr, char c);</h2>
<p dir="auto">Append a single character to the buffer.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_strstrbuf_t-buf_ptr" aria-hidden="true" href="#str_t-strbuf_strstrbuf_t-buf_ptr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_str(strbuf_t** buf_ptr);</h2>
<p dir="auto">Return str_t of buffer contents.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_shrinkstrbuf_t-buf_ptr" aria-hidden="true" href="#str_t-strbuf_shrinkstrbuf_t-buf_ptr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_shrink(strbuf_t** buf_ptr);</h2>
<p dir="auto">Shrink buffer to the minimum size required to hold it&#39;s contents.</p>

<h2 dir="auto"><a id="user-content-void-strbuf_destroystrbuf_t-buf_ptr" aria-hidden="true" href="#void-strbuf_destroystrbuf_t-buf_ptr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>void strbuf_destroy(strbuf_t** buf_ptr);</h2>
<p dir="auto">Free memory allocated to hold the buffer and it&#39;s contents.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_assignstrbuf_t-buf_ptr-str_t-str" aria-hidden="true" href="#str_t-strbuf_assignstrbuf_t-buf_ptr-str_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_assign(strbuf_t** buf_ptr, str_t str);</h2>
<p dir="auto">Assign str_t to buffer. str_t may be owned by the output buffer itself.
This allows a buffers contents to be cropped or trimmed using the str.h functions.
Example to trim whitespace:	strbuf_assign(&amp;buf, str_trim(strbuf_str(&amp;buf), cstr(&#34; &#34;)));</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_appendstrbuf_t-buf_ptr-str_t-str" aria-hidden="true" href="#str_t-strbuf_appendstrbuf_t-buf_ptr-str_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append(strbuf_t** buf_ptr, str_t str);</h2>
<p dir="auto">Append str_t to buffer. str_t may be owned by the output buffer itself.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_prependstrbuf_t-buf_ptr-str_t-str" aria-hidden="true" href="#str_t-strbuf_prependstrbuf_t-buf_ptr-str_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_prepend(strbuf_t** buf_ptr, str_t str);</h2>
<p dir="auto">Prepend str_t to buffer. str_t may be owned by the output buffer itself.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_insert_at_indexstrbuf_t-buf_ptr-int-index-str_t-str" aria-hidden="true" href="#str_t-strbuf_insert_at_indexstrbuf_t-buf_ptr-int-index-str_t-str"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_insert_at_index(strbuf_t** buf_ptr, int index, str_t str);</h2>
<p dir="auto">Insert str_t to buffer at index. str_t may be owned by the output buffer itself. The index accepts python-style negative values to index the end of the string backwards.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_insert_beforestrbuf_t-buf_ptr-str_t-dst-str_t-src" aria-hidden="true" href="#str_t-strbuf_insert_beforestrbuf_t-buf_ptr-str_t-dst-str_t-src"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_insert_before(strbuf_t** buf_ptr, str_t dst, str_t src);</h2>
<p dir="auto">Insert src into the buffer at the location referenced by dst. dst must reference data contained within the destination buffer.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_insert_afterstrbuf_t-buf_ptr-str_t-dst-str_t-src" aria-hidden="true" href="#str_t-strbuf_insert_afterstrbuf_t-buf_ptr-str_t-dst-str_t-src"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_insert_after(strbuf_t** buf_ptr, str_t dst, str_t src);</h2>
<p dir="auto">Insert src after the end of dst in the buffer. dst must reference data contained within the buffer.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_printfstrbuf_t-buf_ptr-const-char-format-" aria-hidden="true" href="#str_t-strbuf_printfstrbuf_t-buf_ptr-const-char-format-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_printf(strbuf_t** buf_ptr, const char* format, ...);</h2>
<h2 dir="auto"><a id="user-content-str_t-strbuf_vprintfstrbuf_t-buf_ptr-const-char-format-va_list-va" aria-hidden="true" href="#str_t-strbuf_vprintfstrbuf_t-buf_ptr-const-char-format-va_list-va"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_vprintf(strbuf_t** buf_ptr, const char* format, va_list va);</h2>
<h3 dir="auto"><a id="user-content-these-functions-are-available-if-you-define-strbuf_provide_printf-ideally-by-adding--dstrbuf_provide_printf-to-your-compiler-options" aria-hidden="true" href="#these-functions-are-available-if-you-define-strbuf_provide_printf-ideally-by-adding--dstrbuf_provide_printf-to-your-compiler-options"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>These functions are available if you define STRBUF_PROVIDE_PRINTF, ideally by adding -DSTRBUF_PROVIDE_PRINTF to your compiler options</h3>
<p dir="auto">These provide the variadic and non-variadic versions of printf, which output to a strbuf_t. They use vsnprintf() from stdio.h to first measure the length of the output string, then resize the buffer to suit. If the buffer is non-dynamic, and the output string does not fit, the buffer will be emptied.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_append_printfstrbuf_t-buf_ptr-const-char-format-" aria-hidden="true" href="#str_t-strbuf_append_printfstrbuf_t-buf_ptr-const-char-format-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append_printf(strbuf_t** buf_ptr, const char* format, ...);</h2>
<h2 dir="auto"><a id="user-content-str_t-strbuf_append_vprintfstrbuf_t-buf_ptr-const-char-format-va_list-va" aria-hidden="true" href="#str_t-strbuf_append_vprintfstrbuf_t-buf_ptr-const-char-format-va_list-va"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append_vprintf(strbuf_t** buf_ptr, const char* format, va_list va);</h2>
<p dir="auto">The output is appended to the buffer. If the buffer is non-dynamic, and the output string does not fit, the buffer will be emptied.</p>

<h2 dir="auto"><a id="user-content-str_t-strbuf_prntfstrbuf_t-buf_ptr-const-char-format-" aria-hidden="true" href="#str_t-strbuf_prntfstrbuf_t-buf_ptr-const-char-format-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_prntf(strbuf_t** buf_ptr, const char* format, ...);</h2>
<h2 dir="auto"><a id="user-content-str_t-strbuf_vprntfstrbuf_t-buf_ptr-const-char-format-va_list-va" aria-hidden="true" href="#str_t-strbuf_vprntfstrbuf_t-buf_ptr-const-char-format-va_list-va"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_vprntf(strbuf_t** buf_ptr, const char* format, va_list va);</h2>
<h2 dir="auto"><a id="user-content-str_t-strbuf_append_prntfstrbuf_t-buf_ptr-const-char-format-" aria-hidden="true" href="#str_t-strbuf_append_prntfstrbuf_t-buf_ptr-const-char-format-"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append_prntf(strbuf_t** buf_ptr, const char* format, ...);</h2>
<h2 dir="auto"><a id="user-content-str_t-strbuf_append_vprntfstrbuf_t-buf_ptr-const-char-format-va_list-va" aria-hidden="true" href="#str_t-strbuf_append_vprntfstrbuf_t-buf_ptr-const-char-format-va_list-va"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>str_t strbuf_append_vprntf(strbuf_t** buf_ptr, const char* format, va_list va);</h2>
<h3 dir="auto"><a id="user-content-these-functions-are-available-if-you-define-strbuf_provide_prnf-ideally-by-adding--dstrbuf_provide_prnf-to-your-compiler-options" aria-hidden="true" href="#these-functions-are-available-if-you-define-strbuf_provide_prnf-ideally-by-adding--dstrbuf_provide_prnf-to-your-compiler-options"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>These functions are available if you define STRBUF_PROVIDE_PRNF, ideally by adding -DSTRBUF_PROVIDE_PRNF to your compiler options</h3>
<p dir="auto">These behave like the printf functions, but use an alternative text formatter <a href="https://github.com/mickjc750/prnf">https://github.com/mickjc750/prnf</a></p>
</article>
          </div></div>
  </body>
</html>
