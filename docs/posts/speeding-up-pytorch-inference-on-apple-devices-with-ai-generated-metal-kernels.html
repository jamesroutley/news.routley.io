<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gimletlabs.ai/blog/ai-generated-metal-kernels">Original</a>
    <h1>Speeding up PyTorch inference on Apple devices with AI-generated Metal kernels</h1>
    
    <div id="readability-page-1" class="page"><div><section><article><div><header></header><p><img alt="Speeding up PyTorch inference by 87% on Apple devices with AI-generated Metal kernels" loading="lazy" width="1200" height="600" decoding="async" data-nimg="1" src="https://proclamations.nebcorp-hias.com/blog/images/server-rack-hero.jpg"/></p><div><dl><p><dt>Published on</dt><dd><time datetime="2025-08-26T00:00:00.000Z">August 26, 2025</time></dd></p><dt>Authors</dt><dd><ul><li><img alt="avatar" loading="lazy" width="38" height="38" decoding="async" data-nimg="1" src="https://proclamations.nebcorp-hias.com/blog/images/avatar/taras_sereda.jpg"/><dl><dt>Name</dt><dd>Taras Sereda</dd><dd></dd></dl></li><li><img alt="avatar" loading="lazy" width="38" height="38" decoding="async" data-nimg="1" src="https://proclamations.nebcorp-hias.com/blog/images/avatar/natalie.jpg"/><dl><dt>Name</dt><dd>Natalie Serrino</dd><dd></dd></dl></li><li><img alt="avatar" loading="lazy" width="38" height="38" decoding="async" data-nimg="1" src="https://proclamations.nebcorp-hias.com/blog/images/avatar/zain.png"/><dl><dt>Name</dt><dd>Zain Asgar</dd><dd></dd></dl></li></ul></dd></dl><div><div><div><p><em>tl;dr: Our lab investigated whether frontier models can write optimized GPU kernels for Apple devices to speed up inference. We found that they can: <strong>our AI-generated Metal kernels were 1.87x faster</strong> across 215 PyTorch modules, with some workloads running <strong>hundreds of times faster</strong> than baseline.</em></p><p>AI models execute on hardware via GPU kernels that define each operation. The efficiency of those kernels determines how fast models run (in training and inference). Kernel optimizations like <em>FlashAttention</em><sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup> show dramatic speedups over baseline, underscoring the need for performant kernels.</p><p>While PyTorch and tools like <code>torch.compile</code><sup><a href="#user-content-fn-2" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-2">2</a></sup> handle some kernel optimizations, the last mile of performance still depends on handtuned kernels. These kernels are difficult to write, requiring significant time and expertise. It gets especially challenging when writing kernels outside of CUDA: expertise in non-CUDA platforms is rarer, and there is less tooling and documentation available</p><p>We set out to answer a simple question: could frontier models implement kernel optimizations automatically, across different backends? Billions of Apple devices rely on Metal kernels that are often under-optimized, so we started with Metal.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/pytorch_to_platforms.png" alt="Our vision: Autonomous kernel optimization for any target platform using frontier models"/></p><p>Our vision: Autonomous kernel optimization for any target platform using frontier models.</p><p>Across 215 PyTorch modules, our results show the generated kernels ran 87% faster on Apple hardware compared to baseline PyTorch. This approach requires no expertise in kernel engineering and can be done nearly instantly.</p><p>Here&#39;s a preview of what we discovered:</p><ul><li>Many cases where our approach improved performance by 10-100X</li><li>Cases where models surfaced algorithmically unnecessary work and removed it (that PyTorch didn&#39;t catch)</li><li>The impact of incorporating performance profiling and CUDA reference code</li><li>Why a simple agentic swarm dominates over individual frontier models</li></ul><p>We included 8 frontier models from Anthropic, DeepSeek, and OpenAI in our analysis:</p><ul><li>Anthropic family<ul><li>claude-sonnet-4 (2025-05-14)</li><li>claude-opus-4 (2025-05-14)</li></ul></li><li>OpenAI family<ul><li>gpt-4o (2024-11-20)</li><li>gpt-4.1 (2025-04-14)</li><li>gpt-5 (2025-08-07)</li><li>o3 (2025-04-16)</li></ul></li><li>DeepSeek family<ul><li>deepseek-v3 (2025-03-25)</li><li>deepseek-r1 (2025-05-28)</li></ul></li></ul><p>In terms of test inputs, we used the PyTorch modules defined in the KernelBench<sup><a href="#user-content-fn-3" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-3">3</a></sup> dataset. KernelBench contains 250 PyTorch modules defining ML workloads of varying complexity. 31 modules contain operations that are currently unsupported in the PyTorch backend for MPS (Metal Performance Shaders), so they were excluded from this analysis. (We ended up excluding 4 additional modules for reasons that will be discussed later.)</p><div><table><thead><tr><th>KernelBench Category</th><th>Description</th><th># of Test Cases</th></tr></thead><tbody><tr><td>Level 1</td><td>Simple primitive operations (e.g. matrix multiplication, convolution)</td><td>91</td></tr><tr><td>Level 2</td><td>Sequences of multiple operations from Level 1</td><td>74</td></tr><tr><td>Level 3</td><td>Complete model architectures (e.g. AlexNet, VGG)</td><td>50</td></tr></tbody></table></div><p>When evaluating the agent-generated kernels, we need to assess both correctness and performance relative to the baseline PyTorch implementation (at the time of writing, <code>torch.compile</code> support for Metal is still underway, so it could not serve as a comparison point. MLX is also a great framework for Apple devices, but this work focused on pure PyTorch code optimization, whereas MLX is its own framework). We also made sure to carefully clear the cache between runs, otherwise cached results can falsely present as speedups.</p><div><table><thead><tr><th>Experimental Variable</th><th>Specification</th></tr></thead><tbody><tr><td>Hardware</td><td>Mac Studio (Apple M4 Max chip)</td></tr><tr><td>Models</td><td>Claude Opus 4, Claude Sonnet, DeepSeek r1, DeepSeek v3, GPT-4.1, GPT-4o, GPT-5, o3</td></tr><tr><td>Dataset</td><td>KernelBench</td></tr><tr><td>Baseline Implementation</td><td>PyTorch eager mode</td></tr><tr><td>Number of shots</td><td>5</td></tr></tbody></table></div><p>We begin with the simplest implementation of the kernel-writing agent for Metal:</p><ul><li>Receives the prompt and PyTorch code</li><li>Generates Metal kernels</li><li>Assesses if they match the baseline PyTorch for correctness<sup><a href="#user-content-fn-4" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-4">4</a></sup>.</li><li>If they fail to compile or are not correct, an error message is passed back to the agent for another try, with up to 5 tries permitted.</li></ul><p>It&#39;s interesting to see how the correctness increases with the number of attempts. o3, for example, gets a working implementation about 60% of the time on the first try, and reaches 94% working implementations by attempt 5.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/o3_baseline_cumulative_success.png" alt="o3&#39;s success rate by generation attempt and kernel level"/></p><p>o3&#39;s success rate by generation attempt and kernel level. We limited the agent to 5 tries, which seems sufficient for Level 1 and 2 kernels, but Level 3 kernels may benefit from further shots.</p><p>Let&#39;s look at each of our 8 models correctness rates, broken down by whether or not the implementation was faster than our baseline or not:</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/frontier_models_correctness_speedup.png" alt="Kernel correctness, broken down by whether or not the optimized version was faster than the baseline"/></p><p>Kernel correctness, broken down by whether or not the optimized version was faster than the baseline.</p><p>The reasoning models are pretty good at generating correct kernels across levels, although the non-reasoning models are also capable of doing this sometimes. However, other than GPT-5, these models are more often generating implementations that are slower than the baseline PyTorch. GPT-5&#39;s success at generating faster implementations for Level 2 problems is particularly notable.</p><p>Every agent produced some kernels that were faster than baseline, and some of them came up with pretty cool stuff. GPT-5 produced a 4.65X speedup for a Mamba 2<sup><a href="#user-content-fn-5" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-5">5</a></sup> state space model, primarily by fusing kernels to reduce the overhead of kernel launch and improve memory access patterns.</p><p>Some of the optimizations were surprisingly clever. In one case, o3 improved latency by over 9000X! o3 assessed the code and identified that given the model&#39;s configuration, the results would always be 0s, mathematically. This was not a trivial realization, but it did make the implementation itself trivial.</p><p>There were 4 problems, all from Level 2, where the most optimal implementation showed that the problem could be reduced to a trivial solution. Despite the true cleverness shown by the models, we excluded these from our analysis - but in the real use cases with imperfect code, this type of speedup mechanism would be quite useful.</p><p>One interesting thing to note is that the AI-generated kernels don&#39;t actually have to be faster every single time to be useful. For long running workloads, it makes sense to profile different implementations - this could even happen automatically. So as long as the AI-generated implementation is <em>sometimes</em> faster, it&#39;s valuable - we can always fall back to the baseline implementation when the AI-generated implementation doesn&#39;t work or is slower.</p><p>Let&#39;s evaluate the average speedup compared to the baseline for each of our 8 agents. Based on our realization above, the minimum speedup is always 1X - this is the case where the generated implementation either doesn&#39;t work or is slower than the baseline. We use the geometric mean here rather than the arithmetic mean<sup><a href="#user-content-fn-6" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-6">6</a></sup>.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/baseline_speedup.png" alt="Average speedup by model, broken down by level"/></p><p>Average speedup by model, broken down by level.</p><p>We can see that using GPT-5 produces an average speedup of ~20%, with the other models trailing. One possible conclusion: we should use GPT-5 for kernel generation, possibly giving it some additional context. This would make sense if all of the models tended to behave the same way - generally finding the same optimizations on a consistent set of problems, and failing to optimize other problems.</p><p>This isn&#39;t what the data actually shows though! Breaking it down by which model did the best across problems, we see that GPT-5 does the best, at 34% of problems where it generates the best solution. But there are another 30% of problems where another model generated a better solution than GPT-5!</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/number_of_wins.png" alt="Across problem levels, this chart shows which model performed the best"/></p><p>Across problem levels, this chart shows which model performed the best (or baseline if none of the models beat the baseline performance).</p><p>This leads to a key insight: kernel generation should use a &#34;Best of N&#34; strategy. Extra generation passes are relatively cheap, it&#39;s human effort and the runtime of the model (once deployed) that are expensive.</p><p>Our flow for optimized kernel generation now looks like an agentic swarm. We have a supervisor, which is simple for now. It assesses the generated kernels across all agents, times them against the baseline, and then selects the optimal implementation for the problem. The ability to time and verify implementations against a baseline makes kernel generation a really good candidate for AI generation - it&#39;s much more convenient than some other code generation use cases, because we need minimal supervision to evaluate results on the fly.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/pytorch_to_metal.png" alt="The architecture of our agentic swarm for kernel generation"/></p><p>The architecture of our agentic swarm for kernel generation. In this iteration, the supervisor is simple, but in upcoming work we will extend the supervisor to be more dynamic.</p><p>Let&#39;s see how our agentic swarm performs compared to the standalone models&#39; performance from earlier.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/baseline_speedup_best_of_n.png" alt="Performance of the initial agentic swarm implementation for kernel generation"/></p><p>Performance of the initial agentic swarm implementation for kernel generation, showing significantly improved results compared to standalone agents.</p><p>We can see this approach gives us better results than even GPT-5 - an average 31% speedup across all levels, 42% speedup in Level 2 problems. The agentic swarm is doing a pretty good job already with minimal context - just the input problem and prompt. Next, we tried giving more context to the agents in order to get even faster kernels.</p><p>What information would a human kernel engineer need to improve the performance of their hand-written kernels? Two key sources come to mind: another optimized reference implementation, and profiling information.</p><p>As a result, we gave our agents the power to take in two additional sources of information when generating kernels for Metal:</p><ol><li>A CUDA implementation for those kernels (since optimized CUDA references are often available due to the pervasiveness of Nvidia GPUs)</li><li>Profiling information from gputrace on the M4.</li></ol><p>Unfortunately, Apple does not make the Metal kernel profiling information easy to pull programmatically via Xcode… So we had to get creative.</p><p>We solved the problem by using <a target="_blank" rel="noopener noreferrer" href="https://github.com/BlueM/cliclick">Bluem&#39;s cliclick</a> tool to interact with Xcode&#39;s GUI. Our Apple Script capture summary, memory and timeline views for each collected gputrace:</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/xcode_screenshot.png" alt="Example screenshot from Xcode used for analysis"/></p><p>Example screenshot from Xcode used for analysis. You can see in the screenshot above that there is a clear pipeline bubble after the ndArrayPooling, resulting in idle time.</p><p>We could only add profiling information to models that support multimodal inputs. We divided out the screenshot processing into a subagent, whose job it was to provide performance optimization hints to the main model. The main agent took an initial pass at implementation, which was then profiled and timed. Screenshots were then passed to the subagent to generate performance hints. The maximum number of shots remained the same as before - 5 shots total.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/subagent.png" alt="Subagent architecture"/></p><p>Subagent architecture</p><p>Similar to our previous finding that the best model varied depending on the problem, we also saw that there was no &#34;single best&#34; configuration in terms of context. Sometimes, adding just one piece of information - either the CUDA reference code or the profiling information - produced the best result. Other times, adding both was helpful. There were still cases where the pure agents with no additional context performed better than the agents with more context!</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/configuration_wins_collapsed.png" alt="Best agent context configuration by problem level"/></p><p>Best agent context configuration by problem level. We can see that the baseline PyTorch is now only superior to the best generated kernels in about ~8% of cases.</p><p>The results are particularly striking for Level 2 kernels. Our assessment is that this is because Level 2 kernels benefit more from fusion than Level 1 kernels. Level 3, on the other hand, may be too complex to generate in a single pass. Stay tuned for some improvements where we break down the problem into more manageable chunks for the agent to handle.</p><p>That being said, there were still some good kernels for Level 3. DeepSeek-R1 improved on the default implementation with advanced fusion techniques for a VisionAttention problem. It also showed awareness of Metal-specific features, leveraging threadgroups for more efficient shared memory. While there are still further optimization opportunities left on the table, this implementation was over 18X faster than the baseline PyTorch!</p><p>Now, let&#39;s evaluate the performance of our agentic swarm. Previously, we did Best of N analysis across all frontier models. Now we do Best of N analysis across the different configurations of each frontier model (CUDA only, CUDA plus profiling, etc). Remember that generating multiple candidate implementations and testing them for performance is a lot &#34;cheaper&#34; than human experts manually writing the code, or running less optimized models at high volume - so offloading more generation to the swarm is worthwhile if it delivers noticeably better results.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/overall_performance.png" alt="The overall performance of the full agentic swarm"/></p><p>The overall performance of the full agentic swarm at kernel generation for Metal on the problems tested.</p><p>This is a great speedup - 1.87x better on average than the baseline, nearly instantly, directly from pure PyTorch code. The vanilla agents only saw a 1.31x average speedup, so adding in this additional context almost tripled the improvement we saw!</p><p>Looking at the distribution of improvements, we see that the median speedup was about 1.35X and 2 kernels were hundreds of times faster than the original implementation. (As mentioned before, we excluded the 4 &#34;trivial&#34; kernels, which were thousands of times faster by cutting out unnecessary work.)</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/speedup_distribution.png" alt="The overall performance of the full agentic swarm"/></p><p>The distribution of speedups for the agentic swarm (215 problems total, 4 trivial kernels with large speedups excluded). Median speedup was 1.35X, (geometric) mean 1.87X, with 2 kernels 100X or more faster.</p><p>These results show that it&#39;s possible to <strong>automatically</strong> drive significant improvements to model performance by automating the kernel optimization without any user code changes, new frameworks, or porting.</p><p>AI can take on portions of optimization that a human kernel engineer would do, leaving the human effort focused on the most complex optimizations.</p><p>Soon, developers can get immediate boosts to their model performance via AI-generated kernels, without low-level expertise or needing to leave pure PyTorch:</p><ul><li>Dynamically speeding up training workloads as they run</li><li>Automatic porting new models to new frameworks/devices (not just Metal)</li><li>Speeding up large scale inference workloads</li></ul><p>We are hard at work at pushing the envelope further with this technique - smarter agent swarms, better context, more collaboration between agents, and more backends (ROCm, CUDA, SYCL, etc). We&#39;re also working on speeding up training workloads, not just inference.</p><p>With this technique, new models can be significantly faster on every platform on day 0. If you&#39;re excited about this direction, we&#39;d love to hear from you: <a target="_blank" rel="noopener noreferrer" href="mailto:hello@gimletlabs.ai">hello@gimletlabs.ai</a>.</p><p><img src="https://proclamations.nebcorp-hias.com/blog/images/ai-metal-kernels/agentic_vision_swarm.png" alt="We can automatically speed up kernels across any target platform using this technique"/></p><p>We can automatically speed up kernels across any target platform using this technique.</p></div></div></div></div></div></article></section></div></div>
  </body>
</html>
