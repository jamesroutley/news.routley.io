<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.bugsiki.dev/posts/apple-pmu/">Original</a>
    <h1>CPU Counters on Apple Silicon: article &#43; tool</h1>
    
    <div id="readability-page-1" class="page"><div>

<article>
   
  <div><p>Last time I wrote about <a href="https://blog.bugsiki.dev/posts/zig-profilers/">profiling in Zig on Apple Silicon</a>, I touched on PMU counter profiling. This time I decided to go further and create my own tool to fetch all available counters for Apple Silicon processors (M1, M2, and later).</p>
<h2 id="brief-explanation-of-pmu-counters">Brief explanation of PMU counters</h2>
<p>PMU (Performance Monitoring Unit) counters are hardware counters that track microarchitectural events inside the CPU, e.g. executed instructions, retired operations, branches, cache misses, and more.</p>
<p>CPUs usually expose a mix of fixed and programmable counters. Fixed counters represent predefined events (often things like cycles and instructions), while programmable counters can be configured to track a selected set of events.</p>
<p>Using PMU counters, developers can better understand the performance characteristics of their applications, e.g. the number of cache misses, branch mispredictions, instruction mix, and other low-level metrics.</p>
<h2 id="motivation">Motivation</h2>
<p>One of the solutions for fetching these counters was the <a href="https://github.com/andrewrk/poop">poop</a> tool written by Andrew Kelly and <a href="https://github.com/andrewrk/poop/pull/70">the PR</a> to his repository that adds the ability to fetch CPU counters on Apple Silicon by <a href="https://github.com/tensorush">tensorush</a>.</p>
<p>The main problem with this PR is that it was gracefully rejected by Andrew, and I fully get that decision, since itâ€™s hard to support additional implementation, especially if you donâ€™t use it.</p>
<p>Iâ€™ve created <a href="https://github.com/verte-zerg/poop">a fork</a> that you can use. Itâ€™s actually a good solution if you need to fetch several predefined PMU counters.</p>
<p>But Iâ€™ve decided to go a bit further and implement another tool for Apple Silicon Macs that can fetch all counters supported by Apple Silicon. Since that required understanding how it works, my tool implementation quickly became a research project about Appleâ€™s private <code>kperf</code> API.</p>
<p>Basically, this article is a journey through how the research went.</p>
<p>To perform experiments, I used a MacBook with an M2 Pro chip running macOS 15.6.1.</p>
<h2 id="apple-instruments-and-the-first-weird-limitation">Apple Instruments and the first weird limitation</h2>
<p>I started by researching how Apple Instruments works.</p>
<p>So, I opened Instruments, went to the â€œCPU Countersâ€ template, and tried to add/delete counters.</p>
<p>I quickly found out that Apple Instruments doesnâ€™t support fetching more than 10 counters, sometimes 8, and sometimes less. I was constantly getting errors like <code>&#39;&lt;SOME_COUNTER&gt;&#39; conflicts with a previously added event</code>. The maximum that I could get is 10 counters. So, the first takeaway was that <strong>there is a limit to how many counters I can fetch</strong>, and another is that <strong>counters are, in some way, incompatible with each other</strong>. Why and how theyâ€™re incompatible is a good question.</p>
<p>The difference between 10 and 8 counters can be explained by the fact that two of the counters are possibly fixed (always monitored by the CPU). In Instruments, they have special aliases. Take a look at this subset of available counters (5 out of 60):</p>
<ul>
<li>INST_ALL</li>
<li>INST_BARRIER</li>
<li>Cycles (FIXED_CYCLES)</li>
<li>L1D_CACHE_MISS_LD</li>
<li>Instructions (FIXED_INSTRUCTIONS)</li>
</ul>
<p>As you can see, the Cycles and Instructions counters have special aliases and the <code>FIXED_</code> prefix. And there are only two such counters in Instruments. So, we can assume that <strong>Apple Silicon has 2 fixed counters</strong>.</p>
<p>Iâ€™ve tried to search for any information about these limitations. These attempts lead me to <a href="https://developer.apple.com/download/apple-silicon-cpu-optimization-guide/">Appleâ€™s CPU optimization guide</a>, which is a great overview of how to optimize performance based on CPU counters.</p>
<p>Note: to access this guide you need to sign in to the Apple Developer portal.</p>
<p>But there I havenâ€™t found any information about limitations and incompatibilities. At least I got an interesting guide, a list of counters for each processor (M1-M4), and their descriptions.</p>
<h2 id="reverse-engineered-kperf-and-the-first-experiments">Reverse-engineered kperf and the first experiments</h2>
<p>The next information source was reverse-engineered code that uses the macOS <code>kperf</code> framework to fetch CPU counters. Itâ€™s great work performed by <a href="https://github.com/ibireme">ibireme</a>. The original code you can find <a href="https://gist.github.com/ibireme/173517c208c7dc333ba962c1f0d67d12">here</a>.</p>
<p>Itâ€™s worth mentioning that <code>kperf</code> is a private Apple framework that provides an interface for performance monitoring. Itâ€™s not documented publicly, so the only way to understand how it works is to study reverse-engineered code that uses it or do your own reverse-engineering. The tool also requires <code>sudo</code> privileges to run.</p>
<p>So, I took the <a href="https://codeberg.org/tensorush/scoop/src/branch/main/src/xnu.zig">Zig port</a> of the reverse-engineered <code>kperf</code> code and tried to find any incompatible pairs. Using this code I ran the first experiment, which basically goes through all counter pairs, adds them to the monitor list, and fetches counters for a simple function. The first good news is that Iâ€™ve found 6 counters (further: group M) that are incompatible in pairs.</p>
<p>The code works with the following algorithm: we make some preparation by initializing several configs and then add counters one by one. These incompatibilities happen when I add a new counter from group M to an already added counter from the same group. In this case, I get an error that the new counter cannot be added.</p>
<p>Group M (6 counters):</p>
<ul>
<li>INST_ALL</li>
<li>INST_INT_ALU</li>
<li>INST_INT_ST</li>
<li>INST_LDST</li>
<li>INST_SIMD_ALU</li>
<li>RETIRE_UOP</li>
</ul>
<p>Thatâ€™s it, the goal is reached, at least I thought so. But when I tried to add 8, in my opinion, compatible counters (not from group M), my attempt failed. I just got another error that these counters cannot be added together. It means that besides counters that are incompatible in pairs, there should be something else. I continued my experiments with finding incompatible counters by creating all possible combinations of triples, quadruples, and up to sets of 8.</p>
<h2 id="when-combinatorics-stopped-making-sense">When combinatorics stopped making sense</h2>
<p>These are the results of running the same experiment for different set sizes.</p>
<ol>
<li>pairs - only 6 counters (group M)</li>
<li>triples - no new incompatible counters (I excluded cases with 2 counters from group M)</li>
<li>quadruples - adds a new group of 18 counters (further: group G) that are incompatible in quadruples or in triples when combined with group M counters</li>
<li>sets of 5-6 - no new incompatible counters (I excluded cases discovered before)</li>
<li>sets of 7 - a lot of new incompatibilities</li>
</ol>
<p>Group G (18 counters):</p>
<ul>
<li>BRANCH_CALL_INDIR_MISPRED_NONSPEC</li>
<li>BRANCH_COND_MISPRED_NONSPEC</li>
<li>BRANCH_INDIR_MISPRED_NONSPEC</li>
<li>BRANCH_MISPRED_NONSPEC</li>
<li>BRANCH_RET_INDIR_MISPRED_NONSPEC</li>
<li>INST_BARRIER</li>
<li>INST_BRANCH</li>
<li>INST_BRANCH_CALL</li>
<li>INST_BRANCH_COND</li>
<li>INST_BRANCH_INDIR</li>
<li>INST_BRANCH_RET</li>
<li>INST_BRANCH_TAKEN</li>
<li>INST_INT_LD</li>
<li>INST_SIMD_LD</li>
<li>INST_SIMD_ST</li>
<li>L1D_CACHE_MISS_LD_NONSPEC</li>
<li>L1D_CACHE_MISS_ST_NONSPEC</li>
<li>L1D_TLB_MISS_NONSPEC</li>
</ul>
<p>So, the final list blew my mind: Iâ€™ve found 18_673_166 new incompatible cases. This is the number of failing combinations for sets of size 7. By the way, the total number of combinations for sets of size 7 is <code>C(55, 7) = 202_927_725</code>. Due to inconsistencies between Appleâ€™s guide and the real available counters, I checked only 55 out of 60 counters.</p>
<p>Iâ€™ve tried really hard to understand whatâ€™s going on, because the list didnâ€™t make any sense. With a little help from combinatorics, Python, and several hours of trying to get the desired number, I ended up with this final formula. You donâ€™t need to check it, but please take a look at it - I donâ€™t want that time to be completely wasted.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>C(<span>30</span>, <span>6</span>) <span>+</span> C(<span>30</span>, <span>5</span>) <span>*</span> C(<span>18</span>, <span>1</span>) <span>+</span> C(<span>30</span>, <span>4</span>) <span>*</span> C(<span>18</span>, <span>2</span>) <span>+</span> C(<span>30</span>, <span>5</span>) <span>*</span> C(<span>6</span>, <span>1</span>) <span>+</span> C(<span>30</span>, <span>4</span>) <span>*</span> C(<span>18</span>, <span>1</span>) <span>*</span> C(<span>6</span>, <span>1</span>)
</span></span><span><span><span>+</span> C(<span>30</span>, <span>6</span>) <span>+</span> C(<span>30</span>, <span>5</span>) <span>*</span> C(<span>18</span>, <span>1</span>) <span>+</span> C(<span>30</span>, <span>4</span>) <span>*</span> C(<span>18</span>, <span>2</span>)
</span></span><span><span><span>+</span> C(<span>12</span>, <span>6</span>) <span>+</span> C(<span>12</span>, <span>5</span>) <span>*</span> C(<span>17</span>, <span>1</span>) <span>+</span> C(<span>12</span>, <span>4</span>) <span>*</span> C(<span>17</span>, <span>2</span>) <span>+</span> C(<span>12</span>, <span>5</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>+</span> C(<span>12</span>, <span>4</span>) <span>*</span> C(<span>17</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>1</span>)
</span></span><span><span><span>+</span> C(<span>8</span>, <span>6</span>) <span>+</span> C(<span>8</span>, <span>5</span>) <span>*</span> C(<span>16</span>, <span>1</span>) <span>+</span> C(<span>8</span>, <span>4</span>) <span>*</span> C(<span>16</span>, <span>2</span>) <span>+</span> C(<span>8</span>, <span>5</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>+</span> C(<span>8</span>, <span>4</span>) <span>*</span> C(<span>16</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>1</span>)
</span></span><span><span><span>+</span> C(<span>7</span>, <span>6</span>) <span>+</span> C(<span>7</span>, <span>5</span>) <span>*</span> C(<span>15</span>, <span>1</span>) <span>+</span> C(<span>7</span>, <span>4</span>) <span>*</span> C(<span>15</span>, <span>2</span>) <span>+</span> C(<span>7</span>, <span>5</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>+</span> C(<span>7</span>, <span>4</span>) <span>*</span> C(<span>15</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>1</span>)
</span></span><span><span><span>+</span> C(<span>5</span>, <span>4</span>) <span>*</span> (C(<span>10</span>, <span>3</span>) <span>+</span> C(<span>10</span>, <span>2</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>+</span> C(<span>10</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>2</span>))
</span></span><span><span><span>+</span> C(<span>5</span>, <span>5</span>) <span>*</span> (C(<span>10</span>, <span>2</span>) <span>+</span> C(<span>10</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>1</span>))
</span></span><span><span><span>+</span> C(<span>5</span>, <span>4</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>*</span> (C(<span>10</span>, <span>2</span>) <span>+</span> C(<span>10</span>, <span>1</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>+</span> C(<span>5</span>, <span>2</span>))
</span></span><span><span><span>+</span> C(<span>5</span>, <span>5</span>) <span>*</span> C(<span>5</span>, <span>1</span>) <span>*</span> (C(<span>10</span>, <span>1</span>) <span>+</span> C(<span>5</span>, <span>1</span>))
</span></span></code></pre></div><p>where <code>C(n, k)</code> is the number of unique subsets of size <code>k</code> from a total of <code>n</code> elements. Itâ€™s also called the binomial coefficient, or â€œn choose kâ€.</p>
<p>I didnâ€™t even try to run the experiment for sets of 8 because it looked like a dead end. My experiments kinda failed, but at least I refreshed my knowledge of combinatorics.</p>
<h2 id="order-matters">Order matters</h2>
<p>I couldnâ€™t stop thinking that it just couldnâ€™t be implemented this way.</p>
<p>My final attempt was to change the order of counters and <em>voila</em>, the number of failed cases changed (I sadly donâ€™t remember the exact numbers). This time I decided to skip the part with figuring out how the final number was made.</p>
<p>So, the new takeaway is: <strong>the order in which you add counters DOES matter</strong>. And the scariest thing is that the order matters even in the Apple Instruments app.</p>
<p>You can verify this yourself: try adding these counters in this specific order:</p>
<ul>
<li>L1D_TLB_ACCESS</li>
<li>L1D_TLB_MISS</li>
<li>L1D_CACHE_MISS_ST</li>
<li>L1D_CACHE_MISS_LD</li>
<li>LD_UNIT_UOP</li>
<li>ST_UNIT_UOP</li>
<li>INST_LDST</li>
</ul>
<p>The last one must show a red circle (error), but if you change the order to:</p>
<ul>
<li>L1D_TLB_ACCESS</li>
<li>L1D_TLB_MISS</li>
<li>L1D_CACHE_MISS_ST</li>
<li>L1D_CACHE_MISS_LD</li>
<li>LD_UNIT_UOP</li>
<li>INST_LDST</li>
<li>ST_UNIT_UOP</li>
</ul>
<p>Basically, swap the last two counters, and everything will work fine.</p>
<p>So, if you ever have an issue with an incompatible counter in Apple Instruments, just try to reorder counters in the app. Weâ€™ll get back to the right order shortly.</p>
<h2 id="the-missing-piece">The missing piece</h2>
<p>Okay, the order matters, but which order is correct, and why does it matter? It forced me to research the reverse-engineered <code>kperf</code> client one more time and find what I can get from it. <code>kpep_db</code> and <code>kpep_event</code> caught my eye, especially their structures.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/// KPEP event (size: 48/28 bytes on 64/32 bit OS)
</span></span></span><span><span><span></span><span>typedef</span> <span>struct</span> kpep_event {
</span></span><span><span>    <span>const</span> <span>char</span> <span>*</span>name;         <span>///&lt; Unique name of an event, such as &#34;INST_RETIRED.ANY&#34;.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>description;  <span>///&lt; Description for this event.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>errata;       <span>///&lt; Errata, currently NULL.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>alias;        <span>///&lt; Alias name, such as &#34;Instructions&#34;, &#34;Cycles&#34;.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>fallback;     <span>///&lt; Fallback event name for fixed counter.
</span></span></span><span><span><span></span>    u32 mask;
</span></span><span><span>    u8 number;
</span></span><span><span>    u8 umask;
</span></span><span><span>    u8 reserved;
</span></span><span><span>    u8 is_fixed;
</span></span><span><span>} kpep_event;
</span></span><span><span>
</span></span><span><span><span>/// KPEP database (size: 144/80 bytes on 64/32 bit OS)
</span></span></span><span><span><span></span><span>typedef</span> <span>struct</span> kpep_db {
</span></span><span><span>    <span>const</span> <span>char</span> <span>*</span>name;              <span>///&lt; Database name, such as &#34;haswell&#34;.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>cpu_id;            <span>///&lt; Plist name, such as &#34;cpu_7_8_10b282dc&#34;.
</span></span></span><span><span><span></span>    <span>const</span> <span>char</span> <span>*</span>marketing_name;    <span>///&lt; Marketing name, such as &#34;Intel Haswell&#34;.
</span></span></span><span><span><span></span>    <span>void</span> <span>*</span>plist_data;              <span>///&lt; Plist data (CFDataRef), currently NULL.
</span></span></span><span><span><span></span>    <span>void</span> <span>*</span>event_map;               <span>///&lt; All events (CFDict&lt;CFSTR(event_name), kpep_event *&gt;).
</span></span></span><span><span><span></span>    kpep_event <span>*</span>event_arr;         <span>///&lt; Event struct buffer (sizeof(kpep_event) * events_count).
</span></span></span><span><span><span></span>    kpep_event <span>**</span>fixed_event_arr;  <span>///&lt; Fixed counter events (sizeof(kpep_event *) * fixed_counter_count)
</span></span></span><span><span><span></span>    <span>void</span> <span>*</span>alias_map;               <span>///&lt; All aliases (CFDict&lt;CFSTR(event_name), kpep_event *&gt;).
</span></span></span><span><span><span></span>    usize reserved_1;
</span></span><span><span>    usize reserved_2;
</span></span><span><span>    usize reserved_3;
</span></span><span><span>    usize event_count;             <span>///&lt; All events count.
</span></span></span><span><span><span></span>    usize alias_count;
</span></span><span><span>    usize fixed_counter_count;
</span></span><span><span>    usize config_counter_count;
</span></span><span><span>    usize power_counter_count;
</span></span><span><span>    u32 architecture;
</span></span><span><span>    u32 fixed_counter_bits;
</span></span><span><span>    u32 config_counter_bits;
</span></span><span><span>    u32 power_counter_bits;
</span></span><span><span>} kpep_db;
</span></span></code></pre></div><p>The first thing that I did was get a list of counters using the <code>kpep_db_events</code> function and display all fields. I provided only name, alias, and mask, because other fields are mostly empty or not relevant.</p>
<table>
<thead>
<tr>
<th>#</th>
<th>name</th>
<th>alias</th>
<th>mask</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>FIXED_CYCLES</td>
<td>Cycles</td>
<td><code>0b0000000001</code></td>
</tr>
<tr>
<td>2</td>
<td>FIXED_INSTRUCTIONS</td>
<td>Instructions</td>
<td><code>0b0000000010</code></td>
</tr>
<tr>
<td>3</td>
<td>RETIRE_UOP</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>4</td>
<td>CORE_ACTIVE_CYCLE</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>5</td>
<td>L1I_TLB_FILL</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>6</td>
<td>L1D_TLB_FILL</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>7</td>
<td>MMU_TABLE_WALK_INSTRUCTION</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>8</td>
<td>MMU_TABLE_WALK_DATA</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>9</td>
<td>L2_TLB_MISS_INSTRUCTION</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>10</td>
<td>L2_TLB_MISS_DATA</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>11</td>
<td>MMU_VIRTUAL_MEMORY_FAULT_NONSPEC</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>12</td>
<td>INTERRUPT_PENDING</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>13</td>
<td>MAP_STALL_DISPATCH</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>14</td>
<td>MAP_REWIND</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>15</td>
<td>MAP_STALL</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>16</td>
<td>MAP_INT_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>17</td>
<td>MAP_LDST_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>18</td>
<td>MAP_SIMD_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>19</td>
<td>FLUSH_RESTART_OTHER_NONSPEC</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>20</td>
<td>INST_ALL</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>21</td>
<td>INST_BRANCH</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>22</td>
<td>INST_BRANCH_CALL</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>23</td>
<td>INST_BRANCH_RET</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>24</td>
<td>INST_BRANCH_TAKEN</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>25</td>
<td>INST_BRANCH_INDIR</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>26</td>
<td>INST_BRANCH_COND</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>27</td>
<td>INST_INT_LD</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>28</td>
<td>INST_INT_ST</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>29</td>
<td>INST_INT_ALU</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>30</td>
<td>INST_SIMD_LD</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>31</td>
<td>INST_SIMD_ST</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>32</td>
<td>INST_SIMD_ALU</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>33</td>
<td>INST_LDST</td>
<td>N/A</td>
<td><code>0b0010000000</code></td>
</tr>
<tr>
<td>34</td>
<td>INST_BARRIER</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>35</td>
<td>L1D_TLB_ACCESS</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>36</td>
<td>L1D_TLB_MISS</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>37</td>
<td>L1D_CACHE_MISS_ST</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>38</td>
<td>L1D_CACHE_MISS_LD</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>39</td>
<td>LD_UNIT_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>40</td>
<td>ST_UNIT_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>41</td>
<td>L1D_CACHE_WRITEBACK</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>42</td>
<td>LDST_X64_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>43</td>
<td>LDST_XPG_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>44</td>
<td>ATOMIC_OR_EXCLUSIVE_SUCC</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>45</td>
<td>ATOMIC_OR_EXCLUSIVE_FAIL</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>46</td>
<td>L1D_CACHE_MISS_LD_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>47</td>
<td>L1D_CACHE_MISS_ST_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>48</td>
<td>L1D_TLB_MISS_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>49</td>
<td>ST_MEMORY_ORDER_VIOLATION_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>50</td>
<td>BRANCH_COND_MISPRED_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>51</td>
<td>BRANCH_INDIR_MISPRED_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>52</td>
<td>BRANCH_RET_INDIR_MISPRED_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>53</td>
<td>BRANCH_CALL_INDIR_MISPRED_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>54</td>
<td>BRANCH_MISPRED_NONSPEC</td>
<td>N/A</td>
<td><code>0b0011100000</code></td>
</tr>
<tr>
<td>55</td>
<td>L1I_TLB_MISS_DEMAND</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>56</td>
<td>MAP_DISPATCH_BUBBLE</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>57</td>
<td>L1I_CACHE_MISS_DEMAND</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>58</td>
<td>FETCH_RESTART</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>59</td>
<td>ST_NT_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
<tr>
<td>60</td>
<td>LD_NT_UOP</td>
<td>N/A</td>
<td><code>0b1111111100</code></td>
</tr>
</tbody>
</table>
<p>If you take a look at the <code>mask</code> field, all incompatibilities suddenly become clear.</p>
<h2 id="the-algorithm">The algorithm</h2>
<p>The mask field gives us answers to all mysteries above:</p>
<ol>
<li>The maximum number of counters is 10, based on the mask width (10 bits).</li>
<li>Two counters are unique: theyâ€™re compatible with any other counter because they have unique masks (fixed counters): Cycles (<code>0b0000000001</code>) and Instructions (<code>0b0000000010</code>).</li>
<li>Besides these two counters, there are 6 others that we found before (group M) that are incompatible in pairs. Their masks are the same (<code>0b0010000000</code>), so they book the same slot when added, causing incompatibility.</li>
<li>There are also 19 counters that have the same specific mask. From the previous research we also found them (group G, but due to inconsistencies between Appleâ€™s guide and the actual list, the group contained only 18 counters). These counters are incompatible in quadruples because when you add 3 of them, they book all 3 available slots, and when you try to add the 4th one, there is no slot left. Group G counters overlap with group M counters, which means that counters from group M also book slots that group G counters use.</li>
</ol>
<p>Regarding the order, I think the following statement explains how the algorithm for adding new counters works:</p>
<p><strong>When we add a counter to the list, it picks the first available slot starting from the lower bit based on its mask.</strong></p>
<p>The reason why order matters is that if you add an event with a wide mask, it books a slot starting from the right side and doesnâ€™t leave a slot for other â€œspecialâ€ counters (with a specific mask). So, to get predictable behavior, itâ€™s better to add events in a specific order. A simple ascending order (by mask) is suitable in this case, but it can be much more complicated if <code>mask</code> has a more complex format.</p>
<p>Here is an explanation of why the Instruments app shows an error for the previous example:</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Counter</th>
<th>Mask</th>
<th>Resulting mask</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Initial</td>
<td>N/A</td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>1</td>
<td>L1D_TLB_ACCESS</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>2</td>
<td>L1D_TLB_MISS</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>3</td>
<td>L1D_CACHE_MISS_ST</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>4</td>
<td>L1D_CACHE_MISS_LD</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>5</td>
<td>LD_UNIT_UOP</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>6</td>
<td>ST_UNIT_UOP</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>7</td>
<td>INST_LDST</td>
<td><code>0010000000</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸ”´ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢ (conflict)</td>
</tr>
</tbody>
</table>
<p>But if we swap the last two counters:</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Counter</th>
<th>Mask</th>
<th>Resulting mask</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>LD_UNIT_UOP</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>6</td>
<td>INST_LDST</td>
<td><code>0010000000</code></td>
<td>ğŸŸ¢ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
<tr>
<td>7</td>
<td>ST_UNIT_UOP</td>
<td><code>1111111100</code></td>
<td>ğŸŸ¢ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¡ğŸŸ¢ğŸŸ¢</td>
</tr>
</tbody>
</table>
<p>In this case, everything works fine.</p>

<p>Wrapping everything up, Iâ€™ve created a tool called â€œLaukaâ€. â€œCreatedâ€ is quite a bold word: Iâ€™ve taken a base from the original <a href="https://github.com/andrewrk/poop">poop</a> repository and the <a href="https://codeberg.org/tensorush/scoop.git">scoop</a> library, merged them, rewrote the CLI and extended it. There is also new functionality, e.g. selecting events to monitor, displaying all available events, and warming up. Also, I deleted support for Linux and Intel-based Macs. So this tool only works for Apple Silicon Macs.</p>
<p>I donâ€™t want to repeat <code>README.md</code> content, you can check it out on <a href="https://github.com/verte-zerg/lauka">GitHub</a>.</p>
<p>Here is a small example of how to run the tool and what output it produces:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>$ lauka -- <span>&#34;./build-old&#34;</span> <span>&#39;./build-new -O2&#39;</span>
</span></span><span><span>
</span></span><span><span>Benchmark <span>1</span> <span>(</span><span>9</span> runs<span>)</span>: ./build-old
</span></span><span><span>
</span></span><span><span>measurement                 mean Â± Ïƒ          min â€¦ max            outliers
</span></span><span><span>wall_time                   591ms Â± 7.6ms     583ms â€¦ 605ms        <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>peak_rss                    137MB Â± 0.3MB     136.6MB â€¦ 137.4MB    <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>core_active_cycle           2.51G Â± 22.1M     2.48G â€¦ 2.54G        <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>inst_all                    3.62G Â± 23.9M     3.53G â€¦ 3.69G        <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>l1d_cache_miss_ld_nonspec   3.58M Â± 31.7K     3.54M â€¦ 3.63M        <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>branch_mispred_nonspec      21.4M Â± 58.2K     21.3M â€¦ 21.5M        <span>0</span> <span>(</span>0%<span>)</span>
</span></span><span><span>
</span></span><span><span>Benchmark <span>2</span> <span>(</span><span>9</span> runs<span>)</span>: ./build-new -O2
</span></span><span><span>
</span></span><span><span>measurement                 mean Â± Ïƒ          min â€¦ max            outliers    delta
</span></span><span><span>wall_time                   130ms Â± 8.3ms     125ms â€¦ 141ms        <span>0</span> <span>(</span>0%<span>)</span>      âš¡ âˆ’78.0% Â± 0.5%
</span></span><span><span>peak_rss                    91.9MB Â± 0.09MB   91.8MB â€¦ 92.1MB      <span>0</span> <span>(</span>0%<span>)</span>      âˆ’32.9% Â± 0.1%
</span></span><span><span>core_active_cycle           507M Â± 2.35M      503M â€¦ 511M          <span>0</span> <span>(</span>0%<span>)</span>      âˆ’79.8% Â± 0.1%
</span></span><span><span>inst_all                    796M Â± 10.7M      781M â€¦ 809M          <span>0</span> <span>(</span>0%<span>)</span>      âˆ’78.0% Â± 0.1%
</span></span><span><span>l1d_cache_miss_ld_nonspec   352K Â± 7.7K       318K â€¦ 355K          <span>0</span> <span>(</span>0%<span>)</span>      âˆ’90.2% Â± 0.1%
</span></span><span><span>branch_mispred_nonspec      4.52M Â± 11.5K     4.51M â€¦ 4.57M        <span>2</span> <span>(</span>5%<span>)</span>      âˆ’78.9% Â± 0.0%
</span></span></code></pre></div><h2 id="summary">Summary</h2>
<p>Quite a nice journey it was: an almost complete lack of documentation, not much discussion, and one great reverse-engineered code as the only reliable source.</p>
<p>Looking back, I think that Iâ€™ve made several mistakes:</p>
<ul>
<li>Trying to search for information only related to Apple Silicon. I think I could have found more by researching how itâ€™s implemented on Linux first.</li>
<li>Reviewing the reverse-engineered code only briefly. Doing a deeper dive earlier could have helped me avoid the combinatorial explosion.</li>
<li>Spending too much time trying to figure out the final number of incompatible sets, instead of focusing on finding the root cause.</li>
</ul>
<p>But I donâ€™t regret anything, because the experience was unforgettable. And I like that Iâ€™ve made these mistakes.</p>
<p>I hope you found the research quite interesting and useful. Thanks for reading!</p>


  </div>

  
</article>
    </div></div>
  </body>
</html>
