<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gbletr42/bef">Original</a>
    <h1>Show HN: bef â€“ a tool that encodes/decodes interleaved erasure coded streams</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>This software package has not been extensively battle tested in the real world. While your data is <em>probably</em> safe, there may be data eating bugs hiding</strong></p>
<p dir="auto"><strong>Due to a problem I hadn&#39;t forseen with information deletion/insertion, the format in v0.1 will be incompatible with the next version that fixes that major issue, hey I warned you that I would have a major flaw that I only realize talking to people in the release notes. We could solve the problem within the current limitations of the format, but it would not be performant, so we&#39;ll violate our sacred trust of backwards compatiblity this time</strong></p>

<p dir="auto">Block Erasure Format is a file utility and file format designed to fix the pain points I&#39;ve personally had with existing utilities. It has a nice and easy to use interface, at least according to me, it is simple with minimal overhead, and it is very fast. It is also designed to be modular and extensible, with modular hash and parity library backends. The file format is fully streamable, meaning it does not need to have a seekable file to work, so you can just pipe data right in from say tar. It is finally a very small piece of software, only around 1.5 klocs, so it should be readily auditable and forkable.</p>

<p dir="auto">Erasure codes are a type of error correction codes that can be applied to a set of k input symbols (such as k blocks of data) and output k+n output symbols. You can lose any n symbols from the output before you are unable to reconstruct the original input, providing you with significant protection against corruption.</p>
<p dir="auto">These are used in situations where there can be significant burst corruption, where a large sequential number of bytes are corrupted, and you don&#39;t want to lose all your data. Examples of existing technologies that use this are CDs, DVDs, BDs, HDDs, and SSDs, each having failure modes that require it.</p>

<p dir="auto">The format is designed to be simple, although it was quite a bit more complicated earlier in the design process. It is based on the concept of a &#39;block&#39; of data, which is then split into data and parity fragments by the parity backend. Then these fragments are hashed and interleaved with fragments from n other blocks. A simple diagram is below. M is the last fragment number, which also are the parity fragments.</p>
<p dir="auto">[B1-F1] -&gt; [B2-F1] -&gt; [B3-F1] -&gt; [B1-F2] -&gt; [...] -&gt; [B1-FM] -&gt; [B2-FM] -&gt; [B3-FM]</p>
<p dir="auto">This format is pretty similar to the one used in CDs, but unlike that standard bef is fully variable in how it can follow this format. The number of parity and data fragments, the number of blocks to interleave, the block size, the hash, and the specific parity library providing the erasure codes are all customizable and stored in a header right before the data.</p>
<p dir="auto">Currently, that is all the information stored in the header, making it only 20 bytes large. However, we want to be able to extend the format in the future and ensure we are getting a good header. So the header has additional operation flags and padding to make it 64 bytes, is duplicated in case it corrupts, and a hash is available to check its integrity. In the worst case, we can omit the header entirely if we already know all information.</p>
<p dir="auto">I believe this format is, or at least can be with the right settings, highly resilient to burst corruption. Under default settings, it can handle in the worst case one burst of slightly larger than 8KiB per 192KiB. It is however not resilient to random noise, and will corrupt beyond repair in such environments. Luckily environments with such ambient noise in computing are rare, outside of telecommunications.</p>

<p dir="auto">I have built and tested it against x86-64 and x86, on Debian Bookworm and Alpine Linux 3.19, and the results are that it <em>seems</em> to work on both architectures!</p>
<p dir="auto">Only Linux is supported for now, it is not cross platform.</p>

<p dir="auto">Mandatory dependencies to build this package are</p>
<ul dir="auto">
<li><a href="https://github.com/Cyan4973/xxHash">xxhash</a></li>
</ul>
<p dir="auto">There are some additional optional dependencies as well</p>
<ul dir="auto">
<li><a href="https://github.com/BLAKE3-team/BLAKE3/tree/master/c">BLAKE3</a> for BLAKE3</li>
<li><a href="https://www.openssl.org" rel="nofollow">OpenSSL</a> for SHA1, SHA256, SHA3, BLAKE2S, and MD5</li>
<li><a href="https://github.com/madler/zlib">Zlib</a> for CRC32</li>
<li><a href="https://github.com/openstack/liberasurecode">liberasurecode</a> for Jerasure, ISA-L, and its own native implementation of Reed solomon codes, support.</li>
</ul>
<p dir="auto">Most of these are provided by distributions, except for liberasurecode and BLAKE3&#39;s C interface.</p>

<p dir="auto">These benchmarks are done on a Dell Latitude 7490, i5-7300U, 16GB of RAM, . The test file is 1GiB of random data recently read with cat right before the benchmark, and also in /tmp/. The software packages being compared are mine&#39;s truly, zfec, and par2cmdline (you&#39;ll see why its last ;) )</p>
<table>
<thead>
<tr>
<th>Run</th>
<th>bef</th>
<th>zfec</th>
<th>par2</th>
</tr>
</thead>
<tbody>
<tr>
<td>encode time (SSD)</td>
<td>2.17s</td>
<td>17.23s</td>
<td>41.88s</td>
</tr>
<tr>
<td>decode time (SSD)</td>
<td>1.06s</td>
<td>1.72s</td>
<td>0s (doesn&#39;t touch original data)</td>
</tr>
<tr>
<td>decode time + corruption (SSD)</td>
<td>4.39s</td>
<td>1.79s</td>
<td>21.62s</td>
</tr>
<tr>
<td>encode time (tmpfs)</td>
<td>2.05s</td>
<td>11.64s</td>
<td>42.90s</td>
</tr>
<tr>
<td>decode time (tmpfs)</td>
<td>1.12s</td>
<td>1.46s</td>
<td>0s (doesn&#39;t touch original data)</td>
</tr>
<tr>
<td>decode time + corruption (tmpfs)</td>
<td>1.11s</td>
<td>1.44s</td>
<td>19.92s</td>
</tr>
</tbody>
</table>
<p dir="auto">As one can see, bef is significantly faster than each option except zfec when it comes to decoding a corrupted fragment or two on disk. Par2 is very very slow, and that&#39;s very much one of the main reasons I made this software.</p>

<p dir="auto">With v0.1, the binary format is now frozen in place and will NEVER change. It can still be extended via use of flags and padding, but it will never be unable to be read by future versions of bef. Thus I guarantee full backward and partial forward compatibility, with the caveat that, since I am not an oracle, the forward compatibility is limited to the subset of features available at that given version, and thus incompatible with newer features extended to the binary format.</p>
<p dir="auto">However, the CLI is not frozen in place, but I will try my hardest to never modify, and the internal library API/ABI has no guarantees of any compatibility with any other version.</p>
</article></div></div>
  </body>
</html>
