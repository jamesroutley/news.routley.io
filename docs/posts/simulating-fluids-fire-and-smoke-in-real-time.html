<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrewkchan.dev/posts/fire.html">Original</a>
    <h1>Simulating fluids, fire, and smoke in real-time</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <h2>Notes on the math, algorithms, and methods involved in simulating fluids like fire and smoke in real-time.</h2>
    <dt-byline></dt-byline>
    <p>
      <em>Source code for this article can be found on <a href="https://github.com/andrewkchan/andrewkchan.github.io/tree/main/source/posts-source/blog-fire">my GitHub</a>.</em>
    </p>
    <p>
      Fire is an interesting graphics problem. Past approaches generally faked it. For example,
      <i>Lord of the Rings</i> <dt-cite key="Aitken:2004:LRV:1103900.1103911"></dt-cite> used sprites with lots and lots of smoke
      (the fluid sim was too expensive at the time, even for movies).
      Real-time applications like video games have pretty much exclusively
      used non-physical approaches.
    </p>
    <iframe width="560" height="400" src="https://www.youtube.com/embed/OieygwngQ6E?si=9kSBKO0WiDgVV0Oe" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
    <p>
      But in the last 10 years GPUs have made fast fluid simulation easy.
      Basic fluid dynamics algorithms are straightforward to implement on the GPU <dt-cite key="harris2005fast"></dt-cite>. In 2009, ILM used these techniques to model and render fire in
      <i>Harry Potter</i> <dt-cite key="horvath2009directable"></dt-cite>.
      And in 2014, NVIDIA released FlameWorks, a whole system for generating fire and smoke effects for games.
    </p>
    <p>
      This post takes notes on how fire can be simulated on the GPU. It walks through the math behind fluid dynamics,
      parallel algorithms for modeling fluids, and the extra combustion bits that make fire special. Readers should have a reasonable
      background in vector calculus and differential equations (know how to take the gradient of a vector). Demos are implemented with WebGL.
    </p>
    <dt-byline></dt-byline>
    <h2>1. Fluid Simulation</h2>
    <p>
      Before we simulate fire, we need to simulate fluid. We assume
      our fluid is <a href="https://en.wikipedia.org/wiki/Incompressible_flow">incompressible</a> and
      <a href="https://en.wikipedia.org/wiki/Inviscid_flow">inviscid</a>, which will vastly simplify our problem.
    </p>
    <h3>1.1 Basic Fluid Dynamics</h3>
    <p>
      Suppose \(D\) is a region in space filled with a fluid. At any point \( \mathbf{x} \in D \) and time \(t\), the fluid has velocity \(\mathbf{u}(\mathbf{x}, t)\).
      Computationally, we can represent the 2D velocity field \( \mathbf{u} \) with an \( N \times N \) grid, where the equally spaced grid points give the value of
      the velocity field at that point in space.
    </p>
    
    <p>
      <em>Ex: A 16\(\times\)16 grid representing \( \mathbf{u} = (y, -x) \)</em>
    </p>
    <p>
      What will happen if we put a drop of dye in the fluid?
    </p>
    <p>
      Let&#39;s define a scalar field \( \psi (\mathbf{x}, t) \) as the density of the dye at any point in space and time.
      The transport of quantities like \( \psi \) within a fluid by the fluid&#39;s velocity is called <b>advection</b>.
      Given some fluid&#39;s velocity field and an initial density field of our dye, we&#39;d like to see how the dye&#39;s density everywhere
      evolves over time by simulating its advection through the fluid.
    </p>
    <p><b>A Naive Method for Advection</b></p>
    <p>
      One idea <dt-fn>As seen below, our scalar field can be expressed as a differential equation. This idea is using Euler&#39;s method to solve it.</dt-fn> to compute
      the advection is to take each grid point, move forward the direction and distance that would be traveled
      by a particle at the grid point&#39;s velocity and the simulation timestep \( \Delta t \), and update the grid point nearest to where the particle lands:

      $$
      \psi (\mathbf{x} + \mathbf{u} (\mathbf{x}, t), t + \Delta t) = \psi (\mathbf{x}, t)
      $$
    </p>
    <p>
      But this is tricky to parallelize, since 2 grid points can end up in the same target point after forward evaluation.
      And in practice, the target point will fall between grid points, meaning it has to be interpolated into the surrounding grid points. Finally, this process is
      unstable for time steps above some number, causing  \( \psi \) to blow up.
    </p>
    <p><b>The Advection Partial Differential Equations</b></p>
    <p>
      This whole time we&#39;ve been solving a partial differential equation! If we&#39;re going to derive a stable method for advection, we&#39;ll need to
      first get an explicit expression for this PDE. Let&#39;s start from first principles.
    </p>
    <p>
      Consider a fixed region of space \(W\) (that is, \(W\) does not vary with time). The total mass of dye within \(W\)
      is \( \int_{W} \psi dV\). Over time, the change in mass is:

      $$
      \frac{d}{dt} \int_{W} \psi (\mathbf{x}, t) dV = \int_{W} \frac{\partial}{\partial t} \psi (\mathbf{x}, t) dV \\
      $$

      Now, letting \(S\) denote the surface of \(W\) and \( \mathbf{n} \) the outward normal vector defined along the surface, we can examine
      the mass flow rate through the surface of \(W\). In particular, observe that the volume flow rate - the <i>volume</i> of fluid that
      flows through per second  - across \(S\) per unit area is \( \mathbf{u} \cdot \mathbf{n} \) and the mass flow rate per unit area
      is \( \psi \mathbf{u} \cdot \mathbf{n} \).
    </p>
    
    <p>
      This gives us the <b>law of conservation of mass</b> in integral form:

      $$
      \frac{d}{dt} \int_{W} \psi dV = - \int_{S} \psi \mathbf{u} \cdot \mathbf{n} dA
      $$

      Can we get rid of the integrals and say something similar for points? By divergence theorem, the above is equivalent to

      $$
      \int_{W} [\frac{\partial \psi}{\partial t} + \nabla \cdot (\psi \mathbf{u})] dV = 0
      $$

      Then for a unit subregion \( W = dV \), we can say that

      $$
      \frac{\partial \psi}{\partial t} + \nabla \cdot (\psi \mathbf{u}) = 0
      $$

      This gives us an explicit PDE that we need to solve for \( \psi \)!
    </p>
    <p>
      Hmm... we could stop here, but we might be able to simplify this more. Specifically, it looks like we could isolate out
      a term \( \nabla \cdot \mathbf{u} \) that goes to zero because of incompressibility.

      $$
      \begin{aligned}
      &amp;\frac{\partial \psi}{\partial t} = - \nabla \cdot (\psi \mathbf{u}) \\
      &amp;= - (\frac{\partial}{\partial x} \psi u + \frac{\partial}{\partial y} \psi v) \\
      &amp;= - (\frac{\partial \psi}{\partial x} u + \frac{\partial u}{\partial x} \psi +  \frac{\partial \psi}{\partial y} v + \frac{\partial v}{\partial y} \psi) \\
      &amp;= - (\psi \nabla \cdot \mathbf{u} + \mathbf{u} \cdot \nabla \psi) \\
      &amp;= - \mathbf{u} \cdot \nabla \psi \\
      \end{aligned}
      $$

      Applying our incompressibility constraint \( \nabla \cdot \mathbf{u} = 0 \) at the end yields a scalar PDE, the first of our <b>incompressible flow advection equations</b>:

      $$
      \frac{\partial \psi}{\partial t} = \text{advection} (\mathbf{u}, \psi) = - \mathbf{u} \cdot \nabla \psi \tag{1}
      $$
      $$
      \frac{\partial \mathbf{v}}{\partial t} = \text{advection} (\mathbf{u}, \mathbf{v}) = - \mathbf{u} \cdot \nabla \mathbf{v} \tag{2}
      $$

      Eq. 2 for advecting a vector field \( \mathbf{v} \) through our velocity field can be derived similarly to the scalar advection equation.
    </p>
    <p><b>A Stable Method for Advection</b></p>
    <p>
      Let&#39;s look closely at eqn. (1):
      $$
      \frac{\partial \psi}{\partial t} = - \mathbf{u} \cdot \nabla \psi
      $$
    </p>
    <p>
      Notice that the right-hand term is a directional derivative in the \( -\mathbf{u} \) direction. This gives us a wonderful new method for
      advecting \( \psi \) by an incompressible fluid - starting at a grid point \( \mathbf{x} \), trace the fluid velocity <i>backwards</i>,
      replacing the value at our original point by the value that we land on (if we land between points, we can interpolate):

      $$
      \psi (\mathbf{x}, t + \Delta t) = \psi (\mathbf{x} - \mathbf{u} (\mathbf{x}, t), t)
      $$

      In GPU pseudocode:
    </p>
    <!-- <dt-code block language="glsl"> -->
      <pre>        <code>
          global Vec2Field u;
          global FloatField density;
          global float dt;

          // Run for each point in our scalar grid that we want to update
          float advectPoint(vec2 x) {
            vec2 coord = x - dt * getVec2At(u, x);
            return getFloatAt(density, coord);
          }
        </code>
      </pre>
    <!-- </dt-code> -->
    <p>
      This method is called
      <b>Semi-Lagrangian advection</b> and was invented in 1999 by Jos Stam <dt-cite key="stam1999stable"></dt-cite>.
      Like Euler, it&#39;s first-order accurate, but has exactly the additional properties we need:
    </p>
    <ol>
      <li>
        It&#39;s extremely easy to parallelize because each grid point only gets updated once per iteration.
      </li>
      <li>
        It&#39;s <i>unconditionally stable</i>. Why? Observe that for any grid point, the maximum value it can get updated to is the maximum value
        of all the grid points.
      </li>
    </ol>
    <p>
      For a fixed velocity field fulfilling the incompressibility constraint, it works great.
    </p>
    <div>
      <div>
        <p>
          Click and hold
        </p>
      </div>
      <canvas id="velocity-canvas"></canvas>
    </div>
    <p>
      <em>Click anywhere above to drop some dye in the flow</em>
    </p>
    <dt-byline></dt-byline>
    <h3>1.2 The Navier-Stokes Equations</h3>
    <p>
      So far we&#39;ve found a model that describes how scalar properties of a fluid evolve over time, assuming the flow is fixed. What about the fluid flow itself -
      how does the velocity field \( \mathbf{u} \) affect itself over time?
    </p>
    <p>
      The <b>Navier-Stokes equations</b>
      <dt-fn>For a detailed derivation, see Chapter 1.3 of Chorin and Marsden (1993).</dt-fn>
      <dt-fn>
        Famous for the <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_existence_and_smoothness">Navier-Stokes existence
        and smoothness</a> problem, one of the Clay Institute&#39;s seven Millenium Prize problems in math.
      </dt-fn>
      for incompressible flow define how the velocity at any point in a fluid evolves over time:

      $$
      \frac{\partial \mathbf{u}}{\partial t} =
      {\underbrace{ - \mathbf{u} \cdot \nabla \mathbf{u} }_\text{self-advection}} +
      {\underbrace{ \mu^2 \nabla \mathbf{u} }_\text{diffusion}} -
      {\underbrace{ \nabla p }_\text{pressure}} +
      {\underbrace{ \textbf{F} }_\text{ext. forces}}
      $$
      $$
      \text{where~}\forall t{~,~} \nabla \cdot \mathbf{u} = 0
      $$

      Here, the constant \( \mu \) is the fluid&#39;s viscosity and \( \mathbf{F} \) are
      external forces. But we assumed earlier that our fluid was <a href="https://en.wikipedia.org/wiki/Inviscid_flow">inviscid</a>,
      so \( \mu = 0 \), and we can just ignore external forces for now. So we&#39;re left with two terms - self-advection and pressure.

      $$
      \frac{\partial \mathbf{u}}{\partial t} =
      {\underbrace{ - \mathbf{u} \cdot \nabla \mathbf{u} }_\text{self-advection}} -
      {\underbrace{ \nabla p }_\text{pressure}}
      \tag{3}
      $$
      $$
      \text{where~}\forall t{~,~} \nabla \cdot \mathbf{u} = 0
      $$

      If at every timestep we numerically compute these terms and add them, we can simulate our fluid! In pseudocode:

      <!-- <dt-code block language="javascript"> -->
        </p><pre>          <code>
          let u = createVectorGrid();
          let density = createScalarGrid();
          let p = createScalarGrid();

          while (true) {
            // Solve for the next velocity field.
            u = advect(u, u);

            p = computePressure(...);
            u = u - gradient(p);

            // Advect dye through the new velocity field.
            density = advect(u, density);
          }
          </code>
        </pre>
        <!-- </dt-code> -->
    
    <p>
      Let&#39;s take a closer look at each of these.
    </p>
    <p><b>Self-Advection</b></p>
    <p>
      From our incompressible advection equations, we can see that the self-advection term is the advection of the fluid&#39;s velocity
      field \( \mathbf{u} \) through itself:

      $$
      \text{advection} (\mathbf{u}, \mathbf{u}) = - \mathbf{u} \cdot \nabla \mathbf{u} \tag{4}
      $$
    </p>
    <p>
      Where do the other terms come from? Well, advecting \( \mathbf{u} \) through itself yields a new velocity field
      \( \mathbf{u}^\prime \) (computable via the Semi-Lagrangian backtracing algorithm from above):

      $$
      \mathbf{u}^\prime = \mathbf{u} - \mathbf{u} \cdot \nabla \mathbf{u}
      $$
    </p>
    <p><b>Pressure</b></p>
    <p>
      We don&#39;t know if this new velocity field follows the incompressibility constraint (e.g. has zero divergence).
      So the pressure term \( p \) needs to correct this somehow:

      $$
      \nabla \cdot (\mathbf{u}^\prime - \nabla p) = 0
      $$

      We rearrange this to get

      $$
      \nabla^2 p = \nabla \cdot \mathbf{u}^\prime \tag{5}
      $$

      which is a type of equation known as a <i>Poisson equation</i>, where the left-hand side is
      the <a href="https://en.wikipedia.org/wiki/Laplace_operator">Laplacian</a> of an unknown scalar field and the
      right-hand side is a known scalar. Solving this Poisson equation is really the slowest computational step
      in fluid simulation, for reasons we will see shortly.
    </p>
    <p><b>Solving for Pressure</b></p>
    <p>
      So how do we solve this particular PDE for \( p \)? Well, we know the value of our candidate velocity field \( \mathbf{u}^\prime \)
      at all of our grid points, so we can approximately compute the right-hand side of the Poisson equation by applying a discrete
      version <dt-fn>We are using a <a href="https://en.wikipedia.org/wiki/Finite_difference">finite difference</a> where the independent variable is the grid index.</dt-fn> of the divergence everywhere:

      $$
      \nabla \cdot \mathbf{u}^\prime \approx
      \frac{ u_{i+1, j} - u_{i-1, j} }{ 2 } +
      \frac{ v_{i, j+1} - v_{i, j-1} }{ 2 }
      $$

      where \( \mathbf{u}^\prime = (u, v) \) in 2 dimensions.
    </p>
    <p>
      Then we can use a discrete version of the Laplacian

      $$
      \nabla^2 p \approx
      p_{i+1, j} + p_{i-1, j} + p_{i, j+1} + p_{i, j-1} - 4p_{i, j}
      $$

      to transform the whole equation into a linear equation with five unknowns.
    </p>
    <p>
      But really, we are solving the Poisson equation (5) over all of space at once, so for an \( N \times N \) grid,
      we end up with a system of \( N^2 \) linear equations with exactly \( N^2 \) unknowns! So we end up with
      the familiar old equation

      $$
      \mathbf{Ax} = \mathbf{b}
      $$

      where \( \mathbf{A} \) is a matrix applying the Laplacian operator to the whole grid and \( \mathbf{b} \) is a vector containing
      the velocity field&#39;s divergence at all grid points.
    </p>
    <p>
      There are many off-the-shelf algorithms for solving linear systems exactly. Unfortunately for us, even the fastest algorithms
      scale superlinearly with our grid size.
    </p>
    <p><b>Solving for Pressure... Efficiently</b></p>
    <p>
      If we&#39;re going to make a real-time simulation, we need to go fast. Can we leverage the GPU?
    </p>
    <p>
      Well, it&#39;s not really possible to achieve an exact solution to the linear system efficiently, but we should
      note that the linear system is already an approximation to the Poisson equation. And it is possible to achieve
      arbitrarily accurate approximations with iterative methods - which begin with an estimate and improve solution
      accuracy every iteration - so we can just pick an iterative algorithm and run it
      until we have something that&#39;s &#34;good enough&#34;. One particularly simple and easy-to-implement iterative algorithm for solving
      linear equations is the <a href="https://en.wikipedia.org/wiki/Jacobi_method">Jacobi method</a>.
    </p>
    <p>
      We start with the very first equation in the system:
      $$
      A_{11}x_1 + A_{12}x_2 + ... + A_{1n}x_n = b_1
      $$
      At the \(k\)th iteration, given some guess \( \mathbf{x}^k \) for the solution \( \mathbf{x} \), we have some error.
      We can use this error to update our guess for \( x_1 \) as follows:
      $$
      x_1^{k+1} = \frac{ b_1 - A_{12}x_2^k - ... - A_{1n}x_n^k }{ A_{11} }
      $$
      In Jacobi, our guesses for all elements of \( \mathbf{x} \) are executed in parallel, giving a perfect
      match for implementation on the GPU. In pseudocode:
    </p>
    <!-- <dt-code block language="glsl"> -->
      <pre>        <code>
          global FloatField divergence;
          global FloatField pressure;
          global float texelSize;

          // Run for each point in our pressure grid that we want to update
          float iterateJacobi(vec2 x) {
            float div = getFloatAt(divergence, x);
            float L = getFloatAt(pressure, x + vec2(-texelSize, 0.));
            float R = getFloatAt(pressure, x + vec2(texelSize, 0.));
            float T = getFloatAt(pressure, x + vec2(0., texelSize));
            float B = getFloatAt(pressure, x + vec2(0., -texelSize));
            return (div - L - R - T - B) / -4.;
          }
        </code>
      </pre>
    <!-- </dt-code> -->
    <p>
      It&#39;s worth noting that other, faster-converging solvers can also be
      implemented on the GPU, like the Conjugate Gradient method and the Multigrid method. But depending on
      the fluid and application, pressure accuracy may not be as important as advection accuracy or ease of implementation.
      For smoke and fire, changes in fluid volume aren&#39;t as apparent as they are for fluids like water
      <dt-cite key="Crane07"></dt-cite>, and high-quality advection tends to matter more<dt-cite key="Green2014"></dt-cite>.
    </p>
    <p><b>Summary: Simulating Navier Stokes</b></p>
    <p>
      The math behind Navier-Stokes can be a little bit dense, but at a high-level, simulating a fluid by solving the equations
      comes down to a few key update procedures on a grid per timestep. For our dye problem, here&#39;s our simulation
      might look:

      <!-- <dt-code block language="javascript"> -->
      </p><pre>        <code>
        let u = createVectorGrid();
        let density = createScalarGrid();
        let div = createScalarGrid();
        let p = createScalarGrid();

        while (true) {
          // Solve for the next velocity field.
          u = advect(u, u);

          // Enforce incompressibility with pressure projection.
          div = divergence(u);
          for (let i = 0; i &lt; JACOBI_ITERATIONS; i++) {
            p = updatePressure(p, div);
          }
          u = u - gradient(p);

          // Advect dye through the new velocity field.
          density = advect(u, density);
        }
        </code>
      </pre>
      <!-- </dt-code> -->

    
    <dt-byline></dt-byline>
    <h3>1.3 Vorticity Confinement</h3>
    <p>
      Using a grid to store our velocity field is extremely convenient, but it results in unwanted
      numerical smoothing whenever we have to interpolate values between grid points.
      This combined with the relatively coarse approximation of a first-order Semi-Lagrangian advection
      scheme has the effect of dissipating out turbulent vortices in our flow. Physically, the velocity field
      loses energy, and the end result is generally overly smooth, &#34;boring&#34; fluid flow.
    </p>
    <p>
      One way to combat lost vorticity is to increase the resolution of our grid, but this isn&#39;t really feasible
      for real-time simulations that have limited computational resources. What we would ideally
      like to do is find all the small details that get smoothed over each step of the simulation, and <i>amplify</i>
      them. This process is called vorticity confinement - admittedly, it&#39;s not totally realistic, but succeeds in
      preserving small scale details in more or less physically correct locations <dt-cite key="fedkiw2001visual"></dt-cite>.
      Indeed, it was originally invented to resolve very complex flow fields in engineering simulations of helicopter blades,
      where it just wasn&#39;t possible to add the number of necessary grid points <dt-cite key="steinhoff1994modification"></dt-cite>.
    </p>
    <p>
      The smallest turbulent features we can find are the vortices centered at each grid point in our simulation.
      We can measure the intensity of these vortices (the <i>vorticity</i> of them) by taking the curl of \( \mathbf{u} \)
      at each point, and amplify them by essentially adding a circular flow scaled by vorticity about each point.
      Mathematically, the vorticity is defined by

      $$
      \bm{\omega} = \nabla \times \mathbf{u}
      $$

      For each grid point, we compute a normalized location vector that points to the highest nearby vorticity concentration:

      $$
      \mathbf{N} = \frac{ \nabla | \bm{\omega} | }{ | \nabla | \bm{\omega} | | }
      $$

      And finally, we compute the confined vorticity vector field and add it to our flow:

      $$
      \mathbf{f_{conf}} = \epsilon (\mathbf{N} \times \bm{\omega})
      $$
      $$
      \mathbf{u_{conf}} = \mathbf{u} + \mathbf{f_{conf}}
      $$

      Here, the confinement constant \( \epsilon &gt; 0 \) is a parameter controlling the amount of small scale detail added
      back to the flow. Even low confinement levels (around 0-15) can make a huge difference, especially for simulations
      using Semi-Lagrangian advection schemes, and higher confinement levels can create highly stylized, billowing flows.
    </p>
    <div>
      <div>
        <p>
          Click and hold
        </p>
      </div>
      <canvas id="vorticity-canvas"></canvas>
    </div>
    <p>
      <em>Click and drag to drop some dye in the turbulent simulation above</em>
    </p>
    <p>
      On the GPU, we can compute curl and confinement like so:
    </p>
    <!-- <dt-code block language="glsl"> -->
      <pre>        <code>
          global Vec2Field u;
          global float texelSize;

          // Run to get curl for each point in grid
          float computeCurl(vec2 x) {
            float L = getVec2At(u, x + vec2(-texelSize, 0.)).y;
            float R = getVec2At(u, x + vec2(texelSize, 0.)).y;
            float T = getVec2At(u, x + vec2(0., texelSize)).x;
            float B = getVec2At(u, x + vec2(0., -texelSize)).x;
            return (R - L) - (T - B);
          }

          global Vec2Field curl;
          global float confinement;

          // Run to get confinement force for each point in grid
          vec2 confinementForce(vec2 x) {
            float L = getFloatAt(curl, x + vec2(-texelSize, 0.));
            float R = getFloatAt(curl, x + vec2(texelSize, 0.));
            float T = getFloatAt(curl, x + vec2(0., texelSize));
            float B = getFloatAt(curl, x + vec2(0., -texelSize));
            float C = getFloatAt(curl, x);

            vec2 N = vec2(abs(T) - abs(B), abs(R) - abs(L));
            N = N / length(N);
            return confinement * C;
          }
        </code>
      </pre>
    <!-- </dt-code> -->
    <p>
      The full simulation with turbulence:
      <!-- <dt-code block language="javascript"> -->
        </p><pre>          <code>
          let u = createVectorGrid();
          let density = createScalarGrid();
          let div = createScalarGrid();
          let p = createScalarGrid();
          let curl = createVectorGrid();

          while (true) {
            // Solve for the next velocity field.
            u = advect(u, u);

            // Use vorticity confinement to amplify turbulence of velocity field.
            curl = computeCurl(u);
            u = u + confinementForce(curl, CONFINEMENT);

            // Enforce incompressibility with pressure projection.
            div = divergence(u);
            for (let i = 0; i &lt; JACOBI_ITERATIONS; i++) {
              p = updatePressure(p, div);
            }
            u = u - gradient(p);

            // Advect dye through the new velocity field.
            density = advect(u, density);
          }
          </code>
        </pre>
      <!-- </dt-code> -->
    
    <p><b>Curl-Noise Turbulence</b></p>
    <p>
      Curl noise is a method that essentially does the same thing as vorticity confinement, but instead of measuring
      and amplifying the vorticity of the velocity field, a scalar vorticity field is made from scratch using noise functions.
      Mathematically, we can combine vorticity confinement and curl-noise turbulence by  synthesizing a random
      vorticity field

      $$
      \bm{\phi} = \text{rand} * \mathbf{z}
      $$

      Then computing our final vorticity field by

      $$
      \bm{\omega}^* = \bm{\omega} + \bm{\phi}
      $$

      Fast-moving, highly-turbulent fluids like smoke and fire benefit the most from vorticity confinement and curl noise,
      and in practice the curl noise field \( \bm{\phi} \) both evolves with time and is also advected by the fluid flow.
    </p>
    <dt-byline></dt-byline>
    <h2>2. Fire Simulation</h2>
    <p>
      If you&#39;ve gotten this far, pat yourself on the back! The methods in the previous section let us efficiently
      and accurately simulate fluids with varying physical parameters (oil, water, honey)
      assuming the fluid domain is a fixed space. Those interested in handling varying domains (that is, fluids that occupy different regions
      within the grid, like a half-full cup of water that sloshes around) will want to explore accounting for different boundary conditions
      within the grid simulation <dt-fn>I suggest <b>Dynamic Obstacles</b> in
      <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch30.html">GPU Gems 3 Chapter 30.2</a>
      <dt-cite key="Crane07"></dt-cite> for details on adding this to our grid simulation.
      There are also non grid-based methods, but those are outside scope here. </dt-fn>.
    </p>
    <p>
      Simulating fire and smoke requires a couple additions. First, we&#39;ll need to add channels representing
      fuel and temperature to our simulation, and model the combustion of fuel to create heat. Next we&#39;ll address how hot pockets
      of our fluid rise with a thermal buoyancy model, and finally, we&#39;ll need to render our flames correctly, taking into account
      blackbody radiation of the flames, human perception of light, and fire movement.
    </p>
    <h3>2.1 A Basic Combustion Model</h3>
    <p>
      Chemically, fire is caused by the oxidation of a fuel material in a reaction that releases both heat and light.
      In our case, we can assume that any fuel in our system has already ignited and is actively adding heat; we won&#39;t worry
      about the problem of unignited fuel.
    </p>
    <p>
      To be more specific, let&#39;s define a scalar field \( \rho \) where \( 0 \leq \rho \leq 1 \) represents the density of fuel and
      another scalar field \( T &gt; 0 \) representing the temperature of the fluid everywhere. At every timestep, temperature is
      added to the system by the fuel, which burns at a given burn temperature:

      $$
      T^\prime = \text{max} ( T, \rho * T_{\text{burn}} )
      $$

      Of course, temperature isn&#39;t static - heat diffuses from hot to cold areas, and with fluids in particular, large-scale movements
      of molecules transport heat. The combination of these 2 processes defines <a href="https://en.wikipedia.org/wiki/Convection">heat convection</a>,
      and conveniently, we already have a mathematical model for how it works - advection! Simulation-wise, we advect our temperature
      field along our velocity field. Since any reacting molecules are also moved by the fluid, we should advect fuel as well.
      The heat itself also affects the movement of the fluid - we&#39;ll see how to handle this shortly.
    </p>
    <p>
      Furthermore, hot molecules radiate off temperature as light<dt-fn>This is called blackbody radiation, and we&#39;ll return
      to it when rendering the fire color. The soot particles present in most fire radiate like ideal blackbodies.</dt-fn> according to the
      <a href="https://en.wikipedia.org/wiki/Stefan%E2%80%93Boltzmann_law">Stefan-Boltzmann Law</a>,
      in a quintic equation <dt-cite key="nguyen2002physically"></dt-cite>:

      $$
      T^\prime = T - \sigma_{\text{cool}} ( \frac{T}{T_{\text{max}}} )^4 * \Delta t
      $$

      Here, \( \sigma_{\text{cool}} \) is the cooling rate parameter. For a physically correct simulation, we would set it to the Stefan-Boltzmann constant,
      but for a graphical simulation, it&#39;s nice for the artist to be able to control the rate of cooling.
    </p>
    <p>
      To complete our combustion model, note that our fuel is always burning (we can imagine it as the density of ionized gas particles
      that give off thermal energy and return to a lower energy state), so every timestep we dissipate it by some given burn
      rate \( \gamma_{fuel} \):
      $$
      \rho^\prime = \rho (1 - \gamma_{fuel})^{\Delta t}
      $$
    </p>
    <h3>2.2 Thermal Buoyancy</h3>
    <p>
      So far, our temperature field doesn&#39;t do anything to our fluid flow. But it should - hot pockets of air should expand and rise, and cooler pockets should fall.
      We can model this with a thermal buoyancy force. Since we&#39;re assuming incompressibility, we won&#39;t actually handle air expansion, but the fluid flow
      should experience an upward force depending on temperature:

      $$
      \mathbf{u}^\prime = \mathbf{u} + (\beta T \Delta t) \mathbf{j}
      $$

      Here, \( \beta \) is a given positive buoyancy constant, and \( \mathbf{j} \) is the upward unit vector.
    </p>
    <p>
      Adding a combustion model and thermal buoyancy force gives us a fantastic simulator for a decidedly &#34;fire-like&#34; fluid -
      with the right values of buoyancy and cooling, we can get bulky, billowing plumes of material.
      Not exactly flames, but very similar to smoke.
    </p>
    <p>
      Tap and drag in the simulation below to inject some combusting fuel.
      The displayed pixels represent density of smoke particles, which dissipate at a constant rate instead of being used
      up during combustion, but are still advected by the fluid simulation.
    </p>
    <div>
      <div>
        <p>
          Click and hold
        </p>
      </div>
      <canvas id="smoke-canvas"></canvas>
    </div>
    <p>
      <em>Click and drag to add smoke above</em>
    </p>
    <p>
      The simulation code builds off the basic fluid routines:
      <!-- <dt-code block language="javascript"> -->
        </p><pre>          <code>
          let u = createVectorGrid();
          let density = createScalarGrid();
          let div = createScalarGrid();
          let p = createScalarGrid();
          let curl = createVectorGrid();
          let fuel = createScalarGrid();
          let temp = createScalarGrid();

          while (true) {
            // Solve for the next velocity field.
            u = advect(u, u);

            // Combustion step.
            temp = combust(temp, fuel);

            // Use vorticity confinement to amplify turbulence of velocity field.
            curl = computeCurl(u);
            u = u + confineVorticity(curl, CONFINEMENT);

            // Add thermal buoyancy.
            u = u + buoyancy(temp);

            // Enforce incompressibility with pressure projection.
            div = divergence(u);
            for (let i = 0; i &lt; JACOBI_ITERATIONS; i++) {
              p = updatePressure(p, div);
            }
            u = u - gradient(p);

            // Advect dye through the new velocity field.
            density = advect(u, density);
          }
          </code>
        </pre>
      <!-- </dt-code> -->
    
    <h3>2.3 Fire Rendering</h3>
    <p>
      Fire is a <a href="http://old.cescg.org/CESCG-2000/SMaierhofer/node6.html">participating medium</a>,
      meaning it emits light through blackbody radiation<dt-fn>Besides emitting its own blackbody radiation, fire also scatters light that passes through it. For more, see
      5.1 in <a href="http://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf">Nguyen et al. 2002</a>
      <dt-cite key="nguyen2002physically"></dt-cite>.</dt-fn>. This is what gives fire its orange and red colors;
      rendering our combusting fuel simulation using the correct formula is then all we need to go from smoke to fire!
    </p>
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bd/Gluehfarben_no_language_horizontal.svg/2880px-Gluehfarben_no_language_horizontal.svg.png"/>
    <p>
      <em>The temperature-to-color spectrum as described by Planck&#39;s law</em>
    </p>
    <p>
      <a href="https://en.wikipedia.org/wiki/Planck%27s_law">Planck&#39;s Law</a> describes the spectral density of light radiated by
      a black body at a given temperature \( T \):

      $$
      M(\lambda, T) = \frac{ c_1 }{ \lambda^5 } \frac{ 1 }{ \exp{ \frac{c_2}{\lambda T} } - 1 }
      $$

      where
      $$
      c_1 = 2 \pi h c^2 \\
      c_2 = \frac{hc}{k}
      $$

      and \(h\), \(c\), and \(k\) are Planck&#39;s constant, the speed of light, and Boltzmann&#39;s constant, respectively.
    </p>
    <p>
      After implementing blackbody rendering using fragment shaders, we have a complete fire simulation!
    </p>
    <div>
      <div>
        <p>
          Click and hold
        </p>
      </div>
      <canvas id="fire-canvas"></canvas>
    </div>
    <p>
      <em>Click and drag to add fire above</em>
    </p>
    <p>
      That&#39;s it for these notes! There is of course much more to fluid and fire simulation not covered here, like
      different (e.g. non-grid-based) techniques for solving the same problem of simulation within a fixed volume,
      different problems to solve involving varying domains or dynamic obstacles, enhancements to rendering like
      more accurate blackbody radiation, light scattering, or post-processing effects. Helpful introductions
      to these topics can be found in references below.
    </p>
  </div></div>
  </body>
</html>
