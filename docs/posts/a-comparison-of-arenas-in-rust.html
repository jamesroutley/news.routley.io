<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://donsz.nl/blog/arenas/">Original</a>
    <h1>A Comparison of Arenas in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-4dqtj3le="">  <p>Sometimes you just really need an arena. Sometimes for performance reasons, other times for lifetime-related reasons.
In their most basic forms, they&#39;re just a vec with some extra guarantees. However, it&#39;s those extra guarantees that matter.
I&#39;ve found myself looking for the right kind of arena too many times, so here&#39;s an overview of literally everything there is.
I think, let me know if I forgot something.</p>
  <h2 id="whats-an-arena">What’s an arena?</h2>
<p>Very basically, an arena is a way to store your data somewhere without directly going through the system allocator.
If you have a lot of small objects which you don’t mind to deallocate <em>together</em> instead of individually,
this can be a lot faster.
You could use a <code>Vec</code> for this.
However, if you store data in a vec its address might change all the time.</p>
<p>When the vector grows, its contents move around memory.
That’s not actually as inefficient as you think, it happens less and less often as the vec grows.
The real problem with this moving around is that you can’t depend on the address of your elements staying the same.
It’s common that you want to hold on to those addresses in a datastructure while also adding new objects.</p>
<p>The simplest kind of arena is built to solve that exact problem, by allocating in large chunks,
and promising never to deallocate or move those.
To grow, such an arena would simply allocate a whole new chunk of memory.
However, there are so many more ways to do this which give you arenas with slightly different properties.</p>
<h2 id="properties-of-arenas">properties of arenas</h2>
<p>In the table below, I talk about various properties arena do and don’t have.
Sometimes, you might not need an arena at all.
Libraries such as <a href="https://crates.io/crates/elsa" data-astro-cid-qjizrjwy=""> <img alt="crates.io logo" src="https://crates.io/assets/cargo.png" data-astro-cid-qjizrjwy=""/> elsa </a>  or <a href="https://crates.io/crates/rpds" data-astro-cid-qjizrjwy=""> <img alt="crates.io logo" src="https://crates.io/assets/cargo.png" data-astro-cid-qjizrjwy=""/> rpds </a>  can help you write efficient datastructures,
that are immutable, or provide quick clones because they are mostly based on pointers internally.
That could be what you’re actually looking for.</p>
<p>In the table, I’ve abbreviated some things a little, so here is the full explanation:</p>
<p><strong>Type</strong></p>
<p>Some arena implementations only allow you to store a single datatype in them.
This can be good for performance, and might make it possible to iterate over the full list of allocations.
However, it can be a limitation too.
If the arena is supposed to work a little like an alternative to the built-in memory allocator,
then you might want to allocate arbitrary elements of mixed types.
This makes element iteration harder, since elements aren’t stored at well-known offsets in the arena.</p>
<p>Interestingly, <a href="https://crates.io/crates/bumpalo" data-astro-cid-qjizrjwy=""> <img alt="crates.io logo" src="https://crates.io/assets/cargo.png" data-astro-cid-qjizrjwy=""/> bumpalo </a>  supports both kinds.
By default, the arena is mixed-type, but you can allocate vectors of a single type in their arena.</p>
<p><strong>Requires</strong></p>
<p>This indicates what kind of reference <em>to the arena</em> you need to allocate something in it.</p>
<p><strong>Gives Out, and Deref Key</strong></p>
<p>Some arenas directly give you references,
but some are based on indices,
and you might even need to have access to the arena to use these indices.
“Gives Out” documents what kind of type you get to refer to an allocation.
Sometimes it has a <code>&#39;a</code> lifetime, refering to the fact that it is bound to the lifetime of the arena.
“Deref Key” documents whether you need access to the arena to use the key,
or whether the key directly gives access to the element.</p>
<p><strong>Reuse Memory</strong></p>
<p>Some arena allocators assume you only allocate, never free.
That might be what you want, but sometimes it might not be.
Most freeing arenas use a linked list of free spots, a freelist,
though there are other options like garbage collection (GC),
and I found one library that can actually compact itself and shrink.</p>
<p>Note, that for performance reasons, shrinking usually isn’t often a very good idea.</p>
<p><strong>Runs Drop</strong></p>
<p>Especially the mixed-type arenas sometimes don’t run <code>Drop</code> of stored elements.
It’s hard to call <code>Drop</code> if you don’t know where in the arena elements are stored.
This is a problem if you, for example, want to store an <code>Rc</code> in an arena,
though there are many more types for which this is a problem.</p>
<p><strong>Iteration</strong></p>
<p>Although an arena isn’t a vec, the items are often stored prety much in-order.
So this column is about whether the arena supports this.
The type behind it indicates whether to iterate you need a reference or mutable reference to the arena.</p>
<p><strong>Collections</strong></p>
<p>A few arena libraries also provide an alternative set of collections like <code>Vec</code>, <code>String</code>, and pointers like <code>Box</code> and <code>Rc</code>.</p>
<p><strong><code>no_std</code> and no <code>unsafe</code></strong></p>
<p>These should be pretty obvious.</p>
<p><strong>ABA mitigation</strong></p>
<p>If your arena supports deletions,
the arena must be careful that on re-allocation it doesn’t accidentally reuse an ID it previously gave to you.
If you had still stored that old ID, you could now use it to access a new allocation.
Or not, some arenas don’t care and let you deal with this.</p>
<p><strong>Concurrent</strong></p>
<p>This documents whether the arena can be used concurrently.
For some, I documented whether they require locking.</p>
<p><strong>Dedup</strong></p>
<p>Interners often deduplicate keys, to gain pointer equality.
So far I only investigated one library doing this.</p>
<p><strong>Approach</strong></p>
<p>This roughly documentes how the library works.</p>
<ul>
<li>Linked Arena Chunks means that at a basic level,
big chunks of contiguous memory are allocated,
slowly filled, and linked together to form one big arena built up from smaller chunks.</li>
<li><code>Vec</code> (with freelist) refers to the backing storage.
An Arena is a <code>Vec</code>, and you get indices to later index the <code>Vec</code> to get the element you stored.</li>
<li>Linked List means every element in the arena gets its own link in a linked list.</li>
</ul>
<p>The others I think mostly make sense.</p>
<h2 id="overview">Overview</h2>
<p>Ordered by number of downloads, not by what you should use!! That only depends on your situation.</p>
 <template id="filter-icon"><i><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="filter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M3.9 54.9C10.5 40.9 24.5 32 40 32H472c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9V448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6V320.9L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"></path></svg></i></template> 
  </div></div>
  </body>
</html>
