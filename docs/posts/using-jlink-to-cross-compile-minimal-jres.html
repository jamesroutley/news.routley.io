<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakewharton.com/using-jlink-to-cross-compile-minimal-jres/">Original</a>
    <h1>Using jlink to cross-compile minimal JREs</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      <p>16 January 2023</p>

      <p><code>jlink</code> is a JDK tool to create bespoke, minimal JREs for your applications.
Let’s try it with a “Hello, world!” program:</p>
<div><div><pre><code><span>class</span> <span>Main</span> <span>{</span>
  <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>...</span> <span>args</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>My laptop is an M1 Mac and I have downloaded the Azul Zulu JDK 19 build for it.
With the JDK I can both compile Java and then run the resulting program.</p>
<div><div><pre><code>$ mkdir out
$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/javac -d out in/Main.java
$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/java -cp out Main
Hello, world!
</code></pre></div></div>

<p>Azul Zulu also provides a JRE that I can use to run compiled programs.</p>
<div><div><pre><code>$ zulu19.30.11-ca-jre19.0.1-macosx_aarch64/bin/java -cp out Main
Hello, world!
</code></pre></div></div>
<p>Note the slight change in folder name (“jdk” → “jre”).</p>

<p>If we were shipping this to end-users it would be an easy win for binary size.</p>
<div><div><pre><code>$ du -hs zulu*
329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64
136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64
</code></pre></div></div>
<p>But 136MiB just for “Hello, world”? Don’t tell Reddit or Hacker News!</p>

<p>Thankfully, <code>jlink</code> is here to help us build a minimal JRE with only what we need.
Given our program, a sibling tool, <code>jdeps</code>, lists the Java modules which are required.</p>
<div><div><pre><code>$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jdeps \
      --print-module-deps \
      out/Main.class
java.base
</code></pre></div></div>

<p>Our program is so simple that it only needs the “base” module.
Now with <code>jlink</code> we can produce a minimal JRE.</p>
<div><div><pre><code>$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \
      --compress 2 \
      --strip-debug \
      --no-header-files \
      --no-man-pages \
      --output zulu-hello-jre \
      --add-modules java.base

$ du -hs zulu*
 28M    zulu-hello-jre
329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64
136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64
</code></pre></div></div>

<p>28MiB won’t win any language wars, but it’s a massive 80% savings over the full JRE.</p>

<div><div><pre><code>$ zulu-hello-jre/bin/java -cp out Main
Hello, world!
</code></pre></div></div>

<p>We can ship it to our client and call it a day, right?</p>
<div><div><pre><code>$ tar -czf hello.tgz zulu-hello-jre out

$ scp hello.tgz jw@server:
hello.tgz            100%   14MB   2.0MB/s   00:07

$ ssh jw@server &#34;tar xzf hello.tgz &amp;&amp; zulu-hello-jre/bin/java -cp out Main&#34;
bash: zulu-hello-jre/bin/java: cannot execute binary file: Exec format error
</code></pre></div></div>

<p>Nope!
While the Java bytecode we compiled is platform independent, the JRE is specific to each platform and my server runs Linux x64.</p>

<p>Thankfully, <code>jlink</code> can operate on JDKs for different platforms.
Let’s download the Linux x64 JDK and point <code>jlink</code> at its Java modules using <code>--module-path</code>.</p>

<div><div><pre><code>$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \
      --compress 2 \
      --strip-debug \
      --no-header-files \
      --no-man-pages \
      --output zulu-hello-jre-linux-x64 \
      --module-path zulu19.30.11-ca-jdk19.0.1-linux_x64/jmods
      --add-modules java.base

$ du -hs zulu*
 28M    zulu-hello-jre
 36M    zulu-hello-jre-linux-x64
338M    zulu19.30.11-ca-jdk19.0.1-linux_x64
329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64
136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64
</code></pre></div></div>

<p>The Linux x64 JRE is a little larger than the one for my ARM Mac, but it’s still small compared to the full-size JRE.
Does it work on the client?</p>

<div><div><pre><code>$ tar -czf hello-linux.tgz zulu-hello-jre-linux-x64 out

$ scp hello-linux.tgz jw@server:
hello.tgz            100%   16MB   2.1MB/s   00:08

$ ssh jw@server &#34;tar xzf hello-linux.tgz &amp;&amp; zulu-hello-jre-linux-x64/bin/java -cp out Main&#34;
Hello, world!
</code></pre></div></div>

<p>It works! Now we can grab JDKs for any architecture for any platform and use our host <code>jlink</code> to effectively cross-compile minimal JREs for each target.</p>

<p>This is a great solution for multi-architecture Docker containers, desktop clients like JetBrains Compose UI, shipping to devices where you can’t fit a full JDK, and more.
Be sure to explore all the options on <code>jdeps</code> and <code>jlink</code> for ways to keep your runtimes small.</p>


      <p>— Jake Wharton</p>
    </div></div>
  </body>
</html>
