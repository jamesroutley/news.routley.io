<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/33%29-KV-Store-Mock-Interview-with-Div">Original</a>
    <h1>33) KV Store Mock Interview with Div</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>Divya offered to conduct a mock interview with me. She asked me to create a MemTable, which is apparently a type of KV store in which, at some interval or after some threshhold of KVs, KV store is “flushed” and saved to the disk to preserve memory.</p>
<p>I was able to implement it in about 30 minutes and I think it went really well! Here was the finished result, and the feedback she gave me at the end.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// interface Entry {</span></span>
<span data-line=""><span>//   val: number,</span></span>
<span data-line=""><span>//   count: number</span></span>
<span data-line=""><span>// }</span></span>
<span data-line=""> </span>
<span data-line=""><span>class</span><span> MemTable</span><span> {</span></span>
<span data-line=""><span>	// size: number</span></span>
<span data-line=""><span>  thresh</span><span>:</span><span> number</span></span>
<span data-line=""><span>  table</span><span>:</span><span> Map</span><span>&lt;</span><span>number</span><span>, </span><span>number</span><span>&gt;</span></span>
<span data-line=""><span>  stack</span><span>:</span><span> number</span><span>[]</span></span>
<span data-line=""><span>  </span></span>
<span data-line=""><span>  // Order</span></span>
<span data-line=""><span>  // timestamps</span></span>
<span data-line=""><span>  // don&#39;t take a note of timestamps, necessary,</span></span>
<span data-line=""><span>  // but take note of order or insertion</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // qs</span></span>
<span data-line=""><span>  // should updates change the order of insertion</span></span>
<span data-line=""><span>  // </span></span>
<span data-line=""> </span>
<span data-line=""><span>  // impl startegy</span></span>
<span data-line=""><span>  // for every instertion, if an update, delete and recreate in map to get the entry to the end</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // flishing will look at the order to make sure that the operations happen in a certain </span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>  // first in last out print of operations</span></span>
<span data-line=""><span>  // updates pop order of operations to the end</span></span>
<span data-line=""><span>  // assume that maps DON&#39;T maintain order</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // I could change the structure of the value to have a property that corresponded to a count</span></span>
<span data-line=""> </span>
<span data-line=""><span>  // stack [key=1, key=2, key=3]</span></span>
<span data-line=""><span>  // insert UPDATE -&gt; filter out the key of an element that was updated, and then add the key back to the end of the stack</span></span>
<span data-line=""> </span>
<span data-line=""><span>	constructor</span><span>(){</span></span>
<span data-line=""><span>    this</span><span>.table </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    this</span><span>.thresh </span><span>=</span><span> 5</span></span>
<span data-line=""><span>    this</span><span>.stack </span><span>=</span><span> []</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""> </span>
<span data-line=""><span>	insert</span><span>(</span><span>key</span><span>:</span><span> number</span><span>, </span><span>val</span><span>:</span><span> number</span><span>)</span><span>:</span><span> void</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>this</span><span>.table.</span><span>has</span><span>(key) </span><span>&amp;&amp;</span><span> this</span><span>.table.size </span><span>&gt;=</span><span> this</span><span>.thresh){</span></span>
<span data-line=""><span>      this</span><span>.</span><span>flush</span><span>()</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (</span><span>this</span><span>.table.</span><span>has</span><span>(key)){</span></span>
<span data-line=""><span>      this</span><span>.stack </span><span>=</span><span> this</span><span>.stack.</span><span>filter</span><span>(</span><span>e</span><span>=&gt;</span><span>e</span><span>!==</span><span>key)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    this</span><span>.stack.</span><span>push</span><span>(key)</span></span>
<span data-line=""><span>    this</span><span>.table.</span><span>set</span><span>(key, val)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>	get</span><span>(</span><span>key</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>this</span><span>.table.</span><span>has</span><span>(key)) </span><span>return</span><span> -</span><span>1</span></span>
<span data-line=""><span>    return</span><span> this</span><span>.table.</span><span>get</span><span>(key)</span><span>!</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>	flush</span><span>()</span><span>:</span><span> void</span><span> {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    this</span><span>.stack.</span><span>forEach</span><span>((</span><span>key</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>      const</span><span> val</span><span> =</span><span> this</span><span>.</span><span>get</span><span>(key)</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`key: ${</span><span>key</span><span>},value:${</span><span>val</span><span>}`</span><span>)</span></span>
<span data-line=""><span>    })</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // empty stuff</span></span>
<span data-line=""><span>    this</span><span>.table </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    this</span><span>.stack </span><span>=</span><span> []</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> memTable</span><span> =</span><span> new</span><span> MemTable</span><span>()</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>1</span><span>, </span><span>10</span><span>)</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>2</span><span>, </span><span>20</span><span>)</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>3</span><span>, </span><span>30</span><span>)</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>4</span><span>, </span><span>40</span><span>)</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>5</span><span>, </span><span>50</span><span>)</span></span>
<span data-line=""><span>memTable.</span><span>insert</span><span>(</span><span>6</span><span>, </span><span>60</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// feedback</span></span>
<span data-line=""> </span>
<span data-line=""><span>// pos</span></span>
<span data-line=""><span>// read error messages which was good</span></span>
<span data-line=""><span>// understand quirks of lang</span></span>
<span data-line=""><span>// mentioning time complexity is good</span></span>
<span data-line=""><span>// talked through implementation methodically</span></span>
<span data-line=""> </span>
<span data-line=""><span>// neg</span></span>
<span data-line=""><span>// made comments about how something was unexpected</span></span>
<span data-line=""><span>// Be careful of &#34;I don&#39;t know&#34; or &#34;I always forget...&#34;</span></span>
<span data-line=""><span>// ^ normal conversationally</span></span>
<span data-line=""><span>// I CAN go back to something and say that I DO know something</span></span>
<span data-line=""><span>// Build / run tests earlier</span></span>
<span data-line=""><span>// If you write a lot of code that doesn&#39;t work, that&#39;s bad</span></span>
<span data-line=""><span>// Test AS EARLY AS POSSIBLE</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Instead of overwriting my tests, re-use them</span></span>
<span data-line=""><span>// Continuity will save time, AND help me catch edge cases more reliably</span></span>
<span data-line=""><span>// Order of operations when i write stuff - taking on more challenging things before easier things</span></span>
<span data-line=""><span>// Consider doing order of DIFFICULTY vs order of operations</span></span>
<span data-line=""><span>  // The reason for this is that if you get stuck, you may forget the easy thing</span></span>
<span data-line=""><span>  // There is also a case for wishful programming here</span></span>
<span data-line=""><span>  // psuedocde placeholders and head quickly to the easy stuff</span></span>
<span data-line=""><span>  // return to placeholders</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>// hw</span></span>
<span data-line=""><span>// Why do I need to do bang operator in the .get method?</span></span></code></pre></figure>
<p>One of the bits of critical feedback was that I didn’t know why typescript throws a type error in this function:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>get</span><span>(key: number): number {</span></span>
<span data-line=""><span>    // if (!this.table.has(key)) return -1</span></span>
<span data-line=""><span>    return</span><span> this</span><span>.table.</span><span>get</span><span>(key) </span><span>??</span><span> -</span><span>1</span></span>
<span data-line=""><span>  }</span></span></code></pre></figure>
<p>I used the <code>!</code> non-null assertion operator to ignore the warning, but didn’t have an especially deep understanding of this pattern, or perhaps anti-pattern</p>
<p>Looking further into it, it looks like the warning exists because the <code>get</code> method of a <code>Map</code> in TypeScript returns <code>T | undefined</code>, where <code>T</code> is the type of the values stored in the map. In this case, it’s <code>number | undefined</code>.</p>
<p>This is the intellisense message I get in VScode:</p>
<pre><code>Type &#39;number | undefined&#39; is not assignable to type &#39;number&#39;.
  Type &#39;undefined&#39; is not assignable to type &#39;number&#39;.ts
</code></pre>
<p>Apparently Typescript doesn’t really have a way to see that the above line <em>ensures</em> that the function won’t return undefined.</p>
<p>My use of the non-null assertion operator is one way to get around this.</p>
<p>However, there are other ways that might be better.</p>
<ol>
<li>
<p>I can use a type assertion:
<code>return this.table.get(key) as number</code>
This essentially does the same thing as a non-null assertion operator, as far as I can tell, as it’s overriding Typescript’s type system and saying ‘trust me, this is a number.’</p>
</li>
<li>
<p>I can use the nullish coalescence operator:</p>
</li>
</ol>
<pre><code>return this.table.get(key) ?? -1
</code></pre>
<p>I like this option the best. It allows me to handle both lines with just one line, and take advantage the the way <code>map.get</code> can return undefined in the way I think it was intended to be used. It’s completely typesafe, which is dope.</p>
<p>It’s important to be able to tell the nullish coalescence operator (<code>??</code>) from the logical OR operator (<code>||</code>).</p>
<ul>
<li><code>x ?? y</code> returns <code>y</code> only if <code>x</code> is <code>null</code> or <code>undefined</code>.</li>
<li><code>x || y</code> would return <code>y</code> for any falsy value of <code>x</code>, including 0 and ”</li>
</ul>
<p>They can both be useful, but could cause serious bugs if one is substituted for another.</p></article><hr/></div></div></div>
  </body>
</html>
