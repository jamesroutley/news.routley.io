<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.karl.berlin/static-site.html">Original</a>
    <h1>“Make” as a static site generator (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>Static site generators are in fashion for good reasons. The resulting pages are easy to host, fast and extremely low on maintenance while being sufficient for many use cases.
As I learned when <a href="https://www.karl.berlin/blog.html">setting up my blog</a>, writing a simple script myself is faster and more satisfying than learning one of the other site builders and customizing it to my needs.
This time, I only need a plain site without automatically updated timestamps or an RSS-feed, so I can go even simpler than by blog script.</p>
<h2>Basic setup</h2>
<p>To get the site into a working state, I require the following functionality:</p>

<ul>
<li>All input files reside in the <code>source</code> directory, in the same layout as I want them in the output.</li>
<li>During processing, add a header to all HTML files.</li>
<li>Copy all other files to the <code>build</code> directory as they are.</li>
</ul>
<p>Each of these points results in one rule in the Makefile:</p>
<pre><code># The `build` target depends on all output files in the `build` directory. It
# does not do anything by itself, but causes one of the following rules to be
# applied for each file.
build: $(patsubst source/%,build/%,$(shell find source -type f))

# For each .html file do `cat header.html $input &gt; $output`.
build/%.html: source/%.html header.html Makefile
	@mkdir -p $(dir $@)
	cat header.html $&lt; &gt; $@

# Copy all other files without changes.
build/%: source/%
	cp $&lt; $@
</code></pre>
<p>With a corresponding <code>header.html</code> and these rules in place, calling <code>make build</code> will create a <code>build</code> directory that can be browsed locally or uploaded to any web server.</p>
<h2>Variations</h2>
<p>This is really all you need, but the real strength of this approach is that it is so simple, that you can trivially extend it to fit different needs. Let me show you a few examples!</p>
<h3>Mark Current Page</h3>
<p>It is helpful to highlight the current page in the navigation so that the visitor sees where he is within the site at a glance. To do this, we search for the link within the navigation and replace the link with a highlighted version. The specifics vary depending on your markup. I&#39;m using the following code to add the <code>current</code> class to the link tag:</p>
<pre><code>build/%.html: source/%.html header.html Makefile
	@mkdir -p $(dir $@)
	sed -E &#39;s|(href=&#34;$(subst source,,$&lt;))|class=&#34;current&#34; \1|&#39; header.html | cat - $&lt; &gt; $@
</code></pre>
<h3>Generate Page From Markdown</h3>
<p>If you dislike writing HTML or if you have existing content in markdown format, you can pipe your markdown content through a markdown-to-HTML converter of you choice (I like <a href="https://github.com/karlb/smu">smu</a>).</p>
<pre><code>build/%.html: source/%.html header.html Makefile
	@mkdir -p $(dir $@)
	smu $&lt; | cat header.html - &gt; $@
</code></pre>
<p>Since we still assume that <code>build/foo.html</code> is built from <code>source/foo.html</code>, you should keep the <code>.html</code> suffix for the markdown files or modify the rules to look for <code>.md</code> files as input.</p>
<h2>Little Helpers</h2>
<p>You can not only modify the site generation itself. Convenience features can also be added as additional make targets.</p>
<h3>Serve Site Locally</h3>
<p>Not all sites can be accurately previewed by opening the local files in your browser.
The most common reason for this is using absolute links instead of relative ones.
In those cases, you will want to run a small test web server locally to preview your site.
Python is already installed on many systems and comes with a web server this is suitable for the task.</p>
<pre><code>serve:
	python -m http.server -d build
</code></pre>
<h3>Rebuild on Change</h3>
<p>If you work a lot on your site, manually rebuilding after each change is a hassle.
Just use <a href="https://eradman.com/entrproject/"><code>entr</code></a> (or <a href="https://linux.die.net/man/1/inotifywait"><code>inotifywait</code></a> if you want to avoid the dependency) to rebuild automatically when a file in the source directory changes.</p>
<pre><code>watch:
	find source header.html Makefile | entr make build
</code></pre>
<h3>Upload to GitHub Pages</h3>
<p>I store my repositories on GitHub, so using GitHub Pages to host the resulting HTML is a natural choice.
Getting the commands just right so that you don&#39;t have to care about git details when publishing is a bit tricky, but easy enough in the end.
The approach is based on <a href="https://sangsoonam.github.io/2019/02/08/using-git-worktree-to-deploy-github-pages.html">Sangsoo Nam&#39;s post</a>.</p>
<pre><code>deploy:
	git worktree add public_html gh-pages
	cp -rf build/* public_html
	cd public_html &amp;&amp; \
	  git add --all &amp;&amp; \
	  git commit -m &#34;Deploy to github pages&#34; &amp;&amp; \
	  git push origin gh-pages
	git worktree remove public_html
</code></pre>
<h2>Summary</h2>
<p>Having your own static site generator in only six simple lines in a Makefile is great!
There are no exotic dependencies, nothing to maintain and you can quickly adapt it to your needs.
A page I built using this approach is available at <a href="https://github.com/karlb/astridbartel.de">https://github.com/karlb/astridbartel.de</a> and can serve as a real world example.</p>
<small>Written on 2022-06-14.</small>
</div></div>
  </body>
</html>
