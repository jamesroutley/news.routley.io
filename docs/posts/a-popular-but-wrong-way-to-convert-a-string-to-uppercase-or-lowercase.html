<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20241007-00/?p=110345">Original</a>
    <h1>A popular but wrong way to convert a string to uppercase or lowercase</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-110345">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>It seems that a popular way of converting a string to uppercase or lowercase is to do it letter by letter.</p>
<pre>std::wstring name;

std::transform(name.begin(), name.end(), name.begin(),
    std::tolower);
</pre>
<p>This is wrong for many reasons.</p>
<p>First of all, <code>std::<wbr/>tolower</code> is not an <i>addressible function</i>. This means, among other things, that you are not allowed to take the function’s address,¹ like we’re doing here when we pass a pointer to the function to <code>std::<wbr/>transform</code>. So we’ll have to use a lambda.</p>
<pre>std::wstring name;

std::transform(name.begin(), name.end(), name.begin(),
    [](auto c) { return std::tolower(c); });
</pre>
<p>The next mistake is a copy-pasta: The code is using <code>std::<wbr/>tolower</code> to convert wide characters (<code>wchar_t</code>) even though <code>std::<wbr/>tolower</code> works only for narrow characters (even more restrictive than that: it works only for <i>unsigned</i> narrow characters <code>unsigned char</code>). There is no compile-time error because <code>std::<wbr/>tolower</code> accepts an <code>int</code>, and on most systems, <code>wchar_t</code> is implicitly promotable to <code>int</code>, so the compiler accepts the value without complaint even though over 99% of the potential values are out of range.</p>
<p>Even if we fix the code to use <code>std::<wbr/>towlower</code>:</p>
<pre>std::wstring name;

std::transform(name.begin(), name.end(), name.begin(),
    [](auto c) { return std::towlower(c); });
</pre>
<p>it’s still wrong because it assumes that case mapping can be performed <code>char</code>-by-<code>char</code> or <code>wchar_t</code>-by-<code>wchar_t</code> in a context-free manner.</p>
<p>If the <code>wchar_t</code> encoding is UTF-16, then characters outside the basic multilingual plane (BMP) are represented by pairs of <code>wchar_t</code> values. For example, the Unicode character OLD HUNGARIAN CAPITAL LETTER A² (U+10C80) is represented by two UTF-16 code units: <kbd>D803</kbd> followed by <kbd>DC80</kbd>.</p>
<p>Passing these two code units to <code>towlower</code> one at a time prevents <code>towlower</code> from understanding how they interact with each other. If you call <code>towlower</code> with <kbd>DC80</kbd>, it recognizes that you passed only half of a character, but it doesn’t know what the other half is, so it has to just shrug its shoulders and say, “Um, <kbd>DC80</kbd>?” Too bad, because the lowercase version of OLD HUNGARIAN CAPITAL LETTER A (U+10C80) is OLD HUNGARIAN SMALL LETTER A (U+10CC0), so it should have returned <kbd>DCC0</kbd>. Of course <code>towlower</code> doesn’t have psychic powers, so you can’t really expect it to have known that the <kbd>DC80</kbd> was the partner of an unseen <kbd>D803</kbd>.</p>
<p>Another problem (which applies even if <code>wchar_t</code> is UTF-32) is that the uppercase and lowercase versions of a character might have different lengths. For example, LATIN SMALL LETTER SHARP S (“ß” U+00DF) uppercases to the two-character sequence “SS”:³ Straße ⇒ STRASSE, and LATIN SMALL LIGATURE FL (“ﬂ” U+FB02) uppercases to the two-character sequence “FL”. In both examples, converting the string to uppercase causes the string to get longer. And in certain forms of the French language, capitalizing an accented character causes the accent to be dropped: à Paris ⇒ A PARIS. If the accented character à were encoded as LATIN SMALL LETTER A (U+0061) followed by COMBINING GRAVE ACCENT (U+0300), then converting to uppercase causes the string to get shorter.</p>
<p>Similar issues apply to the <code>std::string</code> version:</p>
<pre>std::string name;

std::transform(name.begin(), name.end(), name.begin(),
    [](auto c) { return std::tolower(c); });
</pre>
<p>If the string potentially contains characters outside the 7-bit ASCII range, then this triggers undefined behavior when those characters are encountered. And for UTF-8 data, you have the same issues discussed before: Multibyte characters will not be converted properly, and it breaks for case mappings that alter string lengths.</p>
<p>Okay, so those are the problems. What’s the solution?</p>
<p>If you need to perform a case mapping on a string, you can use <code>LCMap­String­Ex</code> with <code>LCMAP_<wbr/>LOWERCASE</code> or <code>LCMAP_<wbr/>UPPERCASE</code>, possibly with other flags like <code>LCMAP_<wbr/>LINGUISTIC_<wbr/>CASING</code>. If you use the <a href="https://icu.unicode.org/"> International Components for Unicode (ICU)</a> library, you can use <code>u_strToUpper</code> and <code>u_strToLower</code>.</p>
<p>¹ The standard imposes this limitation because the implementation may need to add default function parameters, template default parameters, or overloads in order to accomplish the various requirements of the standard.</p>
<p>² I find it quaint that Unicode character names are ALL IN CAPITAL LETTERS, in case you need to put them in a Baudot telegram or something.</p>
<p>³ Under the pre-1996 rules, the ß can capitalize under certain conditions to “SZ”: Maßen ⇒ MASZEN. And in 2017, the Council for German Orthography (<i lang="de">Rat für deutsche Rechtschreibung</i>) permitted LATIN CAPITAL LETTER SHARP S (“ẞ” U+1E9E) to be used as a capital form of ß.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
