<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2021/12/reverse-engineering-tiny-1980s-chip.html">Original</a>
    <h1>Reverse-engineering a tiny 1980s chip that plays Christmas tunes</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-1388234716606366251" itemprop="description articleBody">


<p>For the holidays, I decapped a chip that plays three Christmas melodies.
The UM66T melody chip from the 1980s was designed for applications such as greeting cards and toys. 
It looks like a transistor, but when connected to a battery and speaker it plays music.
The die photo below shows the tiny silicon chip that I reverse engineer in this blog post.</p>
<p><a href="https://static.righto.com/images/um66t/die2.jpg"><img alt="The UM66T die under the microscope. Click this (or any other) image for a larger version." height="669" src="https://static.righto.com/images/um66t/die2-w700.jpg" title="The UM66T die under the microscope. Click this (or any other) image for a larger version." width="700"/></a></p><p>The UM66T die under the microscope. Click this (or any other) image for a larger version.</p>
<p>The video below shows the chip in action. Click to hear the chip play Jingle Bells, Santa Claus is Coming to Town, and We Wish You a Merry Christmas.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/FwSq1o1__Go" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>The chip is packaged in a 3-pin package that looks like a transistor (below).
I dissolved the epoxy package in boiling sulfuric acid to expose the silicon die inside.
This was my first acid decap and it turned out okay, although there are some scratches on the die.
The composite photo above shows the CMOS chip under the microscope.
The features are fairly large, even for the time; the metal traces are about 3.3µm wide and the silicon about 5.4µm.</p>
<p><a href="https://static.righto.com/images/um66t/package.jpg"><img alt="The chip is in a 3-pin TO-92 package, like a transistor." height="259" src="https://static.righto.com/images/um66t/package-w120.jpg" title="The chip is in a 3-pin TO-92 package, like a transistor." width="120"/></a></p><p>The chip is in a 3-pin TO-92 package, like a transistor.</p>
<p>The silicon die is very small, about 1.8mm×1.8mm. The photo below gives an idea of the scale.</p>
<p><a href="https://static.righto.com/images/um66t/penny.jpg"><img alt="The UM66T die on top of a penny." height="353" src="https://static.righto.com/images/um66t/penny-w400.jpg" title="The UM66T die on top of a penny." width="400"/></a></p><p>The UM66T die on top of a penny.</p>
<p>I&#39;ve labeled the die photo with the functional blocks.
The melody chip is an optimized, minimal design.
It is constructed from flip-flops and gates, not the microcontroller you might expect.</p>
<p><a href="https://static.righto.com/images/um66t/die-labeled.jpg"><img alt="Die photo of the UM66T with the main functional blocks labeled." height="670" src="https://static.righto.com/images/um66t/die-labeled-w700.jpg" title="Die photo of the UM66T with the main functional blocks labeled." width="700"/></a></p><p>Die photo of the UM66T with the main functional blocks labeled.</p>
<p>The chip has 3 pins, but there are 8 pads on the die. The other pins appear to be used for testing. By activating one of the pins, the chip can be put into a test mode.
The test mode runs through the songs at 512× speed so the chip can be tested quickly without waiting for the tunes to play.
The other test pins appear to expose other internal data for testing.</p>
<p>The block diagram below shows the structure of the chip. (Inconveniently, I didn&#39;t get this diagram until after I&#39;d reverse-engineered the circuitry.)
The basic idea is that the &#34;program counter&#34; steps through the 64 notes stored in the melody ROM.
Four bits form the note pitch index, while two bits select the note duration. The Scale ROM and tone generator are used to convert the pitch index into the desired output tone.
Meanwhile, the Rhythm ROM converts the 2-bit note duration into a 4-bit value indicating how long the note is.</p>
<p><a href="https://static.righto.com/images/um66t/block-diagram.jpg"><img alt="Block diagram of the UM66T. From Maplin Magazine, March 1988." height="397" src="https://static.righto.com/images/um66t/block-diagram-w500.jpg" title="Block diagram of the UM66T. From Maplin Magazine, March 1988." width="500"/></a></p><p>Block diagram of the UM66T. From Maplin Magazine, March 1988.</p>
<p>The chip is built from CMOS, like most modern ICs.
The photo below shows an inverter: a PMOS transistor on the left and an NMOS transistor on the right.
The PMOS one turns on with a 0 input, pulling the output high. The NMOS transistor turns on with a 1, pulling the output low.
Thus, the two transistors implement the desired inverter behavior.</p>
<p><a href="https://static.righto.com/images/um66t/inverter.png"><img alt="Structure of an inverter." height="170" src="https://static.righto.com/images/um66t/inverter-w250.png" title="Structure of an inverter." width="250"/></a></p><p>Structure of an inverter.</p>
<h2>The melody ROM</h2>
<p>The 64 notes are stored in a 64×6 ROM, shown below. Each note is 4 bits for the frequency and 2 bits for the duration of the note.
The ovals are the transistor gates; bits are stored in the wiring pattern of the transistors, either to the left or to the right.
The vertical column select lines from the top select one column in the ROM. The vertical lines from the bottom, however, inactivate the transistor.</p>
<p>Physically, the ROM stores four notes in each column, so it has 16 columns of 24 bits. 
At the top of the ROM is a binary decoder that energizes one of the 16 columns, based on the input value.
The transistors at the left of the ROM select one bit out of each four to produce the desired 6-bit word.
The 6 bits are latched. Then 4 bits are used to generate the desired note frequency, while two bits select the duration of the note (half note, quarter note, or eighth note).</p>
<p><a href="https://static.righto.com/images/um66t/melody-rom.jpg"><img alt="The melody ROM holds 64 notes." height="498" src="https://static.righto.com/images/um66t/melody-rom-w500.jpg" title="The melody ROM holds 64 notes." width="500"/></a></p><p>The melody ROM holds 64 notes.</p>
<p>In the diagram above, the numbers show the locations of the first four words.
The first word is 000100, a start code. The next two words are 011100; 0111 indicates the note E5 and 00 indicates a short duration.<span id="fnref:code"><a href="#fn:code">1</a></span>
The next word is by 011101, indicating a longer E5. Thus, the indicated words store the first three notes of &#34;Jingle Bells&#34;.</p>
<p>The metal layer of an IC can be changed relatively easily.
By changing the metal layer, different versions of the chip could be manufactured with different ROMS, producing different songs.
(The chip could also be manufactured with different note ranges, tempo, and beats, providing more flexibility.)
The table below shows the songs that were available.<span id="fnref:datasheet"><a href="#fn:datasheet">2</a></span></p>
<p><a href="https://static.righto.com/images/um66t/songs.jpg"><img alt="List of songs available in the UM66T chip line. From the datasheet." height="279" src="https://static.righto.com/images/um66t/songs-w600.jpg" title="List of songs available in the UM66T chip line. From the datasheet." width="600"/></a></p><p>List of songs available in the UM66T chip line. From the <a href="https://www.semiee.com/file/EOL/UMC-UM66T01S.pdf">datasheet</a>.</p>
<h2>Generating the note frequency</h2>
<p>The melody ROM doesn&#39;t specify the note&#39;s frequency directly, but instead has a value from 0 to 15.
A second ROM, the scale ROM, has the mapping to convert the note value into a frequency.
Specifically, the output frequency is 32768÷N, where N is the value in the scale ROM.
The frequency resolution from this isn&#39;t great, so some notes are noticeably out of tune, but it&#39;s good enough for this application.</p>
<p><a href="https://static.righto.com/images/um66t/freq-rom-labeled.jpg"><img alt="The note frequency ROM." height="351" src="https://static.righto.com/images/um66t/freq-rom-labeled-w600.jpg" title="The note frequency ROM." width="600"/></a></p><p>The note frequency ROM.</p>
<p>The image above shows the scale ROM, configured to produce the notes G<sub>4</sub> through C<sub>6</sub> in the key of C.
(Different versions of the chip can generate different notes by changing the scale ROM.)
As with the melody ROM, the binary values are generated by the wiring of the metal layer to the transistors.
For instance, the note B<sub>5</sub>  has the bits 0,1,0,0,1,0,1 (from bottom to top).
Below the ROM, the decoder activates one of the 16 column lines based on the 4-bit note value.
(Notice the binary pattern of transistors in the decoder: the top rows alternate, the next rows are every 2, then every 4 and every 8.</p>
<p>The chip uses an unusual technique to generate the output frequency. 
The standard way is to divide the clock frequency by the scale factor with a counter,
but instead the chip has an unusual approach to save a few transistors.
It uses a 7-bit <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">linear-feedback shift register</a>.
The construction of the linear-feedback shift register is that the input is the XOR of the last two bits. It will cycle pseudo-randomly
through all 127 values.<span id="fnref:lfsr"><a href="#fn:lfsr">4</a></span></p>
<p>The trick in the melody chip is to initialize the shift register with a particular value loaded from the ROM, and run through the sequence until the value 1000000 is reached.
By picking the right starting value, the desired number of counts will be obtained.
The diagram below illustrates the operation of the shift register with the B<sub>5</sub> input 0100101.
With this starting value, it takes 34 steps to reach the final value of binary 1000000.
Notice how the bits are shifted to the right each step, with a new bit inserted at the left.</p>
<pre>0 1 0 0 1 0 1
1 0 1 0 0 1 0
1 1 0 1 0 0 1
1 1 1 0 1 0 0
0 1 1 1 0 1 0
1 0 1 1 1 0 1
1 1 0 1 1 1 0
1 1 1 0 1 1 1
0 1 1 1 0 1 1
0 0 1 1 1 0 1
1 0 0 1 1 1 0
1 1 0 0 1 1 1
0 1 1 0 0 1 1
0 0 1 1 0 0 1
1 0 0 1 1 0 0
0 1 0 0 1 1 0
1 0 1 0 0 1 1
0 1 0 1 0 0 1
1 0 1 0 1 0 0
0 1 0 1 0 1 0
1 0 1 0 1 0 1
1 1 0 1 0 1 0
1 1 1 0 1 0 1
1 1 1 1 0 1 0
1 1 1 1 1 0 1
1 1 1 1 1 1 0
1 1 1 1 1 1 1
0 1 1 1 1 1 1
0 0 1 1 1 1 1
0 0 0 1 1 1 1
0 0 0 0 1 1 1
0 0 0 0 0 1 1
0 0 0 0 0 0 1
1 0 0 0 0 0 0
</pre>

<p>Since this takes 34 steps, the clock frequency is divided by 34 and the output frequency is 32768 ÷ 34 = 963 Hertz, close to the desired frequency of 997 Hertz.<span id="fnref:clock"><a href="#fn:clock">3</a></span>
Similarly, starting with 0000101 the oscillator will run for 50 counts, yielding a frequency of 498 Hertz, the frequency of the note B<sub>4</sub>.
For instance, starting with binary 0110100, the shift register will run for 34 steps (as shown below), producing a frequency of 32 kHz / 34 = 964 Hertz, approximately the frequency of
the note B<sub>5</sub> (997 Hertz).
G<sub>4</sub>, for example, starts with 1001010 and runs for 84 counts, yielding a frequency of 392 Hertz.
Thus, the ROM controls the frequency of the notes produced.
Note that the starting values are not obviously correlated with the frequency; they depend on the sequence generated by the linear feedback shift register.
(This sequence is called pseudo-random since it is deterministic but appears kind of random.)</p>
<p>Next, I&#39;ll discuss the implementation of the shift register.
The die photo below shows one stage of the shift register. It receives input from the stage below and passes its output to the stage above.
The stage is constructed from 26 transistors: 13 PMOS transistors on the left and 13 NMOS transistors on the right.
The transistors are oriented vertically along the pink regions of doped silicon. The transistor gates are where the metal lines widen.
Note that transistors in a column are connected by the silicon.</p>
<p><a href="https://static.righto.com/images/um66t/shift-register-stage.png"><img alt="Die photo showing one stage of the shift register." height="355" src="https://static.righto.com/images/um66t/shift-register-stage-w300.png" title="Die photo showing one stage of the shift register." width="300"/></a></p><p>Die photo showing one stage of the shift register.</p>
<p>The schematic below shows how the transistors are connected, corresponding to the die photo above.</p>
<p><a href="https://static.righto.com/images/um66t/shift-register-schematic.jpg"><img alt="Schematic of one stage of the shift register, corresponding to the die photo." height="458" src="https://static.righto.com/images/um66t/shift-register-schematic-w350.jpg" title="Schematic of one stage of the shift register, corresponding to the die photo." width="350"/></a></p><p>Schematic of one stage of the shift register, corresponding to the die photo.</p>
<p>At a slightly higher level, the circuit consists of inverters and multiplexers<span id="fnref:multiplexer"><a href="#fn:multiplexer">5</a></span> as shown below.
Each loop of two inverters holds a bit.
The first multiplexer selects the input: either a value from the ROM that is loaded into the shift register, or the value from the previous stage.
When the clock goes high, this value is loaded into the first inverter loop.
When the clock goes low, the value in the first inverter loop is transferred to the second inverter loop, and thus the output.
Thus, it takes one complete clock cycle (low then high) to shift a bit one stage in the shift register.</p>
<p><a href="https://static.righto.com/images/um66t/shift-register-schematic2.png"><img alt="Schematic of one stage of the shift register." height="128" src="https://static.righto.com/images/um66t/shift-register-schematic2-w450.png" title="Schematic of one stage of the shift register." width="450"/></a></p><p>Schematic of one stage of the shift register.</p>
<h2>The clock</h2>
<p>The chip runs on a 64-kilohertz clock.
This clock is generated from a simple resistor-capacitor-inverter oscillator inside the chip, avoiding the need for external components.
Because the capacitor takes some time to charge through the resistor, the oscillation speed is controlled.</p>
<p>The die photo below shows a closeup of the oscillator.
The white rectangle is the capacitor.  The green zig-zag is the resistor.
Note that the resistance can be adjusted by shorting out part of the resistor in the metal layer.
The white zig zags are the gates of the inverter transistors. These transistors are larger than the typical logic transistors.</p>
<p><a href="https://static.righto.com/images/um66t/clock.jpg"><img alt="Die photo showing the clock circuitry." height="254" src="https://static.righto.com/images/um66t/clock-w500.jpg" title="Die photo showing the clock circuitry." width="500"/></a></p><p>Die photo showing the clock circuitry.</p>
<p>The on-chip R-C oscillator is cheap but inaccurate, unlike a quartz crystal oscillator. If the voltage changes, the frequency changes.
In the video below, I lower and raise the voltage, and you can hear the effect on the tunes as the frequency changes.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/CTetkFz70OQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2>Timing</h2>
<p>The 64-kilohertz clock goes through a divider chain to divide the frequency by 512.
This divider is made of nine toggle flip-flops, each one dividing the frequency by 2.
These flip-flops are built from inverters and multiplexers similar to the shift register flip-flops, but wired to toggle.
This feeds the beat generator, which adjusts the timing for quarter notes, eighth notes, etc.
It uses a linear-feedback shift register, similar to the tone generator, but with four shift register stages.
The shift register is loaded with a value from the rhythm ROM that determines the length of the note.</p>
<p>The output from the beat generator goes to the tempo generator, which divides
its input by a preset amount (1 to 15) to generate a tempo between 128 and 1920 beats per minute.
The tempo generator is also a 4-bit linear feedback shift register.
The input to the shift register is hard wired to set the fixed tempo.
The photo below shows one stage, wired to 1. A small change to the metal layer would cause 0 to be connected instead of 1.</p>
<p><a href="https://static.righto.com/images/um66t/tempo-program.jpg"><img alt="The tempo is programmed by wiring shift register inputs to either 0 or 1." height="316" src="https://static.righto.com/images/um66t/tempo-program-w300.jpg" title="The tempo is programmed by wiring shift register inputs to either 0 or 1." width="300"/></a></p><p>The tempo is programmed by wiring shift register inputs to either 0 or 1.</p>
<p>The program counter counts through the 64 notes, providing the address to the melody ROM.
It is built from toggle flip-flops chained together to build a 6-bit counter.
The flip-flops have a reset line to initialize the counter to 0 at the start.
The chip has a few dozen logic gates to keep track of the current state, handle startup, test mode, and so forth.</p>
<h2>Conclusion</h2>
<p>This melody chip uses simple circuits to produce songs in a flexible way.
The chip integrates all the necessary circuitry including the R-C oscillator, so only a battery and a speaker were required.
Nowadays a microcontroller would be the easiest way to implement this.
This 1980s chip, however, uses small ROMS and simple counters to produce the tunes.
I&#39;ll end with a quote from <a href="https://twitter.com/johnsnolan/status/1472307118179033089">John Nolan</a>: &#34;Nothing says &#39;Christmas&#39; like decapitating a microchip that plays slightly off-key Christmas songs.&#34;</p>
<p>This article is the extension of my earlier <a href="https://twitter.com/kenshirriff/status/1472297415201869831">Twitter thread</a>, which had a bunch
of discussion on <a href="https://news.ycombinator.com/item?id=29612750">Hacker News</a>.
I announce my latest blog posts on Twitter, so follow me <a href="https://twitter.com/kenshirriff">@kenshirriff</a>. I also have an <a href="https://www.righto.com/feeds/posts/default">RSS feed</a>.
Thanks to <a href="https://twitter.com/mfraz74/status/1472331206046142464">Mark Fraser</a> for finding an article on the chip.<span id="fnref:maplin"><a href="#fn:maplin">6</a></span></p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
