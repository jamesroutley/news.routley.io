<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jason.today/falling-sand">Original</a>
    <h1>Making a falling sand simulator</h1>
    
    <div id="readability-page-1" class="page"><div>
  
  <p>
  Over the years there have been a number of projects focusing on building systems of particle materials that interact
  with one another. The first I saw was called &#34;Powder Game&#34;, which had all kinds of features and was written in Java.
  More recently there has been <a href="https://sandspiel.club/">Sandspiel</a> and an entire roguelike game (ignoring the
    <a href="https://web.archive.org/web/20220416113035/http://www.roguebasin.com/index.php?title=Berlin_Interpretation">Berlin Interpretation</a>
  for a moment) built on the idea that the entire environment is made of particle materials similar to falling sand games,
  called <a href="https://noitagame.com/">Noita</a> (which is pretty fantastic and you should give it a try!).
  </p>

  <p>A fun exercise is implementing one of these falling material particle systems.</p>

  <p>In this post, we&#39;ll just implement the most basic material, &#34;sand&#34;.</p>
  <p>This will be the final product for this post (drag around inside!): </p>
  
  <p>Let&#39;s get started!</p>

  <div>
    <h2>Drawing pixels to the screen</h2>
    <p>
      The idea behind this post is not to implement a falling sand simulation from scratch,
      though it might be an interesting endeavor in the future! For now, we&#39;ll be exploring
      the rules that each particle needs to follow.
    </p>
    <p>
      So first things first, we need a way to draw some pixels on the screen and keep track of their
      positions. Here we&#39;re using p5.js with a bit of abstraction to simplify things. If you want to
      implement this yourself, feel free to check the source code for all the details I&#39;m skipping over.
      I&#39;m hoping I gave enough here that you could pick up another engine and implement this without issue.
    </p>
    <p>We can build a Grid class to represent our pixels with the functions we need to interact with it.</p>
    <pre><code>class Grid {
  initialize(width, height) {
    this.width = width;
    this.height = height;
    this.grid = new Array(width * height).fill(0);
  }

  // Allow us to clear the canvas
  clear() {
    this.grid = new Array(this.width * this.height).fill(0);
  }

  // Allow us to set a specific particle
  set(x, y, color) {
    this.grid[y * this.width + x] = color;
  }

  // Allow us to swap two particles (or space)
  swap(a, b) {
    const temp = this.grid[a];
    this.grid[a] = this.grid[b];
    this.grid[b] = temp;
  }

  // Check if a particle exists in a space
  isEmpty(index) {
    return this.grid[index] === 0;
  }
}</code></pre>
    <p>
      Now we need a way to actually place particles on the screen. We&#39;ll assume there&#39;s a left-click
      method available, and use this to set that particle in our grid.</p>
    <pre><code>p.onLeftClick = (x, y) =&gt; {
  // Vary the color slightly for aesthetics
  let color = varyColor(p, SAND_COLOR);
  grid.set(x, y, color);
};</code></pre>

<p>
  We also added some variation to the color to make it feel a bit higher quality.
  All we&#39;re doing is adding some randomness to the saturation and lightness.
</p>
<pre><code>function varyColor(p, color) {
  let hue = p.floor(p.hue(color));
  let saturation = p.saturation(color) + p.floor(p.random(-20, 0));
  saturation = p.constrain(saturation, 0, 100);
  let lightness = p.lightness(color) + p.floor(p.random(-10, 10));
  lightness = p.constrain(lightness, 0, 100);
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}</code></pre>
    <p>
      And now we can just iterate through the grid and set the corresponding pixels each loop of our draw call.
    </p>
    <pre><code>// This happens every frame
this.grid.forEach((color, index) =&gt; {
  setPixel(p, index, color || background);
})</code></pre>
    <p>Nice, now we can click, drag, and draw some particles. It&#39;s not great, but it&#39;s something!</p>
    
    <p>Awesome! Let&#39;s add gravity.</p>

    <!-- Just Draw Pixels -->
    
  </div>
  <div>
    <h2>
      Adding gravity
    </h2>
    <p>
      Before we implement our first rule, it&#39;s worth stating explicitly that all rules will be applied once per frame.
      This gives all particles equal opportunity to fulfill their rule, before another particle gets to apply their rule
      a second time.
    </p>
    <p>
      Our first rule: <b>gravity</b>.
    </p>
    <p>
      The rule is as follows: if the space below a particle is empty, swap it with the empty space.
    </p>
    <pre><code>updatePixel(i) {
  const below = i + this.width;
  // If there are no pixels below, move it down.
  if (this.isEmpty(below)) {
    this.swap(i, below)
  }
}

update() {
  // Go through each pixel one by one and apply the rule
  for (let i = 0; i &lt; this.grid.length - this.width - 1; i++) {
    this.updatePixel(i);
  }
}</code></pre>
    <p>
      Try drawing a bit on the canvas!
    </p>
    
    <p>
      Hm... Something isn&#39;t working quite right! We don&#39;t actually see the particles falling!
      They just instantly appear.
    </p>
    <p>Let&#39;s take a crack at fixing that!</p>

    <!-- Add gravity -->
    
  </div>
  <div>
    <h2>Fixing gravity</h2>
    <p>
      What&#39;s going on here?
    </p>
    <p>
      Well, if we take another look at our update method and what one pixel is doing, we&#39;ll realize: we&#39;re starting
      from the first pixel, and if it can fall, it swaps with the pixel below it. That means, we&#39;ll actually see
      that pixel again later and apply its rule again! This means, in a single pass of the list of particles, a particle
      could get to the bottom of the screen!
    </p>
    <p>Fortunately, it&#39;s an easy fix - we just start from the end!</p>
    <pre><code>update() {
  // Draw from the end of the list to the beginning
  for (let i = this.grid.length - this.width - 1; i &gt; 0; i--) {
    this.updatePixel(i);
  }
}</code></pre>
    <p>Trying drawing again - you should see the particles falling now!</p>
    
    <p>Can we always iterate from back to front? (What if our particle was smoke?)</p>

    <p>
      Our sand doesn&#39;t really look like sand still - it&#39;s making little towers, which is neat, but not what we want.
    </p>
    <p>
      It&#39;s time for rule #2!
    </p>

    <!-- Add gravity -->
    
  </div>
  <div>
    <h2>Settling behavior</h2>
    <p>
      Consider the way sand behaves. It doesn&#39;t just fall straight down - it&#39;ll roll to the side and down if there&#39;s
      space to. We need to integrate this into our system.
    </p>
    <p>
      We need to check not only directly below, but below and to the left, and below and to the right.
    </p>
    <pre><code>updatePixel(i) {
  // Get the indices of the pixels directly below
  const below = i + this.width;
  const belowLeft = below - 1;
  const belowRight = below + 1;

  // If there are no pixels below, including diagonals, move it accordingly.
  if (this.isEmpty(below)) {
    this.swap(i, below);
  } else if (this.isEmpty(belowLeft)) {
    this.swap(i, belowLeft);
  } else if (this.isEmpty(belowRight)) {
    this.swap(i, belowRight);
  }
}</code></pre>
    <p>
      If we try drawing on the canvas, we can see that the sand properly settles now, instead of making little towers!
    </p>
    
    <p>
      How might this rule differ for some other materials - like water or smoke?
    </p>

    <!-- Add left/right gravity -->
    
  </div>
  <div>
    <h2>Some final polish</h2>
    <p>
      We&#39;re just about done! But let&#39;s add some final touches.
    </p>
    <p>
      We can improve the experience of adding sand by drawing a filled circle, instead of a single granule,
      when we interact with the canvas. We can make it feel even a bit more natural by aerating it a bit- that is,
      only drawing each granule with some probability.
    </p>
    <pre><code>p.onLeftClick = (x, y) =&gt; {
  grid.setCircle(
      x,
      y,
      () =&gt; varyColor(p, SAND_COLOR), // Color
      2, // Radius
      0.5 // Probability
  );
};</code></pre>
    <p>And we&#39;ve arrived at the same canvas that we saw at the very beginning!</p>

    
    <!-- Add left/right gravity -->
    
  </div>
  <p>
    That&#39;s it for now! If this was interesting, feel free to reach out to me! I&#39;m considering making this a series,
    highlighting different materials and the emergent behavior that can arise. Another aspect is performance.
    Our current approach will not scale very well, but there are both lower-level approaches and tricks we can
    use to improve it!
  </p>
  <p><a href="mailto:hi@jason.today">hi@jason.today</a></p><h2>Please note</h2>
  <p><i>
    Throughout the post, I only show the code critical for the functionality of the step.
    There&#39;s some abstraction on top of p5.js to keep everything as simple as possible,
    but all source code that I wrote is non-minified and available by looking at the source
    of this page. There are library functions and there is step-specific code.
  </i>
</p></div></div>
  </body>
</html>
