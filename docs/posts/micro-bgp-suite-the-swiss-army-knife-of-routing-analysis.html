<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://labs.ripe.net/author/lorenzo_cogotti/micro-bgp-suite-the-swiss-army-knife-of-routing-analysis/">Original</a>
    <h1>Micro BGP Suite: The Swiss Army Knife of Routing Analysis</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p>BGP Scanner from the Isolario project helped researchers analyse routing data, but it had its limitations. Overcoming these has led to the development of the Micro BGP Suite. It provides a variety of tools that, while each simple and efficient in their own operations, are capable of achieving complex results when combined.</p>
      <hr/>
      
        
          <section>
            <p>It has been a few years since my colleagues and I at the <a href="https://www.isolario.it/">Isolario project</a> launched ​​<a href="https://blog.apnic.net/2018/11/29/new-mrt-bgp-reader-six-times-faster-than-its-predecessors/">BGP Scanner</a> to assist researchers with analysing increasing amounts of routing data in a reasonable time. This has continued to be a passion project of mine and has led me to develop the Micro BGP Suite project. In this post, I’ll discuss its evolution from BGP Scanner, its advantages, and possible uses.</p>
          </section>
        
      
        
          <section>
            <h2><b>From BGP Scanner to µbgpsuite</b></h2><p>BGP Scanner proved to be a useful tool for <a href="https://gitlab.mpi-klsb.mpg.de/lprehn/imc20_aspp/-/tree/master/data_samples/bgp">many</a> <a href="https://ntwrk.today/2019/06/14/bogon-asns.html">network analysis projects</a>, including <a href="https://github.com/jfuruness/lib_bgp_data">lib_bgp_data</a>, to wade through the vast amount of <a href="https://tools.ietf.org/html/rfc6396">MRT data</a> provided by the multitude of benevolent route-collecting projects.</p><p>Much of its usefulness is owed to its powerful filtering engine and its easily parsable text output, which allow painless integration with larger data-processing workflows, and possibly scripting languages or external tools, by virtue of simple Unix-style output piping.</p><p>Despite this, BGP Scanner has some issues with its filtering capabilities mostly due to backwards compatibility concerns with its predecessor — MRT_data_reader.</p><p>This, <a href="https://git.doublefourteen.io/bgp/ubgpsuite/src/branch/master/doc/HISTORY.md">among other reasons</a>, motivated me to take a rather radical approach, and move the tool to a stand-alone project, rewriting the entire codebase from scratch, taking advantage of my past experience, and freeing myself from the burden of backwards compatibility.</p><p>The result of this choice is <a href="https://git.doublefourteen.io/bgp/ubgpsuite">the Micro BGP Suite</a> (<code>µbgpsuite</code> or <code>ubgpsuite</code> for short, depending on your keyboard proficiency with Greek).</p>
          </section>
        
      
        
          <section>
            <h2><b>So, How’s the Micro BGP Suite Better than BGP Scanner?</b></h2><p>BGP Scanner had a tradition of being fast at what it did. The Micro BGP Suite continues this with <a href="https://doublefourteen.io/blog/bgpgrep-performance-facts">recent benchmarks</a> demonstrating that <code>bgpgrep</code>, the successor to the <code>bgpscanner</code> command within <code>µbgpsuite</code>, can deliver between 12% to 20% additional performance on a middle-end laptop.</p><p>There are more improvements within <code>bgpgrep</code> too, such as better compatibility with less common MRT dump formats and several bugfixes, which make it more reliable. But, by far, its new command line interface and filtering options vastly outshine any other achievement.</p><p>To illustrate, let’s put <code>bgpgrep</code> to use for a significant MRT data set. Assume we wish to find out how many <a href="https://www.manrs.org/2021/01/routing-security-terms-bogons-vogons-and-martians">bogon ASNs and bogon addresses</a> appeared during July 2021.</p><p>First, we’ll lay down our study by fetching the relevant data from a route collecting project of our choice. In this case, we’ll use <a href="https://data.ris.ripe.net/rrc00/2021.07/">RIPE RIS RRC00</a>. By taking the first RIB snapshot of the month and every subsequent update, we obtain 50GB worth of gzip-compressed MRT data (corresponding to about 646GB uncompressed).</p>
          </section>
        
      
        
          <section>
            <pre><code>$ du -hc rrc00/bview.*.gz | tail -n1    # RIB size
1.4G    total
$ du -hc rrc00/updates.*.gz | tail -n1  # updates size
49G     total
$ gzip -l rrc00/*.gz | \
    awk &#39;{ megs+=$2/1000000 } END { printf &#34;%.2fG\n&#34;, megs/1000 }&#39;
645.88G</code></pre>
          </section>
        
      
        
          <section>
            <p>It is relatively easy to use <code>bgpgrep</code>’s filtering option to find out whether a BGP message contains any bogon ASNs in its <code>AS_PATH</code>. However, it is harder to tell whether a bogon address is present, because bogon addresses change over time. Thankfully, <a href="https://team-cymru.com/">Team Cymru</a> provides an up-to-date list that we can use for our study.</p><p>The following script downloads the up-to-date full bogon address list from Team Cymru and adapts it with some <code>sed-fu</code> to generate a suitable filter list for <code>bgpgrep</code>; we’ll save it under our current directory with the name <code>download-fullbogons.sh</code>:</p>
          </section>
        
      
        
          <section>
            <div><pre><span></span><code><span>#!/bin/sh</span>

<span># Be nice and only download bogons once a day.</span>
<span>if</span> <span>[</span> -f fullbogons.txt <span>]</span> <span>&amp;&amp;</span> <span>[</span> <span>$(</span>find fullbogons.txt -mtime -1<span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>&#34;Bogon address list already up to date.&#34;</span>
    <span>exit</span> <span>1</span>
<span>fi</span>

<span># Generate updated bogon list</span>
<span>echo</span> <span>&#34;Writing bogon list to: fullbogons.txt&#34;</span>

<span>(</span> wget -O - https://www.team-cymru.org/Services/Bogons/fullbogons-ipv4.txt
  <span>echo</span>
  wget -O - https://www.team-cymru.org/Services/Bogons/fullbogons-ipv6.txt
<span>)</span> <span>|</span> sed <span>&#39;s/#.*$//g&#39;</span> &gt;fullbogons.txt
</code></pre></div>

          </section>
        
      
        
          <section>
            <p>Our resulting directory layout is:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ ls
download-fullbogons.sh
rrc00</code></pre>
          </section>
        
      
        
          <section>
            <p>Now we are all set for our analysis. For ease of demonstration, we simply print the number of messages containing bogons:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ sh ./download-fullbogons.sh
Writing bogon list to: fullbogons.txt
$ bgpgrep rrc00/*.gz \
    -bogon-asn -or -subnet fullbogons.txt | \
    grep -E &#39;^+|^-|^=&#39; | wc -l
1344411</code></pre>
          </section>
        
      
        
          <section>
            <p>The <code>bgpgrep</code> command reads as follows:</p>
          </section>
        
      
        
          <section>
            <pre><code>For every gzip file in rrc00/, print each BGP message containing bogon ASN, or containing subnets of any prefix listed within fullbogons.txt.</code></pre>
          </section>
        
      
        
          <section>
            <p>Results are piped to grep, which will leave only entries coming from announcements, withdrawals and RIB snapshots, respectively. Every line of output by <code>bgpgrep</code> is prefixed by a character identifying its nature:</p><ul><li>= snapshot</li><li>+ announcement</li><li>– withdrawal</li><li># BGP state change</li><li>…</li></ul><p>Events unrelated to BGP updates aren’t subject to filtering rules and might cause miscounts in our analysis if left there. In the end, wc enters into play to count the total number of lines — <code>bgpgrep</code> produces one line of output for every BGP message or event. We choose to include withdrawals in our count; a slight alteration of the grep expression may easily restrict matching to announcements alone.</p><p>To dig further into our demonstration, let’s elaborate on this example and do some timing. What follows is <b>not</b> a benchmark, but rather a regular execution under a KDE Plasma session running various applications in the background (such as Firefox), on a middle-end laptop with the following configuration:</p><ul><li>CPU: Intel© Core™ i7-8565 @ 1.80GHz, 4 physical cores, (8 with hyperthreading)</li><li>Memory: 16 GB RAM DDR4</li><li>Hard disk: SAMSUNG MZALQ512HALU-000L1</li><li>Kernel: Linux 5.10.62-1-lts SMP x86_64 GNU/Linux</li></ul><p>This is an honest performance you might get analysing that amount of compressed data on a similar machine, under average load.</p><p>Timing of the example above:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ time bgpgrep rrc00/*.gz \
    -bogon-asn -or -subnet fullbogons.txt | \
    grep -E &#39;^+|^-|^=&#39; | wc -l
1344411

real    59m0,248s
user    58m43,747s
sys     1m41,248s</code></pre>
          </section>
        
      
        
          <section>
            <p>Restricting the match to the first seven days of July, note how the more restrictive the match, the faster the performance:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ time bgpgrep rrc00/*.gz \
    -timestamp &#34;&gt;=2021-07-01&#34; -and -timestamp &#34;&lt;2021-07-08&#34; \
    -and \( -bogon-asn -or -subnet fullbogons.txt \) | \
    grep -E &#39;^+|^-|^=&#39; | wc -l
273210

real    28m36,568s
user    28m14,241s
sys     1m9,260s</code></pre>
          </section>
        
      
        
          <section>
            <p>Obtaining a list of direct peers propagating the bogons:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ time bgpgrep rrc00/*.gz \
    -bogon-asn -or -subnet fullbogons.txt | \
    grep -E &#39;^+|^-|^=&#39; | \
    cut -f9 -d&#39;|&#39; | sort -u &gt;peerlist.txt

real    49m15,492s
user    49m7,445s
sys     1m36,730</code></pre>
          </section>
        
      
        
          <section>
            <p>This last example further relies on the <code>bgpgrep</code> output format always placing the peer address and ASN of each BGP message at the 9th field, thus making it trivial to extract and process it by itself. With more relaxed filtering specifications, performance is closer to the first experiment.</p><p>For reference, what follows is a gross estimate of the decompression overhead. We measure this by simply inflating all data to <code>/dev/null</code>. This serves to better grasp how much time <code>bgpgrep</code> has to pay to solely decompress its input — a necessary cost unless MRT data is decompressed in advance:</p>
          </section>
        
      
        
          <section>
            <pre><code>$ time zcat rrc00/*.gz &gt;/dev/null

real    30m57,084s
user    29m38,916s
sys     0m36,911s</code></pre>
          </section>
        
      
        
          <section>
            <h2><b>Take a Dive Into the Suite</b></h2><p><code>bgpgrep</code> is a decent Swiss Army knife for quick and dirty network analysis on huge MRT data sets. Its flexible and intuitive filtering options, coupled with a convenient output format, go to great lengths to provide interoperability with other familiar command line tools and scripting languages.</p><p>The Micro BGP Suite strives to provide similar tools, essentially simple and efficient in their operations, capable of achieving complex results when combined. Clear task division and effective interoperation are encouraged, rather than hidden behind a wall of complexity. Such flexibility is key to overcoming unanticipated needs.</p><p>There is more where <code>bgpgrep</code> came from, including <code>peerindex</code> — see my post on <a href="https://blog.apnic.net/2021/09/23/micro-bgp-suite/">The Micro BGP Suite</a>.</p><p>If you want to know more, be sure to check out <a href="https://doublefourteen.io/">The DoubleFourteen Code Forge</a> website and its <a href="https://git.doublefourteen.io/bgp/ubgpsuite">git code repository</a>.</p>
          </section>
        
      
        
          <section>
            <hr/><p>This article was originally published over on the <a href="https://blog.apnic.net/2021/11/16/micro-bgp-suite-the-swiss-army-knife-of-routing-analysis/">APNIC blog</a>.</p>
          </section>
        
      
    </article></div>
  </body>
</html>
