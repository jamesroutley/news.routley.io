<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borretti.me/article/why-lisp-syntax-works">Original</a>
    <h1>Why Lisp Syntax Works</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p><a href="https://lisp-lang.org/">Lisp</a>’s unusual syntax is connected to its expressive power. How? Not
because of “homoiconicity”, a word that has <a href="https://www.expressionsofchange.org/dont-say-homoiconic/">no meaning</a> but leaves people
somewhat impressed, because it sounds fanciful and mathematical. It’s because of
<em>uniformity</em>.</p>



<p>Language syntax exists on a spectrum from uniform to specific. Lisp (and XML)
have a <em>uniform syntax</em><sup id="fnref:uni" role="doc-noteref"><a href="#fn:uni" rel="footnote">1</a></sup>. The same syntactic construction of</p>

<div><div><pre><code>(&lt;operator&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argn&gt;)
</code></pre></div></div>

<p>Is used for:</p>

<ol>
  <li>Expressions.</li>
  <li>Expressions that would be statements in other languages (i.e. control flow).</li>
  <li>Special operators like <code>if</code> and <code>let</code>.</li>
  <li>Declarations, like function or class declarations.</li>
</ol>

<p>This means that macros apply everywhere. The exact same <code>defmacro</code> facility lets
you write macros that operate on expressions, special operators, and
declarations.</p>

<p>You can write macros that make writing expressions easier, like
<a href="https://github.com/ruricolist/infix-math"><code>infix-math</code></a>:</p>

<div><div><pre><code><span>(</span><span>$</span> <span>(</span><span>x</span> <span>*</span> <span>2</span><span>)</span> <span>/</span> <span>(</span><span>x</span> <span>*</span> <span>3</span><span>))</span>

<span>;; expands to (/ (* x 2) (* x 3))</span>
</code></pre></div></div>

<p>You can write macros that operate on would-be statements, like <a href="https://github.com/Shinmera/for"><code>for</code></a>:</p>

<div><div><pre><code><span>(</span><span>for:for</span> <span>((</span><span>li</span> <span>in</span> <span>(</span><span>list</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span><span>))</span>
          <span>(</span><span>vi</span> <span>across</span> <span>#(</span><span>a</span> <span>b</span> <span>c</span> <span>d</span><span>)))</span>
  <span>(</span><span>format</span> <span>T</span> <span>&#34;~&amp;~a ~a&#34;</span> <span>li</span> <span>vi</span><span>))</span>

<span>;; expands to</span>
<span>;;</span>
<span>;; (loop for li in (list 1 2 3 4)</span>
<span>;;       for vi across #(a b c d)</span>
<span>;;       do (format T &#34;~&amp;~a ~a&#34; li vi))</span>
</code></pre></div></div>

<p>You can write macros that operate on declarations, like <code>deftable</code> in
<a href="https://github.com/eudoxia0/crane"><code>crane</code></a>:</p>

<div><div><pre><code><span>(</span><span>deftable</span> <span>user</span> <span>()</span>
  <span>(</span><span>name</span> <span>:type</span> <span>text</span> <span>:uniquep</span> <span>t</span> <span>:nullp</span> <span>nil</span><span>)</span>
  <span>(</span><span>age</span> <span>:type</span> <span>integer</span> <span>:nullp</span> <span>t</span> <span>:initform</span> <span>18</span><span>)</span>
  <span>(</span><span>description</span> <span>:type</span> <span>text</span><span>))</span>

<span>;; expands to a whole bunch of ORM stuff</span>
</code></pre></div></div>

<p>And macros can be defined succinctly, e.g.:</p>

<div><div><pre><code><span>(</span><span>defmacro</span> <span>if-let</span> <span>((</span><span>var</span> <span>cond</span><span>)</span> <span>&amp;body</span> <span>consequent</span> <span>alternate</span><span>)</span>
  <span>`</span><span>(</span><span>let</span> <span>((</span><span>,</span><span>var</span> <span>,</span><span>cond</span><span>))</span>
     <span>(</span><span>if</span> <span>,</span><span>var</span>
       <span>,</span><span>consequent</span>
       <span>,</span><span>alternate</span><span>)))</span>
</code></pre></div></div>

<p>Defining a macro does not require some ceremonious process of writing an
AST-manipulating program, registering it with the build system or whatever, it
can be done inline, in the source. The language is extensible from within,
without requiring you to string together some build-time Rube Goldberg
preprocessing pipeline.</p>

<p>And macros are Lisp code, so they can use whatever toolkit of list and
tree-manipulation code you bring in. You can even define <a href="http://www.lispworks.com/documentation/lw70/CLHS/Body/s_flet_.htm">lexically-scoped
macros</a>.</p>

<p>Syntactic uniformity also means there is a lot less room for syntax
bikeshedding. Really the only thing you can bikeshed is the naming convention
for identifiers, and how S-expressions should be indented.</p>

<p>Common Lisp syntax works because of the conjunction of:</p>

<ol>
  <li>Syntactic uniformity, allowing macros to be applied everywhere.</li>
  <li>Turing-complete macros that can execute arbitrary code at compile-time, and
leverage libraries.</li>
  <li>An image-based development model that blurs the lines between compile-time
and run-time.</li>
</ol>



<p>At the other end of the spectrum you have languages with a highly <em>specific
syntax</em>. The best example is plain old fashioned SQL. This is the grammar for
the humble <a href="https://www.postgresql.org/docs/current/sql-altertable.html"><code>ALTER TABLE</code></a> statement in Postgres:</p>

<div><div><pre><code><span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>[</span> <span>ONLY</span> <span>]</span> <span>name</span> <span>[</span> <span>*</span> <span>]</span>
    <span>action</span> <span>[,</span> <span>...</span> <span>]</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>[</span> <span>ONLY</span> <span>]</span> <span>name</span> <span>[</span> <span>*</span> <span>]</span>
    <span>RENAME</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>TO</span> <span>new_column_name</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>[</span> <span>ONLY</span> <span>]</span> <span>name</span> <span>[</span> <span>*</span> <span>]</span>
    <span>RENAME</span> <span>CONSTRAINT</span> <span>constraint_name</span> <span>TO</span> <span>new_constraint_name</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>name</span>
    <span>RENAME</span> <span>TO</span> <span>new_name</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>name</span>
    <span>SET</span> <span>SCHEMA</span> <span>new_schema</span>
<span>ALTER</span> <span>TABLE</span> <span>ALL</span> <span>IN</span> <span>TABLESPACE</span> <span>name</span> <span>[</span> <span>OWNED</span> <span>BY</span> <span>role_name</span> <span>[,</span> <span>...</span> <span>]</span> <span>]</span>
    <span>SET</span> <span>TABLESPACE</span> <span>new_tablespace</span> <span>[</span> <span>NOWAIT</span> <span>]</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>name</span>
    <span>ATTACH</span> <span>PARTITION</span> <span>partition_name</span> <span>{</span> <span>FOR</span> <span>VALUES</span> <span>partition_bound_spec</span> <span>|</span> <span>DEFAULT</span> <span>}</span>
<span>ALTER</span> <span>TABLE</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>name</span>
    <span>DETACH</span> <span>PARTITION</span> <span>partition_name</span> <span>[</span> <span>CONCURRENTLY</span> <span>|</span> <span>FINALIZE</span> <span>]</span>

<span>where</span> <span>action</span> <span>is</span> <span>one</span> <span>of</span><span>:</span>

    <span>ADD</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>[</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> <span>]</span> <span>column_name</span> <span>data_type</span> <span>[</span> <span>COLLATE</span> <span>collation</span> <span>]</span> <span>[</span> <span>column_constraint</span> <span>[</span> <span>...</span> <span>]</span> <span>]</span>
    <span>DROP</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span> <span>column_name</span> <span>[</span> <span>RESTRICT</span> <span>|</span> <span>CASCADE</span> <span>]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>[</span> <span>SET</span> <span>DATA</span> <span>]</span> <span>TYPE</span> <span>data_type</span> <span>[</span> <span>COLLATE</span> <span>collation</span> <span>]</span> <span>[</span> <span>USING</span> <span>expression</span> <span>]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>SET</span> <span>DEFAULT</span> <span>expression</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>DROP</span> <span>DEFAULT</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>{</span> <span>SET</span> <span>|</span> <span>DROP</span> <span>}</span> <span>NOT</span> <span>NULL</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>DROP</span> <span>EXPRESSION</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>ADD</span> <span>GENERATED</span> <span>{</span> <span>ALWAYS</span> <span>|</span> <span>BY</span> <span>DEFAULT</span> <span>}</span> <span>AS</span> <span>IDENTITY</span> <span>[</span> <span>(</span> <span>sequence_options</span> <span>)</span> <span>]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>{</span> <span>SET</span> <span>GENERATED</span> <span>{</span> <span>ALWAYS</span> <span>|</span> <span>BY</span> <span>DEFAULT</span> <span>}</span> <span>|</span> <span>SET</span> <span>sequence_option</span> <span>|</span> <span>RESTART</span> <span>[</span> <span>[</span> <span>WITH</span> <span>]</span> <span>restart</span> <span>]</span> <span>}</span> <span>[...]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>DROP</span> <span>IDENTITY</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>SET</span> <span>STATISTICS</span> <span>integer</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>SET</span> <span>(</span> <span>attribute_option</span> <span>=</span> <span>value</span> <span>[,</span> <span>...</span> <span>]</span> <span>)</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>RESET</span> <span>(</span> <span>attribute_option</span> <span>[,</span> <span>...</span> <span>]</span> <span>)</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>SET</span> <span>STORAGE</span> <span>{</span> <span>PLAIN</span> <span>|</span> <span>EXTERNAL</span> <span>|</span> <span>EXTENDED</span> <span>|</span> <span>MAIN</span> <span>}</span>
    <span>ALTER</span> <span>[</span> <span>COLUMN</span> <span>]</span> <span>column_name</span> <span>SET</span> <span>COMPRESSION</span> <span>compression_method</span>
    <span>ADD</span> <span>table_constraint</span> <span>[</span> <span>NOT</span> <span>VALID</span> <span>]</span>
    <span>ADD</span> <span>table_constraint_using_index</span>
    <span>ALTER</span> <span>CONSTRAINT</span> <span>constraint_name</span> <span>[</span> <span>DEFERRABLE</span> <span>|</span> <span>NOT</span> <span>DEFERRABLE</span> <span>]</span> <span>[</span> <span>INITIALLY</span> <span>DEFERRED</span> <span>|</span> <span>INITIALLY</span> <span>IMMEDIATE</span> <span>]</span>
    <span>VALIDATE</span> <span>CONSTRAINT</span> <span>constraint_name</span>
    <span>DROP</span> <span>CONSTRAINT</span> <span>[</span> <span>IF</span> <span>EXISTS</span> <span>]</span>  <span>constraint_name</span> <span>[</span> <span>RESTRICT</span> <span>|</span> <span>CASCADE</span> <span>]</span>
    <span>DISABLE</span> <span>TRIGGER</span> <span>[</span> <span>trigger_name</span> <span>|</span> <span>ALL</span> <span>|</span> <span>USER</span> <span>]</span>
    <span>ENABLE</span> <span>TRIGGER</span> <span>[</span> <span>trigger_name</span> <span>|</span> <span>ALL</span> <span>|</span> <span>USER</span> <span>]</span>
    <span>ENABLE</span> <span>REPLICA</span> <span>TRIGGER</span> <span>trigger_name</span>
    <span>ENABLE</span> <span>ALWAYS</span> <span>TRIGGER</span> <span>trigger_name</span>
    <span>DISABLE</span> <span>RULE</span> <span>rewrite_rule_name</span>
    <span>ENABLE</span> <span>RULE</span> <span>rewrite_rule_name</span>
    <span>ENABLE</span> <span>REPLICA</span> <span>RULE</span> <span>rewrite_rule_name</span>
    <span>ENABLE</span> <span>ALWAYS</span> <span>RULE</span> <span>rewrite_rule_name</span>
    <span>DISABLE</span> <span>ROW</span> <span>LEVEL</span> <span>SECURITY</span>
    <span>ENABLE</span> <span>ROW</span> <span>LEVEL</span> <span>SECURITY</span>
    <span>FORCE</span> <span>ROW</span> <span>LEVEL</span> <span>SECURITY</span>
    <span>NO</span> <span>FORCE</span> <span>ROW</span> <span>LEVEL</span> <span>SECURITY</span>
    <span>CLUSTER</span> <span>ON</span> <span>index_name</span>
    <span>SET</span> <span>WITHOUT</span> <span>CLUSTER</span>
    <span>SET</span> <span>WITHOUT</span> <span>OIDS</span>
    <span>SET</span> <span>ACCESS</span> <span>METHOD</span> <span>new_access_method</span>
    <span>SET</span> <span>TABLESPACE</span> <span>new_tablespace</span>
    <span>SET</span> <span>{</span> <span>LOGGED</span> <span>|</span> <span>UNLOGGED</span> <span>}</span>
    <span>SET</span> <span>(</span> <span>storage_parameter</span> <span>[</span><span>=</span> <span>value</span><span>]</span> <span>[,</span> <span>...</span> <span>]</span> <span>)</span>
    <span>RESET</span> <span>(</span> <span>storage_parameter</span> <span>[,</span> <span>...</span> <span>]</span> <span>)</span>
    <span>INHERIT</span> <span>parent_table</span>
    <span>NO</span> <span>INHERIT</span> <span>parent_table</span>
    <span>OF</span> <span>type_name</span>
    <span>NOT</span> <span>OF</span>
    <span>OWNER</span> <span>TO</span> <span>{</span> <span>new_owner</span> <span>|</span> <span>CURRENT_ROLE</span> <span>|</span> <span>CURRENT_USER</span> <span>|</span> <span>SESSION_USER</span> <span>}</span>
    <span>REPLICA</span> <span>IDENTITY</span> <span>{</span> <span>DEFAULT</span> <span>|</span> <span>USING</span> <span>INDEX</span> <span>index_name</span> <span>|</span> <span>FULL</span> <span>|</span> <span>NOTHING</span> <span>}</span>
</code></pre></div></div>

<p>That’s half the grammar. I trimmed the second half because the point is made.</p>

<p>SQL syntax isn’t composable, the way Lisp is. Composability is about having a
large number of distinct operators with a small number of expression holes,
while SQL is all about having a small number of operators with fifty different
syntactic variants.</p>

<p>And you can’t write macros for SQL. You only options are C-style
text-manipulation macros, cleanly staged and separated from the SQL itself, or
writing a program that parses the SQL into an AST (good luck) and transforms it
at the AST level.</p>



<p>Most languages inhabit the middle ground. Generally, syntax at the same level
will have more or less the same form. Declarations all look kind of the same,
they start with a keyword (<code>struct</code>, <code>fn</code>, <code>union</code>) and use brackets to contain
their inner declarations (record fields, function bodies). Statements may all
end in semicolons. That kind of thing.</p>

<p>But for most languages, writing even a simple template match-and-replace macro
system is hard because the syntax is too specific and irregular. <a href="https://github.com/eudoxia0/cmacro">I tried it
with C</a> and the results were mixed.</p>

<p>So for most languages, the only way to do macros is typed AST-manipulation code,
like OCaml’s <a href="https://ocaml.org/docs/metaprogramming">PPX</a>.</p>

<p>I maintain that Common Lisp is the gold standard of DX for macros, but it works
only because Common Lisp exists at a <em>very narrow</em> conjunction of tradeoffs. In
particular, image-based development is a rarity nowadays, a <a href="https://en.wikipedia.org/wiki/Gal%C3%A1pagos_syndrome">Galápagos island
feature</a> that is undesirable in many contexts, but it’s the thing
that makes it possible to have Turing-complete macros that are defined in the
same place as the code, without needing to involve a build system.</p>

<p>And languages that don’t share this evolutionary niche should simply do away
with macros. The complexity-benefit tradeoff is not worth it.</p>





  </article></div>
  </body>
</html>
