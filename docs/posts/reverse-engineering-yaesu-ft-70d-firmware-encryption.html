<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://landaire.net/reversing-yaesu-firmware-encryption/">Original</a>
    <h1>Reverse Engineering Yaesu FT-70D Firmware Encryption</h1>
    
    <div id="readability-page-1" class="page"><div>
  
  <p><em>This article dives into my full methodology for reverse engineering the tool mentioned in this article. It&#39;s a bit longer but is intended to be accessible to folks who aren&#39;t necessarily advanced reverse-engineers.</em></p>
<p><em>Click on any of the images to view at its original resolution.</em></p>

  
  <h2 id="background"><a href="#background" aria-label="Anchor link for: background">#</a>
Background</h2>
<p>Ham radios are a fun way of learning how the radio spectrum works, and more importantly: they&#39;re embedded devices that may run weird chips/firmware! I got curious how easy it&#39;d be to hack my Yaesu FT-70D, so I started doing some research. The only existing resource I could find for Yaesu radios was <a href="https://www.reddit.com/r/amateurradio/comments/cwoxvv/yaesu_ft1dr_custom_firmware/">someone who posted about custom firmware for their Yaesu FT1DR</a>.</p>
<p>The Reddit poster mentioned that if you go through the firmware update process via USB, the radio exposes its Renesas H8SX microcontroller and can have its flash modified using the Renesas SDK. This was a great start and looked promising, but the SDK wasn&#39;t trivial to configure and I wasn&#39;t sure if it could even dump the firmware... so I didn&#39;t use it for very long.</p>
<h2 id="other-avenues"><a href="#other-avenues" aria-label="Anchor link for: other-avenues">#</a>
Other Avenues</h2>
<p>Yaesu provides a Windows application on their website that can be used to update a radio&#39;s firmware over USB:</p>

<a href="https://landaire.net/img/yaesu/firmware_page.png"><img src="https://landaire.net/processed_images/firmware_page.04f1c2d731a66b56.png"/></a>
<p>The zip contains the following files:</p>
<pre><code><span>1.2 MB  Wed Nov  8 14:34:38 2017  FT-70D_ver111(USA).exe
</span><span>682 KB  Tue Nov 14 00:00:00 2017  FT-70DR_DE_Firmware_Update_Information_ENG_1711-B.pdf
</span><span>8 MB  Mon Apr 23 00:00:00 2018  FT-70DR_DE_MAIN_Firmware_Ver_Up_Manual_ENG_1804-B.pdf
</span><span>3.2 MB  Fri Jan  6 17:54:44 2012  HMSEUSBDRIVER.exe
</span><span>160 KB  Sat Sep 17 15:14:16 2011  RComms.dll
</span><span>61 KB  Tue Oct 23 17:02:08 2012  RFP_USB_VB.dll
</span><span>1.7 MB  Fri Mar 29 11:54:02 2013  vcredist_x86.exe
</span></code></pre>
<p>I&#39;m going to assume that the file specific to the FT-70D, &#34;FT-70D_ver111(USA).exe&#34;, will likely contain our firmware image. A PE file (.exe) can contain binary resources in the <code>.rsrc</code> section -- let&#39;s see what this file contains using <a href="https://github.com/horsicq/XPEViewer">XPEViewer</a>:</p>

<a href="https://landaire.net/img/yaesu/exe_resources.png"><img src="https://landaire.net/processed_images/exe_resources.eb5799636ce0b537.png"/></a>
<p>Resources fit into one of many different <a href="https://docs.microsoft.com/en-us/windows/win32/menurc/resource-types">resource types</a>, but a firmware image would likely be put into a custom type. What&#39;s this last entry, &#34;23&#34;? Expanding that node we have a couple of interesting items:</p>

<a href="https://landaire.net/img/yaesu/start_update.png"><img src="https://landaire.net/processed_images/start_update.fd44b49d8f5a99d8.png"/></a>
<p><code>RES_START_DIALOG</code> is a custom string the updater shows when preparing an update, so we&#39;re in the right area!</p>

<a href="https://landaire.net/img/yaesu/res_update_info.png"><img src="https://landaire.net/processed_images/res_update_info.800caa6b65c3a1dc.png"/></a>
<p><code>RES_UPDATE_INFO</code> looks like just binary data -- perhaps this is our firmware image? Unfortunately looking at the &#34;Strings&#34; tab in XPEViewer or running the <code>strings</code> utility over this data doesn&#39;t yield anything legible. The firmware image is likely encrypted.</p>
<h2 id="reverse-engineering-the-binary"><a href="#reverse-engineering-the-binary" aria-label="Anchor link for: reverse-engineering-the-binary">#</a>
Reverse Engineering the Binary</h2>
<p>Let&#39;s load the update utility into our disassembler of choice to figure out how the data is encrypted. I&#39;ll be using IDA Pro, but Ghidra (free!), radare2 (free!), or Binary Ninja are all great alternatives. Where possible in this article I&#39;ll try to show my rewritten code in C since it&#39;ll be a closer match to the decompiler and machine code output.</p>
<p>A good starting point is the the string we saw above, <code>RES_UPDATE_INFO</code>. Windows applications load resources by calling one of the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea"><code>FindResource*</code> APIs</a>. <code>FindResourceA</code> has the following parameters:</p>
<ol>
<li><code>HMODULE</code>, a handle to the module to look for the resource in.</li>
<li><code>lpName</code>, the resource name.</li>
<li><code>lpType</code>, the resource type.</li>
</ol>
<p>In our disassembler we can find references to the <code>RES_UPDATE_INFO</code> string and look for calls to <code>FindResourceA</code> with this string as an argument in the <code>lpName</code> position.</p>

<a href="https://landaire.net/img/yaesu/update_info_xrefs.png"><img src="https://landaire.net/processed_images/update_info_xrefs.ad5bc7241aaf966e.png"/></a>
<p>We find a match in a function which happens to find/load <em>all</em> of these custom resources under type <code>23</code>.</p>

<a href="https://landaire.net/img/yaesu/load_resource_decompiler_output.png"><img src="https://landaire.net/processed_images/load_resource_decompiler_output.ed358a98d7f4ab3b.png"/></a>
<p>We know where the data is loaded by the application, so now we need to see how it&#39;s used. Doing static analysis from this point may be more work than it&#39;s worth if the data isn&#39;t operated on immediately. To speed things up I&#39;m going to use a debugger&#39;s assistance. I used WinDbg&#39;s <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview">Time Travel Debugging</a> to record an execution trace of the updater while it updates my radio. TTD is an invaluable tool and I&#39;d highly recommend using it when possible. <a href="https://rr-project.org/">rr</a> is an alternative for non-Windows platforms.</p>
<p>The decompiler output shows this function copies the <code>RES_UPDATE_INFO</code> resource to a dynamically allocated buffer. The <code>qmemcpy()</code> is inlined and represented by a <code>rep movsd</code> instruction in the disassembly, so we need to break at this instruction and examine the <code>edi</code> register&#39;s (destination address) value. I set a breakpoint by typing <code>bp 0x406968</code> in the command window, allow the application to continue running, and when it breaks we can see the <code>edi</code> register value is <code>0x2be5020</code>. We can now set a memory access breakpoint at this address using <code>ba r4 0x2be5020</code> to break whenever this data is read.</p>
<p>Our breakpoint is hit at <code>0x4047DC</code> -- back to the disassembler. In IDA you can press <code>G</code> and enter this address to jump to it. We&#39;re finally at what looks like the data processing function:</p>

<a href="https://landaire.net/img/yaesu/deobfuscate_function.png"><img src="https://landaire.net/processed_images/deobfuscate_function.70d489a87307371e.png"/></a>
<p>We broke when dereferencing <code>v2</code> and IDA has automatically named the variable it&#39;s being assigned to as <code>Time</code>. The <code>Time</code> variable is passed to another function which formats it as a string with <code>%Y%m%d%H%M%S</code>. Let&#39;s clean up the variables to reflect what we know:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>bool</span><span> __thiscall </span><span>sub_4047B0</span><span>(</span><span>char </span><span>*</span><span>this</span><span>)
</span></td></tr><tr><td>2</td><td><span>{
</span></td></tr><tr><td>3</td><td><span>  </span><span>char </span><span>*encrypted_data; </span><span>// esi
</span></td></tr><tr><td>4</td><td><span>  BOOL v3; </span><span>// ebx
</span></td></tr><tr><td>5</td><td><span>  </span><span>char </span><span>*v4; </span><span>// eax
</span></td></tr><tr><td>6</td><td><span>  </span><span>char </span><span>*time_string; </span><span>// [esp+Ch] [ebp-320h] BYREF
</span></td></tr><tr><td>7</td><td><span>  </span><span>int</span><span> v7; </span><span>// [esp+10h] [ebp-31Ch] BYREF
</span></td></tr><tr><td>8</td><td><span>  __time64_t Time; </span><span>// [esp+14h] [ebp-318h] BYREF
</span></td></tr><tr><td>9</td><td><span>  </span><span>int </span><span>(__thiscall **v9)(</span><span>void </span><span>*, </span><span>char</span><span>); </span><span>// [esp+1Ch] [ebp-310h]
</span></td></tr><tr><td>10</td><td><span>  </span><span>int</span><span> v10; </span><span>// [esp+328h] [ebp-4h]
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>  </span><span>// rename v2 to encrypted_data
</span></td></tr><tr><td>13</td><td><span>  encrypted_data = *(</span><span>char </span><span>**)(*((_DWORD *)</span><span>AfxGetModuleState</span><span>() + </span><span>1</span><span>) + </span><span>160</span><span>);
</span></td></tr><tr><td>14</td><td><span>  Time = *(</span><span>int </span><span>*)encrypted_data;
</span></td></tr><tr><td>15</td><td><span>  </span><span>// rename this function and its 2nd parameter
</span></td></tr><tr><td>16</td><td><span>  </span><span>format_timestamp</span><span>(&amp;Time, (</span><span>int</span><span>)&amp;time_string, &#34;</span><span>%Y%m</span><span>%d</span><span>%H%M</span><span>%S</span><span>&#34;);
</span></td></tr><tr><td>17</td><td><span>  v10 = </span><span>1</span><span>;
</span></td></tr><tr><td>18</td><td><span>  v7 = </span><span>0</span><span>;
</span></td></tr><tr><td>19</td><td><span>  v9 = off_4244A0;
</span></td></tr><tr><td>20</td><td><span>  </span><span>sub_4082C0</span><span>(time_string);
</span></td></tr><tr><td>21</td><td><span>  v3 = </span><span>sub_408350</span><span>(encrypted_data + </span><span>4</span><span>, </span><span>0x100000</span><span>, this + </span><span>92</span><span>, </span><span>0x100000</span><span>, &amp;v7) == </span><span>0</span><span>;
</span></td></tr><tr><td>22</td><td><span>  v4 = time_string - </span><span>16</span><span>;
</span></td></tr><tr><td>23</td><td><span>  v9 = off_4244A0;
</span></td></tr><tr><td>24</td><td><span>  v10 = -</span><span>1</span><span>;
</span></td></tr><tr><td>25</td><td><span>  </span><span>if </span><span>( </span><span>_InterlockedDecrement</span><span>((</span><span>volatile signed </span><span>__int32 *)time_string - </span><span>1</span><span>) &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>26</td><td><span>    (*(</span><span>void </span><span>(__stdcall **)(</span><span>char </span><span>*))(**(_DWORD **)v4 + </span><span>4</span><span>))(v4);
</span></td></tr><tr><td>27</td><td><span>  </span><span>return</span><span> v3;
</span></td></tr><tr><td>28</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>The timestamp string is passed to <code>sub_4082c0</code> on line 20 and the remainder of the update image is passed to <code>sub_408350</code> on line 21. I&#39;m going to focus on <code>sub_408350</code> since I only care about the firmware data right now and based on how this function is called I&#39;d wager its signature is something like:</p>
<pre data-lang="c"><code data-lang="c"><span>status_t </span><span>sub_408350</span><span>(uint8_t *</span><span>input</span><span>, size_t </span><span>input_len</span><span>, uint8_t *</span><span>output</span><span>, </span><span>output_len</span><span>, size_t *</span><span>out_data_processed</span><span>);
</span></code></pre>
<p>Let&#39;s see what it does:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>int</span><span> __stdcall </span><span>sub_408350</span><span>(</span><span>char </span><span>*</span><span>a1</span><span>, </span><span>int </span><span>a2</span><span>, </span><span>int </span><span>a3</span><span>, </span><span>int </span><span>a4</span><span>, _DWORD *</span><span>a5</span><span>)
</span></td></tr><tr><td>2</td><td><span>{
</span></td></tr><tr><td>3</td><td><span>  </span><span>int</span><span> v5; </span><span>// edx
</span></td></tr><tr><td>4</td><td><span>  </span><span>int</span><span> v7; </span><span>// ebp
</span></td></tr><tr><td>5</td><td><span>  </span><span>int</span><span> v8; </span><span>// esi
</span></td></tr><tr><td>6</td><td><span>  </span><span>unsigned int</span><span> i; </span><span>// ecx
</span></td></tr><tr><td>7</td><td><span>  </span><span>char</span><span> v10; </span><span>// al
</span></td></tr><tr><td>8</td><td><span>  </span><span>char </span><span>*v11; </span><span>// eax
</span></td></tr><tr><td>9</td><td><span>  </span><span>int</span><span> v13; </span><span>// [esp+10h] [ebp-54h]
</span></td></tr><tr><td>10</td><td><span>  </span><span>char</span><span> v14[</span><span>64</span><span>]; </span><span>// [esp+20h] [ebp-44h] BYREF
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>  v5 = a2;
</span></td></tr><tr><td>13</td><td><span>  v7 = </span><span>0</span><span>;
</span></td></tr><tr><td>14</td><td><span>  </span><span>memset</span><span>(v14, </span><span>0</span><span>, sizeof(v14));
</span></td></tr><tr><td>15</td><td><span>  </span><span>if </span><span>( a2 &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>16</td><td><span>  {
</span></td></tr><tr><td>17</td><td><span>LABEL_13:
</span></td></tr><tr><td>18</td><td><span>    *a5 = v7;
</span></td></tr><tr><td>19</td><td><span>    </span><span>return </span><span>0</span><span>;
</span></td></tr><tr><td>20</td><td><span>  }
</span></td></tr><tr><td>21</td><td><span>  </span><span>else
</span></td></tr><tr><td>22</td><td><span>  {
</span></td></tr><tr><td>23</td><td><span>    </span><span>while </span><span>( </span><span>1 </span><span>)
</span></td></tr><tr><td>24</td><td><span>    {
</span></td></tr><tr><td>25</td><td><span>      v8 = v5;
</span></td></tr><tr><td>26</td><td><span>      </span><span>if </span><span>( v5 &gt;= </span><span>8 </span><span>)
</span></td></tr><tr><td>27</td><td><span>        v8 = </span><span>8</span><span>;
</span></td></tr><tr><td>28</td><td><span>      v13 = v5 - v8;
</span></td></tr><tr><td>29</td><td><span>      </span><span>for </span><span>( i = </span><span>0</span><span>; i &lt; </span><span>0x40</span><span>; i += </span><span>8 </span><span>)
</span></td></tr><tr><td>30</td><td><span>      {
</span></td></tr><tr><td>31</td><td><span>        v10 = *a1;
</span></td></tr><tr><td>32</td><td><span>        v14[i] = (</span><span>unsigned </span><span>__int8)*a1 &gt;&gt; </span><span>7</span><span>;
</span></td></tr><tr><td>33</td><td><span>        v14[i + </span><span>1</span><span>] = (v10 &amp; </span><span>0x40</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>34</td><td><span>        v14[i + </span><span>2</span><span>] = (v10 &amp; </span><span>0x20</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>35</td><td><span>        v14[i + </span><span>3</span><span>] = (v10 &amp; </span><span>0x10</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>36</td><td><span>        v14[i + </span><span>4</span><span>] = (v10 &amp; </span><span>8</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>37</td><td><span>        v14[i + </span><span>5</span><span>] = (v10 &amp; </span><span>4</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>38</td><td><span>        v14[i + </span><span>6</span><span>] = (v10 &amp; </span><span>2</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>39</td><td><span>        v14[i + </span><span>7</span><span>] = v10 &amp; </span><span>1</span><span>;
</span></td></tr><tr><td>40</td><td><span>        ++a1;
</span></td></tr><tr><td>41</td><td><span>      }
</span></td></tr><tr><td>42</td><td><span>      </span><span>sub_407980</span><span>(v14, </span><span>0</span><span>);
</span></td></tr><tr><td>43</td><td><span>      </span><span>if </span><span>( v8 )
</span></td></tr><tr><td>44</td><td><span>        </span><span>break</span><span>;
</span></td></tr><tr><td>45</td><td><span>LABEL_12:
</span></td></tr><tr><td>46</td><td><span>      </span><span>if </span><span>( v13 &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>47</td><td><span>        </span><span>goto</span><span> LABEL_13;
</span></td></tr><tr><td>48</td><td><span>      v5 = v13;
</span></td></tr><tr><td>49</td><td><span>    }
</span></td></tr><tr><td>50</td><td><span>    v11 = &amp;v14[</span><span>1</span><span>];
</span></td></tr><tr><td>51</td><td><span>    </span><span>while </span><span>( </span><span>1 </span><span>)
</span></td></tr><tr><td>52</td><td><span>    {
</span></td></tr><tr><td>53</td><td><span>      --v8;
</span></td></tr><tr><td>54</td><td><span>      </span><span>if </span><span>( v7 &gt;= a4 )
</span></td></tr><tr><td>55</td><td><span>        </span><span>return </span><span>-</span><span>101</span><span>;
</span></td></tr><tr><td>56</td><td><span>      *(_BYTE *)(a3 + v7++) = v11[</span><span>6</span><span>] | (</span><span>2
</span></td></tr><tr><td>57</td><td><span>                                      * (v11[</span><span>5</span><span>] | (</span><span>2
</span></td></tr><tr><td>58</td><td><span>                                                 * (v11[</span><span>4</span><span>] | (</span><span>2
</span></td></tr><tr><td>59</td><td><span>                                                            * (v11[</span><span>3</span><span>] | (</span><span>2
</span></td></tr><tr><td>60</td><td><span>                                                                       * (v11[</span><span>2</span><span>] | (</span><span>2
</span></td></tr><tr><td>61</td><td><span>                                                                                  * (v11[</span><span>1</span><span>] | (</span><span>2
</span></td></tr><tr><td>62</td><td><span>                                                                                             * (*v11 | (</span><span>2 </span><span>* *(v11 - </span><span>1</span><span>))))))))))))));
</span></td></tr><tr><td>63</td><td><span>      v11 += </span><span>8</span><span>;
</span></td></tr><tr><td>64</td><td><span>      </span><span>if </span><span>( !v8 )
</span></td></tr><tr><td>65</td><td><span>        </span><span>goto</span><span> LABEL_12;
</span></td></tr><tr><td>66</td><td><span>    }
</span></td></tr><tr><td>67</td><td><span>  }
</span></td></tr><tr><td>68</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>I think we&#39;ve found our function that starts decrypting the firmware! To confirm, we want to see what the <code>output</code> parameter&#39;s data looks like before and after this function is called. I set a breakpoint in the debugger at the address where it&#39;s called (<code>bp 0x404842</code>) and put the value of the <code>edi</code> register (<code>0x2d7507c</code>) in WinDbg&#39;s memory window.</p>
<p>Here&#39;s the data before:</p>

<a href="https://landaire.net/img/yaesu/data_before.png"><img src="https://landaire.net/processed_images/data_before.b3909a2025b89ba1.png"/></a>
<p>After stepping over the function call:</p>

<a href="https://landaire.net/img/yaesu/data_after.png"><img src="https://landaire.net/processed_images/data_after.7ab8bc7523fb6c44.png"/></a>
<p>We can dump this data to a file using the following command:</p>
<pre><code><span>.writemem C:\users\lander\documents\maybe_deobfuscated.bin 0x2d7507c L100000
</span></code></pre>
<p>010 Editor has a built-in strings utility (Search &gt; Find Strings...) and if we scroll down a bit in the results, we have real strings that appear in my radio!</p>

<a href="https://landaire.net/img/yaesu/hex_editor_strings.png"><img src="https://landaire.net/processed_images/hex_editor_strings.21f4f024c6f70e82.png"/></a>
<p>At this point if we were just interested in getting the plaintext firmware we could stop messing with the binary and <a href="https://landaire.net/reversing-yaesu-firmware-encryption/#loading-the-firmware-in-ida-pro">load the firmware into IDA Pro</a>... but I want to know how this encryption works.</p>
<h2 id="encryption-details"><a href="#encryption-details" aria-label="Anchor link for: encryption-details">#</a>
Encryption Details</h2>
<p>Just to recap from the last section:</p>
<ul>
<li>We&#39;ve identified our data processing routine (let&#39;s call this function <code>decrypt_update_info</code>).</li>
<li>We know that the first 4 bytes of the update data are a Unix timestamp that&#39;s formatted as a string and used for an unknown purpose.</li>
<li>We know which function begins decrypting our firmware image.</li>
</ul>
<h3 id="data-decryption"><a href="#data-decryption" aria-label="Anchor link for: data-decryption">#</a>
Data Decryption</h3>
<p>Let&#39;s look at the firmware image decryption routine with some renamed variables:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>int</span><span> __thiscall </span><span>decrypt_data</span><span>(
</span></td></tr><tr><td>2</td><td><span>        </span><span>void </span><span>*</span><span>this</span><span>,
</span></td></tr><tr><td>3</td><td><span>        </span><span>char </span><span>*</span><span>encrypted_data</span><span>,
</span></td></tr><tr><td>4</td><td><span>        </span><span>int </span><span>encrypted_data_len</span><span>,
</span></td></tr><tr><td>5</td><td><span>        </span><span>char </span><span>*</span><span>output_data</span><span>,
</span></td></tr><tr><td>6</td><td><span>        </span><span>int </span><span>output_data_len</span><span>,
</span></td></tr><tr><td>7</td><td><span>        _DWORD *</span><span>bytes_written</span><span>)
</span></td></tr><tr><td>8</td><td><span>{
</span></td></tr><tr><td>9</td><td><span>  </span><span>int</span><span> data_len; </span><span>// edx
</span></td></tr><tr><td>10</td><td><span>  </span><span>int</span><span> output_index; </span><span>// ebp
</span></td></tr><tr><td>11</td><td><span>  </span><span>int</span><span> block_size; </span><span>// esi
</span></td></tr><tr><td>12</td><td><span>  </span><span>unsigned int</span><span> i; </span><span>// ecx
</span></td></tr><tr><td>13</td><td><span>  </span><span>char</span><span> encrypted_byte; </span><span>// al
</span></td></tr><tr><td>14</td><td><span>  </span><span>char </span><span>*idata; </span><span>// eax
</span></td></tr><tr><td>15</td><td><span>  </span><span>int</span><span> remaining_data; </span><span>// [esp+10h] [ebp-54h]
</span></td></tr><tr><td>16</td><td><span>  </span><span>char</span><span> inflated_data[</span><span>64</span><span>]; </span><span>// [esp+20h] [ebp-44h] BYREF
</span></td></tr><tr><td>17</td><td><span>
</span></td></tr><tr><td>18</td><td><span>  data_len = encrypted_data_len;
</span></td></tr><tr><td>19</td><td><span>  output_index = </span><span>0</span><span>;
</span></td></tr><tr><td>20</td><td><span>  </span><span>memset</span><span>(inflated_data, </span><span>0</span><span>, sizeof(inflated_data));
</span></td></tr><tr><td>21</td><td><span>  </span><span>if </span><span>( encrypted_data_len &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>22</td><td><span>  {
</span></td></tr><tr><td>23</td><td><span>LABEL_13:
</span></td></tr><tr><td>24</td><td><span>    *bytes_written = output_index;
</span></td></tr><tr><td>25</td><td><span>    </span><span>return </span><span>0</span><span>;
</span></td></tr><tr><td>26</td><td><span>  }
</span></td></tr><tr><td>27</td><td><span>  </span><span>else
</span></td></tr><tr><td>28</td><td><span>  {
</span></td></tr><tr><td>29</td><td><span>    </span><span>while </span><span>( </span><span>1 </span><span>)
</span></td></tr><tr><td>30</td><td><span>    {
</span></td></tr><tr><td>31</td><td><span>      block_size = data_len;
</span></td></tr><tr><td>32</td><td><span>      </span><span>if </span><span>( data_len &gt;= </span><span>8 </span><span>)
</span></td></tr><tr><td>33</td><td><span>        block_size = </span><span>8</span><span>;
</span></td></tr><tr><td>34</td><td><span>      remaining_data = data_len - block_size;
</span></td></tr><tr><td>35</td><td><span>
</span></td></tr><tr><td>36</td><td><span>      </span><span>// inflate 1 byte of input data to 8 bytes of its bit representation
</span></td></tr><tr><td>37</td><td><span>      </span><span>for </span><span>( i = </span><span>0</span><span>; i &lt; </span><span>0x40</span><span>; i += </span><span>8 </span><span>)
</span></td></tr><tr><td>38</td><td><span>      {
</span></td></tr><tr><td>39</td><td><span>        encrypted_byte = *encrypted_data;
</span></td></tr><tr><td>40</td><td><span>        inflated_data[i] = (</span><span>unsigned </span><span>__int8)*encrypted_data &gt;&gt; </span><span>7</span><span>;
</span></td></tr><tr><td>41</td><td><span>        inflated_data[i + </span><span>1</span><span>] = (encrypted_byte &amp; </span><span>0x40</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>42</td><td><span>        inflated_data[i + </span><span>2</span><span>] = (encrypted_byte &amp; </span><span>0x20</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>43</td><td><span>        inflated_data[i + </span><span>3</span><span>] = (encrypted_byte &amp; </span><span>0x10</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>44</td><td><span>        inflated_data[i + </span><span>4</span><span>] = (encrypted_byte &amp; </span><span>8</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>45</td><td><span>        inflated_data[i + </span><span>5</span><span>] = (encrypted_byte &amp; </span><span>4</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>46</td><td><span>        inflated_data[i + </span><span>6</span><span>] = (encrypted_byte &amp; </span><span>2</span><span>) != </span><span>0</span><span>;
</span></td></tr><tr><td>47</td><td><span>        inflated_data[i + </span><span>7</span><span>] = encrypted_byte &amp; </span><span>1</span><span>;
</span></td></tr><tr><td>48</td><td><span>        ++encrypted_data;
</span></td></tr><tr><td>49</td><td><span>      }
</span></td></tr><tr><td>50</td><td><span>      </span><span>// do something with the inflated data
</span></td></tr><tr><td>51</td><td><span>      </span><span>sub_407980</span><span>(this, inflated_data, </span><span>0</span><span>);
</span></td></tr><tr><td>52</td><td><span>      </span><span>if </span><span>( block_size )
</span></td></tr><tr><td>53</td><td><span>        </span><span>break</span><span>;
</span></td></tr><tr><td>54</td><td><span>LABEL_12:
</span></td></tr><tr><td>55</td><td><span>      </span><span>if </span><span>( remaining_data &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>56</td><td><span>        </span><span>goto</span><span> LABEL_13;
</span></td></tr><tr><td>57</td><td><span>      data_len = remaining_data;
</span></td></tr><tr><td>58</td><td><span>    }
</span></td></tr><tr><td>59</td><td><span>    </span><span>// deflate the data back to bytes
</span></td></tr><tr><td>60</td><td><span>    idata = &amp;inflated_data[</span><span>1</span><span>];
</span></td></tr><tr><td>61</td><td><span>    </span><span>while </span><span>( </span><span>1 </span><span>)
</span></td></tr><tr><td>62</td><td><span>    {
</span></td></tr><tr><td>63</td><td><span>      --block_size;
</span></td></tr><tr><td>64</td><td><span>      </span><span>if </span><span>( output_index &gt;= output_data_len )
</span></td></tr><tr><td>65</td><td><span>        </span><span>return </span><span>-</span><span>101</span><span>;
</span></td></tr><tr><td>66</td><td><span>      output_data[output_index++] = idata[</span><span>6</span><span>] | (</span><span>2
</span></td></tr><tr><td>67</td><td><span>                                              * (idata[</span><span>5</span><span>] | (</span><span>2
</span></td></tr><tr><td>68</td><td><span>                                                           * (idata[</span><span>4</span><span>] | (</span><span>2
</span></td></tr><tr><td>69</td><td><span>                                                                        * (idata[</span><span>3</span><span>] | (</span><span>2
</span></td></tr><tr><td>70</td><td><span>                                                                                     * (idata[</span><span>2</span><span>] | (</span><span>2
</span></td></tr><tr><td>71</td><td><span>                                                                                                  * (idata[</span><span>1</span><span>] | (</span><span>2 </span><span>* (*idata | (</span><span>2 </span><span>* *(idata - </span><span>1</span><span>))))))))))))));
</span></td></tr><tr><td>72</td><td><span>      idata += </span><span>8</span><span>;
</span></td></tr><tr><td>73</td><td><span>      </span><span>if </span><span>( !block_size )
</span></td></tr><tr><td>74</td><td><span>        </span><span>goto</span><span> LABEL_12;
</span></td></tr><tr><td>75</td><td><span>    }
</span></td></tr><tr><td>76</td><td><span>  }
</span></td></tr><tr><td>77</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>At a high level this routine:</p>
<ol>
<li>Allocates a 64-byte scratch buffer</li>
<li>Checks if there&#39;s any data to process. If not, set the output variable <code>out_data_processed</code> to the number of bytes processed and return 0x0 (<code>STATUS_SUCCESS</code>)</li>
<li>Loop over the input data in 8-byte chunks and inflate each byte to its bit representation.</li>
<li>After the 8-byte chunk is inflated, call <code>sub_407980</code> with the scratch buffer and <code>0</code> as arguments.</li>
<li>Loop over the scratch buffer and reassemble 8 sequential bits as 1 byte, then set the byte at the appropriate index in the output buffer.</li>
</ol>
<p>Lots going on here, but let&#39;s take a look at step #3. If we take the bytes <code>0xAA</code> and <code>0x77</code> which have bit representations of <code>0b1010_1010</code> and <code>0b0111_1111</code> respectively and inflate them to a 16-byte array using the algorithm above, we end up with:</p>
<pre><code><span>| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |    | 8 | 9 | A | B | C | D | E | F |
</span><span>|---|---|---|---|---|---|---|---|----|---|---|---|---|---|---|---|---|
</span><span>| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |    | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
</span></code></pre>
<p>This routine does this process over 8 bytes at a time and completely fills the 64-byte scratch buffer with 1s and 0s just like the table above.</p>
<p>Now let&#39;s look at step #4 and see what&#39;s going on in <code>sub_407980</code>:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>_BYTE *__thiscall </span><span>sub_407980</span><span>(</span><span>void </span><span>*</span><span>this</span><span>, _BYTE *</span><span>a2</span><span>, </span><span>int </span><span>a3</span><span>)
</span></td></tr><tr><td>2</td><td><span>{
</span></td></tr><tr><td>3</td><td><span>  </span><span>// long list of stack vars removed for clarity
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>  v3 = (</span><span>int</span><span>)this;
</span></td></tr><tr><td>6</td><td><span>  v4 = </span><span>15</span><span>;
</span></td></tr><tr><td>7</td><td><span>  v5 = a3;
</span></td></tr><tr><td>8</td><td><span>  v32[</span><span>0</span><span>] = (</span><span>int</span><span>)this;
</span></td></tr><tr><td>9</td><td><span>  v28 = </span><span>0</span><span>;
</span></td></tr><tr><td>10</td><td><span>  v31 = </span><span>15</span><span>;
</span></td></tr><tr><td>11</td><td><span>  </span><span>do
</span></td></tr><tr><td>12</td><td><span>  {
</span></td></tr><tr><td>13</td><td><span>    </span><span>for </span><span>( i = </span><span>0</span><span>; i &lt; </span><span>48</span><span>; *((_BYTE *)&amp;v33 + i + </span><span>3</span><span>) = v18 )
</span></td></tr><tr><td>14</td><td><span>    {
</span></td></tr><tr><td>15</td><td><span>      v7 = v28;
</span></td></tr><tr><td>16</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>17</td><td><span>        v7 = v4;
</span></td></tr><tr><td>18</td><td><span>      v8 = *(_BYTE *)(i + </span><span>48 </span><span>* v7 + v3 + </span><span>4</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E50[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>19</td><td><span>      v9 = v28;
</span></td></tr><tr><td>20</td><td><span>      *(&amp;v34 + i) = v8;
</span></td></tr><tr><td>21</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>22</td><td><span>        v9 = v4;
</span></td></tr><tr><td>23</td><td><span>      v10 = *(_BYTE *)(i + </span><span>48 </span><span>* v9 + v3 + </span><span>5</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E51[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>24</td><td><span>      v11 = v28;
</span></td></tr><tr><td>25</td><td><span>      *(&amp;v35 + i) = v10;
</span></td></tr><tr><td>26</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>27</td><td><span>        v11 = v4;
</span></td></tr><tr><td>28</td><td><span>      v12 = *(_BYTE *)(i + </span><span>48 </span><span>* v11 + v3 + </span><span>6</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E52[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>29</td><td><span>      v13 = v28;
</span></td></tr><tr><td>30</td><td><span>      *(&amp;v36 + i) = v12;
</span></td></tr><tr><td>31</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>32</td><td><span>        v13 = v4;
</span></td></tr><tr><td>33</td><td><span>      v14 = *(_BYTE *)(i + </span><span>48 </span><span>* v13 + v3 + </span><span>7</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E53[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>34</td><td><span>      v15 = v28;
</span></td></tr><tr><td>35</td><td><span>      v38[i - </span><span>1</span><span>] = v14;
</span></td></tr><tr><td>36</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>37</td><td><span>        v15 = v4;
</span></td></tr><tr><td>38</td><td><span>      v16 = *(_BYTE *)(i + </span><span>48 </span><span>* v15 + v3 + </span><span>8</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E54[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>39</td><td><span>      v17 = v28;
</span></td></tr><tr><td>40</td><td><span>      v38[i] = v16;
</span></td></tr><tr><td>41</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>42</td><td><span>        v17 = v4;
</span></td></tr><tr><td>43</td><td><span>      v18 = *(_BYTE *)(i + </span><span>48 </span><span>* v17 + v3 + </span><span>9</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E55[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>44</td><td><span>      i += </span><span>6</span><span>;
</span></td></tr><tr><td>45</td><td><span>    }
</span></td></tr><tr><td>46</td><td><span>    v32[</span><span>1</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_424E80
</span></td></tr><tr><td>47</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>0</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* v34 + </span><span>2</span><span>) | (</span><span>16 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>1</span><span>] + </span><span>2</span><span>) | (</span><span>8 </span><span>* v35 + </span><span>2</span><span>) | (</span><span>4 </span><span>* v36 + </span><span>2</span><span>) | (</span><span>2 </span><span>* v37 + </span><span>2</span><span>)));
</span></td></tr><tr><td>48</td><td><span>    v32[</span><span>2</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_424F80
</span></td></tr><tr><td>49</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>6</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>2</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>50</td><td><span>                                                                                           * (</span><span>unsigned </span><span>__int8)v38[</span><span>7</span><span>]
</span></td></tr><tr><td>51</td><td><span>                                                                                           + </span><span>2</span><span>) | (</span><span>8
</span></td></tr><tr><td>52</td><td><span>                                                                                                 * (</span><span>unsigned </span><span>__int8)v38[</span><span>3</span><span>]
</span></td></tr><tr><td>53</td><td><span>                                                                                                 + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>4</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>5</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>54</td><td><span>    v32[</span><span>3</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425080
</span></td></tr><tr><td>55</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>12</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>8</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>56</td><td><span>                                                                                            * (</span><span>unsigned </span><span>__int8)v38[</span><span>13</span><span>]
</span></td></tr><tr><td>57</td><td><span>                                                                                            + </span><span>2</span><span>) | (</span><span>8 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>9</span><span>]
</span></td></tr><tr><td>58</td><td><span>                                                                                                  + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>10</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>11</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>59</td><td><span>    v32[</span><span>4</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425180
</span></td></tr><tr><td>60</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>18</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>14</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>61</td><td><span>                                                                                             * (</span><span>unsigned </span><span>__int8)v38[</span><span>19</span><span>]
</span></td></tr><tr><td>62</td><td><span>                                                                                             + </span><span>2</span><span>) | (</span><span>8 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>15</span><span>] + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>16</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>17</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>63</td><td><span>    v32[</span><span>5</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425280
</span></td></tr><tr><td>64</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>24</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>20</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>65</td><td><span>                                                                                             * (</span><span>unsigned </span><span>__int8)v38[</span><span>25</span><span>]
</span></td></tr><tr><td>66</td><td><span>                                                                                             + </span><span>2</span><span>) | (</span><span>8 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>21</span><span>] + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>22</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>23</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>67</td><td><span>    v32[</span><span>6</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425380
</span></td></tr><tr><td>68</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>30</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>26</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>69</td><td><span>                                                                                             * (</span><span>unsigned </span><span>__int8)v38[</span><span>31</span><span>]
</span></td></tr><tr><td>70</td><td><span>                                                                                             + </span><span>2</span><span>) | (</span><span>8 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>27</span><span>] + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>28</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>29</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>71</td><td><span>    v32[</span><span>7</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425480
</span></td></tr><tr><td>72</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>36</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>32</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>73</td><td><span>                                                                                             * (</span><span>unsigned </span><span>__int8)v38[</span><span>37</span><span>]
</span></td></tr><tr><td>74</td><td><span>                                                                                             + </span><span>2</span><span>) | (</span><span>8 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>33</span><span>] + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>34</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>35</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>75</td><td><span>    v19 = (</span><span>char </span><span>*)(&amp;unk_425681 - (_UNKNOWN *)a2);
</span></td></tr><tr><td>76</td><td><span>    v20 = &amp;unk_425680 - (_UNKNOWN *)a2;
</span></td></tr><tr><td>77</td><td><span>    v33 = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_425580
</span></td></tr><tr><td>78</td><td><span>                 + (((</span><span>unsigned </span><span>__int8)v38[</span><span>42</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>38</span><span>] + </span><span>2</span><span>) | (</span><span>16
</span></td></tr><tr><td>79</td><td><span>                                                                                          * (</span><span>unsigned </span><span>__int8)v38[</span><span>43</span><span>]
</span></td></tr><tr><td>80</td><td><span>                                                                                          + </span><span>2</span><span>) | (</span><span>8
</span></td></tr><tr><td>81</td><td><span>                                                                                                * (</span><span>unsigned </span><span>__int8)v38[</span><span>39</span><span>]
</span></td></tr><tr><td>82</td><td><span>                                                                                                + </span><span>2</span><span>) | (</span><span>4 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>40</span><span>] + </span><span>2</span><span>) | (</span><span>2 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>41</span><span>] + </span><span>2</span><span>)));
</span></td></tr><tr><td>83</td><td><span>    result = a2;
</span></td></tr><tr><td>84</td><td><span>    </span><span>if </span><span>( v4 &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>85</td><td><span>    {
</span></td></tr><tr><td>86</td><td><span>      v30 = </span><span>8</span><span>;
</span></td></tr><tr><td>87</td><td><span>      </span><span>do
</span></td></tr><tr><td>88</td><td><span>      {
</span></td></tr><tr><td>89</td><td><span>        *result ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[v20] + </span><span>3</span><span>);
</span></td></tr><tr><td>90</td><td><span>        result[</span><span>1</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)v19[(_DWORD)result] + </span><span>3</span><span>);
</span></td></tr><tr><td>91</td><td><span>        result[</span><span>2</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[&amp;unk_425682 - (_UNKNOWN *)a2] + </span><span>3</span><span>);
</span></td></tr><tr><td>92</td><td><span>        result[</span><span>3</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[byte_425683 - a2] + </span><span>3</span><span>);
</span></td></tr><tr><td>93</td><td><span>        result += </span><span>4</span><span>;
</span></td></tr><tr><td>94</td><td><span>        --v30;
</span></td></tr><tr><td>95</td><td><span>      }
</span></td></tr><tr><td>96</td><td><span>      </span><span>while </span><span>( v30 );
</span></td></tr><tr><td>97</td><td><span>    }
</span></td></tr><tr><td>98</td><td><span>    </span><span>else
</span></td></tr><tr><td>99</td><td><span>    {
</span></td></tr><tr><td>100</td><td><span>      v29 = </span><span>8</span><span>;
</span></td></tr><tr><td>101</td><td><span>      </span><span>do
</span></td></tr><tr><td>102</td><td><span>      {
</span></td></tr><tr><td>103</td><td><span>        v24 = result[</span><span>32</span><span>];
</span></td></tr><tr><td>104</td><td><span>        v22 = *result ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[v20] + </span><span>3</span><span>);
</span></td></tr><tr><td>105</td><td><span>        result += </span><span>4</span><span>;
</span></td></tr><tr><td>106</td><td><span>        result[</span><span>28</span><span>] = v22;
</span></td></tr><tr><td>107</td><td><span>        *(result - </span><span>4</span><span>) = v24;
</span></td></tr><tr><td>108</td><td><span>        v25 = result[</span><span>29</span><span>];
</span></td></tr><tr><td>109</td><td><span>        result[</span><span>29</span><span>] = *(result - </span><span>3</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[(_DWORD)v19 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>110</td><td><span>        *(result - </span><span>3</span><span>) = v25;
</span></td></tr><tr><td>111</td><td><span>        v26 = result[</span><span>30</span><span>];
</span></td></tr><tr><td>112</td><td><span>        result[</span><span>30</span><span>] = *(result - </span><span>2</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[&amp;unk_425682 - (_UNKNOWN *)a2 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>113</td><td><span>        *(result - </span><span>2</span><span>) = v26;
</span></td></tr><tr><td>114</td><td><span>        v27 = result[</span><span>31</span><span>];
</span></td></tr><tr><td>115</td><td><span>        result[</span><span>31</span><span>] = *(result - </span><span>1</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[byte_425683 - a2 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>116</td><td><span>        *(result - </span><span>1</span><span>) = v27;
</span></td></tr><tr><td>117</td><td><span>        --v29;
</span></td></tr><tr><td>118</td><td><span>      }
</span></td></tr><tr><td>119</td><td><span>      </span><span>while </span><span>( v29 );
</span></td></tr><tr><td>120</td><td><span>    }
</span></td></tr><tr><td>121</td><td><span>    v5 = a3;
</span></td></tr><tr><td>122</td><td><span>    v3 = v32[</span><span>0</span><span>];
</span></td></tr><tr><td>123</td><td><span>    v4 = v31 - </span><span>1</span><span>;
</span></td></tr><tr><td>124</td><td><span>    v23 = v31 - </span><span>1 </span><span>&lt;= -</span><span>1</span><span>;
</span></td></tr><tr><td>125</td><td><span>    ++v28;
</span></td></tr><tr><td>126</td><td><span>    --v31;
</span></td></tr><tr><td>127</td><td><span>  }
</span></td></tr><tr><td>128</td><td><span>  </span><span>while </span><span>( !v23 );
</span></td></tr><tr><td>129</td><td><span>  </span><span>return</span><span> result;
</span></td></tr><tr><td>130</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>Oof. This is substantially more complicated but looks like the meat of the decryption algorithm. We&#39;ll refer to this function, <code>sub_407980</code>, as <code>decrypt_data</code> from here on out. We can see what may be an immediate roadblock: this function takes in a C++ <code>this</code> pointer (line 5) and performs bitwise operations on one of its members (line 18, 23, etc.). For now let&#39;s call this class member <code>key</code> and come back to it later.</p>
<p>This function is the perfect example of decompilers emitting less than ideal code as a result of compiler optimizations/code reordering. For me, TTD was essential for following how data flows through this function. It took a few hours of banging my head against IDA and WinDbg to understand, but this function can be broken up into 3 high-level phases:</p>
<ol>
<li>Building a 48-byte buffer containing our key material XOR&#39;d with data from a static table.</li>
</ol>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>  </span><span>int</span><span> v33;
</span></td></tr><tr><td>2</td><td><span>  </span><span>unsigned </span><span>__int8 v34; </span><span>// [esp+44h] [ebp-34h]
</span></td></tr><tr><td>3</td><td><span>  </span><span>unsigned </span><span>__int8 v35; </span><span>// [esp+45h] [ebp-33h]
</span></td></tr><tr><td>4</td><td><span>  </span><span>unsigned </span><span>__int8 v36; </span><span>// [esp+46h] [ebp-32h]
</span></td></tr><tr><td>5</td><td><span>  </span><span>unsigned </span><span>__int8 v37; </span><span>// [esp+47h] [ebp-31h]
</span></td></tr><tr><td>6</td><td><span>  </span><span>char</span><span> v38[</span><span>44</span><span>]; </span><span>// [esp+48h] [ebp-30h]
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>  v3 = (</span><span>int</span><span>)this;
</span></td></tr><tr><td>9</td><td><span>  v4 = </span><span>15</span><span>;
</span></td></tr><tr><td>10</td><td><span>  v5 = a3;
</span></td></tr><tr><td>11</td><td><span>  v32[</span><span>0</span><span>] = (</span><span>int</span><span>)this;
</span></td></tr><tr><td>12</td><td><span>  v28 = </span><span>0</span><span>;
</span></td></tr><tr><td>13</td><td><span>  v31 = </span><span>15</span><span>;
</span></td></tr><tr><td>14</td><td><span>  </span><span>do
</span></td></tr><tr><td>15</td><td><span>  {
</span></td></tr><tr><td>16</td><td><span>    </span><span>// The end statement of this loop is strange -- it&#39;s writing a byte somewhere? come back
</span></td></tr><tr><td>17</td><td><span>    </span><span>// to this later
</span></td></tr><tr><td>18</td><td><span>    </span><span>for </span><span>( i = </span><span>0</span><span>; i &lt; </span><span>48</span><span>; *((_BYTE *)&amp;v33 + i + </span><span>3</span><span>) = v18 )
</span></td></tr><tr><td>19</td><td><span>    {
</span></td></tr><tr><td>20</td><td><span>    </span><span>// v28 Starts at 0 but is incremented by 1 during each iteration of the outer `while` loop
</span></td></tr><tr><td>21</td><td><span>      v7 = v28;
</span></td></tr><tr><td>22</td><td><span>      </span><span>// v5 is our last argument which was 0
</span></td></tr><tr><td>23</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>24</td><td><span>        </span><span>// overwrite v7 with v4, which begins at 15 but is decremented by 1 during each iteration
</span></td></tr><tr><td>25</td><td><span>        </span><span>// of the outer `while` loop
</span></td></tr><tr><td>26</td><td><span>        v7 = v4;
</span></td></tr><tr><td>27</td><td><span>      </span><span>// left-hand side of the xor, *(_BYTE *)(i + 48 * v7 + v3 + 4)
</span></td></tr><tr><td>28</td><td><span>      </span><span>//     v3 in this context is our `this` pointer + 4, giving us *(_BYTE *)(i + (48 * v7) + this-&gt;maybe_key)
</span></td></tr><tr><td>29</td><td><span>      </span><span>//     so the left-hand side of the xor is likely indexing into our key material:
</span></td></tr><tr><td>30</td><td><span>      </span><span>//     this-&gt;maybe_key[i + 48 * loop_multiplier]
</span></td></tr><tr><td>31</td><td><span>      </span><span>//
</span></td></tr><tr><td>32</td><td><span>      </span><span>// right-hand side of the xor, a2[(unsigned __int8)byte_424E50[i] + 31]
</span></td></tr><tr><td>33</td><td><span>      </span><span>//     a2 is our input encrypted data, and byte_424E50 is some static data
</span></td></tr><tr><td>34</td><td><span>      </span><span>//
</span></td></tr><tr><td>35</td><td><span>      </span><span>// this full statement can be rewritten as:
</span></td></tr><tr><td>36</td><td><span>      </span><span>//     v8 = this-&gt;maybe_key[i + 48 * loop_multiplier] ^ encrypted_data[byte_424E50[i] + 31]
</span></td></tr><tr><td>37</td><td><span>      v8 = *(_BYTE *)(i + </span><span>48 </span><span>* v7 + v3 + </span><span>4</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E50[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>38</td><td><span>
</span></td></tr><tr><td>39</td><td><span>      v9 = v28;
</span></td></tr><tr><td>40</td><td><span>
</span></td></tr><tr><td>41</td><td><span>      </span><span>// write the result of `key_data ^ input_data` to a scratch buffer (v34)
</span></td></tr><tr><td>42</td><td><span>      </span><span>// v34 looks to be declared as the wrong type. v33 is actually a 52-byte buffer
</span></td></tr><tr><td>43</td><td><span>      *(&amp;v34 + i) = v8;
</span></td></tr><tr><td>44</td><td><span>
</span></td></tr><tr><td>45</td><td><span>      </span><span>// repeat the above 5 more times
</span></td></tr><tr><td>46</td><td><span>      </span><span>if </span><span>( !v5 )
</span></td></tr><tr><td>47</td><td><span>        v9 = v4;
</span></td></tr><tr><td>48</td><td><span>      v10 = *(_BYTE *)(i + </span><span>48 </span><span>* v9 + v3 + </span><span>5</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E51[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>49</td><td><span>      v11 = v28;
</span></td></tr><tr><td>50</td><td><span>      *(&amp;v35 + i) = v10;
</span></td></tr><tr><td>51</td><td><span>
</span></td></tr><tr><td>52</td><td><span>      </span><span>// snip
</span></td></tr><tr><td>53</td><td><span>
</span></td></tr><tr><td>54</td><td><span>      </span><span>// v18 gets written to the scratch buffer at the end of the loop...
</span></td></tr><tr><td>55</td><td><span>      v18 = *(_BYTE *)(i + </span><span>48 </span><span>* v17 + v3 + </span><span>9</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E55[i] + </span><span>31</span><span>];
</span></td></tr><tr><td>56</td><td><span>
</span></td></tr><tr><td>57</td><td><span>      </span><span>// this was probably the *real* last statement of the for-loop
</span></td></tr><tr><td>58</td><td><span>      </span><span>// i.e. for (int i = 0; i &lt; 48; i += 6)
</span></td></tr><tr><td>59</td><td><span>      i += </span><span>6</span><span>;
</span></td></tr><tr><td>60</td><td><span>    }
</span></td></tr></tbody></table></code></pre>
<ol start="2">
<li>Build a 32-byte buffer containing data from an 0x800-byte static table, with indexes into this table originating from indices built from the buffer in step #1. Combine this 32-byte buffer with the 48-byte buffer in step #1.</li>
</ol>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>    </span><span>// dword_424E80 -- some static data
</span></td></tr><tr><td>2</td><td><span>    </span><span>// (unsigned __int8)v38[0] + 2) -- the original decompiler output has this wrong.
</span></td></tr><tr><td>3</td><td><span>    </span><span>//     v33 should be a 52-byte buffer which consumes v38, so v38 is actually data set up in
</span></td></tr><tr><td>4</td><td><span>    </span><span>//     the loop above.
</span></td></tr><tr><td>5</td><td><span>    </span><span>// (32 * v34 + 2) -- v34 should be some data from the above loop as well. This looks like
</span></td></tr><tr><td>6</td><td><span>    </span><span>//     a binary shift optimization
</span></td></tr><tr><td>7</td><td><span>    </span><span>// repeat with different multipliers...
</span></td></tr><tr><td>8</td><td><span>    </span><span>//
</span></td></tr><tr><td>9</td><td><span>    </span><span>// This can be simplified as:
</span></td></tr><tr><td>10</td><td><span>    </span><span>//     size_t index  = ((v34 &lt;&lt; 5) + 2)
</span></td></tr><tr><td>11</td><td><span>    </span><span>//                     | ((v37[1] &lt;&lt; 4) + 2)
</span></td></tr><tr><td>12</td><td><span>    </span><span>//                     | ((v35 &lt;&lt; 3) + 2)
</span></td></tr><tr><td>13</td><td><span>    </span><span>//                     | ((v36 &lt;&lt; 2) + 2)
</span></td></tr><tr><td>14</td><td><span>    </span><span>//                     | ((v37 &lt;&lt; 1) + 2)
</span></td></tr><tr><td>15</td><td><span>    </span><span>//                     | v38[0]
</span></td></tr><tr><td>16</td><td><span>    </span><span>//     v32[1] = *(int*)(((char*)&amp;dword_424e80)[index])
</span></td></tr><tr><td>17</td><td><span>    v32[</span><span>1</span><span>] = *(</span><span>int </span><span>*)((</span><span>char </span><span>*)&amp;dword_424E80
</span></td></tr><tr><td>18</td><td><span>                    + (((</span><span>unsigned </span><span>__int8)v38[</span><span>0</span><span>] + </span><span>2</span><span>) | (</span><span>32 </span><span>* v34 + </span><span>2</span><span>) | (</span><span>16 </span><span>* (</span><span>unsigned </span><span>__int8)v38[</span><span>1</span><span>] + </span><span>2</span><span>) | (</span><span>8 </span><span>* v35 + </span><span>2</span><span>) | (</span><span>4 </span><span>* v36 + </span><span>2</span><span>) | (</span><span>2 </span><span>* v37 + </span><span>2</span><span>)));
</span></td></tr><tr><td>19</td><td><span>    </span><span>// repeat 7 times. each time the reference to dword_424e80 is shifted forward by 0x100.
</span></td></tr><tr><td>20</td><td><span>    </span><span>// note: if you do the math, the next line uses dword_424e80[64]. We shift by 0x100 instead of
</span></td></tr><tr><td>21</td><td><span>    </span><span>// 64 because is misleading because dword_424e80 is declared as an int array -- not a char array.
</span></td></tr></tbody></table></code></pre>
<ol start="3">
<li>Iterate over the next 8 bytes of the output buffer. For each byte index of the output buffer, index into yet <em>another</em> static 32-byte buffer and use that as the index into the table from step #2. XOR this value with the value at the current index of the output buffer.</li>
</ol>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>// Not really sure why this calculation works like this. It ends up just being `unk_425681`&#39;s address
</span></td></tr><tr><td>2</td><td><span>// when it&#39;s used.
</span></td></tr><tr><td>3</td><td><span>    v19 = (</span><span>char </span><span>*)(&amp;unk_425681 - (_UNKNOWN *)a2);
</span></td></tr><tr><td>4</td><td><span>    v20 = &amp;unk_425680 - (_UNKNOWN *)a2;
</span></td></tr><tr><td>5</td><td><span>
</span></td></tr><tr><td>6</td><td><span>// v4 is a number that&#39;s decremented on every iteration -- possibly bytes remaining?
</span></td></tr><tr><td>7</td><td><span>    </span><span>if </span><span>( v4 &lt;= </span><span>0 </span><span>)
</span></td></tr><tr><td>8</td><td><span>    {
</span></td></tr><tr><td>9</td><td><span>        </span><span>// Loop over 8 bytes
</span></td></tr><tr><td>10</td><td><span>      v30 = </span><span>8</span><span>;
</span></td></tr><tr><td>11</td><td><span>      </span><span>do
</span></td></tr><tr><td>12</td><td><span>      {
</span></td></tr><tr><td>13</td><td><span>        </span><span>// Start XORing the output bytes with some of the data generated in step 2.
</span></td></tr><tr><td>14</td><td><span>        </span><span>//
</span></td></tr><tr><td>15</td><td><span>        </span><span>// Cheating here and doing the &#34;draw the rest of the owl&#34;, but if you observe that
</span></td></tr><tr><td>16</td><td><span>        </span><span>// we use `unk_425680` (v20), `unk_425681` (v19), `unk_425682`, and byte_425683, the
</span></td></tr><tr><td>17</td><td><span>        </span><span>// the decompiler generated suboptimal code. We can simplify to be relative to just
</span></td></tr><tr><td>18</td><td><span>        </span><span>// `unk_425680`
</span></td></tr><tr><td>19</td><td><span>        </span><span>//
</span></td></tr><tr><td>20</td><td><span>        </span><span>// *result ^= step2_bytes[unk_425680[output_index] - 1]
</span></td></tr><tr><td>21</td><td><span>        *result ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[v20] + </span><span>3</span><span>);
</span></td></tr><tr><td>22</td><td><span>
</span></td></tr><tr><td>23</td><td><span>        </span><span>// result[1] ^= step2_bytes[unk_425680[output_index] + 1]
</span></td></tr><tr><td>24</td><td><span>        result[</span><span>1</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)v19[(_DWORD)result] + </span><span>3</span><span>);
</span></td></tr><tr><td>25</td><td><span>
</span></td></tr><tr><td>26</td><td><span>        </span><span>// result[2] ^= step2_bytes[unk_425680[output_index] + 2]
</span></td></tr><tr><td>27</td><td><span>        result[</span><span>2</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[&amp;unk_425682 - (_UNKNOWN *)a2] + </span><span>3</span><span>);
</span></td></tr><tr><td>28</td><td><span>
</span></td></tr><tr><td>29</td><td><span>        </span><span>// result[3] ^= step2_bytes[unk_425680[output_index] + 3]
</span></td></tr><tr><td>30</td><td><span>        result[</span><span>3</span><span>] ^= *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[byte_425683 - a2] + </span><span>3</span><span>);
</span></td></tr><tr><td>31</td><td><span>        </span><span>// Move our our pointer to the output buffer forward by 4 bytes
</span></td></tr><tr><td>32</td><td><span>        result += </span><span>4</span><span>;
</span></td></tr><tr><td>33</td><td><span>        --v30;
</span></td></tr><tr><td>34</td><td><span>      }
</span></td></tr><tr><td>35</td><td><span>      </span><span>while </span><span>( v30 );
</span></td></tr><tr><td>36</td><td><span>    }
</span></td></tr><tr><td>37</td><td><span>    </span><span>else
</span></td></tr><tr><td>38</td><td><span>    {
</span></td></tr><tr><td>39</td><td><span>        </span><span>// loop over 8 bytes
</span></td></tr><tr><td>40</td><td><span>      v29 = </span><span>8</span><span>;
</span></td></tr><tr><td>41</td><td><span>      </span><span>do
</span></td></tr><tr><td>42</td><td><span>      {
</span></td></tr><tr><td>43</td><td><span>        </span><span>// grab the byte at 0x20, we&#39;re swapping this later
</span></td></tr><tr><td>44</td><td><span>        v24 = result[</span><span>32</span><span>];
</span></td></tr><tr><td>45</td><td><span>
</span></td></tr><tr><td>46</td><td><span>        </span><span>// v22 = *result ^ step2_bytes[unk_425680[output_index] - 1]
</span></td></tr><tr><td>47</td><td><span>        v22 = *result ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[v20] + </span><span>3</span><span>);
</span></td></tr><tr><td>48</td><td><span>
</span></td></tr><tr><td>49</td><td><span>        </span><span>// I&#39;m not sure why the output buffer pointer is incremented here, but
</span></td></tr><tr><td>50</td><td><span>        </span><span>// this really makes the code ugly
</span></td></tr><tr><td>51</td><td><span>        result += </span><span>4</span><span>;
</span></td></tr><tr><td>52</td><td><span>
</span></td></tr><tr><td>53</td><td><span>        </span><span>// Write the byte generated above to offset 0x1c
</span></td></tr><tr><td>54</td><td><span>        result[</span><span>28</span><span>] = v22;
</span></td></tr><tr><td>55</td><td><span>        </span><span>// Write the byte at 0x20 to offset 0
</span></td></tr><tr><td>56</td><td><span>        *(result - </span><span>4</span><span>) = v24;
</span></td></tr><tr><td>57</td><td><span>
</span></td></tr><tr><td>58</td><td><span>        </span><span>// rinse, repeat with slightly different offsets each time...
</span></td></tr><tr><td>59</td><td><span>        v25 = result[</span><span>29</span><span>];
</span></td></tr><tr><td>60</td><td><span>        result[</span><span>29</span><span>] = *(result - </span><span>3</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[(_DWORD)v19 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>61</td><td><span>        *(result - </span><span>3</span><span>) = v25;
</span></td></tr><tr><td>62</td><td><span>        v26 = result[</span><span>30</span><span>];
</span></td></tr><tr><td>63</td><td><span>        result[</span><span>30</span><span>] = *(result - </span><span>2</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[&amp;unk_425682 - (_UNKNOWN *)a2 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>64</td><td><span>        *(result - </span><span>2</span><span>) = v26;
</span></td></tr><tr><td>65</td><td><span>        v27 = result[</span><span>31</span><span>];
</span></td></tr><tr><td>66</td><td><span>        result[</span><span>31</span><span>] = *(result - </span><span>1</span><span>) ^ *((_BYTE *)v32 + (</span><span>unsigned </span><span>__int8)result[byte_425683 - a2 - </span><span>4</span><span>] + </span><span>3</span><span>);
</span></td></tr><tr><td>67</td><td><span>        *(result - </span><span>1</span><span>) = v27;
</span></td></tr><tr><td>68</td><td><span>        --v29;
</span></td></tr><tr><td>69</td><td><span>      }
</span></td></tr><tr><td>70</td><td><span>      </span><span>while </span><span>( v29 );
</span></td></tr><tr><td>71</td><td><span>    }
</span></td></tr></tbody></table></code></pre>
<p>The inner loop in the <code>else</code> branch above I think is kind of nasty, so here it is reimplemented in Rust:</p>
<pre data-linenos="" data-lang="rust"><code data-lang="rust"><table><tbody><tr><td>1</td><td><span>for </span><span>_ in </span><span>0</span><span>..</span><span>8 </span><span>{
</span></td></tr><tr><td>2</td><td><span>    </span><span>// we swap the `first` index with the `second`
</span></td></tr><tr><td>3</td><td><span>    </span><span>for </span><span>(first, second) in (</span><span>0x1c</span><span>..=</span><span>0x1f</span><span>).</span><span>zip</span><span>(</span><span>0</span><span>..</span><span>4</span><span>) {
</span></td></tr><tr><td>4</td><td><span>        </span><span>let</span><span> original_byte_idx = first + output_offset + </span><span>4</span><span>;
</span></td></tr><tr><td>5</td><td><span>
</span></td></tr><tr><td>6</td><td><span>        </span><span>let</span><span> original_byte = outbuf[original_byte_idx];
</span></td></tr><tr><td>7</td><td><span>
</span></td></tr><tr><td>8</td><td><span>        </span><span>let</span><span> constant = unk_425680[output_offset + second] as </span><span>usize</span><span>;
</span></td></tr><tr><td>9</td><td><span>
</span></td></tr><tr><td>10</td><td><span>        </span><span>let</span><span> new_byte = outbuf[output_offset + second] ^ generated_bytes_from_step2[constant - </span><span>1</span><span>];
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>        </span><span>let</span><span> new_idx = original_byte_idx;
</span></td></tr><tr><td>13</td><td><span>        outbuf[new_idx] = new_byte;
</span></td></tr><tr><td>14</td><td><span>        outbuf[output_offset + second] = original_byte;
</span></td></tr><tr><td>15</td><td><span>    }
</span></td></tr><tr><td>16</td><td><span>
</span></td></tr><tr><td>17</td><td><span>    output_offset += </span><span>4</span><span>;
</span></td></tr><tr><td>18</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<h3 id="key-setup"><a href="#key-setup" aria-label="Anchor link for: key-setup">#</a>
Key Setup</h3>
<p>We now need to figure out how our key is set up for usage in the <code>decrypt_data</code> function above. My approach here is to set a breakpoint at the first instruction to use the key data in <code>decrypt_data</code>, which happens to be <code>xor bl, [ecx + esi + 4]</code> at <code>0x4079d3</code>. I know this is where we should break because in the decompiler output the left-hand side of the XOR operation, the key material, will be the <em>second</em> operand in the <code>xor</code> instruction. As a reminder, the decompiler shows the XOR as:</p>
<pre data-lang="c"><code data-lang="c"><span>v8 = *(_BYTE *)(i + </span><span>48 </span><span>* v7 + v3 + </span><span>4</span><span>) ^ a2[(</span><span>unsigned </span><span>__int8)byte_424E50[i] + </span><span>31</span><span>];
</span></code></pre>
<p>The breakpoint is hit and the address we&#39;re loading from is <code>0x19f5c4</code>. We can now lean on TTD to help us figure out where this data was last written. Set a 1-byte memory write breakpoint at this address using <code>ba w1 0x19f5c4</code> and press the <code>Go Back</code> button. If you&#39;ve never used TTD before, this operates exactly as <code>Go</code> would except <em>backwards</em> in the program&#39;s trace. In this case it will execute backward until either a breakpoint is hit, interrupt is generated, or we reach the start of the program.</p>
<p>Our memory write breakpoint gets triggered at <code>0x4078fb</code> -- a function we haven&#39;t seen before. The callstack shows that it&#39;s called not terribly far from the <code>decrypt_update_info</code> routine!</p>
<ul>
<li><code>set_key</code> (we are here -- function is originally called <code>sub_407850</code>)</li>
<li><code>sub_4082c0</code></li>
<li><code>decrypt_update_info</code></li>
</ul>
<p>What&#39;s <code>sub_4082c0</code>?</p>

<a href="https://landaire.net/img/yaesu/timestamp_inflation.png"><img src="https://landaire.net/processed_images/timestamp_inflation.5e46a11b487ec708.png"/></a>
<p>Not a lot to see here except the same function called 4 times, initially with the timestamp string as an argument in position 0, a 64-byte buffer, and bunch of function calls using the return value of the last as its input. The function our debugger just broke into takes only 1 argument, which is the 64-byte buffer used across <em>all</em> of these function calls. So what&#39;s going on in <code>sub_407e80</code>?</p>

<a href="https://landaire.net/img/yaesu/inflate_timestamp.png"><img src="https://landaire.net/processed_images/inflate_timestamp.65ac73080c0654a8.png"/></a>
<p>The bitwise operations that look supsiciously similar to the byte to bit inflation we saw above with the firmware data. After renaming things and performing some loop unrolling, things look like this:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>// sub_407850
</span></td></tr><tr><td>2</td><td><span>int </span><span>inflate_timestamp</span><span>(</span><span>void </span><span>*</span><span>this</span><span>, </span><span>char </span><span>*</span><span>timestamp_str</span><span>, </span><span>char </span><span>*</span><span>output</span><span>, uint8_t *</span><span>key</span><span>) {
</span></td></tr><tr><td>3</td><td><span>    </span><span>for </span><span>(size_t output_idx = </span><span>0</span><span>; output_idx &lt; </span><span>8</span><span>; output_idx++) {
</span></td></tr><tr><td>4</td><td><span>        uint8_t ts_byte = *timestamp_str;
</span></td></tr><tr><td>5</td><td><span>        </span><span>if </span><span>(ts_byte) {
</span></td></tr><tr><td>6</td><td><span>            timestamp_str += </span><span>1</span><span>;
</span></td></tr><tr><td>7</td><td><span>        }
</span></td></tr><tr><td>8</td><td><span>
</span></td></tr><tr><td>9</td><td><span>        </span><span>for </span><span>(</span><span>int</span><span> bit_idx = </span><span>0</span><span>; bit_idx &lt; </span><span>8</span><span>; bit_idx++) {
</span></td></tr><tr><td>10</td><td><span>            uint8_t bit_value = (ts_byte &gt;&gt; (</span><span>7 </span><span>- bit_idx)) &amp; </span><span>1</span><span>;
</span></td></tr><tr><td>11</td><td><span>            output[(output_idx * </span><span>8</span><span>) + bit_idx] ^= bit_value;
</span></td></tr><tr><td>12</td><td><span>        }
</span></td></tr><tr><td>13</td><td><span>    }
</span></td></tr><tr><td>14</td><td><span>
</span></td></tr><tr><td>15</td><td><span>    </span><span>set_key</span><span>(this, key);
</span></td></tr><tr><td>16</td><td><span>    </span><span>decrypt_data</span><span>(this, output, </span><span>1</span><span>);
</span></td></tr><tr><td>17</td><td><span>
</span></td></tr><tr><td>18</td><td><span>    </span><span>return</span><span> timestamp_str;
</span></td></tr><tr><td>19</td><td><span>}
</span></td></tr><tr><td>20</td><td><span>
</span></td></tr><tr><td>21</td><td><span>// sub_4082c0
</span></td></tr><tr><td>22</td><td><span>int </span><span>set_key_to_timestamp</span><span>(</span><span>void </span><span>*</span><span>this</span><span>, </span><span>char </span><span>*</span><span>timestamp_str</span><span>) {
</span></td></tr><tr><td>23</td><td><span>    uint8_t key_buf[</span><span>64</span><span>];
</span></td></tr><tr><td>24</td><td><span>    </span><span>memset</span><span>(&amp;key_buf, </span><span>0</span><span>, sizeof(key_buf));
</span></td></tr><tr><td>25</td><td><span>
</span></td></tr><tr><td>26</td><td><span>    </span><span>char </span><span>*str_ptr = </span><span>inflate_timestamp</span><span>(this, timestamp_str, &amp;key_buf, &amp;static_key_1);
</span></td></tr><tr><td>27</td><td><span>    str_ptr = </span><span>inflate_timestamp</span><span>(this, str_ptr, &amp;key_buf, &amp;static_key_2);
</span></td></tr><tr><td>28</td><td><span>    str_ptr = </span><span>inflate_timestamp</span><span>(this, str_ptr, &amp;key_buf, &amp;static_key_3);
</span></td></tr><tr><td>29</td><td><span>    </span><span>inflate_timestamp</span><span>(this, str_ptr, &amp;key_buf, &amp;static_key_4);
</span></td></tr><tr><td>30</td><td><span>
</span></td></tr><tr><td>31</td><td><span>    </span><span>set_key</span><span>(this, &amp;key_buf);
</span></td></tr><tr><td>32</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>The only mystery now is the <code>set_key</code> routine:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>int</span><span> __thiscall </span><span>set_key</span><span>(</span><span>char </span><span>*</span><span>this</span><span>, </span><span>const void </span><span>*</span><span>a2</span><span>)
</span></td></tr><tr><td>2</td><td><span>{
</span></td></tr><tr><td>3</td><td><span>  _DWORD *v2; </span><span>// ebp
</span></td></tr><tr><td>4</td><td><span>  </span><span>char </span><span>*v3; </span><span>// edx
</span></td></tr><tr><td>5</td><td><span>  </span><span>char</span><span> v4; </span><span>// al
</span></td></tr><tr><td>6</td><td><span>  </span><span>char</span><span> v5; </span><span>// al
</span></td></tr><tr><td>7</td><td><span>  </span><span>char</span><span> v6; </span><span>// al
</span></td></tr><tr><td>8</td><td><span>  </span><span>char</span><span> v7; </span><span>// al
</span></td></tr><tr><td>9</td><td><span>  </span><span>int</span><span> result; </span><span>// eax
</span></td></tr><tr><td>10</td><td><span>  </span><span>char</span><span> v10[</span><span>56</span><span>]; </span><span>// [esp+Ch] [ebp-3Ch] BYREF
</span></td></tr><tr><td>11</td><td><span>
</span></td></tr><tr><td>12</td><td><span>  </span><span>qmemcpy</span><span>(v10, a2, sizeof(v10));
</span></td></tr><tr><td>13</td><td><span>  v2 = &amp;unk_424DE0;
</span></td></tr><tr><td>14</td><td><span>  v3 = this + </span><span>5</span><span>;
</span></td></tr><tr><td>15</td><td><span>  </span><span>do
</span></td></tr><tr><td>16</td><td><span>  {
</span></td></tr><tr><td>17</td><td><span>    v4 = v10[</span><span>0</span><span>];
</span></td></tr><tr><td>18</td><td><span>    </span><span>qmemcpy</span><span>(v10, &amp;v10[</span><span>1</span><span>], </span><span>0x1B</span><span>u</span><span>);
</span></td></tr><tr><td>19</td><td><span>    v10[</span><span>27</span><span>] = v4;
</span></td></tr><tr><td>20</td><td><span>    v5 = v10[</span><span>28</span><span>];
</span></td></tr><tr><td>21</td><td><span>    </span><span>qmemcpy</span><span>(&amp;v10[</span><span>28</span><span>], &amp;v10[</span><span>29</span><span>], </span><span>0x1B</span><span>u</span><span>);
</span></td></tr><tr><td>22</td><td><span>    v10[</span><span>55</span><span>] = v5;
</span></td></tr><tr><td>23</td><td><span>    </span><span>if </span><span>( *v2 == </span><span>2 </span><span>)
</span></td></tr><tr><td>24</td><td><span>    {
</span></td></tr><tr><td>25</td><td><span>      v6 = v10[</span><span>0</span><span>];
</span></td></tr><tr><td>26</td><td><span>      </span><span>qmemcpy</span><span>(v10, &amp;v10[</span><span>1</span><span>], </span><span>0x1B</span><span>u</span><span>);
</span></td></tr><tr><td>27</td><td><span>      v10[</span><span>27</span><span>] = v6;
</span></td></tr><tr><td>28</td><td><span>      v7 = v10[</span><span>28</span><span>];
</span></td></tr><tr><td>29</td><td><span>      </span><span>qmemcpy</span><span>(&amp;v10[</span><span>28</span><span>], &amp;v10[</span><span>29</span><span>], </span><span>0x1B</span><span>u</span><span>);
</span></td></tr><tr><td>30</td><td><span>      v10[</span><span>55</span><span>] = v7;
</span></td></tr><tr><td>31</td><td><span>    }
</span></td></tr><tr><td>32</td><td><span>    </span><span>for </span><span>( result = </span><span>0</span><span>; result &lt; </span><span>48</span><span>; result += </span><span>6 </span><span>)
</span></td></tr><tr><td>33</td><td><span>    {
</span></td></tr><tr><td>34</td><td><span>      v3[result - </span><span>1</span><span>] = v10[(</span><span>unsigned </span><span>__int8)byte_424E20[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>35</td><td><span>      v3[result] = v10[(</span><span>unsigned </span><span>__int8)byte_424E21[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>36</td><td><span>      v3[result + </span><span>1</span><span>] = v10[(</span><span>unsigned </span><span>__int8)byte_424E22[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>37</td><td><span>      v3[result + </span><span>2</span><span>] = v10[(</span><span>unsigned </span><span>__int8)byte_424E23[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>38</td><td><span>      v3[result + </span><span>3</span><span>] = v10[(</span><span>unsigned </span><span>__int8)byte_424E24[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>39</td><td><span>      v3[result + </span><span>4</span><span>] = v10[(</span><span>unsigned </span><span>__int8)byte_424E25[result] - </span><span>1</span><span>];
</span></td></tr><tr><td>40</td><td><span>    }
</span></td></tr><tr><td>41</td><td><span>    ++v2;
</span></td></tr><tr><td>42</td><td><span>    v3 += </span><span>48</span><span>;
</span></td></tr><tr><td>43</td><td><span>  }
</span></td></tr><tr><td>44</td><td><span>  </span><span>while </span><span>( (</span><span>int</span><span>)v2 &lt; (</span><span>int</span><span>)byte_424E20 );
</span></td></tr><tr><td>45</td><td><span>  </span><span>return</span><span> result;
</span></td></tr><tr><td>46</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>This function is a bit more straightforward to reimplement:</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1</td><td><span>void </span><span>set_key</span><span>(</span><span>void </span><span>*</span><span>this</span><span>, uint8_t *</span><span>key</span><span>) {
</span></td></tr><tr><td>2</td><td><span>    uint8_t scrambled_key[</span><span>56</span><span>];
</span></td></tr><tr><td>3</td><td><span>    </span><span>memcpy</span><span>(&amp;scrambled_key, key, sizeof(scrambled_key));
</span></td></tr><tr><td>4</td><td><span>
</span></td></tr><tr><td>5</td><td><span>    </span><span>for </span><span>(size_t i = </span><span>0</span><span>; i &lt; </span><span>16</span><span>; i++) {
</span></td></tr><tr><td>6</td><td><span>        size_t swap_rounds = </span><span>1</span><span>;
</span></td></tr><tr><td>7</td><td><span>        </span><span>if </span><span>(((uint32_t*)GLOBAL_KEY_ROUNDS_CONFIG)[i] == </span><span>2</span><span>) {
</span></td></tr><tr><td>8</td><td><span>            swap_rounds = </span><span>2</span><span>;
</span></td></tr><tr><td>9</td><td><span>        }
</span></td></tr><tr><td>10</td><td><span>
</span></td></tr><tr><td>11</td><td><span>        </span><span>for </span><span>(</span><span>int</span><span> i = </span><span>0</span><span>; i &lt; swap_rounds; i++) {
</span></td></tr><tr><td>12</td><td><span>            uint8_t temp = scrambled_key[</span><span>0</span><span>];
</span></td></tr><tr><td>13</td><td><span>            </span><span>memcpy</span><span>(&amp;scrambled_key, &amp;scrambled_key[</span><span>1</span><span>], </span><span>27</span><span>);
</span></td></tr><tr><td>14</td><td><span>            scrambled_key[</span><span>27</span><span>] = temp;
</span></td></tr><tr><td>15</td><td><span>
</span></td></tr><tr><td>16</td><td><span>            temp = scrambled_key[</span><span>28</span><span>];
</span></td></tr><tr><td>17</td><td><span>            </span><span>memcpy</span><span>(&amp;scrambled_key[</span><span>28</span><span>], &amp;scrambled_key[</span><span>29</span><span>], </span><span>27</span><span>);
</span></td></tr><tr><td>18</td><td><span>            scrambled_key[</span><span>55</span><span>] = temp;
</span></td></tr><tr><td>19</td><td><span>        }
</span></td></tr><tr><td>20</td><td><span>
</span></td></tr><tr><td>21</td><td><span>        </span><span>for </span><span>(size_t swap_idx = </span><span>0</span><span>; swap_idx &lt; </span><span>48</span><span>; swap_idx++) {
</span></td></tr><tr><td>22</td><td><span>            size_t scrambled_key_idx = GLOBAL_KEY_SWAP_TABLE[swap_idx] - </span><span>1</span><span>;
</span></td></tr><tr><td>23</td><td><span>
</span></td></tr><tr><td>24</td><td><span>            size_t persistent_key_idx = swap_idx + (i * </span><span>48</span><span>);
</span></td></tr><tr><td>25</td><td><span>            this-&gt;key[persistent_key_idx] = scrambled_key[scrambled_key_idx];
</span></td></tr><tr><td>26</td><td><span>        }
</span></td></tr><tr><td>27</td><td><span>    }
</span></td></tr><tr><td>28</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<h3 id="putting-everything-together"><a href="#putting-everything-together" aria-label="Anchor link for: putting-everything-together">#</a>
Putting Everything Together</h3>
<ol>
<li>Update data is read from resources</li>
<li>The first 4 bytes of the update data are a Unix timestamp</li>
<li>The timestamp is formatted as a string, has each byte inflated to its bit representation, and decrypted using some static key material as the key. This is repeated 4 times with the output of the previous run used as an input to the next.</li>
<li>The resulting data from step 3 is used as a key for decrypting data.</li>
<li>The remainder of the firmware update image is inflated to its bit representation 8 bytes at a time and uses the dynamic key and 3 other unique static lookup tables to transform the inflated input data.</li>
<li>The result from step 5 is deflated back into its <em>byte</em> representation.</li>
</ol>
<p>My decryption utility which completely reimplements this magic in Rust can be found at <a href="https://github.com/landaire/porkchop">https://github.com/landaire/porkchop</a>.</p>
<h2 id="loading-the-firmware-in-ida-pro"><a href="#loading-the-firmware-in-ida-pro" aria-label="Anchor link for: loading-the-firmware-in-ida-pro">#</a>
Loading the Firmware in IDA Pro</h2>
<p>IDA thankfully supports disassembling the Hitachi/Rensas H8SX architecture. If we load our firmware into IDA and select the &#34;Hitachi H8SX advanced&#34; processsor type, use the default options for the &#34;Disassembly memory organization&#34; dialog, then finally choose &#34;H8S/2215R&#34; in the &#34;Choose the device name&#34; dialog...:</p>

<a href="https://landaire.net/img/yaesu/rom_initial_load.png"><img src="https://landaire.net/processed_images/rom_initial_load.883b3f9fcc2c1b5d.png"/></a>
<p>We don&#39;t have shit. I&#39;m not an embedded systems expert, but my friend suggested that the first few DWORDs look like they may belong to a vector table. If we right-click address 0 and select &#34;Double word 0x142A&#34;, we can click on the new variable <code>unk_142A</code> to go to its location. Press <code>C</code> at this location to define it as Code, then press <code>P</code> to create a function at this address:</p>

<a href="https://landaire.net/img/yaesu/firmware_analyzed.png"><img src="https://landaire.net/processed_images/firmware_analyzed.7bd41c86909a3a9f.png"/></a>
<p>We can now reverse engineer our firmware :)</p>

</div></div>
  </body>
</html>
