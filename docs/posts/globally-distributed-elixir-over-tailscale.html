<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.richardtaylor.dev/articles/globally-distributed-elixir-over-tailscale">Original</a>
    <h1>Globally Distributed Elixir over Tailscale</h1>
    
    <div id="readability-page-1" class="page"><div id="globally-distributed-elixir-over-tailscale" phx-hook="Highlight">
          <p>
I’ve been playing with deploying an Elixir Phoenix application to different clouds recently and started looking into simple solutions to cluster the nodes together.</p>
<p>
I dabbled with <a href="https://docs.docker.com/network/overlay/">Docker overlay networks</a> to make nodes across different machines on the same private network visible to each other and used <a href="https://hexdocs.pm/libcluster/Cluster.Strategy.DNSPoll.html">libcluster DNSPoll Strategy</a> to auto-discover them via DNS which worked great!</p>
<p>
But what if you want to cluster your machines across multiple different clouds, or even anywhere in the world on any device?</p>
<h2>
Going Global</h2>
<p>
<a href="https://tailscale.com/">Tailscale</a> is a VPN service that makes the devices and applications you own accessible anywhere in the world, securely and effortlessly. Follow the instructions to <a href="https://tailscale.com/download">download Tailscale</a> for your system and start the <code>tailscaled</code> daemon.</p>
<p>
When bringing up your node you need to specify the hostname, which we’ll use as a service name for the cluster so make sure it is consistent on all servers. There’s an assumption here you’re bringing up one instance of the service on one host, we’ll cover docker containers in a later post that will allow multiple versions of the service on a single host.</p>
<p>
For example, if your app is called <code>hello</code> then we’d bring up tailscale like this:</p>
<pre><code>tailscale up --authkey=${TAILSCALE_AUTHKEY} --hostname=hello</code></pre>
<p>
Note: you can get your Auth key from your <a href="https://login.tailscale.com/admin/settings/keys">Tailscale settings</a>. Choose a <code>Reusable</code>, <code>Ephemeral</code> key if you have any automation in place.</p>
<p>
If succesful you should see your device in the Tailscale Dashboard.</p>
<p>
  <img src="https://images.ctfassets.net/qnx6g1z4xbnr/RJSTx6tJqbuaOlTo9t58V/2528c38c4d36077b8d13670b5ad16482/tailscale-device.png" alt="Tailsale Device"/>
</p>
<p>
Note: you might see your machine name as <code>hello-1</code>, <code>hello-2</code> etc. if you have multiple services running with the same hostname, which is fine.</p>
<p>
Now, if we repeat the same instructions on a second device (this could be your development machine), we’ll end up with two devices connected to the same <code>tailnet</code> on Tailscale. Let’s assume the second device gets the Tailscale IP address of <code>100.1.1.2</code>, we can now connect two Elixir nodes over the <code>tailnet</code> like this:</p>
<pre><code>iex --name hello@100.1.1.1 --cookie ${SECURE_COOKIE} -S mix</code></pre>
<pre><code>iex(hello@100.1.1.1.2)&gt; Node.list()
[]

iex(hello@100.1.1.1.2)&gt; Node.connect(:&#34;hello@100.1.1.1&#34;)
true

iex(hello@100.1.1.1.2)&gt; Node.list()
[:&#34;hello@100.1.1.1&#34;]</code></pre>
<p>
This is great! we can now connect our Elixir nodes together from anywhere over the secure Tailscale network. But this would be a bit tedious to handle manually in production deployments so let’s find a way to automate it.</p>
<h2>
Automatic discovery</h2>
<p>
The community go-to for Elixir clustering is <a href="https://github.com/bitwalker/libcluster">libcluster</a>. It handles a lot of strategies out of the box and provides a flexible framework for adding other strategies.</p>
<p>
I couldn’t find anything existing in the community to support service discovery and node connection so I wrote <a href="https://github.com/moomerman/libcluster_tailscale">libcluster_tailscale</a> which provides a strategy for libcluster that uses the <a href="https://tailscale.com/kb/1101/api/">Tailscale API</a> to look up hosts with matching hostnames and then automatically connect them together.</p>
<p>
Using the example above we would provide the following configration for <code>libcluster</code>:</p>
<pre><code>config :libcluster,
  debug: true,
  topologies: [
    tailscale: [
      strategy: Cluster.Strategy.Tailscale,
      config: [
        authkey: &#34;tskey-api-xxx-yyy&#34;,
        tailnet: &#34;example.com&#34;,
        hostname: &#34;hello&#34;,
        appname: &#34;hello&#34;
      ]
    ]
  ]</code></pre>
<ul>
  <li>
<code>authkey</code> is your Tailscale API key you can get from <a href="https://login.tailscale.com/admin/settings/keys">Tailscale settings</a>.  </li>
  <li>
<code>tailnet</code> is the name of your unique tailnet you can get from <a href="https://login.tailscale.com/admin/settings/general">Tailscale settings</a> (it is listed under <code>Organization</code>).  </li>
  <li>
<code>hostname</code> is the name you provided Tailscale when bringing it up on your device with <code>--hostname</code>. This acts like a service name that allows us to identify all the nodes belonging to a specific service. In production you might also use the version of the service in the hostname to ensure only nodes running the same version connect with each other, for example when deploying a new version alongside an existing one.  </li>
  <li>
<code>appname</code> is the name part of the Elixir node name you provided with <code>--name</code> eg. <code>hello</code> in <code>hello@100.1.1.1.1</code>  </li>
</ul>
<p>
Note: the <code>hostname</code> and <code>appname</code> are the same in this scenario, but they would likely be different in reality.</p>
<p>
Now when we start our Elixir node, because we enabled <code>debug</code> we’ll see output like this:</p>
<pre><code>[info] [libcluster:tailscale] connected to :&#34;hello@100.1.1.1.2&#34;
[info] [libcluster:tailscale] connected to :&#34;hello@100.1.1.1.3&#34;</code></pre>
<p>
This now allows us to deploy our Elixir application anywhere in the world, on any cloud or bare metal server and have them all automatically discover and connect to each other over Tailscale.</p>
<p>
I’m going to cover a full example Phoenix application deployed using Docker and this Tailscale setup in my next blog post.</p>
<p>
Let me know if you have any comments <a href="https://twitter.com/moomerman/status/1632853370766606336">on Twitter</a> or <a href="https://news.ycombinator.com/item?id=35059770">HN</a>.</p>

        </div></div>
  </body>
</html>
