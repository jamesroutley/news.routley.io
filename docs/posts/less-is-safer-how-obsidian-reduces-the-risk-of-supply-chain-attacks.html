<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://obsidian.md/blog/less-is-safer/">Original</a>
    <h1>Less is safer: how Obsidian reduces the risk of supply chain attacks</h1>
    
    <div id="readability-page-1" class="page"><article>
			<div><p>Supply chain attacks are malicious updates that sneak into open source code used by many apps. Here’s how we design Obsidian to ensure that the app is a <a href="https://obsidian.md/security">secure and private</a> environment for your<span> </span>thoughts.</p>
<h3>Less is safer</h3>
<p>It may sound obvious but the primary way we reduce the risk of supply chain attacks is to avoid depending on third-party code. Obsidian has a low number of dependencies compared to other apps in our category. See a list of open source libraries on <a href="https://help.obsidian.md/credits#Third+party+acknowledgements">our Credits<span> </span>page</a>.</p>
<p>Features like <a href="https://help.obsidian.md/bases">Bases</a> and <a href="https://help.obsidian.md/plugins/canvas">Canvas</a> were implemented from scratch instead of importing off-the-shelf libraries. This gives us full control over what runs in<span> </span>Obsidian.</p>
<ul>
<li><strong>For small utility functions</strong> we almost always re-implement them in our<span> </span>code.</li>
<li><strong>For medium modules</strong> we fork them and keep them inside our codebase if the licenses allows<span> </span>it.</li>
<li><strong>For large libraries</strong> like pdf.js, Mermaid, and MathJax, we include known-good, version-locked files and only upgrade occasionally, or when security fixes land. We read release notes, look at upstream changes, and test thoroughly before<span> </span>switching.</li>
</ul>
<p>This approach keeps our dependency graph shallow with few sub-dependencies. A smaller surface area lowers the chance of a malicious update slipping<span> </span>through.</p>
<h3>What actually ships in the<span> </span>app</h3>
<p>Only a handful of packages are part of the app you run, e.g. Electron, CodeMirror, moment.js. The other packages help us build the app and never ship to users, e.g. esbuild or<span> </span>eslint.</p>
<h3>Version pinning and<span> </span>lockfiles</h3>
<p>All dependencies are strictly version-pinned and committed with a lockfile. The lockfile is the source of truth for builds so we get deterministic installs. This gives us a straightforward audit trail when reviewing<span> </span>changes.</p>
<p>We do not run postinstall scripts. This prevents packages from executing arbitrary code during<span> </span>installation.</p>
<h3>Slow, deliberate upgrades</h3>
<p>When we do dependency updates,<span> </span>we:</p>
<ol>
<li>Read the dependency’s changelog<span> </span>line-by-line.</li>
<li>Check sub-dependencies introduced by the new<span> </span>version.</li>
<li>Diff upstream when the change set is large or<span> </span>risky.</li>
<li>Run automated and manual tests across platforms and critical user<span> </span>paths.</li>
<li>Commit the new lockfile only after these reviews<span> </span>pass.</li>
</ol>
<p>In practice, we rarely update dependencies because they generally work and do not require frequent changes. When we do, we treat each change as if we were taking a new<span> </span>dependency.</p>
<h3>Time is a<span> </span>buffer</h3>
<p>We don’t rush upgrades. There is a delay between upgrading any dependency and pushing a release. That gap acts as an early-warning window: the community and security researchers often detect malicious versions quickly. By the time we’re ready to ship, the ecosystem has usually flagged any problematic<span> </span>releases.</p>
<hr/>
<p>No single measure can eliminate supply chain risk. But choosing fewer dependencies, shallow graphs, exact version pins, no postinstall, and a slow, review-heavy upgrade cadence together make Obsidian much less likely to be impacted, and give us a long window to detect problems before code reaches<span> </span>users.</p>
<p>If you’re curious about our broader approach to security, see our <a href="https://obsidian.md/security">security page</a> and past<span> </span>audits.</p>
</div>
		</article></div>
  </body>
</html>
