<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://info.varnish-software.com/blog/how-memory-maps-mmap-deliver-25x-faster-file-access-in-go">Original</a>
    <h1>How memory maps (mmap) deliver faster file access in Go</h1>
    
    <div id="readability-page-1" class="page"><p><span id="hs_cos_wrapper_post_body" data-hs-cos-general-type="meta_field" data-hs-cos-type="rich_text"><p>One of the slowest things you can do in an application is making system calls. They&#39;re slow because you do have to enter the kernel, which is quite expensive. What should you do when you need to do a lot of disk I/O but you care about performance? One solution is to use memory maps.</p>
<!--more--><h2>Performance</h2>
<p>To show what kind of performance you can get using memory maps, I&#39;ve written a little Go library that allows you to read from a file using a memory map or a ReaderAt. ReaderAt will do a pread(), which is a seek/read combo, while mmap will just read from the memory map.</p>

<p>This almost feels like magic. Initially, when we launched Varnish Cache back in 2006, this was one of the features that made Varnish Cache very fast when delivering content. Varnish Cache would use memory maps to deliver content at blistering speeds.</p>
<h2>The Downside of Memory Maps</h2>
<p>The downside of memory maps is that you really can&#39;t write to the memory map. The reason is due to the way virtual memory works. When you&#39;re writing to a part of virtual memory that isn&#39;t mapped into physical memory, the CPU will generate a page fault. On a modern computer, the CPU is responsible for tracking what virtual memory pages are mapped onto what physical memory. Since you&#39;re writing to a page that isn&#39;t mapped, the CPU needs help.</p>

<p>As you can see, whether or not the pages are in cache is crucial for performance. WriterAt, which uses the pwrite call, is a much more predictable bet.</p>
<h2>Using Memory Maps to Solve Real-world Performance Problems</h2>
<p>The last couple of weeks I&#39;ve been working on an HTTP-backed filesystem. This is part of our AI Storage Acceleration solution, geared towards high performance computing environments. In this filesystem we needed a way to transfer folder data over HTTP. A folder is really just a listing of files, symbolic links and directories. The naive approach would be just to use JSON encoding, but JSON is notorious for being slow.</p>
</span></p></div>
  </body>
</html>
