<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sleepeasy.app/2024/01/21/elixir-best-language-for-bootstrapped-b2b-saas/">Original</a>
    <h1>Why Elixir Is the Best Language for Building a Bootstrapped, B2B SaaS in 2024</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      

<p>[This article is the companion to my <a href="https://codebeamamerica.com/talks/elixir-is-the-one-person-stack/">presentation</a> for CodeBEAM America 2024, Elixir is the One-Person Stack for Building a Software Startup. You can <a href="https://www.sleepeasy.app/assets/files/elixir-one-person-stack-software-startup-codebeam.pdf">download the slides as a PDF</a> or <a href="https://docs.google.com/presentation/d/11aRQTWI-Jqenmqe66rMuWWcy_VhMHN5x-dzm7sAW7ac/edit#slide=id.g2b1888d014f_0_27">view them in Google Slides</a>.]</p>

<p>I‚Äôd like to share why I chose Elixir as the programming language (and really, as we‚Äôll discuss, the full stack) for SleepEasy. I‚Äôm going to do my best to focus on the objective features of the language which make it particularly suitable for a small, nimble team starting a software business.</p>

<p>Because SleepEasy is B2B software, a web app is absolutely required. At some point in the distant future, a mobile app may be too, but I expect to get by without mobile for a long time. Even if I do one day need a mobile app, a simple wrapper around a web view will probably suffice.</p>

<p>The fact that I‚Äôm bootstrapping this company (that is, self-funding to start and growing it solely from the business‚Äôs own profits) sets one other major requirement: the app needs to be able to be built and maintained by a team of one, at least for the first few years or the first $10k+ in monthly revenue.</p>

<!--more-->

<h2 id="who-cares-about-one-person-frameworks">Who cares about one-person frameworks?</h2>

<!--[Late last year](https://world.hey.com/dhh/the-one-person-framework-711e6318), DHH called Rails 7 ‚Äúthe one person framework,‚Äù and since then I‚Äôve seen a lot of discussion online about this idea. It's kind of the dream, right? Whatever software you're building, being able to fit the whole in one person‚Äôs head is a major advantage. To have one _real human_ be able to build and maintain it, full stack, is really important. -->

<!--Of course, I have to specify a _real_ human because modern web stacks have become unspeakably complex.-->

<p>Look at any job posting for a full stack developer and consider just how many things they‚Äôre expected to have expertise in. Every employer is trying to find a unicorn who knows:</p>

<figure>
<img width="280px" src="https://www.sleepeasy.app/assets/images/tom-and-jerry-orchestra.gif" alt="Jerry, of Tom and Jerry, playing a dozen orchestra instruments at once"/>
<p>Pictured: A full-stack dev orchestrating two dozen tools to build a single web app</p>
</figure>

<ul>
  <li>HTML</li>
  <li>CSS</li>
  <li>Tailwind</li>
  <li>A frontend language (JavaScript/TypeScript)</li>
  <li>A backend language (Ruby, Python, Go, etc.)</li>
  <li>A frontend framework (React, Vue, etc.)</li>
  <li>A frontend state management framework (Redux, Jotai, Vuex, etc.)</li>
  <li>A backend framework</li>
  <li>REST</li>
  <li>GraphQL</li>
  <li>A SQL database</li>
  <li>A NoSQL database</li>
  <li>A background job system</li>
  <li>An in-memory cache like Redis</li>
  <li>A service crash recovery system (PM2, Upstart, etc.)</li>
  <li>A message queue (RabbitMQ, Redis, etc.)</li>
  <li>A web server like Nginx</li>
  <li>Docker</li>
  <li>Kubernetes</li>
  <li>A cloud platform (AWS, GCP, Azure)</li>
  <li>Serverless</li>
  <li>Microservices</li>
  <li>Scaling services</li>
</ul>

<p>ü•¥</p>

<p>It‚Äôs too much! It‚Äôs simply not reasonable to expect one person to be able to do it all. And that‚Äôs doubly true for someone starting a solo software company, where you‚Äôre <em>also</em> responsible for customer development, marketing, sales, and all the other parts of the business.</p>

<p>All this leads to one inescapable conclusion:</p>

<blockquote>
  <p><strong>We have to collapse the stack!</strong></p>
</blockquote>

<p>We need to <em>dramatically</em> cut down on the number of different technologies you need to learn to build a best-in-class web app. That‚Äôs where Elixir (and specifically Elixir plus the Phoenix web framework) comes in.</p>

<h2 id="how-elixir-collapses-a-web-apps-tech-stack">How Elixir collapses a web app‚Äôs tech stack</h2>

<p>There are three big ways Elixir helps simplify web application development.</p>

<ol>
  <li>Removing layers of the stack entirely</li>
  <li>Building more of the stack into either the language, the standard library, or Erlang‚Äôs BEAM + OTP platform<a href="#footnote-1" id="footnote-1-source">¬π</a></li>
  <li>Building more of the stack in tools you already know</li>
</ol>

<p>Let me explain‚Ä¶</p>

<h3 id="removing-layers-of-the-stack">Removing layers of the stack</h3>

<p><a href="https://github.com/phoenixframework/phoenix_live_view">Phoenix LiveView</a> has gotten a ton of positive attention<a href="#footnote-2-source" id="footnote-2">¬≤</a>, and for good reason. The pitch is that you can create rich, interactive client-side experiences (comparable to a SPA framework like React or Vue) while writing <em>just</em> ‚Äúbackend‚Äù code. By building on Phoenix‚Äôs excellent WebSocket support, LiveView provides:</p>

<ul>
  <li>SPA-like page transitions (i.e., replacing just the parts of the page that change, without a full page reload),</li>
  <li>real-time ‚Äúreactive‚Äù updates of the client-side view as state changes on the backend, and</li>
  <li>server interactivity without ever needing to construct an API or write JavaScript.</li>
</ul>

<p>And all of this comes more or less for free. Seamless, sub-50 ms page transitions? 0 lines of code.  Triggering backend events from the from the frontend? 3-4 lines of code. Subscribing the frontend to progress updates on some backend job? 4-6 lines of code.</p>

<p>There are caveats, of course. LiveView has a substantial learning curve on its own, and I wouldn‚Äôt advise trying to build something that‚Äôs fundamentally un-document like. (There‚Äôs a reason we built <a href="https://felt.com">Felt</a> as a SPA talking over WebSockets to our Phoenix backend.) But again, if you‚Äôre building a B2B SaaS, 95% of the time the product boils down to an admin dashboard, a CRUD app, or an ecommerce platform‚Ä¶ not the next Figma.</p>

<p>Has LiveView replaced 100% of JavaScript for me? Of course not. But thankfully it ships with support for ‚Äúhooks,‚Äù such that you can delegate bits of functionality to client-side JavaScript (including SPA frameworks if that‚Äôs your thing) while keeping the rest of your app in Elixir. After four months of development on SleepEasy‚Äôs MVP, I have a total of 16 lines of JavaScript in the project.</p>

<p>On top of the concrete benefits of just needing to master fewer technologies, it‚Äôs hard to overstate how nice it is to keep your head in one place (the backend, in this case) for the vast majority of the development. Having to think about the interplay between client-side JavaScript, a REST API, and the backend was like wearing a weighted vest since birth. It wasn‚Äôt something I thought about as being a drag, but once it was removed, it felt like I was walking on air.</p>

<h3 id="building-more-of-the-stack-into-the-platform-itself">Building more of the stack into the platform itself</h3>

<p>Elixir has similar stack-shrinking benefits beyond LiveView too. The BEAM and OTP provides built-in support for a lot of concurrency and fault tolerance tooling that has to be bolted on in other ecosystems.</p>

<ul>
  <li>Elixir‚Äôs fault tolerance primitives (the <a href="https://hexdocs.pm/elixir/main/supervisor-and-application.html">process isolation and supervision tree model</a>) remove the need for crash recovery at the whole-service level</li>
  <li>Erlang‚Äôs ETS tables offer the in-memory caching functionality most apps need from Redis, but without needing to spin up a separate service (and dealing with all the things that can go wrong in a distributed system like that)</li>
  <li>Phoenix PubSub provides an in-memory message queue that can replace something like RabbitMQ</li>
  <li>The platform‚Äôs thoughtful design for concurrency prevents any single process from starving the rest of the system for resources, so you can have thousands of concurrent requests on a single machine without worrying about them conflicting with one another.</li>
</ul>

<h3 id="building-more-of-the-stack-using-tools-you-already-know">Building more of the stack using tools you already know</h3>

<p>Finally, Elixir simplifies applications by having an ecosystem built on tooling you already know. That sounds a little weird, but consider the job queueing system. There are two main ways Elixir handles background jobs:</p>

<ul>
  <li>One is by using the BEAM‚Äôs built-in, effortless concurrency model (usually via <a href="https://hexdocs.pm/elixir/Task.html">Task</a> or, in a roundabout way, via <a href="https://hexdocs.pm/elixir/main/genservers.html">GenServer</a>)‚Äîthis is suitable for any ephemeral tasks that don‚Äôt need to be robust against server reboots.</li>
  <li>The other is using a library called <a href="https://github.com/sorentwo/oban">Oban</a>, which is comparable to Ruby‚Äôs Sidekiq.</li>
</ul>

<p>Oban runs on top of Postgres (or SQLite, if that‚Äôs your thing), unlike Sidekiq and similar systems that are backed by Redis. That reduces the number of technologies you need to learn (and deploy, and manage!) by one, since presumably you already need to know your SQL database.</p>

<p>Elixir has also simplified my deployment model this way. Because of that fantastic concurrency model I‚Äôve been going on about, Elixir scales extremely well as you increase the number of CPU cores and amount of RAM on the system. Vertically scaling like this is way, <em>way</em> easier than scaling out to more machines running your application‚Äîor worse, microservices!‚Äîbecause you avoid introducing distributed systems problems that serve as a drag on all future development. It takes zero lines of code change and zero additional testing to pay a little more for a bigger machine‚Ä¶ that‚Äôs not something you can say about scaling out a distributed system! (As an added benefit, it‚Äôs super cheap to deploy a single monolith talking to a single database!)</p>

<p>The final area where the Elixir stack builds more of the stack in tools that you already know is around testing. While ExUnit is <em>amazing</em> and I could sing the praises of its readability for days (how many other ecosystems have the entire community using the testing tool that ships with the language?), the fact that there‚Äôs <em>some</em> unit testing framework in Elixir isn‚Äôt that remarkable. What‚Äôs amazing is the testing story around LiveView.</p>

<p>Remember how LiveView lets you build frontend interactivity from the backend? It also lets you write <em>tests</em> of your frontend interactions in ExUnit, rather than needing browser automation which is inherently both slower and flakier. You can make assertions like ‚Äúwhen I fill in these form fields and click this button, I should be redirected to a page with the title of _______.‚Äù The cost of writing these integration tests‚Äîin terms of runtime, development time, cognitive load, and general pain-in-the-ass factor‚Äîis more or less the same as if I were testing a pure function in my business logic, and I find myself writing <em>way</em> more tests than I ever did for a React SPA. If I have to manually test something more than once, you can bet it‚Äôs going to become an integration test.</p>

<h3 id="whats-it-add-up-to">What‚Äôs it add up to?</h3>

<p>Let‚Äôs go back to the original list of technologies a full-stack dev is expected to know and see how many of them we can replace or remove with the Elixir stack I‚Äôve described here. By my count, we go from 23 things a web app can reasonably be expected to need down to 8 (counting anything built into Elixir as one technology to learn, and anything built into Phoenix as another):</p>

<ol>
  <li>Elixir (including supervision trees for fault tolerance, concurrency primitives like <code>Task</code>, and ETS for caching)</li>
  <li>Phoenix (including LiveView and PubSub)</li>
  <li>Oban for robust background jobs</li>
  <li>Postgres</li>
  <li>The PaaS of your choice (I prefer to self-host with Dokku, a Heroku-like self-hosted PaaS; others prefer Render, Fly.io, or Gigalixir)</li>
  <li>HTML</li>
  <li>CSS</li>
  <li>Tailwind</li>
</ol>

<p>That‚Äôs not bad, especially considering you‚Äôre probably coming into Elixir with maybe half those skills.</p>

<p>For a complete breakdown of the Elixir ecosystem‚Äôs answer to each of the original list of things a full-stack dev was expected to juggle, see <a href="#appendix-breakdown-of-elixirs-answer-for-common-web-dev-requirements">the appendix below</a>.</p>

<h2 id="a-few-other-accelerators-for-saas-startups">A few other accelerators for SaaS startups</h2>

<p>Using the stack I‚Äôve laid out above, you could build 95% of B2B SaaS apps, and you could do it faster and more reliably than any other ecosystem I‚Äôve seen. That said, there are a few more areas of the Elixir ecosystem that make it a great fit for bootstrapped startups, and I‚Äôd be remiss not to highlight them.</p>

<h3 id="buying-a-200-hour-head-start">Buying a 200 hour head start</h3>

<p>The first is <a href="https://docs.petal.build/petal-pro-documentation/">the Petal Pro framework</a>. ‚ÄúPetal‚Äù there is a reference to the PETAL stack: Phoenix, Elixir, Tailwind, Alpine JS, and LiveView. (It‚Äôs a nice acronym, but since LiveView introduced <code>LiveView.JS</code>  back in 2022, you can handle purely client-side interactions like toggling visibility of a modal without the need for Alpine at all.)</p>

<p>Petal Pro gives you a head start on implementing an absolute <em>ton</em> of functionality that will either be an absolute requirement for every SaaS app, or are <em>extremely</em> nice to have for monitoring, debugging, and providing support. I‚Äôve built most of these from scratch in the past, and they‚Äôre all totally doable, but they take time. Being able to spend $300 to not have to think about them again is an absolute <em>steal</em>.</p>

<p>A few of the biggest time-savers for me:</p>

<ul>
  <li>Stripe integration for doing subscription billing</li>
  <li>Organizations for users to group into (including sending and accepting org invitations)</li>
  <li>Admin dashboards (and a toolkit for building your own admin dashboards that lets me churn out new dashboard views in an hour which would have taken me <em>days</em> before)</li>
  <li>User impersonation, so that when a user reports a problem, I can log in and see exactly what they see</li>
  <li>A nicely designed LiveView component library, complete with page layouts, menus, and dark mode support for everything</li>
</ul>

<h3 id="consuming-openapi-specifications-with-grace">Consuming OpenAPI specifications with grace</h3>

<p>Next, there‚Äôs always the concern around ecosystem size, and it‚Äôs true, Elixir‚Äôs ecosystem is way smaller than NPM or PyPI. Now, in practice, I‚Äôve found the holes in the package ecosystem to not be too bad. If you just need a few REST endpoints from a third-party service, it‚Äôs not hard to write those integration. (I cut my teeth in C++, though, where writing your own implementation for dependencies was not just encouraged, but often the easiest path!) But, if you need deep integration with a huge third party API, that might be a non-starter.</p>

<p>That‚Äôs where AJ Foster‚Äôs <a href="https://github.com/aj-foster/open-api-generator"><code>open-api-generator</code></a> comes in. Unlike most OpenAPI generators, it offers a way to do deep customization of the auto-generated code to produce an ergonomic Elixir API. Rather than consuming the OpenAPI spec for your third party and vomiting it out wholesale (leading to a crummy API that a human would never produce by hand), the generator gives you ways to:</p>

<ul>
  <li>Rename components of the API</li>
  <li>Group schemas into module namespaces</li>
  <li>Merge multiple, nearly-synonymous data structures into one</li>
  <li>‚Ä¶and much more</li>
</ul>

<p>You can see compare <a href="https://github.com/aj-foster/open-api-github">AJ‚Äôs GitHub API wrapper</a> to what you get by default when you spit out the GitHub OpenAPI, and it‚Äôs night and day‚Ä¶ and at a scale that an unpaid volunteer could never match if they tried to wrap the GitHub API by hand.</p>

<p>AJ gave a great talk at last year‚Äôs ElixirConf showing off the power of this stuff:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/XSwxNgza7hE?si=p0xQt9Iu0LawU9_7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h3 id="maintainability-over-time">Maintainability over time</h3>

<p>The last thing I‚Äôd like to mention is how very little churn there is in the Elixir ecosystem. In stark contrast to other stacks I‚Äôve worked in, where taking even a ‚Äúpatch‚Äù update to a framework can require even experts to put in <em>hours</em> of frustrating debugging (as <a href="https://twitter.com/garybernhardt/status/1748486057920963041">Gary Bernhardt recently bemoaned</a>), taking an update to Elixir or Phoenix is not much of an issue. If you‚Äôre like me and treat warnings as errors, you‚Äôll frequently hit a few deprecations and the like, but those are almost always an easy fix. And that‚Äôs reflected in a recent pair of polls I ran<a href="#footnote-3" id="footnote-3-source">¬≥</a>. The overwhelming majority of users are on versions of Elixir and Phoenix released within the last year or so, and less than 5% are on versions more than 3 years old.</p>

<p><a href="https://x.com/TylerAYoung/status/1748423976609554728"><img src="https://www.sleepeasy.app/assets/images/elixir-versions.png" alt="Elixir versions used in production; 82.1% of poll respondents are using Elixir 1.15 or newer; 15.5% are using 1.13 or 1.14; 0.5% are using 1.11 or 1.12; 1.9% are using 1.10 or earlier"/></a></p>

<p><a href="https://x.com/TylerAYoung/status/1748689778650849630"><img src="https://www.sleepeasy.app/assets/images/phoenix-versions.png" alt="Phoenix versions used in production; 78.5% of poll respondents are using Phoenix 1.7; 16.8% are using 1.6; 1.9% are using 1.5; 2.8% are using 1.4 or earlier"/></a></p>

<p>Elixir and Phoenix value stability, so it‚Äôs generally easy to get access to new features without a bunch of hassle.</p>

<h2 id="wrapping-up">Wrapping up</h2>

<p>I‚Äôm not qualified to say Elixir is the right language choice for all apps everywhere. I‚Äôve never worked in a big corporation, and my experience with Elixir has been largely focused on web and networking. I <em>do</em> feel comfortable evaluating it for the project I‚Äôm working on now, though, and for the needs of a one-person development team building a B2B SaaS, I don‚Äôt see any other stack that offers both the speed of getting started and the ability to grow in whatever direction your business takes you.</p>

<p>I‚Äôd love to hear any feedback you have‚Äîyou can reach out to me on <a href="https://twitter.com/TylerAYoung">Twitter</a>, <a href="https://fosstodon.org/@tylerayoung">Mastodon</a>, or email (my first name at this domain).</p>

<h2 id="appendix-breakdown-of-elixirs-answer-for-common-web-dev-requirements">Appendix: Breakdown of Elixir‚Äôs answer for common web dev requirements</h2>



<table>
  <thead>
    <tr>
      <th>Technology</th>
      <th>The typical way</th>
      <th>The Elixir way I‚Äôm advocating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTML</td>
      <td>Gotta learn it</td>
      <td>Still gotta learn it</td>
    </tr>
    <tr>
      <td>CSS</td>
      <td>Gotta learn it</td>
      <td>Sorry, still gotta learn it</td>
    </tr>
    <tr>
      <td>Tailwind</td>
      <td>Optional, but nice</td>
      <td>Optional, but nice</td>
    </tr>
    <tr>
      <td>A frontend language</td>
      <td>JavaScript/TypeScript</td>
      <td>Phoenix LiveView</td>
    </tr>
    <tr>
      <td>A backend language</td>
      <td>Ruby, Python, Go</td>
      <td>Elixir</td>
    </tr>
    <tr>
      <td>A frontend framework</td>
      <td>React, Vue</td>
      <td>Phoenix LiveView</td>
    </tr>
    <tr>
      <td>A frontend state management framework</td>
      <td>Redux, Jotai, Vuex</td>
      <td>N/A with LiveView</td>
    </tr>
    <tr>
      <td>A backend framework</td>
      <td>Rails, Next.js, Django</td>
      <td>Phoenix LiveView</td>
    </tr>
    <tr>
      <td>REST</td>
      <td>Needed for client-server communication</td>
      <td>Unnecessary with LiveView </td>
    </tr>
    <tr>
      <td>GraphQL</td>
      <td>Maybe needed for client-server communication</td>
      <td>Unnecessary with LiveView </td>
    </tr>
    <tr>
      <td>A SQL database</td>
      <td>Postgres, MySQL, SQLite</td>
      <td>Postgres</td>
    </tr>
    <tr>
      <td>A NoSQL database</td>
      <td>Mongo, CouchDB</td>
      <td>Postgres JSONB columns or in-memory caching with ETS</td>
    </tr>
    <tr>
      <td>A background job system</td>
      <td>Sidekiq, Celery, BullMQ</td>
      <td>Built-in <code>Task</code> or Oban library</td>
    </tr>
    <tr>
      <td>An in-memory cache</td>
      <td>Redis</td>
      <td>ETS, or a thin wrapper around ETS like Cachex</td>
    </tr>
    <tr>
      <td>A service crash recovery system</td>
      <td>PM2, Upstart</td>
      <td>Built-in fault recovery via Supervisor trees</td>
    </tr>
    <tr>
      <td>A message queue</td>
      <td>RabbitMQ, Redis</td>
      <td>Phoenix PubSub</td>
    </tr>
    <tr>
      <td>A web server</td>
      <td>Nginx, Apache, Gunicorn</td>
      <td>Phoenix</td>
    </tr>
    <tr>
      <td>Containerization</td>
      <td>Docker</td>
      <td>PaaS like Render, Fly.io, Gigalixir, or Dokku that abstracts over containers (or bare binary release deployments)</td>
    </tr>
    <tr>
      <td>Container orchestration</td>
      <td>Kubernetes</td>
      <td>PaaS or bare metal deployments</td>
    </tr>
    <tr>
      <td>A cloud platform</td>
      <td>AWS, GCP, Azure</td>
      <td>PaaS or bare metal deployments</td>
    </tr>
    <tr>
      <td>Serverless</td>
      <td>AWS Lambda</td>
      <td>Vertically-scaled monolith </td>
    </tr>
    <tr>
      <td>Microservices</td>
      <td>Pain</td>
      <td>Monolith with many cores </td>
    </tr>
    <tr>
      <td>Scaling services</td>
      <td>Horizontal</td>
      <td>Vertical, only horizontal if you really need redundancy or multi-region deployments</td>
    </tr>
  </tbody>
</table>



<p><a href="#footnote-1-source" id="footnote-1">¬π</a> ‚ÄúThe BEAM‚Äù is the name of the Erlang virtual machine on which Elixir is built, and OTP (the ‚ÄúOpen Telecom Platform‚Äù) is the set of core Erlang abstractions and libraries for things like process isolation, networking, and distributed computing.</p>

<p><a href="#footnote-2-source" id="footnote-2">¬≤</a> Phoenix has been ranked the ‚Äúmost loved web framework‚Äù two years running in StackOverflow‚Äôs developer survey (<a href="https://survey.stackoverflow.co/2022/#section-most-loved-dreaded-and-wanted-web-frameworks-and-technologies">2022</a>, <a href="https://survey.stackoverflow.co/2023/#section-admired-and-desired-web-frameworks-and-technologies">2023</a>).</p>

<p><a href="#footnote-3-source" id="footnote-3">¬≥</a> Admittedly unscientific, but with 200+ respondents to the Elixir poll and 100+ to the Phoenix version, it seems like a reasonable snapshot of the ecosystem.</p>

    </div>
  </div></div>
  </body>
</html>
