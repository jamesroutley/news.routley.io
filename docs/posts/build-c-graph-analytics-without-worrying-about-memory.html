<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://memgraph.com/blog/build-graph-analytics-without-worrying-about-memory">Original</a>
    <h1>Build C&#43;&#43; Graph Analytics Without Worrying About Memory</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><p>Extracting value from graph data seems like so much more hassle than it needs to be. Datasets are often useful only when big enough, and at that point you need to scale up your analytics pipeline. More often than not, graph analytics products need changes to make them compatible with what you’ve got. Sometimes, even these changes don’t do the trick, and you need to develop new graph algorithms or ML.</p>
<p>All this is possible with minimal overhead using Memgraph and its <a href="https://memgraph.com/mage">MAGE</a> graph analytics library, even if you haven’t used graph databases before. Grab a coffee, and keep reading to find out how the new <a href="https://memgraph.com/docs/memgraph/reference-guide/query-modules/api/cpp-api">MAGE C++ API</a> gives you the speed of C++ and the smoothness of higher-level languages for handling graph data.</p>
<h2>Extend queries with custom graph methods</h2>
<p>With MAGE, you can build user-defined methods as query procedures and functions, and run them with Cypher queries. Procedures are full-featured operations that can modify the graph and pass the changes for further processing. They return a stream of results which can be complex multi-field values. For simpler use cases, use functions: they take the graph as immutable and return a single value.</p>
<p>Graph users often avoid storing data within graph DBs due to performance constraints: accessing the stored graph can cause bottlenecks, especially in dynamic analytics. We have worked around this issue in two ways:</p>
<ul>
<li>Memgraph is an in-memory database, eliminating the need for expensive read/write operations.</li>
<li>The new C++ API directly interfaces with the stored graph and does not create its own graph representation.</li>
</ul>
<p>In short, if the data is in the DB, it’s ready to use.</p>
<p>However, high-performance code is worth nothing if you don’t know how to write it. Thus, our team has made coding graph methods easier. The following code snippet implements a procedure that adds a user-defined number of nodes to the graph:</p>
<pre><code>
<span><span>void</span> <span>AddXNodes</span><span>(mgp_list *args, mgp_graph *memgraph_graph, mgp_result *result, mgp_memory *memory)</span> </span>{	
  mgp::memory = memory;	
  <span>const</span> <span>auto</span> arguments = mgp::List(args);	
  <span>const</span> <span>auto</span> n_new_nodes = arguments[<span>0</span>].ValueInt();
 
  <span>auto</span> graph = mgp::Graph(memgraph_graph);	
  <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; n_new_nodes; i++) {
    graph.CreateNode();
  }
}
 

<span>extern</span> <span>&#34;C&#34;</span> <span><span>int</span> <span>mgp_init_module</span><span>(struct mgp_module *<span>module</span>, struct mgp_memory *memory)</span> </span>{		
  <span>try</span> {
    mgp::memory = memory;		
  
    mgp::AddProcedure(AddXNodes, <span>&#34;add_x_nodes&#34;</span>, mgp::ProcedureType::Write,
    {mgp::Parameter(<span>&#34;number&#34;</span>, mgp::Type::Int)}, {}, <span>module</span>, memory);		
    
    
  } <span>catch</span> (<span>const</span> <span>std</span>::exception &amp;e) {
    <span>return</span> <span>1</span>;
  }
  <span>return</span> <span>0</span>;
}
</code></pre>
<p>To familiarize yourself with the new API, learn from example with the <a href="https://memgraph.com/docs/memgraph/reference-guide/query-modules/implement-custom-query-modules/custom-query-module-example#c-api-1">reference guide</a> and consult the <a href="https://memgraph.com/docs/memgraph/reference-guide/query-modules/api/cpp-api">documentation</a>.</p>
<h2>Intuitive interface</h2>
<p>The new C++ API is designed for humans, not robots. We followed best practices toreduce unnecessary cognitive load: the components have simple and consistent interfaces, common use cases require fewer user actions, and the API comes with developer guides and extensive documentation.</p>
<p>Memory management is probably the main pain point in C++ development, its usefulness notwithstanding. The new C++ API automatically manages the memory used by graph data, saving you time that would otherwise go to debugging and writing repetitive code.</p>
<p>Under the hood, this API builds upon the existing C API. The ability to use C++ features ties in directly with our goal of creating a simple, consistent interface. During design, we had our minds set on avoiding the cognitive friction that comes with context-switching between C++ standard library classes and ours.
Compare the code snippets below. They both do the same thing - iterate over graph nodes - but the latter is consistent with standard C++ iterables and manages memory on its own.</p>
<pre><code>
<span>auto</span> *vertices_it = mgp::graph_iter_vertices(memgraph_graph, memory);
 
<span>for</span> (<span>auto</span> *vertex = mgp::vertices_iterator_get(vertices_it); vertex;
     vertex = mgp::vertices_iterator_next(vertices_it)) {
  
}
mgp::vertices_iterator_destroy(vertices_it);
</code></pre>
<pre><code>
<span>for</span> (<span>const</span> <span>auto</span> node : graph.Nodes()) {
  
}
</code></pre>
<h2>Going further</h2>
<p>In its initial release, the new C++ API has made it easier to develop query modules with user-defined procedures and functions. To this end, we have cut down boilerplate code and made data accessible through a simple, consistent and high-performance graph API.
Besides query modules, Memgraph supports <a href="https://memgraph.com/docs/memgraph/reference-guide/streams/transformation-modules">transformation modules</a>, which enable the database to ingest data from streams. For the next release, we plan to  add support for transformation modules, as well as restricting graph operations to subgraphs or extending them to work with multiple graph iterations simultaneously.
We will maintain the focus on simplicity and consistency when adding new features and incrementally improve what we’ve already got.</p>
<h2>What’s next?</h2>
<p>Thanks for keeping with us! We’ve worked hard to make graph analytics fast, scalable, and easy to develop and use, come try <a href="https://memgraph.com/mage">MAGE</a> out. You can build graph analytics tailored to your needs in C++ or <a href="https://memgraph.com/docs/memgraph/reference-guide/query-modules/implement-custom-query-modules/custom-query-module-example#python-api">Python</a>, or even contribute to MAGE and see your work now available to everybody. Tell us what you’re doing on our <a href="https://discord.com/invite/GtCzXAmt">Discord server</a>, we’ll be happy to talk about it with you!</p>
</div></div>
  </body>
</html>
