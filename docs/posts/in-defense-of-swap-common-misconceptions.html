<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrisdown.name/2018/01/02/in-defence-of-swap.html">Original</a>
    <h1>In defense of swap: common misconceptions</h1>
    
    <div id="readability-page-1" class="page"><article>  <p>This post is also available in <a href="https://chrisdown.name/ja/2018/01/02/in-defence-of-swap.html">Japanese</a>, <a href="https://farseerfc.me/in-defence-of-swap.html">Chinese</a>, and <a href="https://web.archive.org/web/20200924111107/https://softdroid.net/v-zashchitu-svopa-rasprostranennye-zabluzhdeniya">Russian</a>.</p> <p>tl;dr:</p> <ol> <li>Having swap is a reasonably important part of a well functioning system. Without it, sane memory management becomes harder to achieve.</li> <li>Swap is not generally about getting emergency memory, it&#39;s about making memory reclamation egalitarian and efficient. In fact, using it as &#34;emergency memory&#34; is generally actively harmful.</li> <li>Disabling swap does not prevent disk I/O from becoming a problem under memory contention, it simply shifts the disk I/O thrashing from anonymous pages to file pages. Not only may this be less efficient, as we have a smaller pool of pages to select from for reclaim, but it may also contribute to getting into this high contention state in the first place.</li> <li>The swapper on kernels before 4.0 has a lot of pitfalls, and has contributed to a lot of people&#39;s negative perceptions about swap due to its overeagerness to swap out pages. On kernels &gt;4.0, the situation is significantly better.</li> <li>On SSDs, swapping out anonymous pages and reclaiming file pages are essentially equivalent in terms of performance/latency. On older spinning disks, swap reads are slower due to random reads, so a lower <code>vm.swappiness</code> setting makes sense there (read on for more about <code>vm.swappiness</code>).</li> <li>Disabling swap doesn&#39;t prevent pathological behaviour at near-OOM, although it&#39;s true that having swap may prolong it. Whether the system global OOM killer is invoked with or without swap, or was invoked sooner or later, the result is the same: you are left with a system in an unpredictable state. Having no swap doesn&#39;t avoid this.</li> <li>You can achieve better swap behaviour under memory pressure and prevent thrashing using <code>memory.low</code> and friends in cgroup v2.</li> </ol> <hr/> <p>As part of my work improving kernel memory management and <a href="https://www.youtube.com/watch?v=ikZ8_mRotT4">cgroup v2</a>, I&#39;ve been talking to a lot of engineers about attitudes towards memory, especially around application behaviour under pressure and operating system heuristics used under the hood for memory management.</p> <p>A repeated topic in these discussions has been swap. Swap is a hotly contested and poorly understood topic, even by those who have been working with Linux for many years. Many see it as useless or actively harmful: a relic of a time where memory was scarce, and disks were a necessary evil to provide much-needed space for paging. This is a statement that I still see being batted around with relative frequency in recent years, and I&#39;ve had many discussions with colleagues, friends, and industry peers to help them understand why swap is still a useful concept on modern computers with significantly more physical memory available than in the past.</p> <p>There&#39;s also a lot of misunderstanding about the purpose of swap – many people just see it as a kind of &#34;slow extra memory&#34; for use in emergencies, but don&#39;t understand how it can contribute during normal load to the healthy operation of an operating system as a whole.</p> <p>Many of us have heard most of the usual tropes about memory: &#34;<a href="https://www.linuxatemyram.com/">Linux uses too much memory</a>&#34;, &#34;<a href="https://superuser.com/a/111510/98210">swap should be double your physical memory size</a>&#34;, and the like. While these are either trivial to dispel, or discussion around them has become more nuanced in recent years, the myth of &#34;useless&#34; swap is much more grounded in heuristics and arcana rather than something that can be explained by simple analogy, and requires somewhat more understanding of memory management to reason about.</p> <p>This post is mostly aimed at those who administrate Linux systems and are interested in hearing the counterpoints to running with undersized/no swap or running with <code>vm.swappiness</code> set to 0.</p> <h2 id="background">Background</h2> <p>It&#39;s hard to talk about why having swap and swapping out pages are good things in normal operation without a shared understanding of some of the basic underlying mechanisms at play in Linux memory management, so let&#39;s make sure we&#39;re on the same page.</p> <h3 id="types-of-memory">Types of memory</h3> <p>There are many different types of memory in Linux, and each type has its own properties. Understanding the nuances of these is key to understanding why swap is important.</p> <p>For example, there are <a href="https://en.wikipedia.org/wiki/Page_(computer_memory)"><em>pages</em> (&#34;blocks&#34; of memory, typically 4k)</a> responsible for holding the code for each process being run on your computer. There are also pages responsible for caching data and metadata related to files accessed by those programs in order to speed up future access. These are part of the <a href="https://en.wikipedia.org/wiki/Page_cache">page cache</a>, and I will refer to them as <em>file</em> memory.</p> <p>There are also pages which are responsible for the memory allocations made inside that code, for example, when new memory that has been allocated with <code>malloc</code> is written to, or when using <code>mmap</code>&#39;s <code>MAP_ANONYMOUS</code> flag. These are &#34;anonymous&#34; pages – so called because they are not backed by anything – and I will refer to them as <em>anon</em> memory.</p> <p>There are other types of memory too – shared memory, slab memory, kernel stack memory, buffers, and the like – but anonymous memory and file memory are the most well known and easy to understand ones, so I will use these in my examples, although they apply equally to these types too.</p> <h3 id="reclaimableunreclaimable-memory">Reclaimable/unreclaimable memory</h3> <p>One of the most fundamental questions when thinking about a particular type of memory is whether it is able to be reclaimed or not. &#34;Reclaim&#34; here means that the system can, without losing data, purge pages of that type from physical memory.</p> <p>For some page types, this is typically fairly trivial. For example, in the case of <em>clean</em> (unmodified) page cache memory, we&#39;re simply caching something that we have on disk for performance, so we can drop the page without having to do any special operations.</p> <p>For some page types, this is possible, but not trivial. For example, in the case of <em>dirty</em> (modified) page cache memory, we can&#39;t just drop the page, because the disk doesn&#39;t have our modifications yet. As such we either need to deny reclamation or first get our changes back to disk before we can drop this memory.</p> <p>For some page types, this is not possible. For example, in the case of the anonymous pages mentioned previously, they only exist in memory and in no other backing store, so they have to be kept there.</p> <h2 id="on-the-nature-of-swap">On the nature of swap</h2> <p>If you look for descriptions of the purpose of swap on Linux, you&#39;ll inevitably find many people talking about it as if it is merely an extension of the physical RAM for use in emergencies. For example, here is a random post I got as one of the top results from typing &#34;what is swap&#34; in Google:</p> <blockquote> <p>Swap is essentially emergency memory; a space set aside for times when your system temporarily needs more physical memory than you have available in RAM. It&#39;s considered &#34;bad&#34; in the sense that it&#39;s slow and inefficient, and if your system constantly needs to use swap then it obviously doesn&#39;t have enough memory. […] If you have enough RAM to handle all of your needs, and don&#39;t expect to ever max it out, then you should be perfectly safe running without a swap space.</p> </blockquote> <p>To be clear, I don&#39;t blame the poster of this comment at all for the content of their post – this is accepted as &#34;common knowledge&#34; by a lot of Linux sysadmins and is probably one of the most likely things that you will hear from one if you ask them to talk about swap. It is unfortunately also, however, a misunderstanding of the purpose and use of swap, especially on modern systems.</p> <p>Above, I talked about reclamation for anonymous pages being &#34;not possible&#34;, as anonymous pages by their nature have no backing store to fall back to when being purged from memory – as such, their reclamation would result in complete data loss for those pages. What if we could create such a store for these pages, though?</p> <p>Well, this is precisely what swap is for. Swap is a storage area for these seemingly &#34;unreclaimable&#34; pages that allows us to page them out to a storage device on demand. This means that they can now be considered as equally eligible for reclaim as their more trivially reclaimable friends, like clean file pages, allowing more efficient use of available physical memory.</p> <p><strong>Swap is primarily a mechanism for equality of reclamation, not for emergency &#34;extra memory&#34;. Swap is not what makes your application slow – entering overall memory contention is what makes your application slow.</strong></p> <p>So in what situations under this &#34;equality of reclamation&#34; scenario would we legitimately choose to reclaim anonymous pages? Here are, abstractly, some not uncommon scenarios:</p> <ol> <li>During initialisation, a long-running program may allocate and use many pages. These pages may also be used as part of shutdown/cleanup, but are not needed once the program is &#34;started&#34; (in an application-specific sense). This is fairly common for daemons which have significant dependencies to initialise.</li> <li>During the program&#39;s normal operation, we may allocate memory which is only used rarely. It may make more sense for overall system performance to require a <a href="https://en.wikipedia.org/wiki/Page_fault#Types">major fault</a> to page these in from disk on demand, instead using the memory for something else that&#39;s more important.</li> </ol> <h2 id="examining-what-happens-withwithout-swap">Examining what happens with/without swap</h2> <p>Let&#39;s look at typical situations, and how they perform with and without swap present. I talk about metrics around &#34;memory contention&#34; in my <a href="https://www.youtube.com/watch?v=ikZ8_mRotT4">talk on cgroup v2</a>.</p> <h3 id="under-nolow-memory-contention">Under no/low memory contention</h3> <ul> <li><strong>With swap:</strong> We can choose to swap out rarely-used anonymous memory that may only be used during a small part of the process lifecycle, allowing us to use this memory to improve cache hit rate, or do other optimisations.</li> <li><strong>Without swap:</strong> We cannot swap out rarely-used anonymous memory, as it&#39;s locked in memory. While this may not immediately present as a problem, on some workloads this may represent a non-trivial drop in performance due to stale, anonymous pages taking space away from more important use.</li> </ul> <h3 id="under-moderatehigh-memory-contention">Under moderate/high memory contention</h3> <ul> <li><strong>With swap:</strong> All memory types have an equal possibility of being reclaimed. This means we have more chance of being able to reclaim pages successfully – that is, we can reclaim pages that are not quickly faulted back in again (thrashing).</li> <li><strong>Without swap:</strong> Anonymous pages are locked into memory as they have nowhere to go. The chance of successful long-term page reclamation is lower, as we have only some types of memory eligible to be reclaimed at all. The risk of page thrashing is higher. The casual reader might think that this would still be better as it might avoid having to do disk I/O, but this isn&#39;t true – we simply transfer the disk I/O of swapping to dropping hot page caches and dropping code segments we need soon.</li> </ul> <h3 id="under-temporary-spikes-in-memory-usage">Under temporary spikes in memory usage</h3> <ul> <li><strong>With swap:</strong> We&#39;re more resilient to temporary spikes, but in cases of severe memory starvation, the period from memory thrashing beginning to the OOM killer may be prolonged. We have more visibility into the instigators of memory pressure and can act on them more reasonably, and can perform a controlled intervention.</li> <li><strong>Without swap:</strong> The OOM killer is triggered more quickly as anonymous pages are locked into memory and cannot be reclaimed. We&#39;re more likely to thrash on memory, but the time between thrashing and OOMing is reduced. Depending on your application, this may be better or worse. For example, a queue-based application may desire this quick transfer from thrashing to killing. That said, this is still too late to be really useful – the OOM killer is only invoked at moments of severe starvation, and relying on this method for such behaviour would be better replaced with more opportunistic killing of processes as memory contention is reached in the first place.</li> </ul> <h3 id="okay-so-i-want-system-swap-but-how-can-i-tune-it-for-individual-applications">Okay, so I want system swap, but how can I tune it for individual applications?</h3> <p>You didn&#39;t think you&#39;d get through this entire post without me plugging cgroup v2, did you? ;-)</p> <p>Obviously, it&#39;s hard for a generic heuristic algorithm to be right all the time, so it&#39;s important for you to be able to give guidance to the kernel. Historically the only tuning you could do was at the system level, using <code>vm.swappiness</code>. This has two problems: <code>vm.swappiness</code> is incredibly hard to reason about because it only feeds in as a small part of a larger heuristic system, and it also is system-wide instead of being granular to a smaller set of processes.</p> <p>You can also use <code>mlock</code> to lock pages into memory, but this requires either modifying program code, fun with <code>LD_PRELOAD</code>, or doing horrible things with a debugger at runtime. In VM-based languages this also doesn&#39;t work very well, since you generally have no control over allocation and end up having to <code>mlockall</code>, which has no precision towards the pages you actually care about.</p> <p>cgroup v2 has a tunable per-cgroup in the form of <code>memory.low</code>, which allows us to tell the kernel to prefer other applications for reclaim below a certain threshold of memory used. This allows us to not prevent the kernel from swapping out parts of our application, but prefer to reclaim from other applications under memory contention. Under normal conditions, the kernel&#39;s swap logic is generally pretty good, and allowing it to swap out pages opportunistically generally increases system performance. Swap thrash under heavy memory contention is not ideal, but it&#39;s more a property of simply running out of memory entirely than a problem with the swapper. In these situations, you typically want to fail fast by self-killing non-critical processes when memory pressure starts to build up.</p> <p>You can not simply rely on the OOM killer for this. The OOM killer is only invoked in situations of dire failure when we&#39;ve <em>already</em> entered a state where the system is severely unhealthy and may well have been so for a while. You need to opportunistically handle the situation yourself before ever thinking about the OOM killer.</p> <p>Determination of memory pressure is somewhat difficult using traditional Linux memory counters, though. We have some things which seem somewhat related, but are merely tangential – memory usage, page scans, etc – and from these metrics alone it&#39;s very hard to tell an efficient memory configuration from one that&#39;s trending towards memory contention. There is a group of us at Facebook, spearheaded by <a href="https://github.com/torvalds/linux/commits?author=hnaz">Johannes</a>, working on developing new metrics that expose memory pressure more easily that should help with this in future. If you&#39;re interested in hearing more about this, <a href="https://youtu.be/ikZ8_mRotT4?t=2145">I go into detail about one metric being considered in my talk on cgroup v2</a>.</p> <h2 id="tuning">Tuning</h2> <h3 id="how-much-swap-do-i-need-then">How much swap do I need, then?</h3> <p>In general, the minimum amount of swap space required for optimal memory management depends on the number of anonymous pages pinned into memory that are rarely reaccessed by an application, and the value of reclaiming those anonymous pages. The latter is mostly a question of which pages are no longer purged to make way for these infrequently accessed anonymous pages.</p> <p>If you have a bunch of disk space and a recent (4.0+) kernel, more swap is almost always better than less. In older kernels <code>kswapd</code>, one of the kernel processes responsible for managing swap, was historically very overeager to swap out memory aggressively the more swap you had. In recent times, swapping behaviour when a large amount of swap space is available has been significantly improved. If you&#39;re running kernel 4.0+, having a larger swap on a modern kernel should not result in overzealous swapping. As such, if you have the space, having a swap size of a few GB keeps your options open on modern kernels.</p> <p>If you&#39;re more constrained with disk space, then the answer really depends on the tradeoffs you have to make, and the nature of the environment. Ideally you should have enough swap to make your system operate optimally at normal and peak (memory) load. What I&#39;d recommend is setting up a few testing systems with 2-3GB of swap or more, and monitoring what happens over the course of a week or so under varying (memory) load conditions. As long as you haven&#39;t encountered severe memory starvation during that week – in which case the test will not have been very useful – you will probably end up with some number of MB of swap occupied. As such, it&#39;s probably worth having at least that much swap available, in addition to a little buffer for changing workloads. <code>atop</code> in logging mode can also show you which applications are having their pages swapped out in the <code>SWAPSZ</code> column, so if you don&#39;t already use it on your servers to log historic server state you probably want to set it up on these test machines with logging mode as part of this experiment. This also tells you <em>when</em> your application started swapping out pages, which you can tie to log events or other key data.</p> <p>Another thing worth considering is the nature of the swap medium. Swap reads tend to be highly random, since we can&#39;t reliably predict which pages will be refaulted and when. On an SSD this doesn&#39;t matter much, but on spinning disks, random I/O is extremely expensive since it requires physical movement to achieve. On the other hand, refaulting of file pages is likely less random, since files related to the operation of a single application at runtime tend to be less fragmented. This might mean that on a spinning disk you may want to bias more towards reclaiming file pages instead of swapping out anonymous pages, but again, you need to test and evaluate how this balances out for your workload.</p> <p>For laptop/desktop users who want to hibernate to swap, this also needs to be taken into account – in this case your swap file should be at least your physical RAM size.</p> <h3 id="what-should-my-swappiness-setting-be">What should my swappiness setting be?</h3> <p>First, it&#39;s important to understand what <code>vm.swappiness</code> does. <code>vm.swappiness</code> is a sysctl that biases memory reclaim either towards reclamation of anonymous pages, or towards file pages. It does this using two different attributes: <code>file_prio</code> (our willingness to reclaim file pages) and <code>anon_prio</code> (our willingness to reclaim anonymous pages). <code>vm.swappiness</code> plays into this, as it becomes the default value for <code>anon_prio</code>, and it also is subtracted from the default value of 200 for <code>file_prio</code>, which means for a value of <code>vm.swappiness = 50</code>, the outcome is that <code>anon_prio</code> is 50, and <code>file_prio</code> is 150 (the exact numbers don&#39;t matter as much as their relative weight compared to the other).</p> <p>This means that, in general, <strong>vm.swappiness is simply a ratio of how costly reclaiming and refaulting anonymous memory is compared to file memory for your hardware and workload</strong>. The lower the value, the more you tell the kernel that infrequently accessed anonymous pages are expensive to swap out and in on your hardware. The higher the value, the more you tell the kernel that the cost of swapping anonymous pages and file pages is similar on your hardware. The memory management subsystem will still try to mostly decide whether it swaps file or anonymous pages based on how hot the memory is, but swappiness tips the cost calculation either more towards swapping or more towards dropping filesystem caches when it could go either way. On SSDs these are basically as expensive as each other, so setting <code>vm.swappiness = 100</code> (full equality) may work well. On spinning disks, swapping may be significantly more expensive since swapping in generally requires random reads, so you may want to bias more towards a lower value.</p> <p>The reality is that most people don&#39;t really have a feeling about which their hardware demands, so it&#39;s non-trivial to tune this value based on instinct alone – this is something that you need to test using different values. You can also spend time evaluating the memory composition of your system and core applications and their behaviour under mild memory reclamation.</p> <p>When talking about <code>vm.swappiness</code>, an extremely important change to consider from recent(ish) times is <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/patch/?id=fe35004fbf9eaf67482b074a2e032abb9c89b1dd">this change to vmscan by Satoru Moriya in 2012</a>, which changes the way that <code>vm.swappiness = 0</code> is handled quite significantly.</p> <p>Essentially, the patch makes it so that we are extremely biased against scanning (and thus reclaiming) any anonymous pages at all with <code>vm.swappiness = 0</code>, unless we are already encountering severe memory contention. As mentioned previously in this post, that&#39;s generally not what you want, since this prevents equality of reclamation prior to extreme memory pressure occurring, which may actually <em>lead</em> to this extreme memory pressure in the first place. <code>vm.swappiness = 1</code> is the lowest you can go without invoking the special casing for anonymous page scanning implemented in that patch.</p> <p>The kernel default here is <code>vm.swappiness = 60</code>. This value is generally not too bad for most workloads, but it&#39;s hard to have a general default that suits all workloads. As such, a valuable extension to the tuning mentioned in the &#34;how much swap do I need&#34; section above would be to test these systems with differing values for vm.swappiness, and monitor your application and system metrics under heavy (memory) load. Some time in the near future, once we have a decent implementation of <a href="https://youtu.be/ikZ8_mRotT4?t=2145">refault detection</a> in the kernel, you&#39;ll also be able to determine this somewhat workload-agnostically by looking at cgroup v2&#39;s page refaulting metrics.</p> <h3 id="update-as-of-2019-07-memory-pressure-metrics-in-kernel-420">Update as of 2019-07: memory pressure metrics in kernel 4.20+</h3> <p>The refault metrics mentioned as in development earlier are now in the kernel from 4.20 onwards and can be enabled with <code>CONFIG_PSI=y</code>. See my talk at SREcon at around the 25:05 mark:</p>   <lite-youtube videoid="beefUhRH5lU" playlabel="Play"></lite-youtube> <h2 id="in-conclusion">In conclusion</h2> <ul> <li>Swap is a useful tool to allow equality of reclamation of memory pages, but its purpose is frequently misunderstood, leading to its negative perception across the industry. If you use swap in the spirit intended, though – as a method of increasing equality of reclamation – you&#39;ll find that it&#39;s a useful tool instead of a hindrance.</li> <li>Disabling swap does not prevent disk I/O from becoming a problem under memory contention, it simply shifts the disk I/O thrashing from anonymous pages to file pages. Not only may this be less efficient, as we have a smaller pool of pages to select from for reclaim, but it may also contribute to getting into this high contention state in the first place.</li> <li>Swap can make a system slower to OOM kill, since it provides another, slower source of memory to thrash on in out of memory situations – the OOM killer is only used by the kernel as a last resort, after things have already become monumentally screwed. The solutions here depend on your system: <ul> <li>You can opportunistically change the system workload depending on cgroup-local or global memory pressure. This prevents getting into these situations in the first place, but solid memory pressure metrics are lacking throughout the history of Unix. Hopefully this should be better soon with the addition of <a href="https://youtu.be/ikZ8_mRotT4?t=2145">refault detection</a>.</li> <li>You can bias reclaiming (and thus swapping) away from certain processes per-cgroup using <code>memory.low</code>, allowing you to protect critical daemons without disabling swap entirely.</li> </ul> </li> </ul> <hr/> <p>Many thanks to <a href="https://github.com/rahulg">Rahul</a>, <a href="https://github.com/torvalds/linux/commits?author=htejun">Tejun</a>, and <a href="https://github.com/torvalds/linux/commits?author=hnaz">Johannes</a> for their extensive suggestions and feedback on this post.</p> </article></div>
  </body>
</html>
