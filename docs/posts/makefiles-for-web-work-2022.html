<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rosszurowski.com/log/2022/makefiles">Original</a>
    <h1>Makefiles for Web Work (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><p><code>make</code> is a build tool that’s been around since the 1970s. It was originally designed for automating the building of C programs: installing dependencies, running tests, and compiling binaries.</p>
<p>These days, web projects involve many of the same steps: installing node_modules, running linters and tests, starting dev servers, and compiling files with esbuild or Rollup.</p>
<p>The default choice for automating these steps is often <a href="https://docs.npmjs.com/cli/v6/using-npm/scripts" target="_blank" rel="nofollow noreferrer">npm/yarn scripts</a>: little shell commands written into your project’s <code>package.json</code> file. More complex projects sometimes evolve into using tools like Gulp/Grunt, or even full-blown Docker builds.</p>
<p>But I find <code>make</code> often fills many of the same needs without as much fuss.</p>
<p>Its age and simplicity means it gets a lot of things right:</p>
<ul>
<li><strong>It’s already available everywhere</strong>. Most systems install <code>make</code> when you first set up developer tools. There’s rarely extra steps to get it working.</li>
<li><strong>It’s fast</strong>. People <a href="https://twitter.com/jarredsumner/status/1557694790359085057?s=20&amp;t=R7w-EaxCLuhMhVVaFg_M1g" target="_blank" rel="nofollow noreferrer">routinely point out</a> that npm/yarn scripts are <a href="https://gist.github.com/rosszurowski/1b7971ab2eaf150c5039f3f7ef5e76a0" target="_blank" rel="nofollow noreferrer">shockingly slow to start</a>. <code>make</code> routinely runs commands <strong>~30x faster</strong>, which is nice, because <a href="https://craigmod.com/essays/fast_software/" target="_blank" rel="nofollow noreferrer">fast software is good software</a>.</li>
<li><strong>It’s language-agnostic</strong>. Since <code>make</code> is already installed and works off shell scripts, it doesn’t require commitment to one language or toolchain. You can use it for Go, PHP, Rust, or Node projects equally. And you can shell out to language-specific tools when needed.</li>
<li><strong>It’s simple, with room to grow</strong>. Makefiles have a reputation for getting out-of-hand on large projects. But for smaller projects, the simple file structure, and dependency tracking, and support for multiple commands hits a nice sweet spot.</li>
</ul>
<h3 id="a-consistent-interface-to-project-scripts"><a aria-hidden="true" href="#a-consistent-interface-to-project-scripts"></a>A consistent interface to project scripts</h3>
<p>Thanks to these qualities, <code>make</code> shines as a way to create a consistent interface to commands across projects.</p>
<p>Most projects I work on require some kind of build process. To get to work, I need to re-learn the project’s tools, and the multiple commands needed to download dependencies, build assets, and start a dev server.</p>
<p>Building a site with <a href="https://getkirby.com" target="_blank" rel="nofollow noreferrer">Kirby</a><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> I need a mix of <code>php</code>, <code>tailwindcss</code>, <code>esbuild</code>, and <code>rsync</code> commands. For a <a href="https://nextjs.org" target="_blank" rel="nofollow noreferrer">Next.js</a> site, I’m using their built-in CLI. And with <a href="https://fresh.deno.dev/" target="_blank" rel="nofollow noreferrer">Fresh</a>, I don’t even have a <code>package.json</code> file — I’m using <code>deno run</code> and <code>deno fmt</code>. It’s annoying to track these commands down again and refamiliarize myself with where they live: in a JSON file? In a set of script files? In the README?</p>
<p>A Makefile acts as a conventional home for these tools and commands. It’s a single file at the root of the repository, that works with any language, and is easy read/add new commands to.</p>
<p>I leverage this conventionality to create consistent commands between different projects. For example, in every new project, I add a <code>make dev</code> command, which <a href="#auto-installing-node_modules">auto-downloads dependencies</a>, starts a dev server, and watches for changes, no matter the language.</p>
<p>For reference, here’s a list of common commands I’ll add:</p>
<ul>
<li><code>make dev</code> starts a development server with live reloading</li>
<li><code>make build</code> builds a production-ready binary or set of files</li>
<li><code>make deploy</code> tags a release for CI to build, or rsyncs files to a server</li>
<li><code>make format</code> formats all code to a standard style, using <a href="https://prettier.io/" target="_blank" rel="nofollow noreferrer">prettier</a> or <a href="https://go.dev/blog/gofmt" target="_blank" rel="nofollow noreferrer">gofmt</a></li>
<li><code>make lint</code> runs code quality checks, like <a href="https://eslint.org/" target="_blank" rel="nofollow noreferrer">eslint</a> or <a href="https://golangci-lint.run/" target="_blank" rel="nofollow noreferrer">golanglint-ci</a></li>
<li><code>make test</code> runs a full set of test suites. Sometimes I’ll include <code>lint</code> scripts in here so there’s a single command to run in CI</li>
<li><code>make clean</code> removes all build artifacts and downloaded dependencies</li>
<li><code>make help</code> lists all the commands in a Makefile (<a href="#self-documenting-makefiles">discussed here</a>)</li>
</ul>
<p>This “one command” and “one interface” is highly beneficial for teammates too.
They can get started quickly, and if they want to learn more or tinker, the commands and dependency relationships are all documented in a single place.</p>
<h3 id="recipes"><a aria-hidden="true" href="#recipes"></a>Recipes</h3>
<p>Other articles cover the basics of how to write a Makefile in great depth,<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup> so I’ll leave syntax aside and instead focus on sharing some common techniques that I use:</p>
<ul>
<li><a href="#tasks-without-dependencies">Tasks without dependencies</a></li>
<li><a href="#referencing-node_modules-binaries">Referencing node_modules</a></li>
<li><a href="#auto-installing-node_modules">Auto-installing node_modules</a></li>
<li><a href="#skipping-re-runs-of-slow-tasks">Skipping re-runs of slow tasks</a></li>
<li><a href="#using-environment-variables">Using environment variables</a></li>
<li><a href="#configuring-tasks-with-default-variables">Configuring tasks with default variables</a></li>
<li><a href="#self-documenting-makefiles">Self-documenting Makefiles</a></li>
<li><a href="#parallel-dev-servers">Parallel dev servers</a></li>
<li><a href="#hermetic-environments">Hermetic environments</a></li>
</ul>
<hr/>
<h3 id="tasks-without-dependencies"><a aria-hidden="true" href="#tasks-without-dependencies"></a>Tasks without dependencies</h3>
<p>By default, <code>make</code> rule names refer to actual files to be built. If you write a rule like this:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>dev</span><span>:</span></span>
<span><span>	</span><span>@</span><span>echo &#34;Hello, world!&#34;</span></span></code></pre></div>
<p>And then later create a file named <code>dev</code>, <code>make</code> doesn’t run the commands.</p>
<pre><code>$ touch dev
$ make dev
make: &#39;dev&#39; is up to date.
</code></pre>
<p>For one-off scripts that you just want to run when you tell them to run, this default is a little annoying.</p>
<p>In these cases, add <code>.PHONY: &lt;name&gt;</code> to the end of the target definition. This tells <code>make</code> to skip the dependency checks and run the command every time:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>dev</span><span>:</span></span>
<span><span>	</span><span>@</span><span>echo &#34;Hello, world!&#34;</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span></code></pre></div>
<p>Now:</p>
<pre><code>$ touch dev
$ make dev
Hello, world!
$ make dev
Hello, world!
</code></pre>
<p>I usually bundle the <code>.PHONY</code> line directly with the command it’s associated with, which makes it easy to tell which commands are “tasks” and which ones are instructions for building files:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>dev</span><span>:</span><span> node_modules </span><span>## Start a dev server</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next dev</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>lint</span><span>:</span><span> node_modules </span><span>## Lint files for code quality</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next lint</span></span>
<span><span>.PHONY</span><span>:</span><span> lint</span></span>
<span> </span>
<span><span>format</span><span>:</span><span> node_modules </span><span>## Format code to a standard style</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/eslint --fix &#39;src/**/*.{js,jsx,ts,tsx}&#39;</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/prettier --write &#39;src/**/*.{js,jsx,ts,tsx}&#39;</span></span>
<span><span>.PHONY</span><span>:</span><span> format</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<h3 id="referencing-node_modules-binaries"><a aria-hidden="true" href="#referencing-node_modules-binaries"></a>Referencing node_modules binaries</h3>
<p>In web projects, you’ll often want to reference tools installed via <code>yarn</code> or <code>npm</code>, like <code>next</code>, <code>prettier</code>, or <code>eslint</code>. In npm/yarn scripts, you reference these utilities by name:</p>
<div data-rehype-pretty-code-fragment=""><p>package.json</p><pre data-language="json" data-theme="default"><code data-language="json" data-theme="default"><span><span>{</span></span>
<span><span>  </span><span>&#34;scripts&#34;</span><span>:</span><span> {</span></span>
<span><span>    </span><span>&#34;format&#34;</span><span>:</span><span> </span><span>&#34;prettier --write &#39;src/**/*.{js,jsx,ts,tsx}&#39;&#34;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre></div>
<p>Under the hood, these scripts are stored in the <code>node_modules/.bin</code> directory. When you run <code>yarn dev</code>, it adds that directory to your <code>$PATH</code>, so running <code>yarn next</code> refers to the local installation instead of any global ones.</p>
<p>In Makefiles, we can reference these tools by being explicit. Write <code>./node_modules/.bin/&lt;name&gt;</code> before commands you want to use. So instead of <code>prettier</code>, you write:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>format</span><span>:</span><span> node_modules</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/prettier --write &#39;src/**/*.{js,jsx,ts,tsx}&#39;</span></span>
<span><span>.PHONY</span><span>:</span><span> format</span></span></code></pre></div>
<p>This explicitness has the benefit of throwing an error if the local <code>prettier</code> isn’t installed (but it should be if you <a href="#auto-installing-node_modules">set up node_modules as a dependency</a>).</p>
<p>There are techniques to modify your <code>$PATH</code> inside Makefiles, but they don’t seem to work consistently with the version of <code>make</code> that ships with macOS.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup> Better to keep things simple.</p>
<h3 id="auto-installing-node_modules"><a aria-hidden="true" href="#auto-installing-node_modules"></a>Auto-installing node_modules</h3>
<p>When working with teammates unfamiliar with Node, I’ll sometimes help troubleshoot errors like this:</p>
<blockquote>
<p>I ran <code>yarn start</code> and got this error:</p>
<pre><code>$ yarn start
$ run-p start:*
/bin/sh: run-p: command not found
error Command failed with exit code 127.
</code></pre>
</blockquote>
<p>This message means they tried running <code>yarn start</code> without running <code>yarn install</code> first. But it’s not terribly clear that’s how to resolve the error unless you know what you’re looking for.</p>
<p>Instead, with <code>make</code>, we can express the relationship between all these dependent tasks at once so we don’t need to think about them again.</p>
<p>For example, if we create a task to build node_modules when package.json changes, we can leverage that in all the other scripts:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>dev</span><span>:</span><span> node_modules</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next dev</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>build</span><span>:</span><span> node_modules</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next build</span></span>
<span><span>.PHONY</span><span>:</span><span> build</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<p>Running <code>make dev</code> will install node_modules first, then run the <code>dev</code> command after. And on subsequent runs, it’ll skip the install step and just run the dev command.</p>
<h3 id="skipping-re-runs-of-slow-tasks"><a aria-hidden="true" href="#skipping-re-runs-of-slow-tasks"></a>Skipping re-runs of slow tasks</h3>
<p>For slow tasks, you can save time on subsequent runs by adding known dependencies to your rules.</p>
<p>For example, when working on a Next.js app locally, Next runs data fetching functions like <code>getStaticProps</code> on every page navigation. Sometimes, when I’m working on a feature that requires me to navigate between pages quickly (like transitions between pages), I run a production build to avoid the delay of the data fetching when previewing my work.</p>
<p>With <code>make</code>, I do this by defining the dependent files and folders, which we should rebuild the output for when they change. For this Next.js example, it means we can run a production build and start up the server. When running the command again, if the production build is up-to-date, we can just start up the server without the delay of rebuilding.</p>
<p>In order to get a list of all the files in a directory, we can use the <code>$(shell &lt;cmd&gt;)</code> expression and the <code>find</code> command:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>start</span><span>:</span><span> node_modules .next</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next start</span></span>
<span><span>.PHONY</span><span>:</span><span> start</span></span>
<span> </span>
<span><span>.next</span><span>:</span><span> node_modules next.config.js </span><span>$(</span><span>shell</span><span> find src -type f -name &#34;</span><span>*</span><span>.ts&#34; -o -name &#34;</span><span>*</span><span>.tsx&#34;)</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next build</span></span></code></pre></div>
<p>Now running <code>make start</code>:</p>
<pre><code>$ make start
# ... next.js build output
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
</code></pre>
<p>Running it again skips the build and just starts the server, since the files haven’t changed.</p>
<pre><code>$ make start
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
</code></pre>
<p>You can add different file extensions by adding more instances of <code>-o -name &#34;*.&lt;ext&gt;&#34;</code>. To add CSS files to the mix:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>.next</span><span>:</span><span> node_modules next.config.js </span><span>$(</span><span>shell</span><span> find src -type f -name &#34;</span><span>*</span><span>.ts&#34; -o -name &#34;</span><span>*</span><span>.tsx&#34; -o -name &#34;</span><span>*</span><span>.css&#34;)</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next build</span></span></code></pre></div>
<h3 id="using-environment-variables"><a aria-hidden="true" href="#using-environment-variables"></a>Using environment variables</h3>
<p>To use env variables you’ve defined in a local file, like a <code>.env</code>, you can
use the following block at the top of your Makefile:</p>

<p>I find this makes it easy to store secret token for one-off tasks like API calls or just avoiding installing a dotenv dependency into my projects:</p>
<div data-rehype-pretty-code-fragment=""><p>.env</p><pre data-language="shell" data-theme="default"><code data-language="shell" data-theme="default"><span><span>SSH_USER</span><span>=</span><span>&#34;user&#34;</span></span>
<span><span>SSH_HOST</span><span>=</span><span>&#34;example.com&#34;</span></span>
<span><span>SSH_DIR</span><span>=</span><span>&#34;public_html&#34;</span></span></code></pre></div>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>include</span><span> .env</span></span>
<span><span>export</span></span>
<span> </span>
<span><span>content</span><span>:</span><span>  </span><span>## Sync content from the server to the local environment.</span></span>
<span><span>	</span><span>@</span><span>rsync -avz --delete &#34;</span><span>$(SSH_USER)</span><span>@</span><span>$(SSH_HOST)</span><span>:</span><span>$(SSH_DIR)</span><span>/content/&#34; content/</span></span></code></pre></div>
<h3 id="configuring-tasks-with-default-variables"><a aria-hidden="true" href="#configuring-tasks-with-default-variables"></a>Configuring tasks with default variables</h3>
<p>Using <code>?=</code> you can set default variables that you can override outside of <code>make</code>. This lets you expose some configuration options to Makefile users.</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>PORT </span><span>?=</span><span> 9000</span></span>
<span> </span>
<span><span>dev</span><span>:</span><span> node_modules</span></span>
<span><span>	</span><span>@</span><span>php -S localhost:</span><span>$(PORT)</span><span> index.php</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<p>Now you can customize the port (while falling back to a default value) like so:</p>
<pre><code>$ PORT=2000 make dev
PHP 8.2.1 Development Server (http://localhost:2000) started
</code></pre>
<h3 id="self-documenting-makefiles"><a aria-hidden="true" href="#self-documenting-makefiles"></a>Self-documenting Makefiles</h3>
<p>Makefiles can grow to contain lots of commands over time. One trick I’ve seen is to use this <code>make help</code> target to document important scripts:</p>
<div data-rehype-pretty-code-fragment=""><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>help</span><span>:</span><span> </span><span>## Show this help</span></span>
<span><span>	</span><span>@</span><span>echo &#34;\nSpecify a command. The choices are:\n&#34;</span></span>
<span><span>	</span><span>@</span><span>grep -E &#39;^[0-9a-zA-Z_-]+:.*?## .*$$&#39; </span><span>$(MAKEFILE_LIST)</span><span> | awk &#39;BEGIN {FS = &#34;:.*?## &#34;}; {printf &#34;  \033[0;36m%-12s\033[m %s\n&#34;, $$1, $$2}&#39;</span></span>
<span><span>	</span><span>@</span><span>echo &#34;&#34;</span></span>
<span><span>.PHONY</span><span>:</span><span> help</span></span></code></pre></div>
<p>Using this, you can document commands with a <code>## comment</code> at the end of a line. For example:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>dev</span><span>:</span><span> node_modules </span><span>## Start a local development server</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next dev</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>format</span><span>:</span><span> node_modules </span><span>## Format all source files</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/prettier --write &#39;src/**/*.{ts,tsx}&#39;</span></span>
<span><span>.PHONY</span><span>:</span><span> format</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<p>Adding this target means running <code>make help</code> will list all the targets labelled with the <code>## comment</code>. Use this to call out important commands for yourself or your teammates.</p>
<pre><code>$ make help

Specify a command. The choices are:

  dev          Start a local development server
  format       Format all source files
  clean        Clean all built files
  help         Show this help
</code></pre>
<h3 id="parallel-dev-servers"><a aria-hidden="true" href="#parallel-dev-servers"></a>Parallel dev servers</h3>
<p>I’ll often want to run multiple long-lived processes while working on a project. For example, a recent website I worked on uses:</p>
<ul>
<li>A <code>php -S</code> dev server</li>
<li>A <code>tailwindcss --watch</code> process</li>
<li>An <code>esbuild --watch</code> process</li>
</ul>
<p>Unfortunately, like npm/yarn scripts, <code>make</code> doesn’t have meaningful tools for running long-lived parallel tasks. There <em>are</em> technically a few ways you could get parallel servers running, but each technique gets a little fiddly for my tastes:</p>
<ul>
<li>Using <code>make -j3 &lt;a&gt; &lt;b&gt; &lt;c&gt;</code> doesn’t treat processes as a group. So if one subprocess fails (eg. a syntax error stops the Tailwind <code>--watch</code> process), the others keep on going. You lose your live-updating changes without noticing until things are broken.</li>
<li>Shell background jobs with <code>&lt;command&gt; &amp;</code> suffer the same process group issue, plus can sometimes leave processes hanging around after you Ctrl+C out.</li>
<li>External binaries like GNU’s <code>parallel</code> command, or <code>foreman</code> work, but they need separate installation steps.</li>
</ul>
<p>Thankfully, <code>make</code> doesn’t care: we can just pop into language-specific tools that are suitable for the job. In Go projects, I’ll use a custom Go script. In Node projects, I’ll use the <a href="https://www.npmjs.com/package/concurrently" target="_blank" rel="nofollow noreferrer">concurrently</a> npm package:</p>
<pre><code>yarn add --dev concurrently
</code></pre>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>PORT </span><span>?=</span><span> 9000</span></span>
<span> </span>
<span><span>dev</span><span>:</span><span> node_modules</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/concurrently \</span></span>
<span><span>		&#39;php -S localhost:$PORT index.php&#39; \</span></span>
<span><span>		&#39;./node_modules/.bin/esbuild src/*.ts --bundle --outdir=assets/ --watch&#39; \</span></span>
<span><span>		&#39;./node_modules/.bin/tailwindcss -i src/index.css -o assets/index.css --watch&#39;</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<p>You still get the nice <code>make dev</code> interface and dependency tracking, but proper parallel dev server handling behind-the-scenes.</p>
<p><strong>Update:</strong> as of recently, I’ve been using <a href="https://github.com/rosszurowski/tandem" target="_blank" rel="nofollow noreferrer">tandem</a>, a tool I built for running multiple commands as a process group. You pass it multiple commands and it runs them in parallel, shutting down the whole group if one fails.</p>
<p>It’s designed to be easily embedded in Makefiles with a one-line installation script. Add <code>.cache</code> to your <code>.gitignore</code> file, and use the following block:</p>
<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>PORT </span><span>?=</span><span> 9000</span></span>
<span> </span>
<span><span>dev</span><span>:</span><span> .cache/tandem node_modules</span></span>
<span><span>	</span><span>@</span><span>.cache/tandem \</span></span>
<span><span>		&#39;php -S localhost:$PORT index.php&#39; \</span></span>
<span><span>		&#39;esbuild src/*.ts --bundle --outdir=assets/ --watch&#39; \</span></span>
<span><span>		&#39;tailwindcss -i src/index.css -o assets/index.css --watch&#39;</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>.cache/tandem</span><span>:</span></span>
<span><span>	</span><span>@</span><span>mkdir -p $$(dirname $@)</span></span>
<span><span>	</span><span>@</span><span>curl -fsSL https://raw.githubusercontent.com/rosszurowski/tandem/main/install.sh | bash -s -- --dest=&#34;$$(dirname $@)&#34;</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span></code></pre></div>
<p>The first time you run <code>make dev</code>, it’ll download and cache it for future uses.</p>
<h3 id="hermetic-environments"><a aria-hidden="true" href="#hermetic-environments"></a>Hermetic environments</h3>
<p>Building on <a href="#auto-installing-node_modules">the auto-installing node_modules technique</a>: you can get fancy with dependencies to download local versions of your <em>entire</em> toolchain. This way everyone runs the same version of everything, without the slowness of using Docker.</p>
<p>This snippet reads yarn and node versions from files called <code>yarn.rev</code> and <code>node.rev</code>, downloads local copies into the <code>tool</code>, and uses those instances for all your scripts.</p>


<div data-rehype-pretty-code-fragment=""><p>Makefile</p><pre data-language="makefile" data-theme="default"><code data-language="makefile" data-theme="default"><span><span>export</span><span> CACHE_PATH </span><span>:=</span><span> .cache</span></span>
<span><span>export</span><span> PATH </span><span>:=</span><span> ./tool:</span><span>$(PATH)</span></span>
<span> </span>
<span><span>dev</span><span>:</span><span> node_modules </span><span>## Run a local development server</span></span>
<span><span>	</span><span>@</span><span>./node_modules/.bin/next dev</span></span>
<span><span>.PHONY</span><span>:</span><span> dev</span></span>
<span> </span>
<span><span>clean</span><span>:</span><span> </span><span>## Clean all build artifacts</span></span>
<span><span>	</span><span>@</span><span>rm -rf ./tool</span></span>
<span><span>	</span><span>@</span><span>rm -rf ./cache</span></span>
<span><span>	</span><span>@</span><span>rm -rf ./node_modules</span></span>
<span><span>.PHONY</span><span>:</span><span> clean</span></span>
<span> </span>
<span><span>node_modules</span><span>:</span><span> package.json tool/yarn tool/node</span></span>
<span><span>	</span><span>@</span><span>yarn install</span></span>
<span> </span>
<span><span># Reads a version number from a file called `node.rev`</span></span>
<span><span>tool/node</span><span>:</span><span> node.rev</span></span>
<span><span>	</span><span>@</span><span>mkdir -p tool</span></span>
<span><span>	</span><span>@</span><span>mkdir -p </span><span>$(CACHE_PATH)</span><span>/node</span></span>
<span><span>	</span><span>@</span><span>$(</span><span>eval</span><span> OS=$(</span><span>shell</span><span> uname -s | tr A-Z a-z))</span></span>
<span><span>	</span><span>@</span><span>$(</span><span>eval</span><span> ARCH=$(</span><span>shell</span><span> uname -m | sed -e &#34;s/x86_64/x64/&#34; | sed -e &#34;s/aarch64/arm64/&#34;))</span></span>
<span><span>	</span><span>@</span><span>read -r REV &lt;$&lt; &amp;&amp; \</span></span>
<span><span>		cd </span><span>$(CACHE_PATH)</span><span>/node &amp;&amp; \</span></span>
<span><span>		curl -L -o node.tar.gz https://nodejs.org/dist/v$$REV/node-v$$REV-</span><span>$(OS)</span><span>-</span><span>$(ARCH)</span><span>.tar.gz &amp;&amp; \</span></span>
<span><span>		tar --strip-components=1 -xzf node.tar.gz</span></span>
<span><span>	</span><span>@</span><span>echo &#34;#!/bin/sh&#34; &gt; $@</span></span>
<span><span>	</span><span>@</span><span>echo &#39;exec /usr/bin/env PATH=&#34;</span><span>$(CACHE_PATH)</span><span>/node:$$PATH&#34; &#34;</span><span>$(CACHE_PATH)</span><span>/node/bin/node&#34; &#34;$$@&#34;&#39; &gt;&gt; $@</span></span>
<span><span>	</span><span>@</span><span>chmod +x $@</span></span>
<span> </span>
<span><span># Reads a version number from a file called `yarn.rev`</span></span>
<span><span>tool/yarn</span><span>:</span><span> yarn.rev</span></span>
<span><span>	</span><span>@</span><span>mkdir -p tool</span></span>
<span><span>	</span><span>@</span><span>mkdir -p </span><span>$(CACHE_PATH)</span><span>/yarn</span></span>
<span><span>	</span><span>@</span><span>read -r REV &lt;$&lt; &amp;&amp; \</span></span>
<span><span>		cd </span><span>$(CACHE_PATH)</span><span>/yarn &amp;&amp; \</span></span>
<span><span>		curl -L -o yarn.tar.gz https://github.com/yarnpkg/yarn/releases/download/v$$REV/yarn-v$$REV.tar.gz &amp;&amp; \</span></span>
<span><span>		tar --strip-components=1 -xzf yarn.tar.gz</span></span>
<span><span>	</span><span>@</span><span>echo &#34;#!/bin/sh&#34; &gt; $@</span></span>
<span><span>	</span><span>@</span><span>echo &#39;exec /usr/bin/env PATH=&#34;</span><span>$(CACHE_PATH)</span><span>/yarn:$$PATH&#34; &#34;</span><span>$(CACHE_PATH)</span><span>/yarn/bin/yarn&#34; &#34;$$@&#34;&#39; &gt;&gt; $@</span></span>
<span><span>	</span><span>@</span><span>chmod +x $@</span></span></code></pre></div>
<p>This example probably pushes the limit of what should go directly in a Makefile vs. being broken out into a separate shell script or tool, but hopefully it demonstrates the extent to which you can automate your dev environment with Makefiles.</p>
<p>We use something similar to this <a href="https://tailscale.com" target="_blank" rel="nofollow noreferrer">at Tailscale</a>, and it greatly simplifies getting new teammates started, and upgrading versions of core dependencies like Go, Node, or Yarn.</p>
<hr/>
<h3 id="limitations"><a aria-hidden="true" href="#limitations"></a>Limitations</h3>
<p>While <code>make</code> is great for many projects, it’s not always the right thing to reach for. A few cases where you should avoid it:</p>
<ul>
<li><strong>If you’re working with Windows.</strong> Makefiles usually rely on a lot of UNIX tools and conventions, like <code>ENV=val</code> environment variables, or <code>awk</code>, <code>sed</code>, and <code>grep</code>, which don’t work on Windows. It’s possible to make cross-platform Makefiles, but if this is important to you, it may be better to use a tool that abstracts away platform differences.</li>
<li><strong>If you’re automating complex builds.</strong> <code>make</code> gives you simple tools for simple builds. With involved chains of dependencies, Makefiles get unwieldly fast. If you start mucking with file modification timestamps, dealing with weird shell quoting rules or anything to do with automake, you’ve probably gone too far, and would be better served by another tool.</li>
<li><strong>If you already have a setup you’re happy with</strong>. For simple projects, npm/yarn scripts can be enough! Don’t change if you’ve got something working. That said, I find Make’s speed, simplicity, and little bit of extra flexibility helpful, and suggest you give it a try.</li>
</ul>
<h3 id="reference-makefiles"><a aria-hidden="true" href="#reference-makefiles"></a>Reference Makefiles</h3>
<ul>
<li>The <a href="https://github.com/stripe/stripe-cli/blob/master/Makefile" target="_blank" rel="nofollow noreferrer">stripe-cli</a> has some great snippets, including a <code>// TODO:</code> comment finder, a Git tag generator, and Git hook installation step.</li>
<li>This <a href="https://github.com/tailscale/docker-extension/blob/main/Makefile" target="_blank" rel="nofollow noreferrer">Tailscale docker desktop extension</a> shows using a Makefile to make a nicer dev experience. Rather than manually building containers, installing them, and configuring dev server options, I composed them into some commands that made working on the project a lot easier.</li>
<li>This <a href="https://gist.github.com/rosszurowski/24bdc2cce3bd440e6210c9c7d7164745" target="_blank" rel="nofollow noreferrer">Kirby CMS Makefile</a> which has commands to update a vendored dependency, sync content with a remote server, and deploy via rsync to a PHP server.</li>
</ul>
<p>Know other good web-centric Makefiles? <a href="mailto:ross@rosszurowski.com">Let me know!</a></p>
</div></div>
  </body>
</html>
