<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2024/01/25/we-build-x-509-chains-so-you-dont-have-to/">Original</a>
    <h1>We build X.509 chains so you don&#39;t have to</h1>
    
    <div id="readability-page-1" class="page"><article id="post-106130">
	<!-- .entry-header -->

	<div>
		<p><em>By William Woodruff</em></p>
<p>For the past eight months, Trail of Bits has worked with the <a href="https://github.com/pyca">Python Cryptographic Authority</a> to build <a href="https://github.com/pyca/cryptography/tree/main/src/rust/cryptography-x509-verification">cryptography-x509-verification</a>, a brand-new, pure-Rust implementation of the X.509 path validation algorithm that TLS and other encryption and authentication protocols are built on. Our implementation is fast, standards-conforming, and memory-safe, giving the Python ecosystem a modern alternative to OpenSSL’s <a href="https://blog.trailofbits.com/2023/12/22/catching-openssl-misuse-using-codeql/">misuse-</a> and <a href="https://www.openssl.org/news/vulnerabilities.html">vulnerability-prone</a> X.509 APIs for HTTPS certificate verification, among other protocols. This is a foundational security improvement that will benefit every Python network programmer and, consequently, the internet as a whole.</p>
<p>Our implementation has been <a href="https://cryptography.io/en/latest/x509/verification/">exposed as a Python API</a> and is included in <a href="https://cryptography.io/en/latest/changelog/#v42-0-0">Cryptography’s 42.0.0 release series</a>, meaning that Python developers can take advantage of it today! Here’s an example usage, demonstrating its interaction with <a href="https://pypi.org/project/certifi/">certifi</a> as a root CA bundle:</p>
<p><img fetchpriority="high" decoding="async" data-attachment-id="106133" data-permalink="https://blog.trailofbits.com/2024/01/25/we-build-x-509-chains-so-you-dont-have-to/image2-40/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?fit=1612%2C1036&amp;ssl=1" data-orig-size="1612,1036" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image2" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?fit=300%2C193&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?fit=690%2C443&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=690%2C443&amp;ssl=1" alt="" width="690" height="443" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?w=1612&amp;ssl=1 1612w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=300%2C193&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=1024%2C658&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=768%2C494&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=1536%2C987&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?resize=1200%2C771&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image2.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p>As part of our design we also developed <a href="https://x509-limbo.com/">x509-limbo</a>, a test vector and harness suite for evaluating the standards conformance and consistent behavior of various X.509 path validation implementations. x509-limbo is permissively licensed and reusable, and has already <a href="https://x509-limbo.com/anomalous-results/rust-webpki/">found</a> <a href="https://x509-limbo.com/anomalous-results/openssl-3.0.2/">validation</a> <a href="https://github.com/golang/go/issues/65085">differentials</a> across Go’s <a href="https://pkg.go.dev/crypto/x509">crypto/x509</a>, <a href="https://www.openssl.org/">OpenSSL</a>, and <a href="https://docs.rs/rustls-webpki/latest/webpki/">two</a> <a href="https://docs.rs/webpki/latest/webpki/">popular</a> pre-existing Rust X.509 validators.</p>
<h3>X.509 path validation</h3>
<p>X.509 and path validation are both too expansive to reasonably summarize in a single post. Instead, we’ll grossly oversimplify X.509 to two basic facts:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/X.509"><span>X.509</span></a><span> is a </span><i><span>certificate</span></i><span> format: it binds a </span><i><span>public key</span></i><span> and some metadata for that key (what it can be used for, the </span><i><span>subject</span></i><span> it identifies) to a </span><i><span>signature</span></i><span>, which is produced by a private key. The </span><i><span>subject</span></i><span> of a certificate can be a domain name, or some other relevant identifier.</span></li>
<li><i><span>Verifying</span></i><span> an X.509 certificate entails </span><i><span>obtaining</span></i><span> the public key for its signature, using that public key to check the signature, and (finally) validating the associated metadata against a set of validity rules (sometimes called an X.509 profile). In the context of the public web, there are two profiles that matter: </span><a href="https://datatracker.ietf.org/doc/html/rfc5280"><span>RFC 5280</span></a><span> and the </span><a href="https://cabforum.org/baseline-requirements/"><span>CA/B Forum Baseline Requirements</span></a><span> (“CABF BRs”).</span></li>
</ol>
<p>These two facts make X.509 certificates chainable: an X.509 certificate’s signature can be verified by finding the parent certificate containing the appropriate public key; the parent, in turn, has its own parent. This chain building process continues until an a priori trusted certificate is encountered, typically because of trust asserted in the host OS itself (which maintains a pre-configured set of trusted certificates).</p>
<p>Chain building (also called “path validation”) is the cornerstone of TLS’s authentication guarantees: it allows a web server (like <a href="http://x509-limbo.com">x509-limbo.com</a>) to serve an untrusted “leaf” certificate along with zero or more untrusted parents (called intermediates), which must ultimately chain to a root certificate that the connecting client already knows and trusts.</p>
<p>As a visualization, here is a valid certificate chain for <a href="http://x509-limbo.com">x509-limbo.com</a>, with arrows representing the “signed by” relationship:</p>
<p><img decoding="async" data-attachment-id="106137" data-permalink="https://blog.trailofbits.com/2024/01/25/we-build-x-509-chains-so-you-dont-have-to/image33/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?fit=2314%2C866&amp;ssl=1" data-orig-size="2314,866" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image33" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?fit=300%2C112&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?fit=690%2C258&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=690%2C258&amp;ssl=1" alt="" width="690" height="258" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?w=2314&amp;ssl=1 2314w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=300%2C112&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=1024%2C383&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=768%2C287&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=1536%2C575&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=2048%2C766&amp;ssl=1 2048w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?resize=1200%2C449&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/image33.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p>In this scenario, <a href="http://x509-limbo.com">x509-limbo.com</a> serves us two initially untrusted certificates: the leaf certificate for <a href="http://x509-limbo.com">x509-limbo.com</a> itself, along with an intermediate (Let’s Encrypt R3) that signs for the leaf.</p>
<p>The intermediate in turn is signed for by a root certificate (ISRG Root X1) that’s already trusted (by virtue of being in our OS or runtime trust store), giving us confidence in the complete chain, and thus the leaf’s public key for the purposes of TLS session initiation.</p>
<h3>What can go wrong?</h3>
<p>The above explanation of X.509 and path validation paints a bucolic picture: to build the chain, we simply iterate through our parent candidates at each step, terminating on success once we reach a root of trust or with failure upon exhausting all candidates. Simple, right?</p>
<p>Unfortunately, the reality is far messier:</p>
<ul>
<li><span>The abstraction above (“one certificate, one public key”) is a </span><b>gross oversimplification</b><span>. In reality, a single public key (corresponding to a single “logical” issuing authority) may have multiple “physical” certificates, for cross-issuance purposes.</span></li>
<li><span>Because the trusted set is defined by the host OS or language runtime, </span><b>there is no “one true” chain</b><span> for a given leaf certificate. In reality, most </span><span>(leaf, [intermediates])</span><span> tuples have several candidate solutions, of which </span><i><span>any</span></i><span> is a valid chain.</span>
<ul>
<li><span>This is the “why” for the first bullet: a web server can’t guarantee that any particular client has any particular set of trusted roots, so intermediate issuers typically have multiple certificates for a single public key to maximize the likelihood of a successfully built chain.</span></li>
</ul>
</li>
<li><span>Not all certificates are made equal: certificates (including different “physical” certificates for the same “logical” issuing authority) can contain constraints that prevent otherwise valid paths: </span><a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10"><span>name restrictions</span></a><span>, </span><a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.9"><span>overall length restrictions</span></a><span>, </span><a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12"><span>usage restrictions</span></a><span>, and so forth. In other words, a correct path building implementation </span><b>must be able to backtrack</b><span> after encountering a constraint that eliminates the current candidate chain.</span></li>
<li><span>The X.509 profile </span><i><span>itself</span></i><span> can impose constraints on both the overall chain and its constituent members: the CABF BRs, for example, forbid known-weak signature algorithms and public key types, and many path validation libraries additionally allow users to constrain valid chain constructions below a configurable maximum length.</span></li>
</ul>
<p>In practice, these (non-exhaustive) complications mean that our simple recursive linear scan for chain building is really a depth-first graph search with both static and dynamic constraints. Failing to treat it as such has catastrophic consequences:</p>
<ul>
<li><span>Failing to implement a dynamic search typically results in </span><b>overly conservative</b><span> chain constructions, sometimes with Internet-breaking outcomes. OpenSSL 1.0.x’s inability to build the “</span><a href="https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6"><span>chain of pain</span></a><span>” in 2020 is one recent example of this.</span></li>
<li><span>Failing to honor the interior constraints and profile-wide certificate requirements can result in </span><b>overly permissive</b><span> chain constructions. </span><a href="https://www.cve.org/CVERecord?id=CVE-2021-3450"><span>CVE-2021-3450</span></a><span> is one recent example of this, causing some configurations of OpenSSL 1.1.x to accept chains built with non-CA certificates.</span></li>
</ul>
<p>Consequently, building both correct and maximal (in the sense of finding any valid chain) X.509 path validator is of the utmost importance, both for availability and security.</p>
<h3>Quirks, surprises, and ambiguities</h3>
<p>Despite underpinning the Web PKI and other critical pieces of Internet infrastructure, there are relatively few independent implementations of X.509 path validation: most platforms and languages reuse one of a small handful of common implementations (OpenSSL and its forks, <a href="https://github.com/nss-dev/nss">NSS</a>, Go’s <a href="https://pkg.go.dev/crypto/x509">crypto/x509</a>, GnuTLS, etc.) or the host OS’s implementation (<a href="https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptoapi-system-architecture">CryptoAPI</a> on Windows, <a href="https://developer.apple.com/documentation/security">Security</a> on macOS). This manifests as a few recurring quirks and ambiguities:</p>
<ul>
<li><span>A lack of implementation diversity means that mistakes and design decisions (such as overly or insufficiently conservative profile checks) leak into other implementations: users complain when a PKI deployment that was only tested on OpenSSL fails to work against crypto/x509, so implementations frequently bend their specification adherence to accommodate real-world certificates.</span></li>
<li><span>The specifications often mandate surprising behavior that (virtually) no client implements correctly. RFC 5280, for example, stipulates that path length and name constraints do not apply to self-issued intermediates, but this is </span><a href="https://x509-limbo.com/testcases/pathlen/#pathlenself-issued-certs-pathlen"><span>widely</span></a> <a href="https://x509-limbo.com/testcases/rfc5280/#rfc5280ncpermitted-self-issued"><span>ignored</span></a><span> in practice.</span></li>
<li><span>Because the specifications themselves are so infrequently interpreted, they contain still-unresolved ambiguities: treating roots as “trust anchors” versus policy-bearing certificates, </span><a href="https://github.com/golang/go/issues/33310"><span>handling of serial numbers that are 20 bytes long but DER-encoded with 21 bytes</span></a><span>, and so forth.</span></li>
</ul>
<p>Our implementation needed to handle each of these families of quirks. To do so consistently, we leaned on three basic strategies:</p>
<ul>
<li><i><span>Test first, then implement</span></i><span>: To give ourselves confidence in our designs, we built x509-limbo and pre-validated it against other implementations. This gave us both a coverage baseline for our own implementation, </span><i><span>and</span></i><span> empirical justification for relaxing various policy-level checks, where necessary.</span></li>
<li><i><span>Keep everything in Rust:</span></i><span> Rust’s performance, strong type system and safety properties meant that we could make rapid iterations to our design while focusing on algorithmic correctness rather than memory safety. It certainly didn’t hurt that PyCA Cryptography’s X.509 parsing is </span><a href="https://github.com/pyca/cryptography/tree/main/src/rust/cryptography-x509"><span>already done in Rust</span></a><span>, of course.</span></li>
<li><i><span>Obey </span></i><a href="https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6"><i><span>Sleevi’s Laws</span></i></a><i><span>: </span></i><span>Our implementation treats path construction and path validation as a single unified step with no “one” true chain, meaning that the </span><i><span>entire</span></i><span> graph is always searched before giving up and returning a failure to the user.</span></li>
<li><i><span>Compromise where necessary:</span></i><span> As mentioned above, implementations frequently maintain compatibility with OpenSSL, even where doing so violates the profiles defined in RFC 5280 and the CABF BRs. This situation has improved dramatically over the years (and improvements have accelerated in pace, as certificate issuance periods have shortened on the Web PKI), but some compromises are still necessary.</span></li>
</ul>
<h3>Looking forward</h3>
<p>Our initial implementation is production-ready, and comes in at around 2,500 lines of Rust, not counting the relatively small Python-only API surfaces or x509-limbo:</p>
<ul>
<li><i><span>Expose APIs for client certificate path validation.</span></i><span> To expedite things, we’ve focused the initial implementation on server validation (verifying that a leaf certificate attesting to a specific DNS name or IP address chains up to a root of trust). This ignores </span><i><span>client validation</span></i><span>, wherein the client side of a connection presents its own certificate for the server to verify against a set of known principals. Client path validation shares the same fundamental chain building algorithm as server validation, but has a slightly different ideal public API (since the client’s identity needs to be matched against a potentially arbitrary number of identities known to the server).</span></li>
<li><i><span>Expose different X.509 profiles (and more configuration knobs).</span></i><span> The current APIs expose very little configuration; the only things a user of the Python API can change are the certificate subject, the validation time, and the maximum chain depth. Going forward, we’ll look into exposing additional knobs, including pieces of state that will allow users to perform verifications with the RFC 5280 certificate profile and other common profiles (like Microsoft’s Authenticode profile). Long term, this will help bespoke (such as corporate) PKI use cases to migrate to Cryptography’s X.509 APIs and lessen their dependency on OpenSSL.</span></li>
<li><a href="https://en.wikipedia.org/wiki/Carcinisation"><i><span>Carcinize</span></i></a><i><span> existing C and C++ X.509 users</span></i><span>. One of Rust’s greatest strengths is its native, zero-cost compatibility with C and C++. Given that C and C++ implementations of X.509 and path validation have historically been significant sources of exploitable memory corruption bugs, we believe that a thin “native” wrapper around </span><span>cryptography-x509-verification</span><span> could have an outsized positive impact on the security of major C and C++ codebases.</span></li>
<li><i><span>Spread the gospel of x509-limbo.</span></i><span> x509-limbo was an instrumental component in our ability to confidently ship an X.509 path validator. We’ve written it in such a way that should make integration into other path validation implementations as simple as downloading and consuming </span><a href="https://github.com/trailofbits/x509-limbo/blob/main/limbo.json"><span>a single JSON file</span></a><span>. We look forward to helping other implementations (such as </span><a href="https://github.com/rustls/webpki/issues/206"><span>rustls-webpki</span></a><span>) integrate it directly into their own testing regimens!</span></li>
</ul>
<p>If any of these ideas interests you (or you have any of your own), please <a href="http://opensource@trailofbits.com">get in touch</a>! Open source is <a href="https://www.trailofbits.com/opensource/">key to our mission</a> at Trail of Bits, and we’d love to hear about <a href="https://www.youtube.com/watch?v=ECNcAnu77a4">how we can help you</a> and your team take the fullest advantage of and <a href="https://www.trailofbits.com/services/security-engineering/#ecosystem-security">further secure</a> the open-source ecosystem.</p>
<h3>Acknowledgments</h3>
<p>This work required the coordination of multiple independent parties. We would like to express our sincere gratitude to each of the following groups and individuals:</p>
<ul>
<li><span>The </span><a href="https://www.sovereigntechfund.de/"><span>Sovereign Tech Fund</span></a><span>, whose vision for OSS security and </span><a href="https://www.sovereigntechfund.de/tech/python-package-index"><span>funding</span></a><span> made this work possible. </span></li>
<li><span>The </span><a href="https://github.com/pyca/cryptography"><span>PyCA Cryptography</span></a><span> maintainers (</span><a href="https://langui.sh/"><span>Paul Kehrer</span></a><span> and </span><a href="https://alexgaynor.net/"><span>Alex Gaynor</span></a><span>), who scoped this work from the very beginning and offered constant feedback and review throughout the development process.</span></li>
<li><span>The </span><a href="https://bettertls.com/"><span>BetterTLS</span></a><span> development team, who both reviewed and merged patches that enabled x509-limbo to vendor and reuse their (extensive) testsuite.</span></li>
</ul>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
