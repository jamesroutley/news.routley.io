<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/many-hard-leetcode-problems-are-easy-constraint/">Original</a>
    <h1>Many hard LeetCode problems are easy constraint problems</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                September 10, 2025
                
                
            </date>
            

            

            
            <h2>
                Use the right tool for the job.
            </h2>
            

            

            
            
            <p>In my first interview out of college I was asked the change counter problem:</p>
<blockquote>
<p>Given a set of coin denominations, find the minimum number of coins required to make change for a given number. IE for USA coinage and 37 cents, the minimum number is four (quarter, dime, 2 pennies).</p>
</blockquote>
<p>I implemented the simple greedy algorithm and immediately fell into the trap of the question: the greedy algorithm only works for &#34;well-behaved&#34; denominations. If the coin values were <code>[10, 9, 1]</code>, then making 37 cents would take 10 coins in the greedy algorithm but only 4 coins optimally (<code>10+9+9+9</code>). The &#34;smart&#34; answer is to use a dynamic programming algorithm, which I didn&#39;t know how to do. So I failed the interview.</p>
<p>But you only need dynamic programming if you&#39;re writing your own algorithm. It&#39;s really easy if you throw it into a constraint solver like <a href="https://www.minizinc.org/" target="_blank">MiniZinc</a> and call it a day. </p>
<div><pre><span></span><code>int: total;
array[int] of int: values = [10, 9, 1];
array[index_set(values)] of var 0..: coins;

constraint sum (c in index_set(coins)) (coins[c] * values[c]) == total;
solve minimize sum(coins);
</code></pre></div>
<p>You can try this online <a href="https://play.minizinc.dev/" target="_blank">here</a>. It&#39;ll give you a prompt to put in <code>total</code> and then give you successively-better solutions:</p>
<div><pre><span></span><code>coins = [0, 0, 37];
----------
coins = [0, 1, 28];
----------
coins = [0, 2, 19];
----------
coins = [0, 3, 10];
----------
coins = [0, 4, 1];
----------
coins = [1, 3, 0];
----------
</code></pre></div>

<p>Lots of similar interview questions are this kind of mathematical optimization problem, where we have to find the maximum or minimum of a function corresponding to constraints. They&#39;re hard in programming languages because programming languages are too low-level. They are also exactly the problems that constraint solvers were designed to solve. Hard leetcode problems are easy constraint problems.<sup id="fnref:leetcode"><a href="#fn:leetcode">1</a></sup> Here I&#39;m using MiniZinc, but you could just as easily use Z3 or OR-Tools or whatever your favorite generalized solver is.</p>
<h3>More examples</h3>

<p>This was a question in a different interview (which I thankfully passed):</p>
<blockquote>
<p>Given a list of stock prices through the day, find maximum profit you can get by buying one stock and selling one stock later.</p>
</blockquote>
<p>It&#39;s easy to do in O(n^2) time, or if you are clever, you can do it in O(n). Or you could be not clever at all and just write it as a constraint problem:</p>
<div><pre><span></span><code>array[int] of int: prices = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8];
var int: buy;
var int: sell;
var int: profit = prices[sell] - prices[buy];

constraint sell &gt; buy;
constraint profit &gt; 0;
solve maximize profit;
</code></pre></div>
<p>Reminder, link to trying it online <a href="https://play.minizinc.dev/" target="_blank">here</a>. While working at that job, one interview question we tested out was:</p>
<blockquote>
<p>Given a list, determine if three numbers in that list can be added or subtracted to give 0? </p>
</blockquote>
<p>This is a satisfaction problem, not a constraint problem: we don&#39;t need the &#34;best answer&#34;, any answer will do. We eventually decided against it for being too tricky for the engineers we were targeting. But it&#39;s not tricky in a solver; </p>
<div><pre><span></span><code>include &#34;globals.mzn&#34;;
array[int] of int: numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8];
array[index_set(numbers)] of var {0, -1, 1}: choices;

constraint sum(n in index_set(numbers)) (numbers[n] * choices[n]) = 0;
constraint count(choices, -1) + count(choices, 1) = 3;
solve satisfy;
</code></pre></div>
<p>Okay, one last one, a problem I saw last year at <a href="https://chicagopython.github.io/algosig/" target="_blank">Chipy AlgoSIG</a>. Basically they pick some leetcode problems and we all do them. I failed to solve <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank">this one</a>:</p>
<blockquote>
<p>Given an array of integers heights representing the histogram&#39;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p>
<p><img alt="example from leetcode link" src="https://assets.buttondown.email/images/63337f78-7138-4b21-87a0-917c0c5b1706.jpg?w=960&amp;fit=max"/></p>
</blockquote>
<p>The &#34;proper&#34; solution is a tricky thing involving tracking lots of bookkeeping states, which you can completely bypass by expressing it as constraints:</p>
<div><pre><span></span><code>array[int] of int: numbers = [2,1,5,6,2,3];

var 1..length(numbers): x; 
var 1..length(numbers): dx;
var 1..: y;

constraint x + dx &lt;= length(numbers);
constraint forall (i in x..(x+dx)) (y &lt;= numbers[i]);

var int: area = (dx+1)*y;
solve maximize area;

output [&#34;(\(x)-&gt;\(x+dx))*\(y) = \(area)&#34;]
</code></pre></div>
<p>There&#39;s even a way to <a href="https://docs.minizinc.dev/en/2.9.3/visualisation.html" target="_blank">automatically visualize the solution</a> (using <code>vis_geost_2d</code>), but I didn&#39;t feel like figuring it out in time for the newsletter.</p>
<h3>Is this better?</h3>
<p>Now if I actually brought these questions to an interview the interviewee could ruin my day by asking &#34;what&#39;s the runtime complexity?&#34; Constraint solvers runtimes are unpredictable and almost always than an ideal bespoke algorithm because they are more expressive, in what I refer to as the <a href="https://buttondown.com/hillelwayne/archive/the-capability-tractability-tradeoff/" target="_blank">capability/tractability tradeoff</a>. But even so, they&#39;ll do way better than a <em>bad</em> bespoke algorithm, and I&#39;m not experienced enough in handwriting algorithms to consistently beat a solver.</p>
<p>The real advantage of solvers, though, is how well they handle new constraints. Take the stock picking problem above. I can write an O(nÂ²) algorithm in a few minutes and the O(n) algorithm if you give me some time to think. Now change the problem to</p>
<blockquote>
<p>Maximize the profit by buying and selling up to <code>max_sales</code> stocks, but you can only buy or sell one stock at a given time and you can only hold up to <code>max_hold</code> stocks at a time?</p>
</blockquote>
<p>That&#39;s a way harder problem to write even an inefficient algorithm for! While the constraint problem is only a tiny bit more complicated:</p>
<div><pre><span></span><code>include &#34;globals.mzn&#34;;
int: max_sales = 3;
int: max_hold = 2;
array[int] of int: prices = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8];
array [1..max_sales] of var int: buy;
array [1..max_sales] of var int: sell;
array [index_set(prices)] of var 0..max_hold: stocks_held;
var int: profit = sum(s in 1..max_sales) (prices[sell[s]] - prices[buy[s]]);

constraint forall (s in 1..max_sales) (sell[s] &gt; buy[s]);
constraint profit &gt; 0;

constraint forall(i in index_set(prices)) (stocks_held[i] = (count(s in 1..max_sales) (buy[s] &lt;= i) - count(s in 1..max_sales) (sell[s] &lt;= i)));
constraint alldifferent(buy ++ sell);
solve maximize profit;

output [&#34;buy at \(buy)\n&#34;, &#34;sell at \(sell)\n&#34;, &#34;for \(profit)&#34;];
</code></pre></div>

<p>Most constraint solving examples online are puzzles, like <a href="https://docs.minizinc.dev/en/stable/modelling2.html#ex-sudoku" target="_blank">Sudoku</a> or &#34;<a href="https://docs.minizinc.dev/en/stable/modelling2.html#ex-smm" target="_blank">SEND + MORE = MONEY</a>&#34;. Solving leetcode problems would be a more interesting demonstration. And you get more interesting opportunities to teach optimizations, like symmetry breaking.</p>

            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://buttondown.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            





        </div></div>
  </body>
</html>
