<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rodrigodd.github.io/2023/09/02/gameroy-jit.html">Original</a>
    <h1>GameRoy: JIT Compilation in High-Accuracy Game Boy Emulation</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Over the past two years, I have spent a lot of time working on my Game Boy
emulator, <a href="https://github.com/Rodrigodd/gameroy">GameRoy</a>. It has reached a good point, where it has a GUI interface (including a
debugger and disassembler) and passes numerous tests (comparable to some of the
most accurate emulators). I even made a port to Android!</p>

<p><img src="https://rodrigodd.github.io/assets/gameroy_jit/gameroy.png" alt="GameRoy running on Android"/></p>

<p>However, there’s always been something that I wanted to do, even before
developing this emulator: implementing a dynamic recompiler, also known as a JIT
compiler. Since the first time I researched how an emulator works, one of
the initial descriptions I found was about the distinction between interpreters and
dynamic recompilers. This made me very interested in the subject.</p>

<p>Reinspired by JIT compilers (such as those in Java, JavaScript and LuaJIT), by
Dolphin’s development posts, and primarily by <a href="https://bheisler.github.io/post/experiments-in-nes-jit-compilation/">this blog post by Brook
Heisler</a> regarding a JIT compiler for NES, I began implementing one in my
emulator.</p>

<p>One intriguing point in Brook Heisler’s post was a limitation in how interrupts
were handled in the compiled code. When developing his JIT compiler, he
encountered a trade-off between performance and precision in how to handle
interrupts in his emulator. He ultimately decided to sacrifice performance for
precision, but I was not satisfied with that approach.</p>

<p>After pondering for some time, I came up with a solution to this problem - a way
to achieve maximum performance without sacrificing precision.</p>

<p>In this blog post, I will describe the process and considerations of
implementing a JIT compiler in my emulator, and how I solved the problem of
handling interrupts.</p>

<p>It’s worth noting that I am presenting the topics in the same order they came up
in my thought process, which just happens to be the reverse order in which they
were implemented (excluding the interpreter).</p>
<h2 id="interpreter-x-just-in-time-compilation">
  
  
    Interpreter x Just-In-Time compilation <a href="#interpreter-x-just-in-time-compilation">§</a>
  
  
</h2>
    

<p>An emulator has the job of reproducing a computer system’s behavior in software.
A computer system, including the Game Boy, consists of many components, each
requiring emulation. Among these, the CPU stands out as the most crucial
component, responsible for directly executing the instructions of the programs
that you intend to run on your emulator.</p>

<p>There are two main ways of emulating the CPU (or any programmable component).</p>
<h3 id="a-very-basic-interpreter">
  
  
    A very basic interpreter <a href="#a-very-basic-interpreter">§</a>
  
  
</h3>
    

<p>The simplest way to emulate a system’s CPU is by implementing an interpreter.
Essentially, the interpreter reads instructions from the emulated memory,
decodes them, and emulates their execution by updating the emulator’s state.</p>

<p>For the Game Boy, the instruction to be executed is read byte by byte (since the
Game Boy is an 8-bit system) from the memory address pointed by the program
counter (PC), incrementing the PC after each read. To decode the
instruction only the first byte is needed for most instructions. Since there are
only 255 possible values for a byte, we can use a look-up table. The Game
Boy CPU also haves 0xCB prefixed instructions that are decoded from the second
byte, using another look-up table.</p>

<p>I am using Rust for my emulator implementation, so I can use a <code>match</code> statement
to decode the instruction. Each branch of the <code>match</code> lead to a function that
implements the instruction’s execution. This function reads and writes to
registers or memory, reading additional bytes from the instructions when
necessary (e.g., for immediate values, like the address of jump instructions).</p>

<p>A very simplified for the interpreter would be something like this:</p>

<div><div><pre><code><span>fn</span> <span>interpret_instruction</span><span>(</span><span>gb</span><span>:</span> <span>&amp;</span><span>mut</span> <span>GameBoy</span><span>)</span> <span>{</span>
    <span>let</span> <span>opcode</span> <span>=</span> <span>gb</span><span>.read</span><span>(</span><span>gb</span><span>.cpu.pc</span><span>);</span>
    <span>gb</span><span>.cpu.pc</span> <span>+=</span> <span>1</span><span>;</span>
    <span>match</span> <span>opcode</span> <span>{</span>
        <span>0x00</span> <span>=&gt;</span> <span>nop</span><span>(</span><span>gb</span><span>),</span>
        <span>0x01</span> <span>=&gt;</span> <span>load_bc_im16</span><span>(</span><span>gb</span><span>),</span>
        <span>0x02</span> <span>=&gt;</span> <span>load_bc_a</span><span>(</span><span>gb</span><span>),</span>
        <span>0x03</span> <span>=&gt;</span> <span>inc_bc</span><span>(</span><span>gb</span><span>),</span>
        <span>0x04</span> <span>=&gt;</span> <span>inc_b</span><span>(</span><span>gb</span><span>),</span>
        <span>// 252 more branches like that...</span>
    <span>}</span>
<span>}</span>

<span>// ...</span>

<span>// INC B 1:4 Z 0 H -</span>
<span>fn</span> <span>inc_b</span><span>(</span><span>gb</span><span>:</span> <span>&amp;</span><span>mut</span> <span>GameBoy</span><span>)</span> <span>{</span>
    <span>gb</span><span>.cpu.b</span> <span>+=</span> <span>1</span><span>;</span>    <span>// increment B</span>
    <span>gb</span><span>.cpu.f</span> <span>&amp;=</span> <span>0x1F</span><span>;</span> <span>// clear Z, N, H flags</span>
    <span>if</span> <span>gb</span><span>.cpu.b</span> <span>==</span> <span>0</span> <span>{</span> <span>gb</span><span>.cpu.f</span> <span>|</span><span>=</span> <span>0x80</span><span>;</span> <span>}</span>       <span>// set Z flag on zero</span>
    <span>if</span> <span>gb</span><span>.cpu.b</span> <span>&amp;</span> <span>0xF</span> <span>==</span> <span>0</span> <span>{</span> <span>gb</span><span>.cpu.f</span> <span>|</span><span>=</span> <span>0x80</span><span>;</span> <span>}</span> <span>// set H flag on half carry</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>interpret_instruction</code> function is invoked in a loop, executing one
instruction per iteration.</p>

<p>One issue with this approach is that the speed at which the interpreter can
execute the code is far behind the theoretical speed that your computer’s CPU
could execute the code.</p>

<p>The interpreter requires multiple instructions of the host CPU, not only
to execute the instruction, but also to read from memory and decode it, task
that the host CPU does in a single instruction. Not only that, the interpreter
needs to decode the same instruction multiple times.</p>

<p>But that isn’t a problem, at least not for the Game Boy, whose CPU runs at a
clock speed of just a little over 1 MHz, while you might be reading this on
a device with much more than 1 GHz. In fact, GameRoy can run Game Boy games
at over 60 times the original system’s speed on my notebook with a 2.6 GHz
Intel i5-4200U.</p>

<p>Even so, this is still 41 times slower than the theoretical speed that my CPU
can execute the code! (If you assume the same number of instructions per
instruction not very reasonable, actually). Yet, there is a very interesting
technique that can be used to close this gap: <strong>recompilation</strong>.</p>
<h3 id="a-very-basic-jit-compiler">
  
  
    A very basic JIT compiler <a href="#a-very-basic-jit-compiler">§</a>
  
  
</h3>
    

<p>The second way of emulating the CPU is by translating the instructions of the
Game Boy CPU into the instructions of the host CPU and then executing them. This
method is called <strong>recompilation</strong>. In the case of the Game Boy, as well as in
many other systems, you can not recompile all the code contained in a program
beforehand (known as static recompilation). Therefore, you need to perform that
translation at runtime, which makes the technique be called <strong>dynamic
recompilation</strong>, or more commonly called, <strong>Just-In-Time compilation</strong> (or JIT).</p>

<p>To achieve this, you need to create a compiler. The compilation process is very
similar to the interpreter, where you read, decode and execute instructions. But
instead of executing the instruction directly, it will generate the
corresponding machine code that will.</p>

<p>The machine code can be generated just once and then executed multiple times,
bypassing the overhead of reading and decoding instructions of the interpreter.</p>

<p>In a simplified form, the code for the compiler would look something like this:</p>

<div><div><pre><code><span>fn</span> <span>compile_instruction</span><span>(</span><span>ctx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>JitCompiler</span><span>,</span> <span>gb</span><span>:</span> <span>&amp;</span><span>GameBoy</span><span>,</span> <span>code</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>let</span> <span>opcode</span> <span>=</span> <span>gb</span><span>.read</span><span>(</span><span>ctx</span><span>.curr_pc</span><span>);</span>
    <span>match</span> <span>opcode</span> <span>{</span>
        <span>0x00</span> <span>=&gt;</span> <span>nop</span><span>(</span><span>ctx</span><span>,</span> <span>gb</span><span>),</span>
        <span>0x01</span> <span>=&gt;</span> <span>load_bc_im16</span><span>(</span><span>ctx</span><span>,</span> <span>gb</span><span>),</span>
        <span>0x02</span> <span>=&gt;</span> <span>load_bc_a</span><span>(</span><span>ctx</span><span>,</span> <span>gb</span><span>),</span>
        <span>0x03</span> <span>=&gt;</span> <span>inc_bc</span><span>(</span><span>ctx</span><span>,</span> <span>gb</span><span>),</span>
        <span>0x04</span> <span>=&gt;</span> <span>inc_b</span><span>(</span><span>ctx</span><span>,</span> <span>gb</span><span>),</span>
        <span>// 252 more arms like that...</span>
    <span>}</span>
<span>}</span>

<span>// ...</span>

<span>// INC B 1:4 Z 0 H -</span>
<span>fn</span> <span>inc_b</span><span>(</span><span>_</span><span>:</span> <span>&amp;</span><span>mut</span> <span>JitCompiler</span><span>,</span> <span>code</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>code</span><span>.extend</span><span>(</span><span>&amp;</span><span>[</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0x47</span><span>,</span> <span>0x01</span><span>,</span> <span>// movzx  eax,BYTE PTR [rdi+0x1] ; read F</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0x4f</span><span>,</span> <span>0x02</span><span>,</span> <span>// movzx  ecx,BYTE PTR [rdi+0x2] ; read B</span>
        <span>0xfe</span><span>,</span> <span>0xc1</span><span>,</span>             <span>// inc    cl                     ; increase B</span>
        <span>0x88</span><span>,</span> <span>0x4f</span><span>,</span> <span>0x02</span><span>,</span>       <span>// mov    BYTE PTR [rdi+0x2],cl  ; write B</span>
        <span>0x24</span><span>,</span> <span>0x1f</span><span>,</span>             <span>// and    al,0x1f                ; clear Z, N, H flags</span>
        <span>0x8d</span><span>,</span> <span>0x50</span><span>,</span> <span>0x80</span><span>,</span>       <span>// lea    edx,[rax-0x80]         ; calculate the flags...</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xc0</span><span>,</span>       <span>// movzx  eax,al                 ; ...</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xd2</span><span>,</span>       <span>// movzx  edx,dl</span>
        <span>0x0f</span><span>,</span> <span>0x45</span><span>,</span> <span>0xd0</span><span>,</span>       <span>// cmovne edx,eax</span>
        <span>0x8d</span><span>,</span> <span>0x42</span><span>,</span> <span>0x20</span><span>,</span>       <span>// lea    eax,[rdx+0x20]</span>
        <span>0xf6</span><span>,</span> <span>0xc1</span><span>,</span> <span>0x0f</span><span>,</span>       <span>// test   cl,0xf</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xc0</span><span>,</span>       <span>// movzx  eax,al</span>
        <span>0x0f</span><span>,</span> <span>0x45</span><span>,</span> <span>0xc2</span><span>,</span>       <span>// cmovne eax,edx</span>
        <span>0x88</span><span>,</span> <span>0x47</span><span>,</span> <span>0x01</span><span>,</span>       <span>// mov    BYTE PTR [rdi+0x1],al  ; write F</span>
    <span>]);</span>
<span>}</span>
</code></pre></div></div>

<p>This <code>compile_instruction</code> function reads and decodes an instruction, and then
write the machine code that executes that instruction to a buffer.</p>

<p><em>(For the curious, I got that assembly/machine code by simply <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=77582b2e84dd1896f5c144a790d84e8e">implementing the
instruction in Rust</a>, and then disassembling it with <code>objdump
-d</code>.)</em></p>

<p>So, to create a JIT compiler, you only need to run <code>compile_instruction</code> on the
sequence of instructions starting at the address the <code>PC</code> is currently, write
the code to a memory page with executable permission (you can use a crate like
<a href="https://crates.io/crates/memmap2"><code>memmap2</code></a> for that), transmute it into a
function pointer, and call it! Simple as that!</p>

<p>Well, actually, some instructions that involve function calls in their
implementation or include branching are much trickier to implement than just
appending a static array of bytes to a buffer. You also need to make sure that
the code for each instruction can work together, using the same registers and so
on. You also need a prologue and epilogue for the function that satisfies a
<a href="https://en.wikipedia.org/wiki/Calling_convention">calling convention</a>.</p>

<p>However, this already shows the basics of a JIT compiler.</p>

<p>Also, in my actual implementation I used the crate <a href="https://crates.io/crates/dynasm"><code>dynasm</code></a> for
emitting the machine code (this crate has a macro that translates assembly code
into machine code at compile time), so the code is much more maintainable than
the array of raw bytes that I presented here.</p>
<h2 id="optimizations">
  
  
    Optimizations <a href="#optimizations">§</a>
  
  
</h2>
    

<p>The cool thing about compiling code is that you can do optimizations! For
example, one of the (few) optimizations that I make in the JIT compiler for my
emulator is the omission of unnecessary flag calculations (directly inspired by
the one described in <a href="https://bheisler.github.io/post/experiments-in-nes-jit-compilation/">Brook Heisler’s post</a>).</p>

<p>If you tried to read what the assembly code is doing, you may have noticed that
only instructions are used to increment the value of register B, and the
remaining 10 are being used to update the conditional flags in the register
F. But the value of F may be overwritten by the next instructions before it
could be read from a conditional jump instruction for example. In that scenario,
updating the value of F does not affect the behavior of the emulation, so it is
a waste to compute.</p>

<p>If we compile all these instructions together, we can detect that kind of
scenario and omit the flag calculation, greatly reducing the amount of code
emitted!</p>

<div><div><pre><code><span>// INC B 1:4 Z 0 H -</span>
<span>fn</span> <span>inc_b</span><span>(</span><span>ctx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>JitCompiler</span><span>,</span> <span>code</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Vec</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>)</span> <span>{</span>
    <span>if</span> <span>!</span><span>ctx</span><span>.flag_is_need</span> <span>{</span>
        <span>code</span><span>.extend</span><span>(</span><span>&amp;</span><span>[</span><span>0xfe</span><span>,</span> <span>0x47</span><span>,</span> <span>0x02</span><span>]);</span> <span>// inc BYTE PTR [rdi+0x2]</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>code</span><span>.extend</span><span>(</span><span>&amp;</span><span>[</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0x47</span><span>,</span> <span>0x01</span><span>,</span> <span>// movzx  eax,BYTE PTR [rdi+0x1] ; read F</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0x4f</span><span>,</span> <span>0x02</span><span>,</span> <span>// movzx  ecx,BYTE PTR [rdi+0x2] ; read B</span>
        <span>0xfe</span><span>,</span> <span>0xc1</span><span>,</span>             <span>// inc    cl                     ; increase B</span>
        <span>0x88</span><span>,</span> <span>0x4f</span><span>,</span> <span>0x02</span><span>,</span>       <span>// mov    BYTE PTR [rdi+0x2],cl  ; write B</span>
        <span>0x24</span><span>,</span> <span>0x1f</span><span>,</span>             <span>// and    al,0x1f                ; clear Z, N, H flags</span>
        <span>0x8d</span><span>,</span> <span>0x50</span><span>,</span> <span>0x80</span><span>,</span>       <span>// lea    edx,[rax-0x80]         ; calculate the flags...</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xc0</span><span>,</span>       <span>// movzx  eax,al                 ; ...</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xd2</span><span>,</span>       <span>// movzx  edx,dl</span>
        <span>0x0f</span><span>,</span> <span>0x45</span><span>,</span> <span>0xd0</span><span>,</span>       <span>// cmovne edx,eax</span>
        <span>0x8d</span><span>,</span> <span>0x42</span><span>,</span> <span>0x20</span><span>,</span>       <span>// lea    eax,[rdx+0x20]</span>
        <span>0xf6</span><span>,</span> <span>0xc1</span><span>,</span> <span>0x0f</span><span>,</span>       <span>// test   cl,0xf</span>
        <span>0x0f</span><span>,</span> <span>0xb6</span><span>,</span> <span>0xc0</span><span>,</span>       <span>// movzx  eax,al</span>
        <span>0x0f</span><span>,</span> <span>0x45</span><span>,</span> <span>0xc2</span><span>,</span>       <span>// cmovne eax,edx</span>
        <span>0x88</span><span>,</span> <span>0x47</span><span>,</span> <span>0x01</span><span>,</span>       <span>// mov    BYTE PTR [rdi+0x1],al  ; write F</span>
    <span>]);</span>
<span>}</span>
</code></pre></div></div>

<p>Fantastic! The optimized version is 14 times smaller than the unoptimized one!</p>

<p>There are, of course, many other optimizations that can be done. These could
reach the point where the optimizations become by far the most complex part of
a compiler. Instead of implementing them your-self, you could use a third party
compiler infrastructure, like <a href="https://llvm.org/">LLVM</a> or <a href="https://cranelift.dev/">Cranelift</a>, which
implement many optimizations for you.</p>

<p>But my emulator is, at least for now, only targeting <code>x86-64</code> machine code. So
I will refrain from using any of them.</p>

<p>But there is a big problem in trying to apply any non-trivial optimization, even
the simple flag omission one: the fact that the CPU need to handle interrupts.</p>
<h2 id="interrupts">
  
  
    Interrupts <a href="#interrupts">§</a>
  
  
</h2>
    

<p>Interrupts are a mechanism that allows the CPU to stop the execution of the
current code and start executing a function that handles the interrupt. For
example, in the Game Boy, you can use the interrupt triggered by the VBlank of
the PPU (which occurs right after the screen is fully rendered) to update the
game logic and prepare the next frame for rendering.</p>

<p>There are <a href="https://gbdev.io/pandocs/Interrupt_Sources.html">multiple sources of interrupts</a> in the Game Boy, which
are triggered by one of the various components. So to handle the interrupts we
also need to update them.</p>

<p>And if you want a precise enough emulator, you need to update the components and
check for interrupts before every single instruction. Not only that, if you
pursue cycle-accuracy, you also need to update the components before each memory
access. One way of doing that is by using a <code>tick</code> function.</p>

<p>Our interpreter becomes something like this:</p>

<div><div><pre><code><span>fn</span> <span>interpret_instruction</span><span>(</span><span>gb</span><span>:</span> <span>&amp;</span><span>mut</span> <span>GameBoy</span><span>)</span> <span>{</span>
    <span>if</span> <span>gb</span><span>.interrupts_enabled</span> <span>&amp;</span> <span>gb</span><span>.interrupts_flags</span> <span>!=</span> <span>0</span> <span>{</span>
        <span>// this will write to the stack, and change PC to the interrupts handler</span>
        <span>handle_interrupt</span><span>(</span><span>gb</span><span>);</span>
    <span>}</span>

    <span>let</span> <span>opcode</span> <span>=</span> <span>gb</span><span>.read</span><span>(</span><span>gb</span><span>.cpu.pc</span><span>);</span>
    <span>gb</span><span>.cpu.pc</span> <span>+=</span> <span>1</span><span>;</span>
    <span>tick</span><span>(</span><span>gb</span><span>,</span> <span>4</span><span>);</span> <span>// each memory access takes 4 cycles</span>
    <span>match</span> <span>opcode</span> <span>{</span>
        <span>// ...</span>
        <span>0x36</span> <span>=&gt;</span> <span>ld_hl_im8</span><span>(</span><span>gb</span><span>),</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>tick</span><span>(</span><span>gb</span><span>:</span> <span>&amp;</span><span>mut</span> <span>GameBoy</span><span>,</span> <span>cycles</span><span>:</span> <span>u64</span><span>)</span> <span>{</span>
    <span>gb</span><span>.clock_count</span> <span>+=</span> <span>cycles</span><span>;</span>

    <span>gb</span><span>.update_timer</span><span>(</span><span>clock_count</span><span>);</span>
    <span>gb</span><span>.update_ppu</span><span>(</span><span>clock_count</span><span>);</span>
    <span>gb</span><span>.update_sound_controller</span><span>(</span><span>clock_count</span><span>);</span>
    <span>gb</span><span>.update_serial</span><span>(</span><span>clock_count</span><span>);</span>
<span>}</span>

<span>// LD (HL),d8 2:12 - - - -</span>
<span>fn</span> <span>ld_hl_im8</span><span>(</span><span>gb</span><span>:</span> <span>&amp;</span><span>mut</span> <span>GameBoy</span><span>)</span> <span>{</span>
    <span>let</span> <span>value</span> <span>=</span> <span>gb</span><span>.read</span><span>(</span><span>gb</span><span>.cpu.pc</span><span>);</span>
    <span>gb</span><span>.cpu.pc</span> <span>+=</span> <span>1</span><span>;</span>
    <span>tick</span><span>(</span><span>gb</span><span>,</span> <span>4</span><span>);</span>

    <span>let</span> <span>address</span> <span>=</span> <span>gb</span><span>.cpu.h</span> <span>as</span> <span>u16</span> <span>*</span> <span>0x100</span> <span>+</span> <span>gb</span><span>.cpu.l</span> <span>as</span> <span>u16</span><span>;</span>
    <span>gb</span><span>.write</span><span>(</span><span>address</span><span>,</span> <span>value</span><span>);</span>
    <span>tick</span><span>(</span><span>gb</span><span>,</span> <span>4</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Ignoring all the complexity of emulating each component and some quirks with
interrupt handling timing, this is roughly how the interpreter handles the
interrupts.</p>

<p>However, handling interrupts poses a problem for our JIT compiler. Not only
might constantly checking for interrupts introduce a considerable amount of
overhead, but we can no longer apply many of the optimizations that we would
like to do, like omitting calculation, because the code needs to always
be prepared to branch to the interrupt handler.</p>

<p>You could try to check for interrupts only every 10 instructions or something;
it may be precise enough for most games (but not all). But my emulator pursues
maximum accuracy, and the point of the JIT compiler is to determine if it’s
possible to implement it, without sacrificing precision or performance.</p>

<p>And I have figured out a way to achieve that: by estimating when the next
interrupt will happen.</p>
<h2 id="estimating-the-next-interrupt">
  
  
    Estimating the next interrupt <a href="#estimating-the-next-interrupt">§</a>
  
  
</h2>
    

<p>The JIT compiler in GameRoy works this way: given the current address in the
PC register and the bank currently mapped to that address, the compiler produces
a block of instructions starting at that address. This block is then compiled
down into machine code, and stored in a cache.</p>

<p>Before executing the block, it checks if an interrupt will happen during its
execution. If not, the block is executed, otherwise, we fall back to the
interpreter.</p>

<p>This allows us to apply all the optimizations that we want, without worrying
about interrupts (for the most part).</p>

<p>The disadvantage is that we still need to have an interpreter around, and the
fallback may decrease the emulator’s performance. However, I already had an
interpreter working, so there’s no problem with that. Only a small fraction of
the instructions need to be interpreted, so the loss of performance is not so
bad. An alternative is to use, as a fallback, a version of the compiler that
handles interrupts.</p>

<p>The main challenge in this approach is estimating when the next interrupt will
happen. Depending on how a component generates interrupts, it may just not be
possible to estimate when the next interrupt will happen more efficiently than
just emulating the component until it occurs.</p>

<p>Thankfully, in the case of the components of the Game Boy, it is possible to
estimate the instant of the next interrupt in constant time. But implementing
the estimation is still tricky, with a lot of edge cases. Thanks to a lot of
<a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing-based testing</a>, I am somewhat
confident that I got it right.</p>

<p>If you want to take a look at how the implementation looks like, here are
links for the <a href="https://github.com/Rodrigodd/gameroy/blob/4ac46fff3a203c20aadbb108585354701a52546e/core/src/gameboy/timer.rs#L262-L306">timer</a>, for the <a href="https://github.com/Rodrigodd/gameroy/blob/4ac46fff3a203c20aadbb108585354701a52546e/core/src/gameboy/ppu.rs#L1536-L1723">PPU</a>,
and for the <a href="https://github.com/Rodrigodd/gameroy/blob/4ac46fff3a203c20aadbb108585354701a52546e/core/src/gameboy/serial_transfer.rs#L121-L131">serial</a>. The fuzz tests are at the bottom
of the same file, if you also want to take a look at them.</p>
<h2 id="lazy-update">
  
  
    Lazy Update <a href="#lazy-update">§</a>
  
  
</h2>
    

<p>And with that we fix the problem with interrupts! But we still need to update
the components. But thankfully we only need to update the components before
accessing a memory address that is mapped to a component or right before an
interrupt is triggered. So we can just update the components in the memory access
function, right before reading or writing to memory, and before checking for
interrupts in the interpreter.</p>

<p>To implement that, each component will contain a clock count of the last time it
was updated, and a function that updates the component to the current clock
count. The cool part is that this allows us to further optimize the emulation of
each component. By decreasing the number of times we update each component we
save some work, and emulating many cycles at once allows more efficient
emulation.</p>

<p>The implementation of the PPU is a good example of that. The PPU is the
component responsible for transforming the tile map and sprite data into pixels
for the screen. The final rendering result is somewhat straightforward to
emulate if the input data doesn’t change. But the necessity of taking into
account that the CPU may be changing the input during rendering makes it
necessary to emulate the <a href="https://gbdev.io/pandocs/pixel_fifo.html">complex inner workings of the
PPU</a>.</p>

<p>But when we lazily update the PPU we can be sure that there were no changes since
the last update, allowing us to bypass most of the complexity of the PPU, 
just emulating the final rendering result, which is much faster.</p>

<p>In the figure below we can view the time spent emulating the PPU, when updating
it every instruction and when updating only when necessary.</p>

<p><img src="https://rodrigodd.github.io/assets/gameroy_jit/interrupt-prediction.svg" alt="PPU emulation time"/></p>

<p>The <code>draw_scan_line</code> function renders the final result of a scan line, without
emulating the entire PPU’s inner workings. Doing the math, it is possible to see
that the emulation of the PPU gains a speed-up of almost 10 times, increasing the
overall speed of the emulator by 4.</p>

<p>One thing to notice is that before this optimization, only 14% of the time was
spent in the CPU. That means the CPU emulation was hardly the bottleneck of the
emulator, and the JIT compiler would not provide a significant speed-up. But
after this optimization, the CPU emulation is responsible for 63% of the time,
giving some room for the JIT compiler to shine.</p>
<h2 id="the-compiler-a-little-more-in-depth">
  
  
    The Compiler a little more in depth <a href="#the-compiler-a-little-more-in-depth">§</a>
  
  
</h2>
    

<p>Above, I’ve just provided a simplified version of how a JIT compiler would work.
However, the actual implementation concerns itself with more details.</p>

<p>First, it needs to decide which group of instructions to compile. For that,
I have a step for “tracing a block”, which basically starts at a given address
(very likely the current address in the PC register) and decodes instructions
one after the other, until it reaches an unconditional branch (like a jump or a
call). This produces a block for that address.</p>

<p>Currently, the blocks are just linear sequences of instructions, but I could
very well also expand the block tracing to follow branches and potentially
compile big sections of the program at once. However, my block caching is still
too suboptimal for that (I explain it in the <a href="#remaining-work">“Remaining Work”</a>
section).</p>

<p>An important point is that I only trace blocks when the PC is pointing to an
address in the memory ROM (range <code>0x0000</code> to <code>0xFFFF</code>). If it is pointing
outside of it, like the RAM, I just fall back to the interpreter. This allows me
to avoid handling self-modifying code, which is a general problem for dynamic
recompilers. Also, games in general don’t run much code in RAM, so it’s not that
big of a loss.</p>

<p>Another point is that the Game Boy uses bank switching, which means that
different memory banks may be mapped into the same addresses at different
times. So, a block needs to be identified not only by its starting address but
also by a bank number.</p>

<p>After tracing a block, the compiler compiles it down to a function. It
emits machine code for the function prologue (align the stack, push registers,
etc.), and then emits the machine code for each instruction.</p>

<p>Instructions that update registers work like the one I gave as an example
before. They just load the registers from memory, do the operation, and store
them back. A much more efficient way would be to keep the Game Boy registers in
the x86-64 registers for as long as possible, but I still haven’t implemented
that.</p>

<p>Instructions that may branch check if the target address is inside the block,
and if it is, they emit a jump to the target address inside the block. This uses
<a href="https://crates.io/crates/dynasm"><code>dynasm</code></a> helper for emitting jumps. If the target isn’t in the block,
it just emits the prologue for the block (pop registers and call <code>ret</code>).</p>

<p>Instructions that read or write to memory emit function calls to Rust functions
that handle the memory access. This allows me to handle cases where it may
change the emulator’s state, like the lazy update of components. But memory
access with an immediate address may be emitted inline if possible.</p>

<p>Another important point is that writing to memory may trigger an interrupt, or
at least change its timing. This means that after each write, the compiler needs
to emit another check for interrupts, exiting if necessary. The same is true for
bank switching: a write to ROM could switch the bank that the block is currently
executing, so it needs to check if it did change and exit the block.</p>

<p>Also, because writes can trigger interrupts and the interrupts can read the
content of flags, each write also compromises inter-instruction optimizations,
like the omission of flag calculations that I mentioned earlier.</p>

<p>And because there are now multiple checks for interrupts throughout the block,
each check only needs to make sure that the next interrupt will not happen
before the next interrupt check, including the initial check that happens before
entering the block.</p>

<p>After finishing emitting the block, the compiler moves the buffer with the
machine code to an executable memory region and stores it in a <code>HashMap</code>, which
maps <code>(bank, address)</code> to the block. Now, whenever the emulator needs to execute
this block again, it just gets it from the <code>HashMap</code> (or compiles it if it isn’t
there yet).</p>
<h2 id="results">
  
  
    Results <a href="#results">§</a>
  
  
</h2>
    

<p>The entire point of implementing a JIT compiler is to improve the performance of
the emulator. So, how much of a speed-up did I get?</p>

<p>First, let’s compare the speed of the interpreter and the JIT compiler. For
that, I ran the emulator with two different games and measured the time it took
to run each game for 100 seconds. The first game is <a href="https://en.wikipedia.org/wiki/The_Legend_of_Zelda:_Link%27s_Awakening">The Legend of Zelda: Link’s
Awakening</a>, and the second is <a href="https://tangramgames.dk/tobutobugirl/">Tobu Tobu Girl</a>. Both games have a
nice start screen animation, which may be a good benchmark for the speed of the
emulator.</p>

<p><img src="https://rodrigodd.github.io/assets/gameroy_jit/interpreter-vs-jit.svg" alt="Emulator comparison"/></p>

<p>The emulator was capable of emulating Tobu Tobu Girl more than 100 times faster
than the real system! However, when comparing the two implementations, it’s
possible to see that the JIT compiler decreases the execution time by about 40%
in Tobu Tobu Girl and about 30% in Zelda. This is not the massive speed-up I was
expecting, but it is still very significant.</p>

<p>We can also take a closer look at the time spent emulating each component. By
using <a href="https://github.com/nico-abram/blondie/"><code>blondie</code></a> or <a href="https://github.com/jonhoo/inferno"><code>inferno</code></a> to capture a stack trace and
passing it to my <a href="https://github.com/Rodrigodd/gameroy/blob/4ac46fff3a203c20aadbb108585354701a52546e/tools/plot.py">plot script</a>, I can generate the following pie charts:</p>

<p><img src="https://rodrigodd.github.io/assets/gameroy_jit/per-component-inter-vs-jit.svg" alt="Interpreter time"/></p>

<p>From the pie chart above, we can see that a big chunk of the time is spent
emulating the PPU. We can also see that Zelda has a lot less opportunities for
optimizing the PPU, and therefore spends more time in it, which explains why it
is much slower and has a smaller speed up.</p>

<p>Looking just at the interpreter (blue) and JIT (red) sections, we can roughly
estimate that the JIT compiler is about 4 times faster than the interpreter.
However, a considerable amount of time is still spent just querying the block in
the <code>HashMap</code>. And even with the JIT compiler, some time is still spent in the
interpreter.</p>

<p>Another aspect we can explore is comparing the emulator with others out
there. I picked 4 emulators that are relatively popular and have a high degree
of accuracy: <a href="https://sameboy.github.io/">SameBoy</a>, <a href="http://bgb.bircd.org/">BGB</a>, <a href="https://mattcurrie.com/bdm/">Beaten Dying Moon</a>, and
<a href="https://emulicious.net/">Emulicious</a>.</p>

<p>You can have a feel for how accurate each emulator is by seeing the test results
in daid’s <a href="https://daid.github.io/GBEmulatorShootout/">GBEmulatorShootout</a>. Noticed that these test included DMG, GBC, and
SGB version of the Game Boy, but GameRoy only emulates DMG, so it appears a
little behind the others.</p>

<p>To measure the performance of each emulator, I ran the same two games as before,
and measured the time it took to run the intro animation of each game, using
a video recorded with <a href="https://obsproject.com/">OBS Studio</a>. For Tobu Tobu Girl, I let the intro run
three times, and for Zelda, I let it run twice.</p>

<p>The emulators were run on Windows, with their default GUI frontend, configure to
emulate DMG and with “turbo mode” enabled. Due to the use of a GUI frontend, the
measurement being based on video recording, and the intro being run only two or
three times, the results are not that precise. But hopefully they are good
enough to compare them with each other.</p>

<p><img src="https://rodrigodd.github.io/assets/gameroy_jit/emulator-comparison.svg" alt="Emulator comparison"/></p>

<p>Based on these results, I can now claim that GameRoy is the fastest emulator out
there! Interestingly, even the interpreted version of my emulator is faster than
most of the other emulators. This is likely due to the optimizations achieved by
implementing the lazy updates and estimating the next interrupt.</p>

<p>Only Emulicious was faster than my interpreted emulator when running Zelda
(perhaps my emulator is invalidating the PPU optimization too much).</p>
<h2 id="remaining-work">
  
  
    Remaining work <a href="#remaining-work">§</a>
  
  
</h2>
    

<p>I may have achieved the state-of-the-art regarding dynamic recompilation
applied to Game Boy emulation (the only related work that I know of is
<a href="https://github.com/sysprog21/jitboy">JitBoy</a>), but my implementation is still far from perfect.</p>

<p>The first thing is that I am not implementing some obvious optimizations. For
example, I am not keeping the Game Boy registers loaded in the <code>x64</code> registers,
but instead, I am loading and saving them to memory every instruction. The only
register that I optimize is the PC register, whose value I can know at compile
time, so I only update it on block exit.</p>

<p>The flags are the most suboptimal, as I am computing the value of the flag,
encoding it in the F register bit flag, and then later decoding them in the
branch instructions, where I could be using the value of each flag directly
between instructions.</p>

<p>But I will probably not implement these optimizations, at least not directly.
Instead, I plan to write another backend for the compiler using
<a href="https://cranelift.dev/">Cranelift</a>, which will likely automatically handle these optimizations
and more. I have already <a href="https://rodrigodd.github.io/2022/11/26/bf_compiler-part3.html">done some experiments with it before</a>, and
it seems to work pretty well. It will also help with porting the JIT compiler to
run on Android.</p>

<p>Another inefficiency in my JIT compiler is regarding redundant
recompilations. Currently, I am building an entire block for each <code>(bank,
address)</code> entry point, even if that same address is already in the middle of
another block. This means that many of the blocks are overlapping, introducing
unnecessary compilation time and memory usage.</p>

<p>I don’t know if this is a big problem (I need to do some profiling first), but I
could fix it by including in the <code>HashMap</code> a key for the address of each
instruction in the block and moving the block prelude to a Rust naked function,
that jumps to the middle of the block.</p>

<p>However, this would introduce some complications, like filling the <code>HashMap</code>
with too many keys, and the need to ensure that each compiled instruction can be
jumped to. This last point may be a problem for optimizations, but I haven’t
given it too much thought yet.</p>
<h2 id="conclusion">
  
  
    Conclusion <a href="#conclusion">§</a>
  
  
</h2>
    

<p>And that’s it! I was not able to achieve the massive speed-up I was expecting,
but I still managed to make my emulator the fastest one out there, even if the
generated code is far from optimum.</p>

<p>I would like to thank Brook Heisler for his blog post, <a href="https://bheisler.github.io/post/experiments-in-nes-jit-compilation/">“Experiments In NES JIT
Compilation”</a>, which inspired me to try this out, and gave me some
useful links on how to implement a JIT compiler, like <a href="https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/">Eli Bendersky’s
Adventures In JIT Compilation series</a>, which I <a href="https://rodrigodd.github.io/2022/10/21/bf_compiler-part1.html">re-implemented in
Rust</a> as a learning exercise.</p>

<p>If you want to take a look at GameRoy, I invite you to check out <a href="https://github.com/Rodrigodd/gameroy">its GitHub
repository</a>.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
