<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2024/04/03/improvements-static-analysis-gcc-14-compiler">Original</a>
    <h1>Improvements to static analysis in GCC 14</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
                  
                <div>
          
<p>I work at Red Hat on <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>. For the last five releases of GCC, I&#39;ve been working on <code>-fanalyzer</code>, a static analysis pass that tries to identify various problems at compile-time, rather than at runtime. It performs &#34;symbolic execution&#34; of <a href="https://developers.redhat.com/topics/c">C</a> source code—effectively simulating the behavior of the code along the various possible paths of execution through it.</p>

<p>This article summarizes what&#39;s new with <code>-fanalyzer</code> in <a href="https://gcc.gnu.org/gcc-14/changes.html">GCC 14</a>, which I hope will be officially released sometime in April 2024.</p>

<h2>Solving the halting problem?</h2>

<p>Obviously <a href="https://en.wikipedia.org/wiki/Halting_problem">I&#39;m kidding with the title</a> here, but for GCC 14 I&#39;ve implemented a new warning: <a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-infinite-loop">-Wanalyzer-infinite-loop</a> that&#39;s able to detect some simple cases of infinite loops.</p>

<p>For example, consider the following C code:</p>

<pre><code>void test (int m, int n)
{
  float arr[m][n];
  for (int i = 0; i &lt; m; i++)
    for (int j = 0; j &lt; n; i++)
      arr[i][j] = 0.f;
  /* etc */
}
</code></pre>

<p>If you look closely, you&#39;ll see that the user probably made the second <code>for</code> statement by copying the first one, but forgot to change the increment clause from an <code>i</code> to a <code>j</code>.</p>

<p>GCC 14&#39;s <a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-fanalyzer">-fanalyzer</a> option successfully detects this, with this output:</p>

<pre><code> warning: infinite loop [CWE-835] [-Wanalyzer-infinite-loop]
    5 |     for (int j = 0; j &lt; n; i++)
      |                     ~~^~~
  &#39;test&#39;: events 1-5
    |
    |    5 |     for (int j = 0; j &lt; n; i++)
    |      |                     ~~^~~  ~~~
    |      |                       |     |
    |      |                       |     (4) looping back...
    |      |                       (1) infinite loop here
    |      |                       (2) when &#39;j &lt; n&#39;: always following &#39;true&#39; branch...
    |      |                       (5) ...to here
    |    6 |       arr[i][j] = 0.f;
    |      |       ~~~~~~~~~        
    |      |             |
    |      |             (3) ...to here
    |
</code></pre>

<p>The output could be more readable here—you have to read the events in order of their numbers, from <code>(1)</code> to <code>(5)</code>. For GCC 15 I hope to improve this, perhaps with ASCII art that highlights the path taken by control flow.</p>

<p>I find the Compiler Explorer website very useful for trying out code snippets with different compilers and options. You can try the above example on it <a href="https://godbolt.org/z/vn55nn43z">here</a>.</p>

<h2>Visualizing buffer overflows</h2>

<p>The analyzer gained support in GCC 13 for bounds checking with a <a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-out-of-bounds">-Wanalyzer-out-of-bounds</a> warning.</p>

<p>For example, given the out-of-bounds write in <code>strcat</code> in:</p>

<pre><code>#include &lt;string.h&gt;

void test (void)
{
  char buf[10];
  strcpy (buf, &#34;hello&#34;);
  strcat (buf, &#34; world!&#34;);
}
</code></pre>

<p>The analyzer emits this message:</p>

<pre><code>&lt;source&gt;: In function &#39;test&#39;:
&lt;source&gt;:7:3: warning: stack-based buffer overflow [CWE-121] [-Wanalyzer-out-of-bounds]
    7 |   strcat (buf, &#34; world!&#34;);
      |   ^~~~~~~~~~~~~~~~~~~~~~~
  &#39;test&#39;: events 1-2
    |
    |    5 |   char buf[10];
    |      |        ^~~
    |      |        |
    |      |        (1) capacity: 10 bytes
    |    6 |   strcpy (buf, &#34;hello&#34;);
    |    7 |   strcat (buf, &#34; world!&#34;);
    |      |   ~~~~~~~~~~~~~~~~~~~~~~~
    |      |   |
    |      |   (2) out-of-bounds write from byte 10 till byte 12 but &#39;buf&#39; ends at byte 10
    |
&lt;source&gt;:7:3: note: write of 3 bytes to beyond the end of &#39;buf&#39;
    7 |   strcat (buf, &#34; world!&#34;);
      |   ^~~~~~~~~~~~~~~~~~~~~~~
&lt;source&gt;:7:3: note: valid subscripts for &#39;buf&#39; are &#39;[0]&#39; to &#39;[9]&#39;

</code></pre>

<p>I&#39;ve been unhappy with the readability of these messages: it describes some aspects of the problem, but it&#39;s hard for the user to grasp exactly what the analyzer is &#34;thinking.&#34;</p>

<p>So for GCC 14, I&#39;ve added the ability for the analyzer to emit text-based diagrams visualizing the spatial relationships in a predicted buffer overflow. For the above example (which you can try <a href="https://godbolt.org/z/qM3hYKzjx">here in Compiler Explorer</a>) it emits the diagram shown in Figure 1.</p>

<figure role="group">
<figure><a href="https://developers.redhat.com/sites/default/files/screenshot_from_2024-03-28_16-05-22.png" data-featherlight="image"><img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2024-03-28_16-05-22.png?itok=DlDqiM5y" width="600" height="396" alt="Screenshot of diagram showing buffer overflow" typeof="foaf:Image"/></a>

  </figure><figcaption>Figure 1: Visualizing buffer overflows in GCC 14.</figcaption></figure><p>This diagram shows the destination buffer populated by the content from the <code>strcpy</code> call, and thus the existing terminating <code>NUL</code> byte used for the start of the <code>strcat</code> call.</p>

<p>For non-ASCII strings such as this:</p>

<pre><code>#include &lt;string.h&gt;

void test (void)
{
  char buf[11];
  strcpy (buf, &#34;サツキ&#34;);
  strcat (buf, &#34;メイ&#34;);
}
</code></pre>

<p>It can show the UTF-8 representation of the characters (Figure 2).</p>

<figure role="group">
<figure><a href="https://developers.redhat.com/sites/default/files/screenshot_from_2024-03-28_16-04-16.png" data-featherlight="image"><img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/screenshot_from_2024-03-28_16-04-16.png?itok=U3zQXlQ_" width="600" height="453" alt="FIXME" typeof="foaf:Image"/></a>

  </figure><figcaption>Figure 2: Visualizing non-ASCII strings in GCC 14.</figcaption></figure><p>This demonstrates that the overflow happens partway through the <a href="https://en.wiktionary.org/wiki/%E3%83%A1">メ character (U+30E1)</a>. (<a href="https://godbolt.org/z/eKn9rMTWG">Link to Compiler Explorer</a>).</p>

<h2>Analyzing C string operations</h2>

<p>I&#39;ve put some work into better tracking C string operations in GCC 14&#39;s analyzer.</p>

<p>One of the improvements is that the analyzer now simulates APIs that scan a buffer expecting a null terminator byte, and will complain about code paths where a pointer to a buffer that isn&#39;t properly terminated is passed to such an API.</p>

<p>I&#39;ve added a new function attribute <a href="http://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-null_005fterminated_005fstring_005farg-function-attribute">null_terminated_string_arg(<em>PARAM_IDX</em>)</a> for telling the analyzer (and human readers of the code) about parameters that are expected to be null-terminated strings. For example, given this buggy code:</p>

<pre><code>extern char *
example_fn (const char *p)
  __attribute__((null_terminated_string_arg (1)))
  __attribute__((nonnull));

char *
test_unterminated_str (void)
{
  char str[3] = &#34;abc&#34;;
  return example_fn (str);
}
</code></pre>

<p>Here, the analyzer correctly complains that <code>str</code> doesn&#39;t have a null terminator byte, and thus <code>example_fn</code> will presumably read past the end of the buffer:</p>

<pre><code>&lt;source&gt;: In function &#39;test_unterminated_str&#39;:
&lt;source&gt;:10:10: warning: stack-based buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]
   10 |   return example_fn (str);
      |          ^~~~~~~~~~~~~~~~
  &#39;test_unterminated_str&#39;: events 1-3
    |
    |    9 |   char str[3] = &#34;abc&#34;;
    |      |        ^~~
    |      |        |
    |      |        (1) capacity: 3 bytes
    |   10 |   return example_fn (str);
    |      |          ~~~~~~~~~~~~~~~~
    |      |          |
    |      |          (2) while looking for null terminator for argument 1 (&#39;&amp;str&#39;) of &#39;example_fn&#39;...
    |      |          (3) out-of-bounds read at byte 3 but &#39;str&#39; ends at byte 3
    |
&lt;source&gt;:10:10: note: read of 1 byte from after the end of &#39;str&#39;
   10 |   return example_fn (str);
      |          ^~~~~~~~~~~~~~~~
&lt;source&gt;:10:10: note: valid subscripts for &#39;str&#39; are &#39;[0]&#39; to &#39;[2]&#39;

                                                       ┌─────────────────┐
                                                       │ read of 1 byte  │
                                                       └─────────────────┘
                                                                ^
                                                                │
                                                                │
  ┌─────────────────┬────────────────┬────────────────┐┌─────────────────┐
  │       [0]       │      ...       │      [2]       ││                 │
  ├─────────────────┴────────────────┴────────────────┤│after valid range│
  │              &#39;str&#39; (type: &#39;char[3]&#39;)              ││                 │
  └───────────────────────────────────────────────────┘└─────────────────┘
  ├─────────────────────────┬─────────────────────────┤├────────┬────────┤
                            │                                   │
                     ╭──────┴──────╮                ╭───────────┴──────────╮
                     │size: 3 bytes│                │  over-read of 1 byte │
                     ╰─────────────╯                ╰──────────────────────╯

&lt;source&gt;:2:1: note: argument 1 of &#39;example_fn&#39; must be a pointer to a null-terminated string
    2 | example_fn (const char *p)
      | ^~~~~~~~~~</code></pre>

<p>Again, you can <a href="https://godbolt.org/z/naoa6oq5b">try this example in Compiler Explorer here</a>.</p>

<h2>Taint analysis</h2>

<p>The analyzer has a form of &#34;taint analysis&#34;, which tracks attacker-controlled inputs, places where they are sanitized, and places where they are used without sanitization. In previous GCC releases this was too buggy to enable by default, with lots of false positives, so I hid it behind an extra command-line argument. I&#39;ve fixed many bugs with this, so for GCC 14 I&#39;ve enabled this by default when <a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-fanalyzer">-fanalyzer</a> is selected. This also enables these 6 taint-based warnings:</p>

<ul><li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-allocation-size">-Wanalyzer-tainted-allocation-size</a></li>
	<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-array-index">-Wanalyzer-tainted-array-index</a></li>
	<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-assertion">-Wanalyzer-tainted-assertion</a></li>
	<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-divisor">-Wanalyzer-tainted-divisor</a></li>
	<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-offset">-Wanalyzer-tainted-offset</a></li>
	<li><a href="http://gcc.gnu.org/onlinedocs/gcc/Static-Analyzer-Options.html#index-Wanalyzer-tainted-size">-Wanalyzer-tainted-size</a></li>
</ul><p>For example, here&#39;s an excerpt from <a href="https://access.redhat.com/security/cve/CVE-2011-2210">CVE-2011-2210</a> from the Linux kernel:</p>

<pre><code>extern struct hwrpb_struct *hwrpb;

SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,
		unsigned long, nbytes, int __user *, start, void __user *, arg)
{
	/* [...snip...] */

	/* case GSI_GET_HWRPB: */
		if (nbytes &lt; sizeof(*hwrpb))
			return -1;

		if (copy_to_user(buffer, hwrpb, nbytes) != 0)
			return -2;

		return 1;

	/* [...snip...] */
}
</code></pre>

<p>You can see <a href="https://godbolt.org/z/sqsx8avfG">a more full version at Compiler Explorer</a>. In particular, I added <code>__attribute__((tainted_args))</code> to the <code>__SYSCALL_DEFINEx</code> macro to indicate to the analyzer that the arguments to <code>osf_getsysinfo</code> are coming from across a trust boundary, and thus should be considered tainted.</p>

<p>With GCC 14, the analyzer is able to detect the vulnerability (again, edited somewhat for brevity):</p>

<pre><code>&lt;source&gt;: In function &#39;sys_osf_getsysinfo&#39;:
&lt;source&gt;:55:21: warning: use of attacker-controlled value &#39;nbytes&#39; as size without upper-bounds checking [CWE-129] [-Wanalyzer-tainted-size]
   55 |                 if (copy_to_user(buffer, hwrpb, nbytes) != 0)
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  &#39;sys_osf_getsysinfo&#39;: event 1
    |
    |   28 |         long sys##name(__SC_DECL##x(__VA_ARGS__))
    |      |              ^~~
    |      |              |
    |      |              (1) function &#39;sys_osf_getsysinfo&#39; marked with &#39;__attribute__((tainted_args))&#39;
    |
    +--&gt; &#39;sys_osf_getsysinfo&#39;: event 2
           |
           |   28 |         long sys##name(__SC_DECL##x(__VA_ARGS__))
           |      |              ^~~
           |      |              |
           |      |              (2) entry to &#39;sys_osf_getsysinfo&#39;
           |
         &#39;sys_osf_getsysinfo&#39;: events 3-6
           |
           |   52 |                 if (nbytes &lt; sizeof(*hwrpb))
           |      |                    ^
           |      |                    |
           |      |                    (3) &#39;nbytes&#39; has its lower bound checked here
           |      |                    (4) following &#39;false&#39; branch (when &#39;nbytes &gt; 31&#39;)...
           |......
           |   55 |                 if (copy_to_user(buffer, hwrpb, nbytes) != 0)
           |      |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           |      |                     |
           |      |                     (5) ...to here
           |      |                     (6) use of attacker-controlled value &#39;nbytes&#39; as size without upper-bounds checking
           |
&lt;source&gt;:11:13: note: parameter 3 of &#39;copy_to_user&#39; marked as a size via attribute &#39;access (write_only, 1, 3)&#39;
   11 | extern long copy_to_user(void __user *to, const void *from, unsigned long n)
      |             ^~~~~~~~~~~~
</code></pre>

<p>The issue is that the attempt to sanitize <code>nbytes</code> was written as</p>

<pre><code>if (nbytes &lt; sizeof(*hwrpb))</code></pre>

<p>when it should have been</p>

<pre><code>if (nbytes &gt; sizeof(*hwrpb))</code></pre>

<p>With a fixed version of that conditional, the <a href="https://godbolt.org/z/vecezenKj">analyzer is silent</a>.</p>

<p>I&#39;m continuing to work on running the analyzer on the kernel to look for vulnerabilities (and fix false positives in the analyzer).</p>

<h2>Try it out!</h2>

<p>We&#39;re still fixing bugs, but we hope that <a href="https://gcc.gnu.org/gcc-14/changes.html">GCC 14</a> will be ready to officially release (as 14.1) sometime in April 2024.</p>

<p>With my &#34;downstream&#34; hat on, we&#39;re already using the prerelease (GCC 14.0) within <a href="https://fedoramagazine.org/announcing-fedora-linux-40-beta/">Fedora 40 Beta</a>.</p>

<p>Finally, you can use the <a href="https://godbolt.org/z/YTx3Pfocn">excellent Compiler Explorer site</a> to play with the new compiler. Have fun!</p>

          
                            </div>
      </div>
    </div></div>
  </body>
</html>
