<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cliki.net/naming&#43;conventions">Original</a>
    <h1>Common Lisp Wiki: Naming Conventions</h1>
    
    <div id="readability-page-1" class="page"><div id="article"><p>Some symbol naming conventions, distilled from <a href="https://www.cliki.net/CLHS">CLHS</a>, the Lisp <a href="https://www.cliki.net/FAQ">FAQ</a>, and <a href="https://www.cliki.net/comp.lang.lisp">comp.lang.lisp</a>.</p><p>Widely used &#34;need-to-know&#34; conventions:</p><table>
  <tbody><tr>
<td>foo-bar</td>
<td>&#34;-&#34; is used as a word delimiter</td>
</tr>
  <tr>
<td>*foo*</td>
<td>(global) special variable</td>
</tr>
  <tr>
<td>foo*</td>
<td>slightly different variant of the foo operator</td>
</tr>
  <tr>
<td>&amp;foo</td>
<td>lambda list keyword.  These symbols will be in the <a href="https://www.cliki.net/site/HyperSpec/Body/convar_lambda_ist-keywords.html">lambda-list-keywords</a> list.</td>
</tr>
  <tr>
<td>nfoo</td>
<td>(possibly) destructive (non-consing) function</td>
</tr>
  <tr>
<td>foop</td>
<td>predicate (also foo-p); see notes below for when to hyphenate</td>
</tr>
  <tr>
<td>foof</td>
<td>place changing (like in <a href="https://www.cliki.net/site/HyperSpec/Body/any_setf.html">SETF</a>, <a href="https://www.cliki.net/site/HyperSpec/Body/mac_incfcm_decf.html">INCF</a>, ...) (also foo-f)</td>
</tr>
  <tr>
<td>+foo+</td>
<td>constant, or single CLOS instance</td>
</tr>
  <tr>
<td>%foo</td>
<td>low-level, fast, dangerous function, or Lisp system specific implementation of foo</td>
</tr>
  <tr>
<td>make-foo</td>
<td>create a foo and return it </td>
</tr>
  <tr>
<td>define-foo</td>
<td>(globally) define a new foo (also short version: &#34;deffoo&#34;)</td>
</tr>
  <tr>
<td>with-foo</td>
<td>create a dynamic context with a foo</td>
</tr>
  <tr>
<td>do-foo</td>
<td>iterate through a foo</td>
</tr>
  <tr>
<td>foo-case</td>
<td>foo-specific case expression</td>
</tr>
  <tr>
<td>foo-bar</td>
<td>type-slot, converting FOO to BAR</td>
</tr>
  <tr>
<td>foo-to-bar</td>
<td>converting FOO to BAR</td>
</tr>
</tbody></table><p>Often seen, but not-quite-so-common conventions:</p><table>
  <tbody><tr>
<td>bar-of</td>
<td>slot bar of an object</td>
</tr>
  <tr>
<td>foo/bar</td>
<td>type/operation, foo with bar, bar version of foo</td>
</tr>
  <tr>
<td>foo.bar</td>
<td>type.slot or, in some implementations conventional hierarchical package (e.g. <a href="https://www.cliki.net/ACL">ACL</a> and <a href="https://www.cliki.net/CMUCL">CMUCL</a>)</td>
</tr>
  <tr>
<td>?foo</td>
<td>variable in embedded language</td>
</tr>
  <tr>
<td>&lt;foo&lt;</td>
<td>variable in embedded language</td>
</tr>
</tbody></table><p>Occasionally seen:</p><table>
  <tbody><tr>
<td>&lt;foo&gt;</td>
<td>class</td>
</tr>
  <tr>
<td>%foo%</td>
<td>local special variable</td>
</tr>
  <tr>
<td>.foo.</td>
<td>internal special variable</td>
</tr>
  <tr>
<td>.foo.</td>
<td>private macro symbol</td>
</tr>
  <tr>
<td>/foo/</td>
<td>global lexical variable</td>
</tr>
  <tr>
<td>$foo</td>
<td>function visible from Macsyma</td>
</tr>
  <tr>
<td>foo&amp;</td>
<td>foo, operating on fixnums</td>
</tr>
  <tr>
<td>foo$</td>
<td>foo, operating on floats</td>
</tr>
</tbody></table><p>Conventions in Scheme:</p><table>
  <tbody><tr>
<td>foo!</td>
<td>destructive function</td>
</tr>
  <tr>
<td>foo?</td>
<td>predicate</td>
</tr>
  <tr>
<td>$foo</td>
<td>constant</td>
</tr>
  <tr>
<td>call-with-foo</td>
<td>Invoke a thunk in some dynamic context</td>
</tr>
  <tr>
<td>foo-&gt;bar</td>
<td>Coerce object of type foo to object of type bar</td>
</tr>
</tbody></table><p>This is standard syntax, not convention:</p><table>
  <tbody><tr>
<td>:bar</td>
<td>keyword</td>
</tr>
  <tr>
<td>foo:bar</td>
<td>external symbol bar in package foo</td>
</tr>
  <tr>
<td>foo::bar</td>
<td>internal symbol bar in package foo (don&#39;t try this at home, kids!)</td>
</tr>
  <tr>
<td>#:bar</td>
<td>uninterned symbol (does not belong to any package)</td>
</tr>
</tbody></table><p>These will annoy people:</p><table>
  <tbody><tr>
<td>CamelCaseIdentifiers</td>
<td>Use identifiers-like-this</td>
</tr>
  <tr>
<td>identifiers_with_underscores</td>
<td>are harder to type</td>
</tr>
  <tr><td>hungarian-identifiers-pcsnsi</td></tr>
  <tr>
<td>abbrv-idntfrs</td>
<td>Use Emacs to expand them.</td>
</tr>
</tbody></table><p>Unless there is a good reason to use them (for instance, you need to interface
to a third-party package that uses them), they should be avoided.</p><p>Some additional style notes:</p><ul>
<li>A function that tests for something involving its arguments is called a <i>predicate</i> and usually ends in <tt>p</tt> or <tt>-p</tt>. <a href="https://www.cliki.net/CLTL2">CLTL2</a> explains the rationale for each suffix:<blockquote>
By convention, the names of predicates usually end in the letter p (which stands for &#34;predicate&#34;). Common Lisp uses a uniform convention in hyphenating names of predicates. If the name of the predicate is formed by adding a p to an existing name, such as the name of a data type, a hyphen is placed before the final p if and only if there is a hyphen in the existing name. For example, <a href="https://www.cliki.net/site/HyperSpec/Body/syscla_number.html">number</a> begets <a href="https://www.cliki.net/site/HyperSpec/Body/fun_numberp.html">numberp</a> but <a href="https://www.cliki.net/site/HyperSpec/Body/typ_standard-char.html">standard-char</a> begets <a href="https://www.cliki.net/site/HyperSpec/Body/fun_standard-char-p.html">standard-char-p</a>. On the other hand, if the name of a predicate is formed by adding a prefixing qualifier to the front of an existing predicate name, the two names are joined with a hyphen and the presence or absence of a hyphen before the final p is not changed. For example, the predicate <a href="https://www.cliki.net/site/HyperSpec/Body/fun_stringeqc_ng-not-lessp.html">string-lessp</a> has no hyphen before the p because it is the string version of <tt>lessp</tt> (a <a href="https://www.emacswiki.org/emacs/MacLisp">MACLISP</a> function that has been renamed <tt>&lt;</tt> in Common Lisp). The name <tt>string-less-p</tt> would incorrectly imply that it is a predicate that tests for a kind of object called a string-less, and the name <tt>stringlessp</tt> would connote a predicate that tests whether something has no strings (is &#34;stringless&#34;)! 
</blockquote></li>
<li>There are useful conventions for macros: <tt>deffoo</tt> or <tt>define-foo</tt> defines objects of type <tt>foo</tt>. Setting up a context for some actions, usually performing some binding, and including setup and teardown code, is usually a <tt>with-foo</tt>. Iterating macros are defined usually as <tt>do-foo</tt>.</li>
<li>
<tt>deffoo</tt> vs. <tt>define-foo</tt> used to be, and is in the spec, determined by <tt>foo</tt>. If <tt>foo</tt> is a hyphenated name, then the <tt>define-foo</tt> format is used, otherwise <tt>deffoo</tt> is used. For example, <a href="https://www.cliki.net/site/HyperSpec/Body/mac_defmethod.html">defmethod</a> and <a href="https://www.cliki.net/site/HyperSpec/Body/mac_defsetf.html">defsetf</a> vs. <a href="https://www.cliki.net/site/HyperSpec/Body/mac_define-me_-combination.html">define-method-combination</a> and <a href="https://www.cliki.net/site/HyperSpec/Body/mac_define-setf-expander.html">define-setf-expander</a>.</li>
<li>Occasionally, there will be a pair of operator functions, and one is a destructive version of the other. Historical tradition will name the destructive variant <tt>nfoo</tt> for the basic non-destructive function, but this is inconsistently used.</li>
<li>The <a href="https://www.cliki.net/CLIM">CLIM</a> specification supports a rather large protocol, and has a &#34;spread arguments&#34; convention for functions where there is a desire not to have to construct a large object just to call one function with it. A spread function takes many small constituent arguments and is named <tt>foo*</tt> for a basic function <tt>foo</tt>.</li>
<li>There are some various methods ending in <tt>f</tt>, notably <a href="https://www.cliki.net/site/HyperSpec/Body/any_setf.html">setf</a> (but some advanced ones include <tt>locf</tt> for old <a href="https://www.emacswiki.org/emacs/ZetaLisp">ZetaLisp</a>). The <tt>f</tt> stands for a generic field of an object, like a part of a cons cell, structure, vector, array, class instance, and so forth. <a href="https://groups.google.com/g/comp.lang.lisp/c/1OERjYfSKqc/m/keoNb0gdKjoJ" title="messageid:sfwsmt3ya36.fsf@shell01.TheWorld.com">Kent M. Pitman explained the origin of it</a> on <a href="https://www.cliki.net/comp.lang.lisp">comp.lang.lisp</a>.</li>
<li>Note that nested conversions (e.g., <tt>(bar-to-baz (foo-to-bar x))</tt> or <tt>(bar-&gt;baz (foo-&gt;bar x))</tt>) compose nicer if written the other way around: <tt>(baz-from-bar (bar-from-foo x))</tt>, <tt>(baz&lt;-bar (bar&lt;-foo x))</tt>.
</li>
</ul></div></div>
  </body>
</html>
