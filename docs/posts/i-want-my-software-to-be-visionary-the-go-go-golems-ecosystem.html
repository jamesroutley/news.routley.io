<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/i-want-my-software-to-be-visionary-the-go-go-golems-ecosystem/">Original</a>
    <h1>I want my software to be visionary - the go go golems ecosystem</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p><img alt="https://s.mj.run/c5n61SnhpX8 https://s.mj.run/Vzq5-c2jnAs retro mainframe flower zombie head, flower fountain retro mainframe, exposed electronics, tentacular book shapes, extremely detailed, white on black background, dark background, night scene, ink and brush watercolor by moebius, dark black and white watercolor, watercolor ink drawing by junji ito, trending on artstation, highly detailed, 4k" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/manuel-1678640527-0.png"/></p>
<p>Last year, informed by 2 decades of creating command-line tools, I wrote <a href="https://dev.to/wesen/14-great-tips-to-make-amazing-cli-applications-3gp3">14 great tips to make amazing CLI applications</a>. I did not have anything concrete to show, all these concepts having been built in private codebases and <a href="https://the.scapegoat.dev/finding-my-way-back-to-open-source/">having stopped writing open-source</a>.</p>
<p>In October, I set out to implement all these concepts in a go library called <a href="https://github.com/go-go-golems/glazed">glazed</a>. While I initially wanted to target Rust, I felt too frustrated working on it in my after-hours, and was missing the consistent asynchronous code writing experience go was giving me. Plus, <a href="https://charm.sh">charmbracelet</a> just has too much cool stuff.</p>
<p>This blog post started out as a level-headed overview of the concepts underlying glazed, and turned into, well... this.</p>
<h2 id="opinionated-visionary-software-development">Opinionated, visionary software development</h2>
<p>Initially, <a href="https://github.com/go-go-golems/glazed">glazed</a> was meant to only implement a data export layer. I had spent the summer taking a sabbatical trying to put my thoughts down on paper, aiming for a manifesto-style of writing. It is easy to complain about the state of data tooling, the lack of interoperation, the vision of what could be—everybody does it. How many times did I hear people dismiss what they do as just &#34;Software is just glueing APIs together,&#34; as if that wasn&#39;t miraculously challenging? <strong>It is one thing to complain and argue about perceived problems, it is another thing to actually come up with and build a solution.</strong> Advice obviously meant for me.</p>
<p>Instead of writing more big bold unsubstantiated statements in my diary, I started focusing on designing and building something that would be eminently practical, yet absolutely stringent, coherent and visionary in its goals.</p>
<p>I wish more software was ambitious, utopian, bold, breaking free of the confines of what we have come to accept as whatsoftware should be. I am growing increasingly frustrated by the corporate shaped, influencer inspired, bland github-backed open-source software; by the boring-ass markdown rendering of its wikis, the lack of personality, the endless controversies about market share of individual frameworks; by the arguing about squash merges and test hygiene and CICD and package management and code styles and linting and this language and that language, event-driven microservices distributed cloud column database analytics datalake software architecture secret management infrastructure as code.</p>
<p><strong>As software developers, we create machines out of thin air.</strong> Every time we run our code, a golem is set into motion. Wethink of something, tell sand (literally a golem) to execute it and impact the lives of other people. We are making magic happen every time we sit down, yet we are mentally stuck thinking in terms of &#34;backend&#34;, &#34;full-stack&#34;, &#34;embedded&#34;, &#34;machine-learning&#34;, &#34;gamedev&#34;, &#34;mobile&#34;, &#34;UX&#34;—as if we were little checkboxes on a resume; our brains are just Lego blocks that someone else designed, only to be assembled according to Google&#39;s latest take on software engineering. We are lured by the fully enshittified corporate grip on public discourse into thinking that arguing for react vs raw Javascript is a crucial fight to fight.</p>
<p>We assume that practicing agile, being a &#34;product thinker&#34;, building workflows to enable cross-team collaboration, becoming a staff engineer, speaking at conferences to develop our brands, blogging because writing is thinking and productivity is our actual value in life. We are dedicating the best years of our lives, of our days to dehumanizing concepts that pretend to be about self-actualization. We have come to believe that team lead product lead individual contributor senior junior staff principal CTO being glue mentor are valid words to define how we relate to each other, and that these relationships is how software has to be built.</p>
<p><strong>What the actual fuck? Why are we doing this? Why do we assume that one should strive to &#34;become a product-minded, T-shaped, systems-thinking engineer?&#34;</strong></p>
<p>We can make our dreams come true with a few kilobytes of ASCII text; we can conjure virtual worlds and change the world. Software our brethren and ancestors built allows us to talk to like-minded people on the other side of the world and robots exploring other planets and comets; it allows us to watch videos from another age, browse museums&#39; online collections and enjoy the works of art of millions. And yet, Mathematica seems to somehow be the only tool left with a vision that personal computers&#39; primary goal can also be computing.</p>
<p>Anyway...</p>
<h2 id="exploring-thoughts-with-software">Exploring thoughts with software</h2>
<p>GO GO GOLEMS&#39; library collection is my exploration of concepts that have been maturing in my wetware for some time now. <strong>The only way I know to properly identify what these concepts are about is to turn them into working code and solve real problems.</strong> Similar to writing for clarifying one&#39;s thoughts, coding is a programmer&#39;s way to clarify what they actually want to say. For me, this means writing multiple iterations of something, not being afraid to throw everything away and starting from scratch (with varying levels of keeping backwards compatibility, approaching the endeavour as a seamless refactoring).</p>
<p>While I do write this software for an audience, it is unclear how I will approach showing this to the world. I have a tendency to break APIs if I feel that something is not right. I don&#39;t think I&#39;ll be able to cope with third-party input beyond discussing and arguing concepts. I want to relentlessly refine the vision and make no compromises, so that the end-result ultimately benefits a wide range of users. I think that having to accommodate &#34;legacy&#34; too early might be to the detriment of my endeavour.</p>
<p>As such, <strong>while the software is open-source and you are free to do with it whatever you want (it is all MIT licensed), be aware that I&#39;ll most certainly break APIs about 5 times a day.</strong></p>
<h2 id="glazed-s-approach-to-data">glazed&#39;s approach to data</h2>
<p><strong>The core idea around glazed is that applications, as simple as they might be, have a rich representation of the data they manipulate.</strong> From the simplest <code>struct</code>, the most menial SQL query, the barest array all the way to a rich swagger specification, a full blown ORM schema, graph database, the tiniest command-line tool knows a lot about the business domain of the application. Yet most programs then use some variant of <code>printf</code> to export that data. It is then up to the user to figure out how to parse it; to infer the now lost structure; to browse through endless indigest lines of structured logs.</p>
<p>At its core, glazed provides a <code>Table</code> and <code>Row</code> interface (they are absolutely terrible, being the absolute first draft, but they got the job done until now), a <a href="https://github.com/go-go-golems/glazed/tree/main/pkg/middlewares"><code>ObjectMiddleware</code> and a <code>TableMiddleware</code> interface</a>, and an <a href="https://github.com/go-go-golems/glazed/tree/main/pkg/formatters"><code>OutputFormatter</code></a> (intimately and confusingly mixed with something called <code>GlazeProcessor</code>) interface.</p>
<p>The idea is that an application throws objects (<code>map[string]interface{}</code>, a generic string-indexed hash-map) into the <code>OutputFormatter</code>, where they get processed first by the string of <code>ObjectMiddleware</code>s (which operate at the object level, allowing one to rename/flatten/filter/replace keys). The object is then added to the <code>OutputFormatter</code>&#39;s <code>Table</code>. Once all the data has been processed, the <code>OutputFormatter</code> processes its internal <code>Table</code> through its <code>TableMiddleware</code>s and finally outputs it.</p>
<p><code>TableMiddleware</code> are again different variants of filter/rename/replace/template, but operate at a <code>Table</code> (and usually at a <code>Row</code> level). The current set of <code>OutputFormatter</code>s are: <code>table</code> (CSV/human-readable tables/HTML/Markdown), <code>json</code>, <code>yaml</code>, <code>excel</code> and <code>template</code> (go templates). Planned are many more (<code>sqlite</code> with varying degrees of table normalization configuration, <code>rdf</code>, <code>hdf5</code>, <code>pandas.dataframe</code>, etc...).</p>
<p><img alt="a diagram of the objects going through a chain of ObjectMiddleware, then into a Table, then into a chain of TableMiddleware, then into an OutputFormatter, and then into CSV/JSON/YAML/Excel/Markdown/Text" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/manuel-1678640620-0.png"/></p>
<p>All the middlewares&#39; and <code>OutputFormatter</code>s&#39; options can be configured programmatically, through config files or through command-line arguments (currently, the <code>viper</code> and <code>cobra</code> libraries are supported, although the system is built with genericity in mind). The main concept however is that as a developer, it should take you at most 10 lines of code to add <code>glazed</code> to your application.</p>
<p>I created the <code>glaze</code> application to not just showcase how to use the library, but as a tool that can be used to quickly convert and modify structured data, as a universal Swiss-army tool. There are already many of those, but I hope that <code>glaze</code> brings something unique to the table.</p>
<h2 id="glazed-s-approach-to-help">glazed&#39;s approach to help</h2>
<p><strong>For the rich data an application manages to provide useful information to a user, the user needs to know its structure.</strong> This is often a major hurdle, both for the developer, who needs to write and maintain that documentation, and for the user, who wants to find, understand and act upon said documentation. What we often end up with is a set of automatically generated docpages in a wiki that no-one knows how to find, as well as cryptic command line flags.</p>
<p>I am deeply in love with <a href="https://wolfram.com">Wolfram Mathematica&#39;s</a> helper system. The software is worth it for that system alone. Each function is described in detail, in an appealing format. More importantly, each line of the documentation is directly actionable and the documentation itself is an absolute blast to play with. Besides giving examples for each function and its arguments, each function gives a list of practical applications, often involving a few other constructs, to provide actual real-world examples, as well as a section of &#34;fun applications&#34; which try to show some wild, fun, mind-bending, ingenious ways to use the function itself. Furthermore, the documentation comes with topical pages that give a narrative, structured overview of the different domains of the application. These range from simple index pages to entire tutorials and treatises on certain topics.</p>
<p>The major strength of using go or rust, vs for example python, is that command-line applications are usually self-contained. Every hurdle to an applications use will hinder their widespread use, and fighting with pyenv and anaconda is one of the world&#39;s most tragic hurdles. The strength of a self-contained, well-documented command-line application is that it makes its functionality &#34;discoverable.&#34; A user should be able to run <code>--help</code> and discover the full functionality the application provides (I always was a big fan of GNU software bundling not just manpages, but entire hyperlinked manuals in its texinfo format).</p>
<p>As I was building <code>glazed</code>, I stumbled upon the <code>go:embed</code> functionality, which allows one to embed entire &#34;filesystems&#34; into the binary. I built a <a href="https://github.com/go-go-golems/glazed/tree/main/pkg/help"><code>HelpSystem</code></a> class that allows one to embed <code>Section</code>s parsed out of additional markdown files directly into the binary, as well as a rich <code>help</code> command that enables the user to browse these files.</p>
<p>A <code>Section</code> can be one of:</p>
<ul>
<li><p><code>Application</code> - real-world use cases of command-line applications</p>
</li>
<li><p><code>Examples</code> - short, concise, copy-pastable examples of how to use the applications for different purposes</p>
</li>
<li><p><code>Topics</code> - help pages about general topics around the application</p>
</li>
<li><p><code>Tutorials</code> - step-by-step, self-contained tutorials exploring a specific topic</p>
</li>
</ul>
<p>These pages can be linked to specific verbs and flags of the application, so that they can be found through the <code>--help</code> flag for a specific verb, or by searching the help system through <code>help --flag</code> or <code>help --verb</code>. Each section can further be tagged. This metadata is provided as a YAML preamble.</p>
<p>Here is the documentation file for the <a href="https://github.com/go-go-golems/glazed/blob/main/cmd/glaze/doc/topics/01-help-system.md">help system</a> itself (a <code>Topic</code> section).</p>
<p>Each section can be marked as <code>shownByDefault</code>, which means that it will be listed each time the <code>usage</code> information of a verb is shown or the <code>help</code> command for a matching set of tags/flags/verbs/topics is shown.</p>
<h2 id="further-steps">Further steps</h2>
<p>I have since built 5 real world applications I use daily on top of <code>glazed</code>, and identified and implemented many more concepts. To not overburden this blog post, I will split these out into follow-up posts, covering my tools <code>sqleton</code>, <code>escuse-me</code>, <code>pinocchio</code>, <code>parka</code>, <code>plunger</code>, <code>flour</code> and whatever I&#39;ll decide is worth building until then.</p>
</div>
</div></div>
  </body>
</html>
