<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2025/04/18/sneak-peek-a-new-asn.1-api-for-python/">Original</a>
    <h1>A New ASN.1 API for Python</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><main role="main"><article><div><p>If you’ve ever worked with cryptography, PKI schemes, or low-level networking
in Python, you’ve likely encountered <a href="https://en.wikipedia.org/wiki/ASN.1">ASN.1</a>.
ASN.1 undergirds every TLS handshake (via <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> path validation),
provides the serialization layer for core internet protocols like <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a>, <a href="https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">SNMP</a>,
and <a href="https://www.3gpp.org/">3GPP</a>, and generally operates as the <em>lingua franca</em> of cryptographic
primitive and protocol representation.</p><p>ASN.1’s critical role is complemented by a colorful security history:
implementations of ASN.1’s encoding rules have historically been a
rich source of
<a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=asn.1">memory corruption and denial-of-service vulnerabilities</a>. Similarly,
ASN.1’s presence at the lowest layers of the internet’s protocols
makes performance and a lack of <a href="https://langsec.org/">parser differentials</a> a critical requirement.</p><p>Python has multiple excellent ASN.1 implementations (like <a href="https://pypi.org/project/pyasn1/">pyasn1</a>,
<a href="https://pypi.org/project/asn1/">asn1</a>, and
<a href="https://pypi.org/project/asn1tools/">asn1tools</a>), but these generally
fall into the latter category: being written purely in Python makes performance
a concern, and integration into a stack where other ASN.1 parsers are used
(e.g., at the X.509 layer) introduces a differential risk.</p><p>We’re changing that: with the help of funding from <a href="https://alpha-omega.dev/">Alpha-Omega</a>,
we’re building an ASN.1 API for <a href="https://cryptography.io/">PyCA Cryptography</a> that addresses
three key shortcomings in the Python ecosystem today:</p><ol><li><strong>Performance</strong>: This new API will use a <a href="https://github.com/alex/rust-asn1">pure Rust ASN.1 parser</a>,
giving us close-to-native parsing performance.</li><li><strong>Differential reduction</strong>: The parser mentioned above is already used
by <a href="https://cryptography.io/">PyCA Cryptography</a> for its X.509 APIs. This will reduce the need for
“mix and match” approaches to ASN.1 parsing, which in turn drive
differential vulnerabilities.</li><li><strong>Modernization</strong>: The new API will expose a declarative <a href="https://docs.python.org/3/library/dataclasses.html"><code>dataclasses</code></a>
style interface replete with type hints, making it familiar, idiomatic,
and compatible with type checkers.</li></ol><p>For example, an ASN.1 definition like this:</p><figure><pre tabindex="0"><code data-lang="asn.1"><span><span>Doohickies ::= SEQUENCE {
</span></span><span><span>    tschotchkes       OCTET STRING,
</span></span><span><span>    baubles           INTEGER,
</span></span><span><span>    knickknacks       UTF8String,
</span></span><span><span>    whatchamacallits  SEQUENCE OF OBJECT IDENTIFIER,
</span></span><span><span>    gizmos            SET OF GeneralizedTime OPTIONAL
</span></span><span><span>}</span></span></code></pre></figure><p>…will correspond to the following Python code:</p><figure><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span>
</span></span><span><span>
</span></span><span><span><span>from</span> <span>cryptography.hazmat</span> <span>import</span> <span>asn1</span>
</span></span><span><span>
</span></span><span><span><span>@asn1.sequence</span>
</span></span><span><span><span>class</span> <span>Doohickies</span><span>:</span>
</span></span><span><span>    <span>tschotchkes</span><span>:</span> <span>bytes</span>
</span></span><span><span>    <span>baubles</span><span>:</span> <span>int</span>
</span></span><span><span>    <span>knickknacks</span><span>:</span> <span>str</span>
</span></span><span><span>    <span>whatchamacallits</span><span>:</span> <span>list</span><span>[</span><span>asn1</span><span>.</span><span>ObjectIdentifier</span><span>]</span>
</span></span><span><span>    <span>gizmos</span><span>:</span> <span>set</span><span>[</span><span>datetime</span><span>]</span> <span>|</span> <span>None</span>
</span></span><span><span>
</span></span><span><span><span>doohickies</span> <span>=</span> <span>Doohickies</span><span>.</span><span>from_der</span><span>(</span><span>b</span><span>&#34;...&#34;</span><span>)</span>
</span></span><span><span><span>print</span><span>(</span><span>doohickies</span><span>.</span><span>tschotchkes</span><span>)</span>
</span></span><span><span><span>doohickies</span><span>.</span><span>to_der</span><span>()</span> <span># b&#34;...&#34;</span></span></span></code></pre></figure><p>This work is a logical continuation of our previous work on
<a href="https://blog.trailofbits.com/2024/01/25/we-build-x-509-chains-so-you-dont-have-to/">X.509 path validation</a>, as funded by the <a href="https://www.sovereign.tech/programs/fund">Sovereign Tech Fund</a>. It
reflects our ongoing commitment to improving the Python ecosystem, particularly
in the areas of cryptography and supply chain security.</p><p>Please <a href="mailto:ecosystem@trailofbits.com">get in touch</a> if you’re interested in learning more, or funding
similar work!</p><h2 id="some-quick-background-on-asn1">Some quick background on ASN.1</h2><p><a href="https://en.wikipedia.org/wiki/ASN.1">ASN.1</a>, or Abstract Syntax Notation One, is an <em>interface description language</em>
(IDL). That’s a fancy way of saying that it’s a syntax for describing
data structures in a language- and platform-agnostic manner.</p><p>Confusingly, ASN.1 is <strong>not itself</strong> a serialization format. Instead, it defines
<em>encoding rules</em>, which in turn define serialization and deserialization
of ASN.1 structures in different settings. In practice,
ASN.1 is synonymous<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> with the <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">Distinguished Encoding Rules</a>, or DER.</p><figure><img src="https://blog.trailofbits.com/img/encoding-rules.png" alt="A helpful visual explanation of ASN.1’s different encoding rules"/><figcaption>Figure 1: A helpful visual explanation of ASN.1&#39;s different encoding rules</figcaption></figure><p>We’ll treat “ASN.1” and “DER” as interchangeable for the purposes of this post.
Instead of delving too deeply into the intricacies of both
(<a href="https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/">Let’s Encrypt covers them excellently</a>), we’ll focus on the properties
of DER that have kept it relevant for decades:</p><ul><li><p><strong>DER is a <em>canonical</em> encoding:</strong> There’s only one way to encode a given ASN.1
structure in DER. In other words, the encoding of an ASN.1 structure in DER
is deterministic and can be round-tripped while preserving bit-for-bit
equality.</p></li><li><p><strong>DER is <em>relatively compact</em>:</strong> DER defines a binary format and, as a
consequence of being canonical, forbids non-minimal encodings of integers,
booleans, and times.</p></li><li><p><strong>DER is a <em>self-describing</em> and <em>self-delimiting</em> encoding:</strong> A given DER
message can be fully and soundly parsed without prior reference to a
schema or format description beyond the encoding rules of DER themselves.</p><p>These properties lend themselves naturally to what web developers would
call “progressive enhancement”: an application that consumes DER can
decode the specific structures it cares about while skipping the ones it
doesn’t, decoding only their length in order to jump ahead to the next one.</p></li><li><p><strong>DER supports <em>arbitrary-precision integers</em>:</strong> The <code>INTEGER</code> type in DER
is functionally unconstrained in size, which makes it suitable for
representing the kinds of large numbers that regularly appear in
cryptographic settings (e.g., primes).</p></li></ul><p>Put together, these properties make DER very popular in cryptographic,
networking, and telecommunications settings.</p><p>More precisely, it’s very popular in the guts of each of these settings:
ASN.1 is used to represent the X.509 certificates that secure the world’s TLS
traffic, is widely used with <a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail#PEM_encoding">PEM-encoded</a> formats, and provides the
description and serialization for much of the internet’s lower protocol layers.</p><h2 id="motivating-an-asn1-library-for-python">Motivating an ASN.1 library for Python</h2><p>You might reasonably ask: why does Python need this?</p><p>After all, most Python developers aren’t touching ASN.1 on a daily basis, and
those that do are mostly doing so in predefined ways (such as X.509
certificates). Why does the ecosystem need <em>generic</em> support for ASN.1?</p><p>The answer to this is that, for better or worse, there are <em>many</em> situations
in which Python developers need to do ASN.1 encoding and decoding outside
of the “standard” shapes of X.509 and other well-known formats and protocols.</p><p>This can be seen in the <a href="https://sigstore.dev/">Sigstore</a> ecosystem: Sigstore is
<em>primarily</em> an ordinary <a href="https://datatracker.ietf.org/doc/html/rfc5280">RFC 5280</a>–style PKI, but it also includes some custom
<a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.2">X.509 extensions</a> for its own purposes. For example, an excerpt
of a <a href="https://search.sigstore.dev/?logIndex=147137139">Sigstore log entry</a> shows the following extensions:</p><figure><pre tabindex="0"><code data-lang="plaintext"><span><span>OIDC Issuer: https://token.actions.githubusercontent.com
</span></span><span><span>Runner Environment: github-hosted
</span></span><span><span>Source Repository URI: https://github.com/pypa/sampleproject
</span></span><span><span>Source Repository Ref: refs/heads/main
</span></span><span><span>Source Repository Owner URI: https://github.com/pypa</span></span></code></pre></figure><p>If we want to consume these from Python (e.g., for the purposes of verifying
a Sigstore certificate against a policy), we need to extract them:</p><figure><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>cryptography</span> <span>import</span> <span>x509</span>
</span></span><span><span>
</span></span><span><span><span>raw_cert</span> <span>=</span> <span>b</span><span>&#34;&#34;&#34;
</span></span></span><span><span><span>-----BEGIN CERTIFICATE-----
</span></span></span><span><span><span>MIIGoTCCBiigAwIBAgITFai+PDKak1xA1HLq0mskqhDV5zAKBggqhkjOPQQDAzA3
</span></span></span><span><span><span>MRUwEwYDVQQKEwxzaWdzdG9yZS5kZXYxHjAcBgNVBAMTFXNpZ3N0b3JlLWludGVy
</span></span></span><span><span><span>bWVkaWF0ZTAeFw0yNDExMDYyMjM3MDdaFw0yNDExMDYyMjQ3MDdaMAAwWTATBgcq
</span></span></span><span><span><span>hkjOPQIBBggqhkjOPQMBBwNCAARbx1Fse2Ln00On5aFaL+lHNGFYLaqeKDduplZD
</span></span></span><span><span><span>PJS+w2PjYfNPL0g/n4sDWEQFZfyIExEWKulZ2GKNzAc0+SmUo4IFSDCCBUQwDgYD
</span></span></span><span><span><span>VR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMB0GA1UdDgQWBBT/uSEI
</span></span></span><span><span><span>XmQzuRkppWXrTKVkfZFJbzAfBgNVHSMEGDAWgBTf0+nPViQRlvmo2OkoVaLGLhhk
</span></span></span><span><span><span>PzBhBgNVHREBAf8EVzBVhlNodHRwczovL2dpdGh1Yi5jb20vcHlwYS9zYW1wbGVw
</span></span></span><span><span><span>cm9qZWN0Ly5naXRodWIvd29ya2Zsb3dzL3JlbGVhc2UueW1sQHJlZnMvaGVhZHMv
</span></span></span><span><span><span>bWFpbjA5BgorBgEEAYO/MAEBBCtodHRwczovL3Rva2VuLmFjdGlvbnMuZ2l0aHVi
</span></span></span><span><span><span>dXNlcmNvbnRlbnQuY29tMBIGCisGAQQBg78wAQIEBHB1c2gwNgYKKwYBBAGDvzAB
</span></span></span><span><span><span>AwQoNjIxZTQ5NzRjYTI1Y2U1MzE3NzNkZWY1ODZiYTNlZDhlNzM2YjNmYzAVBgor
</span></span></span><span><span><span>BgEEAYO/MAEEBAdSZWxlYXNlMCAGCisGAQQBg78wAQUEEnB5cGEvc2FtcGxlcHJv
</span></span></span><span><span><span>amVjdDAdBgorBgEEAYO/MAEGBA9yZWZzL2hlYWRzL21haW4wOwYKKwYBBAGDvzAB
</span></span></span><span><span><span>CAQtDCtodHRwczovL3Rva2VuLmFjdGlvbnMuZ2l0aHVidXNlcmNvbnRlbnQuY29t
</span></span></span><span><span><span>MGMGCisGAQQBg78wAQkEVQxTaHR0cHM6Ly9naXRodWIuY29tL3B5cGEvc2FtcGxl
</span></span></span><span><span><span>cHJvamVjdC8uZ2l0aHViL3dvcmtmbG93cy9yZWxlYXNlLnltbEByZWZzL2hlYWRz
</span></span></span><span><span><span>L21haW4wOAYKKwYBBAGDvzABCgQqDCg2MjFlNDk3NGNhMjVjZTUzMTc3M2RlZjU4
</span></span></span><span><span><span>NmJhM2VkOGU3MzZiM2ZjMB0GCisGAQQBg78wAQsEDwwNZ2l0aHViLWhvc3RlZDA1
</span></span></span><span><span><span>BgorBgEEAYO/MAEMBCcMJWh0dHBzOi8vZ2l0aHViLmNvbS9weXBhL3NhbXBsZXBy
</span></span></span><span><span><span>b2plY3QwOAYKKwYBBAGDvzABDQQqDCg2MjFlNDk3NGNhMjVjZTUzMTc3M2RlZjU4
</span></span></span><span><span><span>NmJhM2VkOGU3MzZiM2ZjMB8GCisGAQQBg78wAQ4EEQwPcmVmcy9oZWFkcy9tYWlu
</span></span></span><span><span><span>MBgGCisGAQQBg78wAQ8ECgwIMTQ4OTk1OTYwJwYKKwYBBAGDvzABEAQZDBdodHRw
</span></span></span><span><span><span>czovL2dpdGh1Yi5jb20vcHlwYTAWBgorBgEEAYO/MAERBAgMBjY0NzAyNTBjBgor
</span></span></span><span><span><span>BgEEAYO/MAESBFUMU2h0dHBzOi8vZ2l0aHViLmNvbS9weXBhL3NhbXBsZXByb2pl
</span></span></span><span><span><span>Y3QvLmdpdGh1Yi93b3JrZmxvd3MvcmVsZWFzZS55bWxAcmVmcy9oZWFkcy9tYWlu
</span></span></span><span><span><span>MDgGCisGAQQBg78wARMEKgwoNjIxZTQ5NzRjYTI1Y2U1MzE3NzNkZWY1ODZiYTNl
</span></span></span><span><span><span>ZDhlNzM2YjNmYzAUBgorBgEEAYO/MAEUBAYMBHB1c2gwWQYKKwYBBAGDvzABFQRL
</span></span></span><span><span><span>DElodHRwczovL2dpdGh1Yi5jb20vcHlwYS9zYW1wbGVwcm9qZWN0L2FjdGlvbnMv
</span></span></span><span><span><span>cnVucy8xMTcxMzAzODk4MS9hdHRlbXB0cy8xMBYGCisGAQQBg78wARYECAwGcHVi
</span></span></span><span><span><span>bGljMIGKBgorBgEEAdZ5AgQCBHwEegB4AHYA3T0wasbHETJjGR4cmWc3AqJKXrje
</span></span></span><span><span><span>PK3/h4pygC8p7o4AAAGTA5/X5AAABAMARzBFAiA6nYK0GxqVzJutrjrYA1bAIKHU
</span></span></span><span><span><span>jGrsHMLrOJTTEUiERAIhAJZotATnSwlKt7C3Zwhx3fcSrhGfOakTlM2w+8qmltcj
</span></span></span><span><span><span>MAoGCCqGSM49BAMDA2cAMGQCMB+ilsPgy4ynUG9GtqDEBqW8+ZqjX6LpuxQqjCr7
</span></span></span><span><span><span>s4ytyt2ppFdgjrGrG1DY4nSZtQIwblrgq9t9izAMTkJeqhQBs2OUiyIJZipceD5v
</span></span></span><span><span><span>AAE/Nfgd/9uK0MZAHFsLgalqOBl8
</span></span></span><span><span><span>-----END CERTIFICATE-----
</span></span></span><span><span><span>&#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span><span>cert</span> <span>=</span> <span>x509</span><span>.</span><span>load_pem_x509_certificate</span><span>(</span><span>raw_cert</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># 1.3.6.1.4.1.57264.1.16 corresponds to Source Repository Owner URI above</span>
</span></span><span><span><span>ext</span> <span>=</span> <span>cert</span><span>.</span><span>extensions</span><span>.</span><span>get_extension_for_oid</span><span>(</span><span>x509</span><span>.</span><span>ObjectIdentifier</span><span>(</span><span>&#34;1.3.6.1.4.1.57264.1.16&#34;</span><span>))</span><span>.</span><span>value</span>
</span></span><span><span>
</span></span><span><span><span>ext</span><span>.</span><span>value</span> <span># =&gt; b&#39;\x0c\x17https://github.com/pypa&#39;</span></span></span></code></pre></figure><p>As we can see, the X.509 extension’s value is <em>itself</em> DER encoded, and
PyCA Cryptography’s APIs (rightfully) leave it up to us to interpret
it<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p><p>So, we need <em>some</em> kind of DER parser. Luckily, Python is a mature ecosystem,
and we can avail ourselves of <a href="https://pypi.org/project/pyasn1/"><code>pyasn1</code></a>:</p><figure><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>pyasn1.codec.der.decoder</span> <span>import</span> <span>decode</span>
</span></span><span><span><span>from</span> <span>pyasn1.type.char</span> <span>import</span> <span>UTF8String</span>
</span></span><span><span>
</span></span><span><span><span>ext_value</span> <span>=</span> <span>decode</span><span>(</span><span>ext</span><span>.</span><span>value</span><span>,</span> <span>UTF8String</span><span>)[</span><span>0</span><span>]</span><span>.</span><span>decode</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>ext_value</span> <span># =&gt; &#39;https://github.com/pypa&#39;</span></span></span></code></pre></figure><p>Now we have our inner extension value, and we can get on with our lives.</p><h2 id="but-why-a-_new_-library">But why a <em>new</em> library?</h2><p>But wait: if we have <a href="https://pypi.org/project/pyasn1/"><code>pyasn1</code></a>, why do we need a <em>new</em> ASN.1 library?</p><p>The answer to this is threefold, and is <em>not</em> a knock against <a href="https://pypi.org/project/pyasn1/"><code>pyasn1</code></a>
(which is an excellent library that performs its role admirably):</p><ol><li><p><strong>Performance</strong>: Python is not a fast language, and <a href="https://pypi.org/project/pyasn1/"><code>pyasn1</code></a> is written in
pure Python. The Python ecosystem has historically compensated for that by
putting performance-sensitive code in native extensions: at first C, but now
increasingly Rust. By leveraging <a href="https://github.com/alex/rust-asn1"><code>rust-asn1</code></a>, we can approach the
performance of native code without leaving the comforts of Python.</p></li><li><p><strong>Differential reduction</strong>: The ASN.1 ecosystem is notoriously
heterogenous, and implementations of ASN.1 vary widely in their conformance
to the strict requirements of DER.</p><p>In particular, many implementations have found it tempting to apply
<a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel’s Law</a> to the parsing of incoming “DER” data, allowing improperly
canonicalized or outright malformed data so long as the user’s intent
can be inferred. This has had a <a href="https://alexgaynor.net/2025/mar/25/postels-law-and-the-three-ring-circus/">deleterious effect</a> on both
protocol evolution and security: protocols struggle to evolve under the
pressure of unspecified behavior, and <a href="https://langsec.org/">parser differentials</a> are a
<a href="https://github.blog/security/sign-in-as-anyone-bypassing-saml-sso-authentication-with-parser-differentials/">consistent source</a> of major security incidents.</p><p>For this reason, reducing the number of independent parsers for a single
format in a given codebase is generally a sound engineering choice.
PyCA Cryptography is already built up around <a href="https://github.com/alex/rust-asn1"><code>rust-asn1</code></a>,
so it makes sense to use the exact same parsing routines in a new ASN.1
library.</p></li><li><p><strong>Modernization</strong>: <a href="https://docs.python.org/3/library/dataclasses.html"><code>dataclasses</code></a> and <code>dataclass</code>-style declarative APIs
have taken the Python ecosystem by storm, and for good reason: they’re
uniform, integrate cleanly with type checkers<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, and define
types as <em>code</em> rather than as <em>data</em>.</p><p><a href="https://pypi.org/project/pyasn1/"><code>pyasn1</code></a> has a fantastic declarative API, but that API predates
the dataclass concept and therefore needs to mix code and data to define
its types. Modernizing this API would be at least as difficult
(in our estimation) as creating a new one from <a href="https://github.com/alex/rust-asn1"><code>rust-asn1</code></a> but without
the performance and differential reduction benefits.</p></li></ol><h2 id="stay-tuned-for-more">Stay tuned for more</h2><p>This is just a sneak peek; watch this space for updates!</p><p>We’re still early in the development process for this work; our plan is as
follows:</p><ul><li>Build an initial version with support for <code>@asn1.sequence</code> and <code>@asn1.enum</code>
as the main decorators, along with support for ASN.1’s basic types
and modifiers (e.g., <code>OPTIONAL</code>, <code>DEFAULT</code>, <code>IMPLICIT</code>, and <code>EXPLICIT</code>).</li><li>Integrate this version into PyCA Cryptography, tentatively as
<code>cryptography.asn1</code> or <code>cryptography.hazmat.asn1</code> or similar, then work
on deduplicating types where possible. For example, the
<code>cryptography.x509.ObjectIdentifier</code> type is already present and should
be shared or reused across both APIs.</li><li>Get it released with a major version of PyCA Cryptography!</li></ul><p>We’d like to thank <a href="https://alpha-omega.dev/">Alpha-Omega</a> for funding this work, as well as
the <a href="https://cryptography.io/">PyCA Cryptography</a> maintainers for their support and design review.</p></div></article></main></div></div></div></div>
  </body>
</html>
