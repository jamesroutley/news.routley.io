<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.synacktiv.com/en/publications/defend-against-vampires-with-10-gbps-network-encryption">Original</a>
    <h1>Defend against vampires with 10 gbps network encryption</h1>
    
    <div id="readability-page-1" class="page"><div property="schema:text"><p>Let&#39;s say you have a fiber optic line running between two buildings, or between two spaces you rent in the same building. You use trunk ports on the switches connected to the fiber, in order to &#34;stretch&#34; your L2 Ethernet network and its different VLANs, so computers, servers, printers, cameras, etc. in both offices easily communicate with their peers.</p>
<p>But there is next to no physical security in the shared wiring closets and common cabling paths, and so you are concerned about someone <em>tapping</em> into the fiber line and capturing data.</p>
<p>First you may ask, is that really possible? And if so, is it easy to do? Would you need NSA-level hardware and skills or could anyone do it?</p>
<p>Turns out, it is both possible and easy, so you&#39;re right to worry! But there is a solution...</p>

<h3>Tapping on copper cables</h3>
<p>It&#39;s so simple to tap on copper network cables that back in the 80s, it was the official way to expand your 10BASE5 Ethernet network. IT people used so-called &#34;vampire taps&#34; that truly <em>bit</em> through the insulation of the cable to make contact with the conductors inside, enabling a new connection without interrupting ongoing data transmission.</p>
<figure role="group">
<img alt="photo of a 80s vampire tap showing bite marks on the cable" data-entity-type="file" data-entity-uuid="239417dc-b316-4b38-8a2e-a7a6589df581" src="https://www.synacktiv.com/sites/default/files/inline-images/vampiretap.jpg"/>
<figcaption>Vampire tap and 10BASE5 Ethernet cable showing &#34;bite marks&#34;</figcaption>
</figure>
<p><a href="https://www.tiktok.com/@davidbombal/video/7246772712696335643">This TikTok video</a> shows one of these devices in action.</p>
<p>Nowadays, people might still use copper cables instead of fiber for distances &lt; 100m, and <a href="https://en.wikipedia.org/wiki/Network_tap#Gigabit_Ethernet_issues">it&#39;s a bit more difficult to tap on 1000BASE-T modern cables</a>. Anyway, since our typical LAN-to-LAN scenario rather involves optical fibers running along not-well-protected cable runways, let&#39;s see if optical fibers are vulnerable too.</p>
<h3></h3>
<p>For a number of years it was commonly believed that tapping on optical fibers was possible, but that it needed both expertise and expensive hardware.</p>
<p>But in 2015, the late <a href="https://www.zdnet.com/article/infamous-hacker-kevin-mitnick-sniffs-fiber-reads-email/">Kevin Mitnick demonstrated just how easy it is to tap into a fiber and sniff the traffic</a>, using a 200$ optical &#34;clip-on coupler&#34;.</p>
<p>These couplers are originally designed to be used by line technicians to talk to one another over long distances using so-called &#34;optical talk sets&#34;, and coordinate with one another while installing these fibers, even when they have no access to the ends of the fiber.</p>
<p>They work by exposing a portion of the fiber core and bending it slightly, reflecting some 2-3% of the light inside the fiber (but still 100% of its data) and also allowing to inject light in it. Of course, it&#39;s better to have some practice and a steady hand in order to expose the fiber core without damaging the fiber.</p>
<p>In true hacker fashion, these couplers are creatively used by attackers to read data from the fiber, and inject data of their own. </p>
<figure role="group">
<img alt="clip-on coupler like the one used by Mitnick" data-entity-type="file" data-entity-uuid="f8ad2517-2643-41eb-b7d6-358848d41033" src="https://www.synacktiv.com/sites/default/files/inline-images/clip_on_coupler_small.jpg"/>
<figcaption>The FOD5516 Clip-on Coupler that can detect and inject light in (singlemode) optical fiber</figcaption>
</figure>
<p>This opens many classical man-in-the-middle attack scenarios such as forcing the downgrade of crypto protocols, redirecting traffic, etc. on top of simple sniffing.</p>

<h2>Encrypt ALL the things !</h2>
<p>So it seems there&#39;s not much you can do to prevent vampire tapping onto your easily-accessible cable paths. In fact, they might already be there...</p>
<p>As with any confidentiality issue, the best solution lies in encryption. If your whole network traffic is encrypted, the data vampires might still suck on your network cables, but instead of draining the very blood of your company, they will only gather encrypted gibberish of no use to them.</p>
<p>But how exactly can you encrypt &#34;everything&#34; in such a LAN-to-LAN scenario? And at what cost?</p>
<p>If you had routers on both ends of the fiber, with each site having its own dedicated IP zones with no overlap, you could easily setup a VPN tunnel like IPSec or Wireguard between the two routers and solve your problem.</p>
<p>The idea we had to solve such a problem, with the least disruption to existing networks and protocols, was to mix &#34;802.1q trunk links&#34; and VPN-like encryption between the two ends of the fiber. So instead of plugging the fiber directly into your switches, you plug them to an equipment with two network interfaces, that will on one end &#34;swallow&#34; all your 802.1q traffic (VLANs and all) and then transfer them over the fiber, through an encrypted tunnel, to a second &#34;mirror&#34; equipment that will decrypt the packets and transform them again into 802.1q frames and &#34;spit them out&#34; to its local network. This was dubbed the &#34;wormhole&#34; project.</p>
<h2>The quest for the encrypted trunk : MACsec</h2>
<p>If you search for ways to &#34;encrypt/secure a 802.1q trunk&#34; you will probably read about MACsec, aka the Cisco-designed 802.1ae standard, which on paper seems to do exactly what we want, with the added benefit that if you use MACsec-capable switches on each end of the fiber, you don&#39;t need additionnal equipements to do the secure tunneling.</p>
<p>MACsec creates point-to-point Secure Channels pairs (one for Tx, one for Rx) between two devices over an untrusted connection, using first a negotiation protocol called MKA (MACsec Key Agreement) and for example pre-shared keys (or a PKI). Over these Secure Channels, MACSec Frames are sent, which are only slightly modified Ethernet frames with their layer-3+ payload encrypted using GCM-AES-128 (or GCM-AES-256 in newer hardware). Since they are essentially Ethernet frames, MACSec can natively support 802.1q VLAN headers for example.</p>
<p>In order to test these promises, we bought a pair of the smallest Cisco switch that supports MACsec : the Catalyst 3560 CX WS-3560CX-8XPD-S, at ~1600€ each.</p>
<h3></h3>
<p>Unfortunately, during our testing we found MACsec underwhelming for our LAN-to-LAN scenario.</p>
<p>First, it&#39;s difficult to find accurate MACsec documentation since it supports a variety of use cases (securing a link between a workstation and a switch, securing a link between two switches...) and as usual with Cisco, there are configuration directives that may or may not exist on a given Cisco switch, depending on its IOS image, feature level, generation, etc. So it was a bit of a pain to get it working for our trunk ports.</p>
<p>Then, we found out something that in hindsight was pretty clear in the MACsec specification : MACsec <em>does not hide the real MAC addresses of devices talking on your network</em> to the eavesdropping attacker. It may make sense, in order for traffic to be able go through MACsec-unaware bridges, to preserve the original MAC adresses of (for example) two computers talking to each other, but we expected to be able to see only the MAC Adresses of the two switches directly connected to the untrusted network and doing the MACsec tunnel. This could have been considered a minor inconvenience, but as MAC addresses are assigned by device manufacturers, it gives an attacker quite a good intel on what brand of computer, printer, appliances, etc. devices you have on your network, so that may help them plan a targeted attack. And if you&#39;re worried about industrial espionage, maybe you don&#39;t want your spying concurrent to know what brand of components you use on your R&amp;D VLANs either.</p>
<p>Last but not least, on several occasions during our offensive testing, we were able to mess with the MKA/MACsec traffic enough (using not-so-transparent software bridges and resetting MKA sessions on the switches ) so that half of the traffic (corresponding to one of the two secure channels) was being sent fully unencrypted, despite the <code>linksec policy must-secure</code> settings on the ports specifying to never send traffic in the clear on this interface according to Cisco documentation (&#34;Must-Secure imposes that only MACsec encrypted traffic can flow. Hence, until the MKA session is secured, traffic is dropped.&#34;). Moreover, the switches were not reporting errors at all and happily continued sending/receiving clear traffic on MACsec must-secure interfaces. The end-user devices (laptops) had no way to know their traffic was being read, since their communications continued as usual (minus the loss of a few ICMP or UDP packets during MKA renegociation).</p>
<figure role="group">
<img alt="wireshard capture showing half the traffic in clear" data-entity-type="file" data-entity-uuid="7101fb11-ea1d-4bcb-81c4-10ca1c3fa7fb" src="https://www.synacktiv.com/sites/default/files/inline-images/pcap_macsec_clair.png"/>
<figcaption>Wireshark traffic capture : the ping replies are sent in clear over the MACsec link, although the ping echo requests are still sent encrypted.</figcaption>
</figure>
<p>This behaviour was observed with the most recent IOS firmware at that time, and although it then required both 1) an attacker on the fiber doing Man-in-the-Middle and dropping some frames, and 2) an admin action on the switch CLI itself (<code>clear mka sessions</code>), given that the MKA sessions have an expiry and must be renegociated after some time or when a port goes down, we think it&#39;s likely that there&#39;s a way to trigger that behavior only by &#34;sitting on the wire&#34; with no CLI access to the switch.</p>
<p>The bug tracker from Cisco showed bugs and behaviour that, although apparently not applying to our model, looked close to what we found:</p>
<ul>
<li><a href="https://bst.cisco.com/quickview/bug/CSCvx83835">&#34;MACsec access-control must-secure is allowing the unencrypted traffic to pass through a link&#34;</a></li>
<li><a href="https://bst.cisco.com/quickview/bug/CSCvw36505">&#34;MACsec ports in Auth-pending state after changing to should secure policy with Empty keychain&#34;</a></li>
<li><a href="https://bst.cisco.com/quickview/bug/CSCus74990">&#34;MKA sessions struck in &#34;pending&#34; state after clear MKA sess&#34;</a></li>
</ul>
<p>We had to drop there our experiments with our Cisco switches since the goal of this mission was to &#34;find a reliable way to encrypt LAN to LAN fiber links at high speed&#34;, not to &#34;break MACsec&#34;, but we may go back to it sometime in the future :)</p>
<h2>Native Linux solution : VXLAN+Wireguard</h2>
<p>Having set MACsec aside, we decided to PoC something that would use only native and well-known Linux kernel features on commodity hardware.</p>
<p>Since Wireguard is the state-of-the-art, in-kernel tunneling, was there a way to shove 802.1q L2 traffic inside a wireguard tunnel, and what speeds could be reached on customer-level hardware costing approximately the same as the Cisco switches we just tested ?</p>
<p>The &#34;missing bit&#34; to go from an L2 trunk to a L3 tunnel was solved by using VXLAN. </p>
<h3>VXLAN</h3>
<p>VXLAN is a protocol used to carry over L2 frames using UDP encapsulation (port 4789 or 8472 depending on the implementation) to a distant endpoint (called VTEP, for &#34;VXLAN termination endpoint&#34;). It works by hooking onto L2 forwarding tables (like on a Linux bridge), and sending to the remote VTEP the frames that must be broadcasted on the segment, along with the frames that have no local destination (&#34;flood and learn&#34;). The remote VTEP decapsulates the L2 frame from the UDP packet and sends it to its local network.</p>
<p>VXLAN real-world use case mostly involves &#34;datacenter bridging&#34;, so that VMs from Datacenter 1 could behave like they are &#34;on the same Ethernet segment&#34; than VMs from Datacenter 2 so they can really share the same IP subnet (respond to ARP &#34;who-has&#34;, etc). </p>
<p>Despite its name, VXLAN is only &#34;inspired&#34; by the concept of L2 VLANs : it is not something that will, out-of-the box, listen on a trunk port and carry 802.1q tagged frames to the remote endpoint. But it&#39;s very possible to do so using Linux wonderful networking stack ! You just need to to map each 802.1q VLAN ID to a VXLAN &#34;vid&#34; and do the same thing in reverse on the other VTEP.</p>
<p>Most of the documentation you find online about injecting L2 VLAN info into a VXLAN tunnel has you creating a Linux bridge + a VLAN interface + a VXLAN interface <em>per VLAN </em>that you want to transmit. </p>
<p>With these commands you can have a single bridge and VXLAN interface that handles every VLAN coming its way.</p>
<pre><code># Create a Linux bridge with the right options
/sbin/ip link add br0 type bridge vlan_filtering 1 vlan_default_pvid 0 vlan_stats_enabled 1 vlan_stats_per_port 1

# Enslave the trunk eth interface (connected to the switch trunk port)
# to the bridge
/sbin/ip link set dev ${TRUNK_IFACE} master br0

# Create a vxlan interface and enslave it to the same bridge
/sbin/ip link add vxlan0 type vxlan vni ${VXLAN_DEFAULT_VNI} local ${VTEP_LOCALIP} remote ${VTEP_REMOTEIP} dstport 4789
/sbin/ip link set dev vxlan0 master br0

# Activate vlan tunneling !
/sbin/bridge link set dev vxlan0 vlan_tunnel on</code></pre>
<p>Then, adding a specific VLAN ID to the bridge so its extracted and mapped to a VXLAN vid requires these 3 commands</p>
<pre><code>/sbin/bridge vlan add vid $vid dev ${TRUNK_IFACE}
/sbin/bridge vlan add vid $vid dev vxlan0
/sbin/bridge vlan set dev vxlan0 vid $vid tunnel_info id $vid</code></pre>
<p>You can easily run a little script to do the mapping once and for all for every possible VLAN ID :</p>
<pre><code># extract vlans from trunk, map them to same vxlan vid
for vid in $(seq 2 4095); do
/sbin/bridge vlan add vid $vid dev ${TRUNK_IFACE}
/sbin/bridge vlan add vid $vid dev vxlan0
/sbin/bridge vlan set dev vxlan0 vid $vid tunnel_info id $vid
done</code></pre>

<h3>Wireguard</h3>

<p>Indeed, if you&#39;ve already set up a wg0 interface over the (insecure) fiber connection, with (secure) IP addresses for both of your &#34;wormholes&#34;, you can specify the remote peer&#39;s wireguard IP address directly as ${VTEP_REMOTEIP}. Linux in-kernel networking will then do its magic and dutifully forward over the wire your 802-1q frames, encapsulated in UDP VXLAN, and encapsulated again in UDP Wireguard.</p>
<p>Having read that, you might worry like we did at the potential performance cost of such many-levels of encapsulation and encryption on top of it.</p>

<h2>Performance </h2>
<p><img alt="scheme of the multiple layers of encapsulation between the wormholes" data-entity-type="file" data-entity-uuid="3c48c427-11f2-416a-b2fe-c228fc8c3a54" src="https://www.synacktiv.com/sites/default/files/inline-images/max-encap.png"/></p><p>So, the final packets that will transit &#34;on the wire&#34; between our wormholes will end up looking something  like <code>Eth/IP/UDP/WG/IP/UDP/VXLAN/Eth/802.1q/IP/Payload</code>. That&#39;s quite an overhead indeed!</p>
<p>But this overhead is only present during the transit on the fiber, which on our scenario is a local, short-distance (read : low latency) optical fiber, typically using at least 10 Gbps SFP+ optical transceivers. So the latency and bandwidth should be good, and we will be able to maximize the Maximum Transfer Unit (MTU) on the fiber interface ports, so that a typical Ethernet data payload of 1500 bytes will be able to &#34;sit&#34; easily in the payload of our jumbo wireguard+vxlan frame :  there will be no need for segmentation and retransmits. </p>
<p>Regarding wireguard encryption, we did a little research and felt confident after reading <a href="https://restoreprivacy.com/optimizations-in-wireguard-achieve-record-10gbit-sec-throughput/">resources</a>  that we could reach high speeds with the right hardware offloads, altough 10 Gbps seemed like the &#34;record&#34;.</p>
<p>The corresponding <code>ethtool</code> vars that matched offloads that enabled good performance for VXLAN+wireguard were determined to be : <code>tx-udp_tnl-segmentation, generic-segmentation-offload, generic-receive-offload, rx-vlan-offload</code> and <code>tx-vlan-offload</code>.</p>
<p>The next step was to find server hardware that had 10 Gbps SFP+ ports with <strong>UDP Segmentation Offload</strong> (Generic Segmentation Offload), <strong>UDP Receive Coalescing</strong> (Generic Receive Offload) and <strong>VXLAN offloading</strong> capabilites</p>
<p>The search was over when we found out about SuperMicro SuperServer 5019D-4C-FN8TP, that had everything we needed with an Intel Xeon D-2123IT SoC that directly handles 2x 10Gbps SFP+ and 2x 10Gbps base-T ports, both the CPU and NICs supporting the aforementioned offload instructions. It costed about 1300€ (you then have to add ECC RAM and local hard drive yourself).</p>
<p><img alt="picture of chosen supermicro server" data-entity-type="file" data-entity-uuid="ff622867-34b4-409c-b904-49fc587e2ef8" src="https://www.synacktiv.com/sites/default/files/inline-images/supermicro.png"/></p><h3>Test setup</h3>
<p>Our test setup was like this :</p>
<p><img alt="schema of our test setup described below" data-entity-type="file" data-entity-uuid="592259de-dcc4-40cd-bac4-bb474ba78e6b" src="https://www.synacktiv.com/sites/default/files/inline-images/maquette_0.png"/></p><p>We planned to measure throughput using <code>iperf3</code> in the following conditions:</p>
<ul>
<li>Between the Supermico wormholes on the untrusted fiber</li>
<li>Between the Supermico wormholes through the wireguard tunnel built over the untrusted fiber (to measure wireguard encryption penalty)</li>
<li>Between a pair of two 1 Gbps laptops, each on one side of the wormholes, to measure end-device to end-device performance</li>
<li>Between <em>two</em> pairs of such laptops, each pair on a different VLAN and simultaneously trying to use their 1 Gbps max bandwidth, just to be sure we were scaling... and this was quite a good intuition to do this test, as you will read further.</li>
</ul>
<p>We also measured the base performance of the four laptops with a classical setup (just the network switches linked by a trunk port, no vxlan or wireguard, no &#34;wormholing&#34;) : they were able to reach 942 Mbps.</p>
<p>Just out-of-the box, with no particular tuning, here were the first tests results:</p>
<ul>
<li>9.81 Gbits/sec between the Supermicros on untrusted fiber (no crypto) - so it seems we really did buy 10 Gbps-capable NICs! nice</li>
<li>8.18 Gbits/sec between the Supermicros on wg0 (AES) - a 17% performance penalty, seemed to be expected from encrypting...</li>
<li>874 Mbits/sec between two laptops (compared to 942 Mbps in a classical setup) - a 8% performance &#34;end-user&#34; penalty, did not seem so bad</li>
<li>But only 658 Mbits/sec when there were 4 laptops each connected in pairs (again compared to 942 Mbps for each pair) - oops, something seemed off! </li>
</ul>
<p>It looked like we were stalling somewhere around a ~1 Gbps shared bandwith for every end-user devices. Looked like a waste of our &#34;next to 10 Gbps&#34; bandwidth, surely there was something to do about it.</p>
<h3>Tuning Linux networking</h3>
<p>So we activated all the network-related tuning we had thought off beforehand:</p>
<pre><code># enable Jumbo frames (9000 bytes MTU) on 10 Gbps fiber
/sbin/ip li set dev ${UNTRUSTED_IFACE} mtu 9000

# https://cromwell-intl.com/open-source/performance-tuning/ethernet.html
/sbin/ip link set dev ${UNTRUSTED_IFACE} txqueuelen 13888 
/sbin/ethtool -G ${UNTRUSTED_IFACE} rx 4096 tx 4096

# setup a 8020 MTU on wg0 interface to account for the 80 bytes wireguard headers overhead
# 20-byte IPv4 header or 40 byte IPv6 header, 8-byte UDP header  4-byte type, 4-byte key index, 8-byte nonce, 16-byte authentication tag)
/sbin/ip li set dev wg0 mtu 8020</code></pre>
<p>we added some <code>sysctl</code> tuning for 10Gbps ethernet as well:</p>
<pre><code># Maximum receive socket buffer size
net.core.rmem_max = 134217728 

# Maximum send socket buffer size
net.core.wmem_max = 134217728 

# Minimum, initial and max TCP Receive buffer size in Bytes
net.ipv4.tcp_rmem = 4096 87380 134217728 

# Minimum, initial and max buffer space allocated
net.ipv4.tcp_wmem = 4096 65536 134217728 

# Maximum number of packets queued on the input side
net.core.netdev_max_backlog = 300000 

# Auto tuning
net.ipv4.tcp_moderate_rcvbuf =1

# Don&#39;t cache ssthresh from previous connection
net.ipv4.tcp_no_metrics_save = 1

# If you are using jumbo frames set this to avoid MTU black holes.
net.ipv4.tcp_mtu_probing = 1</code></pre>

<p>After that we had the following test results:</p>
<ul>
<li>9.91 Gbits/sec between the Supermicros on untrusted fiber (no crypto) - 100 Mbps better than 9.81 Gbits/sec !</li>
<li>8.41 Gbits/sec between the Supermicros on wg0 (wireguard) - more than 200 Mbps better than 8.18 Gbits/sec !!</li>
<li>942 Mbits/sec between two laptops - now equivalent to the legacy setup without wormholes - yay !</li>
<li>still 658 Mbits/sec when they were 4 laptops each connected in pairs - something&#39;s still off...</li>
</ul>
<p>Having tuned everything network-related we could think of, it then occured to us that a good part of the networking ( bridging, forwarding, encapsulating) was really done in-kernel (read: &#34;in-memory&#34;) and not on NICs. So surely some default Linux performance setting was stalling us around ~ 1 Gbps .</p>
<h3>Last tunables</h3>
<p>We then set the CPU governor to <code>performance</code> and tuned virtual memory <code>sysctl</code>s to match what RedHat&#39;s <code>tuned</code> tool does when setting the profile <code>throughput-performance</code>:</p>
<pre><code>vm.dirty_ratio = 40
vm.dirty_background_ratio = 10
vm.swappiness=10
# set cpu/power options
governor=performance
energy_perf_bias=performance
min_perf_pct=100</code></pre>
<p>And<em> lo and behold</em>, here were the tests results:</p>
<ul>
<li>9.86 Gbits/sec between the Supermicros on untrusted fiber (no crypto) - bit lower than previous test</li>
<li><strong>9.71 Gbits/sec</strong> between the Supermicros on wg0  - the crypto impact was becoming negligible!</li>
<li>942 Mbits/sec between two laptops (still equivalent to the legacy setup without wormholes)</li>
<li>finally 942 Mbits/sec even when they were 4 laptops each connected in pairs - job done!</li>
</ul>
<p>In fact, the performance was so great we felt the need to vampire tap the fiber to make sure everythink was still encrypted - and it still was ;-)</p>
<h2>Conclusion</h2>
<p>So, we were able to build a fully open-source pair of appliances that will strongly encrypt a 10 Gbps 802.1q trunk at almost wire-speed (less than 2% performance penalty), defeating any spying vampire tapping onto the underlying network link. And this appliance costs less than a flagship smartphone.</p>
<p>This truly speaks levels about the performance of today&#39;s affordable server hardware and the maturity of Linux networking stack. You can chain network technologies like trunking, bridging, routing, VXLAN and Wireguard almost like you chain CLI commands in true UNIX fashion, and the kernel makes it &#34;just work&#34;. It just takes quite a bit of time and trial &amp; error to find the right feature flags and tuning settings so you can get the most out of it. We hope this blog article will do its part as well for future researchers.</p>
<p>If you liked this article and building secure-yet-performant infrastructure, speak French and are living near Paris, note that we are hiring an experienced profile to join our Infrastructure team ! More info (in French) : <a href="https://www.synacktiv.com/apt-search-sysadmin">https://www.synacktiv.com/apt-search-sysadmin</a></p>

</div></div>
  </body>
</html>
