<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/what-is-a-query-planner">Original</a>
    <h1>What Is a Query Planner?</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>Anyone that has worked with large databases can testify how slow queries can get. This is often due to the necessary indexes not being there, or something in the query that stops the database system from using the index. Choosing the right indexes to use, and the right order to fetch data in, proves to be the difference between a 10ms and 5s query.</p>
<p>Choosing the indexes and join order is called query planning. The output of this process is a query plan that tells the database system how to answer a query from a user. For simple queries with a single table, it’s often trivial to find the optimal query plan. But for large queries with lots of tables and lots of indexes, the available options can quickly run into the thousands and even millions of alternatives. Most of these alternatives are really slow, so the planner&#39;s job is to find the best possible query plan among all possibilities.</p>
<h2 id="how-query-planning-works"><a href="#how-query-planning-works">How query planning works<span aria-label="Permalink to How query planning works" role="complementary">#</span></a></h2>
<p>Most people are more familiar with compilers than with query planners, so I thought I should compare the work of a query planner with the work of a compiler.</p>
<p>A compiler is a program that takes source code written in a programming language and translates it into machine code that can be executed by a computer&#39;s processor. A query planner does something similar. The input is code written in SQL (or some other database query language), and the output is a query plan that describes which indexes will be used, and in which order to access tables.</p>
<p>The typical phases of a compiler/planner are: lexing and parsing, semantic analysis, optimization, and code generation. Let’s look at each of these individually to understand the similarities and the differences between a compiler and a query planner.</p>
<h3>Lexing and parsing</h3>
<p>In the first phase, lexing and parsing, the source code is analyzed and divided into a sequence of tokens, which are basic units such as keywords, operators, and identifiers. The sequence of tokens generated by the lexical analyzer is analyzed and checked for correctness according to the rules of the programming language. This phase typically involves building a syntax tree, which is a hierarchical representation of the structure of the source code. The output of this step is an abstract syntax tree (AST). There is no interesting difference between a compiler and a planner here.</p>
<p>As an example, let’s look at the following query:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>SELECT</span><span> </span><span>name</span><span>, </span><span>avg</span><span>(salary) </span><span>FROM</span><span> employees </span><span>JOIN</span><span> salary_info </span><span>ON</span><span> id </span><span>=</span><span> empid</span></span></code></pre></div></div>
<p>The AST would look something like this:</p>

<p>It’s the same query, but instead of a string, it’s now this tree data structure. All the unnecessary parts have been stripped away — the planner doesn’t care if the user wrote “<code>SELECT</code>” or “<code>select</code>”, or any whitespaces in the query.</p>
<h3>Semantic analysis</h3>
<p>The semantic analysis phase of compilation is where the compiler checks for semantic errors in the input source code. Semantic errors are errors that are not detected during the lexical analysis or syntax analysis phases, but which can only be detected by analyzing the meaning of the source code.</p>
<p>During semantic analysis, the compiler performs a variety of checks to ensure that the source code is semantically correct. For example, the compiler may check for type mismatches, in which a value of one type is used in a context where a value of a different type is expected. The compiler may also check for undefined variables or other entities, such as functions or classes, and may perform additional checks and transformations on the syntax tree generated during syntax analysis.</p>
<p>A query planner does almost exactly the same thing here. Instead of searching for classes and methods, it would bind to tables and columns, but the idea is the same.</p>
<p>After semantic analysis, the data structures representing the query will be enriched with information such as which table a column comes from, what types the columns and expressions in the query have, etc.</p>
<h3>Optimization</h3>
<p>During the optimization phase, the compiler will now take all the information gathered during parsing and semantic analysis and iteratively change it to a more optimal form. This is often done using an intermediate representation of the query. Instead of staying in a shape that is close to the input language, the intermediate representation is custom made to make optimisations easier and faster to do.</p>
<p>In this step, the query planner uses a variety of algorithms and techniques to determine the most efficient way to execute the query, considering factors such as the available indexes, the data distribution, and the overall structure of the database. This may involve selecting the most efficient algorithms for operations such as joins and sorting, and choosing the most appropriate indexes to use. It usually also does some of the optimizations that a compiler would perform, such as constant folding. These types of optimizations are about rewriting the input into an equivalent form that is easier for the planner to optimize.</p>
<p>An example of this is how the <a href="https://vitess.io/blog/2021-11-02-why-write-new-planner/">Vitess planner</a> massages predicates into a shape that can be solved using an index. Given a predicate such as:</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>WHERE</span><span> (id </span><span>=</span><span> </span><span>5</span><span> </span><span>AND</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;Toto&#39;</span><span>) </span><span>OR</span><span> (id </span><span>=</span><span> </span><span>5</span><span> </span><span>AND</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;Mumin&#39;</span><span>)</span></span></code></pre></div></div>
<p>The <strong>OR</strong> in the middle here makes it hard for the planner to use an index on <strong>id</strong> to find the correct row. The optimizer will rewrite the predicate into something that is easier to optimize but still means the same thing.</p>
<div data-rehype-pretty-code-fragment=""><div><pre><code><span><span>WHERE</span><span> id </span><span>=</span><span> </span><span>5</span><span> </span><span>AND</span><span> (</span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;Toto&#39;</span><span> </span><span>OR</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>&#39;Mumin&#39;</span><span>)</span></span></code></pre></div></div>
<p>Let us pause here and talk about why the order of table access is so important. Say we want to join three tables: A with B, and B with C. We could start by joining A with B, and take the output of that and join it with C. Or we can start from the other side - join B with C and then join that result with A. The intermediate state needed is where the big difference comes in. If AxB is very large, joining that with C will be very slow, compared to if we start with BxC that happens to be pretty small. It’s a path finding problem.</p>
<p>Here is a diagram of the tables used in the <a href="https://gist.github.com/systay/8b5065e6cc83abe07d998c2b7c1b03bf">TPC-H query #8</a>. The <a href="https://www.tpc.org/tpch/">TPC-H</a> is a decision support benchmark. It consists of a suite of business oriented ad-hoc queries and concurrent data modifications. It’s a well known dataset used to test the strength of database systems, in particular the query planner.</p>

<blockquote>
<p>Source: <a href="https://www.sqlite.org/queryplanner-ng.html">https://www.sqlite.org/queryplanner-ng.html</a></p>
</blockquote>
<p>All the tables need to be visited, and the connections between tables have different costs. The planner can start at any (*) node. What is the path that touches all tables with the least cost? This is why the join order is so important.</p>
<h4>Optimization in Vitess query planner</h4>
<p>In Vitess, our query plans are partly executed on the SQL proxy layer, called <a href="https://vitess.io/docs/concepts/vtgate/">VTGate</a>, and partly on the individual shards. Probably the most important optimization we perform is to push down as much work as possible to MySQL. If we can perform a join or a filter in MySQL, that is always going to be faster than fetching all the individual rows and performing the same operation on the VTGate side. So, during query planning, we are searching for the query plan that has the least number of network calls.</p>
<p>When planning aggregations, our strategy is to do as much aggregation as possible in MySQL, and then aggregate the aggregates. The planner rewrites the aggregation that the user asked for into smaller aggregations and sends those to MySQL. The results of these queries are then used as inputs and summarized into the final aggregation result. You can read more about <a href="https://planetscale.com/blog/grouping-and-aggregations-on-vitess">grouping and aggregations in an earlier blog post</a>.</p>
<h3>Code generation</h3>
<p>In the code generation phase, the compiler generates machine code based on the input source code and the analysis performed in previous phases. This machine code can then be executed by the computer&#39;s processor.</p>
<p>The query planner generates a plan that specifies the exact steps that the database engine should take to execute the query. This plan may include operations such as index scans, join algorithms, and sorting algorithms, as well as other details such as the order in which the operations should be performed.</p>
<h2 id="the-importance-of-a-good-query-planner"><a href="#the-importance-of-a-good-query-planner">The importance of a good query planner<span aria-label="Permalink to The importance of a good query planner" role="complementary">#</span></a></h2>
<p>Query planners are an essential component of database management systems, and the work that query planner developers do plays a crucial role for database systems. The field of query planning is an active area of research, with new algorithms and techniques being developed all the time. A good query planner can have a direct impact on the performance and efficiency of databases, which can have real-world benefits for the organizations and users that rely on those databases.</p>
</div></section></article></div>
  </body>
</html>
