<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/926882/">Original</a>
    <h1>Standardizing BPF</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Please consider subscribing to LWN</b><p>Subscriptions are the lifeblood of LWN.net.  If you appreciate this
       content and would like to see more of it, your subscription will
       help to ensure that LWN continues to thrive.  Please visit
       <a href="https://lwn.net/subscribe/">this page</a> to join up and keep LWN on
       the net.</p></div>
           </center>
           
<p>
The <a href="https://lwn.net/Articles/599755/">extended BPF (eBPF)</a> virtual machine
allows programs to be loaded into and executed with the kernel — and,
increasingly, other environments.  As the use of BPF grows, so does
interest in defining what the BPF virtual machine actually is.  In an
effort to ensure a consistent and fair environment for defining what
constitutes the official BPF language and run-time environment, and to
encourage NVMe vendors to support BPF offloading, a recent <a href="https://lwn.net/ml/bpf/DM4PR21MB3440837AE8F54F8E6EA5D475A3119@DM4PR21MB3440.namprd21.prod.outlook.com/">effort</a>
has been undertaken to standardize BPF.
</p><p>
BPF programs are written in
C, and compiled into <a href="https://docs.kernel.org/bpf/instruction-set.html">BPF
bytecode</a>. Like other bytecode instruction sets, BPF programs are
platform-independent and just-in-time (JIT) compiled. For a long time,
&#34;platform-independent&#34; for BPF simply meant the ability to run BPF programs
on multiple different architectures on Linux. That definition has expanded
in recent years, with Microsoft implementing <a href="https://lwn.net/Articles/857215/">a
version of BPF for Windows</a>, and network-interface vendors, such as <a href="https://www.netronome.com/products/agilio-software/agilio-ebpf-software/">Netronome</a>,
providing the ability to <a href="http://vger.kernel.org/lpc-bpf2018.html#session-8">offload</a> BPF
networking programs. NVMe vendors are also <a href="https://www.snia.org/educational-library/nvme-computational-storage-update-standard-2022">looking
into</a> supporting offloading functionality to BPF for storage devices
with a new framework called <a href="https://www.usenix.org/conference/osdi22/presentation/zhong">eXpress
Resubmission Path (XRP)</a>, though this effort is currently stalled due to
BPF not being standardized. 
</p><h4>What&#39;s in scope for standardization?</h4>

<p>
BPF is not simply an instruction set, but rather a combination of an
instruction set and a run-time environment.
The latter must, at a minimum, include the necessary logic to execute the
BPF program; either through an interpreter, or by JIT-compiling the
program directly into native instructions. Additionally, it may
include features such as static verification of
the program, performing type checking using information provided via <a href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BTF</a>,
built-in data structures, and more. While the BPF instruction set
architecture (ISA) is in scope for standardization, it&#39;s
less clear which other aspects of BPF are appropriate.

</p><p>This question was posed by Christoph Hellwig in his
<a href="https://www.youtube.com/watch?v=9NmDqjfMKfo">2022 LSFMM/BPF
presentation</a>. While all of the participants in the discussion agreed
that standardizing the ISA is the highest priority, there was also discussion
about whether to standardize certain run-time semantics such as what happens
when a program divides by zero. In the discussion, Alexei Starovoitov
explained that, initially, BPF would simply exit the program if a divide by
zero was encountered. After realizing that abruptly exiting a program can
be dangerous (it may, for example, have needed to clean up some state), the
semantics were changed to instead simply return zero and produce no
exception; matching the behavior of aarch64.

</p><p>The discussion concluded with a general agreement that the first order
of business was to fully document and decide on a versioning system for
the ISA.

</p><p>
In a <a href="https://lwn.net/ml/bpf/20220510081657.GA12910@lst.de/">follow-up</a> email,
Hellwig suggested that the ISA should be versioned according to Clang CPU
levels — the &#34;processor version&#34; used by Clang when compiling BPF
programs. Starovoitov pointed out in <a href="https://lwn.net/ml/bpf/CAADnVQKBbh6T0-cs0WB2bsapg0wbb9Zu1az==CHD19sxeD5o_g@mail.gmail.com/">response</a>
that multiple instructions have, in the past, been added to the BPF ISA
without a bump in the Clang CPU level, so the CPU levels weren&#39;t a clean
match with the BPF ISA versions. Starovoitov suggested a number of other
approaches, such as versioning with an upstream kernel commit hash, or
simply declaring the current ISA as 1.0 and bumping it for every new
instruction. Hellwig <a href="https://lwn.net/ml/bpf/20220517091011.GA18723@lst.de/">was
unenthusiastic</a> about the idea of using kernel commit hashes, but was
amenable to the idea of considering the current ISA as version 1.0.

</p><p>
Following these discussions, the BPF ISA documentation has been improved
significantly, with all of the current instructions being fully
documented. The documentation page lists the instruction set as v1.0, so it
would seem that Starovoitov&#39;s idea of treating the current ISA as v1.0 was
chosen as the way forward.

</p><p>
Yet, while the current ISA is fully documented, there are still new
instructions being added that will presumably be included in the official
v1.0 BPF ISA. Yonghong Song <a href="https://lwn.net/ml/bpf/01515302-c37d-2ee5-c950-2f556a4caad0@meta.com/">proposed</a>
a set of six such instructions to be included in the new <tt>-mcpu=v4</tt>
Clang CPU level. These will surely not be the last instructions added to the
ISA, but for now they appear to be the last instructions that will be
added to v1.0.


</p><h4>Choosing a standards organization</h4>

<p>In addition to finalizing the ISA and deciding what else is in scope for
standardization, there is another important question to resolve before
standardization can begin in earnest: with which organization will the
standard be ratified?

</p><p>
The natural choice is the <a href="https://ebpf.foundation/">eBPF
Foundation</a>, which was <a href="https://www.linuxfoundation.org/press/press-release/facebook-google-isovalent-microsoft-and-netflix-launch-ebpf-foundation-as-part-of-the-linux-foundation">founded</a>
as a subsidiary of the Linux Foundation in December 2021; the foundation is
responsible for managing both the finances and the technical direction of
the BPF project. For technical matters, the foundation has a <a href="https://ebpf.foundation/bsc/">steering committee</a> composed of
engineers from various companies throughout the tech industry. Were BPF to
be standardized through the eBPF Foundation, the steering committee would
presumably be the responsible party.

</p><p>Standardizing through the eBPF Foundation would likely be the most
straightforward option, incurring the smallest amount of latency in
achieving consensus. It does, however, have a major drawback: the eBPF
Foundation has never published a standard. This, on its own, isn&#39;t
necessarily a hard blocker for publishing (every organization had to
publish their first standard at some point), but it does mean that the
eBPF Foundation would have to go through the standardization process
without the benefit of prior experience. In this regard, while the
bureaucracy of a more recognized organization could be considered a pain
point, it could also be considered a feature if that organization&#39;s
processes and experience help to ensure that the standard is well
considered and of the highest quality. On the other hand, some members
of the steering committee, such as Dave Thaler, have experience from
working with other standards organizations such as the Internet
Engineering Task Force (IETF).

</p><p>One alternative to publishing with the eBPF Foundation is
publishing directly through <a href="https://www.iso.org/home.html">ISO</a>, an international standards
organization that is home to the C programming language standard, among
others, that we all know and love. Standardizing with ISO would likely
guarantee the strongest possible worldwide consensus, as it is an
international standards body with a rigorous and widely reviewed
ratification process. For that reason, it is also likely to be the most
difficult and time-consuming option. While I am by no means an expert in
the domain of standardizing with ISO, it appears that, in order to even
consider standardizing BPF with the ISO, the standard would first have to
be brought before the <a href="https://ansi.org/">American National
Standards Institute (ANSI)</a>, (the ISO member representing the US), which
would then propose the idea to the larger international ISO
community. Ratifying the BPF standard with the ISO may be a desirable
long-term goal, but seems unlikely to be the approach taken for the initial
standardization effort.

</p><h4>IETF discussions</h4>
<p>
Yet another alternative is standardizing with the IETF, which is best known
for creating the standards that comprise the &#34;Internet Protocol Suite&#34;,
more commonly known as TCP/IP, though it also publishes standards for
non-networking topics such as <a href="https://www.rfc-editor.org/info/rfc9116">file formats</a>. The IETF
is also an international standards body, though its process for
standardization is less onerous than the ISO. As such, it may represent an
ideal middle ground between the eBPF Foundation and the ISO.

</p><p>
Discussions have been ongoing between members of the BPF and IETF
communities, including on <a href="https://mailarchive.ietf.org/arch/browse/bpf/">an IETF mailing
list</a>, following a BPF standardization meeting at the IETF 115
conference in 2022 as to whether IETF is an appropriate venue for BPF
standardization.  The topic was recently <a href="https://www.youtube.com/watch?v=CSGQmAloqho">revisited</a> at IETF
116 in 2023.  Despite there being some vocal opponents among the attendees,
the overall consensus in favor of standardizing BPF was apparently quite
strong relative to the norm for IETF.  Jari Arkko, an IETF Area Director
(AD), posted <a href="https://mailarchive.ietf.org/arch/msg/bpf/JTUytbt_kEscF0oC_P8LvRREFo0/">this
summary</a> on the IETF BPF mailing list:

</p><blockquote>
<p>The chairs asked if the room felt the problem was well defined and
scoped. The meeting was almost unanimous that it was. Same for
recommending to start the work. The community seems to want the work to
go ahead by a larger level of consensus than we&#39;re normally used to in
IETF BOFs.

</p></blockquote>
<p>Yet, while IETF as an organization seems enthusiastic to move forward
(pending some legal matters as discussed below), Arkko also pointed out
that more work needs to be done in terms of formally defining what is in
scope for standardization:

</p><blockquote>
	I do have one concern however. I think the meeting discussed the
	issues only in the abstract, and spent almost no time discussing
	the actual list of work items. There&#39;s a draft list of work items
	in the charter (<a href="https://datatracker.ietf.org/doc/charter-ietf-bpf/">https://datatracker.ietf.org/doc/charter-ietf-bpf/</a>),
	and the room hums seemed to say that the charter is
	acceptable. However, to what extent has this been discussed on list
	or somewhere else? I personally thought some items were quite
	clearly feasible while I wasn&#39;t so sure of others.
</blockquote>
<p>Arkko certainly has a point. As discussed above, the scope of
standardization for BPF could be broad. If BPF proceeds with
the IETF, achieving consensus on what will be in scope for the first
publication of the standard will certainly be one of the major work items.

</p><p>Now that some sort of consensus has been achieved in the IETF community, it seems
likely that BPF standardization will proceed through the IETF. Before work
can formally begin in earnest, however, there are still a few legal matters
to finalize. The co-chairs of the IETF 116 BPF BoF meeting, Suresh Krishnan
and Lorenzo Colitti, mentioned that the IETF legal counsel was still doing
due diligence on some questions related to licensing and copyright. Though
these legal matters are expected to be resolved without issue, final
approval has yet to be given. Assuming there are no legal hiccups, the next
step would be to formally create an IETF working group, which would likely
be co-chaired by Krishnan and myself.





</p><p>
Worth noting as well is that BPF is not the first major subsystem in the
kernel that is undergoing a standardization effort.  <a href="https://lwn.net/Articles/580186/">Virtio</a> was first standardized through the
Organization for the Advancement of Structured Information Standards
(OASIS) back in March 2016, and there are lessons to be learned from that
effort. For instance, Rusty Russell, who led this effort, also made it a
point to shop around for different standards organizations. According to
the LWN article linked above, he was warned that, &#34;<q>some standards groups
exist primarily to slow things down</q>&#34;, which did not suit his goals of
finding an organization that was &#34;<q>interested in the creation of useful
standards without a lot of unnecessary hoops to jump through.</q>&#34;  The BPF
community will have similar goals of its own and, so far, it seems that it
is following virtio&#39;s example of putting in the legwork to find an
organization whose processes match the project&#39;s needs.

</p><p>
It will be interesting to see where the standardization effort goes from
here. Some interested parties, such as the aforementioned NVMe vendors,
seem to be deferring substantial investment until BPF is fully
standardized. There is thus a significant incentive for the effort to
proceed. In the meantime, we can at least enjoy the steady stream of
high-quality BPF documentation inspired by this standardization effort.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#BPF">BPF</a></td></tr>
            <tr><td><a href="https://lwn.net/Archives/GuestIndex/">GuestArticles</a></td><td><a href="https://lwn.net/Archives/GuestIndex/#Vernet_David">Vernet, David</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
