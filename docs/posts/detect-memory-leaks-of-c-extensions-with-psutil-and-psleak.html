<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gmpy.dev/blog/2025/psutil-heap-introspection-apis">Original</a>
    <h1>Detect memory leaks of C extensions with psutil and psleak</h1>
    
    <div id="readability-page-1" class="page"><section id="content">
  <article>
    <header>
      
    </header>

    <div>
<!-- /.post-info -->      <p>Memory leaks in Python are often straightforward to diagnose. Just look at RSS,
track Python object counts, follow reference graphs. But leaks inside <strong>C
extension modules</strong> are another story. Traditional memory metrics such as RSS
and VMS frequently fail to reveal them because Python&#39;s memory allocator sits
above the platform&#39;s native heap (see
<a href="https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator">pymalloc</a>).
If something in an extension calls <code>malloc()</code> without a corresponding
<code>free()</code>, that memory often won&#39;t show up where you expect it. You have a
leak, and <strong>you don&#39;t know</strong>.</p>
<p>psutil 7.2.0 introduces two new APIs for <strong>C heap introspection</strong>, designed
specifically to catch these kinds of native leaks. They give you a window
directly into the underlying platform allocator (e.g. glibc&#39;s malloc), letting
you track how much memory the C layer is actually consuming.</p>
<p>These C functions bypass Python entirely. They don&#39;t reflect Python object
memory, arenas, pools, or anything managed by
<a href="https://docs.python.org/3/c-api/memory.html">pymalloc</a>. Instead, they examine
the allocator that C extensions actually use. If your RSS is flat but your C
heap usage climbs, you now have a way to see it.</p>
<h2>Why native heap introspection matters</h2>
<p>Many Python projects rely on C extensions: psutil, NumPy, pandas, PIL, lxml,
psycopg, PyTorch, custom in-house modules, etc. And even cPython itself, which
implements many of its standard library modules in C. If any of these
components mishandle memory at the C level, you get a leak that:</p>
<ul>
<li>Doesn&#39;t show up in Python reference counts (<a href="https://docs.python.org/dev/library/sys.html#sys.getrefcount">sys.getrefcount</a>).</li>
<li>Doesn&#39;t show up in <a href="https://docs.python.org/3/library/tracemalloc.html">tracemalloc module</a>.</li>
<li>Doesn&#39;t show up in Python&#39;s <a href="https://docs.python.org/dev/library/gc.html">gc</a> stats.</li>
<li>Often don&#39;t show up in RSS, VMS or
  <a href="https://gmpy.dev/blog/2016/real-process-memory-and-environ-in-python">USS</a>
  due to allocator caching, especially for small objects. This can happen, for
  example, when you forget to <code>Py_DECREF</code> a Python object.</li>
</ul>
<p>psutil&#39;s new functions solve this by inspecting platform-native allocator
state, in a manner similar to Valgrind.</p>
<h2>heap_info(): direct allocator statistics</h2>
<p><code>heap_info()</code> exposes the following metrics:</p>
<ul>
<li><code>heap_used</code>: total number of bytes currently allocated via <code>malloc()</code>
  (small allocations).</li>
<li><code>mmap_used</code>: total number of bytes currently allocated via <code>mmap()</code> or
  via large <code>malloc()</code> allocations.</li>
<li><code>heap_count</code>: (Windows only) number of private heaps created via
  <code>HeapCreate()</code>.</li>
</ul>
<p>Example:</p>
<div><pre><span></span><code><span>&gt;&gt;&gt;</span> <span>import</span> <span>psutil</span>
<span>&gt;&gt;&gt;</span> <span>psutil</span><span>.</span><span>heap_info</span><span>()</span>
<span>pheap</span><span>(</span><span>heap_used</span><span>=</span><span>5177792</span><span>,</span> <span>mmap_used</span><span>=</span><span>819200</span><span>)</span>
</code></pre></div>

<p>Reference for what contributes to each field:</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Allocation type</th>
<th>Field affected</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNIX / Windows</td>
<td>small <code>malloc()</code> â‰¤128 KB without <code>free()</code></td>
<td><code>heap_used</code></td>
</tr>
<tr>
<td>UNIX / Windows</td>
<td>large <code>malloc()</code> &gt;128 KB without <code>free()</code>, or <code>mmap()</code> without <code>munmap()</code> (UNIX)</td>
<td><code>mmap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>HeapAlloc()</code> without <code>HeapFree()</code></td>
<td><code>heap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>VirtualAlloc()</code> without <code>VirtualFree()</code></td>
<td><code>mmap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>HeapCreate()</code> without <code>HeapDestroy()</code></td>
<td><code>heap_count</code></td>
</tr>
</tbody>
</table>
<h2>heap_trim(): returning unused heap memory</h2>
<p><code>heap_trim()</code> provides a cross-platform way to request that the underlying
allocator free any unused memory it&#39;s holding in the heap (typically small
<code>malloc()</code> allocations).</p>
<p>In practice, modern allocators rarely comply, so this is not a general-purpose
memory-reduction tool and won&#39;t meaningfully shrink RSS in real programs. Its
primary value is in <strong>leak detection tools</strong>.</p>
<p>Calling <code>heap_trim()</code> before taking measurements helps reduce allocator
noise, giving you a cleaner baseline so that changes in <code>heap_used</code> come from
the code you&#39;re testing, not from internal allocator caching or fragmentation.</p>
<h2>Real-world use: finding a C extension leak</h2>
<p>The workflow is simple:</p>
<ol>
<li>Take a baseline snapshot of the heap.</li>
<li>Call the C extension hundreds of times.</li>
<li>Take another snapshot.</li>
<li>Compare.</li>
</ol>
<div><pre><span></span><code><span>import</span> <span>psutil</span>

<span>psutil</span><span>.</span><span>heap_trim</span><span>()</span>  <span># reduce noise</span>

<span>before</span> <span>=</span> <span>psutil</span><span>.</span><span>heap_info</span><span>()</span>
<span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>200</span><span>):</span>
    <span>my_cext_function</span><span>()</span>
<span>after</span> <span>=</span> <span>psutil</span><span>.</span><span>heap_info</span><span>()</span>

<span>print</span><span>(</span><span>&#34;delta heap_used =&#34;</span><span>,</span> <span>after</span><span>.</span><span>heap_used</span> <span>-</span> <span>before</span><span>.</span><span>heap_used</span><span>)</span>
<span>print</span><span>(</span><span>&#34;delta mmap_used =&#34;</span><span>,</span> <span>after</span><span>.</span><span>mmap_used</span> <span>-</span> <span>before</span><span>.</span><span>mmap_used</span><span>)</span>
</code></pre></div>

<p>If <code>heap_used</code> or <code>mmap_used</code>  values increase consistently, you&#39;ve found a
native leak.</p>
<p>To reduce false positives, repeat the test multiple times, increasing the
number of calls on each retry. This approach helps distinguish real leaks from
random noise or transient allocations.</p>
<h2>A new tool: psleak</h2>
<p>The strategy described above is exactly what I implemented in a new PyPI
package, which I called <strong><a href="https://github.com/giampaolo/psleak">psleak</a></strong>. It
runs the target function repeatedly, trims the allocator before each run, and
tracks differences across retries. Memory that grows consistently after several
runs is flagged as a leak.</p>
<p>A minimal test suite looks like this:</p>
<div><pre><span></span><code>  <span>from</span> <span>psleak</span> <span>import</span> <span>MemoryLeakTestCase</span>

  <span>class</span> <span>TestLeaks</span><span>(</span><span>MemoryLeakTestCase</span><span>):</span>
      <span>def</span> <span>test_fun</span><span>(</span><span>self</span><span>):</span>
          <span>self</span><span>.</span><span>execute</span><span>(</span><span>some_c_function</span><span>)</span>
</code></pre></div>

<p>If the function leaks memory, the test will fail with a descriptive exception:</p>
<div><pre><span></span><code>psleak.MemoryLeakError: memory kept increasing after 10 runs
Run # 1: heap=+388160  | uss=+356352  | rss=+327680  | (calls= 200, avg/call=+1940)
Run # 2: heap=+584848  | uss=+614400  | rss=+491520  | (calls= 300, avg/call=+1949)
Run # 3: heap=+778320  | uss=+782336  | rss=+819200  | (calls= 400, avg/call=+1945)
Run # 4: heap=+970512  | uss=+1032192 | rss=+1146880 | (calls= 500, avg/call=+1941)
Run # 5: heap=+1169024 | uss=+1171456 | rss=+1146880 | (calls= 600, avg/call=+1948)
Run # 6: heap=+1357360 | uss=+1413120 | rss=+1310720 | (calls= 700, avg/call=+1939)
Run # 7: heap=+1552336 | uss=+1634304 | rss=+1638400 | (calls= 800, avg/call=+1940)
Run # 8: heap=+1752032 | uss=+1781760 | rss=+1802240 | (calls= 900, avg/call=+1946)
Run # 9: heap=+1945056 | uss=+2031616 | rss=+2129920 | (calls=1000, avg/call=+1945)
Run #10: heap=+2140624 | uss=+2179072 | rss=+2293760 | (calls=1100, avg/call=+1946)
</code></pre></div>

<p>Psleak is now part of the psutil test suite, to make sure that the C code does
not leak memory. All psutil APIs are tested (see
<a href="https://github.com/giampaolo/psutil/blob/1a946cfe738045cecf031222cd5078da21946af4/tests/test_memleaks.py">test_memleaks.py</a>),
making it a de facto <strong>regression-testing tool</strong>.</p>
<p>It&#39;s worth noting that without inspecting heap metrics, missing calls such as
<code>Py_CLEAR</code> and <code>Py_DECREF</code> often go unnoticed, because they don&#39;t affect RSS,
VMS, and USS. Something I confirmed from experimenting by commenting them
out. Monitoring the heap is therefore essential to reliably detect memory
leaks in Python C extensions.</p>
<h2>Under the hood</h2>
<p>For those interested in seeing how I did this in terms of code:</p>
<ul>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/linux/heap.c">Linux</a></strong>:
  uses glibc&#39;s
  <a href="https://man7.org/linux/man-pages/man3/mallinfo.3.html">mallinfo2()</a> to report
  <code>uordblks</code> (heap allocations) and <code>hblkhd</code> (mmap-backed blocks).</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/windows/heap.c">Windows</a></strong>:
  enumerates heaps and aggregates <code>HeapAlloc</code> / <code>VirtualAlloc</code> usage.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/osx/heap.c">macOS</a></strong>:
  uses malloc zone statistics.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/bsd/heap.c">BSD</a></strong>:
  uses jemalloc&#39;s arena and stats interfaces.</li>
</ul>
<h2>Summary</h2>
<p>psutil 7.2.0 fills a long-standing observability gap: native-level memory leaks
in C extensions are now visible directly from Python. You now have a simple
method to <strong>test C extensions for leaks</strong>. This turns psutil into not just a
monitoring library, but a practical debugging tool for Python projects that
rely on native C extension modules.</p>
<p>To make leak detection practical, I created
<a href="https://github.com/giampaolo/psleak">psleak</a>, a test-regression framework
designed to integrate into Python unit tests.</p>
<h2>References</h2>
<ul>
<li><strong><a href="https://github.com/giampaolo/psleak">psleak</a></strong>, the new memory leak
  testing framework.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/pull/2692/">psutil PR #2692</a></strong>, the
  implementation.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/issues/1275">psutil issue #1275</a></strong>,
  the original proposal from 8 years earlier.</li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="https://www.reddit.com/r/Python/comments/1puqgfg/detect_memory_leaks_of_c_extensions_with_psutil/">Reddit</a></li>
<li><a href="https://news.ycombinator.com/item?id=46376608">Hacker News</a></li>
</ul>
    </div><!-- /.entry-content -->
  </article>
</section></div>
  </body>
</html>
