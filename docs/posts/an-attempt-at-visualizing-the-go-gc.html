<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aadhav.me/posts/visualizing-the-go-gc">Original</a>
    <h1>An attempt at visualizing the Go GC</h1>
    
    <div id="readability-page-1" class="page"><article>
      <section>
        
        
        09 Oct, 2023
      </section>

      
      <h2>A rejected talk proposal for GopherCon India &#39;23.</h2>
      <p><b>Disclaimer</b>: I have limited experience with GCs and the Go runtime, so if there are any mistakes, please go easy on me! This post doesn&#39;t focus on understanding the Go GC; those who&#39;d like to do so should read the <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go;bpv=0;bpt=1">source code</a> once. I&#39;ll cover them in a future post if possible.
</p>

<p>In late 2022, I stumbled upon <a href="https://pusher.github.io/tricolor-gc-visualization/" rel="nofollow">this visualization</a> during my exploration around the Go GC (for learning the internals). A thought came to my mind, <em>“Wouldn’t it be pretty cool if someone could build a tool to visualize the live process of mark and sweep?”</em>, and I got more curious than ever.</p>

<p>This was more tempting than anything else I had ever worked on. <em>Why?</em> Because I always wanted to explore Go internals and what better way to explore than to hack around stuff and find out more?</p>

<p>I talked to a few people, explained about the experiment, and most of them wanted me to publish this post, irrespective of how much progress I made on the experiment, so, here I am.</p>

<p>(My original 2022 playground got nuked due to a boot failure after a Windows Update, and I eventually had to reset the entire system. (thank you Windows!) )</p>

<h2>What was I trying to build?</h2>

<p>As explained above, <a href="https://pusher.github.io/tricolor-gc-visualization/" rel="nofollow">Pusher’s GC visualizer</a> was the starting point of this experiment. Their visualizer was meant for educational purposes. <em>“What would it take to build a visualizer with real data?”</em> was the real question.</p>

<p>Okay, wait. But even before all of this, is it even required? Probably not. I don’t know if a standalone visualizer would help in actual production use cases. But in true hacker spirit, <strong>I had to do it</strong>.</p>

<p>The end goal for this exploration is to build a tool that:</p>

<ul>
<li>attempts to extract maximum information from the Go runtime and treats it as the source of truth</li>
<li>Use the extracted information to build relationships between individual runtime “objects”</li>
<li>Find a way to determine <em>object liveness</em> from the extracted info, or different sources</li>
<li>Construct an object graph with object liveness info to color “objects” to emulate the tri-color mark-sweep algorithm</li>
<li>Iterate over different object graphs and generate an animated overview of the GC process using real data</li>
</ul>

<p>Simply put, I wanted to build a tool which would show a <em>“live”</em> object graph with objects colored as black/grey/white, with the colors changing with respect to time.</p>

<p>To understand things further, I had to learn some GC theory. Let me give you a walkthrough about a few things in GC theory.</p>

<h2>Understanding some GC theory</h2>

<p>Okay, first things first. What is the heap?</p>

<p>In simple terms, a <strong>heap</strong> is either a continuous array of memory words or a non-contiguous collection of memory blocks, where each word is a sequence of bytes large enough to hold a pointer. Allocating objects on the heap is usually meant for objects whose size, quantity, or lifetime cannot be determined at compile-time. Think of it as a <em>“free store”</em> that can be managed manually or automatically. The heap is usually represented as an object graph, where the nodes are heap objects and the edges are references to the heap objects.</p>

<p>In manual memory management, if we incorrectly use explicit deallocation to reclaim memory, we may accidentally free memory that has references to it. These references are often called as <em>dangling pointers</em>. Following dangling pointers may result in unpredictable behavior.</p>

<p>This is where GC (garbage collection) comes into play and helps in preventing the creation of dangling pointers. The <strong>garbage collector</strong> attempts to reclaim memory that was allocated by the program, but is no longer referenced. The GC has the context of the global heap state, which helps in making reclamation decisions easier.</p>

<p>Remember, GC is not a silver bullet, and manual memory management can be performed correctly with care. <em>I do not want to start a war :)</em></p>

<p>Next are <strong>mutators</strong> and <strong>collectors</strong>, the two most commonly discussed <em>“actors”</em> in the context of garbage collection.</p>

<p>The <strong>mutator</strong> allocates new objects and “mutates” the (heap) object graph by changing references. A <strong>collector</strong> discovers unreachable objects (objects that cannot be reached by following any set of edges from the roots).</p>

<p>Bear with me, some more theory incoming:</p>

<p>An object is said to be <strong><em>live</em></strong> if it will be accessed sometime in the near future by the mutator. However, figuring out object liveness is a hard problem: <strong><em>liveness is non-deterministic</em></strong>; there is technically no possible way to determine if an object will be accessed by the mutator before time X.</p>

<p>A way to figure out if an object is live is to approximate it. Approximation can be done by <em>object reachability</em>. (check if an object X is reachable from an object Y by following references from Y -&gt; X)</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/obj-reachability.png" alt="Object reachability"/></p>

<p>The algorithm that Go’s garbage collector uses is the <strong>mark and sweep algorithm</strong>. The mark and sweep algorithm is a two-phase garbage collection method that first <strong>marks</strong> all live objects in memory and then <strong>sweeps</strong> through the memory to deallocate unreferenced objects. In <em>mark-and-sweep</em>, the collector operates in two phases:</p>

<ul>
<li><strong>Tracing (mark) phase</strong>: The collector traverses through the object graph by starting from the roots, and then marks each object it finds during its traversal.</li>
<li><strong>Sweeping phase</strong>: Finds unmarked objects, and determines them as garbage indirectly (<em>mark-and-sweep</em> doesn’t directly detect garbage, but assumes that unmarked objects are garbage.)</li>
</ul>

<p>Go’s GC uses the concept of <strong>tri-color abstraction</strong> to efficiently track and identify live objects for garbage collection without stopping program execution for significant periods of time. (this is achieved by marking objects during mutation)</p>

<p>Under the tri-color abstraction, the object graph is partitioned into three colors (black, white, and grey). Initially, every node is white and the root is grey (as it is the first node that is encountered).</p>

<p>When an object is encountered by the collector, it is marked as grey, and when the object is scanned and its descendants are identified it is marked as black. Gray objects are those that are potentially reachable and need further examination, while black objects are confirmed as live and in use. Objects that remain white after this process can be safely deallocated.</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/tri-color.gif" alt="Tri-color abstraction in mark-and-sweep algorithm"/></p>

<p>Mark-and-sweep also focuses on preserving an invariant to guarantee correctness: at the end of each iteration of the marking loop, there are no references from black to white objects. White objects must be only reachable from a grey object.</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/tricolor-strong.png" alt="Tri-color invariant"/></p>

<p>What would happen if the invariant is to be broken? Let’s consider a black object pointing to a white object after the mark phase. As the algorithm doesn’t process black objects further, the white object will be reclaimed by the collector during the sweep phase, leading to the presence of dangling pointers.</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/tricolor-invariant.gif" alt="Tri-color invariant"/></p>

<p>Phew! Hope I didn’t bore you out this wall of text, but this would help understand the content below in a better way.</p>

<h2>Exploring the runtime package and more</h2>

<p>Everything we’re looking at right now has some overlap with the runtime. I knew that Go provides a <code>runtime</code> package, but I wasn’t sure if it exported any information related to the Go GC.</p>

<p>After some exploration, the closest related thing that I could find in the <code>runtime</code> package was <code>runtime.MemStats</code>. But <code>MemStats</code> exports numerical data; my goal isn’t to build a live chart of memory statistics, a lot of great tools do it already. I needed more information, numerical data isn’t going to help in any way.</p>

<p>Thankfully during my search, I came across <a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html" rel="nofollow">Ardan Labs’ article</a> on GC semantics, where a section on GC traces piqued my interest. GC traces seemed promising as they could be toggled using a flag and had a low entry barrier. However, the trace itself doesn’t have sufficient information on actual objects and I don’t blame it; traces aren’t meant to capture that information anyway.</p>

<p>I had to look for other solutions.</p>

<h2>Forking Go</h2>

<p>Yep, you read it right. I was tempted, really tempted. Let me explain this journey of forking Go.</p>

<p>So, nothing from the official Go standard library had been of help so far.</p>

<p>If I were to get the most information, the only place to look into would be the actual Go source code. <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go;bpv=0;bpt=1" rel="nofollow">runtime/mgc.go</a> is the main GC algorithm, and is the expected place where I should be making tweaks to export data related to the mark-and-sweep process. (or maybe in <a href="https://cs.opensource.google/go/go/+/master:src/runtime/mgcmark.go;bpv=0;bpt=1" rel="nofollow">runtime/mgcmark.go</a>?)</p>

<p>But on further exploration and lots of code reading, I just couldn’t find a way to cleanly export this data. Every patch I tried to add resulted in more tweaks being made to different parts of the runtime. </p>

<p>The major challenge/disadvantage of using this approach was that I needed to maintain a forked version of Go. This also made the exploration more divergent than my intended goal - the idea was to make it run on the official Go releases, not forked versions.</p>

<p>Finally, I decided to stop making progress on this idea.</p>

<h2>Heap dumps</h2>

<p>At this point, I was lost. I did some more research and found a <a href="https://github.com/golang/go/issues/16410" rel="nofollow">Go proposal</a> which was interesting and close to my experiment’s goals.</p>

<p>After reading the title, I thought - <em>“wow. why didn’t I ever think of using heap dumps?”</em></p>

<p>Heap dumps are snapshots of the program’s memory at a specific point in time.</p>

<p>The proposal talks about the various ways to obtain a heap dump: by using <code>debug.WriteHeapDump</code>, using standard core dumps, etc.</p>

<p>Since I wanted to stick closer to the Go runtime, I decided to go ahead with the heap dumps generated by Go as the source for obtaining more information.</p>

<p>I went straight to the playground and generated a heap dump in a few seconds. But I still had to parse it, and <em>oh boy</em>, I didn’t know that a <strong>working</strong> heap dump parser for Go 1.18 (the version I was working on at that time (Oct 2022)) didn’t exist.</p>

<p><a href="https://github.com/randall77" rel="nofollow">Keith Randall</a>’s <a href="https://github.com/randall77/heapdump14" rel="nofollow">heapdump14</a> was the standard heap dump parser for Go, but it wasn’t maintained for newer versions. Keeping up with the runtime is a challenging task.</p>

<p>Keith also <a href="https://github.com/randall77/hprof/pull/6#pullrequestreview-111066791" rel="nofollow">mentioned</a> that the GC has been exporting less information related to types in the recent versions. (I need you to keep this in mind for the sections below)</p>

<p>I looked up more parsers, but each parser had a few bugs that prevented me from getting a complete overview of the heap dump. </p>

<h2>Understanding the heap dump format</h2>

<p>Now, I had to build a simple heap dump parser on my own. To start working on the implementation, I needed to understand the heap dump format.</p>

<p>The <a href="https://github.com/golang/go/wiki/heapdump15-through-heapdump17" rel="nofollow">Go wiki</a> nicely documents this. A Go heap dump is essentially a sequence of records, where each record starts with a 64-bit unsigned integer describing the type of the record.</p>

<p>There are 17 record types:</p>

<ul>
<li>0 = EOF</li>
<li>1 = object</li>
<li>2 = otherroot</li>
<li>3 = type</li>
<li>4 = goroutine</li>
<li>5 = stack frame</li>
<li>6 = dump params</li>
<li>7 = registered finalizer</li>
<li>8 = itab</li>
<li>9 = OS thread</li>
<li>10 = mem stats</li>
<li>11 = queued finalizer</li>
<li>12 = data segment</li>
<li>13 = bss segment</li>
<li>14 = defer record</li>
<li>15 = panic record</li>
<li>16 = alloc/free profile record</li>
<li>17 = alloc stack trace sample</li>
</ul>

<p>To know more about how Go writes these heap dumps, I’d recommend checking the <strong>bonus section</strong> at the end of this post.</p>

<h2>Parse, parse, parse</h2>

<p>After understanding the heap dump format, I started working on building the parser. The basic approach for parsing it was pretty simple: identify the record type using the 64-bit unsigned integer, use a reader for that record type, and return the read contents.</p>

<p>The actual implementation looks something like this:</p>
<pre tabindex="0"><code><span><span><span>// parse.go
</span></span></span><span><span><span></span>
</span></span><span><span><span>func</span> <span>ParseDump</span><span>(</span><span>rd</span> <span>*</span><span>bufio</span><span>.</span><span>Reader</span><span>)</span> <span>(</span><span>[</span><span>]</span><span>RecordData</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>err</span> <span>:=</span> <span>record</span><span>.</span><span>ReadHeader</span><span>(</span><span>rd</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>...</span><span>.</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>{</span>
</span></span><span><span>        <span>r</span><span>,</span> <span>err</span> <span>:=</span> <span>record</span><span>.</span><span>ReadRecord</span><span>(</span><span>rd</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        
</span></span><span><span>        <span>...</span><span>.</span>
</span></span></code></pre>
<p><code>ReadRecord</code> is the place where the type of record is identified and a suitable reader is initialized:</p>
<pre tabindex="0"><code><span><span><span>// record.go
</span></span></span><span><span><span></span>
</span></span><span><span><span>func</span> <span>ReadRecord</span><span>(</span><span>r</span> <span>*</span><span>bufio</span><span>.</span><span>Reader</span><span>)</span> <span>(</span><span>Record</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// Read record type
</span></span></span><span><span><span></span>    <span>recordType</span><span>,</span> <span>err</span> <span>:=</span> <span>binary</span><span>.</span><span>ReadUvarint</span><span>(</span><span>r</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>var</span> <span>record</span> <span>Record</span>
</span></span><span><span>
</span></span><span><span>    <span>switch</span> <span>RecordType</span><span>(</span><span>recordType</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>case</span> <span>EOF</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>EOFRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>Object</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>ObjectRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>OtherRoot</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>OtherRootRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>TypeDescriptor</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>TypeDescriptorRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>Goroutine</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>GoroutineRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>StackFrame</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>StackFrameRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>DumpParams</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>DumpParamsRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>RegisteredFinalizer</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>RegisteredFinalizerRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>ITab</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>ITabRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>OSThread</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>OSThreadRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>MemStats</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>MemStatsRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>QueuedFinalizer</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>QueuedFinalizerRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>DataSegment</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>DataSegmentRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>BSSSegment</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>BSSSegmentRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>DeferRecord</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>DeferRecordRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>PanicRecord</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>PanicRecordRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>AllocFreeProfile</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>AllocFreeProfileRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>case</span> <span>AllocStackTraceSample</span><span>:</span>
</span></span><span><span>        <span>record</span> <span>=</span> <span>&amp;</span><span>AllocStackTraceSampleRecord</span><span>{</span><span>}</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>nil</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;unexpected record type: %v&#34;</span><span>,</span> <span>recordType</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Read record. Each record implements the Record interface.
</span></span></span><span><span><span></span>    <span>err</span> <span>=</span> <span>record</span><span>.</span><span>Read</span><span>(</span><span>r</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>nil</span><span>,</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>record</span><span>,</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>For example, if the record type is <code>itab</code>, then the reader’s implementation will look like this:</p>
<pre tabindex="0"><code><span><span><span>// itab.go
</span></span></span><span><span><span></span>
</span></span><span><span><span>// uvarint: Itab address
</span></span></span><span><span><span></span><span>// uvarint: address of type descriptor for contained type
</span></span></span><span><span><span></span><span>type</span> <span>ITabRecord</span> <span>struct</span> <span>{</span>
</span></span><span><span>    <span>Address</span>            <span>uint64</span>
</span></span><span><span>    <span>TypeDescriptorAddr</span> <span>uint64</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>r</span> <span>*</span><span>ITabRecord</span><span>)</span> <span>GetAddress</span><span>(</span><span>)</span> <span>uint64</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>r</span><span>.</span><span>Address</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>r</span> <span>*</span><span>ITabRecord</span><span>)</span> <span>Read</span><span>(</span><span>rd</span> <span>*</span><span>bufio</span><span>.</span><span>Reader</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>    <span>var</span> <span>err</span> <span>error</span>
</span></span><span><span>
</span></span><span><span>    <span>r</span><span>.</span><span>Address</span><span>,</span> <span>err</span> <span>=</span> <span>binary</span><span>.</span><span>ReadUvarint</span><span>(</span><span>rd</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>r</span><span>.</span><span>TypeDescriptorAddr</span><span>,</span> <span>err</span> <span>=</span> <span>binary</span><span>.</span><span>ReadUvarint</span><span>(</span><span>rd</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>By using this approach, I can get a textual representation of the entire heap:</p>
<pre tabindex="0"><code><span><span>OS thread at address 0x54b300 (Go internal ID = 0, OS ID = 53413)
</span></span><span><span>Data segment at address 0x546660 (content size = 16784, pointers = 1184)
</span></span><span><span>BSS segment at address 0x54a800 (content size = 196376, pointers = 10185)
</span></span><span><span>Registered finalizer at address 0xc000078060, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
</span></span><span><span>Registered finalizer at address 0xc0000a8000, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
</span></span><span><span>Registered finalizer at address 0xc0000a8060, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
</span></span><span><span>Registered finalizer at address 0xc0000a80c0, FuncVal ptr address = 0x4b7078, type = 4832448, object type = 4832448
</span></span></code></pre>
<p>While I reached near completion on this parser, I got to know that a similar parser existed in the <a href="https://github.com/adamroach/heapspurs" rel="nofollow">heapspurs</a> tool, which I wasn’t aware of. (<em>Sigh. Why didn’t I come across it earlier?</em>)</p>

<p>heapspurs tries to do a lot more, but the core idea of parsing remains the same - identify record types using the 64-bit unsigned integer and read the contents based on the record type.</p>

<p>However, I wanted the result to be somewhat similar to <a href="https://github.com/eclipse/jifa" rel="nofollow">Eclipse Jifa</a>’s heap dump <a href="https://github.com/eclipse/jifa/blob/master/backend/heap-dump-analyzer/README.md#sample" rel="nofollow">view</a>. So, I separated the parsing logic into a <a href="https://github.com/burntcarrot/heaputil" rel="nofollow">different project (heaputil)</a> (in case anyone else wants to use it) and decided to build a <a href="https://github.com/burntcarrot/heapview" rel="nofollow">separate project (heapview)</a> for the visualizer.</p>

<figure>
<img src="https://raw.githubusercontent.com/wiki/eclipse/jifa/resources/jifa-sample.jpg" alt="Jifa&#39;s view"/>
<figcaption>Jifa&#39;s view</figcaption>
</figure>

<p>I built the records view using HTML templates:</p>
<pre tabindex="0"><code><span><span><span>&lt;!--</span><span> Records view </span><span>--&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;recordsView&#34;</span><span></span><span>&gt;</span>
</span></span><span><span>        {{range .Records}}
</span></span><span><span>            <span>&lt;</span><span>div</span> <span>class</span><span>=</span><span>&#34;row {{.RecordType}}&#34;</span><span></span><span>&gt;</span>
</span></span><span><span>                {{.Repr}}
</span></span><span><span>                {{if .HasPointers}}
</span></span><span><span>                    <span>&lt;</span><span>button</span> <span>onclick</span><span>=</span><span>&#34;toggleRow(&#39;{{.RowID}}&#39;)&#34;</span><span></span><span>&gt;</span>Toggle<span>&lt;</span><span>/</span><span>button</span><span>&gt;</span>
</span></span><span><span>                    <span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;{{.RowID}}&#34;</span> <span>class</span><span>=</span><span>&#34;pointer-info&#34;</span> <span>style</span><span>=</span><span>&#34;display: none;&#34;</span><span></span><span>&gt;</span>
</span></span><span><span>                        {{range .Pointers}}
</span></span><span><span>                            <span>&lt;</span><span>p</span><span></span><span>&gt;</span>Pointer({{.Index}}) at address 0x{{.Address}} (incoming = 0x{{.Incoming}}, outgoing = 0x{{.Outgoing}})<span>&lt;</span><span>/</span><span>p</span><span>&gt;</span>
</span></span><span><span>                        {{end}}
</span></span><span><span>                    <span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span><span><span>                {{end}}
</span></span><span><span>            <span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span><span><span>        {{end}}
</span></span><span><span>    <span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span></code></pre><pre tabindex="0"><code><span><span><span>...</span><span>.</span>
</span></span><span><span>
</span></span><span><span>    <span>data</span> <span>:=</span> <span>templateData</span><span>{</span>
</span></span><span><span>        <span>RecordTypes</span><span>:</span>     <span>GetUniqueRecordTypes</span><span>(</span><span>records</span><span>)</span><span>,</span>
</span></span><span><span>        <span>Records</span><span>:</span>         <span>records</span><span>,</span>
</span></span><span><span>        <span>GraphVizContent</span><span>:</span> <span>graphContent</span><span>,</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>var</span> <span>htmlBuilder</span> <span>strings</span><span>.</span><span>Builder</span>
</span></span><span><span>    <span>err</span> <span>=</span> <span>tmpl</span><span>.</span><span>Execute</span><span>(</span><span>&amp;</span><span>htmlBuilder</span><span>,</span> <span>data</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>&#34;&#34;</span><span>,</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span><span>...</span><span>.</span>
</span></span></code></pre>
<p>Which results in a fairly nice view of individual records:</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/heapview-records.png" alt="List view"/></p>

<h2>Building object graphs</h2>

<p>The main part of the visualization is the object graph. An object graph is essentially a visual or conceptual map that shows how different objects in the heap are connected to each other through references or pointers.</p>

<p>Even before building the object graph, I had to decide on what record types are going to be a part of it. A small heap dump can have a lot of records, and representing everything in the object graph is not going to work out. (<strong>Note</strong>: I’m not talking about other types like <em>Gs</em> and <em>Ms</em> , but other “objects” like data segments and BSS segments.)</p>

<p>For the initial implementation, I wanted to keep the scope small - so, the focus was only on objects. No data or BSS segments.</p>

<p>What would a barebones implementation for this look like? After some head-scratching, I decided to do some additional things while parsing each record:</p>

<ul>
<li>if the record isn’t of type <code>Object</code>, just ignore. (to keep the graph small)</li>
<li>create a node with a unique ID, where the label would have details (name, address, etc.)</li>
<li>the name and address is extracted from the record’s representation (<code>Repr</code>) (<em>yup, a tiny hack</em>)</li>
<li>create edges for outgoing pointers</li>
</ul>
<pre tabindex="0"><code><span><span>    <span>for</span> <span>{</span>
</span></span><span><span>        <span>r</span><span>,</span> <span>err</span> <span>:=</span> <span>record</span><span>.</span><span>ReadRecord</span><span>(</span><span>rd</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>return</span> <span>dotContent</span><span>.</span><span>String</span><span>(</span><span>)</span><span>,</span> <span>err</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>_</span><span>,</span> <span>isEOF</span> <span>:=</span> <span>r</span><span>.</span><span>(</span><span>*</span><span>record</span><span>.</span><span>EOFRecord</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>isEOF</span> <span>{</span>
</span></span><span><span>            <span>break</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>dp</span><span>,</span> <span>isDumpParams</span> <span>:=</span> <span>r</span><span>.</span><span>(</span><span>*</span><span>record</span><span>.</span><span>DumpParamsRecord</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>isDumpParams</span> <span>{</span>
</span></span><span><span>            <span>dumpParams</span> <span>=</span> <span>dp</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>// Filter out objects. If the record isn&#39;t of the type Object, ignore.
</span></span></span><span><span><span></span>        <span>_</span><span>,</span> <span>isObj</span> <span>:=</span> <span>r</span><span>.</span><span>(</span><span>*</span><span>record</span><span>.</span><span>ObjectRecord</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>!</span><span>isObj</span> <span>{</span>
</span></span><span><span>            <span>continue</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>// Create a DOT node for each record
</span></span></span><span><span><span></span>        <span>nodeName</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;Node%d&#34;</span><span>,</span> <span>counter</span><span>)</span>
</span></span><span><span>        <span>counter</span><span>++</span>
</span></span><span><span>        <span>name</span><span>,</span> <span>address</span> <span>:=</span> <span>ParseNameAndAddress</span><span>(</span><span>r</span><span>.</span><span>Repr</span><span>(</span><span>)</span><span>)</span>
</span></span><span><span>        <span>nodeLabel</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;[%s] %s&#34;</span><span>,</span> <span>name</span><span>,</span> <span>address</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>// Write DOT node entry within the &#34;heap&#34; cluster
</span></span></span><span><span><span></span>        <span>s</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;    %s [label=\&#34;%s\&#34;];\n&#34;</span><span>,</span> <span>nodeName</span><span>,</span> <span>nodeLabel</span><span>)</span>
</span></span><span><span>        <span>dotContent</span><span>.</span><span>WriteString</span><span>(</span><span>s</span><span>)</span>
</span></span><span><span>
</span></span><span><span>        <span>// Check if the record has pointers
</span></span></span><span><span><span></span>        <span>p</span><span>,</span> <span>isParent</span> <span>:=</span> <span>r</span><span>.</span><span>(</span><span>record</span><span>.</span><span>ParentGuard</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>isParent</span> <span>{</span>
</span></span><span><span>            <span>_</span><span>,</span> <span>outgoing</span> <span>:=</span> <span>record</span><span>.</span><span>ParsePointers</span><span>(</span><span>p</span><span>,</span> <span>dumpParams</span><span>)</span>
</span></span><span><span>            <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>len</span><span>(</span><span>outgoing</span><span>)</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>                <span>if</span> <span>outgoing</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>0</span> <span>{</span>
</span></span><span><span>                    <span>childNodeName</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;Pointer0x%x&#34;</span><span>,</span> <span>outgoing</span><span>[</span><span>i</span><span>]</span><span>)</span>
</span></span><span><span>
</span></span><span><span>                    <span>// Create an edge from the current record to the child record
</span></span></span><span><span><span></span>                    <span>s</span> <span>:=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;    %s -&gt; %s;\n&#34;</span><span>,</span> <span>nodeName</span><span>,</span> <span>childNodeName</span><span>)</span>
</span></span><span><span>                    <span>dotContent</span><span>.</span><span>WriteString</span><span>(</span><span>s</span><span>)</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span></code></pre>
<p>Now, to render this to a HTML view, I used <a href="https://viz-js.com/" rel="nofollow">viz.js</a> (<em>ignore the terrible JS code, I’m not good at it</em>):</p>
<pre tabindex="0"><code><span><span><span>&lt;!--</span><span> Graph view (initially hidden) </span><span>--&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;graphView&#34;</span> <span>style</span><span>=</span><span>&#34;display: none;&#34;</span><span></span><span>&gt;</span>
</span></span><span><span>        <span>&lt;</span><span>div</span> <span>id</span><span>=</span><span>&#34;graphContainer&#34;</span><span></span><span>&gt;</span>
</span></span><span><span>            <span>&lt;!--</span><span> The GraphViz graph will be rendered here using viz.js </span><span>--&gt;</span>
</span></span><span><span>        <span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span><span><span>    <span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span><span><span><span>&lt;</span><span>/</span><span>div</span><span>&gt;</span>
</span></span><span><span><span>&lt;!--</span><span> .... </span><span>--&gt;</span>
</span></span><span><span><span>&lt;</span><span>script</span> <span>src</span><span>=</span><span>&#34;https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js&#34;</span><span></span><span>&gt;</span><span>&lt;</span><span>/</span><span>script</span><span>&gt;</span>
</span></span><span><span><span>&lt;!--</span><span> .... </span><span>--&gt;</span>
</span></span><span><span><span>&lt;</span><span>script</span><span></span><span>&gt;</span>
</span></span><span><span>    <span>// ....
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// Function to render the GraphViz graph
</span></span></span><span><span><span></span>    <span>function</span> <span>renderGraph</span><span>(</span><span>graphVizContent</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>var</span> <span>graphContainer</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#34;graphContainer&#34;</span><span>)</span><span>;</span>
</span></span><span><span>        
</span></span><span><span>        <span>// Create a new Viz instance with the graph content and render it
</span></span></span><span><span><span></span>        <span>var</span> <span>viz</span> <span>=</span> <span>new</span> <span>Viz</span><span>(</span><span>)</span><span>;</span>
</span></span><span><span>        <span>viz</span><span>.</span><span>renderSVGElement</span><span>(</span><span>graphVizContent</span><span>)</span>
</span></span><span><span>            <span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>element</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>// Append the SVG element to the container
</span></span></span><span><span><span></span>                <span>graphContainer</span><span>.</span><span>innerHTML</span> <span>=</span> <span>&#34;&#34;</span><span>;</span>
</span></span><span><span>                <span>graphContainer</span><span>.</span><span>appendChild</span><span>(</span><span>element</span><span>)</span><span>;</span>
</span></span><span><span>            <span>}</span><span>)</span>
</span></span><span><span>            <span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>console</span><span>.</span><span>error</span><span>(</span><span>error</span><span>)</span><span>;</span>
</span></span><span><span>            <span>}</span><span>)</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>&lt;</span><span>/</span><span>script</span><span>&gt;</span>
</span></span></code></pre>
<p>This finally came into life like this:</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/heapview-graph.png" alt="HeapView graph"/></p>

<p>Source code is available <a href="https://github.com/burntcarrot/heapview" rel="nofollow">here</a>!</p>

<h2>Coloring nodes</h2>

<p>With the object graph in place, all that was required to bring this experiment to an almost completed stage was to figure out the core “algorithm” to color individual nodes with any of these three colors (black, grey, white) to emulate the tri-color mark-sweep algorithm.</p>

<p>A rough sketch looked like this:</p>

<ul>
<li>take two “snapshots” (heap dumps) at different times</li>
<li>compare the heap dumps and identify “dangling” objects

<ul>
<li>a “dangling” object could be assumed to have no references; which means it is waiting to get GC’d (garbage collected)</li>
<li>we can color these objects as <em>white</em>?</li>
</ul></li>
<li>objects with existing pointers can be colored <em>black</em>, and their descendants can be colored <em>grey</em>.</li>
</ul>

<p>This looked good enough, but I had to at least figure out the color coding “algorithm” on a single object graph; irrespective of temporal aspects. I could build on top on this foundational algorithm, and can add context in terms of time - seemed reasonable.</p>

<p>The foundational algorithm would be similar:</p>

<ul>
<li>take a heap dump</li>
<li>construct the object graph</li>
<li>identify objects with pointers and color them <em>black</em>, and their descendants <em>grey</em>.</li>
<li>color objects without references as <em>white</em></li>
</ul>

<p>This assumes that objects which are “standalone” (without any references) are garbage and are waiting to be collected by the GC. The descendants of the black object are immediately colored <em>grey</em> to preserve the invariant which I mentioned above. (black objects cannot point to white objects)</p>

<p>Writing code for this part was a bit harder than I thought. I went ahead with parsing the original graph using regular expressions to distinguish between nodes and edges. If a node is encountered, we color it grey, and if has children nodes, we color it black. Here’s the <em>hacky</em> code I wrote for achieving this:</p>
<pre tabindex="0"><code><span><span><span>// NodeColor represents the color of a node in the graph.
</span></span></span><span><span><span></span><span>type</span> <span>NodeColor</span> <span>int</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>(</span>
</span></span><span><span>    <span>White</span> <span>NodeColor</span> <span>=</span> <span>iota</span>
</span></span><span><span>    <span>Grey</span>
</span></span><span><span>    <span>Black</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ColorGraph</span><span>(</span><span>inputPath</span><span>,</span> <span>outputPath</span> <span>string</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>    <span>file</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>Open</span><span>(</span><span>inputPath</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>defer</span> <span>file</span><span>.</span><span>Close</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>nodeColors</span> <span>:=</span> <span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>NodeColor</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Parse the GraphViz file and determine node colors.
</span></span></span><span><span><span></span>    <span>err</span> <span>=</span> <span>determineNodeColors</span><span>(</span><span>file</span><span>,</span> <span>nodeColors</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Modify the graph to add node colors.
</span></span></span><span><span><span></span>    <span>err</span> <span>=</span> <span>applyColors</span><span>(</span><span>inputPath</span><span>,</span> <span>outputPath</span><span>,</span> <span>nodeColors</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>determineNodeColors</span><span>(</span><span>dotFile</span> <span>io</span><span>.</span><span>Reader</span><span>,</span> <span>nodeColors</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>NodeColor</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>    <span>scanner</span> <span>:=</span> <span>bufio</span><span>.</span><span>NewScanner</span><span>(</span><span>dotFile</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Regular expression pattern to match node lines.
</span></span></span><span><span><span></span>    <span>nodePattern</span> <span>:=</span> <span>regexp</span><span>.</span><span>MustCompile</span><span>(</span><span>`</span><span>^\s+(\w+)\s+\[.*\]</span><span>`</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Regular expression pattern to match edge lines.
</span></span></span><span><span><span></span>    <span>edgePattern</span> <span>:=</span> <span>regexp</span><span>.</span><span>MustCompile</span><span>(</span><span>`</span><span>^\s+(\w+)\s+-&gt;\s+(\w+)</span><span>`</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>scanner</span><span>.</span><span>Scan</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>line</span> <span>:=</span> <span>scanner</span><span>.</span><span>Text</span><span>(</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>matches</span> <span>:=</span> <span>nodePattern</span><span>.</span><span>FindStringSubmatch</span><span>(</span><span>line</span><span>)</span><span>;</span> <span>matches</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>// This is a node line.
</span></span></span><span><span><span></span>            <span>nodeName</span> <span>:=</span> <span>matches</span><span>[</span><span>1</span><span>]</span>
</span></span><span><span>
</span></span><span><span>            <span>// Processed object, color it as grey.
</span></span></span><span><span><span></span>            <span>nodeColors</span><span>[</span><span>nodeName</span><span>]</span> <span>=</span> <span>Grey</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>if</span> <span>matches</span> <span>:=</span> <span>edgePattern</span><span>.</span><span>FindStringSubmatch</span><span>(</span><span>line</span><span>)</span><span>;</span> <span>matches</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>// This is an edge line.
</span></span></span><span><span><span></span>            <span>sourceNode</span> <span>:=</span> <span>matches</span><span>[</span><span>1</span><span>]</span>
</span></span><span><span>
</span></span><span><span>            <span>// Mark the source node as black.
</span></span></span><span><span><span></span>            <span>nodeColors</span><span>[</span><span>sourceNode</span><span>]</span> <span>=</span> <span>Black</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>applyColors</span><span>(</span><span>inputPath</span><span>,</span> <span>outputPath</span> <span>string</span><span>,</span> <span>nodeColors</span> <span>map</span><span>[</span><span>string</span><span>]</span><span>NodeColor</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>    <span>content</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>inputPath</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Create a regular expression pattern to match node lines.
</span></span></span><span><span><span></span>    <span>nodePattern</span> <span>:=</span> <span>regexp</span><span>.</span><span>MustCompile</span><span>(</span><span>`</span><span>^\s+(\w+)\s+\[.*\]</span><span>`</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>lines</span> <span>:=</span> <span>strings</span><span>.</span><span>Split</span><span>(</span><span>string</span><span>(</span><span>content</span><span>)</span><span>,</span> <span>&#34;\n&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>var</span> <span>modifiedContent</span> <span>strings</span><span>.</span><span>Builder</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>line</span> <span>:=</span> <span>range</span> <span>lines</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>matches</span> <span>:=</span> <span>nodePattern</span><span>.</span><span>FindStringSubmatch</span><span>(</span><span>line</span><span>)</span><span>;</span> <span>matches</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>nodeName</span> <span>:=</span> <span>matches</span><span>[</span><span>1</span><span>]</span>
</span></span><span><span>            <span>color</span><span>,</span> <span>exists</span> <span>:=</span> <span>nodeColors</span><span>[</span><span>nodeName</span><span>]</span>
</span></span><span><span>            <span>if</span> <span>exists</span> <span>{</span>
</span></span><span><span>                <span>line</span> <span>=</span> <span>line</span><span>[</span><span>:</span><span>len</span><span>(</span><span>line</span><span>)</span><span>-</span><span>2</span><span>]</span>
</span></span><span><span>
</span></span><span><span>                <span>fontColor</span> <span>:=</span> <span>&#34;black&#34;</span>
</span></span><span><span>                <span>if</span> <span>color</span> <span>==</span> <span>Black</span> <span>{</span>
</span></span><span><span>                    <span>fontColor</span> <span>=</span> <span>&#34;white&#34;</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>
</span></span><span><span>                <span>// Modify the line to include the fillcolor and fontcolor attributes with the determined color.
</span></span></span><span><span><span></span>                <span>line</span> <span>=</span> <span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;%s fillcolor=%s, fontcolor=%s, style=filled];&#34;</span><span>,</span> <span>line</span><span>,</span> <span>getColorName</span><span>(</span><span>color</span><span>)</span><span>,</span> <span>fontColor</span><span>)</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>modifiedContent</span><span>.</span><span>WriteString</span><span>(</span><span>line</span><span>)</span>
</span></span><span><span>        <span>modifiedContent</span><span>.</span><span>WriteString</span><span>(</span><span>&#34;\n&#34;</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Write the modified GraphViz content to the output GraphViz file.
</span></span></span><span><span><span></span>    <span>err</span> <span>=</span> <span>os</span><span>.</span><span>WriteFile</span><span>(</span><span>outputPath</span><span>,</span> <span>[</span><span>]</span><span>byte</span><span>(</span><span>modifiedContent</span><span>.</span><span>String</span><span>(</span><span>)</span><span>)</span><span>,</span> <span>0644</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>err</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>This resulted in this object graph (trimmed for easier visualization):</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/tricolor-heap-colors.png" alt="Colored object graph (tri-color abstraction)"/></p>

<p><em>What a relief</em>. I finally had managed to figure out coloring individual nodes; and this brought me to closer to my end goal.</p>

<h2>What’s next?</h2>

<p>I’d like to continue working on it, but since I’ve been affected by layoffs, I’ll need to prioritize interview preparation for now.</p>

<p>I feel that more type information can be extracted from core dumps using <a href="https://cs.opensource.google/go/x/debug/+/master:cmd/viewcore/main.go" rel="nofollow">viewcore</a>. viewcore is a tool for exploring the state of a Go process that has dumped core. I had considered using viewcore, and even made a <a href="https://groups.google.com/g/golang-dev/c/deAqU2PKxVw/m/xnYOxTDoAgAJ" rel="nofollow">forum post</a> for understanding more about it:</p>

<p><img src="https://quantum5.ca/static/assets/go-gc/forum-post.png" alt="golang-dev forum post"/></p>

<p>But since I was focusing on extracting information from heap dumps written by <code>debug.WriteHeapDump</code>, I couldn’t get much time to explore standard core dumps. Using core dumps might be a better way do it, as with more type information, the construction of object graphs becomes easier; and you get more detailed information as opposed to plain objects with addresses.</p>

<p>The animation part is easy - either iterate over a set of GraphViz graphs and generate a GIF, or parse each graph, check if the object references have changed or not and generate even <em>smoother</em> animations.</p>

<p><strong>If you’d like to contribute or have better ideas, please create an issue</strong> on <a href="https://github.com/burntcarrot/gclive" rel="nofollow">this repository</a>. I’ll be happy to assist with any improvements!</p>

<p>I’ve open sourced the <strong>heap dump parser</strong> as <a href="https://github.com/burntcarrot/heaputil" rel="nofollow">heaputil</a>, and the <strong>heap dump visualizer</strong> as <a href="https://github.com/burntcarrot/heapview" rel="nofollow">heapview</a>.</p>

<h2>Are you hiring?</h2>

<p><strong>I’m looking for new roles</strong> in backend/systems/infrastructure engineering (open to general roles as well!); if you’re hiring, please reach out to me via <code>work &lt;at&gt; aadhav.me</code>, <a href="https://twitter.com/carrotburnt" rel="nofollow">Twitter DMs</a> or <a href="https://linkedin.com/in/aadhav-vignesh" rel="nofollow">LinkedIn</a>.</p>

<p>I have <em>~7 months</em> of full-time experience, and I primarily work with Go/Python (I tinker around with Rust/Elixir occasionally).</p>

<p><em>Location preference</em>: EU/APAC (remote), India (in-office). Also interested in globally distributed teams.</p>

<p>(sorry for the interruption, back to the bonus section!)</p>

<h2>BONUS: How does Go write heap dumps?</h2>

<p>I’ll try to explain how Go writes heap dumps. (I explored this while I was taking a look at the GC internals)</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=20;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=20;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>//go:linkname runtime_debug_WriteHeapDump runtime/debug.WriteHeapDump
</span></span></span><span><span><span></span><span>func</span> <span>runtime_debug_WriteHeapDump</span><span>(</span><span>fd</span> <span>uintptr</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>stopTheWorld</span><span>(</span><span>stwWriteHeapDump</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Keep m on this G&#39;s stack instead of the system stack.
</span></span></span><span><span><span></span>    <span>// Both readmemstats_m and writeheapdump_m have pretty large
</span></span></span><span><span><span></span>    <span>// peak stack depths and we risk blowing the system stack.
</span></span></span><span><span><span></span>    <span>// This is safe because the world is stopped, so we don&#39;t
</span></span></span><span><span><span></span>    <span>// need to worry about anyone shrinking and therefore moving
</span></span></span><span><span><span></span>    <span>// our stack.
</span></span></span><span><span><span></span>    <span>var</span> <span>m</span> <span>MemStats</span>
</span></span><span><span>    <span>systemstack</span><span>(</span><span>func</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>// Call readmemstats_m here instead of deeper in
</span></span></span><span><span><span></span>        <span>// writeheapdump_m because we might blow the system stack
</span></span></span><span><span><span></span>        <span>// otherwise.
</span></span></span><span><span><span></span>        <span>readmemstats_m</span><span>(</span><span>&amp;</span><span>m</span><span>)</span>
</span></span><span><span>        <span>writeheapdump_m</span><span>(</span><span>fd</span><span>,</span> <span>&amp;</span><span>m</span><span>)</span>
</span></span><span><span>    <span>}</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>startTheWorld</span><span>(</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>Notice the first line, the <code>go:linkname</code> directive is used to link the internal implementation to the externally-available <code>runtime/debug.WriteHeapDump</code> as the format for the <code>go:linkname</code> is <code>// go:linkname localname importpath.name</code>. More explanation:</p>

<blockquote>
<p>The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported “unsafe”.</p>
</blockquote>

<p><code>writeheapdump_m</code> has the logic for writing the heap dump:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=694;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=694;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>writeheapdump_m</span><span>(</span><span>fd</span> <span>uintptr</span><span>,</span> <span>m</span> <span>*</span><span>MemStats</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>gp</span> <span>:=</span> <span>getg</span><span>(</span><span>)</span>
</span></span><span><span>    <span>casGToWaiting</span><span>(</span><span>gp</span><span>.</span><span>m</span><span>.</span><span>curg</span><span>,</span> <span>_Grunning</span><span>,</span> <span>waitReasonDumpingHeap</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Set dump file.
</span></span></span><span><span><span></span>    <span>dumpfd</span> <span>=</span> <span>fd</span>
</span></span><span><span>
</span></span><span><span>    <span>// Call dump routine.
</span></span></span><span><span><span></span>    <span>mdump</span><span>(</span><span>m</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// Reset dump file.
</span></span></span><span><span><span></span>    <span>dumpfd</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>if</span> <span>tmpbuf</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>        <span>sysFree</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>tmpbuf</span><span>[</span><span>0</span><span>]</span><span>)</span><span>,</span> <span>uintptr</span><span>(</span><span>len</span><span>(</span><span>tmpbuf</span><span>)</span><span>)</span><span>,</span> <span>&amp;</span><span>memstats</span><span>.</span><span>other_sys</span><span>)</span>
</span></span><span><span>        <span>tmpbuf</span> <span>=</span> <span>nil</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>casgstatus</span><span>(</span><span>gp</span><span>.</span><span>m</span><span>.</span><span>curg</span><span>,</span> <span>_Gwaiting</span><span>,</span> <span>_Grunning</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>It calls the <code>assertWorldStopped</code> function to ensure that the Go scheduler (the “world”) is in a stopped state. This is typically done to prevent concurrent execution and ensure safety while performing certain operations.</p>

<p><code>getg</code> returns the pointer to the current <em>G</em>, and it sets its state to a waiting stage with a wait reason. The file descriptor is passed from the top level <code>debug.WriteHeapDump</code> is set to <code>dumpfd</code> (a global file descriptor). The main dump routine <code>mdump</code> is called, and G’s status is set to running.</p>

<p>Now, what does <code>mdump</code> do?</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=671" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=671</a>)</p>
<pre tabindex="0"><code><span><span><span>var</span> <span>dumphdr</span> <span>=</span> <span>[</span><span>]</span><span>byte</span><span>(</span><span>&#34;go1.7 heap dump\n&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>mdump</span><span>(</span><span>m</span> <span>*</span><span>MemStats</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// make sure we&#39;re done sweeping
</span></span></span><span><span><span></span>    <span>for</span> <span>_</span><span>,</span> <span>s</span> <span>:=</span> <span>range</span> <span>mheap_</span><span>.</span><span>allspans</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>s</span><span>.</span><span>state</span><span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>mSpanInUse</span> <span>{</span>
</span></span><span><span>            <span>s</span><span>.</span><span>ensureSwept</span><span>(</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>memclrNoHeapPointers</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>typecache</span><span>)</span><span>,</span> <span>unsafe</span><span>.</span><span>Sizeof</span><span>(</span><span>typecache</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dwrite</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>dumphdr</span><span>[</span><span>0</span><span>]</span><span>)</span><span>,</span> <span>uintptr</span><span>(</span><span>len</span><span>(</span><span>dumphdr</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpparams</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpitabs</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpobjs</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpgs</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpms</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumproots</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpmemstats</span><span>(</span><span>m</span><span>)</span>
</span></span><span><span>    <span>dumpmemprof</span><span>(</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagEOF</span><span>)</span>
</span></span><span><span>    <span>flush</span><span>(</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>At first, <code>mdump</code> checks if the heap’s spans (which are in use) are swept. Once ensured, it writes the header <code>go1.7 heap dump</code> and calls other functions for dumping information. Let’s look at <code>dumpparams</code> first:</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumpparams</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagParams</span><span>)</span>
</span></span><span><span>    <span>x</span> <span>:=</span> <span>uintptr</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>    <span>if</span> <span>*</span><span>(</span><span>*</span><span>byte</span><span>)</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>x</span><span>)</span><span>)</span> <span>==</span> <span>1</span> <span>{</span>
</span></span><span><span>        <span>dumpbool</span><span>(</span><span>false</span><span>)</span> <span>// little-endian ptrs
</span></span></span><span><span><span></span>    <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>        <span>dumpbool</span><span>(</span><span>true</span><span>)</span> <span>// big-endian ptrs
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>goarch</span><span>.</span><span>PtrSize</span><span>)</span>
</span></span><span><span>    <span>var</span> <span>arenaStart</span><span>,</span> <span>arenaEnd</span> <span>uintptr</span>
</span></span><span><span>    <span>for</span> <span>i1</span> <span>:=</span> <span>range</span> <span>mheap_</span><span>.</span><span>arenas</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>mheap_</span><span>.</span><span>arenas</span><span>[</span><span>i1</span><span>]</span> <span>==</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>continue</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>for</span> <span>i</span><span>,</span> <span>ha</span> <span>:=</span> <span>range</span> <span>mheap_</span><span>.</span><span>arenas</span><span>[</span><span>i1</span><span>]</span> <span>{</span>
</span></span><span><span>            <span>if</span> <span>ha</span> <span>==</span> <span>nil</span> <span>{</span>
</span></span><span><span>                <span>continue</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>            <span>base</span> <span>:=</span> <span>arenaBase</span><span>(</span><span>arenaIdx</span><span>(</span><span>i1</span><span>)</span><span>&lt;&lt;</span><span>arenaL1Shift</span> <span>|</span> <span>arenaIdx</span><span>(</span><span>i</span><span>)</span><span>)</span>
</span></span><span><span>            <span>if</span> <span>arenaStart</span> <span>==</span> <span>0</span> <span>||</span> <span>base</span> <span>&lt;</span> <span>arenaStart</span> <span>{</span>
</span></span><span><span>                <span>arenaStart</span> <span>=</span> <span>base</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>            <span>if</span> <span>base</span><span>+</span><span>heapArenaBytes</span> <span>&gt;</span> <span>arenaEnd</span> <span>{</span>
</span></span><span><span>                <span>arenaEnd</span> <span>=</span> <span>base</span> <span>+</span> <span>heapArenaBytes</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>arenaStart</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>arenaEnd</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpstr</span><span>(</span><span>goarch</span><span>.</span><span>GOARCH</span><span>)</span>
</span></span><span><span>    <span>dumpstr</span><span>(</span><span>buildVersion</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>ncpu</span><span>)</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>At first, an integer associated with the record type is dumped, and then the <a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow">endianness</a> of the pointers is calculated. The pointer size in bytes is dumped. The heap arena map is iterated, and the heap’s start and end addresses are calculated. (I don’t understand the logic behind the bitwise operations; if you do please let me know!)</p>

<p>Once the addresses are computed, they are dumped. Other info like the Go architecture, build version and the <code>ncpu</code> are also dumped.</p>

<p>Next up are <code>itab</code>s. But what are they? Let me explain:</p>

<p>Each interface type in Go is associated with an <code>itab</code>, a runtime data structure that stores information about the concrete type implementing the interface and pointers to its methods.</p>

<p>When a method is invoked on an interface value, the Go runtime utilizes the itab to identify the concrete type and dispatch the call to the appropriate method implementation, ensuring that the correct behavior is executed. Consider it as an equivalent to a phonebook for your interfaces. </p>

<p>A callback for dumping <code>itab</code>-related information is specified here:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=549;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=549;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>itab_callback</span><span>(</span><span>tab</span> <span>*</span><span>itab</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>t</span> <span>:=</span> <span>tab</span><span>.</span><span>_type</span>
</span></span><span><span>    <span>dumptype</span><span>(</span><span>t</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagItab</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>tab</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>t</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>dumpitabs</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>iterate_itabs</span><span>(</span><span>itab_callback</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>which is called by <code>iterate_itabs</code>, which gets the <code>itab</code> and iterates over it. On each iteration, the callback function is executed, which keeps dumping data. Data dumped for each <code>itab</code> record includes the ITab (<code>tab</code>) address and the address of type descriptor for contained type (<code>t</code>).</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/iface.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=481" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/iface.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=481</a>)</p>
<pre tabindex="0"><code><span><span><span>// iface.go
</span></span></span><span><span><span></span>
</span></span><span><span><span>func</span> <span>iterate_itabs</span><span>(</span><span>fn</span> <span>func</span><span>(</span><span>*</span><span>itab</span><span>)</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// Note: only runs during stop the world or with itabLock held,
</span></span></span><span><span><span></span>    <span>// so no other locks/atomics needed.
</span></span></span><span><span><span></span>    <span>t</span> <span>:=</span> <span>itabTable</span>
</span></span><span><span>    <span>for</span> <span>i</span> <span>:=</span> <span>uintptr</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>i</span> <span>&lt;</span> <span>t</span><span>.</span><span>size</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>        <span>m</span> <span>:=</span> <span>*</span><span>(</span><span>*</span><span>*</span><span>itab</span><span>)</span><span>(</span><span>add</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>t</span><span>.</span><span>entries</span><span>)</span><span>,</span> <span>i</span><span>*</span><span>goarch</span><span>.</span><span>PtrSize</span><span>)</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>m</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>fn</span><span>(</span><span>m</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p><code>dumpobjs</code> dumps information related to objects:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=476" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1;l=476</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumpobjs</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// To protect mheap_.allspans.
</span></span></span><span><span><span></span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>for</span> <span>_</span><span>,</span> <span>s</span> <span>:=</span> <span>range</span> <span>mheap_</span><span>.</span><span>allspans</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>s</span><span>.</span><span>state</span><span>.</span><span>get</span><span>(</span><span>)</span> <span>!=</span> <span>mSpanInUse</span> <span>{</span>
</span></span><span><span>            <span>continue</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>p</span> <span>:=</span> <span>s</span><span>.</span><span>base</span><span>(</span><span>)</span>
</span></span><span><span>        <span>size</span> <span>:=</span> <span>s</span><span>.</span><span>elemsize</span>
</span></span><span><span>        <span>n</span> <span>:=</span> <span>(</span><span>s</span><span>.</span><span>npages</span> <span>&lt;&lt;</span> <span>_PageShift</span><span>)</span> <span>/</span> <span>size</span>
</span></span><span><span>        <span>if</span> <span>n</span> <span>&gt;</span> <span>uintptr</span><span>(</span><span>len</span><span>(</span><span>freemark</span><span>)</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>throw</span><span>(</span><span>&#34;freemark array doesn&#39;t have enough entries&#34;</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>for</span> <span>freeIndex</span> <span>:=</span> <span>uintptr</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>freeIndex</span> <span>&lt;</span> <span>s</span><span>.</span><span>nelems</span><span>;</span> <span>freeIndex</span><span>++</span> <span>{</span>
</span></span><span><span>            <span>if</span> <span>s</span><span>.</span><span>isFree</span><span>(</span><span>freeIndex</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>freemark</span><span>[</span><span>freeIndex</span><span>]</span> <span>=</span> <span>true</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>for</span> <span>j</span> <span>:=</span> <span>uintptr</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>j</span> <span>&lt;</span> <span>n</span><span>;</span> <span>j</span><span>,</span> <span>p</span> <span>=</span> <span>j</span><span>+</span><span>1</span><span>,</span> <span>p</span><span>+</span><span>size</span> <span>{</span>
</span></span><span><span>            <span>if</span> <span>freemark</span><span>[</span><span>j</span><span>]</span> <span>{</span>
</span></span><span><span>                <span>freemark</span><span>[</span><span>j</span><span>]</span> <span>=</span> <span>false</span>
</span></span><span><span>                <span>continue</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>            <span>dumpobj</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>p</span><span>)</span><span>,</span> <span>size</span><span>,</span> <span>makeheapobjbv</span><span>(</span><span>p</span><span>,</span> <span>size</span><span>)</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>Go iterates over all spans, and does the following:</p>

<ul>
<li>It calculates the base address <code>p</code> of the span.</li>
<li>It determines the size of each element in the span (size) and the number of elements (n) that can fit in the span.</li>
<li>It checks if the number of elements <code>n</code> exceeds the length of the freemark array and throws an error if there are not enough entries in freemark.</li>
<li>It iterates over each element in the span, checking whether it is marked as free by inspecting the corresponding freemark entry. If an element is marked as free, it updates the freemark entry to true.
If an element is not marked as free, it calls the <code>dumpobj</code> function to dump information about that object.</li>
</ul>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=212;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=212;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumpobj</span><span>(</span><span>obj</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>,</span> <span>size</span> <span>uintptr</span><span>,</span> <span>bv</span> <span>bitvector</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagObject</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>obj</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpmemrange</span><span>(</span><span>obj</span><span>,</span> <span>size</span><span>)</span>
</span></span><span><span>    <span>dumpfields</span><span>(</span><span>bv</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p><code>dumpgs</code> dumps goroutine information:</p>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=407;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=407;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumpgs</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// goroutines &amp; stacks
</span></span></span><span><span><span></span>    <span>forEachG</span><span>(</span><span>func</span><span>(</span><span>gp</span> <span>*</span><span>g</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>status</span> <span>:=</span> <span>readgstatus</span><span>(</span><span>gp</span><span>)</span> <span>// The world is stopped so gp will not be in a scan state.
</span></span></span><span><span><span></span>        <span>switch</span> <span>status</span> <span>{</span>
</span></span><span><span>        <span>default</span><span>:</span>
</span></span><span><span>            <span>print</span><span>(</span><span>&#34;runtime: unexpected G.status &#34;</span><span>,</span> <span>hex</span><span>(</span><span>status</span><span>)</span><span>,</span> <span>&#34;\n&#34;</span><span>)</span>
</span></span><span><span>            <span>throw</span><span>(</span><span>&#34;dumpgs in STW - bad status&#34;</span><span>)</span>
</span></span><span><span>        <span>case</span> <span>_Gdead</span><span>:</span>
</span></span><span><span>            <span>// ok
</span></span></span><span><span><span></span>        <span>case</span> <span>_Grunnable</span><span>,</span>
</span></span><span><span>            <span>_Gsyscall</span><span>,</span>
</span></span><span><span>            <span>_Gwaiting</span><span>:</span>
</span></span><span><span>            <span>dumpgoroutine</span><span>(</span><span>gp</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>Here, it iterates over each <em>G</em>, gets its status, and calls <code>dumpgoroutine</code> when the <em>G</em> is in a runnable, <code>syscall</code> or a waiting state.</p>

<p>The <code>dumpgoroutine</code> function is pretty heavy, it does the following:</p>

<ul>
<li>dumps a lot of information about the goroutine (including the stack pointer, goroutine ID, etc.) </li>
<li>uses an unwinder to unwind/iterate the physical stack frames of a Go stack</li>
<li>use the unwinded stack frame, and dump its information </li>
<li>dump the panic and defer records held by the <em>G</em></li>
</ul>

<p>(<a href="https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=340;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1" rel="nofollow">https://cs.opensource.google/go/go/+/master:src/runtime/heapdump.go;l=340;drc=deb8e29000ebecbd788e0e86e239d52c26707457;bpv=0;bpt=1</a>)</p>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumpgoroutine</span><span>(</span><span>gp</span> <span>*</span><span>g</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>var</span> <span>sp</span><span>,</span> <span>pc</span><span>,</span> <span>lr</span> <span>uintptr</span>
</span></span><span><span>    <span>if</span> <span>gp</span><span>.</span><span>syscallsp</span> <span>!=</span> <span>0</span> <span>{</span>
</span></span><span><span>        <span>sp</span> <span>=</span> <span>gp</span><span>.</span><span>syscallsp</span>
</span></span><span><span>        <span>pc</span> <span>=</span> <span>gp</span><span>.</span><span>syscallpc</span>
</span></span><span><span>        <span>lr</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>        <span>sp</span> <span>=</span> <span>gp</span><span>.</span><span>sched</span><span>.</span><span>sp</span>
</span></span><span><span>        <span>pc</span> <span>=</span> <span>gp</span><span>.</span><span>sched</span><span>.</span><span>pc</span>
</span></span><span><span>        <span>lr</span> <span>=</span> <span>gp</span><span>.</span><span>sched</span><span>.</span><span>lr</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagGoroutine</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>sp</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>gp</span><span>.</span><span>goid</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>gp</span><span>.</span><span>gopc</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>readgstatus</span><span>(</span><span>gp</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpbool</span><span>(</span><span>isSystemGoroutine</span><span>(</span><span>gp</span><span>,</span> <span>false</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpbool</span><span>(</span><span>false</span><span>)</span> <span>// isbackground
</span></span></span><span><span><span></span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>gp</span><span>.</span><span>waitsince</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpstr</span><span>(</span><span>gp</span><span>.</span><span>waitreason</span><span>.</span><span>String</span><span>(</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>gp</span><span>.</span><span>sched</span><span>.</span><span>ctxt</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>.</span><span>m</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>.</span><span>_defer</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>.</span><span>_panic</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// dump stack
</span></span></span><span><span><span></span>    <span>var</span> <span>child</span> <span>childInfo</span>
</span></span><span><span>    <span>child</span><span>.</span><span>args</span><span>.</span><span>n</span> <span>=</span> <span>-</span><span>1</span>
</span></span><span><span>    <span>child</span><span>.</span><span>arglen</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>child</span><span>.</span><span>sp</span> <span>=</span> <span>nil</span>
</span></span><span><span>    <span>child</span><span>.</span><span>depth</span> <span>=</span> <span>0</span>
</span></span><span><span>    <span>var</span> <span>u</span> <span>unwinder</span>
</span></span><span><span>    <span>for</span> <span>u</span><span>.</span><span>initAt</span><span>(</span><span>pc</span><span>,</span> <span>sp</span><span>,</span> <span>lr</span><span>,</span> <span>gp</span><span>,</span> <span>0</span><span>)</span><span>;</span> <span>u</span><span>.</span><span>valid</span><span>(</span><span>)</span><span>;</span> <span>u</span><span>.</span><span>next</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>dumpframe</span><span>(</span><span>&amp;</span><span>u</span><span>.</span><span>frame</span><span>,</span> <span>&amp;</span><span>child</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// dump defer &amp; panic records
</span></span></span><span><span><span></span>    <span>for</span> <span>d</span> <span>:=</span> <span>gp</span><span>.</span><span>_defer</span><span>;</span> <span>d</span> <span>!=</span> <span>nil</span><span>;</span> <span>d</span> <span>=</span> <span>d</span><span>.</span><span>link</span> <span>{</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>tagDefer</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>d</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>d</span><span>.</span><span>sp</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>d</span><span>.</span><span>pc</span><span>)</span><span>)</span>
</span></span><span><span>        <span>fn</span> <span>:=</span> <span>*</span><span>(</span><span>*</span><span>*</span><span>funcval</span><span>)</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>&amp;</span><span>d</span><span>.</span><span>fn</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>d</span><span>.</span><span>fn</span> <span>==</span> <span>nil</span> <span>{</span>
</span></span><span><span>            <span>// d.fn can be nil for open-coded defers
</span></span></span><span><span><span></span>            <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>0</span><span>)</span><span>)</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>            <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>.</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>d</span><span>.</span><span>link</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>for</span> <span>p</span> <span>:=</span> <span>gp</span><span>.</span><span>_panic</span><span>;</span> <span>p</span> <span>!=</span> <span>nil</span><span>;</span> <span>p</span> <span>=</span> <span>p</span><span>.</span><span>link</span> <span>{</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>tagPanic</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>p</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>gp</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>eface</span> <span>:=</span> <span>efaceOf</span><span>(</span><span>&amp;</span><span>p</span><span>.</span><span>arg</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>eface</span><span>.</span><span>_type</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>eface</span><span>.</span><span>data</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>0</span><span>)</span> <span>// was p-&gt;defer, no longer recorded
</span></span></span><span><span><span></span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>p</span><span>.</span><span>link</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p><code>dumproots</code> does the following:</p>

<ul>
<li>dumps data and BSS segments through <code>dumpmemrange</code></li>
<li>checks the spans and iterates over <code>specials</code> (a linked list of special records sorted by offset held in the span)</li>
<li>dumps information related to the registered finalizers</li>
<li>and finally, the <code>finq_callback</code> is passed to <code>iterate_finq</code> which iterates over all queued finalizers and executes the callback to dump information</li>
</ul>
<pre tabindex="0"><code><span><span><span>func</span> <span>dumproots</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// To protect mheap_.allspans.
</span></span></span><span><span><span></span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// TODO(mwhudson): dump datamask etc from all objects
</span></span></span><span><span><span></span>    <span>// data segment
</span></span></span><span><span><span></span>    <span>dumpint</span><span>(</span><span>tagData</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>firstmoduledata</span><span>.</span><span>data</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpmemrange</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>firstmoduledata</span><span>.</span><span>data</span><span>)</span><span>,</span> <span>firstmoduledata</span><span>.</span><span>edata</span><span>-</span><span>firstmoduledata</span><span>.</span><span>data</span><span>)</span>
</span></span><span><span>    <span>dumpfields</span><span>(</span><span>firstmoduledata</span><span>.</span><span>gcdatamask</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// bss segment
</span></span></span><span><span><span></span>    <span>dumpint</span><span>(</span><span>tagBSS</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>firstmoduledata</span><span>.</span><span>bss</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpmemrange</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>firstmoduledata</span><span>.</span><span>bss</span><span>)</span><span>,</span> <span>firstmoduledata</span><span>.</span><span>ebss</span><span>-</span><span>firstmoduledata</span><span>.</span><span>bss</span><span>)</span>
</span></span><span><span>    <span>dumpfields</span><span>(</span><span>firstmoduledata</span><span>.</span><span>gcbssmask</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// mspan.types
</span></span></span><span><span><span></span>    <span>for</span> <span>_</span><span>,</span> <span>s</span> <span>:=</span> <span>range</span> <span>mheap_</span><span>.</span><span>allspans</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>s</span><span>.</span><span>state</span><span>.</span><span>get</span><span>(</span><span>)</span> <span>==</span> <span>mSpanInUse</span> <span>{</span>
</span></span><span><span>            <span>// Finalizers
</span></span></span><span><span><span></span>            <span>for</span> <span>sp</span> <span>:=</span> <span>s</span><span>.</span><span>specials</span><span>;</span> <span>sp</span> <span>!=</span> <span>nil</span><span>;</span> <span>sp</span> <span>=</span> <span>sp</span><span>.</span><span>next</span> <span>{</span>
</span></span><span><span>                <span>if</span> <span>sp</span><span>.</span><span>kind</span> <span>!=</span> <span>_KindSpecialFinalizer</span> <span>{</span>
</span></span><span><span>                    <span>continue</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>                <span>spf</span> <span>:=</span> <span>(</span><span>*</span><span>specialfinalizer</span><span>)</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>sp</span><span>)</span><span>)</span>
</span></span><span><span>                <span>p</span> <span>:=</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>s</span><span>.</span><span>base</span><span>(</span><span>)</span> <span>+</span> <span>uintptr</span><span>(</span><span>spf</span><span>.</span><span>special</span><span>.</span><span>offset</span><span>)</span><span>)</span>
</span></span><span><span>                <span>dumpfinalizer</span><span>(</span><span>p</span><span>,</span> <span>spf</span><span>.</span><span>fn</span><span>,</span> <span>spf</span><span>.</span><span>fint</span><span>,</span> <span>spf</span><span>.</span><span>ot</span><span>)</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// Finalizer queue
</span></span></span><span><span><span></span>    <span>iterate_finq</span><span>(</span><span>finq_callback</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>dumpfinalizer</span><span>(</span><span>obj</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>,</span> <span>fn</span> <span>*</span><span>funcval</span><span>,</span> <span>fint</span> <span>*</span><span>_type</span><span>,</span> <span>ot</span> <span>*</span><span>ptrtype</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagFinalizer</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>obj</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>.</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fint</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>ot</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>finq_callback</span><span>(</span><span>fn</span> <span>*</span><span>funcval</span><span>,</span> <span>obj</span> <span>unsafe</span><span>.</span><span>Pointer</span><span>,</span> <span>nret</span> <span>uintptr</span><span>,</span> <span>fint</span> <span>*</span><span>_type</span><span>,</span> <span>ot</span> <span>*</span><span>ptrtype</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>tagQueuedFinalizer</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>obj</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fn</span><span>.</span><span>fn</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>fint</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>ot</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>Dumping <i>M</i>s and mem stats is similar to what we have seen so far, so I won’t be explaining it.</p>
<pre tabindex="0"><code><span><span>
</span></span><span><span><span>func</span> <span>dumpms</span><span>(</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>for</span> <span>mp</span> <span>:=</span> <span>allm</span><span>;</span> <span>mp</span> <span>!=</span> <span>nil</span><span>;</span> <span>mp</span> <span>=</span> <span>mp</span><span>.</span><span>alllink</span> <span>{</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>tagOSThread</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>uintptr</span><span>(</span><span>unsafe</span><span>.</span><span>Pointer</span><span>(</span><span>mp</span><span>)</span><span>)</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>mp</span><span>.</span><span>id</span><span>)</span><span>)</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>mp</span><span>.</span><span>procid</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>//go:systemstack
</span></span></span><span><span><span></span><span>func</span> <span>dumpmemstats</span><span>(</span><span>m</span> <span>*</span><span>MemStats</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>assertWorldStopped</span><span>(</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>// These ints should be identical to the exported
</span></span></span><span><span><span></span>    <span>// MemStats structure and should be ordered the same
</span></span></span><span><span><span></span>    <span>// way too.
</span></span></span><span><span><span></span>    <span>dumpint</span><span>(</span><span>tagMemStats</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>Alloc</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>TotalAlloc</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>Sys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>Lookups</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>Mallocs</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>Frees</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapAlloc</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapIdle</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapInuse</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapReleased</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>HeapObjects</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>StackInuse</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>StackSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>MSpanInuse</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>MSpanSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>MCacheInuse</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>MCacheSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>BuckHashSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>GCSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>OtherSys</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>NextGC</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>LastGC</span><span>)</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>PauseTotalNs</span><span>)</span>
</span></span><span><span>    <span>for</span> <span>i</span> <span>:=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>256</span><span>;</span> <span>i</span><span>++</span> <span>{</span>
</span></span><span><span>        <span>dumpint</span><span>(</span><span>m</span><span>.</span><span>PauseNs</span><span>[</span><span>i</span><span>]</span><span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>dumpint</span><span>(</span><span>uint64</span><span>(</span><span>m</span><span>.</span><span>NumGC</span><span>)</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<h2>Conclusion</h2>

<p><strong>And that is it!</strong> I never knew that I’d be spending my time on this, but it has been a great experience!</p>

<p>Please let me know if you have any comments or want to know more about the experiment! You can reach out to me via <code>contact &lt;at&gt; aadhav.me</code>, <a href="https://twitter.com/carrotburnt" rel="nofollow">Twitter DMs</a> or <a href="https://linkedin.com/in/aadhav-vignesh" rel="nofollow">LinkedIn</a>.</p>



    </article></div>
  </body>
</html>
