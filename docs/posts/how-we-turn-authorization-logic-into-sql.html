<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.osohq.com/post/logic-into-sql">Original</a>
    
    <div id="readability-page-1" class="page"><div>
<p>Authorization questions can take many different forms in your application. The most obvious one, given <code>kitten</code> and <code>resource</code>, is to ask something like &#34;Can <code>kitten</code> access this <code>resource</code>?&#34; A slightly more sophisticated but still common case is to ask &#34;What are all the <code>resources</code> that <code>kitten</code> can access?&#34;</p>
<p>Letting users answer the second type of question is the goal of a project we call <em>data filtering.</em> Briefly, data filtering turns authorization logic from our declarative policy language, Polar, into SQL to enable efficient and secure data access. In this post I&#39;ll describe how we built data filtering for the first, second, and third times, and talk about the functionality we hope to make available to all of our users over the coming releases.</p>
<h2>Oso and Polar</h2>
<p>To understand exactly how we&#39;re approaching the problem, it helps to know a little bit about how Oso works under the hood. <a href="https://osohq.com">Oso</a> is a cross-platform authorization framework based a declarative policy language that we built, called <a href="https://docs.osohq.com/learn/polar-foundations.html">Polar</a>. More specifically, Polar is an interpreted logic programming language, and it runs inside a library loaded by your application. To make a specific authorization decision, the Polar interpreter evaluates your authorization policy (a Polar program) for a given ‚Äúsubject verb object‚Äù triple (we usually give them the names <code>actor</code>, <code>action</code>, and <code>resource</code>).</p>
<p>Polar is a logic programming language based on <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a>. Logic programming is an underutilized programming style where programs are expressed as logical formulas and executed by trying to verify them for a given set of values for their variables. A feature of logic programming that sets it apart from other styles is that in many cases, not every variable needs to have an associated value in order for a program that refers to it to continue executing.</p>
<p>This means that an expression like <code>kitten(Max)</code> has two possible interpretations: either we know who <code>Max</code> is, so we should be able to say whether or not they&#39;re <code>kitten</code>; or we don&#39;t, in which case we treat this as an assertion: <code>Max</code> <em>is</em>  <code>kitten</code> until proven otherwise.</p>
<h2>üêª‚Äç‚ùÑÔ∏è¬†vs üêç</h2>
<p>The same idea extends to rules with more arguments: as an example, let‚Äôs compare the Polar rule</p>
<pre><code>add(a, b, c) if a + b = c;
</code></pre>

<p>with the Python function</p>
<pre><code>def add(a, b):
    return a + b
</code></pre>

<p>The most obvious change between the two versions is their arity: the Python function takes two arguments while the Polar rule takes three. The second most obvious difference is the absence of anything like a <code>return</code> statement in the Polar rule. This would be the usual in an expression-oriented language like Ruby or Rust, where the <code>return</code> would be implicit, but Polar rules don‚Äôt return values at all; they only make assertions about their arguments. Nevertheless, both definitions can be used to find the sum of two numbers. The Python function returns the sum as a value, while the Polar rule assigns the sum to its third argument:</p>
<pre><code># Python
sum = add(2, 2)
# Polar
add(2, 2, sum)
</code></pre>

<p>But the power of logic programming makes the Polar rule more versatile. We can use it to obtain a representation of the difference between two numbers instead, by calling it like this:</p>
<pre><code>add(10, difference, 20)
</code></pre>

<p>In some languages, this would assign <code>10</code> to <code>difference</code>. In Polar, it instead assigns a placeholder value called a &#34;partial&#34; that we&#39;ll talk about in more detail below. But both representations, in theory, carry the same information.</p>
<p>To summarize, we might try to describe the difference between Polar and Python by saying that the Polar rule <em>defines a relationship between values</em> while the Python function <em>computes a value from values.</em></p>
<h2>What does this have to do with data filtering?</h2>
<p>The <code>add</code> example above isn‚Äôt super interesting, because we already know how to do subtraction. But the same principle works outside of just arithmetic. To see how it could apply in the context of authorization, consider this simple <code>allow</code> rule:</p>
<pre><code>allow(actor, ‚Äúedit‚Äù, resource) if actor = resource.owner;
</code></pre>

<p>The most basic application for this rule is to check whether a given <code>actor</code> can edit a specific <code>resource</code>. But if, as above, we were to call the rule <em>without</em> a known resource as its third argument, we might expect to receive back the set of possible values for <code>resource</code> that satisfy the rule. In other words, fully supporting the logic programming abstraction here would let one rule answer both of the questions we referred to in the intro: Can this actor edit this resource? And, what resources <em>can</em> this actor edit? Letting developers use their existing Oso policies to answer the second type of question is what we call &#34;data filtering.&#34;</p>
<h2>Partial success</h2>
<p>Before going into detail about how we‚Äôve been trying to make this possible, let‚Äôs take a look at what happens right now, if you try to call the <code>allow</code> rule given above in a Polar <a href="https://en.wikipedia.org/wiki/Read‚Äìeval‚Äìprint_loop">REPL</a> using the Python library. (Anyone following along at home is encouraged to use the Python REPL, as there&#39;s some disparity between host libraries when it comes to handling unbound variables.) </p>
<p>When you enter something like</p>
<pre><code>query&gt; actor = { name: ‚Äúgwen‚Äù } and 
       resource = { created_by: actor } and 
       allow(actor, ‚Äúedit‚Äù, resource)
</code></pre>

<p>the Polar shell simply displays the variable/value associations</p>
<pre><code>actor = { name: ‚Äògwen‚Äô }
resource = { created_by: { name: ‚Äògwen‚Äô } }
</code></pre>

<p>These are just the values we passed in. Neither one has been &#34;computed&#34; by the rule here: the rule has simply verified that all the required conditions hold over them. However if we leave <code>resource</code> undefined, the output becomes more complicated:</p>
<pre><code>query&gt; actor = { name: &#34;gwen&#34; } and
       allow(actor, &#34;edit&#34;, resource)

actor = {&#39;name&#39;: &#39;gwen&#39;}
resource = Expression(And, [Expression(Unify, [{&#39;name&#39;: &#39;gwen&#39;}, Expression(Dot, [Variable(&#39;_this&#39;), &#39;created_by&#39;])])])
</code></pre>

<p>The binding for <code>resource</code> above is no longer a concrete or ‚Äúground‚Äù value. Instead, the <code>Expression</code> type represents a predicate that must hold on <code>resource</code> for the rule to be satisfied. We call these provisional assignments ‚Äúpartials‚Äù, which as far as I know is a term we made up. But, it makes sense if you consider the variables they refer to as being ‚Äúpartially‚Äù bound to a value: whatever it is, whoever it was <code>created_by</code>, their <code>name</code> is <code>&#34;gwen&#34;</code>.</p>
<p>Partials are computed as a side effect of regular policy evaluation, so we already have something to start with. The next step is to transform the set of partials into the set of values they describe. SQL is a widely-used tool for describing data sets filtered by conditions, so &#34;targeting&#34; is useful for both practical and explanatory purposes: in the case above, our goal would be roughly to turn the condition expressed by the partial <code>_this.created_by = { name: &#34;gwen&#34; }</code> into a query such as <code>SELECT posts.* FROM posts WHERE posts.created_by_id = &lt;gwen&#39;s id&gt;</code>.</p>
<h2>v0: <code>authorized_session</code></h2>
<p>Our first attempt at this resulted in two Python integration libraries that we still maintain today. Oso‚Äôs Django and SQLAlchemy integrations turn partials from Polar into database queries, and use this capability to automatically apply authorization to every model we pull out of the database. This makes for a ‚Äúhands-free‚Äù experience where you can often avoid writing any explicit authorization logic <em>at all</em> in your application, not even calls to Oso API functions; everything is automatically handled by middleware.</p>
<p>Unfortunately, these libraries have some limitations. First and most obviously, they‚Äôre Python-specific, and framework-specific on top of that, which is <a href="https://www.osohq.com/post/cross-platform-rust-libraries">not our vibe</a> here at Oso. They‚Äôre also limited in what kinds of policies they can translate into queries, and tightly coupled to the details of how we represent partials, which makes them difficult to extend. The SQL they produce relies heavily on nested subqueries: for example, here&#39;s a selection from our tests:</p>
<pre><code>SELECT posts.id AS posts_id, posts.contents AS posts_contents, posts.title AS posts_title, posts.access_level AS
       posts_access_level, posts.created_by_id AS posts_created_by_id, posts.needs_moderation AS
       posts_needs_moderation
       FROM posts
       WHERE (EXISTS (SELECT 1
       FROM users
       WHERE users.id = posts.created_by_id AND (EXISTS (SELECT 1        FROM posts
       WHERE users.id = posts.created_by_id AND posts.id &gt; ? AND (EXISTS (SELECT 1
       FROM users
       WHERE users.id = posts.created_by_id AND (EXISTS (SELECT 1
       FROM posts
       WHERE users.id = posts.created_by_id AND posts.id &gt; ? AND (EXISTS (SELECT 1
       FROM users
       WHERE users.id = posts.created_by_id AND (EXISTS (SELECT 1
       FROM posts
       WHERE users.id = posts.created_by_id AND posts.id &gt; ?)))))))))))) AND (EXISTS (SELECT 1
       FROM users
       WHERE users.id = posts.created_by_id AND (EXISTS (SELECT 1
       FROM posts
       WHERE users.id = posts.created_by_id)))) AND posts.id &gt; ? AND posts.id =
</code></pre>

<p>Finally, while the <code>authorized_session</code> API they offer is very cool and has some compelling use cases, it‚Äôs not as general as we would like. Popular ORMs already offer abstractions around database queries that we‚Äôd like to plug into. Our ideal, general-purpose API would return a query with authorization already applied, that the user can then refine in whatever way they need to, for example by applying additional conditions, or paginating the results.</p>
<h2>v1: <code>authorized_query</code></h2>
<p>Our next attempt would be more ambitious. Oso v0.20.1 saw the initial release of our framework-agnostic data filtering API for the Python, Ruby and Node libraries. This time we&#39;d offer a more flexible, <a href="https://docs.osohq.com/reference/api/index.html#oso.Oso.authorized_query">slightly lower-level API</a> that returns an ORM query or a collection of objects to the user. We added a component to the Rust library that translates partial results into what we called a &#34;filter plan&#34;, a structure that captures information about dependencies between different data sources and describes a sequence of filters that, when composed, yield the desired query or set of objects. To use data filtering, the user would supply Oso with callbacks to operate on &#34;queries&#34;, in their application-specific form. In a Rails app, for example, this would be through <code>ActiveRecord::Relation</code> objects.</p>
<p>While this design works in many cases, it also has some drawbacks. For example, it makes no attempt to consolidate partial results into a single database query, instead making separate queries over each table. It also assembles some intermediate results in memory in order to generate subsequent queries. That means that although you can now call <code>authorized_query</code> and get a query object back, there&#39;s actually no guarantee Oso is accessing your data store in an efficient way. And not only would Oso issue intermediate queries in order to construct the final query, but the SQL it ended up generating wan&#39;t always ideal either. Take a look at the sequence of database queries issued to handle an API call in our <a href="https://github.com/osohq/gitclub">GitClub example application</a></p>
<p><img alt="Untitled" src="https://images.osohq.com/logic-into-sql/Data%20Filtering%20Blog%20Post%20692a6a339cb541e8b4caf9db690b9aec/Untitled.png"/></p>
<p>Finally, v1 was originally based on a prototype design that didn&#39;t quite capture some fairly common usage patterns. To support these cases, we had to cram a lot more information into our filter descriptions, which made data filtering significantly more complicated for users to configure.</p>
<h2>v2: don&#39;t know much about algebra</h2>
<p>Our next iteration tried to solve these problems by choosing a new representation for filters, one that we believed would be more able to express the full range of queries we&#39;d like to support. Fortunately, SQL is already based on a convenient formalism called <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a>, that can express complicated selections of data by composing a few general primitives. Although we aim to support more than just relational databases, we felt that this way of describing data sets was general enough to work for most of our users, and that we&#39;d be able to extend it fairly easily to work with non-relational data if the need arose.</p>
<p>So we went ahead with a proof-of-concept for the new filter design. The v1 approach required users to analyze a complicated data structure with non-obvious semantics in order to get a useful query out of data filtering. The new approach would essentially send back an abstract syntax syntax tree describing an idealized SQL query, which would turn itself into an ORM query object by recursively calling a user-defined method on each node. User configuration would now consist of providing definitions for these <code>to_query</code> methods for each relational primitive: <code>select</code>, <code>join</code>, etc.</p>
<p>This approach quickly proved its ability to render relatively complicated policies as a single database query:</p>
<p><img alt="Untitled" src="https://images.osohq.com/logic-into-sql/Data%20Filtering%20Blog%20Post%20692a6a339cb541e8b4caf9db690b9aec/Untitled%201.png"/></p>
<p>Nevertheless, we still had some misgivings. Expressing queries as an AST made them easy to work with programmatically, but hard to inspect and verify. It also became clear that we didn&#39;t really need the full power of the &#34;algebraic&#34; representation, and that a simpler, more regular format would have the same degree of expressiveness while also being easier for us to understand. Finally, the plan for how users would configure data filtering worked fine in Ruby, which we used to develop the new version, but would translate awkwardly into languages where concepts like &#34;subclass&#34; and &#34;method&#34; have no clear interpretation.</p>
<h2>v3: the present moment</h2>
<p>Rather than expressing a query as an arbitrarily nested algebraic expression, we decided to flatten the structure by using a <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">disjunctive normal form</a> representation, and to separate logical conditions (<code>users.id = 99</code>) from relational information (Which tables? How are they joined?) at the top level. The result is a new format that&#39;s comprehensible to humans while still being easy for a machine to digest:</p>
<p><img alt="Untitled" src="https://images.osohq.com/logic-into-sql/Data%20Filtering%20Blog%20Post%20692a6a339cb541e8b4caf9db690b9aec/Untitled%202.png"/></p>
<p>We&#39;ve also pushed the details of how we translate relations into joins out into the host library, which keeps the core simpler and more platform-independent. The user configuration question is still somewhat open, but it&#39;s no longer tied to language-specific concepts like subclasses, and the data it has to handle are much simpler and more regular. We expect the picture to become clearer as we begin porting the new version to more languages.</p>
<h2>v4???</h2>
<p>While we&#39;re excited about our improved data filtering code and expect it eventually to supplant the original version, we plan to support both APIs initially. The new system has the potential to be much more performant than v1 and to support a wider range of policies, but there are still some limitations on the queries it&#39;s able to generate that mean it&#39;s not quite a drop-in replacement -- although based on the policies we&#39;ve seen in the wild, we don&#39;t expect most users to encounter any problems.</p>
<p>Assuming the new design proves to be a good foundation for future work, one of our next steps will be to port it to the remaining host libraries. Big <em>nostra culpa</em> here to any Rust/Java/Go users in need of data filtering: sorry for the wait! We want to deliver something solid, and dynamic languages are good for prototyping, so we hope you understand. Thank you ... for bearing with us üêª</p>
<p>We use <a href="https://github.com/osohq/oso/issues">GitHub issues</a> to gauge community interest in different platforms and prioritize work accordingly, so in the event you&#39;d really like to use data filtering with Rust, Go, Java, .NET, Haskell, Elixir, Lua, Lisp, Julia, OCaml, APL, or whatever else your favorite platform happens to be ‚Äî we&#39;d appreciate hearing from you there!</p>
<h2>thx for reading ü§ì</h2>
<p>If you&#39;d like to learn more about Oso, please come and join our <a href="http://oso-oss.slack.com">community Slack channel</a> and let&#39;s chat. And since you made it all the way down to the bottom, we might as well mention that <a href="https://www.osohq.com/company/jobs">we&#39;re hiring</a>.</p>
<p>Good luck out there bear cubs, and happy authorizing!</p></div></div>
  </body>
</html>
