<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sicuranext.com/response-filter-denial-of-service-a-new-way-to-shutdown-a-website/">Original</a>
    <h1>Response Filter Denial of Service: shut down a website by triggering WAF rule</h1>
    
    <div id="readability-page-1" class="page"><section>
        <p>TL;DR: Basically, if a target website is protected by a WAF using the OWASP Core Rule Set or Comodo Rule Set or Atomicorp Rule Set, you can send the string <code>ORA-1234</code> or <code>OracleDrive</code> or <code>ASL-CONFIG-FILE</code> in a comment, product review, registration form, e-commerce order details, etc... <strong>to prevent the website from showing its content to any users</strong> like a Denial of Service with a minimal effort. This happens because the overly inclusive response rules of the WAF try to prevent SQL error leakage or web shells. </p><p>By checking all target websites on the most popular bug bounty platforms, I&#39;ve earned 1,200$ of bounty for a single company having this RFDoS problem on their portal.</p><h2 id="why-showing-debug-errors-isnt-good-for-security">Why showing debug errors isn&#39;t good for security?</h2><p>One of the information-gathering technique used by attackers is based on the extraction of valuable insights from error or debug messages inadvertently exposed by target web applications. Imagine a scenario where a database throw an error, or a server-side script like PHP or ASP accidentally reveals a full path or a snippet of its inner workings. These unintentional leaks, often overlooked, can provide valuable information for an attacker, collecting information for more significant vulnerabilities to be exploited.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/02/php_error.png" alt="" loading="lazy" width="1128" height="289" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/02/php_error.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/02/php_error.png 1000w, https://blog.sicuranext.com/content/images/2024/02/php_error.png 1128w" sizes="(min-width: 720px) 720px"/><figcaption><span>Example of a PHP error</span></figcaption></figure><p>Also, showing SQL error messages in a web application can be a security problem if the website inadvertently expose sensitive information about the underlying database. When these error messages are displayed, they often include specific details such as <strong>the type and name of the database, table names, and portions of the SQL query</strong> that triggered the error.</p><p>As you might know, by understanding the database schema, an attacker can craft more effective SQL injection attacks, which can lead to unauthorized data access, data loss, or even complete system compromise. </p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-23.png" alt="" loading="lazy" width="1261" height="694" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-23.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-23.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-23.png 1261w" sizes="(min-width: 720px) 720px"/></figure><p>For that reason, <strong>many Web Application Firewalls implement rules and response validation methods to prevent the leakage of sensitive information</strong>, such as SQL errors or errors related to scripting languages. The same happens, for example, to prevent Web Shell response body.</p><p>This prevention often occurs by blocking the response body before it reaches the user, <strong>typically returning a 403 Forbidden</strong> status instead of the page containing the leakage. More modern WAFs often replace the leaked information with a series of asterisk characters <code>****</code>. This method is commonly used to prevent leaks of credit card numbers or US Social Security numbers. </p><p>However, both prevention methods (blocking the response or replacing the leaked content) are often completely ineffective. <strong>An attacker can usually bypass these preventions</strong> by sending a Range HTTP Request, which requests only portions of the response that do not trigger the WAF. We&#39;ll explore in more detail how this is done later in this post.</p><h2 id="preventing-leakages-with-a-waf-is-good-right">Preventing leakages with a WAF is good, right?</h2><p>Once I read a statement attributed to <strong>Ivan Ristić</strong> that went something like, &#34;<em>When you create a new WAF Rule, you are also creating many ways to bypass it.</em>&#34; Similarly, we can say that <strong>every time you create a response body WAF rule, you&#39;re also exposing websites or applications to RFDoS</strong>.</p><p>Let&#39;s say you are trying to prevent the leakage of credit card numbers on your e-commerce site. To do this, you create a WAF rule that checks for four groups of digits separated by a <code>-</code> in the response body, using a regex like <code>[0-9]+\-[0-9]+\-[0-9]+\-[0-9]+</code>. </p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-21.png" alt="" loading="lazy" width="597" height="269"/><figcaption><span>An example of Regular Expression matching CC numbers</span></figcaption></figure><p>While this might seem like a sensible approach,<strong> it is actually quite risky because it&#39;s very easy for someone to exploit this rule to shut down parts of the website where user input is displayed</strong>. For example, if a user posts a comment or a review on a product with the string <code>4111-1111-1111-1111</code>, the WAF will block the page response for everyone. Imagine if a user sends this type of comment or review to <strong>ALL</strong> products on the e-commerce site... it could trigger a sort of Denial of Service, preventing everyone from viewing any products on the protected e-commerce site.</p><p>That&#39;s why I&#39;ve started referring to this scenario as &#34;Response Filter Denial of Service&#34; or <strong>RFDoS</strong>.</p><p>Additionally, apart from RFDoS, <strong>an attacker could always obtain data leakage from the target website using a Range Request</strong>. We&#39;ll explore why and how in the section titled &#34;<em>Prevent leakage in HTTP response body is often useless because of Byte Range HTTP request</em>&#34;.</p><p>To get the website up and running again after a Response Filter Denial of Service attack, the website owner has several options. These options include removing the rules that triggered the block, creating new exclusion rules to bypass these triggers, or disabling the response body access feature in the WAF. Each of these solutions <strong>requires a good understanding of how the WAF and its rules work</strong>, which can be challenging for someone without technical expertise in this area.</p><p>Sometimes, less experienced users may not understand what is happening with the WAF and could decide to disable it, leaving the website without any protection or monitoring.</p><p>For example, a user who simply activated ModSecurity v2 and the Core Rule Set via their hosting control panel like Plesk might find it difficult to diagnose and resolve the issue. <strong>The time required to identify and fix the problem could result in significant downtime</strong>. This downtime is particularly critical for e-commerce sites, where prolonged unavailability can directly translate into financial losses due to missed sales opportunities.</p><h2 id="modsecurity-and-community-rule-set">ModSecurity and community Rule Set</h2><p>ModSecurity is an open-source Web Application Firewall that provides a variety of security features for web applications. It operates as a module in the web server environment, where it can perform real-time HTTP traffic monitoring, logging, and access control. ModSecurity supports flexible rule configuration, that can inspect both HTTP request and HTTP response.</p><p>ModSecurity it&#39;s just the engine, and <strong>it requires rules</strong> to protect a web application. There&#39;re more than one free rule set, but the most well-known and widely used is the OWASP Core Rule Set (CRS) that is used by Google Cloud Armor, Azure Application Gateway, CloudFlare, and many other vendors (no... AWS WAF has a &#34;Core Rule Set&#34; managed rule, but it is not the OWASP Core Rule Set).</p><p>However, there are also other rule sets available, created and distributed by different security organizations or companies, each with their unique features and focus. For instance, <strong>Comodo</strong> and <strong>Atomicorp</strong> are two such providers. <em>Comodo offers its own set of ModSecurity rules focusing on a broad range of web security threats, while Atomicorp develops rules that are often integrated into their broader security products and services. These company-specific rule sets can provide alternative or supplementary protection strategies to the OWASP CRS, giving users more options depending on their specific security needs and the nature of the threats they are most concerned about</em>.</p><p>And what you&#39;ve just read is ChatGPT&#39;s take on rule set alternatives to the OWASP Core Rule Set. The truth that few are willing to say publicly is that there are no good alternatives to the OWASP Core Rule Set. <strong>Other rule sets are often a jumble of poorly crafted rules</strong> that target very specific payloads and are easily bypassed. Most of the time, they end up being a waste of CPU resources.</p><h3 id="the-owasp-core-rule-set">The OWASP Core Rule Set</h3><p>The OWASP Core Rule Set is a set of generic attack detection rules for use with ModSecurity or compatible WAFs. CRS aims to protect web applications from a wide range of attacks, including the OWASP Top Ten vulnerabilities, with minimal false positives. The CRS is designed as a plug-and-play solution, providing a basic security layer for any web application out of the box.</p><p>Like many other WAF rule sets, the OWASP Core Rule Set includes some rules that inspect the response body, which you can find <a href="https://github.com/coreruleset/coreruleset/tree/main/rules?ref=blog.sicuranext.com" rel="noreferrer">here</a>.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image.png" alt="" loading="lazy" width="624" height="442" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image.png 600w, https://blog.sicuranext.com/content/images/2024/05/image.png 624w"/></figure><p>All those rule sets pose problems in terms of <strong>RFDoS</strong>, but the most problematic one is the <code>RESPONSE-951-DATA-LEAKAGES-SQL.conf</code> configuration file/rule set.</p><p>The main issue with detecting SQL errors in the HTTP response body is that you cannot avoid using a list of regexes that match simple strings without special characters. This is due to how some SQL errors are output by the engine. </p><p>Consider blocking all HTTP response bodies containing the string &#34;<em>You have an error in your SQL syntax</em>&#34;. While this might seem like a good practice, it&#39;s actually a risky approach that can not only cause false positives but also <strong>gives any attacker the ability to shut down any page that stores user input and displays it on the website</strong>. The fact that the statement &#34;<em>You have an error in your SQL syntax</em>&#34; contains no special characters makes it <strong>nearly impossible to validate or sanitize before storing it</strong>.</p><p>Another example is a SQL error leakage rule that uses a regular expression to match <code>ORA-</code> followed by four digits, such as:</p>
<!--kg-card-begin: html-->
<center></center>
<!--kg-card-end: html-->
<figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-12.png" alt="" loading="lazy" width="1115" height="561" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-12.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-12.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-12.png 1115w"/></figure><p>As you can see, this rule runs at phase 4, which includes the response body, and blocks the response if the regex matches the <code>RESPONSE_BODY</code> variable.</p><p>Another really simple string is <code>dynamic sql error</code></p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-13.png" alt="" loading="lazy" width="1043" height="556" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-13.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-13.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-13.png 1043w"/></figure><p>Imagine how easy could be to trigger those rules, just by sending <code>ORA-1234</code> inside a comment, or used as username or e-mail address.</p><h3 id="update-14th-may-2024">Update 14th May 2024</h3><p>While I was completing this article, the OWASP Core Rule Set team committed a change to the rule I used to demonstrate RFDoS. They modified the regex that matched <code>ORA-1234</code> to something like <code>ORA-12345:</code>. However, this change doesn&#39;t impact the RFDoS issue, and you&#39;ll still find the old regex in all of the OWASP Core Rule Sets deployed in production environments.</p><h3 id="comodo-free-rules">Comodo Free Rules</h3><p><strong>The &#34;Comodo Free ModSecurity Rules&#34; project</strong>, on this topic is even worse. It provides a set of free (but not open-source) rules for ModSecurity. These rules are maintained and updated by Comodo, after days trying to download the latest version (the website was always down) I finally managed to get my copy of <code>cwaf_rules-1.241</code>. </p><p>Comodo distributes a series of OutgoingFilter rule sets that also include prevention of SQL error leakages.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-11.png" alt="" loading="lazy" width="869" height="280" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-11.png 600w, https://blog.sicuranext.com/content/images/2024/05/image-11.png 869w" sizes="(min-width: 720px) 720px"/><figcaption><span>from Comodo </span><a href="https://waf.comodo.com/user/cwaf_revisions?ref=blog.sicuranext.com"><span>https://waf.comodo.com/user/cwaf_revisions</span></a></figcaption></figure><p>As you can imagine, inside the <code>17_Outgoing_FilterSQL.conf</code> file we can found our magic string ORA-1234:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-8.png" alt="" loading="lazy" width="1586" height="214" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-8.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-8.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-8.png 1586w" sizes="(min-width: 1200px) 1200px"/></figure><p>But also other really simple string like <code>Dynamic SQL Error</code> or <code>JET Database Engine</code> or <code>Access Database Engine</code></p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-9.png" alt="" loading="lazy" width="1544" height="152" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-9.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-9.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-9.png 1544w" sizes="(min-width: 1200px) 1200px"/></figure><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-10.png" alt="" loading="lazy" width="1635" height="168" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-10.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-10.png 1000w, https://blog.sicuranext.com/content/images/size/w1600/2024/05/image-10.png 1600w, https://blog.sicuranext.com/content/images/2024/05/image-10.png 1635w" sizes="(min-width: 1200px) 1200px"/></figure><h3 id="atomicorp-free-modsecurity-rules">Atomicorp Free ModSecurity Rules</h3><p>Atomicorp offers a free-to-use set of ModSecurity rules that you can download by registering on their portal. One of these rules aims to prevent the leakage of the rules or configurations themselves by <strong>blocking any response body that includes the string:</strong></p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-3.png" alt="" loading="lazy" width="1109" height="112" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-3.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-3.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-3.png 1109w"/><figcaption><span>From the latest Atomicorp modsec-202405080003.tar.bz2</span></figcaption></figure><h2 id="why-response-waf-rules-are-dangerous">Why response WAF rules are dangerous?</h2><p>If you can store user input on a target website (protected by a WAF), such as a comment or a product review, you can easily shut down the page where the user input is displayed by simply sending something like:</p><p><strong>ORA-1234</strong></p><p>Imagine an e-commerce protected by WAF. To generate a Denial of Service attack on it, an attacker could simply submit a product review containing a message like, &#34;<em>Really useful product, I tried it with ORA-1234, and it works really well</em>&#34; <strong>effectively preventing any user from accessing the page where the review is published</strong>. The same applies to the &#34;User Account Details&#34; page: by registering an account with an email address like <code>andrea+ORA-1234@gmail.com</code>, it would stop any administrator from viewing the user list or editing the account details.</p><h2 id="the-magic-string-ora-1234">The magic string ORA-1234</h2><p><code>ORA-1234</code> isn&#39;t the only string that triggers this issue. Here&#39;s a list of very simple strings (without any special characters) that anyone can use to generate a Response Filter Denial of Service on a website that meets the conditions we mentioned earlier.</p><p><strong>Each one of the following strings will be blocked</strong> by one or more Response Body rule enabled on ModSecurity v2 + OWASP Core Rule Set:</p><pre><code>ET Database Engine
Access Database Engine
ORA-1234
Oracle error
OracleDriver
CLI DriverDB2
DB2 SQL error
Dynamic SQL Error
An illegal character has been found in the statement
ExceptionInformix
Ingres SQLSTATE
Unexpected end of command in statement
SQL errorPOS1
Warningmaxdb
Unclosed quotation mark after the character string
Microsoft OLE DB Provider for ODBC Drivers
Microsoft OLE DB Provider for SQL Server
Incorrect syntax near
Sintaxis incorrecta cerca de
Syntax error in string in query expression
Procedure or function foo expects parameter
Unclosed quotation mark before the character string
Syntax error foo in query expression
the used select statements have different number of columns
OLE DBSQL Server
DriverSQL Server
SQL ServerDriverS
QL Server12345678
supplied argument is not a valid MySQL
on MySQL result index
You have an error in your SQL syntax near
MySQL server version for the right syntax to use
SQL syntaxMySQL
valid MySQL result
PostgreSQLERROR
valid PostgreSQL result
Supplied argument is not a valid PostgreSQL foo resource
Unable to connect to PostgreSQL server
Warningsybase
SybaseServer message
An Error Has Occurred
</code></pre>
<h2 id="the-core-problem">The Core Problem</h2><p>The main issue here is that <strong>all these strings can pass through any type of input validation or sanitization module</strong>. The lack of special characters, HTML tags, and terms included in bad-word dictionaries (like <code>eval</code> or <code>exec</code>) makes them the perfect choice for any attacker who wants to prevent a website from being displayed to users.</p><h2 id="rfdos-demo-on-a-vanilla-wordpress-website">RFDoS demo on a vanilla WordPress website</h2>
<!--kg-card-begin: html-->
<iframe width="560" height="315" src="https://www.youtube.com/embed/JPi0_kZwSco?si=8tMtxob5L_Qbm1UA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<!--kg-card-end: html-->
<h2 id="prevent-leakage-in-http-response-body-is-often-useless-because-of-byte-range-http-request">Prevent leakage in HTTP response body is often useless because of Byte Range HTTP request</h2><p>Let&#39;s say I&#39;m triggering a visible error-based SQL Injection on a target protected by a WAF. This WAF blocks all response bodies containing a SQL error. To bypass this and see the SQL error, I can send an <strong>Byte Range HTTP request</strong>. By requesting only a portion of the response body, it&#39;s quite easy to avoid triggering the WAF rule that is designed to prevent data leakage. </p><p>The <code>Range</code> request header in the HTTP protocol is a feature that allows clients to request a specific part of a resource, rather than downloading the entire file or content at once. This header indicates which part of the resource the client wants to receive, specified as one or more data ranges. For example, a client can request the first 500 bytes of a file or a specific segment in the middle of a large video or document.</p><p>The syntax for a <code>Range</code> request is typically like this: <code>Range: bytes=0-499</code>, which requests the first 500 bytes of the resource.</p><p>Let test it.</p><p>In the following test, I&#39;m attempting to exploit a SQL Injection using the query string parameter &#39;a&#39;, but an error occurs and <strong>the WAF blocks the response body to prevent the error from being leaked</strong>:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-5.png" alt="" loading="lazy" width="1466" height="529" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-5.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-5.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-5.png 1466w" sizes="(min-width: 1200px) 1200px"/></figure><p>Typically, MySQL errors display a message like: &#34;<strong>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;foo bar&#39; at line xyz</strong>&#34;. </p><p>Knowing that the WAF rule likely matches the initial part of this message, <code>You have an error in your SQL syntax</code>, I can avoid triggering the WAF by &#34;cutting off&#34; the beginning of the response. I do this by sending a byte range HTTP request from 90 to 140. For example:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-6.png" alt="" loading="lazy" width="1467" height="383" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-6.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-6.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-6.png 1467w" sizes="(min-width: 1200px) 1200px"/></figure><p>So, as you can see, bypassing any response body filter becomes quite easy using the Range request header. <strong>This applies not only to SQL error leakage but also to rules designed to prevent web shell or backdoor responses in the response body</strong>.</p><p>⚠️ Requesting a byte range HTTP request <strong>is not always possible</strong>, as it depends on the webserver&#39;s decision to accept it or not. For example, if a SQL Injection payload leads the application to an error resulting in a 500 internal server error, the webserver might choose not to accept the byte range request and instead send the entire error page to the user.</p><p>The OWASP Core Rule Set includes a set of rules aimed at preventing &#34;Web Shells&#34; or, in other words, backdoors. These rules attempt to match the HTML body of the most common online backdoors by, for example, triggering on the title tag of the page.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-15.png" alt="" loading="lazy" width="1004" height="835" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-15.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-15.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-15.png 1004w" sizes="(min-width: 720px) 720px"/></figure><p>One of the most common objections I&#39;ve encountered when explaining the RFDoS problem goes something like this: &#34;<em>Okay, RFDoS could be a problem, but preventing backdoors or PHP shells from being sent to an attacker is more important and worth the risk of RFDoS.</em>&#34; </p><p>Initially, this seemed like a valid point. However, I then remembered the Byte Range request, and I realized that attackers are often in a position to circumvent the response filter by requesting portions of the response body. I say often because this really depends on the configuration of the webserver and the server side modules. Let&#39;s do a test.</p><p><strong>I&#39;m going to simulate a web shell</strong>, with a title tag that matches one of the Web Shells rules, and include a leak of the WordPress config file (which often contains the username and password for the MySQL database) that will trigger the PHP code leakage rule.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-16.png" alt="" loading="lazy" width="1169" height="634" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-16.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-16.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-16.png 1169w" sizes="(min-width: 720px) 720px"/></figure><p>If I attempt to access the content of the web shell, the WAF will block my request because of one of the rules mentioned above.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-17.png" alt="" loading="lazy" width="1406" height="517" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-17.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-17.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-17.png 1406w" sizes="(min-width: 720px) 720px"/></figure><p>ModSecurity logs:</p><pre><code>ModSecurity: Warning. Match of &#34;rx ...&#34; against &#34;RESPONSE_BODY&#34; required. [file &#34;/etc/modsecurity.d/owasp-crs/rules/RESPONSE-953-DATA-LEAKAGES-PHP.conf&#34;] [line &#34;102&#34;] [id &#34;953120&#34;] [msg &#34;PHP source code leakage&#34;] [severity &#34;ERROR&#34;] ...

ModSecurity: Warning. Matched phrase &#34;&lt;title&gt;=[ 1n73ct10n privat shell ]=&lt;/title&gt;&#34; at RESPONSE_BODY. [file &#34;/etc/modsecurity.d/owasp-crs/rules/RESPONSE-955-WEB-SHELLS.conf&#34;] [line &#34;41&#34;] [id &#34;955100&#34;] [msg &#34;Web shell detected&#34;] ...
</code></pre>
<p>To bypass the response filter, I can omit the first part of the response that contains the title tag by skipping the first 60 bytes:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-18.png" alt="" loading="lazy" width="1473" height="647" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-18.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-18.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-18.png 1473w" sizes="(min-width: 1200px) 1200px"/></figure><p>But when I try to extend the response to include the wp-config file content, the WAF block me again due to PHP leakage rule:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-19.png" alt="" loading="lazy" width="1448" height="621" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-19.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-19.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-19.png 1448w" sizes="(min-width: 1200px) 1200px"/></figure><p>Fortunately, I can use a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests?ref=blog.sicuranext.com#multipart_ranges" rel="noreferrer">Multipart Range</a> to request multiple portions of the same response body, which will be served to me as a multipart response. For example:</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-20.png" alt="" loading="lazy" width="1466" height="818" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-20.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-20.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-20.png 1466w" sizes="(min-width: 1200px) 1200px"/></figure><p>As you can see, I was able to bypass two OWASP Core Rule Set response body rules simply because the HTTP protocol allows me to do so.</p><p>With this demonstration, I&#39;m not suggesting that preventing web shells is a bad thing. <strong>In many cases, it can help website administrators or hosting providers quickly identify compromised websites</strong>, alert the owners, or even remove the shells promptly.</p><p>The point is that developers and maintainers need to consider RFDoS before implementing a new response body rule, and users should have the option to enable these rules rather than having them activated by default.</p><h2 id="why-only-modsecurity-v2x-branch-is-affected-by-this-problem-and-not-the-v3x-branch">Why only ModSecurity v2.x branch is affected by this problem, and not the v3.x branch?</h2><p>ModSecurity v2 is primarily available on Apache (as of this writing). The v3.x branch can only run as an external library on Nginx and other webservers, except for Apache.</p><p>As you might be aware, all ModSecurity rules must operate in a specific phase. Phase 1 is for the request string and request headers, Phase 2 includes the request body, Phase 3 adds the response headers, and Phase 4 includes the response body.</p><p>Nginx, like many other modern webservers, tries to send the HTTP response to the user as quickly as possible. This means that sending the response takes priority over ModSecurity rule inspection. That’s why you can&#39;t inspect the response body on Nginx + ModSecurity v3.x; Nginx sends the response body before ModSecurity has a chance to inspect it at Phase 4.</p><h2 id="why-owasp-core-rule-set-doesnt-fixed-it-yet">Why OWASP Core Rule Set doesn&#39;t fixed it yet?</h2><p>Before I continue, I want to mention that <strong>we at SicuraNext are all big fans of the OWASP Core Rule Set project</strong>. I privately reported this issue months ago, hoping to convince the team to (at least) remove all those strings that don&#39;t include special characters from the list of denied strings in the response body, or (a better solution for me) move all <code>RESPONSE</code> rules to a plugin, meaning that no response rule are executed by default.</p><p>My concern was about releasing the major version 4.0 of the Core Rule Set with all these RFDoS issues enabled by default. This, along with other issues related to the ModSecurity engine that should be addressed by the rule set itself to prevent bypasses not only in ModSecurity but also in compatible WAFs and all possible future implementations, forms part of a bigger picture (but it&#39;s another story).</p><p>Unfortunately, my request to fix wasn&#39;t really considered for the following sentences, with which I strongly disagree:</p><ul><li>ModSecurity does not enable access to the response body by default.</li><li>Users can choose to not include rules for the response body.</li><li>The problem has not yet been reported by any other users.</li><li>The technique requires too many preconditions.</li><li>Blocking web shell worth the risk of RFDoS.</li></ul><p>Let&#39;s examine why, in my opinion, these assumptions are incorrect.</p><h3 id="modsecurity-doesnt-access-to-the-response-body-by-default">ModSecurity doesn&#39;t access to the response body by default</h3><p>Yes, <a href="https://github.com/owasp-modsecurity/ModSecurity/blob/c8056483f7dbf5fc267962324aeffe5ff60f3467/modsecurity.conf-recommended?ref=blog.sicuranext.com#L171" rel="noreferrer">it does on v3.x</a> and <a href="https://github.com/owasp-modsecurity/ModSecurity/blob/788c36d34360811bc21cc3319412195542ed0bc0/modsecurity.conf-recommended?ref=blog.sicuranext.com#L124" rel="noreferrer">it does on v2.x</a> and based on my experience, users typically opt to use the default configuration.</p><h3 id="users-can-choose-to-not-include-rules-for-the-response-body">Users can choose to not include rules for the response body</h3><p>In my personal experience with WAFs, <strong>users seldom try to understand what a rule actually inspects</strong>. Typically, users simply run the rule set without even reading the rule descriptions. </p><p>Moreover, let&#39;s put ourselves in the shoes of a WAF end user: Our primary concern is to protect our website, and when a team of security experts (maintaining one of the most used WAF rule sets) recommends preventing SQL error leakages by enabling by default all response rules, what would you do? So, I believe that most users are not able to discern when and where to enable a rule set, and understandably, <strong>they tend to trust the vendor (or the community)</strong>.</p><p>Even in the <a href="https://coreruleset.org/docs/deployment/install/?ref=blog.sicuranext.com#include-ing-the-rule-files">Core Rule Set Documentation</a>, there is no mention that users should first review the rules to decide whether or not to include the response rule set. The documentation simply instructs users to use <code>Include rules/*.conf</code>, which implies including all rules.</p><p>In this post we&#39;ll see how prevalent this RFDoS is across many websites, and one of the main reasons is <strong>Plesk</strong>. Many of the targets I checked in order to trigger this problem, send a Plesk error page along with a 403 Forbidden response. As detailed in <a href="https://docs.plesk.com/en-US/obsidian/administrator-guide/server-administration/web-application-firewall-modsecurity.73383/?ref=blog.sicuranext.com" rel="noreferrer">this documentation</a>, it’s very easy for a Plesk user to enable ModSecurity and the OWASP Core Rule Set (which they refer to simply as OWASP Rule... <strong>shame on you, Plesk</strong>), but <strong>it&#39;s nearly impossible for a user to choose whether or not to enable the Core Rule Set response rules</strong>.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-14.png" alt="" loading="lazy" width="1020" height="742" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-14.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-14.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-14.png 1020w" sizes="(min-width: 720px) 720px"/><figcaption><span>Plesk 403 Response HTML</span></figcaption></figure><h3 id="the-problem-has-not-yet-been-reported-by-any-other-users-and-if-it-were-a-real-issue-we-would-have-received-numerous-reports-by-now">The problem has not yet been reported by any other users, and if it were a real issue, we would have received numerous reports by now</h3><p>It&#39;s true that leakage prevention rules have been part of the OWASP Core Rule Set for many years, and there haven&#39;t been any security issues reported related to them. However, we did earn a bounty thanks to this problem, so I am really convinced that these rules represent a real issue that nobody has thoroughly investigated yet.</p><p>Moreover, there are numerous cases where a vulnerability was discovered years after being included in software.</p><h3 id="the-technique-requires-too-many-preconditions">The technique requires too many preconditions</h3><p>When we talk about e-commerce, there are many places where user input is stored and reflected in the response body. As I mentioned before, nearly all e-commerce platforms, like WooCommerce and similar, allow users to leave reviews and comments on products. This alone is enough to be concerned about this issue. Moreover, nowadays, <strong>I believe there are no websites that don&#39;t handle user input at all, and very few do not store it and include it in the response body</strong>.</p><h3 id="blocking-web-shell-worth-the-risk-of-rfdos">Blocking web shell worth the risk of RFDoS</h3><p>As I mentioned earlier, an attacker is often in a position to bypass a WAF response filter by leveraging the Range request header, allowing them to request just a portion of the response that doesn&#39;t match any WAF rules.</p><p>In my opinion, protecting users from a backdoor should not expose them to another type of attack that could be much easier to execute and that anyone could perform, regardless of their skill level.</p><h2 id="how-many-websites-are-affected-by-this-rfdos">How many websites are affected by this RFDoS?</h2><p>As I mentioned earlier, software like Plesk and cPanel allows users to easily enable ModSecurity and rule sets such as the OWASP Core Rule Set, Comodo, or Atomicorp Rules. In both cPanel and Plesk, disabling response body inspection isn&#39;t something a non-expert user can easily do or would typically consider doing. Therefore, many users opt to enable the default configuration, which includes response body inspection and SQL Error leakage prevention rules.</p><p>Due to the widespread use of Plesk and cPanel, this type of RFDoS can easily be triggered on many websites across the internet.</p><p>It&#39;s hard to determine the exact extent of this issue across the internet. As part of our side project, <a href="https://pwnpress.io/?ref=blog.sicuranext.com" rel="noreferrer"><strong>PWNPress</strong></a>, we&#39;ve been collecting data on all WordPress websites worldwide by parsing the Common Crawl dataset. Through this, we have identified <strong>15 million WordPress sites</strong>. Using this information, I ran a custom Nuclei template to verify the presence of a RFDoS condition against a subset of those 15 million websites, by using the WordPress search engine function. </p><p>As you might know, <strong>WordPress reflects the user input</strong> from the <code>s</code> parameter in the query string back to the response body, as seen in URLs like <code>/?s=foobar</code>.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-1.png" alt="" loading="lazy" width="1028" height="545" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-1.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-1.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-1.png 1028w" sizes="(min-width: 720px) 720px"/></figure><p>So, basically for each target I&#39;m going to run 2 HTTP request: </p><ol><li><code>/?s=ORA-1</code> expecting a <strong>200 OK</strong></li><li><code>/?s=ORA-1234</code> expecting a <strong>403 Forbidden</strong></li></ol><p>If both return the expected status code, so RFDoS is possible. By doing this, I was able to identify a lot of WordPress websites affected by RFDoS.</p><p>So, what I&#39;ve done is selected just the first 200K WordPress sites with some European ccTLDs (specifically IT, DE, FR, ES, CH). I&#39;m not planning to test all 15 million WordPress sites available to me because that would require a huge amount of time. My goal is more to understand how frequent this problem is.</p><table>
<thead>
<tr>
<th>ccTLD</th>
<th>Tested First N. Targets</th>
<th>RFDoS Found</th>
<th>%</th>
</tr>
</thead>
<tbody>
<tr>
<td>.it</td>
<td>200.000</td>
<td>3076</td>
<td>1.54</td>
</tr>
<tr>
<td>.es</td>
<td>200.000</td>
<td>2516</td>
<td>1.26</td>
</tr>
<tr>
<td>.fr</td>
<td>200.000</td>
<td>1032</td>
<td>0.52</td>
</tr>
<tr>
<td>.de</td>
<td>200.000</td>
<td>835</td>
<td>0.42</td>
</tr>
<tr>
<td>.ch</td>
<td>124.658</td>
<td>481</td>
<td>0.39</td>
</tr>
</tbody>
</table>
<p>Please keep in mind that all these numbers refer <strong>only to WordPress websites</strong>, and the subset of tested targets was selected in alphabetical order: the first 200,000 results from 0 to z.</p><h2 id="top-10-providers-with-rfdos-found-for-each-analyzed-cctld-wordpress-websites">Top 10 Providers with RFDoS Found for Each Analyzed ccTLD (WordPress websites)</h2><table>
<thead>
<tr>
<th>.it Provider Name</th>
<th>RFDoS found</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aruba S.p.A.</td>
<td>1224</td>
</tr>
<tr>
<td>OVH SAS</td>
<td>386</td>
</tr>
<tr>
<td>Server Plan S.r.l.</td>
<td>314</td>
</tr>
<tr>
<td>Cloudflare, Inc.</td>
<td>216</td>
</tr>
<tr>
<td>SEEWEB s.r.l.</td>
<td>158</td>
</tr>
<tr>
<td>Hetzner Online GmbH</td>
<td>141</td>
</tr>
<tr>
<td>Amazon.com, Inc.</td>
<td>94</td>
</tr>
<tr>
<td>IONOS SE</td>
<td>91</td>
</tr>
<tr>
<td>Consortium GARR</td>
<td>78</td>
</tr>
<tr>
<td>INTRED S.P.A.</td>
<td>62</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>.es Provider Name</th>
<th>RFDoS found</th>
</tr>
</thead>
<tbody>
<tr>
<td>DinaHosting S.L.</td>
<td>667</td>
</tr>
<tr>
<td>IONOS SE</td>
<td>478</td>
</tr>
<tr>
<td>OVH SAS</td>
<td>374</td>
</tr>
<tr>
<td>Cloudflare, Inc.</td>
<td>157</td>
</tr>
<tr>
<td>Soluciones web on line s.l.</td>
<td>135</td>
</tr>
<tr>
<td>AXARNET COMUNICACIONES, S.L.</td>
<td>77</td>
</tr>
<tr>
<td>Hetzner Online GmbH</td>
<td>67</td>
</tr>
<tr>
<td>Abansys &amp; Hostytec, S.L.</td>
<td>45</td>
</tr>
<tr>
<td>Amazon.com, Inc.</td>
<td>41</td>
</tr>
<tr>
<td>CLOUDI NEXTGEN SL</td>
<td>40</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>.fr Provider Name</th>
<th>RFDoS found</th>
</tr>
</thead>
<tbody>
<tr>
<td>OVH SAS</td>
<td>552</td>
</tr>
<tr>
<td>IONOS SE</td>
<td>104</td>
</tr>
<tr>
<td>Cloudflare, Inc.</td>
<td>63</td>
</tr>
<tr>
<td>SCALEWAY S.A.S.</td>
<td>43</td>
</tr>
<tr>
<td>Contabo GmbH</td>
<td>41</td>
</tr>
<tr>
<td>Renater</td>
<td>32</td>
</tr>
<tr>
<td>Internet Vikings International AB</td>
<td>22</td>
</tr>
<tr>
<td>Cogent Communications</td>
<td>21</td>
</tr>
<tr>
<td>Amazon.com, Inc.</td>
<td>12</td>
</tr>
<tr>
<td>Ikoula Net SAS</td>
<td>10</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>.de Provider Name</th>
<th>RFDoS found</th>
</tr>
</thead>
<tbody>
<tr>
<td>Host Europe GmbH</td>
<td>104</td>
</tr>
<tr>
<td>IONOS SE</td>
<td>100</td>
</tr>
<tr>
<td>Hetzner Online GmbH</td>
<td>91</td>
</tr>
<tr>
<td>dogado GmbH</td>
<td>77</td>
</tr>
<tr>
<td>Strato AG</td>
<td>49</td>
</tr>
<tr>
<td>netcup GmbH</td>
<td>30</td>
</tr>
<tr>
<td>Cloudflare, Inc.</td>
<td>29</td>
</tr>
<tr>
<td>Internet Vikings International AB</td>
<td>29</td>
</tr>
<tr>
<td>Nawork Internet Informationssysteme GmbH</td>
<td>26</td>
</tr>
<tr>
<td>Michael Sebastian Schinzel trading as IP-Projects GmbH &amp; Co. KG</td>
<td>20</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>.ch Provider Name</th>
<th>RFDoS found</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hetzner Online GmbH</td>
<td>157</td>
</tr>
<tr>
<td>Cloudflare, Inc.</td>
<td>35</td>
</tr>
<tr>
<td>DATAWIRE AG</td>
<td>31</td>
</tr>
<tr>
<td>Internet Vikings International AB</td>
<td>25</td>
</tr>
<tr>
<td>Nexanet AG</td>
<td>20</td>
</tr>
<tr>
<td>Infomaniak Network SA</td>
<td>17</td>
</tr>
<tr>
<td>OVH SAS</td>
<td>17</td>
</tr>
<tr>
<td>hosttech GmbH</td>
<td>11</td>
</tr>
<tr>
<td>Amazon.com, Inc.</td>
<td>10</td>
</tr>
<tr>
<td>Liberty Global B.V.</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Obviously, if any of the mentioned providers want to know where we found RFDoS issues with their customers, they can contact us, and we are willing to share this information with them.</p><figure><img src="https://blog.sicuranext.com/content/images/2024/05/image-22.png" alt="" loading="lazy" width="1262" height="616" srcset="https://blog.sicuranext.com/content/images/size/w600/2024/05/image-22.png 600w, https://blog.sicuranext.com/content/images/size/w1000/2024/05/image-22.png 1000w, https://blog.sicuranext.com/content/images/2024/05/image-22.png 1262w" sizes="(min-width: 720px) 720px"/></figure><h2 id="the-credit-card-number-problem">The Credit Card Number Problem</h2><p>Many years ago, Trustwave <a href="https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/modsecurity-advanced-topic-of-the-week-credit-card-tracking/?ref=blog.sicuranext.com" rel="noreferrer">published</a> some advice on how to prevent credit card number leakages using ModSecurity WAF.</p><pre><code># Visa
SecRule RESPONSE_BODY|RESPONSE_HEADERS:Location &#34;@verifyCC (?:^|[^\d])(?&lt;!google_ad_client = \&#34;pub-)(4\d{3}\-?\d{4}\-?\d{2}\-?\d{2}\-?\d(?:\d{3})??)(?:[^\d]|$)&#34; \
&#34;chain,\
logdata:&#39;Start of CC #: %{tx.ccdata_begin}***...&#39;,\
phase:4,\
t:none,\
ctl:auditLogParts=-E,\
block,
msg:&#39;Visa Credit Card Number sent from site to user&#39;,\
id:&#39;920008&#39;,\
tag:&#39;WASCTC/5.2&#39;,\
tag:&#39;PCI/3.3&#39;,\
severity:&#39;1&#39;&#34;

</code></pre>
<p>This SecRule is a ModSecurity rule designed to identify and block the transmission of Visa credit card numbers either within the response body or in the headers of a web response. Let&#39;s break down the components of this rule to understand its function:</p><ul><li><strong>SecRule RESPONSE_BODY|RESPONSE_HEADERS:Location</strong>: This specifies the targets for the rule, which are the response body and the <code>Location</code> header in HTTP responses. The rule will check these areas for patterns that match a Visa credit card number.</li><li><strong>@verifyCC ..regex..</strong>: This is the regular expression used for detection. It uses <code>@verifyCC</code> to apply a credit card verification algorithm, ensuring the numbers match a typical Visa card format:<ul><li>Visa cards begin with a 4.</li><li>The format is typically 4 sets of 4 digits, which can optionally be separated by hyphens.</li><li>The regex ensures that the numbers are not part of a larger sequence of digits and aren&#39;t improperly extracted from substrings like text or scripts.</li></ul></li><li><strong>ctl:auditLogParts=-E</strong>: This control directive modifies which parts of the transaction are included in the audit log. In this case, <code>-E</code> means to exclude the response body from the audit logs to protect sensitive data.</li><li><strong>block</strong>: This action directive tells ModSecurity to block the response if the rule condition is met, preventing the data from reaching the user.</li></ul><p>This rule seems crucial for compliance with data security standards like PCI DSS, which require the protection of credit card information to prevent data breaches and fraud. However, it also exposes the protected website to RFDoS, when the website allows users to store and reflect any user input.</p><p>Indeed, this approach is widely used where companies must comply with PCI DSS. Many vendors opt for an alternative to blocking the response body. They replace the suspicious leakage string with a series of <code>*</code> without actually blocking the response. While this method is less problematic in terms of RFDoS, it becomes completely ineffective when an attacker can send a Byte Range HTTP request, as we&#39;ve seen before.</p><h2 id="conclusion">Conclusion</h2><p>The Response Filter Denial of Service problem represents a significant security challenge that arises when well-intentioned security measures inadvertently create new vulnerabilities. Specifically, RFDoS occurs when Web Application Firewalls or similar security tools are configured to inspect and filter HTTP response bodies to prevent sensitive data leakage, such as application errors or credit card numbers. While these filters aim to protect against data exposure and comply with regulations like PCI DSS, they also allow attackers to exploit these mechanisms to induce service disruptions.</p><p>Attackers can trigger RFDoS by injecting content that matches the filters set to block or alter responses, leading to legitimate requests being blocked or altered (effectively denying access to the service for regular users). Furthermore, the ability of attackers to use features like the HTTP Range request complicates the issue, as it allows them to bypass filters that inspect entire response bodies by requesting only portions of the data.</p><p>The main takeaway is that while response body filtering is critical for protecting sensitive data from being exposed, it requires a balanced approach to ensure it does not compromise the availability of web services. Security teams must continually evaluate the effectiveness of their protective measures against emerging threat vectors and consider adopting more dynamic and context-aware filtering techniques. Additionally, educating users on the potential risks and configurations of WAF settings can help mitigate some aspects of RFDoS vulnerabilities.</p>
    </section></div>
  </body>
</html>
