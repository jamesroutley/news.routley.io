<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.merovius.de/posts/2022-05-16-calculating-type-sets/">Original</a>
    <h1>Calculating Go type sets is harder than you think</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p>Go 1.18 added the biggest and probably one of the most requested features of
all time to the language: <a href="https://go.dev/doc/go1.18#generics">Generics</a>. If
you want a comprehensive introduction to the topic, there are many out there
and I would personally <a href="https://www.youtube.com/watch?v=QP6v-Q5Foek">recommend this talk I gave at the Frankfurt Gopher
Meetup</a>.</p><p>This blog post is not an introduction to generics, though. It is about <a href="https://go.dev/ref/spec#Operands">this
sentence from the spec</a>:</p><blockquote><p>Implementation restriction: A compiler need not report an error if an
operand’s type is a type parameter with an empty type set.</p></blockquote><p>As an example, consider this interface:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>C</span> <span>interface</span> {
</span></span><span><span>  <span>int</span>
</span></span><span><span>  <span>M</span>()
</span></span><span><span>}
</span></span></code></pre></div><p>This constraint can never be satisfied. It says that a type has to be <em>both</em>
the predeclared type <code>int</code> <em>and</em> have a method <code>M()</code>. But predeclared
types in Go do not have any methods. So there is no type satisfying <code>C</code> and its
type set is empty.
<a href="https://go.dev/play/p/36pFPhJKGxl">The compiler accepts it just fine</a>, though.
That is what this clause from the spec is about.</p><p>This decision might seem strange to you. After all, if a type set is empty,
it would be very helpful to report that to the user. They obviously made a
mistake - an empty type set can never be used as a constraint. A function using
it could never be instantiated.</p><p>I want to explain why that sentence is there and also go into a couple of
related design decisions of the generics design. I’m trying to be expansive in
my explanation, which means that you should not need any special knowledge to
understand it. It also means, some of the information might be boring to you -
feel free to skip the corresponding sections.</p><p>That sentence is in the Go spec because it turns out to be hard to determine if
a type set is empty. Hard enough, that the Go team did not want to require an
implementation to solve that. Let’s see why.</p><h2 id="p-vs-np">P vs. NP</h2><p>When we talk about whether or not a problem is hard, we often group problems
into two big classes:</p><ol><li>Problems which can be <em>solved</em> reasonably efficiently. This class is called
P.</li><li>Problems which can be <em>verified</em> reasonably efficiently. This class is called
NP.</li></ol><p>The first obvious follow up question is “what does ‘reasonably efficient’
mean?”. The answer to that is “there is an algorithm with a running time
polynomial in its input size”<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>The second obvious follow up question is “what’s the difference between
‘solving’ and ‘verifying’?”.</p><p><em>Solving</em> a problem means what you think it means: Finding a solution. If I
give you a number and ask you to solve the factorization problem, I’m asking
you to find a (non-trivial) factor of that number.</p><p><em>Verifying</em> a problem means that I give you a solution and I’m asking you if the
solution is correct. For the factorization problem, I’d give you two numbers
and ask you to verify that the second is a factor of the first.</p><p>These two things are often very different in difficulty. If I ask you to give
me a factor of 297863737, you probably know no better way than to sit down and
try to divide it by a lot of numbers and see if it comes out evenly. But if I
ask you to verify that 9883 is a factor of that number, you just have to do a
bit of long division and it either divides it, or it does not.</p><p>It turns out, that every problem which is efficiently <em>solvable</em> is also
efficiently <em>verifiable</em>. You can just calculate the solution and compare it to
the given one. So every problem in P is also in NP<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. But it is
<a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">a famously open question</a>
whether the opposite is true - that is, we don’t really <em>know</em>, if there are
problems which are hard to solve but easy to verify.</p><p>This is hard to know in general. Because us not having <em>found</em> an efficient
algorithm to solve a problem does not mean <em>there is none</em>. But in practice we
usually assume that there are some problems like that.</p><p>One fact that helps us talk about hard problems, is that there are some
problems which are <em>as hard as possible</em> in NP. That means we were able to
prove that if you can solve one of these problems you can use that to solve
<em>any other problem in NP</em>. These problems are called “NP-complete”.</p><p>That is, to be frank, plain magic and explaining it is far beyond my
capabilities. But it helps us to tell if a given problem is hard, by doing it
the other way around. If solving problem X would enable us to solve one of
these NP-complete problems then solving problem X is obviously itself NP-complete
and therefore <em>probably very hard</em>. This is called a “proof by reduction”.</p><p>One example of such problem is boolean satisfiability. And it is used very
often to prove a problem is hard.</p><h2 id="sat">SAT</h2><p>Imagine I give you a boolean function. The function has a bunch of <code>bool</code>
arguments and returns <code>bool</code>, by joining its arguments with logical operators
into a single expression. For example:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>F</span>(<span>x</span>, <span>y</span>, <span>z</span> <span>bool</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> ((!<span>x</span> <span>&amp;&amp;</span> <span>y</span>) <span>||</span> <span>z</span>) <span>&amp;&amp;</span> (<span>x</span> <span>||</span> !<span>y</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>If I give you values for these arguments, you can efficiently tell me if the
formula evaluates to <code>true</code> or <code>false</code>. You just substitute them in and
evaluate every operator. For example</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>f</span>(<span>true</span>, <span>true</span>, <span>false</span>)
</span></span><span><span>  <span>→</span> ((!<span>true</span> <span>&amp;&amp;</span> <span>true</span>) <span>||</span> <span>false</span>) <span>&amp;&amp;</span> (<span>true</span> <span>||</span> !<span>true</span>)
</span></span><span><span>  <span>→</span> ((<span>false</span> <span>&amp;&amp;</span> <span>true</span>) <span>||</span> <span>false</span>) <span>&amp;&amp;</span> (<span>true</span> <span>||</span> !<span>true</span>)
</span></span><span><span>  <span>→</span> ((<span>false</span> <span>&amp;&amp;</span> <span>true</span>) <span>||</span> <span>false</span>) <span>&amp;&amp;</span> (<span>true</span> <span>||</span> <span>false</span>)
</span></span><span><span>  <span>→</span> ((<span>false</span> <span>&amp;&amp;</span> <span>true</span>) <span>||</span> <span>false</span>) <span>&amp;&amp;</span> <span>true</span>
</span></span><span><span>  <span>→</span>  (<span>false</span> <span>&amp;&amp;</span> <span>true</span>) <span>||</span> <span>false</span>
</span></span><span><span>  <span>→</span>   <span>false</span> <span>&amp;&amp;</span> <span>true</span>
</span></span><span><span>  <span>→</span>   <span>false</span>
</span></span></code></pre></div><p>This takes at most one step per operator in the expression. So it takes a
<em>linear</em> number of steps in the length of the input, which is very efficient.</p><p>But if I <em>only</em> give you the function and ask you to <em>find</em> arguments which
make it return <code>true</code> - or even to find out whether such arguments exist - you
probably have to try out all possible input combinations to see if any of them
does. That’s easy for three arguments. But for \(n\) arguments there are
\(2^n\) possible assignments, so it takes <em>exponential</em> time in the number of
arguments.</p><p>The problem of finding arguments that makes such a function return <code>true</code> (or
proving that no such arguments exists) is called “boolean satisfiability” and
it is NP-complete.</p><p>It is extremely important <em>in what form</em> the expression is given, though. Some
forms make it pretty easy to solve, while others make it hard.</p><p>For example, every expression can be rewritten into what is called a
<a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">“Disjunctive Normal Form” (DNF)</a>.
It is called that because it consists of a series of <em>conjunction</em> (<code>&amp;&amp;</code>)
terms, joined together by <em>disjunction</em> (<code>||</code>) operators<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>F_DNF</span>(<span>x</span>, <span>y</span>, <span>z</span> <span>bool</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> (<span>x</span> <span>&amp;&amp;</span> <span>z</span>) <span>||</span> (!<span>y</span> <span>&amp;&amp;</span> <span>z</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>(You can verify that this is the same function as above, by
<a href="https://go.dev/play/p/dCtSs3tf91F">trying out all 8 input combinations</a>)</p><p>Each term has a subset of the arguments, possibly negated, joined by
<code>&amp;&amp;</code>. The terms are then joined together using <code>||</code>.</p><p>Solving the satisfiability problem for an expression in DNF is easy:</p><ol><li>Go through the individual terms. <code>||</code> is <code>true</code> if and only if
either of its operands is <code>true</code>. So for each term:<ul><li>If it contains both an argument and its negation (<code>x &amp;&amp; !x</code>) it can never
be <code>true</code>. Continue to the next term.</li><li>Otherwise, you can infer valid arguments from the term:<ul><li>If it contains <code>x</code>, then we must pass <code>true</code> for <code>x</code></li><li>If it contains <code>!x</code>, then we must pass <code>false</code> for <code>x</code></li><li>If it contains neither, then what we pass for <code>x</code> does not matter and
either value works.</li></ul></li><li>The term then evaluates to <code>true</code> with these arguments, so the entire
expression does.</li></ul></li><li>If none of the terms can be made <code>true</code>, the function can never return
<code>true</code> and there is no valid set of arguments.</li></ol><p>On the other hand, there is also a <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">“Conjunctive Normal Form”
(CNF)</a>. Here, the
expression is a series of <em>disjunction</em> (<code>||</code>) terms, joined together with
<em>conjunction</em> (<code>&amp;&amp;</code>) operators:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>F_CNF</span>(<span>x</span>, <span>y</span>, <span>z</span> <span>bool</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> (!<span>x</span> <span>||</span> <span>z</span>) <span>&amp;&amp;</span> (<span>y</span> <span>||</span> <span>z</span>) <span>&amp;&amp;</span> (<span>x</span> <span>||</span> !<span>y</span>)
</span></span><span><span>}
</span></span></code></pre></div><p>(Again, you can <a href="https://go.dev/play/p/0xldLVGqu7m">verify that this is the same function</a>)</p><p>For this, the idea of our algorithm does not work. To find a solution, you have
to take <em>all terms</em> into account simultaneously. You can’t just tackle them one
by one. In fact, solving satisfiability on CNF (often abbreviated as “CNFSAT”)
is NP-complete<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.</p><p><a href="https://en.wikipedia.org/wiki/Functional_completeness">It turns out</a> that
<em>every</em> boolean function can be written as a single expression using only <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>. In particular, every boolean function has a DNF and a CNF.</p><p>Very often, when we want to prove a problem is hard, we do so by reducing
CNFSAT to it. That’s what we will do for the problem of calculating type sets.
But there is one more preamble we need.</p><h2 id="sets-and-satisfiability">Sets and Satisfiability</h2><p>There is an important relationship between
<a href="https://en.wikipedia.org/wiki/Set_(mathematics)">sets</a> and boolean functions.</p><p>Say we have a type <code>T</code> and a <code>Universe</code> which contains all possible values of
<code>T</code>. If we have a <code>func(T) bool</code>, we can create a set from that, by looking at
all objects for which the function returns <code>true</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>Universe</span> <span>Set</span>[<span>T</span>]
</span></span><span><span>
</span></span><span><span><span>func</span> <span>MakeSet</span>(<span>f</span> <span>func</span>(<span>T</span>) <span>bool</span>) <span>Set</span>[<span>T</span>] {
</span></span><span><span>  <span>s</span> <span>:=</span> make(<span>Set</span>[<span>T</span>])
</span></span><span><span>  <span>for</span> <span>v</span> <span>:=</span> <span>range</span> <span>Universe</span> {
</span></span><span><span>    <span>if</span> <span>f</span>(<span>v</span>) {
</span></span><span><span>      <span>s</span>.<span>Add</span>(<span>v</span>)
</span></span><span><span>    }
</span></span><span><span>  }
</span></span><span><span>  <span>return</span> <span>s</span>
</span></span><span><span>}
</span></span></code></pre></div><p>This set contains exactly all elements for which <code>f</code> is <code>true</code>. So calculating
<code>f(v)</code> is equivalent to checking <code>s.Contains(v)</code>. And checking if <code>s</code> is empty
is equivalent to checking if <code>f</code> can ever return <code>true</code>.</p><p>We can also go the other way around:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>MakeFunc</span>(<span>s</span> <span>Set</span>[<span>T</span>]) <span>func</span>(<span>T</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> <span>func</span>(<span>v</span> <span>T</span>) <span>bool</span> {
</span></span><span><span>    <span>return</span> <span>s</span>.<span>Contains</span>(<span>v</span>)
</span></span><span><span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>So in a sense <code>func(T) bool</code> and <code>Set[T]</code> are “the same thing”. We can
transform a question about one into a question about the other and back.</p><p>As we observed above it is important <em>how</em> a boolean function is given.
To take that into account we have to also convert boolean operators into set
operations:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Union(s, t) contains all elements which are in s *or* in t.
</span></span></span><span><span><span></span><span>func</span> <span>Union</span>(<span>s</span>, <span>t</span> <span>Set</span>[<span>T</span>]) <span>Set</span>[<span>T</span>] {
</span></span><span><span>  <span>return</span> <span>MakeSet</span>(<span>func</span>(<span>v</span> <span>T</span>) <span>bool</span> {
</span></span><span><span>    <span>return</span> <span>s</span>.<span>Contains</span>(<span>v</span>) <span>||</span> <span>t</span>.<span>Contains</span>(<span>v</span>)
</span></span><span><span>  })
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Intersect(s, t) contains all elements which are in s *and* in t.
</span></span></span><span><span><span></span><span>func</span> <span>Intersect</span>(<span>s</span>, <span>t</span> <span>Set</span>[<span>T</span>]) <span>Set</span>[<span>T</span>] {
</span></span><span><span>  <span>return</span> <span>MakeSet</span>(<span>func</span>(<span>v</span> <span>T</span>) <span>bool</span> {
</span></span><span><span>    <span>return</span> <span>s</span>.<span>Contains</span>(<span>v</span>) <span>&amp;&amp;</span> <span>t</span>.<span>Contains</span>(<span>v</span>)
</span></span><span><span>  })
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Complement(s) contains all elements which are *not* in s.
</span></span></span><span><span><span></span><span>func</span> <span>Complement</span>(<span>s</span> <span>Set</span>[<span>T</span>]) <span>Set</span>[<span>T</span>] {
</span></span><span><span>  <span>return</span> <span>MakeSet</span>(<span>func</span>(<span>v</span> <span>T</span>) <span>bool</span> {
</span></span><span><span>    <span>return</span> !<span>s</span>.<span>Contains</span>(<span>v</span>)
</span></span><span><span>  })
</span></span><span><span>}
</span></span></code></pre></div><p>And back:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>// Or creates a function which returns if f or g is true.
</span></span></span><span><span><span></span><span>func</span> <span>Or</span>(<span>f</span>, <span>g</span> <span>func</span>(<span>T</span>) <span>bool</span>) <span>func</span>(<span>T</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> <span>MakeFunc</span>(<span>Union</span>(<span>MakeSet</span>(<span>f</span>), <span>MakeSet</span>(<span>g</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// And creates a function which returns if f and g are true.
</span></span></span><span><span><span></span><span>func</span> <span>And</span>(<span>f</span>, <span>g</span> <span>func</span>(<span>T</span>) <span>bool</span>) <span>func</span>(<span>T</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> <span>MakeFunc</span>(<span>Intersect</span>(<span>MakeSet</span>(<span>f</span>), <span>MakeSet</span>(<span>g</span>)))
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Not creates a function which returns if f is false
</span></span></span><span><span><span></span><span>func</span> <span>Not</span>(<span>f</span> <span>func</span>(<span>T</span>) <span>bool</span>) <span>func</span>(<span>T</span>) <span>bool</span> {
</span></span><span><span>  <span>return</span> <span>MakeFunc</span>(<span>Complement</span>(<span>MakeSet</span>(<span>f</span>)))
</span></span><span><span>}
</span></span></code></pre></div><p>The takeaway from all of this is that constructing a set using <code>Union</code>,
<code>Intersect</code> and <code>Complement</code> is really the same as writing a boolean function
using <code>||</code>, <code>&amp;&amp;</code> and <code>!</code>.</p><p>And proving that a set constructed in this way is empty is the same as proving
that a corresponding boolean function is never <code>true</code>.</p><p>And because checking that a boolean function is never <code>true</code> is NP-complete, so
is checking if one of the sets constructed like this.</p><p>With this, let us look at the specific sets we are interested in.</p><h2 id="basic-interfaces-as-type-sets">Basic interfaces as type sets</h2><p>Interfaces in Go are used to describe sets of types. For example, the interface</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>S</span> <span>interface</span> {
</span></span><span><span>    <span>X</span>()
</span></span><span><span>    <span>Y</span>()
</span></span><span><span>    <span>Z</span>()
</span></span><span><span>}
</span></span></code></pre></div><p>is “the set of all types which have a method <code>X()</code> and a method <code>Y()</code> and a
method <code>Z()</code>”.</p><p>We can also express set intersection, using <a href="https://go.dev/ref/spec#Embedded_interfaces">interface embedding</a>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>S</span> <span>interface</span> { <span>X</span>() }
</span></span><span><span><span>type</span> <span>T</span> <span>interface</span> { <span>Y</span>() }
</span></span><span><span><span>type</span> <span>U</span> <span>interface</span> {
</span></span><span><span>    <span>S</span>
</span></span><span><span>    <span>T</span>
</span></span><span><span>}
</span></span></code></pre></div><p>This expresses the intersection of <code>S</code> and <code>T</code> as an interface. Or we can view
the property “has a method <code>X()</code>” as a boolean variable and think of this as
the formula <code>x &amp;&amp; y</code>.</p><p>Surprisingly, there is also a limited form of negation. It happens implicitly,
because a type can not have two different methods with the same name.
Implicitly, if a type has a method <code>X()</code> it does <em>not</em> have a method <code>X() int</code> for example:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>X</span> <span>interface</span> { <span>X</span>() }
</span></span><span><span><span>type</span> <span>NotX</span> <span>interface</span>{ <span>X</span>() <span>int</span> }
</span></span></code></pre></div><p>There is a small snag: A type can have <em>neither</em> a method <code>X()</code> <em>nor</em> have a
method <code>X() int</code>. That’s why our negation operator is limited. Real boolean
variables are always <em>either</em> <code>true</code> <em>or</em> <code>false</code>, whereas our negation also
allows them to be neither. In mathematics we say that this logic language lacks
<a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">the law of the excluded middle</a>
(also called “Tertium Non Datur” - “there is no third”). For this section, that does not matter. But we have to worry about it later.</p><p>Because we have intersection and negation, we can express interfaces which
could never be satisfied by any type (i.e. which describe an empty type set):</p><p><a href="https://go.dev/play/p/r4kpXNynscX">The compiler rejects such interfaces</a>. But
how can it do that? Did we not say above that checking if a set is empty is
NP-complete?</p><p>The reason this works is that we only have negation and conjunction (<code>&amp;&amp;</code>). So
all the boolean expressions we can build with this language have the form</p><p>These expressions are in DNF! We have a term, which contains a couple of
variables - possibly negated - and joins them together using <code>&amp;&amp;</code>. We don’t
have <code>||</code>, so there is only a single term.</p><p>Solving satisfiability in DNF is easy, as we said. So with the language as we
have described it so far, we can only express type sets which are easy to check
for emptiness.</p><h2 id="adding-unions">Adding unions</h2><p>Go 1.18 extends the interface syntax. For our purposes, the important addition
is the <code>|</code> operator:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>S</span> <span>interface</span>{
</span></span><span><span>    <span>A</span> | <span>B</span>
</span></span><span><span>}
</span></span></code></pre></div><p>This represents the set of all types which are in the <em>union</em> of the type sets
<code>A</code> and <code>B</code> - that is, it is the set of all types which are in <code>A</code> <em>or</em> in <code>B</code>
(or both).</p><p>This means our language of expressible formulas now also includes a
<code>||</code>-operator - we have added set unions and set unions are equivalent to
<code>||</code> in the language of formulas. What’s more, the form of our formula is now a
<em>conjunctive</em> normal form - every line is a term of <code>||</code> and the lines are
connected by <code>&amp;&amp;</code>:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>X</span> <span>interface</span> { <span>X</span>() }
</span></span><span><span><span>type</span> <span>NotX</span> <span>interface</span>{ <span>X</span>() <span>int</span> }
</span></span><span><span><span>type</span> <span>Y</span> <span>interface</span> { <span>Y</span>() }
</span></span><span><span><span>type</span> <span>NotY</span> <span>interface</span>{ <span>Y</span>() <span>int</span> }
</span></span><span><span><span>type</span> <span>Z</span> <span>interface</span> { <span>Z</span>() }
</span></span><span><span><span>type</span> <span>NotZ</span> <span>interface</span>{ <span>Z</span>() <span>int</span> }
</span></span><span><span>
</span></span><span><span><span>// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span><span><span></span><span>type</span> <span>S</span> <span>interface</span> {
</span></span><span><span>    <span>NotX</span> | <span>Z</span>
</span></span><span><span>    <span>Y</span> | <span>Z</span>
</span></span><span><span>    <span>X</span> | <span>NotY</span>
</span></span><span><span>}
</span></span></code></pre></div><p>This is not <em>quite</em> enough to prove NP-completeness though, because of the snag
above. If we want to prove that it is easy, it does not matter that a type can
have neither method. But if we want to prove that it is hard, we really need an
<em>exact</em> equivalence between boolean functions and type sets. So we need to
guarantee that a type has one of our two contradictory methods.</p><p>“Luckily”, the <code>|</code> operator gives us a way to fix that:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> <span>TertiumNonDatur</span> <span>interface</span> {
</span></span><span><span>    <span>X</span> | <span>NotX</span>
</span></span><span><span>    <span>Y</span> | <span>NotY</span>
</span></span><span><span>    <span>Z</span> | <span>NotZ</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// (!x || z) &amp;&amp; (y || z) &amp;&amp; (x || !y)
</span></span></span><span><span><span></span><span>type</span> <span>S</span> <span>interface</span> {
</span></span><span><span>    <span>TertiumNonDatur</span>
</span></span><span><span>
</span></span><span><span>    <span>NotX</span> | <span>Z</span>
</span></span><span><span>    <span>Y</span> | <span>Z</span>
</span></span><span><span>    <span>X</span> | <span>NotY</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Now any type which could possibly implement <code>S</code> <em>must</em> have either an <code>X()</code> or
an <code>X() int</code> method, because it must implement <code>TertiumNonDatur</code> as well. So
this extra interface helps us to get the law of the excluded middle into our
language of type sets.</p><p>With this, checking if a type set is empty is in general as hard as checking if
an arbitrary boolean formula in CNF has no solution. As described above, that
is NP-complete.</p><p>Even worse, we want to define which operations are allowed on a type parameter
by saying that it is allowed if every type in a type set supports it. However,
<a href="https://github.com/golang/go/issues/45346#issuecomment-822330394">that check is also NP-complete</a>.</p><p>The easy way to prove that is to observe that if a type set is empty, <em>every
operator</em> should be allowed on a type parameter constrained by it. Because any
statement about “every element of the empty set“ is true<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>.</p><p>But this would mean that type-checking a generic function would be NP-complete.
If an operator is used, we have to at least check if the type set of its
constraint is empty. Which is NP-complete.</p><h2 id="why-do-we-care">Why do we care?</h2><p>A fair question is “why do we even care? Surely these cases are super exotic.
In any real program, checking this is trivial”.</p><p>That’s true, but there are still reasons to care:</p><ul><li><p>Go has the goal of having a fast compiler. And importantly, one which is
guaranteed to be fast <em>for any program</em>. If I give you a Go program, you can
be reasonably sure that it compiles quickly, in a time frame predictable by
the size of the input.</p><p>If I <em>can</em> craft a program which compiles slowly - and may take longer than
the lifetime of the universe - this is no longer true.</p><p>This is especially important for environments like the Go playground, which
regularly compiles untrusted code.</p></li><li><p>NP complete problems are notoriously hard to debug if they fail.</p><p>If you use Linux, you might have occasionally run into a problem where you
accidentally tried installing conflicting versions of some package. And if
so, you might have noticed that your computer first chugged along for a while
and then gave you an unhelpful error message about the conflict. And maybe
you had trouble figuring out which packages declared the conflicting
dependencies.</p><p>This is typical for NP complete problems. As an exact solution is often too
hard to compute, they rely on heuristics and randomization and it’s hard to
work backwards from a failure.</p></li><li><p>We generally don’t want the correctness of a Go program to depend on the
compiler used. That is, a program should not suddenly stop compiling because
you used a different compiler or the compiler was updated to a new Go
version.</p><p>But NP-complete problems don’t allow us to calculate an exact solution. They
always need some heuristic (even if it is just “give up after a bit”). If we
don’t want the correctness of a program to be implementation defined, that
heuristic must become part of the Go language specification. But these
heuristics are very complex to describe. So we would have to spend a lot of
room in the spec for something which does not give us a very large benefit.</p></li></ul><p>Note that Go also decided to restrict the version constraints a <code>go.mod</code> file
can express, <a href="https://research.swtch.com/version-sat">for exactly the same reasons</a>.
Go has a clear priority, not to require too complicated algorithms in its
compilers and tooling. Not because they are hard to implement, but because the
behavior of complicated algorithms also tends to be hard to understand for
humans.</p><p>So requiring to solve an NP-complete problem is out of the question.</p><h2 id="the-fix">The fix</h2><p>Given that there must not be an NP-complete problem in the language
specification and given that Go 1.18 was released, this problem must have
somehow been solved.</p><p>What changed is that the language for describing interfaces was limited from
what I described above. <a href="https://go.dev/ref/spec#General_interfaces">Specifically</a></p><blockquote><p>Implementation restriction: A union (with more than one term) cannot contain
the predeclared identifier <code>comparable</code> or interfaces that specify methods, or
embed <code>comparable</code> or interfaces that specify methods.</p></blockquote><p>This disallows the main mechanism we used to map formulas to interfaces above.
We can no longer express our <code>TertiumNonDatur</code> type, or the individual <code>|</code>
terms of the formula, as the respective terms specify methods. Without
specifying methods, we can’t get our “implicit negation” to work either.</p><p>The hope is that this change (among a couple of others) is sufficient to ensure
that we can always calculate type sets accurately. Which means I pulled a bit
of a bait-and-switch: I said that calculating type sets is hard. But as they
were actually released, they <em>might not be</em>.</p><p>The reason I wrote this blog post anyways is to explain the <em>kind of problems</em>
that exist in this area. It is easy to say we have solved this problem
<a href="https://www.youtube.com/watch?v=0SYpUSjSgFg">once and for all</a>.</p><p>But to be certain, someone should <em>prove</em> this - either by writing a proof that
the problem is still hard or by writing an algorithm which solves it
efficiently.</p><p>There are also still discussions about changing the generics design. As one
example, the limitations we introduced to fix all of this made
<a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#interface-types-in-union-elements">one of the use cases from the design doc</a>
impossible to express. We might want to tweak the design to allow this use
case. We have to look out in these discussions, so we don’t
re-introduce NP-completeness. It took us some time to even detect it
<a href="https://github.com/golang/go/issues/45346">when the union operator was proposed</a>.</p><p>And there are other kinds of “implicit negations” in the Go language. For
example, a <code>struct</code> can not have both a field <em>and</em> a method with the same
name. Or being one type implies not being another type (so <code>interface{int}</code>
implicitly negates <code>interface{string}</code>).</p><p>All of which is to say that even if the problem might no longer be
NP-complete - I hope that I convinced you it is still more complicated than you
might have thought.</p><p>If you want to discuss this further, you can find links to my social media on
the bottom of this site.</p><hr/><p>I want to thank my beta-readers for helping me improve this article.
Namely
<a href="https://github.com/arnehormann">arnehormann</a>,
<a href="https://twitter.com/johanbrandhorst">@johanbrandhorst</a>,
<a href="https://twitter.com/mvdan_">@mvdan_</a>,
<a href="https://twitter.com/_myitcv">@_myitcv</a>,
<a href="https://mobile.twitter.com/readcodesing">@readcodesing</a>,
<a href="https://twitter.com/rogpeppe">@rogpeppe</a> and
<a href="https://twitter.com/zekjur">@zekjur</a>.</p><p>They took a frankly unreasonable chunk of time out of their day. And their
suggestions were invaluable.</p></div></article></div></div>
  </body>
</html>
