<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://romanliutikov.com/blog/running-clojure-in-wasm">Original</a>
    <h1>Running Clojure in WASM with GraalVM</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <header>
          
          <time datetime="4/26/2025, 1:58:44 PM">Apr 26, 2025</time>
        </header>
        <p>Starting from v25 <a href="https://github.com/oracle/graal">GraalVM</a> added support for <a href="https://webassembly.org/">WASM</a> backend for Java programs compiled to native image, which means that it&#39;s finally becomes possible to compile and run <a href="https://clojure.org/">Clojure</a> programs in WASM!</p>
<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Z2SWSIThHXY?si=uofWsFkvdRs8behE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p>

<p>Although WASM backend is in its early days, and <a href="https://github.com/graalvm/graalvm-demos/issues/346#issuecomment-2774867010">doesn&#39;t support threading and networking</a>, it is already possible to compile and run single-threaded computational programs in Java/Clojure.</p>
<p>If you open browser console now, on this page, you&#39;ll see <code>Hello, World!</code> printed in the console. That&#39;s a Clojure program talking to you :)</p>
<pre><code>(ns core
  (:gen-class))

(defn -main [&amp; args]
  (println &#34;Hello, World!&#34;))
</code></pre>
<h2>Binary size</h2>
<p>The output WASM of this simple program is 5.6MB binary, which can be pruned a bit via <a href="https://github.com/WebAssembly/binaryen?tab=readme-ov-file#wasm-opt"><code>wasm-opt</code> tool</a>, just make sure that it doesn&#39;t break anything for you. Luckily when compressed (gzip, brotli, etc) the binary becomes just ~2.5MB in size.</p>
<p>After running the binary through wasm-opt I got 5MB output, so roughly ~600KB less ones and zeroes.</p>
<pre><code>wasm-opt core.js.wasm -o core.js.wasm -Oz --enable-gc --enable-strings --enable-reference-types --enable-exception-handling --enable-bulk-memory --enable-nontrapping-float-to-int
</code></pre>
<p>In comparison, this basic hello world program in Java results in just 1MB of WASM.</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println(&#34;Hello, World!&#34;);
    }
}
</code></pre>
<p>To give you a sense of how binary size changes with added libraries, using <code>clojure.data.json</code> increases WASM binary by 130KB. Note that if a namespace is required but never used, it&#39;s pruned from the output.</p>
<pre><code>(ns core
  (:require [clojure.data.json :as json])
  (:gen-class))

(defn -main [&amp; args]
  (prn (json/write-str {:a 1 :b 2})))
</code></pre>
<p>For detailed analysis GraalVM provides a build report, that says that 70% of compiled output is heap snapshot and roughly 50% of it is filled with strings and hash maps.</p>
<p>It&#39;s interesting that number of methods chanrt shows that majority, 60% of methods are coming from various Java namespaces, while Clojure only occupies 17% of methods.</p>
<img src="https://romanliutikov.com/blog/clj-wasm-graal-build-report.jpg"/>

<p>Here&#39;s the full interactive build report of the WASM binary running on this page.</p>


<h2>Speed</h2>
<p>Running unoptimized binary via Node 23.9.0</p>
<pre><code>- big reduce:         {:total-ops 10**1, :total-time 2.6s, :per-op-time 256.3ms}
- int/float division: {:total-ops 10**7, :total-time 763.2ms, :per-op-time 76ns}
- float division:     {:total-ops 10**7, :total-time 398.9ms, :per-op-time 39ns}
- integer division:   {:total-ops 10**7, :total-time 45.2ms, :per-op-time 4ns}
</code></pre>
<p>Optimized binary runs about 10% faster.</p>
<pre><code>wasm-opt core.js.wasm -o core.js.wasm -O4 --enable-gc --enable-strings --enable-reference-types --enable-exception-handling --enable-bulk-memory --enable-nontrapping-float-to-int
</code></pre>
<pre><code>- big reduce:         {:total-ops 10**1, :total-time 2.3s, :per-op-time 226.0ms}
- int/float division: {:total-ops 10**7, :total-time 646.6ms, :per-op-time 64ns}
- float division:     {:total-ops 10**7, :total-time 348.0ms, :per-op-time 34ns}
- integer division:   {:total-ops 10**7, :total-time 45.3ms, :per-op-time 4ns}
</code></pre>
<p>You can run the benchmark yourself on this page, press the button below and wait for logs in the console</p>


<p>Same Clojure code, compiled as native image, run 2-3x faster than WASM version</p>
<pre><code>- big reduce:         {:total-ops 10**1, :total-time 1.0s, :per-op-time 102.0ms}
- int/float division: {:total-ops 10**7, :total-time 248.9ms, :per-op-time 24ns}
- float division:     {:total-ops 10**7, :total-time 87.2ms, :per-op-time 8ns}
- integer division:   {:total-ops 10**7, :total-time 19.8ms, :per-op-time 1ns}
</code></pre>
<p>Running the benchmark via Clojure CLI on OpenJDK Temurin-21.0.7+6 runs significantly faster, from 5x to 12x faster to be precise</p>
<pre><code>- big reduce:         {:total-ops 10**2, :total-time 1.8s, :per-op-time 18.2ms}
- int/float division: {:total-ops 10**7, :total-time 326.1ms, :per-op-time 32ns}
- float division:     {:total-ops 10**7, :total-time 86.8ms, :per-op-time 8ns}
- integer division:   {:total-ops 10**7, :total-time 24.0ms, :per-op-time 2ns}
</code></pre>
<p>And finally here&#39;s the same code compiled as ClojureScript running on Node 23.9.0, 5x faster than WASM version</p>
<pre><code>- big reduce:         {:total-ops 10**2, :total-time 4s, :per-op-time 41ms}
- int/float division: {:total-ops 10**7, :total-time 40ms, :per-op-time 4ns}
- float division:     {:total-ops 10**7, :total-time 39ms, :per-op-time 3ns}
- integer division:   {:total-ops 10**7, :total-time 39ms, :per-op-time 3ns}
</code></pre>
<p>Which brings us to the following very scientific performance chart:</p>
<img src="https://romanliutikov.com/blog/wasm-clj-perf-chart.jpg"/>

<p>I&#39;m no expert on WASM and GraalVM, so can&#39;t really tell anything in defence of it, but I was also surprised that native image runs slower. Of course there&#39;s JVM startup but that&#39;s a different story.</p>
<h2>Interop with host environment</h2>
<p>Ok, now try to press this button...</p>



<p>What you see is an example of WASM&lt;-&gt;JavaScript interop. Let&#39;s have a look how this is implemented with GraalVM.</p>
<pre><code>(ns core
  (:import [browser Browser Callback]
           [org.graalvm.webimage.api JSObject])
  (:gen-class))

(defn as-callback [f]
  (reify Callback
    (run [this value]
      (f value))))

(defn invoke-method [^JSObject object ^String method &amp; args]
  (.call ^JSObject (.get object method) object (object-array args)))

(defn -main [&amp; args]
 (Browser/main)
 (let [window (Browser/globalThis)
       root (Browser/querySelector &#34;#btn-root&#34;)
       button (Browser/createElement &#34;button&#34;)
       on-click (fn [event]
                  (invoke-method window &#34;alert&#34; &#34;Hello, from Clojure in WASM!&#34;))]
   (.set button &#34;textContent&#34; &#34;Press me&#34;)
   (Browser/addEventListener button &#34;click&#34; (as-callback on-click))
   (Browser/appendChild root button)))
</code></pre>
<p>The main part here is the <code>-main</code> function. This is your typical imperative DOM manipulation: create a button element, add text child, assign event listener and insert the element into the DOM. <code>invoke-method</code> is a helper that executes object methods and <code>as-callback</code> wraps event handler into an object that implements <code>Callback</code> interface. The purpose of this interface is somewhat similar to <code>java.lang.Runnable</code>.</p>
<p>That was user facing code, now let&#39;s take a look at the &#34;backend&#34; â€” the interop layer. First of all, <a href="https://github.com/oracle/graal/tree/master/web-image/src/org.graalvm.webimage.api/src/org/graalvm/webimage/api"><code>org.graalvm.webimage.api</code></a> provides a set of classes that define various ways of accessing JavaScript environment.</p>
<p>The <code>Callback</code> interface has to be a functional interface. Notice that its <code>run</code> method takes an argument of type <code>JSObject</code>.</p>
<pre><code>package browser;

import org.graalvm.webimage.api.JSObject;

@FunctionalInterface
public interface Callback {
    void run(JSObject event);
}
</code></pre>
<p>And finally the <code>Browser</code> class, that&#39;s where DOM API is declared for WASM side of things.</p>
<pre><code>package browser;

import org.graalvm.webimage.api.JS;
import org.graalvm.webimage.api.JSObject;

public class Browser {
    public static void main() {
        try {
            // TODO GR-62854 Here to ensure run is generated. Remove once
            // objects passed to @JS methods automatically have their SAM registered.
            sink(Callback.class.getDeclaredMethod(&#34;run&#34;, JSObject.class));
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }

    @JS(&#34;&#34;)
    private static native void sink(Object o);

    @JS.Coerce
    @JS(&#34;return globalThis;&#34;)
    public static native JSObject globalThis();

    @JS.Coerce
    @JS(&#34;return document.querySelector(selector);&#34;)
    public static native JSObject querySelector(String selector);

    @JS.Coerce
    @JS(&#34;return document.createElement(tag);&#34;)
    public static native JSObject createElement(String tag);

    @JS.Coerce
    @JS(&#34;return parent.appendChild(child);&#34;)
    public static native void appendChild(JSObject parent, JSObject child);

    @JS.Coerce
    @JS(&#34;element.addEventListener(eventType, handler);&#34;)
    public static native void addEventListener(JSObject element, String eventType, Callback handler);
}
</code></pre>
<p>This interfacing code is quite simple. <code>@JS</code> decorator takes a string of JavaScript code that will be generated as a part of JS runtime, and <code>native</code> Java method will be bound to that JS code on WASM side.</p>
<pre><code>@JS.Coerce
@JS(&#34;return document.createElement(tag);&#34;)
public static native JSObject createElement(String tag);
</code></pre>
<p>You have to make sure that both JS and Java declarations use the same method names, and classes are compiled with <code>-parameters</code> flag to preserve arguments names in the bytecode.</p>
<p>The benchmark button on this page calls into WASM binary. Here&#39;s how you can export Clojure function into browser&#39;s global scope.</p>
<pre><code>(.set (Browser/globalThis) &#34;runBenchmark&#34;
  (as-callback (fn [_] (run-benchmark))))
</code></pre>
<p>The <code>main</code> method of the <code>Browser</code> class registers methods of the <code>Callback</code> interface, so they are not removed after compilation. This should go away eventually.</p>
<p>You can find the complete Clojure setup in <a href="https://github.com/roman01la/graal-clojure-wasm">roman01la/graal-clojure-wasm</a> repo.</p>


      </article>
      
      
    </div></div>
  </body>
</html>
