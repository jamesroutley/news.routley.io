<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/jackdoe/pico2-swd-riscv">Original</a>
    <h1>Vibe Code Warning – A personal casestudy</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div dir="auto"><a id="user-content-pico2-swd-riscv" aria-label="Permalink: pico2-swd-riscv" href="#pico2-swd-riscv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A stateful SWD protocol implementation for debugging RP2350 RISC-V cores (Hazard3) from any Raspberry Pi Pico2 (target) using GPIO&#39;s on another Pico (probe).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">0. VIBE CODE WARNING (WRITTEN BY HUMAN)</h2><a id="user-content-0-vibe-code-warning-written-by-human" aria-label="Permalink: 0. VIBE CODE WARNING (WRITTEN BY HUMAN)" href="#0-vibe-code-warning-written-by-human"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">About 80% of the code is vibe coded; The readme is almost completely generated (except the whole vibe-code-warning section). I spent many nights with the oscilloscope and the docs and made a working prototype that was able ti do sba/read/write regs and do abstract commands and progbuf, the rest was done with claude code. The tests are quite <a href="https://thornberry.io/jackdoe/pico2-swd-riscv/blob/master/examples/test_suite">comprehensive test suite</a> and I use the core of the library in my own projects, but, as they say, &#34;hic sunt dracones&#34;. I also read the readme and the code didn&#39;t notice anything wrong (and removed the wrong/unclear parts).</p>
<p dir="auto">This project was my casestudy of vibecoding a more complicated project that I dont understand 100% and there is no obvious existing code that can be &#34;used&#34;. It started as ~1000 loc that I have written and knew very well, reading the rp2350, arm swd and riscv debug docs, capturing data with oscilloscope and openocd then decoding it and analyzing the wakeup sequence and then read/write commands. After I got it working I gave it to claude to make it into a library that I can use in other projects, and then I slowly built it up.</p>
<p dir="auto">After about 3-4k lines of code I completely lost track of what is going on, and I woudn&#39;t consider this code that I have written, but adding more and more tests felt &#34;nice&#34;, or at least reassuring.</p>
<p dir="auto">There was a some gaslighting, particularly when it misunderstood dap_read_mem32 thinking it is reading from ram and not MEM-AP TAR/DRW/RDBUFF protocol, which lead to incredible amount of nonsense.</p>
<p dir="auto">Overall I would say it was a horrible experience, even though it took 10 hours to write close to 10000 lines of code, I don&#39;t consider this my project, and I have no sense of acomplishment or growth.</p>
<p dir="auto">In contrast, using AI to read all the docs (which are thousands of pages) and write helpful scripts to decode the oscilloscope data, create packed C structs from docs and etc, was very nice, and I did feel good after. The moment I read the first register and then when I was able to read memory via SBA I felt amazing.</p>
<p dir="auto">The main issue is <code>taste</code>, when I write code I feel if its good or bad, as I am writing it, I know if its wrong, but using claude code I get desensitized very quickly and I just can&#39;t tell, it &#34;reads&#34; OK, but I don&#39;t know how it feels. In this case it happened when the code grew about 4x, from 1k to 4k lines. And worse of all, my mental model of the code is completely gone, and with it my ownership.</p>
<p dir="auto"><strong>The tokens have no reason or purpose</strong>, which makes reading code ridiculously difficult, as and each token can be complete nonsense. When reading human code the symbols have a purpose, someone thought &#34;I will put this in a variable, later I will check its status.&#34;, so I pretend I am them, and think <code>why</code> would they have written this? Shortly after I understand, as they are human and I am human. But the AI symbols have no reason, and worse of all, they all look deceptively correct, so I have to think 10 times harder if it is wrong. With any human code (including your own) it is quite easy to gauge how much you can trust it, and it is quite consistent, with the AI code, one function can be much better than what you woudld&#39;ve written, and the code 2 lines below can be cargo culted gunk that looks incredibly good, but is structurally wrong.</p>
<p dir="auto">In the end I would say I have gained good understanding of the wires, timings, and the lower level ap/dp mechanics, sba and progbuf, but I regret not writing the whole thing myself, even if it would&#39;ve taken 10x the time.</p>
<p dir="auto">I fucking hate this.</p>
<p dir="auto">And I can not help, but feel dusgust and shame. Is this what programming is now? I really hope this is some intermediate stage and it changes for the better, the problem is I dont know what &#34;better&#34; is, it seems for some people is not writing the code, for others is not modeling the problem and for third is not having to think. For me, I am not sure, I do want to make things, and many times I dont want to know something, but I want to use it, e.g. the rp2350 usb host controller the way you have to re-arm interrupts and the way the epx register is shared is super annoying, for good reasons probably, but I just want to use it to make my CBI driver.</p>
<p dir="auto">I guess the question is what is the thing I want to make, because you can go way up the stack, from the USB chip registers to CBI to UFI to FAT16 to the OS of the old school computer I am making, but why stop? make the schematics, the pcbs, the cad files, maybe automatically send it to the factory? and then just ship it to me? but why stop? make my webshop, start selling, make a community, ads, marketing, generate some unboxing videos, maybe some viral memes? process the orders directly to the factory, on demand, if there is an issue, it is ready with customer support.</p>
<p dir="auto">What do I do in the meanwhile? Sit on the beach? I hate the beach.</p>
<p dir="auto">Where does it stop?</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">1. ARCHITECTURAL OVERVIEW</h2><a id="user-content-1-architectural-overview" aria-label="Permalink: 1. ARCHITECTURAL OVERVIEW" href="#1-architectural-overview"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This library implements a complete three-layer abstraction for Serial Wire Debug protocol communication with RP2350&#39;s RISC-V Debug Module, modeled after the Debug Access Port specification and informed by ARM Debug Interface Architecture Specification v5.2.</p>
<div data-snippet-clipboard-copy-content="┌────────────────────────────────────────┐
│  Application Layer                     │
│  (User Code)                           │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Debug Module Layer (rp2350.c)         │
│  - RISC-V Debug Specification v0.13    │
│  - Hart control via DMCONTROL          │
│  - Abstract commands for GPR access    │
│  - System Bus Access (non-intrusive)   │
│  - PROGBUF execution for CSR access    │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Debug Access Port Layer (dap.c)       │
│  - DP/AP register transactions         │
│  - RP2350-specific DP_SELECT encoding  │
│  - Bank selection caching              │
│  - Memory-mapped debug register access │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Serial Wire Debug Layer (swd*.c)      │
│  - 2-wire bidirectional protocol       │
│  - PIO state machine bit-banging       │
│  - Request/ACK/Data phase handling     │
│  - Parity computation and verification │
│  - Line reset and dormant sequences    │
└────────────────────────────────────────┘"><pre><code>┌────────────────────────────────────────┐
│  Application Layer                     │
│  (User Code)                           │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Debug Module Layer (rp2350.c)         │
│  - RISC-V Debug Specification v0.13    │
│  - Hart control via DMCONTROL          │
│  - Abstract commands for GPR access    │
│  - System Bus Access (non-intrusive)   │
│  - PROGBUF execution for CSR access    │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Debug Access Port Layer (dap.c)       │
│  - DP/AP register transactions         │
│  - RP2350-specific DP_SELECT encoding  │
│  - Bank selection caching              │
│  - Memory-mapped debug register access │
└────────────────┬───────────────────────┘
                 │
┌────────────────▼───────────────────────┐
│  Serial Wire Debug Layer (swd*.c)      │
│  - 2-wire bidirectional protocol       │
│  - PIO state machine bit-banging       │
│  - Request/ACK/Data phase handling     │
│  - Parity computation and verification │
│  - Line reset and dormant sequences    │
└────────────────────────────────────────┘
</code></pre></div>
<p dir="auto">The separation of concerns follows classical protocol stack design: each layer exposes a well-defined interface and maintains independent state, with lower layers unaware of higher-layer semantics.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">2. RISC-V DEBUG ARCHITECTURE: A FORMAL MODEL</h2><a id="user-content-2-risc-v-debug-architecture-a-formal-model" aria-label="Permalink: 2. RISC-V DEBUG ARCHITECTURE: A FORMAL MODEL" href="#2-risc-v-debug-architecture-a-formal-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Before examining the protocol implementation, we must establish the theoretical foundations of RISC-V external debugging. This section develops the debug architecture from first principles, following the RISC-V External Debug Support Specification v0.13.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.A The Hart State Machine</h3><a id="user-content-2a-the-hart-state-machine" aria-label="Permalink: 2.A The Hart State Machine" href="#2a-the-hart-state-machine"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A RISC-V hart (hardware thread) exists in one of three abstract states:</p>
<div data-snippet-clipboard-copy-content="                    ┌─────────────┐
                    │   RUNNING   │
                    │  (Normal)   │
                    └──────┬──────┘
                           │
                  halt_request, ebreak,
                  trigger_fire, step_complete
                           │
                           ▼
                    ┌─────────────┐
                    │   HALTED    │
                    │  (Debug)    │
                    └──────┬──────┘
                           │
                     resume_request
                           │
                           ▼
                    ┌─────────────┐
                    │  RESUMING   │
                    │ (Transient) │
                    └──────┬──────┘
                           │
                           ▼
                    ┌─────────────┐
                    │   RUNNING   │
                    └─────────────┘"><pre><code>                    ┌─────────────┐
                    │   RUNNING   │
                    │  (Normal)   │
                    └──────┬──────┘
                           │
                  halt_request, ebreak,
                  trigger_fire, step_complete
                           │
                           ▼
                    ┌─────────────┐
                    │   HALTED    │
                    │  (Debug)    │
                    └──────┬──────┘
                           │
                     resume_request
                           │
                           ▼
                    ┌─────────────┐
                    │  RESUMING   │
                    │ (Transient) │
                    └──────┬──────┘
                           │
                           ▼
                    ┌─────────────┐
                    │   RUNNING   │
                    └─────────────┘
</code></pre></div>
<p dir="auto"><strong>State 1: RUNNING</strong> - The hart executes instructions from main memory. PC advances according to program flow. All architectural state (GPRs, CSRs, memory) is accessible to the executing program.</p>
<p dir="auto"><strong>State 2: HALTED</strong> - The hart has entered debug mode. No instructions from main memory execute. The hart is &#34;parked&#34; in a special debug ROM or implicit debug loop within the Debug Module. Debug-specific CSRs (DPC, DCSR, DSCRATCH) become accessible.</p>
<p dir="auto"><strong>State 3: RESUMING</strong> - A transient state where the hart has received a resume request but has not yet returned to normal execution. This state exists to model the asynchronous nature of resume operations.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.B The Debug Module: An Independent Controller</h3><a id="user-content-2b-the-debug-module-an-independent-controller" aria-label="Permalink: 2.B The Debug Module: An Independent Controller" href="#2b-the-debug-module-an-independent-controller"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Module (DM) is a hardware block separate from the hart itself. It acts as a &#34;shadow controller&#34; that can:</p>
<ol dir="auto">
<li><strong>Observe hart state</strong> without halting (DMSTATUS register)</li>
<li><strong>Command hart transitions</strong> (halt, resume, reset via DMCONTROL)</li>
<li><strong>Access hart registers</strong> when halted (abstract commands)</li>
<li><strong>Access system memory</strong> independently of hart state (System Bus Access)</li>
</ol>
<p dir="auto">The DM is itself controlled by an external debugger via a Debug Transport Module (DTM). In our case, the DTM is the SWD interface.</p>
<div data-snippet-clipboard-copy-content="┌──────────────────────────────────────────────────┐
│  External Debugger (Host CPU)                    │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼ SWD Protocol
┌──────────────────────────────────────────────────┐
│  Debug Transport Module (DTM)                    │
│  - Exposes DM registers as memory-mapped space   │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼ Internal Bus
┌──────────────────────────────────────────────────┐
│  Debug Module (DM)                               │
│  ┌──────────────┐  ┌──────────────┐              │
│  │  Abstract    │  │  System Bus  │              │
│  │  Command     │  │  Master      │              │
│  │  Engine      │  │              │              │
│  └──────┬───────┘  └──────┬───────┘              │
│         │                 │                      │
└─────────┼─────────────────┼──────────────────────┘
          │                 │
          ▼                 ▼
    ┌─────────────┐   ┌──────────────┐
    │  Hart 0     │   │ System Bus   │
    │  (Hazard3)  │   │              │
    ├─────────────┤   └──────────────┘
    │  Hart 1     │
    │  (Hazard3)  │
    └─────────────┘    "><pre><code>┌──────────────────────────────────────────────────┐
│  External Debugger (Host CPU)                    │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼ SWD Protocol
┌──────────────────────────────────────────────────┐
│  Debug Transport Module (DTM)                    │
│  - Exposes DM registers as memory-mapped space   │
└────────────────────┬─────────────────────────────┘
                     │
                     ▼ Internal Bus
┌──────────────────────────────────────────────────┐
│  Debug Module (DM)                               │
│  ┌──────────────┐  ┌──────────────┐              │
│  │  Abstract    │  │  System Bus  │              │
│  │  Command     │  │  Master      │              │
│  │  Engine      │  │              │              │
│  └──────┬───────┘  └──────┬───────┘              │
│         │                 │                      │
└─────────┼─────────────────┼──────────────────────┘
          │                 │
          ▼                 ▼
    ┌─────────────┐   ┌──────────────┐
    │  Hart 0     │   │ System Bus   │
    │  (Hazard3)  │   │              │
    ├─────────────┤   └──────────────┘
    │  Hart 1     │
    │  (Hazard3)  │
    └─────────────┘    
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.C Debug Mode: A Privileged Exception Context</h3><a id="user-content-2c-debug-mode-a-privileged-exception-context" aria-label="Permalink: 2.C Debug Mode: A Privileged Exception Context" href="#2c-debug-mode-a-privileged-exception-context"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When a hart enters debug mode, it is not simply &#34;stopped.&#34; Rather, it enters a special execution context analogous to an exception handler:</p>
<ol dir="auto">
<li><strong>PC is saved</strong> to DPC (Debug Program Counter, CSR 0x7b1)</li>
<li><strong>Privilege level</strong> is elevated to M-mode (Machine mode, highest privilege)</li>
<li><strong>DCSR.cause</strong> records the entry reason (halt request, ebreak, trigger, etc.)</li>
<li><strong>Hart begins executing</strong> from the debug exception vector (typically in debug ROM)</li>
</ol>
<p dir="auto">The debug exception vector contains a tight polling loop that repeatedly checks for commands from the Debug Module. This loop is architecturally invisible to the debugger—we simply observe the hart as &#34;halted.&#34;</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.D Abstract Commands: The Debug Module API</h3><a id="user-content-2d-abstract-commands-the-debug-module-api" aria-label="Permalink: 2.D Abstract Commands: The Debug Module API" href="#2d-abstract-commands-the-debug-module-api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Abstract Command mechanism provides a hardware-implemented function call interface. Each abstract command is a 32-bit word written to the COMMAND register that encodes:</p>
<div data-snippet-clipboard-copy-content="31                            24 23                            0
┌────────────────────────────────┬────────────────────────────────┐
│         cmdtype                │         command-specific       │
└────────────────────────────────┴────────────────────────────────┘"><pre><code>31                            24 23                            0
┌────────────────────────────────┬────────────────────────────────┐
│         cmdtype                │         command-specific       │
└────────────────────────────────┴────────────────────────────────┘
</code></pre></div>
<p dir="auto"><strong>cmdtype=0</strong>: Access Register</p>
<div data-snippet-clipboard-copy-content="31      24 23          20 19 18 17 16 15                          0
┌──────────┬─────────────┬─┬──┬──┬──┬──────────────────────────────┐
│    0     │   aarsize   │0│pc│tr│wr│         regno                │
└──────────┴─────────────┴─┴──┴──┴──┴──────────────────────────────┘

aarsize: Access size (2 = 32-bit)
aarpostincrement: Ignored
postexec: Execute program buffer after transfer
transfer: Perform the transfer (1=yes)
write: Direction (1=write, 0=read)
regno: Register number (0x1000-0x101f for GPRs x0-x31)"><pre><code>31      24 23          20 19 18 17 16 15                          0
┌──────────┬─────────────┬─┬──┬──┬──┬──────────────────────────────┐
│    0     │   aarsize   │0│pc│tr│wr│         regno                │
└──────────┴─────────────┴─┴──┴──┴──┴──────────────────────────────┘

aarsize: Access size (2 = 32-bit)
aarpostincrement: Ignored
postexec: Execute program buffer after transfer
transfer: Perform the transfer (1=yes)
write: Direction (1=write, 0=read)
regno: Register number (0x1000-0x101f for GPRs x0-x31)
</code></pre></div>
<p dir="auto">The Debug Module hardware interprets this command and performs the register access autonomously. From the debugger&#39;s perspective, this is a synchronous operation: write COMMAND, poll ABSTRACTCS.busy until clear, read result from DATA0.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.E The Program Buffer: A Programmable Exception Handler</h3><a id="user-content-2e-the-program-buffer-a-programmable-exception-handler" aria-label="Permalink: 2.E The Program Buffer: A Programmable Exception Handler" href="#2e-the-program-buffer-a-programmable-exception-handler"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Program Buffer (PROGBUF) is a small instruction memory (2-16 entries) within the Debug Module. When abstract commands cannot accomplish a task (e.g., accessing debug-only CSRs), the debugger can:</p>
<ol dir="auto">
<li>Write RISC-V instructions to PROGBUF</li>
<li>Issue an abstract command with the <code>postexec</code> bit set</li>
<li>The hart executes PROGBUF instructions while still in debug mode</li>
<li>The final <code>ebreak</code> instruction returns control to the Debug Module</li>
</ol>
<p dir="auto">This is not a &#34;code injection&#34; attack—the hart never leaves debug mode. It&#39;s analogous to a debugger writing instructions into a trap handler&#39;s stack frame.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.F System Bus Access: A Parallel Execution Path</h3><a id="user-content-2f-system-bus-access-a-parallel-execution-path" aria-label="Permalink: 2.F System Bus Access: A Parallel Execution Path" href="#2f-system-bus-access-a-parallel-execution-path"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">SBA provides a second path to memory that bypasses the hart entirely:</p>
<div data-snippet-clipboard-copy-content="         Debugger Commands
                │
                ▼
         ┌─────────────┐
         │     DM      │
         └──┬───────┬──┘
            │       │
   ┌────────┘       └───────┐
   │                        │
   ▼ Abstract Cmd           ▼ SBA
┌──────┐                ┌─────────┐
│ Hart │───────────────▶│ Memory  │
└──────┘  Hart Accesses └─────────┘"><pre><code>         Debugger Commands
                │
                ▼
         ┌─────────────┐
         │     DM      │
         └──┬───────┬──┘
            │       │
   ┌────────┘       └───────┐
   │                        │
   ▼ Abstract Cmd           ▼ SBA
┌──────┐                ┌─────────┐
│ Hart │───────────────▶│ Memory  │
└──────┘  Hart Accesses └─────────┘
</code></pre></div>
<p dir="auto">The hart and SBA compete for memory bus bandwidth. The hart&#39;s view of memory may differ from SBA&#39;s view due to:</p>
<ol dir="auto">
<li><strong>Cache</strong>: Hart caches writes; SBA sees stale memory</li>
<li><strong>MMU/PMP</strong>: Hart accesses are translated/protected; SBA bypasses</li>
<li><strong>Atomicity</strong>: Hart&#39;s atomic operations (LR/SC) are invisible to SBA</li>
</ol>
<p dir="auto">This is not a bug—it&#39;s a fundamental architectural trade-off. SBA provides speed and non-intrusiveness at the cost of coherency guarantees.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">2.G The Debugging Contract</h3><a id="user-content-2g-the-debugging-contract" aria-label="Permalink: 2.G The Debugging Contract" href="#2g-the-debugging-contract"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RISC-V debugging rests on several invariants:</p>
<p dir="auto"><strong>Invariant 1: Debug Mode is Atomic</strong>
While in debug mode, the hart executes no instructions from main memory. The debugger has exclusive control.</p>
<p dir="auto"><strong>Invariant 2: Architectural Transparency</strong>
Entering and exiting debug mode does not change architected state (except DPC/DCSR). The program cannot detect it was halted (modulo real-time constraints).</p>
<p dir="auto"><strong>Invariant 3: Debug Privilege</strong>
Debug mode executes at maximum privilege (M-mode). All memory is accessible, all CSRs are readable.</p>
<p dir="auto"><strong>Invariant 4: No Interrupts in Debug</strong>
Interrupts are masked while in debug mode. The debugger must explicitly re-enable them.</p>
<p dir="auto">These invariants enable reproducible debugging: halting twice at the same PC should show identical state.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">3. THE SERIAL WIRE DEBUG PROTOCOL</h2><a id="user-content-3-the-serial-wire-debug-protocol" aria-label="Permalink: 3. THE SERIAL WIRE DEBUG PROTOCOL" href="#3-the-serial-wire-debug-protocol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Serial Wire Debug (SWD) is a 2-wire replacement for JTAG&#39;s 5-wire interface, developed by ARM. The protocol operates over two signals:</p>
<ul dir="auto">
<li><strong>SWCLK</strong>: Clock signal driven by the debugger (host)</li>
<li><strong>SWDIO</strong>: Bidirectional data signal with turnaround phases</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">3.A Protocol Packet Structure</h3><a id="user-content-3a-protocol-packet-structure" aria-label="Permalink: 3.A Protocol Packet Structure" href="#3a-protocol-packet-structure"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Each SWD transaction consists of three phases:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Request Phase</strong> (8 bits, host drives SWDIO):</p>
<div data-snippet-clipboard-copy-content="Bit 0:     Start (always 1)
Bit 1:     APnDP (0=DP access, 1=AP access)
Bit 2:     RnW (0=Write, 1=Read)
Bit 3-4:   A[3:2] (register address bits)
Bit 5:     Parity (even parity of bits 1-4)
Bit 6:     Stop (always 0)
Bit 7:     Park (always 1)"><pre><code>Bit 0:     Start (always 1)
Bit 1:     APnDP (0=DP access, 1=AP access)
Bit 2:     RnW (0=Write, 1=Read)
Bit 3-4:   A[3:2] (register address bits)
Bit 5:     Parity (even parity of bits 1-4)
Bit 6:     Stop (always 0)
Bit 7:     Park (always 1)
</code></pre></div>
</li>
<li>
<p dir="auto"><strong>Acknowledge Phase</strong> (3 bits, target drives SWDIO):</p>
<div data-snippet-clipboard-copy-content="OK    (001): Transaction accepted
WAIT  (010): Target requests retry
FAULT (100): Error condition"><pre><code>OK    (001): Transaction accepted
WAIT  (010): Target requests retry
FAULT (100): Error condition
</code></pre></div>
</li>
<li>
<p dir="auto"><strong>Data Phase</strong> (33 bits, direction depends on RnW):</p>
<div data-snippet-clipboard-copy-content="Bits 0-31: Data word
Bit 32:    Parity bit"><pre><code>Bits 0-31: Data word
Bit 32:    Parity bit
</code></pre></div>
</li>
</ol>
<p dir="auto">Turnaround cycles (host releases SWDIO, target can drive) occur between request→ack and during data phase direction changes.</p>
<p dir="auto">Our implementation of the packet construction is in <code>swd_protocol.c:97-113</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="static uint8_t make_swd_request(bool APnDP, bool RnW, uint8_t addr) {
    uint8_t a2 = (addr &gt;&gt; 2) &amp; 1;
    uint8_t a3 = (addr &gt;&gt; 3) &amp; 1;
    uint8_t parity = (APnDP + RnW + a2 + a3) &amp; 1;

    uint8_t request = 0;
    request |= (1 &lt;&lt; 0);          // Start bit
    request |= (APnDP &lt;&lt; 1);      // AP/DP select
    request |= (RnW &lt;&lt; 2);        // Read/Write
    request |= (a2 &lt;&lt; 3);         // Address bit 2
    request |= (a3 &lt;&lt; 4);         // Address bit 3
    request |= (parity &lt;&lt; 5);     // Parity
    request |= (0 &lt;&lt; 6);          // Stop bit
    request |= (1 &lt;&lt; 7);          // Park bit
    return request;
}"><pre><span>static</span> <span>uint8_t</span> <span>make_swd_request</span>(<span>bool</span> <span>APnDP</span>, <span>bool</span> <span>RnW</span>, <span>uint8_t</span> <span>addr</span>) {
    <span>uint8_t</span> <span>a2</span> <span>=</span> (<span>addr</span> &gt;&gt; <span>2</span>) <span>&amp;</span> <span>1</span>;
    <span>uint8_t</span> <span>a3</span> <span>=</span> (<span>addr</span> &gt;&gt; <span>3</span>) <span>&amp;</span> <span>1</span>;
    <span>uint8_t</span> <span>parity</span> <span>=</span> (<span>APnDP</span> <span>+</span> <span>RnW</span> <span>+</span> <span>a2</span> <span>+</span> <span>a3</span>) <span>&amp;</span> <span>1</span>;

    <span>uint8_t</span> <span>request</span> <span>=</span> <span>0</span>;
    <span>request</span> |= (<span>1</span> &lt;&lt; <span>0</span>);          <span>// Start bit</span>
    <span>request</span> |= (<span>APnDP</span> &lt;&lt; <span>1</span>);      <span>// AP/DP select</span>
    <span>request</span> |= (<span>RnW</span> &lt;&lt; <span>2</span>);        <span>// Read/Write</span>
    <span>request</span> |= (<span>a2</span> &lt;&lt; <span>3</span>);         <span>// Address bit 2</span>
    <span>request</span> |= (<span>a3</span> &lt;&lt; <span>4</span>);         <span>// Address bit 3</span>
    <span>request</span> |= (<span>parity</span> &lt;&lt; <span>5</span>);     <span>// Parity</span>
    <span>request</span> |= (<span>0</span> &lt;&lt; <span>6</span>);          <span>// Stop bit</span>
    <span>request</span> |= (<span>1</span> &lt;&lt; <span>7</span>);          <span>// Park bit</span>
    <span>return</span> <span>request</span>;
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">3.B PIO-Based Physical Layer</h3><a id="user-content-3b-pio-based-physical-layer" aria-label="Permalink: 3.B PIO-Based Physical Layer" href="#3b-pio-based-physical-layer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Unlike software bit-banging (which suffers from timing jitter and CPU overhead), this implementation uses RP2040/RP2350&#39;s Programmable I/O (PIO) blocks for deterministic timing.</p>
<p dir="auto">The PIO program (<code>swd.pio</code>) implements a command-based interface where each FIFO entry encodes either a command or data payload. Command format:</p>
<div data-snippet-clipboard-copy-content="Bits 0-7:   Bit count - 1
Bit 8:      Direction (0=input, 1=output)
Bits 9-13:  Target instruction address"><pre><code>Bits 0-7:   Bit count - 1
Bit 8:      Direction (0=input, 1=output)
Bits 9-13:  Target instruction address
</code></pre></div>
<p dir="auto">The state machine operates at 4 cycles per clock period, providing precise SWCLK generation independent of system clock frequency. See <code>swd.pio:45-68</code> for the complete implementation.</p>
<p dir="auto">Clock divider calculation (<code>swd_protocol.c:313-330</code>) accounts for this 4-cycle period:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t clk_sys_khz = clock_get_hz(clk_sys) / 1000;
uint32_t divider = (((clk_sys_khz + freq_khz - 1) / freq_khz) + 3) / 4;"><pre><span>uint32_t</span> <span>clk_sys_khz</span> <span>=</span> <span>clock_get_hz</span>(<span>clk_sys</span>) / <span>1000</span>;
<span>uint32_t</span> <span>divider</span> <span>=</span> (((<span>clk_sys_khz</span> <span>+</span> <span>freq_khz</span> <span>-</span> <span>1</span>) / <span>freq_khz</span>) <span>+</span> <span>3</span>) / <span>4</span>;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">3.C The Dormant State and Protocol Selection</h3><a id="user-content-3c-the-dormant-state-and-protocol-selection" aria-label="Permalink: 3.C The Dormant State and Protocol Selection" href="#3c-the-dormant-state-and-protocol-selection"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">ARM Debug Interface Architecture v6 introduces a <strong>Dormant State</strong> to enable coexistence of multiple debug protocols (JTAG and SWD) on the same pins. At power-up, RP2350&#39;s SW-DP enters the Dormant state, requiring explicit activation before SWD operations can proceed.</p>
<p dir="auto">The dormant state solves a fundamental problem: JTAG uses 5 signals (TMS, TCK, TDI, TDO, TRST), while SWD uses 2 (SWCLK, SWDIO). When both protocols share physical pins, the debug port must determine which protocol the debugger intends to use. The solution is to require a protocol-specific &#34;unlock&#34; sequence that:</p>
<ol dir="auto">
<li>Cannot be generated accidentally by non-debug traffic on the pins</li>
<li>Is sufficiently long to avoid false positives (128 bits)</li>
<li>Uniquely identifies the target protocol (JTAG vs SWD)</li>
</ol>
<div dir="auto"><h4 tabindex="-1" dir="auto">3.C.1 The State Transition Model</h4><a id="user-content-3c1-the-state-transition-model" aria-label="Permalink: 3.C.1 The State Transition Model" href="#3c1-the-state-transition-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The SW-DP implements a finite state machine with three protocol modes:</p>
<div data-snippet-clipboard-copy-content="Power-On → [Default State] → Dormant
                                 │
                    ┌────────────┼────────────┐
                    │                         │
         JTAG Activation              SWD Activation
         Sequence (0x33bbbbba)        Sequence (0x1a)
                    │                         │
                    ▼                         ▼
              ┌──────────┐              ┌──────────┐
              │   JTAG   │              │   SWD    │
              │  Active  │              │  Active  │
              └────┬─────┘              └────┬─────┘
                   │                         │
         JTAG-to-Dormant              SWD-to-Dormant
         Sequence                     Sequence
                   │                         │
                   └──────────┬──────────────┘
                              ▼
                         ┌──────────┐
                         │ Dormant  │
                         └──────────┘"><pre><code>Power-On → [Default State] → Dormant
                                 │
                    ┌────────────┼────────────┐
                    │                         │
         JTAG Activation              SWD Activation
         Sequence (0x33bbbbba)        Sequence (0x1a)
                    │                         │
                    ▼                         ▼
              ┌──────────┐              ┌──────────┐
              │   JTAG   │              │   SWD    │
              │  Active  │              │  Active  │
              └────┬─────┘              └────┬─────┘
                   │                         │
         JTAG-to-Dormant              SWD-to-Dormant
         Sequence                     Sequence
                   │                         │
                   └──────────┬──────────────┘
                              ▼
                         ┌──────────┐
                         │ Dormant  │
                         └──────────┘
</code></pre></div>
<p dir="auto">Once activated, the debug port remains in the selected protocol mode until:</p>
<ul dir="auto">
<li>A transition-to-dormant sequence is sent</li>
<li>Power is cycled</li>
<li>The external reset (RUN) pin is asserted</li>
</ul>
<div dir="auto"><h4 tabindex="-1" dir="auto">3.C.2 The Selection Alert Sequence</h4><a id="user-content-3c2-the-selection-alert-sequence" aria-label="Permalink: 3.C.2 The Selection Alert Sequence" href="#3c2-the-selection-alert-sequence"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Before sending a protocol-specific activation code, ARM requires transmission of a 128-bit <strong>Selection Alert Sequence</strong>. This sequence serves as a &#34;wake-up call&#34; that:</p>
<ol dir="auto">
<li>Synchronizes the target&#39;s bit-stream parser</li>
<li>Ensures the target is listening for an activation sequence</li>
<li>Provides sufficient entropy to avoid accidental activation</li>
</ol>
<p dir="auto">The Selection Alert Sequence is a fixed 128-bit pattern defined in the ADI v6 specification:</p>
<div data-snippet-clipboard-copy-content="0x19bc0ea2_e3ddafe9_86852d95_6209f392 (transmitted LSB-first)"><pre><code>0x19bc0ea2_e3ddafe9_86852d95_6209f392 (transmitted LSB-first)
</code></pre></div>
<p dir="auto">This constant was chosen for its Hamming distance properties—it is unlikely to occur in normal signal traffic or be generated by crosstalk, glitches, or other non-debug activity.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">3.C.3 Implementation: Robust Activation Strategy</h4><a id="user-content-3c3-implementation-robust-activation-strategy" aria-label="Permalink: 3.C.3 Implementation: Robust Activation Strategy" href="#3c3-implementation-robust-activation-strategy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Our implementation (<code>swd_protocol.c:357-382</code>) uses a <strong>defensive activation strategy</strong> that ensures reliable connection regardless of the SW-DP&#39;s initial state:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Phase 1: Exit any prior protocol mode
static const uint8_t seq_jtag_to_dormant[] = {
    0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xbc,0xe3
};

// Phase 2: Activate SWD mode
static const uint8_t seq_dormant_to_swd[] = {
    0xff,                                        // Line reset (8 ones)
    0x92,0xf3,0x09,0x62,0x95,0x2d,0x85,0x86,     // Selection Alert
    0xe9,0xaf,0xdd,0xe3,0xa2,0x0e,0xbc,0x19,     //   (128 bits)
    0xa0,0xf1,0xff,                              // SWD Activation Code (0x1a)
    0xff,0xff,0xff,0xff,0xff,0xff,0xff, 0xff,    // Line reset (&gt;50 ones)
    0x00                                         // Idle low
};"><pre><span>// Phase 1: Exit any prior protocol mode</span>
<span>static</span> <span>const</span> <span>uint8_t</span> <span>seq_jtag_to_dormant</span>[] <span>=</span> {
    <span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>, <span>0xbc</span>,<span>0xe3</span>
};

<span>// Phase 2: Activate SWD mode</span>
<span>static</span> <span>const</span> <span>uint8_t</span> <span>seq_dormant_to_swd</span>[] <span>=</span> {
    <span>0xff</span>,                                        <span>// Line reset (8 ones)</span>
    <span>0x92</span>,<span>0xf3</span>,<span>0x09</span>,<span>0x62</span>,<span>0x95</span>,<span>0x2d</span>,<span>0x85</span>,<span>0x86</span>,     <span>// Selection Alert</span>
    <span>0xe9</span>,<span>0xaf</span>,<span>0xdd</span>,<span>0xe3</span>,<span>0xa2</span>,<span>0x0e</span>,<span>0xbc</span>,<span>0x19</span>,     <span>//   (128 bits)</span>
    <span>0xa0</span>,<span>0xf1</span>,<span>0xff</span>,                              <span>// SWD Activation Code (0x1a)</span>
    <span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>,<span>0xff</span>, <span>0xff</span>,    <span>// Line reset (&gt;50 ones)</span>
    <span>0x00</span>                                         <span>// Idle low</span>
};</pre></div>
<p dir="auto"><strong>Why this two-phase approach?</strong></p>
<p dir="auto">The problem is that we don&#39;t know the SW-DP&#39;s current state:</p>
<ol dir="auto">
<li><strong>Fresh power-up</strong>: SW-DP is in Dormant mode (default)</li>
<li><strong>Prior debug session</strong>: SW-DP may be in SWD or JTAG mode</li>
<li><strong>Failed connection attempt</strong>: SW-DP may be in an undefined state</li>
</ol>
<p dir="auto">If the SW-DP is already in SWD or JTAG mode, sending the Selection Alert Sequence will be interpreted as data transactions, potentially putting the DP into an error state. Our solution:</p>
<p dir="auto"><strong>Phase 1: Force transition to Dormant</strong></p>
<p dir="auto">Send the JTAG-to-Dormant sequence (56 ones followed by 0xbc, 0xe3). This sequence:</p>
<ul dir="auto">
<li>If in JTAG mode: transitions to Dormant</li>
<li>If in SWD mode: interpreted as line reset + invalid transactions (harmless)</li>
<li>If already Dormant: has no effect (dormant state ignores invalid input)</li>
</ul>
<p dir="auto">The sequence consists of:</p>
<ul dir="auto">
<li><strong>56 clock cycles high</strong> (JTAG TMS=1 → Test-Logic-Reset state)</li>
<li><strong>0x3cbe</strong> (0xbc, 0xe3 LSB-first): JTAG-specific exit pattern</li>
</ul>
<p dir="auto"><strong>Phase 2: Activate SWD from Dormant</strong></p>
<p dir="auto">Now that we&#39;re guaranteed to be in Dormant mode (or already in SWD mode where line reset is idempotent), we send:</p>
<ol dir="auto">
<li><strong>Line reset</strong> (8 ones): Clears any pending SWD transactions</li>
<li><strong>Selection Alert Sequence</strong> (128 bits): Wakes dormant state machine</li>
<li><strong>SWD Activation Code</strong> (0x1a, 8 bits): Selects SWD protocol</li>
<li><strong>Line reset</strong> (&gt;50 ones): Enters SWD Reset state, clearing sticky errors</li>
<li><strong>Idle cycles</strong>: Ensures clean transition</li>
</ol>
<p dir="auto">The SWD Activation Code <code>0x1a</code> decodes as:</p>
<div data-snippet-clipboard-copy-content="Bits[7:0] = 0x1a = 0b00011010"><pre><code>Bits[7:0] = 0x1a = 0b00011010
</code></pre></div>
<p dir="auto">This specific bit pattern was chosen to be distinct from valid JTAG TMS sequences, ensuring protocol disambiguation.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">3.C.4 Why Not Use the RP2350 Datasheet Sequence?</h4><a id="user-content-3c4-why-not-use-the-rp2350-datasheet-sequence" aria-label="Permalink: 3.C.4 Why Not Use the RP2350 Datasheet Sequence?" href="#3c4-why-not-use-the-rp2350-datasheet-sequence"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The RP2350 datasheet (Section 3.5.1) describes a simpler connection sequence:</p>
<div data-snippet-clipboard-copy-content="1. At least 8 × SWCLK cycles with SWDIO high
2. The 128-bit Selection Alert sequence
3. Four SWCLK cycles with SWDIO low
4. SWD activation code: 0x1a, LSB first
5. At least 50 × SWCLK cycles with SWDIO high (line reset)
6. A DPIDR read to exit the Reset state"><pre><code>1. At least 8 × SWCLK cycles with SWDIO high
2. The 128-bit Selection Alert sequence
3. Four SWCLK cycles with SWDIO low
4. SWD activation code: 0x1a, LSB first
5. At least 50 × SWCLK cycles with SWDIO high (line reset)
6. A DPIDR read to exit the Reset state
</code></pre></div>
<p dir="auto">This sequence assumes the SW-DP is in Dormant mode at power-up. However, in real-world scenarios:</p>
<ul dir="auto">
<li>The target may have been previously debugged (SW-DP in SWD mode)</li>
<li>A debugger crash may have left the SW-DP in an error state</li>
<li>Multi-drop SWD configurations may require explicit state reset</li>
</ul>
<p dir="auto">Our JTAG→Dormant→SWD sequence provides <strong>universal robustness</strong>: it works regardless of the SW-DP&#39;s initial state. The cost is negligible—approximately 100 extra clock cycles, taking ~100µs at 1 MHz SWCLK—while the benefit is reliable connection without manual power-cycling.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">3.C.5 Post-Activation Verification</h4><a id="user-content-3c5-post-activation-verification" aria-label="Permalink: 3.C.5 Post-Activation Verification" href="#3c5-post-activation-verification"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">After activation, we immediately read DP_IDCODE (<code>swd_protocol.c:386-397</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t idcode = 0;
err = swd_read_dp_raw(target, DP_IDCODE, &amp;idcode);
if (err != SWD_OK) {
    swd_set_error(target, err, &#34;Failed to read IDCODE&#34;);
    return err;
}

if ((idcode &amp; 0x0fffffff) == 0) {
    swd_set_error(target, SWD_ERROR_PROTOCOL, &#34;Invalid IDCODE: 0x%08x&#34;, idcode);
    return SWD_ERROR_PROTOCOL;
}"><pre><span>uint32_t</span> <span>idcode</span> <span>=</span> <span>0</span>;
<span>err</span> <span>=</span> <span>swd_read_dp_raw</span>(<span>target</span>, <span>DP_IDCODE</span>, <span>&amp;</span><span>idcode</span>);
<span>if</span> (<span>err</span> <span>!=</span> <span>SWD_OK</span>) {
    <span>swd_set_error</span>(<span>target</span>, <span>err</span>, <span>&#34;Failed to read IDCODE&#34;</span>);
    <span>return</span> <span>err</span>;
}

<span>if</span> ((<span>idcode</span> <span>&amp;</span> <span>0x0fffffff</span>) <span>==</span> <span>0</span>) {
    <span>swd_set_error</span>(<span>target</span>, <span>SWD_ERROR_PROTOCOL</span>, <span>&#34;Invalid IDCODE: 0x%08x&#34;</span>, <span>idcode</span>);
    <span>return</span> <span>SWD_ERROR_PROTOCOL</span>;
}</pre></div>
<p dir="auto">A successful IDCODE read confirms:</p>
<ol dir="auto">
<li>SWD protocol is active</li>
<li>The SW-DP is responding to transactions</li>
<li>The SWCLK frequency is within tolerance</li>
<li>SWDIO signal integrity is sufficient</li>
</ol>
<p dir="auto">For RP2350, the IDCODE is <code>0x4c013477</code></p>
<p dir="auto">This defensive activation strategy, while not strictly necessary for fresh power-up scenarios, ensures our library works reliably across the full range of real-world debug connection scenarios—a critical property for a reusable debug library.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">4. DEBUG ACCESS PORT ARCHITECTURE</h2><a id="user-content-4-debug-access-port-architecture" aria-label="Permalink: 4. DEBUG ACCESS PORT ARCHITECTURE" href="#4-debug-access-port-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Access Port (DAP) provides memory-mapped access to debug resources through two register banks:</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">4.A Debug Port Registers</h3><a id="user-content-4a-debug-port-registers" aria-label="Permalink: 4.A Debug Port Registers" href="#4a-debug-port-registers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Port (DP) manages power domains and AP selection:</p>
<ul dir="auto">
<li><strong>DP_IDCODE</strong> (0x0): Designer and part number identification</li>
<li><strong>DP_CTRL_STAT</strong> (0x4): Power control and status flags</li>
<li><strong>DP_SELECT</strong> (0x8): AP and register bank selection</li>
<li><strong>DP_RDBUFF</strong> (0xC): Read buffer for pipelined AP reads</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">4.B Access Port Registers</h3><a id="user-content-4b-access-port-registers" aria-label="Permalink: 4.B Access Port Registers" href="#4b-access-port-registers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Access Ports (AP) provide interfaces to debug resources. RP2350 implements multiple APs:</p>
<ul dir="auto">
<li><strong>AP 0x0</strong>: ROM Table</li>
<li><strong>AP 0x2</strong>: ARM Core 0 AHB-AP</li>
<li><strong>AP 0x4</strong>: ARM Core 1 AHB-AP</li>
<li><strong>AP 0x8</strong>: RP2350-specific AP</li>
<li><strong>AP 0xA</strong>: RISC-V APB-AP (target of this library)</li>
</ul>
<p dir="auto">Each AP has standardized registers:</p>
<ul dir="auto">
<li><strong>AP_CSW</strong> (0x00): Control/Status Word</li>
<li><strong>AP_TAR</strong> (0x04): Transfer Address Register</li>
<li><strong>AP_DRW</strong> (0x0C): Data Read/Write Register</li>
<li><strong>AP_IDR</strong> (0xFC): Identification Register</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">4.C RP2350-Specific DP_SELECT Encoding</h3><a id="user-content-4c-rp2350-specific-dp_select-encoding" aria-label="Permalink: 4.C RP2350-Specific DP_SELECT Encoding" href="#4c-rp2350-specific-dp_select-encoding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Standard ARM DP_SELECT format uses bits[31:24] for APSEL and bits[7:4] for APBANKSEL. RP2350 implements a non-standard encoding (<code>dap.c:18-22</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t make_dp_select_rp2350(uint8_t apsel, uint8_t bank, bool ctrlsel) {
    // [15:12] = APSEL, [11:8] = 0xD, [7:4] = bank, [0] = ctrlsel
    return ((apsel &amp; 0xF) &lt;&lt; 12) | (0xD &lt;&lt; 8) | ((bank &amp; 0xF) &lt;&lt; 4) | (ctrlsel ? 1 : 0);
}"><pre><span>uint32_t</span> <span>make_dp_select_rp2350</span>(<span>uint8_t</span> <span>apsel</span>, <span>uint8_t</span> <span>bank</span>, <span>bool</span> <span>ctrlsel</span>) {
    <span>// [15:12] = APSEL, [11:8] = 0xD, [7:4] = bank, [0] = ctrlsel</span>
    <span>return</span> ((<span>apsel</span> <span>&amp;</span> <span>0xF</span>) &lt;&lt; <span>12</span>) | (<span>0xD</span> &lt;&lt; <span>8</span>) | ((<span>bank</span> <span>&amp;</span> <span>0xF</span>) &lt;&lt; <span>4</span>) | (<span>ctrlsel</span> ? <span>1</span> : <span>0</span>);
}</pre></div>
<p dir="auto">The magic constant 0xD in bits[11:8] is undocumented but required for correct AP selection.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">4.D Bank Selection Caching</h3><a id="user-content-4d-bank-selection-caching" aria-label="Permalink: 4.D Bank Selection Caching" href="#4d-bank-selection-caching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">AP registers are accessed through a banking mechanism where DP_SELECT must be written before each AP access. To minimize SWD transactions, the library maintains a cache of the current bank selection (<code>dap.c:28-55</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="static swd_error_t select_ap_bank(swd_target_t *target, uint8_t apsel, uint8_t bank) {
    if (target-&gt;dap.current_apsel == apsel &amp;&amp;
        target-&gt;dap.current_bank == bank &amp;&amp;
        target-&gt;dap.ctrlsel == true) {
        return SWD_OK;  // Already selected
    }
    // Write DP_SELECT...
    target-&gt;dap.current_apsel = apsel;
    target-&gt;dap.current_bank = bank;
    // ...
}"><pre><span>static</span> <span>swd_error_t</span> <span>select_ap_bank</span>(<span>swd_target_t</span> <span>*</span><span>target</span>, <span>uint8_t</span> <span>apsel</span>, <span>uint8_t</span> <span>bank</span>) {
    <span>if</span> (<span>target</span><span>-&gt;</span><span>dap</span>.<span>current_apsel</span> <span>==</span> <span>apsel</span> <span>&amp;&amp;</span>
        <span>target</span><span>-&gt;</span><span>dap</span>.<span>current_bank</span> <span>==</span> <span>bank</span> <span>&amp;&amp;</span>
        <span>target</span><span>-&gt;</span><span>dap</span>.<span>ctrlsel</span> <span>==</span> true) {
        <span>return</span> <span>SWD_OK</span>;  <span>// Already selected</span>
    }
    <span>// Write DP_SELECT...</span>
    <span>target</span><span>-&gt;</span><span>dap</span>.<span>current_apsel</span> <span>=</span> <span>apsel</span>;
    <span>target</span><span>-&gt;</span><span>dap</span>.<span>current_bank</span> <span>=</span> <span>bank</span>;
    <span>// ...</span>
}</pre></div>
<p dir="auto">This caching reduces transaction count by approximately 50% in typical debug sessions.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">5. DEBUG DOMAIN POWER SEQUENCING</h2><a id="user-content-5-debug-domain-power-sequencing" aria-label="Permalink: 5. DEBUG DOMAIN POWER SEQUENCING" href="#5-debug-domain-power-sequencing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Before any debug operations can proceed, the Debug Power Domain (DPD) and System Power Domain (SPD) must be powered up. This is not a physical power operation but rather clock and reset domain enabling.</p>
<p dir="auto">The power-up sequence (<code>dap.c:61-110</code>) follows the ARM Debug Interface specification:</p>
<ol dir="auto">
<li><strong>Clear sticky errors</strong>: Write 0 to DP_CTRL_STAT</li>
<li><strong>Request power-up</strong>: Set CDBGPWRUPREQ (bit 28) and CSYSPWRUPREQ (bit 30)</li>
<li><strong>Poll acknowledgment</strong>: Wait for CDBGPWRUPACK (bit 29) and CSYSPWRUPACK (bit 31)</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t ctrl_stat = (1 &lt;&lt; 28) | (1 &lt;&lt; 30);
swd_write_dp_raw(target, DP_CTRL_STAT, ctrl_stat);

for (int i = 0; i &lt; 10; i++) {
    swd_read_dp_raw(target, DP_CTRL_STAT, &amp;status);
    bool cdbgpwrupack = (status &gt;&gt; 29) &amp; 1;
    bool csyspwrupack = (status &gt;&gt; 31) &amp; 1;
    if (cdbgpwrupack &amp;&amp; csyspwrupack) {
        return SWD_OK;
    }
    sleep_ms(20);
}"><pre><span>uint32_t</span> <span>ctrl_stat</span> <span>=</span> (<span>1</span> &lt;&lt; <span>28</span>) | (<span>1</span> &lt;&lt; <span>30</span>);
<span>swd_write_dp_raw</span>(<span>target</span>, <span>DP_CTRL_STAT</span>, <span>ctrl_stat</span>);

<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
    <span>swd_read_dp_raw</span>(<span>target</span>, <span>DP_CTRL_STAT</span>, <span>&amp;</span><span>status</span>);
    <span>bool</span> <span>cdbgpwrupack</span> <span>=</span> (<span>status</span> &gt;&gt; <span>29</span>) <span>&amp;</span> <span>1</span>;
    <span>bool</span> <span>csyspwrupack</span> <span>=</span> (<span>status</span> &gt;&gt; <span>31</span>) <span>&amp;</span> <span>1</span>;
    <span>if</span> (<span>cdbgpwrupack</span> <span>&amp;&amp;</span> <span>csyspwrupack</span>) {
        <span>return</span> <span>SWD_OK</span>;
    }
    <span>sleep_ms</span>(<span>20</span>);
}</pre></div>
<p dir="auto">Failure to complete this sequence results in all subsequent debug operations returning WAIT responses indefinitely.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">6. RP2350 DEBUG MODULE INITIALIZATION</h2><a id="user-content-6-rp2350-debug-module-initialization" aria-label="Permalink: 6. RP2350 DEBUG MODULE INITIALIZATION" href="#6-rp2350-debug-module-initialization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">After DAP power-up, the RP2350-specific Debug Module must be initialized through an undocumented activation handshake. This sequence was reverse-engineered from OpenOCD&#39;s RP2350 support with an oscilloscope and patience.</p>
<p dir="auto">The activation sequence (<code>rp2350.c:106-194</code>) consists of:</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">6.A AP Selection and CSW Configuration</h3><a id="user-content-6a-ap-selection-and-csw-configuration" aria-label="Permalink: 6.A AP Selection and CSW Configuration" href="#6a-ap-selection-and-csw-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t sel_bank0 = make_dp_select_rp2350(AP_RISCV, 0, true);
dap_write_dp(target, DP_SELECT, sel_bank0);

uint32_t csw = 0xA2000002;  // 32-bit access, auto-increment disabled
dap_write_ap(target, AP_RISCV, AP_CSW, csw);"><pre><span>uint32_t</span> <span>sel_bank0</span> <span>=</span> <span>make_dp_select_rp2350</span>(<span>AP_RISCV</span>, <span>0</span>, true);
<span>dap_write_dp</span>(<span>target</span>, <span>DP_SELECT</span>, <span>sel_bank0</span>);

<span>uint32_t</span> <span>csw</span> <span>=</span> <span>0xA2000002</span>;  <span>// 32-bit access, auto-increment disabled</span>
<span>dap_write_ap</span>(<span>target</span>, <span>AP_RISCV</span>, <span>AP_CSW</span>, <span>csw</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">6.B Bank 1 Activation Handshake</h3><a id="user-content-6b-bank-1-activation-handshake" aria-label="Permalink: 6.B Bank 1 Activation Handshake" href="#6b-bank-1-activation-handshake"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Module registers are normally accessed through Bank 0, but activation requires Bank 1:</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t sel_bank1 = make_dp_select_rp2350(AP_RISCV, 1, true);
dap_write_dp(target, DP_SELECT, sel_bank1);

// Three-phase handshake
dap_write_ap(target, AP_RISCV, AP_CSW, 0x00000000);  // Reset
dap_read_dp(target, DP_RDBUFF);
sleep_ms(50);

dap_write_ap(target, AP_RISCV, AP_CSW, 0x00000001);  // Activate
dap_read_dp(target, DP_RDBUFF);
sleep_ms(50);

dap_write_ap(target, AP_RISCV, AP_CSW, 0x07FFFFC1);  // Configure
dap_read_dp(target, DP_RDBUFF);
sleep_ms(50);"><pre><span>uint32_t</span> <span>sel_bank1</span> <span>=</span> <span>make_dp_select_rp2350</span>(<span>AP_RISCV</span>, <span>1</span>, true);
<span>dap_write_dp</span>(<span>target</span>, <span>DP_SELECT</span>, <span>sel_bank1</span>);

<span>// Three-phase handshake</span>
<span>dap_write_ap</span>(<span>target</span>, <span>AP_RISCV</span>, <span>AP_CSW</span>, <span>0x00000000</span>);  <span>// Reset</span>
<span>dap_read_dp</span>(<span>target</span>, <span>DP_RDBUFF</span>);
<span>sleep_ms</span>(<span>50</span>);

<span>dap_write_ap</span>(<span>target</span>, <span>AP_RISCV</span>, <span>AP_CSW</span>, <span>0x00000001</span>);  <span>// Activate</span>
<span>dap_read_dp</span>(<span>target</span>, <span>DP_RDBUFF</span>);
<span>sleep_ms</span>(<span>50</span>);

<span>dap_write_ap</span>(<span>target</span>, <span>AP_RISCV</span>, <span>AP_CSW</span>, <span>0x07FFFFC1</span>);  <span>// Configure</span>
<span>dap_read_dp</span>(<span>target</span>, <span>DP_RDBUFF</span>);
<span>sleep_ms</span>(<span>50</span>);</pre></div>
<p dir="auto">The expected status response is <code>0x04010001</code>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">7. RISC-V DEBUG MODULE INTERFACE</h2><a id="user-content-7-risc-v-debug-module-interface" aria-label="Permalink: 7. RISC-V DEBUG MODULE INTERFACE" href="#7-risc-v-debug-module-interface"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The RISC-V Debug Module implements the RISC-V External Debug Support specification v0.13. Debug Module registers are memory-mapped at base address 0x40 (register addresses are byte offsets × 4).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">7.A Debug Module Registers</h3><a id="user-content-7a-debug-module-registers" aria-label="Permalink: 7.A Debug Module Registers" href="#7a-debug-module-registers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Key registers (<code>rp2350.c:17-29</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define DM_DMCONTROL   (0x10 * 4)  // Hart control
#define DM_DMSTATUS    (0x11 * 4)  // Hart status
#define DM_ABSTRACTCS  (0x16 * 4)  // Abstract command status
#define DM_COMMAND     (0x17 * 4)  // Abstract command execution
#define DM_DATA0       (0x04 * 4)  // Data transfer register
#define DM_PROGBUF0    (0x20 * 4)  // Program buffer word 0
#define DM_PROGBUF1    (0x21 * 4)  // Program buffer word 1
#define DM_SBCS        (0x38 * 4)  // System Bus Access Control
#define DM_SBADDRESS0  (0x39 * 4)  // SBA Address
#define DM_SBDATA0     (0x3C * 4)  // SBA Data"><pre><span>#define</span> <span>DM_DMCONTROL</span>   (0x10 * 4)  // Hart control
<span>#define</span> <span>DM_DMSTATUS</span>    (0x11 * 4)  // Hart status
<span>#define</span> <span>DM_ABSTRACTCS</span>  (0x16 * 4)  // Abstract command status
<span>#define</span> <span>DM_COMMAND</span>     (0x17 * 4)  // Abstract command execution
<span>#define</span> <span>DM_DATA0</span>       (0x04 * 4)  // Data transfer register
<span>#define</span> <span>DM_PROGBUF0</span>    (0x20 * 4)  // Program buffer word 0
<span>#define</span> <span>DM_PROGBUF1</span>    (0x21 * 4)  // Program buffer word 1
<span>#define</span> <span>DM_SBCS</span>        (0x38 * 4)  // System Bus Access Control
<span>#define</span> <span>DM_SBADDRESS0</span>  (0x39 * 4)  // SBA Address
<span>#define</span> <span>DM_SBDATA0</span>     (0x3C * 4)  // SBA Data</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">7.B Hart Control via DMCONTROL</h3><a id="user-content-7b-hart-control-via-dmcontrol" aria-label="Permalink: 7.B Hart Control via DMCONTROL" href="#7b-hart-control-via-dmcontrol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Hart (hardware thread) execution is controlled through DMCONTROL register fields:</p>
<ul dir="auto">
<li><strong>dmactive</strong> (bit 0): Debug Module active (must be 1)</li>
<li><strong>haltreq</strong> (bit 31): Request hart halt</li>
<li><strong>resumereq</strong> (bit 30): Request hart resume</li>
</ul>
<p dir="auto">Halt sequence (<code>rp2350.c:205-240</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t dmcontrol = (1 &lt;&lt; 31) | (1 &lt;&lt; 0);  // haltreq | dmactive
dap_write_mem32(target, DM_DMCONTROL, dmcontrol);

// Poll DMSTATUS.allhalted (bit 9)
for (int i = 0; i &lt; 10; i++) {
    swd_result_t result = dap_read_mem32(target, DM_DMSTATUS);
    bool allhalted = (result.value &gt;&gt; 9) &amp; 1;
    if (allhalted) {
        target-&gt;rp2350.hart_halted = true;
        return SWD_OK;
    }
    sleep_ms(10);
}"><pre><span>uint32_t</span> <span>dmcontrol</span> <span>=</span> (<span>1</span> &lt;&lt; <span>31</span>) | (<span>1</span> &lt;&lt; <span>0</span>);  <span>// haltreq | dmactive</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_DMCONTROL</span>, <span>dmcontrol</span>);

<span>// Poll DMSTATUS.allhalted (bit 9)</span>
<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span>) {
    <span>swd_result_t</span> <span>result</span> <span>=</span> <span>dap_read_mem32</span>(<span>target</span>, <span>DM_DMSTATUS</span>);
    <span>bool</span> <span>allhalted</span> <span>=</span> (<span>result</span>.<span>value</span> &gt;&gt; <span>9</span>) <span>&amp;</span> <span>1</span>;
    <span>if</span> (<span>allhalted</span>) {
        <span>target</span><span>-&gt;</span><span>rp2350</span>.<span>hart_halted</span> <span>=</span> true;
        <span>return</span> <span>SWD_OK</span>;
    }
    <span>sleep_ms</span>(<span>10</span>);
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">7.C Abstract Commands for Register Access</h3><a id="user-content-7c-abstract-commands-for-register-access" aria-label="Permalink: 7.C Abstract Commands for Register Access" href="#7c-abstract-commands-for-register-access"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Abstract commands provide a high-level interface to hart state without halting. The COMMAND register format for GPR access:</p>
<div data-snippet-clipboard-copy-content="Bits 0-15:   regno (0x1000 + reg_num for GPRs)
Bit 16:      write (1=write, 0=read)
Bit 17:      transfer (1=execute transfer)
Bits 20-22:  aarsize (2=32-bit access)"><pre><code>Bits 0-15:   regno (0x1000 + reg_num for GPRs)
Bit 16:      write (1=write, 0=read)
Bit 17:      transfer (1=execute transfer)
Bits 20-22:  aarsize (2=32-bit access)
</code></pre></div>
<p dir="auto">GPR read implementation (<code>rp2350.c:333-389</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t command = 0;
command |= (0x1000 + reg_num) &lt;&lt; 0;    // regno
command |= (1 &lt;&lt; 17);                  // transfer
command |= (2 &lt;&lt; 20);                  // aarsize=32-bit

dap_write_mem32(target, DM_COMMAND, command);
wait_abstract_command(target);  // Poll ABSTRACTCS.busy
result = dap_read_mem32(target, DM_DATA0);"><pre><span>uint32_t</span> <span>command</span> <span>=</span> <span>0</span>;
<span>command</span> |= (<span>0x1000</span> <span>+</span> <span>reg_num</span>) &lt;&lt; <span>0</span>;    <span>// regno</span>
<span>command</span> |= (<span>1</span> &lt;&lt; <span>17</span>);                  <span>// transfer</span>
<span>command</span> |= (<span>2</span> &lt;&lt; <span>20</span>);                  <span>// aarsize=32-bit</span>

<span>dap_write_mem32</span>(<span>target</span>, <span>DM_COMMAND</span>, <span>command</span>);
<span>wait_abstract_command</span>(<span>target</span>);  <span>// Poll ABSTRACTCS.busy</span>
<span>result</span> <span>=</span> <span>dap_read_mem32</span>(<span>target</span>, <span>DM_DATA0</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">7.D Program Buffer Execution Model</h3><a id="user-content-7d-program-buffer-execution-model" aria-label="Permalink: 7.D Program Buffer Execution Model" href="#7d-program-buffer-execution-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Program Buffer (PROGBUF) is a 16-entry instruction memory within the Debug Module that enables execution of arbitrary RISC-V code in the debug context. Understanding its operation requires examining the execution model, register preservation semantics, and synchronization mechanisms.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.1 The Dual-Context Execution Model</h4><a id="user-content-7d1-the-dual-context-execution-model" aria-label="Permalink: 7.D.1 The Dual-Context Execution Model" href="#7d1-the-dual-context-execution-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A RISC-V hart operates in one of two contexts:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Normal Context</strong>: The hart executes from main memory, PC advances sequentially, and all architectural state is visible to the program.</p>
</li>
<li>
<p dir="auto"><strong>Debug Context</strong>: Upon entering debug mode (via halt request, ebreak, or trigger), the hart:</p>
<ul dir="auto">
<li>Saves PC to DPC (Debug Program Counter, CSR 0x7b1)</li>
<li>Enters a special execution mode where PROGBUF instructions execute</li>
<li>Maintains all GPRs and CSRs in their pre-halt state</li>
<li>Cannot access main memory without explicit instructions</li>
</ul>
</li>
</ol>
<p dir="auto">The Debug Module provides a &#34;scratch pad&#34; where debugger-supplied instructions execute with full access to hart state, but without disturbing that state beyond explicit modifications.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.2 PROGBUF Entry Layout</h4><a id="user-content-7d2-progbuf-entry-layout" aria-label="Permalink: 7.D.2 PROGBUF Entry Layout" href="#7d2-progbuf-entry-layout"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RP2350&#39;s Debug Module provides 2 program buffer entries (PROGBUF0 and PROGBUF1), though the specification allows up to 16. Each entry holds one 32-bit RISC-V instruction:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define DM_PROGBUF0  (0x20 * 4)  // First instruction
#define DM_PROGBUF1  (0x21 * 4)  // Second instruction (typically ebreak)"><pre><span>#define</span> <span>DM_PROGBUF0</span>  (0x20 * 4)  // First instruction
<span>#define</span> <span>DM_PROGBUF1</span>  (0x21 * 4)  // Second instruction (typically ebreak)</pre></div>
<p dir="auto">The execution model assumes the final instruction is <code>ebreak</code> (0x00100073), which returns control to the Debug Module and makes the hart available for further debug operations.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.3 The Abstract Command Postexec Mechanism</h4><a id="user-content-7d3-the-abstract-command-postexec-mechanism" aria-label="Permalink: 7.D.3 The Abstract Command Postexec Mechanism" href="#7d3-the-abstract-command-postexec-mechanism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Abstract commands can trigger PROGBUF execution through the <code>postexec</code> bit (bit 18 of the COMMAND register). This creates a transactional execution model:</p>
<div data-snippet-clipboard-copy-content="┌──────────────────────────────────────────┐
│ 1. Debugger writes PROGBUF instructions  │
├──────────────────────────────────────────┤
│ 2. Debugger writes DATA0 (optional)      │
├──────────────────────────────────────────┤
│ 3. Abstract command with postexec=1      │
│   - Transfers DATA0 → GPR (if transfer=1)│
│   - Executes PROGBUF[0]..PROGBUF[N]      │
│   - Executes ebreak (returns to DM)      │
│   - Transfers GPR → DATA0 (if transfer=1)│
└──────────────────────────────────────────┘"><pre><code>┌──────────────────────────────────────────┐
│ 1. Debugger writes PROGBUF instructions  │
├──────────────────────────────────────────┤
│ 2. Debugger writes DATA0 (optional)      │
├──────────────────────────────────────────┤
│ 3. Abstract command with postexec=1      │
│   - Transfers DATA0 → GPR (if transfer=1)│
│   - Executes PROGBUF[0]..PROGBUF[N]      │
│   - Executes ebreak (returns to DM)      │
│   - Transfers GPR → DATA0 (if transfer=1)│
└──────────────────────────────────────────┘
</code></pre></div>
<p dir="auto">This mechanism eliminates race conditions: the data transfer and program execution form an atomic operation from the debugger&#39;s perspective.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.4 Case Study: Reading Debug CSR (DPC)</h4><a id="user-content-7d4-case-study-reading-debug-csr-dpc" aria-label="Permalink: 7.D.4 Case Study: Reading Debug CSR (DPC)" href="#7d4-case-study-reading-debug-csr-dpc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Program Counter (DPC, CSR 0x7b1) cannot be accessed via abstract commands—it exists only in debug context and abstract commands target normal context registers. Reading DPC requires PROGBUF execution (<code>rp2350.c:804-833</code>):</p>
<p dir="auto"><strong>Phase 1: Preserve scratch register</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="swd_result_t saved_s0 = rp2350_read_reg(target, hart_id, 8);  // x8 = s0"><pre><span>swd_result_t</span> <span>saved_s0</span> <span>=</span> <span>rp2350_read_reg</span>(<span>target</span>, <span>hart_id</span>, <span>8</span>);  <span>// x8 = s0</span></pre></div>
<p dir="auto">The RISC-V ABI designates s0 (x8) as a saved register, but we must preserve it because our PROGBUF code will clobber it.</p>
<p dir="auto"><strong>Phase 2: Write PROGBUF instructions</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="dap_write_mem32(target, DM_PROGBUF0, 0x7b102473);  // csrr s0, dpc
dap_write_mem32(target, DM_PROGBUF1, 0x00100073);  // ebreak"><pre><span>dap_write_mem32</span>(<span>target</span>, <span>DM_PROGBUF0</span>, <span>0x7b102473</span>);  <span>// csrr s0, dpc</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_PROGBUF1</span>, <span>0x00100073</span>);  <span>// ebreak</span></pre></div>
<p dir="auto">The instruction <code>csrr s0, dpc</code> (CSR Read) has the encoding:</p>
<div data-snippet-clipboard-copy-content="31      20 19   15 14  12 11    7 6      0
┌─────────┬───────┬──────┬───────┬────────┐
│ 0x7b1   │ 0x00  │ 0x2  │ 0x08  │ 0x73   │
│ CSR addr│ rs1   │funct3│  rd   │ opcode │
│  DPC    │  x0   │CSRRS │  s0   │ SYSTEM │
└─────────┴───────┴──────┴───────┴────────┘"><pre><code>31      20 19   15 14  12 11    7 6      0
┌─────────┬───────┬──────┬───────┬────────┐
│ 0x7b1   │ 0x00  │ 0x2  │ 0x08  │ 0x73   │
│ CSR addr│ rs1   │funct3│  rd   │ opcode │
│  DPC    │  x0   │CSRRS │  s0   │ SYSTEM │
└─────────┴───────┴──────┴───────┴────────┘
</code></pre></div>
<ul dir="auto">
<li><strong>funct3=0x2 (CSRRS)</strong>: CSR Read and Set. Since rs1=x0, no bits are set (read-only operation).</li>
<li><strong>CSR 0x7b1</strong>: DPC is defined in RISC-V Debug Spec v0.13, section 4.8.2</li>
</ul>
<p dir="auto"><strong>Phase 3: Execute with postexec</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t command = (1 &lt;&lt; 18);  // postexec=1, transfer=0
dap_write_mem32(target, DM_COMMAND, command);
wait_abstract_command(target);  // Poll ABSTRACTCS.busy"><pre><span>uint32_t</span> <span>command</span> <span>=</span> (<span>1</span> &lt;&lt; <span>18</span>);  <span>// postexec=1, transfer=0</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_COMMAND</span>, <span>command</span>);
<span>wait_abstract_command</span>(<span>target</span>);  <span>// Poll ABSTRACTCS.busy</span></pre></div>
<p dir="auto">The hart now executes:</p>
<ol dir="auto">
<li><code>csrr s0, dpc</code> → DPC value loaded into s0</li>
<li><code>ebreak</code> → Return to Debug Module, s0 contains DPC</li>
</ol>
<p dir="auto"><strong>Phase 4: Extract result via abstract command</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="result = rp2350_read_reg(target, hart_id, 8);  // Read s0 (now contains DPC)"><pre><span>result</span> <span>=</span> <span>rp2350_read_reg</span>(<span>target</span>, <span>hart_id</span>, <span>8</span>);  <span>// Read s0 (now contains DPC)</span></pre></div>
<p dir="auto"><strong>Phase 5: Restore architectural state</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="rp2350_write_reg(target, hart_id, 8, saved_s0.value);  // Restore s0"><pre><span>rp2350_write_reg</span>(<span>target</span>, <span>hart_id</span>, <span>8</span>, <span>saved_s0</span>.<span>value</span>);  <span>// Restore s0</span></pre></div>
<p dir="auto">This five-phase sequence is invisible to the hart&#39;s normal execution: when resumed, all registers appear unchanged.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.5 Writing Debug CSRs: The Inverse Operation</h4><a id="user-content-7d5-writing-debug-csrs-the-inverse-operation" aria-label="Permalink: 7.D.5 Writing Debug CSRs: The Inverse Operation" href="#7d5-writing-debug-csrs-the-inverse-operation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Writing DPC uses the inverse data flow (<code>rp2350.c:879-909</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Phase 1: Transfer new PC value to s0
err = rp2350_write_reg(target, hart_id, 8, new_pc_value);

// Phase 2: Write PROGBUF to copy s0 → DPC
dap_write_mem32(target, DM_PROGBUF0, 0x7b141073);  // csrw dpc, s0
dap_write_mem32(target, DM_PROGBUF1, 0x00100073);  // ebreak

// Phase 3: Execute
uint32_t command = (1 &lt;&lt; 18);  // postexec=1
dap_write_mem32(target, DM_COMMAND, command);
wait_abstract_command(target);"><pre><span>// Phase 1: Transfer new PC value to s0</span>
<span>err</span> <span>=</span> <span>rp2350_write_reg</span>(<span>target</span>, <span>hart_id</span>, <span>8</span>, <span>new_pc_value</span>);

<span>// Phase 2: Write PROGBUF to copy s0 → DPC</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_PROGBUF0</span>, <span>0x7b141073</span>);  <span>// csrw dpc, s0</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_PROGBUF1</span>, <span>0x00100073</span>);  <span>// ebreak</span>

<span>// Phase 3: Execute</span>
<span>uint32_t</span> <span>command</span> <span>=</span> (<span>1</span> &lt;&lt; <span>18</span>);  <span>// postexec=1</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_COMMAND</span>, <span>command</span>);
<span>wait_abstract_command</span>(<span>target</span>);</pre></div>
<p dir="auto">The instruction <code>csrw dpc, s0</code> (CSR Write) has encoding 0x7b141073:</p>
<div data-snippet-clipboard-copy-content="31      20 19   15 14  12 11    7 6      0
┌─────────┬───────┬──────┬───────┬────────┐
│ 0x7b1   │ 0x08  │ 0x1  │ 0x00  │ 0x73   │
│ CSR addr│ rs1   │funct3│  rd   │ opcode │
│  DPC    │  s0   │CSRRW │  x0   │ SYSTEM │
└─────────┴───────┴──────┴───────┴────────┘"><pre><code>31      20 19   15 14  12 11    7 6      0
┌─────────┬───────┬──────┬───────┬────────┐
│ 0x7b1   │ 0x08  │ 0x1  │ 0x00  │ 0x73   │
│ CSR addr│ rs1   │funct3│  rd   │ opcode │
│  DPC    │  s0   │CSRRW │  x0   │ SYSTEM │
└─────────┴───────┴──────┴───────┴────────┘
</code></pre></div>
<p dir="auto"><strong>funct3=0x1 (CSRRW)</strong>: CSR Read and Write. The old CSR value is discarded (rd=x0), and s0&#39;s value is written to DPC.</p>
<div dir="auto"><h4 tabindex="-1" dir="auto">7.D.6 PROGBUF Execution Constraints</h4><a id="user-content-7d6-progbuf-execution-constraints" aria-label="Permalink: 7.D.6 PROGBUF Execution Constraints" href="#7d6-progbuf-execution-constraints"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The PROGBUF execution environment imposes several constraints:</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Memory Access Limitation</strong>: PROGBUF instructions execute in debug mode, where memory access depends on Debug Module configuration. Standard loads/stores may fault.</p>
</li>
<li>
<p dir="auto"><strong>Instruction Count</strong>: With only 2 entries, complex operations require multiple PROGBUF sequences. Each sequence incurs the cost of abstract command execution (~100µs typical).</p>
</li>
<li>
<p dir="auto"><strong>No Branching</strong>: PROGBUF is linear. Conditional execution requires host-side logic to decide which PROGBUF sequence to execute.</p>
</li>
<li>
<p dir="auto"><strong>Register Pressure</strong>: Only one scratch register (s0) is conventionally used. More complex operations require additional saves/restores.</p>
</li>
<li>
<p dir="auto"><strong>Ebreak Requirement</strong>: The final instruction must be <code>ebreak</code>. Omitting it causes the hart to hang in debug mode.</p>
</li>
</ol>
<p dir="auto">This execution model provides a &#34;remote procedure call&#34; mechanism where the host supplies short instruction sequences that execute atomically on the hart, providing a window into debug-only architectural state.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">8. SYSTEM BUS ACCESS: NON-INTRUSIVE MEMORY OPERATIONS</h2><a id="user-content-8-system-bus-access-non-intrusive-memory-operations" aria-label="Permalink: 8. SYSTEM BUS ACCESS: NON-INTRUSIVE MEMORY OPERATIONS" href="#8-system-bus-access-non-intrusive-memory-operations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">System Bus Access (SBA) represents a fundamental departure from the traditional halt-based debugging model. Where classical debugging requires stopping the hart, transferring data through GPRs, and resuming, SBA provides a &#34;back door&#34; to the memory subsystem that operates concurrently with hart execution.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.A The SBA Architecture</h3><a id="user-content-8a-the-sba-architecture" aria-label="Permalink: 8.A The SBA Architecture" href="#8a-the-sba-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The Debug Module contains a bus master that can initiate memory transactions on the system bus independently of the harts. This master has the following characteristics:</p>
<ol dir="auto">
<li><strong>Separate Bus Master</strong>: SBA transactions do not consume hart resources or execution time</li>
<li><strong>Concurrent Operation</strong>: Memory reads/writes occur while harts execute normally</li>
<li><strong>Cache Coherency Dependency</strong>: SBA bypasses hart caches; coherency is NOT guaranteed</li>
<li><strong>Bus Arbitration</strong>: SBA competes with harts for bus bandwidth</li>
</ol>
<p dir="auto">The SBA interface consists of three memory-mapped registers in the Debug Module:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define DM_SBCS        (0x38 * 4)  // System Bus Access Control and Status
#define DM_SBADDRESS0  (0x39 * 4)  // System Bus Address (32-bit)
#define DM_SBDATA0     (0x3C * 4)  // System Bus Data (32-bit)"><pre><span>#define</span> <span>DM_SBCS</span>        (0x38 * 4)  // System Bus Access Control and Status
<span>#define</span> <span>DM_SBADDRESS0</span>  (0x39 * 4)  // System Bus Address (32-bit)
<span>#define</span> <span>DM_SBDATA0</span>     (0x3C * 4)  // System Bus Data (32-bit)</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.B SBCS: Control and Status Word</h3><a id="user-content-8b-sbcs-control-and-status-word" aria-label="Permalink: 8.B SBCS: Control and Status Word" href="#8b-sbcs-control-and-status-word"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The SBCS register (offset 0x38) contains configuration and status fields defined in RISC-V Debug Spec v0.13.2, section 3.12.18:</p>
<div data-snippet-clipboard-copy-content="31:29 sbversion        (read-only)  SBA version
28:23 (reserved)       0
   22 sbbusyerror      (W1C)        Bus error occurred
   21 sbbusy           (read-only)  Bus master is busy
   20 sbreadonaddr     (read-write) Auto-read on SBADDRESS0 write
19:17 sbaccess         (read-write) Access width: 0=8-bit, 1=16-bit, 2=32-bit
   16 sbautoincrement  (read-write) Auto-increment address after access
   15 sbreadondata     (read-write) Auto-read on SBDATA0 read
14:12 sberror          (W1C)        Error status (0=none, 1=timeout, 2=bad addr, 3=alignment, 4=size, 7=other)
11:5  sbasize          (read-only)  Address width in bits (32 for RP2350)"><pre><code>31:29 sbversion        (read-only)  SBA version
28:23 (reserved)       0
   22 sbbusyerror      (W1C)        Bus error occurred
   21 sbbusy           (read-only)  Bus master is busy
   20 sbreadonaddr     (read-write) Auto-read on SBADDRESS0 write
19:17 sbaccess         (read-write) Access width: 0=8-bit, 1=16-bit, 2=32-bit
   16 sbautoincrement  (read-write) Auto-increment address after access
   15 sbreadondata     (read-write) Auto-read on SBDATA0 read
14:12 sberror          (W1C)        Error status (0=none, 1=timeout, 2=bad addr, 3=alignment, 4=size, 7=other)
11:5  sbasize          (read-only)  Address width in bits (32 for RP2350)
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.C SBA Initialization: Capability Discovery</h3><a id="user-content-8c-sba-initialization-capability-discovery" aria-label="Permalink: 8.C SBA Initialization: Capability Discovery" href="#8c-sba-initialization-capability-discovery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The SBA subsystem initialization (<code>rp2350.c:958-992</code>) follows a capability discovery pattern:</p>
<p dir="auto"><strong>Phase 1: Read SBCS to detect supported features</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="swd_result_t result = dap_read_mem32(target, DM_SBCS);"><pre><span>swd_result_t</span> <span>result</span> <span>=</span> <span>dap_read_mem32</span>(<span>target</span>, <span>DM_SBCS</span>);</pre></div>
<p dir="auto"><strong>Phase 2: Verify SBA capability</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Check sbasize field (bits [11:5]) to verify SBA is present
uint32_t sbasize = (result.value &gt;&gt; 5) &amp; 0x7F;
if (sbasize == 0) {
    return SWD_ERROR_INVALID_STATE;  // SBA not available
}"><pre><span>// Check sbasize field (bits [11:5]) to verify SBA is present</span>
<span>uint32_t</span> <span>sbasize</span> <span>=</span> (<span>result</span>.<span>value</span> &gt;&gt; <span>5</span>) <span>&amp;</span> <span>0x7F</span>;
<span>if</span> (<span>sbasize</span> <span>==</span> <span>0</span>) {
    <span>return</span> <span>SWD_ERROR_INVALID_STATE</span>;  <span>// SBA not available</span>
}</pre></div>
<p dir="auto">The <code>sbasize</code> field indicates the system bus address width (32 bits for RP2350). RP2350 supports 8-bit, 16-bit, and 32-bit access widths. We configure for 32-bit:</p>
<p dir="auto"><strong>Phase 3: Configure access mode</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t sbcs = 0;
sbcs |= (2 &lt;&lt; 17);  // sbaccess = 2 (32-bit)
sbcs |= (1 &lt;&lt; 20);  // sbreadonaddr = 1 (auto-read trigger)
dap_write_mem32(target, DM_SBCS, sbcs);"><pre><span>uint32_t</span> <span>sbcs</span> <span>=</span> <span>0</span>;
<span>sbcs</span> |= (<span>2</span> &lt;&lt; <span>17</span>);  <span>// sbaccess = 2 (32-bit)</span>
<span>sbcs</span> |= (<span>1</span> &lt;&lt; <span>20</span>);  <span>// sbreadonaddr = 1 (auto-read trigger)</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_SBCS</span>, <span>sbcs</span>);</pre></div>
<p dir="auto">The <code>sbreadonaddr</code> flag is critical: it converts the address write into an atomic read-trigger operation.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.D The Auto-Read Mechanism</h3><a id="user-content-8d-the-auto-read-mechanism" aria-label="Permalink: 8.D The Auto-Read Mechanism" href="#8d-the-auto-read-mechanism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Without <code>sbreadonaddr</code>, a memory read requires three transactions:</p>
<div data-snippet-clipboard-copy-content="1. Write address to SBADDRESS0
2. Write SBCS with read trigger
3. Read data from SBDATA0"><pre><code>1. Write address to SBADDRESS0
2. Write SBCS with read trigger
3. Read data from SBDATA0
</code></pre></div>
<p dir="auto">With <code>sbreadonaddr=1</code>, the middle step is eliminated:</p>
<div data-snippet-clipboard-copy-content="1. Write address to SBADDRESS0  ← Triggers bus read automatically
2. Read data from SBDATA0       ← Data is ready"><pre><code>1. Write address to SBADDRESS0  ← Triggers bus read automatically
2. Read data from SBDATA0       ← Data is ready
</code></pre></div>
<p dir="auto">Implementation (<code>rp2350.c:1013-1020</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="dap_write_mem32(target, DM_SBADDRESS0, addr);  // Write triggers read
result = dap_read_mem32(target, DM_SBDATA0);   // Data is already valid"><pre><span>dap_write_mem32</span>(<span>target</span>, <span>DM_SBADDRESS0</span>, <span>addr</span>);  <span>// Write triggers read</span>
<span>result</span> <span>=</span> <span>dap_read_mem32</span>(<span>target</span>, <span>DM_SBDATA0</span>);   <span>// Data is already valid</span></pre></div>
<p dir="auto">The Debug Module&#39;s state machine looks like:</p>
<div data-snippet-clipboard-copy-content="IDLE → [SBADDRESS0 written] → BUSY → [bus read completes] → DATA_READY
                                ↓
                           [bus timeout] → SBERROR=1"><pre><code>IDLE → [SBADDRESS0 written] → BUSY → [bus read completes] → DATA_READY
                                ↓
                           [bus timeout] → SBERROR=1
</code></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.E SBA Write Transactions</h3><a id="user-content-8e-sba-write-transactions" aria-label="Permalink: 8.E SBA Write Transactions" href="#8e-sba-write-transactions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Memory writes use SBDATA0 as the trigger register:</p>
<div dir="auto" data-snippet-clipboard-copy-content="dap_write_mem32(target, DM_SBADDRESS0, addr);   // Set address
dap_write_mem32(target, DM_SBDATA0, value);     // Write triggers bus write"><pre><span>dap_write_mem32</span>(<span>target</span>, <span>DM_SBADDRESS0</span>, <span>addr</span>);   <span>// Set address</span>
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_SBDATA0</span>, <span>value</span>);     <span>// Write triggers bus write</span></pre></div>
<p dir="auto">The write to SBDATA0 initiates the system bus write transaction. The debugger should poll SBCS.sbbusyerror to detect completion (though in practice, pipelined writes are often used).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">8.G SBA Error Handling</h3><a id="user-content-8g-sba-error-handling" aria-label="Permalink: 8.G SBA Error Handling" href="#8g-sba-error-handling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The SBCS.sberror field reports transaction failures:</p>
<div data-snippet-clipboard-copy-content="0: No error
1: Timeout (bus did not respond)
2: Bad address (unmapped region)
3: Bad alignment (misaligned access)
4: Bad size (unsupported width)
7: Other error"><pre><code>0: No error
1: Timeout (bus did not respond)
2: Bad address (unmapped region)
3: Bad alignment (misaligned access)
4: Bad size (unsupported width)
7: Other error
</code></pre></div>
<p dir="auto">Errors are sticky and must be explicitly cleared by writing 1 to SBCS.sberror (W1C = Write-1-to-Clear).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">9. STATE MANAGEMENT AND CACHING</h2><a id="user-content-9-state-management-and-caching" aria-label="Permalink: 9. STATE MANAGEMENT AND CACHING" href="#9-state-management-and-caching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library maintains comprehensive state tracking to avoid redundant SWD transactions:</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">9.A Connection State</h3><a id="user-content-9a-connection-state" aria-label="Permalink: 9.A Connection State" href="#9a-connection-state"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    bool connected;
    uint32_t idcode;
    bool resource_registered;
    // ...
} swd_target_t;"><pre><span>typedef</span> <span>struct</span> {
    <span>bool</span> <span>connected</span>;
    <span>uint32_t</span> <span>idcode</span>;
    <span>bool</span> <span>resource_registered</span>;
    <span>// ...</span>
} <span>swd_target_t</span>;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">9.B DAP State Caching</h3><a id="user-content-9b-dap-state-caching" aria-label="Permalink: 9.B DAP State Caching" href="#9b-dap-state-caching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    uint8_t current_apsel;
    uint8_t current_bank;
    bool ctrlsel;
    uint32_t select_cache;
    bool powered;
    uint retry_count;
} dap_state_t;"><pre><span>typedef</span> <span>struct</span> {
    <span>uint8_t</span> <span>current_apsel</span>;
    <span>uint8_t</span> <span>current_bank</span>;
    <span>bool</span> <span>ctrlsel</span>;
    <span>uint32_t</span> <span>select_cache</span>;
    <span>bool</span> <span>powered</span>;
    <span>uint</span> <span>retry_count</span>;
} <span>dap_state_t</span>;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">9.C Per-Hart State Tracking</h3><a id="user-content-9c-per-hart-state-tracking" aria-label="Permalink: 9.C Per-Hart State Tracking" href="#9c-per-hart-state-tracking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RP2350 contains two RISC-V harts (hardware threads) that execute independently. The library maintains per-hart state to avoid redundant operations and enable concurrent debugging:</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    bool halt_state_known;  // false after resume, true after halt/read status
    bool halted;            // true if hart is currently halted

    // Register cache
    bool cache_valid;       // true if cached values are current
    uint32_t cached_pc;
    uint32_t cached_gprs[32];
    uint64_t cache_timestamp;  // For LRU if needed
} hart_state_t;"><pre><span>typedef</span> <span>struct</span> {
    <span>bool</span> <span>halt_state_known</span>;  <span>// false after resume, true after halt/read status</span>
    <span>bool</span> <span>halted</span>;            <span>// true if hart is currently halted</span>

    <span>// Register cache</span>
    <span>bool</span> <span>cache_valid</span>;       <span>// true if cached values are current</span>
    <span>uint32_t</span> <span>cached_pc</span>;
    <span>uint32_t</span> <span>cached_gprs</span>[<span>32</span>];
    <span>uint64_t</span> <span>cache_timestamp</span>;  <span>// For LRU if needed</span>
} <span>hart_state_t</span>;</pre></div>
<p dir="auto">The top-level RP2350 state maintains an array of hart states:</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define RP2350_NUM_HARTS 2

typedef struct {
    bool initialized;
    bool sba_initialized;

    // Per-hart state
    hart_state_t harts[RP2350_NUM_HARTS];

    // Shared cache configuration
    bool cache_enabled;
} rp2350_state_t;"><pre><span>#define</span> <span>RP2350_NUM_HARTS</span> 2

<span>typedef</span> <span>struct</span> {
    <span>bool</span> <span>initialized</span>;
    <span>bool</span> <span>sba_initialized</span>;

    <span>// Per-hart state</span>
    <span>hart_state_t</span> <span>harts</span>[<span>RP2350_NUM_HARTS</span>];

    <span>// Shared cache configuration</span>
    <span>bool</span> <span>cache_enabled</span>;
} <span>rp2350_state_t</span>;</pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">9.C.1 Halt State Tracking</h4><a id="user-content-9c1-halt-state-tracking" aria-label="Permalink: 9.C.1 Halt State Tracking" href="#9c1-halt-state-tracking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>halt_state_known</code> flag implements a three-state model:</p>
<ol dir="auto">
<li><strong>Unknown</strong> (<code>halt_state_known=false</code>): Hart state is uncertain (after resume or initialization)</li>
<li><strong>Known Halted</strong> (<code>halt_state_known=true, halted=true</code>): Hart is confirmed halted</li>
<li><strong>Known Running</strong> (<code>halt_state_known=true, halted=false</code>): Hart is confirmed running</li>
</ol>
<p dir="auto">This prevents expensive DMSTATUS polls when the state is known. State transitions:</p>
<div data-snippet-clipboard-copy-content="                ┌─────────────┐
                │   Unknown   │
                └──────┬──────┘
                       │
         ┌─────────────┼─────────────┐
         │                           │
    halt_request()             read_dmstatus()
         │                           │
         ▼                           ▼
   ┌────────────┐             ┌──────────────┐
   │   Halted   │             │   Running    │
   └─────┬──────┘             └──────┬───────┘
         │                           │
         │         resume()          │
         └───────────────────────────┘
                      │
                      ▼
                 ┌─────────┐
                 │ Unknown │  (state invalidated)
                 └─────────┘"><pre><code>                ┌─────────────┐
                │   Unknown   │
                └──────┬──────┘
                       │
         ┌─────────────┼─────────────┐
         │                           │
    halt_request()             read_dmstatus()
         │                           │
         ▼                           ▼
   ┌────────────┐             ┌──────────────┐
   │   Halted   │             │   Running    │
   └─────┬──────┘             └──────┬───────┘
         │                           │
         │         resume()          │
         └───────────────────────────┘
                      │
                      ▼
                 ┌─────────┐
                 │ Unknown │  (state invalidated)
                 └─────────┘
</code></pre></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">9.C.2 Register Caching</h4><a id="user-content-9c2-register-caching" aria-label="Permalink: 9.C.2 Register Caching" href="#9c2-register-caching"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When <code>cache_enabled=true</code>, the library caches register values after reads. This optimization benefits:</p>
<ol dir="auto">
<li><strong>Repeated reads</strong> of the same register (e.g., polling loop variables)</li>
<li><strong>Bulk register dumps</strong> where <code>rp2350_read_all_regs()</code> populates the cache</li>
<li><strong>Reduced SWD traffic</strong> (each register read requires ~6 SWD transactions)</li>
</ol>
<p dir="auto">Cache invalidation occurs on:</p>
<ul dir="auto">
<li>Hart resume (execution changes registers)</li>
<li>Register write (specific register invalidated)</li>
<li>Hart halt request (conservative invalidation)</li>
</ul>
<p dir="auto">The cache is per-hart, allowing concurrent debugging of both harts without interference.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">10. RESOURCE MANAGEMENT</h2><a id="user-content-10-resource-management" aria-label="Permalink: 10. RESOURCE MANAGEMENT" href="#10-resource-management"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">PIO resources are scarce: RP2040/RP2350 provide 2 PIO blocks with 4 state machines each. The library implements a global resource tracker for multi-target support.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">10.A Global Resource Tracking</h3><a id="user-content-10a-global-resource-tracking" aria-label="Permalink: 10.A Global Resource Tracking" href="#10a-global-resource-tracking"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    swd_target_t *pio0_sm_owners[4];
    swd_target_t *pio1_sm_owners[4];
    uint active_count;
} resource_tracker_t;

extern resource_tracker_t g_resources;"><pre><span>typedef</span> <span>struct</span> {
    <span>swd_target_t</span> <span>*</span><span>pio0_sm_owners</span>[<span>4</span>];
    <span>swd_target_t</span> <span>*</span><span>pio1_sm_owners</span>[<span>4</span>];
    <span>uint</span> <span>active_count</span>;
} <span>resource_tracker_t</span>;

<span>extern</span> <span>resource_tracker_t</span> <span>g_resources</span>;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">10.B Automatic Allocation</h3><a id="user-content-10b-automatic-allocation" aria-label="Permalink: 10.B Automatic Allocation" href="#10b-automatic-allocation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When <code>SWD_PIO_AUTO</code> or <code>SWD_SM_AUTO</code> is specified in configuration, the library scans for free resources (<code>swd.c:105-125</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="swd_error_t allocate_pio_sm(PIO *pio, uint *sm) {
    for (uint i = 0; i &lt; 4; i++) {
        if (g_resources.pio0_sm_owners[i] == NULL) {
            *pio = pio0;
            *sm = i;
            return SWD_OK;
        }
    }
    // Try PIO1...
}"><pre><span>swd_error_t</span> <span>allocate_pio_sm</span>(<span>PIO</span> <span>*</span><span>pio</span>, <span>uint</span> <span>*</span><span>sm</span>) {
    <span>for</span> (<span>uint</span> <span>i</span> <span>=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>4</span>; <span>i</span><span>++</span>) {
        <span>if</span> (<span>g_resources</span>.<span>pio0_sm_owners</span>[<span>i</span>] <span>==</span> <span>NULL</span>) {
            <span>*</span><span>pio</span> <span>=</span> <span>pio0</span>;
            <span>*</span><span>sm</span> <span>=</span> <span>i</span>;
            <span>return</span> <span>SWD_OK</span>;
        }
    }
    <span>// Try PIO1...</span>
}</pre></div>
<p dir="auto">Up to 8 simultaneous target connections are supported (limited by hardware resources).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">11. ERROR HANDLING AND RECOVERY</h2><a id="user-content-11-error-handling-and-recovery" aria-label="Permalink: 11. ERROR HANDLING AND RECOVERY" href="#11-error-handling-and-recovery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library provides comprehensive error reporting through enumerated error codes and detailed message strings.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">11.A Error Code Taxonomy</h3><a id="user-content-11a-error-code-taxonomy" aria-label="Permalink: 11.A Error Code Taxonomy" href="#11a-error-code-taxonomy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="typedef enum {
    SWD_OK = 0,
    SWD_ERROR_TIMEOUT,        // Transaction timeout
    SWD_ERROR_FAULT,          // Target FAULT response
    SWD_ERROR_PROTOCOL,       // Malformed packet
    SWD_ERROR_PARITY,         // Parity check failure
    SWD_ERROR_WAIT,           // WAIT response retry exhausted
    SWD_ERROR_NOT_CONNECTED,  // No active connection
    SWD_ERROR_NOT_HALTED,     // Operation requires halted hart
    SWD_ERROR_ALREADY_HALTED, // Hart already halted (informational)
    // ...
} swd_error_t;"><pre><span>typedef</span> <span>enum</span> {
    <span>SWD_OK</span> <span>=</span> <span>0</span>,
    <span>SWD_ERROR_TIMEOUT</span>,        <span>// Transaction timeout</span>
    <span>SWD_ERROR_FAULT</span>,          <span>// Target FAULT response</span>
    <span>SWD_ERROR_PROTOCOL</span>,       <span>// Malformed packet</span>
    <span>SWD_ERROR_PARITY</span>,         <span>// Parity check failure</span>
    <span>SWD_ERROR_WAIT</span>,           <span>// WAIT response retry exhausted</span>
    <span>SWD_ERROR_NOT_CONNECTED</span>,  <span>// No active connection</span>
    <span>SWD_ERROR_NOT_HALTED</span>,     <span>// Operation requires halted hart</span>
    <span>SWD_ERROR_ALREADY_HALTED</span>, <span>// Hart already halted (informational)</span>
    <span>// ...</span>
} <span>swd_error_t</span>;</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">11.B Error Detail Buffer</h3><a id="user-content-11b-error-detail-buffer" aria-label="Permalink: 11.B Error Detail Buffer" href="#11b-error-detail-buffer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Each target maintains a 128-byte error detail buffer for formatted diagnostic messages (<code>swd.c:67-84</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="void swd_set_error(swd_target_t *target, swd_error_t error,
                   const char *detail, ...) {
    target-&gt;last_error = error;
    va_list args;
    va_start(args, detail);
    vsnprintf(target-&gt;error_detail, sizeof(target-&gt;error_detail),
              detail, args);
    va_end(args);
}"><pre><span>void</span> <span>swd_set_error</span>(<span>swd_target_t</span> <span>*</span><span>target</span>, <span>swd_error_t</span> <span>error</span>,
                   <span>const</span> <span>char</span> <span>*</span><span>detail</span>, ...) {
    <span>target</span><span>-&gt;</span><span>last_error</span> <span>=</span> <span>error</span>;
    <span>va_list</span> <span>args</span>;
    <span>va_start</span>(<span>args</span>, <span>detail</span>);
    <span>vsnprintf</span>(<span>target</span><span>-&gt;</span><span>error_detail</span>, <span>sizeof</span>(<span>target</span><span>-&gt;</span><span>error_detail</span>),
              <span>detail</span>, <span>args</span>);
    <span>va_end</span>(<span>args</span>);
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">11.C ACK Response Mapping</h3><a id="user-content-11c-ack-response-mapping" aria-label="Permalink: 11.C ACK Response Mapping" href="#11c-ack-response-mapping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">SWD protocol ACK responses are mapped to error codes (<code>swd.c:91-99</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="swd_error_t swd_ack_to_error(uint8_t ack) {
    switch (ack) {
        case 0x1: return SWD_OK;            // OK
        case 0x2: return SWD_ERROR_WAIT;    // WAIT
        case 0x4: return SWD_ERROR_FAULT;   // FAULT
        default:  return SWD_ERROR_PROTOCOL;
    }
}"><pre><span>swd_error_t</span> <span>swd_ack_to_error</span>(<span>uint8_t</span> <span>ack</span>) {
    <span>switch</span> (<span>ack</span>) {
        <span>case</span> <span>0x1</span>: <span>return</span> <span>SWD_OK</span>;            <span>// OK</span>
        <span>case</span> <span>0x2</span>: <span>return</span> <span>SWD_ERROR_WAIT</span>;    <span>// WAIT</span>
        <span>case</span> <span>0x4</span>: <span>return</span> <span>SWD_ERROR_FAULT</span>;   <span>// FAULT</span>
        <span>default</span>:  <span>return</span> <span>SWD_ERROR_PROTOCOL</span>;
    }
}</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">11.D Retry Mechanism</h3><a id="user-content-11d-retry-mechanism" aria-label="Permalink: 11.D Retry Mechanism" href="#11d-retry-mechanism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">WAIT responses trigger automatic retry with backoff (<code>swd_protocol.c:197-208</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="for (uint retry = 0; retry &lt; target-&gt;dap.retry_count; retry++) {
    err = swd_io_raw(target, request, value, false);
    if (err != SWD_ERROR_WAIT) break;
    sleep_us(100);
}"><pre><span>for</span> (<span>uint</span> <span>retry</span> <span>=</span> <span>0</span>; <span>retry</span> <span>&lt;</span> <span>target</span><span>-&gt;</span><span>dap</span>.<span>retry_count</span>; <span>retry</span><span>++</span>) {
    <span>err</span> <span>=</span> <span>swd_io_raw</span>(<span>target</span>, <span>request</span>, <span>value</span>, false);
    <span>if</span> (<span>err</span> <span>!=</span> <span>SWD_ERROR_WAIT</span>) <span>break</span>;
    <span>sleep_us</span>(<span>100</span>);
}</pre></div>
<p dir="auto">Default retry count is 5, configurable via <code>swd_config_t</code>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">12. API USAGE</h2><a id="user-content-12-api-usage" aria-label="Permalink: 12. API USAGE" href="#12-api-usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.A Target Creation and Connection</h3><a id="user-content-12a-target-creation-and-connection" aria-label="Permalink: 12.A Target Creation and Connection" href="#12a-target-creation-and-connection"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="swd_config_t config = swd_config_default();
config.pin_swclk = 2;
config.pin_swdio = 3;
config.freq_khz = 1000;
config.enable_caching = true;

swd_target_t *target = swd_target_create(&amp;config);
swd_connect(target);
rp2350_init(target);"><pre><span>swd_config_t</span> <span>config</span> <span>=</span> <span>swd_config_default</span>();
<span>config</span>.<span>pin_swclk</span> <span>=</span> <span>2</span>;
<span>config</span>.<span>pin_swdio</span> <span>=</span> <span>3</span>;
<span>config</span>.<span>freq_khz</span> <span>=</span> <span>1000</span>;
<span>config</span>.<span>enable_caching</span> <span>=</span> true;

<span>swd_target_t</span> <span>*</span><span>target</span> <span>=</span> <span>swd_target_create</span>(<span>&amp;</span><span>config</span>);
<span>swd_connect</span>(<span>target</span>);
<span>rp2350_init</span>(<span>target</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.B Hart Control</h3><a id="user-content-12b-hart-control" aria-label="Permalink: 12.B Hart Control" href="#12b-hart-control"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Halt hart 0
rp2350_halt(target, 0);

// Read program counter
swd_result_t pc = rp2350_read_pc(target, 0);
if (pc.error == SWD_OK) {
    printf(&#34;PC: 0x%08x\n&#34;, pc.value);
}

// Read all registers
uint32_t regs[32];
rp2350_read_all_regs(target, 0, regs);

// Single-step execution
rp2350_step(target, 0);

// Resume execution
rp2350_resume(target, 0);

// Reset hart
rp2350_reset(target, 0, true);  // Reset and halt"><pre><span>// Halt hart 0</span>
<span>rp2350_halt</span>(<span>target</span>, <span>0</span>);

<span>// Read program counter</span>
<span>swd_result_t</span> <span>pc</span> <span>=</span> <span>rp2350_read_pc</span>(<span>target</span>, <span>0</span>);
<span>if</span> (<span>pc</span>.<span>error</span> <span>==</span> <span>SWD_OK</span>) {
    <span>printf</span>(<span>&#34;PC: 0x%08x\n&#34;</span>, <span>pc</span>.<span>value</span>);
}

<span>// Read all registers</span>
<span>uint32_t</span> <span>regs</span>[<span>32</span>];
<span>rp2350_read_all_regs</span>(<span>target</span>, <span>0</span>, <span>regs</span>);

<span>// Single-step execution</span>
<span>rp2350_step</span>(<span>target</span>, <span>0</span>);

<span>// Resume execution</span>
<span>rp2350_resume</span>(<span>target</span>, <span>0</span>);

<span>// Reset hart</span>
<span>rp2350_reset</span>(<span>target</span>, <span>0</span>, true);  <span>// Reset and halt</span></pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.C Memory Operations</h3><a id="user-content-12c-memory-operations" aria-label="Permalink: 12.C Memory Operations" href="#12c-memory-operations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Read memory (non-intrusive via SBA)
swd_result_t result = rp2350_read_mem32(target, 0x20000000);

// Write memory
rp2350_write_mem32(target, 0x20000000, 0xDEADBEEF);

// Block operations
uint32_t buffer[256];
rp2350_read_mem_block(target, 0x20000000, buffer, 256);"><pre><span>// Read memory (non-intrusive via SBA)</span>
<span>swd_result_t</span> <span>result</span> <span>=</span> <span>rp2350_read_mem32</span>(<span>target</span>, <span>0x20000000</span>);

<span>// Write memory</span>
<span>rp2350_write_mem32</span>(<span>target</span>, <span>0x20000000</span>, <span>0xDEADBEEF</span>);

<span>// Block operations</span>
<span>uint32_t</span> <span>buffer</span>[<span>256</span>];
<span>rp2350_read_mem_block</span>(<span>target</span>, <span>0x20000000</span>, <span>buffer</span>, <span>256</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.D Code Execution</h3><a id="user-content-12d-code-execution" aria-label="Permalink: 12.D Code Execution" href="#12d-code-execution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="const uint32_t program[] = {
    0x200415b7,  // lui  a1, 0x20040
    0xabcd0537,  // lui  a0, 0xabcd0
    0x23450513,  // addi a0, a0, 0x234
    0x00a5a223,  // sw   a0, 4(a1)
    0x0000006f,  // j    0 (infinite loop)
};

rp2350_execute_code(target, 0, 0x20000000, program, 5);"><pre><span>const</span> <span>uint32_t</span> <span>program</span>[] <span>=</span> {
    <span>0x200415b7</span>,  <span>// lui  a1, 0x20040</span>
    <span>0xabcd0537</span>,  <span>// lui  a0, 0xabcd0</span>
    <span>0x23450513</span>,  <span>// addi a0, a0, 0x234</span>
    <span>0x00a5a223</span>,  <span>// sw   a0, 4(a1)</span>
    <span>0x0000006f</span>,  <span>// j    0 (infinite loop)</span>
};

<span>rp2350_execute_code</span>(<span>target</span>, <span>0</span>, <span>0x20000000</span>, <span>program</span>, <span>5</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.E Instruction Tracing</h3><a id="user-content-12e-instruction-tracing" aria-label="Permalink: 12.E Instruction Tracing" href="#12e-instruction-tracing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Trace callback receives each executed instruction
bool trace_callback(const trace_record_t *record, void *user_data) {
    printf(&#34;PC: 0x%08x  Instruction: 0x%08x\n&#34;,
           record-&gt;pc, record-&gt;instruction);

    // Optional: inspect registers
    if (record-&gt;regs) {
        printf(&#34;  x5=0x%08x\n&#34;, record-&gt;regs[5]);
    }

    return true;  // Continue tracing (false = stop)
}

// Trace 100 instructions on hart 0, capturing registers
int count = rp2350_trace(target, 0, 100, trace_callback, NULL, true);
printf(&#34;Traced %d instructions\n&#34;, count);"><pre><span>// Trace callback receives each executed instruction</span>
<span>bool</span> <span>trace_callback</span>(<span>const</span> <span>trace_record_t</span> <span>*</span><span>record</span>, <span>void</span> <span>*</span><span>user_data</span>) {
    <span>printf</span>(<span>&#34;PC: 0x%08x  Instruction: 0x%08x\n&#34;</span>,
           <span>record</span><span>-&gt;</span><span>pc</span>, <span>record</span><span>-&gt;</span><span>instruction</span>);

    <span>// Optional: inspect registers</span>
    <span>if</span> (<span>record</span><span>-&gt;</span><span>regs</span>) {
        <span>printf</span>(<span>&#34;  x5=0x%08x\n&#34;</span>, <span>record</span><span>-&gt;</span><span>regs</span>[<span>5</span>]);
    }

    <span>return</span> true;  <span>// Continue tracing (false = stop)</span>
}

<span>// Trace 100 instructions on hart 0, capturing registers</span>
<span>int</span> <span>count</span> <span>=</span> <span>rp2350_trace</span>(<span>target</span>, <span>0</span>, <span>100</span>, <span>trace_callback</span>, <span>NULL</span>, true);
<span>printf</span>(<span>&#34;Traced %d instructions\n&#34;</span>, <span>count</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">12.F Dual-Hart Operations</h3><a id="user-content-12f-dual-hart-operations" aria-label="Permalink: 12.F Dual-Hart Operations" href="#12f-dual-hart-operations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="// Operate on both harts independently
rp2350_halt(target, 0);
rp2350_halt(target, 1);

// Read registers from both harts
uint32_t h0_regs[32], h1_regs[32];
rp2350_read_all_regs(target, 0, h0_regs);
rp2350_read_all_regs(target, 1, h1_regs);

// Execute different programs on each hart
rp2350_execute_code(target, 0, 0x20000000, program0, len0);
rp2350_execute_code(target, 1, 0x20001000, program1, len1);

// Trace hart 1 while hart 0 runs
rp2350_resume(target, 0);
rp2350_trace(target, 1, 50, trace_callback, NULL, false);"><pre><span>// Operate on both harts independently</span>
<span>rp2350_halt</span>(<span>target</span>, <span>0</span>);
<span>rp2350_halt</span>(<span>target</span>, <span>1</span>);

<span>// Read registers from both harts</span>
<span>uint32_t</span> <span>h0_regs</span>[<span>32</span>], <span>h1_regs</span>[<span>32</span>];
<span>rp2350_read_all_regs</span>(<span>target</span>, <span>0</span>, <span>h0_regs</span>);
<span>rp2350_read_all_regs</span>(<span>target</span>, <span>1</span>, <span>h1_regs</span>);

<span>// Execute different programs on each hart</span>
<span>rp2350_execute_code</span>(<span>target</span>, <span>0</span>, <span>0x20000000</span>, <span>program0</span>, <span>len0</span>);
<span>rp2350_execute_code</span>(<span>target</span>, <span>1</span>, <span>0x20001000</span>, <span>program1</span>, <span>len1</span>);

<span>// Trace hart 1 while hart 0 runs</span>
<span>rp2350_resume</span>(<span>target</span>, <span>0</span>);
<span>rp2350_trace</span>(<span>target</span>, <span>1</span>, <span>50</span>, <span>trace_callback</span>, <span>NULL</span>, false);</pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">13. BUILDING AND INTEGRATION</h2><a id="user-content-13-building-and-integration" aria-label="Permalink: 13. BUILDING AND INTEGRATION" href="#13-building-and-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">13.A CMake Integration</h3><a id="user-content-13a-cmake-integration" aria-label="Permalink: 13.A CMake Integration" href="#13a-cmake-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="add_subdirectory(lib/pico2-swd-riscv)
target_link_libraries(your_application pico2_swd_riscv)"><pre><span>add_subdirectory</span>(lib/pico2-swd-riscv)
<span>target_link_libraries</span>(your_application pico2_swd_riscv)</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">13.B Debug Level Configuration</h3><a id="user-content-13b-debug-level-configuration" aria-label="Permalink: 13.B Debug Level Configuration" href="#13b-debug-level-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Set compile-time debug verbosity:</p>
<div dir="auto" data-snippet-clipboard-copy-content="target_compile_definitions(your_application PRIVATE PICO2_SWD_DEBUG_LEVEL=3)"><pre><span>target_compile_definitions</span>(your_application <span>PRIVATE</span> PICO2_SWD_DEBUG_LEVEL=3)</pre></div>
<p dir="auto">Levels: 0 (none), 1 (warnings), 2 (info), 3 (debug).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">14. REFERENCES</h2><a id="user-content-14-references" aria-label="Permalink: 14. REFERENCES" href="#14-references"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>ARM Debug Interface Architecture Specification v5.2</li>
<li>ARM CoreSight SWD-DP Technical Reference Manual</li>
<li>RISC-V External Debug Support version 0.13</li>
<li>RP2350 Datasheet, Chapter 3.5: Debug</li>
<li>ADIv5.2 Supplement for Multi-drop SWD</li>
<li>IEEE 1149.1-2001 (JTAG)</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">15. RISC-V SINGLE-STEP EXECUTION</h2><a id="user-content-15-risc-v-single-step-execution" aria-label="Permalink: 15. RISC-V SINGLE-STEP EXECUTION" href="#15-risc-v-single-step-execution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Single-step execution enables instruction-level debugging by executing exactly one instruction before re-entering debug mode. This is implemented via the DCSR.step bit (Debug Control and Status Register, bit 2).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">15.A The Step Bit Mechanism</h3><a id="user-content-15a-the-step-bit-mechanism" aria-label="Permalink: 15.A The Step Bit Mechanism" href="#15a-the-step-bit-mechanism"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When DCSR.step=1, the hart executes one instruction after <code>resumereq</code>, then immediately re-halts:</p>
<div data-snippet-clipboard-copy-content="Debug Mode → [resumereq + DCSR.step=1] → Execute 1 instruction → Debug Mode"><pre><code>Debug Mode → [resumereq + DCSR.step=1] → Execute 1 instruction → Debug Mode
</code></pre></div>
<p dir="auto">Implementation (<code>rp2350.c:431-504</code>):</p>
<p dir="auto"><strong>Phase 1: Read current DCSR</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="swd_result_t dcsr_result = read_dcsr(target, hart_id);"><pre><span>swd_result_t</span> <span>dcsr_result</span> <span>=</span> <span>read_dcsr</span>(<span>target</span>, <span>hart_id</span>);</pre></div>
<p dir="auto">DCSR must be read via PROGBUF (see Section 7.D) because it&#39;s a debug-only CSR.</p>
<p dir="auto"><strong>Phase 2: Set step bit</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t dcsr_stepped = dcsr_result.value | (1 &lt;&lt; 2);
write_dcsr(target, hart_id, dcsr_stepped);"><pre><span>uint32_t</span> <span>dcsr_stepped</span> <span>=</span> <span>dcsr_result</span>.<span>value</span> | (<span>1</span> &lt;&lt; <span>2</span>);
<span>write_dcsr</span>(<span>target</span>, <span>hart_id</span>, <span>dcsr_stepped</span>);</pre></div>
<p dir="auto"><strong>Phase 3: Resume hart</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t dmcontrol = make_dmcontrol(hart_id, false, true, false);
dap_write_mem32(target, DM_DMCONTROL, dmcontrol);"><pre><span>uint32_t</span> <span>dmcontrol</span> <span>=</span> <span>make_dmcontrol</span>(<span>hart_id</span>, false, true, false);
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_DMCONTROL</span>, <span>dmcontrol</span>);</pre></div>
<p dir="auto">The hart now executes exactly one instruction, then:</p>
<ol dir="auto">
<li>PC is saved to DPC</li>
<li>Hart re-enters debug mode</li>
<li>DCSR.cause = 0x4 (single-step)</li>
</ol>
<p dir="auto"><strong>Phase 4: Wait for automatic halt</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="poll_dmstatus_halted(target, hart_id, true);"><pre><span>poll_dmstatus_halted</span>(<span>target</span>, <span>hart_id</span>, true);</pre></div>
<p dir="auto"><strong>Phase 5: Clear step bit</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="write_dcsr(target, hart_id, dcsr_result.value);  // Restore original DCSR"><pre><span>write_dcsr</span>(<span>target</span>, <span>hart_id</span>, <span>dcsr_result</span>.<span>value</span>);  <span>// Restore original DCSR</span></pre></div>
<p dir="auto">This ensures subsequent <code>rp2350_resume()</code> calls don&#39;t single-step.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">16. INSTRUCTION TRACING VIA ITERATED SINGLE-STEPPING</h2><a id="user-content-16-instruction-tracing-via-iterated-single-stepping" aria-label="Permalink: 16. INSTRUCTION TRACING VIA ITERATED SINGLE-STEPPING" href="#16-instruction-tracing-via-iterated-single-stepping"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library implements software instruction tracing by repeatedly single-stepping and recording each instruction. This provides a &#34;time-travel&#34; debugging capability at the cost of execution speed.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">16.A The Trace Callback Model</h3><a id="user-content-16a-the-trace-callback-model" aria-label="Permalink: 16.A The Trace Callback Model" href="#16a-the-trace-callback-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Tracing uses a callback function to process each instruction (<code>rp2350.c:1262-1337</code>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="typedef struct {
    uint32_t pc;
    uint32_t instruction;
    uint32_t regs[32];  // Valid if capture_regs=true
} trace_record_t;

typedef bool (*trace_callback_t)(const trace_record_t *record, void *user_data);"><pre><span>typedef</span> <span>struct</span> {
    <span>uint32_t</span> <span>pc</span>;
    <span>uint32_t</span> <span>instruction</span>;
    <span>uint32_t</span> <span>regs</span>[<span>32</span>];  <span>// Valid if capture_regs=true</span>
} <span>trace_record_t</span>;

<span>typedef</span> <span>bool</span> (<span>*</span><span>trace_callback_t</span>)(<span>const</span> <span>trace_record_t</span> <span>*</span><span>record</span>, <span>void</span> <span>*</span><span>user_data</span>);</pre></div>
<p dir="auto">The callback returns <code>true</code> to continue or <code>false</code> to stop.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">16.B Trace Implementation</h3><a id="user-content-16b-trace-implementation" aria-label="Permalink: 16.B Trace Implementation" href="#16b-trace-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="int rp2350_trace(swd_target_t *target, uint8_t hart_id,
                 uint32_t max_instructions,
                 trace_callback_t callback, void *user_data,
                 bool capture_regs);"><pre><span>int</span> <span>rp2350_trace</span>(<span>swd_target_t</span> <span>*</span><span>target</span>, <span>uint8_t</span> <span>hart_id</span>,
                 <span>uint32_t</span> <span>max_instructions</span>,
                 <span>trace_callback_t</span> <span>callback</span>, <span>void</span> <span>*</span><span>user_data</span>,
                 <span>bool</span> <span>capture_regs</span>);</pre></div>
<p dir="auto">For each instruction:</p>
<ol dir="auto">
<li><strong>Read PC</strong> (via PROGBUF): Current instruction address</li>
<li><strong>Read memory at PC</strong>: Fetch the instruction word</li>
<li><strong>Optional: Read all GPRs</strong>: If <code>capture_regs=true</code></li>
<li><strong>Invoke callback</strong>: User processes the record</li>
<li><strong>Single-step</strong>: Execute one instruction</li>
<li><strong>Repeat</strong> until <code>max_instructions</code> or callback returns false</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">16.C Trace Use Cases</h3><a id="user-content-16c-trace-use-cases" aria-label="Permalink: 16.C Trace Use Cases" href="#16c-trace-use-cases"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><strong>Loop Detection</strong>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bool detect_loop(const trace_record_t *record, void *user_data) {
    static uint32_t entry_pc = 0;
    static int count = 0;

    if (count == 0) entry_pc = record-&gt;pc;
    if (record-&gt;pc == entry_pc &amp;&amp; count &gt; 0) {
        printf(&#34;Loop detected at PC=0x%08x\n&#34;, record-&gt;pc);
        return false;  // Stop trace
    }
    count++;
    return true;
}"><pre><span>bool</span> <span>detect_loop</span>(<span>const</span> <span>trace_record_t</span> <span>*</span><span>record</span>, <span>void</span> <span>*</span><span>user_data</span>) {
    <span>static</span> <span>uint32_t</span> <span>entry_pc</span> <span>=</span> <span>0</span>;
    <span>static</span> <span>int</span> <span>count</span> <span>=</span> <span>0</span>;

    <span>if</span> (<span>count</span> <span>==</span> <span>0</span>) <span>entry_pc</span> <span>=</span> <span>record</span><span>-&gt;</span><span>pc</span>;
    <span>if</span> (<span>record</span><span>-&gt;</span><span>pc</span> <span>==</span> <span>entry_pc</span> <span>&amp;&amp;</span> <span>count</span> <span>&gt;</span> <span>0</span>) {
        <span>printf</span>(<span>&#34;Loop detected at PC=0x%08x\n&#34;</span>, <span>record</span><span>-&gt;</span><span>pc</span>);
        <span>return</span> false;  <span>// Stop trace</span>
    }
    <span>count</span><span>++</span>;
    <span>return</span> true;
}</pre></div>
<p dir="auto"><strong>Register State History</strong>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bool capture_state(const trace_record_t *record, void *user_data) {
    printf(&#34;%08x: %08x  x5=%08x x6=%08x\n&#34;,
           record-&gt;pc, record-&gt;instruction,
           record-&gt;regs[5], record-&gt;regs[6]);
    return true;
}

rp2350_trace(target, 0, 100, capture_state, NULL, true);"><pre><span>bool</span> <span>capture_state</span>(<span>const</span> <span>trace_record_t</span> <span>*</span><span>record</span>, <span>void</span> <span>*</span><span>user_data</span>) {
    <span>printf</span>(<span>&#34;%08x: %08x  x5=%08x x6=%08x\n&#34;</span>,
           <span>record</span><span>-&gt;</span><span>pc</span>, <span>record</span><span>-&gt;</span><span>instruction</span>,
           <span>record</span><span>-&gt;</span><span>regs</span>[<span>5</span>], <span>record</span><span>-&gt;</span><span>regs</span>[<span>6</span>]);
    <span>return</span> true;
}

<span>rp2350_trace</span>(<span>target</span>, <span>0</span>, <span>100</span>, <span>capture_state</span>, <span>NULL</span>, true);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">16.D Trace Limitations</h3><a id="user-content-16d-trace-limitations" aria-label="Permalink: 16.D Trace Limitations" href="#16d-trace-limitations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li><strong>Speed</strong>: ~5ms per instruction (200 instructions/second)</li>
<li><strong>Interrupt Masking</strong>: Tracing should occur with interrupts disabled (clear mstatus.MIE)</li>
<li><strong>Memory Consistency</strong>: Instructions are fetched via SBA; ensure I-cache coherency</li>
<li><strong>No Hardware Triggers</strong>: Trace starts immediately; no &#34;trace until condition&#34;</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">17. HART RESET OPERATIONS</h2><a id="user-content-17-hart-reset-operations" aria-label="Permalink: 17. HART RESET OPERATIONS" href="#17-hart-reset-operations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Hart reset (<code>rp2350_reset</code>) implements a controlled reset sequence via DMCONTROL.ndmreset (non-debug module reset, bit 1).</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">17.A Reset Sequence</h3><a id="user-content-17a-reset-sequence" aria-label="Permalink: 17.A Reset Sequence" href="#17a-reset-sequence"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="swd_error_t rp2350_reset(swd_target_t *target, uint8_t hart_id,
                         bool halt_on_reset);"><pre><span>swd_error_t</span> <span>rp2350_reset</span>(<span>swd_target_t</span> <span>*</span><span>target</span>, <span>uint8_t</span> <span>hart_id</span>,
                         <span>bool</span> <span>halt_on_reset</span>);</pre></div>
<p dir="auto"><strong>Phase 1: Assert ndmreset</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="uint32_t dmcontrol = make_dmcontrol(hart_id, halt_on_reset, false, true);
dap_write_mem32(target, DM_DMCONTROL, dmcontrol);
sleep_ms(10);  // Hold reset"><pre><span>uint32_t</span> <span>dmcontrol</span> <span>=</span> <span>make_dmcontrol</span>(<span>hart_id</span>, <span>halt_on_reset</span>, false, true);
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_DMCONTROL</span>, <span>dmcontrol</span>);
<span>sleep_ms</span>(<span>10</span>);  <span>// Hold reset</span></pre></div>
<p dir="auto"><strong>Phase 2: Deassert ndmreset</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="dmcontrol = make_dmcontrol(hart_id, halt_on_reset, false, false);
dap_write_mem32(target, DM_DMCONTROL, dmcontrol);
sleep_ms(50);  // Wait for reset completion"><pre><span>dmcontrol</span> <span>=</span> <span>make_dmcontrol</span>(<span>hart_id</span>, <span>halt_on_reset</span>, false, false);
<span>dap_write_mem32</span>(<span>target</span>, <span>DM_DMCONTROL</span>, <span>dmcontrol</span>);
<span>sleep_ms</span>(<span>50</span>);  <span>// Wait for reset completion</span></pre></div>
<p dir="auto">If <code>halt_on_reset=true</code>, the DMCONTROL.haltreq bit remains set, causing the hart to enter debug mode immediately after reset, with PC set to the reset vector.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">17.B Reset vs Power-On</h3><a id="user-content-17b-reset-vs-power-on" aria-label="Permalink: 17.B Reset vs Power-On" href="#17b-reset-vs-power-on"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This reset is equivalent to a power-on reset for the hart:</p>
<ul dir="auto">
<li>PC → reset vector (typically 0x00000000 for RP2350 RISC-V cores)</li>
<li>All CSRs → architectural reset values</li>
<li>GPRs → undefined</li>
<li>Cache → invalidated</li>
</ul>
<p dir="auto">Unlike a full chip reset, peripherals and other harts are unaffected.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">18. DUAL-HART ARCHITECTURE</h2><a id="user-content-18-dual-hart-architecture" aria-label="Permalink: 18. DUAL-HART ARCHITECTURE" href="#18-dual-hart-architecture"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RP2350&#39;s two RISC-V harts (Hazard3 cores) are symmetric and independently controllable. The library provides full per-hart state tracking and concurrent operation.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">18.A Hart Selection via DMCONTROL</h3><a id="user-content-18a-hart-selection-via-dmcontrol" aria-label="Permalink: 18.A Hart Selection via DMCONTROL" href="#18a-hart-selection-via-dmcontrol"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Each Debug Module operation targets a specific hart via DMCONTROL.hartsel[9:0]:</p>
<div dir="auto" data-snippet-clipboard-copy-content="static inline uint32_t make_dmcontrol(uint8_t hart_id, bool haltreq,
                                       bool resumereq, bool ndmreset) {
    uint32_t dmcontrol = (1 &lt;&lt; 0);  // dmactive = 1
    dmcontrol |= ((uint32_t)hart_id &lt;&lt; 16);  // hartsello[9:0] at bits 25:16
    if (haltreq) dmcontrol |= (1 &lt;&lt; 31);
    if (resumereq) dmcontrol |= (1 &lt;&lt; 30);
    if (ndmreset) dmcontrol |= (1 &lt;&lt; 1);
    return dmcontrol;
}"><pre><span>static</span> <span>inline</span> <span>uint32_t</span> <span>make_dmcontrol</span>(<span>uint8_t</span> <span>hart_id</span>, <span>bool</span> <span>haltreq</span>,
                                       <span>bool</span> <span>resumereq</span>, <span>bool</span> <span>ndmreset</span>) {
    <span>uint32_t</span> <span>dmcontrol</span> <span>=</span> (<span>1</span> &lt;&lt; <span>0</span>);  <span>// dmactive = 1</span>
    <span>dmcontrol</span> |= ((<span>uint32_t</span>)<span>hart_id</span> &lt;&lt; <span>16</span>);  <span>// hartsello[9:0] at bits 25:16</span>
    <span>if</span> (<span>haltreq</span>) <span>dmcontrol</span> |= (<span>1</span> &lt;&lt; <span>31</span>);
    <span>if</span> (<span>resumereq</span>) <span>dmcontrol</span> |= (<span>1</span> &lt;&lt; <span>30</span>);
    <span>if</span> (<span>ndmreset</span>) <span>dmcontrol</span> |= (<span>1</span> &lt;&lt; <span>1</span>);
    <span>return</span> <span>dmcontrol</span>;
}</pre></div>
<p dir="auto">Before any hart-specific operation (halt, resume, register read), the library writes DMCONTROL with the correct <code>hart_id</code>, switching the Debug Module&#39;s attention to that hart.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">18.B Independent Hart Control</h3><a id="user-content-18b-independent-hart-control" aria-label="Permalink: 18.B Independent Hart Control" href="#18b-independent-hart-control"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The test suite validates that harts operate independently:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Halt hart 0, keep hart 1 running
rp2350_halt(target, 0);
rp2350_resume(target, 1);

// Read hart 0 registers while hart 1 executes
uint32_t h0_regs[32];
rp2350_read_all_regs(target, 0, h0_regs);"><pre><span>// Halt hart 0, keep hart 1 running</span>
<span>rp2350_halt</span>(<span>target</span>, <span>0</span>);
<span>rp2350_resume</span>(<span>target</span>, <span>1</span>);

<span>// Read hart 0 registers while hart 1 executes</span>
<span>uint32_t</span> <span>h0_regs</span>[<span>32</span>];
<span>rp2350_read_all_regs</span>(<span>target</span>, <span>0</span>, <span>h0_regs</span>);</pre></div>
<p dir="auto">This enables debugging one hart while the other maintains real-time operation.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">18.C Register Isolation</h3><a id="user-content-18c-register-isolation" aria-label="Permalink: 18.C Register Isolation" href="#18c-register-isolation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Each hart maintains independent register state. Writing x5 on hart 0 does not affect x5 on hart 1. This is validated by <code>test_dual_hart.c:69-115</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="rp2350_write_reg(target, 0, 5, 0xAAAAAAAA);
rp2350_write_reg(target, 1, 5, 0x55555555);

assert(rp2350_read_reg(target, 0, 5).value == 0xAAAAAAAA);
assert(rp2350_read_reg(target, 1, 5).value == 0x55555555);"><pre><span>rp2350_write_reg</span>(<span>target</span>, <span>0</span>, <span>5</span>, <span>0xAAAAAAAA</span>);
<span>rp2350_write_reg</span>(<span>target</span>, <span>1</span>, <span>5</span>, <span>0x55555555</span>);

<span>assert</span>(<span>rp2350_read_reg</span>(<span>target</span>, <span>0</span>, <span>5</span>).<span>value</span> <span>==</span> <span>0xAAAAAAAA</span>);
<span>assert</span>(<span>rp2350_read_reg</span>(<span>target</span>, <span>1</span>, <span>5</span>).<span>value</span> <span>==</span> <span>0x55555555</span>);</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">18.D Shared Memory, Independent Caches</h3></div>
<p dir="auto">Both harts share the same physical memory space but maintain independent caches. This creates coherency considerations:</p>
<ol dir="auto">
<li><strong>SBA Writes</strong>: Visible to both harts (after cache invalidation)</li>
<li><strong>Hart 0 Writes</strong>: Not immediately visible to Hart 1 if cached</li>
<li><strong>Explicit Synchronization</strong>: Required for inter-hart communication</li>
</ol>
<p dir="auto">The test suite exercises memory access while both harts run concurrently (<code>test_mem.c:291-347</code>).</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">19. CURRENT LIMITATIONS</h2><a id="user-content-19-current-limitations" aria-label="Permalink: 19. CURRENT LIMITATIONS" href="#19-current-limitations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This implementation does not currently support:</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">19.A Hardware Breakpoints (Trigger Module)</h3><a id="user-content-19a-hardware-breakpoints-trigger-module" aria-label="Permalink: 19.A Hardware Breakpoints (Trigger Module)" href="#19a-hardware-breakpoints-trigger-module"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RISC-V Debug Specification defines a Trigger Module for hardware breakpoints. Implementation was removed due to complexity. Workaround: Use single-step + PC comparison in software.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">19.B Multi-Drop SWD</h3><a id="user-content-19b-multi-drop-swd" aria-label="Permalink: 19.B Multi-Drop SWD" href="#19b-multi-drop-swd"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The SWD protocol supports multiple targets on one bus via unique addresses. This library assumes a single target. Physical wiring for multi-target is possible but requires additional multiplexing logic.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">19.C Compressed Instruction (RVC) Extension</h3><a id="user-content-19c-compressed-instruction-rvc-extension" aria-label="Permalink: 19.C Compressed Instruction (RVC) Extension" href="#19c-compressed-instruction-rvc-extension"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">RP2350&#39;s Hazard3 cores support the C extension (16-bit compressed instructions). The library:</p>
<ul dir="auto">
<li>Correctly reads compressed instructions during tracing</li>
<li>Does NOT decode compressed instruction mnemonics</li>
<li>Assumes 4-byte alignment for code upload</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">19.D Performance Profiling</h3><a id="user-content-19d-performance-profiling" aria-label="Permalink: 19.D Performance Profiling" href="#19d-performance-profiling"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">No cycle-accurate performance counters are exposed. Implementing this requires:</p>
<ol dir="auto">
<li>Access to mcycle/minstret CSRs</li>
<li>Periodic sampling without halting (not possible with current SBA coherency)</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">19.E Flash Programming</h3><a id="user-content-19e-flash-programming" aria-label="Permalink: 19.E Flash Programming" href="#19e-flash-programming"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">No routines for RP2350 flash programming. This requires:</p>
<ol dir="auto">
<li>Loading flash programmer stub to SRAM</li>
<li>Executing stub via <code>rp2350_execute_code()</code></li>
<li>Monitoring completion via polling</li>
</ol>
<p dir="auto">The architecture supports this; implementation is left to applications.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">20. LICENSE</h2><a id="user-content-20-license" aria-label="Permalink: 20. LICENSE" href="#20-license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Copyright (c) 2025</p>
<p dir="auto">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p dir="auto">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p dir="auto">THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</article></div></div>
  </body>
</html>
