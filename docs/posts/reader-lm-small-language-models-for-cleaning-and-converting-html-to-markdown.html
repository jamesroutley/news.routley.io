<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jina.ai/news/reader-lm-small-language-models-for-cleaning-and-converting-html-to-markdown/?nocache=1">Original</a>
    <h1>Reader-LM: Small Language Models for Cleaning and Converting HTML to Markdown</h1>
    
    <div id="readability-page-1" class="page"><article data-v-3304182e=""><section data-v-3304182e=""><p>In April 2024, we released <a href="https://jina.ai/reader">Jina Reader</a>, a simple API that converts any URL into LLM-friendly markdown with just a simple prefix: <code>r.jina.ai</code>. Despite the sophisticated network programming behind the scenes, the core &#34;reading&#34; part is quite straightforward. First, we use a headless Chrome browser to fetch the source of the webpage. Then, we leverage Mozilla’s <a href="https://github.com/mozilla/readability">Readability</a> package to extract the main content, removing elements like headers, footers, navigation bars, and sidebars. Finally, we convert the cleaned-up HTML into markdown using <a href="https://x.com/JinaAI_/status/1823756993108304135">regex</a> and the <a href="https://github.com/mixmark-io/turndown">Turndown library</a>. The result is a well-structured markdown file, ready to be used by LLMs for grounding, summarizing, and reasoning.</p><p>In the first few weeks after the release of Jina Reader, we received a lot of feedback, particularly regarding the quality of the content. Some users found it too detailed, while others felt it wasn’t detailed enough. There were also reports that the Readability filter removed the wrong content or that Turndown struggled to convert certain parts of the HTML into markdown. Fortunately, many of these issues were successfully resolved by patching the existing pipeline with new regex patterns or heuristics.</p><p>Since then, we’ve been pondering one question: instead of patching it with more heuristics and regex (which becomes increasingly difficult to maintain and isn’t multilingual friendly), can we solve this problem <em>end-to-end</em> with a language model?</p><figure><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png" alt="" width="1800" height="945" srcset="https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/Heading--48-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/Heading--48-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/Heading--48-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/Heading--48-.png 1800w" sizes="(min-width: 720px) 720px"/><figcaption><span>Illustration of </span><code spellcheck="false"><span>reader-lm</span></code><span>, replacing the pipeline of readability+turndown+regex heuristics using a small language model.</span></figcaption></figure><p>At first glance, using LLMs for data cleaning might seem excessive due to their low cost-efficiency and slower speeds. But what if we&#39;re considering a <strong>small language model (SLM)</strong> — one with fewer than 1 billion parameters that can run efficiently on the edge? That sounds much more appealing, right? But is this truly feasible or just wishful thinking? According to the scaling law, fewer parameters generally lead to reduced reasoning and summarizing capabilities. So an SLM might even struggle to generate any meaningful content if its parameter size is too small. To explore this further, let’s take a closer look at the HTML-to-Markdown task:</p><ul><li>First, the task we’re considering <strong>isn’t as creative or complex as typical LLM tasks</strong>. In the case of converting HTML to markdown, the model primarily needs to <strong>selectively copy</strong> from the input to the output (i.e., skipping over HTML markup, sidebars, headers, footers), with minimal effort spent on generating new content (mostly inserting markdown syntax). This contrasts sharply with the broader tasks LLMs handle, such as generating poems or writing code, where the output involves much more creativity and is not a direct copy-paste from the input. This observation suggests that an SLM might work, as the task <em>seems</em> simpler than more general text generation.</li><li>Second, we need to <strong>prioritize the long-context support</strong>. Modern HTML often contains much more noise than simple <code>&lt;div&gt;</code> markup. Inline CSS and scripts can easily balloon the code to hundreds of thousands of tokens. For an SLM to be practical in this scenario, the context length must be sufficiently large. Token limits like 8K or 16K may not be useful at all.</li></ul><p>It seems that what we need is a <strong><em>shallow-but-wide</em></strong> SLM. &#34;Shallow&#34; in the sense that the task is primarily &#34;copy-paste&#34; and relatively straightforward, and &#34;wide&#34; in the sense that it requires long context support to be practical. However, previous research has shown that context length and reasoning ability are closely intertwined. For an SLM, it’s extremely challenging to optimize both dimensions while keeping the parameter size small.</p><p>Today, we’re excited to announce the release of <code>reader-lm-0.5b</code> and <code>reader-lm-1.5b</code>, two SLMs specifically trained <strong>to generate clean markdown directly from noisy raw HTML</strong>. Both models are multilingual and support a context length of up to <strong>256K tokens</strong>. Despite their compact size, these models achieve state-of-the-art performance on this task, outperforming larger LLM counterparts while being only 1/50th of their size.</p><figure><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/2024/09/Reader-LM-vs-LLMs-on-the-HTML2Markdown-task.svg" alt="" width="805" height="514"/></figure><p>Below are the two models&#39; specifications:</p>
<table>
<thead>
<tr>
<th></th>
<th>reader-lm-0.5b</th>
<th>reader-lm-1.5b</th>
</tr>
</thead>
<tbody>
<tr>
<td># Parameters</td>
<td>494M</td>
<td>1.54B</td>
</tr>
<tr>
<td>Context length</td>
<td>256K</td>
<td>256K</td>
</tr>
<tr>
<td>Hidden Size</td>
<td>896</td>
<td>1536</td>
</tr>
<tr>
<td># Layers</td>
<td>24</td>
<td>28</td>
</tr>
<tr>
<td># Query Heads</td>
<td>14</td>
<td>12</td>
</tr>
<tr>
<td># KV Heads</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>Head Size</td>
<td>64</td>
<td>128</td>
</tr>
<tr>
<td>Intermediate Size</td>
<td>4864</td>
<td>8960</td>
</tr>
<tr>
<td>Multilingual</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>HuggingFace Repo</td>
<td><a href="https://huggingface.co/jinaai/reader-lm-0.5b/">Link</a></td>
<td><a href="https://huggingface.co/jinaai/reader-lm-1.5b/">Link</a></td>
</tr>
</tbody>
</table>
<h2 id="get-started-with-reader-lm">Get Started with Reader-LM</h2><h3 id="on-google-colab">On Google Colab</h3><p>The easiest way to experience <code>reader-lm</code> is by running our Colab notebook, where we demonstrate how to use <code>reader-lm-1.5b</code> to convert the Hacker News website into markdown. The notebook is optimized to run smoothly on Google Colab’s free T4 GPU tier. You can also load <code>reader-lm-0.5b</code> or change the URL to any website and explore the output. Note that the input (i.e., the prompt) to the model is the raw HTML—no prefix instruction is required.</p><figure><a href="https://colab.research.google.com/drive/1wXWyj5hOxEHY6WeHbOwEzYAC0WB1I5uA"><div><p>Google Colab</p><p><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/icon/favicon.ico" alt=""/></p></div><p><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/thumbnail/colab_favicon_256px.png" alt="" onerror="this.style.display = &#39;none&#39;"/></p></a></figure><p>Please be aware that the free-tier T4 GPU comes with limitations that might prevent the use of advanced optimizations during model execution. Features such as bfloat16 and flash attention are not available on the T4, which could result in higher VRAM usage and slower performance for longer inputs. <strong>For production environments, we recommend using a higher-end GPU like the RTX 3090/4090 for significantly better performance.</strong></p><h3 id="in-production-available-on-azure-aws-soon">In Production: Available on Azure &amp; AWS Soon</h3><p>Reader-LM will be available on Azure Marketplace and AWS SageMaker. If you need to use these models beyond those platforms or on-premises within your company, note that both models are licensed under CC BY-NC 4.0. <a href="https://jina.ai/contact-sales/" rel="noreferrer">For commercial usage inquiries, feel free to contact us.</a></p><h2 id="quantitative-evaluation">Quantitative Evaluation</h2><p>To quantitatively evaluate the performance of Reader-LM, we compared it with several large language models, including: GPT-4o, Gemini-1.5-Flash, Gemini-1.5-Pro, LLaMA-3.1-70B, Qwen2-7B-Instruct.</p><p>The models were assessed using the following metrics:</p><ul><li><strong>ROUGE-L (higher is better)</strong>: This metric, widely used for summarization and question-answering tasks, measures the overlap between the predicted output and the reference at the n-gram level.</li><li><strong>Token Error Rate (TER, lower is better)</strong>: This metric calculates the rate at which the generated markdown tokens do not appear in the original HTML content. We designed this metric to assess the model&#39;s hallucination rate, helping us identify cases where the model produces content that isn’t grounded in the HTML. Further improvements will be made based on case studies.</li><li><strong>Word Error Rate (WER, lower is better)</strong>: Commonly used in OCR and ASR tasks, WER considers the word sequence and calculates errors such as insertions (ADD), substitutions (SUB), and deletions (DEL). This metric provides a detailed assessment of mismatches between the generated markdown and the expected output.</li></ul><p>To leverage LLMs for this task, we used the following uniform instruction as the prefix prompt:</p><pre><code>Your task <span>is</span> <span>to</span> <span>convert</span> the content <span>of</span> the provided HTML file <span>into</span> the <span>corresponding</span> markdown file. You need <span>to</span> <span>convert</span> the structure, elements, <span>and</span> attributes <span>of</span> the HTML <span>into</span> equivalent representations <span>in</span> markdown format, ensuring that <span>no</span> important information <span>is</span> lost. The output should strictly be <span>in</span> markdown format, <span>without</span> <span>any</span> additional explanations.</code></pre><p>The results can be found in the table below.</p>
<table>
<thead>
<tr>
<th></th>
<th>ROUGE-L</th>
<th>WER</th>
<th>TER</th>
</tr>
</thead>
<tbody>
<tr>
<td>reader-lm-0.5b</td>
<td>0.56</td>
<td>3.28</td>
<td>0.34</td>
</tr>
<tr>
<td>reader-lm-1.5b</td>
<td><strong>0.72</strong></td>
<td><strong>1.87</strong></td>
<td><strong>0.19</strong></td>
</tr>
<tr>
<td>gpt-4o</td>
<td>0.43</td>
<td>5.88</td>
<td>0.50</td>
</tr>
<tr>
<td>gemini-1.5-flash</td>
<td>0.40</td>
<td>21.70</td>
<td>0.55</td>
</tr>
<tr>
<td>gemini-1.5-pro</td>
<td>0.42</td>
<td>3.16</td>
<td>0.48</td>
</tr>
<tr>
<td>llama-3.1-70b</td>
<td>0.40</td>
<td>9.87</td>
<td>0.50</td>
</tr>
<tr>
<td>Qwen2-7B-Instruct</td>
<td>0.23</td>
<td>2.45</td>
<td>0.70</td>
</tr>
</tbody>
</table>
<h2 id="qualitative-study">Qualitative Study</h2><p>We conducted a qualitative study to visually evaluate the models on this HTML2Markdown task. <a href="https://docs.google.com/spreadsheets/d/1Wb2sMdiEoToPaXohcrEznFKStt_4alVOnJD3WKkiM7o/edit?gid=1576339853&amp;ref=jina-ai-gmbh.ghost.io#gid=1576339853">We selected 22 HTML sources</a> including news articles, blog posts, landing pages, e-commerce pages, and forum posts in multiple languages: English, German, Japanese, and Chinese. We also included the Jina Reader API as a baseline, which relies on regex, heuristics, and predefined rules.</p><p>The evaluation focused on four key dimensions of the output, with each model rated on a scale from 1 (lowest) to 5 (highest):</p><ol><li><strong>Header Extraction</strong>: Assessed how well each model identified and formatted the document’s h1,h2,..., h6 headers using correct markdown syntax.</li><li><strong>Main Content Extraction</strong>: Evaluated the models&#39; ability to accurately convert body text, preserving paragraphs, formatting lists, and maintaining consistency in presentation.</li><li><strong>Rich Structure Preservation</strong>: Analyzed how effectively each model maintained the overall structure of the document, including headings, subheadings, bullet points, and ordered lists.</li><li><strong>Markdown Syntax Usage</strong>: Evaluated each model’s ability to correctly convert HTML elements such as <code>&lt;a&gt;</code> (links), <code>&lt;strong&gt;</code> (bold text), and <code>&lt;em&gt;</code> (italics) into their appropriate markdown equivalents.</li></ol><p>The results can be found below.</p><figure><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/2024/09/Qualitative-Evaluation-of-Reader-LM-vs-LLMs-and-Jina-Reader-API--1-.svg" alt="" width="863" height="533"/></figure><p>Reader-LM-1.5B consistently performs well across all dimensions, particularly excelling in structure preservation and markdown syntax usage. While it doesn&#39;t always outperform Jina Reader API, its performance is competitive with larger models like Gemini 1.5 Pro, making it a highly efficient alternative to larger LLMs. Reader-LM-0.5B, though smaller, still offers solid performance, particularly in structure preservation.</p><h2 id="how-we-trained-reader-lm">How We Trained Reader-LM</h2><h3 id="data-preparation">Data Preparation</h3><p>We used the Jina Reader API to generate training pairs of raw HTML and their corresponding markdown. During the experiment, we found that SLMs are particularly sensitive to the quality of the training data. So we built a data pipeline that ensures only high-quality markdown entries are included in the training set.</p><p>Additionally, we added some synthetic HTML and their markdown counterparts, generated by <code>GPT-4o</code>. Compared to real-world HTML, synthetic data tends to be much shorter, with simpler and more predictable structures, and a significantly lower noise level.</p><p>Finally, we concatenated the HTML and markdown using a chat template. The final training data is formatted as follows:</p><pre><code>&lt;|im_start|&gt;<span>system</span>
You are a helpful assistant.&lt;|im_end|&gt;
&lt;|im_start|&gt;user
{<span>{RAW_HTML}</span>}&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant
{<span>{MARKDOWN}</span>}&lt;|im_end|&gt;
</code></pre><p>The full training data amounts to 2.5 billion tokens.</p><h3 id="two-stage-training">Two-Stage Training</h3><p>We experimented with various model sizes, starting from 65M and 135M, up to 3B parameters. The specifications for each model can be found in the table below.</p>
<table>
<thead>
<tr>
<th></th>
<th>reader-lm-65m</th>
<th>reader-lm-135m</th>
<th>reader-lm-360m</th>
<th>reader-lm-0.5b</th>
<th>reader-lm-1.5b</th>
<th>reader-lm-1.7b</th>
<th>reader-lm-3b</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hidden Size</td>
<td>512</td>
<td>576</td>
<td>960</td>
<td>896</td>
<td>1536</td>
<td>2048</td>
<td>3072</td>
</tr>
<tr>
<td># Layers</td>
<td>8</td>
<td>30</td>
<td>32</td>
<td>24</td>
<td>28</td>
<td>24</td>
<td>32</td>
</tr>
<tr>
<td># Query Heads</td>
<td>16</td>
<td>9</td>
<td>15</td>
<td>14</td>
<td>12</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td># KV Heads</td>
<td>8</td>
<td>3</td>
<td>5</td>
<td>2</td>
<td>2</td>
<td>32</td>
<td>32</td>
</tr>
<tr>
<td>Head Size</td>
<td>32</td>
<td>64</td>
<td>64</td>
<td>64</td>
<td>128</td>
<td>64</td>
<td>96</td>
</tr>
<tr>
<td>Intermediate Size</td>
<td>2048</td>
<td>1536</td>
<td>2560</td>
<td>4864</td>
<td>8960</td>
<td>8192</td>
<td>8192</td>
</tr>
<tr>
<td>Attention Bias</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>False</td>
<td>False</td>
</tr>
<tr>
<td>Embedding Tying</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>True</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
<tr>
<td>Vocabulary Size</td>
<td>32768</td>
<td>49152</td>
<td>49152</td>
<td>151646</td>
<td>151646</td>
<td>49152</td>
<td>32064</td>
</tr>
<tr>
<td>Base Model</td>
<td>Lite-Oute-1-65M-Instruct</td>
<td>SmolLM-135M</td>
<td>SmolLM-360M-Instruct</td>
<td>Qwen2-0.5B-Instruct</td>
<td>Qwen2-1.5B-Instruct</td>
<td>SmolLM-1.7B</td>
<td>Phi-3-mini-128k-instruct</td>
</tr>
</tbody>
</table>
<p>The model training was conducted in two stages:</p><ol><li><strong>Short-and-simple HTML: </strong>In this stage, the maximum sequence length (HTML + markdown) was set to 32K tokens, with a total of 1.5 billion training tokens.</li><li><strong>Long-and-hard HTML</strong>: the sequence length was extended to 128K tokens, with 1.2 billion training tokens. We implemented the zigzag-ring-attention mechanism from<a href="https://github.com/zhuzilin/ring-flash-attention"> Zilin Zhu&#39;s &#34;Ring Flash Attention&#34; (2024)</a> for this stage.</li></ol><p>Since the training data included sequences of up to 128K tokens, we believe that the model can support up to 256K tokens without issue. However, handling 512K tokens may be challenging, as extending RoPE positional embeddings to four times the training sequence length could result in performance degradation.</p><p>For the 65M and 135M parameter models, we observed that they could achieve reasonable &#34;copy&#34; behavior, but only with short sequences (fewer than 1K tokens). As the input length increased, these models struggled to produce any reasonable output. Given that modern HTML source code can easily exceed 100K tokens, a 1K token limit is far from sufficient.</p><h3 id="degeneration-and-dull-loops">Degeneration and Dull Loops</h3><p>One of the major challenges we encountered was degeneration, particularly in the form of repetition and looping. After generating some tokens, the model would begin to generate the same token repeatedly or get stuck in a loop, continuously repeating a short sequence of tokens until reaching the maximum allowed output length. </p><figure><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png" alt="" width="2000" height="1278" srcset="https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/image-1.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/image-1.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/image-1.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/image-1.png 2040w" sizes="(min-width: 720px) 720px"/><figcaption><span>Dull loops pointed by the red arrows represent serious degeneration of SLM.</span></figcaption></figure><p>To address this issue:</p><ul><li>We applied <a href="https://github.com/yxuansu/SimCTG">contrastive search</a> as a decoding method and incorporate contrastive loss during training. From our experiments, this method effectively reduced repetitive generation in practice.</li><li>We implemented a simple repetition stop criterion within the transformer pipeline. This criterion automatically detects when the model begins to repeat tokens and stops decoding early to avoid dull loops. This idea was inspired by this <a href="https://github.com/huggingface/transformers/issues/32902" rel="noopener">HuggingFace discussion</a>.</li></ul><h3 id="training-efficiency-on-long-inputs">Training Efficiency on Long Inputs</h3><p>To mitigate the risk of out-of-memory (OOM) errors when handling long input, we implemented chunk-wise model forwarding. This approach encodes the long input with smaller chunks, reducing VRAM usage.</p><p>We improved the data packing implementation in our training framework, which is based on the Transformers Trainer. To optimize training efficiency, multiple short texts (e.g., 2K tokens) are concatenated into a single long sequence (e.g., 30K tokens), enabling padding-free training. However, in the original implementation, some short examples were split into two sub-texts and included in different long training sequences. In such cases, the second sub-text would lose its context (e.g., raw HTML content in our case), leading to corrupted training data. This forces the model to rely on its parameters rather than the input context, which we believe is a major source of hallucination.</p><p>In the end, we selected the 0.5B and 1.5B models for publication. The 0.5B model is the smallest one capable of achieving the desired &#34;selective-copy&#34; behavior on long-context inputs, while the 1.5B model is the smallest larger model that significantly improves performance without hitting diminishing returns in relation to parameter size.</p><h3 id="alternative-architecture-encoder-only-model">Alternative Architecture: Encoder-Only Model</h3><p>In the early stages of this project, we explored using an encoder-only architecture to tackle this task. As mentioned earlier, the HTML-to-Markdown conversion task appears to be primarily a &#34;selective-copy&#34; task. Given a training pair (raw HTML and markdown), we can label tokens that exist in both the input and output as <code>1</code>, and the rest as <code>0</code>. This converts the problem into a token classification task, similar to what is used in Named Entity Recognition (NER).</p><p>While this approach seemed logical, it presented significant challenges in practice. First, raw HTML from real-world sources is extremely noisy and long, making the <code>1</code> labels extremely sparse hence difficult for the model to learn. Second, encoding special markdown syntax in a <code>0-1</code> schema proved problematic, as symbols like <code>## title</code>, <code>*bold*</code>, and <code>| table |</code> do not exist in the raw HTML input. Third, the output tokens do not always strictly follow the order of the input. Minor reordering often occurs, particularly with tables and links, making it difficult to represent such reordering behaviors in a simple <code>0-1</code> schema. Short-distance reordering could potentially be handled with dynamic programming or alignment-warping algorithms by introducing labels like <code>-1, -2, +1, +2</code> to represent distance offsets, transforming the binary classification problem into a multi-class token classification task.</p><figure><img loading="lazy" src="https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png" alt="" width="2000" height="1436" srcset="https://jina-ai-gmbh.ghost.io/content/images/size/w600/2024/09/output--2-.png 600w, https://jina-ai-gmbh.ghost.io/content/images/size/w1000/2024/09/output--2-.png 1000w, https://jina-ai-gmbh.ghost.io/content/images/size/w1600/2024/09/output--2-.png 1600w, https://jina-ai-gmbh.ghost.io/content/images/2024/09/output--2-.png 2179w" sizes="(min-width: 720px) 720px"/><figcaption><span>Using dynamic programming to align the raw HTML (X-axis) and the markdown (Y-axis) for creating token-level training labels.</span></figcaption></figure><p>In summary, solving the problem with an encoder-only architecture and treating it as a token classification task has its charm, especially since the training sequences are much shorter compared to a decoder-only model, making it more VRAM-friendly. However,<strong> the major challenge lies in constructing the training data.</strong> When we realized that the time and effort spent preparing the training data—using dynamic programming and heuristics to create perfect token-level labeling sequences—was significant, we decided to discontinue this approach.</p><h2 id="conclusion">Conclusion</h2><p>Reader-LM is a novel small language model (SLM) designed for data extraction and cleaning on the open web. Inspired by Jina Reader, our goal was to create an end-to-end language model solution capable of converting raw, noisy HTML into clean markdown. At the same time, we focused on cost-efficiency, keeping the model size small to ensure Reader-LM remains practical and usable. <strong>It is also the first decoder-only long-context model trained at Jina AI.</strong></p><p>Although the task may initially appear to be a simple &#34;selective-copy&#34; problem, converting and cleaning HTML to markdown is far from easy. Specifically, it requires the model to excel at position-aware, context-based reasoning, which demands a larger parameter size, particularly in the hidden layers. In comparison, learning markdown syntax is relatively straightforward.</p><p>During our experiments, we also found that training an SLM from scratch is particularly challenging. Starting with a pretrained model and continuing with task-specific training significantly improved training efficiency. There&#39;s still much room for improvement in terms of both efficiency and quality: expanding the context length, speeding up decoding, and adding support for instructions in the input, which would allow Reader-LM to extract specific parts of a webpage into markdown.</p></section></article></div>
  </body>
</html>
