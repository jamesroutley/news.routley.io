<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/">Original</a>
    <h1>The cheapest flash microcontroller you can buy is actually an Arm Cortex-M0&#43;</h1>
    
    <div id="readability-page-1" class="page"><div><p>Browse the Microcontroller pages of LCSC and you’ll see tons of low-cost MCUs from companies like Padauk, Nyquest, Holychip, SimOne, and Fremont Micro Devices — with <a href="https://www.lcsc.com/product-detail/Microcontroller-Units-MCUs-MPUs-SOCs_Nyquest-Tech-NY8A051H_C5143390.html">prices as low as 4 cents</a>. The problem is these parts all use EPROM: Electronically Programmable Read Only Memory. The missing “E” means these aren’t electronically erasable — they’re OTP (One-Time Programmable) parts. Once you’ve burned your hex file, you’re locked in. OTP parts are widely used for simple devices in cost-sensitive applications, but they’re annoying to use in designs since to develop firmware, you need <a href="https://jaycarlson.net/2019/09/06/whats-up-with-these-3-cent-microcontrollers/">special emulator hardware</a> (or a huge supply of ICs and a conveniently-located trash can).</p><p>I was interested in finding the cheapest <em>flash</em> microcontroller LCSC sells, and it turns out it’s not a crusty old 8051 or a PIC16 clone — and it’s not the <a href="https://twitter.com/search?q=CH32V003%20&amp;src=typed_query">WCH CH32V003 that the Internet is freaking out about</a> — it’s actually an Arm Cortex-M0+ made by Puya, it’s less than 10 cents in moderate quantities, and it’s awesome.</p><p>Puya? They’re a flash memory company out of Shanghai that’s been around since 2012 — mostly making really low-cost SPI flash memory for IoT gadgets. While it may seem odd that the cheapest MCU is made by a Flash memory company, if you know a thing or two about chip design (which I don’t) you’ll know that it’s often the flash memory inside the part that’s the most expensive IP in the design. This is why so many fabless semiconductor shops don’t bother with it and just use external SPI flash or OTP memory (just look at any USB webcam controller, Bluetooth audio chip, or even the popular Espressif products).</p><h3>Puya PY32 Selection Guide</h3><p>Puya makes a range of ultra-low-cost Arm Cortex-M0+ parts in the <a href="https://www.puyasemi.com/cpzx3/info_271_aid_247_kid_246.html">PY32 series</a>. There are three families in the series: the PY32F002A, the PY32F003, and the PY32F030. The families differ in memory, maximum speed, and peripheral inclusion, but they seem entirely progressive (e.g., firmware written for the PY32F002A should run on the PY32F003 and PY32F030). Regardless, all the parts are modern designs that use internal regulators and have an operating voltage range of 1.7 to 5.5V.</p><p>Unlike many other low-cost MCUs that only come in one or two (usually low-density) package options, the PY32 has nine different choices, ranging from a tiny 2×3 mm DFN to a full-sized 32-pin LQFP — along with QFN, TSSOP, and drunk-soldering-friendly SOIC packages.</p><p>I bought a ton of different PY32 parts from LCSC (just <a href="https://www.lcsc.com/products/Microcontroller-Units-MCUs-MPUs-SOCs_11329.html?keyword=py32">search for PY32</a>). At the time of publication, prices have shot up quite a bit compared to when I first ordered these parts, but currently, the prices range from less than 8 cents up to $0.74 depending on the exact part, configuration, and quantity you’re buying.</p><p>If you want to avoid redoing some of the work I’ve done to get these parts going, I have a <a href="https://github.com/jaydcarlson/py32-template">py32-template GitHub repo</a> with a sample project you can clone and adapt to your needs.</p> <figure id="attachment_2192" aria-describedby="caption-attachment-2192"><img data-attachment-id="2192" data-permalink="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/screenshot_20230204_095215/" data-orig-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215.png" data-orig-size="1264,890" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot_20230204_095215" data-image-description="" data-medium-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-300x211.png" data-large-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-1024x721.png" src="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-1024x721.png?cbc196&amp;cbc196" alt="" width="1024" height="721" srcset="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-1024x721.png 1024w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-300x211.png 300w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215-768x541.png 768w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_095215.png 1264w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption id="caption-attachment-2192">The PY32F002A is a bit bare-bones, but it has everything you need for simple projects.</figcaption></figure><p>The F002A is the base model; it clocks in at 24 MHz, has 20K of flash, 3K of SRAM, and comes in SOIC8/16, TSSOP20, and QFN16 packages — along with an odd 1mm-pitched ESSOP10 package. It has one advanced-control timer with 4 outputs (plus two complementary pairs for driving H-bridges), 1 low-power timer, 1 general-purpose timer, a 1 MSPS 12-bit ADC with 6 external channels, two comparators, a basic watchdog timer, and one SPI, I2C, and USART peripheral. And since this is a Cortex-M0+, you get an SWD debugging interface, a SysTick timer, and a nested vector interrupt controller (NVIC) bundled in.</p> <figure id="attachment_2195" aria-describedby="caption-attachment-2195"><img data-attachment-id="2195" data-permalink="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/screenshot_20230204_102159/" data-orig-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159.png" data-orig-size="1502,1086" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot_20230204_102159" data-image-description="" data-medium-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-300x217.png" data-large-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-1024x740.png" src="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-1024x740.png?cbc196&amp;cbc196" alt="" width="1024" height="740" srcset="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-1024x740.png 1024w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-300x217.png 300w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159-768x555.png 768w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_102159.png 1502w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption id="caption-attachment-2195">The PY32F003 adds DMA and bumps the max CPU frequency up to 32 MHz — but doesn’t provide an internal oscillator to achieve that.</figcaption></figure><p>The big thing the PY32F003 has over the F002A is DMA support, which is an unusual feature in this price range. The PY32F003 comes in 16K and 32K flash versions (with 2K and 4K of RAM respectively). In addition to the DMA, it adds three more general-purpose timers, a second USART, plus an “IR timer” (which is really just a NAND gate fed from TIM16 and TIM17 which can be configured to generate the carrier and data signals respectively). It also adds some reliability with a windowed watchdog (WWDG) and programmable voltage detect (PVD) brownout supervisor.</p><p>While the F003 advertises a 32 MHz operating frequency, its internal oscillator only runs at 24 Mhz. To get to 32 MHz, you’ll need an external crystal, which can cost more than half as much as the actual microcontroller does, and depending on the MCU package, can double the board area required to lay out the part.</p> <figure id="attachment_2194" aria-describedby="caption-attachment-2194"><img data-attachment-id="2194" data-permalink="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/screenshot_20230204_101935/" data-orig-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935.png" data-orig-size="1483,1068" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot_20230204_101935" data-image-description="&lt;p&gt;The PY32F030 adds even more peripherals, as well as a PLL capable of driving the CPU to 48 MHz.&lt;/p&gt;
" data-medium-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-300x216.png" data-large-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-1024x737.png" src="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-1024x737.png?cbc196&amp;cbc196" alt="" width="1024" height="737" srcset="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-1024x737.png 1024w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-300x216.png 300w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935-768x553.png 768w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_101935.png 1483w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption id="caption-attachment-2194">The PY32F030 can run the CPU at 48 MHz off an internal oscillator thanks to a 2x PLL. It also has larger-package options and up to 64K of flash.</figcaption></figure><p>The PY32F030 is the highest-end part in the lineup. It adds a 2x PLL that can run the core at 48 MHz off of the 24 MHz internal oscillator. The F030 also adds 32-pin QFP/QFN package support to get you up to 30 GPIO pins. In addition to the other capacities already mentioned, the F030 is also available in a higher-capacity 64K flash / 8K RAM version. The peripheral set between the F003 and F030 is identical, save for the F030’s built-in scanning LED matrix controller, which supports 4 8-segment digits.</p><p>What’s particularly strange is that the F030 has two different sets of pinouts. The F2 QFN and TSSOP 20-pin packages has three extra analog inputs, which the F1 package trades for 32kHz oscillator support. On the 32-pin package, the K2 version adds an extra GPIO pin in exchange for one fewer GND pin. I’m not sure of the rationale for trading GPIO pins for redundant power pins; maybe for better analog performance?</p><h3>Are these STM32 clones?</h3><p>While the PY32F030 family looks very much like an STM32F030, they are not compatible parts in any capacity. None of the parts appear to have complete pin compatibility, so they are not compatible at a hardware level. And the register offsets and interrupt vectors are different, meaning there is no binary compatibility for even very basic programs. While the peripherals are very similar to STM32 ones, there are subtle differences in the registers that will trip you up if you’re familiar with STM32 programming. These changes mostly appear to correct questionable decisions ST made in the first place; for example, the EXTI peripheral now contains configuration registers that allows you to route the correct GPIO bank to the EXTI signal you want (this was strangely located in SYSCFG on the STM32F030).</p><h3>Development Experience</h3><p>Overall, these parts are much easier to use than other parts in this price range, which often have poor English documentation, no code samples or peripheral libraries, or require vendor-provided IDEs and weird tooling.</p><h4>Sourcing</h4><p>You don’t need to buy these parts from weird Taobao links or AliExpress sellers — they’re available <a href="https://www.lcsc.com/products/Microcontroller-Units-MCUs-MPUs-SOCs_11329.html?keyword=PY32">straight from LCSC</a>. I initially designed my own breakout boards for these parts, but my friend Charles noticed Puya has <a href="https://www.lcsc.com/products/Development-Boards-Kits_11135.html">$5 dev boards</a> available too (which are really just breakout boards — they don’t even have a built-in debugger). Stock has been fluctuating a lot, as have prices, but they’re cheap enough to hoard for small-term low-volume projects.</p><h4>Documentation and SDK</h4><p>PY32 documentation is quite good. Visit <a href="https://www.puyasemi.com/cpzx3/info_271_aid_247_kid_246.html">Puya’s PY32 web page</a> and you can download everything you need — just scroll horizontally all the way to the right and click on the “Datasheet” download (<a href="https://www.puyasemi.com/uploadfiles/2022/11/PY-MCU%E8%B5%84%E6%96%99-20221117.rar">here’s a direct link</a> that I’ll surely forget to update in the future). Notice this isn’t a datasheet, but a ZIP that contains all the PY32 resources (and yes, each product links to this same file on their web site). Inside, you’ll find English and Chinese datasheets and reference manuals, code samples, a Keil DFP that contains the flash algorithms you’ll need to be able to burn your code onto these parts with an SWD probe. The documentation is pretty good, but at the time of writing, only the PY32F030 contains an English reference manual. This isn’t much of a problem as you can use this same guide for all parts.</p><h4>Compiling</h4><p>Next to all the goofy low-cost 8-bit parts I’ve played with, boy, it sure does feel nice to be working on an Arm Cortex part. I fired up VSCode, pulled in the SDK, created a Makefile and <code>launch.json</code> config, and I was off to the races.</p><p>Well… not quite. Like most Arm parts from the East, Puya’s SDK has set them up for Keil MDK development. You can definitely go grab a free version of Keil MDK and get going immediately, but I wanted a <a href="https://code.visualstudio.com/">VSCode</a> / <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> / <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">GCC</a>-based solution, which took a bit more fiddling. Using other GCC Arm Cortex project code I had laying around as a reference, I created GCC linker config and startup files for each part with a memory map and vector table based on the Keil linker config and startup files. With a bit more source-file mashing, I was able to pull in their STM32 HAL-like peripheral library and build a project.</p><h4>Flashing</h4><p>I really only use two debug servers these days: Segger’s J-Link GDB Server (obviously for use with their Segger J-Link) and pyOCD (which I use with low-cost CMSIS-DAP probes). To get pyOCD working, I tried searching for the Puya pack, but it’s not indexed in the repositories that pyOCD searches, so I had to manually install it. I extracted the PY32 DFP (which is just a ZIP file), then I copied the pdsc to pyOCD’s cmsis-pack-manager’s pack folder inside the Python distribution I’m using (mine was in <code>LocalCache\Local\cmsis-pack-manager\cmsis-pack-manager</code>). It’s important to rename the file to include the version number in it — <code>Puya.PY32F0xx_DFP.1.1.0.pdsc</code>. I then copied the original whole DFP file to the same directory, following the same convention as all the other packs use — copying it to <code>Puya\PY32F0xx_DFP\1.1.0.pack</code>.  After that, to rebuild the index file to include the new pack, I ran:</p><pre data-enlighter-language="generic">PS C:\&gt; pack-manager add-packs Puya.PY32F0xx_DFP.1.1.0.pdsc</pre><p>I checked that pyOCD could now find the pack:</p><pre data-enlighter-language="generic">PS C:\&gt; pyocd pack find PY32
  Part          Vendor   Pack                Version   Installed
------------------------------------------------------------------
  PY32F002Ax5   Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F003x4    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F003x6    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F003x8    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F030x3    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F030x4    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F030x6    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F030x7    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F030x8    Puya     Puya.PY32F0xx_DFP   1.1.0     True
  PY32F072xB    Puya     Puya.PY32F0xx_DFP   1.1.0     True</pre><p>and then installed it:</p><pre data-enlighter-language="generic">PS C:\&gt; pyocd pack install PY32F003x8</pre><p>Getting J-Link support was actually less involved. Segger doesn’t have Puya PY32 support, but you can add custom device support by <a href="https://wiki.segger.com/J-Link_Device_Support_Kit">following directions here</a>. I created a <code>JLinkDevices\Puya\PY32</code> folder structure, then added a Devices.xml file:</p><pre data-enlighter-language="generic">&lt;Database&gt;
  &lt;Device&gt;
    &lt;ChipInfo Vendor=&#34;Puya&#34; Name=&#34;PY32F002Ax5&#34; WorkRAMAddr=&#34;0x20000000&#34; WorkRAMSize=&#34;3072&#34; Core=&#34;JLINK_CORE_CORTEX_M0&#34; /&gt;
    &lt;FlashBankInfo Name=&#34;Internal code flash&#34; BaseAddr=&#34;0x08000000&#34; AlwaysPresent=&#34;1&#34; &gt;
      &lt;LoaderInfo Name=&#34;Default&#34; MaxSize=&#34;0x5000&#34; Loader=&#34;PY32F0xx_20.FLM&#34; LoaderType=&#34;FLASH_ALGO_TYPE_OPEN&#34; /&gt;
    &lt;/FlashBankInfo&gt;
  &lt;/Device&gt;
&lt;/Database&gt;</pre><p>I then copied the FLM flash programming algorithm files out of Puya’s DFP into this folder. After doing that, I was able to see the device in J-Link’s target selection box, and everything worked flawlessly. I will note that you have to be on a relatively-recent version of J-Link for this to work, so make sure you’ve upgraded and actually have the correct version on your PATH.</p> <figure id="attachment_2196" aria-describedby="caption-attachment-2196"><img data-attachment-id="2196" data-permalink="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/screenshot_20230204_113335/" data-orig-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335.png" data-orig-size="1424,822" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot_20230204_113335" data-image-description="" data-medium-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-300x173.png" data-large-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-1024x591.png" src="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-1024x591.png?cbc196&amp;cbc196" alt="" width="1024" height="591" srcset="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-1024x591.png 1024w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-300x173.png 300w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335-768x443.png 768w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_113335.png 1424w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption id="caption-attachment-2196">Debugging in VSCode with the Cortex-Debug plugin worked without any issues.</figcaption></figure><h4>Debugging</h4><p>I tested both Segger Ozone and VSCode (via Cortex-Debug) and was a little disappointed with how little effort it took to get going. It’s a Cortex-M0+, so debugging worked without a hiccup. Breakpoints, reading memory, yada-yada. I will say that while I was working through some low-power code, I noticed the SVD files provided by Puya were missing the PWR peripheral, so I had to manually add it. The SVD files are very bare-bones, with no descriptions or enumerations for things, but they seem to be accurate. Again, when compared to other parts in this price range, there’s no contest.</p><h4>In Use</h4><p>On parts with unique peripherals, I try to play with everything a bit before casting judgment — just to look for gaping holes or big-time “gotchas” — but since these are STM32-like peripherals, you kind of know what you’re getting.</p><p>One big difference between this and the STM32F030 is low-power support. The PY32F030 parts advertise a typical low-power stop mode current consumption of 4.5 µA when using a 1.0V setting with the internal regulator, and I was able to get the part to drop down to 5 µA in my testing. Meanwhile, the STM32F030 uses less than half of that in stop mode, and in run mode always outpaces the PY32F030 substantially: it doesn’t have the low-power internal 32 kHz oscillator the PY32 does, but it doesn’t seem to need it — when powered with its internal 8 MHz oscillator it uses less than half the current as the PY32 running off its internal 32 kHz one (while running 250 times faster). All told, the PY32F030 does not live in the sub-microamp ultra-low-power territory that you can hit with more expensive parts, but we’re still talking about a microcontroller that can be powered for several years with a minuscule CR2032 battery.</p><p>Puya chose to nearly copy the STM32 peripheral register API, as well as the STM32 HAL library. When I started with STM32 years ago, I wasn’t particularly offended by STM32’s HAL library, but as I’ve used more parts over the years, I find it more and more annoying to configure and use. On a part with only 20K of flash, these HAL libraries can eat into quite a bit of space, so if you’re using this part for real projects, you may find yourself using lighter-weight peripheral libraries to save space.</p><h3>What about the CH32V003 or STM32F030?</h3><p>The elephant in the room is the <a href="http://www.wch-ic.com/products/CH32V003.html">WCH CH32V003</a>, an entry-level RISC-V chip <a href="https://www.cnx-software.com/2022/10/22/10-cents-ch32v003-risc-v-mcu-offers-2kb-sram-16kb-flash-in-sop8-to-qfn20-packages/">widely covered</a> in the electronics press that may or may not be available for around 10 cents. While people mention buying these parts from WCH’s official AliExpress store, at the time of writing, it appears that they yanked the part, and I can’t find them anywhere on AliExpress for less than <a href="https://www.aliexpress.us/item/3256804778040328.html?spm=a2g0o.productlist.main.1.1fbb1981RBztKh&amp;algo_pvid=1d9be512-b6ad-482f-9934-82a620a317d0&amp;algo_exp_id=1d9be512-b6ad-482f-9934-82a620a317d0-0&amp;pdp_ext_f=%7B%22sku_id%22%3A%2212000031176801908%22%7D&amp;pdp_npi=2%40dis%21USD%2111.9%2111.9%21%21%21%21%21%4021021aa216755522467013891d0701%2112000031176801908%21sea&amp;curPageLogUid=WdKd7BJeTabV">$2 per chip</a>, though it’s on Taobao for <a href="https://item.taobao.com/item.htm?spm=a230r.1.14.24.1556799fHGTRPW&amp;id=690298445813&amp;ns=1&amp;abbucket=15#detail">about 25 cents each</a>.</p><p>It’s hard to find a direct cross between the CH32V003 and the PY32. In terms of flash/RAM/peripherals, the CH32V003 is very similar to the entry-level PY32F002A, which can be had for <a href="https://www.lcsc.com/product-detail/Microcontroller-Units-MCUs-MPUs-SOCs_PUYA-PY32F002AL15S6TU_C5292060.html">less than 10 cents</a> in fairly modest volumes (though for most projects, you’d need more pins and would opt for the <a href="https://www.lcsc.com/product-detail/Microcontroller-Units-MCUs-MPUs-SOCs_PUYA-PY32F002AW15U6TR_C5291740.html">14-cent QFN16 version</a>). The Puya part has more flash and RAM, while the CH32V003 has an internal 2x PLL that runs the core twice as fast. The CH32V003 also has DMA, which is especially important when working with high-bit-rate communications interfaces on these low-speed devices. If you move up to the PY32F030 to match the clock speed and DMA of the CH32V003, you’ve jumped up considerably to <a href="https://www.lcsc.com/product-detail/Microcontroller-Units-MCUs-MPUs-SOCs_PUYA-PY32F030F18P6TU_C3018715.html">30 cents or more</a>, but you’re also getting a part with four times more flash and RAM, plus 3 more timers and another USART.</p> <figure id="attachment_2198" aria-describedby="caption-attachment-2198"><img data-attachment-id="2198" data-permalink="https://jaycarlson.net/2023/02/04/the-cheapest-flash-microcontroller-you-can-buy-is-actually-an-arm-cortex-m0/screenshot_20230204_123809/" data-orig-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809.png" data-orig-size="1148,981" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Screenshot_20230204_123809" data-image-description="" data-medium-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-300x256.png" data-large-file="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-1024x875.png" src="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-1024x875.png?cbc196&amp;cbc196" alt="" width="1024" height="875" srcset="https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-1024x875.png 1024w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-300x256.png 300w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809-768x656.png 768w, https://jaycarlson.net/wp-content/uploads/2023/02/Screenshot_20230204_123809.png 1148w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption id="caption-attachment-2198">Unlike other parts in this price range (including the CH32V003), Segger Ozone has no issues working with the Puya PY32 — here, I’m plotting ADC data streamed live from my breadboard.</figcaption></figure><p>My biggest gripe with the CH32V003 is the tooling: it uses a goofy one-wire debug interface requiring a proprietary debugger and a hacked-together custom version of OpenOCD (a software I detest). I think most WCH users just use MounRiver, an Eclipse-based IDE that comes preconfigured for WCH CH32 parts. This software feels painfully slow compared to VSCode and Ozone-based workflows. Some of these issues are WCH-specific, and some are more broadly a problem with RISC-V — no pyOCD support, no Cortex-Debug support, and spotty J-Link support, too. I haven’t looked into higher-end RISC-V cores, so I have no idea what kind of support there is for instruction trace and other advanced debugging tools, but it just seems like the RISC-V development ecosystem has a long way to go before it achieves parity with Arm.</p><p>What about Arm competitors? It’s no surprise these PY32 parts are cheaper than the STM32F030, though the direct cross — the PY32F030 — really isn’t <em>that much</em> cheaper. You can get <a href="https://www.lcsc.com/product-detail/Microcontroller-Units-MCUs-MPUs-SOCs_STMicroelectronics-STM32F030F4P6_C32908.html">STM32F030F4P6s from LCSC</a> for about 50 cents each in moderate quantity. These don’t have the flash or RAM or 5V compatibility the PY32F030 does, but you get better low-power support and a bit less pain in initial project set-up (especially considering the STM32CubeMX compatibility). The Puya parts, however, offer way more varied package options. I’m not a big fan of TSSOP and LQFP packages, so it’s nice to get similarly-spec’d parts in tiny DFN and QFN packages. And if you can sacrifice some performance, you can get into the PY32 for much less than an STM32F030.</p><h2>Final Thoughts</h2><p>A while back I wrote a large blog post on the Padauk PMS150; the post ended up so long simply because the ecosystem was quite different than modern development environments. There were several-hundred-dollar emulators and programmers you had to buy, a weird IDE that used a subset C dialect that often looked more like assembly, and OTP memory that meant that one mistake could send you to the soldering rework station to pop off and discard the MCU you just accidentally ruined. Unless you’re making products in super high volumes, it really doesn’t make much sense to invest in the tools, time, and effort to learn that ecosystem.</p><p>The Puya PY32 couldn’t be more different. The entire time I worked through this project, I kept forgetting that I was using a part that is 20 times cheaper than what I’m used to using. It has the same sorts of peripherals you’d expect to find on any NXP, ST, or Microchip Arm part you’d buy off DigiKey. It has good English documentation, full compatibility with the debug probes you already own, and you can use whatever software ecosystem you prefer — Eclipse, Vim, VSCode, Embedded Studio, Keil, IAR, or nearly anything else.</p><p>Bottom line: the Puya PY32 ecosystem is just plain boring — and that’s a good thing.</p></div></div>
  </body>
</html>
