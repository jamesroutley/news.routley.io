<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.kowalczyk.info/a-stsj/simplest-c-callback-from-sumatrapdf.html">Original</a>
    <h1>Simplest C&#43;&#43; Callback, from SumatraPDF</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
        <div id="stsj">
<p><a target="_blank" href="https://www.sumatrapdfreader.org/free-pdf-reader">SumatraPDF</a> is a Windows GUI application for viewing PDF, ePub and comic books written in C++.</p>

<p>A common need in GUI programs is a callback. E.g. when a button is clicked we need to call a function with some data identifying which button was clicked. Callback is therefore a combo of function and data and we need to call the function with data as an argument.</p>

<p>In programming language lingo, code + data combo is called a closure.</p>

<p>C++ has <code>std::function&lt;&gt;</code> and lambdas (i.e. closures). Lambdas convert to <code>std::function&lt;&gt;</code> and capture local variables.</p>

<p>Lambdas can be used as callbacks so problems solved?</p>

<p>Not for me.</p>

<p>I’ve used <code>std::function&lt;&gt;</code> and I’ve used lambdas and what pushed me away from them were crash reports.</p>

<p>I’ve implemented <a href="https://blog.kowalczyk.info/article/c4qb/how-to-make-software-crash-less.html#client-side-on-windows-in-c-apps-1">crash reporting</a> and it’s been very useful.</p>

<p>The problem with lambdas is that they are implemented as compiler-generated functions. They get non-descriptive, auto-generated names. When I look at call stack of a crash I can’t map the auto-generated closure name to a function in my code. It makes it harder to read crash reports.</p>

<h2 id="simplest-solution-that-could-possibly-work"><p>Simplest solution that could possibly work</p><a href="#simplest-solution-that-could-possibly-work">

</a>
</h2>

<p>You should know up front that my solution is worse than <code>std::function&lt;&gt;</code> in most ways. It’s not as nice to type as a lambda, it supports a small subset of <code>std::function&lt;&gt;</code> functionality.</p>

<p>On the other hand it’s small, fast and I can understand it.</p>

<p>One thing you need to know about me is that despite working on SumatraPDF C++ code base for 16 years, I don’t know 80% of C++.</p>

<p>I get by thanks to sticking to a small subset that I do understand.</p>

<p>I don’t claim I’ve invented this particular method. It seems obvious in retrospect but it did take me 16 years to arrive at it.</p>

<h2 id="implementation-of-a-simple-callback-in-c"><p>Implementation of a simple callback in C++</p><a href="#implementation-of-a-simple-callback-in-c">

</a>
</h2>

<h3 id="a-closure-is-code-data"><p>A closure is code + data</p><a href="#a-closure-is-code-data">

</a>
</h3>

<p>A closure is conceptually simple. It combines code (function) and data:</p>
<pre tabindex="0"><code><span><span><span>using</span> <span>func0Ptr</span> <span>=</span> <span>void</span> <span>(</span><span>*</span><span>)(</span><span>void</span><span>*</span><span>);</span>
</span></span><span><span><span>struct</span> <span>Func0</span> <span>{</span>
</span></span><span><span>  <span>func0Ptr</span> <span>fn</span><span>;</span>
</span></span><span><span>  <span>void</span><span>*</span> <span>data</span><span>;</span>
</span></span><span><span>  <span>void</span> <span>Call</span><span>()</span> <span>{</span> <span>fn</span><span>(</span><span>data</span><span>);</span> <span>}</span>
</span></span><span><span><span>};</span>
</span></span></code></pre>
<p>There are 2 big problems with this.</p>

<p>First is annoying casting. You have to do:</p>
<pre tabindex="0"><code><span><span><span>struct</span> <span>MyFuncData</span> <span>{</span> <span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>MyFunc</span><span>(</span><span>void</span><span>*</span> <span>voidData</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>MyFuncData</span><span>*</span> <span>data</span> <span>=</span> <span>(</span><span>MyFuncData</span><span>*</span><span>)</span><span>voidData</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>auto</span> <span>data</span> <span>=</span> <span>new</span> <span>MyFuncData</span><span>;</span>
</span></span><span><span><span>auto</span> <span>fn</span> <span>=</span> <span>Func0</span><span>{(</span><span>void</span><span>*</span><span>)</span><span>data</span><span>,</span> <span>MyFunc</span><span>}</span>
</span></span></code></pre>
<p>Second is lack of type safety:</p>
<pre tabindex="0"><code><span><span><span>struct</span> <span>MyFuncData</span> <span>{};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>MyOhterFunc</span><span>(</span><span>void</span><span>*</span> <span>voidData</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>MyOtherFuncData</span><span>*</span> <span>data</span> <span>=</span> <span>(</span><span>MyOtherFuncData</span><span>*</span><span>)</span><span>voidData</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>auto</span> <span>data</span> <span>=</span> <span>new</span> <span>MyFuncData</span><span>;</span>
</span></span><span><span><span>auto</span> <span>fn</span> <span>=</span> <span>Func0</span><span>{</span> <span>MyOtherFunc</span><span>,</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>data</span> <span>};</span>
</span></span></code></pre>
<p>We will call <code>MyOtherFunc</code> with data of <code>MyFunc</code>. This will likely crash.</p>

<p>The good thing is that pointer types are compatible. The machine instructions to call <code>void Foo(void*)</code> are exactly the same as calling <code>void Foo(FooData*)</code>.</p>

<p>We can solve the above annoyances with a bit of cleverness in the form of <code>MkFunc0()</code>:</p>
<pre tabindex="0"><code><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
</span></span><span><span><span>Func0</span> <span>MkFunc0</span><span>(</span><span>void</span> <span>(</span><span>*</span><span>fn</span><span>)(</span><span>T</span><span>*</span><span>),</span> <span>T</span><span>*</span> <span>d</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>auto</span> <span>res</span> <span>=</span> <span>Func0</span><span>{};</span>
</span></span><span><span>    <span>res</span><span>.</span><span>fn</span> <span>=</span> <span>(</span><span>func0Ptr</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>    <span>res</span><span>.</span><span>userData</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>d</span><span>;</span>
</span></span><span><span>    <span>return</span> <span>res</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>MyFunc</span><span>(</span><span>MyFuncData</span><span>*</span> <span>data</span><span>)</span> <span>{</span> <span>}</span>
</span></span><span><span>
</span></span><span><span><span>auto</span> <span>data</span> <span>=</span> <span>new</span> <span>MyFuncData</span><span>;</span>
</span></span><span><span><span>auto</span> <span>fn</span> <span>=</span> <span>MkFunc0</span><span>(</span><span>MyFunc</span><span>,</span> <span>data</span><span>);</span>
</span></span></code></pre>
<p>We no longer need to cast data from <code>void*</code> in <code>MyFunc</code>.</p>

<p>Trying to to create a mis-matched <code>auto fn = MkFunc0(MyFunc, new MyOtherFuncData)</code> will error out. The compiler will notice that <code>fn</code>and <code>data</code> arguments don’t match.</p>

<p>We’ll make one improvement: ability to also create closure for functions without any arguments:</p>
<pre tabindex="0"><code><span><span><span>void</span> <span>MyFuncNoData</span><span>()</span> <span>{</span> <span>};</span>
</span></span><span><span><span>Func0</span> <span>fn</span> <span>=</span> <span>MkFuncVoid</span><span>(</span><span>MyFuncNoData</span><span>);</span>
</span></span></code></pre>
<p>The implementation cleverness: use a special, impossible value of a pointer (-1) to indicate a function without arguments.</p>

<p>The full implementation is:</p>
<pre tabindex="0"><code><span><span><span>using</span> <span>func0Ptr</span> <span>=</span> <span>void</span> <span>(</span><span>*</span><span>)(</span><span>void</span><span>*</span><span>);</span>
</span></span><span><span><span>using</span> <span>funcVoidPtr</span> <span>=</span> <span>void</span> <span>(</span><span>*</span><span>)();</span>
</span></span><span><span>
</span></span><span><span><span>#define kVoidFunc0 (void*)-1
</span></span></span><span><span><span></span>
</span></span><span><span><span>// the simplest possible function that ties a function and a single argument to it
</span></span></span><span><span><span>// we get type safety and convenience with mkFunc()
</span></span></span><span><span><span></span><span>struct</span> <span>Func0</span> <span>{</span>
</span></span><span><span>    <span>void</span><span>*</span> <span>fn</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>    <span>void</span><span>*</span> <span>userData</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>Func0</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</span></span><span><span>    <span>Func0</span><span>(</span><span>const</span> <span>Func0</span><span>&amp;</span> <span>that</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>this</span><span>-&gt;</span><span>fn</span> <span>=</span> <span>that</span><span>.</span><span>fn</span><span>;</span>
</span></span><span><span>        <span>this</span><span>-&gt;</span><span>userData</span> <span>=</span> <span>that</span><span>.</span><span>userData</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>~</span><span>Func0</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>bool</span> <span>IsEmpty</span><span>()</span> <span>const</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>fn</span> <span>==</span> <span>nullptr</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>void</span> <span>Call</span><span>()</span> <span>const</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>!</span><span>fn</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>userData</span> <span>==</span> <span>kVoidFunc0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>auto</span> <span>func</span> <span>=</span> <span>(</span><span>funcVoidPtr</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>            <span>func</span><span>();</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>        <span>auto</span> <span>func</span> <span>=</span> <span>(</span><span>func0Ptr</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>        <span>func</span><span>(</span><span>userData</span><span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
</span></span><span><span><span>Func0</span> <span>MkFunc0</span><span>(</span><span>void</span> <span>(</span><span>*</span><span>fn</span><span>)(</span><span>T</span><span>*</span><span>),</span> <span>T</span><span>*</span> <span>d</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>auto</span> <span>res</span> <span>=</span> <span>Func0</span><span>{};</span>
</span></span><span><span>    <span>res</span><span>.</span><span>fn</span> <span>=</span> <span>(</span><span>func0Ptr</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>    <span>res</span><span>.</span><span>userData</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>d</span><span>;</span>
</span></span><span><span>    <span>return</span> <span>res</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>Func0</span> <span>MkFuncVoid</span><span>(</span><span>funcVoidPtr</span> <span>fn</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>auto</span> <span>res</span> <span>=</span> <span>Func0</span><span>{};</span>
</span></span><span><span>    <span>res</span><span>.</span><span>fn</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>    <span>res</span><span>.</span><span>userData</span> <span>=</span> <span>kVoidFunc0</span><span>;</span>
</span></span><span><span>    <span>return</span> <span>res</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<h3 id="closure-with-additional-caller-provided-argument"><p>Closure with additional caller-provided argument</p><a href="#closure-with-additional-caller-provided-argument">

</a>
</h3>

<p><code>Func0</code> only addresses a use case of packaging a function and its own data.</p>

<p>Most of use cases for callbacks require passing additional arguments.</p>

<p>For example a list view control has <code>onItemSelected(int itemIndex)</code> callback.</p>

<p>For that we need <code>Func1</code>:</p>
<pre tabindex="0"><code><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T</span><span>&gt;</span>
</span></span><span><span><span>struct</span> <span>Func1</span> <span>{</span>
</span></span><span><span>    <span>void</span> <span>(</span><span>*</span><span>fn</span><span>)(</span><span>void</span><span>*</span><span>,</span> <span>T</span><span>)</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>    <span>void</span><span>*</span> <span>userData</span> <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>Func1</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</span></span><span><span>    <span>~</span><span>Func1</span><span>()</span> <span>=</span> <span>default</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    <span>bool</span> <span>IsEmpty</span><span>()</span> <span>const</span> <span>{</span>
</span></span><span><span>        <span>return</span> <span>fn</span> <span>==</span> <span>nullptr</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>void</span> <span>Call</span><span>(</span><span>T</span> <span>arg</span><span>)</span> <span>const</span> <span>{</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>fn</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>fn</span><span>(</span><span>userData</span><span>,</span> <span>arg</span><span>);</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>template</span> <span>&lt;</span><span>typename</span> <span>T1</span><span>,</span> <span>typename</span> <span>T2</span><span>&gt;</span>
</span></span><span><span><span>Func1</span><span>&lt;</span><span>T2</span><span>&gt;</span> <span>MkFunc1</span><span>(</span><span>void</span> <span>(</span><span>*</span><span>fn</span><span>)(</span><span>T1</span><span>*</span><span>,</span> <span>T2</span><span>),</span> <span>T1</span><span>*</span> <span>d</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>auto</span> <span>res</span> <span>=</span> <span>Func1</span><span>&lt;</span><span>T2</span><span>&gt;</span><span>{};</span>
</span></span><span><span>    <span>using</span> <span>fptr</span> <span>=</span> <span>void</span> <span>(</span><span>*</span><span>)(</span><span>void</span><span>*</span><span>,</span> <span>T2</span><span>);</span>
</span></span><span><span>    <span>res</span><span>.</span><span>fn</span> <span>=</span> <span>(</span><span>fptr</span><span>)</span><span>fn</span><span>;</span>
</span></span><span><span>    <span>res</span><span>.</span><span>userData</span> <span>=</span> <span>(</span><span>void</span><span>*</span><span>)</span><span>d</span><span>;</span>
</span></span><span><span>    <span>return</span> <span>res</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre>
<p>We can now do:</p>
<pre tabindex="0"><code><span><span><span>struct</span> <span>OnListItemSelectedData</span> <span>{</span> <span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>OnListItemSelected</span><span>(</span><span>OnListItemChangedData</span><span>*</span> <span>d</span><span>,</span> <span>int</span> <span>selectedIdx</span><span>)</span> <span>{</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>struct</span> <span>ListView</span> <span>{</span>
</span></span><span><span>  <span>Func1</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>onListItemSelected</span><span>;</span>
</span></span><span><span>  <span>void</span> <span>listItemSelected</span><span>(</span><span>int</span> <span>idx</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>onListItemSelected</span><span>.</span><span>Call</span><span>(</span><span>idx</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>auto</span> <span>lv</span> <span>=</span> <span>new</span> <span>ListView</span><span>;</span>
</span></span><span><span><span>auto</span> <span>data</span> <span>=</span> <span>new</span> <span>OnListItemSelectedData</span><span>;</span>
</span></span><span><span><span>lv</span><span>.</span><span>onListItemSelected</span> <span>=</span> <span>MkFunc1</span><span>(</span><span>OnListItemSelected</span><span>,</span> <span>data</span><span>)</span>
</span></span></code></pre>
<p>In <code>Func0</code> the argument must be a pointer because the type is forgotten when we put it in a struct. We rely on the fact that <code>void foo(void*)</code> and <code>void foo(Foo*)</code> are compatible and we can cast the argument and function.</p>

<p>But <code>Func1</code> retains the type of second argument so it can be any type and the right call will happen.</p>

<p>We also don’t want to erase the second type to avoid casts when calling it and to serve as documentation.</p>

<p>We could write <code>Func2</code>for 2 arguments, <code>Func3</code> for 3 arguments etc. but I didn’t bother. If I need more than one argument, I can always use <code>struct</code> to pack any number of arguments into a single one.</p>

<h2 id="fringe-benefits"><p>Fringe benefits</p><a href="#fringe-benefits">

</a>
</h2>

<p>So is it worth it to use this over <code>std::function&lt;&gt;</code>?</p>

<p>For me it does and I’ve refactored SumatraPDF to get rid of most of <code>std::function&lt;&gt;</code> uses in favor of <code>Func0</code> and <code>Func1</code>.</p>

<p>Yes, <code>std::function&lt;&gt;</code> is better in many ways.</p>

<p>It’s more flexible. My solution only supports <code>void Foo()</code>, <code>void Foo(T*)</code> and <code>void Foo(T1*, T2)</code>. <code>std::function&lt;&gt;</code> supports arbitrary number arguments of any type.</p>

<p>Compared to writing a lambda with variable capture, I need to write more code:</p>

<ul>
<li>define a <code>struct</code> for closure data</li>
<li>allocate and initialize struct</li>
<li>construct <code>Func0</code> or <code>Func1</code></li>
<li>delete the data (typically at the end of closure)</li>
</ul>

<p>I decided writing this boilerplate doesn’t bother me.</p>

<p>There are fringe benefits of my approach.</p>

<p>On MSVC 64-bit <code>std::function&lt;&gt;</code> is 64 bytes. <code>Func0</code> and <code>Func1</code> are 16 bytes.</p>

<p>Templated code is a highway to bloat. For every unique type, the compiler generates a new class definition on set of methods. Implementation of <code>std::function&lt;&gt;</code> is gigantic compared to <code>Func1</code> and <code>Func2</code>.</p>

<p>Templated code is also a highway to slow compilation. Again, <code>std::function&lt;&gt;</code> is at least order of magnitude more complicated so it’ll take order of magnitude longer to compile.</p>

<p>Finally, I understand my implementation. I don’t understand <code>std::function&lt;&gt;</code> implementation. It’s scarier than Freddy Krueger. It’s scarier than Frankenstein’s monster.</p>

<p>In fact, I don’t think anyone understands <code>std::function&lt;&gt;</code> including the 3 people who implemented it.</p>

</div>

    </div></div>
  </body>
</html>
