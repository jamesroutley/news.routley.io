<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://storytime.ivysaur.me/posts/why-not-zfs/">Original</a>
    <h1>Why Not ZFS (2021)</h1>
    
    <div id="readability-page-1" class="page"><section id="js-article">
    <p><a href="https://arstechnica.com/information-technology/2020/05/zfs-101-understanding-zfs-storage-and-performance/">ZFS is a hybrid filesystem and volume manager system</a> that is quite popular recently but has some important and unexpected problems.</p>
<p>It has many good features, which are probably why it is used: snapshots (with send/receive suppport), checksumming, RAID of some kind (with scrubbing support), deduplication, compression, and encryption.</p>
<p>But ZFS also has a lot of downsides. It is not the only way to achieve those features on Linux, and there are better alternatives.</p>
<h2 id="terminology">Terminology</h2>
<p>In this post I will refer to <a href="https://zfsonlinux.org/">the ZFS on Linux project</a> as ZoL. It was renamed to OpenZFS since ZoL got FreeBSD support, and FreeBSD’s own in-tree ZFS driver was deprecated in favor of just periodically syncing ZoL from out-of-tree.</p>
<blockquote>
<p>What is “Scrubbing”? If a disk has an unrecoverable read error (URE) when reading a sector, it’s possible to repair the sector by rewriting its contents; the physical disk detects the rewrite over an unreadable sector and performs remapping in firmware. The RAID layer can do this automatically by relying on its redundant copy. Scrubbing is the process of periodically, preemtively reading every sector to check for UREs and repair them early.</p>
</blockquote>
<h2 id="bad-things-about-zfs">Bad things about ZFS</h2>
<h3 id="out-of-tree-and-will-never-be-mainlined">Out-of-tree and will never be mainlined</h3>
<p>Linux drivers are best maintained when they’re in the Linux kernel git repository along with all the other filesystem drivers. This is not possible because ZFS is under the CDDL license and Oracle are unlikely to relicense it, if they are even legally able to.</p>
<p>Therefore just like how all proprietary software eventually finds a GPL implementation and then a BSD/MIT one, ZFS will eventually be superceded by a mainline solution, so don’t get too used to it.</p>
<p>As an out-of-tree GPL-incompatible module, it is <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=ZFS-On-Linux-5.0-Problem">regularly broken by upstream changes on Linux</a> where ZoL was discovered to be abusing GPL symbols, causing long periods of unavailability until a workaround can be found.</p>
<p>When compiled together, loaded and runnning, the resulting kernel is a combined work of both GPL and CDDL code. It’s all open source, but your right to redistribute the work to others requires your compliance with both the CDDL and GPL license which can’t be satisifed simultaneously.</p>
<p>It’s still easy to install on Debian. They ship only ZoL’s source code with a nice script that compiles everything on your own machine (<code>zfs-dkms</code>), so it is <em>technically</em> never redistributed in this form which satisfies both licenses.</p>
<p>Ubuntu ships ZFS as part of the kernel, not even as a separate loadable module. This redistribution of a combined CDDL/GPLv2 work is probably illegal.</p>
<p>Red Hat will not touch this with a bargepole.</p>
<p>You could consider trying the <a href="https://packages.debian.org/sid/zfs-fuse">fuse ZFS</a> instead of the in-kernel one at least, as a userspace program it is definitely not a combined work.</p>
<h3 id="slow-performance-of-encryption">Slow performance of encryption</h3>
<p>ZoL did workaround the Linux symbol issue above by <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=ZFS-On-Linux-5.0-Workaround">disabling all use of SIMD for encryption</a>, reducing the performance versus an in-tree filesystem.</p>
<h3 id="rigid">Rigid</h3>
<p>To first clarify ZFS’s custom terminology (not considered a really bad point because even LVM2 is also guilty of using custom terminology here):</p>
<ul>
<li>A “dataset” is a filesystem you can mount. It might be the main filesystem or perhaps a snapshot.</li>
<li>A “pool” is the top-level block device. It is a union span (call it RAID-0, stripe, or JBOD if you like) of all the vdevs in the pool.</li>
<li>A “vdev” is the 2nd-level block device. It can be a passthrough of a single real block device, or a RAID of multiple underlying block devices. RAID happens at the vdev layer.</li>
</ul>
<p>This <code>RAID-X0</code> (stripe of mirrors) structure is rigid, you can’t do <code>0X</code> (mirror of stripes) instead at all. You can’t stack vdevs in any other configuration.</p>
<p>For argument’s sake, let’s assume most small installations would have a pool with only a single RAID-Z2 vdev.</p>
<h3 id="cant-addremove-disks-to-a-raid">Can’t add/remove disks to a RAID</h3>
<p>You can’t shrink a RAIDZ vdev by removing disks and you can’t grow a RAIDZ vdev in by adding disks.</p>
<p>All you can do in ZFS is expand your pool to create a whole second RAIDZ vdev and stripe your pool across it, creating a <code>RAID60</code> - you can’t just have one big <code>RAID6</code>. This could badly affect your storage efficiency.</p>
<p><em>(Just for comparison, mdadm lets you grow a RAID volume by adding disks since 2006 and shrink by removing disks since 2009.)</em></p>
<blockquote>
<p>Growing a RAIDZ vdev by adding disks is at least coming soon. It is <a href="https://github.com/openzfs/zfs/pull/12225">still a WIP as of August 2021</a> despite a <a href="https://arstechnica.com/gadgets/2021/06/raidz-expansion-code-lands-in-openzfs-master/">breathless Ars Technica article about it in June</a>.</p>
</blockquote>
<blockquote>
<p>There are several Ars Technica links in this blog post. I like Ars a lot and appreciate the Linux coverage, but as an influencer why are they so bullish about ZFS? It turns out all their ZFS articles <a href="https://arstechnica.com/author/jimsalter/">are written by this person</a> who is also <a href="https://www.reddit.com/r/zfs/comments/ovpxfe/poll_what_is_your_vdev_speed/h7bmh7n/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">a mod of /r/zfs and hangs out there a lot</a>. At least he is highly informed on the topic.</p>
</blockquote>
<h3 id="raidz-is-slow">RAIDZ is slow</h3>
<p>For some reason ZFS’s file-level RAIDZ <a href="https://www.reddit.com/r/zfs/comments/obul6a/having_a_conversation_about_mirrors_vs_raidz/h3v5lfb/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">IOPS only scale per vdev, not per underlying device</a>. A 10-disk RAIDZ2 has IOPS similar to a single disk.</p>
<p><em>(Just for comparison, mdadm’s block-level RAID6 will deliver more IOPS.)</em></p>
<h3 id="file-based-raid-is-slow">File-based RAID is slow</h3>
<p>For operations such as resilvering, rebuilding, or scrubbing, a block-based RAID can do this sequentially, whereas a file-based RAID has to perform a lot of random seeks. Sequential read/write is a far more performant workload for both HDDs and SSDs.</p>
<p>File-based RAID offers the promise of having to do less work and avoiding RAIDing the empty space, but in practice it is outweighed significantly by this difference.</p>
<p>It’s especially bad if you have a lot of small files.</p>
<p>It is even worse on SMR drives, and <a href="https://arstechnica.com/gadgets/2020/06/western-digitals-smr-disks-arent-great-but-theyre-not-garbage/2/">Ars Technica blame the drives</a> when they probably should have blamed ZFS’s RAID implementation.</p>
<p><em>(Just for comparison, mdadm works perfectly fine with these drives.)</em></p>
<h3 id="real-world-performance-is-slow">Real-world performance is slow</h3>
<p><a href="https://www.phoronix.com/scan.php?page=article&amp;item=ubuntu1910-ext4-zfs&amp;num=3">Phoronix benchmarks of ext4 vs zfs in 2019</a> show that ZFS does win some synthetic benchmarks but badly loses all real-world tests to ext4.</p>
<h3 id="performance-degrades-faster-with-low-free-space">Performance degrades faster with low free space</h3>
<p>It’s recommended to <a href="https://serverfault.com/a/511160">keep a ZFS volume below 80 - 85% usage</a> and <a href="https://serverfault.com/q/733817">even on SSDs</a>. This means you have to buy bigger drives to get the same usable size compared to other filesystems.</p>
<p>At high utilization, most filesystems will take a little bit longer to fragment new writes into rarer free blocks, but ZFS’s problem is on an entirely different level because it does not have a free-blocks bitmap at all.</p>
<p><em>(Just for comparison, ext4 and even NTFS perform highly well up to extremely high percentage utilization.)</em></p>
<h3 id="layering-violation-of-volume-management">Layering violation of volume management</h3>
<p>ZFS is both a filesystem and a volume manager.</p>
<p>However, its volume management is exclusive to its filesystem, and its filesystem is exclusive to its volume management.</p>
<p>If you use ZFS’s volume management, you can’t have it manage your other drives using ext4, xfs, UFS, ntfs filesystems. And likewise you can’t use ZFS’s filesystem with any other volume manager.</p>
<p>Therefore you’ll need to know both the standard <code>mount</code>/<code>umount</code>/<code>fstab</code> commands as well as an entirely separate set of <code>zfs</code>/<code>zpool</code>/<code>zdb</code> commands and never the two shall meet.</p>
<p>On Linux you definitely can’t escape the traditional volume manager (e.g. <code>mount -a</code> on your <code>fstab</code> is used for swap) and likewise on FreeBSD (where <code>mount</code> on UFS is still the standard filesystem) where ZFS is supposedly “better integrated”.</p>
<p>This is understandable given ZFS is trying to do file-level RAID, but I’ve explained that performs badly and was probably a bad idea.</p>
<h3 id="doesnt-support-reflink">Doesn’t support reflink</h3>
<p>Despite being a copy on write (CoW) filesystem <a href="https://github.com/openzfs/zfs/issues/405">it doesn’t support <code>cp --reflink</code></a>. Btrfs does. <a href="https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink">Even XFS does</a> despite being a traditional non-CoW filesystem.</p>
<h3 id="high-memory-requirements-for-dedupe">High memory requirements for dedupe</h3>
<p>For all intents and purposes, this online deduplication feature may as well not exist.</p>
<p>The RAM requirements are eye-wateringly high (e.g. <a href="https://www.reddit.com/r/zfs/comments/8bcjoy/cheating_deduplication_memory_requirements/">1GB per 1TB pool size may not be sufficient</a>), because the deduplication table (DDT) is kept in memory and without this much RAM the performance degrades significantly.</p>
<p>Deduplication generally offers neglegible savings unless perhaps you’re storing a lot of VM disk images of the same OS. There is a <a href="https://www.oracle.com/technical-resources/articles/it-infrastructure/admin-o11-113-size-zfs-dedup.html">nice tool to estimate the dedupe savings</a> (<code>zdb -S</code>) but general recommendations are not to bother with ZFS dedupe unless you can save 16x storage (!!!) owing to the extreme performance impact of the feature.</p>
<p><em>(By comparison <a href="https://www.reddit.com/r/homelab/comments/bmxybr/experience_with_vdo_block_layer_dedupcompression/">lvmvdo has similarly bad performance</a> but at least <a href="https://man7.org/linux/man-pages/man7/lvmvdo.7.html#:~:text=268%20MiB">uses significantly less RAM</a>.)</em></p>
<h3 id="dedupe-is-synchronous-instead-of-asynchronous">Dedupe is synchronous instead of asynchronous</h3>
<p>This means that if deduplication is enabled, every single write operation has to undergo read/write IOPS amplification.</p>
<p><em>(By comparison, btrfs’s deduplication and Windows Server deduplication run as a background process, to reclaim space at off-peak times.)</em></p>
<h3 id="high-memory-requirements-for-arc">High memory requirements for ARC</h3>
<p>Linux has a unified caching system for file operations, block IO (<code>bio</code>) operations, and swap, called the page cache. ZFS is not allowed to use the Linux page cache at all, because such a deep part of Linux’s design can only be accessed via GPL symbols and the CDDL source code can’t rely on them.</p>
<p>Therefore ZoL implements its own cache, the Adaptive Replacement Cache (ARC) that constantly fights with the Linux page cache for memory.</p>
<p>The <a href="https://utcc.utoronto.ca/~cks/space/blog/linux/ZFSOnLinuxPageCacheProblem">infighting problem is really bad</a> but since then the <a href="https://utcc.utoronto.ca/~cks/space/blog/linux/ZFSOnLinuxARCNowWorksRight">heuristics were improved to the point</a> where it still used &gt;17GB of RAM just for the ARC.</p>
<p>If you do literally anything else on the PC other than be a ZFS host (e.g. use a web browser, browse an SMB share…) then you are subject to this infighting.</p>
<p>If a program uses <code>mmap</code>, files are double-buffered in both the ARC and the Linux page cache.</p>
<p>Even on FreeBSD where ZFS is supposedly better integrated, ZoL still pretends that every OS is Solaris via <a href="https://openzfs.org/wiki/Reduce_code_differences">the Solaris Porting Layer (SPL)</a> and doesn’t use their page cache neither. This design decision makes it a bad citizen on every OS.</p>
<p>Even the <a href="https://packages.debian.org/sid/zfs-fuse">fuse ZFS</a> has <a href="https://www.kernel.org/doc/html/latest/filesystems/fuse-io.html">better page cache properties</a> here (although it has lower performance in general).</p>
<h3 id="buggy">Buggy</h3>
<p>At time of writing there are <a href="https://github.com/openzfs/zfs/labels/Type%3A%20Defect">387 open issues with <code>Type: Defect</code> label on the ZoL Github</a> and the bulk of them seem to be genuinely important problems, such as logic bugs, panics, assertions, hanging, system crashes, kernel null pointer dereferences, and <a href="https://git.kernel.org/pub/scm/fs/xfs/xfstests-dev.git/tree/README">xfstests</a> failures.</p>
<p>One good thing to say about the ZoL project is the triage and categorization of these bugs is well organized.</p>
<h3 id="no-disk-checking-tool-fsck">No disk checking tool (fsck)</h3>
<p>Yikes.</p>
<p>In ZFS you can use <code>zpool clear</code> to roll back to the last good snapshot, that’s better than nothing.</p>
<p>One common excuse for the missing tool is <a href="http://www.c0t0d0s0.org/2009-11-04/no-zfs-really-doesn-t-need-a-fsck.c0t0d0s0">that the CoW data structures are always consistent on disk</a>, but so is ext4 with its journalling. ZFS can still get corrupt on disk for various reasons:</p>
<ul>
<li>merely rolling back to the last good snapshot as above does not verify the deduplication table (DDT) and this will cause all snapshots to be unmountable</li>
<li>coupled with the above point (“Buggy”) if ZFS writes bad data to the disk or writes bad metaslabs, this is a showstopper</li>
</ul>
<p>and so it should have an <code>fsck.zfs</code> tool that does <a href="https://news.ycombinator.com/item?id=5466575">more repair steps than just <code>exit 0</code></a>.</p>
<h3 id="past-complaints-that-are-now-fixed">Past complaints that are now fixed</h3>
<ul>
<li> no TRIM support (added in ZoL 0.8.0 in mid 2019)</li>
</ul>
<h2 id="things-to-use-instead">Things to use instead</h2>
<p>The baseline comparison should just be ext4. Maybe on mdadm.</p>
<p>Then if you want the other features, you can easily get them from either the block layer (if I convinced you file-level RAID was a bad idea), or from a filesystem (if you were not convinced), or because it’s Linux you can mix-and-match features from each as you like.</p>
<p><strong>RAID</strong> is best done at the block layer with mdadm. LVM2 has its own wrapper for this (lvraid) which is more nicely integrated, but using mdadm directly is more debuggable. Btrfs has a file-level RAID feature that is okay for 0/1 but not for 5/6, better stick with mdadm.</p>
<p><strong>Encryption</strong> is best done at the block layer with LUKS (<code>cryptsetup</code>). Btrfs has a feature for it too. Both perform significantly better than ZFS owing to the aforementioned SIMD symbol workaround for Linux 5.0.</p>
<p><strong>Snapshots</strong> can be done with LVM2 thin pools or by swapping ext4 for btrfs or (wildcard suggestion) NILFS2. LVM2 is the more performant approach. Support for send/receive is built-in to btrfs, and is easily available for LVM2 with a utility like <a href="https://theshed.hezmatt.org/lvmsync/">lvmsync</a>, <a href="https://github.com/davidbartonau/lvm-thin-sendrcv">lvm-thin-sendrcv</a>, or <a href="https://github.com/LINBIT/thin-send-recv">thin-send-recv</a>.</p>
<p><strong>Scrubbing</strong> simply needs to read every file from the disk so the RAID layer notices and repairs a URE. You can simply put <code>cat /dev/array &gt; /dev/null</code> on cron once a month which is enough for mdadm to notice and repair UREs.</p>
<p><strong>Deduplication</strong> is usually not worthwhile - for VM disk images, it’s better to use differencing disks in your hypervisor, and for for storing backups, it’s better to use a real deduplicating backup store like <a href="https://www.borgbackup.org/">borg</a>, <a href="https://restic.net/">restic</a>, or <a href="https://kopia.io/">kopia</a>. But you can easily get this if you want, <a href="https://man7.org/linux/man-pages/man7/lvmvdo.7.html">with LVM2’s new lvmvdo / kvdo</a> and with btrfs use any off-peak daemon such as <a href="https://github.com/lakshmipathi/dduper">dduper</a> or <a href="https://github.com/Zygo/bees">bees</a>.</p>
<p><strong>Compression</strong> is usually not worthwhile - most files (e.g. Microsoft Office’s XML.zip documents, JPGs, binaries, …) do not benefit from compression, and the files that do (e.g. sqlite databases) are usually sparse for performance reasons. But you can easily get this if you want with lvmvdo, or it’s an option when you create a btrfs filesystem.</p>
<p><strong>Checksumming</strong> is usually not worthwhile - the physical disk already has CRC checksums at the SATA level, and if you are paranoid you should also have ECC ram to prevent integrity issues in-memory (applies to ZFS too), and this should be enough. But you can easily get this if you want, either at the block layer with <a href="https://gitlab.com/cryptsetup/cryptsetup/-/wikis/DMIntegrity">dm-integrity (<code>integritysetup</code>)</a> below your disk or btrfs does it automatically.</p>
<p>Checksumming can also be done offline at the file level by running <a href="http://md5deep.sourceforge.net/">hashdeep</a> / <a href="https://linux.die.net/man/1/cksfv">cksfv</a> on cron to create a <code>*.sfv</code> file of all your file hashes. This would also be a replacement for the scrubbing process.</p>
<h2 id="summary">Summary</h2>
<p>If you use upstream Linux features such as mdadm, LVM2, and/or btrfs instead of ZFS, you can achieve all the same nice advanced features, with the side benefit that it won’t break with any upstream kernel update; it’s legal; it’s faster; it works on SMR drives; it uses less RAM; it has a real repair tool; and it works better with other standard Linux features.</p>
<p>It might seem like there are more parts to set up, but actually all these features need to be configured and enabled on ZFS too, it’s not really any simpler. ZFS also has a lot of tuning parameters to set.</p>
<p>In the future we’re waiting to see what <a href="https://stratis-storage.github.io/"><code>stratis</code></a> and <a href="https://bcachefs.org/"><code>bcachefs</code></a> offer. For extremely large installations you should also consider doing the erasure-coding in userspace with Ceph or OpenStack Swift.</p>
<p>There are probably some situations where ZFS still makes sense and it’s interesting to learn about all solutions in this space. But in general I couldn’t recommend using it.</p>

  </section></div>
  </body>
</html>
