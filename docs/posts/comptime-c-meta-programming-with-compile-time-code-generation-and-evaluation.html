<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sebastienros/comptime">Original</a>
    <h1>Comptime â€“ C# meta-programming with compile-time code generation and evaluation</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A .NET source generator that executes methods at compile time and serializes their results to C# code. Comptime brings meta-programming capabilities to C#, enabling compile-time code generation and evaluation.</p>

<p dir="auto">Comptime allows you to mark methods with the <code>[Comptime]</code> attribute to have them executed during compilation. The return values are serialized into C# source code and used at runtime, eliminating the need for runtime computation of values that can be determined at build time.</p>
<p dir="auto">This meta-programming approach enables developers to shift expensive computations from runtime to compile time, resulting in faster application startup and execution.</p>

<ul dir="auto">
<li><strong>Compile-time execution</strong>: Methods marked with <code>[Comptime]</code> are executed during compilation</li>
<li><strong>Method parameters</strong>: Methods can accept parameters with compile-time constant expressions</li>
<li><strong>C# serialization</strong>: Results are serialized to valid C# code</li>
<li><strong>Supported return types</strong>:
<ul dir="auto">
<li>Primitive types: <code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>, <code>sbyte</code>, <code>uint</code>, <code>ulong</code>, <code>ushort</code>, <code>float</code>, <code>double</code>, <code>decimal</code>, <code>bool</code>, <code>char</code>, <code>string</code></li>
<li>Collections: <code>IReadOnlyList&lt;T&gt;</code>, <code>IReadOnlyDictionary&lt;TKey, TValue&gt;</code>, <code>List&lt;T&gt;</code>, <code>Dictionary&lt;TKey, TValue&gt;</code></li>
<li>Note: Arrays are <strong>not</strong> allowed as return types because they are mutable. Use <code>IReadOnlyList&lt;T&gt;</code> instead.</li>
</ul>
</li>
<li><strong>Supported argument types</strong>: Any expression that doesn&#39;t contain variables, including:
<ul dir="auto">
<li>Literals: <code>42</code>, <code>&#34;hello&#34;</code>, <code>true</code></li>
<li>Collection initializers: <code>new List&lt;int&gt; { 1, 2, 3 }</code>, <code>new[] { &#34;a&#34;, &#34;b&#34;, &#34;c&#34; }</code></li>
<li>Expressions: <code>1 + 2</code>, <code>Math.PI * 2</code></li>
<li>Const values and enum members</li>
</ul>
</li>
<li><strong>Interceptor-based</strong>: Uses C# interceptors to replace method calls with pre-computed values</li>
</ul>

<div dir="auto"><h3 tabindex="-1" dir="auto">Basic Usage (Parameterless Methods)</h3><a id="user-content-basic-usage-parameterless-methods" aria-label="Permalink: Basic Usage (Parameterless Methods)" href="#basic-usage-parameterless-methods"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="using Comptime;

public static partial class Constants
{
    [Comptime]
    public static IReadOnlyList&lt;int&gt; GetPrimeNumbers()
    {
        // Complex computation that runs at compile time
        var primes = new List&lt;int&gt;();
        for (int i = 2; i &lt;= 100; i++)
        {
            if (IsPrime(i))
                primes.Add(i);
        }
        return primes;
    }
    
    private static bool IsPrime(int n) { /* ... */ }
}

// At runtime, calling GetPrimeNumbers() returns the pre-computed list
var primes = Constants.GetPrimeNumbers(); // Returns [2, 3, 5, 7, 11, ...]"><pre><span>using</span> <span>Comptime</span><span>;</span>

<span>public</span> <span><span>static</span></span> <span>partial</span> <span>class</span> <span>Constants</span>
<span>{</span>
    <span>[</span><span>Comptime</span><span>]</span>
    <span>public</span> <span><span>static</span></span> <span>IReadOnlyList</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>GetPrimeNumbers</span><span>(</span><span>)</span>
    <span>{</span>
        <span>// Complex computation that runs at compile time</span>
        <span>var</span> <span>primes</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>100</span><span>;</span> <span>i</span><span>++</span><span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span><span>IsPrime</span><span>(</span><span>i</span><span>)</span><span>)</span>
                <span>primes</span><span>.</span><span>Add</span><span>(</span><span>i</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>primes</span><span>;</span>
    <span>}</span>
    
    <span>private</span> <span><span>static</span></span> <span>bool</span> <span>IsPrime</span><span>(</span><span>int</span> <span>n</span><span>)</span> <span>{</span> <span>/* ... */</span> <span>}</span>
<span>}</span>

<span>// At runtime, calling GetPrimeNumbers() returns the pre-computed list</span>
<span>var</span> <span>primes</span> <span>=</span> <span>Constants</span><span>.</span><span>GetPrimeNumbers</span><span>(</span><span>)</span><span>;</span> <span>// Returns [2, 3, 5, 7, 11, ...]</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="using Comptime;

public static partial class Math
{
    [Comptime]
    public static long Factorial(int n)
    {
        if (n &lt;= 1) return 1;
        long result = 1;
        for (int i = 2; i &lt;= n; i++)
            result *= i;
        return result;
    }

    [Comptime]
    public static int SumList(IReadOnlyList&lt;int&gt; numbers)
    {
        return numbers.Sum();
    }
}

// Each unique argument combination is computed at compile time
var fact5 = Math.Factorial(5);   // Pre-computed: 120
var fact10 = Math.Factorial(10); // Pre-computed: 3628800

// Collection initializers work too!
var sum = Math.SumList(new List&lt;int&gt; { 1, 2, 3, 4, 5 }); // Pre-computed: 15
var sum2 = Math.SumList(new[] { 10, 20, 30 });           // Pre-computed: 60"><pre><span>using</span> <span>Comptime</span><span>;</span>

<span>public</span> <span><span>static</span></span> <span>partial</span> <span>class</span> <span>Math</span>
<span>{</span>
    <span>[</span><span>Comptime</span><span>]</span>
    <span>public</span> <span><span>static</span></span> <span>long</span> <span>Factorial</span><span>(</span><span>int</span> <span>n</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>n</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>return</span> <span>1</span><span>;</span>
        <span>long</span> <span>result</span> <span>=</span> <span>1</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>2</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span>
            <span>result</span> <span>*=</span> <span>i</span><span>;</span>
        <span>return</span> <span>result</span><span>;</span>
    <span>}</span>

    <span>[</span><span>Comptime</span><span>]</span>
    <span>public</span> <span><span>static</span></span> <span>int</span> <span>SumList</span><span>(</span><span>IReadOnlyList</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>numbers</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>numbers</span><span>.</span><span>Sum</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// Each unique argument combination is computed at compile time</span>
<span>var</span> <span>fact5</span> <span>=</span> <span>Math</span><span>.</span><span>Factorial</span><span>(</span><span>5</span><span>)</span><span>;</span>   <span>// Pre-computed: 120</span>
<span>var</span> <span>fact10</span> <span>=</span> <span>Math</span><span>.</span><span>Factorial</span><span>(</span><span>10</span><span>)</span><span>;</span> <span>// Pre-computed: 3628800</span>

<span>// Collection initializers work too!</span>
<span>var</span> <span>sum</span> <span>=</span> <span>Math</span><span>.</span><span>SumList</span><span>(</span><span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>)</span><span>;</span> <span>// Pre-computed: 15</span>
<span>var</span> <span>sum2</span> <span>=</span> <span>Math</span><span>.</span><span>SumList</span><span>(</span><span>new</span><span>[</span><span>]</span> <span>{</span> <span>10</span><span>,</span> <span>20</span><span>,</span> <span>30</span> <span>}</span><span>)</span><span>;</span>           <span>// Pre-computed: 60</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="using Comptime;

public static partial class Utils
{
    [Comptime]
    public static int CountItems&lt;T&gt;(IReadOnlyList&lt;T&gt; items)
    {
        return items.Count;
    }

    [Comptime]
    public static string JoinStrings(IReadOnlyList&lt;string&gt; strings, string separator)
    {
        return string.Join(separator, strings);
    }
}

var count = Utils.CountItems(new[] { &#34;a&#34;, &#34;b&#34;, &#34;c&#34; }); // Pre-computed: 3
var joined = Utils.JoinStrings(new[] { &#34;hello&#34;, &#34;world&#34; }, &#34; &#34;); // Pre-computed: &#34;hello world&#34;"><pre><span>using</span> <span>Comptime</span><span>;</span>

<span>public</span> <span><span>static</span></span> <span>partial</span> <span>class</span> <span>Utils</span>
<span>{</span>
    <span>[</span><span>Comptime</span><span>]</span>
    <span>public</span> <span><span>static</span></span> <span>int</span> <span>CountItems</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>IReadOnlyList</span><span>&lt;</span><span>T</span><span>&gt;</span> <span>items</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>items</span><span>.</span><span>Count</span><span>;</span>
    <span>}</span>

    <span>[</span><span>Comptime</span><span>]</span>
    <span>public</span> <span><span>static</span></span> <span>string</span> <span>JoinStrings</span><span>(</span><span>IReadOnlyList</span><span>&lt;</span><span>string</span><span>&gt;</span> <span>strings</span><span>,</span> <span>string</span> <span>separator</span><span>)</span>
    <span>{</span>
        <span>return</span> <span>string</span><span>.</span><span>Join</span><span>(</span><span>separator</span><span>,</span> <span>strings</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>var</span> <span>count</span> <span>=</span> <span>Utils</span><span>.</span><span>CountItems</span><span>(</span><span>new</span><span>[</span><span>]</span> <span>{</span> <span>&#34;a&#34;</span><span>,</span> <span>&#34;b&#34;</span><span>,</span> <span>&#34;c&#34;</span> <span>}</span><span>)</span><span>;</span> <span>// Pre-computed: 3</span>
<span>var</span> <span>joined</span> <span>=</span> <span>Utils</span><span>.</span><span>JoinStrings</span><span>(</span><span>new</span><span>[</span><span>]</span> <span>{</span> <span>&#34;hello&#34;</span><span>,</span> <span>&#34;world&#34;</span> <span>}</span><span>,</span> <span>&#34; &#34;</span><span>)</span><span>;</span> <span>// Pre-computed: &#34;hello world&#34;</span></pre></div>

<ul dir="auto">
<li>.NET 8.0 or later</li>
<li>C# 12 or later (for interceptors support)</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="&lt;PackageReference Include=&#34;Comptime&#34; Version=&#34;1.0.0&#34; /&gt;"><pre>&lt;<span>PackageReference</span> <span>Include</span>=<span><span>&#34;</span>Comptime<span>&#34;</span></span> <span>Version</span>=<span><span>&#34;</span>1.0.0<span>&#34;</span></span> /&gt;</pre></div>

<ol dir="auto">
<li>The source generator finds methods marked with <code>[Comptime]</code></li>
<li>It identifies all call sites and their arguments</li>
<li>For each unique argument combination, it executes the method at compile time</li>
<li>The return values are serialized to C# literals/expressions</li>
<li>Interceptor methods are generated that return the pre-computed values</li>
<li>At runtime, calls to the original methods are intercepted and return the cached values</li>
</ol>

<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>COMPTIME001</td>
<td>Class must be partial</td>
</tr>
<tr>
<td>COMPTIME002</td>
<td>Method must be static</td>
</tr>
<tr>
<td>COMPTIME004</td>
<td>Unsupported return type</td>
</tr>
<tr>
<td>COMPTIME005</td>
<td>Compilation emit failed</td>
</tr>
<tr>
<td>COMPTIME006</td>
<td>Method execution failed</td>
</tr>
<tr>
<td>COMPTIME007</td>
<td>Serialization failed</td>
</tr>
<tr>
<td>COMPTIME011</td>
<td>Array return type not allowed (use IReadOnlyList)</td>
</tr>
<tr>
<td>COMPTIME012</td>
<td>Argument must be a constant (no variables allowed)</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<ul dir="auto">
<li>Methods must be <code>static</code></li>
<li>The containing class must be <code>partial</code></li>
<li>Return types must be immutable (arrays are not allowed, use <code>IReadOnlyList&lt;T&gt;</code>)</li>
<li>Method arguments must be compile-time constant expressions (no variables, only literals and expressions of literals)</li>
<li>Methods cannot have side effects that depend on runtime state</li>
</ul>

<p dir="auto">MIT License</p>
</article></div></div>
  </body>
</html>
