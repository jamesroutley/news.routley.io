<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.benshoof.org/blog/sci-scripts">Original</a>
    <h1>Annotated scripts of old Sierra games</h1>
    
    <div id="readability-page-1" class="page"><div>
				
			
				<div>
					<p>
					&#39;Round these parts, we write about old Sierra games and their rich inner lives. As I&#39;m often at pains to point out, this is thanks to the brilliant script decompiler written by Phil Fortier for <a href="http://scicompanion.com/">SCI Companion</a>. Released in 2015, it was the first and only decompiler for SCI games — at least as far as the world is concerned. And now lo, for there is another.
					</p>
			
					<p>
					Last year, I had a vision and began writing my own decompiler — a <i>mass decompiler</i> — with the goal of wiring it up to my script tools for annotations. Annotations are comments and symbols that transform decompiled code from something you <i>can</i> read into something you want to. That&#39;s how I learned the scripts in the first place: by writing automatic annotators and reading the results. I wanted to share this with the community<a href="https://www.benshoof.org/blog/community">*</a> but the particulars of SCI Companion made it a thorny problem. The decompiler I envisioned could unlock the solution, but I didn&#39;t know how to write it. I wasn&#39;t sure I ever would. The only certainty was that win or lose, it would take a while.
					</p>
			
					<p>
					In the meantime, I slowly obtained as many games and variants as I could. What&#39;s a mass decompiler without the masses? There are only about sixty games, but they were heavily revised, ported, and translated. Software scavenger hunts are fun and this one as been successful. I&#39;ve now amassed over three hundred versions of SCI games from 1988 through 1996. While that&#39;s not <i>every</i> single one, you have my permission to say it is.
					</p>
			
					<p>
					Today, with one command and a couple of cores, I&#39;ve decompiled and annotated every Sierra SCI game, and <i>practically</i> every version, and dumped the results on github for everyone to enjoy. <b>Gentlemen... <i>BEHOLD!</i></b>
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/behold.jpg" alt="Dr. Weird with arms outstretched"/>
					</p>
			
					<p>
					<i>You&#39;re still here??</i> Look, you&#39;re welcome to stay, but I just linked to half a gig of <b>way</b> more interesting text. I even got out the big font! (When do we <i>ever</i> get out the big font?) In fact, I&#39;m counting on the crowd thinning out so I can indulge in some inside baseball.
					</p>
			
					<p>
					I just want to kick back and tell the story of how this came to be. We&#39;ll see where Sierra&#39;s script language came from, what reverse engineers have done with it, and why I&#39;m cheerfully undermining the blog with today&#39;s release. I&#39;ve got <i>a lot</i> of meta-rules to break. You go outside and play with your scripts!
					</p>
			
					<p>
					When I talk about Sierra code, I break it into three categories:
					</p>
			
					<ul>
					<li><p>
					<b>Game Scripts:</b> This is the unique code that defines a game. Every room in every game gets its own script. You care about this if you want to solve <a href="https://www.benshoof.org/blog/super-sleuth">murder mysteries</a> or find <a href="https://www.benshoof.org/blog/gabriel-knight-1-easter-eggs">easter eggs</a>. This is probably the only code you care about.
					</p></li>
					<li><p>
					<b>System Scripts:</b> These are the supporting scripts that appear in every game. They form a common runtime library that the games are built on. You&#39;ll find generic classes for rooms and actors and icon bars, and utility functions for things like message boxes and math. Even the game loop lives here. As you get deeper into SCI mechanics, you care more about these scripts, although perhaps reluctantly.
					</p></li>
					<li><p>
					<b>The Interpreter:</b> This is the program that runs the show; you know it as SIERRA.EXE or SCIV.EXE. The interpreter was written in C and a lot of assembly, and then rewritten in C++ and slightly less assembly. It loads drivers, decodes resources, and runs the first game script in a virtual machine. It&#39;s the &#34;VM&#34; in <a href="https://www.scummvm.org/">ScummVM</a>. From there, it just follows orders until a script sets the quit flag or it famously crashes. It also contains over a hundred kernel functions that scripts call to do work. You care about the interpreter if you want to solve <a href="https://www.benshoof.org/blog/case-cracked">bonus mysteries</a> or find <a href="https://www.benshoof.org/blog/sierras-macintosh-timebomb">timebombs</a>. Or if you&#39;re <a href="https://www.scummvm.org/credits/#engine_teams">crazy enough</a> to replace the whole thing.
					</p></li>
					</ul>
			
					<p>
					Today is all about the scripts. Let&#39;s see what one looks like! Remember that Sierra programmers wrote these in their proprietary language (also called Script) and compiled them with their in-house compiler to SCI bytecode. Those are the bytes that shipped with the games. Decompiling can <i>never</i> recover the original text. Symbols are lost. Control flow is ambiguous. Compilers have bugs. Optimizations ruin everything.
					</p>
			
					<p>
					But God is alive, and Magic is afoot.
					</p>
			
<pre>(<span>instance</span> <span>mints</span> <span>of</span> <span>View</span>
	(<span>method</span> (doVerb param1)
		(<span>switch</span> param1
			(<span>5</span>
				(<span>if</span> (&lt; global153 <span>3</span>)
					(<span>if</span> (<span>not</span> (global0 <span>has:</span> <span>23</span>))
						(global2 <span>setScript:</span> <span>takeMintScr</span>)
					<span>else</span>
						(global91 <span>say:</span> noun param1 <span>35</span>)
					)
				<span>else</span>
					(global91 <span>say:</span> <span>7</span> <span>5</span> <span>32</span>)
				)
			)
			(<span>1</span>
				(<span>if</span> (&lt; global153 <span>3</span>)
					(global91 <span>say:</span> noun param1 <span>33</span>)
				<span>else</span>
					(global91 <span>say:</span> noun param1 <span>32</span>)
				)
			)
			(<span>else</span>
				(<span>super</span> <span>doVerb:</span> param1 <span>&amp;rest</span>)
			)
		)
	)
)
</pre>
			
					<p>
					Thanks, decompiler! Now let&#39;s see it with annotations.
					</p>
			
<pre>(<span>instance</span> <span>mints</span> <span>of</span> <span>View</span>
	(<span>method</span> (doVerb theVerb)
		(<span>switch</span> theVerb
			(<span>5</span> 
				(<span>if</span> (&lt; gAct <span>3</span>)
					(<span>if</span> (<span>not</span> (gEgo <span>has:</span> <span>23</span>)) 
						(gCurRoom <span>setScript:</span> <span>takeMintScr</span>)
					<span>else</span>
						(gMessager <span>say:</span> noun theVerb <span>35</span>) 
					)
				<span>else</span>
					(gMessager <span>say:</span> <span>7</span> <span>5</span> <span>32</span>) 
				)
			)
			(<span>1</span> 
				(<span>if</span> (&lt; gAct <span>3</span>)
					(gMessager <span>say:</span> noun theVerb <span>33</span>) 
				<span>else</span>
					(gMessager <span>say:</span> noun theVerb <span>32</span>) 
				)
			)
			(<span>else</span>
				(<span>super</span> <span>doVerb:</span> theVerb <span>&amp;rest</span>)
			)
		)
	)
)
</pre>
			
					<p>
					This is the code that runs when you click the mint dish in King&#39;s Quest VI. And thanks to the annotations, you know what it does. Each comment was generated by an annotator. The message annotator is usually the most helpful. Without the comments, you&#39;re just staring at numbers. The global variables were renamed by two annotators: one that handles system globals and another that knows KQ6 details. As you can see in the first version, some symbols come straight from the game. Sierra generously included them for debugging. Combine those names with annotations and you get highly readable code.
					</p>
			
					<p>
					Annotations aside, scope out that language. SCI Script is often described as LISP-like, but that&#39;s just a curvy stereotype. It <i>looks</i> like LISP because of parenthesis and prefix notation, but if that&#39;s all it takes... well please tell that to a LISP programmer. They deserve it. This language doesn&#39;t even have LISts! The syntax does make it easy to parse, but I haven&#39;t seen anyone take advantage of that; except compiler authors and me. So join the rest of the world and forget about LISP. The real inspiration for SCI Script is Smalltalk.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/smalltalk.jpg" alt="BYTE Magazine Cover, August 1981, Smalltalk"/>
					</p>
			
					<p>
					Jeff Stephenson is the father of SCI — he wrote the language, the compiler, and the bytecode interpreter. Two years ago, the <i>Video Game Newsroom Time Machine</i> scored a two hour <a href="https://www.youtube.com/watch?v=K3s0nW1FBN8">interview</a> about his life and career, and he recounted his influences:
					</p>
			
					<blockquote>
						<p>
						Somewhere in there, BYTE Magazine came out with their Smalltalk issue and I discovered object oriented programming, and you know, I read that issue cover to cover I think, and sometimes multiple times maybe. [...]
						</p>
			
						<p>
						In any case I started learning about object oriented programming and it just really resonated with me. And then suddenly we were able to start displaying more than 16 colors on monitors, and Ken wanted of course to take advantage of that, but AGI was written in such a way that it was going to take a major rework of the entire game engine and language and everything in order to support 256 colors. And so that&#39;s when I pitched Ken on SCI and basically saying okay let&#39;s go with a whole new language, we&#39;re going to have to rewrite this thing anyway, let&#39;s make things better. And he was pretty dubious, but I guess he figured since we were having to rewrite everything anyway, he might as well let me do it.
						</p>
			
						
					</blockquote>
			
					<p>
					BYTE Magazine dedicated one issue to a language each year. In August 1981, that was Smalltalk. Reading through, I was first struck by the magazine cover. Oh... it has a back story. It&#39;s a charming retort to the <a href="https://archive.org/details/byte-magazine-1978-08">Pascal cover</a> from 1978 that painted Smalltalk as aloof and inaccessible. I love it; did that allegorical slight really fester at Xerox PARC for three years? Of course it did! <i>They&#39;re nerds!</i> And their response? A textbook <a href="https://www.merriam-webster.com/words-at-play/clapback-meaning-origin">clapback</a> from the <a href="https://www.youtube.com/watch?v=YNTARSM-Fjc&amp;list=PL10CF667591857A2D">Yacht Rock</a> era.
					</p>
			
					<p>
					Reading further, I was surprised by how much terminology made its way into SCI: selectors, method dictionaries, temporary variables, receivers — they&#39;re all in those pages. Even SCI&#39;s ubiquitous <i>doit</i> method is a Smalltalk convention. The influence is clear.
					</p>
			
					<p>
					Jeff also mentioned Objective C, and I&#39;m sure that contributed too, but I refused to research it. Sorry, it&#39;s a personal prejudice. That language is just so damned ugly that, like a <a href="https://www.adn.com/alaska-news/wildlife/2023/04/14/an-opossums-arrival-in-homer-spurs-capture-efforts-memes-and-a-campaign-to-freegrubby/">filthy</a> <a href="https://www.adn.com/alaska-news/wildlife/2023/05/25/opossum-that-ran-loose-in-homer-for-weeks-finds-a-home-at-the-alaska-zoo/">freakin&#39;</a> <a href="https://www.adn.com/alaska-news/wildlife/2023/06/02/wildlife-officials-seek-help-as-additional-invasive-opossums-are-discovered-in-homer/">opossum</a>, it triggers my fight-or-flight. And I&#39;m done breaking laptops! So we&#39;re sticking with the Smalltalk narrative. And breaking meta-rules instead.
					</p>
			
					<p>
					My one exposure to Smalltalk was in school. The assignment was to implement the <a href="https://en.wikipedia.org/wiki/Enigma_machine">Enigma cipher</a> in a language you didn&#39;t know. For extra credit, you could write a program to <a href="https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma">crack</a> it. Excuse me? Breaking Nazi encryption is <i>optional??</i> Not in my family! We <b>really</b> need <a href="https://www.amazon.com/Anchors-Aweigh-Lynden-Benshoof-ebook/dp/B00AT35E40">Grandpa Benshoof</a> to survive D-Day! Smalltalk did the trick and I remember it fondly. My fascist decoder worked, but as the messages got longer it got slower. Really slow. Even on the expensive machines. Oh well, I wasn&#39;t getting graded on speed. Later, the department chair left a handwritten note about my impressive use of CPU cycles. The polite implication was that I would have lost us the war for want of a hash table.
					</p>
			
					<p>
					Speaking of impressions! I&#39;m impressed with the shelf life on that Smalltalk issue. SCI was developed in 1988 and yet these technical articles from 1981 were still relevant. In a way, they&#39;re timeless. Just not timely.
					</p>
			
					<blockquote>
						<p>
						<b>When Can I Buy It?</b>
						</p>
			
						<p>
						There are currently no personal computer implementations for the Smalltalk-80
						language. Because of this, I&#39;m sure we&#39;ll be criticized by some for introducing
						the language too early and frustrating our readers. Nevertheless, I feel that
						the time to begin exposing people to object-oriented language is <i>now</i>. Only by challenging and enticing the personal computer community can we stimulate the industry to create the machines we all dream of.
						</p>
			
						
					</blockquote>
			
					<p>
					Smalltalk fans had the programming language, but not the software. SCI fans had the opposite problem. They had years of games, and years to reverse engineer them, but the source language was a secret. How do you decompile that? What syntax do you use? If SCI Script was internal to Sierra, and the games only contain bytecode, then how do we know what the language looks like at all?
					</p>
			
					<p>
					<b><i>We didn&#39;t!</i></b> Not exactly. And not for a long time. But all that&#39;s over. Now we know everything.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/brief.png" alt="SCI Programming Language document by Jeff Stephenson, 1988"/>
					</p>
			
					<p>
					To see how far we&#39;ve come, take a look at this snapshot of Lance Ewing&#39;s <a href="https://web.archive.org/web/20110729181959/http://www.scriptinterpreter.com/syntax">SCI Syntax page</a> from 2011. Lance thoroughly documented the publicly available clues to establish what was known and could be inferred about the language. Here In The Future, we have things a bit easier. Here&#39;s the original <a href="https://www.benshoof.org/blog/files/sci-programming.language.txt">language spec</a> by Jeff Stephenson himself. This document is a monument to getting things right the first time. Throughout SCI&#39;s successful nine year run, the language never changed. The details that drifted are unspeakably dull. The games from 1988 are radically different than 1996, but underneath it&#39;s all the same bytecode from the same language. This was a design goal from the start.
					</p>
			
					<blockquote>
						<p>
						The whole goal was flexibility in programming, and trying to push as much of the programming capabilities up to the game developer level rather than having them have to go into the engine as we could, and decoupling graphics and so forth to the point where you could keep extending the graphical capabilities. Because at that point it was pretty clear we&#39;re going to be getting more and more changes in hardware and everything.
						</p>
			
						
					</blockquote>
			
					<p>
					To a reverse engineer, this sounds like great news. It sounds like if you want to work with SCI scripts, you can do so universally. And that&#39;s true! Kinda? But also not really, because even though the bytecode is consistent, everything else is all over the map.
					</p>
			
					<p>
					When I joined the ScummVM team, Martin Kiewitz told me that the hardest part of SCI was all the versions. Now that ScummVM runs even more of them, I joke that the entire codebase is version checks. The SciVersion <a href="https://github.com/scummvm/scummvm/blob/master/engines/sci/detection.h">code</a> is a window into the madness:
					</p>
			
<pre>

<span>enum</span> <span>SciVersion</span> {
	<span>SCI_VERSION_NONE</span>,
	<span>SCI_VERSION_0_EARLY</span>, 
	<span>SCI_VERSION_0_LATE</span>, 
	<span>SCI_VERSION_01</span>, 
	<span>SCI_VERSION_1_EGA_ONLY</span>, 
	<span>SCI_VERSION_1_EARLY</span>, 
	<span>SCI_VERSION_1_MIDDLE</span>, 
	<span>SCI_VERSION_1_LATE</span>, 
	<span>SCI_VERSION_1_1</span>, 
	<span>SCI_VERSION_2</span>, 
	<span>SCI_VERSION_2_1_EARLY</span>, 
	<span>SCI_VERSION_2_1_MIDDLE</span>, 
	<span>SCI_VERSION_2_1_LATE</span>, 
	<span>SCI_VERSION_3</span> 
};
</pre>
			
					<p>
					Depending on your perspective, thirteen versions could be a little, could be a lot. But these aren&#39;t <i>real</i> versions; they&#39;re high level buckets invented by reverse engineers. Games don&#39;t cleanly fall into them. Sierra typically had three or four games in various stages of development. Meanwhile, the interpreter evolved at its own pace. Think of each release as a fork with who knows what fixes and features backported in or taken out or tweaked. Resource formats, container formats, and compression formats each change over time. So apply those fuzzy versions to every layer. And then multiply the combinations across all the patches and ports.
					</p>
			
					<p>
					If you want to write SCI software that works with more than a handful of games then these are your problems to deal with.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/kq4-disks.jpg" alt="King&#39;s Quest 4 floppy disks"/>
					</p>
			
					<p>
					God help you if you turn to SCI&#39;s version numbers. Assuming Sierra didn&#39;t typo the floppy labels, or leave the placeholder x.yy.zzz, or release a non-release version, or get the odometer stuck on 2.100.002, then they&#39;re best treated as based on a true story. Versions that start with &#34;L.rry&#34; aren&#39;t Leisure Suit Larry games; they&#39;re whatever Larry Scott compiled that day. Consider that ScummVM is the most comprehensive SCI software and it doesn&#39;t even attempt to look at these version numbers.
					</p>
			
					<p>
					Instead, each piece is felt out at runtime with careful heuristics, deductive inference, and deep vats of hard-coded exceptions. And then someone finds a German Amiga version full of anachronisms and blows it all up.
					</p>
			
					<p>
					Believe it or not, <i>I&#39;m not complaining!</i> If these things were easy then there wouldn&#39;t be any left for me.
					</p>
			
					<p>
					But I do want to convince you that <b>Universal SCI is hard</b> and the versions are a heavy tax. We&#39;re going to talk about the reverse engineers who took on the scripts, and I want you to know what they were getting into, and appreciate how far they got.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/scistudio.png" alt="SCI Studio screenshot"/>
					</p>
			
					<p>
					Brian Provinciano is an SCI pioneer. In 1999 he wrote SCI Graphics Studio and set a dangerous precedent with a resource editor for Windows. This grew into SCI Studio, the first program that allowed fans to create their own EGA games. By 2002 it was out of beta and included a script editor, script compiler, and a full template game. SCI Studio was a legitimate Integrated Development Environment — the era of fan games had begun.
					</p>
			
					<p>
					What an exciting time that must have been. And so much work! Sierra&#39;s Script was still a secret, so to write a compiler you first had to <i>reinvent the language</i>. At least there were clues to what it should look like. And the bytecode wasn&#39;t a total mystery; the names of opcodes and kernel functions were included with games for debugging. Still — <i>sounds hard!</i> Brian took all this and developed his own script syntax with the necessary features that captured the spirit of the original, and then wrote a compiler for it. Sierra&#39;s 1980s executables happily ran the results. Nowadays we call this SCI Studio Syntax, but at the time it was the only game in town.
					</p>
			
					<p>
					Okay so you have the world&#39;s first third party SCI compiler. Now what? Well, Sierra&#39;s game programmers didn&#39;t start from scratch, they had all those system scripts we discussed earlier. So I guess you need those scripts! But if all you have is bytecode...
					</p>
			
					<blockquote>
						<p>
						I am now working on decompiling Leisure Suit Larry 2 to create the template game. It is TONS of work because my program can only disassemble, not decompile. I am having to do it all by hand. In order to write a decompiler, I would basically have to mimic the interpreter. It would be a lot of work, more work than it&#39;s worth.
						</p>
			
						
					</blockquote>
			
					<p>
					Brian later said that he spent weeks on this &#34;long and grueling task&#34; and manually decompiled 50-60 scripts and over 130 classes from several games. If you&#39;ve never decompiled assembly code by hand then it&#39;s hard to explain this sacrifice. And I won&#39;t try, because you shouldn&#39;t be punished for good life choices. But I will say that once it&#39;s done it&#39;s done, and <i>is</i> less work than writing a decompiler.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/techtv.jpg" alt="TechTV" title="allegedly"/>
					</p>
			
					<p>
					March 2003 was a big month. Brian released SCI Studio 3 and flew from Canada to San Francisco to appear on the TechTV show <i>Call For Help</i> to present it with Sierra fan Aaron Wester. Afterwards, he... sorry can we back up for a sec?
					</p>
			
					<p>
					Let me get this straight... you&#39;re saying that in <i>2003</i>... a <i>real</i> television studio recorded a <i>real</i> show about <b><i>SCI fan software?</i></b> And this was broadcast across real satellites to real hotel rooms all over the world? And you want <i>me</i> to believe that <i>U.S. Customs</i> believed all this?? No. Absolutely not! As an SCI nerd in 2023, I can&#39;t accept any of this. Nope nope nope. The Wayback Machine must have <a href="https://web.archive.org/web/20030608080619/http://www.bripro.com/news.php">crawled</a> an alternate timeline<a href="https://www.benshoof.org/blog/alternate-timeline">*</a>.
					</p>
			
					<p>
					That same month, Brian announced he was working on supporting VGA games, and had even begun writing a <i>script decompiler</i>. Over the next two years he posted status updates. He even posted entire scripts he&#39;d decompiled from a variety of games.
					</p>
			
					<p>
					And then a hellbeast ate him.
					</p>
			
					<p>
					In 2006 Brian <a href="https://web.archive.org/web/20060418054504/http://www.bripro.com/scistudio/index.php">retired</a> from SCI and posted his remaining code, but without mentioning the decompiler. He worked on SCI Studio for many years, some while in school, and set the bar for all future tools. His goal was for people to make games and <a href="https://sciprogramming.com/fangames.php">they did</a> and they were <a href="https://sciprogramming.com/fangames.php?action=review&amp;id=32">weird</a> and that is good. ScummVM happily supports fan games so you can still run them today, and probably forever.
					</p>
			
					<p>
					As you can imagine, this left some people disappointed. Not me though. <b><i>I just found out!</i></b> Oh man... so here I am, thinking I&#39;m ushering in the second decompiling, finish the dang thing, do the research for the announcement, and only <i>then</i> find out I&#39;ve been bumped down to third.
					</p>
			
					<p>
					I&#39;m thrilled that the SCI decompiler story is a trilogy with a lost first volume. Brian&#39;s samples and posts are now highly relevant to my interests, so I read them all. Here&#39;s the executive summary:
					</p>
			
					<p>
					Brian&#39;s decompiler was a standalone program that targeted the full range of SCI versions. The hardest part of decompiling is analyzing control flow, and when the decompiler couldn&#39;t figure that out, it generated code with goto statements. That&#39;s also what professional programs like IDA Pro and Ghidra do. Goto code isn&#39;t very readable, but the alternative is all or nothing. An impressive amount of the samples he posted were right. At one point he said that he was 90% done, but I said the same thing — right before the other 90%. Brian&#39;s decompiler was the real deal and on track to do everything.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/scicompanion.jpg" alt="SCI Companion"/>
					</p>
			
					<p>
					Phil Fortier is our SCI savior. In 2007 he released SCI Companion 2 to replace SCI Studio. Phil is an independent <a href="http://www.icefallgames.com/">game developer</a> and one of his motivations was to make his own game. SCI Companion supported Brian&#39;s script syntax and the existing fan games. Like SCI Studio, it was limited to EGA games. After a few updates, things quieted down, and then got real quiet.
					</p>
			
					<p>
					<i>Eight years later</i> Phil returned with SCI Companion 3. And it had <a href="https://sciprogramming.com/community/index.php?topic=1420.0">everything</a>! There was support for VGA games, a sound editor, and... AND... an end to the twelve year thirst: the world finally had a script decompiler.
					</p>
			
					<p>
					When I describe SCI reverse engineering, I stress that not only have we been graced with a latter day decompiler — against all odds — but an excellent one. It works so well that there&#39;s little to talk about except its limitations.
					</p>
			
					<blockquote>
						<p>
						The decompiler isn&#39;t perfect, but typically it can decompile about 95 to 99 percent of a game into source code. Success is typically on a function-by-function basis. Luckily, if an error or unexpected condition occurs anywhere during the decompilation of a function, we can have the entire function fallback to assembly. This at least retains the ability to recompile code correctly, and also retains some symbol information.
						</p>
			
						
					</blockquote>
			
					<p>
					Compare this approach to Brian&#39;s goto statements. If just one thing goes wrong then SCI Companion fails a function and produces no code. The larger the function, the more likely it fails. But gotos aren&#39;t an option anymore, and for a good reason.
					</p>
			
					<p>
					Phil created a new script syntax based on the original and named it Sierra Script. It&#39;s so close to Sierra&#39;s that I can&#39;t remember the differences. I think Phil&#39;s is stricter but my parsers can&#39;t tell the difference so neither can I. Decompiled scripts look like the real thing, and that&#39;s great, and that means no gotos — also great.
					</p>
			
					<p>
					That leaves the bugs where the decompiler silently produces incorrect code. I&#39;m familiar with these because my decompiler stumbled on the same scripts, just louder. Causes include: unexpected optimizations, nonsensical source scripts, and impossible instructions due to compiler bugs. But these instances are so rare that you can pretend they don&#39;t exist. So sure, trust but verify, but in practice don&#39;t worry about it.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/scicompanion-version.png" alt="SCI Companion version dialog"/>
					</p>
			
					<p>
					The decompiler&#39;s biggest limitations aren&#39;t in its algorithms, but its ergonomics. It&#39;s a complex component in a huge Windows GUI whose primary purpose is to let fans make games. In order to even find the bytecode it has to survive the SCI version nightmare. Phil borrowed the version logic from ScummVM, so it supports most, but he understandably skipped some of the more annoying bits. Some versions fall between these cracks. And the SCI3 script format from the last four games is unsupported. And there&#39;s no concept of multiple CDs or Macintosh. If it&#39;s outside the mainstream then it&#39;s unavailable to the decompiler.
					</p>
			
					<p>
					These are all reasonable priorities for a program that makes fan games. No fan was going to make a seven disc Fantasmagoria. If you want to add support for these extras, you&#39;ll have to touch a lot of unfun C++ before you even get to the decompiler. It&#39;s been <a href="https://github.com/icefallgames/SCICompanion/">open source</a> for many years so nothing has stopped you, but that brings us to the real limitation...
					</p>
			
					<p>
					SCI Companion is a Microsoft Foundation Classes Win32 C++ codebase that no one wants to work on<a href="https://www.benshoof.org/blog/prove-me-wrong">*</a>. <i>Oh, I get it!</i> Long ago I wrote some of my favorite programs in that stuff, and I still love running them today, but I can&#39;t bring myself to look at the code again.
					</p>
			
					<p>
					There are signs of life. The Cat has a <a href="https://github.com/Kawa-oneechan/SCICompanion">fork</a> with some fixes, and Laurence Myers recently added <a href="https://github.com/Kawa-oneechan/SCICompanion/pull/15">automatic builds</a>. That&#39;s exciting, but let&#39;s not quibble over commits: Phil finished a long time ago and no one else has touched the decompiler. <i>Including me!</i> As you&#39;ll see, I don&#39;t even know how it works. Maybe today&#39;s release will spark some interest. For now, the decompiler is done, and that&#39;s okay.
					</p>
			
					<blockquote>
						<p>
						With a bunch more work, it should be possible to have the decompiler 100% effective (except for corrupted scripts, of course) — but I decided that the effort vs reward wasn&#39;t worth it beyond this point, especially given the fallback to assembly.
						</p>
			
						
					</blockquote>
			
					<p>
					Phil split SCI reverse engineering into two eras: Before Companion and After Decompiler. Reverse engineering generates countless unknowns that are too impractical to investigate. There&#39;s a threshold there, and it&#39;s determined by the tools. SCI Companion&#39;s decompiler sent that threshold plummeting. I&#39;m hoping that today&#39;s release finishes the job.
					</p>
			
					<p>
					Think of all the SCI details that were too difficult to figure out before 2015. Turn all the bytecode into high quality text, and people like us can knock them out with one grep. It&#39;s fun! It has to be — <i>it&#39;s cheating!</i>
					</p>
			
					<p>
					But you can have too much fun, so you have to be careful. Or else you could end up with a hobby.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/sluicebox.png" alt="my avatar" title="my original sin: forgot to adjust the aspect ratio"/>
					</p>
			
					<p>
					Here&#39;s where I enter the story:
					</p>
			
					<blockquote>
						<p>
						It&#39;s important to have goals, or so I&#39;m told by several reputable hashtags. In the 90s mine were to solve The Colonel&#39;s Bequest, and more importantly, The Dagger of Amon Ra. It was clear that merely playing them wasn&#39;t going to cut it. As time passed I would occasionally check in on the Sierra scene and when SCI Viewer dropped so did my hopes.
						</p>
			
						<p>
						SCI Viewer revealed that there was indeed a lot more to these cases but that the answers were all in the scripts. At the time, this meant reams of intolerably low level disassembly text. This wouldn&#39;t do for the high level answers I sought. &#34;I&#39;ll come back later.&#34; In 2015 it was later, and lo, for Phil Fortier released from the heavens SCI Companion 3.0 with an honest to goodness script decompiler. It had been twenty years but not only could my investigation now proceed, it <i>had</i> to.
						</p>
			
						
					</blockquote>
			
					<p>
					I don&#39;t know exactly when I discovered SCI Companion 3, but I remember feeling lucky. It must have been pretty new, because it crashed so much that I couldn&#39;t use it. Before giving up, I tried compiling the latest code — the last refuge of a scoundrel. It wouldn&#39;t build, some MFC or SDK thing, the usual strife. <i>&#34;Just when I think I&#39;m out.&#34;</i> After some begrudging hacks, it built. SCI Companion was stable as a table and I&#39;ve built from source ever since. More luck! The miracle I&#39;d been waiting for hinged on latent knowledge of the Windows API. I bore witness and became a decompiler disciple.
					</p>
			
					<p>
					I quickly hit my limits with the scripts. Remember that first example? It&#39;s great by decompiler standards, but it&#39;s still not good enough for solving complex things like a <a href="https://www.benshoof.org/blog/super-sleuth">Sleuth-O-Meter</a>. It was taking too long to get my bearings in the game code and I didn&#39;t even know the language. <i>I didn&#39;t know anything!</i> But I did know the messages that appear in the games.
					</p>
			
					<p>
					<a href="https://web.archive.org/web/20080413035345/http://www.geocities.com/sciviewer/">SCI Viewer</a> had command line tools that could dump resources and export game messages as XML. Script those up, write some regular expressions to parse out message tuples, and baby you got a stew going: one ham-fisted message annotator. No knowledge of SCI internals required. I had my foothold! Now I could get around in these message-heavy games and build from there.
					</p>
			
					<p>
					As my tools grew they set off a cycle. A typical pattern: first my parser trips on something, then I investigate and crash ScummVM, then I investigate with ScummVM&#39;s debugger and crash that, and finally it turns out that none of this ever worked and the game has been crashing since 1990. By the time it was over I&#39;d have fixed my bug, the ScummVM bug, the debugger, and written a script patch in bytecode to fix the game. Bonus points if there was a ten year old ticket in the bug tracker. Then my parsers would scan for similar anomalies across other games and it would start all over.
					</p>
			
					<p>
					I didn&#39;t mean to build a bug hunting machine, I just wrote some parsers that weren&#39;t very bright, and things got out of hand.
					</p>
			
					<p>
					<a href="https://github.com/scummvm/scummvm/graphs/contributors">
					<img src="https://www.benshoof.org/blog/images/scummvm-stats.png" alt="ScummVM contributor statistics"/>
					</a>
					</p>
			
					<p>
					As I learned more, I wrote proper parsers, and the annotators flourished. I was closing a lot of ScummVM tickets thanks to my decompiled scripts. But as you&#39;ll recall, SCI Companion doesn&#39;t support everything. If I couldn&#39;t decompile, then I couldn&#39;t do much. The open tickets were starting to hint at which games and versions were outside of SCI Companion&#39;s purview. So I wrote some programs to bring them into the fold. The first one converted <a href="https://www.benshoof.org/blog/quest-for-glory-i-macintosh-easter-egg">Macintosh scripts</a> to DOS with a bunch of byte-swapping. The second program downgraded SCI3 scripts to SCI2, which is so insane that I named it Conversion Therapy. Now I could decompile and annotate everything, and without touching SCI Companion&#39;s code. The tickets continued to close and the writing queue <a href="https://www.benshoof.org/blog/archive">grew</a>.
					</p>
			
					<p>
					Eventually I had a big problem: the annotated scripts had gotten too good to keep to myself. But they weren&#39;t good enough to release. Even if they were, they weren&#39;t the products of a program, but a process. Then I realized just how many imperfections I was working around, reverting, or tolerating. <i>Hell&#39;s horses!</i> I&#39;d outgrown the SCI Companion decompiler.
					</p>
			
					<p>
					Obviously the problem with this pipeline is that it runs through an unmaintained Windows GUI. Obviously the solution is to replace it. Obviously there are problems with that solution:
					</p>
			
					<ol>
					<li>
					It rather involves writing a decompiler
					</li>
					<li>
					Phil&#39;s is a tough act to follow!
					</li>
					</ol>
			
					<p>
					There was hope. Phil left a map: a <a href="https://mtnphil.wordpress.com/2016/04/09/decompiling-sci-byte-code-part-1/">four</a> <a href="https://mtnphil.wordpress.com/2016/04/09/decompiling-sci-part-2-control-flow/">part</a> <a href="https://mtnphil.wordpress.com/2016/04/09/decompiling-sci-part-3-instruction-consumption/">blog</a> <a href="https://mtnphil.wordpress.com/2016/04/09/decompiling-sci-part-4-final-steps/">series</a> on decompiling SCI — a masterclass in accessible technical writing. By now I&#39;ve read a lot of decompiler literature and Phil&#39;s articles are still the best. If you want to decompile any kind of bytecode, start there.
					</p>
			
					<p>
					And so last year I used Phil&#39;s guide and started writing a decompiler, failed, tried again this year, and succeeded. I later learned that Phil also shelved his first attempt. I&#39;d love to talk about how mine works, but we&#39;ll save that for another day. I owe us a full write-up about what it takes to get to one hundred percent.
					</p>
			
					<p>
					Yes, that&#39;s right: <b>One Hundred Percent</b>. Brian&#39;s decompiler produced goto statements. Phil&#39;s fell back to assembly. I didn&#39;t want to do either, so mine fully decompiles every function in every Sierra script. No need to write fallback code if you never fail!
					</p>
			
					<table>
						<tbody><tr>
							<th></th>
							<th>Total</th>
							<th>Solved</th>
							<th></th>
						</tr>
						<tr>
							<td>Games</td>
							<td>319</td>
							<td>319</td>
							<td>100%</td>
						</tr>
						<tr>
							<td>Scripts</td>
							<td>65,567</td>
							<td>65,567</td>
							<td>100%</td>
						</tr>
						<tr>
							<td>Functions</td>
							<td>818,796</td>
							<td>818,796</td>
							<td>100%</td>
						</tr>
						<tr>
							<td>Loop Functions</td>
							<td>46,666</td>
							<td>46,666</td>
							<td>100%</td>
						</tr>
						<tr>
							<td>Loops</td>
							<td>66,761</td>
							<td>66,761</td>
							<td>100%</td>
						</tr>
					</tbody></table>
			
					<p>
					You crave caveats. Well, there could be silent failures I don&#39;t know about. It seems like there must be some in all that text. Find &#39;em and I&#39;ll fix &#39;em. But the last bug affected only <i>one</i> function, and it was from a bug in Sierra&#39;s compiler, and that was a while ago. So I don&#39;t know what to think. As I mentioned, there are also a few versions I don&#39;t have. Maybe you do? It&#39;s mostly a handful of localized games. I don&#39;t expect any exciting scripts, but who knows? Help me find out!
					</p>
			
					<p>
					SCI Companion will always be the best way to view scripts, so I&#39;ve packaged mine to be compatible; you just need the game. You can try compiling the scripts, but you&#39;re on your own there. It might work! Just remember that the version detection in SCI Companion is incomplete, so it can misinterpret accurate symbols like kernel functions. Maybe you&#39;ll fix it?
					</p>
			
					<p>
					I wish my work produced fixes for SCI Companion, but the projects didn&#39;t overlap. For one thing, I didn&#39;t use C++, because #selfcare. Bigger obstacle: I don&#39;t really know how the other decompiler works. Phil&#39;s articles are <i>so good</i> that I didn&#39;t need the code to design my own. The two decompilers must be pretty different though, because I came up with my algorithms by staring at a mess of graphs until blacking out. <i>(Dramatization! ...I Think!)</i>
					</p>
			
					<p>
					Speaking of drama! ...There&#39;s one more thing.
					</p>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/codepink.jpg" alt="sierra disk in a pink drive"/>
					</p>
			
					<p>
					<i>Original Sierra source code.</i> That subject has been off limits, but thanks to recent events I can relax that rule. If there&#39;s anything good about performance art, it&#39;s the unexpected. I consider this performance art, and I didn&#39;t expect to be presented with a Sierra cache on deep background. There&#39;s a good story there, but it&#39;s not mine to tell. The important thing, I told myself, is that it&#39;s found its way into enough hands that it won&#39;t get lost — and won&#39;t stay underground forever.
					</p>
			
					<p>
					On Christmas Day, Jason Scott discreetly posted the original scripts for nine Sierra games to the <a href="https://archive.org/details/sierrasourcecode">Internet Archive</a>. They&#39;re also on <a href="https://github.com/historicalsource/">github</a>. I&#39;m happy (and relieved) that we can discuss these publicly, but I have to tell you... as exciting as real source code is, annotated decompiled scripts are <i>so much more useful</i>. But you&#39;re hard to convince. So I wrote one more annotator...
					</p>
			
					<p>
					<b>My decompiled scripts include Sierra&#39;s symbols — <i>even ones not publicly available!</i></b> The annotator extracts the names of functions and variables from my cache of original scripts and matches them to decompiled scripts. Every game benefits because I also have original system scripts. Of course, if one or two games whose scripts <i>haven&#39;t</i> been posted were to have <b><i>all</i></b> of their symbols, that could raise some questions. <i>Not to worry!</i> This blog doesn&#39;t have comments.
					</p>
			
					<p>
					Speaking of comments! Let&#39;s end with one of Jeff&#39;s, the gentleman who got us into this mess. I think it will resonate with every ScummVM developer, and anyone else who plays computer games as an adult by making graphs full of assembly.
					</p>
			
					<blockquote>
						<p>
						While I did play some of the games just to see how they worked, and actually I probably played Space Quest more just because it was such a gas, but I was pretty unaware of the actual game involved. So my involvement was really at doing the tools that allowed the games to be built, and I encountered the games sort of off and on, but eh they&#39;re all just the animated things that are stories, they&#39;re not the fun part.
						</p>
					</blockquote>
			
					<p>
					<img src="https://www.benshoof.org/blog/images/decompiler-graph.png" alt="decompiler graph" title="the fun part!"/>
					</p>
			
					
			
					<p>
					<b><i>And I gave away the farm!</i></b>
					</p>
			
					<p>
					See, I&#39;ve still got this writing queue of Sierra discoveries here, and while nothing has ever stopped <i>you</i> from finding them yourself... <i>it just got a heck of a lot easier!</i> So go ahead and scoop me. You can even do your own write-ups! In fact, I&#39;d love to read them. All I ask is that you do a good job and don&#39;t skimp on the NewsRadio references. We&#39;ll call it outsourcing and they&#39;ll call me <a href="https://www.benshoof.org/blog/macho-business-donkey-wrestler">genius</a>.
					</p>
			
					<p>
					Otherwise I&#39;ll keep getting to them in my own sweet time. <i>Or faster!</i> — if you can just get me back on the <a href="https://en.wikipedia.org/wiki/Paycheck_Protection_Program">dole</a>...
					</p>
				</div>
			</div></div>
  </body>
</html>
