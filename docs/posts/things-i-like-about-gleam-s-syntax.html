<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/gleam-syntax">Original</a>
    <h1>Things I like about Gleam&#39;s Syntax</h1>
    
    <div id="readability-page-1" class="page"><section id="Things-I-like-about-Gleams-Syntax">

<p>Gleam is a Type-Safe programming language that transpiles to Erlang<label for="fn1"></label><span><span>And <a href="https://gleam.run/news/v0.16-gleam-compiles-to-javascript/">javascript</a>.</span></span>, so you can run its code on the BEAM. I’ve slept on Gleam for a while because its syntax. It was too much Rust and not enough Elixir for me.</p>
<p>Recently, I was reminded of Gleam when someone mentioned that Gleam doesn’t have an if statement, but instead uses <code>case</code> for everything. As a consequence, I ended up re-reading the <a href="https://gleam.run/book/tour/index.html">Gleam language tour</a>.</p>
<p>As another reminder to check my assumptions from time to time,
Gleam’s syntax has some goodies that I hadn’t noticed before,
It’s definitely grown on me now that I’ve used Rust for a while.<label for="fn2"></label><span><span>Gleam’s syntax draws a lot from Rust’s syntax. Gleam’s transpiler is <a href="https://github.com/gleam-lang/gleam">written in Rust</a>.</span></span></p>
<p>Some examples:</p>
<section id="Handy-pipe-operator">
<h2>Handy pipe operator</h2>
<p>Gleam adopts a <a href="https://gleam.run/book/tour/functions.html#pipe-operator">pipe operator</a> similar to Elixir<label for="fn3"></label><span><span>Gleam’s <code>list.at</code> function returns a <code>Result</code> type, which allows me to know whether I’ve received a value from the list or used an index outside the bounds of the list. The former will be <code>Ok(value)</code> and the latter will return <code>Err(Nil)</code> per the type signature of <code>list.at</code>.</span><span>This is in contrast to Elixir’s <code>Enum.at/2</code> function, which returns <code>value</code> or <code>nil</code> with no indication of whether that <code>nil</code> came from the list or from an out-of-bounds index.</span></span>:</p>
<pre><code>import gleam/io
import gleam/list

pub fn main() {
  [1, 2, 3]
  |&gt; list.append([4,5,6])
  |&gt; list.reverse
  |&gt; list.at(2) 
  |&gt; io.debug() // prints Ok(4)
}
</code></pre>
</section>
<section id="Labeled-arguments">
<h2>Labeled arguments</h2>
<p><a href="https://stackoverflow.com/questions/10091185/piping-composition-and-currying">Labeled arguments</a> is how Gleam does keyword arguments which are notably missing from both Elixir and Rust. So this is a great addition. The main benefit of labeled arguments is that you can pass them into the function in any order, since they’re identified by name.<label for="fn4"></label><span><span>Note that I had to use <code>name</code> twice in <code>greet</code>. The first time is the label, the second time is the variable I use in the body of the function. Using one <code>name</code> by itself raises a compiler error.</span></span><label for="fn5"></label><span><span>Elixir can simulate keyword arguments with keyword lists, but those require a <code>Keyword.get</code> call to retrieve keys inside the function body, and can’t be passed in positionally.</span></span></p>
<pre><code>import gleam/io

fn greet(name name: String, in place: String) {
  &#34;Hello &#34; &lt;&gt; name &lt;&gt; &#34; from &#34; &lt;&gt; place
}

pub fn main() {
  greet(name: &#34;Christine&#34;, in: &#34;NASA&#34;)
  |&gt; io.debug() // &#34;Hello Christine from NASA&#34;
}
</code></pre>
</section>
<section id="Elegant-function-capturing">
<h2>Elegant function capturing</h2>
<p><a href="https://gleam.run/book/tour/functions.html#function-capturing">Function capturing</a> allows me to quickly create a one-argument anonymous function from a named function. The one argument will go wherever I place the <code>_</code> in the function capture. It only seems to work for creating one-argument anonymous functions,
putting multiple <code>_</code> in a capture will compile error<label for="fn6"></label><span><span>By contrast, in Elixir you can have arbitrarily many arguments in a captured function with the numbered <code>&amp;</code> syntax: <code>&amp;Enum.reduce([1, 2, 3], &amp;1, &amp;2)</code></span><span>(At least, I think it’s arbitrarily many, I stopped checking after <code>&amp;11</code> worked)</span></span>.</p>
<pre><code>import gleam/io
import gleam/list
import gleam/string

pub fn main() {
  let prepend = string.append(&#34;other &#34;, _)

  list.map([&#34;hello&#34;, &#34;world&#34;], prepend) 
  |&gt; io.debug() // [&#34;other hello&#34;, &#34;other world&#34;]
}
</code></pre>
<p>Function capturing is also nice for arranging functions for the pipe operator, since Gleam lets me pipe directly into an anonymous function<label for="fn7"></label><span><span>Elixir does not let you pipe directly into an anonymous function. In Elixir 1.12.0, <a href="https://hexdocs.pm/elixir/1.12/Kernel.html#then/2"><code>then/2</code></a> was added to remedy this problem.</span></span>:</p>
<pre><code>import gleam/io
import gleam/string

pub fn main() {
  &#34;hello&#34;
  |&gt; string.append(&#34;some text &#34;, _)
  |&gt; io.debug()
}
</code></pre>
</section>
<section id="Only-case-statement-no-if">
<h2>Only case statement, no if</h2>
<p>Gleam <a href="https://gleam.run/book/tour/case-expressions.html#checking-equality-and-ordering-in-patterns">doesn’t have an if statement</a>, it uses case for that instead<label for="fn8"></label><span><span>Gleam does use <code>if</code> as a keyword, but only in <a href="https://gleam.run/book/tour/case-expressions.html#checking-equality-and-ordering-in-patterns">guard expressions</a>.</span></span>:</p>
<pre><code>case if_boolean {
  True -&gt; &#34;case statements only&#34;
  False -&gt; &#34;you didn&#39;t get a choice&#34;
}
</code></pre>
<p>I like this syntax better than an if statement. It shines a spotlight on the branch, makes it clear which path belongs to which condition, and Gleam will do exhaustiveness checking to force me to handle both cases.</p>
<p>It also makes it easier to refactor into a sum type:</p>
<pre><code>type CaseExample {
  CaseGood
  CaseAnyway
  ThirdOption
}

case case_example {
  CaseGood -&gt; &#34;case statements only&#34;
  CaseAnyway -&gt; &#34;you didn&#39;t get a choice&#34;
  ThirdOption -&gt; &#34;more choices!&#34;
}
</code></pre>
</section>
<section id="Sub-pattern-names-using-as">
<h2>Sub pattern names using <code>as</code></h2>
<p>Gleam lets me <a href="https://gleam.run/book/tour/case-expressions.html#assigning-names-to-sub-patterns">assign names to sub-patterns</a> using <code>as</code> in pattern matching expressions. Elixir solved this problem by making <code>=</code> expressions return their value, so you could use them in pattern matching, but I always found that somewhat awkward. <code>as</code> makes it clear that I’m naming a sub-pattern for reuse.</p>
<pre><code>case list {
  [[_, ..] as inner_list] -&gt; inner_list
  other -&gt; []  
}
</code></pre>
<p>Note that Gleam makes it easy to destructure types with custom variables, avoiding the need for <code>as</code>:</p>
<pre><code>// example, use gleam/option.Option instead
type OptionalString {
  Some(string: String)
  None
} 

fn unpack_string(optional_string) {
  case optional_string {
    Some(chosen_variable) -&gt; chosen_variable
    None -&gt; &#34;&#34;
  }
}
</code></pre>
</section>
<section id="Succinct-alternative-clause-patterns-using">
<h2>Succinct alternative clause patterns using <code>|</code></h2>
<p>Gleam lets you succinctly specify <a href="https://gleam.run/book/tour/case-expressions.html#alternative-clause-patterns">alternate patterns</a> in a case statement using <code>|</code>:</p>
<pre><code>type NumberKind {
  Prime
  Composite
}

case number {
  2 | 3 | 5 | 7 -&gt; Prime
  _ -&gt; Composite
}
</code></pre>
</section>
<section id="Support-for-todo-to-mark-uncompleted-work">
<h2>Support for <code>todo</code> to mark uncompleted work</h2>
<p>Gleam includes a <a href="https://gleam.run/book/tour/todo-and-panic.html#todo--panic">todo</a> keyword to indicate that some code isn’t finished. That code will type check, but will raise a warning on compilation:</p>
<pre><code>fn fancy(something: SomeComplexType) {
  todo
}
</code></pre>
<p>The warning:</p>
<blockquote>
<p>This code will crash if it is run. Be sure to finish it before
running your program.</p>
</blockquote>
<p>Gleam lets me add a description to the <code>todo</code> using <code>as</code>:</p>
<pre><code>import gleam/io

pub fn main() {
  let incomplete = fn(x) {
    case x {
      2 | 3 | 5 | 7 -&gt; &#34;Prime&#34;
      _ -&gt; todo as &#34;Something about composite numbers&#34;
    }
  }
  incomplete(7)
  |&gt; io.debug()
}
</code></pre>
</section>
<section id="Takeaways">
<h2>Takeaways</h2>
<p>I really like what Gleam has done with its syntax. Despite my initial misgivings, I’m finding it hard not to play with Gleam as I write this article.</p>
<p>If Gleam’s syntax initially put you off, consider giving it another look. I know I like what I found.</p>
</section>
</section></div>
  </body>
</html>
