<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/20%29-Flood-Fill-%28Again%29">Original</a>
    <h1>20) Flood Fill (Again)</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>Tackled this again with Seamus! Communication can be difficult when referring to visually complicated graphs - I initially failed to grasp the nuance of how we needed to save the color of our initial tile, and couldn’t quite catch up quickly enough <em>until</em> Seamus and Paul walked me through line by line using an example, at which point it made sense that we needed to save this information so we could check each successive tile against it.</p>
<p><strong>Time to completion:</strong> 24 minutes</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// given row column color</span></span>
<span data-line=""><span>// </span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> floodFill</span><span>(</span><span>image</span><span>:</span><span> number</span><span>[][], </span><span>sr</span><span>:</span><span> number</span><span>, </span><span>sc</span><span>:</span><span> number</span><span>, </span><span>color</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[][] {</span></span>
<span data-line=""><span>    let</span><span> q </span><span>=</span><span> [] </span><span>// first in first out (stack is last out )</span></span>
<span data-line=""><span>    // shift and push (vs push and pop)</span></span>
<span data-line=""><span>    let</span><span> visited </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // first thing in queue?</span></span>
<span data-line=""><span>    q.</span><span>push</span><span>([sr, sc])</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> offsets</span><span> =</span><span> [[</span><span>-</span><span>1</span><span>, </span><span>0</span><span>], [</span><span>0</span><span>, </span><span>-</span><span>1</span><span>], [</span><span>1</span><span>, </span><span>0</span><span>], [</span><span>0</span><span>, </span><span>1</span><span>]];</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> target</span><span> =</span><span> image[sr][sc];</span></span>
<span data-line=""><span>    image[sr][sc] </span><span>=</span><span> color;</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (q.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        // do stuff!</span></span>
<span data-line=""><span>        const</span><span> current</span><span> =</span><span> q.</span><span>shift</span><span>()</span></span>
<span data-line=""><span>        if</span><span> (visited.</span><span>has</span><span>(current.</span><span>join</span><span>(</span><span>&#34;_&#34;</span><span>))) </span><span>continue</span></span>
<span data-line=""><span>        visited.</span><span>add</span><span>(current.</span><span>join</span><span>(</span><span>&#34;_&#34;</span><span>))</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        const</span><span> [</span><span>row</span><span>, </span><span>col</span><span>] </span><span>=</span><span> current</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        for</span><span> (</span><span>const</span><span> [</span><span>rO</span><span>, </span><span>cO</span><span>] </span><span>of</span><span> offsets){</span></span>
<span data-line=""><span>            const</span><span> nextR</span><span> =</span><span> row </span><span>+</span><span> rO;</span></span>
<span data-line=""><span>            const</span><span> nextC</span><span> =</span><span> col </span><span>+</span><span> cO;</span></span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (nextR </span><span>&lt;</span><span> 0</span><span> ||</span><span> nextR </span><span>&gt;=</span><span> image.</span><span>length</span><span>) {</span></span>
<span data-line=""><span>                continue</span><span>;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            if</span><span> (nextC </span><span>&lt;</span><span> 0</span><span> ||</span><span> nextC </span><span>&gt;=</span><span> image[</span><span>0</span><span>].</span><span>length</span><span>) {</span></span>
<span data-line=""><span>                continue</span><span>;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (image[nextR][nextC] </span><span>===</span><span> target){</span></span>
<span data-line=""><span>                // Actually change the color in place!</span></span>
<span data-line=""><span>                image[nextR][nextC] </span><span>=</span><span> color;</span></span>
<span data-line=""><span>                q.</span><span>push</span><span>([nextR, nextC]);</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> image;</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Okay I’m going to go through this with annotations:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""> </span>
<span data-line=""><span>function</span><span> floodFill</span><span>(</span><span>image</span><span>:</span><span> number</span><span>[][], </span><span>sr</span><span>:</span><span> number</span><span>, </span><span>sc</span><span>:</span><span> number</span><span>, </span><span>color</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span>[][] {</span></span>
<span data-line=""><span>    let</span><span> q </span><span>=</span><span> [] </span><span>// first in first out (stack is last out )</span></span>
<span data-line=""><span>    // shift and push (vs push and pop)</span></span>
<span data-line=""><span>    let</span><span> visited </span><span>=</span><span> new</span><span> Set</span><span>()</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // first thing in queue?</span></span>
<span data-line=""><span>    q.</span><span>push</span><span>([sr, sc])</span></span>
<span data-line=""><span> </span></span>
<span data-line=""><span>    const</span><span> offsets</span><span> =</span><span> [[</span><span>-</span><span>1</span><span>, </span><span>0</span><span>], [</span><span>0</span><span>, </span><span>-</span><span>1</span><span>], [</span><span>1</span><span>, </span><span>0</span><span>], [</span><span>0</span><span>, </span><span>1</span><span>]];</span></span>
<span data-line=""> </span>
<span data-line=""><span>    const</span><span> target</span><span> =</span><span> image[sr][sc];</span></span>
<span data-line=""><span>    image[sr][sc] </span><span>=</span><span> color;</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (q.</span><span>length</span><span>){</span></span>
<span data-line=""><span>        // do stuff!</span></span>
<span data-line=""><span>        const</span><span> current</span><span> =</span><span> q.</span><span>shift</span><span>()</span></span>
<span data-line=""><span>        if</span><span> (visited.</span><span>has</span><span>(current.</span><span>join</span><span>(</span><span>&#34;_&#34;</span><span>))) </span><span>continue</span></span>
<span data-line=""><span>        visited.</span><span>add</span><span>(current.</span><span>join</span><span>(</span><span>&#34;_&#34;</span><span>))</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        const</span><span> [</span><span>row</span><span>, </span><span>col</span><span>] </span><span>=</span><span> current</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        for</span><span> (</span><span>const</span><span> [</span><span>rO</span><span>, </span><span>cO</span><span>] </span><span>of</span><span> offsets){</span></span>
<span data-line=""><span>            const</span><span> nextR</span><span> =</span><span> row </span><span>+</span><span> rO;</span></span>
<span data-line=""><span>            const</span><span> nextC</span><span> =</span><span> col </span><span>+</span><span> cO;</span></span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (nextR </span><span>&lt;</span><span> 0</span><span> ||</span><span> nextR </span><span>&gt;=</span><span> image.</span><span>length</span><span>) {</span></span>
<span data-line=""><span>                continue</span><span>;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>            </span></span>
<span data-line=""><span>            if</span><span> (nextC </span><span>&lt;</span><span> 0</span><span> ||</span><span> nextC </span><span>&gt;=</span><span> image[</span><span>0</span><span>].</span><span>length</span><span>) {</span></span>
<span data-line=""><span>                continue</span><span>;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (image[nextR][nextC] </span><span>===</span><span> target){</span></span>
<span data-line=""><span>                // Actually change the color in place!</span></span>
<span data-line=""><span>                image[nextR][nextC] </span><span>=</span><span> color;</span></span>
<span data-line=""><span>                q.</span><span>push</span><span>([nextR, nextC]);</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> image;</span></span>
<span data-line=""> </span>
<span data-line=""><span>};</span></span></code></pre></figure>

<p>So we obviously started with a BFS approach</p>

<p>Recommends the graph traversal section of the Algorithm design manual BFS vs. DFS graph traversal. <a href="https://mimoza.marmara.edu.tr/~msakalli/cse706_12/SkienaTheAlgorithmDesignManual.pdf">Here’s a free PDF!<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> Sorry Steven Skiena - please buy this mans book.</p></article><hr/></div></div></div>
  </body>
</html>
