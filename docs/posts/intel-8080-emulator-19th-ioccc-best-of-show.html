<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nanochess.org/emulator.html">Original</a>
    <h1>Intel 8080 emulator. 19th IOCCC. Best of Show</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>
After winning the IOCCC for the <a href="https://nanochess.org/chess1.html">first time</a>, I had
the idea of writing an emulator of the 8080 processor in 2000 characters of C,
after patterning experimentally the more than 200 instructions and doing
measures of byte count, I realized that it was possible and I made it.
Then I added CP/M support as a extra feature. I was completely astonished when
I won Best of Show of 19th IOCCC :).
</p>
<div><p>
This program was one of three winning entries I sent for the 19th edition, the
other two were a <a href="https://nanochess.org/chess2.html">graphical chess program</a> and a
<a href="https://nanochess.org/knight.html">knight&#39;s tour solver</a>.
</p></div>
<h2>Source code</h2>
<p>This program emulates a complete IntelÂ® 8080
processor, along with a teletype and a disk
controller, just like at the start of the personal
computers revolution (circa 1975).</p>
<p>Here is the source code, written in C language:</p>
<pre><small>                               #include &lt;stdio.h&gt;
           #define n(o,p,e)=y=(z=a(e)%16 p x%16 p o,a(e)p x p o),h(
                                #define s 6[o]
             #define p z=l[d(9)]|l[d(9)+1]&lt;&lt;8,1&lt;(9[o]+=2)||++8[o]
                                #define Q a(7)
           #define w 254&gt;(9[o]-=2)||--8[o],l[d(9)]=z,l[1+d(9)]=z&gt;&gt;8
                               #define O )):((
                  #define b (y&amp;1?~s:s)&gt;&gt;&#34;\6\0\2\7&#34;[y/2]&amp;1?0:(
                               #define S )?(z-=
                    #define a(f)*((7&amp;f)-6?&amp;o[f&amp;7]:&amp;l[d(5)])
                               #define C S 5 S 3
                       #define D(E)x/8!=16+E&amp;198+E*8!=x?
                             #define B(C)fclose((C))
                       #define q (c+=2,0[c-2]|1[c-2]&lt;&lt;8)
                          #define m x=64&amp;x?*c++:a(x),
                         #define A(F)=fopen((F),&#34;rb+&#34;)
                    unsigned char o[10],l[78114],*c=l,*k=l
                          #define d(e)o[e]+256*o[e-1]
#define h(l)s=l&gt;&gt;8&amp;1|128&amp;y|!(y&amp;255)*64|16&amp;z|2,y^=y&gt;&gt;4,y^=y&lt;&lt;2,y^=~y&gt;&gt;1,s|=y&amp;4
+64506; FILE *u, *v, *e, *V; int x,y,z,Z; main(r,U)char**U;{

     { { { } } }       { { { } } }       { { { } } }       { { { } } }
    { { {   } } }     { { {   } } }     { { {   } } }     { { {   } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
    { { {   } } }    { { {     } } }    { { {   } } }    { { {     } } }
      { { ; } }      { { {     } } }      { { ; } }      { { {     } } }
    { { {   } } }    { { {     } } }    { { {   } } }    { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
   { { {     } } }   { { {     } } }   { { {     } } }   { { {     } } }
    { { {   } } }     { { {   } } }     { { {   } } }     { { {   } } }
     { { { } } }       { { { } } }       { { { } } }       { { { } } }

                                   for(v A((u A((e A((r-2?0:(V A(1[U])),&#34;C&#34;)
),system(&#34;stty raw -echo min 0&#34;),fread(l,78114,1,e),B(e),&#34;B&#34;)),&#34;A&#34;)); 118-(x
=*c++); (y=x/8%8,z=(x&amp;199)-4 S 1 S 1 S 186 S 2 S 2 S 3 S 0,r=(y&gt;5)*2+y,z=(x&amp;
207)-1 S 2 S 6 S 2 S 182 S 4)?D(0)D(1)D(2)D(3)D(4)D(5)D(6)D(7)(z=x-2 C C C C
C C C C+129 S 6 S 4 S 6 S 8 S 8 S 6 S 2 S 2 S 12)?x/64-1?((0 O a(y)=a(x) O 9
[o]=a(5),8[o]=a(4) O 237==*c++?((int (*)())(2-*c++?fwrite:fread))(l+*k+1[k]*
256,128,1,(fseek(e=5[k]-1?u:v,((3[k]|4[k]&lt;&lt;8)&lt;&lt;7|2[k])&lt;&lt;7,Q=0),e)):0 O y=a(5
),z=a(4),a(5)=a(3),a(4)=a(2),a(3)=y,a(2)=z O c=l+d(5) O y=l[x=d(9)],z=l[++x]
,x[l]=a(4),l[--x]=a(5),a(5)=y,a(4)=z O 2-*c?Z||read(0,&amp;Z,1),1&amp;*c++?Q=Z,Z=0:(
Q=!!Z):(c++,Q=r=V?fgetc(V):-1,s=s&amp;~1|r&lt;0) O++c,write(1,&amp;7[o],1) O z=c+2-l,w,
c=l+q O p,c=l+z O c=l+q O s^=1 O Q=q[l] O s|=1 O q[l]=Q O Q=~Q O a(5)=l[x=q]
,a(4)=l[++x] O s|=s&amp;16|9&lt;Q%16?Q+=6,16:0,z=s|=1&amp;s|Q&gt;159?Q+=96,1:0,y=Q,h(s&lt;&lt;8)
O l[x=q]=a(5),l[++x]=a(4) O x=Q%2,Q=Q/2+s%2*128,s=s&amp;~1|x O Q=l[d(3)]O x=Q  /
128,Q=Q*2+s%2,s=s&amp;~1|x O l[d(3)]=Q O s=s&amp;~1|1&amp;Q,Q=Q/2|Q&lt;&lt;7 O Q=l[d(1)]O s=~1
&amp;s|Q&gt;&gt;7,Q=Q*2|Q&gt;&gt;7 O l[d(1)]=Q O m y n(0,-,7)y) O m z=0,y=Q|=x,h(y) O m z=0,
y=Q^=x,h(y) O m z=Q*2|2*x,y=Q&amp;=x,h(y) O m Q n(s%2,-,7)y) O m Q n(0,-,7)y)  O
m Q n(s%2,+,7)y) O m Q n(0,+,7)y) O z=r-8?d(r+1):s|Q&lt;&lt;8,w O p,r-8?o[r+1]=z,r
[o]=z&gt;&gt;8:(s=~40&amp;z|2,Q=z&gt;&gt;8) O r[o]--||--o[r-1]O a(5)=z=a(5)+r[o],a(4)=z=a(4)
+o[r-1]+z/256,s=~1&amp;s|z&gt;&gt;8 O ++o[r+1]||r[o]++O o[r+1]=*c++,r[o]=*c++O z=c-l,w
,c=y*8+l O x=q,b z=c-l,w,c=l+x) O x=q,b c=l+x) O b p,c=l+z) O a(y)=*c++O r=y
,x=0,a(r)n(1,-,y)s&lt;&lt;8) O r=y,x=0,a(r)n(1,+,y)s&lt;&lt;8))));
system(&#34;stty cooked echo&#34;); B((B((V?B(V):0,u)),v)); }</small></pre>
<h2>How to compile it</h2>
<p>First, download the source code from <a href="https://nanochess.org/toledo2.c">here</a>.
It requires an *NIX compatible system (find porting notes below).</p>
<p>To compile use:</p>
<pre><small>    cc toledo2.c -o toledo2</small></pre>
<div><p>The emulator needs an initial memory image to do something
usable, so it will need two files
(</p><tt><a href="https://nanochess.org/c_basic.bin">c_basic.bin</a></tt><p> and
</p><tt><a href="https://nanochess.org/c_bios.bin">c_bios.bin</a></tt><p>).
Rename </p><tt>c_basic.bin</tt><p> to C and run
the emulator, and et voila! you have the public
domain Palo Alto Tiny BASIC (by Li-Chen Wang),
published on the very first volume of the now extinct Dr. Dobb&#39;s
Journal magazine.</p></div>
<p>Type using uppercase letters, here are three example
programs, press Enter after each line:</p>
<pre><small>   10 PRINT &#34;Hello, world!&#34;
   LIST
   RUN

   10 FOR A=1 TO 10       10 INPUT A
   20 PRINT A             20 INPUT B
   30 NEXT A              30 PRINT A+B
   LIST                   LIST
   RUN                    RUN</small></pre>
<p>Press Ctrl+Z to quit, by the way, the segmentation
fault is normal at this point.</p>
<p>All good programmers started learning BASIC, now,
what about a CP/M emulator?</p>
<p>Download the following file (not included because
of possible copyright and blah, blah):</p>
<pre><small>  <a href="http://www.retroarchive.org/cpm/os/KAYPROII.ZIP">http://www.retroarchive.org/cpm/os/KAYPROII.ZIP</a></small></pre>
<p>Extract CPM64.COM from the SOURCE directory, and
copy it to files named A and B (these will be the
disk drives). Now rename the provided c_bios.bin to C
and run the emulator.</p>
<p>Now you have a running CP/M operating system!, with two
files on A: drive, HALT.COM to stop the emulator
(so it closes drives) and IMPORT.COM to introduce
new files.</p>
<p>To get a complete CP/M system, you will need the
following files from the KAYPROII.ZIP, SOURCE
directory:</p>
<pre><small>  ASM.COM  DDT.COM   DUMP.COM   ED.COM   LOAD.COM
  PIP.COM  STAT.COM  SUBMIT.COM XSUB.COM</small></pre>
<p>To import them, you must run the emulator with an
argument, by example:</p>
<pre><small>  prog DDT.COM</small></pre>
<p>When the A&gt; prompt appears, do:</p>
<pre><small>  IMPORT DDT.COM</small></pre>
<p>When it ends, do HALT, so the file is saved, and
you can start the same process with another file.</p>
<p>The WS33-KPR directory of the KAYPROII.ZIP file also
contains a Wordstar version that works with this emulator. There is also
an interesting game, the classical Adventure by Crowther and Woods in the
ADVENTUR directory, at that time was amazing that a microcomputer could
contain such big game.</p>
<p>At this time I have tested successfully the
following software from
<a href="http://www.retroarchive.org">www.retroarchive.org</a>:</p>
<pre>Languages
<small>  <a href="http://www.retroarchive.org/cpm/lang/c80v30.zip">http://www.retroarchive.org/cpm/lang/c80v30.zip</a>
  <a href="http://www.retroarchive.org/cpm/lang/Mbasic.com">http://www.retroarchive.org/cpm/lang/Mbasic.com</a>
</small>
Spreadsheet
<small>  <a href="http://www.retroarchive.org/cpm/business/MULTPLAN.ZIP">http://www.retroarchive.org/cpm/business/MULTPLAN.ZIP</a>
</small>
Games
<small>  <a href="http://www.retroarchive.org/cpm/games/zork123_80.zip">http://www.retroarchive.org/cpm/games/zork123_80.zip</a>
</small>
Utilities
<small>  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/UNARC16.ARK">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/UNARC16.ARK</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/UNARC16.MSG">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/UNARC16.MSG</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/DELBR12.ARK">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/ARC-LBR/DELBR12.ARK</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/SQUSQ/USQ-20.COM">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/SQUSQ/USQ-20.COM</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/SQUSQ/UNCR8080.LBR">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/SQUSQ/UNCR8080.LBR</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/DIRUTL/XDIR3-12.LBR">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/DIRUTL/XDIR3-12.LBR</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/DIRUTL/CU.LBR">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/DIRUTL/CU.LBR</a>
  <a href="http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/FILCPY/SWEEP40.LBR">http://www.retroarchive.org/cpm/cdrom/CPM/UTILS/FILCPY/SWEEP40.LBR</a></small></pre>
<p>Some programs require installation to configure
the terminal, locate ANSI or VT-100.</p>
<h2>A little course on CP/M</h2>
<p>The CP/M user&#39;s manuals are available on
<a href="http://www.retroarchive.org">www.retroarchive.org</a>. But
if you remember how to use MS-DOS then you can use CP/M very easily. Here is a
little reference of the command line:</p>
<pre><b>Internal commands:</b>
A:              Change current drive to A
B:              Change current drive to B
DIR             List files in drive
DIR *.TXT       List all files with TXT extension
TYPE FILE.TXT   Shows content of FILE.TXT
ERA FILE.TXT    Erases file FILE.TXT
USER 1          Change to user 1 (0-15 available)
                It is something as subdirectories.
                So you can separate your files.

<b>External commands:</b>
STAT            Show used/free space on drive
STAT *.*        Show file sizes.
DDT PROG.COM    Debug PROG.COM.
                To quit use Ctrl+C

                Dump address 0100 (hex):
                  D0100</pre>
<div><p><img src="https://nanochess.org/img/captura1.gif" alt="Emulator running Wordstar under CP/M"/></p></div>
<h2>What is an 8080?</h2>
<p>It is simply the little brother of the Zilog Z80,
it has no extended registers (AF&#39;, BC&#39;, DE&#39;, HL&#39;,
IX or IY), no relative jumps, and every instruction
beginning with CB, DD, ED or FD doesn&#39;t exist.</p>
<p>The flags are only S (Sign, bit 7), Z (Zero, bit 6),
P (Parity, bit 2) and C (Carry, bit 0).</p>
<p>The 8080 processor was created by Federico Faggin and
Masatoshi Shima in 1974, afterwards both would design the Zilog Z80 in 1976,
these two processors were pretty important and influential for the rise of
microcomputers.</p>
<h2>Porting it</h2>
<div><p>It is easy if your platform has </p><tt>getch</tt><p>/</p><tt>kbhit</tt><p>
and ANSI terminal</p></div>
<pre><small>    read    --&gt;  Z=kbhit()?getch():0
    write   --&gt;  putchar(7[o])
    system  --&gt;  nothing</small></pre>
<p>Also add the following to trap Ctrl-C:</p>
<pre><small>    #include &lt;signal.h&gt;
    signal(SIGINT, SIG_IGN);</small></pre>
<div><p>On PC/DOS you will need to add </p><tt>ANSI.SYS</tt><p> to
</p><tt>CONFIG.SYS</tt></div>
<div><p>In *NIX the </p><tt>min 0</tt><p> for </p><tt>stty</tt><p> is required,
circa 2001 it was not required.</p></div>
<h2>How it works (SPOILER)</h2>
<p>The l array contains the 64K memory, it is
initialized with a boot image loaded from the &#39;C&#39;
file, the program counter is the c pointer, and
registers are on o[]. The main loops reads every
op-code and separates it in one of three common
forms, a lot of trinary operators selects the
instruction.</p>
<p>Execution starts at 0000, you can write your own boot
or monitor program, or even your own operating system playing with the
&#39;C&#39; file.</p>
<pre><small>   o[0] = B register   o[1] = C register
   o[2] = D register   o[3] = E register
   o[4] = H register   o[5] = L register
   o[6] = Flags        o[7] = A or accumulator</small></pre>
<p>The following instructions do peripheral operation:</p>
<pre><small>   76           Quits emulator
   DB 00        Reads key pressed status
   DB 01        Reads key
   DB 02        Reads byte from file (Carry=EOF)
   D3 xx        Writes byte from acc. to console
   ED ED 02     Reads sector (128 bytes)
   ED ED 03     Writes sector (128 bytes)

   Memory addresses:

   FBFA = Low source/target address
   FBFB - High source/target address
   FBFC - Sector (0-127)
   FBFD - Cylinder (low byte)
   FBFE - Cylinder (high byte)
   FBFF - Drive (1/2)</small></pre>
<p>The BIOS is tailor made for this emulator and
helps to simplify it. Though the size of each virtual hard disk drive can
reach 1 GB, CP/M only handles up to 8 MB.</p>
<h2>Other notes:</h2>
<ul>
<li>The 8080 runs at your computer speed divided
between a number that I have not calculated.
</li><li>This obfuscated processor was created using
obfuscated code produced by an obfuscated mind,
no brains were harmed during its production,
except those that tried to read the code.
</li><li>The original version of this code was eaten
by my C++ dog.
</li><li>I intended to make it simple to understand,
it uses only four C keywords.
</li><li>Also I discovered that braces are very useful
for commenting.
</li><li>Why to bother with prototypes?, every good C
programmer can develop its C programs using
only one function.
</li></ul>
<h2>And now it is 2024</h2>
<p>This emulator was developed eighteen years ago when the computers had 32-bit processors and it used a hole in the C language syntax where you could pass a pointer on an integer. In fact, this is the IOCCC objective: make C compilers to do things these shouldn&#39;t be supposed to do.</p>
<p>However, the C compilers for 64-bit processors don&#39;t allow it anymore as pointers are 64-bit and the int types are 32-bit, so compilers stop with an error (in especial in macOS because clang).</p>
<p>The source code in this webpage is already updated to use FILE * instead of int, and this way we brought CP/M to year 2024, hehe.</p>
<p>If you are curious about it, the previous version of the emulator can be downloaded <a href="https://nanochess.org/toledo2_orig.c">here</a> or in the IOCCC website. In 2020, Mark Abene sent me a workaround for x86-64 computers:</p>
<pre><small>    gcc -static toledo2.c -o toledo2</small></pre>
<p>But this doesn&#39;t work in macOS.</p>
<h2>Useful links:</h2>
<ul>
<li><a href="http://www.nicholson.com/rhn/basic/">Palo Alto Tiny BASIC source
code</a>, this is a modified version of the original.</li>
<li><a href="http://www.retroarchive.org/cpm/archive/unofficial/source.html">CP/M
source code</a>, the foundation of an operating system: monotask,
no memory manager, only console and file services provided.</li>
<li><a href="http://stardot.org.uk/forums/viewtopic.php?f=3&amp;t=9821&amp;p=116643">Someone received an 8080 computer as a gift</a>,
dumped the ROM, and someone
else found a way to test them with my 8080 emulator. :)</li>
</ul>
<p>Last modified: Feb/06/2024</p>
</div></div>
  </body>
</html>
