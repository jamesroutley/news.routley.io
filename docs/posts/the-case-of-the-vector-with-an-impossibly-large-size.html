<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20240105-00/?p=109242">Original</a>
    <h1>The case of the vector with an impossibly large size</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            January 5th, 2024</p><!-- .entry-meta -->
        <p>A customer had a program that crashed with this stack:</p>
<pre>contoso!Widget::GetCost
contoso!StandardWidgets::get_TotalCost+0x12f
rpcrt4!Invoke+0x73
rpcrt4!Ndr64StubWorker+0xb9b
rpcrt4!NdrStubCall3+0xd7
combase!CStdStubBuffer_Invoke+0xdb
combase!ObjectMethodExceptionHandlingAction&lt;&lt;lambda_...&gt; &gt;+0x47
combase!DefaultStubInvoke+0x376
combase!ServerCall::ContextInvoke+0x6f3
combase!ComInvokeWithLockAndIPID+0xacb
combase!ThreadInvoke+0x103
rpcrt4!DispatchToStubInCNoAvrf+0x18
rpcrt4!RPC_INTERFACE::DispatchToStubWorker+0x1a9
rpcrt4!RPC_INTERFACE::DispatchToStubWithObject+0x1a7
rpcrt4!LRPC_SCALL::DispatchRequest+0x308
rpcrt4!LRPC_SCALL::HandleRequest+0xdcb
rpcrt4!LRPC_SASSOCIATION::HandleRequest+0x2c3
rpcrt4!LRPC_ADDRESS::HandleRequest+0x183
rpcrt4!LRPC_ADDRESS::ProcessIO+0x939
rpcrt4!LrpcIoComplete+0xff
ntdll!TppAlpcpExecuteCallback+0x14d
ntdll!TppWorkerThread+0x4b4
kernel32!BaseThreadInitThunk+0x18
ntdll!RtlUserThreadStart+0x21
</pre>
<p>They wondered if some recent change to Windows was the source of the problem, since it didn’t happen as much in earlier versions of Windows.</p>
<p>The stack trace pointed to <code>Widget::<wbr/>IsEnabled</code>, which was crashing on the first instruction because it was given an invalid <code>this</code> pointer.</p>
<pre>00007fff`73a8a59f mov edx,dword ptr [rcx+40h]
                                    ds:00000000`00000040=????????
</pre>
<p>The <code>Widget</code> pointer came from a <code>std::vector</code> that is a member of the <code>Standard­Widgets</code> class.</p>
<pre>using namespace Microsoft::WRL;

class StandardWidgets : RuntimeClass&lt;IStandardWidgets, FtmBase&gt;
{
    IFACEMETHODIMP get_TotalCost(INT32* result);
    ⟦ other methods not relevant here ⟧

private:
    HRESULT LazyInitializeWidgetList();

    static constexpr PCWSTR standardWidgetNames[] = {
        L&#34;Bob&#34;, L&#34;Carol&#34;, L&#34;Ted&#34;, L&#34;Alice&#34; };
    static constexpr int standardWidgetCount =
        ARRAYSIZE(standardWidgetNames);

    std::vector&lt;ComPtr&lt;Widget&gt;&gt; m_widgets;
};
</pre>
<p>The code crashed at this call to <code>Widget::<wbr/>GetCost</code>:</p>
<pre>IFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)
{
    *result = 0;

    RETURN_IF_FAILED(LazyInitializeWidgetList());

    INT32 totalCost = 0;
    for (int i = 0; i &lt; standardWidgetCount; i++) {
        totalCost += <span>m_widgets[i]-&gt;GetCost()</span>; // here
    }
    *result = totalCost;
    return S_OK;
}
</pre>
<p>The customer’s debugging showed that at the point of the crash, not only was the <code>widget</code> garbage, but the <code>m_widgets</code> vector had an impossibly large number of elements. The <code>m_widgets</code> is expected to have only four widgets, but it somehow found itself with ten, and sometimes as many as a hundred widgets. Of course, they were nearly all corrupted.</p>
<p>Here’s the code that lazy-initializes the widget list:</p>
<pre>HRESULT StandardWidgets::LazyInitializeWidgetList()
{
    // Early-out if already initialized.
    if (!m_widgets.empty()) {
        return S_OK;
    }

    // Lazy-create the vector of standard widgets
    try {
        m_widgets.reserve(standardWidgetCount);
        for (auto name : standardWidgetNames) {
            ComPtr&lt;Widget&gt; widget;
            RETURN_IF_FAILED(
                MakeAndInitialize&lt;Widget&gt;(&amp;widget, name));
            m_widgets.push_back(widget);
        }
    } catch (std::bad_alloc const&amp;) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}
</pre>
<p>The customer noted that the <code>reserve</code> method is always called with the value 4, and the code never pushes more than four items into the vector. They admitted that if there is a problem creating all four of the standard widgets, the vector could end up with fewer than four widgets, but it should never have <i>more</i> than four.</p>
<p>You already have multiple clues that point toward what the customer’s problem is. I’ll give you some time to think about it.</p>
<p>In the meantime, let’s look at other issues with how the code lazy-initializes the widget list.</p>
<p>As the customer noted, if there is a problem creating any of the four standard widgets, the failure is propagated to the caller of <code>Lazy­Initialize­Widget­List</code>, and <code>get_TotalCost</code> in turn propagates the error to its own caller, and it never gets to the point where it walks through the vector adding up all the costs.</p>
<p>If there is a memory allocation failure at the <code>reserve()</code>, or if there is a problem with the first standard widget, then the vector remains empty, and a second call to <code>Lazy­Initialize­Widget­List</code> will make a new attempt at initialization.</p>
<p>If there is a problem with the second or subsequent standard widget, however, things get weird. The <code>Lazy­Initialize­Widget­List</code> function returns a failure, which causes <code>get_TotalCost</code> to return failure. But the second time someone calls <code>get_TotalCost</code>, <code>Lazy­Initialize­Widget­List</code> will see a nonempty vector and assume that everything was initialized. This time, the <code>get_TotalCost</code> method will proceed with the summation and perform an out-of-bounds array access when it gets to the widget that failed to be created.</p>
<p>Oops.</p>
<p>This particular problem boils down to leaving a partially-initialized <code>m_widgets</code> if the lazy initialization fails. To avoid this problem, we should create the vector in a local variable and transfer it to the member variable only after we are sure all of the widgets were created successfully.</p>
<pre>HRESULT StandardWidgets::LazyInitializeWidgetList()
{
    // Early-out if already initialized.
    if (!m_widgets.empty()) {
        return S_OK;
    }

    // Lazy-create the vector of standard widgets
    try {
        <span>std::vector&lt;ComPtr&lt;Widget&gt;&gt; widgets;</span>
        <span>widgets</span>.reserve(standardWidgetCount);
        for (auto name : standardWidgetNames) {
            ComPtr&lt;Widget&gt; widget;
            RETURN_IF_FAILED(
                MakeAndInitialize&lt;Widget&gt;(&amp;widget, name));
            <span>widgets</span>.push_back(widget);
        }
        <span>m_widgets.swap(widgets);</span>
    } catch (std::bad_alloc const&amp;) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}
</pre>
<p>This ensures that the <code>m_widgets</code> is either totally empty or totally initialized. It is never in a half-initialized state.</p>
<p>While we’re at it, we probably should convert the loop in <code>get_TotalCost</code> into a ranged <code>for</code> loop. Right now, <code>get_<wbr/>Total­Cost</code> has a hidden dependency on <code>Lazy­Initialize­Widgets</code>: It assumes that <code>Lazy­Initialize­Widgets</code> always creates exactly the number of widgets as there are <code>standard­Widget­Names</code>. Maybe in the future, you might want to suppress some of the standard widgets based on some configuration setting. If you add that configuration setting and forget to update <code>get_<wbr/>Total­Cost</code> to account for suppressed widgets, you will have an out-of-bounds index. All the logic to decide which widgets are standard should be local to <code>Lazy­Initialize­Widgets</code>.</p>
<pre>IFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)
{
    *result = 0;

    RETURN_IF_FAILED(LazyInitializeWidgetList());

    INT32 totalCost = 0;
    <span>for (auto&amp;&amp; widget : m_widgets) {  </span>
    <span>    totalCost += widget-&gt;GetCost();</span>
    <span>}                                  </span>
    *result = totalCost;
    return S_OK;
}
</pre>
<p>Or if you want to get fancy,</p>
<pre>IFACEMETHODIMP StandardWidgets::get_TotalCost(INT32* result)
{
    *result = 0;

    RETURN_IF_FAILED(LazyInitializeWidgetList());

    <span>*result = std::transform_reduce(                         </span>
    <span>    m_widgets.begin(), m_widgets.end(), 0, std::plus&lt;&gt;(),</span>
    <span>    [](auto&amp;&amp; w) { return w-&gt;GetCost(); });              </span>
    return S_OK;
}
</pre>
<p>Okay, but back to the crash. I think I’ve added enough filler to give you time to consider what is happening.</p>
<p>When I looked at this crash, I noticed that the class is implemented with <a href="https://learn.microsoft.com/en-us/cpp/cppcx/wrl/runtimeclass-class?view=msvc-170"> the <code>Microsoft::<wbr/>WRL::<wbr/>RuntimeClass</code> template class</a>, and the implementation explicitly listed <code>FtmBase</code> as a template parameter, marking this class as free-threaded (also known as “agile”), which means that it can be used from multiple threads simultaneously.¹</p>
<p>The object is eligible for multithreaded use, but there are no mutexes to protect two threads from modifying <code>m_widgets</code> at the same time. I suspected a race condition.</p>
<p>You can also observe that the class is being used in a free-threaded manner because the stack trace that leads to the crash says that it’s running on a thread pool thread (<code>TppWorkerThread</code>), and thread pool threads default to the multi-threaded apartment.² The only code on the stack between <code>TppWorkerThread</code> and the application code is all COM and RPC, so no application code snuck in and initialized the thread into single-threaded apartment mode.</p>
<p>And when I looked at the crash dump, I caught the code red-handed: There was another thread also calling into this code.</p>
<pre>// Crashing thread
0:006&gt; .frame 1
01 contoso!StandardWidgets::get_TotalCost+0x12f
0:006&gt; dv
    this = <span>0x000001b7`492833b0</span>
    ...

// Another thread running at the time of the crash
0:004&gt; kn
 # Call Site
00 ntdll!ZwDelayExecution+0x14
01 ntdll!RtlDelayExecution+0x4c
02 KERNELBASE!SleepEx+0x84
04 kernel32!WerpReportFault+0xa4
05 KERNELBASE!UnhandledExceptionFilter+0xd3a02
06 ntdll!TppExceptionFilter+0x7a
07 ntdll!TppWorkerpInnerExceptionFilter+0x1a
08 ntdll!TppWorkerThread$filt$3+0x19
09 ntdll!__C_specific_handler+0x96
0a ntdll!__GSHandlerCheck_SEH+0x6a
0b ntdll!RtlpExecuteHandlerForException+0xf
0c ntdll!RtlDispatchException+0x2d4
0d ntdll!KiUserExceptionDispatch+0x2e
0e contoso!StandardWidgets::get_TotalCost+0x12f
0f rpcrt4!Invoke+0x73
10 rpcrt4!Ndr64StubWorker+0xb9b
11 rpcrt4!NdrStubCall3+0xd7
12 combase!CStdStubBuffer_Invoke+0xdb
14 combase!ObjectMethodExceptionHandlingAction&lt;&lt;lambda_...&gt; &gt;+0x47
16 combase!DefaultStubInvoke+0x376
1a combase!ServerCall::ContextInvoke+0x6f3
1f combase!ComInvokeWithLockAndIPID+0xacb
21 combase!ThreadInvoke+0x103
22 rpcrt4!DispatchToStubInCNoAvrf+0x18
23 rpcrt4!RPC_INTERFACE::DispatchToStubWorker+0x1a9
25 rpcrt4!RPC_INTERFACE::DispatchToStubWithObject+0x1a7
27 rpcrt4!LRPC_SCALL::DispatchRequest+0x308
29 rpcrt4!LRPC_SCALL::HandleRequest+0xdcb
2a rpcrt4!LRPC_SASSOCIATION::HandleRequest+0x2c3
2b rpcrt4!LRPC_ADDRESS::HandleRequest+0x183
2c rpcrt4!LRPC_ADDRESS::ProcessIO+0x939
2d rpcrt4!LrpcIoComplete+0xff
2e ntdll!TppAlpcpExecuteCallback+0x14d
2f ntdll!TppWorkerThread+0x4b4
30 kernel32!BaseThreadInitThunk+0x18
31 ntdll!RtlUserThreadStart+0x21
0:004&gt; .frame 0xe
0e contoso!StandardWidgets::get_TotalCost+0x12f
0:004&gt; dv
    this = <span>0x000001b7`492833b0</span>
    ...
</pre>
<p>Notice that the <code>this</code> pointer is the same for both threads, so we have proof that this object is being used from multiple threads simultaneously.</p>
<p>The fix for the multithreading issue is to ensure that only one thread tries to initialize the widget vector at a time. We can do this by adding a mutex, but I’m going to go even further and use the <code>std::once_flag</code>, whose purpose in life is to be used in conjunction with <code>std::<wbr/>call_once</code> to perform thread-safe one-time initialization, which is exactly what we want.</p>
<pre>class StandardWidgets : RuntimeClass&lt;IStandardWidgets, FtmBase&gt;
{
    IFACEMETHODIMP get_TotalCost(INT32* result);
    ⟦ other methods not relevant here ⟧

private:
    HRESULT LazyInitializeWidgetList();

    static constexpr PCWSTR standardWidgetNames[] = {
        L&#34;Bob&#34;, L&#34;Carol&#34;, L&#34;Ted&#34;, L&#34;Alice&#34; };
    static constexpr int standardWidgetCount =
        ARRAYSIZE(standardWidgetNames);

    <span>std::once_flag m_initializeFlag;</span>
    std::vector&lt;ComPtr&lt;Widget&gt;&gt; m_widgets;
};

HRESULT StandardWidgets::LazyInitializeWidgetList()
{
    try {
        <span>std::call_once(m_initializeFlag, [&amp;] {</span>
            std::vector&lt;ComPtr&lt;Widget&gt;&gt; widgets;
            widgets.reserve(standardWidgetCount);
            for (auto name : standardWidgetNames) {
                ComPtr&lt;Widget&gt; widget;
                <span>THROW</span>_IF_FAILED(
                    MakeAndInitialize&lt;Widget&gt;(&amp;widget, name));
                widgets.push_back(widget);
            }
            m_widgets = std::move(widgets);
        <span>});</span>
    } catch (std::bad_alloc const&amp;) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}
</pre>
<p><b>Update</b>: We had to change the <code>RETURN_<wbr/>IF_<wbr/>FAILED</code> to <code>THROW_<wbr/>IF_<wbr/>FAILED</code> because (1) without the change, the compiler will complain that not all code paths return a value, because the lambda also falls off the end, and more importantly, (2) <code>call_once</code> doesn’t care about the lambda return value; it uses exceptions to detect errors. <b>End Update</b>.</p>
<p>This version also deals with the edge case where there are no standard widgets at all. The original code would continuously try to reinitialize the vector since it couldn’t tell whether an empty vector means “Not yet initialized” or “Successfully initialized (and it’s empty)”.</p>
<p><b>Bonus chatter</b>: How did this multithreaded race condition lead to a vector with a ridiculous size? Well, we saw some time ago that <a title="Inside STL: The vector" href="https://devblogs.microsoft.com/oldnewthing/20230802-00/?p=108524"> the internal structure of a <code>std::vector</code></a> is three pointers, one for the start of the vector data, one for the end of the valid data, and one for the end of the allocated data. If two threads call <code>reserve()</code> simultaneously, both will allocate new data, and then they were race to update the three pointers. You might end up with a “start” pointer that points to the data allocated by the first thread, but an “end” pointer that points to the data allocated by the second thread, resulting in a vector of unusual size.</p>
<p>¹ It was actually convenient that the implementation lists <code>FtmBase</code> explicitly, since the default behavior varies depending on whether <code>__WRL_<wbr/>CONFIGURATION_<wbr/>LEGACY__</code> is set.</p>
<table>
<tbody>
<tr>
<th>Template parameter</th>
<th>Standard mode</th>
<th>Legacy mode</th>
</tr>
<tr>
<td>Nothing specified</td>
<td>Free-threaded</td>
<td>Not free-threaded</td>
</tr>
<tr>
<td><code>FtmBase</code></td>
<td colspan="2">Free-threaded</td>
</tr>
<tr>
<td><code>InhibitFtmBase</code></td>
<td colspan="2">Not free-threaded</td>
</tr>
<tr>
<td><code>InhibitFtmBase</code> + <code>FtmBase</code></td>
<td colspan="2">Not free-threaded</td>
</tr>
</tbody>
</table>
<p>In pseudocode:</p>
<pre>bool isFreeThreaded = !InhibitFtmBase &amp;&amp; (FtmBase || Standard mode);
</pre>
<p>The explicitly inclusion of <code>FtmBase</code> saved me the trouble of looking up what mode the customer’s project is using.</p>
<p>² Assuming the multi-threaded apartment exists at all.</p>

        

        
		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
