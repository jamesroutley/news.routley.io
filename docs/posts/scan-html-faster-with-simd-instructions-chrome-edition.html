<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2024/06/08/scan-html-faster-with-simd-instructions-chrome-edition/">Original</a>
    <h1>Scan HTML faster with SIMD instructions – Chrome edition</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Modern processors have instructions to process several bytes at once. Effectively all processors have the capability of processing 16 bytes at once. These instructions are called SIMD, for single instruction, multiple data.</p>
<p>It was once an open question whether these instructions could be useful to accelerate common tasks such as parsing HTML or JSON. However, the work on JSON parsing, as <a href="https://github.com/simdjson/simdjson">in the simdjson parser</a>, has shown rather decisively that SIMD instructions could, indeed, be helpful in breaking speed records.</p>
<p>Inspired by such work, the engine under the Google Chrome browser (Chromium) <a href="https://chromium-review.googlesource.com/c/chromium/src/+/5538407">has adopted SIMD parsing of the HTML inputs</a>. It is the result of the excellent work by a Google engineer, Anton Bikineev.</p>
<p>The approach is used to quickly jump to four specific characters: &lt;, &amp;, \r and \0. You can implement something that looks a lot like it using regular C++ code as follows:</p>
<pre><span><span>void</span> NaiveAdvanceString<span>(</span><span>const</span> <span>char</span> <span>*</span><span>&amp;</span>start<span>,</span> <span>const</span> <span>char</span> <span>*</span>end<span>)</span> <span>{</span></span>
<span>  <span>for</span> <span>(</span><span>;</span>start <span>&lt;</span> end<span>;</span> start<span>+</span><span>+</span><span>)</span> <span>{</span></span>
<span>    <span>if</span><span>(</span><span>*</span>start <span>=</span><span>=</span> <span>&#39;&lt;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;&amp;&#39;</span> </span>
<span>        <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\r&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\0&#39;</span><span>)</span> <span>{</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span></span>
<span><span>}</span></span></pre>
<p>A ‘naive’ approach using the SIMD instructions available on ARM processors looks as follows. Basically, you just do more or less the same thing as the naive regular/scalar approach, except that instead of taking one character at a time, you take 16 characters at a time.</p>
<pre><span><span>void</span> AdvanceString<span>(</span><span>const</span> <span>char</span> <span>*</span><span>&amp;</span>start<span>,</span> <span>const</span> <span>char</span> <span>*</span>end<span>)</span> <span>{</span></span>
<span>  uint8x16_t quote_mask <span>=</span> vmovq_n_u8<span>(</span><span>&#39;&lt;&#39;</span><span>)</span><span>;</span></span>
<span>  uint8x16_t escape_mask <span>=</span> vmovq_n_u8<span>(</span><span>&#39;&amp;&#39;</span><span>)</span><span>;</span></span>
<span>  uint8x16_t newline_mask <span>=</span> vmovq_n_u8<span>(</span><span>&#39;\r&#39;</span><span>)</span><span>;</span></span>
<span>  uint8x16_t zero_mask <span>=</span> vmovq_n_u8<span>(</span><span>&#39;\0&#39;</span><span>)</span><span>;</span></span>
<span>  uint8x16_t bit_mask <span>=</span> <span>{</span><span>16</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>13</span><span>,</span> <span>12</span><span>,</span> <span>11</span><span>,</span> <span>10</span><span>,</span> <span>9</span><span>,</span> <span>8</span><span>,</span></span>
<span>                            <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>}</span><span>;</span></span>
<span>  <span>static</span> <span>constexpr</span> <span>auto</span> stride <span>=</span> <span>16</span><span>;</span></span>
<span>  <span>for</span> <span>(</span><span>;</span> start <span>+</span> <span>(</span>stride <span>-</span> <span>1</span><span>)</span> <span>&lt;</span> end<span>;</span> start <span>+</span><span>=</span> stride<span>)</span> <span>{</span></span>
<span>    uint8x16_t data <span>=</span> vld1q_u8<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span> <span>uint8_t</span> <span>*</span><span>&gt;</span><span>(</span>start<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t quotes <span>=</span> vceqq_u8<span>(</span>data<span>,</span> quote_mask<span>)</span><span>;</span></span>
<span>    uint8x16_t escapes <span>=</span> vceqq_u8<span>(</span>data<span>,</span> escape_mask<span>)</span><span>;</span></span>
<span>    uint8x16_t newlines <span>=</span> vceqq_u8<span>(</span>data<span>,</span> newline_mask<span>)</span><span>;</span></span>
<span>    uint8x16_t zeros <span>=</span> vceqq_u8<span>(</span>data<span>,</span> zero_mask<span>)</span><span>;</span></span>
<span>    uint8x16_t mask <span>=</span> vorrq_u8<span>(</span>vorrq_u8<span>(</span>quotes<span>,</span>zeros<span>)</span><span>,</span> 
           vorrq_u8<span>(</span>escapes<span>,</span> newlines<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t matches <span>=</span> vandq_u8<span>(</span>bit_mask<span>,</span> mask<span>)</span><span>;</span></span>
<span>    <span>int</span> m <span>=</span> vmaxvq_u8<span>(</span>matches<span>)</span><span>;</span></span>
<span>    <span>if</span><span>(</span>m <span>!</span><span>=</span> <span>0</span><span>)</span> <span>{</span></span>
<span>      start <span>+</span><span>=</span> <span>16</span> <span>-</span> m<span>;</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span>  </span>
<span>  <span>for</span> <span>(</span><span>;</span>start <span>&lt;</span> end<span>;</span> start<span>+</span><span>+</span><span>)</span> <span>{</span></span>
<span>    <span>if</span><span>(</span><span>*</span>start <span>=</span><span>=</span> <span>&#39;&lt;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;&amp;&#39;</span> 
<span>       |</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\r&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\0&#39;</span><span>)</span> <span>{</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span></span>
<span><span>}</span></span></pre>
<p>If you have a PC with an Intel or AMD processor, you can do the equivalent using SSE2 instructions:</p>
<pre><span><span>void</span> AdvanceString<span>(</span><span>const</span> <span>char</span><span>*</span><span>&amp;</span> start<span>,</span> <span>const</span> <span>char</span><span>*</span> end<span>)</span> <span>{</span></span>
<span>    <span>const</span> __m128i quote_mask <span>=</span> _mm_set1_epi8<span>(</span><span>&#39;&lt;&#39;</span><span>)</span><span>;</span></span>
<span>    <span>const</span> __m128i escape_mask <span>=</span> _mm_set1_epi8<span>(</span><span>&#39;&amp;&#39;</span><span>)</span><span>;</span></span>
<span>    <span>const</span> __m128i newline_mask <span>=</span> _mm_set1_epi8<span>(</span><span>&#39;\r&#39;</span><span>)</span><span>;</span></span>
<span>    <span>const</span> __m128i zero_mask <span>=</span> _mm_set1_epi8<span>(</span><span>&#39;\0&#39;</span><span>)</span><span>;</span></span>

<span>    <span>static</span> <span>constexpr</span> <span>auto</span> stride <span>=</span> <span>16</span><span>;</span></span>
<span>    <span>for</span> <span>(</span><span>;</span> start <span>+</span> <span>(</span>stride <span>-</span> <span>1</span><span>)</span> <span>&lt;</span> end<span>;</span> start <span>+</span><span>=</span> stride<span>)</span> <span>{</span></span>
<span>        __m128i data <span>=</span> _mm_loadu_si128<span>(
</span><span>           reinterpret_cast</span><span>&lt;</span><span>const</span> __m128i<span>*</span><span>&gt;</span><span>(</span>start<span>)</span><span>)</span><span>;</span></span>
<span>        __m128i quotes <span>=</span> _mm_cmpeq_epi8<span>(</span>data<span>,</span> quote_mask<span>)</span><span>;</span></span>
<span>        __m128i escapes <span>=</span> _mm_cmpeq_epi8<span>(</span>data<span>,</span> escape_mask<span>)</span><span>;</span></span>
<span>        __m128i newlines <span>=</span> _mm_cmpeq_epi8<span>(</span>data<span>,</span> newline_mask<span>)</span><span>;</span></span>
<span>        __m128i zeros <span>=</span> _mm_cmpeq_epi8<span>(</span>data<span>,</span> zero_mask<span>)</span><span>;</span></span>
<span>        __m128i mask <span>=</span> _mm_or_si128<span>(</span>_mm_or_si128<span>(</span>quotes<span>,</span> zeros<span>)</span><span>,                   
</span>             _mm_or_si128<span>(</span>escapes<span>,</span> newlines<span>)</span><span>)</span><span>;</span></span>
<span>        <span>int</span> m <span>=</span> _mm_movemask_epi8<span>(</span>mask<span>)</span><span>;</span></span>
<span>        <span>if</span> <span>(</span>m <span>!</span><span>=</span> <span>0</span><span>)</span> <span>{</span></span>
<span>            start <span>+</span><span>=</span> __builtin_ctz<span>(</span>m<span>)</span><span>;</span></span>
<span>            <span>return</span><span>;</span></span>
<span>        <span>}</span></span>
<span>    <span>}</span></span>

<span>    <span>// Process any remaining bytes (less than 16)</span></span>
<span>    <span>while</span> <span>(</span>start <span>&lt;</span> end<span>)</span> <span>{</span></span>
<span>        <span>if</span> <span>(</span><span>*</span>start <span>=</span><span>=</span> <span>&#39;&lt;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;&amp;&#39;</span> 
<span>             |</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\r&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\0&#39;</span><span>)</span> <span>{</span></span>
<span>            <span>return</span><span>;</span></span>
<span>        <span>}</span></span>
<span>        start<span>+</span><span>+</span><span>;</span></span>
<span>    <span>}</span></span>
<span><span>}</span></span></pre>
<p>You can do slightly better if you use an approach we call vectorize classification (see <a href="https://arxiv.org/pdf/1902.08318">Langdale and Lemire</a>, 2019). Basically, you combine a SIMD approach with vectorized table lookups to classify the characters. The ARM NEON version using two table lookups looks as follows:</p>
<pre><span><span>void</span> AdvanceStringTable<span>(</span><span>const</span> <span>char</span> <span>*</span><span>&amp;</span>start<span>,</span> <span>const</span> <span>char</span> <span>*</span>end<span>)</span> <span>{</span></span>
<span>  uint8x16_t low_nibble_mask <span>=</span> <span>{</span><span>0</span><span>b</span><span>0001</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>b</span><span>0100</span><span>,</span> 
<span>          0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>b</span><span>0010</span><span>,</span> <span>0</span><span>b</span><span>1000</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span></span>
<span>  uint8x16_t high_nibble_mask <span>=</span> <span>{</span><span>0</span><span>b</span><span>1001</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>b</span><span>0100</span><span>,</span> <span>0</span><span>b</span><span>0010</span><span>,</span> 
<span>          0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span></span>
<span>  uint8x16_t v0f <span>=</span> vmovq_n_u8<span>(</span><span>0xf</span><span>)</span><span>;</span></span>
<span>  uint8x16_t bit_mask <span>=</span> <span>{</span><span>16</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>13</span><span>,</span> <span>12</span><span>,</span> <span>11</span><span>,</span> <span>10</span><span>,</span> <span>9</span><span>,</span> <span>8</span><span>,</span></span>
<span>                            <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>}</span><span>;</span></span>
<span>  <span>static</span> <span>constexpr</span> <span>auto</span> stride <span>=</span> <span>16</span><span>;</span></span>
<span>  <span>for</span> <span>(</span><span>;</span> start <span>+</span> <span>(</span>stride <span>-</span> <span>1</span><span>)</span> <span>&lt;</span> end<span>;</span> start <span>+</span><span>=</span> stride<span>)</span> <span>{</span></span>
<span>    uint8x16_t data <span>=</span> vld1q_u8<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span> <span>uint8_t</span> <span>*</span><span>&gt;</span><span>(</span>start<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t lowpart <span>=</span> vqtbl1q_u8<span>(</span>low_nibble_mask<span>,</span> vandq_u8<span>(</span>data<span>,</span> v0f<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t highpart <span>=</span> vqtbl1q_u8<span>(</span>high_nibble_mask<span>,  
</span>           vshrq_n_u8<span>(</span>data<span>,</span> <span>4</span><span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t classify <span>=</span> vandq_u8<span>(</span>lowpart<span>,</span> highpart<span>)</span><span>;</span></span>
<span>    uint8x16_t matchesones <span>=</span> vtstq_u8<span>(</span>classify<span>,</span> vdupq_n_u8<span>(</span><span>0xFF</span><span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t matches <span>=</span> vandq_u8<span>(</span>bit_mask<span>,</span> matchesones<span>)</span><span>;</span></span>
<span>    <span>int</span> m <span>=</span> vmaxvq_u8<span>(</span>matches<span>)</span><span>;</span></span>
<span>    <span>if</span><span>(</span>m <span>!</span><span>=</span> <span>0</span><span>)</span> <span>{</span></span>
<span>      start <span>+</span><span>=</span> <span>16</span> <span>-</span> m<span>;</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span>  </span>
<span>  <span>for</span> <span>(</span><span>;</span>start <span>&lt;</span> end<span>;</span> start<span>+</span><span>+</span><span>)</span> <span>{</span></span>
<span>    <span>if</span><span>(</span><span>*</span>start <span>=</span><span>=</span> <span>&#39;&lt;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;&amp;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\r&#39;</span> 
<span>     |</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\0&#39;</span><span>)</span> <span>{</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span></span>
<span><span>}</span></span></pre>
<p>This version is close to Bikineev’s code as it appears in the Google Chrome engine, except that I use standard instrinsics while Google engineers prefer to use the excellent <a href="https://github.com/google/highway">highway SIMD library</a> by Jan Wassenberg.</p>
<p>We can do slightly better in this instance because Bikineev only needs to distinguish between four characters. A single table lookup is needed. We did not elaborate in <a href="https://arxiv.org/pdf/1902.08318">Langdale and Lemire</a> (2019) but vectorized classification works using one, two, three or more table lookups, depending on the complexity of the target set. The simpler version might look as follows:</p>
<pre><span><span>void</span> AdvanceStringTableSimpler<span>(</span><span>const</span> <span>char</span> <span>*</span><span>&amp;</span>start<span>,</span> <span>const</span> <span>char</span> <span>*</span>end<span>)</span> <span>{</span></span>
<span>  uint8x16_t low_nibble_mask <span>=</span> <span>{</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0x26</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> 
<span>                            0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0x3c</span><span>,</span> <span>0xd</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>}</span><span>;</span></span>
<span>  uint8x16_t v0f <span>=</span> vmovq_n_u8<span>(</span><span>0xf</span><span>)</span><span>;</span></span>
<span>  uint8x16_t bit_mask <span>=</span> <span>{</span><span>16</span><span>,</span> <span>15</span><span>,</span> <span>14</span><span>,</span> <span>13</span><span>,</span> <span>12</span><span>,</span> <span>11</span><span>,</span> <span>10</span><span>,</span> <span>9</span><span>,</span> <span>8</span><span>,</span></span>
<span>                            <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>}</span><span>;</span></span>
<span>  <span>static</span> <span>constexpr</span> <span>auto</span> stride <span>=</span> <span>16</span><span>;</span></span>
<span>  <span>for</span> <span>(</span><span>;</span> start <span>+</span> <span>(</span>stride <span>-</span> <span>1</span><span>)</span> <span>&lt;</span> end<span>;</span> start <span>+</span><span>=</span> stride<span>)</span> <span>{</span></span>
<span>    uint8x16_t data <span>=</span> vld1q_u8<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>const</span> <span>uint8_t</span> <span>*</span><span>&gt;</span><span>(</span>start<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t lowpart <span>=</span> vqtbl1q_u8<span>(</span>low_nibble_mask<span>,</span> vandq_u8<span>(</span>data<span>,</span> v0f<span>)</span><span>)</span><span>;</span></span>
<span>    uint8x16_t matchesones <span>=</span> vceqq_u8<span>(</span>lowpart<span>,</span> data<span>)</span><span>;</span></span>
<span>    uint8x16_t matches <span>=</span> vandq_u8<span>(</span>bit_mask<span>,</span> matchesones<span>)</span><span>;</span></span>
<span>    <span>int</span> m <span>=</span> vmaxvq_u8<span>(</span>matches<span>)</span><span>;</span></span>
<span>    <span>if</span><span>(</span>m <span>!</span><span>=</span> <span>0</span><span>)</span> <span>{</span></span>
<span>      start <span>+</span><span>=</span> <span>16</span> <span>-</span> m<span>;</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span>  </span>
<span>  <span>for</span> <span>(</span><span>;</span>start <span>&lt;</span> end<span>;</span> start<span>+</span><span>+</span><span>)</span> <span>{</span></span>
<span>    <span>if</span><span>(</span><span>*</span>start <span>=</span><span>=</span> <span>&#39;&lt;&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;&amp;&#39;</span> 
<span>     |</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\r&#39;</span> <span>|</span><span>|</span> <span>*</span>start <span>=</span><span>=</span> <span>&#39;\0&#39;</span><span>)</span> <span>{</span></span>
<span>      <span>return</span><span>;</span></span>
<span>    <span>}</span></span>
<span>  <span>}</span></span>
<span><span>}</span></span></pre>
<p>How do these three techniques compare? I wrote a small benchmark <a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2024/06/08">where I scan the HTML of the Google home page</a>. I ran the benchmark on my Apple M2 laptop (LLVM 15).</p>
<table>
<tbody>
<tr>
<th>method</th>
<th>speed</th>
<th>instructions/byte</th>
</tr>
<tr>
<td>naive (scalar)</td>
<td>2.0 GB/s</td>
<td>9.8 instructions/byte</td>
</tr>
<tr>
<td>naive (SIMD)</td>
<td>5.8 GB/s</td>
<td>2.1 instructions/byte</td>
</tr>
<tr>
<td>vectorized classification (2 lookups)</td>
<td>6.0 GB/s</td>
<td>2.0 instructions/byte</td>
</tr>
<tr>
<td>vectorized classification (1 lookup)</td>
<td>6.8 GB/s</td>
<td>1.8 instructions/byte</td>
</tr>
</tbody>
</table>
<p>The results follow my expectations: the simplest vectorized classification routine has the best performance. However, you may observe that even a rather naive SIMD approach can be quite fast in this instance.</p>
<p>If you have an old SSE2 PC, only the simple SIMD approach is available. My results suggest that it might be good enough to get good results.</p>
<p>Daniel Lemire, &#34;Scan HTML faster with SIMD instructions: Chrome edition,&#34; in <em>Daniel Lemire&#39;s blog</em>, June 8, 2024.</p> </div></div>
  </body>
</html>
