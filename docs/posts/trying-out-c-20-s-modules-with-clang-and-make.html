<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://0x1.pt/2023/10/15/trying-out-c&#43;&#43;20s-modules-with-clang-and-make/">Original</a>
    <h1>Trying out C&#43;&#43;20&#39;s modules with Clang and Make</h1>
    
    <div id="readability-page-1" class="page"><div><time datetime="2023-10-15">15/10/2023</time><p>Header files are a relic from the past. No modern programming language has an equivalent concept.</p><p>As far as I know, header files came to be because when C was built disk space was at a prime and storing libraries with their full source code would be expensive. Header files included just the necessary to be able to call into the library while being considerably smaller.</p><p>C++20’s modules are C++’s attempt to do away with header files and implement traditional modules like most programming languages. Both MSVC and GCC implement modules, at least partially, but I usually reach for Clang so let’s give it a try.</p><p>Here’s some annotated source code for a module.</p><div><div><pre><code><span>// mod1.ccm - A module. Notice the extension.</span>

<span>// Needed because we&#39;re importing headers in this module.</span>
<span>module</span><span>;</span>

<span>#include</span> <span>&lt;iostream&gt;</span><span>
</span>
<span>// Export the module with a name that matches the filename.</span>
<span>export</span> <span>module</span> <span>mod1</span><span>;</span>

<span>// Modules are orthogonal to namespaces.</span>
<span>namespace</span> <span>demo</span> <span>{</span>

<span>// We&#39;re exporting this class with the &#39;export&#39; keyword.</span>
<span>export</span> <span>class</span> <span>Printer</span> <span>{</span>
<span>public:</span>
  <span>void</span> <span>Print</span><span>()</span> <span>{</span> <span>std</span><span>::</span><span>cout</span> <span>&lt;&lt;</span> <span>&#34;Hi from the module</span><span>\n</span><span>&#34;</span><span>;</span> <span>}</span>
<span>};</span>

<span>}</span>
</code></pre></div></div><p>And here’s a regular source file that calls the module.</p><div><div><pre><code><span>// main.cc - A regular C++ file</span>

<span>// And here we&#39;re importing the module we defined above.</span>
<span>import</span> <span>mod1</span><span>;</span>

<span>auto</span> <span>main</span><span>()</span> <span>-&gt;</span> <span>int</span> <span>{</span>
  <span>demo</span><span>::</span><span>Printer</span> <span>printer</span><span>;</span>
  <span>printer</span><span>.</span><span>Print</span><span>();</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div><p>Finally, a <code>Makefile</code> to pull both files together.</p><div><div><pre><code><span>CXX</span> <span>:=</span> clang++

<span>CXXFLAGS</span> <span>:=</span> <span>-std</span><span>=</span>c++20 <span>-fprebuilt-module-path</span><span>=</span>.

<span>MODS</span> <span>:=</span> mod1.ccm
<span>SRCS</span> <span>:=</span> main.cc
<span>OBJS</span> <span>:=</span> <span>$(</span>MODS:.ccm<span>=</span>.o<span>)</span> <span>$(</span>SRCS:.cc<span>=</span>.o<span>)</span>

<span>exe</span><span>:</span> <span>$(OBJS)</span>
	<span>$(</span>CXX<span>)</span> <span>-o</span> <span>$@</span> <span>$^</span>

<span>%.o</span><span>:</span> <span>%.ccm</span>
	<span>$(</span>CXX<span>)</span> <span>$(</span>CXXFLAGS<span>)</span> <span>-fmodule-output</span> <span>-c</span> <span>$&lt;</span> <span>-o</span> <span>$@</span>

<span>%.o</span><span>:</span> <span>%.cc</span>
	<span>$(</span>CXX<span>)</span> <span>$(</span>CXXFLAGS<span>)</span> <span>-c</span> <span>$&lt;</span> <span>-o</span> <span>$@</span>
</code></pre></div></div><p>And now let’s compile and run.</p><div><div><pre><code>$ make
clang++ -std=c++20 -fprebuilt-module-path=. -fmodule-output -c mod1.ccm -o mod1.o
clang++ -std=c++20 -fprebuilt-module-path=. -c main.cc -o main.o
clang++ -o exe mod1.o main.o
$ ./exe
Hi from the module
</code></pre></div></div><p>We passed a couple of unfamiliar options to Clang.</p><p>The <code>-fmodule-output</code> option makes it generate a “Built Module Interface” as part of the compilation. This is the <code>*.pcm</code> file you now see in the build directory.</p><p>The <code>-fprebuilt-module-path=.</code> option passes the path to the directory that holds the <code>*.pcm</code> files.</p><hr/><p>Not having to duplicate a bunch of code between header and implementation files is certainly a productivity boost. And not having to deal with <code>#pragma once</code> and include guards is very nice.</p><p>The compilation time for modules seems to be worse that regular translation units. This is to be expected as it’s now generating two files. I do wonder why there’s a need to generate <code>.pcm</code> files. Couldn’t their content be added to the object file in a backwards compatible manner? Still, I wouldn’t be surprised that this improves significantly as this process gets optimized.</p><p>What I think is a bit weird is that we now have modules and namespaces. I sort of expected that we wouldn’t need namespace anymore but it’s not the case. Modules really only handle the “import” part and not the “name disambiguation” part. It would be better if it worked more like Python’s modules.</p><p>Another weird part is that the standard library is currently lacking modules so you need to keep importing headers. MSVC has support for doing <code>import std.core</code> but it’s marked as experimental and doesn’t seem to work on Clang. General support for this is bound to come later.</p><p>Overall, despite these weird bits, C++’s modules are certainly an improvement.</p></div></div>
  </body>
</html>
