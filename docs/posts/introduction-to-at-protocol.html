<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mackuba.eu/2025/08/20/introduction-to-atproto/">Original</a>
    <h1>Introduction to AT Protocol</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Some time ago I wrote a long blog post I called “<a href="https://mackuba.eu/2024/02/21/bluesky-guide/">Complete guide to Bluesky</a>”, which explains how all the user-facing features of Bluesky work and various tips and tricks. This one is meant to be a bit like a developer version of that – I want to explain in hopefully understandable language what all the pieces of the network architecture are and how they all fit together. I hope this will let you understand better how Bluesky and the underlying protocol works, and how it differs from e.g. the Fediverse. This should also be a good starting point if you want to start building some apps or tools on ATProto.</p>

<p>This post is a first part of a series – next I want to look at some comparisons with the Fediverse and some common misconceptions that people have, and look at the state of decentralization of this network, but that was way too much for one post; so this one focuses on the “ATProto intro tutorial” part.</p>

<p>But before we start, a little philosophical aside:</p>


<h2>What is “Bluesky”? Which “Bluesky” are we talking about?</h2>

<p>Discussions about Bluesky sometimes get a little confusing because… “Bluesky” could mean a few different things. Language is hard.</p>

<p>First, we have Bluesky the company, the team. Usually, when people want to clarify that they’re talking about the group of people or the organization, they say “Bluesky PBC” (PBC = Public Benefit Corporation), or “Bluesky team”.</p>

<p>(If you want to read a bit about where Bluesky came from and what’s the current state of the company, read <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#what-is-bluesky">these two sections</a> in the Bluesky Guide blog post.)</p>

<p>And we also have Bluesky the product, the social network, the thing that they’ve built. This network is not a single black box like Twitter or Facebook are (despite what they say about it on Mastodon), it’s more like a set of separate and actually very transparent boxes.</p>

<p>The system they’ve built, of which Bluesky was initially meant to be just a tech demo, is called the <strong>Authenticated Transfer Protocol</strong>, or AT Protocol, or ATProto. Bluesky is built on ATProto, and it is in practice a huge part of what ATProto currently is, which makes the boundary between Bluesky and non-Bluesky a bit hard to define at times, but it’s still only a subset of it.</p>

<p>Bluesky in this second meaning is some nebulous thing that consists of: the data types (“<a href="#lexicons">lexicons</a>”) that are specific to the Bluesky microblogging aspect of ATProto, like Bluesky posts or follows; the APIs for handling them and for accessing other Bluesky-specific features; the rules according to which they all work together; and the whole “social layer” that is created out of all of this, the virtual “place” – the thing that people have in mind when they say “this website”, even when it’s accessed through a mobile app. One of the coolest things about Bluesky &amp; ATProto, in my opinion, is that it connects many different independent pieces into something that still feels like one shared virtual space.</p>

<p>People outside the company can create (and are creating) other such things on ATProto that aren’t necessarily Bluesky-related – see e.g. <a href="https://whtwnd.com">WhiteWind</a> or <a href="https://leaflet.pub">Leaflet</a> (blogging platforms), <a href="https://tangled.sh">Tangled</a> (GitHub alternative), <a href="https://frontpage.fyi">Frontpage</a> (Hacker News style link aggregator), or <a href="https://grain.social">Grain</a> (photo sharing site). They use the same underlying mechanisms that are at the base of ATProto, but use separate data types, have different rules, goals, and UIs. How do we call these things as a whole, the different sets of “data types + rules + required servers + client apps” that define different use cases of the network?</p>

<p>Bluesky team usually calls them “apps”, but I’m not a big fan of this term, because “app” kinda implies a client app, and that’s just one small piece of it. I sometimes call them “services” – though it’s probably not perfect either, since it implies just the server part in turn. Suggestions welcome :) (I’m mentioning this at the beginning, because this is something that many different parts are related to.)</p>

<p>Personally, when I say “the Bluesky app”, I will generally mean the actual client app (mobile / webapp), not the “service”, and when I say “Bluesky-specific”, I will mean the “service”, not the company; and “Bluesky-hosted” will mean run by Bluesky the company. Hopefully in most cases, it can be guessed from context.</p>

<p>BTW, the commonly accepted term for the whole shared “multiverse” of all ATProto apps is “The Atmosphere”, or “ATmosphere” (though I much prefer the former personally, the weird capitalization bugs me somehow ;). It was <a href="https://bsky.app/profile/did:plc:bnqkww7bjxaacajzvu5gswdf/post/3k26nw6kwnh2e">coined</a> by someone from the community, but was accepted by the team and is now mentioned on the <a href="https://atproto.com/guides/glossary#atmosphere">official atproto site</a>.</p>

<hr/>

<p>Let’s start with defining the various building pieces of the protocol:</p>



<h2>Records &amp; blobs</h2>

<p>The most basic piece of the ATProto world is a <strong>record</strong>. Records are basically JSON objects representing the data about a specific entity like a post or profile, organized in a specific way. A post/reply, repost, like, follow, block, list, entry on a list, user profile info – each of these is one record. Most public actions you take on Bluesky, like following someone or liking a post, are performed by creating a record of an appropriate type (or editing/deleting one created before).</p>

<p>For example, this is a <a href="https://shiitake.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:vc7f4oafdgxsihk4cry2xpze&amp;collection=app.bsky.feed.post&amp;rkey=3ltxjiss3is2j">post record</a>. This is one of the <a href="https://lionsmane.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:sflxm2fxohaqpfgahgdlm7rl&amp;collection=app.bsky.feed.like&amp;rkey=3luapblv3vd2i">likes of that post</a>.</p>

<p>Records are stored on disk and transferred between servers in a binary format called <a href="https://cbor.io">CBOR</a>, although in most API endpoints they’re returned in a JSON form (they are equivalent, just different encodings of the same data).</p>

<p>The key thing about records, which has very real consequences for user-facing features, is that you can only create and modify <em>your own</em> records, not those owned by others (and there are no “shared” records at the moment, each record is owned by a specific account). This means that e.g. when you follow someone, you create a follow record on your account, and that other person can’t delete your record, which is why there’s currently no “soft-blocking” feature, i.e. you can’t make someone stop following you (though you can block them). There are workarounds though, as I’ll explain later in the <a href="#appview">AppView section</a>.</p>

<p>This also means that there’s often an unexpected assymetry between seemingly similar actions: for example, getting a list of people followed by person X is very simple (they’re all X’s records, so they’re all in one place), but getting a list of all followers of X is much harder (each record is in a different place!). This is something that the AppView helps with too, as we’ll see later.</p>

<p>A second, complimentary way of storing user data is <strong>blobs</strong>. Blobs are basically binary files, meant mostly for storing media like images and video. For example, here is a direct link to an <a href="https://lab.martianbase.net/xrpc/com.atproto.sync.getBlob?did=did:plc:oio4hkxaop4ao4wz2pp3f4cr&amp;cid=bafkreib7vmhsk7w36bmrlwi2mjgkkoq44xysdahi226re2a76rlmgamgvu">image blob</a> showing a photo of when I started writing this blog post. Blobs are stored on the same server as records, but somewhat separate from them, since it’s a different type of data.</p>



<h2>Lexicons</h2>

<p>Each record belongs to a specific “record type” and stores its data organized in a specific structure, which defines what kinds of fields it can have with what types, what they mean, which are required, and so on – kind of like XML/JSON Schema. This schema definition which describes a given record type is called a <strong>lexicon</strong> in ATProto. (If you’re curious why make a new standard, see threads e.g. <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3juoxe37rez2q">here</a>, <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3kjgebkayik2g">here</a>, or <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3jvf7bakmm22h">here</a>, or <a href="https://www.pfrazee.com/blog/why-not-rdf">this blog post</a>).</p>

<p>A lexicon needs to have an identifier (called <strong>NSID</strong>, Namespace Identifier), which uses the reverse domain name format, e.g. <code>app.bsky.feed.post</code>. All lexicons that are used to store the data of a specific app are usually grouped under the same prefix, e.g. Bluesky lexicons all start with <code>app.bsky</code>.</p>

<p>The structure of a given lexicon’s records is defined in a special JSON file – for example, this file defines the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/feed/post.json">app.bsky.feed.post lexicon</a>. As you can see, this is the place which for example specifies that a post’s text can have at most 300 characters (more specifically, Unicode graphemes). This also means that you can’t create a different server which would make posts longer than 300 characters that would be Bluesky-compatible and displayed on <a href="https://bsky.app">bsky.app</a> – such posts would not pass the validation against the post record schema, and would be rejected by any server or client which performs such validation. Essentially, whover designs and controls the given lexicon, decides what kinds of data it can hold and any constraints on it. In order to store a different, incompatible type of data, you need to create a new lexicon (although you <em>can</em> add additional fields to a record that aren’t defined in its lexicon; many third party apps are doing that, like e.g. <a href="https://github.com/snarfed/bridgy-fed/issues/1092#issuecomment-2164027121">Bridgy Fed</a>).</p>

<p>Lexicon name prefixes generally define boundaries between “apps” as in “services”, and between the “territory” that’s owned by different parties. The lexicons and endpoints defined by Bluesky are defined either under <code>app.bsky.*</code> – these are things specific to Bluesky the microblogging service – or under <code>com.atproto.*</code>, which are things meant to be used by all ATProto apps and services regardless of the use case. There are also a couple of other minor namespaces like <code>chat.bsky.*</code> for the (centralized) DM service, and <code>tools.ozone.*</code> for the open source <a href="https://github.com/bluesky-social/ozone/">Ozone moderation tool</a>.</p>

<p>The lexicon prefix is generally (in most cases) a good way to tell if a piece of the protocol is something Bluesky-specific (specific to the Bluesky service), or something general for all ATProto. There are no record types defined in <code>com.atproto</code>, so things like post, profile, follow are all Bluesky-specific and under <code>app.bsky</code>, as are APIs for e.g. searching users, getting timelines, custom feeds and so on. Meanwhile, <code>com.atproto</code> APIs deal more with things like: info about a repository, fetching a repository, signing up for a new account, refreshing an access token, downloading a blob, etc.</p>

<p>Third party developers and teams building apps on ATProto/Bluesky, which either extend Bluesky’s features or make something completely separate, use their own namespaces for new lexicons, like <code>blue.flashes</code>, <code>social.pinksky</code>, <code>events.smokesignal</code>, <code>sh.tangled</code>, and so on. (There is a lot of nuance to whether you should use your own lexicons or reuse or extend existing ones when building things, and there have been a lot of discussions about it on Bluesky, and even conference talks. A good starting point is <a href="https://www.pfrazee.com/blog/lexicon-guidance">this blog post</a> by Paul Frazee.)</p>



<h2>Identity</h2>

<p>Each user is uniquely identified in the network with their <strong>Decentralized Identifier (DID)</strong>. DIDs are a <a href="https://www.w3.org/TR/did-1.0/">W3C standard</a>, but (as I understand) this standard mostly just defines a framework, and there can be many different “methods” of storing and resolving the identifiers, and each system that uses it can pick or create different types of those DIDs.</p>

<p>The format of a DID is: <code>did:&lt;type&gt;:&lt;…&gt;</code>, where the last part depends on the method. ATProto supports two types of DIDs, but in practice, almost everyone uses one of them, the “plc”. Each DID has a “<strong>DID document</strong>”, a JSON file (<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr">see mine</a>) which describes the account – in ATProto at least, the document includes things such as: the assigned handles, the PDS server hosting the account, and some cryptographic keys.</p>

<p>An important thing to note is that <strong>DIDs are permanent</strong>; it’s the only thing that is permanent about your account, because something has to be. There needs to be some unique ID that all databases everywhere can use to identify you, which doesn’t change, and the DID is that ID. This means that you can’t change a DID of one type into another type later.</p>

<p>The main DID method is <code>did:plc</code>, where IIRC “plc” originally stood for “placeholder” (I think it was meant to be temporary until something better is designed), and was later kind of retconned to mean “<a href="https://github.com/did-method-plc/did-method-plc">Public Ledger of Credentials</a>” 🙃 The DIDs of this type are identified by a random string of characters, which looks like this: <code>did:plc:vc7f4oafdgxsihk4cry2xpze</code>. The DID documents of each DID are stored in a centralized service hosted at <a href="https://plc.directory">plc.directory</a> (Bluesky wants to eventually transfer the ownership to some external non-profit), which basically keeps a key-value store mapping a DID to a JSON file. It also keeps an “<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr/log/audit">audit log</a>” of the previous versions of the document (this means that, for example, the whole history of your old handles is available and you can’t erase it!). There’s also some cryptographic stuff there which, as I understand it, lets anyone verify that everything in the database checks out (don’t ask me how).</p>

<p>The other, rarely used method is <code>did:web</code>. Those DIDs look like this: <code>did:web:witchcraft.systems</code>, and the DID document is stored in a specific <code>.well-known</code> path on the given hostname, in this case <a href="https://witchcraft.systems/.well-known/did.json">witchcraft.systems</a> (yes, that’s an actual TLD ;). It does not store an audit log/history like <code>plc</code> does.</p>

<p>The reason why it’s rarely used and not recommended, is because, first, it’s more complicated to create one (though that’s a solvable problem of course, see a <a href="https://blog.smokesignal.events/posts/3lwopvsmtx22a-creating-a-did-method-web-identity-for-atprotocol">just published guide</a>); but second and more importantly, since DIDs are permanent, this means that your account is permanently bound to that domain. You need to keep it accessible and not let it expire, or you lose the account – you can’t migrate it to <code>did:web:another.site</code> at some point later. It gives you more independence, but at the cost of being tied to that domain you have, and this isn’t a tradeoff that most people are likely to want, and definitely not people who don’t understand what they’re getting into.</p>

<p>If you’re fine with that choice, you can create a <code>did:web</code> account and almost everything in Bluesky and ATProto should work exactly the same. “Almost”, because some services forget to implement that second code path, since it’s so rarely used 😉 but in that case, politely nudging the developer to fix the issue should help in most cases :&gt;</p>



<h4>Handles</h4>

<p>What DIDs enable is that since they act as the unique identifier, your handle doesn’t have to, like it does on the Fediverse. I can be <code>@mackuba.bsky.social</code> one day, <code>@mackuba.eu</code> the next day, and <code>@mackuba.martianbase.net</code> the week after. All existing connections – follows &amp; followers, my posts, likes, blocks, lists I’m on, mentions in posts, etc. all work as before, because they all reference the DID, not the handle. With mentions specifically it works kinda funny, because they use what’s called a “facets” system (see <a href="#facets">later section</a>), where the link target is specified separately from the displayed text. So you can have an old post saying “hey @mackuba.bsky.social”, where the handle in it links to my profile which is now named “@mackuba.eu”. The link still works, because it really links to the DID behind the scenes.</p>

<p>Unlike on the Fediverse, the format of handles is just a hostname, not username + hostname. You assign a whole hostname to a specific account, and if you own any domain name, that can be your username (and if you own a well known domain name, it’s strongly recommended that you do, as a form of self-verification!).</p>

<p>The handle to DID assignment is a two-way link – a DID needs to claim a given handle, and the owner of the domain needs to verify that they own that DID. On the DID side, this happens in the <code>alsoKnownAs</code> field of the DID document (<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr">see here in mine</a>). On the domain side, there are two ways of verifying a handle, depending on what’s more convenient to you: either a DNS TXT entry, or a file on a <code>.well-known</code> path.</p>

<p>You might be wondering how handles like <code>*.bsky.social</code> work – in this case, each such handle is its own domain name, and you can actually enter a domain like <a href="https://aoc.bsky.social">aoc.bsky.social</a> into a browser and it will redirect to a Bluesky profile on <a href="https://bsky.app">bsky.app</a>. Behind the scenes, this is normally handled by having a wildcard domain pointing to one service, which responds to HTTP requests on that <code>.well-known</code> path by returning different DIDs, depending on the domain. That’s not only a <code>bsky.social</code> thing – e.g. there’s now an open Blacksky PDS server which hands out <code>blacksky.social</code> handles, and there are even “handle services” which <em>only</em> give out handles – e.g. you can be <a href="https://swifties.social">yourname.swifties.social</a> if you want ;)</p>

<p>One place where handle changes break things is (some) post URLs on <a href="https://bsky.app">bsky.app</a>. The official web client uses handles by default in permalinks, which means that if you link to a Bluesky post e.g. from a blog post and you change your handle later, that link will no longer work. You can however replace the handle after <code>/profile/</code> with the user’s DID, and the router accepts such links just fine, they just aren’t used by default. So the form you’d want to use when putting links in a blog post or article (like the one you’re reading) would be something like: <a href="https://bsky.app/profile/did:plc:ragtjsm2j2vknwkz3zp4oxrd/post/3llwrsdcdvc2s">https://bsky.app/profile/did:plc:ragtjsm2j2vknwkz3zp4oxrd/post/3llwrsdcdvc2s</a>.</p>



<h2>AT URIs</h2>

<p>Each record can be uniquely addressed with a specific <strong>URI</strong> with the at:// scheme. The format of the URI is:</p>

<pre><code>at://&lt;user_DID&gt;/&lt;lexicon_NSID&gt;/&lt;rkey&gt;
</code></pre>

<p><strong>Rkey</strong> is an identifier of a specific record instance – a usually short alphanumeric string, e.g. Bluesky post rkeys look something like <code>3larljiybf22v</code>. So a complete post URI might look like this: <code>at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.post/3larljiybf22v</code>. You can look up at:// URIs in some record browser tools, e.g. <a href="https://pdsls.dev/at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.post/3larljiybf22v">PDSls</a>.</p>

<p>AT URIs are used for all references between records – quotes, replies, likes, mute list entries, and so on. If you look at <a href="https://morel.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:l3rouwludahu3ui3bt66mfvj&amp;collection=app.bsky.feed.like&amp;rkey=3lwctqgpttm2a">this like record</a>, for example, its <code>subject.uri</code> points to <code>at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3lv2b3f5nys2n</code>, which is the URI of a post record you can see <a href="https://pdsls.dev/at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3lv2b3f5nys2n">here</a>. Since the URIs use DIDs in the first part, handle changes don’t affect such links.</p>



<h2>User repositories</h2>

<p>All user data (records and blobs) is stored in a <strong>repository</strong> (or “repo”). The repository is identified by user’s DID, and stores:</p>

<ul>
<li>records, grouped by lexicon into so-called <strong>collections</strong></li>
<li>blobs (stored separately from records)</li>
<li>authentication data like access tokens, signing keys, hashed passwords etc.</li>
</ul>


<p>Internally, an important part of how the repo stores user records is a data structure called “<a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Search Tree</a>” – but this isn’t something that you need to understand when using the protocol, unless you’re working on a PDS/relay implementation (I haven’t needed to get into it so far).</p>

<p>You can download the records part of your (or anyone else’s!) repo as a bundle called a <a href="https://bsky.app/profile/did:plc:fkasq7xtzrmlvz46c5trkrn3/post/3lkedsoq4vs2d">CAR file</a>, a <a href="https://ipld.io/specs/transport/car/">Content Addressed Archive</a> (fun fact: the icon for the button in the Bluesky app which downloads a repo backup is the shape of a car 🚘).</p>

<p>The cool part is that a repository stores all data of the given user, from *all* lexicons. Including third party developer lexicons. This means that if someone has their account hosted on Bluesky servers, but uses third party ATProto apps like Tangled or Grain, Bluesky lets them store these apps’ records like Grain photos or Tangled pull requests on the same server where it keeps their Bluesky posts. (And yes, of course someone made a <a href="https://github.com/ziodotsh/atfile">lexicon/tool for storing arbitrary files</a> on your Bluesky PDS… and did it in Bash, because why not 🙃)</p>



<h2>XRPC</h2>

<p><strong>XRPC</strong> is the convention used for APIs in the ATProto network. The API endpoints use the same naming convention as lexicon NSIDs, and they have URLs with paths in the format of <code>/xrpc/&lt;nsid&gt;</code>, e.g. <code>/xrpc/app.bsky.feed.getPosts</code>. There are similar <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/feed/getPostThread.json">lexicon definition files</a> which specify what parameters are accepted/required by an endpoint and what types of data are returned in the JSON response. PDSes, AppViews, labellers and feed generators all implement the same kind of API, although with different subsets of specific endpoints. Third party apps don’t <em>have</em> to use the same convention, but it’s generally a good idea, since it integrates better with the rest of the ecosystem.</p>



<h2>Rich text / facets</h2>

<p>This one is kinda Bluesky-specific, but it’s pretty important to understand, and I think you can reuse it for non-Bluesky apps too.</p>

<p>The “<strong>facets</strong>” system is something used for links and possibly rich text in future in Bluesky posts. It’s perhaps a little bit unintuitive at first, but it’s pretty neat and allows for a lot of flexibility.</p>

<p>The way you handle links, mentions, or hashtags, is that they aren’t highlighted automatically, but you need to specifically mark some range of text as a link using the facets. A facet is a marking of some range of the post text (from-to) with a specific kind of link. If you look e.g. at <a href="https://pdsls.dev/at://did:plc:257wekqxg4hyapkq6k47igmp/app.bsky.feed.post/3lnkwu24v5k2j">this post here</a>, you can see that it has a facet marking the byte range 60-67 of the post text as a hashtag “ahoy25”. If there was no facet there, it would just render as normal unlinked text “#ahoy25” in the post (when you see that, it’s an easy tell that a post was made using some custom tool that’s in early stages of development). It works the same way for mention links and normal URL links.</p>

<p>(If you’re curious why they implemented it this way, check out <a href="https://www.pfrazee.com/blog/why-facets">this blog post</a>.)</p>

<p>Note that the displayed text in the marked fragment doesn’t have to match what the facet links to; this means that you can have links that just use some shorter text for the link instead of a part of the URL, in order to fit more text in one post (although in the official app, clicking such link triggers a warning popup first). E.g. some Hacker News bots commonly use this format, see <a href="https://bsky.app/profile/did:plc:7dh44snmqoa4gyzv3652gm3j/post/3lmhylb375m2a">this post</a>. The Bsky app doesn’t let you create such posts directly, but some other clients like <a href="https://skeetdeck.pages.dev/decks/3lpzuhjwlxcns">Skeetdeck</a> do.</p>

<p>Facets are also used for URL shortening – if you just put a long URL in the text of a post made through the API, it will be neither shortened nor highlighted. You need to manually mark it with a facet, and manually shorten the displayed part to whatever length you want.</p>

<p>Likely the most tricky part is that the index numbers you need to use for the ranges are counted on a UTF-8 representation of the text string, but they’re counted in… bytes and not unicode scalars, which most languages index strings in 😅 This is somewhat of an unfortunate tech debt thing as I understand, and it was made this way mostly because of JavaScript, which doesn’t work with UTF-8 natively. But this means you need to be extra careful with the indexes in most languages.</p>

<hr/>

<p>Ok, now that we got through the basic pieces, let’s talk about servers:</p>



<h2>PDS</h2>

<p>The original copy of all user data is stored on a server called <strong>PDS</strong>, Personal Data Server. This is the “source of truth”. A PDS stores one or more user accounts and repos, handles user authentication, and serves as an “entry point” to the network when connecting from a client app. Most network requests from the client are sent to your PDS, although only some of them are handled directly by the PDS, and the rest are proxied e.g. to the AppView. So in a way, your PDS kind of serves as your “user agent” in the network on the backend side of things (beyond the client app), especially if it’s under your control.</p>

<p>Each PDS has an XRPC API with some number of endpoints for things like listing repositories, listing contents of each, looking up a specific record or blob, account authentication and management, and so on. It also has a websocket API called a “<strong>firehose</strong>” (the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/com/atproto/sync/subscribeRepos.json">subscribeRepos endpoint</a>). The firehose streams all changes happening on a given PDS (from all repos) as a stream of “events”, where each event is an addition, edit, or deletion of a record in one of the repos, or some change related to an account, like handle change or deactivation.</p>

<p>One of the most important features of ATProto is that <strong>an account is not permanently assigned to a PDS</strong>. Unlike in ActivityPub, where your identifier is e.g. <code>mackuba@mastodon.social</code> and it can never change, because everything uses that as the unique ID, here the unique ID is the DID. The PDS host is assigned to a user in the DID document JSON (e.g. on <a href="https://plc.directory">plc.directory</a>), but you can migrate to a different PDS at any point, and at the moment there are even some fairly user-friendly tools available for doing that, like <a href="https://atpairport.com">ATP Airport</a> or <a href="https://pdsmoover.com">PDS MOOver</a> (although it’s still a bit unpolished at the moment, and for now you can’t migrate back to Bluesky-hosted PDSes). In theory, you should even be able to migrate to a different PDS if your old PDS is dead or goes rogue, if you have prepared in advance (<a href="https://www.da.vidbuchanan.co.uk/blog/adversarial-pds-migration.html">this is a bit more technical</a>). If everything goes well, nobody even notices that anything has changed (you can’t even easily check in the app what PDS someone is on, although there are external tools for that, like <a href="https://internect.info">internect.info</a>).</p>

<p>Initially, during the limited beta in 2023, Bluesky only had one PDS, <code>bsky.social</code>. In November 2023, several additional PDSes were created (also under Bluesky PBC control) and existing users were quietly all spread to a random one of those. At that point, the network was already “technically federated”, operating in the target architecture, although with access restricted to only Bluesky-run servers. This restriction was lifted in February 2024 with the <a href="https://docs.bsky.app/blog/self-host-federation">public federation launch</a>.</p>

<p>Since then, ATProto enthusiasts started setting setting up PDS servers for themselves, either creating alt/test accounts there, or moving their main accounts. As of August 2025, there around 2000 third party PDS servers, although most of them are very small – usually hosting one person’s main and/or test accounts, and maybe those of a couple of their friends. I have <a href="https://blue.mackuba.eu/directory/pdses">a list of them</a> on my website, and there’s also a more complete list <a href="https://github.com/mary-ext/atproto-scraping">here</a> (mine excludes inactive PDSes and empty accounts).</p>

<p>As you can see there, there’s one massive PDS for <a href="https://fed.brid.gy">Bridgy Fed</a>, the Bluesky-Mastodon bridge service, hosting around 30-40k bridged accounts from the Fediverse, Threads, Nostr, Flipboard, or the web (blogs); then some number of small to medium PDSes for various services, and a very long tail of servers with single-digit number of accounts. At this moment, large public PDS in the style of Fedi instances aren’t much of a thing yet, although there are at least a few communities working on setting up one (e.g. <a href="https://www.blackskyweb.xyz">Blacksky</a>, <a href="https://northskysocial.com">Northsky</a>, or <a href="https://turtleisland.blog/2025/04/28/turtle-island-bluesky-pds/">Turtle Island</a>). Blacksky specifically has <a href="https://bsky.app/profile/did:plc:w4xbfzo7kqfes5zb7r6qv3rw/post/3lvtlqoef5c2z">opened up for migrations</a> just last week and has now a few hundred real accounts.</p>

<p>The vast majority of PDSes at the moment use the <a href="https://github.com/bluesky-social/pds">reference implementation from Bluesky</a> (written in TypeScript), but there are a few alternative implementations at various levels of maturity (Blacksky’s Rudy Fraser’s <a href="https://github.com/blacksky-algorithms/rsky/tree/main/rsky-pds">rsky</a> written in Rust, <a href="https://github.com/haileyok/cocoon">cocoon</a> in Go, or <a href="https://github.com/DavidBuchanan314/millipds">millipds</a> in Python). The official version is very easy to set up and very cheap to run – it’s bundled in Docker, and there’s basically one script you need to run and answer a few questions.</p>

<p>As for the Bluesky-hosted PDSes, the number is currently in high double digits, and each of them hosts a few hundred thousands of accounts (!). And what’s more, they keep the record data in SQLite databases, one per account. And it works really well, go figure. The Bluesky PDSes are all given names of different kinds of mushrooms (like Amanita, Boletus or Shiitake), hence they are often called “mushroom servers”; you can see the full list e.g. <a href="https://status.bsky.app">here</a>. <code>bsky.social</code> was left as a so-called “<strong>entryway server</strong>”, which handles shared authentication for all Bluesky-hosted PDSes (it’s a private piece of Bluesky PBC infrastructure that’s not open source and not needed for independent PDS hosters).</p>



<h2>Relay</h2>

<p>A <strong>relay</strong> is probably the piece of the ATProto architecture that’s most commonly misunderstood by people familiar with other networks like the Fediverse. It doesn’t help that both the Fediverse and Nostr also include servers called “relays”, but they serve a different purpose in each of them:</p>

<ul>
<li>a relay in Nostr is a core piece of the architecture: your posts are uploaded to one or more relays that you have configured and are hosted there, where other users can fetch them from</li>
<li>a relay in the Fediverse is an optional helper service that redistributes posts from some number of instances who have opted in to others, in order to make content more discoverable e.g. on hashtag feeds</li>
</ul>


<p>In ATProto, a relay is a server which combines the firehose streams from all PDSes it knows about into one massive stream that includes every change happening anywhere on the network. Such full-network firehose is then used as the input for many other services, like AppViews, labellers, or feed generators. It serves as a convenient streaming API to get e.g. all posts on the network to process them somehow, or all changes to accounts, or all content in general, from a single place.</p>

<p>Initially, the relay was also expected to keep a complete archive of all the data on the network, from all repos, from the beginning of time. This requirement was later removed in the updates late last year, at least partially triggered by the drastic increase in traffic in November 2024, which overwhelmed Bluesky’s and third party servers for at least a few days. Currently, Bluesky’s and other relays are generally “non-archival”, meaning that they live stream current events (+ a buffer of e.g. last 24 or 36 hours), but don’t keep a full archive of all repos (this change has <a href="https://whtwnd.com/bnewbold.net/3lo7a2a4qxg2l">massive lowered the resource requirements</a> / cost of running a relay, making it much more accessible). An archival relay could always be set up too, but I’m not aware of any currently operating.</p>

<p>Bluesky operates one main relay at <a href="https://bsky.network">bsky.network</a>, which is used as a data source for their AppView and pretty much everyone else in the ATProto ecosystem at the moment (internally, it’s really some kind of “load balancer” using the <a href="https://github.com/bluesky-social/indigo/tree/main/cmd/rainbow">rainbow</a> service, with a few real relay servers behind it).</p>

<p>The relay code is <a href="https://github.com/bluesky-social/indigo/">implemented in Go</a>, and isn’t very hard to get up and running (especially the recent “1.1” update improved things quite a lot). Some people have been running alternative relay services privately for some time, and there is now e.g. a public relay run by Rudy Fraser at <a href="https://atproto.africa">atproto.africa</a> (with a custom implementation in Rust! 🦀), and a couple run by <a href="https://bsky.app/profile/did:plc:hdhoaan3xa3jiuq4fg4mefid/post/3ltkh6bdo4ki5">Phil @bad-example.com</a>. I’m also running <a href="https://relay.feeds.blue">my own small relay</a>, feeding content only from non-Bluesky PDSes.</p>



<h4>Jetstream</h4>

<p>There is also a variant of a relay called <a href="https://github.com/bluesky-social/jetstream">Jetstream</a> – it’s a service that reads from a real CBOR relay and outputs a stream that’s JSON based, better organized, and much more lightweight (the full relay includes a lot of additional data that’s mostly used for cryptographic operations and other low-level stuff). For many simpler tools and services, it might make more sense to stream data from that one instead, if only to save bandwidth. (Bluesky runs a couple of instances listed there in the readme, but you can also run your own.)</p>



<h2>AppView</h2>

<p>The terribly named <strong>AppView</strong> is the second most important piece of the network after the PDS.</p>

<p>The AppView is basically an API server that serves processed data to client apps. It’s an equivalent of an API backend (with the databases behind it) that you’d find on a classic social media site like Twitter. AppView streams all new data written on the network from the relay, and saves a copy of it locally in a processed, aggregated and optimized form. For example, an AppView backed by an SQL database could have a <code>posts</code> table with a <code>text</code> column, a <code>likes</code> table storing all likes with a foreign key <code>post_id</code>, probably also an integer <code>likes_count</code> column in <code>posts</code> for optimization, and so on.</p>

<p>The AppView is designed to be able to easily give information such as:</p>

<ul>
<li>the latest posts from this user</li>
<li>all the replies in a given thread organized in a tree</li>
<li>most recent posts on the network with the hashtag #rubylang or mentioning “iOS 26”</li>
<li>how many likes/reposts has a given post received, and who made them</li>
<li>how many follows/followers does a given user have, and who are they</li>
<li>is user A allowed to view or reply to a post from user B</li>
</ul>


<p>All this data originates from users’ PDSes and has its original copy stored there, but the “raw” record don’t always allow you to access all information easily. For example, to find out how many likes a post has, you need to know all <code>app.bsky.feed.like</code> records referencing it from other users, and each of those like records is stored in the liking user’s repo on that user’s PDS. Same with followers, as I mentioned earlier in the section on records, or with building threads (again, different replies in one thread are hosted in different repos), or for basically any kind of search. So having this kind of API with processed data from the entire network is essential for client apps and various tools and services built around Bluesky by other people.</p>

<p>AppView also applies some additional rules to the data, sometimes overriding what people post into their PDSes, since anyone can technically post anything into their PDS. For example, the AppView prevents you from looking at the profiles of people who have blocked you, at least when you’re logged in. It also hides them from your followers list, even if they have a <code>follow</code> record referencing you, making it seem like they don’t; and if they try to make an <code>app.bsky.feed.post</code> replying to you (they <em>can</em> create such record on their PDS!), it excludes such reply from feeds and threads, as if it never happened. Same goes for “thread gates” which lock access to threads, and so on.</p>

<p>The AppView is one of the few components which <em>aren’t</em> completely open source. Initially, the AppView used Postgres as its data store; <em>that</em> version is still in the public repository. In late 2023, Bluesky has migrated to a “v2” version, which uses the NoSQL database <a href="https://www.scylladb.com">ScyllaDB</a> instead, to be able to handle the massive read traffic from many millions of concurrent users. The upper layer with the “business logic” is kept in the <a href="https://github.com/bluesky-social/atproto/tree/main/packages/bsky">public repository</a>, while the so called “dataplane” layer that interacts directly with Scylla is not. The reason is mostly that it’s built for a specific hardware setup they have and wouldn’t be directly usable by others, while it would add some unnecesary work for the team to publish it. It’s still possible to run the AppView with the <a href="https://github.com/bluesky-social/atproto/tree/main/packages/bsky/src/data-plane">old Postgres-based data layer</a> (and I think the team uses that internally for development), it just can’t handle as much traffic as the current live version.</p>

<p>This is the piece that’s hardest to run yourself, and one that requires the most resources. That said, a private AppView should be possible to run right now for <a href="https://whtwnd.com/futur.blue/3ls7sbvpsqc2w">under $200/month</a> – the biggest requirement is at least a few TB of disk space. The truly costly part is not collecting and storing all this data, but serving it to a huge number of users who would use it as a backend for the client app in daily use. An alternative full-network Bluesky AppView that is used by a few thousands of users shouldn’t be very hard to run, but to be able to serve millions, you’ll need a lot of hardware and something more custom than the Postgres-based version.</p>

<p>There have also been some attempts at alternative implementations – the most advanced right now is <a href="https://github.com/alnkesq/AppViewLite">AppViewLite</a>, built in C#, which goes to great lengths to minimize the resource use.</p>



<h4>CDN</h4>

<p>A part of the AppView (at least the Bluesky one) is also a CDN for serving images &amp; videos. The API responses from e.g. <code>getTimeline</code> or <code>getPostThread</code> generally include links to any media on the Bluesky CDN hostname, not directly on the PDS, even though you <em>can</em> fetch every blob from the PDS, since that’s the “source of truth” (although IIRC the Bluesky PDS implementation doesn’t set the CORS headers there). It’s recommended to access any media this way in order to not use too much bandwidth from the PDS.</p>



<h2>Labellers</h2>

<p>(Or “labelers” officially, but I like the British spelling more here, sue me ¯\_(ツ)_/¯)</p>

<p>We’re now getting to more Bluesky specific things (i.e. specific for the Bluesky-service, although some parts of it are ATProto-general and mentioned on the <a href="https://atproto.com/specs/label">atproto.com site</a>).</p>

<p>A <strong>labeller</strong> is a moderation service for Bluesky (or other ATProto app), which can be run by third parties. Labellers emit labels, which are assigned to an account or a record (like a post). Each labeller defines its own set of labels, depending on what it’s focusing on; then, users can “subscribe” to a labeller and choose how they want to handle the labels it assigns: you can hide the labelled posts/users, mark them with a warning badge, or ignore given label.</p>

<p>Labellers were initially designed to just do community moderation of unwanted content, e.g. you can have a service focused on fighting racism, transphobia, or right-wing extremism, and that service helps protect its users from some kinds of bad actors; or you can have one marking e.g. posts with political content, users who follow 20k accounts, or who post way too many hashtags. In practice, many <a href="https://blue.mackuba.eu/labellers/">existing labellers</a> are meant for self-labelling instead, letting you assign e.g. a country flag or some fun things like a D&amp;D character class to yourself.</p>

<p>The way it works technically is:</p>

<ul>
<li>a labeller either runs a firehose client pulling posts from the relay, or relies on reports from users and/or its operating team (usually using the <a href="https://github.com/bluesky-social/ozone/">Ozone tool</a> for that)</li>
<li>labels, which are lightweight objects (<em>not</em> ATProto records) are emitted from labeller’s special firehose stream (the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/com/atproto/label/subscribeLabels.json">subscribeLabels endpoint</a>)</li>
<li>the AppView listens to the label firehoses of all labellers it knows about, in addition to the relay stream, and records all received labels in its database</li>
<li>when a logged in user pulls data like threads or timelines from the AppView, it adds relevant label info to the responses depending on which labellers the user follows</li>
<li>the specific list of labellers whose labels should be applied is passed explicitly in API requests in the <code>atproto-accept-labelers</code> header (there is a “soft” limit of 20 labellers you can pass at a time, which is why the official app won’t let you subscribe to more)</li>
<li>in the official app, Bluesky’s official moderation service (which is “just” another labeller) is hardcoded as one of those 20 and you can’t turn it off; when connecting from your own app or tool, you’re free to ignore it if you want</li>
</ul>


<p>(Read more about labellers <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#labellers">here</a>.)</p>



<h2>Feed generators</h2>

<p><a href="https://mackuba.eu/2024/02/21/bluesky-guide/#feeds">Custom feeds</a> are one of the coolest features of Bluesky. They let you create any kind of feed using any algorithm and let everyone on the platform use it (even as the default feed, if they want to).</p>

<p>The way this system works is that you need to run a “<strong>feed generator</strong>” service on your server. In that service, you expose an API that the AppView can call, which returns a list of post at:// URIs selected by you however you want in response to a given request.</p>

<p>A minimal feed service can be pretty simple – the API is just three endpoints, two of which are static, and the third returns the post URIs. One “small” problem is that in order to return the post URIs, you need to have some info about posts stored up front, which in practice means that you almost always need to connect to a relay’s firehose stream and store some post data (of selected or all posts, depending on your use case).</p>

<p>The flow is like this:</p>

<ul>
<li>a feed record is uploaded to your repo, including metadata and location of the feed generator service, which lets other users find your feed</li>
<li>when the user opens that feed in the app, the AppView makes a request to your service on their behalf</li>
<li>your service looks at the request params and headers, and returns a list of posts it selected in the form of at:// URIs</li>
<li>the AppView takes those URIs and maps them to full posts (so-called “hydration”), which it returns to the user’s app</li>
</ul>


<p>How exactly those posts are selected to be returned in the given request is completely up to you, the only requirement is that these are posts that the AppView will have in its database, since you only send URIs, not actual post data. In most cases, feeds use some kind of keyword/regexp matching and chronological ordering, but you can even build very complex, AI-driven algorithmic “For You” style personalized feeds.</p>

<p>You don’t necessarily have to code a feed service yourself and host it in order to have a custom feed – there are a few feed hosting services that don’t require technical knowledge to use, like <a href="https://skyfeed.app">SkyFeed</a> or <a href="https://www.graze.social">Graze</a>.</p>



<h2>Client apps</h2>

<p>Ok, that’s technically not a server, but stay with me…</p>

<p>The final piece that you need to fully enjoy Bluesky is the client app – a mobile/desktop one or a web frontend. Unlike on Fedi, where an instance software like Mastodon usually includes a built-in web frontend that is your main interface for accessing the service, the PDS doesn’t include anything like that, just a database and an API (which also means it’s much more lightweight and needs less resources). All browsing is done through a separate client, and the client always does everything through the public API – kind of like when you run a custom web client for Mastodon like <a href="https://elk.zone">Elk</a> or <a href="https://phanpy.social">Phanpy</a>, you connect it to your instance, and you view your timeline on <a href="https://elk.zone">elk.zone</a>.</p>

<p>So when you go to <a href="https://bsky.app">bsky.app</a>, that’s what you’re seeing – a web client that connects to your PDS (Bluesky-hosted or self-hosted) through the public API, no more, no less. The official app is built for both mobile platforms and for the web from a single React Native codebase (apparently React Native on the web and normal web React is not the same thing 🧐). This has allowed the still very small frontend team (and IIRC at first it was literally just Paul) to build the app for three platforms in any reasonable amount of time and maintain it going forward. The downside is that it’s kinda neither a great webapp nor a great mobile app… But the team is doing what they can to improve it, and it’s already much better than it used to be, and tbh more than good enough for me.</p>

<p>There aren’t nearly as many alternative clients as there are for Mastodon, and none of them are <em>really</em> great, but there are a few options; see the <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#apps">apps part of my Bluesky Guide</a> blog post for links.</p>



<h2>DMs</h2>

<p>Notice that I haven’t mentioned DMs anywhere – that’s because they aren’t a part of the protocol at the moment. The Bluesky team wants to eventually add some properly implemented, end-to-end encrypted, secure DMs using some open standard, but they won’t be able to finish that in the short term, and a lot of people were asking for at least some simple version of DMs in the app. So they’ve decided as an interim solution to implement them as a fully centralized, closed source service. It is accessible to third-party Bluesky clients through the API (the <code>chat.bsky.*</code> namespace), but it’s not something you can run yourself. The team is <a href="https://bsky.app/profile/did:plc:44ybard66vv44zksje25o7dz/post/3lacrutxhio2h">very open</a> about the fact that it’s not a proper replacement for something like Signal, and that for sensitive communication, you should ideally just use it for swapping contacts on Signal on iMessage and move the conversation there. They also kinda don’t want to spend too much time adding features there, because it’s considered a temporary solution, so it’s pretty basic in terms of available features.</p>

<p>There are also a few other closed-source helper services, like the “cardyb” they use for generating link card details, or the video service for preprocessing videos, but they’re all specific to some Bluesky use cases only and not strictly necessary to use.</p>

<hr/>



<h2>How it all fits together</h2>

<p>So the flow and hierarchy is like this:</p>

<ul>
<li>the <strong>client app</strong> you use creates new records as a result of actions you take (new posts, likes, follows), and saves them into your PDS</li>
<li>your <strong>PDS</strong> emits events on its firehose with the record details</li>
<li>Bluesky <strong>relay</strong> and other relays are connected to the firehoses of each PDS they know about (your PDS generally needs to ask them to connect using the <code>PDS_CRAWLERS</code> ENV variable), and they pass those events to their output firehose</li>
<li>the Bluesky <strong>AppView</strong> (and other AppViews) listen to the firehose of their selected relay (though it could be multiple relays, or it could even just stream directly from PDSes, but in practice this will normally be one trusted relay)</li>
<li>the AppView gets events including your records, and if they are relevant, saves the data to its internal database in some appropriate representations</li>
<li>when other users browse Bluesky in their client apps, they load timelines, feeds and threads from the AppView, which returns info about your post from that database it saved it to</li>
</ul>


<p>Additionally:</p>

<ul>
<li><strong>feed generators</strong> run by third party feed operators also stream data from Bluesky’s or some other relay and save it locally, so they can respond to feed requests from the AppView</li>
<li><strong>labellers</strong> also stream data from Bluesky’s or some other relay, and emit labels on their firehoses, which get sent to the AppView (note: there is no official “labeller relay” sitting between labellers and the AppView, although one third party dev <a href="https://bsky.app/profile/did:plc:w4xbfzo7kqfes5zb7r6qv3rw/post/3lrgs3itqyc2q">wrote one</a>)</li>
</ul>


<p>Note:</p>

<ul>
<li>PDSes <strong>do not connect to each other directly</strong>, and they don’t store posts of users from other PDSes, only their own</li>
<li>although right now basically everyone uses the Bluesky relay and AppView, anyone <em>can</em> set up their own alternative relays and AppViews, which feed from all or any subset of known PDSes</li>
<li>PDS chooses which relays to ask to connect, but relays can also connect by themselves to a PDS or another relay; AppView chooses which relay(s) it streams data from; and PDS chooses which AppView it loads timelines &amp; threads from</li>
<li>it’s absolutely possible and expected that two users using different PDSes, which use separate AppViews feeding from separate relays will be able to talk to each other and see each other’s responses on their own AppView, as long as the users aren’t banned on the other user’s infrastructure</li>
</ul>


<p>The metaphor that’s often used to describe these relationship is that PDSes are like websites which publish some blog posts, and relays &amp; AppViews are like search engines which crawl and index the web, and then let you look up results in them. In most cases, a website should be indexed and visible in all/most available search engines.</p>

<hr/>



<h2>Where to go next</h2>

<p>And that’s about it – I think with the above, you should have a pretty good grasp of the big picture of ATProto architecture and all the specific parts of it. Now, if you want to start playing with the protocol and building some things on it, a lot will depend on what specifically you want to build and using what languages/technologies:</p>



<h4>SDKs:</h4>

<p>Two languages are officially supported by Bluesky:</p>

<ul>
<li>JavaScript/TypeScript, in which most of their code is written (see the <a href="https://github.com/bluesky-social/atproto/tree/main/packages">packages folder</a> in the <code>atproto</code> repo)</li>
<li>Go, which is used in some backend pieces like the relay, or the <a href="https://github.com/bluesky-social/goat">goat</a> command line tool used e.g. for PDS migrations (see the <a href="https://github.com/bluesky-social/indigo"><code>indigo</code> repo</a>)</li>
</ul>


<p>For Python, there is a <a href="https://atproto.blue">pretty full-featured SDK created by Marshal</a>, which is the only third party SDK <a href="https://atproto.com/sdks">officially endorsed</a> by the Bluesky team.</p>

<p>For other languages, I have a website called <a href="https://sdk.blue">sdk.blue</a>, which lists all libraries and SDKs I know about, grouped by language. As you can see, there is something there for most major languages; I’ve built and maintain a group of <a href="https://sdk.blue/#ruby">Ruby gems</a> myself. If you want to use a language that doesn’t have any libraries yet, it’s really not that hard to make one from scratch – for most things you just need an HTTP client and a JSON parser, and maybe a websocket client.</p>



<h4>Docs:</h4>

<p>There is quite a lot of official documentation, although it’s a bit spread out and sometimes not easy to find.</p>

<p>The places to look in are:</p>

<ul>
<li><a href="https://atproto.com">atproto.com</a> – the official AT Protocol website; a bit more formal documentation about the elements of the protocol, kind of like what I did here, but with much more info and detailed specifications of each thing</li>
<li><a href="https://docs.bsky.app/docs/get-started">docs.bsky.app</a> – more practical documentation with guides and examples of specific use cases in TS &amp; Python (roll down the sections in the sidebar); it shows examples of how to make a post, upload a video, how to connect to the firehose, how to make a custom feed, etc.</li>
<li><a href="https://docs.bsky.app/blog">docs.bsky.app/blog</a> – developer blog with updates about protocol changes</li>
<li><a href="https://docs.bsky.app/docs/category/http-reference">HTTP reference</a> – a reference of all the API endpoints</li>
<li>something that I also find useful is to have the <a href="https://github.com/bluesky-social/atproto">atproto repo</a> checked out locally and opened in the editor, and look things up in the JSON files from the <a href="https://github.com/bluesky-social/atproto/tree/main/lexicons">/lexicons folder</a></li>
</ul>


<p>And a few other articles that might work better for you:</p>

<ul>
<li>“<a href="https://atproto.com/articles/atproto-for-distsys-engineers">ATProto for distributed systems engineers</a>”, Bluesky’s technical overview of the server and data flow architecture</li>
<li>“<a href="https://atproto.com/articles/atproto-ethos">ATProto Ethos</a>”, also on the Bluesky blog, based on a conference talk</li>
<li>“<a href="https://steveklabnik.com/writing/how-does-bluesky-work/">How Does BlueSky Work?</a>”, by Steve Klabnik (of Ruby &amp; Rust fame) (Feb 2024)</li>
<li>the “<a href="https://atproto.com/guides/applications">Statusphere</a>” app example on atproto.com</li>
</ul>




<h4>Community:</h4>

<p>Someone said recently that “<em>bsky replies are the only real documentation for ATProto</em>”, and honestly, they’re not wrong. We have a great community of third party developers now, building their own tools, apps, libraries, services, even organizing <a href="https://ahoy.eu">conferences</a>. If you’re starting out and you have any questions, just ask and someone will probably help, and some of the Bluesky team developers are also very active in Bluesky threads, answering questions and clarifying things. So a lot of such knowledge that’s not necessarily found in the official docs can be found somewhere on Bluesky.</p>

<p>The two places I recommend looking at are:</p>

<ul>
<li>the “ATProto Touchers” Discord chat – ping me or some other developer for an invite :)</li>
<li>my <a href="https://bsky.app/profile/did:plc:oio4hkxaop4ao4wz2pp3f4cr/feed/atproto">ATProto feed</a> on Bluesky, which tries to catch any ATProto development discussions – it should include posts with any mention of “ATProto” or things like “AppView” or various API names and technical terms, or you can use <code>#atproto</code> or <code>#atdev</code> hashtag to be sure</li>
</ul>


<p>Also, there’s a fantastic newsletter called <a href="https://connectedplaces.online">Connected Places</a> (formerly Fediverse Report) by Laurens Hof, who publishes two separate editions every week, about what’s happening in Bluesky/ATProto and in the Fediverse (and *a lot* of things are happening).</p>



<h4>Ideas:</h4>

<p>Some easy ways to start tinkering:</p>

<ul>
<li>use one of the <a href="https://sdk.blue">existing libraries for your favorite language</a> and make a website or command-line tool which loads some data from the AppView or PDS: load and print timelines, calculate statistics, browse contents of PDSes and repos, etc.</li>
<li>make a bot that posts something (not spammy!)</li>
<li>make a simple custom feed service using <a href="https://docs.bsky.app/docs/starter-templates/custom-feeds">one of the available templates</a></li>
<li>connect to the relay firehose and print or record some specific types of data</li>
</ul>




<h4>Tools:</h4>

<p>And a couple of tools which will certainly be useful in development:</p>

<ul>
<li><a href="https://internect.info">internect.info</a> – look up an account by handle/DID and see details like assigned PDS or handle history</li>
<li><a href="https://pdsls.dev">PDSls</a> – PDS and repository browser, lets you look up repos by account DID or records by at:// URI (there are a few others, but this one is most popular)</li>
</ul>


  </div></div>
  </body>
</html>
