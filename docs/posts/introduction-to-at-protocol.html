<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mackuba.eu/2025/08/20/introduction-to-atproto/">Original</a>
    <h1>Introduction to AT Protocol</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Some time ago IÂ wrote a long blog post IÂ called â€œ<a href="https://mackuba.eu/2024/02/21/bluesky-guide/">Complete guide to Bluesky</a>â€, which explains how all the user-facing features of Bluesky work and various tips and tricks. This one is meant to be a bit like a developer version of that â€“ IÂ want to explain in hopefully understandable language what all the pieces of the network architecture are and how they all fit together. IÂ hope this will let you understand better how Bluesky and the underlying protocol works, and how it differs from e.g. the Fediverse. This should also be a good starting point if you want to start building some apps or tools on ATProto.</p>

<p>This post is a first part of a series â€“ next IÂ want to look at some comparisons with the Fediverse and some common misconceptions that people have, and look at the state of decentralization of this network, but that was way too much for one post; so this one focuses on the â€œATProto intro tutorialâ€ part.</p>

<p>But before we start, a little philosophical aside:</p>


<h2>What is â€œBlueskyâ€? Which â€œBlueskyâ€ are we talking about?</h2>

<p>Discussions about Bluesky sometimes get a little confusing becauseâ€¦ â€œBlueskyâ€ could mean a few different things. Language is hard.</p>

<p>First, we have Bluesky the company, the team. Usually, when people want to clarify that theyâ€™re talking about the group of people or the organization, they say â€œBluesky PBCâ€ (PBC = Public Benefit Corporation), or â€œBluesky teamâ€.</p>

<p>(If you want to read a bit about where Bluesky came from and whatâ€™s the current state of the company, read <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#what-is-bluesky">these two sections</a> in the Bluesky Guide blog post.)</p>

<p>And we also have Bluesky the product, the social network, the thing that theyâ€™ve built. This network is not a single black box like Twitter or Facebook are (despite what they say about it on Mastodon), itâ€™s more like a set of separate and actually very transparent boxes.</p>

<p>The system theyâ€™ve built, of which Bluesky was initially meant to be just a tech demo, is called the <strong>Authenticated Transfer Protocol</strong>, or AT Protocol, or ATProto. Bluesky is built on ATProto, and it is in practice a huge part of what ATProto currently is, which makes the boundary between Bluesky and non-Bluesky a bit hard to define at times, but itâ€™s still only a subset of it.</p>

<p>Bluesky in this second meaning is some nebulous thing that consists of: the data types (â€œ<a href="#lexicons">lexicons</a>â€) that are specific to the Bluesky microblogging aspect of ATProto, like Bluesky posts or follows; the APIs for handling them and for accessing other Bluesky-specific features; the rules according to which they all work together; and the whole â€œsocial layerâ€ that is created out of all of this, the virtual â€œplaceâ€ â€“ the thing that people have in mind when they say â€œthis websiteâ€, even when itâ€™s accessed through a mobile app. One of the coolest things about Bluesky &amp; ATProto, in my opinion, is that it connects many different independent pieces into something that still feels like one shared virtual space.</p>

<p>People outside the company can create (and are creating) other such things on ATProto that arenâ€™t necessarily Bluesky-related â€“ see e.g. <a href="https://whtwnd.com">WhiteWind</a> or <a href="https://leaflet.pub">Leaflet</a> (blogging platforms), <a href="https://tangled.sh">Tangled</a> (GitHub alternative), <a href="https://frontpage.fyi">Frontpage</a> (Hacker News style link aggregator), or <a href="https://grain.social">Grain</a> (photo sharing site). They use the same underlying mechanisms that are at the base of ATProto, but use separate data types, have different rules, goals, and UIs. How do we call these things as a whole, the different sets of â€œdata types + rules + required servers + client appsâ€ that define different use cases of the network?</p>

<p>Bluesky team usually calls them â€œappsâ€, but Iâ€™m not a big fan of this term, because â€œappâ€ kinda implies a client app, and thatâ€™s just one small piece of it. IÂ sometimes call them â€œservicesâ€ â€“ though itâ€™s probably not perfect either, since it implies just the server part in turn. Suggestions welcomeÂ :) (Iâ€™m mentioning this at the beginning, because this is something that many different parts are related to.)</p>

<p>Personally, when IÂ say â€œthe Bluesky appâ€, IÂ will generally mean the actual client app (mobile / webapp), not the â€œserviceâ€, and when IÂ say â€œBluesky-specificâ€, IÂ will mean the â€œserviceâ€, not the company; and â€œBluesky-hostedâ€ will mean run by Bluesky the company. Hopefully in most cases, it can be guessed from context.</p>

<p>BTW, the commonly accepted term for the whole shared â€œmultiverseâ€ of all ATProto apps is â€œTheÂ Atmosphereâ€, or â€œATmosphereâ€ (though IÂ much prefer the former personally, the weird capitalization bugs me somehowÂ ;). It was <a href="https://bsky.app/profile/did:plc:bnqkww7bjxaacajzvu5gswdf/post/3k26nw6kwnh2e">coined</a> by someone from the community, but was accepted by the team and is now mentioned on the <a href="https://atproto.com/guides/glossary#atmosphere">official atproto site</a>.</p>

<hr/>

<p>Letâ€™s start with defining the various building pieces of the protocol:</p>



<h2>Records &amp; blobs</h2>

<p>The most basic piece of the ATProto world is a <strong>record</strong>. Records are basically JSON objects representing the data about a specific entity like a post or profile, organized in a specific way. A post/reply, repost, like, follow, block, list, entry on a list, user profile info â€“ each of these is one record. Most public actions you take on Bluesky, like following someone or liking a post, are performed by creating a record of an appropriate type (or editing/deleting one created before).</p>

<p>For example, this is a <a href="https://shiitake.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:vc7f4oafdgxsihk4cry2xpze&amp;collection=app.bsky.feed.post&amp;rkey=3ltxjiss3is2j">post record</a>. This is one of the <a href="https://lionsmane.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:sflxm2fxohaqpfgahgdlm7rl&amp;collection=app.bsky.feed.like&amp;rkey=3luapblv3vd2i">likes of that post</a>.</p>

<p>Records are stored on disk and transferred between servers in a binary format called <a href="https://cbor.io">CBOR</a>, although in most APIÂ endpoints theyâ€™re returned in a JSON form (they are equivalent, just different encodings of the same data).</p>

<p>The key thing about records, which has very real consequences for user-facing features, is that you can only create and modify <em>your own</em> records, not those owned by others (and there are no â€œsharedâ€ records at the moment, each record is owned by a specific account). This means that e.g. when you follow someone, you create a follow record on your account, and that other person canâ€™t delete your record, which is why thereâ€™s currently no â€œsoft-blockingâ€ feature, i.e. you canâ€™t make someone stop following you (though you can block them). There are workarounds though, as Iâ€™ll explain later in the <a href="#appview">AppView section</a>.</p>

<p>This also means that thereâ€™s often an unexpected assymetry between seemingly similar actions: for example, getting a list of people followed by person X is very simple (theyâ€™re all Xâ€™s records, so theyâ€™re all in one place), but getting a list of all followers of X is much harder (each record is in a different place!). This is something that the AppView helps with too, as weâ€™ll see later.</p>

<p>A second, complimentary way of storing user data is <strong>blobs</strong>. Blobs are basically binary files, meant mostly for storing media like images and video. For example, here is a direct link to an <a href="https://lab.martianbase.net/xrpc/com.atproto.sync.getBlob?did=did:plc:oio4hkxaop4ao4wz2pp3f4cr&amp;cid=bafkreib7vmhsk7w36bmrlwi2mjgkkoq44xysdahi226re2a76rlmgamgvu">image blob</a> showing a photo of when IÂ started writing this blog post. Blobs are stored on the same server as records, but somewhat separate from them, since itâ€™s a different type of data.</p>



<h2>Lexicons</h2>

<p>Each record belongs to a specific â€œrecord typeâ€ and stores its data organized in a specific structure, which defines what kinds of fields it can have with what types, what they mean, which are required, and so on â€“ kind of like XML/JSON Schema. This schema definition which describes a given record type is called a <strong>lexicon</strong> in ATProto. (If youâ€™re curious why make a new standard, see threads e.g. <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3juoxe37rez2q">here</a>, <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3kjgebkayik2g">here</a>, or <a href="https://blue.mackuba.eu/skythread/?author=did:plc:ragtjsm2j2vknwkz3zp4oxrd&amp;post=3jvf7bakmm22h">here</a>, or <a href="https://www.pfrazee.com/blog/why-not-rdf">this blog post</a>).</p>

<p>A lexicon needs to have an identifier (called <strong>NSID</strong>, Namespace Identifier), which uses the reverse domain name format, e.g. <code>app.bsky.feed.post</code>. All lexicons that are used to store the data of a specific app are usually grouped under the same prefix, e.g. Bluesky lexicons all start with <code>app.bsky</code>.</p>

<p>The structure of a given lexiconâ€™s records is defined in a special JSON file â€“ for example, this file defines the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/feed/post.json">app.bsky.feed.post lexicon</a>. As you can see, this is the place which for example specifies that a postâ€™s text can have at most 300 characters (more specifically, Unicode graphemes). This also means that you canâ€™t create a different server which would make posts longer than 300 characters that would be Bluesky-compatible and displayed on <a href="https://bsky.app">bsky.app</a> â€“ such posts would not pass the validation against the post record schema, and would be rejected by any server or client which performs such validation. Essentially, whover designs and controls the given lexicon, decides what kinds of data it can hold and any constraints on it. In order to store a different, incompatible type of data, you need to create a new lexicon (although you <em>can</em> add additional fields to a record that arenâ€™t defined in its lexicon; many third party apps are doing that, like e.g. <a href="https://github.com/snarfed/bridgy-fed/issues/1092#issuecomment-2164027121">Bridgy Fed</a>).</p>

<p>Lexicon name prefixes generally define boundaries between â€œappsâ€ as in â€œservicesâ€, and between the â€œterritoryâ€ thatâ€™s owned by different parties. The lexicons and endpoints defined by Bluesky are defined either under <code>app.bsky.*</code> â€“ these are things specific to Bluesky the microblogging service â€“ or under <code>com.atproto.*</code>, which are things meant to be used by all ATProto apps and services regardless of the use case. There are also a couple of other minor namespaces like <code>chat.bsky.*</code> for the (centralized) DM service, and <code>tools.ozone.*</code> for the open source <a href="https://github.com/bluesky-social/ozone/">Ozone moderation tool</a>.</p>

<p>The lexicon prefix is generally (in most cases) a good way to tell if a piece of the protocol is something Bluesky-specific (specific to the Bluesky service), or something general for all ATProto. There are no record types defined in <code>com.atproto</code>, so things like post, profile, follow are all Bluesky-specific and under <code>app.bsky</code>, as are APIs for e.g. searching users, getting timelines, custom feeds and so on. Meanwhile, <code>com.atproto</code> APIs deal more with things like: info about a repository, fetching a repository, signing up for a new account, refreshing an access token, downloading a blob, etc.</p>

<p>Third party developers and teams building apps on ATProto/Bluesky, which either extend Blueskyâ€™s features or make something completely separate, use their own namespaces for new lexicons, like <code>blue.flashes</code>, <code>social.pinksky</code>, <code>events.smokesignal</code>, <code>sh.tangled</code>, and so on. (There is a lot of nuance to whether you should use your own lexicons or reuse or extend existing ones when building things, and there have been a lot of discussions about it on Bluesky, and even conference talks. A good starting point is <a href="https://www.pfrazee.com/blog/lexicon-guidance">this blog post</a> by Paul Frazee.)</p>



<h2>Identity</h2>

<p>Each user is uniquely identified in the network with their <strong>Decentralized Identifier (DID)</strong>. DIDs are a <a href="https://www.w3.org/TR/did-1.0/">W3C standard</a>, but (as IÂ understand) this standard mostly just defines a framework, and there can be many different â€œmethodsâ€ of storing and resolving the identifiers, and each system that uses it can pick or create different types of those DIDs.</p>

<p>The format of a DID is: <code>did:&lt;type&gt;:&lt;â€¦&gt;</code>, where the last part depends on the method. ATProto supports two types of DIDs, but in practice, almost everyone uses one of them, the â€œplcâ€. Each DID has a â€œ<strong>DID document</strong>â€, a JSON file (<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr">see mine</a>) which describes the account â€“ in ATProto at least, the document includes things such as: the assigned handles, the PDS server hosting the account, and some cryptographic keys.</p>

<p>An important thing to note is that <strong>DIDs are permanent</strong>; itâ€™s the only thing that is permanent about your account, because something has to be. There needs to be some unique ID that all databases everywhere can use to identify you, which doesnâ€™t change, and the DID is that ID. This means that you canâ€™t change a DID of one type into another type later.</p>

<p>The main DID method is <code>did:plc</code>, where IIRC â€œplcâ€ originally stood for â€œplaceholderâ€ (IÂ think it was meant to be temporary until something better is designed), and was later kind of retconned to mean â€œ<a href="https://github.com/did-method-plc/did-method-plc">Public Ledger of Credentials</a>â€ ğŸ™ƒ The DIDs of this type are identified by a random string of characters, which looks like this: <code>did:plc:vc7f4oafdgxsihk4cry2xpze</code>. The DID documents of each DID are stored in a centralized service hosted at <a href="https://plc.directory">plc.directory</a> (Bluesky wants to eventually transfer the ownership to some external non-profit), which basically keeps a key-value store mapping a DID to a JSON file. It also keeps an â€œ<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr/log/audit">audit log</a>â€ of the previous versions of the document (this means that, for example, the whole history of your old handles is available and you canâ€™t erase it!). Thereâ€™s also some cryptographic stuff there which, as IÂ understand it, lets anyone verify that everything in the database checks out (donâ€™t ask me how).</p>

<p>The other, rarely used method is <code>did:web</code>. Those DIDs look like this: <code>did:web:witchcraft.systems</code>, and the DID document is stored in a specific <code>.well-known</code> path on the given hostname, in this case <a href="https://witchcraft.systems/.well-known/did.json">witchcraft.systems</a> (yes, thatâ€™s an actual TLDÂ ;). It does not store an audit log/history like <code>plc</code> does.</p>

<p>The reason why itâ€™s rarely used and not recommended, is because, first, itâ€™s more complicated to create one (though thatâ€™s a solvable problem of course, see a <a href="https://blog.smokesignal.events/posts/3lwopvsmtx22a-creating-a-did-method-web-identity-for-atprotocol">just published guide</a>); but second and more importantly, since DIDs are permanent, this means that your account is permanently bound to that domain. You need to keep it accessible and not let it expire, or you lose the account â€“ you canâ€™t migrate it to <code>did:web:another.site</code> at some point later. It gives you more independence, but at the cost of being tied to that domain you have, and this isnâ€™t a tradeoff that most people are likely to want, and definitely not people who donâ€™t understand what theyâ€™re getting into.</p>

<p>If youâ€™re fine with that choice, you can create a <code>did:web</code> account and almost everything in Bluesky and ATProto should work exactly the same. â€œAlmostâ€, because some services forget to implement that second code path, since itâ€™s so rarely used ğŸ˜‰ but in that case, politely nudging the developer to fix the issue should help in most casesÂ :&gt;</p>



<h4>Handles</h4>

<p>What DIDs enable is that since they act as the unique identifier, your handle doesnâ€™t have to, like it does on the Fediverse. IÂ can be <code>@mackuba.bsky.social</code> one day, <code>@mackuba.eu</code> the next day, and <code>@mackuba.martianbase.net</code> the week after. All existing connections â€“ follows &amp; followers, my posts, likes, blocks, lists Iâ€™m on, mentions in posts, etc. all work as before, because they all reference the DID, not the handle. With mentions specifically it works kinda funny, because they use whatâ€™s called a â€œfacetsâ€ system (see <a href="#facets">later section</a>), where the link target is specified separately from the displayed text. So you can have an old post saying â€œhey @mackuba.bsky.socialâ€, where the handle in it links to my profile which is now named â€œ@mackuba.euâ€. The link still works, because it really links to the DID behind the scenes.</p>

<p>Unlike on the Fediverse, the format of handles is just a hostname, not username + hostname. You assign a whole hostname to a specific account, and if you own any domain name, that can be your username (and if you own a well known domain name, itâ€™s strongly recommended that you do, as a form of self-verification!).</p>

<p>The handle to DID assignment is a two-way link â€“ a DID needs to claim a given handle, and the owner of the domain needs to verify that they own that DID. On the DID side, this happens in the <code>alsoKnownAs</code> field of the DID document (<a href="https://plc.directory/did:plc:oio4hkxaop4ao4wz2pp3f4cr">see here in mine</a>). On the domain side, there are two ways of verifying a handle, depending on whatâ€™s more convenient to you: either a DNS TXT entry, or a file on a <code>.well-known</code> path.</p>

<p>You might be wondering how handles like <code>*.bsky.social</code> work â€“ in this case, each such handle is its own domain name, and you can actually enter a domain like <a href="https://aoc.bsky.social">aoc.bsky.social</a> into a browser and it will redirect to a Bluesky profile on <a href="https://bsky.app">bsky.app</a>. Behind the scenes, this is normally handled by having a wildcard domain pointing to one service, which responds to HTTP requests on that <code>.well-known</code> path by returning different DIDs, depending on the domain. Thatâ€™s not only a <code>bsky.social</code> thing â€“ e.g. thereâ€™s now an open Blacksky PDS server which hands out <code>blacksky.social</code> handles, and there are even â€œhandle servicesâ€ which <em>only</em> give out handles â€“ e.g. you can be <a href="https://swifties.social">yourname.swifties.social</a> if you wantÂ ;)</p>

<p>One place where handle changes break things is (some) post URLs on <a href="https://bsky.app">bsky.app</a>. The official web client uses handles by default in permalinks, which means that if you link to a Bluesky post e.g. from a blog post and you change your handle later, that link will no longer work. You can however replace the handle after <code>/profile/</code> with the userâ€™s DID, and the router accepts such links just fine, they just arenâ€™t used by default. So the form youâ€™d want to use when putting links in a blog post or article (like the one youâ€™re reading) would be something like: <a href="https://bsky.app/profile/did:plc:ragtjsm2j2vknwkz3zp4oxrd/post/3llwrsdcdvc2s">https://bsky.app/profile/did:plc:ragtjsm2j2vknwkz3zp4oxrd/post/3llwrsdcdvc2s</a>.</p>



<h2>AT URIs</h2>

<p>Each record can be uniquely addressed with a specific <strong>URI</strong> with the at:// scheme. The format of the URIÂ is:</p>

<pre><code>at://&lt;user_DID&gt;/&lt;lexicon_NSID&gt;/&lt;rkey&gt;
</code></pre>

<p><strong>Rkey</strong> is an identifier of a specific record instance â€“ a usually short alphanumeric string, e.g. Bluesky post rkeys look something like <code>3larljiybf22v</code>. So a complete post URIÂ might look like this: <code>at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.post/3larljiybf22v</code>. You can look up at:// URIs in some record browser tools, e.g. <a href="https://pdsls.dev/at://did:plc:z72i7hdynmk6r22z27h6tvur/app.bsky.feed.post/3larljiybf22v">PDSls</a>.</p>

<p>AT URIs are used for all references between records â€“ quotes, replies, likes, mute list entries, and so on. If you look at <a href="https://morel.us-east.host.bsky.network/xrpc/com.atproto.repo.getRecord?repo=did:plc:l3rouwludahu3ui3bt66mfvj&amp;collection=app.bsky.feed.like&amp;rkey=3lwctqgpttm2a">this like record</a>, for example, its <code>subject.uri</code> points to <code>at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3lv2b3f5nys2n</code>, which is the URIÂ of a post record you can see <a href="https://pdsls.dev/at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3lv2b3f5nys2n">here</a>. Since the URIs use DIDs in the first part, handle changes donâ€™t affect such links.</p>



<h2>User repositories</h2>

<p>All user data (records and blobs) is stored in a <strong>repository</strong> (or â€œrepoâ€). The repository is identified by userâ€™s DID, and stores:</p>

<ul>
<li>records, grouped by lexicon into so-called <strong>collections</strong></li>
<li>blobs (stored separately from records)</li>
<li>authentication data like access tokens, signing keys, hashed passwords etc.</li>
</ul>


<p>Internally, an important part of how the repo stores user records is a data structure called â€œ<a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Search Tree</a>â€ â€“ but this isnâ€™t something that you need to understand when using the protocol, unless youâ€™re working on a PDS/relay implementation (IÂ havenâ€™t needed to get into it so far).</p>

<p>You can download the records part of your (or anyone elseâ€™s!) repo as a bundle called a <a href="https://bsky.app/profile/did:plc:fkasq7xtzrmlvz46c5trkrn3/post/3lkedsoq4vs2d">CAR file</a>, a <a href="https://ipld.io/specs/transport/car/">Content Addressed Archive</a> (fun fact: the icon for the button in the Bluesky app which downloads a repo backup is the shape of a car ğŸš˜).</p>

<p>The cool part is that a repository stores all data of the given user, from *all* lexicons. Including third party developer lexicons. This means that if someone has their account hosted on Bluesky servers, but uses third party ATProto apps like Tangled or Grain, Bluesky lets them store these appsâ€™ records like Grain photos or Tangled pull requests on the same server where it keeps their Bluesky posts. (And yes, of course someone made a <a href="https://github.com/ziodotsh/atfile">lexicon/tool for storing arbitrary files</a> on your Bluesky PDSâ€¦ and did it in Bash, because why not ğŸ™ƒ)</p>



<h2>XRPC</h2>

<p><strong>XRPC</strong> is the convention used for APIs in the ATProto network. The APIÂ endpoints use the same naming convention as lexicon NSIDs, and they have URLs with paths in the format of <code>/xrpc/&lt;nsid&gt;</code>, e.g. <code>/xrpc/app.bsky.feed.getPosts</code>. There are similar <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/feed/getPostThread.json">lexicon definition files</a> which specify what parameters are accepted/required by an endpoint and what types of data are returned in the JSON response. PDSes, AppViews, labellers and feed generators all implement the same kind of API, although with different subsets of specific endpoints. Third party apps donâ€™t <em>have</em> to use the same convention, but itâ€™s generally a good idea, since it integrates better with the rest of the ecosystem.</p>



<h2>Rich text / facets</h2>

<p>This one is kinda Bluesky-specific, but itâ€™s pretty important to understand, and IÂ think you can reuse it for non-Bluesky apps too.</p>

<p>The â€œ<strong>facets</strong>â€ system is something used for links and possibly rich text in future in Bluesky posts. Itâ€™s perhaps a little bit unintuitive at first, but itâ€™s pretty neat and allows for a lot of flexibility.</p>

<p>The way you handle links, mentions, or hashtags, is that they arenâ€™t highlighted automatically, but you need to specifically mark some range of text as a link using the facets. A facet is a marking of some range of the post text (from-to) with a specific kind of link. If you look e.g. at <a href="https://pdsls.dev/at://did:plc:257wekqxg4hyapkq6k47igmp/app.bsky.feed.post/3lnkwu24v5k2j">this post here</a>, you can see that it has a facet marking the byte range 60-67 of the post text as a hashtag â€œahoy25â€. If there was no facet there, it would just render as normal unlinked text â€œ#ahoy25â€ in the post (when you see that, itâ€™s an easy tell that a post was made using some custom tool thatâ€™s in early stages of development). It works the same way for mention links and normal URL links.</p>

<p>(If youâ€™re curious why they implemented it this way, check out <a href="https://www.pfrazee.com/blog/why-facets">this blog post</a>.)</p>

<p>Note that the displayed text in the marked fragment doesnâ€™t have to match what the facet links to; this means that you can have links that just use some shorter text for the link instead of a part of the URL, in order to fit more text in one post (although in the official app, clicking such link triggers a warning popup first). E.g. some Hacker News bots commonly use this format, see <a href="https://bsky.app/profile/did:plc:7dh44snmqoa4gyzv3652gm3j/post/3lmhylb375m2a">this post</a>. The Bsky app doesnâ€™t let you create such posts directly, but some other clients like <a href="https://skeetdeck.pages.dev/decks/3lpzuhjwlxcns">Skeetdeck</a> do.</p>

<p>Facets are also used for URL shortening â€“ if you just put a long URL in the text of a post made through the API, it will be neither shortened nor highlighted. You need to manually mark it with a facet, and manually shorten the displayed part to whatever length you want.</p>

<p>Likely the most tricky part is that the index numbers you need to use for the ranges are counted on a UTF-8 representation of the text string, but theyâ€™re counted inâ€¦ bytes and not unicode scalars, which most languages index strings in ğŸ˜… This is somewhat of an unfortunate tech debt thing as IÂ understand, and it was made this way mostly because of JavaScript, which doesnâ€™t work with UTF-8 natively. But this means you need to be extra careful with the indexes in most languages.</p>

<hr/>

<p>Ok, now that we got through the basic pieces, letâ€™s talk about servers:</p>



<h2>PDS</h2>

<p>The original copy of all user data is stored on a server called <strong>PDS</strong>, Personal Data Server. This is the â€œsource of truthâ€. A PDS stores one or more user accounts and repos, handles user authentication, and serves as an â€œentry pointâ€ to the network when connecting from a client app. Most network requests from the client are sent to your PDS, although only some of them are handled directly by the PDS, and the rest are proxied e.g. to the AppView. So in a way, your PDS kind of serves as your â€œuser agentâ€ in the network on the backend side of things (beyond the client app), especially if itâ€™s under your control.</p>

<p>Each PDS has an XRPC APIÂ with some number of endpoints for things like listing repositories, listing contents of each, looking up a specific record or blob, account authentication and management, and so on. It also has a websocket APIÂ called a â€œ<strong>firehose</strong>â€ (the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/com/atproto/sync/subscribeRepos.json">subscribeRepos endpoint</a>). The firehose streams all changes happening on a given PDS (from all repos) as a stream of â€œeventsâ€, where each event is an addition, edit, or deletion of a record in one of the repos, or some change related to an account, like handle change or deactivation.</p>

<p>One of the most important features of ATProto is that <strong>an account is not permanently assigned to a PDS</strong>. Unlike in ActivityPub, where your identifier is e.g. <code>mackuba@mastodon.social</code> and it can never change, because everything uses that as the unique ID, here the unique ID is the DID. The PDS host is assigned to a user in the DID document JSON (e.g. on <a href="https://plc.directory">plc.directory</a>), but you can migrate to a different PDS at any point, and at the moment there are even some fairly user-friendly tools available for doing that, like <a href="https://atpairport.com">ATP Airport</a> or <a href="https://pdsmoover.com">PDS MOOver</a> (although itâ€™s still a bit unpolished at the moment, and for now you canâ€™t migrate back to Bluesky-hosted PDSes). In theory, you should even be able to migrate to a different PDS if your old PDS is dead or goes rogue, if you have prepared in advance (<a href="https://www.da.vidbuchanan.co.uk/blog/adversarial-pds-migration.html">this is a bit more technical</a>). If everything goes well, nobody even notices that anything has changed (you canâ€™t even easily check in the app what PDS someone is on, although there are external tools for that, like <a href="https://internect.info">internect.info</a>).</p>

<p>Initially, during the limited beta in 2023, Bluesky only had one PDS, <code>bsky.social</code>. In November 2023, several additional PDSes were created (also under Bluesky PBC control) and existing users were quietly all spread to a random one of those. At that point, the network was already â€œtechnically federatedâ€, operating in the target architecture, although with access restricted to only Bluesky-run servers. This restriction was lifted in February 2024 with the <a href="https://docs.bsky.app/blog/self-host-federation">public federation launch</a>.</p>

<p>Since then, ATProto enthusiasts started setting setting up PDS servers for themselves, either creating alt/test accounts there, or moving their main accounts. As of August 2025, there around 2000 third party PDS servers, although most of them are very small â€“ usually hosting one personâ€™s main and/or test accounts, and maybe those of a couple of their friends. IÂ have <a href="https://blue.mackuba.eu/directory/pdses">a list of them</a> on my website, and thereâ€™s also a more complete list <a href="https://github.com/mary-ext/atproto-scraping">here</a> (mine excludes inactive PDSes and empty accounts).</p>

<p>As you can see there, thereâ€™s one massive PDS for <a href="https://fed.brid.gy">Bridgy Fed</a>, the Bluesky-Mastodon bridge service, hosting around 30-40k bridged accounts from the Fediverse, Threads, Nostr, Flipboard, or the web (blogs); then some number of small to medium PDSes for various services, and a very long tail of servers with single-digit number of accounts. At this moment, large public PDS in the style of Fedi instances arenâ€™t much of a thing yet, although there are at least a few communities working on setting up one (e.g. <a href="https://www.blackskyweb.xyz">Blacksky</a>, <a href="https://northskysocial.com">Northsky</a>, or <a href="https://turtleisland.blog/2025/04/28/turtle-island-bluesky-pds/">Turtle Island</a>). Blacksky specifically has <a href="https://bsky.app/profile/did:plc:w4xbfzo7kqfes5zb7r6qv3rw/post/3lvtlqoef5c2z">opened up for migrations</a> just last week and has now a few hundred real accounts.</p>

<p>The vast majority of PDSes at the moment use the <a href="https://github.com/bluesky-social/pds">reference implementation from Bluesky</a> (written in TypeScript), but there are a few alternative implementations at various levels of maturity (Blackskyâ€™s Rudy Fraserâ€™s <a href="https://github.com/blacksky-algorithms/rsky/tree/main/rsky-pds">rsky</a> written in Rust, <a href="https://github.com/haileyok/cocoon">cocoon</a> in Go, or <a href="https://github.com/DavidBuchanan314/millipds">millipds</a> in Python). The official version is very easy to set up and very cheap to run â€“ itâ€™s bundled in Docker, and thereâ€™s basically one script you need to run and answer a few questions.</p>

<p>As for the Bluesky-hosted PDSes, the number is currently in high double digits, and each of them hosts a few hundred thousands of accounts (!). And whatâ€™s more, they keep the record data in SQLite databases, one per account. And it works really well, go figure. The Bluesky PDSes are all given names of different kinds of mushrooms (like Amanita, Boletus or Shiitake), hence they are often called â€œmushroom serversâ€; you can see the full list e.g. <a href="https://status.bsky.app">here</a>. <code>bsky.social</code> was left as a so-called â€œ<strong>entryway server</strong>â€, which handles shared authentication for all Bluesky-hosted PDSes (itâ€™s a private piece of Bluesky PBC infrastructure thatâ€™s not open source and not needed for independent PDS hosters).</p>



<h2>Relay</h2>

<p>A <strong>relay</strong> is probably the piece of the ATProto architecture thatâ€™s most commonly misunderstood by people familiar with other networks like the Fediverse. It doesnâ€™t help that both the Fediverse and Nostr also include servers called â€œrelaysâ€, but they serve a different purpose in each of them:</p>

<ul>
<li>a relay in Nostr is a core piece of the architecture: your posts are uploaded to one or more relays that you have configured and are hosted there, where other users can fetch them from</li>
<li>a relay in the Fediverse is an optional helper service that redistributes posts from some number of instances who have opted in to others, in order to make content more discoverable e.g. on hashtag feeds</li>
</ul>


<p>In ATProto, a relay is a server which combines the firehose streams from all PDSes it knows about into one massive stream that includes every change happening anywhere on the network. Such full-network firehose is then used as the input for many other services, like AppViews, labellers, or feed generators. It serves as a convenient streaming APIÂ to get e.g. all posts on the network to process them somehow, or all changes to accounts, or all content in general, from a single place.</p>

<p>Initially, the relay was also expected to keep a complete archive of all the data on the network, from all repos, from the beginning of time. This requirement was later removed in the updates late last year, at least partially triggered by the drastic increase in traffic in November 2024, which overwhelmed Blueskyâ€™s and third party servers for at least a few days. Currently, Blueskyâ€™s and other relays are generally â€œnon-archivalâ€, meaning that they live stream current events (+ a buffer of e.g. last 24 or 36 hours), but donâ€™t keep a full archive of all repos (this change has <a href="https://whtwnd.com/bnewbold.net/3lo7a2a4qxg2l">massive lowered the resource requirements</a> / cost of running a relay, making it much more accessible). An archival relay could always be set up too, but Iâ€™m not aware of any currently operating.</p>

<p>Bluesky operates one main relay at <a href="https://bsky.network">bsky.network</a>, which is used as a data source for their AppView and pretty much everyone else in the ATProto ecosystem at the moment (internally, itâ€™s really some kind of â€œload balancerâ€ using the <a href="https://github.com/bluesky-social/indigo/tree/main/cmd/rainbow">rainbow</a> service, with a few real relay servers behind it).</p>

<p>The relay code is <a href="https://github.com/bluesky-social/indigo/">implemented in Go</a>, and isnâ€™t very hard to get up and running (especially the recent â€œ1.1â€ update improved things quite a lot). Some people have been running alternative relay services privately for some time, and there is now e.g. a public relay run by Rudy Fraser at <a href="https://atproto.africa">atproto.africa</a> (with a custom implementation in Rust! ğŸ¦€), and a couple run by <a href="https://bsky.app/profile/did:plc:hdhoaan3xa3jiuq4fg4mefid/post/3ltkh6bdo4ki5">Phil @bad-example.com</a>. Iâ€™m also running <a href="https://relay.feeds.blue">my own small relay</a>, feeding content only from non-Bluesky PDSes.</p>



<h4>Jetstream</h4>

<p>There is also a variant of a relay called <a href="https://github.com/bluesky-social/jetstream">Jetstream</a> â€“ itâ€™s a service that reads from a real CBOR relay and outputs a stream thatâ€™s JSON based, better organized, and much more lightweight (the full relay includes a lot of additional data thatâ€™s mostly used for cryptographic operations and other low-level stuff). For many simpler tools and services, it might make more sense to stream data from that one instead, if only to save bandwidth. (Bluesky runs a couple of instances listed there in the readme, but you can also run your own.)</p>



<h2>AppView</h2>

<p>The terribly named <strong>AppView</strong> is the second most important piece of the network after the PDS.</p>

<p>The AppView is basically an APIÂ server that serves processed data to client apps. Itâ€™s an equivalent of an APIÂ backend (with the databases behind it) that youâ€™d find on a classic social media site like Twitter. AppView streams all new data written on the network from the relay, and saves a copy of it locally in a processed, aggregated and optimized form. For example, an AppView backed by an SQL database could have a <code>posts</code> table with a <code>text</code> column, a <code>likes</code> table storing all likes with a foreign key <code>post_id</code>, probably also an integer <code>likes_count</code> column in <code>posts</code> for optimization, and so on.</p>

<p>The AppView is designed to be able to easily give information such as:</p>

<ul>
<li>the latest posts from this user</li>
<li>all the replies in a given thread organized in a tree</li>
<li>most recent posts on the network with the hashtag #rubylang or mentioning â€œiOS 26â€</li>
<li>how many likes/reposts has a given post received, and who made them</li>
<li>how many follows/followers does a given user have, and who are they</li>
<li>is user A allowed to view or reply to a post from user B</li>
</ul>


<p>All this data originates from usersâ€™ PDSes and has its original copy stored there, but the â€œrawâ€ record donâ€™t always allow you to access all information easily. For example, to find out how many likes a post has, you need to know all <code>app.bsky.feed.like</code> records referencing it from other users, and each of those like records is stored in the liking userâ€™s repo on that userâ€™s PDS. Same with followers, as IÂ mentioned earlier in the section on records, or with building threads (again, different replies in one thread are hosted in different repos), or for basically any kind of search. So having this kind of APIÂ with processed data from the entire network is essential for client apps and various tools and services built around Bluesky by other people.</p>

<p>AppView also applies some additional rules to the data, sometimes overriding what people post into their PDSes, since anyone can technically post anything into their PDS. For example, the AppView prevents you from looking at the profiles of people who have blocked you, at least when youâ€™re logged in. It also hides them from your followers list, even if they have a <code>follow</code> record referencing you, making it seem like they donâ€™t; and if they try to make an <code>app.bsky.feed.post</code> replying to you (they <em>can</em> create such record on their PDS!), it excludes such reply from feeds and threads, as if it never happened. Same goes for â€œthread gatesâ€ which lock access to threads, and so on.</p>

<p>The AppView is one of the few components which <em>arenâ€™t</em> completely open source. Initially, the AppView used Postgres as its data store; <em>that</em> version is still in the public repository. In late 2023, Bluesky has migrated to a â€œv2â€ version, which uses the NoSQL database <a href="https://www.scylladb.com">ScyllaDB</a> instead, to be able to handle the massive read traffic from many millions of concurrent users. The upper layer with the â€œbusiness logicâ€ is kept in the <a href="https://github.com/bluesky-social/atproto/tree/main/packages/bsky">public repository</a>, while the so called â€œdataplaneâ€ layer that interacts directly with Scylla is not. The reason is mostly that itâ€™s built for a specific hardware setup they have and wouldnâ€™t be directly usable by others, while it would add some unnecesary work for the team to publish it. Itâ€™s still possible to run the AppView with the <a href="https://github.com/bluesky-social/atproto/tree/main/packages/bsky/src/data-plane">old Postgres-based data layer</a> (and IÂ think the team uses that internally for development), it just canâ€™t handle as much traffic as the current live version.</p>

<p>This is the piece thatâ€™s hardest to run yourself, and one that requires the most resources. That said, a private AppView should be possible to run right now for <a href="https://whtwnd.com/futur.blue/3ls7sbvpsqc2w">under $200/month</a> â€“ the biggest requirement is at least a few TB of disk space. The truly costly part is not collecting and storing all this data, but serving it to a huge number of users who would use it as a backend for the client app in daily use. An alternative full-network Bluesky AppView that is used by a few thousands of users shouldnâ€™t be very hard to run, but to be able to serve millions, youâ€™ll need a lot of hardware and something more custom than the Postgres-based version.</p>

<p>There have also been some attempts at alternative implementations â€“ the most advanced right now is <a href="https://github.com/alnkesq/AppViewLite">AppViewLite</a>, built in C#, which goes to great lengths to minimize the resource use.</p>



<h4>CDN</h4>

<p>A part of the AppView (at least the Bluesky one) is also a CDN for serving images &amp; videos. The APIÂ responses from e.g. <code>getTimeline</code> or <code>getPostThread</code> generally include links to any media on the Bluesky CDN hostname, not directly on the PDS, even though you <em>can</em> fetch every blob from the PDS, since thatâ€™s the â€œsource of truthâ€ (although IIRC the Bluesky PDS implementation doesnâ€™t set the CORS headers there). Itâ€™s recommended to access any media this way in order to not use too much bandwidth from the PDS.</p>



<h2>Labellers</h2>

<p>(Or â€œlabelersâ€ officially, but IÂ like the British spelling more here, sue me Â¯\_(ãƒ„)_/Â¯)</p>

<p>Weâ€™re now getting to more Bluesky specific things (i.e. specific for the Bluesky-service, although some parts of it are ATProto-general and mentioned on the <a href="https://atproto.com/specs/label">atproto.com site</a>).</p>

<p>A <strong>labeller</strong> is a moderation service for Bluesky (or other ATProto app), which can be run by third parties. Labellers emit labels, which are assigned to an account or a record (like a post). Each labeller defines its own set of labels, depending on what itâ€™s focusing on; then, users can â€œsubscribeâ€ to a labeller and choose how they want to handle the labels it assigns: you can hide the labelled posts/users, mark them with a warning badge, or ignore given label.</p>

<p>Labellers were initially designed to just do community moderation of unwanted content, e.g. you can have a service focused on fighting racism, transphobia, or right-wing extremism, and that service helps protect its users from some kinds of bad actors; or you can have one marking e.g. posts with political content, users who follow 20k accounts, or who post way too many hashtags. In practice, many <a href="https://blue.mackuba.eu/labellers/">existing labellers</a> are meant for self-labelling instead, letting you assign e.g. a country flag or some fun things like a D&amp;D character class to yourself.</p>

<p>The way it works technically is:</p>

<ul>
<li>a labeller either runs a firehose client pulling posts from the relay, or relies on reports from users and/or its operating team (usually using the <a href="https://github.com/bluesky-social/ozone/">Ozone tool</a> for that)</li>
<li>labels, which are lightweight objects (<em>not</em> ATProto records) are emitted from labellerâ€™s special firehose stream (the <a href="https://github.com/bluesky-social/atproto/blob/main/lexicons/com/atproto/label/subscribeLabels.json">subscribeLabels endpoint</a>)</li>
<li>the AppView listens to the label firehoses of all labellers it knows about, in addition to the relay stream, and records all received labels in its database</li>
<li>when a logged in user pulls data like threads or timelines from the AppView, it adds relevant label info to the responses depending on which labellers the user follows</li>
<li>the specific list of labellers whose labels should be applied is passed explicitly in APIÂ requests in the <code>atproto-accept-labelers</code> header (there is a â€œsoftâ€ limit of 20 labellers you can pass at a time, which is why the official app wonâ€™t let you subscribe to more)</li>
<li>in the official app, Blueskyâ€™s official moderation service (which is â€œjustâ€ another labeller) is hardcoded as one of those 20 and you canâ€™t turn it off; when connecting from your own app or tool, youâ€™re free to ignore it if you want</li>
</ul>


<p>(Read more about labellers <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#labellers">here</a>.)</p>



<h2>Feed generators</h2>

<p><a href="https://mackuba.eu/2024/02/21/bluesky-guide/#feeds">Custom feeds</a> are one of the coolest features of Bluesky. They let you create any kind of feed using any algorithm and let everyone on the platform use it (even as the default feed, if they want to).</p>

<p>The way this system works is that you need to run a â€œ<strong>feed generator</strong>â€ service on your server. In that service, you expose an APIÂ that the AppView can call, which returns a list of post at:// URIs selected by you however you want in response to a given request.</p>

<p>A minimal feed service can be pretty simple â€“ the APIÂ is just three endpoints, two of which are static, and the third returns the post URIs. One â€œsmallâ€ problem is that in order to return the post URIs, you need to have some info about posts stored up front, which in practice means that you almost always need to connect to a relayâ€™s firehose stream and store some post data (of selected or all posts, depending on your use case).</p>

<p>The flow is like this:</p>

<ul>
<li>a feed record is uploaded to your repo, including metadata and location of the feed generator service, which lets other users find your feed</li>
<li>when the user opens that feed in the app, the AppView makes a request to your service on their behalf</li>
<li>your service looks at the request params and headers, and returns a list of posts it selected in the form of at:// URIs</li>
<li>the AppView takes those URIs and maps them to full posts (so-called â€œhydrationâ€), which it returns to the userâ€™s app</li>
</ul>


<p>How exactly those posts are selected to be returned in the given request is completely up to you, the only requirement is that these are posts that the AppView will have in its database, since you only send URIs, not actual post data. In most cases, feeds use some kind of keyword/regexp matching and chronological ordering, but you can even build very complex, AI-driven algorithmic â€œFor Youâ€ style personalized feeds.</p>

<p>You donâ€™t necessarily have to code a feed service yourself and host it in order to have a custom feed â€“ there are a few feed hosting services that donâ€™t require technical knowledge to use, like <a href="https://skyfeed.app">SkyFeed</a> or <a href="https://www.graze.social">Graze</a>.</p>



<h2>Client apps</h2>

<p>Ok, thatâ€™s technically not a server, but stay with meâ€¦</p>

<p>The final piece that you need to fully enjoy Bluesky is the client app â€“ a mobile/desktop one or a web frontend. Unlike on Fedi, where an instance software like Mastodon usually includes a built-in web frontend that is your main interface for accessing the service, the PDS doesnâ€™t include anything like that, just a database and an APIÂ (which also means itâ€™s much more lightweight and needs less resources). All browsing is done through a separate client, and the client always does everything through the public APIÂ â€“ kind of like when you run a custom web client for Mastodon like <a href="https://elk.zone">Elk</a> or <a href="https://phanpy.social">Phanpy</a>, you connect it to your instance, and you view your timeline on <a href="https://elk.zone">elk.zone</a>.</p>

<p>So when you go to <a href="https://bsky.app">bsky.app</a>, thatâ€™s what youâ€™re seeing â€“ a web client that connects to your PDS (Bluesky-hosted or self-hosted) through the public API, no more, no less. The official app is built for both mobile platforms and for the web from a single React Native codebase (apparently React Native on the web and normal web React is not the same thing ğŸ§). This has allowed the still very small frontend team (and IIRC at first it was literally just Paul) to build the app for three platforms in any reasonable amount of time and maintain it going forward. The downside is that itâ€™s kinda neither a great webapp nor a great mobile appâ€¦ But the team is doing what they can to improve it, and itâ€™s already much better than it used to be, and tbh more than good enough for me.</p>

<p>There arenâ€™t nearly as many alternative clients as there are for Mastodon, and none of them are <em>really</em> great, but there are a few options; see the <a href="https://mackuba.eu/2024/02/21/bluesky-guide/#apps">apps part of my Bluesky Guide</a> blog post for links.</p>



<h2>DMs</h2>

<p>Notice that IÂ havenâ€™t mentioned DMs anywhere â€“ thatâ€™s because they arenâ€™t a part of the protocol at the moment. The Bluesky team wants to eventually add some properly implemented, end-to-end encrypted, secure DMs using some open standard, but they wonâ€™t be able to finish that in the short term, and a lot of people were asking for at least some simple version of DMs in the app. So theyâ€™ve decided as an interim solution to implement them as a fully centralized, closed source service. It is accessible to third-party Bluesky clients through the APIÂ (the <code>chat.bsky.*</code> namespace), but itâ€™s not something you can run yourself. The team is <a href="https://bsky.app/profile/did:plc:44ybard66vv44zksje25o7dz/post/3lacrutxhio2h">very open</a> about the fact that itâ€™s not a proper replacement for something like Signal, and that for sensitive communication, you should ideally just use it for swapping contacts on Signal on iMessage and move the conversation there. They also kinda donâ€™t want to spend too much time adding features there, because itâ€™s considered a temporary solution, so itâ€™s pretty basic in terms of available features.</p>

<p>There are also a few other closed-source helper services, like the â€œcardybâ€ they use for generating link card details, or the video service for preprocessing videos, but theyâ€™re all specific to some Bluesky use cases only and not strictly necessary to use.</p>

<hr/>



<h2>How it all fits together</h2>

<p>So the flow and hierarchy is like this:</p>

<ul>
<li>the <strong>client app</strong> you use creates new records as a result of actions you take (new posts, likes, follows), and saves them into your PDS</li>
<li>your <strong>PDS</strong> emits events on its firehose with the record details</li>
<li>Bluesky <strong>relay</strong> and other relays are connected to the firehoses of each PDS they know about (your PDS generally needs to ask them to connect using the <code>PDS_CRAWLERS</code> ENV variable), and they pass those events to their output firehose</li>
<li>the Bluesky <strong>AppView</strong> (and other AppViews) listen to the firehose of their selected relay (though it could be multiple relays, or it could even just stream directly from PDSes, but in practice this will normally be one trusted relay)</li>
<li>the AppView gets events including your records, and if they are relevant, saves the data to its internal database in some appropriate representations</li>
<li>when other users browse Bluesky in their client apps, they load timelines, feeds and threads from the AppView, which returns info about your post from that database it saved it to</li>
</ul>


<p>Additionally:</p>

<ul>
<li><strong>feed generators</strong> run by third party feed operators also stream data from Blueskyâ€™s or some other relay and save it locally, so they can respond to feed requests from the AppView</li>
<li><strong>labellers</strong> also stream data from Blueskyâ€™s or some other relay, and emit labels on their firehoses, which get sent to the AppView (note: there is no official â€œlabeller relayâ€ sitting between labellers and the AppView, although one third party dev <a href="https://bsky.app/profile/did:plc:w4xbfzo7kqfes5zb7r6qv3rw/post/3lrgs3itqyc2q">wrote one</a>)</li>
</ul>


<p>Note:</p>

<ul>
<li>PDSes <strong>do not connect to each other directly</strong>, and they donâ€™t store posts of users from other PDSes, only their own</li>
<li>although right now basically everyone uses the Bluesky relay and AppView, anyone <em>can</em> set up their own alternative relays and AppViews, which feed from all or any subset of known PDSes</li>
<li>PDS chooses which relays to ask to connect, but relays can also connect by themselves to a PDS or another relay; AppView chooses which relay(s) it streams data from; and PDS chooses which AppView it loads timelines &amp; threads from</li>
<li>itâ€™s absolutely possible and expected that two users using different PDSes, which use separate AppViews feeding from separate relays will be able to talk to each other and see each otherâ€™s responses on their own AppView, as long as the users arenâ€™t banned on the other userâ€™s infrastructure</li>
</ul>


<p>The metaphor thatâ€™s often used to describe these relationship is that PDSes are like websites which publish some blog posts, and relays &amp; AppViews are like search engines which crawl and index the web, and then let you look up results in them. In most cases, a website should be indexed and visible in all/most available search engines.</p>

<hr/>



<h2>Where to go next</h2>

<p>And thatâ€™s about it â€“ IÂ think with the above, you should have a pretty good grasp of the big picture of ATProto architecture and all the specific parts of it. Now, if you want to start playing with the protocol and building some things on it, a lot will depend on what specifically you want to build and using what languages/technologies:</p>



<h4>SDKs:</h4>

<p>Two languages are officially supported by Bluesky:</p>

<ul>
<li>JavaScript/TypeScript, in which most of their code is written (see the <a href="https://github.com/bluesky-social/atproto/tree/main/packages">packages folder</a> in the <code>atproto</code> repo)</li>
<li>Go, which is used in some backend pieces like the relay, or the <a href="https://github.com/bluesky-social/goat">goat</a> command line tool used e.g. for PDS migrations (see the <a href="https://github.com/bluesky-social/indigo"><code>indigo</code> repo</a>)</li>
</ul>


<p>For Python, there is a <a href="https://atproto.blue">pretty full-featured SDK created by Marshal</a>, which is the only third party SDK <a href="https://atproto.com/sdks">officially endorsed</a> by the Bluesky team.</p>

<p>For other languages, IÂ have a website called <a href="https://sdk.blue">sdk.blue</a>, which lists all libraries and SDKs IÂ know about, grouped by language. As you can see, there is something there for most major languages; Iâ€™ve built and maintain a group of <a href="https://sdk.blue/#ruby">Ruby gems</a> myself. If you want to use a language that doesnâ€™t have any libraries yet, itâ€™s really not that hard to make one from scratch â€“ for most things you just need an HTTP client and a JSON parser, and maybe a websocket client.</p>



<h4>Docs:</h4>

<p>There is quite a lot of official documentation, although itâ€™s a bit spread out and sometimes not easy to find.</p>

<p>The places to look in are:</p>

<ul>
<li><a href="https://atproto.com">atproto.com</a> â€“ the official AT Protocol website; a bit more formal documentation about the elements of the protocol, kind of like what IÂ did here, but with much more info and detailed specifications of each thing</li>
<li><a href="https://docs.bsky.app/docs/get-started">docs.bsky.app</a> â€“ more practical documentation with guides and examples of specific use cases in TS &amp; Python (roll down the sections in the sidebar); it shows examples of how to make a post, upload a video, how to connect to the firehose, how to make a custom feed, etc.</li>
<li><a href="https://docs.bsky.app/blog">docs.bsky.app/blog</a> â€“ developer blog with updates about protocol changes</li>
<li><a href="https://docs.bsky.app/docs/category/http-reference">HTTP reference</a> â€“ a reference of all the APIÂ endpoints</li>
<li>something that IÂ also find useful is to have the <a href="https://github.com/bluesky-social/atproto">atproto repo</a> checked out locally and opened in the editor, and look things up in the JSON files from the <a href="https://github.com/bluesky-social/atproto/tree/main/lexicons">/lexicons folder</a></li>
</ul>


<p>And a few other articles that might work better for you:</p>

<ul>
<li>â€œ<a href="https://atproto.com/articles/atproto-for-distsys-engineers">ATProto for distributed systems engineers</a>â€, Blueskyâ€™s technical overview of the server and data flow architecture</li>
<li>â€œ<a href="https://atproto.com/articles/atproto-ethos">ATProto Ethos</a>â€, also on the Bluesky blog, based on a conference talk</li>
<li>â€œ<a href="https://steveklabnik.com/writing/how-does-bluesky-work/">How Does BlueSky Work?</a>â€, by Steve Klabnik (of Ruby &amp; Rust fame) (Feb 2024)</li>
<li>the â€œ<a href="https://atproto.com/guides/applications">Statusphere</a>â€ app example on atproto.com</li>
</ul>




<h4>Community:</h4>

<p>Someone said recently that â€œ<em>bsky replies are the only real documentation for ATProto</em>â€, and honestly, theyâ€™re not wrong. We have a great community of third party developers now, building their own tools, apps, libraries, services, even organizing <a href="https://ahoy.eu">conferences</a>. If youâ€™re starting out and you have any questions, just ask and someone will probably help, and some of the Bluesky team developers are also very active in Bluesky threads, answering questions and clarifying things. So a lot of such knowledge thatâ€™s not necessarily found in the official docs can be found somewhere on Bluesky.</p>

<p>The two places IÂ recommend looking at are:</p>

<ul>
<li>the â€œATProto Touchersâ€ Discord chat â€“ ping me or some other developer for an inviteÂ :)</li>
<li>my <a href="https://bsky.app/profile/did:plc:oio4hkxaop4ao4wz2pp3f4cr/feed/atproto">ATProto feed</a> on Bluesky, which tries to catch any ATProto development discussions â€“ it should include posts with any mention of â€œATProtoâ€ or things like â€œAppViewâ€ or various APIÂ names and technical terms, or you can use <code>#atproto</code> or <code>#atdev</code> hashtag to be sure</li>
</ul>


<p>Also, thereâ€™s a fantastic newsletter called <a href="https://connectedplaces.online">Connected Places</a> (formerly Fediverse Report) by Laurens Hof, who publishes two separate editions every week, about whatâ€™s happening in Bluesky/ATProto and in the Fediverse (and *a lot* of things are happening).</p>



<h4>Ideas:</h4>

<p>Some easy ways to start tinkering:</p>

<ul>
<li>use one of the <a href="https://sdk.blue">existing libraries for your favorite language</a> and make a website or command-line tool which loads some data from the AppView or PDS: load and print timelines, calculate statistics, browse contents of PDSes and repos, etc.</li>
<li>make a bot that posts something (not spammy!)</li>
<li>make a simple custom feed service using <a href="https://docs.bsky.app/docs/starter-templates/custom-feeds">one of the available templates</a></li>
<li>connect to the relay firehose and print or record some specific types of data</li>
</ul>




<h4>Tools:</h4>

<p>And a couple of tools which will certainly be useful in development:</p>

<ul>
<li><a href="https://internect.info">internect.info</a> â€“ look up an account by handle/DID and see details like assigned PDS or handle history</li>
<li><a href="https://pdsls.dev">PDSls</a> â€“ PDS and repository browser, lets you look up repos by account DID or records by at:// URIÂ (there are a few others, but this one is most popular)</li>
</ul>


  </div></div>
  </body>
</html>
