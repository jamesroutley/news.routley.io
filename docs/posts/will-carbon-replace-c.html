<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://semaphoreci.com/blog/carbon">Original</a>
    <h1>Will Carbon Replace C&#43;&#43;?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">

		
<p>The last <a href="https://cppnorth.ca/2022/index.html">CppNorth 2022</a> was announced with Chandler Carruth scheduled to give a keynote, where he showed the results of a new scientific experiment. The keynote was titled: <a href="https://youtu.be/omrY53kbVoA">Carbon Language: An experimental successor to C++</a>. But why do we need a successor and where did this idea come from?</p>



<p>The last day for the <a href="https://cppcon.org/cppcon-2019-program/">CppCon 2019</a> conference came with a surprise talk by the same Chandler Carruth and Titus Winters, where they discussed <a href="https://youtu.be/LJh5QCV4wDg">What is C++?</a> I recommend that you listen to this talk as it is very entertaining and informative. I think the most interesting phrase and idea transmitted during the first part of the talk is that “<em>languages are tools and we have to use the right tool for the job</em>.”</p>



<p>At the end of the talk, they made different proposals intended to address some of the common problems that C++ developers face, these proposals were:</p>



<ul>
<li>Performance critical software. We are not only talking about speed but also about latency, memory utilization, and battery utilization among other things.</li>



<li>Software evolution, and language evolution. C++ was written decades ago, language designers also make mistakes and it should be possible to improve and upgrade according to the changes that most languages include these days–there are always, however, people in the community opposed to changing things.</li>



<li>Simple and easy to read, understand, and write. I think this quote from John Carmack sums it up well: “<em>An enormous virtue of plain old C is that most senior developers are capable of writing their own C compiler, and knowing your tools at that level is valuable! I would need a lot of study time to write a C++ compiler</em>.”</li>



<li>Practical safety and testing. Safer APIs, cheap security mitigations, and comprehensive testing methodology using Continuous Integrated (CI) unit and integration tests. All untrusted inputs are continuously fuzzed and all tests use checking build mode (sanitizers, asserts).</li>



<li>Fast and scalable development: modules, essentially.</li>



<li>Hardware, OSs, Environments. Define what we are committing to support and keep that rolling forward predictably. We’re not going to go out of the way to break your 20-year old platform but we may not go out of our way to keep supporting it either.</li>
</ul>



<h2 id="could-we-improve-c-or-use-another-language">Could we improve C++ or use another language?</h2>



<p>Carruth gave us information in the last CppNorth 2022. He started by mentioning the proposals for the previous talk and discussing why they weren’t possible to realize for C++. The main problem is the accumulated <em>decades</em> of technical debt, during which the community was prioritizing backward compatibility, which prevents <em>fixing</em> technical debt.</p>



<p>Is there an existing language that could be used in place of C++? Languages using garbage collection are great but we are not going to consider them because they have a performance cost and most C++ developers consider that a trade-off they don’t want to make.</p>



<p>The Rust programming language is a good option because it’s memory safe and it could fit very well as a low-level language replacement, but keeping in mind the following relationships, it doesn’t fit well:</p>



<ul>
<li>C –&gt; C++</li>



<li>JavaScript –&gt; TypeScript</li>



<li>Objective C –&gt; Swift</li>



<li>Java –&gt; Kotlin</li>



<li>C++ –&gt; Rust?</li>
</ul>



<p>Rust is a language that works perfectly well and it’s very recommendable if you are starting a project right now, but if you need to move a C++ ecosystem to Rust with very deep dependencies, it’s a very hard task. It’s not something that I recommend trying.</p>



<p>What we need is a <em>successor </em>language. A successor language is a language built within an existing ecosystem, without bootstrapping a new one, that provides interoperability, optimizes the learning curve and adoption path, and ideally has tool-assisted migration support. It’s essentially a superset for its ancestor language.</p>



<h2 id="what-is-the-carbon-programming-language"><strong>What is the Carbon programming language?</strong></h2>



<p>Carruth started his talk with the question <em>C++: What Comes Next?</em> and guided listeners through some questions from the community like why we cannot improve C++, why we cannot use the Go language or another garbage-collected language, or even why we cannot use the Rust language (or another low-level language), before jumping to the need to create a real successor language for C++: Carbon.</p>



<p>Carbon took the proposals for improving C++ and incorporated them into its design goals, but they needed to add a new and critical goal, maybe the most important one: <em>Interoperability with and migration from existing C++ code</em>.</p>



<p>As defined on its <a href="https://github.com/carbon-language/carbon-lang#why-build-carbon">website</a>, we can establish the following definition and justification for the creation of the Carbon language:</p>



<p>“Carbon is fundamentally a successor language approach, rather than an attempt to incrementally evolve C++. It is designed around interoperability with C++ as well as large-scale adoption and migration for existing C++ codebases and developers. […] With this approach, we can build on top of C++’s existing ecosystem, and bring along existing investments, codebases, and developer populations.”</p>



<h2 id="will-go-or-dart-disappear"><strong>Will Go or Dart disappear?</strong></h2>



<p>Because this initiative started at Google, where Carruth works as Technical Lead for Google’s Programming Languages and Software Foundations, one might worry that the support for Golang or even Dart could be decreased. Google is a big company, however, and they develop software for different platforms and very different projects. This means that they need different languages for different things.</p>



<p><a href="https://go.dev/doc/faq#internal_usage">Go is in use by Google in production</a> for a couple of services (i.e. Google’s download server at <code>dl.google.com</code>) but, as Carruth said, migrating from big C++ projects is very hard and it won’t be done.</p>



<p>Dart is a language on top of JavaScript and other languages with the mission to be the main language for the Flutter project, addressing the creation of cross-platform apps. Because Flutter doesn’t support C++, Carbon is essentially useless in this environment and therefore the Dart language isn’t going to be affected.</p>



<h2 id="how-do-we-develop-in-this-new-language">How do we develop in this new language?</h2>



<p>During Core C++ 2022, Jon Ross-Perking (a Staff Software Engineer at Google who was working in the Carbon language for 2 years) talked about <a href="https://youtu.be/9Y2ivB8VaIs">the syntax and trade-offs</a> for the Carbon language.</p>



<p>The initial part of the talk emphasized the experimental nature of the project at the moment, but I would like to make a few observations about the ecosystem starting with the tooling. Ross-Perking revealed the following tooling goals for the project:</p>



<ul>
<li>Compiler. The compilation of the code is very important, of course.</li>



<li>Formatter. Getting the code formatted correctly.</li>



<li>Automatic language upgrades. Tidy our code at a higher level than the formatter does.</li>



<li>IDE and LSP support.</li>



<li>Refactoring support.</li>



<li>Package manager.</li>
</ul>



<p>About writing code, keeping the context where we are developing is important but, do we need to keep that amount of information? Carbon is simplifying the context by giving specific reserved words to make the tooling easier, and code more readable. These reserved words are:</p>



<ul>
<li><code>var</code> – used for declaring variables.</li>



<li><code>class</code> – used for defining classes.</li>



<li><code>fn</code> – used for defining a function.</li>



<li><code>interface</code> – used for defining an interface.</li>



<li><code>let</code> – used for declaring a constant.</li>
</ul>



<p>As an example for each one is shown below:</p>



<pre><code>var radius: Printer(Circle);

class Circle

class Printer(template t:! Type)

fn Draw()

interface Shape

let Pi: f32</code></pre>



<p>I think we can jump into the details of the syntax after this and check out an example of code. But before we start to browse the code, let me say that this language is still experimental and, as with most of the experiments, it could evolve or even disappear. At the moment, the project looks promising and that’s a good signal.</p>



<p>About syntax, this is still not the first release, which means that it could change from what you see here. You can check the <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/design/README.md">design document</a> where the designers and developers are contributing their proposals and changes, if you want to stay up to speed with the latest developments.</p>



<pre><code>import Math;

// Returns the smallest factor of `n` &gt; 1, and
// whether `n` itself is prime.
fn SmallestFactor(n: i32) -&gt; (i32, bool) {
  let limit: i32 = Math.Sqrt(n) as i32;
  var i: i32 = 2;
  while (i &lt;= limit) {
    let remainder: i32 = n % i;
    if (remainder == 0) {
      Carbon.Print(&#34;{0} is a factor of {1}&#34;, i, n);
      return (i, false);
    }
    if (i == 2) {
      i = 3;
    } else {
      // Skip even numbers once we get past `2`.
      i += 2;
    }
  }
  return (n, true);
}</code></pre>



<p>We are using two different functions here. Looks like the functions inside of the <code>Carbon</code> package are imported by default and we need to import the <code>Math</code> package so we can use it.</p>



<p>We also used two constants (<code>let</code>). The first one (<code>limit</code>) is a constant for the whole function, while the second one (<code>reminder</code>) is a constant in the scope of the <code>while</code> loop, and it’s created and bound to the value in every iteration. The <code>limit</code> constant also declares a type different from the return of the <code>Math.sqrt</code> function, but it’s cast (or converted) using the <code>as i32 </code>suffix.</p>



<p>In the return, we can see the definition of a tuple. We are returning two values instead of only one based on this technique. Languages like Python, Erlang, or Elixir use this type of data. This makes it possible to create a set of values to be handled in different situations.</p>



<h2 id="roadmap-looking-into-the-future">Roadmap: looking into the future </h2>



<p>Carbon is an experiment at the moment, but you can check the <a href="https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/roadmap.md">roadmap</a> and see how it is progressing. By comparing the previous entries for the same document we can see that the expected release (stopping the experiment) was slated for 2023, then 2024, and now it has been moved to 2025-2026. However, one thing we can see in the <a href="https://github.com/carbon-language/carbon-lang/graphs/code-frequency">Github Insights</a> is that Carbon is moving fast and it’s not stopping.</p>



<p>Is it going to be a real replacement for C++? We can only guess at the moment but keep in mind other initiatives like Swift or Kotlin. Carbon could be accepted and adopted by most of the big companies that wanted to solve the issues Carbon is addressing, issues addressed by the proposals we enumerated in the beginning of this article.</p>


	</div></div>
  </body>
</html>
