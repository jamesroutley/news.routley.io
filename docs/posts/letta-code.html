<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.letta.com/blog/letta-code">Original</a>
    <h1>Letta Code</h1>
    
    <div id="readability-page-1" class="page"><div><div fs-toc-element="contents"><figure><p><iframe allowfullscreen="true" frameborder="0" scrolling="no" src="https://www.youtube.com/embed/TC-Q2ulTPhw" title="Letta Code: a memory-first coding agent"></iframe></p></figure><p>Letta Code is a memory-first coding agent, designed for working with agents that learn over time. When working with coding agents today, interactions happen in independent sessions. Letta Code is built around long-lived agents that persist across sessions and improve with use. Rather than working in independent sessions, each session is tied to a persisted agent that learns. Letta Code is also the #1 model-agnostic OSS harness on TerminalBench, and achieves comparable performance to harnesses built by LLM providers (<a href="https://code.claude.com/docs/en/overview">Claude Code</a>, <a href="https://github.com/google-gemini/gemini-cli">Gemini CLI</a>, <a href="https://openai.com/codex/">Codex CLI</a>) on their own models.</p><h2>Continual Learning &amp; Memory for Coding Agents </h2><p>Agents today accumulate valuable experience: they receive the user’s preferences and feedback, review significant parts of code, and observe the outcomes of taking actions like running scripts or commands. Yet today this experience is largely wasted. Letta agents learn from experience through <a href="https://arxiv.org/pdf/2310.08560">agentic</a> <a href="https://arxiv.org/abs/2510.04618">context engineering</a>, <a href="https://www.letta.com/blog/agent-memory">long-term memory</a>, and <a href="https://www.letta.com/blog/skill-learning">skill learning</a>. The more you work with an agent, the more context and memory it accumulates, and the better it becomes. </p><h3><strong>Memory Initialization </strong></h3><p>When you get started with Letta Code, you can run an `/init` command to encourage your agent to learn about your existing project. This will trigger your agent to run deep research on your local codebase, forming memories and rewriting its system prompt (through <a href="https://www.letta.com/blog/memory-blocks">memory blocks</a>) as it learns.</p><p>‍</p><p>‍</p><p>Your agent will continue to learn automatically, but you can also explicitly trigger your agent to reflect and learn with the `/remember` command. </p><h3><strong>Skill Learning </strong></h3><p>Many tasks that we work on with coding agents are repeated or follow similar patterns - for example API patterns or running DB migrations. Once you’ve worked with an agent to coach it through a complex task, you can trigger it to learn a skill from its experience, so the agent itself or other agents can reference the skill for similar tasks in the future. <a href="https://www.letta.com/blog/skill-learning">Skill learning</a> can dramatically improve performance on future similar tasks, as we showed with recent results on TerminalBench.</p><p>On our team, some skills that agents have contributed (with the help of human engineers) are: </p><ul role="list"><li>Generating DB migrations on schema changes</li><li>Creating PostHog dashboards with the PostHog CLI</li><li>Best practices for API changes   </li></ul><p>Since skills are simply <code>.md</code> files, they can be managed in git repositories for versioning - or even used by other coding agents that support skills. </p><h3><strong>Persisted State</strong></h3><p>Agents can also lookup past conversations (or even conversations of other agents) through the <a href="https://docs.letta.com/api">Letta API</a>. The builtin `/search` command allows you to easily search through messages, so you can find the agent you worked on something with. The Letta API supports vector, full-text, and hybrid search over <a href="https://docs.letta.com/api/resources/messages/methods/search">messages</a> and <a href="https://docs.letta.com/api/resources/tools/methods/search">available tools</a>.</p><h2>Letta Code is the #1 model-agnostic OSS coding harness </h2><p>Letta Code adds statefulness and learning to coding agents, but is the #1 model-agnostic, OSS harness on <a href="https://www.tbench.ai/">Terminal-Bench</a>. Letta Code’s performance is comparable to provider-specific harnesses (Gemini CLI, Claude Code, Codex) across model providers, and significantly outperforms the previous leading model-agnostic harness, Terminus 2.</p><figure><p><img src="https://cdn.prod.website-files.com/66bb3d1f468f0f3848a20a84/69419fd8e48a3dd80df1c6e5_letta-code-chart-4x.png" loading="lazy" alt=""/></p></figure><p>This means that even without memory, you can expect Letta Code agents to work just as well with a frontier model as they would with a specific harness built by the model provider. </p><h2>Getting Started with Letta Code </h2><p>To try out Letta Code, you can install it with <code>npm install -g @letta-ai/letta-code</code> or <a href="https://github.com/letta-ai/letta-code">install from source</a> (see the full <a href="https://docs.letta.com/letta-code">documentation</a>).</p><p>Letta Code can be used with the <a href="https://app.letta.com/">Letta Developer Platform</a>, or with a self-hosted Letta server.</p></div></div></div>
  </body>
</html>
