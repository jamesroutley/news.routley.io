<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/2021/12/03/pg-graphql">Original</a>
    <h1>Pg_GraphQL: A GraphQL Extension for PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p>Today we&#39;re open sourcing <a href="https://github.com/supabase/pg_graphql"><code>pg_graphql</code></a>, a work-in-progress native PostgreSQL extension adding GraphQL support. The extension keeps schema generation, query parsing, and resolvers all neatly contained on your database server requiring no external services.</p><p><code>pg_graphql</code> inspects an existing PostgreSQL schema and reflects a GraphQL schema with resolvers that are:</p><ul><li>performant</li><li>always up-to-date</li><li>compliant with best practices</li><li>serverless</li><li>open source</li></ul><p>Interested? You&#39;re <a href="https://supabase.github.io/pg_graphql/quickstart/">3 commands away</a> from a live <a href="https://graphql-dotnet.github.io/docs/getting-started/graphiql/">GraphiQL</a> demo.</p><h2 id="motivation">Motivation</h2><p>The Supabase stack is centered around PostgreSQL as the single source of truth. All data, configuration, and security are housed in the database so any GraphQL solution needed to be equivalently SQL-centric.</p><p>With that in mind, we took a look at the landscape and considered two excellent technologies, <a href="https://www.graphile.org/postgraphile/">Graphile</a>, and <a href="https://hasura.io/">Hasura</a>.</p><table><thead><tr><th>Requirements</th><th>Graphile</th><th>Hasura</th></tr></thead><tbody><tr><td>Open Source</td><td>âœ…</td><td>âœ…</td></tr><tr><td>Reflected GraphQL Schema</td><td>âœ…</td><td>âœ…</td></tr><tr><td>Reflected Resolvers</td><td>âœ…</td><td>âœ…</td></tr><tr><td>Always up-to-date</td><td>âœ…</td><td>âœ…</td></tr><tr><td>Performant</td><td>âœ…</td><td>âœ…</td></tr></tbody></table><p>We found both options to be largely viable for the core feature set. </p><p>Which left us with one final hang-up: we host free-tier projects on VMs with 1 GB of memory. After tallying the resources reserved for PostgreSQL, PostgREST, Kong, GoTrue, and a handful of smaller services, we were left with a total memory budget of ... 0 MB ðŸ˜¬. Unsurprisingly, our pathological memory target disqualified any option that required launching another process in those VMs.</p><p>For that reason, we decided to invest in a lightweight alternative that runs in the database, and can be exposed over HTTP using the existing <a href="https://supabase.com/docs/guides/api">PostgREST</a> deployments&#39; <a href="https://postgrest.org/en/v8.0/api.html#stored-procedures">RPC functionality.</a></p><p>By our most conservative estimate, that reduces the platform&#39;s memory requirements by 525 TB/hours every month, saving ðŸ’° and ðŸŒ³.</p><h2 id="design">Design</h2><p>As a native PostgreSQL extension, <code>pg_graphl</code> is written in a combination of C and SQL. Each GraphQL query is parsed, validated, and transpiled to SQL, all within the database.</p><p>Each GraphQL request is resolved by a single SQL statement. That SQL statement aggregates requested data as a JSON document to return to the caller. This approach results blazing fast response times, avoids the <a href="https://medium.com/the-marcy-lab-school/what-is-the-n-1-problem-in-graphql-dd4921cb3c1a">N+1 query problem</a>, and hits the theoretical minimum achievable network IO of any GraphQL to SQL resolver. No special permissions are required for the PostgreSQL role executing queries so <code>pg_graphql</code> is fully compatible with your existing <a href="https://supabase.com/docs/guides/auth/row-level-security">row level security policies</a>.</p><p>Embedding the GraphQL server directly in the database enables us leverage PostgreSQL&#39;s built-in solutions for common challenges:</p><p>Caching â†’ <code>PREPARE STATEMENT</code></p><p>Errors â†’ <code>RAISE EXCEPTION</code></p><p>Bad Data â†’ <code>ROLLBACK</code></p><p>Authorization â†’ <code>CREATE POLICY</code></p><p>Similarly, <code>pg_graphql</code> benefits from PostgreSQL&#39;s strong <a href="https://database.guide/what-is-acid-in-databases/">ACID</a> guarantees and can expose them through its API.</p><p>Ever wanted to execute multiple operations in a single transaction? Each request is managed in a single transaction so with a multi-operation GraphQL request and <code>pg_graphql</code>, that behavior falls out for free!</p><h3 id="schema-reflection">Schema Reflection</h3><p>As a limited example of how the reflection engine works, here&#39;s how it converts a single table into a full GraphQL schema.</p><pre><div><pre><code><span># schema.sql
</span><span></span><span>create</span><span> </span><span>table</span><span> account(
</span><span>    id serial </span><span>primary</span><span> key,
</span><span>    email </span><span>varchar</span><span>(</span><span>255</span><span>) </span><span>not</span><span> </span><span>null</span><span>,
</span><span>    created_at </span><span>timestamp</span><span> </span><span>not</span><span> </span><span>null</span><span>,
</span><span>    updated_at </span><span>timestamp</span><span> </span><span>not</span><span> </span><span>null</span><span>
</span>);

</code></pre></div></pre><p>Translates into</p><pre><div><pre><code><span># schema.graphql</span><span>
</span><span></span><span>scalar</span><span> </span><span>Cursor</span><span>
</span><span></span><span>scalar</span><span> </span><span>DateTime</span><span>
</span><span></span><span>scalar</span><span> </span><span>JSON</span><span>
</span><span></span><span>scalar</span><span> </span><span>UUID</span><span>
</span><span></span><span>scalar</span><span> </span><span>BigInt</span><span>
</span>
<span></span><span>type</span><span> </span><span>PageInfo</span><span> {
</span><span>  </span><span>hasNextPage</span><span>: </span><span>Boolean</span><span>!
</span><span>  </span><span>hasPreviousPage</span><span>: </span><span>Boolean</span><span>!
</span><span>  </span><span>startCursor</span><span>: </span><span>String</span><span>!
</span><span>  </span><span>endCursor</span><span>: </span><span>String</span><span>!
</span><span>}</span><span>
</span>
<span></span><span>type</span><span> </span><span>Query</span><span> {
</span><span>  </span><span>account</span><span>(</span><span>nodeId</span><span>: </span><span>ID</span><span>!): </span><span>Account</span><span>
</span><span>  </span><span>allAccounts</span><span>(
</span><span>        </span><span>after</span><span>: </span><span>Cursor</span><span>,
</span><span>        </span><span>before</span><span>: </span><span>Cursor</span><span>,
</span><span>        </span><span>first</span><span>: </span><span>Int</span><span>,
</span><span>        </span><span>last</span><span>: </span><span>Int</span><span>
</span><span>    ): </span><span>AccountConnection</span><span> 
</span><span>}</span><span>
</span>
<span></span><span>type</span><span> </span><span>Account</span><span> {
</span><span>  </span><span>nodeId</span><span>: </span><span>ID</span><span>!
</span><span>  </span><span>id</span><span>: </span><span>String</span><span>!
</span><span>  </span><span>email</span><span>: </span><span>String</span><span>!
</span><span>  </span><span>createdAt</span><span>: </span><span>DateTime</span><span>!
</span><span>  </span><span>updatedAt</span><span>: </span><span>DateTime</span><span>!
</span><span>}</span><span>
</span>
<span></span><span>type</span><span> </span><span>AccountEdge</span><span> {
</span><span>  </span><span>cursor</span><span>: </span><span>String</span><span>!
</span><span>  </span><span>node</span><span>: </span><span>Account</span><span>
</span><span>}</span><span>
</span>
<span></span><span>type</span><span> </span><span>AccountConnection</span><span> {
</span><span>  </span><span>totalCount</span><span>: </span><span>Int</span><span>!
</span><span>  </span><span>pageInfo</span><span>: </span><span>PageInfo</span><span>!
</span><span>  </span><span>edges</span><span>: [</span><span>AccountEdge</span><span>]
</span><span>}</span><span>
</span>
</code></pre></div></pre><p>Where <code>Query</code> type&#39;s <code>account</code> field selects a single account by its globally unique <code>ID</code> and <code>allAccounts</code> enables pagination via the <a href="https://relay.dev/graphql/connections.htm">relay connections specification</a>. Under the SQL hood, iterating through pages is handled using keyset pagination giving consistent retrieval times on every page.</p><p>For a more complete examples with relationships, enums, and more exotic types check out the <a href="https://supabase.github.io/pg_graphql/reflection">reflection doc</a>.</p><h3 id="api">API</h3><p><code>pg_graphql</code>&#39;s public API is a single SQL function that returns JSON.</p><pre><div><pre><code><span>gql.resolve(
</span><span>    stmt text, </span><span>-- the graphql query/mutation</span><span>
</span><span>    variables jsonb </span><span>default</span><span> </span><span>&#39;{}&#39;</span><span>::jsonb, </span><span>-- key value pairs</span><span>
</span>)
<span>    </span><span>returns</span><span> jsonb
</span>
</code></pre></div></pre><p>For example, a GraphQL query selecting the <code>id</code> field for a collection of type <code>Book</code> would look like this:</p><pre><div><pre><code><span>gqldb</span><span>=</span><span> </span><span>select</span><span> gql.resolve($$
</span>
query {
  allBooks {
    edges {
      node {
        id
      }
    }
  }
}

$$);

             resolve
<span></span><span>----------------------------------------------------------------------</span><span>
</span><span>{&#34;data&#34;: {&#34;allBooks&#34;: {&#34;edges&#34;: [{&#34;node&#34;: {&#34;id&#34;: </span><span>1</span><span>}}]}}, &#34;errors&#34;: []}
</span>
</code></pre></div></pre><p>We&#39;re opting to expose the function over HTTP through PostgREST but you could also connect to the PostgreSQL database and call the function directly from your server code in any programming language.</p><h2 id="performance">Performance</h2><p>When it comes to APIs, performance counts. Here are some figures from <a href="https://www.tutorialspoint.com/apache_bench/apache_bench_quick_guide.htm">Apache Bench</a> showing 2,205 requests/second on a 4 core machine with 16 GB of memory.</p><pre><div><pre><code><span>Concurrency Level:      8
</span>Time taken for tests:   3.628 seconds
Complete requests:      8000
Failed requests:        0
Total transferred:      1768000 bytes
Total body sent:        1928000
HTML transferred:       368000 bytes
Requests per second:    2205.21 [#/sec] (mean)
Time per request:       3.628 [ms] (mean)
Time per request:       0.453 [ms] (mean, across all concurrent requests)
Transfer rate:          475.93 [Kbytes/sec] received

</code></pre></div></pre><p>Full steps to reproduce this output are available in <a href="https://supabase.github.io/pg_graphql">the docs</a>.</p><h2 id="open-source">Open Source</h2><p><code>pg_graphql</code> is <a href="https://github.com/supabase/pg_graphql/">open source software</a>. As always, Issues and PRs are welcome.</p><p><a href="https://supabase.github.io/pg_graphql/quickstart/">Try <code>pg_graphql</code></a> today to see a live <a href="https://graphql-dotnet.github.io/docs/getting-started/graphiql/">GraphiQL</a> demo.</p></div></div></article></div>
  </body>
</html>
