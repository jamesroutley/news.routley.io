<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://k-monk.org/blog/minimal-parenthesization-of-lambda-terms/">Original</a>
    <h1>Minimal Parenthesization of Lambda Terms</h1>
    
    <div id="readability-page-1" class="page"><div>
      

<p><strong>2024-09-15</strong></p>
<p><em>Thanks to <a rel="noopener" target="_blank" href="https://bernsteinbear.com/">Max Bernstein</a> for inspiring me to write this.</em></p>
<p>When writing a compiler, it&#39;s useful to be able to visualize the syntax tree as it gets processed. One simple way of doing so is to serialize the tree to text, using parentheses to specify the structure. The most naive approach is to simply wrap every subexpression in parentheses, which means we get representations that look like</p>
<pre><code><span>(((((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9) + 10)
</span></code></pre>
<p>even though a human would have probably written the term as</p>
<pre><code><span>1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
</span></code></pre>
<p>As terms become bigger, excessive parentheses make it hard to look at a term and quickly understand its structure. Max Bernstein has <a rel="noopener" target="_blank" href="https://bernsteinbear.com/blog/precedence-printing/">written</a> about a simple algorithm that finds the minimal parenthesization necessary for terms in an arithmetic expression language. We&#39;ll apply the same idea to the <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply typed lambda calculus</a> (implemented in OCaml).</p>
<h3 id="the-term-language">The Term Language</h3>
<p>Our calculus will have a single base type of machine integers:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>type ty </span><span>=
</span><span>  | </span><span>Z64                 </span><span>(* machine integers *)
</span><span>  | </span><span>Arrow </span><span>of ty * ty    </span><span>(* functions        *)
</span></code></pre>
<p>We&#39;ll use strings as identifiers:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>type identifier </span><span>= </span><span>string
</span><span>
</span><span>(* associate an identifier with some value *)
</span><span>type &#39;a binding </span><span>= {
</span><span>  name : </span><span>identifier ;
</span><span>  value : </span><span>&#39;a ;
</span><span>}
</span></code></pre>
<p>We&#39;ll include primitive operations for integer addition, subtraction, multiplication, and exponentiation:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>type binop </span><span>=
</span><span>  | </span><span>Add
</span><span>  | </span><span>Sub
</span><span>  | </span><span>Mul
</span><span>  | </span><span>Exp
</span></code></pre>
<p>Expressions are defined as follows:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>type expression </span><span>=
</span><span>  | </span><span>Lit </span><span>of int                                  </span><span>(* integer literal      *)
</span><span>  | </span><span>Bin </span><span>of binop * expression * expression      </span><span>(* integer arithmetic   *)
</span><span>  | </span><span>Var </span><span>of identifier                           </span><span>(* variable             *)
</span><span>  | </span><span>App </span><span>of expression * expression              </span><span>(* function application *)
</span><span>  | </span><span>Abs </span><span>of ty binding * expression              </span><span>(* function abstraction *)
</span></code></pre>
<h3 id="representing-types">Representing Types</h3>
<p>Let&#39;s start by considering the problem in the case of types, which have a relatively simple grammar. A naive implementation might look something like the following:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>let </span><span>print </span><span>= </span><span>Printf.sprintf
</span><span>
</span><span>let rec </span><span>naive_show_ty </span><span>: </span><span>ty -&gt; string = function
</span><span>  </span><span>| </span><span>Z64 </span><span>-&gt; </span><span>&#34;Z&#34;
</span><span>  </span><span>| </span><span>Arrow </span><span>(domain, codomain) -&gt;
</span><span>      print </span><span>&#34;(%s -&gt; %s)&#34; </span><span>(naive_show_ty domain) (naive_show_ty codomain)
</span></code></pre>
<p>This will represent the type <code>Arrow (Z64, Arrow (Z64, Z64))</code> as <code>&#34;(Z -&gt; (Z -&gt; Z))&#34;</code>. If we take function arrows to be right associative (as they conventionally are), then this could have been represented as <code>&#34;Z -&gt; Z -&gt; Z&#34;</code>.</p>
<p>In the case of types, the only information we need is <em>whether we are on the left of a function arrow</em>, in which case an arrow will need to be parenthesized. We can pass that information down, recursively. The resulting algorithm is:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>let </span><span>show_ty </span><span>: </span><span>ty -&gt; string =
</span><span>  </span><span>let rec </span><span>show </span><span>(left </span><span>: bool</span><span>) </span><span>= function
</span><span>    </span><span>| </span><span>Z64 </span><span>-&gt; </span><span>&#34;Z&#34;
</span><span>    </span><span>| </span><span>Arrow </span><span>(domain, codomain) -&gt;
</span><span>        </span><span>let </span><span>representation </span><span>=</span><span> print </span><span>&#34;%s -&gt; %s&#34; </span><span>(show </span><span>true</span><span> domain) (show </span><span>false</span><span> codomain) </span><span>in
</span><span>        </span><span>if</span><span> left </span><span>then</span><span> print </span><span>&#34;(%s)&#34;</span><span> representation </span><span>else</span><span> representation </span><span>in
</span><span>  show </span><span>false
</span></code></pre>
<h3 id="representing-terms">Representing Terms</h3>
<p>The same kind of idea applies to the more complicated grammar of terms. <strong>The key insight is that parenthesization decisions require only local context: parentheses are necessary if and only if the precedence of an operation is less than or equal to the precedence of the parent.</strong> For example, the fact that <code>3 + 4</code> must be parenthesized in <code>1 + 2 * (3 + 4) - 5</code> depends only on the fact that <code>+</code> has lower precedence than <code>*</code>.</p>
<p>As we descend the syntax tree, we&#39;ll pass down the precedence of each parent. In other words, we&#39;ll pass down the <em>minimum precedence needed to avoid parenthesization</em> at each step. (Associativity may be understood as requiring one less level of precedence on the associative side.)</p>
<p>Here&#39;s the precedence and associativity table for our expression language:</p>
<pre><code><span>OPERATION     PRECEDENCE  ASSOCIATIVITY
</span><span>lambda        1           n/a
</span><span>+             2           left
</span><span>-             2           left
</span><span>*             3           left
</span><span>^             4           right
</span><span>application   5           left
</span></code></pre>
<p>We&#39;ll express our text serialization algorithm in terms of nullary, unary, and binary operations with precedence and associativity. To do this, we&#39;ll define a data structure that captures the relevant properties of an operation:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>type associativity </span><span>=
</span><span>  | </span><span>Left
</span><span>  | </span><span>Right
</span><span>
</span><span>type precedence </span><span>= </span><span>int
</span><span>
</span><span>type operation </span><span>=
</span><span>  | </span><span>Nullary
</span><span>  | </span><span>Unary   </span><span>of precedence * expression
</span><span>  </span><span>(* associativity is only applicable in the case of binary operations *)
</span><span>  | </span><span>Binary  </span><span>of precedence * associativity * expression * expression
</span></code></pre>
<p>Mapping our expression language into this form is straightforward:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>let </span><span>structure </span><span>: </span><span>expression -&gt; operation = function
</span><span>  </span><span>| </span><span>Lit </span><span>_ </span><span>-&gt; </span><span>Nullary
</span><span>  </span><span>| </span><span>Bin </span><span>(op, lhs, rhs) -&gt;
</span><span>      </span><span>begin match</span><span> op </span><span>with
</span><span>      </span><span>| </span><span>Add </span><span>-&gt; </span><span>Binary </span><span>(2, </span><span>Left</span><span> , lhs, rhs)
</span><span>      </span><span>| </span><span>Sub </span><span>-&gt; </span><span>Binary </span><span>(2, </span><span>Left</span><span> , lhs, rhs)
</span><span>      </span><span>| </span><span>Mul </span><span>-&gt; </span><span>Binary </span><span>(3, </span><span>Left</span><span> , lhs, rhs)
</span><span>      </span><span>| </span><span>Exp </span><span>-&gt; </span><span>Binary </span><span>(4, </span><span>Right</span><span>, lhs, rhs)
</span><span>      </span><span>end
</span><span>  </span><span>| </span><span>Var </span><span>_ </span><span>-&gt; </span><span>Nullary
</span><span>  </span><span>| </span><span>App </span><span>(f, x) -&gt; </span><span>Binary </span><span>(5, </span><span>Left</span><span>, f, x)
</span><span>  </span><span>| </span><span>Abs </span><span>(_, body) -&gt; </span><span>Unary </span><span>(1, body)
</span></code></pre>
<p>These precedence and associativity values could be read from some other source here, if we wanted to share the data with a parser.</p>
<p>Notice that lambda abstraction is a unary operator, but it doesn&#39;t have a constant textual representation in the way that the arithmetic operators do. To account for this, we&#39;ll express the representation of a node as a function:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>let </span><span>node_text </span><span>: </span><span>expression -&gt; string = function
</span><span>  </span><span>| </span><span>Lit </span><span>i -&gt; print </span><span>&#34;%d&#34;</span><span> i
</span><span>  </span><span>| </span><span>Bin </span><span>(Add, _, _) -&gt; </span><span>&#34; + &#34;
</span><span>  </span><span>| </span><span>Bin </span><span>(Sub, _, _) -&gt; </span><span>&#34; - &#34;
</span><span>  </span><span>| </span><span>Bin </span><span>(Mul, _, _) -&gt; </span><span>&#34; * &#34;
</span><span>  </span><span>| </span><span>Bin </span><span>(Exp, _, _) -&gt; </span><span>&#34; ^ &#34;
</span><span>  </span><span>| </span><span>Var </span><span>id -&gt; id
</span><span>  </span><span>| </span><span>App </span><span>_ </span><span>-&gt; </span><span>&#34; &#34;
</span><span>  </span><span>| </span><span>Abs </span><span>({ name ; value = domain }, _) -&gt;
</span><span>      print </span><span>&#34;λ %s : %s . &#34;</span><span> name (show_ty domain)
</span></code></pre>
<p>At this point, we&#39;re ready to write the complete serializer:</p>
<pre data-lang="OCaml"><code data-lang="OCaml"><span>let </span><span>show_expression </span><span>: </span><span>expression -&gt; string =
</span><span>
</span><span>  </span><span>(* wrap a string in parentheses when a condition is met *)
</span><span>  </span><span>let </span><span>wrap </span><span>(s </span><span>: string</span><span>) (condition </span><span>: bool</span><span>) </span><span>=
</span><span>    </span><span>if</span><span> condition </span><span>then</span><span> print </span><span>&#34;(%s)&#34;</span><span> s </span><span>else</span><span> s </span><span>in
</span><span>
</span><span>  </span><span>let rec </span><span>show </span><span>(p </span><span>: precedence</span><span>) (expr </span><span>: expression</span><span>) </span><span>=
</span><span>    </span><span>let </span><span>atom </span><span>=</span><span> node_text expr </span><span>in
</span><span>    </span><span>match</span><span> structure expr </span><span>with
</span><span>    </span><span>| </span><span>Nullary </span><span>-&gt; atom
</span><span>    </span><span>| </span><span>Unary </span><span>(p&#39;, e) -&gt;
</span><span>        </span><span>let </span><span>s </span><span>=</span><span> print </span><span>&#34;%s%s&#34;</span><span> atom (show (p&#39; </span><span>- </span><span>1) e) </span><span>in
</span><span>        wrap s (p&#39; </span><span>&lt;=</span><span> p)
</span><span>    </span><span>| </span><span>Binary </span><span>(p&#39;, assoc, lhs, rhs) -&gt;
</span><span>        </span><span>let </span><span>(left, right) </span><span>= match</span><span> assoc </span><span>with
</span><span>        </span><span>| </span><span>Left  </span><span>-&gt; (p&#39; </span><span>- </span><span>1, p&#39;)
</span><span>        </span><span>| </span><span>Right </span><span>-&gt; (p&#39;, p&#39; </span><span>- </span><span>1) </span><span>in
</span><span>        </span><span>let </span><span>s </span><span>=</span><span> print </span><span>&#34;%s%s%s&#34; </span><span>(show left lhs) atom (show right rhs) </span><span>in
</span><span>        wrap s (p&#39; </span><span>&lt;=</span><span> p) </span><span>in
</span><span>
</span><span>  show 0
</span></code></pre>
<p>For unary and binary operators, the pattern is the same: we compare the precedence of the subterm we&#39;re looking at (p&#39;) to the minimum precedence passed down by the parent (p). When p&#39; isn&#39;t greater than the minimum, we wrap the subterm in parentheses. When an operator is left or right associative, we subtract one from the minimum precedence to pass down on the left or right, respectively.</p>
<p>This gives us representations that look like this:</p>
<pre><code><span>(λ a : Z . λ b : Z . a + b) 1 2 * (λ a : Z . λ b : Z . a - b) 3 4
</span></code></pre>
<h3 id="resources">Resources</h3>
<ul>
<li>the source code in this document is available <a rel="noopener" target="_blank" href="https://github.com/rdck/minimal-parenthesization">here</a></li>
<li>Max Bernstein&#39;s <a rel="noopener" target="_blank" href="https://bernsteinbear.com/blog/precedence-printing/">implementation</a> that inspired this article</li>
<li>a <a rel="noopener" target="_blank" href="https://softwarefoundations.cis.upenn.edu/plf-current/Stlc.html">chapter</a> on the simply typed lambda calculus in <a rel="noopener" target="_blank" href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a></li>
</ul>


    </div></div>
  </body>
</html>
