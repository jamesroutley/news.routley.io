<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.kernel.org/driver-api/mtd/nand_ecc.html">Original</a>
    <h1>NAND Error-correction Code</h1>
    
    <div id="readability-page-1" class="page"><div>
    
      
      <div>
        <div>
          

          <div role="main">
            
  <section id="nand-error-correction-code">

<section id="introduction">
<h2>Introduction<a href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>Having looked at the linux mtd/nand Hamming software ECC engine driver
I felt there was room for optimisation. I bashed the code for a few hours
performing tricks like table lookup removing superfluous code etc.
After that the speed was increased by 35-40%.
Still I was not too happy as I felt there was additional room for improvement.</p>
<p>Bad! I was hooked.
I decided to annotate my steps in this file. Perhaps it is useful to someone
or someone learns something from it.</p>
</section>
<section id="the-problem">
<h2>The problem<a href="#the-problem" title="Permalink to this heading">¶</a></h2>
<p>NAND flash (at least SLC one) typically has sectors of 256 bytes.
However NAND flash is not extremely reliable so some error detection
(and sometimes correction) is needed.</p>
<p>This is done by means of a Hamming code. I&#39;ll try to explain it in
laymans terms (and apologies to all the pro&#39;s in the field in case I do
not use the right terminology, my coding theory class was almost 30
years ago, and I must admit it was not one of my favourites).</p>
<p>As I said before the ecc calculation is performed on sectors of 256
bytes. This is done by calculating several parity bits over the rows and
columns. The parity used is even parity which means that the parity bit = 1
if the data over which the parity is calculated is 1 and the parity bit = 0
if the data over which the parity is calculated is 0. So the total
number of bits over the data over which the parity is calculated + the
parity bit is even. (see wikipedia if you can&#39;t follow this).
Parity is often calculated by means of an exclusive or operation,
sometimes also referred to as xor. In C the operator for xor is ^</p>
<p>Back to ecc.
Let&#39;s give a small figure:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr><td><p>byte   0:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr><td><p>byte   1:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp2</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr><td><p>byte   2:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr><td><p>byte   3:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp4</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr><td><p>byte   4:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp2</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp14</p></td>
</tr>
<tr><td><p>...</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr><td><p>byte 254:</p></td>
<td><p>bit7</p></td>
<td><p>bit6</p></td>
<td><p>bit5</p></td>
<td><p>bit4</p></td>
<td><p>bit3</p></td>
<td><p>bit2</p></td>
<td><p>bit1</p></td>
<td><p>bit0</p></td>
<td><p>rp0</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp15</p></td>
</tr>
<tr><td><p>byte 255:</p></td>
<td><p>bit7
cp1
cp3
cp5</p></td>
<td><p>bit6
cp0
cp3
cp5</p></td>
<td><p>bit5
cp1
cp2
cp5</p></td>
<td><p>bit4
cp0
cp2
cp5</p></td>
<td><p>bit3
cp1
cp3
cp4</p></td>
<td><p>bit2
cp0
cp3
cp4</p></td>
<td><p>bit1
cp1
cp2
cp4</p></td>
<td><p>bit0
cp0
cp2
cp4</p></td>
<td><p>rp1</p></td>
<td><p>rp3</p></td>
<td><p>rp5</p></td>
<td><p>...</p></td>
<td><p>rp15</p></td>
</tr>
</tbody>
</table>
<p>This figure represents a sector of 256 bytes.
cp is my abbreviation for column parity, rp for row parity.</p>
<p>Let&#39;s start to explain column parity.</p>
<ul>
<li><p>cp0 is the parity that belongs to all bit0, bit2, bit4, bit6.</p>
<p>so the sum of all bit0, bit2, bit4 and bit6 values + cp0 itself is even.</p>
</li>
</ul>
<p>Similarly cp1 is the sum of all bit1, bit3, bit5 and bit7.</p>
<ul>
<li><p>cp2 is the parity over bit0, bit1, bit4 and bit5</p></li>
<li><p>cp3 is the parity over bit2, bit3, bit6 and bit7.</p></li>
<li><p>cp4 is the parity over bit0, bit1, bit2 and bit3.</p></li>
<li><p>cp5 is the parity over bit4, bit5, bit6 and bit7.</p></li>
</ul>
<p>Note that each of cp0 .. cp5 is exactly one bit.</p>
<p>Row parity actually works almost the same.</p>
<ul>
<li><p>rp0 is the parity of all even bytes (0, 2, 4, 6, ... 252, 254)</p></li>
<li><p>rp1 is the parity of all odd bytes (1, 3, 5, 7, ..., 253, 255)</p></li>
<li><p>rp2 is the parity of all bytes 0, 1, 4, 5, 8, 9, ...
(so handle two bytes, then skip 2 bytes).</p></li>
<li><p>rp3 is covers the half rp2 does not cover (bytes 2, 3, 6, 7, 10, 11, ...)</p></li>
<li><p>for rp4 the rule is cover 4 bytes, skip 4 bytes, cover 4 bytes, skip 4 etc.</p>
<p>so rp4 calculates parity over bytes 0, 1, 2, 3, 8, 9, 10, 11, 16, ...)</p>
</li>
<li><p>and rp5 covers the other half, so bytes 4, 5, 6, 7, 12, 13, 14, 15, 20, ..</p></li>
</ul>
<p>The story now becomes quite boring. I guess you get the idea.</p>
<ul>
<li><p>rp6 covers 8 bytes then skips 8 etc</p></li>
<li><p>rp7 skips 8 bytes then covers 8 etc</p></li>
<li><p>rp8 covers 16 bytes then skips 16 etc</p></li>
<li><p>rp9 skips 16 bytes then covers 16 etc</p></li>
<li><p>rp10 covers 32 bytes then skips 32 etc</p></li>
<li><p>rp11 skips 32 bytes then covers 32 etc</p></li>
<li><p>rp12 covers 64 bytes then skips 64 etc</p></li>
<li><p>rp13 skips 64 bytes then covers 64 etc</p></li>
<li><p>rp14 covers 128 bytes then skips 128</p></li>
<li><p>rp15 skips 128 bytes then covers 128</p></li>
</ul>
<p>In the end the parity bits are grouped together in three bytes as
follows:</p>
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr><th><p>ECC</p></th>
<th><p>Bit 7</p></th>
<th><p>Bit 6</p></th>
<th><p>Bit 5</p></th>
<th><p>Bit 4</p></th>
<th><p>Bit 3</p></th>
<th><p>Bit 2</p></th>
<th><p>Bit 1</p></th>
<th><p>Bit 0</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>ECC 0</p></td>
<td><p>rp07</p></td>
<td><p>rp06</p></td>
<td><p>rp05</p></td>
<td><p>rp04</p></td>
<td><p>rp03</p></td>
<td><p>rp02</p></td>
<td><p>rp01</p></td>
<td><p>rp00</p></td>
</tr>
<tr><td><p>ECC 1</p></td>
<td><p>rp15</p></td>
<td><p>rp14</p></td>
<td><p>rp13</p></td>
<td><p>rp12</p></td>
<td><p>rp11</p></td>
<td><p>rp10</p></td>
<td><p>rp09</p></td>
<td><p>rp08</p></td>
</tr>
<tr><td><p>ECC 2</p></td>
<td><p>cp5</p></td>
<td><p>cp4</p></td>
<td><p>cp3</p></td>
<td><p>cp2</p></td>
<td><p>cp1</p></td>
<td><p>cp0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
</tbody>
</table>
<p>I detected after writing this that ST application note AN1823
(<a href="http://www.st.com/stonline/">http://www.st.com/stonline/</a>) gives a much
nicer picture.(but they use line parity as term where I use row parity)
Oh well, I&#39;m graphically challenged, so suffer with me for a moment :-)</p>
<p>And I could not reuse the ST picture anyway for copyright reasons.</p>
</section>
<section id="attempt-0">
<h2>Attempt 0<a href="#attempt-0" title="Permalink to this heading">¶</a></h2>
<p>Implementing the parity calculation is pretty simple.
In C pseudocode:</p>
<div><div><pre><span></span>for (i = 0; i &lt; 256; i++)
{
  if (i &amp; 0x01)
     rp1 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp1;
  else
     rp0 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp0;
  if (i &amp; 0x02)
     rp3 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp3;
  else
     rp2 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp2;
  if (i &amp; 0x04)
    rp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp5;
  else
    rp4 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp4;
  if (i &amp; 0x08)
    rp7 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp7;
  else
    rp6 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp6;
  if (i &amp; 0x10)
    rp9 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp9;
  else
    rp8 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp8;
  if (i &amp; 0x20)
    rp11 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp11;
  else
    rp10 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp10;
  if (i &amp; 0x40)
    rp13 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp13;
  else
    rp12 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp12;
  if (i &amp; 0x80)
    rp15 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp15;
  else
    rp14 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ bit3 ^ bit2 ^ bit1 ^ bit0 ^ rp14;
  cp0 = bit6 ^ bit4 ^ bit2 ^ bit0 ^ cp0;
  cp1 = bit7 ^ bit5 ^ bit3 ^ bit1 ^ cp1;
  cp2 = bit5 ^ bit4 ^ bit1 ^ bit0 ^ cp2;
  cp3 = bit7 ^ bit6 ^ bit3 ^ bit2 ^ cp3
  cp4 = bit3 ^ bit2 ^ bit1 ^ bit0 ^ cp4
  cp5 = bit7 ^ bit6 ^ bit5 ^ bit4 ^ cp5
}
</pre></div>
</div>
</section>
<section id="analysis-0">
<h2>Analysis 0<a href="#analysis-0" title="Permalink to this heading">¶</a></h2>
<p>C does have bitwise operators but not really operators to do the above
efficiently (and most hardware has no such instructions either).
Therefore without implementing this it was clear that the code above was
not going to bring me a Nobel prize :-)</p>
<p>Fortunately the exclusive or operation is commutative, so we can combine
the values in any order. So instead of calculating all the bits
individually, let us try to rearrange things.
For the column parity this is easy. We can just xor the bytes and in the
end filter out the relevant bits. This is pretty nice as it will bring
all cp calculation out of the for loop.</p>
<p>Similarly we can first xor the bytes for the various rows.
This leads to:</p>
</section>
<section id="attempt-1">
<h2>Attempt 1<a href="#attempt-1" title="Permalink to this heading">¶</a></h2>
<div><div><pre><span></span>const char parity[256] = {
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0
};

void ecc1(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned char *bp = buf;
    unsigned char cur;
    unsigned char rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned char rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned char par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 256; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp1 ^= cur; else rp0 ^= cur;
        if (i &amp; 0x02) rp3 ^= cur; else rp2 ^= cur;
        if (i &amp; 0x04) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x08) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x10) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x20) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x40) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x80) rp15 ^= cur; else rp14 ^= cur;
    }
    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>Still pretty straightforward. The last three invert statements are there to
give a checksum of 0xff 0xff 0xff for an empty flash. In an empty flash
all data is 0xff, so the checksum then matches.</p>
<p>I also introduced the parity lookup. I expected this to be the fastest
way to calculate the parity, but I will investigate alternatives later
on.</p>
</section>
<section id="analysis-1">
<h2>Analysis 1<a href="#analysis-1" title="Permalink to this heading">¶</a></h2>
<p>The code works, but is not terribly efficient. On my system it took
almost 4 times as much time as the linux driver code. But hey, if it was
<em>that</em> easy this would have been done long before.
No pain. no gain.</p>
<p>Fortunately there is plenty of room for improvement.</p>
<p>In step 1 we moved from bit-wise calculation to byte-wise calculation.
However in C we can also use the unsigned long data type and virtually
every modern microprocessor supports 32 bit operations, so why not try
to write our code in such a way that we process data in 32 bit chunks.</p>
<p>Of course this means some modification as the row parity is byte by
byte. A quick analysis:
for the column parity we use the par variable. When extending to 32 bits
we can in the end easily calculate rp0 and rp1 from it.
(because par now consists of 4 bytes, contributing to rp1, rp0, rp1, rp0
respectively, from MSB to LSB)
also rp2 and rp3 can be easily retrieved from par as rp3 covers the
first two MSBs and rp2 covers the last two LSBs.</p>
<p>Note that of course now the loop is executed only 64 times (256/4).
And note that care must taken wrt byte ordering. The way bytes are
ordered in a long is machine dependent, and might affect us.
Anyway, if there is an issue: this code is developed on x86 (to be
precise: a DELL PC with a D920 Intel CPU)</p>
<p>And of course the performance might depend on alignment, but I expect
that the I/O buffers in the nand driver are aligned properly (and
otherwise that should be fixed to get maximum performance).</p>
<p>Let&#39;s give it a try...</p>
</section>
<section id="attempt-2">
<h2>Attempt 2<a href="#attempt-2" title="Permalink to this heading">¶</a></h2>
<div><div><pre><span></span>extern const char parity[256];

void ecc2(const unsigned char *buf, unsigned char *code)
{
    int i;
    const unsigned long *bp = (unsigned long *)buf;
    unsigned long cur;
    unsigned long rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7;
    unsigned long rp8, rp9, rp10, rp11, rp12, rp13, rp14, rp15;
    unsigned long par;

    par = 0;
    rp0 = 0; rp1 = 0; rp2 = 0; rp3 = 0;
    rp4 = 0; rp5 = 0; rp6 = 0; rp7 = 0;
    rp8 = 0; rp9 = 0; rp10 = 0; rp11 = 0;
    rp12 = 0; rp13 = 0; rp14 = 0; rp15 = 0;

    for (i = 0; i &lt; 64; i++)
    {
        cur = *bp++;
        par ^= cur;
        if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
        if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
        if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
        if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
        if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
        if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
    }
    /*
       we need to adapt the code generation for the fact that rp vars are now
       long; also the column parity calculation needs to be changed.
       we&#39;ll bring rp4 to 15 back to single byte entities by shifting and
       xoring
    */
    rp4 ^= (rp4 &gt;&gt; 16); rp4 ^= (rp4 &gt;&gt; 8); rp4 &amp;= 0xff;
    rp5 ^= (rp5 &gt;&gt; 16); rp5 ^= (rp5 &gt;&gt; 8); rp5 &amp;= 0xff;
    rp6 ^= (rp6 &gt;&gt; 16); rp6 ^= (rp6 &gt;&gt; 8); rp6 &amp;= 0xff;
    rp7 ^= (rp7 &gt;&gt; 16); rp7 ^= (rp7 &gt;&gt; 8); rp7 &amp;= 0xff;
    rp8 ^= (rp8 &gt;&gt; 16); rp8 ^= (rp8 &gt;&gt; 8); rp8 &amp;= 0xff;
    rp9 ^= (rp9 &gt;&gt; 16); rp9 ^= (rp9 &gt;&gt; 8); rp9 &amp;= 0xff;
    rp10 ^= (rp10 &gt;&gt; 16); rp10 ^= (rp10 &gt;&gt; 8); rp10 &amp;= 0xff;
    rp11 ^= (rp11 &gt;&gt; 16); rp11 ^= (rp11 &gt;&gt; 8); rp11 &amp;= 0xff;
    rp12 ^= (rp12 &gt;&gt; 16); rp12 ^= (rp12 &gt;&gt; 8); rp12 &amp;= 0xff;
    rp13 ^= (rp13 &gt;&gt; 16); rp13 ^= (rp13 &gt;&gt; 8); rp13 &amp;= 0xff;
    rp14 ^= (rp14 &gt;&gt; 16); rp14 ^= (rp14 &gt;&gt; 8); rp14 &amp;= 0xff;
    rp15 ^= (rp15 &gt;&gt; 16); rp15 ^= (rp15 &gt;&gt; 8); rp15 &amp;= 0xff;
    rp3 = (par &gt;&gt; 16); rp3 ^= (rp3 &gt;&gt; 8); rp3 &amp;= 0xff;
    rp2 = par &amp; 0xffff; rp2 ^= (rp2 &gt;&gt; 8); rp2 &amp;= 0xff;
    par ^= (par &gt;&gt; 16);
    rp1 = (par &gt;&gt; 8); rp1 &amp;= 0xff;
    rp0 = (par &amp; 0xff);
    par ^= (par &gt;&gt; 8); par &amp;= 0xff;

    code[0] =
        (parity[rp7] &lt;&lt; 7) |
        (parity[rp6] &lt;&lt; 6) |
        (parity[rp5] &lt;&lt; 5) |
        (parity[rp4] &lt;&lt; 4) |
        (parity[rp3] &lt;&lt; 3) |
        (parity[rp2] &lt;&lt; 2) |
        (parity[rp1] &lt;&lt; 1) |
        (parity[rp0]);
    code[1] =
        (parity[rp15] &lt;&lt; 7) |
        (parity[rp14] &lt;&lt; 6) |
        (parity[rp13] &lt;&lt; 5) |
        (parity[rp12] &lt;&lt; 4) |
        (parity[rp11] &lt;&lt; 3) |
        (parity[rp10] &lt;&lt; 2) |
        (parity[rp9]  &lt;&lt; 1) |
        (parity[rp8]);
    code[2] =
        (parity[par &amp; 0xf0] &lt;&lt; 7) |
        (parity[par &amp; 0x0f] &lt;&lt; 6) |
        (parity[par &amp; 0xcc] &lt;&lt; 5) |
        (parity[par &amp; 0x33] &lt;&lt; 4) |
        (parity[par &amp; 0xaa] &lt;&lt; 3) |
        (parity[par &amp; 0x55] &lt;&lt; 2);
    code[0] = ~code[0];
    code[1] = ~code[1];
    code[2] = ~code[2];
}
</pre></div>
</div>
<p>The parity array is not shown any more. Note also that for these
examples I kinda deviated from my regular programming style by allowing
multiple statements on a line, not using { } in then and else blocks
with only a single statement and by using operators like ^=</p>
</section>
<section id="analysis-2">
<h2>Analysis 2<a href="#analysis-2" title="Permalink to this heading">¶</a></h2>
<p>The code (of course) works, and hurray: we are a little bit faster than
the linux driver code (about 15%). But wait, don&#39;t cheer too quickly.
There is more to be gained.
If we look at e.g. rp14 and rp15 we see that we either xor our data with
rp14 or with rp15. However we also have par which goes over all data.
This means there is no need to calculate rp14 as it can be calculated from
rp15 through rp14 = par ^ rp15, because par = rp14 ^ rp15;
(or if desired we can avoid calculating rp15 and calculate it from
rp14).  That is why some places refer to inverse parity.
Of course the same thing holds for rp4/5, rp6/7, rp8/9, rp10/11 and rp12/13.
Effectively this means we can eliminate the else clause from the if
statements. Also we can optimise the calculation in the end a little bit
by going from long to byte first. Actually we can even avoid the table
lookups</p>
</section>
<section id="attempt-3">
<h2>Attempt 3<a href="#attempt-3" title="Permalink to this heading">¶</a></h2>
<p>Odd replaced:</p>
<div><div><pre><span></span>if (i &amp; 0x01) rp5 ^= cur; else rp4 ^= cur;
if (i &amp; 0x02) rp7 ^= cur; else rp6 ^= cur;
if (i &amp; 0x04) rp9 ^= cur; else rp8 ^= cur;
if (i &amp; 0x08) rp11 ^= cur; else rp10 ^= cur;
if (i &amp; 0x10) rp13 ^= cur; else rp12 ^= cur;
if (i &amp; 0x20) rp15 ^= cur; else rp14 ^= cur;
</pre></div>
</div>
<p>with:</p>
<div><div><pre><span></span>if (i &amp; 0x01) rp5 ^= cur;
if (i &amp; 0x02) rp7 ^= cur;
if (i &amp; 0x04) rp9 ^= cur;
if (i &amp; 0x08) rp11 ^= cur;
if (i &amp; 0x10) rp13 ^= cur;
if (i &amp; 0x20) rp15 ^= cur;
</pre></div>
</div>
<p>and outside the loop added:</p>
<div><div><pre><span></span>rp4  = par ^ rp5;
rp6  = par ^ rp7;
rp8  = par ^ rp9;
rp10  = par ^ rp11;
rp12  = par ^ rp13;
rp14  = par ^ rp15;
</pre></div>
</div>
<p>And after that the code takes about 30% more time, although the number of
statements is reduced. This is also reflected in the assembly code.</p>
</section>
<section id="analysis-3">
<h2>Analysis 3<a href="#analysis-3" title="Permalink to this heading">¶</a></h2>
<p>Very weird. Guess it has to do with caching or instruction parallellism
or so. I also tried on an eeePC (Celeron, clocked at 900 Mhz). Interesting
observation was that this one is only 30% slower (according to time)
executing the code as my 3Ghz D920 processor.</p>
<p>Well, it was expected not to be easy so maybe instead move to a
different track: let&#39;s move back to the code from attempt2 and do some
loop unrolling. This will eliminate a few if statements. I&#39;ll try
different amounts of unrolling to see what works best.</p>
</section>
<section id="attempt-4">
<h2>Attempt 4<a href="#attempt-4" title="Permalink to this heading">¶</a></h2>
<p>Unrolled the loop 1, 2, 3 and 4 times.
For 4 the code starts with:</p>
<div><div><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++;
    par ^= cur;
    rp4 ^= cur;
    rp6 ^= cur;
    rp8 ^= cur;
    rp10 ^= cur;
    if (i &amp; 0x1) rp13 ^= cur; else rp12 ^= cur;
    if (i &amp; 0x2) rp15 ^= cur; else rp14 ^= cur;
    cur = *bp++;
    par ^= cur;
    rp5 ^= cur;
    rp6 ^= cur;
    ...
</pre></div>
</div>
</section>
<section id="analysis-4">
<h2>Analysis 4<a href="#analysis-4" title="Permalink to this heading">¶</a></h2>
<p>Unrolling once gains about 15%</p>
<p>Unrolling twice keeps the gain at about 15%</p>
<p>Unrolling three times gives a gain of 30% compared to attempt 2.</p>
<p>Unrolling four times gives a marginal improvement compared to unrolling
three times.</p>
<p>I decided to proceed with a four time unrolled loop anyway. It was my gut
feeling that in the next steps I would obtain additional gain from it.</p>
<p>The next step was triggered by the fact that par contains the xor of all
bytes and rp4 and rp5 each contain the xor of half of the bytes.
So in effect par = rp4 ^ rp5. But as xor is commutative we can also say
that rp5 = par ^ rp4. So no need to keep both rp4 and rp5 around. We can
eliminate rp5 (or rp4, but I already foresaw another optimisation).
The same holds for rp6/7, rp8/9, rp10/11 rp12/13 and rp14/15.</p>
</section>
<section id="attempt-5">
<h2>Attempt 5<a href="#attempt-5" title="Permalink to this heading">¶</a></h2>
<p>Effectively so all odd digit rp assignments in the loop were removed.
This included the else clause of the if statements.
Of course after the loop we need to correct things by adding code like:</p>

<p>Also the initial assignments (rp5 = 0; etc) could be removed.
Along the line I also removed the initialisation of rp0/1/2/3.</p>
</section>
<section id="analysis-5">
<h2>Analysis 5<a href="#analysis-5" title="Permalink to this heading">¶</a></h2>
<p>Measurements showed this was a good move. The run-time roughly halved
compared with attempt 4 with 4 times unrolled, and we only require 1/3rd
of the processor time compared to the current code in the linux kernel.</p>
<p>However, still I thought there was more. I didn&#39;t like all the if
statements. Why not keep a running parity and only keep the last if
statement. Time for yet another version!</p>
</section>
<section id="attempt-6">
<h2>Attempt 6<a href="#attempt-6" title="Permalink to this heading">¶</a></h2>
<p>THe code within the for loop was changed to:</p>
<div><div><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp8 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= cur;

    cur = *bp++; tmppar ^= cur; rp4 ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
</pre></div>
</div>
<p>As you can see tmppar is used to accumulate the parity within a for
iteration. In the last 3 statements is added to par and, if needed,
to rp12 and rp14.</p>
<p>While making the changes I also found that I could exploit that tmppar
contains the running parity for this iteration. So instead of having:
rp4 ^= cur; rp6 ^= cur;
I removed the rp6 ^= cur; statement and did rp6 ^= tmppar; on next
statement. A similar change was done for rp8 and rp10</p>
</section>
<section id="analysis-6">
<h2>Analysis 6<a href="#analysis-6" title="Permalink to this heading">¶</a></h2>
<p>Measuring this code again showed big gain. When executing the original
linux code 1 million times, this took about 1 second on my system.
(using time to measure the performance). After this iteration I was back
to 0.075 sec. Actually I had to decide to start measuring over 10
million iterations in order not to lose too much accuracy. This one
definitely seemed to be the jackpot!</p>
<p>There is a little bit more room for improvement though. There are three
places with statements:</p>

<p>It seems more efficient to also maintain a variable rp4_6 in the while
loop; This eliminates 3 statements per loop. Of course after the loop we
need to correct by adding:</p>
<div><div><pre><span></span>rp4 ^= rp4_6;
rp6 ^= rp4_6
</pre></div>
</div>
<p>Furthermore there are 4 sequential assignments to rp8. This can be
encoded slightly more efficiently by saving tmppar before those 4 lines
and later do rp8 = rp8 ^ tmppar ^ notrp8;
(where notrp8 is the value of rp8 before those 4 lines).
Again a use of the commutative property of xor.
Time for a new test!</p>
</section>
<section id="attempt-7">
<h2>Attempt 7<a href="#attempt-7" title="Permalink to this heading">¶</a></h2>
<p>The new code now looks like:</p>
<div><div><pre><span></span>for (i = 0; i &lt; 4; i++)
{
    cur = *bp++; tmppar  = cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= tmppar;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp8 ^= tmppar;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur; rp10 ^= tmppar;

    notrp8 = tmppar;
    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;
    rp8 = rp8 ^ tmppar ^ notrp8;

    cur = *bp++; tmppar ^= cur; rp4_6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp6 ^= cur;
    cur = *bp++; tmppar ^= cur; rp4 ^= cur;
    cur = *bp++; tmppar ^= cur;

    par ^= tmppar;
    if ((i &amp; 0x1) == 0) rp12 ^= tmppar;
    if ((i &amp; 0x2) == 0) rp14 ^= tmppar;
}
rp4 ^= rp4_6;
rp6 ^= rp4_6;
</pre></div>
</div>
<p>Not a big change, but every penny counts :-)</p>
</section>
<section id="analysis-7">
<h2>Analysis 7<a href="#analysis-7" title="Permalink to this heading">¶</a></h2>
<p>Actually this made things worse. Not very much, but I don&#39;t want to move
into the wrong direction. Maybe something to investigate later. Could
have to do with caching again.</p>
<p>Guess that is what there is to win within the loop. Maybe unrolling one
more time will help. I&#39;ll keep the optimisations from 7 for now.</p>
</section>
<section id="attempt-8">
<h2>Attempt 8<a href="#attempt-8" title="Permalink to this heading">¶</a></h2>
<p>Unrolled the loop one more time.</p>
</section>
<section id="analysis-8">
<h2>Analysis 8<a href="#analysis-8" title="Permalink to this heading">¶</a></h2>
<p>This makes things worse. Let&#39;s stick with attempt 6 and continue from there.
Although it seems that the code within the loop cannot be optimised
further there is still room to optimize the generation of the ecc codes.
We can simply calculate the total parity. If this is 0 then rp4 = rp5
etc. If the parity is 1, then rp4 = !rp5;</p>
<p>But if rp4 = rp5 we do not need rp5 etc. We can just write the even bits
in the result byte and then do something like:</p>
<div><div><pre><span></span>code[0] |= (code[0] &lt;&lt; 1);
</pre></div>
</div>
<p>Lets test this.</p>
</section>
<section id="attempt-9">
<h2>Attempt 9<a href="#attempt-9" title="Permalink to this heading">¶</a></h2>
<p>Changed the code but again this slightly degrades performance. Tried all
kind of other things, like having dedicated parity arrays to avoid the
shift after parity[rp7] &lt;&lt; 7; No gain.
Change the lookup using the parity array by using shift operators (e.g.
replace parity[rp7] &lt;&lt; 7 with:</p>
<div><div><pre><span></span>rp7 ^= (rp7 &lt;&lt; 4);
rp7 ^= (rp7 &lt;&lt; 2);
rp7 ^= (rp7 &lt;&lt; 1);
rp7 &amp;= 0x80;
</pre></div>
</div>
<p>No gain.</p>
<p>The only marginal change was inverting the parity bits, so we can remove
the last three invert statements.</p>
<p>Ah well, pity this does not deliver more. Then again 10 million
iterations using the linux driver code takes between 13 and 13.5
seconds, whereas my code now takes about 0.73 seconds for those 10
million iterations. So basically I&#39;ve improved the performance by a
factor 18 on my system. Not that bad. Of course on different hardware
you will get different results. No warranties!</p>
<p>But of course there is no such thing as a free lunch. The codesize almost
tripled (from 562 bytes to 1434 bytes). Then again, it is not that much.</p>
</section>
<section id="correcting-errors">
<h2>Correcting errors<a href="#correcting-errors" title="Permalink to this heading">¶</a></h2>
<p>For correcting errors I again used the ST application note as a starter,
but I also peeked at the existing code.</p>
<p>The algorithm itself is pretty straightforward. Just xor the given and
the calculated ecc. If all bytes are 0 there is no problem. If 11 bits
are 1 we have one correctable bit error. If there is 1 bit 1, we have an
error in the given ecc code.</p>
<p>It proved to be fastest to do some table lookups. Performance gain
introduced by this is about a factor 2 on my system when a repair had to
be done, and 1% or so if no repair had to be done.</p>
<p>Code size increased from 330 bytes to 686 bytes for this function.
(gcc 4.2, -O3)</p>
</section>
<section id="conclusion">
<h2>Conclusion<a href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>The gain when calculating the ecc is tremendous. Om my development hardware
a speedup of a factor of 18 for ecc calculation was achieved. On a test on an
embedded system with a MIPS core a factor 7 was obtained.</p>
<p>On a test with a Linksys NSLU2 (ARMv5TE processor) the speedup was a factor
5 (big endian mode, gcc 4.1.2, -O3)</p>
<p>For correction not much gain could be obtained (as bitflips are rare). Then
again there are also much less cycles spent there.</p>
<p>It seems there is not much more gain possible in this, at least when
programmed in C. Of course it might be possible to squeeze something more
out of it with an assembler program, but due to pipeline behaviour etc
this is very tricky (at least for intel hw).</p>
<p>Author: Frans Meulenbroeks</p>
<p>Copyright (C) 2008 Koninklijke Philips Electronics NV.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    
  </div></div>
  </body>
</html>
