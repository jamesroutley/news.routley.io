<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://evanhahn.com/typescript-immutability-experiment/">Original</a>
    <h1>Experiment: Making TypeScript Immutable-by-Default</h1>
    
    <div id="readability-page-1" class="page"><div><p>I like programming languages where variables are immutable by default. For example, <a href="https://doc.rust-lang.org/stable/std/keyword.let.html">in Rust</a>, <code>let</code> declares an immutable variable and <code>let mut</code> declares a mutable one. I’ve long wanted this in other languages, like TypeScript, which is mutable by default—the opposite of what I want!</p><p>I wondered: <strong>is it possible to make TypeScript values immutable by default?</strong></p><p>My goal was to do this purely with TypeScript, without changing TypeScript itself. That meant no lint rules or other tools. I chose this because I wanted this solution to be as “pure” as possible…and it also sounded more fun.</p><p>I spent an evening trying to do this. <strong>I failed but made progress! I made arrays and <code>Record</code>s immutable by default, but I couldn’t get it working for regular objects.</strong> If you figure out how to do this completely, <a href="https://evanhahn.com/contact/">please contact me</a>—I must know!</p><h2 id="step-1-obliterate-the-built-in-libraries">Step 1: obliterate the built-in libraries</h2><p>TypeScript has built-in type definitions for JavaScript APIs like <code>Array</code> and <code>Date</code> and <code>String</code>. If you’ve ever changed the <a href="https://www.typescriptlang.org/tsconfig/#target"><code>target</code></a> or <a href="https://www.typescriptlang.org/tsconfig/#lib"><code>lib</code></a> options in your TSConfig, you’ve tweaked which of these definitions are included. For example, you might add the “ES2024” library if you’re targeting a newer runtime.</p><p><strong>My goal was to swap the built-in libraries with an immutable-by-default replacement.</strong></p><p>The first step was to stop using any of the built-in libraries. I set the <a href="https://www.typescriptlang.org/tsconfig/#noLib"><code>noLib</code></a> flag in my TSConfig, like this:</p><div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  &#34;compilerOptions&#34;: {
</span></span><span><span>    &#34;noLib&#34;: <span>true</span>
</span></span><span><span>  }
</span></span><span><span>}
</span></span></code></pre></div><p>Then I wrote a very simple script and put it in <code>test.ts</code>:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span>console.log(<span>&#34;Hello world!&#34;</span>);
</span></span></code></pre></div><p>When I ran <code>tsc</code>, it gave a bunch of errors:</p><pre tabindex="0"><code>Cannot find global type &#39;Array&#39;.
Cannot find global type &#39;Boolean&#39;.
Cannot find global type &#39;Function&#39;.
Cannot find global type &#39;IArguments&#39;.
Cannot find global type &#39;Number&#39;.
Cannot find global type &#39;Object&#39;.
Cannot find global type &#39;RegExp&#39;.
Cannot find global type &#39;String&#39;.
</code></pre><p>Progress! I had successfully obliterated any default TypeScript libraries, which I could tell because it couldn’t find core types like <code>String</code> or <code>Boolean</code>.</p><p>Time to write the replacement.</p><h2 id="step-2-a-skeleton-standard-library">Step 2: a skeleton standard library</h2><p>This project was a prototype. Therefore, I started with a minimal solution that would type-check. I didn’t need it to be good!</p><p>I created <code>lib.d.ts</code> and put the following inside:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In lib.d.ts:
</span></span></span><span><span><span></span><span>declare</span> <span>var</span> console: <span>any</span>;
</span></span><span><span>
</span></span><span><span><span>interface</span> Boolean {}
</span></span><span><span><span>interface</span> Function {}
</span></span><span><span><span>interface</span> IArguments {}
</span></span><span><span><span>interface</span> Number {}
</span></span><span><span><span>interface</span> RegExp {}
</span></span><span><span><span>interface</span> String {}
</span></span><span><span><span>interface</span> Object {}
</span></span><span><span>
</span></span><span><span><span>// TODO: We&#39;ll update this soon.
</span></span></span><span><span><span></span><span>interface</span> Array&lt;T&gt; {}
</span></span></code></pre></div><p>Now, when I ran <code>tsc</code>, I got no errors! I’d defined all the built-in types that TypeScript needs, and a dummy <code>console</code> object.</p><p>As you can see, this solution is impractical for production. For one, none of these interfaces have any properties! <code>&#34;foo&#34;.toUpperCase()</code> isn’t defined, for example. That’s okay because this is only a prototype. A production-ready version would need to define all of those things—tedious, but should be straightforward.</p><h2 id="step-3-making-arrays-immutable">Step 3: making arrays immutable</h2><p>I decided to tackle this with a test-driven development style. I’d write some code that I want to type-check, watch it <em>fail</em> to type-check, then fix it.</p><p>I updated <code>test.ts</code> to contain the following:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In test.ts:
</span></span></span><span><span><span></span><span>const</span> arr = [<span>1</span>, <span>2</span>, <span>3</span>];
</span></span><span><span>
</span></span><span><span><span>// Non-mutation should be allowed.
</span></span></span><span><span><span></span>console.log(arr[<span>1</span>]);
</span></span><span><span>console.log(arr.map((n) =&gt; n + <span>1</span>));
</span></span><span><span>
</span></span><span><span><span>// @ts-expect-error Mutation should not be allowed.
</span></span></span><span><span><span></span>arr[<span>0</span>] = <span>9</span>;
</span></span><span><span><span>// @ts-expect-error Mutation should not be allowed.
</span></span></span><span><span><span></span>arr.push(<span>4</span>);
</span></span></code></pre></div><p>This tests three things:</p><ol><li>Creating arrays with array literals is possible.</li><li>Non-mutating operations, like <code>arr[1]</code> and <code>arr.map()</code>, are allowed.</li><li>Operations that mutate the array, like <code>arr[1] = 9</code>, are disallowed.</li></ol><p>When I ran <code>tsc</code>, I saw two errors:</p><ul><li><code>arr[0] = 9</code> is allowed. There’s an unused <code>@ts-expect-error</code> there.</li><li><code>arr.map</code> doesn’t exist.</li></ul><p>So I updated the <code>Array</code> type in <code>lib.d.ts</code> with the following:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In lib.d.ts:
</span></span></span><span><span><span></span><span>interface</span> Array&lt;T&gt; {
</span></span><span><span>  <span>readonly</span> [n: <span>number</span>]: T;
</span></span><span><span>
</span></span><span><span>  map&lt;U&gt;(
</span></span><span><span>    callbackfn: (value: <span>T</span>, index: <span>number</span>, array: <span>readonly</span> T[]) =&gt; U,
</span></span><span><span>    thisArg?: <span>any</span>
</span></span><span><span>  ): U[];
</span></span><span><span>}
</span></span></code></pre></div><p>The property accessor—the <code>readonly [n: number]: T</code> line—tells TypeScript that you can access array properties by numeric index, but they’re read-only. That should make <code>arr[1]</code> possible but <code>arr[1] = 9</code> impossible.</p><p>The <code>map</code> method definition is <a href="https://github.com/microsoft/TypeScript/blob/cc2610fd347127c28609b4fca6fa9d55ee5063c6/src/lib/es5.d.ts#L1257">copied from the TypeScript source code</a> with no changes (other than some auto-formatting). That should make it possible to call <code>arr.map()</code>.</p><p>Notice that I did <em>not</em> define <code>push</code>. We shouldn’t be calling that on an immutable array!</p><p>I ran <code>tsc</code> again and…success! No errors! We now have immutable arrays!</p><p>At this stage, I’ve shown that <strong>it’s possible to configure TypeScript to make all arrays immutable with no extra annotations</strong>. No need for <code>readonly string[]</code> or <code>ReadonlyArray&lt;number&gt;</code>! In other words, we have some immutability by default.</p><p>This code, like everything in this post, is simplistic. There are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#instance_methods">lots of other array methods</a>, like <code>filter()</code> and <code>join()</code> and <code>forEach()</code>! If this were made production-ready, I’d make sure to define <a href="https://github.com/microsoft/TypeScript/blob/cc2610fd347127c28609b4fca6fa9d55ee5063c6/src/lib/es5.d.ts#L1173-L1298">all the read-only array methods</a>.</p><p>But for now, I was ready to move on to mutable arrays.</p><h2 id="step-4-mutable-arrays">Step 4: mutable arrays</h2><p>I prefer immutability, but I want to be able to define a mutable array sometimes. So I made another test case:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In test.ts:
</span></span></span><span><span><span></span><span>const</span> arr = [<span>1</span>, <span>2</span>, <span>3</span>] <span>as</span> MutableArray&lt;number&gt;;
</span></span><span><span>arr[<span>0</span>] = <span>9</span>;
</span></span><span><span>arr.push(<span>4</span>);
</span></span></code></pre></div><p>Notice that this requires a little extra work to make the array mutable. In other words, it’s not the default.</p><p>TypeScript complained that it can’t find <code>MutableArray</code>, so I defined it:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In lib.d.ts:
</span></span></span><span><span><span></span><span>interface</span> MutableArray&lt;T&gt; <span>extends</span> Array&lt;T&gt; {
</span></span><span><span>  [n: <span>number</span>]: T;
</span></span><span><span>  push(...items: <span>T</span>[]): <span>number</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>And again, type-checks passed!</p><p><strong>Now, I had mutable and immutable arrays, with immutability as the default.</strong> Again, this is simplistic, but good enough for this proof-of-concept!</p><p>This was exciting to me. It was possible to configure TypeScript to be immutable by default, for arrays at least. I didn’t have to fork the language or use any other tools.</p><p>Could I make more things immutable?</p><h2 id="step-5-the-same-for-record">Step 5: the same for <code>Record</code></h2><p>I wanted to see if I could go beyond arrays. My next target was the <code>Record</code> type, which is <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type">a TypeScript utility type</a>. So I defined another pair of test cases similar to the ones I made for arrays:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In test.ts:
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Immutable records
</span></span></span><span><span><span></span><span>const</span> obj1: <span>Record</span>&lt;string, string&gt; = { foo: <span>&#34;bar&#34;</span> };
</span></span><span><span>console.log(obj1.foo);
</span></span><span><span><span>// @ts-expect-error Mutation should not be allowed.
</span></span></span><span><span><span></span>obj1.foo = <span>&#34;baz&#34;</span>;
</span></span><span><span>
</span></span><span><span><span>// Mutable records
</span></span></span><span><span><span></span><span>const</span> obj2: <span>MutableRecord</span>&lt;string, string&gt; = { foo: <span>&#34;bar&#34;</span> };
</span></span><span><span>obj2.foo = <span>&#34;baz&#34;</span>;
</span></span></code></pre></div><p>TypeScript complained that it couldn’t find <code>Record</code> or <code>MutableRecord</code>. It also complained about an unused <code>@ts-expect-error</code>, which meant that mutation was allowed.</p><p>I rolled up my sleeves and fixed those errors like this:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In lib.d.ts:
</span></span></span><span><span><span></span><span>declare</span> <span>type</span> PropertyKey = <span>string</span> | <span>number</span> | <span>symbol</span>;
</span></span><span><span><span>type</span> Record&lt;KeyT extends PropertyKey, ValueT&gt; = {
</span></span><span><span>  <span>readonly</span> [key <span>in</span> KeyT]: ValueT;
</span></span><span><span>};
</span></span><span><span><span>type</span> MutableRecord&lt;KeyT extends PropertyKey, ValueT&gt; = {
</span></span><span><span>  [key <span>in</span> KeyT]: ValueT;
</span></span><span><span>};
</span></span></code></pre></div><p>Now, we have <code>Record</code>, which is an immutable key-value pair, and the mutable version too. Just like arrays!</p><p>You can imagine extending this idea to other built-in types, like <code>Set</code> and <code>Map</code>. I think it’d be pretty easy to do this the same way I did arrays and records. I’ll leave that as an exercise to the reader.</p><h2 id="failed-step-6-plain-objects">Failed step 6: plain objects</h2><p>My final test was to make regular objects (not records or arrays) immutable. Unfortunately for me, I could not figure this out.</p><p>Here’s the test case I wrote:</p><div><pre tabindex="0"><code data-lang="typescript"><span><span><span>// In test.ts:
</span></span></span><span><span><span></span><span>const</span> obj = { foo: <span>&#34;bar&#34;</span> };
</span></span><span><span>console.log(obj.foo);
</span></span><span><span><span>// @ts-expect-error Mutation should not be allowed.
</span></span></span><span><span><span></span>obj.foo = <span>&#34;baz&#34;</span>;
</span></span></code></pre></div><p>This stumped me. No matter what I did, I could not write a type that would disallow this mutation. I tried modifying the <code>Object</code> type every way I could think of, but came up short!</p><p>There are ways to annotate <code>obj</code> to make it immutable, but that’s not in the spirit of my goal. I want it to be immutable by default!</p><p>Alas, this is where I gave up.</p><h2 id="can-you-figure-this-out">Can you figure this out?</h2><p>I wanted to make TypeScript immutable by default. I was able to do this with arrays, <code>Record</code>s, and other types like <code>Map</code> and <code>Set</code>. Unfortunately, I couldn’t make it work for plain object definitions like <code>obj = { foo: &#34;bar&#34; }</code>.</p><p>There’s probably a way to enforce this with lint rules, either by disallowing mutation operations or by requiring <code>Readonly</code> annotations everywhere. I’d like to see what that looks like.</p><p>If <em>you</em> figure out how to make TypeScript immutable by default <em>with no other tools</em>, I would love to know, and I’ll update my post. I hope my failed attempt will lead someone else to something successful.</p><p>Again, <a href="https://evanhahn.com/contact/">please contact me</a> if you figure this out, or have any other thoughts.</p></div></div>
  </body>
</html>
