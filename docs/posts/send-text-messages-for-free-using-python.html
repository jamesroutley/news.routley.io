<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.alfredosequeida.com/blog/how-to-send-text-messages-for-free-using-python-use-python-to-send-text-messages-via-email/">Original</a>
    <h1>Send text messages for free using Python</h1>
    
    <div id="readability-page-1" class="page"><div><iframe src="https://www.youtube.com/embed/4-ysecoraKo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>If you want to skip the work, you can use <a href="https://github.com/AlfredoSequeida/etext/">ðŸ”—etext</a> - a Python module I created using the same technique explained in this blog post.</p>
<p>Okay, first let&#39;s get on the same page with the terms, we will be using to build this. SMS or short messaging service is what a text message is; which is limited to 160 characters and sent over mobile networks. And MMS or multimedia messaging service is basically the same thing as a text message but instead with embedded multimedia like images videos or even pdf files which I didn&#39;t know you could send over text messages until about yesterday. To send free text messages what we&#39;ll be doing is using SMS gateways which are servers that serve as middlemen that can be used to deliver our messages to mobile phones via mobile networks.</p>
<h2 id="sending-sms-messages">Sending SMS messages</h2>
<p>Unlike alternatives like Twilio, which lets you send text messages programmatically using their API for a fee,  these SMS and MMS gateways can be used for free because one of the ways we can interact with them is by using email. In other words, these gateways which have been set up by the mobile providers allow us to send our text messages in the form of an email message and then forward our messages to mobile
phones via SMS or MMS. </p>
<p>To make your life easier I have taken the liberty of aggregating a list of SMS and MMS email domains for U.S phone providers:</p>
<p>providers.py</p>
<pre><code>PROVIDERS = {
    <span>&#34;AT&amp;T&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;txt.att.net&#34;</span>, <span>&#34;mms&#34;</span>: <span>&#34;mms.att.net&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;Boost Mobile&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;sms.myboostmobile.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;myboostmobile.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;C-Spire&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;cspire1.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>False</span>},
    <span>&#34;Cricket Wireless&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;sms.cricketwireless.net &#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;mms.cricketwireless.net&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;Consumer Cellular&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;mailmymobile.net&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>False</span>},
    <span>&#34;Google Project Fi&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;msg.fi.google.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;Metro PCS&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;mymetropcs.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;Mint Mobile&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;mailmymobile.net&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>False</span>},
    <span>&#34;Page Plus&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;vtext.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;mypixmessages.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;Republic Wireless&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;text.republicwireless.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>False</span>,
    },
    <span>&#34;Sprint&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;messaging.sprintpcs.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;pm.sprint.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;Straight Talk&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;vtext.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;mypixmessages.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;T-Mobile&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;tmomail.net&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;Ting&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;message.ting.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>False</span>},
    <span>&#34;Tracfone&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;&#34;</span>, <span>&#34;mms&#34;</span>: <span>&#34;mmst5.tracfone.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;U.S. Cellular&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;email.uscc.net&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;mms.uscc.net&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;Verizon&#34;</span>: {<span>&#34;sms&#34;</span>: <span>&#34;vtext.com&#34;</span>, <span>&#34;mms&#34;</span>: <span>&#34;vzwpix.com&#34;</span>, <span>&#34;mms_support&#34;</span>: <span>True</span>},
    <span>&#34;Virgin Mobile&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;vmobl.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;vmpix.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
    <span>&#34;Xfinity Mobile&#34;</span>: {
        <span>&#34;sms&#34;</span>: <span>&#34;vtext.com&#34;</span>,
        <span>&#34;mms&#34;</span>: <span>&#34;mypixmessages.com&#34;</span>,
        <span>&#34;mms_support&#34;</span>: <span>True</span>,
    },
}
</code></pre>
<p>As a bonus, I recently found this site, which has SMS gateways for multiple countries, which might be helpful if you are not in the US: <a href="https://email2sms.info/">ðŸ”— https://email2sms.info/</a></p>
<p>As a quick explanation, this is how it works using a 10 digit U.S phone number:</p>
<p>We can take the phone number followed by the @ symbol, followed by the domain of the SMS or MMS server. </p>
<pre><code>number@gateway-domain.com
</code></pre>
<p>Other than having the email domain for SMS or MMS for your provider, you also need to have an email provider which gives you access to its SMTP servers. For our example, we will be using Gmail and Gmail&#39;s SMTP server. So you will need to have a Gmail account. You should also set up an app password as a way to log in to the SMTP server without needing two-step verification. </p>
<p>You can do this by going to <a href="https://myaccount.google.com/apppasswords">https://myaccount.google.com/apppasswords</a>. Select email for the app drop-down and any device; then you will get a password which we can later use to authenticate with Gmail&#39;s SMTP server.</p>
<p>Now let&#39;s get to the code.  The first thing we have to do is import some modules that we&#39;re gonna be using we&#39;ll be using <code>email</code> to format the emails later. We also need the <code>smtp</code> library we&#39;ll be using that to send our emails through the SMTP servers. We also need <code>ssl</code> and we&#39;ll be using that as our connection with the SMTP servers. And then, one more thing we&#39;re going to add is the providers from before.</p>
<p>main.py</p>
<pre><code>importemail, smtplib, ssl
<span>from</span> providers <span>import</span> PROVIDERS
</code></pre>
<p>and now that we have this let&#39;s start making the SMS portion now our program. It takes a few parameters:</p>
<p>main.py</p>
<pre><code><span>def</span> <span>send_sms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
</code></pre>
<p>The first one is the most obvious one which is the actual number that we&#39;ll be using to send these emails. We also need the actual message that we&#39;ll be sending and this again will be of type string next, we&#39;ll use the provider also of type string the provider is going to be the carrier, which again corresponds to one of these providers from before. Then we need the sender credentials and the credentials will involve not only the email that will be used to send these out but also that password that we got earlier using app passwords from Google. </p>
<p>The subject will also be of type string. One thing here is that I&#39;ve noticed that certain SMS gateways won&#39;t allow you to send out an email without having a properly structured email and that&#39;s why we&#39;re including a subject. Next, we&#39;ll add a parameter for the SMTP server. </p>
<p>In this case, we&#39;re using Gmail to send the emails, so the default for that is <code>smtp.gmail.com</code>. One more thing we need is the port that&#39;s going to be used to send these emails. You don&#39;t need to know much about this if you&#39;re using Gmail but if you&#39;re using a different SMPT provider or different email server you might want to go ahead and see if they use a different port to send emails. In our case, the SMTP port is going to be of type integer.</p>
<p>The first thing we should define is the sender email and the email password for that sender now this information we&#39;re going to be getting from the sender credentials</p>
<p>main.py</p>
<pre><code><span>def</span> <span>send_sms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
    sender_email, email_password = sender_credentials
</code></pre>
<p>and like I mentioned before, the receiver email is made up of a phone number followed by the domain of the SMS gateway. To format that I&#39;m going to use an f-string here.</p>
<p>main.py</p>
<pre><code><span>def</span> <span>send_sms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>
</code></pre>
<p>Awesome now let&#39;s format our email message. We&#39;ll make a variable called email message now like I said before some providers won&#39;t allow you to send messages unless it&#39;s structured like an actual email that means that what we send doesn&#39;t only need a message but, also needs a subject and who is being sent to so again we&#39;re going to use an f string here.</p>
<p>main.py</p>
<pre><code><span>def</span> <span>send_sms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

    email_message = <span>f&#34;Subject:<span>{subject}</span>\nTo:<span>{receiver_email}</span>\n<span>{message}</span>&#34;</span>
</code></pre>
<p>To send the email we&#39;re going to use a context manager. If you&#39;re not familiar with that it&#39;s just a way for the SMTP server connection to exit graciously after we&#39;re done with everything so we&#39;ll do with we&#39;ll use the <code>smtp</code> lib here we&#39;ll create an object using <code>SMTP_SSL</code> as well as use that instance to authenticate with the SMTP server:</p>
<p>main.py</p>
<pre><code><span>def</span> <span>send_sms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

    email_message = <span>f&#34;Subject:<span>{subject}</span>\nTo:<span>{receiver_email}</span>\n<span>{message}</span>&#34;</span>

    <span>with</span> smtplib.SMTP_SSL(
        smtp_server, smtp_port, context=ssl.create_default_context()
    ) <span>as</span> email:
        email.login(sender_email, email_password)
        email.sendmail(sender_email, receiver_email, email_message)
</code></pre>
<p>Let&#39;s send an SMS message! I&#39;m just going to quickly
create the main method and then inside this main method let&#39;s
call <code>send_sms_via_email</code> </p>
<p>main.py</p>
<pre><code><span>def</span> <span>main</span>():
    number = <span>&#34;5623720883&#34;</span>
    message = <span>&#34;hello world!&#34;</span>
    provider = <span>&#34;T-Mobile&#34;</span>

    sender_credentials = (<span>&#34;email@domain.com&#34;</span>, <span>&#34;password&#34;</span>)

    send_sms_via_email(number, message, provider, sender_credentials)
</code></pre>
<p>To run our program we&#39;ll use the
<code>__name__</code> dunder  method</p>
<p>main.py</p>
<pre><code><span>if</span> __name__ == <span>&#34;__main__&#34;</span>:
    main()
</code></pre>
<h2 id="sending-mms-messages">Sending MMS messages</h2>
<p>Now that we have that let me
show you how to send an MMS message. Everything is pretty similar so I&#39;m going to start with this:</p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>
</code></pre>
<p>Since we need a file to send a multimedia message let&#39;s add it as a parameter. It&#39;s going to be a file path of type string. Something else we&#39;ll need is the mime-type of the file, so let&#39;s add a mime main type and a mime subtype to our parameters. I&#39;ll get into what this means in a bit. </p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):
</code></pre>
<p>Let&#39;s import more things, that we need to send MMS.</p>
<pre><code>main.py
</code></pre>
<pre><code><span>from</span> email <span>import</span> encoders
<span>from</span> email.mime.base <span>import</span> MIMEBase
<span>from</span> email.mime.image <span>import</span> MIMEImage
<span>from</span> email.mime.multipart <span>import</span> MIMEMultipart
<span>from</span> email.mime.text <span>import</span> MIMEText

<span>from</span> os.path <span>import</span> basename
</code></pre>
<p>Now what&#39;s going to change in the MMS function is the way we send an email. So instead of sending an email that shows the subject, the receiver, and the message; we need to create a multi-part email. The multi-part being (1) the message itself that we&#39;re sending and (2) the file that we&#39;re attaching to that email. </p>
<p>If we go back to our providers&#39; list, you&#39;ll notice that some providers might not give you the ability to send multimedia messages or will use a single domain for both short messages and multimedia messages so because of that I have noted this in the list I aggregated. With the use of an SMS-supported key. </p>
<p>For example, T-Mobile does not have an MMS key, but it does support MMS, which means that we can use the same SMS domain to send both SMS and MMS. 
However, AT&amp;T for example has both an SMS and MMS domain. So you need to use the appropriate one depending on what you&#39;re sending. </p>
<p>We&#39;ll use <code>email_message</code> like before,  but instead, we&#39;ll use a multi-part object. 
We also need to add our email attributes. We&#39;ll use <code>email_message</code> to add the subject, receiver
(whoever&#39;s receiving our email), 
and sender (who is sending the email). </p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):

    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

 â€‹   â€‹email_messageâ€‹ â€‹=â€‹ â€‹MIMEMultipartâ€‹()
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;Subject&#34;</span>â€‹] â€‹=â€‹ â€‹subject
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;From&#34;</span>â€‹] â€‹=â€‹ â€‹sender_email
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;To&#34;</span>â€‹] â€‹=â€‹ â€‹receiver_email
</code></pre>
<p>Let&#39;s attach the message to our email, which is of mine type plain (plain text).</p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):

    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

 â€‹   â€‹email_messageâ€‹ â€‹=â€‹ â€‹MIMEMultipartâ€‹()
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;Subject&#34;</span>â€‹] â€‹=â€‹ â€‹subject
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;From&#34;</span>â€‹] â€‹=â€‹ â€‹sender_email
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;To&#34;</span>â€‹] â€‹=â€‹ â€‹receiver_email

 â€‹   â€‹email_messageâ€‹.â€‹attachâ€‹(â€‹MIMETextâ€‹(â€‹messageâ€‹, â€‹<span>&#34;plain&#34;</span>â€‹))
</code></pre>
<h3 id="what-are-mime-types">What are MIME types?</h3>
<p>If you&#39;re not familiar with MIME types,  It&#39;s just a declaration of a type of file or a type of piece of content. In this case, mime text is telling us that the piece of content that we&#39;re using is text. Similarly, To attach the file that we&#39;re going to be sending, we will have to change specify the MIME type. </p>
<h3 id="attaching-the-file">Attaching the file</h3>
<p>Using a context manager we&#39;ll add the file path that we&#39;re passing in our parameters. Then we also need to specify a read type in this case we&#39;ll read the bytes. Using <code>MIMEBase</code>, we can specify the file&#39;s MIME type. The main type comes first and then we have the mine subtype. Then we&#39;ll set the payload which is the content we&#39;ll be using. In this case that&#39;s the file attachment. To send a file we need to encode it as base64, so from the encoders that we imported earlier, we&#39;ll encode the media to base64. We also need to add a header. The header is going to be of type content-disposition and for that, we want to add the file name that we&#39;re sending. Then, we can attach that to our email right we have to attach our actual file to our email as we did before with our message email:</p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):

    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

 â€‹   â€‹email_messageâ€‹ â€‹=â€‹ â€‹MIMEMultipartâ€‹()
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;Subject&#34;</span>â€‹] â€‹=â€‹ â€‹subject
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;From&#34;</span>â€‹] â€‹=â€‹ â€‹sender_email
 â€‹   email_messageâ€‹[â€‹<span>&#34;To&#34;</span>â€‹] â€‹=â€‹ â€‹receiver_email

 â€‹   email_messageâ€‹.â€‹attachâ€‹(â€‹MIMETextâ€‹(â€‹messageâ€‹, â€‹<span>&#34;plain&#34;</span>â€‹))

    <span>with</span> <span>open</span>(file_path, <span>&#34;rb&#34;</span>) <span>as</span> attachment:
        part = MIMEBase(mime_maintype, mime_subtype)
        part.set_payload(attachment.read())

        encoders.encode_base64(part)
        part.add_header(
            <span>&#34;Content-Disposition&#34;</span>,
            <span>f&#34;attachment; filename=<span>{basename(file_path)}</span>&#34;</span>,
        )

        email_message.attach(part)
</code></pre>
<p>The last thing we have to do is send our email, but we can&#39;t just send our email of type mime multi-part. We have to convert that into text outside of the context manager. </p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):

    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

 â€‹   â€‹email_messageâ€‹ â€‹=â€‹ â€‹MIMEMultipartâ€‹()
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;Subject&#34;</span>â€‹] â€‹=â€‹ â€‹subject
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;From&#34;</span>â€‹] â€‹=â€‹ â€‹sender_email
 â€‹   email_messageâ€‹[â€‹<span>&#34;To&#34;</span>â€‹] â€‹=â€‹ â€‹receiver_email

 â€‹   email_messageâ€‹.â€‹attachâ€‹(â€‹MIMETextâ€‹(â€‹messageâ€‹, â€‹<span>&#34;plain&#34;</span>â€‹))

    <span>with</span> <span>open</span>(file_path, <span>&#34;rb&#34;</span>) <span>as</span> attachment:
        part = MIMEBase(mime_maintype, mime_subtype)
        part.set_payload(attachment.read())

        encoders.encode_base64(part)
        part.add_header(
            <span>&#34;Content-Disposition&#34;</span>,
            <span>f&#34;attachment; filename=<span>{basename(file_path)}</span>&#34;</span>,
        )

        email_message.attach(part)

    text = email_message.as_string()
</code></pre>
<p>So now if we go down here we have the same thing as before from the SMS function but we have to change our email message to that text that we just made.</p>
<pre><code>main.py
</code></pre>
<pre><code><span>def</span> <span>send_mms_via_email</span>(<span>
    number: <span>str</span>,
    message: <span>str</span>,
    file_path: <span>str</span>,
    mime_maintype: <span>str</span>,
    mime_subtype: <span>str</span>,
    provider: <span>str</span>,
    sender_credentials: <span>tuple</span>,
    subject: <span>str</span> = <span>&#34;sent using etext&#34;</span>,
    smtp_server: <span>str</span> = <span>&#34;smtp.gmail.com&#34;</span>,
    smtp_port: <span>int</span> = <span>465</span>,
</span>):

    sender_email, email_password = sender_credentials
    receiver_email = <span>f&#39;<span>{number}</span>@<span>{PROVIDERS.get(provider).get(<span>&#34;sms&#34;</span>)}</span>&#39;</span>

 â€‹   â€‹email_messageâ€‹ â€‹=â€‹ â€‹MIMEMultipartâ€‹()
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;Subject&#34;</span>â€‹] â€‹=â€‹ â€‹subject
 â€‹   â€‹email_messageâ€‹[â€‹<span>&#34;From&#34;</span>â€‹] â€‹=â€‹ â€‹sender_email
 â€‹   email_messageâ€‹[â€‹<span>&#34;To&#34;</span>â€‹] â€‹=â€‹ â€‹receiver_email

 â€‹   email_messageâ€‹.â€‹attachâ€‹(â€‹MIMETextâ€‹(â€‹messageâ€‹, â€‹<span>&#34;plain&#34;</span>â€‹))

    <span>with</span> <span>open</span>(file_path, <span>&#34;rb&#34;</span>) <span>as</span> attachment:
        part = MIMEBase(mime_maintype, mime_subtype)
        part.set_payload(attachment.read())

        encoders.encode_base64(part)
        part.add_header(
            <span>&#34;Content-Disposition&#34;</span>,
            <span>f&#34;attachment; filename=<span>{basename(file_path)}</span>&#34;</span>,
        )

        email_message.attach(part)

    text = email_message.as_string()

    <span>with</span> smtplib.SMTP_SSL(
        smtp_server, smtp_port, context=ssl.create_default_context()
    ) <span>as</span> email:
        email.login(sender_email, email_password)
        email.sendmail(sender_email, receiver_email, text)
</code></pre>
<p>Let&#39;s create the main function (without the SMS version). It&#39;s similar to the SMS version, but we have to add the file path and the mime type. To send a png image that&#39;s going to be a main type of image and then the subtype is almost always the actual extension of the file and this gives us a png.</p>
<p>main.py</p>
<pre><code><span>def</span> <span>main</span>():
    file_path = <span>&#34;/path/to/file/file.png&#34;</span>

    mime_maintype = <span>&#34;image&#34;</span>
    mime_subtype = <span>&#34;png&#34;</span>

    phone_number = <span>&#34;5623720883&#34;</span>

    message = <span>&#34;hello world!&#34;</span>
    provider = <span>&#34;T-Mobile&#34;</span>

    sender_credentials = (<span>&#34;email@domain.com&#34;</span>, <span>&#34;password&#34;</span>)

    send_mms_via_email(
        phone_number,
        message,
        file_path,
        mime_maintype,
        mime_subtype,
        provider,
        sender_credentials,
    )

<span>if</span> __name__ == <span>&#34;__main__&#34;</span>:
    main()
</code></pre>
<p>In case you are not sending a png image, here are some common MIME types:</p>
<div>

<table>
<thead>
<tr>
<th>Extension</th>
<th>Kind of document</th>
<th>MIME Type</th>
</tr>
</thead>
<tbody><tr>
<td>.aac</td>
<td>AAC audio</td>
<td>audio/aac</td>
</tr>
<tr>
<td>.abw</td>
<td>AbiWord document</td>
<td>application/x-abiword</td>
</tr>
<tr>
<td>.arc</td>
<td>Archive document (multiple files embedded)</td>
<td>application/x-freearc</td>
</tr>
<tr>
<td>.avi</td>
<td>AVI: Audio Video Interleave</td>
<td>video/x-msvideo</td>
</tr>
<tr>
<td>.azw</td>
<td>Amazon Kindle eBook format</td>
<td>application/vnd.amazon.ebook</td>
</tr>
<tr>
<td>.bin</td>
<td>Any kind of binary data</td>
<td>application/octet-stream</td>
</tr>
<tr>
<td>.bmp</td>
<td>Windows OS/2 Bitmap Graphics</td>
<td>image/bmp</td>
</tr>
<tr>
<td>.bz</td>
<td>BZip archive</td>
<td>application/x-bzip</td>
</tr>
<tr>
<td>.bz2</td>
<td>BZip2 archive</td>
<td>application/x-bzip2</td>
</tr>
<tr>
<td>.cda</td>
<td>CD audio</td>
<td>application/x-cdf</td>
</tr>
<tr>
<td>.csh</td>
<td>C-Shell script</td>
<td>application/x-csh</td>
</tr>
<tr>
<td>.css</td>
<td>Cascading Style Sheets (CSS)</td>
<td>text/css</td>
</tr>
<tr>
<td>.csv</td>
<td>Comma-separated values (CSV)</td>
<td>text/csv</td>
</tr>
<tr>
<td>.doc</td>
<td>Microsoft Word</td>
<td>application/msword</td>
</tr>
<tr>
<td>.docx</td>
<td>Microsoft Word (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.wordprocessingml.document</td>
</tr>
<tr>
<td>.eot</td>
<td>MS Embedded OpenType fonts</td>
<td>application/vnd.ms-fontobject</td>
</tr>
<tr>
<td>.epub</td>
<td>Electronic publication (EPUB)</td>
<td>application/epub+zip</td>
</tr>
<tr>
<td>.gz</td>
<td>GZip Compressed Archive</td>
<td>application/gzip</td>
</tr>
<tr>
<td>.gif</td>
<td>Graphics Interchange Format (GIF)</td>
<td>image/gif</td>
</tr>
<tr>
<td>.htm .html</td>
<td>HyperText Markup Language (HTML)</td>
<td>text/html</td>
</tr>
<tr>
<td>.ico</td>
<td>Icon format</td>
<td>image/vnd.microsoft.icon</td>
</tr>
<tr>
<td>.ics</td>
<td>iCalendar format</td>
<td>text/calendar</td>
</tr>
<tr>
<td>.jar</td>
<td>Java Archive (JAR)</td>
<td>application/java-archive</td>
</tr>
<tr>
<td>.jpeg .jpg</td>
<td>JPEG images</td>
<td>image/jpeg</td>
</tr>
<tr>
<td>.js</td>
<td>JavaScript</td>
<td>text/javascript (Specifications: HTML and its reasoning, and IETF)</td>
</tr>
<tr>
<td>.json</td>
<td>JSON format</td>
<td>application/json</td>
</tr>
<tr>
<td>.jsonld</td>
<td>JSON-LD format</td>
<td>application/ld+json</td>
</tr>
<tr>
<td>.mid .midi</td>
<td>Musical Instrument Digital Interface (MIDI)</td>
<td>audio/midi audio/x-midi</td>
</tr>
<tr>
<td>.mjs</td>
<td>JavaScript module</td>
<td>text/javascript</td>
</tr>
<tr>
<td>.mp3</td>
<td>MP3 audio</td>
<td>audio/mpeg</td>
</tr>
<tr>
<td>.mp4</td>
<td>MP4 video</td>
<td>video/mp4</td>
</tr>
<tr>
<td>.mpeg</td>
<td>MPEG Video</td>
<td>video/mpeg</td>
</tr>
<tr>
<td>.mpkg</td>
<td>Apple Installer Package</td>
<td>application/vnd.apple.installer+xml</td>
</tr>
<tr>
<td>.odp</td>
<td>OpenDocument presentation document</td>
<td>application/vnd.oasis.opendocument.presentation</td>
</tr>
<tr>
<td>.ods</td>
<td>OpenDocument spreadsheet document</td>
<td>application/vnd.oasis.opendocument.spreadsheet</td>
</tr>
<tr>
<td>.odt</td>
<td>OpenDocument text document</td>
<td>application/vnd.oasis.opendocument.text</td>
</tr>
<tr>
<td>.oga</td>
<td>OGG audio</td>
<td>audio/ogg</td>
</tr>
<tr>
<td>.ogv</td>
<td>OGG video</td>
<td>video/ogg</td>
</tr>
<tr>
<td>.ogx</td>
<td>OGG</td>
<td>application/ogg</td>
</tr>
<tr>
<td>.opus</td>
<td>Opus audio</td>
<td>audio/opus</td>
</tr>
<tr>
<td>.otf</td>
<td>OpenType font</td>
<td>font/otf</td>
</tr>
<tr>
<td>.png</td>
<td>Portable Network Graphics</td>
<td>image/png</td>
</tr>
<tr>
<td>.pdf</td>
<td>Adobe Portable Document Format (PDF)</td>
<td>application/pdf</td>
</tr>
<tr>
<td>.php</td>
<td>Hypertext Preprocessor (Personal Home Page)</td>
<td>application/x-httpd-php</td>
</tr>
<tr>
<td>.ppt</td>
<td>Microsoft PowerPoint</td>
<td>application/vnd.ms-powerpoint</td>
</tr>
<tr>
<td>.pptx</td>
<td>Microsoft PowerPoint (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.presentationml.presentation</td>
</tr>
<tr>
<td>.rar</td>
<td>RAR archive</td>
<td>application/vnd.rar</td>
</tr>
<tr>
<td>.rtf</td>
<td>Rich Text Format (RTF)</td>
<td>application/rtf</td>
</tr>
<tr>
<td>.sh</td>
<td>Bourne shell script</td>
<td>application/x-sh</td>
</tr>
<tr>
<td>.svg</td>
<td>Scalable Vector Graphics (SVG)</td>
<td>image/svg+xml</td>
</tr>
<tr>
<td>.swf</td>
<td>Small web format (SWF) or Adobe Flash document</td>
<td>application/x-shockwave-flash</td>
</tr>
<tr>
<td>.tar</td>
<td>Tape Archive (TAR)</td>
<td>application/x-tar</td>
</tr>
<tr>
<td>.tif .tiff</td>
<td>Tagged Image File Format (TIFF)</td>
<td>image/tiff</td>
</tr>
<tr>
<td>.ts</td>
<td>MPEG transport stream</td>
<td>video/mp2t</td>
</tr>
<tr>
<td>.ttf</td>
<td>TrueType Font</td>
<td>font/ttf</td>
</tr>
<tr>
<td>.txt</td>
<td>Text, (generally ASCII or ISO 8859-n)</td>
<td>text/plain</td>
</tr>
<tr>
<td>.vsd</td>
<td>Microsoft Visio</td>
<td>application/vnd.visio</td>
</tr>
<tr>
<td>.wav</td>
<td>Waveform Audio Format</td>
<td>audio/wav</td>
</tr>
<tr>
<td>.weba</td>
<td>WEBM audio</td>
<td>audio/webm</td>
</tr>
<tr>
<td>.webm</td>
<td>WEBM video</td>
<td>video/webm</td>
</tr>
<tr>
<td>.webp</td>
<td>WEBP image</td>
<td>image/webp</td>
</tr>
<tr>
<td>.woff</td>
<td>Web Open Font Format (WOFF)</td>
<td>font/woff</td>
</tr>
<tr>
<td>.woff2</td>
<td>Web Open Font Format (WOFF)</td>
<td>font/woff2</td>
</tr>
<tr>
<td>.xhtml</td>
<td>XHTML</td>
<td>application/xhtml+xml</td>
</tr>
<tr>
<td>.xls</td>
<td>Microsoft Excel</td>
<td>application/vnd.ms-excel</td>
</tr>
<tr>
<td>.xlsx</td>
<td>Microsoft Excel (OpenXML)</td>
<td>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</td>
</tr>
<tr>
<td>.xml</td>
<td>XML</td>
<td>application/xml is recommended as of RFC 7303 (section 4.1), but text/xml is still used sometimes. You can assign a specific MIME type to a file with .xml extension depending on how its contents are meant to be interpreted. For instance, an Atom feed is application/atom+xml, but application/xml serves as a valid default.</td>
</tr>
<tr>
<td>.xul</td>
<td>XUL</td>
<td>application/vnd.mozilla.xul+xml</td>
</tr>
<tr>
<td>.zip</td>
<td>ZIP archive</td>
<td>application/zip</td>
</tr>
<tr>
<td>.3gp</td>
<td>3GPP audio/video container</td>
<td>video/3gpp; audio/3gpp if it doesn&#39;t contain video</td>
</tr>
<tr>
<td>.3g2</td>
<td>3GPP2 audio/video container</td>
<td>video/3gpp2; audio/3gpp2 if it doesn&#39;t contain video</td>
</tr>
<tr>
<td>.7z</td>
<td>7-zip archive</td>
<td>application/x-7z-compressed</td>
</tr>
</tbody></table>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types">ðŸ”—Source</a></p>
</div>

<p>And that&#39;s how you can send SMS and MMS for free using Python!</p>
</div></div>
  </body>
</html>
