<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.adamgrant.info/tiny-predictive-text">Original</a>
    <h1>Show HN: Predictive text using only 13kb of JavaScript. no LLM</h1>
    
    <div id="readability-page-1" class="page"><p>## Predictive Text Using only 13KB of JavaScript. No LLM.
![[permy.gif]]
[Try it here](https://adamjgrant.github.io/Tiny-Predictive-Text/) | [Code](https://github.com/adamjgrant/Tiny-Predictive-Text) | [Permy](https://permy.link)
This is a simple POC of using [Permy](https://permy.link) with a simple JSON dictionary for predictive text that is surprisingly expressive despite the [tiny size (**&lt;8KB**) of the dictionary](https://github.com/adamjgrant/Tiny-Predictive-Text/blob/main/dict.js) and even the full [JS implementation itself (**13KB**)](https://github.com/adamjgrant/Tiny-Predictive-Text/blob/main/script.min.js).
## Background
This code leverages how [Permy](https://permy.link) combines words through nested arrays of word choices and can loop back on itself through branch references.
The dictionary starts by defining the 25 most common first words used in sentences as individual branches:
```json
{&#34;main&#34;:[{&#34;branch&#34;:&#34;the&#34;},{&#34;branch&#34;:&#34;be&#34;},{&#34;branch&#34;:&#34;to&#34;},{&#34;branch&#34;:&#34;of&#34;},{&#34;branch&#34;:&#34;and&#34;},{&#34;branch&#34;:&#34;a&#34;},{&#34;branch&#34;:&#34;in&#34;},{&#34;branch&#34;:&#34;that&#34;},{&#34;branch&#34;:&#34;have&#34;},{&#34;branch&#34;:&#34;i&#34;},{&#34;branch&#34;:&#34;it&#34;},{&#34;branch&#34;:&#34;for&#34;},{&#34;branch&#34;:&#34;not&#34;},{&#34;branch&#34;:&#34;on&#34;},{&#34;branch&#34;:&#34;with&#34;},{&#34;branch&#34;:&#34;he&#34;},{&#34;branch&#34;:&#34;as&#34;},{&#34;branch&#34;:&#34;you&#34;},{&#34;branch&#34;:&#34;do&#34;},{&#34;branch&#34;:&#34;at&#34;},{&#34;branch&#34;:&#34;this&#34;},{&#34;branch&#34;:&#34;but&#34;},{&#34;branch&#34;:&#34;his&#34;},{&#34;branch&#34;:&#34;by&#34;},{&#34;branch&#34;:&#34;from&#34;}]}
```
Then, each branch starts with that word and defines the top five most likely words to follow. Then, for each of those five, it provides three more words that are most likely to follow it.
```json
  &#34;the&#34;: [
    [
      &#34;the &#34;,
      [
        [
          &#34;world &#34;,
          [
            &#34;is &#34;,
            &#34;has &#34;,
            &#34;seems &#34;
          ]
        ],
 ...
```
Sometimes one of these words is already a branch, so I replaced those with branch references, allowing the sentence creation to loop back on itself and keep writing one or two more words. In this case, one random selection starting with &#34;of&#34; would auto complete with a random construction of the &#34;the&#34; tree above.
```json
  &#34;of&#34;: [
    [
      &#34;of &#34;,
      [
        [
          {
            &#34;branch&#34;: &#34;the&#34;
          },
          [
            [
              &#34;world &#34;,
              [
                &#34;is &#34;,
                &#34;has &#34;,
                &#34;knows &#34;
              ]
            ],
```
### This is just a POC
If it can do this in 13kb, it makes me wonder what it could do with more bytes.
A tree of 25x5x3 isn&#39;t really that big. It&#39;s only 375 possible combinations without considering rebranching. I can see several ways someone could take this even further with a larger dictionary and some other magic here and there. Permy has lots of flexibility in defining links between string nodes and can further be compressed with the permyscript syntax where applicable.
I mainly just wanted to see what would happened if I tried to use this library this way. Now I&#39;m eager to try different things with it.</p></div>
  </body>
</html>
