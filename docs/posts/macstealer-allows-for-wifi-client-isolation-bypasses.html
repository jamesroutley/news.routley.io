<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/vanhoefm/macstealer">Original</a>
    <h1>MacStealer allows for WiFi client isolation bypasses</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">

<p dir="auto">This repo contains MacStealer. It can test Wi-Fi networks for <strong>client isolation bypasses</strong>
<strong>(CVE-2022-47522). Our attack can intercept (steal) traffic toward other clients at the MAC layer</strong>,
even if clients are prevented from communicating with each other. This vulnerability affects Wi-Fi
networks with malicious insiders, where our attack can bypass client isolation, which is sometimes
also known as AP isolation. The attack can also be used to bypass Dynamic ARP inspection (DAI),
and can likely also be used to bypass other methods that prevent clients from attacking each other.
The attack is also known as the <em>security context override attack</em>, see Section 5 of our
<a href="https://papers.mathyvanhoef.com/usenix2023-wifi.pdf" rel="nofollow">USENIX Security &#39;23 paper</a> (<a href="https://github.com/domienschepers/wifi-framing">repo</a>).</p>
<p dir="auto">Concrete examples of possible affected networks are:</p>
<ul dir="auto">
<li>
<p dir="auto">Enterprise networks where users may distrust each other, and where techniques such as client isolation
or ARP inspection are used to prevent users from attacking each other. For instance, company
networks with accounts for both guests and staff, networks such as eduroam and govroam, etc.</p>
</li>
<li>
<p dir="auto">Public hotspots protected by <a href="https://www.wi-fi.org/discover-wi-fi/passpoint" rel="nofollow">Passpoint</a> (formerly Hotspot 2.0).
These are hotspots that you can automatically and securely connect to. For instance,
it can seamlessly authenticate you using your phone&#39;s SIM card.</p>
</li>
<li>
<p dir="auto">Home WPA2 or WPA3 networks that have client isolation enabled. This includes networks with
a separate SSID for guests or for insecure (IoT) devices. It also includes networks where
multiple passwords are used to further isolate devices, which is also known as
<a href="https://www.arubanetworks.com/techdocs/central/2.5.1/content/access-points/cfg/security/wpa2_mpsk.htm" rel="nofollow">Multi-PSK</a>,
<a href="https://www.cisco.com/c/en/us/td/docs/wireless/controller/technotes/8-5/b_Identity_PSK_Feature_Deployment_Guide.html" rel="nofollow">Identity PSK</a>,
<a href="https://0x72326432.com/posts/perstapsk_en/" rel="nofollow">per-station PSK</a>,
or <a href="https://www.cisco.com/c/en/us/td/docs/wireless/controller/9800/17-6/config-guide/b_wl_17_6_cg/m_epsk.html" rel="nofollow">EasyPSK</a>.
See the <a href="#id-threat-model">threat model discussion</a> for extra info.</p>
</li>
<li>
<p dir="auto">Public hotspots based on <a href="https://www.wi-fi.org/beacon/thomas-derham-nehru-bhandaru/wi-fi-certified-wpa3-december-2020-update-brings-new-0" rel="nofollow">WPA3 SAE-PK</a>.
These are hotspots protected by a shared public password, but where an adversary cannot
abuse this publicly-known password.</p>
</li>
</ul>
<p dir="auto">We remark that <strong>our attack cannot bypass VLANs</strong>. In other words, based on current experiments,
our attack cannot be used to exploit a device in another VLAN.</p>
<p dir="auto">The <a href="https://github.com/domienschepers/wifi-framing">repository of other results in our USENIX Security &#39;23</a> is also available.</p>


<p dir="auto">The core idea behind the attack is that the manner in which clients are authenticated is unrelated to
how packets are routed to the correct Wi-Fi client. Namely, authentication is done based on passwords,
usernames, 802.1X identities, and/or certificates, but once the client has connected the routing of
packets is done based on MAC addresses. A malicious insider can abuse this to intercept data towards
a Wi-Fi client by <strong>disconnecting a victim and then connecting under the MAC address of the victim</strong>
<strong>(using the credentials of the adversary)</strong>. Any packets that were still underway to the victim,
such website data that the victim was still loading, will now be received by the adversary instead.</p>
<p dir="auto">More precisely, attack consists of three steps:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/vanhoefm/macstealer/blob/main/attack.png"><img src="https://github.com/vanhoefm/macstealer/raw/main/attack.png"/></a>
</p>
<ol dir="auto">
<li>
<p dir="auto"><strong>Letting the victim request data</strong>: The adversary first waits until the victim (client)
establishes a Wi-Fi connection with the vulnerable Access Point (AP). We assume the victim
will then send a request to a server on the Internet. For instance, the victim may send a
HTTP request to the (plaintext) website <code>example.com</code>. The goal of the adversary is to
intercept the response that will be sent by the website.</p>
</li>
<li>
<p dir="auto"><strong>Connecting under the victim&#39;s MAC address</strong>: After the victim requested data, for instance
by sending a HTTP Request packet, the adversary will forcibly disconnect the victim from the
network <em>before</em> the response arrives at the
vulnerable AP. In our example, this means the victim is disconnected before the response from
<code>example.com</code> arrives at the AP. Once the victim is disconnected, the adversary spoofs
the MAC address of the victim and the adversary will connect to the network using their own
credentials. This means the adversary is a malicious insider that can connect using their own
credentials to the network, for instance, using their own username and password in an
Enterprise Wi-Fi network.</p>
</li>
<li>
<p dir="auto"><strong>Intercepting the response</strong>: Once the adversary connected under the MAC address of the victim,
the AP will associate the adversary&#39;s newly generated encryption keys with the victim&#39;s MAC address.
As a result, when the response from the server arrives at the Wi-Fi network, or any incoming traffic
towards the victim in general, the router will forward these incoming packets to the victim&#39;s
MAC address. In our example, this means the response from <code>example.com</code> is forwarded by the router
to the victim&#39;s MAC address. However, the adversary is now using this MAC address. This means the
AP will encrypt the response using the keys of the adversary. In other words, the adversary will
now recieve any pending traffic that is still underway the victim.</p>
</li>
</ol>
<p dir="auto">We remark that intercepted traffic may be protected by higher-layer encryption, such as TLS and HTTPS.
Nevertheless, even if higher-layer encryption is being used, our attack still reveals
the IP address that a victim is communicating with. This in turn reveals the websites that a victim
is visiting, which can be sensitive information on its own.</p>
<p dir="auto">By default, the attack does not intercept traffic <em>sent by the victim</em>, but can only intercept
traffic <em>sent towards the victim</em>. However, an adversary can attempt subsequent attacks to also
intercept traffic sent by the victim. In particular, by intercepting a DNS reply to the victim,
the adversary can spoof a DNS reply and intercept all IP traffic both sent towards and sent by
victim.</p>
<p dir="auto">Performing the above attack only makes sense when client isolation is enabled in the target network.
Otherwise, if client isolation is disabled, a malicious insider can just directly attack other
clients using techniques such as <a href="https://en.wikipedia.org/wiki/ARP_spoofing" rel="nofollow">ARP spoofing</a> (see the
<a href="#id-test-isolation">client isolation tests</a>).</p>
<p dir="auto">The attack is identical against Enterprise WPA1, WPA2 and WPA3 networks. This is because the attack
does not exploit any cryptographic properties of Wi-Fi, but instead abuses how a network determines
to which client packets should be sent, i.e., routed, to.</p>
<p dir="auto">For extra details on the attack, see the <em>security context override attack</em> (Section 5) in our paper
<a href="https://papers.mathyvanhoef.com/usenix2023-wifi.pdf" rel="nofollow">Framing Frames: Bypassing Wi-Fi Encryption by Manipulating Transmit Queues</a>.</p>


<h2 tabindex="-1" dir="auto"><a id="user-content-31-preventing-mac-address-stealing" aria-hidden="true" href="#31-preventing-mac-address-stealing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3.1. Preventing MAC address stealing</h2>
<p dir="auto">To mitigate our attack, an AP can temporarily prevent clients from connecting if they are using
a MAC address that was recently connected to the AP. This prevents an adversary from spoofing a
MAC address and intercepting pending or queued frames towards a victim. When it can be guaranteed
that the user behind a MAC address has not changed, the client can be allowed to immediately reconnect.
Note that this check must be done over all APs that are part of the same distribution system, and
more specifically, over all APs that clients can roam between while keeping their current IP address.</p>
<p dir="auto">To securely recognize recently-connected users, an AP can store a mapping between a clientâ€™s MAC
address and their cached security associations (e.g., their cached PMK). A client can be allowed
to immediately (re)connect under a recently-used MAC address by proving that they posses the cached
security association linked to this MAC address, e.g., by connecting using the correct cached PMK.</p>
<p dir="auto">When using multi-PSK, which is also known as <a href="https://0x72326432.com/posts/perstapsk_en/" rel="nofollow">per-station PSK</a>
or <a href="https://www.cisco.com/c/en/us/td/docs/wireless/controller/technotes/8-5/b_Identity_PSK_Feature_Deployment_Guide.html" rel="nofollow">Identity PSK</a>,
the AP can keep a mapping of recently connected MAC addresses and the (unique) password that they used.
When a client connects, the AP checks whether its MAC address was recently used. If it isn&#39;t, or if it
is and the client is using the same password as before, the client can connect as normal. However,
if the same MAC address is used with a different password, the client is forced to wait a predefined
amount of time before being able to successfully connect.</p>
<p dir="auto">When using SAE-PK to secure hotspots, the only method that we are aware of to securely recognize
that a MAC address is being reused by the same user as before, is by relying on cached security
associations (e.g., the cached PMK linked to the MAC address).</p>
<p dir="auto">The above defenses assume that, after a certain delay, no more pending packets will arrive for the
victim. To prevent leaks beyond this delay, clients can use end-to-end encryption (such as TLS)
with the services they communicate with.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-32-8021x-authentication-and-radius-extensions" aria-hidden="true" href="#32-8021x-authentication-and-radius-extensions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3.2. 802.1X authentication and RADIUS extensions</h2>
<p dir="auto">Another method to securely recognize recently-connected users is based on the EAP identity they
used during 802.1X authentication. An AP can securely <a href="https://www.rfc-editor.org/rfc/rfc2865" rel="nofollow">learn the EAP identity from the RADIUS server</a>
that authenticated the client, and can keep a mapping of recently connected MAC addresses
and their corresponding EAP identity. When a client connects, the AP checks whether its MAC address
was recently used. If it isn&#39;t, or if it is and the client is using the same EAP identity as before,
the client can connect as normal. However, if the same MAC address is used under a different EAP
identity, the client is forced to wait a predefined amount of time before being able to connect
successfully.</p>
<p dir="auto">One challenge is that the AP may not always know the 802.1X identity of a client due to privacy
concerns. For instance, this information may only be available at the home AAA server, and the AP
will only receive a Chargeable User Identity from the RADIUS server. This identity does not allow the
AP to recognize two associations of the same device/credentials because its value may constantly
change. The AP does receive the anonymous identity in the EAP-Response/Identity, such as anonymous@realm,
and can rely on that to at least recognize users from different realms.</p>
<p dir="auto">To prevent users in the same realm from attacking each other, without revealing a client&#39;s
identity to the AP, cooperation and changes to the RADIUS server are needed. In particular,
the RADIUS server can be updated to help detect if the MAC address was recently being used by
another user in the same realm (in the given local network). The RADIUS server would then need
to be informed when a client disconnects, so it knows when a MAC address was last being used by
one of its users, and needs to be informed of the MAC address of any client that is trying to connect.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-33-protecting-the-gateways-mac-address" aria-hidden="true" href="#33-protecting-the-gateways-mac-address"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3.3. Protecting the gateway&#39;s MAC address</h2>
<p dir="auto">Important to note is that our attack is not limited to intercepting packets going to
Wi-Fi clients. An adversary could also try to associate with a MAC address of a default
gateway or another server in the local network. To prevent such attacks, the AP or
controller can prohibit clients from using a MAC address equal to the default gateway.
More generally, duplicate MAC address detection can be used when a Wi-Fi client is
connecting to the network, to prevent Wi-Fi clients from using a MAC address that is
also in use by other devices in the network.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-34-management-frame-protection-80211w" aria-hidden="true" href="#34-management-frame-protection-80211w"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3.4. Management Frame Protection (802.11w)</h2>
<p dir="auto">Using Management Frame Protection (MFP) would make the attack harder but not impossible.
<a href="https://papers.mathyvanhoef.com/wisec2022.pdf" rel="nofollow">In previous work</a>, we found some ways
that clients can be disconnected/deauthenticated even when MFP is being used. Based on that
experience, there always appears to be some method to forcibly disconnect a client from the
network, even when MFP is being used. Put differently, it&#39;s hard to completely prevent
disconnection and deauthentication attacks. That being said, MFP would be extra hurdle to
overcome when performing the attack in practice, so it can be useful mitigation to make the
attack harder (but not impossible) in practice.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-35-usage-of-vlans" aria-hidden="true" href="#35-usage-of-vlans"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>3.5. Usage of VLANs</h2>
<p dir="auto">Based on preliminary experiments, the attack does not work across different VLANs. In other
words, the malicious insider that performs the attack must be in the same VLAN as the victim.
One mitigation is therefore to put different groups of users in different VLANs. However,
a malicious insider would still be able to perform the attack (i.e., bypass client isolation)
against other users in the same VLAN.</p>
<p dir="auto">Note that when using multi-PSK (a.ka. per-station PSK or identity PSK), you can put clients
in different VLANs depending on the password that they use. In other words, you can use a VLAN
for each password. This prevents clients with different passwords from attacking each other.</p>


<p dir="auto">The MacStealer tool works with any network card that is supported by Linux. We tested
MacStealer on Ubuntu 22.04. To install the required dependencies on Ubuntu 22.04 execute:</p>
<div data-snippet-clipboard-copy-content="sudo apt update
sudo apt install libnl-3-dev libnl-genl-3-dev libnl-route-3-dev libssl-dev \
	libdbus-1-dev git pkg-config build-essential net-tools python3-venv \
	aircrack-ng rfkill"><pre><code>sudo apt update
sudo apt install libnl-3-dev libnl-genl-3-dev libnl-route-3-dev libssl-dev \
	libdbus-1-dev git pkg-config build-essential net-tools python3-venv \
	aircrack-ng rfkill
</code></pre></div>
<p dir="auto">Now clone this repository, build the tools, and configure a virtual python3 environment:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/vanhoefm/macstealer.git macstealer
cd macstealer/research
./build.sh
./pysetup.sh"><pre><code>git clone https://github.com/vanhoefm/macstealer.git macstealer
cd macstealer/research
./build.sh
./pysetup.sh
</code></pre></div>
<p dir="auto">The above instructions only have to be executed once.</p>
<p dir="auto">After pulling in new code using git you do have to execute <code>./build.sh</code> and <code>./pysetup.sh</code> again.
See the <a href="#id-change-log">change log</a> for a detailed overview of updates to the MacStealer
since the coordinated disclosure started.</p>


<h2 tabindex="-1" dir="auto"><a id="user-content-51-execution-environment" aria-hidden="true" href="#51-execution-environment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>5.1 Execution environment</h2>
<p dir="auto">Every time you want to use MacStealer, you first have to load the virtual python3 environment
as root. This can be done using:</p>
<div data-snippet-clipboard-copy-content="cd research
sudo su
source venv/bin/activate"><pre><code>cd research
sudo su
source venv/bin/activate
</code></pre></div>
<p dir="auto">You should now <a href="https://github.com/vanhoefm/libwifi/blob/master/docs/linux_tutorial.md#id-disable-wifi">disable Wi-Fi in your network manager</a>
so it will not interfere with MacStealer. Optionally check using <code>sudo airmon-ng check</code> to see
which other processes might be using the wireless network card and might interfere with MacStealer.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-52-network-configuration" aria-hidden="true" href="#52-network-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>5.2. Network configuration</h2>
<p dir="auto">The next step is to edit <a href="https://github.com/vanhoefm/macstealer/blob/main/research/client.conf"><code>client.conf</code></a> with the information of the network that you want to test.
This is a configuration for <a href="https://wiki.archlinux.org/title/wpa_supplicant#Connecting_with_wpa_passphrase" rel="nofollow"><code>wpa_supplicant</code></a>
that must contain two network blocks: one representing the victim and one representing
the attacker. An example configuration file to test the fictitious network <code>kuleuven</code> is:</p>
<div data-snippet-clipboard-copy-content="# Don&#39;t change this line, other MacStealer won&#39;t work
ctrl_interface=wpaspy_ctrl

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test: fill in properties of the network to test
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Victim login: fill in login credentials representing the victim
	identity=&#34;the.professor@kuleuven.be&#34;
	password=&#34;SuperSecret&#34;
}

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;attacker&#34;

	# Network to test: you can copy this from the previous block
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Attacker login: fill in login credentials representing the attacker
	identity=&#34;some.student@student.kuleuven.be&#34;
	password=&#34;SomePassword&#34;
}"><pre><code># Don&#39;t change this line, other MacStealer won&#39;t work
ctrl_interface=wpaspy_ctrl

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test: fill in properties of the network to test
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Victim login: fill in login credentials representing the victim
	identity=&#34;the.professor@kuleuven.be&#34;
	password=&#34;SuperSecret&#34;
}

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;attacker&#34;

	# Network to test: you can copy this from the previous block
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Attacker login: fill in login credentials representing the attacker
	identity=&#34;some.student@student.kuleuven.be&#34;
	password=&#34;SomePassword&#34;
}
</code></pre></div>
<p dir="auto">In the part &#34;network to test&#34; you must provide the name of the network being tested and its
security configuration. See <a href="https://github.com/vanhoefm/macstealer/blob/main/wpa_supplicant/wpa_supplicant.conf">wpa_supplicant.conf</a> for
documentation on to write/edit configuration files and for example network blocks for various
types of Wi-Fi networks. In the first network block, under &#34;victim login&#34;, you must specify
valid login credentials that represents the simulated victim. In the second network block,
you can provide exactly the same information under &#34;network to test&#34;, but you must provide
login credentials that represent the simulated attacker.</p>
<p dir="auto">In the above example, MacStealer will test an attack where the adverary is <code>some.student@student.kuleuven.be</code>
and this adversary will try to intercept traffic sent towards the victim <code>the.professor@kuleuven.be</code>.</p>
<p dir="auto">By default the script uses the configuration file <code>client.conf</code>. You can use a different
configuration file by providing the <code>--config network.conf</code> paramater, where you can replace
<code>network.conf</code> with the configuration file that you want to use.</p>
<p dir="auto">This repository also contains the following example configuration files:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://github.com/vanhoefm/macstealer/blob/main/research/multipsk.conf"><code>multipsk.conf</code></a>: A configuration file to test a network that
uses multi-PSK where one password is used by trusted devices and a second password is
given to guests.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/vanhoefm/macstealer/blob/main/research/saepk.conf"><code>saepk.conf</code></a>: A configuration file to test a public hotspot that
uses SAE-PK.</p>
</li>
</ul>
<p dir="auto">Note that it is also possible to edit the network block(s) to test a <a href="#id-test-bss">specific AP/BSS</a>.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-53-server-configuration" aria-hidden="true" href="#53-server-configuration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>5.3. Server configuration</h2>
<p dir="auto">By default, MacStealer will send a TCP SYN packet to <code>8.8.8.8</code> at port 443 in all tests, which is a
DNS server of Google. If you want to use a different server or port, you can provide one using
the <code>--server</code> parameter. For instance:</p>
<div data-snippet-clipboard-copy-content="./macstealer.py wlan0 --server 208.67.222.222"><pre><code>./macstealer.py wlan0 --server 208.67.222.222
</code></pre></div>
<p dir="auto">You can also add the port that must be used in the TCP SYN packets:</p>
<div data-snippet-clipboard-copy-content="./macstealer.py wlan0 --server 208.67.222.222:80"><pre><code>./macstealer.py wlan0 --server 208.67.222.222:80
</code></pre></div>
<p dir="auto">Replace <code>wlan0</code> with the name of your Wi-Fi interface and the IP address with the server
that you want to use.
<strong>This server must retransmit TCP SYN/ACK replies and should, ideally, still send a retransmitted</strong>
<strong>SYN/ACK more than 10 seconds after MacStealer transmitted the initial TCP SYN.</strong> You can
test this retransmission behaviour using the <code>--ping</code> parameter as follows:</p>
<div data-snippet-clipboard-copy-content="./macstealer.py wlan0 --server 208.67.222.222 --ping"><pre><code>./macstealer.py wlan0 --server 208.67.222.222 --ping
</code></pre></div>
<p dir="auto">MacStealer will output the following in case the server has the required retransmission
behaviour:</p>
<div data-snippet-clipboard-copy-content="[22:53:15] Received SYN/ACK 15.265095233917236 seconds after sending SYN.
[22:53:20] &gt;&gt;&gt; Ping test done, everything looks good so far. You can continue with other tests."><pre><code>[22:53:15] Received SYN/ACK 15.265095233917236 seconds after sending SYN.
[22:53:20] &gt;&gt;&gt; Ping test done, everything looks good so far. You can continue with other tests.
</code></pre></div>
<p dir="auto">In case the provided server doesn&#39;t send TCP SYN/ACK replies, or doesn&#39;t retransmit them
sufficiently late, MacStealer will output the following:</p>
<div data-snippet-clipboard-copy-content="[22:52:05] Received SYN/ACK 1.0727121829986572 seconds after sending SYN.
[22:52:24] &gt;&gt;&gt; Ping test done. Consider using a server that retransmits SYN/ACK for a longer time."><pre><code>[22:52:05] Received SYN/ACK 1.0727121829986572 seconds after sending SYN.
[22:52:24] &gt;&gt;&gt; Ping test done. Consider using a server that retransmits SYN/ACK for a longer time.
</code></pre></div>
<p dir="auto">The reason why the server must still retransmit a SYN/ACK after more than 10 seconds, is because
it can sometimes take several seconds to reconnect as the simulated attacker. This reconnection
process must complete before the server sends the last retransmitted TCP SYN/ACK packet.</p>


<p dir="auto">The following table contains common commands that you will execute when testing a network
along with a short description of what each command does. Below the table the details behind
each command are explained.</p>
<p dir="auto">If the network being tested uses Management Frame Protection (802.11w), the tool assumes
that the adversary can still forcibly disconnect the victim from the network. This assumption
is based on <a href="https://papers.mathyvanhoef.com/wisec2022.pdf" rel="nofollow">recent research</a> that showed that
disconnections attacks are typically still possible, albeit less straightforward or general,
when using MFP.</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Short description</th>
</tr>
</thead>
<tbody>
<tr>
<td><div dir="auto"><p><em><a href="#id-test-sanity">Sanity checks</a></em></p></div></td>
<td></td>
</tr>
<tr>
<td><code>./macstealer.py wlan0 --ping</code></td>
<td>Connect as victim &amp; test server&#39;s retransmission behavior.</td>
</tr>
<tr>
<td><code>./macstealer.py wlan0 --ping --flip</code></td>
<td>Connect as attacker &amp; test server&#39;s retransmission behavior.</td>
</tr>
<tr>
<td><div dir="auto"><p><em><a href="#id-test-vulnerability">Vulnerability tests</a></em></p></div></td>
<td></td>
</tr>
<tr>
<td><code>./macstealer.py wlan0</code></td>
<td>Test the default variant of the MAC address stealing attack.</td>
</tr>
<tr>
<td><code>./macstealer.py wlan0 --other-bss</code></td>
<td>Let the attacker connect with a different AP than the victim.</td>
</tr>
<tr>
<td><div dir="auto"><p><em><a href="#id-test-isolation">Client isolation: Ethernet layer</a></em></p></div></td>
<td></td>
</tr>
<tr>
<td><code>./macstealer.py wlan0 --c2c wlan1</code></td>
<td>Test client-to-client Ethernet layer traffic (ARP poisoning).</td>
</tr>
<tr>
<td><code>./macstealer.py wlan0 --c2c-eth wlan1</code></td>
<td>Test client-to-client Ethernet layer traffic (DNS).</td>
</tr>
</tbody>
</table>

<h2 tabindex="-1" dir="auto"><a id="user-content-61-sanity-checks" aria-hidden="true" href="#61-sanity-checks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6.1. Sanity checks</h2>
<p dir="auto">Before testing for vulnerabilities, you can use the following to commands to confirm
that MacStealer can connect to the network as both the victim and attacker:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>./macstealer.py wlan0 --ping</code>: connects to the network using the credentials of the victim.
Once connected, a TCP SYN is sent to the server (which is by default <code>8.8.8.8</code> and <a href="https://github.com/vanhoefm/macstealer/blob/main/id-server-config">can be changed</a>).
MacStealer will check whether and how many times the SYN/ACK is (re)transmitted. You can use
this to confirm that the credentials of the victim are correct and to check that the configured
server is properly retransmitting SYN/ACK replies.</p>
</li>
<li>
<p dir="auto"><code>./macstealer.py wlan0 --ping --flip</code>: Same as the above test, but now the script will connect
using the credentials of the adversary. You can use this to confirm that the credentials of the
adversary are correct.</p>
</li>
</ul>

<h2 tabindex="-1" dir="auto"><a id="user-content-62-vulnerability-tests-cve-2022-47522" aria-hidden="true" href="#62-vulnerability-tests-cve-2022-47522"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6.2. Vulnerability tests (CVE-2022-47522)</h2>
<ul dir="auto">
<li>
<p dir="auto"><code>./macstealer.py wlan0</code>: Test the default variant of the MAC address stealer attack. The attacker
will reconnect to the same AP/BSS as the victim.</p>
</li>
<li>
<p dir="auto"><code>./macstealer.py wlan0 --other-bss</code>: The attacker will connect to a different AP/BSS of the same
network. A network that is (also) vulnerable to this test is easier to exploit in practice. If only
a single AP/BSS is within radio range, the script will timeout when connecting as the attacker.</p>
</li>
</ul>

<h2 tabindex="-1" dir="auto"><a id="user-content-63-client-isolation-tests-ethernet-layer" aria-hidden="true" href="#63-client-isolation-tests-ethernet-layer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6.3. Client isolation tests (Ethernet layer)</h2>
<p dir="auto">Exploiting the MAC address stealing vulnerability only makes sense if client isolation is enabled
or when techniques such as ARP inspection are used to prevent clients from attacking each other.
Otherwise, an adversary can use easier attacks such as <a href="https://en.wikipedia.org/wiki/ARP_spoofing" rel="nofollow">ARP poisoning</a>
to intercept traffic. To test whether client isolation is enabled, or whether ARP inspection is
used by the network, you can use the following commands:</p>
<ul dir="auto">
<li>
<p dir="auto"><code>./macstealer.py wlan0 --c2c wlan1</code>: With these arguments, MacStealer tests whether the network
allows client-to-client ARP poisoning traffic from the attacker (<code>wlan1</code>) towards the victim (<code>wlan0</code>).
Here <code>wlan1</code> is a second wireless network interface. The script will then test whether malicious
ARP packets can be sent from the attacker to the victim.</p>
</li>
<li>
<p dir="auto"><code>./macstealer.py wlan0 --c2c-eth wlan1</code>: This is similar to the above test, but instead of sending
malicious ARP packets, the attacker will send DNS packets to the victim.</p>
</li>
</ul>
<p dir="auto">The MAC address stealing vulnerability should be considered a risk in practice if client-to-client
traffic is blocked in any of the above two tests (meaning when client isolation is enabled or when
other techniques such as ARP inspection are used to prevent users from attacker each other).</p>
<p dir="auto">By default, MacStealer will try to connect to the same AP/BSS using both interface, so it&#39;s
important that both network cards can see the same networks (i.e. make sure that both network
interfaces support the same frequency bands and channels). If you want both clients to connect
to a different AP/BSS then you can use the parameter <code>--other-bss</code>.</p>
<p dir="auto">You can use the <code>--flip-id</code> parameter to test whether traffic from the victim (<code>wlan0</code>) is allowed
towards the attacker (<code>wlan1</code>).</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-64-troubleshooting-checklist" aria-hidden="true" href="#64-troubleshooting-checklist"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>6.4. Troubleshooting checklist</h2>
<p dir="auto">In case MacStealer doesn&#39;t appear to be working, check the following:</p>
<ol dir="auto">
<li>
<p dir="auto">Check that no other process is using the network card (e.g. kill your network manager).
You may see the output <code>kernel reports: match already configured</code> if another process
is also using the network card.</p>
</li>
<li>
<p dir="auto">If everything worked previously, try unplugging your Wi-Fi dongle, restart your computer or virtual
machine, and then try again.</p>
</li>
<li>
<p dir="auto">Confirm that you are connecting to the correct network. Double-check <code>client.conf</code>.</p>
</li>
<li>
<p dir="auto">If you updated the code using git, execute <code>./build.sh</code> and <code>./pysetup.sh</code> again (see <a href="#id-prerequisites">Prerequisites</a>).</p>
</li>
<li>
<p dir="auto">If you are using a virtual machine, try to run MacStealer from a native Linux installation instead.</p>
</li>
<li>
<p dir="auto">Run MacStealer with the extra parameter <code>-dd</code> to get extra debug output from wpa_supplicant
and from MacStealer itself.</p>
</li>
</ol>

<h2 tabindex="-1" dir="auto"><a id="user-content-71-testing-ip-layer-client-isolation" aria-hidden="true" href="#71-testing-ip-layer-client-isolation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>7.1. Testing IP layer client isolation</h2>
<p dir="auto">The default <a href="https://github.com/vanhoefm/macstealer/blob/main/id-test-isolation">client isolation tests</a> will check whether traffic at the Ethernet
layer is allowed between clients. It is also possible to test whether IP layer traffic is allowed
between clients using the following command:</p>
<div data-snippet-clipboard-copy-content="./macstealer.py wlan0 --c2c-ip wlan1 [--flip-id]"><pre><code>./macstealer.py wlan0 --c2c-ip wlan1 [--flip-id]
</code></pre></div>
<p dir="auto">When IP layer traffic between clients is allowed, it still possible for clients to attack each other.
For instance, <a href="https://www.usenix.org/conference/usenixsecurity22/presentation/feng" rel="nofollow">ICMP redirect attacks</a>
may then still be possible. Such attacks are more cumbersome than ARP spoofing, but are ideally
still prevented by also blocking IP layer traffic between clients.</p>

<p dir="auto">The following tests can be executed to test general properties of a network. These tests aren&#39;t
directly related to vulnerabilities but can be used to better understand the behaviour of a network.</p>
<ul dir="auto">
<li>
<p dir="auto"><code>./macstealer.py wlan0 --same-id [--other-bss] [--flip]</code>: Test whether TCP connections stay alive after
disconnecting and reconnecting to an Access Points. If connections do not stay alive after reconnecting,
the network is likely not vulnerable to the MAC address stealing attacks. However, a major downside
of this behaviour is that legitimate clients have to open new TCP connections whenever reconnecting
to this network, making this network appear slow and unreliable (so a better defense should be used
instead).</p>
<p dir="auto">You can use the <code>--other-bss</code> parameter to reconnect to a different AP/BSS of the same network.
You can use the <code>--flip</code> argument to perform this test under the attacker identity instead
of the victim identity.</p>
</li>
<li>
<p dir="auto"><code>./macstealer.py wlan0 --flip</code>: Test the normal MAC address stealing attack, but switch the
role of the attacker and victim. In other words, the attacker will use the &#34;victim credentials&#34;
provided in the configuration file, and the victim will use the &#34;adversary credentials&#34;.</p>
</li>
<li>
<p dir="auto"><code>./macstealer.py wlan0 --c2c wlan1 --same-id [--flid-id]</code>: Test whether client-to-client traffic is
allowed between two devices of the same user. See <a href="#id-test-isolation">client isolation tests</a> for
documentation on the <code>wlan1</code> parameter.</p>
<p dir="auto">You can use the <code>--flip</code> argument to perform this test under the attacker identity instead
of the victim identity.</p>
</li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-73-other-parameters" aria-hidden="true" href="#73-other-parameters"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>7.3. Other parameters</h2>
<ul dir="auto">
<li>
<p dir="auto"><code>--delay seconds</code>: You can use the parameter <code>--delay</code> to specify a delay, in seconds, before reconnecting as
the attacker.</p>
</li>
<li>
<p dir="auto"><code>-d</code> or <code>-dd</code>: Adding one of these parameters increases the debug verbosity of the script
and the underlying <code>wpa_supplicant</code> instance.</p>
</li>
</ul>

<h2 tabindex="-1" dir="auto"><a id="user-content-74-testing-a-specific-access-point--bss" aria-hidden="true" href="#74-testing-a-specific-access-point--bss"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>7.4. Testing a specific Access Point / BSS</h2>
<p dir="auto">By default, MacStealer will automatically select an AP/BSS of the network to connect with and test.
In case you have a network with multiple APs/BSSes, you can test a specific one by specifying this
AP/BSS in the network block of the victim using the <code>bssid</code> keyword. For example, you can use:</p>
<div data-snippet-clipboard-copy-content="...

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test: fill in properties of the network to test
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Victim login: fill in login credentials representing the victim
	identity=&#34;the.professor@kuleuven.be&#34;
	password=&#34;SuperSecret&#34;

	# This a specific AP/BSS
	bssid=00:11:22:33:44:55
}

..."><pre><code>...

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test: fill in properties of the network to test
	ssid=&#34;kuleuven&#34;
	key_mgmt=WPA-EAP
	eap=PEAP
	phase2=&#34;auth=MSCHAPV2&#34;

	# Victim login: fill in login credentials representing the victim
	identity=&#34;the.professor@kuleuven.be&#34;
	password=&#34;SuperSecret&#34;

	# This a specific AP/BSS
	bssid=00:11:22:33:44:55
}

...
</code></pre></div>
<p dir="auto">With the above configuration, MacStealer will test <code>00:11:22:33:44:55</code>. This means it will
connect both as the victim <em>and as the attacker</em> to this AP.</p>
<p dir="auto">You can also combine this with the <code>--other-bss</code> parameter. In that case, the victim will
connect to <code>00:11:22:33:44:55</code>, and the attacker will connect to a different AP/BSS of the
same network.</p>
<p dir="auto">Another option is to specify an explicit BSS/AP in the network block of the victim <em>and</em> attacker.</p>
<p dir="auto">Note that MacStealer will search for at most 30 seconds for the given AP/BSS. If it cannot
find the specified AP/BSS the tool will quit.</p>

<h2 tabindex="-1" dir="auto"><a id="user-content-75-testing-an-sae-pk-network" aria-hidden="true" href="#75-testing-an-sae-pk-network"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>7.5. Testing an SAE-PK network</h2>
<p dir="auto">You can test an SAE-PK network by using the following configuration file. Notice that for
SAE-PK networks there is no difference in how the victim and attacker authenticate, i.e.,
they both use the same password.</p>
<div data-snippet-clipboard-copy-content="# Don&#39;t change this line, other MacStealer won&#39;t work
ctrl_interface=wpaspy_ctrl

# WPA3/SAE: support both hunting-and-pecking loop and hash-to-element
sae_pwe=2

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;attacker&#34;

	# Network to test - attacker login
	ssid=&#34;test-saepk&#34;
	psk=&#34;7iip-ytnz-qa25&#34;
	key_mgmt=SAE
	ieee80211w=2
}

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test - victim login
	ssid=&#34;test-saepk&#34;
	psk=&#34;7iip-ytnz-qa25&#34;
	key_mgmt=SAE
	ieee80211w=2
}"><pre><code># Don&#39;t change this line, other MacStealer won&#39;t work
ctrl_interface=wpaspy_ctrl

# WPA3/SAE: support both hunting-and-pecking loop and hash-to-element
sae_pwe=2

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;attacker&#34;

	# Network to test - attacker login
	ssid=&#34;test-saepk&#34;
	psk=&#34;7iip-ytnz-qa25&#34;
	key_mgmt=SAE
	ieee80211w=2
}

network={
	# Don&#39;t change this field, the script relies on it
	id_str=&#34;victim&#34;

	# Network to test - victim login
	ssid=&#34;test-saepk&#34;
	psk=&#34;7iip-ytnz-qa25&#34;
	key_mgmt=SAE
	ieee80211w=2
}
</code></pre></div>


<h2 tabindex="-1" dir="auto"><a id="user-content-81-wpa-psk-authentication" aria-hidden="true" href="#81-wpa-psk-authentication"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>8.1. WPA-PSK authentication</h2>
<p dir="auto">In practice, client isolation is also used in networks that are secured using a pre-shared password.
For instance, several routers have an option to create a network for guests or insecure (IoT) devices,
where clients in this network are isolated so they cannot attack each other. However, the security
advantage of using client isolation in this scenario can be questioned. Client isolation is supposed
to prevent a malicious insider from attacking others. But if the malicious insider knows the
pre-shared password, they can just create a rogue clone (evil twin), trick victims into connecting to
this malicious copy of the network, and then attack other clients! In other words, <strong>using client</strong>
<strong>isolation in a network secured using a password provides no strong security</strong>, a malicious client
can create a rogue AP to still attack other clients.</p>
<p dir="auto">That being said, it can be argued that creating a rogue AP can be detected by the network administrator,
meaning client isolation does make attacks harder. Additionally, when a lightweight device is (remotely)
compromised, it may not have the resources to (easily) act as a rogue AP. This makes it harder, but not
impossible, to perform attacks when client isolation is used. Overall, although client isolation provides
no strong security guarantees in a password-protected network, it can be argued that it increases the
practical difficulty of performing attacks.</p>
<p dir="auto">Our MacStealing attack is easier to perform than creating a rogue AP. All that the malicious insider,
e.g., a lightweight compromised IoT devices, needs to do is spoof a MAC address and (re)connect to the
network. Such an attack is also harder to detect. Based on this observation, our new attack makes the
situation worse, and therefore one can argue that our attack should also be considered relevant in
networks protected using a pre-shared password.</p>
<p dir="auto"><strong>Conclusion: when using client isolation in a password-protected network, you are making the assumption</strong>
<strong>that a malicious insider will not create a rogue AP. Otherwise, the usage of client isolation is</strong>
<strong>meaningless from a security perspective. The MacStealing attack can be performed without creating a</strong>
<strong>rogue AP and therefore makes attacks easier.</strong></p>

<h2 tabindex="-1" dir="auto"><a id="user-content-82-common-misunderstandings" aria-hidden="true" href="#82-common-misunderstandings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>8.2. Common misunderstandings</h2>
<ul dir="auto">
<li>
<p dir="auto">The goal of our attack isn&#39;t to bypass MAC address deny/allow lists on Access Points. Spoofing MAC
addresses to bypass MAC address filtering is a different and known attack.</p>
</li>
<li>
<p dir="auto">The goal of our attack isn&#39;t to hijack someone&#39;s paid connection in Wi-Fi hotspots. For instance,
some open (or protected) hotspots require the user to pay before being allowed to access the internet.
Often a paying subscriber is recognized based on their MAC address, and an adversary can spoof a victim&#39;s
MAC address to gain access to the Internet. This is not the purpose of our attack; the goal of MacStealer
is to bypass client isolation.</p>
</li>
<li>
<p dir="auto">Our attack also affects networks that defend against the Hole 196 vulnerability. For instance,
<a href="https://www.wi-fi.org/discover-wi-fi/passpoint" rel="nofollow">Passpoint</a> (formerly Hotspot 2.0) networks are required
to prevent the Hole 196 vulnerability, but are still vulnerable to our attack.</p>
</li>
<li>
<p dir="auto">Our attack works in networks that defend against ARP spoofing. It badly-secured Wi-Fi networks, an
adversary can trivially perform ARP spoofing to intercept a victim&#39;s traffic, and our attack is not
really practical. However, modern networks, which may have malicious insiders, rely on client isolation
or other methods to prevent machine-in-the-middle attacks. Our attacker bypasses all these modern defenses
and still enables an adversary to intercept traffic toward a victim.</p>
</li>
</ul>
<p dir="auto">To summarize, our attack affects Wi-Fi networks where clients are prevented from attacking each other,
enabling an adversary to intercept traffic to another client.</p>


<p dir="auto"><strong>Version 1.2 (in progress)</strong></p>
<ul dir="auto">
<li>
<p dir="auto">Improved README: focus intro on bypassing client isolation, update defenses with 802.1X remarks and
to prevent stealing the default gateway&#39;s MAC address.</p>
</li>
<li>
<p dir="auto">Added the <code>--delay</code> parameter to specify a delay in seconds before reconnecting as the attacker.</p>
</li>
</ul>
<p dir="auto"><strong>Version 1.1 (18 January 2023)</strong></p>
<ul dir="auto">
<li>
<p dir="auto">By default use <code>8.8.8.8</code> as the server instead of <code>216.58.208.100</code> (both are Google servers).</p>
</li>
<li>
<p dir="auto">Updated client isolation tests: by default test using ARP poisoning at Ethernet layer. Also provide
option to send UDP data with forwarding at Ethernet layer, and a test with forwarding at IP layer.</p>
</li>
<li>
<p dir="auto">Improved README: updated the types of network that may be affected. Included a discussion of
whether password-protected WPA2 or WPA3 networks are affected. Explanation of different commands
to test for client-to-client Ethernet or IP layer traffic.</p>
</li>
<li>
<p dir="auto">Improved README: discussion of MFP, discussion of VLANs as mitigation, clarify over which APs the
<a href="#id-prevent-stealing">identity check</a> must be done, specifying port of the server,</p>
</li>
<li>
<p dir="auto">Improved output of MacStealer.</p>
</li>
</ul>
<p dir="auto"><strong>Version 1.0 (3 January 2023)</strong>:</p>
<ul dir="auto">
<li>Prepared initial release for usage during the embargo. The code is based on hostap commit 0f3f9cdcab6a.</li>
</ul>
</article>
          </div></div>
  </body>
</html>
