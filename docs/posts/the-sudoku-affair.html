<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://explaining.software/archive/the-sudoku-affair/">Original</a>
    <h1>The Sudoku Affair</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                February 5, 2025
                
            </date>
            
            
            

            

            
            
            <p>In 2006, Ron Jeffries wrote a series of posts describing his attempts to build a <a href="https://en.wikipedia.org/wiki/Sudoku" target="_blank">Sudoku</a> solver.  He <a href="https://ronjeffries.com/xprog/articles/oksudoku/" target="_blank">began</a> by wrapping a class around a simple datatype for the board — essentially a <code>List[Option[Int]]</code> — and after that, there isn&#39;t much to tell.  As Peter Seibel puts it:</p>
<blockquote>
<p>[H]e basically wandered around for the rest of his five blog postings fiddling with the representation, making it more “object oriented” and then fixing up the tests to work with the new representation and so on until eventually, it seems, he just got bored and gave up, having made only one minor stab at the problem of actually solving puzzles.<sup id="fnref:seibel1"><a href="#fn:seibel1">1</a></sup></p>
</blockquote>
<p>This story has, in some circles, become notorious.  There are two reasons for this.  The first is that Ron Jeffries is a leading proponent of a <a href="https://explaining.software/archive/the-death-of-the-architect/" target="_blank">post-design</a> approach to software development.  Good design, he asserts, is simply the result of keeping your code &#34;properly-factored:&#34;</p>
<blockquote>
<p>[Kent] Beck has those rules for properly-factored code: 1) runs all the tests, 2) contains no duplication, 3) expresses every idea you want to express, 4) minimal number of classes and methods. When you work with these rules, you pay attention only to micro-design matters.</p>
<p>When I used to watch Beck do this, I was sure he was really doing macro design &#34;in his head&#34; and just not talking about it, because you can see the design taking shape, but he never seems to be doing anything directed to the design. So I started trying it. What I experience is that I am never doing anything directed to macro design or architecture: just making small changes, removing duplication, improving the expressiveness of little patches of code. Yet the overall design of the system improves. I swear I&#39;m not doing it.<sup id="fnref:jeffries1"><a href="#fn:jeffries1">2</a></sup></p>
</blockquote>
<p>The second reason is that, in the same week that Jeffries was wandering around, Peter Norvig released a <a href="https://norvig.com/sudoku.html" target="_blank">complete Sudoku solver</a>.  And in his first fifteen lines of code, he got further than Jeffries:</p>
<div><pre><span></span><code><span>def</span> <span>cross</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>):</span>
    <span>&#34;Cross product of elements in A and elements in B.&#34;</span>
    <span>return</span> <span>[</span><span>a</span><span>+</span><span>b</span> <span>for</span> <span>a</span> <span>in</span> <span>A</span> <span>for</span> <span>b</span> <span>in</span> <span>B</span><span>]</span>

<span>digits</span>   <span>=</span> <span>&#39;123456789&#39;</span>
<span>rows</span>     <span>=</span> <span>&#39;ABCDEFGHI&#39;</span>
<span>cols</span>     <span>=</span> <span>digits</span>
<span>squares</span>  <span>=</span> <span>cross</span><span>(</span><span>rows</span><span>,</span> <span>cols</span><span>)</span>
<span>unitlist</span> <span>=</span> <span>([</span><span>cross</span><span>(</span><span>rows</span><span>,</span> <span>c</span><span>)</span> <span>for</span> <span>c</span> <span>in</span> <span>cols</span><span>]</span> <span>+</span>
            <span>[</span><span>cross</span><span>(</span><span>r</span><span>,</span> <span>cols</span><span>)</span> <span>for</span> <span>r</span> <span>in</span> <span>rows</span><span>]</span> <span>+</span>
            <span>[</span><span>cross</span><span>(</span><span>rs</span><span>,</span> <span>cs</span><span>)</span> <span>for</span> <span>rs</span> <span>in</span> <span>(</span><span>&#39;ABC&#39;</span><span>,</span><span>&#39;DEF&#39;</span><span>,</span><span>&#39;GHI&#39;</span><span>)</span> <span>for</span> <span>cs</span> <span>in</span> <span>(</span><span>&#39;123&#39;</span><span>,</span><span>&#39;456&#39;</span><span>,</span><span>&#39;789&#39;</span><span>)])</span>
<span>units</span> <span>=</span> <span>dict</span><span>((</span><span>s</span><span>,</span> <span>[</span><span>u</span> <span>for</span> <span>u</span> <span>in</span> <span>unitlist</span> <span>if</span> <span>s</span> <span>in</span> <span>u</span><span>])</span> 
             <span>for</span> <span>s</span> <span>in</span> <span>squares</span><span>)</span>
<span>peers</span> <span>=</span> <span>dict</span><span>((</span><span>s</span><span>,</span> <span>set</span><span>(</span><span>sum</span><span>(</span><span>units</span><span>[</span><span>s</span><span>],[]))</span><span>-</span><span>set</span><span>([</span><span>s</span><span>]))</span>
             <span>for</span> <span>s</span> <span>in</span> <span>squares</span><span>)</span>
</code></pre></div>
<p>If you compare both implementations, Norvig&#39;s is notable for its clarity and directness.  Even more notable is his chosen datatype.  When Jeffries chose <code>List[Option[Int]]</code>, he was clearly mimicking how a Sudoku board was rendered on a page: there are a 81 cells, and some of them have numbers.  In Norvig&#39;s code, however, the Sudoku board is represented as a collection of possible moves: <code>Map[Coord, Set[Int]]</code>.  </p>
<p>An empty board is a collection of full sets; each cell can be assigned any integer in <code>{1, ..., 9}</code>.  When a cell is assigned a number, its set is reduced to a singleton, and that number is removed from the sets of all its <code>peers</code>.  If, as a result, a peer set is reduced to a singleton, this process repeats.</p>
<p>After that, the only thing left was a simple recursive search.  At each step, a move was randomly selected from the available options.  If that move emptied one of the sets, that line of search was abandoned.  And if all the sets were reduced to singletons, then our search was over.</p>
<p>While Norvig didn&#39;t employ any heuristics in his search, they&#39;d be easy to add.  A common strategy in Sudoku is looking for <a href="https://www.learn-sudoku.com/naked-pairs.html" target="_blank">naked pairs</a>: if two peers have the same two candidate values, then simply assign one to each.  To employ this, all you&#39;d need to do is replace the random selection with a function that looks for matching 2-sets.</p>
<p>And so Norvig&#39;s implementation was more than a toy solution.  It was a minimal, but extensible, example of <a href="https://en.wikipedia.org/wiki/Local_consistency" target="_blank">constraint propagation</a>.  It provided a foundation for exploring both the problem and the solution.</p>
<hr/>
<h2>what it all means</h2>
<p>Norvig, for his part, didn&#39;t assign any of this much importance.  When interviewed by Seibel, he said the key difference was that Jeffries &#34;didn&#39;t know how to solve the problem.&#34;</p>
<blockquote>
<p>I actually knew — from AI — that, well, there&#39;s this field of constraint propagation — I know how that works.  There&#39;s this field of recursive search — I know how that works.  And I could see, right from the start, you put these two together, and you could solve this Sudoku thing.  He didn&#39;t know that so he was sort of blundering in the dark even though all his code &#34;worked&#34; because he had all these test cases.<sup id="fnref:seibel2"><a href="#fn:seibel2">3</a></sup></p>
</blockquote>
<p>I agree, but would take it a little further.  Both Norvig and Jeffries are <strong>genre programmers</strong>; they have spent most of their career solving a specific kind of problem.  And that problem, inevitably, lends itself to a particular kind of solution.</p>
<p>Peter Norvig&#39;s genre is search.  He literally <a href="https://aima.cs.berkeley.edu/" target="_blank">wrote the book</a> on good old-fashioned AI, where every problem is reduced — for better or worse — to a search problem.  </p>
<p>Ron Jeffries&#39; genre is, as best I can tell, the database application.  Like the rest of the Agile Manifesto co-authors, he came up in an era where every business was seeking to &#34;computerize&#34; its processes.  This led to a decade&#39;s worth of applications consisting of a database, a thin layer of business logic, and an even thinner frontend.  </p>
<p>There is, in these applications, a close relationship between the database schema and user interface.  Consider the scaffolding provided by the Rails framework: you describe an entity, and it generates the code necessary to view and change those entities.  This is why Jeffries chose the <code>List[Option[Int]]</code> representation; it mimicked how a Sudoku board is presented to its user.</p>
<p>This choice is not remarked upon.  It is, to Jeffries, simply the obvious place to start.  And I&#39;d imagine that in his professional career, this intuition served him well.  But his intuition was developed, and applied, within his chosen genre.  Here, he was doing something new; a mystery novelist trying his hand at fantasy.  But in the end, it was just a bunch of elves and dwarves in a stately manor, waiting for the wizard to tell them whodunnit.</p>
<p>Jeffries, it should be noted, also assigns little importance to this episode.  After weathering fifteen years of online discourse, he wrote this:</p>
<blockquote>
<p>Did incremental design and development fail? I don’t think so. Certainly I was using an incremental approach, and certainly no product came out. Did the approach fail?</p>
<p>I don’t think so. I think I wasn’t having fun and just stopped working on the project.<sup id="fnref:jeffries2"><a href="#fn:jeffries2">4</a></sup></p>
</blockquote>
<p>This is belied, however, by the fact that he returned to Sudoku two years later, writing <a href="https://ronjeffries.com/categories/sudoku/" target="_blank">forty-five</a> new posts on the topic.  </p>
<p>By the end of the fifth post, Jeffries had a working Sudoku solver.  <em>But then he kept going.</em>  He continued to tinker with the solver for another two months and forty posts.  And in this prolonged epilogue, we can see the limits of his incremental approach to software design.</p>
<hr/>
<h2>back in the saddle point</h2>
<p>Jeffries&#39; second attempt at a Sudoku solver begins, predictably, with a <code>List[Option[Int]]</code> representation.  From there, he writes a function that calculates the possible values for an empty cell.  He writes a simple recursive search function, which always selects the first possible value for the first possible cell.  And with that, his solver was complete.</p>
<p>His <a href="https://ronjeffries.com/articles/-x024/-z00/4/#Summary" target="_blank">solution</a> is, from a design perspective, serviceable.  It&#39;s fewer than a hundred lines, but because of his chosen representation, much of that is spent on integer arithmetic:</p>
<div><pre><span></span><code><span>def</span> <span>used_numbers_in_sub_grid</span><span>(</span><span>self</span><span>,</span> <span>position</span><span>):</span>
  <span>first_index_in_row</span> <span>=</span> <span>position</span> <span>//</span> <span>self</span><span>.</span><span>line_size</span> <span>*</span> <span>self</span><span>.</span><span>line_size</span>
  <span>offset_in_row</span> <span>=</span> <span>position</span> <span>%</span> <span>9</span> <span>//</span> <span>3</span> <span>*</span> <span>3</span>
  <span>first_index_in_sub_grid</span> <span>=</span> <span>first_index_in_row</span> <span>//</span> <span>27</span> <span>*</span> <span>27</span> <span>+</span> <span>offset_in_row</span>
  <span>...</span>
  <span>for</span> <span>row</span> <span>in</span> <span>range</span><span>(</span><span>first_index_in_sub_grid</span><span>,</span> <span>first_index_in_sub_grid</span><span>+</span><span>27</span><span>,</span> <span>9</span><span>):</span>
    <span>for</span> <span>col</span> <span>in</span> <span>range</span><span>(</span><span>0</span><span>,</span> <span>3</span><span>):</span>
      <span>...</span>
</code></pre></div>
<p>We can contrast this with the (roughly) equivalent code in Norvig&#39;s implementation:</p>
<div><pre><span></span><code><span>[</span><span>cross</span><span>(</span><span>rs</span><span>,</span> <span>cs</span><span>)</span> <span>for</span> <span>rs</span> <span>in</span> <span>(</span><span>&#39;ABC&#39;</span><span>,</span><span>&#39;DEF&#39;</span><span>,</span><span>&#39;GHI&#39;</span><span>)</span> <span>for</span> <span>cs</span> <span>in</span> <span>(</span><span>&#39;123&#39;</span><span>,</span><span>&#39;456&#39;</span><span>,</span><span>&#39;789&#39;</span><span>)]</span>
</code></pre></div>
<p>The difference lies in how each cell is represented.  In Jeffries&#39; code, each cell is an integer, representing its index in the <code>List</code>.  Norvig&#39;s code, on the other hand, represents each cell as a string describing its row and column.  As a result, he doesn&#39;t need to fuss with modulo operators; he can simply use string concatenation.</p>
<p>This, by itself, is not an indictment of Jeffries&#39; approach.  His software design is incremental; what matters is the destination.  As he explains in his twenty-third post:</p>
<blockquote>
<p>Naturally, I try to make good design decisions, not bad ones, although often enough the decisions I make do not pan out. (Yes, I hear you saying that makes your case for coming up with a solid design early, but no, it doesn’t. It makes mine: I don’t know enough to make a better decision.) So I try to make small decisions, simple decisions, decisions that will be easy to change when, not if, a better idea comes along.<sup id="fnref:jeffries3"><a href="#fn:jeffries3">5</a></sup></p>
</blockquote>
<p>There is, unfortunately, little evidence of this in the preceding posts.  After demonstrating a working solver, Jeffries spends the next six posts trying to &#34;simplify&#34; it.  He tinkers a bit with the integer arithmetic, and then hides it away in a separate class.</p>
<p>Then, in the twelfth post, things get interesting.  While debugging his implementation, he generates an analogue of Norvig&#39;s representation: rather than an <code>Option[Int]</code>, each cell is a <code>Set[Int]</code> of possible values.  And in the thirteenth post, he arrives at the notion of constraint propagation:</p>
<blockquote>
<ol>
<li>Suppose the puzzle contains, not just the current solution state, but also, for each of the 81 cells, the available values for that cell. So when we do our <code>new_puzzle_trying</code> method, we’d</li>
<li>Create a new puzzle that copied all those values … then</li>
<li>Assign our guess … and then</li>
<li>Recompute the available values for the position’s components, which</li>
<li>Can be done either by removing the guess or recalculating, whichever is better.<sup id="fnref:jeffries4"><a href="#fn:jeffries4">6</a></sup></li>
</ol>
</blockquote>
<p>This is a pivotal point in Jeffries&#39; design process.  He has solved the problem, understood the limitations of that solution, and imagined something entirely different.  It is, in other words, a chance to start over.</p>
<p>If Jeffries started with a different core representation, then it&#39;s likely his subsequent design decisions would also change.  The bookkeeping for constraint propagation might push him towards Norvig&#39;s relational approach to the rules of Sudoku; rather than continually recomputing the rows, columns, and boxes, he could simply have a map of each cell onto its <code>peers</code>.  He could distill every lesson of the previous posts, creating something simpler and faster.</p>
<p>But Jeffries isn&#39;t in the business of starting over.  He not only believes in incremental design, but in using the smallest possible increments.  In his posts, he regularly returns to GeePaw Hill&#39;s maxim of <a href="https://www.geepawhill.org/2021/09/29/many-more-much-smaller-steps-first-sketch/" target="_blank">&#34;many more much smaller steps.&#34;</a>  He is only interested in designs that are reachable through a series of small, discrete steps:</p>
<blockquote>
<p>In most every article of the 5,000 articles here, at least the programming ones, I have intentionally done minimal design up front. My intention was to demonstrate what happens when I do that, expecting that small steps, tests, and refactoring would enable me to improve the design as needed.... In almost every situation, that has turned out to be the case. Incremental design, at least at the level I do it here, works well. And the techniques thereof allow us to improve any code that needs it.<sup id="fnref:jeffries5"><a href="#fn:jeffries5">7</a></sup></p>
</blockquote>
<p>This, again, is contradicted by the preceding posts.  His attempts to implement constraint propagation had unambiguously failed.  </p>
<p>He began in his seventeenth post, adding a <code>List[Set[Int]]</code> as a sidecar to his core representation.  But since the incremental updates were, as yet, unimplemented, it had to be recomputed after each move.  As a result, his solver became two orders of magnitude slower; his test puzzle, which once took 200ms to solve, now took a full 20 seconds.  </p>
<p>Jeffries seems largely unbothered by this.  He disables the slow test, and begins to look at search heuristics, under the theory that &#34;moving towards more human approaches&#34;<sup id="fnref:jeffries6"><a href="#fn:jeffries6">8</a></sup> might offset the performance loss.  He only returns to it ten days and eleven posts later, at which point he&#39;s clearly lost the thread.  Rather than try to implement the incremental updates, he simply makes it so that the <code>List[Set[Int]]</code> is lazily generated.  And since nothing is actually <em>using</em> this new data structure, this &#34;fixes&#34; the issue.  </p>
<p>In the twenty-odd posts that follow, Jeffries never returns to constraint propagation.  Instead, he putters around with search heuristics like naked pairs; something that, again, Norvig&#39;s approach makes fairly trivial.  And after the forty-fifth post, Jeffries seems to lose interest.  He has, apparently, reached his destination.</p>
<p>The resulting code is, again, serviceable.  It solves Sudoku puzzles, and has support for various &#34;human approaches&#34; to solving puzzles.  But the implementation<sup id="fnref:implementation"><a href="#fn:implementation">9</a></sup> has a diffuse, muddled quality.  In his <code>Puzzle</code> class, some methods refer to the <code>Set[Int]</code> associated with a cell as <code>possible_answers</code>, and others as <code>candidates</code>.  Likewise, most method names distinguish between <code>position</code> (index) and <code>cell</code> (value), but <code>Puzzle.unknown_cells</code> returns a list of indices.  And while <code>Puzzle</code> began as an immutable representation, somewhere along the way it grew a mutable <code>remove_naked_pair</code> method.</p>
<p>In a larger codebase, these sorts of inconsistencies are inevitable.  Despite our best efforts, entropy creeps in.  But Jeffries&#39; solver is only a few hundred lines of code, and was refined for months on end.  We must treat every line as intentional.</p>
<p>When we say software is <a href="https://explaining.software/archive/glossary/#complexity" target="_blank">simple</a>, we mean it&#39;s easy to explain.  Well-designed structure often has a narrative structure; there is a natural order to its components, and each helps to explain the next.  We can see this in Norvig&#39;s implementation: it codifies the rules as a set of relationships, and then uses those relationships to solve the problem.</p>
<p>This doesn&#39;t happen by accident.  The developer needs to hold the entire <a href="https://explaining.software/archive/glossary/#structure" target="_blank">structure</a> in their head, and find a simple path that connects its constituent parts.  And if no such path can be found, they need to find a better structure. </p>
<p>Jeffries, however, does not believe in bigger pictures; his approach to software design is proudly myopic.  He prevents himself from seeing the forest by pressing his face against the trees.  And sometimes, as he moves from one tree to the next, he takes a moment to celebrate:</p>
<blockquote>
<p>As I refine and refine and refine, the design moves toward smaller objects, with single responsibilities and simple code. The design improves, bit by bit, almost by itself.<sup id="fnref:jeffries7"><a href="#fn:jeffries7">10</a></sup></p>
</blockquote>
<p>But it doesn&#39;t.  Software design is a deliberate process, and requires deliberate effort.  Anything less is just a shrug in the face of entropy.</p>

            
            

            
            
            <hr/>
<p>This post is an excerpt from my (incomplete) book on software design.  For more about the book, see the <a href="https://explaining.software/" target="_blank">overview</a>.</p>
            
            

            




        </div></div>
  </body>
</html>
