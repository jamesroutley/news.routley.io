<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.akshaykhot.com/dynamically-create-instance-variables-ruby/">Original</a>
    <h1>How to Dynamically Create Instance Variables in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div id="gh-main">
    <article>
        <header>
        <p><time datetime="2023-07-25">Jul 25, 2023</time>
        </p>

    

        <p>This post shows one way to dynamically initialize multiple instance variables in a Ruby class using metaprogramming. If you need to pass multiple, separate pieces of data to a constructor (and cannot refactor the code for some reason), it&#39;s a pretty good technique to reduce all the repetitive code.</p>
</header>

    <figure>
        <img srcset="/content/images/size/w300/2023/07/code-14.png 300w,
                    /content/images/size/w720/2023/07/code-14.png 720w,
                    /content/images/size/w960/2023/07/code-14.png 960w,
                    /content/images/size/w1200/2023/07/code-14.png 1200w,
                    /content/images/size/w2000/2023/07/code-14.png 2000w" sizes="(max-width: 1200px) 100vw, 1200px" src="https://www.akshaykhot.com/content/images/size/w1200/2023/07/code-14.png" alt="instance_variable_set method in Ruby"/>
    </figure>

<section>
    <blockquote>Disclaimer: The point of the post is not that we should all be creating instance variables dynamically from now on, but just to show one way to do it for those rare cases when you actually do need it.</blockquote><p>Reading the Rails codebase is a very effective way I&#39;ve found to learn Ruby, especially its advanced concepts, including <a href="https://www.akshaykhot.com/metaprogramming-ruby/">metaprogramming</a>. Rails makes an abundant use of metaprogramming, and I always learn something new when reading the Rails source code. </p><p>Late into last night, while browsing the <a href="https://github.com/rails/rails/blob/main/actionview/lib/action_view/base.rb?ref=akshaykhot.com">code for ActionView framework</a> in Rails, I came across an interesting pattern to dynamically initialize multiple instance variables. It uses a little metaprogramming, but nothing scary. Here&#39;s the highly simplified version: </p><pre><code># actionview/lib/action_view/base.rb

module ActionView
  class Base
    def initialize(assigns)
      assign(assigns)
    end

    def assign(assigns)
      assigns.each { |key, value| instance_variable_set(&#34;@#{key}&#34;, value) }
    end
  end
end</code></pre><p>Apparently, Rails loves the <code>instance_variable_set</code> method and uses it <a href="https://github.com/search?q=repo%3Arails%2Frails+instance_variable_set&amp;type=code&amp;ref=akshaykhot.com">a lot</a>. Let&#39;s take a deeper look to understand the problem it&#39;s solving, and the solution. </p><h2 id="problem">Problem</h2><p>Imagine that you have a class constructor with too many arguments. You want to assign each argument to an instance variable of that class.</p><pre><code>class Person
  def initialize(name, age, address, data, ...)
    @name = name
    @age = age
    @address = address
    @data = data
    
    # remaining assignments
  end
end</code></pre><p>You&#39;d like to avoid all the repetitive typing to assign all the instance variables. </p><p>If you were programming in TypeScript, you could use <a href="https://www.typescriptlang.org/docs/handbook/2/classes.html?ref=akshaykhot.com#parameter-properties">parameter properties</a> shorthand to assign multiple properties:</p><pre><code>class Params {
  constructor(
    public readonly x: number,
    protected y: number,
    private z: number
  ) {
    // No body necessary
  }
}
const a = new Params(1, 2, 3);
console.log(a.x);  // 1</code></pre><p>No such shorthand exists in Ruby (and I&#39;m glad that Ruby doesn&#39;t have the feature bloat like TypeScript and C#), so let&#39;s examine how you could use Ruby&#39;s metaprogramming to initialize these instance variables on the fly.</p><div><p>ðŸ’¡</p><p>Before using any advanced techniques, I suggest you try to refactor the code so you don&#39;t need to pass so many parameters. For example, you could <a href="https://refactoring.com/catalog/introduceParameterObject.html?ref=akshaykhot.com">introduce a parameter object</a>, or <a href="https://refactoring.com/catalog/preserveWholeObject.html?ref=akshaykhot.com">preserve the whole object</a>. Resort to metaprogramming only when you can&#39;t do it in a simpler way.</p></div><h2 id="solution">Solution</h2><p>Use the <code>Object#instance_variable_set</code> method provided by Ruby to initialize instance variables. From the <a href="https://docs.ruby-lang.org/en/3.2/Object.html?ref=akshaykhot.com#method-i-instance_variable_set">documentation</a>,</p><blockquote><code>instance_variable_set</code> sets the instance variable named by <em>symbol</em> to the given object. <strong>This may circumvent the encapsulation intended by the author of the class, so it should be used with care.</strong> The variable does not have to exist prior to this call. If the instance variable name is passed as a string, that string is converted to a symbol.</blockquote><p>Let&#39;s add a method that will initialize instance variables using the above method.</p><pre><code>class Person
  def initialize(assigns)
    assign(assigns)
  end

  private
    def assign(attributes)
      attributes.each do |key, value|
        instance_variable_set(&#34;@#{key}&#34;, value)
      end
    end
end

ak = Person.new(name: &#39;Akshay&#39;, age: 31)
puts ak.instance_variable_get(&#34;@name&#34;)  # Akshay</code></pre><p>The <code>assign</code> method takes a Hash of variable names and their values. Then, for each key value pair, it calls the <a href="https://docs.ruby-lang.org/en/3.2/Object.html?ref=akshaykhot.com#method-i-instance_variable_set"><code>instance_variable_set</code></a> method, passing the stringified key (prepended with the <code>@</code> character to indicate an instance variable) and its value.</p><p><strong>Now, just because you can do it, doesn&#39;t mean you should.</strong> As I mentioned in the beginning of the post, the point here is not to dynamically create all your instance variables from now on, but to show one way to do so, for those rare occasions when you do need it. In fact, if you scan the Rails codebase, you&#39;ll find a few excellent situations where you <strong>do </strong>need this approach. I&#39;ll leave this as an exercise for the readers.</p><div><p>ðŸ’¡</p><p>To be honest, I can&#39;t think of a situation where I&#39;ll be using it in my application code, but it&#39;s an interesting pattern, nonetheless. And it doesn&#39;t hurt to know all the capacities of this beautiful programming language.</p></div><p><strong>What do you think?</strong> Do you have a real-world use case where you might need this in a Rails application?</p><p>P.S. If you liked this post, you might enjoy my notes from the excellent book &#34;Metaprogramming Ruby 2&#34;.</p><figure><a href="https://www.akshaykhot.com/metaprogramming-ruby/"><div><p>Metaprogramming in Ruby</p><p>Metaprogramming in Ruby enables you to produce elegant, clean, and beautiful programs as well as unreadable, complex code thatâ€™s not maintainable. This book teaches you the powerful metaprogramming concepts in Ruby, and how to use them judiciously.</p><p><img src="https://www.akshaykhot.com/content/images/size/w256h256/2022/09/Akshay-3.jpeg" alt=""/><span>Akshay Khot</span></p></div><p><img src="https://www.akshaykhot.com/content/images/2022/09/metaprogramming_ruby-4.jpeg" alt=""/></p></a></figure>
</section>

    

    
    </article>
</div></div>
  </body>
</html>
