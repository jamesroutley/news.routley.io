<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jpieper.com/2022/08/05/debugging-bare-metal-stm32-from-the-seventh-level-of-hell/">Original</a>
    <h1>Debugging bare-metal STM32 from the seventh level of hell</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Here’s a not-so-brief story about troubleshooting a problem that was at times vexing, impossible, incredibly challenging, frustrating, and all around just a terrible time with the bare-metal STM32G4 firmware for the <a href="https://mjbots.com/products/moteus-r4-11">moteus brushless motor controller</a>.</p>



<h2>Background</h2>



<p>First, some things for context:</p>



<p>moteus has a variety of testing done on every firmware release.  There are unit tests that run with pieces of the firmware compiled to <a href="https://github.com/mjbots/moteus/tree/main/fw/test">run in a host environment</a>.  There is a hardware-in-the-loop <a href="https://jpieper.com/2020/08/19/initial-dynamometer-assembly/">dynamometer test fixture</a> that is used to <a href="https://github.com/mjbots/moteus/blob/main/utils/firmware_validate.py">run a separate battery of tests</a>.  There is also an <a href="https://jpieper.com/2022/07/25/updated-moteus-test-fixture/">end-of-line test fixture</a> that is used to run tests on every board and some other firmware level performance tests.</p>



<p>Because of all that testing, we’re pretty confident to release new firmware images once all the tests have passed, and try to ship out boards with firmware that is within a week or two of the newest on all boards and devices that go out the door.  That said, there is some effort made to ensure that large orders all have the same firmware on them.  Thus, my saga started when I went to re-program a few dozen boards using the end-of-line test fixture so that they could all match the most recent version.</p>



<h2>The first symptom</h2>



<p>When I went to re-program them, a large portion of the boards failed tests surrounding the quality of the current sense measurements, indicating there was too much noise in the current sense measurements, specifically when driving 0 current.  That could mean that there were soldering problems on the board, or that the test fixture had corroded contacts, or potentially firmware issues.  In response, the test fixture got its contacts cleaned very thoroughly, I verified this was happening across many boards all of which had passed earlier, and there were only 3 changesets that affected the firmware in any way, all of which seemed pretty innocuous.</p>



<p>Once I had given up on the problem being a fluke, I opened up tview on the end-of-line fixture and sure enough, wow, there was a problem:</p>



<figure><img data-attachment-id="4034" data-permalink="https://jpieper.com/2022/08/05/debugging-bare-metal-stm32-from-the-seventh-level-of-hell/2022-08-04-070807_2335x1461_scrot/" data-orig-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png" data-orig-size="2335,1461" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-08-04-070807_2335x1461_scrot" data-image-description="" data-image-caption="" data-medium-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=300" data-large-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=604" src="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=1024" alt="" srcset="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=1024 1024w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=2048 2048w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=150 150w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=300 300w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-070807_2335x1461_scrot.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Note how the values of <code>servo_stats.adc_cur3_raw</code> seem to bounce between what looks like their true value and 2048.  I have seen problems like this before, related to ADC configuration and clock rate (as – <a href="https://community.st.com/s/question/0D50X00009XkWomSAF/stm32l4-adc-inaccuracy-around-vref2-adc-result-gets-stuck-at-2047">have</a> – <a href="https://community.st.com/s/question/0D53W000013MxH2SAK/why-is-does-the-adc-stay-on-2048-12bit">others</a>), but absolutely nothing about the ADC configuration has changed in more than a year, so surely that can’t be it, can it?</p>



<h2>The first diagnostic step</h2>



<p>So, first things first.  Now that I can observe a problem, is it reproducible.  I used git bisect across the relevant firmware versions, and sure enough, one of the changes was positively correlated with the problem: <a href="https://github.com/mjbots/moteus/commit/64f2a82575795d782ff3806ea2036f4cd2f02ef0">64f2a82575795d782ff3806ea2036f4cd2f02ef0</a>  However, that change does absolutely nothing with the ADCs or the current sense pipeline, or the STM32 register configuration at all.  So, I tried to create a more minimal version of that change which would still trigger the problem.  What I got was this:</p>



<pre>diff --git a/fw/bldc_servo_structs.h b/fw/bldc_servo_structs.h
index abbe26e..f06c16c 100644
--- a/fw/bldc_servo_structs.h
+++ b/fw/bldc_servo_structs.h
@@ -509,7 +509,7 @@ struct BldcServoConfig {
   // debug UART at full control rate.
   uint32_t emit_debug = 0;
 
-  uint32_t field1;
+  uint32_t field1 = 0;
 
   BldcServoConfig() {
     pid_dq.kp = 0.005f;</pre>



<p>So, adding the initialization of a member in a random structure (the one that holds PID gains among others), triggered the issue.  If the initialization was only of a uint8_t or uint16_t, no problem, but a uint32_t, float, or uint64_t did it.  </p>



<p>Well, “that’s odd”.</p>



<p>Clearly that change shouldn’t have any impact, so if the problem is at the C++ level, it must be undefined behavior somewhere else, and if it isn’t at the C++ level, it could be anywhere.  So, my next step was to look at the difference in the disassembly to see what that code change wrought that the STM32 would see.</p>



<figure><img data-attachment-id="4037" data-permalink="https://jpieper.com/2022/08/05/debugging-bare-metal-stm32-from-the-seventh-level-of-hell/equals-zero-diff-1/" data-orig-file="https://jpiepercom.files.wordpress.com/2022/08/equals-zero-diff-1.gif" data-orig-size="1600,800" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="equals-zero-diff-1" data-image-description="" data-image-caption="" data-medium-file="https://jpiepercom.files.wordpress.com/2022/08/equals-zero-diff-1.gif?w=300" data-large-file="https://jpiepercom.files.wordpress.com/2022/08/equals-zero-diff-1.gif?w=604" src="https://jpiepercom.files.wordpress.com/2022/08/equals-zero-diff-1.gif?w=1024" alt=""/></figure>



<p>This is from “meld”, with a set of custom filters to remove most spurious changes related to addresses changing.  But yikes, that one extra initialization results in a *lot* of churn in the assembly.  If we look at the structure constructor, the change we expect is there in that we can see that the field is getting newly initialized.</p>



<figure><img data-attachment-id="4039" data-permalink="https://jpieper.com/2022/08/05/debugging-bare-metal-stm32-from-the-seventh-level-of-hell/2022-08-04-074207_3219x416_scrot/" data-orig-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png" data-orig-size="3219,416" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-08-04-074207_3219x416_scrot" data-image-description="" data-image-caption="" data-medium-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=300" data-large-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=604" src="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=1024" alt="" srcset="https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=1024 1024w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=2043 2043w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=150 150w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=300 300w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-04-074207_3219x416_scrot.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>However, with “-O3” optimizations on, gcc-11 makes all kinds of different decisions at various points.  Instructions are re-ordered, different registers are used, entire blocks of code are re-ordered in their memory layout and execution, and extra padding is added or removed.  There are many changes, any of which could be interacting with whatever undefined behavior is in the system.</p>



<h2>Taking a step back</h2>



<p>Since looking at the disassembly wasn’t going to be easy, I decided to take a step back and see if I could observe what was different in the system when it was running between the good and not-good states.  Most likely some peripheral was configured incorrectly, with the ADCs being a prime candidate, but the clock tree could also be a culprit.</p>



<p>When debugging STM32s, I sometimes use the <a href="https://github.com/bnahill/PyCortexMDebug">PyCortexMDebug project</a>, which lets gdb use the vendor provided SVDs to interpret the contents of all registers.  Here, I wanted to print out every register on every peripheral just to see what was different.  PycortexMDebug doesn’t natively give you a way to do that.  However, it can list all the peripherals it knows about, which I wrote to a file and pre-processed to remove the human level annotation.  Then using gdb’s “python-interactive” mode, I could do a:</p>


<div><pre title="">python-interactive
&gt; regs = [x.strip() for x in open(&#39;/tmp/all_regs.txt&#39;).readlines()&#39;]
&gt; for reg in regs:
&gt;   gdb.execute(&#39;svd/x &#39; + reg)
</pre></div>


<p>Which did the trick — at least after copy and pasting the output from the terminal.  I didn’t bother figuring out how to get it written to a file.  So, now, I have two giant files with every peripheral register, one from a firmware that was working, and one from a firmware that was exhibiting the extra noise.  I went through them line by line and found…. nothing.</p>



<p>Some registers were different of course, but the only ones were timer values, and data registers on the ADC and SPI peripherals, and the system control block depending upon if the code happened to be in an interrupt when I stopped to sample it.  No configuration values or anything that would point to a problem.  Sigh.</p>



<h2>More backing up</h2>



<p>OK.  So maybe there is a peripheral register that isn’t in the SVD that would correlate with the problem?  My next step was to use gdb to dump the entire peripheral address space to an srec file in both cases.</p>


<div><pre title="">dump srec memory /tmp/out.srec 0x40000000 0x51000000
</pre></div>


<p>Note, this does take a *long* time, at least 15 minutes with the hardware I was using.</p>



<p>What did I earn for my hard earned wait?  Bupkis, nothing, nada, squat.  After looking through every single byte that was different, the only ones that had changed were the same ones that the svd method above turned up, plus a bit of random noise in the “reserved” section between peripherals that looked like genuine bus noise.  Notably, not any configuration registers on any peripheral at all.</p>



<h2>Even more backing up</h2>



<p>OK.  So if the problem isn’t in a peripheral register, maybe there is some difference in program state that is causing the problem?  Maybe a stack overflow or something?  So, I switched to SRAM dumps.   First, I modified my startup assembly to start out with guard bytes across all of SRAM so that I could verify the stack hadn’t overflowed (not even close).  I also used that to verify that the code which was copied into CCM SRAM on startup hadn’t overflowed or been stomped on (it hadn’t).  Next I did a diff between the working and non-working states.</p>



<p>Here, there were a lot more differences as the firmware has a lot of state that varies from run to run.  With the structure of the moteus firmware, most storage ends up being allocated on the C/C++ stack from a fixed size pool.  This means that most of the variables don’t have a useful entry in the symbol table, even though their address is consistent from run to run.  To identify what each change was, I started the firmware afresh with a breakpoint on _start, then added a hardware watchpoint on the address of interest.</p>


<div><pre title="">b _start
run
watch *0x20004560 # (for example)
continue (as many times as necessary)
</pre></div>


<p>And then looked to see what modified that particular memory location to determine what it was doing.  I methodically went through every difference, about 50 of them.  I found things like the buffer used to hold CAN-FD frames, timers, nonce counters, the values read by the position sensor and current sensor, and many other things that all seemed perfectly reasonable.</p>



<p>Yet another approach doomed to give no useful information.</p>



<h2>Back to an earlier approach</h2>



<p>Whatever the problem was, it appeared to be in state on the STM32 that was not accessible to mere mortals.  Probably a peripheral got into a bad state that wasn’t exposed via its registers or something.  If I couldn’t find the state that was different, could I at least make a “minimal code difference” which was actually minimal?</p>



<p>My C++ minimal difference was pretty small, just the addition of an “=0” to a field initializer.  However, that resulted in significant changes in the output program.  To make things a little bit more controllable, I tried adding some <code>__asm__(&#34;nop&#34;)</code> entries to the constructor in question and sure enough, some counts of NOPs would trigger the problem and others wouldn’t.  However, they still resulted in large differences in the output.</p>



<p>So then I undertook the painstaking step of gradually turning off optimizations in each function that I saw had changed.  In some cases it was as easy as sticking a <code>__attribute__((optimize(&#34;O1&#34;)))</code> on the definition.  However, in many cases gcc/C++ requires the inline definitions be pulled out-of-line to make that annotation.  Both because of that, and just because of bad luck, often these changes would result in my “nop” trick no longer  triggering a failure.  I worked methodically though, trying new functions until I was eventually able to make a minimal assembly diff that failed.  </p>


<div><pre title="">diff --git a/fw/bldc_servo_structs.h b/fw/bldc_servo_structs.h
index 95db9fe..8916d4e 100644
--- a/fw/bldc_servo_structs.h
+++ b/fw/bldc_servo_structs.h
@@ -533,6 +533,11 @@ struct BldcServoConfig {
     pid_position.ilimit = 0.0f;
     pid_position.kd = 0.05f;
     pid_position.sign = -1.0f;
+
+    asm volatile (
+        &#34;nop;&#34;
+        &#34;nop;&#34;
+    );
   }
 
   template &lt;typename Archive&gt;
</pre></div>


<p>And the assembly diff is solely:</p>



<figure><img data-attachment-id="4043" data-permalink="https://jpieper.com/2022/08/05/debugging-bare-metal-stm32-from-the-seventh-level-of-hell/2022-08-05-135659_3193x479_scrot/" data-orig-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png" data-orig-size="3193,479" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="2022-08-05-135659_3193x479_scrot" data-image-description="" data-image-caption="" data-medium-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=300" data-large-file="https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=604" src="https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=1024" alt="" srcset="https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=1024 1024w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=2048 2048w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=150 150w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=300 300w, https://jpiepercom.files.wordpress.com/2022/08/2022-08-05-135659_3193x479_scrot.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Solely the addition of the 2 nops!</p>



<p>WTF!</p>



<p>As before, I’m using the same regexes with meld to exclude spurious changes related to addresses and literals.  The exact set of expressions is below:</p>


<div><pre title="">asm_address      ^.{20}
stm32_pc         08[0-9a-f]{6}
stm32_pc2        (80[012345][0-9a-f]{4})
stm32_addr       \+0x[0-9a-f]+&gt;
stm32_literal    #[0-9]{2,5}
</pre></div>


<h2>Trying to understand this a bit more</h2>



<p>So far we have learned that simply adding two NOPs to one function that is totally unrelated to the problem in question causes the ADC to become noisy in an odd way.  I tried some experimenting to learn more about the failure.</p>



<p>What does adding more NOPs do?  The answer… 1 or 2 NOPs fails, 3 or 4 NOPs works, 5 or 6 fails, etc.</p>



<p>Hmmm….  my current top two theories are that either a) it is the instruction layout or b) the execution timing that results in the difference.  To rule out one or the other, I made up a series of 8 NOPs, and then substituted a jump in for the first NOP that skipped to one of the later NOPs.  That way I could adjust the execution cycle time of the relevant function one by one without changing any layout.  That had no effect.  Which meant it must have to be the physical layout of the code, not the timing.</p>



<h2>The grind</h2>



<p>At this point, I undertook what was perhaps the most arduous debugging task yet.  To figure out which code was unhappy about having its instruction address changed, I bisected adding NOPs.  This wasn’t super straightforward, because as mentioned, gcc’s optimizations generally mean that adding a NOP to a random function results in all kinds of changes all over the place.  My procedure was roughly like this:</p>



<ol><li>Identify where in the address space I wanted to add a NOP.</li><li>Find a nearby function that was written by me, and not a template expansion or library function.</li><li>Switch it to be O1/O0</li><li>See if I can still trigger the problem at any of my former test points by adding NOPs (turning off optimizations on the one function sometimes re-ordered everything)</li><li>If I can’t, then pick a different function and go back to 1</li><li>If I can, then bisect over all my current test points (which may be in a different order than the last bisection) to find the latest address space point where I can add a NOP to trigger the problem</li></ol>



<p>While brutal, I figured this was sure to result in finding the culprit.</p>



<p>And sure enough, after about 15 steps, each taking around 5-10 minutes, it did.  I thought the following two lines were the culprit:</p>


<div><pre title="">    ADC12_COMMON-&gt;CCR =
        (map_adc_prescale(kAdcPrescale) &lt;&lt; ADC_CCR_PRESC_Pos) |
        (1 &lt;&lt; ADC_CCR_DUAL_Pos); // dual mode, regular + injected
    ADC345_COMMON-&gt;CCR =
        (map_adc_prescale(kAdcPrescale) &lt;&lt; ADC_CCR_PRESC_Pos) |
        (1 &lt;&lt; ADC_CCR_DUAL_Pos); // dual mode, regular + injected
</pre></div>


<p>The two lines that configure the ADC prescaler!  But, wait, didn’t we verify that the ADC prescaler as read from the peripheral registers was the same in both instances?  Why yes, we certainly did.</p>



<p>Working:</p>


<div><pre title="">(gdb) svd/x ADC12_COMMON
Registers in ADC12_Common:
	CSR:  0x000A000A  ADC Common status register
	CCR:  0x000C0001  ADC common control register
	CDR:  0x00000000  ADC common regular data register for dual and triple modes
(gdb) svd/x ADC345_COMMON
Registers in ADC345_Common:
	CSR:  0x000A000A  ADC Common status register
	CCR:  0x000C0001  ADC common control register
	CDR:  0x05250000  ADC common regular data register for dual and triple modes
</pre></div>


<p>Not working:</p>


<div><pre title="">(gdb) svd/x ADC12_COMMON
Registers in ADC12_Common:
	CSR:  0x000A000A  ADC Common status register
	CCR:  0x000C0001  ADC common control register
	CDR:  0x00000000  ADC common regular data register for dual and triple modes
(gdb) svd/x ADC345_COMMON
Registers in ADC345_Common:
	CSR:  0x000A000A  ADC Common status register
	CCR:  0x000C0001  ADC common control register
	CDR:  0x05270002  ADC common regular data register for dual and triple modes
</pre></div>


<p>For good measure, I tested using <code>stepi</code> to walk through the initialization in the bad state to see if it was somehow related to wall clock timing, but that didn’t make a difference.</p>



<h2>Narrowing things down</h2>



<p>To avoid the “flavor-of-the-day” the gcc optimizer gives you and make my life easier for experimenting, I rewrote those two lines in inline assembler, just hard-coding the required CCR value:</p>


<div><pre title="">    asm volatile(
        &#34;str %2, [%0];&#34;
        &#34;str %2, [%1];&#34;
        :
        : &#34;r&#34; (&amp;ADC12_COMMON-&gt;CCR),
          &#34;r&#34; (&amp;ADC345_COMMON-&gt;CCR),
          &#34;r&#34; (0x000C0001)
    );
</pre></div>


<p>I added in NOPs before, in between, and after the two stores.  To my surprise, in all 3 places failures could be induced, but only on every 4th NOP.  Which meant my identification of these two lines was incorrect.</p>



<p>Thus, false alarm.  I kept moving down the function, replacing sections with inline assembler and then bisecting with NOPs until I reached the following section:</p>


<div><pre title="">    ADC1-&gt;CR |= ADC_CR_ADEN;
    ADC2-&gt;CR |= ADC_CR_ADEN;
    ADC3-&gt;CR |= ADC_CR_ADEN;
    ADC4-&gt;CR |= ADC_CR_ADEN;
    ADC5-&gt;CR |= ADC_CR_ADEN;
</pre></div>


<p>Here, all 5 ADCs are turned on in rapid succession after previously having all their pre-requisite startup operations and delays performed.  NOPs placed before this could cause the ADCs to get into the bad state, but NOPs immediately after did not.  Placing NOPs between them always seemed to make the following sections work without problem.  Once I had at least 3 NOPs between each, then no amount of change above could cause a failure.</p>



<h2>Finally, a decent hypothesis and solution</h2>



<p>It seems that the ADCs on the STM32G4 do not like to be turned on in rapid succession, and if they do, bad things can happen like having the prescaler flipped to a different value without it showing in the corresponding register.  In this case, the flash accelerator was probably delaying the initialization when the ADEN sets happened such that they crossed a fetch boundary.  Then when two of them ended up in the same pre-fetch block, they would get turned on too quickly together.  Maybe it causes a local brownout or something?  Somewhat recently I upgraded to gcc-11, which probably did a better job of packing these enables into a smaller amount of code space.</p>



<p>I guess that’s an errata for you.</p>



<p>With that understanding, a solution is trivial.  Just initialize the ADCs one by one instead of all at once.  The initialization sequence for the ADC is documented as requiring a wait until the ADRDY flag is set, so the fix is just to wait for that for each ADC in turn before enabling the next one.  For good measure, since initialization isn’t time critical, I switched the whole process to be serial for each ADC, as I expect that is the more tested path with the hardware.</p>



<ul><li><a href="https://github.com/mjbots/moteus/commit/a398d0c4fde08ea5a585bbf0d53da6be422e0915">mjbots/moteus: a398d0c4fde08ea5a585bbf0d53da6be422e0915</a></li></ul>



<p>What is the lesson?  Hardware is hard?  Persistence pays off?  I guess you can decide!</p>



<p>As a bonus, now that I know one of the prime symptoms to look for to troubleshoot bad prescalers (unusual bit flips around 2048), I discovered that I could get a bit more performance around the 0 current point by increasing the moteus prescalers a bit (<a href="https://github.com/mjbots/moteus/commit/75df0139aaf6e76f207dffae17b81b39f3d5d5ce">75df013</a>).</p>
	</div></div>
  </body>
</html>
