<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2023/11/first-handset-with-mte-on-market.html">Original</a>
    <h1>First Handset with MTE on the Market</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-2472210734448723641" itemprop="description articleBody">

 <p><span>By Mark Brand, Google Project Zero</span></p><h2 id="h.y3m9emfhkn17"><span>Introduction</span></h2>
 <p><span>It&#39;s </span><span>finally time</span><span> for me to fulfill a long-standing promise. Since I first heard about ARM&#39;s Memory Tagging Extensions, I&#39;ve said (to far too many people at this point to be able to back out…) that I&#39;d immediately switch to the first available device that supported this feature. It&#39;s been a long wait (since late 2017) but with the release of the new </span><span><a href="https://blog.google/products/pixel/google-pixel-8-pro/">Pixel 8 / Pixel 8 Pro</a></span><span> handsets, there&#39;s finally a production handset that allows you to enable MTE!</span></p>
 
 <p><span>T</span><span>he ability of MTE to detect memory corruption exploitation at the first dangerous access is a significant improvement in diagnostic and potential security effectiveness. The availability of MTE on a production handset for the first time is a big step forward, and I think there&#39;s real potential to use this technology to make 0-day harder.</span></p>
 
 <p><span>I&#39;ve been running my Pixel 8 with MTE enabled since release day, and so far I haven&#39;t found any issues with any of the applications I use on a daily basis</span><span><a href="#h.9x1hlkdzy7n9">1</a></span><span>, or any noticeable performance issues.</span></p>
 
 <p><span>Currently, MTE is only available on the Pixel as a developer option, intended for app developers to test their apps using MTE</span><span>, but we can configure it to default to synchronous mode for </span><span>all</span><span><a href="#h.c72zfxz1h4jv">2</a></span><span> apps and native user mode binaries. This can be done on a stock image, without bootloader unlocking or rooting required - just a couple of debugger commands. We&#39;ll do that now, but first:</span></p><h2 id="h.1wg7xxcfic4o"><span>Disclaimer</span></h2>
 <p><span>This is absolutely not a supported device configuration; </span><span>and it&#39;s highly likely that you&#39;ll encounter issues with at least some applications crashing or failing to run correctly with MTE if you set your device up in this way</span><span>.</span><span> </span></p>
 
 <p><span>This is how I&#39;ve configured my personal Pixel 8, and so far I&#39;ve not experienced any issues, but this was somewhat of a surprise to me, and I&#39;m still waiting to see what the first app that simply won&#39;t work at all will be...</span><span></span><span>Enabling MTE on Pixel 8/Pixel 8 Pro</span></p>
 
 <p><span>Enabling MTE on an Android device requires the bootloader to reserve a portion of the device memory for storing tags. This means that there are two separate places where MTE needs to be enabled - first we need to configure the bootloader to enable it, and then we need to configure the system to use it in applications.<br/></span></p>
 <p><span>First we need follow the </span><span><a href="https://developer.android.com/studio/debug/dev-options#:~:text=Enable%20USB%20debugging%20on%20your%20device,-Before%20you%20can&amp;text=Enable%20USB%20debugging%20in%20the,Advanced%20%3E%20Developer%20Options%20%3E%20USB%20debugging">Android instructions </a></span><span>to</span><span> enable developer mode and USB debugging on the device:</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMUk4xkJBZCV6AiOVlAXpvjqe7Jy8zbE16O3VggdMsppvQyNa4JmkS05c2G6tnAQ2VBEqQDCtJ3MnZgTW3IICWVAdnDZOAW9B66AsuQZPN5wj_diwjLH3n_quGk9u4-nLoORIUXBuOX3KyxclJvUd87vWjBK8fBG79A70dLxa_vK2brlb5YgZaon5BoWU/s1224/Screenshot%202023-11-01%20at%204.54.22%E2%80%AFPM.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjMUk4xkJBZCV6AiOVlAXpvjqe7Jy8zbE16O3VggdMsppvQyNa4JmkS05c2G6tnAQ2VBEqQDCtJ3MnZgTW3IICWVAdnDZOAW9B66AsuQZPN5wj_diwjLH3n_quGk9u4-nLoORIUXBuOX3KyxclJvUd87vWjBK8fBG79A70dLxa_vK2brlb5YgZaon5BoWU/s1200/Screenshot%202023-11-01%20at%204.54.22%E2%80%AFPM.png" title=""/></a></span></p>
 
 <p><span>Now we need to connect our phone to a trusted </span><span>computer</span><span> that has the </span><span><a href="https://developer.android.com/tools/adb">Android debugging tools</a></span><span> installed on it - I&#39;m using my linux workstation:</span></p>
 <div>
 <p><span></span><span>markbrand@markbrand$ adb devices -l</span></p>
 <p><span>List of devices attached</span></p>
 <p><span>XXXXXXXXXXXXXX         device usb:3-3 product:shiba model:Pixel_8 device:shiba transport_id:5</span></p>
 
 <p><span>markbrand@markbrand$ adb shell</span></p>
 <p><span>shiba:/ $ setprop arm64.memtag.bootctl memtag</span></p>
 <p><span>shiba:/ $ setprop persist.arm64.memtag.default sync</span></p>
 <p><span>shiba:/ $ setprop persist.arm64.memtag.app_default sync</span></p>
 <p><span>shiba:/ $ reboot</span></p>
</div>
 <p><span>These commands are doing a couple of things - first, we&#39;re configuring the bootloader to enable MTE at boot. The second command sets the default MTE mode for native executables running on the device, and the third command sets the default MTE mode for apps. An app developer can enable MTE by using the </span><span><a href="https://developer.android.com/ndk/guides/arm-mte#production">manifest</a></span><span>, but this system property sets the default MTE mode for apps, effectively making it </span><span>opt-out</span><span> instead of opt-in.</span></p>
 
 <p><span>While on the topic of apps opting-out, it&#39;s worth noting that </span><span>Chrome</span><span> doesn&#39;t use the system allocator for most allocations, and instead uses PartitionAlloc. There is experimental MTE support under development, which can be enabled with some additional steps</span><span><a href="#h.48b4e8cq1xxw">3</a></span><span>. U</span><span>nfortunately this currently requires setting a command-line flag which involves some security tradeoffs. </span><span>We expect that Chrome will add an easier way to enable MTE support without these problems in the near future.</span></p>
 
 <p><span>I</span><span>f we look at all of the system properties, we can see that there are a few additional properties that are related to memory tagging:</span></p>

 <div>
 <p><span></span><span>shiba:/</span><span> </span><span>$</span><span> </span><span>getprop</span><span> </span><span>|</span><span> </span><span>grep</span><span> </span><span>memtag</span></p>
 <p><span>[arm64.memtag.bootctl]:</span><span> </span><span>[memtag]</span></p>
 <p><span>[persist.arm64.memtag.app.com.android.nfc]:</span><span> </span><span>[off]</span></p>
 <p><span>[persist.arm64.memtag.app.com.android.se]:</span><span> </span><span>[off]</span></p>
 <p><span>[persist.arm64.memtag.app.com.google.android.bluetooth]:</span><span> </span><span>[off]</span></p>
 <p><span>[persist.arm64.memtag.app_default]:</span><span> </span><span>[sync]</span></p>
 <p><span>[persist.arm64.memtag.default]:</span><span> </span><span>[sync]</span></p>
 <p><span>[persist.arm64.memtag.system_server]:</span><span> </span><span>[off]</span></p>
 <p><span>[ro.arm64.memtag.bootctl_supported]:</span><span> </span><span>[1]</span></p>
</div>
 <p><span>There are unfortunately some default exclusions which we can&#39;t overwrite - the protections on system properties mean that we can&#39;t currently enable </span><span>MTE for a few components</span><span> in a normal production build - these exceptions are </span><span>system_server</span><span> and applications related to nfc, the secure element and bluetooth</span><span>.</span></p>
 
 <p><span>We wanted to make sure that these commands work, so we&#39;ll do that now. We&#39;ll first check whether it&#39;s working for native executables:</span></p>
 <div>
 <p><span></span><span>shiba:/ $ cat /proc/self/smaps | grep mt</span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>VmFlags: rd wr mr mw me ac mt </span></p>
 <p><span>765bff1000-765c011000 r--s 00000000 00:12 97                             /dev/__properties__/u:object_r:arm64_memtag_prop:s0</span></p>
</div>
 
 <p><span>We can see that our</span><span> </span><span>cat</span><span> process</span><span> has mappings with the</span><span> </span><span>mt</span><span> </span><span>bit set, so MTE has been enabled for the process.</span></p>
 
 <p><span>Now in order to check that an app without any manifest setting has picked up this, we added a little bit of code to an empty JNI project to trigger a use-after-free bug:</span></p>
 <div>
 <p><span></span><span>extern</span><span> </span><span>&#34;C&#34;</span><span> </span><span>JNIEXPORT</span><span> </span><span>jstring</span><span> </span><span>JNICALL</span></p>
 <p><span>Java_com_example_mtetestapplication_MainActivity_stringFromJNI(</span></p>
 <p><span>        </span><span>JNIEnv*</span><span> </span><span>env,</span></p>
 <p><span>        </span><span>jobject</span><span> </span><span>/*</span><span> </span><span>this</span><span> </span><span>*/)</span><span> </span><span>{</span></p>
 <p><span>    </span><span>char</span><span>*</span><span> </span><span>ptr</span><span> </span><span>=</span><span> </span><span>strdup(</span><span>&#34;test string&#34;</span><span>);</span></p>
 <p><span>  free(ptr);</span></p>
 <p><span>  </span><span>// Use-after-free when ptr is accessed below.</span></p>
 <p><span>    </span><span>return</span><span> </span><span>env-&gt;NewStringUTF(ptr);</span></p>
 <p><span>}</span></p>
</div>
 <p><span>Without MTE, it&#39;s unlikely that the application would crash running this code. I also made sure that the application manifest does not set MTE, so it will inherit the default. When we launch the application we will see whether it crashes, and whether the crash is caused by an MTE check failure!</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBr9j-dr80RvnKDtyymIUa-olnp9ByD4_KTfJObFeKt6zOyw6IOXWI005OT5JmtcWXHFyTjTVsu_Rc4HcdUDRxsTJce3w0ZqL98JrZKNFEgPmVdED-U79ZUhnxhsysMjhCQqpSzSTXnkshRQbHZpno5CvlfP7NanoRWvUTKwcAZSnFg4YZwEpEF5M0y40/s2400/record.webp"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBr9j-dr80RvnKDtyymIUa-olnp9ByD4_KTfJObFeKt6zOyw6IOXWI005OT5JmtcWXHFyTjTVsu_Rc4HcdUDRxsTJce3w0ZqL98JrZKNFEgPmVdED-U79ZUhnxhsysMjhCQqpSzSTXnkshRQbHZpno5CvlfP7NanoRWvUTKwcAZSnFg4YZwEpEF5M0y40/s1200/record.webp" title=""/></a></span></p>
 
 <p><span>Looking at the logcat output we can see that the cause of the crash was a synchronous MTE tag check failure (</span><span>SEGV_MTESERR</span><span>).</span></p>
 <div>
 <p><span></span><span>DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span></p>
 <p><span>DEBUG   : Build fingerprint: &#39;google/shiba/shiba:14/UD1A.230803.041/10808477:user/release-keys&#39;</span></p>
 <p><span>DEBUG   : Revision: &#39;MP1.0&#39;</span></p>
 <p><span>DEBUG   : ABI: &#39;arm64&#39;</span></p>
 <p><span>DEBUG   : Timestamp: 2023-10-24 16:56:32.092532886+0200</span></p>
 <p><span>DEBUG   : Process uptime: 2s</span></p>
 <p><span>DEBUG   : Cmdline: com.example.mtetestapplication</span></p>
 <p><span>DEBUG   : pid: 24147, tid: 24147, name: testapplication  &gt;&gt;&gt; com.example.mtetestapplication &lt;&lt;&lt;</span></p>
 <p><span>DEBUG   : uid: 10292</span></p>
 <p><span>DEBUG   : tagged_addr_ctrl: 000000000007fff3 (PR_TAGGED_ADDR_ENABLE, PR_MTE_TCF_SYNC, mask 0xfffe)</span></p>
 <p><span>DEBUG   : pac_enabled_keys: 000000000000000f (PR_PAC_APIAKEY, PR_PAC_APIBKEY, PR_PAC_APDAKEY, PR_PAC_APDBKEY)</span></p>
 <p><span>DEBUG   : signal 11 (SIGSEGV), code 9 (SEGV_MTESERR), fault addr 0x0b000072afa9f790</span></p>
 <p><span>DEBUG   :     x0  0000000000000001  x1  0000007fe384c2e0  x2  0000000000000075  x3  00000072aae969ac</span></p>
 <p><span>DEBUG   :     x4  0000007fe384c308  x5  0000000000000004  x6  7274732074736574  x7  00676e6972747320</span></p>
 <p><span>DEBUG   :     x8  0000000000000020  x9  00000072ab1867e0  x10 000000000000050c  x11 00000072aaed0af4</span></p>
 <p><span>DEBUG   :     x12 00000072aaed0ca8  x13 31106e3dee7fb177  x14 ffffffffffffffff  x15 00000000ebad6a89</span></p>
 <p><span>DEBUG   :     x16 0000000000000001  x17 000000722ff047b8  x18 00000075740fe000  x19 0000007fe384c2d0</span></p>
 <p><span>DEBUG   :     x20 0000007fe384c308  x21 00000072aae969ac  x22 0000007fe384c2e0  x23 070000741fa897b0</span></p>
 <p><span>DEBUG   :     x24 0b000072afa9f790  x25 00000072aaed0c18  x26 0000000000000001  x27 000000754a5fae40</span></p>
 <p><span>DEBUG   :     x28 0000007573c00000  x29 0000007fe384c260</span></p>
 <p><span>DEBUG   :     lr  00000072ab35e7ac  sp  0000007fe384be30  pc  00000072ab1867ec  pst 0000000080001000</span></p>
 <p><span>DEBUG   : 98 total frames</span></p>
 <p><span>DEBUG   : backtrace:</span></p>
 <p><span>DEBUG   :       #00 pc 00000000003867ec  /apex/com.android.art/lib64/libart.so (art::(anonymous namespace)::ScopedCheck::Check(art::ScopedObjectAccess&amp;, bool, char const*, art::(anonymous namespace)::JniValueType*) (.__uniq.99033978352804627313491551960229047428)+1636) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)</span></p>
 <p><span>DEBUG   :       #01 pc 000000000055e7a8  /apex/com.android.art/lib64/libart.so (art::(anonymous namespace)::CheckJNI::NewStringUTF(_JNIEnv*, char const*) (.__uniq.99033978352804627313491551960229047428.llvm.6178811259984417487)+160) (BuildId: a5fcf27f4a71b07dff05c648ad58e3cd)</span></p>
 <p><span>DEBUG   :       #02 pc 00000000000017dc  /data/app/~~lgGoAt3gB6oojf3IWXi-KQ==/com.example.mtetestapplication-k4Yl4oMx9PEbfuvTEkjqFg==/base.apk!libmtetestapplication.so (offset 0x1000) (_JNIEnv::NewStringUTF(char const*)+36) (BuildId: f60a9970a8a46ff7949a5c8e41d0ece51e47d82c)</span></p>
 <p><span>...</span></p>
 <p><span>DEBUG   : Note: multiple potential causes for this crash were detected, listing them in decreasing order of likelihood.</span></p>
 <p><span>DEBUG   : </span><span>Cause: [MTE]: Use After Free</span><span>, 0 bytes into a 12-byte allocation at 0x72afa9f790</span></p>
 <p><span>DEBUG   : deallocated by thread 24147:</span></p>
 <p><span>DEBUG   :       #00 pc 000000000005e800  /apex/com.android.runtime/lib64/bionic/libc.so (scudo::Allocator&lt;scudo::AndroidConfig, &amp;(scudo_malloc_postinit)&gt;::quarantineOrDeallocateChunk(scudo::Options, void*, scudo::Chunk::UnpackedHeader*, unsigned long)+496) (BuildId: a017f07431ff6692304a0cae225962fb)</span></p>
 <p><span>DEBUG   :       #01 pc 0000000000057ba4  /apex/com.android.runtime/lib64/bionic/libc.so (scudo::Allocator&lt;scudo::AndroidConfig, &amp;(scudo_malloc_postinit)&gt;::deallocate(void*, scudo::Chunk::Origin, unsigned long, unsigned long)+212) (BuildId: a017f07431ff6692304a0cae225962fb)</span></p>
 <p><span>DEBUG   :       #02 pc 000000000000179c  /data/app/~~lgGoAt3gB6oojf3IWXi-KQ==/com.example.mtetestapplication-k4Yl4oMx9PEbfuvTEkjqFg==/base.apk!libmtetestapplication.so (offset 0x1000) (Java_com_example_mtetestapplication_MainActivity_stringFromJNI+40) (BuildId: f60a9970a8a46ff7949a5c8e41d0ece51e47d82c)</span></p>
</div>
 <p><span>If you just want to check that MTE has been enabled in the bootloader, there&#39;s an </span><span><a href="https://play.google.com/store/apps/details?id=com.sanitizers.app.production">application on the Play Store</a></span><span> from Google&#39;s Dynamic Tools team, which you can also use (this app enables MTE in async mode in the manifest, which is why you see below that it&#39;s not running in sync mode on all cores):</span></p>
 
 
 <p><span><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiOtT6oQclPF7hRKziqlNC7M7GD7BjDlBeVgaEyM500foNJXSlgvp4228zplJQr7HdZz85PJpA-8QKXrpo4t8nLt2Nk4AvLO4o0JIzFJFJ1R1EWEeLklM3dzHpXDQAm9WliYKYqPoe-PtBPtt0sRQDoqQOLFbGHEsqcqMBuw4zWH7qNv09XhtLFt9CJgnI/s1212/Screenshot%202023-11-02%20at%209.48.54%E2%80%AFAM.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiOtT6oQclPF7hRKziqlNC7M7GD7BjDlBeVgaEyM500foNJXSlgvp4228zplJQr7HdZz85PJpA-8QKXrpo4t8nLt2Nk4AvLO4o0JIzFJFJ1R1EWEeLklM3dzHpXDQAm9WliYKYqPoe-PtBPtt0sRQDoqQOLFbGHEsqcqMBuw4zWH7qNv09XhtLFt9CJgnI/s1212/Screenshot%202023-11-02%20at%209.48.54%E2%80%AFAM.png" title=""/></a></span></p>
 
 <p><span>At this point, we can go back into the developer settings and disable USB debugging, since we don&#39;t want that enabled for normal day-to-day usage. We do need to leave the developer mode toggle on, since disabling that will turn off MTE again entirely on the next reboot.</span></p>
 <p><span><br/></span><span>Conclusion</span></p>
 
 <p><span>T</span><span>he Pixel 8 with synchronous-MTE enabled is at least subjectively a performance and battery-life upgrade over my previous phone.</span></p>
 
 <p><span>I think this is a huge improvement for the general security of the device - many zero-click attack surfaces involve large amounts of unsafe C/C++ code, whether that&#39;s WebRTC for calling, or one of the many media or image file parsing libraries. MTE is </span><span><a href="https://googleprojectzero.blogspot.com/2023/08/mte-as-implemented-part-2-mitigation.html">not a silver bullet</a></span><span> for memory safety - but the release of the first production device with the ability to run almost all user-mode applications with synchronous-MTE is a huge step forward, and something that&#39;s worth celebrating!</span></p>
 
 
 
 
 
 
 
 <h3 id="h.9x1hlkdzy7n9"><span>1 </span><span>On a team member&#39;s device, a single MTE detection of a use-after-free bug happened last week. This resulted in a crash that wasn&#39;t noticed at the time, but which we later found when looking through the saved crash reports on their device. Because the alloc and free stacktraces of the allocation were recorded, we were able to quickly figure out the bug and report it to the application developers - the bug in this case was caused by user gesture input, and doesn&#39;t really have security impact, but it already illustrates some of the advantages of MTE.</span></h3><h3 id="h.c72zfxz1h4jv"><span>2</span><span> </span><span>Except for se (secure element), bluetooth, nfc, and the system server, due to these system apps explicitly setting their individual system properties to &#39;off&#39; in the Pixel system image.</span></h3><h3 id="h.48b4e8cq1xxw"><span>3 </span><span>Enabling MTE in Chrome requires setting multiple command line flags, which on a non-rooted Android device requires configuring Chrome to load the command line flags from a file in /data/local/tmp. This is potentially unsafe, so we&#39;d not suggest doing this, but if you&#39;d like to experiment on a test device or for fuzzing, the following commands will allow you to </span><span>run Chrome with MTE enabled</span><span>:</span></h3>
 <div>
 <p><span></span><span>markbrand@markbrand:~$ adb shell</span></p>
 <p><span>shiba:/</span><span> </span><span>$ umask 022</span><span> </span><span>$ echo</span><span> </span><span>&#34;_</span><span> </span><span>--enable-features=PartitionAllocMemoryTagging:enabled-processes/all-processes/memtag-mode/sync</span><span> </span><span>--disable-features=PartitionAllocPermissiveMte,KillPartitionAllocMemoryTagging&#34;</span><span> </span><span>&gt;</span><span> </span><span>/data/local/tmp/chrome-command-line</span><span> </span><span>$ ls -la /data/local/tmp/chrome-command-line                                          </span></p>
 <p><span>-rw-r--r-- 1 shell shell 176 2023-10-25 19:14 /data/local/tmp/chrome-command-line</span></p>
</div>
 <h3><span><br/></span><span><b>Having run these commands, we need to configure Chrome to read the command line file; this can be done by opening Chrome, browsing to chrome://flags#enable-command-line-on-non-rooted-devices, and setting the highlighted flag to &#34;Enabled&#34;.</b></span></h3>

</div></div>
  </body>
</html>
