<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://c64os.com/post/howthekeyboardworks">Original</a>
    <h1>How the C64 Keyboard Works</h1>
    
    <div id="readability-page-1" class="page"><div>
							
		<a name="howthekeyboardworks">
			<div><p>October 23, 2017<em>#45 Technical Deep Dive</em></p><hr/>
			</div>
		</a>
		

		<p><a href="https://s3.amazonaws.com/com.c64os.resources/weblog/howthekeyboardworks/mos6526.png"><img src="https://riskmusings.substack.com/resources/placeholder.php?width=200&amp;height=200" alt="Post Archive Icon"/></a></p><p>
	I&#39;m almost ashamed to admit it, but just 1 year ago when I started working on C64 OS, I didn&#39;t
	have the first clue how the C64 Keyboard worked. I knew there was a thing called the keyboard 
	buffer, but I had cloudy thoughts of it being inside the keyboard itself. When I had to actually
	write the keyboard scanning routine for C64 and started looking at the 1982 fullspread double 
	sided C64 schematics, I could see that the keyboard was wired up to the CIAs, but my first 
	assumption was that when a key was pressed an IRQ would be generated. These ideas in retrospect 
	seem embarassingly ignorant of such a basic feature of the Commodore 64.
</p>
<p>
	But how are we supposed to know until we learn, right? I&#39;ve written on lots of technical topics,
	but this post will be a deep explanation of how the C64 reads data in from the keyboard.
</p>

<h4>The CIAs (MOS 6526)</h4>

<p>
	The C64 has two Complex Interface Adapter chips. Better known as the CIAs, officially the MOS 
	6526. You can read <a href="https://en.wikipedia.org/wiki/MOS_Technology_CIA">all about this chip</a>
	on Wikipedia. But I want to explain some of my most interesting discoveries.
</p>
<p>
	MOS Technology, which was acquired by Commodore and rebranded the Commodore Semiconductor Group, 
	made a whole series of chips which I like to think of as the 65xx family. If you look up MOS 
	65xx on Wikipedia it&#39;ll tell you that this is a series of 8-bit microprocessors. And it&#39;s true,
	the 6501, 6502, 6503, 6504, 6505, 6507, 6508 and 6510, (at least) are all microprocessors. But
	the 65xx numbered series includes a whole family of chips that are designed to work together
	on a logicboard, together with some ram, rom, and other glue chips, to implement a complete 
	microcomputer.
</p>
<p>
	The C64 has a 6510 (CPU), 6567 (VIC-II, Video Interface Chip), 6581 (SID, Sound Interface Device), 
	plus two 6526 (CIA, Complex Interface Adapter) chips. Then it has three rom chips (the shortboard
	reduced this to two), KERNAL, BASIC and CHARACTER roms, a bunch of RAM chips totalling to 64K, 
	a handful of simple glue chips, in the 74xx and 74xxx series, a 556, a pair of 4066&#39;s, and most 
	importantly the PLA (Programmable Logic Array). Together, they work beautifully to provide all 
	that the computer is able to do.
</p>

<p><a href="https://s3.amazonaws.com/com.c64os.resources/weblog/howthekeyboardworks/mos6526.png"><img src="https://riskmusings.substack.com/resources/placeholder.php?width=924&amp;height=630" width="924" height="630" alt="pinout of the MOS 6526 CIA chip"/></a></p><p>
	So, what does a 6526 provide? Lots of handy things. It&#39;s got 16 registers for configuration, it&#39;s 
	got a Time-of-Day clock with programmable alarms, it&#39;s got two 16-bit programmable timers, it&#39;s 
	got a serial I/O port, and, most importantly for today&#39;s discussion, it has two 8-bit
	bi-directional ports, which we&#39;ll talk about in a minute.
</p>

<h4>What is a port, anyway?</h4>

<p>
	If you&#39;d asked me what is a <em>port</em>, just a year ago, I&#39;d have said that it&#39;s a connector
	on the back or side of a computer, to which you can connect a peripheral device. That&#39;s half
	right, but it misses a couple of critical points.
</p>
<p>
	A port is a line, a wire, that the CPU can control. If it&#39;s an output port that means instructions
	executed by the CPU can force that wire either to output +5V or GND, a logical 1 or 0 respectively.
	An input port means instructions executed by the CPU can read the voltage level of that line, 
	and if it&#39;s near +5V the CPU sees this as logical 1, or near GND which the CPU reads as logical 0.
	There is virtually always some controlling device that allows the CPU to manage the state of that
	port line. And in the case of the C64 that controlling device is the 6526 CIA chip itself.
</p>
<p>
	The next important thing to understand is that in a digital computer, one line (1 wire) is one 
	bit. The wire can either be high or low, at a time. So when we say that the CIA chip has two 
	8-bit bi-directional ports, this no longer has to sound like gobbledygook. An 8-bit port is a 
	port with 8 parallel, simultaenously settable or readable lines. Bi-directional means that each 
	of those lines can be configured either as inputs or outputs. And in the case of the 6526 each 
	line can be configured for input or output individually. At the same time some of them can be 
	inputs and others outputs. A <em>serial</em> port, by the way, which the 6526 has, may as well be 
	called a 1-bit port.
</p>
<p>
	If the 6526 has two 8-bit ports, and each bit requires a line, there should be 16 lines dedicated
	to those ports. And indeed, when you look at the pinout diagram of the CIA above, reading down
	the left hand side you see PA0 through PA7, followed by PB0 through PB7. PA and PB stand for 
	Port A and Port B, and each has 8 lines numbered 0 through 7. Amazing. That means the computer,
	software instructions running on the CPU, can cause those 16 chip legs to be +5V or GND, or can
	read the +5V or GND status of those legs.
</p>
<p>
	One more step to go, the legs of the chips are connected to traces on the logicboard which run
	directly to a physical connector which is exposed through the chassis of the computer, and boom, 
	it&#39;s called a port. Those physical things we&#39;ve colloquially called ports our whole lives are 
	literal technical ports, wires the CPU can independently manipulate.
</p>

<h4>How does the CPU interact with the port?</h4>

<p>
	The question of course is, how does the CPU actually interact with one of those 8-bit ports?
	The 6526 has to be addressable, and it needs to get data from the CPU. And as we&#39;ll recall it 
	must have one line per bit. The C64 (the 6510 CPU) has a 16-bit address bus and an 8-bit data bus,
	so the CIA must have 16 address legs and 8 data legs, right? Almost.
</p>
<p>
	If we go back to our pinout diagram and read down the right side we see 4 legs labeled 
	A0 through A3, and 8 labeled D0 through D7, in amongst a bunch of other lines we don&#39;t need to 
	worry about at the moment. The Ax legs are <em>address</em> lines and the Dx legs are 
	<em>data</em> lines. There are 8 data lines, that&#39;s good, those are obviously connected directly 
	to the 8 data bus lines from the CPU. But why are there only 4 address lines?
</p>
<p>
	As mentioned above, the 6526 has 16 configuration registers. What that actually means is that 
	there are 16 memory addresses where the CPU can read or write to interact with the CIA. 4 bits
	can address from 0 to 15, and we need one line per bit, so bingo the 16 registers need only 
	4 address lines. But in a real C64 there are two CIAs addressed from $DC00 to $DC0F for CIA 1, 
	and from $DD00 to $DD0F for CIA 2. Somehow, only when the upper 8 bits of the 16-bit address bus 
	are $DC (1101 1100) or $DD (1101 1101) should CIA 1 or 2 be active respectively.
</p>
<p>
	In steps the glue logic. A combination of the PLA chip (Programmable Logic Array), which is a 
	highly custom chip created just for the C64, and a 74239 (an off the shelf 4-bit decoder), are
	used to monitor the upper 8-bits of the address bus and selectively turn on and off a variety
	of chips that are themselves connected only to the lower bits of the address bus. The 6526 is
	enabled or disabled via pin 23, labeled in the diagram above &#34;/CE&#34;, for chip enable. 
</p>
<p>
	The fact that the chip only has 4 address lines plus a chip enable pin, rather than a full 16 
	address lines, means that custom glue logic can be used to map the CIA&#39;s small addressable 
	range somewhere into a much larger address space. And, as is the case in the C64, multiple CIA
	chips can be mapped into different places in the main 16-bit address space.
</p>
<p>
	The net result is that when the CPU sets $DC00 (1101 1100 0000 0000) onto the address bus, the 
	PLA and 74239 together enable CIA 1, and disable every other chip on the bus. The CIA 1 chip, 
	being enabled, sees 0000 on its 4 address lines, and the 8 data lines interact directly with
	whatever the 6526&#39;s register 0 actually does. We&#39;ll get to a description of the 6526&#39;s registers 
	in a moment.
</p>

<h4>What are the CIAs hooked up to?</h4>

<p>
	Now that we know what a port is, that the CIA offers two 8-bit ports, that the C64 has two CIAs,
	and how the C64&#39;s glue logic is setup to allow the CPU to address them, the next question is, 
	what are those CIAs hooked up?
</p>

<p><a href="https://s3.amazonaws.com/com.c64os.resources/weblog/howthekeyboardworks/cias-schematic.png"><img src="https://riskmusings.substack.com/resources/placeholder.php?width=887&amp;height=1315" width="887" height="1315" alt="Part of the C64 schematic, showing how the CIAs are hooked up"/></a></p><p>
	Above is a section of the schematics of the C64 logicboard. I&#39;ve intentionally removed a number
	of extraneous bits around the edges to try to bring focus just on how the CIAs are wired up. In
	this diagram there are two main ICs shown, U1 and U2, both are labelled 6526 CIA. Their addresses
	are written in parentheses (DC00 - DCFF) and (DD00-DDFF)<sup><a href="#fn_p45_1" id="fnid_p45_1">1</a></sup>.
	I added the labels in blue, #1 and #2, as they are usually referred to in documentation.
</p>
<p>
	Along the left side we have four blocks. From top to bottom: Control Port 2, Control Port 1, 
	Keyboard, and User Port. The two control ports are of course the joystick ports we all know
	and love on the right side of our C64. The user port is that wonderful geek port on the back of 
	the computer at the far left. The keyboard <em>port</em> is a block of pins in the middle of the 
	logic board, which the keyboard is connected to. It is as much a port as any other, but one that 
	is only internally accessible as a result of the design of the chassis.
</p>
<p>
	Let&#39;s start with the user port. You can see that pins on CIA 2 labeled PB0 through PB7, as well
	as PA2, run directly to pins on the user port&#39;s edge connector. Nothing could be more straight
	forward than that. When you plug something into the user port, you are literally connecting 
	something directly to the Port B legs of CIA 2. Now we know why static electric discharge is 
	so dangerous for the computer, when you touch that user port connector, you may as well be 
	rubbing your fingers across the CIA&#39;s legs. There are no over voltage or surge protections of
	any kind. But at least the connection is very easy to understand.
</p>
<p>
	Here&#39;s a thought. When nothing is plugged into the user port, the Port B legs of CIA 2 are very 
	evidently not connected to anything at all. It is neither connected to a +5V source, but nor 
	is it connected to GND. We would say that the legs are in the third state of 
	<a href="https://en.wikipedia.org/wiki/Three-state_logic">three-state logic</a>.
	That is, they&#39;re hooked up to effectively infinite resistance. In a sense they are actually 
	connected to ground, but they are connected via a massive bridge of open air, which is highly 
	non-conductive and thus extremely high in resistance. The question is what would the CPU read if 
	it tried to read the values off those legs when they&#39;re hooked to nothing? The answer cannot be 
	known by looking at the schematics alone. However, in the 6526&#39;s documentation, they are said to 
	internally <em>pull up</em>. That&#39;s electronics terminology to mean, when the legs are connected 
	to nothing, the computer will read them as logically high, or 1s rather than 0s. This is 
	important.
</p>

<h4>How is the keyboard hooked up?</h4>

<p>
	Now let&#39;s look at how the keyboard is hooked up. You can see that all 8 bits of both Port A and
	Port B run straight across to the keyboard connector. Port A&#39;s bits are correspondingly labeled
	COL0 through COL7, and Port B&#39;s bits are ROW0 to ROW7. Some of those lines branch off and up to
	the control ports, but we can ignore those for the moment.
</p>
<p>
	The keyboard connector has just 3 additional lines, plus a spacer (KEY) to make sure you orient 
	the cable correctly. These are +5V, GND, and a special line labeled RESTORE, which we&#39;ll get to.
	I took apart a C64 keyboard, shown below, so we can see what its insides look like. It was 
	already dead, so don&#39;t worry I didn&#39;t sacrifice it in the name of science.
</p>

<p><a href="https://s3.amazonaws.com/com.c64os.resources/weblog/howthekeyboardworks/keyboardmatrix-silkscreen.jpg"><img src="https://riskmusings.substack.com/resources/placeholder.php?width=1200&amp;height=900" width="1200" height="900" alt="Physical keyboard matrix"/></a></p><p>
	In the image above, I&#39;ve faux-silk-screened the keycaps onto the circuit board so it&#39;s easy to see
	how the keys line up. Notice that the keyboard connector in the schematics labels the pins 1 
	through 20. On the keyboard&#39;s circuit board you can see the solder points where the wires connect, 
	they aren&#39;t neatly in a row, but they are labeled, 0,1,2,3,4,5,6,7,8 and A,B,C,D,E,F,G,H,I. But
	9 numbers and 9 letters make 18 not 20. One of those 20 is the orientation key, so it&#39;s not 
	connected to anything, and interestingly, as we&#39;ll see, the +5V line is not needed for the 
	keyboard, so it&#39;s not connected to anything.
</p>
<p>
	Looking at the keyboard&#39;s PCB it is pretty clear that it has no electronics intelligence of any
	kind. It is merely a collection of switches. Each key connects two pads, and each pad is 
	connected along a long snaking trace the joins several pads together and eventually leads to one
	of the 18 wires of the keyboard cable.
</p>
<p>
	If we follow the traces, or better yet, use a continuity tester, we discover that the RESTORE key
	joins two pads which are alone on their own traces leading back to the keyboard connector. The
	image above doesn&#39;t show the full PCB, the function keys are missing, but you can see that from 
	the RESTORE key&#39;s two pads the traces lead off the right side on their own. One pad is connected
	to the GND pin, the other to the /RESTORE pin in the schematics. Note the slash before that 
	label, on the schematics it appears as a long bar above the word RESTORE. This means that the 
	restore behavior is triggered by pulling the line low, or hooking it to ground. And indeed, when
	you press the restore key the key switch simply joins the GND line to the /RESTORE line.
</p>
<p>
	Nothing else on the keyboard is connected to the /RESTORE or GND pins, the +5V pin connects to
	nothing, and pin 2 is just an orientation spacer, so that leaves us with 16 lines. The lines
	labeled COL0 through COL7 and ROW0 through ROW7, which connect to Port A and Port B of CIA 1.
	COL and ROW are for columns and rows, because the rest of the keys are arranged into an 8 by 8
	matrix. Leaving out the RESTORE key, with its dedicated lines, if you count up all the other keys
	on the keyboard (and don&#39;t forget the four function keys) you get 65. Ah, but there is one other
	little thing to notice. The Shift Lock key is wired to exactly the same two lines as the Left 
	Shift key. Therefore, the Shift Lock key is just a mechanically latching switch that to the 
	computer is indistinguishable from the ordinary Left Shift key. Exclude this key, and we&#39;re left
	with 64 keys. And 8 times 8 is 64.
</p>
<p>
	Each ROW line snakes around the board connecting to one half of the contact pads of 8 different
	keys. And each COL line snakes around connecting to the other half of the contact pads of 8 keys.
	Such that each key is a switch that connects one ROW line to one COL line. It can be a bit tricky
	to trace these all out visually, but a continuity tester comes in really handy. The result is 
	that the keys are arranged in the following grid:
</p>



<h4>Commodore 64 keyboard matrix layout</h4>

<table>
	<tbody><tr>
		<th> </th>
		<th> </th>
		<td colspan="8">CIA 1, Port A, $DC00, write to select a column.</td>
	</tr>
	<tr>
		<th> </th>
		<th> </th>
		<th>Bit 7</th>
		<th>Bit 6</th>
		<th>Bit 5</th>
		<th>Bit 4</th>
		<th>Bit 3</th>
		<th>Bit 2</th>
		<th>Bit 1</th>
		<th>Bit 0</th>
	</tr>
	<tr>
		<td rowspan="8"><span>CIA 1, Port B, $DC01, read.</span></td>
		<td><b>Bit 7</b></td>
		<td>Run</td>
		<td>/</td>
		<td>,</td>
		<td>N</td>
		<td>V</td>
		<td>X</td>
		<td>Left Shift</td>
		<td>Cursor</td>
	</tr>
	<tr>
		<td><b>Bit 6</b></td>
		<td>Q</td>
		<td>↑</td>
		<td>@</td>
		<td>O</td>
		<td>U</td>
		<td>T</td>
		<td>E</td>
		<td>F5</td>
	</tr>
	<tr>
		<td><b>Bit 5</b></td>
		<td>Commodore</td>
		<td>=</td>
		<td>:</td>
		<td>K</td>
		<td>H</td>
		<td>F</td>
		<td>S</td>
		<td>F3</td>
	</tr>
	<tr>
		<td><b>Bit 4</b></td>
		<td>Space</td>
		<td>Right</td>
		<td>.</td>
		<td>M</td>
		<td>B</td>
		<td>C</td>
		<td>Z</td>
		<td>F1</td>
	</tr>
	<tr>
		<td><b>Bit 3</b></td>
		<td>2</td>
		<td>Clear</td>
		<td>-</td>
		<td>0</td>
		<td>8</td>
		<td>6</td>
		<td>4</td>
		<td>F7</td>
	</tr>
	<tr>
		<td><b>Bit 2</b></td>
		<td>Control</td>
		<td>;</td>
		<td>L</td>
		<td>J</td>
		<td>G</td>
		<td>D</td>
		<td>A</td>
		<td>Cursor</td>
	</tr>
	<tr>
		<td><b>Bit 1</b></td>
		<td>←</td>
		<td>*</td>
		<td>P</td>
		<td>I</td>
		<td>Y</td>
		<td>R</td>
		<td>W</td>
		<td>Return</td>
	</tr>
	<tr>
		<td><b>Bit 0</b></td>
		<td>1</td>
		<td>£</td>
		<td>+</td>
		<td>9</td>
		<td>7</td>
		<td>5</td>
		<td>3</td>
		<td>Insert</td>
	</tr>
</tbody></table>

<!-- 
<p align="JUSTIFY">Notes:</p>

<ol>
<li><p align="JUSTIFY">Rows refer to values for memory address $DC00, columns
  to values for $DC01.</p>
</ol>
 -->

<p>
	<em>Original Source: <a href="http://sta.c64.org/cbm64kbdlay.html">http://sta.c64.org/cbm64kbdlay.html</a>.
	HTML reformatted, re-styled and one minor error corrected.</em>
</p>

<h4>UPDATE: March 3, 2023</h4>
<p>
		I&#39;ve inverted the Rows and Columns from the way sta.c64.org had them. And it makes more
		sense just thinking about it. N, M, K, J, I, O, 9, 0 are physically in a column on the 
		keyboard. They should be laid out in the in the table above as a column, which they now are.
	</p>


<p>
	Below you can see a visualization of the columns listed in the table above, superimposed over
	the actual C64 keyboard. The logical columns as they are wired together to the CIA chip are
	indeed laid out, more or less, in physical columns.
</p>
<p>
	The only thing to be careful of, and these are labeled in the graphic below, is that the 
	column selection bits of CIA 1&#39;s Port A ($DC00) are not in sequential order with the physical
	columns of the keyboard. I don&#39;t know why this is, but bits 1 through 6 are in order moving
	across the keyboard from left to right. However, the outer two columns have been swapped. 
	Column 7 (i.e., bit 7,) is not beside Column 6; It&#39;s over on the left beside Column 1. And
	Column 0 is not beside Column 1; It&#39;s over on the right beside Column 6! It was at first
	suggested to me that this might be because of some sort of matrix layout issue. Upon further
	thinking about it, that cannot be the reason. To swap Column 7 and Column 0 would only require
	swapping those two wires coming from the CIA, this would be a trivial change. Does it date back
	to the PET and its weird keyboard layout? I don&#39;t know.
</p>

<p><a href="https://s3.amazonaws.com/com.c64os.resources/weblog/howthekeyboardworks/keyboard-columns-highlight.jpg"><img src="https://riskmusings.substack.com/resources/placeholder.php?width=1941&amp;height=900" width="1941" height="900" alt="C64 Keyboard with the columns highlighted and their bits labeled."/></a></p></div></div>
  </body>
</html>
