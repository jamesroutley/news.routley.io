<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2025/03/pentium-multiplier-adder-reverse-engineered.html">Original</a>
    <h1>The Pentium contains a complicated circuit to multiply by three</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3533328182698832872" itemprop="description articleBody">
<p>In 1993, Intel released the high-performance Pentium processor, the start of the long-running Pentium line.
I&#39;ve been examining the Pentium&#39;s circuitry in detail and I came across a circuit to multiply by three, a complex circuit with thousands of
transistors. Why does the Pentium have a circuit to multiply specifically by three? Why is it so complicated? In this article, I examine
this multiplier—which I&#39;ll call the ×3 circuit—and explain its purpose and how it is implemented.</p>
<p>It turns out that this multiplier is a small part of the Pentium&#39;s floating-point multiplier circuit. In particular, the Pentium multiplies two
64-bit numbers using base-8 multiplication, which is faster than binary multiplication.<span id="fnref:speed"><a href="#fn:speed">1</a></span> However, multiplying by 3 needs to be handled as a special case.
Moreover, since the rest of the multiplication process can&#39;t start until the multiplication by 3 finishes, this circuit must be very fast.
If you&#39;ve studied digital design, you may have heard of techniques such as carry lookahead, Kogge-Stone addition, and carry-select addition.
I&#39;ll explain how the ×3 circuit combines all these techniques to maximize performance.</p>
<p>The photo below shows the Pentium&#39;s thumbnail-sized silicon die under a microscope.
I&#39;ve labeled the main functional blocks.
In the center is the integer execution unit that performs most instructions. On the left, the code and data caches improve memory performance. The floating point
unit, in the lower right, performs floating point operations.
Almost half of the floating point unit is occupied by the multiplier, which uses an array of adders to rapidly multiply two 64-bit numbers.
The focus of this article is the ×3 circuit, highlighted in yellow near the top of the multiplier.
As you can see, the ×3 circuit takes up a nontrivial amount of the Pentium die, especially considering that its task seems simple.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/pentium-labeled.jpg"><img alt="This die photo of the Pentium shows the location of the multiplier." height="524" src="https://static.righto.com/images/pentium-mult3/pentium-labeled-w500.jpg" title="This die photo of the Pentium shows the location of the multiplier." width="500"/></a></p><p>This die photo of the Pentium shows the location of the multiplier.</p>
<h2>Why does the Pentium use base-8 to multiply numbers?</h2>
<p>Multiplying two numbers in binary is conceptually straightforward.
You can think of binary multiplication as similar to grade-school long multiplication, but with binary numbers instead of decimal numbers.
The example below shows how 5×6 is computed in binary: the three terms are added to produce the result.
Conveniently, each term is either the multiplicand (101 in this case) or 0, shifted appropriately, so computing the terms is easy.</p>
<pre>     101
    ×110
     ―――
     000    <span>i.e. 0×101</span>
    101     <span>i.e. 1×101</span>
  +101      <span>i.e. 1×101</span>
   ―――――
   11110
</pre>

<p>Unfortunately, this straightforward multiplication approach is slow. With the three-bit numbers above, there are three terms to add.
But if you multiply two 64-bit numbers, you have 64 terms to add, requiring a lot of time and/or circuitry.</p>
<p>The Pentium uses a more complicated approach, computing multiplication in base 8.
The idea is to consider the multiplier in groups of three bits, so instead of multiplying by 0 or 1 in each step, you multiply by a number from 0 to 7.
Each term that gets added is still in binary, but the number of terms is reduced by a factor of three.
Thus, instead of adding 64 terms, you add 22 terms, providing a substantial reduction in
the circuitry required.
(I&#39;ll describe the full details of the Pentium multiplier in a future article.<span id="fnref:details"><a href="#fn:details">2</a></span>)</p>
<p>The downside to radix-8 multiplication is that multiplying by a number from 0 to 7 is much more complicated than multiplying by 0 or 1, which is almost trivial.
Fortunately, there are some shortcuts.
Note that multiplying by 2 is the same as shifting the number to the left by 1 bit position, which is very easy in hardware—you wire each bit one position to the left.
Similarly, to multiply by 4, shift the multiplicand two bit positions to the left.</p>
<p>Multiplying by 7 seems inconvenient, but there is a trick, known as Booth&#39;s multiplication algorithm.
Instead of multiplying by 7, you add 8 times the number and subtract the number, ending up with 7 times the number.
You might think this requires two steps, but the trick is to multiply by one more in the digit to the left, so you get the factor of 8 without an additional step.
(A base-10 analogy is that if you want to multiply by 19, you can multiply by 20 and subtract the multiplicand.)
Thus, you can get the ×7 by subtracting.
Similarly, for a ×6 term, you can subtract a ×2 multiple and add ×8 in the next digit.
Thus, the only difficult multiple is ×3.
(What about ×5? If you can compute ×3, you can subtract that from ×8 to get ×5.)</p>
<p>To summarize, the Pentium&#39;s radix-8 Booth&#39;s algorithm is a fast way to multiply, but it requires a special circuit to produce the ×3 multiple
of the multiplicand.</p>
<h2>Implementing a fast ×3 circuit with carry lookahead</h2>
<p>Multiplying a number by three is straightforward in binary: add the number to itself, shifted to the left one position.
(As mentioned above, shifting to the left is the same as multiplying by two and is easy in hardware.)
Unfortunately, using a simple adder is too slow.</p>
<p>The problem with addition is that carries make addition slow.
Consider calculating 99999+1 by hand.
You&#39;ll start with 9+1=10, then carry the one, generating another carry, which generates another carry, and so forth, until you go through all the digits.
Computer addition has the same problem:
If you&#39;re adding two numbers, the low-order bits can generate a carry that then propagates through all the bits.
An adder that works this way—known as a ripple carry adder—will be slow because the carry has to ripple through
all the bits.
As a result, CPUs use special circuits to make addition faster.</p>
<p>One solution is the carry-lookahead adder. In this adder, all the carry bits are computed in parallel, before computing
the sums. Then, the sum bits can be computed in parallel, using the carry bits.
As a result, the addition can be completed quickly, without waiting for the carries to ripple through
the entire sum.</p>
<p>It may seem impossible to compute the carries without computing the sum first, but there&#39;s a way to do it.
For each bit position, you determine signals called &#34;carry generate&#34; and &#34;carry propagate&#34;.
These signals can then be used to determine all the carries in parallel.
The <em>generate</em> signal indicates that the position generates a carry. For instance, if you add binary
<code>1xx</code> and <code>1xx</code> (where <code>x</code> is an arbitrary bit), a carry will be generated from the top bit,
regardless of the unspecified bits.
On the other hand, adding <code>0xx</code> and <code>0xx</code> will never generate a carry.
Thus, the <em>generate</em> signal is produced for the first case but not the second.</p>
<p>But what about <code>1xx</code> plus <code>0xx</code>? We might get a carry, for instance, <code>111+001</code>, but we might not,
for instance, <code>101+001</code>. In this &#34;maybe&#34; case, we set the <em>carry propagate</em> signal, indicating that a carry into the
position will get propagated out of the position. For example, if there is a carry out of
the middle position, <code>1xx+0xx</code> will have a carry from the top bit. But if there is no carry out of the middle position, then
there will not be a carry from the top bit. In other words, the <em>propagate</em> signal indicates that a carry into the top bit will be propagated out of the top
bit.</p>
<p>To summarize, adding <code>1+1</code> will generate a carry. Adding <code>0+1</code> or <code>1+0</code> will propagate a
carry.
Thus, the <em>generate</em> signal is formed at each position by <em>G<sub>n</sub> = A<sub>n</sub>·B<sub>n</sub></em>, where <em>A</em> and <em>B</em> are the inputs.
The <em>propagate</em> signal is <em>P<sub>n</sub> = A<sub>n</sub>+B<sub>n</sub></em>,
the logical-OR of the inputs.<span id="fnref:propagate"><a href="#fn:propagate">3</a></span></p>
<p>Now that the <em>propagate</em> and <em>generate</em> signals are defined, some moderately complex logic<span id="fnref:carry"><a href="#fn:carry">4</a></span> can compute the carry <em>C<sub>n</sub></em> into
each bit position.
The important thing is that all the carry bits can be computed in parallel, without waiting for the carry to ripple through each bit position.
Once each carry is computed, the sum bits can be computed in parallel: <em>S<sub>n</sub> = A<sub>n</sub> ⊕ B<sub>n</sub> ⊕ C<sub>n</sub></em>. In other words, the two input bits and the computed carry are combined with exclusive-or.
Thus, the entire sum can be computed in parallel by using carry lookahead.
However, there are complications.</p>
<h2>Implementing carry lookahead with a parallel prefix adder</h2>
<p>The carry bits can be generated directly from the <em>G</em> and <em>P</em> signals.
However, the straightforward approach requires too much hardware as the number of bits increases.
Moreover, this approach needs gates with many inputs, which are slow for electrical reasons.
For these reasons, the Pentium uses two techniques to keep the hardware requirements for carry lookahead tractable.
First, it uses a &#34;parallel prefix adder&#34; algorithm for carry lookahead across 8-bit chunks.<span id="fnref:parallel-prefix"><a href="#fn:parallel-prefix">7</a></span>
Second, it uses a two-level hierarchical approach for carry lookahead: the upper carry-lookahead circuit handles eight 8-bit chunks, using
the same 8-bit algorithm.<span id="fnref:bytes"><a href="#fn:bytes">5</a></span></p>
<p>The photo below shows the complete ×3 circuit;
you can see that the circuitry is divided into blocks of 8 bits.
(Although I&#39;m calling this a 64-bit circuit, it really produces a 69-bit output: there are 5 &#34;extra&#34; bits on the left to avoid overflow and to provide additional bits for rounding.)</p>
<p><a href="https://static.righto.com/images/pentium-mult3/wide-view.jpg"><img alt="The full ×3 adder circuit under a microscope." height="65" src="https://static.righto.com/images/pentium-mult3/wide-view-w800.jpg" title="The full ×3 adder circuit under a microscope." width="800"/></a></p><p>The full ×3 adder circuit under a microscope.</p>
<p>The idea of the parallel-prefix adder is to
produce the <em>propagate</em> and <em>generate</em> signals across ranges of bits, not just single bits as before.
For instance, the <em>propagate</em> signal <em>P<sub>32</sub></em> indicates that a carry in to bit 2 would be propagated out of bit 3,
(This would happen with <code>10xx+01xx</code>, for example.)
And <em>G<sub>30</sub></em> indicates that bits 3 to 0 generate a carry out of bit 3.
(This would happen with <code>1011+0111</code>, for example.)</p>
<p>Using some mathematical tricks,<span id="fnref:pg"><a href="#fn:pg">6</a></span> you can take the <em>P</em> and <em>G</em> values for two smaller ranges and merge them into
the <em>P</em> and <em>G</em> values for the combined range.
For instance, you can start with the <em>P</em> and <em>G</em> values for bits 0 and 1, and produce <em>P<sub>10</sub></em> and <em>G<sub>10</sub></em>, the <em>propagate</em> and <em>generate</em>
signals describing two bits.
These could be merged with <em>P<sub>32</sub></em> and <em>G<sub>32</sub></em> to produce <em>P<sub>30</sub></em> and <em>G<sub>30</sub></em>,
indicating if a carry is propagated across bits 3-0 or generated by bits 3-0.
Note that <em>G<sub>n0</sub></em> tells us if a carry is generated into bit <em>n+1</em> from all the lower bits, which is the <em>C<sub>n+1</sub></em> carry value that we
need to compute the final sum.
This merging process is more efficient than the &#34;brute force&#34; implementation of the carry-lookahead logic since
logic subexpressions can be reused.</p>
<p>There are many different ways that you can combine the <em>P</em> and <em>G</em> terms to generate the necessary terms.<span id="fnref:brent-kung"><a href="#fn:brent-kung">8</a></span>
The Pentium uses an approach called
<a href="https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder">Kogge-Stone</a>
that attempts to minimize the total delay while keeping the amount of circuitry reasonable.
The diagram below is the standard diagram that illustrates how a
Kogge-Stone adder works.
It&#39;s rather abstract, but I&#39;ll try to explain it.
The diagram shows how the <em>P</em> and <em>G</em> signals are merged to produce each output at the bottom. 
Each square box at the top generates the <em>P</em> and <em>G</em> signals for that bit.
Each line corresponds to both the <em>P</em> and the <em>G</em> signal.
Each diamond combines two ranges of <em>P</em> and <em>G</em> signals to generate new <em>P</em> and <em>G</em> signals for the combined
range.
Thus, the signals cover wider ranges of bits as they progress downward, ending with the <em>G<sub>n0</sub></em> outputs that indicate carries.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/kogge-stone.jpg"><img alt="A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons." height="437" src="https://static.righto.com/images/pentium-mult3/kogge-stone-w500.jpg" title="A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons." width="500"/></a></p><p>A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, <a href="https://commons.wikimedia.org/wiki/File:Kogge-stone-8-bit.png">Wikimedia Commons</a>.</p>
<p>I&#39;ve labeled a few of the intermediate signals so you can get an idea of how it works. Circuit &#34;A&#34; combines
<em>P<sub>7</sub></em> and <em>G<sub>7</sub></em> with <em>P<sub>6</sub></em> and <em>G<sub>6</sub></em> to produce the signals describing two bits: <em>P<sub>76</sub></em> and
<em>G<sub>76</sub></em>.
Similarly, circuit &#34;B&#34; combines
<em>P<sub>76</sub></em> and <em>G<sub>76</sub></em> with <em>P<sub>54</sub></em> and <em>G<sub>54</sub></em> to produce the signals describing four bits: <em>P<sub>74</sub></em> and
<em>G<sub>74</sub></em>.
Finally, circuit &#34;C&#34; produces the final outputs for bit 7: <em>P<sub>70</sub></em> and <em>G<sub>70</sub></em>.
Note that most of the intermediate results are used twice, reducing the amount of circuitry.
Moreover, there are at most three levels of combination circuitry, reducing the delay compared to a deeper network.</p>
<p>The key point is the <em>P</em> and <em>G</em> values are computed in parallel so the carry bits can all be computed in parallel,
without waiting for the carry to ripple through all the bits.
(If this explanation doesn&#39;t make sense, see my discussion of the Kogge-Stone adder
in the <a href="https://www.righto.com/2025/01/pentium-carry-lookahead-reverse-engineered.html">Pentium&#39;s division circuit</a> for a different—but maybe still confusing—explanation.)</p>
<h2>Recursive Kogge-Stone lookahead</h2>
<p>The Kogge-Stone approach can be extended to 64 bits, but the amount of circuitry and wiring becomes overwhelming.
Instead, the Pentium uses a recursive, hierarchical approach with two levels of Kogge-Stone lookahead.
The lower layer uses eight Kogge-Stone adders as described above, supporting 64 bits in total.</p>
<p>The upper layer uses a single eight-bit Kogge-Stone lookahead circuit, treating each of the lower chunks as a single bit.
That is, a lower chunk has a propagate signal <em>P</em> indicating that a carry into the chunk will be propagated out, as well as a generate signal <em>G</em>
indicating that the chunk generates a carry.
The upper Kogge-Stone circuit combines these chunked signals to determine if carries will be generated or propagated by groups of chunks.<span id="fnref:recursive"><a href="#fn:recursive">9</a></span></p>
<p>To summarize, each of the eight lower lookahead circuits computes the carries within an 8-bit chunk.
The upper lookahead circuit computes the carries into and out of each 8-bit chunk.
In combination, the circuits rapidly provide all the carries needed to compute the 64-bit sum.</p>
<h2>The carry-select adder</h2>
<p>Suppose you&#39;re on a game show: &#34;What is 553 + 246 + <em>c</em>? In 10 seconds, I&#39;ll tell you if <em>c</em> is 0 or 1 and whoever gives the answer first wins $1000.&#34;
Obviously, you shouldn&#39;t just sit around until you get <em>c</em>. You should do the two sums now, so you can hit the buzzer as soon as <em>c</em> is announced.
This is the concept behind the carry-select adder: perform two additions—with a carry-in and without--and then supply the correct answer as soon as the
carry is available.
The carry-select adder requires additional hardware—two adders along with a multiplexer to select the result—but it overlaps the time to compute
the sum with the time to compute the carry.
In effect, the addition and the carry lookahead operations are performed in parallel, with the multiplexer combining the results from each.</p>
<p>The Pentium uses a carry-select adder for each 8-bit chunk in the ×3 circuit. The carry from the second-level carry-lookahead selects which sum should be produced for the chunk.
Thus, the time to compute the carry is overlapped with the time to compute the sum.</p>
<h2>Putting the adder pieces together</h2>
<p>The image below zooms in on an 8-bit chunk of the ×3 multiplier, implementing an 8-bit adder.
Eight input lines are at the top (along with some unrelated wires). Note that each
input line splits with a signal going to the adder on the left and a signal going to the right.
This is what causes the adder to multiply by 3: it adds the input and the input shifted one bit to the left, i.e. multiplied by two.
The top part of the adder has eight circuits to produce the <em>propagate</em> and <em>generate</em> signals.
These signals go into the 8-bit Kogge-Stone lookahead circuit. Although most of the adder consists of a circuit block repeated eight times, the
Kogge-Stone circuitry appears chaotic. 
This is because each bit of the Kogge-Stone circuit is different—higher bits are more complicated to compute than lower bits.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/block-poly-labeled.jpg"><img alt="One 8-bit block of the ×3 circuit." height="323" src="https://static.righto.com/images/pentium-mult3/block-poly-labeled-w500.jpg" title="One 8-bit block of the ×3 circuit." width="500"/></a></p><p>One 8-bit block of the ×3 circuit.</p>
<p>The lower half of the circuit block contains an 8-bit carry-select adder. This circuit produces two sums, with multiplexers selecting the correct sum
based on the carry into the block.
Note that the carry-select adder blocks are narrower than the other circuitry.<span id="fnref:cell"><a href="#fn:cell">10</a></span>
This makes room for a Kogge-Stone block on the left. The second level Kogge-Stone circuitry is split up; the 8-bit carry-lookahead circuitry has one bit
implemented in each block of the adder, and produces the carry-in signal for that adder block.
In other words, the image above includes 1/8 of the second-level Kogge-Stone circuit.
Finally, eight driver circuits amplify the output bits before they are sent to the rest of the floating-point multiplier.</p>
<p>The block diagram below shows the pieces are combined to form the ×3 multiplier.
The multiplier has eight 8-bit adder blocks (green boxes, corresponding to the image above).
Each block computes eight bits of the total sum.
Each block provides
<em>P<sub>70</sub></em> and <em>G<sub>70</sub></em> signals to the second-level lookahead, which determines if each block receives a carry in.
The key point to this architecture is that everything is computed in parallel, making the addition fast.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/overall-diagram.jpg"><img alt="A block diagram of the multiplier." height="312" src="https://static.righto.com/images/pentium-mult3/overall-diagram-w600.jpg" title="A block diagram of the multiplier." width="600"/></a></p><p>A block diagram of the multiplier.</p>
<p>In the diagram above, the first 8-bit block is expanded to show its contents. The 8-bit lookahead circuit generates the <em>P</em> and <em>G</em> signals that determine the
internal carry signals.
The carry-select adder contains two 8-bit adders that use the carry lookahead values.
As described earlier, one adder assumes that the block&#39;s carry-in is 1 and the second assumes the carry-in is 0. When the real carry in value is
provided by the second-level lookahead circuit, the multiplexer selects the correct sum.</p>
<p>The photo below shows how the complete multiplier is constructed from 8-bit blocks.
The multiplier produces a 69-bit output; there are 5 &#34;extra&#34; bits on the left.
Note that the second-level Kogge-Stone blocks are larger on the right than the left since the lookahead circuitry is more complex for higher-order bits.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/wide-view.jpg"><img alt="The full adder circuit. This is the same image as before, but hopefully it makes more sense at this point." height="65" src="https://static.righto.com/images/pentium-mult3/wide-view-w800.jpg" title="The full adder circuit. This is the same image as before, but hopefully it makes more sense at this point." width="800"/></a></p><p>The full adder circuit. This is the same image as before, but hopefully it makes more sense at this point.</p>
<p>Going back to the full ×3 circuit above, you can see that the 
8 bits on the right have significantly simpler circuitry.
Because there is no carry-in to this block, the carry-select circuitry can be omitted.
The block&#39;s internal carries, generated by the Kogge-Stone lookahead circuitry, are added using exclusive-NOR gates.
The diagram below shows the implementation of an XNOR gate, using inverters and a multiplexer.</p>
<h2>The XNOR circuit</h2>
<p>I&#39;ll now describe one of the multiplier&#39;s circuits at the transistor level, in particular an XNOR gate.
It&#39;s interesting to look at XNOR because XNOR (like XOR) is a tricky gate to implement and different processors use very different approaches. 
For instance, the Intel 386 implements XOR from AND-NOR gates (<a href="https://www.righto.com/2023/12/386-xor-circuits.html">details</a>) while the
Z-80 uses pass transistors (<a href="https://www.righto.com/2013/09/understanding-z-80-processor-one-gate.html">details</a>).
The Pentium, on the other hand, uses a multiplexer.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/xnor-diagram.jpg"><img alt="An exclusive-NOR gate with the components labeled. This is a focus-stacked image." height="271" src="https://static.righto.com/images/pentium-mult3/xnor-diagram-w500.jpg" title="An exclusive-NOR gate with the components labeled. This is a focus-stacked image." width="500"/></a></p><p>An exclusive-NOR gate with the components labeled. This is a focus-stacked image.</p>
<p>The diagram above shows one of the XNOR gates in the adder&#39;s low bits.<span id="fnref:low-bits"><a href="#fn:low-bits">11</a></span>
The gate is constructed from four inverters and a pass-transistor multiplexer.
Input B selects one of the multiplexer&#39;s two inputs: input A or input A inverted. The result is the XNOR function.
(Inverter 1 buffers the input, inverter 5 buffers the output, and inverter 4 provides the complemented B signal to drive the multiplexer.)</p>
<p>For the photo, I removed the top two metal layers from the chip, leaving the bottom metal layer, called M1. 
The doped silicon regions are barely visible beneath the metal.
When a polysilicon line crosses doped silicon, it forms the gate of a transistor.
This CMOS circuit has NMOS transistors at the top and PMOS transistors at the bottom.
Each inverter consists of two transistors, while the multiplexer consists of four transistors.</p>
<h2>The BiCMOS output drivers</h2>
<p>The outputs from the ×3 circuit require high current.
In particular, each signal from the ×3 circuit can drive up to 22 terms in the floating-point multiplier.
Moreover, the destination circuits
can be a significant distance from the ×3 circuit due to the size of the multiplier.
Since the ×3 signals are connected to many transistor gates through long wires, the capacitance is high, requiring high current to change the
signals quickly.</p>
<p>The Pentium is constructed with a somewhat unusual process called BiCMOS, which combines bipolar transistors and CMOS on the same chip.
The Pentium extensively uses BiCMOS circuits since they reduced signal delays by up to 35%.
Intel also used BiCMOS for the Pentium Pro, Pentium II, Pentium III, and Xeon processors.
However, as chip voltages dropped, the benefit from bipolar transistors dropped too and BiCMOS was eventually abandoned.</p>
<p>The schematic below shows a simplified BiCMOS driver that inverts its input.
A 0 input turns on the upper inverter, providing current into the bipolar (NPN) transistor&#39;s base.
This turns on the transistor, causing it to pull the output high strongly and rapidly.
A 1 input, on the other hand, will stop the current flow through the NPN transistor&#39;s base, turning it off.
At the same time, the lower inverter will pull the output low. (The NPN transistor can only pull the output high.)</p>
<p>Note the asymmetrical construction of the inverters. Since the upper inverter must provide a large current into the NPN transistor&#39;s base, it is designed to produce a strong (high-current)
positive output and a weak low output.
The lower inverter, on the other hand, is responsible for pulling the output low. Thus, it is constructed to produce a strong low output, while the
high output can be weak.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/bicmos-driver.jpg"><img alt="The basic circuit for a BiCMOS driver." height="150" src="https://static.righto.com/images/pentium-mult3/bicmos-driver-w200.jpg" title="The basic circuit for a BiCMOS driver." width="200"/></a></p><p>The basic circuit for a BiCMOS driver.</p>
<p>The driver of the ×3 circuit goes one step further: it uses a BiCMOS driver to drive a second BiCMOS driver.
The motivation is that the high-current inverters have fairly large transistor gates, so they need to be driven with high current (but not as much as they produce, so there isn&#39;t an infinite regress).<span id="fnref:logical-effort"><a href="#fn:logical-effort">12</a></span></p>
<p>The schematic below shows the BiCMOS driver circuit that the ×3 multiplier uses.
Note the large, box-like appearance of the NPN transistors, very different from the regular MOS transistors.
Each box contains two NPN transistors sharing collectors: a larger transistor on the left and a smaller one on the right.
You might expect these transistors to work together, but the contiguous transistors are part of two
separate circuits.
Instead, the small NPN transistor to the left and the large NPN transistor to the right are part of the same circuit.</p>
<p><a href="https://static.righto.com/images/pentium-mult3/driver-diagram.jpg"><img alt="One of the output driver circuits, showing the polysilicon and silicon." height="292" src="https://static.righto.com/images/pentium-mult3/driver-diagram-w800.jpg" title="One of the output driver circuits, showing the polysilicon and silicon." width="800"/></a></p><p>One of the output driver circuits, showing the polysilicon and silicon.</p>
<p>The inverters are constructed as standard CMOS circuits with PMOS transistors to pull the output high and NMOS transistors to pull the output low.
The inverters are carefully structured to provide asymmetrical current, making them more interesting than typical inverters.
Two pullup transistors have a long gate, making these transistors unusually weak.
Other parts of the inverters have multiple transistors in parallel, providing more current.
Moreover, the inverters have unusual layouts, with the NMOS and PMOS transistors widely separated to make the layout more efficient.
For more on BiCMOS in the Pentium, see my article on <a href="https://www.righto.com/2025/01/pentium-reverse-engineering-bicmos.html">interesting BiCMOS circuits in the Pentium</a>.</p>
<h2>Conclusions</h2>
<p>Hardware support for computer multiplication has a long history going back to the 1950s.<span id="fnref:history"><a href="#fn:history">13</a></span>
Early microprocessors, though, had very limited capabilities, so microprocessors such as the 6502 didn&#39;t have hardware support for multiplication;
users had to implement multiplication in software through shifts and adds.
As hardware advanced, processors provided multiplication instructions but they were still slow.
For example, the Intel 8086 processor (1978) implemented multiplication in microcode, performing a slow shift-and-add loop internally.
Processors became exponentially more powerful over time, as described by Moore&#39;s Law, allowing later processors to include dedicated multiplication hardware.
The 386 processor (1985) included a <a href="https://bitsavers.trailing-edge.com/components/intel/80386/231746-001_Introduction_to_the_80386_Apr86.pdf#page=9">multiply unit</a>, but it was still slow, taking up to 41 clock cycles for a multiplication instruction.</p>
<p>By the time of the Pentium (1993), microprocessors contained millions of transistors, opening up new possibilities for design.
With a seemingly unlimited number of transistors, chip architects could look at complicated new approaches to squeeze more performance out of a system.
This ×3 multiplier contains roughly 9000 transistors, a bit more than an entire Z80 microprocessor (1976).
Keep in mind that the ×3 multiplier is a small part of the floating-point multiplier, which is part of the floating-point unit in the
Pentium.
Thus, this small piece of a feature is more complicated than an entire microprocessor from 17 years earlier, illustrating
the incredible growth in processor complexity.</p>
<p>I plan to write more about the implementation of the Pentium, so
follow me on Bluesky (<a href="https://bsky.app/profile/righto.com">@righto.com</a>) or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates. (I&#39;m no longer on Twitter.)
The <a href="https://www.righto.com/2024/08/pentium-navajo-fairchild-shiprock.html">Pentium Navajo rug</a> inspired me to examine the Pentium in more detail.</p>
<h2>Footnotes and references</h2>


</div></div>
  </body>
</html>
