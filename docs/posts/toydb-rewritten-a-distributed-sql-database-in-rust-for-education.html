<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/erikgrinaker/toydb">Original</a>
    <h1>ToyDB rewritten: a distributed SQL database in Rust, for education</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Distributed SQL database in Rust, built from scratch as an educational project. Main features:</p>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://github.com/erikgrinaker/toydb/blob/main/src/raft/mod.rs">Raft distributed consensus</a> for linearizable state machine replication.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/erikgrinaker/toydb/blob/main/src/storage/mvcc.rs">ACID transactions</a> with MVCC-based snapshot isolation.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/erikgrinaker/toydb/blob/main/src/storage/engine.rs">Pluggable storage engine</a> with <a href="https://github.com/erikgrinaker/toydb/blob/main/src/storage/bitcask.rs">BitCask</a> and <a href="https://github.com/erikgrinaker/toydb/blob/main/src/storage/memory.rs">in-memory</a> backends.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/erikgrinaker/toydb/blob/main/src/sql/execution/executor.rs">Iterator-based query engine</a> with <a href="https://github.com/erikgrinaker/toydb/blob/main/src/sql/planner/optimizer.rs">heuristic optimization</a> and time-travel
support.</p>
</li>
<li>
<p dir="auto"><a href="https://github.com/erikgrinaker/toydb/blob/main/src/sql/parser/parser.rs">SQL interface</a> including joins, aggregates, and transactions.</p>
</li>
</ul>
<p dir="auto">I originally wrote toyDB in 2020 to learn more about database internals. Since then, I&#39;ve spent
several years building real distributed SQL databases at
<a href="https://github.com/cockroachdb/cockroach">CockroachDB</a> and
<a href="https://github.com/neondatabase/neon">Neon</a>. Based on this experience, I&#39;ve rewritten toyDB as a
simple illustration of the architecture and concepts behind distributed SQL databases.</p>
<p dir="auto">toyDB is intended to be simple and understandable, and also functional and correct. Other aspects
like performance, scalability, and availability are non-goals -- these are major sources of
complexity in production-grade databases, and obscure the basic underlying concepts. Shortcuts have
been taken where possible.</p>

<ul dir="auto">
<li>
<p dir="auto"><a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/architecture/index.md">Architecture guide</a>: a guided tour of toyDB&#39;s code and architecture.</p>
</li>
<li>
<p dir="auto"><a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/examples.md">SQL examples</a>: walkthrough of toyDB&#39;s SQL features.</p>
</li>
<li>
<p dir="auto"><a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/sql.md">SQL reference</a>: reference documentation for toyDB&#39;s SQL dialect.</p>
</li>
<li>
<p dir="auto"><a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/references.md">References</a>: research materials used while building toyDB.</p>
</li>
</ul>

<p dir="auto">With a <a href="https://www.rust-lang.org/tools/install" rel="nofollow">Rust compiler</a> installed, a local five-node
cluster can be built and started as:</p>
<div data-snippet-clipboard-copy-content="$ ./cluster/run.sh
Starting 5 nodes on ports 9601-9605 with data under cluster/*/data/.
To connect to node 1, run: cargo run --release --bin toysql

toydb4 21:03:55 [INFO] Listening on [::1]:9604 (SQL) and [::1]:9704 (Raft)
toydb1 21:03:55 [INFO] Listening on [::1]:9601 (SQL) and [::1]:9701 (Raft)
toydb2 21:03:55 [INFO] Listening on [::1]:9602 (SQL) and [::1]:9702 (Raft)
toydb3 21:03:55 [INFO] Listening on [::1]:9603 (SQL) and [::1]:9703 (Raft)
toydb5 21:03:55 [INFO] Listening on [::1]:9605 (SQL) and [::1]:9705 (Raft)
toydb2 21:03:56 [INFO] Starting new election for term 1
[...]
toydb2 21:03:56 [INFO] Won election for term 1, becoming leader"><pre><code>$ ./cluster/run.sh
Starting 5 nodes on ports 9601-9605 with data under cluster/*/data/.
To connect to node 1, run: cargo run --release --bin toysql

toydb4 21:03:55 [INFO] Listening on [::1]:9604 (SQL) and [::1]:9704 (Raft)
toydb1 21:03:55 [INFO] Listening on [::1]:9601 (SQL) and [::1]:9701 (Raft)
toydb2 21:03:55 [INFO] Listening on [::1]:9602 (SQL) and [::1]:9702 (Raft)
toydb3 21:03:55 [INFO] Listening on [::1]:9603 (SQL) and [::1]:9703 (Raft)
toydb5 21:03:55 [INFO] Listening on [::1]:9605 (SQL) and [::1]:9705 (Raft)
toydb2 21:03:56 [INFO] Starting new election for term 1
[...]
toydb2 21:03:56 [INFO] Won election for term 1, becoming leader
</code></pre></div>
<p dir="auto">A command-line client can be built and used with node 1 on <code>localhost:9601</code>:</p>
<div data-snippet-clipboard-copy-content="$ cargo run --release --bin toysql
Connected to toyDB node n1. Enter !help for instructions.
toydb&gt; CREATE TABLE movies (id INTEGER PRIMARY KEY, title VARCHAR NOT NULL);
toydb&gt; INSERT INTO movies VALUES (1, &#39;Sicario&#39;), (2, &#39;Stalker&#39;), (3, &#39;Her&#39;);
toydb&gt; SELECT * FROM movies;
1, &#39;Sicario&#39;
2, &#39;Stalker&#39;
3, &#39;Her&#39;"><pre><code>$ cargo run --release --bin toysql
Connected to toyDB node n1. Enter !help for instructions.
toydb&gt; CREATE TABLE movies (id INTEGER PRIMARY KEY, title VARCHAR NOT NULL);
toydb&gt; INSERT INTO movies VALUES (1, &#39;Sicario&#39;), (2, &#39;Stalker&#39;), (3, &#39;Her&#39;);
toydb&gt; SELECT * FROM movies;
1, &#39;Sicario&#39;
2, &#39;Stalker&#39;
3, &#39;Her&#39;
</code></pre></div>
<p dir="auto">toyDB supports most common SQL features, including joins, aggregates, and transactions. Below is an
<code>EXPLAIN</code> query plan of a more complex query (fetches all movies from studios that have released any
movie with an IMDb rating of 8 or more):</p>
<div data-snippet-clipboard-copy-content="toydb&gt; EXPLAIN SELECT m.title, g.name AS genre, s.name AS studio, m.rating
  FROM movies m JOIN genres g ON m.genre_id = g.id,
    studios s JOIN movies good ON good.studio_id = s.id AND good.rating &gt;= 8
  WHERE m.studio_id = s.id
  GROUP BY m.title, g.name, s.name, m.rating, m.released
  ORDER BY m.rating DESC, m.released ASC, m.title ASC;

Remap: m.title, genre, studio, m.rating (dropped: m.released)
└─ Order: m.rating desc, m.released asc, m.title asc
   └─ Projection: m.title, g.name as genre, s.name as studio, m.rating, m.released
      └─ Aggregate: m.title, g.name, s.name, m.rating, m.released
         └─ HashJoin: inner on m.studio_id = s.id
            ├─ HashJoin: inner on m.genre_id = g.id
            │  ├─ Scan: movies as m
            │  └─ Scan: genres as g
            └─ HashJoin: inner on s.id = good.studio_id
               ├─ Scan: studios as s
               └─ Scan: movies as good (good.rating &gt; 8 OR good.rating = 8)"><pre><code>toydb&gt; EXPLAIN SELECT m.title, g.name AS genre, s.name AS studio, m.rating
  FROM movies m JOIN genres g ON m.genre_id = g.id,
    studios s JOIN movies good ON good.studio_id = s.id AND good.rating &gt;= 8
  WHERE m.studio_id = s.id
  GROUP BY m.title, g.name, s.name, m.rating, m.released
  ORDER BY m.rating DESC, m.released ASC, m.title ASC;

Remap: m.title, genre, studio, m.rating (dropped: m.released)
└─ Order: m.rating desc, m.released asc, m.title asc
   └─ Projection: m.title, g.name as genre, s.name as studio, m.rating, m.released
      └─ Aggregate: m.title, g.name, s.name, m.rating, m.released
         └─ HashJoin: inner on m.studio_id = s.id
            ├─ HashJoin: inner on m.genre_id = g.id
            │  ├─ Scan: movies as m
            │  └─ Scan: genres as g
            └─ HashJoin: inner on s.id = good.studio_id
               ├─ Scan: studios as s
               └─ Scan: movies as good (good.rating &gt; 8 OR good.rating = 8)
</code></pre></div>

<p dir="auto">toyDB&#39;s architecture is fairly typical for a distributed SQL database: a transactional
key/value store managed by a Raft cluster with a SQL query engine on top. See the
<a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/architecture/index.md">architecture guide</a> for more details.</p>
<p dir="auto"><a href="https://cthulahoops.org/erikgrinaker/toydb/blob/main/docs/architecture/index.md"><img src="https://cthulahoops.org/erikgrinaker/toydb/raw/main/docs/architecture/images/architecture.svg" alt="toyDB architecture"/></a></p>

<p dir="auto">toyDB mainly uses <a href="https://github.com/erikgrinaker/goldenscript">Goldenscripts</a> for tests. These
script various scenarios, capture events and output, and later assert that the behavior remains the
same. See e.g.:</p>
<ul dir="auto">
<li><a href="https://github.com/erikgrinaker/toydb/tree/main/src/raft/testscripts/node">Raft cluster tests</a></li>
<li><a href="https://github.com/erikgrinaker/toydb/tree/main/src/storage/testscripts/mvcc">MVCC transaction tests</a></li>
<li><a href="https://github.com/erikgrinaker/toydb/tree/main/src/sql/testscripts">SQL execution tests</a></li>
<li><a href="https://github.com/erikgrinaker/toydb/tree/main/tests/scripts">End-to-end tests</a></li>
</ul>
<p dir="auto">Run tests with <code>cargo test</code>, or have a look at the latest
<a href="https://github.com/erikgrinaker/toydb/actions/workflows/ci.yml">CI run</a>.</p>

<p dir="auto">toyDB is not optimized for performance, but comes with a <code>workload</code> benchmark tool that can run
various workloads against a toyDB cluster. For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Start a 5-node toyDB cluster.
$ ./cluster/run.sh
[...]

# Run a read-only benchmark via all 5 nodes.
$ cargo run --release --bin workload read
Preparing initial dataset... done (0.179s)
Spawning 16 workers... done (0.006s)
Running workload read (rows=1000 size=64 batch=1)...

Time   Progress     Txns      Rate       p50       p90       p99      pMax
1.0s      13.1%    13085   13020/s     1.3ms     1.5ms     1.9ms     8.4ms
2.0s      27.2%    27183   13524/s     1.3ms     1.5ms     1.8ms     8.4ms
3.0s      41.3%    41301   13702/s     1.2ms     1.5ms     1.8ms     8.4ms
4.0s      55.3%    55340   13769/s     1.2ms     1.5ms     1.8ms     8.4ms
5.0s      70.0%    70015   13936/s     1.2ms     1.5ms     1.8ms     8.4ms
6.0s      84.7%    84663   14047/s     1.2ms     1.4ms     1.8ms     8.4ms
7.0s      99.6%    99571   14166/s     1.2ms     1.4ms     1.7ms     8.4ms
7.1s     100.0%   100000   14163/s     1.2ms     1.4ms     1.7ms     8.4ms

Verifying dataset... done (0.002s)"><pre><span><span>#</span> Start a 5-node toyDB cluster.</span>
$ ./cluster/run.sh
[...]

<span><span>#</span> Run a read-only benchmark via all 5 nodes.</span>
$ cargo run --release --bin workload <span>read</span>
Preparing initial dataset... <span>done</span> (0.179s)
Spawning 16 workers... <span>done</span> (0.006s)
Running workload <span>read</span> (rows=1000 size=64 batch=1)...

Time   Progress     Txns      Rate       p50       p90       p99      pMax
1.0s      13.1%    13085   13020/s     1.3ms     1.5ms     1.9ms     8.4ms
2.0s      27.2%    27183   13524/s     1.3ms     1.5ms     1.8ms     8.4ms
3.0s      41.3%    41301   13702/s     1.2ms     1.5ms     1.8ms     8.4ms
4.0s      55.3%    55340   13769/s     1.2ms     1.5ms     1.8ms     8.4ms
5.0s      70.0%    70015   13936/s     1.2ms     1.5ms     1.8ms     8.4ms
6.0s      84.7%    84663   14047/s     1.2ms     1.4ms     1.8ms     8.4ms
7.0s      99.6%    99571   14166/s     1.2ms     1.4ms     1.7ms     8.4ms
7.1s     100.0%   100000   14163/s     1.2ms     1.4ms     1.7ms     8.4ms

Verifying dataset... <span>done</span> (0.002s)</pre></div>
<p dir="auto">The available workloads are:</p>
<ul dir="auto">
<li><code>read</code>: single-row primary key lookups.</li>
<li><code>write</code>: single-row inserts to sequential primary keys.</li>
<li><code>bank</code>: bank transfers between various customers and accounts. To make things interesting, this
includes joins, secondary indexes, sorting, and conflicts.</li>
</ul>
<p dir="auto">For more information about workloads and parameters, run <code>cargo run --bin workload -- --help</code>.</p>
<p dir="auto">Example workload results are listed below. Write performance is atrocious, due to
<a href="https://en.wikipedia.org/wiki/Sync_(Unix)" rel="nofollow">fsync</a> and a lack of write batching in the Raft layer.
Disabling fsync, or using the in-memory engine, significantly improves write performance (at the
expense of durability).</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Workload</th>
<th>BitCask</th>
<th>BitCask w/o fsync</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>read</code></td>
<td>14163 txn/s</td>
<td>13941 txn/s</td>
<td>13949 txn/s</td>
</tr>
<tr>
<td><code>write</code></td>
<td>35 txn/s</td>
<td>4719 txn/s</td>
<td>7781 txn/s</td>
</tr>
<tr>
<td><code>bank</code></td>
<td>21 txn/s</td>
<td>1120 txn/s</td>
<td>1346 txn/s</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<p dir="auto"><a href="https://code.visualstudio.com" rel="nofollow">VSCode</a> and the <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" rel="nofollow">CodeLLDB</a>
extension can be used to debug toyDB, with the debug configuration under <code>.vscode/launch.json</code>.</p>
<p dir="auto">Under the &#34;Run and Debug&#34; tab, select e.g. &#34;Debug executable &#39;toydb&#39;&#34; or &#34;Debug unit tests in
library &#39;toydb&#39;&#34;.</p>

<p dir="auto">The toyDB logo is courtesy of <a href="https://github.com/jonasmerlin">@jonasmerlin</a>.</p>
</article></div></div>
  </body>
</html>
