<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/openziti-test-kitchen/go-http">Original</a>
    <h1>Show HN: Golang HTTP Clients/Servers and Alternative Networking</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">This project provides examples of how to use different mechanisms within the GoLang HTTP standard libraries
to intercept network socket creation to route HTTP client and server traffic over alternative networks.</p>
<p dir="auto">Specifically, the <a href="https://github.com/openziti/ziti">OpenZiti overlay network</a>  GoLang SDK is used to create <code>net.Conn</code>
implementations that can be used in<code>net.Listener</code> use cases (servers) and <code>http.Client</code>.</p>

<p dir="auto">Taking over socket level connections make it easy to integrate alternative networking into GoLang based applications.
This enables OSI level 3 API Security for software developers. Normally layer 3 concerns are delegated to
network engineers as physical hardware or cloud resources are invovled.</p>
<p dir="auto">Additionally, this approach is orthogonal to the development of the application logic. Meaning it can
be added or removed at any time. Old applications can be converted as the main interfaces <code>net.Conn</code> and
<code>net.Listner</code> are used. The client/servers are unaware of any networking change. This also means that other GoLang
libraries easily fit this model too - not just HTTP.</p>
<p dir="auto">Consider the following diagram where existing HTTP API Clients and HTTP API Server is secured using one alternative
networking solution: OpenZiti. The Application Server (e.g. HTTP API Server) does not open any ports for listening.
Instead, the SDK calls out to an overlay network that verifies it. In this scenario, the Application Server cannot
be scanned by normal means on the internet or an internal network unless the overlay network is compromised first.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/openziti-test-kitchen/go-http/blob/main/diagram-overall.png"><img src="https://github.com/openziti-test-kitchen/go-http/raw/main/diagram-overall.png" alt="Example Network"/></a></p>

<p dir="auto">The examples are all runnable executables under the <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd"><code>cmd</code></a> directory.</p>
<h2 dir="auto"><a id="user-content-servers" aria-hidden="true" href="#servers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Servers</h2>
<ul dir="auto">
<li><a href="https://pkg.go.dev/net/http" rel="nofollow">Standard Go Server</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-server-go/main.go">example</a></li>
<li><a href="https://github.com/gin-gonic/gin">Gin</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-server-gin/main.go">example</a></li>
<li><a href="https://github.com/goji/goji">Goji</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-server-goji/main.go">example</a></li>
<li><a href="https://github.com/gorilla/mux">Gorilla</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-server-gorilla/main.go">example</a></li>
</ul>
<h2 dir="auto"><a id="user-content-clients" aria-hidden="true" href="#clients"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Clients</h2>
<ul dir="auto">
<li><a href="https://pkg.go.dev/net/http" rel="nofollow">Standard Go Client</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-client-go/main.go">example</a></li>
<li><a href="https://github.com/go-resty/resty">Resty</a> - <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/ziti-client-resty/main.go">example</a></li>
</ul>

<p dir="auto">GoLang&#39;s built-in HTTP facilitates provide excellent methods for hooking into them. With the use of
the OpenZiti SDK, it essentially boils down to the following patterns that work for the standard
GoLang HTTP client and server. These can then be adjusted to fit into any framework/library that uses
the GoLang HTTP packages.</p>
<p dir="auto">The <a href="https://github.com/openziti/sdk-golang">OpenZiti GoLang SDK</a> provides
<a href="https://github.com/openziti/sdk-golang/blob/main/http_transport.go"><code>ZitiTransport</code></a>, which can be used as an
<code>http.Transport</code>/<code>http.RoundTripper</code>, and <code>edge.Listener</code> that can be used as a <code>net.Listener</code>. <code>ZitiTransport</code> can be used to create
<code>http.Client</code> instances and <code>edge.Listener</code> can be used to with <code>http.Serve(listener,...)</code> calls. The rest of the
GoLang HTTP machinery handles all the HTTP interactions unknowingly over an OpenZiti network.</p>
<p dir="auto">This same pattern can be used to inject any custom networking you wish!</p>
<p dir="auto">If you want to deep dive, the <code>ZitiTransport</code> definition can be found <a href="https://github.com/openziti/sdk-golang/blob/main/http_transport.go">here</a>
and <code>edge.Listen()</code> can be found <a href="https://github.com/openziti/sdk-golang/blob/main/ziti/ziti.go#L590">here</a>.</p>
<h2 dir="auto"><a id="user-content-client" aria-hidden="true" href="#client"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Client</h2>
<p dir="auto">Before:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    client := http.DefaultClient
    resp, err := client.Get(&#34;http://&#34; + args.ServiceName)"><pre>    <span>client</span> <span>:=</span> <span>http</span>.<span>DefaultClient</span>
    <span>resp</span>, <span>err</span> <span>:=</span> <span>client</span>.<span>Get</span>(<span>&#34;http://&#34;</span> <span>+</span> <span>args</span>.<span>ServiceName</span>)</pre></div>
<p dir="auto">After:</p>
<div dir="auto" data-snippet-clipboard-copy-content="	client := sdk_golang.NewHttpClient(ctx, nil)
	resp, err := client.Get(&#34;http://&#34; + args.ServiceName)"><pre>	<span>client</span> <span>:=</span> <span>sdk_golang</span>.<span>NewHttpClient</span>(<span>ctx</span>, <span>nil</span>)
	<span>resp</span>, <span>err</span> <span>:=</span> <span>client</span>.<span>Get</span>(<span>&#34;http://&#34;</span> <span>+</span> <span>args</span>.<span>ServiceName</span>)</pre></div>
<h2 dir="auto"><a id="user-content-server" aria-hidden="true" href="#server"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Server</h2>
<p dir="auto">Before:</p>
<div dir="auto" data-snippet-clipboard-copy-content="	if err := http.Serve(listener, http.HandlerFunc(handler)); err != nil {
		log.Fatalf(&#34;serving failed: %v&#34;, err)
	}"><pre>	<span>if</span> <span>err</span> <span>:=</span> <span>http</span>.<span>Serve</span>(<span>listener</span>, <span>http</span>.<span>HandlerFunc</span>(<span>handler</span>)); <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;serving failed: %v&#34;</span>, <span>err</span>)
	}</pre></div>
<p dir="auto">After:</p>
<div dir="auto" data-snippet-clipboard-copy-content="	listener, err = ctx.Listen(args.ServiceName)

	if err := http.Serve(listener, http.HandlerFunc(handler)); err != nil {
		log.Fatalf(&#34;https serving failed: %v&#34;, err)
	}"><pre>	<span>listener</span>, <span>err</span> <span>=</span> <span>ctx</span>.<span>Listen</span>(<span>args</span>.<span>ServiceName</span>)

	<span>if</span> <span>err</span> <span>:=</span> <span>http</span>.<span>Serve</span>(<span>listener</span>, <span>http</span>.<span>HandlerFunc</span>(<span>handler</span>)); <span>err</span> <span>!=</span> <span>nil</span> {
		<span>log</span>.<span>Fatalf</span>(<span>&#34;https serving failed: %v&#34;</span>, <span>err</span>)
	}</pre></div>

<p dir="auto">Each example uses the same <a href="https://github.com/openziti-test-kitchen/go-http/blob/main/cmd/args.go">command line argument processing</a>. This processing takes in two
or four arguments that specify the Ziti Identity configuration file and OpenZiti service name. The two
additional arguments are paths to a x509 certificate and key in PEM format. If specified for a server,
the server will be hosted as an HTTPS service using the provided certificate and key files for the server&#39;s
identity. For a client, the x509 certificate and key will be used as the client certificate and key used to
initiate the TLS connection over the OpenZiti network.</p>
<p dir="auto"><code>ziti-server-gin &lt;serviceName&gt; &lt;identityConfig&gt; [&lt;certificate&gt; &lt;key&gt;]</code></p>
<p dir="auto">However, HTTPS when working with OpenZiti is not necessary. See the next section!</p>

<p dir="auto">Hosting an HTTPS server over OpenZiti means that a TLS handshake will occur. A TLS handshake
requires that the server presents a certificate with a SAN IP or a SAN DNS entry that matches
the address the client used to access the service. For OpenZiti, this means that a SAN DNS
that matches the OpenZiti service name must be present.</p>
<p dir="auto">If the service will only be hosted over OpenZiti, HTTPS is an extra layer of security that can safely
be omitted. OpenZiti connections are inherently end-to-end encrypted and the data plane across
an OpenZiti network is additionally encrypted on each leg of transit. Further, the controller
has already verified all clients and hosts before they &#34;dial&#34; (connect) or &#34;bind&#34; (host).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/openziti-test-kitchen/go-http/blob/main/diagram-encrypt.png"><img src="https://github.com/openziti-test-kitchen/go-http/raw/main/diagram-encrypt.png" alt=""/></a></p>

<ol dir="auto">
<li><code>git clone https://github.com/openziti-test-kitchen/go-http.git</code></li>
<li><code>cd go-http</code></li>
<li><code>go install ./...</code></li>
<li><code>~/go/bin/ziti-server-go ...</code> or <code>$GOBIN/ziti-server-go ...</code> if you have a custom <code>GOBIN</code> environment variable</li>
</ol>
<p dir="auto">After building the examples, see the next section on setting up a network.</p>

<p dir="auto">To run these examples an OpenZiti network must be up and running. This includes a controller and router.
A service, service host, and client will need to be created. The host and client identities will require
policies to access and host the service. To set up an OpenZiti network, please see the
<a href="https://openziti.github.io/ziti/quickstarts/quickstart-overview.html" rel="nofollow">quickstart guides</a>.</p>
<p dir="auto">You will need the Ziti CLI from the <a href="https://github.com/openziti/ziti">main Ziti repository</a> installed and on your path.</p>
<ol dir="auto">
<li>Login
<ul dir="auto">
<li><code>ziti edge login &#34;https://localhost:1280/edge/management/v1&#34; -c $controllerCa -u $user -p $password</code></li>
</ul>
</li>
<li>Create the Service
<ul dir="auto">
<li><code>ziti create service myHttpService -a httpService</code></li>
</ul>
</li>
<li>Create the identities
<ul dir="auto">
<li><code>ziti create identity service httpServer -a httpServer -o server.jwt</code> &gt; creates <code>server.jwt</code></li>
<li><code>ziti create identity user httpClient -a httpClient -o client.jwt</code> &gt; creates <code>client.jwt</code></li>
</ul>
</li>
<li>Create policies
<ul dir="auto">
<li><code>ziti create service-policy httpServers Bind --identity-roles #httpServer --service-roles #httpService</code></li>
<li><code>ziti create service-policy httpClients Dial --identity-roles #httpClient --service-roles #httpService</code></li>
</ul>
</li>
<li>Enroll your identities
<ul dir="auto">
<li><code>ziti edge enroll server.jwt</code> &gt; creates <code>server.json</code></li>
<li><code>ziti edge enroll client.jwt</code> &gt; creates <code>client.json</code></li>
</ul>
</li>
<li>Start an example
<ul dir="auto">
<li><code>ziti-server-go myHttpService server.json</code></li>
<li><code>ziti-client-resty myHttpService client.json</code></li>
</ul>
</li>
</ol>
</article>
          </div></div>
  </body>
</html>
