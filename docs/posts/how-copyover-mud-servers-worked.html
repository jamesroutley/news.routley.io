<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://jackkelly.name/blog/archives/2025/02/06/how_copyover_mud_servers_worked/">Original</a>
    <h1>How Copyover MUD Servers Worked</h1>
    
    <div id="readability-page-1" class="page"><div>
  
  <div><p>
  Posted on February  6, 2025
  
    by Jack Kelly
  

  
    </p>
  
</div>

  <p>When I was younger, I played a lot of MUDs (“<a href="https://mudconnect.com/mudfaq/mudfaq-p1.html#q1">Multi-User
Dungeons</a>” — the text-only predecessors of modern MMORPGs, often
played over <a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a>).
They were great fun, particularly during high school: a lightweight
multiplayer game with no client state meant you could log in from any
machine in any lab, even Windows shipped a Telnet client in those days,
the Telnet protocol was light enough to run on my school’s slow PCs and
limited internet connection, and the lack of flashy graphics meant it
was easy to hide the window from a passing teacher or librarian.</p>
<p>At some point, building and tinkering with MUDs became more
interesting than playing them. In those days, MUD builders and wizards
(admins) were often recruited from each game’s playerbase, and many MUDs
let builders edit the world through in-game commands. This was
incredibly cool at the time — even through a clumsy line-oriented (<a href="https://www.gnu.org/software/ed/"><code>ed</code>-style</a>)
editor, there was something magical about summoning blank rooms from the
void, writing rich descriptions to turn them into “real” spaces, and
adding items and “mobs” (Mobile OBJects — NPCs) to make them come to
life. A few of my friends and I signed up to a “builder academy” MUD,
where everyone got a zone to mess around in, and we tried our hand at
crafting our own areas. Most of these projects didn’t get very far, and
all of them have been lost to time.</p>
<p>There’s only so much you can do with builder rights on someone else’s
MUD. To really change the game, you needed to be able to code, and most
MUDs were written “real languages” like C. We’d managed to get a copy of
Visual C++ 6 and the <a href="https://www.circlemud.org/">CircleMUD</a>
source code, and started messing about. But the development cycle was
pretty frustrating — for every change, you had to recompile the server,
shut it down (dropping everyone’s connections), bring it back up, and
wait for everyone to log back in.</p>
<p>Some MUDs used a very cool trick to avoid this, called “copyover” or
“hotboot”. It’s an idiom that lets a stateful server replace itself
while retaining its PID and open connections. It seemed like magic back
then: you recompiled the server, sent the right command, everything
froze for a few seconds, and (if you were lucky) it came back to life
running the latest code. The trick is simple but I can’t find a detailed
write-up, so I wanted to write it out while I thought of it.</p>
<!--more-->
<p>The copyover method I’m most familiar with works like this:</p>
<ol type="1">
<li><p>The copyover command is invoked by a MUD admin.</p></li>
<li><p>The server calls <a href="https://www.man7.org/linux/man-pages/man2/pipe.2.html"><code>pipe(2)</code></a>
to create a “pipe”. This is the data channel that the new version of the
server will read from, and the old version of the server will write
to.</p></li>
<li><p>The server calls <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html"><code>fork(2)</code></a>,
creating a copy of itself with the same state. We now have a
<strong>parent</strong> and a <strong>child</strong> process.</p></li>
<li><p>The <strong>child</strong> closes the read end of the pipe,
writes the game state into the pipe, and then exits.</p></li>
<li><p>(In parallel with №3) The <strong>parent</strong> closes the
write end of the pipe and calls an <a href="https://man7.org/linux/man-pages/man3/exec.3.html"><code>exec(3)</code></a>
function to replace itself with the new binary. This <code>exec</code>
usually includes a specific “copyover” flag on the command line as well
as the FD for the read end of the pipe. File descriptors, including open
sockets, will remain open across the <code>exec()</code> call.</p></li>
<li><p>(In parallel with №3) The <strong>parent</strong>, now running
the new code, reads the game state through the pipe and then closes
it.</p></li>
<li><p>The <strong>parent</strong> calls <a href="https://man7.org/linux/man-pages/man2/wait.2.html"><code>wait(2)</code></a>
to clear away the zombie <strong>child</strong> process.</p></li>
</ol>
<p>At this point, we’ve achieved all of our goals. The server is running
the new code with the old state under the old PID. The biggest weakness
I see with this scheme is that if the new server fails to come up,
you’ve got no way to abort the copyover and you lose all your state. If
you give up maintaining a constant PID, I can imagine more elaborate and
robust schemes; for example, swapping out the pipe for something more
sophisticated allows the new server to report that it’s ready to take
over. It’s also possible to be smarter about how file descriptors are
handled: A server could split network connection handling off into a
separate process from the game logic (and have them communicate over
Unix domain sockets), pass sockets to the replacing server using <a href="https://www.man7.org/linux/man-pages/man7/unix.7.html#:~:text=SCM_RIGHTS"><code>SCM_RIGHTS</code></a>,
store copyover state in a <a href="https://man7.org/linux/man-pages/man2/memfd_create.2.html">memfd</a>,
or use <a href="https://systemd.io/FILE_DESCRIPTOR_STORE/">systemd’s
file descriptor store</a> to hold your memfds and socket fds while
systemd replaces your process. I don’t know what the most modern idioms
are, I just wanted to document how it used to work.</p>
<p>A simple copyover server uses well-known Unix primitives — pipes,
<code>fork(2)</code>, and file descriptor persistence across
<code>exec(3)</code> — but it doesn’t take much to prove that
sufficiently clever use of Unix is <a href="https://archive.org/details/unix-magic-poster-gary-overcare-1">indistinguishable
from magic</a>. (Other examples: <a href="https://factorio.com/blog/post/fff-408#:~:text=Asynchronous%20saving">Factorio
using <code>fork(2)</code> to implement asynchronous saving on macOS and
GNU/Linux</a>; <a href="https://blog.cloudflare.com/know-your-scm_rights/">Cloudflare
using <code>SCM_RIGHTS</code> to send TLS 1.3 connections to a separate
process</a>.) Much of the apparent magic comes not from Unix itself
being magical, but because many of its primitives now lie hidden beneath
cross-language runtimes or platform abstraction libraries, or are even
forgotten outright. I’d started this post just looking to document the
old way of copying over a stateful server, but the things I’ve found
along the way make me want to dig further. What else have I missed? Is
Stevens’ <em>Advanced Programming in the UNIX Environment</em> still the
canonical reference?</p>
</div></div>
  </body>
</html>
