<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://inside.java/2025/05/01/strings-just-got-faster/">Original</a>
    <h1>Strings Just Got Faster</h1>
    
    <div id="readability-page-1" class="page"><div id="entry"><p>In JDK 25, <a href="https://github.com/openjdk/jdk/pull/24625">we improved</a> the performance of the class <code>String</code> in such a way that the <code>String::hashCode</code> function is mostly <a href="https://en.wikipedia.org/wiki/Constant_folding"><em>constant foldable</em></a>. For example, if you use Strings as keys in a static unmodifiable <code>Map</code>, you will likely see significant performance improvements.</p>


<p>Here is a relatively advanced example where we maintain an immutable <code>Map</code> of native calls, its keys are the name of the method call and the values are a <code>MethodHandle</code> that can be used to invoke the associated system call:</p>

<div><div><pre><code><span>// Set up an immutable Map of system calls</span>
<span>static</span> <span>final</span> <span>Map</span><span>&lt;</span><span>String</span><span>,</span> <span>MethodHandle</span><span>&gt;</span> <span>SYSTEM_CALLS</span> <span>=</span> <span>Map</span><span>.</span><span>of</span><span>(</span>
        <span>“</span><span>malloc</span><span>”</span><span>,</span> <span>linker</span><span>.</span><span>downcallHandle</span><span>(</span><span>mallocSymbol</span><span>,</span><span>…</span><span>),</span>
        <span>“</span><span>free</span><span>”</span><span>,</span> <span>linker</span><span>.</span><span>downcallHandle</span><span>(</span><span>freeSymbol</span><span>…</span><span>),</span>
        <span>...);</span>

<span>…</span>

<span>// Allocate a memory region of 16 bytes</span>
<span>long</span> <span>address</span> <span>=</span> <span>SYSTEM_CALLS</span><span>.</span><span>get</span><span>(</span><span>“</span><span>malloc</span><span>”</span><span>).</span><span>invokeExact</span><span>(</span><span>16L</span><span>);</span>
<span>…</span>
<span>// Free the memory region</span>
<span>SYSTEM_CALLS</span><span>.</span><span>get</span><span>(</span><span>“</span><span>free</span><span>”</span><span>).</span><span>invokeExact</span><span>(</span><span>address</span><span>);</span>

</code></pre></div></div>

<p>The method <code>linker.downcallHandle(…)</code> takes a symbol and additional parameters to bind a native call to a Java <code>MethodHandle</code> via the <a href="https://openjdk.org/jeps/454">Foreign Function &amp; Memory API</a> introduced in JDK 22. This is a relatively slow process and involves spinning bytecode. However, once entered into the <code>Map</code>, the new performance improvements in the <code>String</code> class alone allow constant folding of both the key lookups and the values, thus improving performance by a factor of more than 8x:</p>

<div><div><pre><code>--- JDK 24 ---

Benchmark                     Mode  Cnt  Score   Error  Units
StringHashCodeStatic.nonZero  avgt   15  4.632 ± 0.042  ns/op

--- JDK 25 ---

Benchmark                     Mode  Cnt  Score   Error  Units
StringHashCodeStatic.nonZero  avgt   15  0.571 ± 0.012  ns/op
</code></pre></div></div>
<p><strong>Note</strong> : the benchmarks above are not using a <code>malloc()</code> <code>MethodHandle</code> but an <code>int</code> <em>identity function</em>. After all, we are not testing the performance of <code>malloc()</code> but the actual <code>String</code> lookup and <code>MethodHandle</code> performance.</p>

<p>This improvement will benefit any immutable <code>Map&lt;String, V&gt;</code> with Strings as keys and where values (of arbitrary type <code>V</code>) are looked up via constant Strings.</p>



<p>When a <code>String</code> is first created, its hashcode is unknown. On the first call to <code>String::hashCode</code>, the actual hashcode is computed and stored in a private field <code>String.hash</code>. This transformation might sound odd; if <code>String</code> is <em>immutable</em>, how can it mutate its state? The answer is that the mutation cannot be observed from the outside; <code>String</code> would functionally behave the same regardless of whether or not an internal <code>String.hash</code> cache field is used. The only difference is that it becomes faster for subsequent calls.</p>

<p>Now that we know how <code>String::hashCode</code> works, we can unveil the performance changes made (which consists of a single line of code): the internal field <code>String.hash</code> is marked with the JDK-internal <code>@Stable</code> annotation. That’s it!</p>

<p><code>@Stable</code> tells the virtual machine it can read the field once and, if it is no longer its default value (zero), it can trust the field never change again. Hence, it can <em>constant-fold</em> the <code>String::hashcode</code> operation and replace the call with the known <code>hash</code>. As it turns out, the fields in the immutable <code>Map</code> and the internals of the <code>MethodHandle</code> are also trusted in the same way. This means the virtual machine can constant-fold the entire chain of operations:</p>

<ul>
  <li>Computing the hash code of the String “malloc” (which is always <code>-1081483544</code>)</li>
  <li>Probing the immutable <code>Map</code> (i.e., compute the internal array index which is always the same for the <code>malloc</code> hashcode)</li>
  <li>Retrieving the associated <code>MethodHandle</code> (which always resides on said computed index)</li>
  <li>Resolving the actual native call (which is always the native <code>malloc()</code> call)</li>
</ul>

<p>In effect, this means the native <code>malloc()</code> method call can be invoked directly, which explains the tremendous performance improvements. To put it in other words, the chain of operation is completely short-circuited.</p>


<p>There is an unfortunate corner case that the new improvement does not cover: if the hash code of the <code>String</code> happens to be zero, constant folding will not work. As we learned above, constant folding can only take place for non-default values (i.e., non-zero values for <code>int</code> fields). However, we anticipate we will be able to fix this small impediment in the near future. You might think only one in about 4 billion distinct Strings has a hash code of zero and that might be right in the average case. However, one of the most common strings (the empty string “”) has a hash value of zero. On the other hand, no string with 1 - 6 characters (inclusive) (all characters ranging from ` ` (space) to <code>Z</code>) has a hash code that is zero.</p>


<p>As <code>@Stable</code> annotation is applicable only to internal JDK code, you cannot use it directly in your Java applications. However, we are working on a new JEP called <a href="https://openjdk.org/jeps/502">JEP 502: Stable Values (Preview)</a> that will provide constructs that allow user code to indirectly benefit from <code>@Stable</code> fields in a similar way.</p>


<p>You can <a href="https://jdk.java.net/">download JDK 25</a> already today and see how much this performance improvement will benefit your current applications,</p>
</div></div>
  </body>
</html>
