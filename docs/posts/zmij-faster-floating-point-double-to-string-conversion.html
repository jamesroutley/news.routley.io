<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vitaut.net/posts/2025/faster-dtoa/">Original</a>
    <h1>Zmij: Faster floating point double-to-string conversion</h1>
    
    <div id="readability-page-1" class="page"><div><div v-pre=""><p><img src="https://vitaut.net/img/dragons.jpg#floatright" alt="" title="Guess which dragon represents which algorithm"/></p><p>There comes a time in every software engineer’s life when they come up with a
new binary-to-decimal floating-point conversion method. I guess my time has
come. I just wrote one, mostly over a weekend: <a href="https://github.com/vitaut/zmij">https://github.com/vitaut/zmij</a>.</p><p>It incorporates lessons learned from implementing
<a href="https://fmt.dev/papers/p372-steele.pdf">Dragon4</a>,
<a href="https://dl.acm.org/doi/10.1145/1809028.1806623">Grisu</a> and
<a href="https://fmt.dev/papers/Schubfach4.pdf">Schubfach</a> along with a few new ideas
from myself and others. The main guiding principle is Alexandrescu’s
“no work is less work than some work” so a number of improvements come from
removing things from Schubfach (conditional branches, computations and even
candidate numbers).</p><h2 id="performance">Performance</h2><p>Here is how it performs on <a href="https://github.com/fmtlib/dtoa-benchmark">dtoa-benchmark</a>:</p><ul><li>~68% faster than <a href="https://github.com/jk-jeon/dragonbox">Dragonbox</a>, the
previous leader (at least among algorithms with correctness proofs)</li><li>~2 times faster than <a href="https://github.com/vitaut/schubfach">my Schubfach implementation</a> that closely follows the original paper</li><li>~3.5 times faster than <a href="https://en.cppreference.com/w/cpp/utility/to_chars.html"><code>std::to_chars</code></a> from libc++ (Ryu?)</li><li>~6.8 times faster than Google’s <a href="https://github.com/google/double-conversion">double-conversion</a> (Grisu3)</li><li>~59 times (not percent!) faster than <code>sprintf</code> on macOS (Dragon4?)</li></ul><p>Converting a single double takes about 10 to 20 ns on Apple M1.</p><h2 id="what-are-the-improvements">What are the improvements?</h2><p>Here is a list of improvements compared to Schubfach:</p><ul><li>Selection from 1-3 candidates instead of 2-4</li><li>Fewer integer multiplications in the shorter case</li><li>Faster logarithm approximations</li><li>Faster division and modulo</li><li>Fewer conditional branches</li><li>More efficient significand and exponent output</li></ul><p>Let’s take a look at some of them.</p><p>The first small improvement is having a single branch to quickly check for
special cases: NaN, infinity, zero or subnormals. There are still additional
checks within that path but the common case is more streamlined.</p><p>Another improvement is using faster fixed-point logarithm approximations.
Schubfach does the following:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>// log10_2_sig = round(log10(2) * 2**log10_2_exp)
</span></span></span><span><span><span></span><span>constexpr</span> <span>int64_t</span> <span>log10_2_sig</span> <span>=</span> <span>661&#39;971&#39;961&#39;083</span><span>;</span>
</span></span><span><span><span>constexpr</span> <span>int</span> <span>log10_2_exp</span> <span>=</span> <span>41</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>// Computes floor(log10(pow(2, e))) for e &lt;= 5456721.
</span></span></span><span><span><span></span><span>auto</span> <span>floor_log10_pow2</span><span>(</span><span>int</span> <span>e</span><span>)</span> <span>noexcept</span> <span>-&gt;</span> <span>int</span> <span>{</span>
</span></span><span><span>  <span>return</span> <span>e</span> <span>*</span> <span>log10_2_sig</span> <span>&gt;&gt;</span> <span>log10_2_exp</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>which uses 64-bit multiplication:</p><div><pre tabindex="0"><code data-lang="s"><span><span><span>floor_log10_pow2</span><span>(</span><span>int</span><span>)</span><span>:</span>
</span></span><span><span>        <span>movsxd</span>  <span>rcx</span><span>,</span> <span>edi</span>
</span></span><span><span>        <span>movabs</span>  <span>rax</span><span>,</span> <span>661971961083</span>
</span></span><span><span>        <span>imul</span>    <span>rax</span><span>,</span> <span>rcx</span>
</span></span><span><span>        <span>sar</span>     <span>rax</span><span>,</span> <span>41</span>
</span></span><span><span>        <span>ret</span>
</span></span></code></pre></div><p>However, for the range of inputs (exponents) we could use 32-bit approximations:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>// log10_2_sig = round(log10(2) * 2**log10_2_exp)
</span></span></span><span><span><span></span><span>constexpr</span> <span>int</span> <span>log10_2_sig</span> <span>=</span> <span>315&#39;653</span><span>;</span>
</span></span><span><span><span>constexpr</span> <span>int</span> <span>log10_2_exp</span> <span>=</span> <span>20</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>auto</span> <span>floor_log10_pow2</span><span>(</span><span>int</span> <span>e</span><span>)</span> <span>noexcept</span> <span>-&gt;</span> <span>int</span> <span>{</span>
</span></span><span><span>  <span>return</span> <span>e</span> <span>*</span> <span>log10_2_sig</span> <span>&gt;&gt;</span> <span>log10_2_exp</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>resulting in</p><div><pre tabindex="0"><code data-lang="s"><span><span><span>floor_log10_pow2</span><span>(</span><span>int</span><span>)</span><span>:</span>
</span></span><span><span>        <span>imul</span>    <span>eax</span><span>,</span> <span>edi</span><span>,</span> <span>315653</span>
</span></span><span><span>        <span>sar</span>     <span>eax</span><span>,</span> <span>20</span>
</span></span><span><span>        <span>ret</span>
</span></span></code></pre></div><p>Dragonbox also uses 32-bit approximations with slightly different constants.</p><p>Similarly, we can replace some integer divisions with integer multiplications.
Compilers already know how to do this, but we can do better when we know that
the range of inputs is small:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>// Returns {value / 100, value % 100} correct for values of up to 4 digits.
</span></span></span><span><span><span></span><span>inline</span> <span>auto</span> <span>divmod100</span><span>(</span><span>uint32_t</span> <span>value</span><span>)</span> <span>noexcept</span> <span>-&gt;</span> <span>divmod_result</span> <span>{</span>
</span></span><span><span>  <span>assert</span><span>(</span><span>value</span> <span>&lt;</span> <span>10&#39;000</span><span>);</span>
</span></span><span><span>  <span>constexpr</span> <span>int</span> <span>exp</span> <span>=</span> <span>19</span><span>;</span>  <span>// 19 is faster or equal to 12 even for 3 digits.
</span></span></span><span><span><span></span>  <span>constexpr</span> <span>int</span> <span>sig</span> <span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>/</span> <span>100</span> <span>+</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>uint32_t</span> <span>div</span> <span>=</span> <span>(</span><span>value</span> <span>*</span> <span>sig</span><span>)</span> <span>&gt;&gt;</span> <span>exp</span><span>;</span>  <span>// value / 100
</span></span></span><span><span><span></span>  <span>return</span> <span>{</span><span>div</span><span>,</span> <span>value</span> <span>-</span> <span>div</span> <span>*</span> <span>100</span><span>};</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Another optimization and simplification is branchless handling of irregular
rounding intervals. I wrote about rounding intervals in my <a href="https://vitaut.net/posts/2025/smallest-dtoa/">earlier blog
post</a>, but for the purposes of this post
it is sufficient to know that a rounding interval for a floating-point number
is an interval that contains all real numbers that round back to that number.
Normally the intervals are symmetric, except when there is a jump in the
exponent (the irregular case):</p><p>Most algorithms handle irregular intervals via a completely separate path or at
least some branching. This is not terrible, because irregular cases are rare for
random floating-point numbers. However, it is possible to handle it cheaply and
branchlessly, avoiding extra complexity, which is what I did.</p><p>A more interesting improvement comes from a talk by Cassio Neri
<a href="https://www.youtube.com/watch?v=w0WrRdW7eqg">Fast Conversion From Floating Point Numbers</a>. In Schubfach, we look at four
candidate numbers. The first two, of which at most one is in the rounding
interval, correspond to a larger decimal exponent. The other two, of which at
least one is in the rounding interval, correspond to the smaller exponent.
Cassio’s insight is that we can directly construct a single candidate
from the upper bound in the first case.</p><p>This improvement has a nice effect: it allows us to avoid scaling the value
itself by a power of 10, because we only need the lower and upper bounds.
This saves two 64-bit integer multiplications in the shorter case.</p><p>Unfortunately, this does not help in the longer case, but there are improvements
to be made there as well. Classic Schubfach first checks whether there is only
one candidate from the second set in the rounding interval and returns early in
that case. We can combine this check with the closedness check. This seems
counterintuitive, because we do more work (sorry, Andrei), but it eliminates a
poorly predicted conditional branch and also simplifies the code.</p><p>So we go from this:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>uint64_t</span> <span>dec_sig_over</span> <span>=</span> <span>dec_sig_under</span> <span>+</span> <span>1</span><span>;</span>
</span></span><span><span><span>bool</span> <span>under_in</span> <span>=</span> <span>lower</span> <span>+</span> <span>bin_sig_lsb</span> <span>&lt;=</span> <span>(</span><span>dec_sig_under</span> <span>&lt;&lt;</span> <span>2</span><span>);</span>
</span></span><span><span><span>bool</span> <span>over_in</span> <span>=</span> <span>(</span><span>dec_sig_over</span> <span>&lt;&lt;</span> <span>2</span><span>)</span> <span>+</span> <span>bin_sig_lsb</span> <span>&lt;=</span> <span>upper</span><span>;</span>
</span></span><span><span><span>if</span> <span>(</span><span>under_in</span> <span>!=</span> <span>over_in</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>// Only one of dec_sig_under or dec_sig_over are in the rounding interval.
</span></span></span><span><span><span></span>  <span>return</span> <span>write</span><span>(</span><span>buffer</span><span>,</span> <span>under_in</span> <span>?</span> <span>dec_sig_under</span> <span>:</span> <span>dec_sig_over</span><span>,</span> <span>dec_exp</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// Both dec_sig_under and dec_sig_over are in the interval - pick the closest.
</span></span></span><span><span><span></span><span>int</span> <span>cmp</span> <span>=</span> <span>scaled_sig</span> <span>-</span> <span>((</span><span>dec_sig_under</span> <span>+</span> <span>dec_sig_over</span><span>)</span> <span>&lt;&lt;</span> <span>1</span><span>);</span>
</span></span><span><span><span>bool</span> <span>under_closer</span> <span>=</span> <span>cmp</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>cmp</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span><span>dec_sig_under</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
</span></span><span><span><span>return</span> <span>write</span><span>(</span><span>buffer</span><span>,</span> <span>under_closer</span> <span>?</span> <span>dec_sig_under</span> <span>:</span> <span>dec_sig_over</span><span>,</span> <span>dec_exp</span><span>);</span>
</span></span></code></pre></div><p>to this:</p><div><pre tabindex="0"><code data-lang="c++"><span><span><span>// Pick the closest of dec_sig_under and dec_sig_over and check if it&#39;s in
</span></span></span><span><span><span>// the rounding interval.
</span></span></span><span><span><span></span><span>int64_t</span> <span>cmp</span> <span>=</span> <span>int64_t</span><span>(</span><span>scaled_sig</span> <span>-</span> <span>((</span><span>dec_sig_under</span> <span>+</span> <span>dec_sig_over</span><span>)</span> <span>&lt;&lt;</span> <span>1</span><span>));</span>
</span></span><span><span><span>bool</span> <span>under_closer</span> <span>=</span> <span>cmp</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>(</span><span>cmp</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span><span>dec_sig_under</span> <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>);</span>
</span></span><span><span><span>bool</span> <span>under_in</span> <span>=</span> <span>(</span><span>dec_sig_under</span> <span>&lt;&lt;</span> <span>2</span><span>)</span> <span>&gt;=</span> <span>lower</span><span>;</span>
</span></span><span><span><span>write</span><span>(</span><span>buffer</span><span>,</span> <span>(</span><span>under_closer</span> <span>&amp;</span> <span>under_in</span><span>)</span> <span>?</span> <span>dec_sig_under</span> <span>:</span> <span>dec_sig_over</span><span>,</span>
</span></span><span><span>      <span>dec_exp</span><span>);</span>
</span></span></code></pre></div><p>There are also many improvements in significand and exponent output. The
simplest one, which has been used for many years in <a href="https://github.com/fmtlib/fmt">{fmt}</a> and which I learned from Alexandrescu’s talk
“Three Optimization Tips for C++”, is using a lookup table to output pairs of
decimal digits. This alone halves the number of integer multiplications and is
particularly important here, because the significand is often 16–17 digits long.</p><p>Another trick is branchless removal of trailing zeros using another small
lookup table, which I believe comes from the excellent <a href="https://github.com/abolz/Drachennest">Drachennest</a> project by Alexander Bolz. There are
ideas for improving this further and potentially getting rid of the lookup
table entirely.</p><h2 id="is-this-a-new-algorithm">Is this a new algorithm?</h2><p>Does it deserve to be called a new algorithm, or is it just an optimization of
Schubfach?</p><p>I am not sure, but at the very least it deserves a <a href="https://github.com/vitaut/zmij">separate GitHub project</a> =).</p><h2 id="where-this-can-be-used">Where this can be used</h2><p>This method, or at least some elements of it, will be used in {fmt},
and it is also a good candidate for JSON serialization in <a href="https://github.com/facebook/fbthrift">Thrift</a> and elsewhere. If you have other
applications that could benefit from faster floating-point formatting,
feel free to check it out now, or wait until it is integrated into {fmt}.</p><p>Thanks to my ISO C++ paper <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r3.html">P2587</a>
“to_string or not to_string”, <code>std::to_string</code> will also be able to use this
or a similar method. This will make this standard API both performant and
actually useful.</p><h2 id="current-limitations">Current limitations</h2><p>Despite the name, the implementation is not fully <a href="https://pl.wikipedia.org/wiki/%C5%BBmij">polished</a> yet. In particular, it currently
supports only exponential, also known as scientific, format, although adding
fixed format should be straightforward.</p><h2 id="fun-fact">“Fun” fact</h2><p>My former colleague David Gay wrote an early <code>dtoa</code> implementation back at
Bell Labs, and it was widely used for many years.</p><hr id="EOF"/><p>Last modified on 2025-12-13</p></div></div></div>
  </body>
</html>
