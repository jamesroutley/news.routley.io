<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prog21.dadgum.com/29.html">Original</a>
    <h1>A Spellchecker Used to Be a Major Feat of Software Engineering</h1>
    
    <div id="readability-page-1" class="page"><div id="c1"><p>Here&#39;s the situation: it&#39;s 1984, and you&#39;re assigned to write the spellchecker for a new MS-DOS word processor.  Some users, but not many, will have 640K of memory in their PCs.  You need to support systems with as little as 256K.  That&#39;s a quarter megabyte to contain the word processor, the document being edited, and the memory needed by the operating system.  Oh, and the spellchecker.</p><p>For reference, on my MacBook, the standard dictionary in <code>/usr/share/dict/words</code> is 2,486,813 bytes and contains 234,936 words.</p><p>An enticing first option is a data format that&#39;s more compressed than raw text.  The UNIX dictionary contains <i>stop</i> and <i>stopped</i> and <i>stopping</i>, so there&#39;s a lot of repetition.  A clever trie implementation might do the trick...but we&#39;ll need a big decrease to go from 2+ megabytes to a hundred K or so.</p><p>In fact, even if we could represent each word in the spellchecker dictionary as a single byte, we need almost all the full 256K just for that, and of course the single byte representation isn&#39;t going to work.  So not only does keeping the whole dictionary in RAM look hopeless, but so does keeping the actual dictionary on disk with only an index in RAM.</p><p>Now it gets messy.  We could try taking a subset of the dictionary, one containing the most common words, and heavily compressing that so it fits in memory.  Then we come up with a slower, disk-based mechanism for looking up the rest of the words.  Or maybe we jump directly to a completely disk-based solution using a custom database of sorts (remembering, too, that we can&#39;t assume the user has a hard disk, so the dictionary still needs to be crunched onto a 360K floppy disk).</p><p>On top of this, we need to handle some other features, such as the user adding new words to the dictionary.</p><p>Writing a spellchecker in the mid-1980s was a hard problem.  Programmers came up with some impressive data compression methods in response to the spellchecker challenge.  Likewise there were some very clever data structures for quickly finding words in a compressed dictionary.  This was a problem that could take months of focused effort to work out a solution to.  (And, for the record, reducing the size of the dictionary from 200,000+ to 50,000 or even 20,000 words was a reasonable option, but even that doesn&#39;t leave the door open for a naive approach.)</p><p>Fast forward to today.  A program to load <code>/usr/share/dict/words</code> into a hash table is 3-5 lines of Perl or Python, depending on how terse you mind being.  Looking up a word in this hash table dictionary is a trivial expression, one built into the language.  <i>And that&#39;s it.</i>  Sure, you could come up with some ways to decrease the load time or reduce the memory footprint, but that&#39;s icing and likely won&#39;t be needed.  The basic implementation is so mindlessly trivial that it could be an exercise for the reader in an early chapter of any Python tutorial.</p><p>That&#39;s progress.</p><p><a href="https://prog21.dadgum.com/29.html" id="perm">permalink</a> <i>June 8, 2008</i></p><ul><li><a href="https://prog21.dadgum.com/28.html">Coding as Performance</a></li><li><a href="https://prog21.dadgum.com/27.html">Don&#39;t Be Afraid of Special Cases</a></li><li><a href="https://prog21.dadgum.com/26.html">Purely Functional Retrogames, Part 4</a></li><li><a href="https://prog21.dadgum.com/25.html">Purely Functional Retrogames, Part 3</a></li><li><a href="https://prog21.dadgum.com/24.html">Purely Functional Retrogames, Part 2</a></li></ul></div></div>
  </body>
</html>
