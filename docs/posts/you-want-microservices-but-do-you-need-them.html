<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.docker.com/blog/do-you-really-need-microservices/">Original</a>
    <h1>You want microservices, but do you need them?</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Do you know who managed to cut costs by a staggering 90% by <a href="https://web.archive.org/web/20230505213415/https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90" id="dkr_abandoning-microservices-for-a-monolith-83395" rel="nofollow noopener" target="_blank">abandoning microservices for a monolith</a> in May 2023? Not a cash-strapped startup or an indie project—<strong>Amazon itself</strong>, for its Prime Video service. The same AWS that earns <a href="https://www.datacenterdynamics.com/en/news/aws-achieves-123bn-annualized-revenue-run-rate-capex-for-the-year-set-to-exceed-118bn/" id="dkr_billions-every-year-83395" rel="nofollow noopener" target="_blank">billions every year</a> by selling microservices infrastructure admitted that, sometimes, a good old monolith wins. </p>



<p>This reversal from the company that practically wrote the playbook on distributed systems sent shockwaves through the cloud-native community. Amazon later removed the original blog post, but the internet never forgets, as you’ll see later.</p>







<p>I’ve been <a href="https://x.com/_zenman/status/1224557249906999296" id="dkr_speaking-up-against-unnecessary-or-premature-use-of-microservices-architecture-83395" rel="nofollow" target="_blank">speaking up against unnecessary or premature use of microservices architecture</a> for five, six years now. After Amazon Prime Video went back to a monolith, I came across several eminent architects who are also speaking against microservices as default.</p>







<p>And yet in most tech circles, microservices are still viewed as the only way to build modern software. They dominate conferences, blogs, and job listings. Teams adopt them not because their requirements justify it, but because it feels like the obvious (and résumé-boosting) choice. “Cloud-native” has become synonymous with “microservices-by-default”, as if other approaches are as obsolete as floppy disks. </p>







<p>Microservices <strong>do</strong> solve real problems, but at a massive scale. Most teams don’t actually operate at that scale.</p>











<h2>Microservices: The Agility-Complexity Trade-Off</h2>







<p>On paper, microservices look impressive. Instead of one big monolith, you split your application into many small services. Each one can be written in any language, owned by a small team, and deployed on its own schedule. If you need more capacity, you can scale only the part that’s under load. The promise is elegant: independent deployability, autonomous teams, multi-language stacks, and elastic scaling.</p>







<p>But the catch is that every split creates a seam, and every seam is a potential failure point. Inside a monolith, function calls are instant and predictable. Across services, those same calls become network requests: slower, failure-prone, sometimes returning inconsistent data. With dozens (or hundreds) of services, you need version management, schema evolution, distributed transactions, tracing, centralized logging, and heavy-duty CI/CD pipelines just to keep things running.</p>







<p>This <a href="https://thenewstack.io/miniservices-a-realistic-alternative-to-microservices/" id="dkr_gartner-diagram-83395" rel="nofollow noopener" target="_blank">Gartner diagram</a> captures the trade-off perfectly: microservices exchange the simplicity of one codebase for the complexity of many.</p>









<p><img fetchpriority="high" decoding="async" width="1024" height="563" src="https://www.docker.com/app/uploads/2025/11/microservices-gartner.jpg" alt="microservices gartner" srcset="https://www.docker.com/app/uploads/2025/11/microservices-gartner.jpg 1024w, https://www.docker.com/app/uploads/2025/11/microservices-gartner-546x300.jpg 546w" sizes="(max-width: 1024px) 100vw, 1024px" title="- microservices gartner"/>
    </p>







<p>At a massive scale (think Netflix), that trade-off may be worth it. But when operational benefits don’t outweigh the costs, teams end up paying a steep price in debugging, coordination, and glue code just to hold their product together.</p>







<p>Microservices make sense in very specific scenarios <em>where distinct business capabilities need independent scaling and deployment</em>. For example, <strong>payment processing</strong> (security-critical, rarely updated) differs fundamentally from <strong>recommendation engine</strong> (memory-intensive, constantly A/B tested). These components have different scaling patterns, deployment cycles, and risk profiles, which justify separate services.</p>







<p>The success of microservices hinges on clear business domain boundaries that match your team structure, as <a href="https://martinfowler.com/bliki/ConwaysLaw.html" id="dkr_conways-law-83395" rel="nofollow noopener" target="_blank">Conway’s Law</a> predicts. If your organization naturally splits into autonomous teams that own distinct capabilities, microservices might work. (So, most <strong>“one-and-a-half pizza”</strong> startups don’t qualify, do they?) </p>







<p>That’s why microservices work effectively for companies like Amazon and Uber—although <strong>not always</strong>.</p>







<p>In fact, most organizations lack the prerequisites: dedicated service ownership, mature CI/CD, robust monitoring, and crucially, <em>scale that justifies the operational overhead</em>. Startups that adapt microservices prematurely often <a href="https://www.indiehackers.com/post/why-we-replaced-our-microservices-with-a-monolith-and-it-worked-NEec3alGYvYoRLHjgrGv" id="dkr_regret-their-decision-83395" rel="nofollow noopener" target="_blank">regret their decision</a>.</p>







<p>So ask yourself:</p>







<p>Are you using microservices to solve an independent scaling problem, or are you inviting more complexity than your solution needs?</p>







<h2>The Great Microservices Reversal</h2>







<p>Ironically, even though tech giants are the ones that are most likely to benefit from microservices, many of these very same companies are walking back their microservices architectures, and the results are eye-opening.</p>







<h3>Amazon Prime Video: 90% Cost Reduction with a Monolith</h3>







<p>In May 2023, Amazon engineers admitted the unthinkable: Prime Video had abandoned microservices for a monolith. Their Video Quality Analysis (VQA) team had built what looked like a textbook distributed system: AWS Step Functions and Lambda monitored thousands of video streams through independent, scalable components. On paper, it was serverless perfection.</p>







<p>In practice, it was a disaster. “We realized that distributed approach wasn’t bringing a lot of benefits in our specific use case,” said <a href="https://web.archive.org/web/20230505213415/https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90" id="dkr_marcin-kolny-in-the-now-archived-prime-video-engineering-blog-83395" rel="nofollow noopener" target="_blank">Marcin Kolny in the now-archived Prime Video Engineering blog</a>. Their “infinitely scalable” system <strong>crumbled at just 5% of expected load</strong> due to orchestration overhead.</p>







<p>The fix was embarrassingly simple: collapse everything into a single process. It resulted in <em>90% lower costs and faster performance</em>. </p>







<h3>Twilio Segment: From 140 Services to One Fast Monolith</h3>







<p>Back in 2018, Twilio Segment, a customer data platform, documented a similar reversal in their brutally honest post <a href="https://www.twilio.com/en-us/blog/developers/best-practices/goodbye-microservices" id="dkr_goodbye-microservices-83395" rel="nofollow noopener" target="_blank">“Goodbye Microservices”</a>.</p>







<p>Their system had sprawled into 140+ services, creating operational chaos. At one point, three full-time engineers spent most of their time firefighting instead of building. As they admitted, “Instead of enabling us to move faster, the small team found themselves mired in exploding complexity. Essential benefits of this architecture became burdens. As our velocity plummeted, our defect rate exploded.”</p>







<p>Their solution was radical but effective: collapse all 140+ services into a single monolith. The impact was immediate. Test suites that once took an hour now finished in milliseconds. Developer productivity soared: they shipped 46 improvements to shared libraries in a year, up from 32 in the microservices era. </p>







<h3>Shopify: Sanity over Hype</h3>







<p>Shopify runs one of the largest Ruby on Rails codebases in the world (2.8M+ lines). Instead of chasing microservices, they deliberately chose a <a href="https://shopify.engineering/shopify-monolith" id="dkr_modular-monolith-83395" rel="nofollow noopener" target="_blank">modular monolith</a>: a single codebase with clear component boundaries.</p>







<p>Shopify’s engineers concluded that “microservices would bring their own set of challenges”, so they chose modularity without the operational overhead.</p>







<p>All these examples beg the question:</p>







<p>If even the pioneers of microservices are retreating, why are we still treating it as gospel?</p>







<h2>Expert Voices against Microservices Mania</h2>







<p>Some of the most respected voices in software architecture—people behind many of the systems we all admire—are also cautioning against microservices and repeating mistakes they’ve seen play out at scale. (After all, cheerleaders don’t play the game; cloud DevRels rarely build at scale.)</p>







<h3>Rails Creator: Simplicity over Sophistication</h3>







<p><a href="https://en.wikipedia.org/wiki/David_Heinemeier_Hansson" id="dkr_david-heinemeier-hansson-83395" rel="nofollow noopener" target="_blank">David Heinemeier Hansson</a> (DHH), the creator of Ruby on Rails, has long advocated simplicity over architectural trends. His <a href="https://world.hey.com/dhh/even-amazon-can-t-make-sense-of-serverless-or-microservices-59625580" id="dkr_analysis-of-the-amazon-prime-video-reversal-83395" rel="nofollow noopener" target="_blank">analysis of the Amazon Prime Video reversal</a> puts it bluntly:</p>







<p><strong>“The real-world results of all this theory are finally in, and it’s clear that in practice, microservices pose perhaps the biggest siren song for needlessly complicating your system.”</strong></p>







<p>DHH’s image of a siren song is apt: microservices promise elegance but leave teams wrecked on the rocks of complexity.</p>







<h3>Microservices: Mistake of The Decade?</h3>







<p><a href="https://threadreaderapp.com/thread/1592227285024636928.html" id="dkr_jason-warner-former-cto-of-github-83395" rel="nofollow noopener" target="_blank">Jason Warner, former CTO of GitHub</a>, doesn’t mince words while commenting on microservices: </p>







<p><strong>“I’m convinced that one of the biggest architectural mistakes of the past decade was going full microservice.”</strong></p>







<p>Warner understands scale: GitHub runs at internet scale, and he’s led engineering at Heroku and Canonical. His critique cuts deeper because it’s lived experience, beyond <a href="https://www.martinfowler.com/bliki/MicroservicePremium.html#:~:text=The%20majority%20of%20software%20systems%20should%20be%20built%20as%20a%20single%20monolithic%20application" id="dkr_theoretical-advice-83395" rel="nofollow noopener" target="_blank">theoretical advice</a>:</p>







<p><strong>“90% of all companies in the world could probably just be a monolith running against a primary db cluster with db backups, some caches and proxies and be done with it.”</strong></p>







<h3>GraphQL Co-Creator: “Don’t”</h3>







<p>Then there’s <a href="https://www.linkedin.com/in/schrockn/" id="dkr_nick-schrock-co-creator-of-graphql-83395" rel="nofollow noopener" target="_blank">Nick Schrock, co-creator of GraphQL</a>. If anyone had a reason to cheer for distributed systems, it’d be him. Instead, he says:</p>







<p><strong>“Microservices are such a fundamentally and catastrophically bad idea that there are going to be an entire cohort of multi-billion companies built that do nothing but contain the damage that they have wrought.”</strong></p>









<p><img decoding="async" width="621" height="256" src="https://www.docker.com/app/uploads/2025/11/microservices-bad-idea-Graph-QL-cocreator.png" alt="microservices bad idea Graph QL cocreator" title="- microservices bad idea Graph QL cocreator"/>
    </p>







<p>He goes on to describe microservices as <a href="https://x.com/schrockn/status/1130567665548873728" id="dkr_organizational-gambles-83395" rel="nofollow" target="_blank">organizational gambles</a>:</p>







<p><strong>“[Y]ou end up with these services that you have to maintain forever that match the org structure and the product requirements from five years ago. Today, they don’t make a lot of sense.”</strong></p>







<p>The person who literally built tools to fix distributed system pain says <strong>don’t distribute unless you must</strong>, maybe it’s time to listen.</p>







<h3>Other Voices Questioning Microservice Maximalism</h3>







<p>Other engineering leaders are also reconsidering microservice maximalism. </p>







<p>At Uber, <a href="https://x.com/GergelyOrosz/status/1247132806041546754" id="dkr_gergely-orosz-admitted-83395" rel="nofollow" target="_blank">Gergely Orosz admitted</a>:</p>







<p><strong>“We’re moving many of our microservices to macroservices (well-sized services). Exactly b/c testing and maintaining thousands of microservices is not only hard – it can cause more trouble long-term than it solves the short-term.”</strong></p>







<p>Uber still runs microservices where they’re justified, but they’re <a href="https://www.youtube.com/watch?v=kb-m2fasdDY&amp;t=430s" id="dkr_choosing-their-battles-83395" rel="nofollow noopener" target="_blank">choosing their battles</a>.</p>







<p><a href="https://en.wikipedia.org/wiki/Kelsey_Hightower" id="dkr_kelsey-hightower-83395" rel="nofollow noopener" target="_blank">Kelsey Hightower</a>, known for his work with Kubernetes and Google Cloud, cut through the microservices hype with CS101:</p>







<p><strong>“I’m willing to wager a monolith will outperform every microservice architecture. Just do the math on the network latency between each service and the amount of serialization and deserialization of each request.”</strong></p>







<p>He subsequently deleted this tweet, but the network math still grades microservices.</p>







<p>When pioneers like these, including those who actually solved distributed systems at scale, start waving red flags, it’s worth taking note. </p>







<p>My question here is:</p>







<p>If GitHub’s CTO thinks 90% of companies don’t need microservices, are you sure yours is part of the 10%?</p>







<h2>The Hidden Costs of Microservices</h2>







<p>Microservices demand such caution because of these hidden costs that teams often underestimate.</p>







<h3>Operational Costs</h3>







<p>A monolith is simple: in-process function calls. </p>







<p>Microservices replace that with networks. Every request now travels across machines, through load balancers, service meshes, and authentication layers, creating more failure points and infrastructure needs. You suddenly need service discovery (how services find each other), distributed tracing (tracking requests across services), centralized logging (aggregating logs from multiple services), and monitoring systems that understand service topology.</p>







<p>Each of these is necessary, but together they’re complex and expensive. Duplicated data requires extra storage. Constant service-to-service calls rack up network egress fees. Cloud <a href="https://www.reddit.com/r/ProgrammerHumor/comments/xkadmh/150k_bill/" id="dkr_costs-scale-faster-83395" rel="nofollow noopener" target="_blank">costs scale faster</a> than the apps they host. Prime Video’s workflow <a href="https://www.wudsn.com/productions/www/site/news/2023/2023-05-08-microservices-01.pdf" id="dkr_spent-more-on-orchestrating-s3-data-transfers-83395" rel="nofollow noopener" target="_blank">spent more on orchestrating S3 data transfers</a> between services than on actual processing. </p>







<h3>Developer Productivity Drain</h3>







<p>In microservices, the hard part isn’t writing code; it’s navigating distributed system interactions.</p>







<p>In “<a href="https://stackoverflow.blog/2020/11/23/the-macro-problem-with-microservices/" id="dkr_the-macro-problem-with-microservices-83395" rel="nofollow noopener" target="_blank">The macro problem with microservices</a>“, Stack Overflow identifies a critical productivity drain: distributed state forces developers to write defensive code that constantly checks for partial failures. </p>







<p>In a monolith, a developer can follow a code path end-to-end within one repo. In microservices, one feature might span four or five repos with different dependencies and deploy cycles. Adding a single field triggers weeks of coordination: you need to update one service, then wait for consumers to adopt, version your APIs, manage rollouts, and so on. Different teams will also typically maintain different microservices using different tech stacks, so there’s a risk that they unintentionally break something as well. Breaking changes that a compiler would catch in a monolith now surface as runtime errors in production.</p>







<h3>Testing and Deployment Complexity</h3>







<p>Monolith integration and end-to-end tests are faster because they run locally, in memory. Distributed systems don’t allow that luxury: real confidence requires integration and end-to-end tests across numerous service boundaries. So these tests are slower, more brittle, and require staging environments that resemble production, all of which effectively double infrastructure costs and slow feedback loops.</p>







<p>Many teams discover this only after their <a href="https://www.craigkerstiens.com/2019/03/13/give-me-back-my-monolith/#:~:text=%20now%20to%20really%20test%20my%20service%20I%20have%20to" id="dkr_test-suite-becomes-a-bottleneck-83395" rel="nofollow noopener" target="_blank">test suite becomes a bottleneck</a>. Deployment orchestration adds another layer. Rolling updates across interdependent services require careful sequencing to avoid breaking contracts. Version incompatibility disturbs frequently: Service A works with Service B v2.1 but breaks with v2.2.</p>







<p>Failed deployments leave systems partially updated and difficult to recover.</p>







<h3>Data Management and Consistency</h3>







<p>The most underestimated complexity of microservices lies in data consistency across service boundaries.</p>







<p>Monoliths benefit from ACID transactions: operations complete entirely or fail entirely. Microservices split that across services, forcing you to build <a href="https://cs.brown.edu/courses/csci2952-f/slides/Class16.pdf" id="dkr_distributed-saga-83395" rel="nofollow noopener" target="_blank">distributed saga</a> (multi-step workflows with rollback logic), live with <a href="https://en.wikipedia.org/wiki/Eventual_consistency" id="dkr_eventual-consistency-83395" rel="nofollow noopener" target="_blank">eventual consistency</a> (data only becomes correct after a delay), or write <a href="https://softwarepatternslexicon.com/101/12/24/" id="dkr_compensation-logic-83395" rel="nofollow noopener" target="_blank">compensation logic</a> (extra code to undo partial failures). What was once a single database transaction now spans network hops, retries, and partial failures. Debugging inconsistent orders or payments gets much harder when state is duplicated across services. </p>







<p>As <a href="https://arxiv.org/pdf/2103.00170" id="dkr_research-confirms-83395" rel="nofollow noopener" target="_blank">research confirms</a>, data duplication, correctness challenges, and transactional complexity are the top pain points in microservice systems.</p>







<h3>The Compounding Effect</h3>







<p>These complexities multiply. Operational overhead makes debugging harder, which slows testing, which makes deployments riskier, which creates more incidents. Microservices don’t just shift complexity from code to operations; they tax every part of your engineering process. </p>







<p>Unless your scale demands it, that tax often outweighs the benefits. </p>







<p>Think about it:</p>







<p>If every network hop adds complexity and cost, does your use case really justify the price?</p>







<h2>Beyond Microservices: Smarter Architectural Alternatives</h2>







<p>Before defaulting to microservices, it’s worth considering how simpler, well-structured architectures can deliver comparable scalability without the distributed complexity tax. Two noteworthy alternatives are modular monoliths and service-oriented architectures.</p>







<h3>Modular Monoliths: Structure without Distribution</h3>







<p>Unlike traditional monoliths that become tangled messes, <a href="https://www.geeksforgeeks.org/system-design/what-is-a-modular-monolith/" id="dkr_modular-monoliths-83395" rel="nofollow noopener" target="_blank">modular monoliths</a> enforce strict internal boundaries through clear module APIs and disciplined separation. Each module exposes well-defined interfaces, enabling teams to work independently while deploying a single, coherent system.</p>









<p><img decoding="async" width="1137" height="839" src="https://www.docker.com/app/uploads/2025/11/modular-monolith-architecture.png" alt="modular monolith architecture" srcset="https://www.docker.com/app/uploads/2025/11/modular-monolith-architecture.png 1137w, https://www.docker.com/app/uploads/2025/11/modular-monolith-architecture-407x300.png 407w, https://www.docker.com/app/uploads/2025/11/modular-monolith-architecture-1110x819.png 1110w" sizes="(max-width: 1137px) 100vw, 1137px" title="- modular monolith architecture"/>
    </p>







<p>As Kent Beck explains in <a href="https://medium.com/%40kentbeck_7670/monolith-services-theory-practice-617e4546a879" id="dkr_monolith---services-theory--practice-83395" rel="nofollow noopener" target="_blank">“Monolith -&gt; Services: Theory &amp; Practice”</a>, modular monoliths manage coupling through organizational discipline rather than distributed networks. The key difference: modules still communicate via explicit contracts like microservices, but they use fast, reliable function calls instead of HTTP requests that are vulnerable to network latency and partial failures.</p>







<p>Why does it work?</p>







<ul>
<li><em>Simpler operations</em>: microservices-level organization with monolithic simplicity</li>



<li><em>Stronger consistency</em>: full ACID transactions</li>



<li><em>Easier debugging</em>: one traceable system, no hunting for bugs in the <a href="https://aws.amazon.com/what-is/elk-stack/" rel="nofollow noopener" target="_blank">ELK</a> haystack</li>



<li><em>Better performance</em>: function calls beat network hops</li>
</ul>







<p>Here’s some real-world proof: Shopify’s 2.8 million-line codebase <a href="https://newsletter.systemdesign.one/p/modular-monolith#:~:text=Shopify%20Handled%2030TB%20per%20Minute" id="dkr_handles-30tb-per-minute-83395" rel="nofollow noopener" target="_blank">handles 30TB per minute</a> with separate teams owning distinct modules, yet everything deploys together. Facebook runs similarly. (And principal architect <a href="https://www.youtube.com/watch?v=sLEuXDgfAS4&amp;t=3880s" id="dkr_keith-adams-jokes-83395" rel="nofollow noopener" target="_blank">Keith Adams jokes</a> that if you want to be talked <strong>out</strong> of microservices, he’s your guy.)</p>







<p>With recent developments in frameworks like <a href="https://spring.io/projects/spring-modulith" id="dkr_spring-modulith-83395" rel="nofollow noopener" target="_blank">Spring Modulith</a>, <a href="https://makimo.com/blog/modular-monolith-in-django/" id="dkr_django-83395" rel="nofollow noopener" target="_blank">Django</a>, <a href="https://dev.to/abstractmusa/modular-monolith-architecture-within-laravel-communication-between-different-modules-a5" id="dkr_laravel-83395" rel="nofollow noopener" target="_blank">Laravel</a>, and <a href="https://dev.to/alex_aslam/modular-monoliths-in-rails-taming-complexity-without-microservices-madness-30nj" id="dkr_rails-83395" rel="nofollow noopener" target="_blank">Rails</a> (as seen at scale with Shopify), modular monoliths are poised to <a href="https://news.ycombinator.com/item?id=41534179" id="dkr_gain-wider-traction-83395" rel="nofollow noopener" target="_blank">gain wider traction</a> in the years ahead.</p>







<h3>Service-Oriented Architecture: The Middle Ground</h3>







<p><a href="https://www.geeksforgeeks.org/software-engineering/service-oriented-architecture/" id="dkr_service-oriented-architecture-soa-83395" rel="nofollow noopener" target="_blank">Service-oriented architecture (SOA)</a> sits between monoliths and microservices, favoring larger, domain-driven services instead of dozens or hundreds of tiny ones. These services often communicate via an enterprise service bus (ESB), which reduces orchestration overhead while preserving separation of concerns.</p>









<p><img decoding="async" width="1137" height="839" src="https://www.docker.com/app/uploads/2025/11/service-oriented-acrhitecture.png" alt="service oriented acrhitecture" srcset="https://www.docker.com/app/uploads/2025/11/service-oriented-acrhitecture.png 1137w, https://www.docker.com/app/uploads/2025/11/service-oriented-acrhitecture-407x300.png 407w, https://www.docker.com/app/uploads/2025/11/service-oriented-acrhitecture-1110x819.png 1110w" sizes="(max-width: 1137px) 100vw, 1137px" title="- service oriented acrhitecture"/>
    </p>







<p>Instead of splitting authentication, user preferences, and notifications into separate microservices, SOA might combine them into a single “User Service”, simplifying coordination while preserving autonomy and targeted scaling. SOA provides enterprise-grade modularity without ultra-fine-grained distribution overhead.</p>







<p>Here’s why it works:</p>







<ul>
<li><em>Right-sized boundaries</em>: fewer, domain-aligned services instead of sprawl</li>



<li><em>Targeted scalability</em>: scale services tied to real business domains</li>



<li><em>Pragmatic complexity</em>: avoids ultra-fine-grained overhead while retaining modular reasoning</li>
</ul>







<p>SOA has also been proven to work at scale. Norwegian Air Shuttle, Europe’s 9th-largest airline, <a href="https://www.researchgate.net/publication/254028496_A_Successful_Implementation_of_Service_Oriented_Architecture" id="dkr_used-soa-83395" rel="nofollow noopener" target="_blank">used SOA</a> to boost agility across complex flight operations. Credit Suisse’s <a href="https://www.infoq.com/articles/service-oriented-architecture-at-credit-suisse/" id="dkr_soa-rollout-83395" rel="nofollow noopener" target="_blank">SOA rollout</a> powered millions of service calls per day back in the early 2000s.</p>







<h3>Choosing Wisely: Fit over Hype</h3>







<p>The problem you’re solving should justify your architecture.</p>







<p>I often use this analogy in consulting: <strong>You don’t need a sword to cut a lemon—a knife suffices. </strong>And as timeless wisdom reminds us, simplicity is the ultimate sophistication. </p>







<p>In all likelihood, <a href="https://blog.bradfieldcs.com/you-are-not-google-84912cf44afb" id="dkr_youre-not-google-83395" rel="nofollow noopener" target="_blank">you’re not Google</a> (you don’t need Google-level fault tolerance), or Amazon (you don’t need massive write availability), or LinkedIn (you don’t handle billions of events a day). Most applications don’t operate at that scale, demanding fundamentally different solutions than ultra-distributed architectures.</p>







<p>For most systems, well-structured modular monoliths (for most common applications, including startups) or SOA (enterprises) deliver comparable scalability and resilience as microservices, without the distributed complexity tax. Alternatively, you may also consider well-sized services (<a href="https://x.com/copyconstruct/status/1247131341851783168" id="dkr_macroservices-83395" rel="nofollow" target="_blank"><strong>macroservices</strong></a>, or what Gartner proposed as <a href="https://thenewstack.io/miniservices-a-realistic-alternative-to-microservices/#:~:text=%5BA%20miniservice%20is%5D%20like%20a%20group%20of%20microservices" id="dkr_miniservices-83395" rel="nofollow noopener" target="_blank"><strong>miniservices</strong></a>) instead of tons of microservices.</p>







<p>It’s worth asking:</p>







<p>If simpler architectures can deliver comparable scalability, why are you choosing the complexity of microservices?</p>







<h2>Docker: Built for Any Architecture</h2>







<p><a href="https://www.docker.com/" id="dkr_docker-83395">Docker</a> isn’t just for microservices—it <a href="https://www.docker.com/blog/are-containers-only-for-microservices-myth-debunked/" id="dkr_works-great-across-all-kinds-of-architectures-83395">works great across all kinds of architectures</a> like monoliths, SOA, APIs, and event-driven systems. The real benefit is that Docker gives you consistent performance, easier deployment, and flexibility to scale up your apps no matter what architectural approach you’re using.</p>







<p>Docker packages applications cleanly, keeps environments consistent from laptop to production, simplifies dependency management, and isolates applications from the host system. A Dockerized monolith offers all these benefits, minus the orchestration overhead of microservices. </p>







<p><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/containerize-monolithic-applications" id="dkr_microsofts-guidance-on-containerizing-monoliths-83395" rel="nofollow noopener" target="_blank">Microsoft’s guidance on containerizing monoliths</a> clarifies that scaling containers is “far faster and easier than deploying additional VMs”, whether you run one service or fifty. <a href="https://web.archive.org/web/20250319065616/https://segment.com/blog/monoliths-microservices-and-containers/" id="dkr_twilio-segment-observed-83395" rel="nofollow noopener" target="_blank">Twilio Segment observed</a> that containerized monoliths can “horizontally scale your environment easily by spinning up more containers and shutting them down when demand subsides.” For many applications, scaling the whole app is exactly what’s needed.</p>







<p>As for DevOps, a monolith in Docker is lighter to operate than a full-blown microservices setup. <a href="https://docs.docker.com/engine/logging/configure/" id="dkr_logging-aggregation-83395" rel="nofollow noopener" target="_blank">Logging aggregation</a> becomes simpler when you’re collecting from identical containers rather than disparate services with different formats. Monitoring and debugging remain centralized, and troubleshooting avoids tracing requests across service boundaries.</p>







<p>So, it’s definitely worth considering:</p>







<p>Even without the complexity of microservices, Docker gives you the same advantages — clean deployments, easy scaling, and consistent environments. So why not keep it?</p>







<h2>Wrapping Up</h2>







<p>A few years ago, my then-8-year-old wanted a bicycle. He’d mostly ride around our apartment complex, maybe venture into the nearby lane. He didn’t <strong>need</strong> 21 gears, but those shiny shifters had him smitten—imagine riding faster by changing those gears! He absolutely <strong>wanted</strong> that mechanically complex beauty. (It’s hard to argue with a starry-eyed kid… or a founder :P).</p>







<p>Once he started riding the new bike, the gears slipped, the chain jammed, and the bicycle spent more time broken than on the road. Eventually, we had to dump it. </p>







<p>I wasn’t able to convince him back then that a simpler bicycle could’ve served him better, but maybe this article will convince a few grown-ups making architectural decisions.</p>







<p>We techies love indulging in complex systems. (Check: were you already thinking, <strong>What’s complex about bicycles with gears??</strong>) But the more moving parts you add, the more often they break. Complexity often creates more problems than it solves.</p>







<p>The point I’m making isn’t to dump microservices entirely—it’s to pick an architecture that fits your actual needs, not what the cloud giant is pushing (while quietly rolling back their own <strong>commit</strong>). Most likely, modular monoliths or well-designed SOA will serve your needs better and make your team more productive.</p>







<p>So here’s the million-dollar question: </p>







<p>Will you design for cloud-native hype or for your own business requirements?</p>







<p>Do you really need microservices?</p>




</div></div>
  </body>
</html>
