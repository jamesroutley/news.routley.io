<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://oxide.computer/blog/lpc55s69-tzpreset">Original</a>
    <h1>A Gap in the TrustZone preset settings for the LPC55S69</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div id="content"><div id="preamble"><div><p>We’re very excited to have <a href="https://oxide.computer/blog/the-cloud-computer">announced</a>
the general availability of our cloud computer. As part of this work, we
continue to build on top of the LPC55S69 from NXP as our Root of Trust. We’ve
discovered some gaps when using TrustZone preset settings on the LPC55S69 that
can allow for unexpected behavior including enabling debug settings and
exposure of the UDS (Unique Device Secret). These issues require a signed
image or access at manufacturing time.</p></div></div><div><h2 data-sectnum="">How to (safely, securely) configure a chip</h2><div><p>The LPC55S69 uses the <a href="https://developer.arm.com/documentation/ddi0553/latest">Armv8-m</a>
architecture which includes TrustZone-M. We’ve <a href="https://oxide.computer/blog/exploiting-undocumented-hardware-blocks-in-the-lpc55s69">previously</a>
discussed some aspects of the Armv8-m architecture and <a href="https://media.defcon.org/DEF%20CON%2029/DEF%20CON%2029%20video%20and%20slides/DEF%20CON%2029%20-%20Laura%20Abbott%20Rick%20Altherr%20-%20Breaking%20TrustZone-M%20-%20Privilege%20Escalation%20on%20LPC55S69.mp4">presented</a>
on it in more detail. Fundamentally, setting up TrustZone-M is simply a matter
of putting the right values in the right registers. The word &#34;simply&#34; is, of
course, doing a lot of heavy lifting here. TrustZone-M must also be set up
in conjunction with the Memory Protection Unit (MPU) and any other vendor
specific security settings. Once the ideal settings have been decided upon,
there’s still the matter of actually performing the register programming
sequence. NXP offers a feature called TrustZone preset data to make this
programming easier. Register data may optionally be appended to the end of
an image for the LPC55S69, and the ROM will set the registers before jumping
into the user image. Some of those registers may also be configured to
prevent futher modification. This means the user image does not need to be
concerned with the settings for those registers.</p><p>The structure used to configure the registers looks like the <a href="https://github.com/nxp-mcuxpresso/spsdk/blob/09c711a8fd4c54f126a7dfe1b3ae8bb361c5473e/spsdk/data/tz_presets/lpc55s6x.yaml">following</a>:</p><div><div><pre><code data-lang="c"><span>typedef</span> <span><span>struct</span> _<span>tzm_secure_config</span>
{</span>
  <span>uint32_t</span> cm33_vtor_addr;  
  <span>uint32_t</span> cm33_vtor_ns_addr; 
  <span>uint32_t</span> cm33_nvic_itns0; 
  <span>uint32_t</span> cm33_nvic_itns1; 
  <span>uint32_t</span> mcm33_vtor_addr; 
  <span>uint32_t</span> cm33_mpu_ctrl; 
  <span>uint32_t</span> cm33_mpu_mair0; 
  <span>uint32_t</span> cm33_mpu_mair1; 
  <span>uint32_t</span> cm33_mpu_rbar0; 
  <span>uint32_t</span> cm33_mpu_rlar0; 
  <span>uint32_t</span> cm33_mpu_rbar1; 
  <span>uint32_t</span> cm33_mpu_rlar1; 
  <span>uint32_t</span> cm33_mpu_rbar2; 
  <span>uint32_t</span> cm33_mpu_rlar2; 
  <span>uint32_t</span> cm33_mpu_rbar3; 
  <span>uint32_t</span> cm33_mpu_rlar3; 
  <span>uint32_t</span> cm33_mpu_rbar4; 
  <span>uint32_t</span> cm33_mpu_rlar4; 
  <span>uint32_t</span> cm33_mpu_rbar5; 
  <span>uint32_t</span> cm33_mpu_rlar5; 
  <span>uint32_t</span> cm33_mpu_rbar6; 
  <span>uint32_t</span> cm33_mpu_rlar6; 
  <span>uint32_t</span> cm33_mpu_rbar7; 
  <span>uint32_t</span> cm33_mpu_rlar7; 
  <span>uint32_t</span> cm33_mpu_ctrl_ns; 
  <span>uint32_t</span> cm33_mpu_mair0_ns; 
  <span>uint32_t</span> cm33_mpu_mair1_ns; 
  <span>uint32_t</span> cm33_mpu_rbar0_ns; 
  <span>uint32_t</span> cm33_mpu_rlar0_ns; 
  <span>uint32_t</span> cm33_mpu_rbar1_ns; 
  <span>uint32_t</span> cm33_mpu_rlar1_ns; 
  <span>uint32_t</span> cm33_mpu_rbar2_ns; 
  <span>uint32_t</span> cm33_mpu_rlar2_ns; 
  <span>uint32_t</span> cm33_mpu_rbar3_ns; 
  <span>uint32_t</span> cm33_mpu_rlar3_ns; 
  <span>uint32_t</span> cm33_mpu_rbar4_ns; 
  <span>uint32_t</span> cm33_mpu_rlar4_ns; 
  <span>uint32_t</span> cm33_mpu_rbar5_ns; 
  <span>uint32_t</span> cm33_mpu_rlar5_ns; 
  <span>uint32_t</span> cm33_mpu_rbar6_ns; 
  <span>uint32_t</span> cm33_mpu_rlar6_ns; 
  <span>uint32_t</span> cm33_mpu_rbar7_ns; 
  <span>uint32_t</span> cm33_mpu_rlar7_ns; 
  <span>uint32_t</span> cm33_sau_ctrl;
  <span>uint32_t</span> cm33_sau_rbar0;
  <span>uint32_t</span> cm33_sau_rlar0;
  <span>uint32_t</span> cm33_sau_rbar1;
  <span>uint32_t</span> cm33_sau_rlar1;
  <span>uint32_t</span> cm33_sau_rbar2;
  <span>uint32_t</span> cm33_sau_rlar2;
  <span>uint32_t</span> cm33_sau_rbar3;
  <span>uint32_t</span> cm33_sau_rlar3;
  <span>uint32_t</span> cm33_sau_rbar4;
  <span>uint32_t</span> cm33_sau_rlar4;
  <span>uint32_t</span> cm33_sau_rbar5;
  <span>uint32_t</span> cm33_sau_rlar5;
  <span>uint32_t</span> cm33_sau_rbar6;
  <span>uint32_t</span> cm33_sau_rlar6;
  <span>uint32_t</span> cm33_sau_rbar7;
  <span>uint32_t</span> cm33_sau_rlar7;
  <span>uint32_t</span> flash_rom_slave_rule;
  <span>uint32_t</span> flash_mem_rule0;
  <span>uint32_t</span> flash_mem_rule1;
  <span>uint32_t</span> flash_mem_rule2;
  <span>uint32_t</span> rom_mem_rule0;
  <span>uint32_t</span> rom_mem_rule1;
  <span>uint32_t</span> rom_mem_rule2;
  <span>uint32_t</span> rom_mem_rule3;
  <span>uint32_t</span> ramx_slave_rule;
  <span>uint32_t</span> ramx_mem_rule0;
  <span>uint32_t</span> ram0_slave_rule;
  <span>uint32_t</span> ram0_mem_rule0;
  <span>uint32_t</span> ram0_mem_rule1;
  <span>uint32_t</span> ram1_slave_rule; 
  <span>uint32_t</span> ram1_mem_rule1;
  <span>uint32_t</span> ram2_mem_rule1;
  <span>uint32_t</span> ram3_mem_rule0;
  <span>uint32_t</span> ram3_mem_rule1;
  <span>uint32_t</span> ram4_slave_rule;
  <span>uint32_t</span> ram2_mem_rule0;
  <span>uint32_t</span> ram3_slave_rule;
  <span>uint32_t</span> ram1_mem_rule0;
  <span>uint32_t</span> ram2_slave_rule;
  <span>uint32_t</span> ram4_mem_rule0;
  <span>uint32_t</span> apb_grp_slave_rule;
  <span>uint32_t</span> apb_grp0_mem_rule0;
  <span>uint32_t</span> apb_grp0_mem_rule1;
  <span>uint32_t</span> apb_grp0_mem_rule2;
  <span>uint32_t</span> apb_grp0_mem_rule3;
  <span>uint32_t</span> apb_grp1_mem_rule0;
  <span>uint32_t</span> apb_grp1_mem_rule1;
  <span>uint32_t</span> apb_grp1_mem_rule2;
  <span>uint32_t</span> apb_grp1_mem_rule3;
  <span>uint32_t</span> ahb_periph0_slave_rule0;
  <span>uint32_t</span> ahb_periph0_slave_rule1;
  <span>uint32_t</span> ahb_periph1_slave_rule0;
  <span>uint32_t</span> ahb_periph1_slave_rule1;
  <span>uint32_t</span> ahb_periph2_slave_rule0;
  <span>uint32_t</span> ahb_periph2_slave_rule1;
  <span>uint32_t</span> ahb_periph2_mem_rule0;
  <span>uint32_t</span> usb_hs_slave_rule0; 
  <span>uint32_t</span> usb_hs__mem_rule0; 
  <span>uint32_t</span> sec_gp_reg0;
  <span>uint32_t</span> sec_gp_reg1;
  <span>uint32_t</span> sec_gp_reg2;
  <span>uint32_t</span> sec_gp_reg3;
  <span>uint32_t</span> sec_int_reg0;
  <span>uint32_t</span> sec_int_reg1;
  <span>uint32_t</span> sec_gp_reg_lock;
  <span>uint32_t</span> master_sec_reg;
  <span>uint32_t</span> master_sec_anti_pol_reg;
  <span>uint32_t</span> cm33_lock_reg; 
  <span>uint32_t</span> mcm33_lock_reg; 
  <span>uint32_t</span> misc_ctrl_dp_reg;
  <span>uint32_t</span> misc_ctrl_reg;
  <span>uint32_t</span> misc_tzm_settings;
} <span>tzm_secure_config_t</span>;</code></pre></div></div><p>An implementation detail of the ROM is that the settings for these registers
are (mostly) applied in the order shown in the structure. This means that the
very first register that gets changed is <code>VTOR</code> which switches the vector
table from the one in the ROM to the user provided one. <strong>Any faults that
occur after <code>VTOR</code> is changed will be handled by user code, not ROM
code.</strong> This turns out to have some &#34;interesting&#34; side effects.</p></div></div><div><h2 data-sectnum="">(Un)locking debug access</h2><div><p>The LPC55S69 offers debug access via <a href="https://developer.arm.com/documentation/ihi0031/g/?lang=en">standard ARM interfaces (SWD)</a>.
Debug access can be configured to be always available, always disabled, or
only available to authenticated users. These settings are designed to be
applied at manufacturing time via the <a href="https://github.com/nxp-mcuxpresso/spsdk/blob/09c711a8fd4c54f126a7dfe1b3ae8bb361c5473e/spsdk/data/pfr/cmpa/lpc55s6x_1b.xml">CMPA</a> region.
Debugging is disabled by default while executing in the ROM and only enabled
(if allowed) as the very last step before jumping to user code. The debug
settings are also locked out, preventing further modification from user code
except in specific authenticated circumstances. Because debug access is highly
sensitive, it makes sense to minimize the amount of time the ROM spends with
it enabled.</p><p>If the debug settings are applied last, this means that the TrustZone preset
settings must be applied before them. Combine this information with the
implementation detail of how the preset setting are applied, <strong>if the code
faults after <code>VTOR</code> is changed but before we apply the debug settings, it
will be possible to run in user controlled code with debug registers open
for modification</strong>.</p><p>How easy is it to actually trigger this? Very easy. Other registers in the
preset structure include settings for the MPU. Setting the enable bit in
<code>MPU_CTRL</code> without any other regions set is enough to trigger
the fault. NXP actually says in their manual that you need to make sure
the entire ROM region is configured as secure privileged and executable
otherwise &#34;boot process will fail&#34;. &#34;fail&#34; in this case is vectoring off
into the appropriate fault handler of the user code.</p><p>This makes the following sequence possible:</p><div><ul><li><p>Have debug disabled in the CMPA</p></li><li><p>Sign an image with TrustZone preset settings with a valid <code>VTOR</code> and MPU
settings that exclude the ROM region</p></li><li><p>Have the <code>MemManage</code> fault handler follow the standard sequence to enable
debugging</p></li><li><p>The image will trigger the fault handler and have debugging enabled despite
the settings in the CMPA</p></li></ul></div><p>This does require access to the secure boot signing key, but it’s a departure
from the presentation of the CMPA settings as being independent of any
possible settings in an image.</p></div></div><div><h2 data-sectnum="">Extracting the UDS</h2><div><p>One additional step in the setting of the debug registers is a final lockout
of some PUF registers. The PUF (Physically Unclonable Function) is designed to
tie secrets to a specific chip. When a secret is PUF encoded, it can only
be decoded by that specific chip. The LPC55S69 uses the PUF to encode the
Unique Device Secret (UDS) for use as the basis of a <a href="https://trustedcomputinggroup.org/work-groups/dice-architectures/">DICE</a> identity.
To ensure the identity is tied to the specific chip and cannot be cloned,
access to the PUF index for the UDS is locked out after it is used.</p><p>The UDS is always locked out for secure boot images, but the ROM relies on
the code path for debug settings to lock out for non-secure images.
TrustZone preset settings can be used with non-secure CRC images which means
that the previously described issue can be used to extract the UDS since the
final lockout will never occur.</p><p>Requiring an unsigned image significantly limits the impact to
cases such as the following:</p><div><ul><li><p>Attacker at manufacturing time runs ISP command to generate the UDS on an
unprogrammed LPC55S69</p></li><li><p>Attacker runs an unsigned image with a buggy TrustZone preset to extract the
UDS</p></li><li><p>Attacker continues on with the rest of the manufacturing sequence, making
sure not to re-generate the extracted UDS</p></li></ul></div><p>This may be mitigated with sufficient tooling at manufacturing time but the
issue still remains.</p></div></div><div><h2 data-sectnum="">Is this a security issue?</h2><div><p>There was disagreement between Oxide and NXP about whether this qualified
as a true security vulnerability (Oxide’s opinion) vs. a gap in design and
documentation (NXP’s opinion). The areas of disagreement were related to what
exactly it was possible to do with these issues and what was
required to make them happen. Unlocking the debug ports requires access to the
secure boot signing keys and arguably if you can sign something with a bad
TrustZone preset you don’t need to bother with debug port access; once your
secure boot integrity has been compromised all bets are off. Oxide believes
this undersells the potential for mitigation and why this should be considered
a security issue: there could be circumstances where having debug port access
would make extracting assets significantly easier.</p><p>Transparency is an Oxide value and that is what we strive for in bug reporting.
Our goal is to make sure that issues are acknowledged and information about
the bug is made widely available. NXP agreed to acknowledge this issue as
a non-security errata and there will not be a CVE filed at this time. Given
the narrow scope and lack of agreement between Oxide and NXP, filing a CVE
would provide <a href="https://daniel.haxx.se/blog/2023/08/26/cve-2020-19909-is-everything-that-is-wrong-with-cves/">little benefit</a>.
If new information were to come to light from Oxide, NXP, or other
researchers who are interested in our findings, we would re-evaluate this
decision.</p><p>We are pleased that NXP is choosing to protect its customers by informing them
of this gap. A bigger takeaway from this issue is to understand the limitations
of secure/verified boot. A proper secure boot implementation will ensure that
the only code that runs on a device is code that has been signed with an
appropriate private key. Secure boot provides no assertions about the
implementation of that code. <strong>The strength of secure boot is bounded by the
code you choose to sign</strong>. In the absence of a fix for this errata, we will
not be using the TrustZone preset data. If other customers choose to continue
using TrustZone preset data they will need to be diligent about validating
their inputs to avoid introducing gaps in the security model. Oxide has a
commitment to open firmware to ensure our customers can have confidence in
what code we will be signing to run on their machines.</p></div></div><div><h2 data-sectnum="">Timeline</h2><div><div><h3 data-sectnum="..">2023-08-16</h3><div><p>Oxide discovers issue while reviewing image settings</p></div></div><div><h3 data-sectnum="..">2023-08-21</h3><div><p>Oxide discloses issue to NXP PSIRT with a disclosure deadline of 2023-11-20</p></div></div><div><h3 data-sectnum="..">2023-08-21</h3><div><p>Oxide PSIRT acknowledges receipt</p></div></div><div><h3 data-sectnum="..">2023-10-11</h3><div><p>NXP requests meeting to discuss the report with Oxide</p></div></div><div><h3 data-sectnum="..">2023-10-19</h3><div><p>Oxide and NXP meet to discuss the reported issues</p></div></div><div><h3 data-sectnum="..">2023-10-23</h3><div><p>Oxide suggests documentation clarifications</p></div></div><div><h3 data-sectnum="..">2023-10-27</h3><div><p>NXP agress to issue an errata</p></div></div><div><h3 data-sectnum="..">2023-11-20</h3><div><p>Oxide publishes this blog post as a disclosure</p></div></div></div></div></div></div></div></div></div>
  </body>
</html>
