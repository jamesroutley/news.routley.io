<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matt.might.net/articles/26-languages-part1/">Original</a>
    <h1>26 Programming Languages in 25 Days</h1>
    
    <div id="readability-page-1" class="page"><div id="main-abstract">
   <p>Since making a sudden leap from computer science to academic medicine about seven years ago, I haven’t programmed as much.</p>

<p>I love what I do in medicine and biology, and I love helping patients.</p>

<p>But, I have missed programming – and programming languages.</p>

<p>Then I came across the <a href="https://adventofcode.com/">Advent of Code</a> on <a href="https://mathstodon.xyz/@mattmight">Mastodon</a> – a series of daily two-part puzzles for programmers that runs for 25 days.</p>

<p>On a whim, I <a href="https://github.com/mattmight/advent-of-code-2022/tree/main/day-1">solved the Day 1 puzzle using awk</a>.</p>

<p>I <a href="https://github.com/mattmight/advent-of-code-2022/tree/main/day-2">solved Day 2 in TeX</a> (which underpins LaTeX) to reboot an old skill.</p>

<p>After that, I wondered if I could solve each of the 25 puzzles using a different programming language every day.</p>

<p>So, <a href="https://github.com/mattmight/advent-of-code-2022">I did</a>.</p>

<p><img src="https://matt.might.net/articles/26-languages-part1/images/2022-advent-of-code-completed-small.png"/></p><p>In the end:</p>

<ul>
<li><p> on 12 days, I had to learn a new programming language from scratch, and then use it to solve that day’s puzzle;</p></li>
<li><p> on 4 days, I used languages where I had very little experience; and</p></li>
<li><p> on the other 9 days, I used languages I had known well at some point.</p></li>
</ul>

<p>Ultimately, I used 26 languages, because I combined two on Day 21 (sed and bc), turning the experience into a rapid-fire “breadth-first search” of programming language space.</p>

<p>Learning how to learn a new language became the key meta-learning.</p>

<p>And, it’s a great way to build an appreciation of the relative strengths and intended domains of different languages.</p>

<p>If you’d like to try the breadth-first search yourself, I have distilled advice on the strategy, tactics and logistics involved in using a new programming language every day for 25 days.</p>
  </div><div id="main-content">
  <h2 id="strategicplanning">Strategic planning</h2>

<p>On Day 3, I looked back at some previous years of Advent of Code to get a sense of the problems.</p>

<p>I noticed the problems escalate in difficulty (on average) each day.</p>

<p>The <a href="https://adventofcode.com/2022/stats">completion statistics</a> support that observation too.</p>

<p>So, as a contest-wide strategy, I ranked languages by their power (relative to my ability in them),
where ranking was roughly the product of:</p>

<ol>
<li> my experience and comfort with the language; and</li>
<li> its expressiveness.</li>
</ol>

<p>For example, I’ve done a lot of programming in Scala (over 10 years ago, anyway), and Scala is a highly expressive language.</p>

<p>So, I pushed Scala toward the end of my list (using it ultimately on Day 24).</p>

<p>In contrast, I moved C toward the beginning of the list, because even though I have plenty of experience writing C code, it’s a painful language in which to do much of anything.</p>

<p>Similarly, I moved MATLAB toward the very beginning because I didn’t have any experience in it, and by reputation, it seemed clunky and difficult for tasks outside its core domain.</p>

<p>Were I to do it over, I’d probably save truly novel languages for prior to day 15, and go with my best languages for day 16 and onward.</p>

<p>The difficulty on the first 15 days was almost perfectly calibrated for kicking the tires on a new language.</p>

<h3 id="adailysorting">A daily sorting</h3>

<p>Each day, I did some re-sorting of the list, trying to use the “minimum viable language” for that day.</p>

<p>In the end, here’s how it unfolded, along with my experience in that language:</p>

<pre><code>Day 01: Awk          [minor experience]
Day 02: LaTeX        [minor experience (as programming language)] 
Day 03: C            [extensive experience]
Day 04: Java         [extensive experience]
Day 05: MATLAB       [no experience]

Day 06: C#           [no experience]
Day 07: Ruby         [no experience]
Day 08: Julia        [no experience]
Day 09: Bash         [extensive experience]
Day 10: vimscript    [no experience]

Day 11: C++          [no experience (beyond meta-programming)]
Day 12: R            [no experience]
Day 13: JavaScript   [extensive experience]
Day 14: Erlang       [no experience]
Day 15: Go           [no experience]

Day 16: Python       [minor experience]
Day 17: Standard ML  [extensive experience] 
Day 18: PHP          [extensive experience]
Day 19: Common Lisp  [no experience]
Day 20: TypeScript   [no experience]

Day 21: sed &amp; bc     [minor experience]
Day 22: Lua          [no experience]
Day 23: Haskell      [extensive experience]
Day 24: Scala        [extensive experience]
Day 25: Racket       [extensive experience]
</code></pre>

<h3 id="thereserves">The reserves</h3>

<p>Throughout the contest, I also updated a “primary reserve” of languages I could pull out to use for particularly hard problem if the language I’d planned for that day proved too tedious or cumbersome.</p>

<p>Here are the languages I still had in the primary reserve at the end:</p>

<pre><code>F#
Ocaml
Rust
Perl
Swift
Clojure
Smalltalk
</code></pre>

<p>For example, Standard ML had been in my primary reserve on <a href="https://adventofcode.com/2022/day/17">Day 17</a>.</p>

<p>I had tentatively penciled in PHP for Day 17.</p>

<p>But, when I looked at the problem, my hunch was that PHP was going to turn painful quickly, whereas a more functional approach was well-suited.</p>

<p>It seemed worth using up a “high-value” language.</p>

<p>(And, when part 2 was revealed for Day 17, this proved to be a wise choice.)</p>

<p>I had a “secondary reserve” too – languages that might be well-suited for a particular problem, and these were the ones left at the end:</p>

<pre><code>Elixir 
Perl6/Raku
Elm
D
Emacs lisp
Groovy
Tcl
Kotlin
Dart
Objective-C
Prolog
</code></pre>

<p>In retrospect, I was probably overly cautious, since plenty of “high value” languages remained at the end.</p>

<p>I kept a “probably not” list too, of languages that could be fun to use but probably not practical:</p>

<pre><code>APL / J
Prolog
Forth
m4
COBOL
Fortran
Ada
</code></pre>

<p>These probably would have been fine for the early problems (day 10 or earlier).</p>

<h2 id="logisticsforalanguageaday">Logistics for a language a day</h2>

<p>Using a different language every day meant:</p>

<ul>
<li> getting these languages installed on my machine;</li>
<li> finding a suitable environment in which to program them; and</li>
<li> pre-programming a little in advance in each language.</li>
</ul>

<h3 id="homebrewtotherescue">Homebrew to the rescue</h3>

<p>For the most part, homebrew solved the installation problem.</p>

<p>Almost every language had a homebrew-based option.</p>

<h3 id="vimasuniversalide">vim as universal IDE</h3>

<p>I knew I didn’t have time to learn a new language <em>and</em> a new IDE every day, so I used <code>vim</code> and
<code>make</code> for my universal IDE.</p>

<p>The only exception was that I couldn’t figure out how to not use Visual Studio for C#, so I just went with it.</p>

<p>I used to use emacs, and this would have been a fine choice as well.</p>

<h3 id="writingcatineverylanguageinadvance">Writing <code>cat</code> in every language in advance</h3>

<p>For languages I had a reasonable chance of using at some point, I wrote a
simple program that printed out the contents of a file to stdout.</p>

<p>This allowed a pre-exploration of the languages, and it gave me stub projects with skeleton Makefiles from which to start the puzzles.</p>

<h2 id="tacticsforusinganewlanguagequickly">Tactics for using a new language quickly</h2>

<p>I wasn’t going for the fastest completion time on any of these days, nor was I going for the shortest solution.</p>

<p>However, given personal and professional constraints, I had one to two hours to work on the puzzles each day, and these constraints evolved specific tactics.</p>

<h3 id="tactic:sleep">Tactic: Sleep</h3>

<p>Well-timed sleep was probably the most important thing I did.</p>

<p>I stayed up each night until the problem was released (11pm my time), but I didn’t try to code up the solution right away.</p>

<p>Instead, I read the problem description before bed and then thought about how to solve it while falling asleep.</p>

<p>I usually woke up every morning with a full sketch of the solution in my head, or something close to it.</p>

<p>Using sleep to do the heavy lifting on algorithm design meant I could utilize waking hours for learning the relevant bits of the language.</p>

<h3 id="tactic:focusonthealgorithm">Tactic: Focus on the algorithm</h3>

<p>With at least a rough sketch of the solution in my head from sleep, I focused on
describing the solution – usually in pseudocode or in discrete mathematics.</p>

<p>Where possible, I tried to describe the algorithm in purely functional terms, so that I could make a <a href="https://matt.might.net/articles/discrete-math-and-code/">direct translation from the math into code</a>.</p>

<h3 id="tactic:pickthelanguagefamilyfirst">Tactic: Pick the language family first</h3>

<p>Once I had the algorithm, I tried to figure out the best language <em>family</em>.</p>

<p>Would it be easier in a statically typed language or a dynamically typed language?</p>

<p>Would it be amenable to a purely (or mostly) functional solution, or would it be more naturally solved using side effects?</p>

<p>Was it possible or advantageous to use a logic-programming language?</p>

<p>Could it be solved with a domain-specific language?</p>

<h3 id="tactic:selecttheminimumviablelanguage">Tactic: Select the minimum viable language</h3>

<p>After I had a sense of what kind of language would make it easiest to implement the solution,
I tried to pick the minimum viable member of that family that remained on my lists.</p>

<h3 id="tactic:exploituniversaldatastructures">Tactic: Exploit universal data structures</h3>

<p>When writing down the algorithm, I tended to focus on the universal data structures I knew I could either find in any language or quickly recreate in any language: tuples, sets, lists, (multidimensional) vectors/arrays, associative arrays/dictionaries, ordered-key maps, functions and hash tables.</p>

<p>And, I usually launched a rapid fire series of Google queries like “how to implement <em>X</em> in <em>language Y</em>” for every data structure <em>X</em> that I used in the design.</p>

<h3 id="tactic:dotranslationmorethanoptimization">Tactic: Do translation more than optimization</h3>

<p>I focused my attention on getting a translation of the algorithm up and running in the target language first rather than trying to learn the best way to represent that algorithm in the target language.</p>

<p>If there was time remaining, I might go back and try to learn better ways to do what I’d done in that language, but only if there was time.</p>

<p>This meant I didn’t always get to exploit or learn all of the cool features of a language.</p>

<h3 id="tactic:proactivelylearninglinguisticquirks">Tactic: Proactively learning linguistic quirks</h3>

<p>I was often tripped up by quirks in a language.</p>

<p>Ironically, I was so often tripped up that I benefited more from proactively searching up the quirks of a language than looking up the cool or expressive features of the language.</p>

<p>I made a habit of searching for known warts or quirks in each language, just to know what to guard against, and where to look first for bugs when something didn’t work.</p>

<p>Frequent offenders for wartiness were implicit value conversions; what counted as false (or true); and 1-based/0-based array indexing.</p>

<h3 id="tactic:hard-codetheinputtostartthenparseitlater">Tactic: Hard-code the input to start; then parse it later</h3>

<p>For most of the problems, it was much faster to hard-code the problem input as literal value (after some manipulation in vim or with sed) than it was to write a parser.</p>

<p>Early on, I had spent a lot of time writing a parser or tokenizer first, and then started on the puzzle proper.</p>

<p>Hard-coding the input let me start solving the real problem, building up a working familiarity with the language before going back (or not!) to properly parse the input from a file.</p>

<h2 id="finalthoughts">Final thoughts</h2>

<p>I highly recommend Advent of Code to anyone looking to sharpen (or re-sharpen) their programming skills.</p>

<p>It is exceptionally well done.</p>

<p>And, if you want to attempt your own bread-first search of programming languages, it is an excellent way to do so!</p>
  </div></div>
  </body>
</html>
