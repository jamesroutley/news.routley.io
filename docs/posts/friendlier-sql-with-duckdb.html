<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duckdb.org/2022/05/04/friendlier-sql.html">Original</a>
    <h1>Friendlier SQL with DuckDB</h1>
    
    <div id="readability-page-1" class="page"><div>
		
		<div>
		
			<div>
				<div>
					
						<div>
							<p><span>2022-05-04</span><span>Alex Monahan</span></p>
							
							<p><img src="https://duckdb.org/images/blog/duck_chewbacca.png" alt="Chewbacca_the_duck" title="Chewbacca the duck is pretty friendly" width="200"/></p>

<p>An elegant user experience is a key design goal of DuckDB. This goal guides much of DuckDB’s architecture: it is simple to install, seamless to integrate with other data structures like Pandas, Arrow, and R Dataframes, and requires no dependencies. Parallelization occurs automatically, and if a computation exceeds available memory, data is gracefully buffered out to disk. And of course, DuckDB’s processing speed makes it easier to get more work accomplished.</p>

<p>However, SQL is not famous for being user-friendly. DuckDB aims to change that! DuckDB includes both a Relational API for dataframe-style computation, and a highly Postgres-compatible version of SQL. If you prefer dataframe-style computation, we would love your feedback on <a href="https://github.com/duckdb/duckdb/issues/2000">our roadmap</a>. If you are a SQL fan, read on to see how DuckDB is bringing together both innovation and pragmatism to make it easier to write SQL in DuckDB than anywhere else. Please reach out on <a href="https://github.com/duckdb/duckdb/discussions">GitHub</a> or <a href="https://discord.gg/vukK4xp7Rd">Discord</a> and let us know what other features would simplify your SQL workflows. Join us as we teach an old dog new tricks!
<!--more--></p>
      <h3 id="select--exclude">
        
        <a href="#select--exclude">SELECT * EXCLUDE</a>
        
      </h3>
    
<p>A traditional SQL <code>SELECT</code> query requires that requested columns be explicitly specified, with one notable exception: the <code>*</code> wildcard. <code>SELECT *</code> allows SQL to return all relevant columns. This adds tremendous flexibility, especially when building queries on top of one another. However, we are often interested in <em>almost</em> all columns. In DuckDB, simply specify which columns to <code>EXCLUDE</code>:</p>
<div><div><pre><code><span>SELECT</span> <span>*</span> <span>EXCLUDE</span> <span>(</span><span>jar_jar_binks</span><span>,</span> <span>midichlorians</span><span>)</span> <span>FROM</span> <span>star_wars</span>
</code></pre></div></div>
<p>Now we can save time repeatedly typing all columns, improve code readability, and retain flexibility as additional columns are added to underlying tables.</p>

<p>DuckDB’s implementation of this concept can even handle exclusions from multiple tables within a single statement:</p>
<div><div><pre><code><span>SELECT</span> 
    <span>sw</span><span>.</span><span>*</span> <span>EXCLUDE</span> <span>(</span><span>jar_jar_binks</span><span>,</span> <span>midichlorians</span><span>),</span>
    <span>ff</span><span>.</span><span>*</span> <span>EXCLUDE</span> <span>cancellation</span>
<span>FROM</span> <span>star_wars</span> <span>sw</span><span>,</span> <span>firefly</span> <span>ff</span>
</code></pre></div></div>
      <h3 id="select--replace">
        
        <a href="#select--replace">SELECT * REPLACE</a>
        
      </h3>
    
<p>Similarly, we often wish to use all of the columns in a table, aside from a few small adjustments. This would also prevent the use of <code>*</code> and require a list of all columns, including those that remain unedited. In DuckDB, easily apply changes to a small number of columns with <code>REPLACE</code>:</p>
<div><div><pre><code><span>SELECT</span> 
    <span>*</span> <span>REPLACE</span> <span>(</span><span>movie_count</span><span>+</span><span>3</span> <span>as</span> <span>movie_count</span><span>,</span> <span>show_count</span><span>*</span><span>1000</span> <span>as</span> <span>show_count</span><span>)</span>
<span>FROM</span> <span>star_wars_owned_by_disney</span>
</code></pre></div></div>
<p>This allows views, CTE’s, or sub-queries to be built on one another in a highly concise way, while remaining adaptable to new underlying columns.</p>
      <h3 id="group-by-all">
        
        <a href="#group-by-all">GROUP BY ALL</a>
        
      </h3>
    
<p>A common cause of repetitive and verbose SQL code is the need to specify columns in both the <code>SELECT</code> clause and the <code>GROUP BY</code> clause. In theory this adds flexibility to SQL, but in practice it rarely adds value. DuckDB now offers the <code>GROUP BY</code> we all expected when we first learned SQL - just <code>GROUP BY ALL</code> columns in the <code>SELECT</code> clause that aren’t wrapped in an aggregate function!</p>
<div><div><pre><code><span>SELECT</span>
    <span>systems</span><span>,</span>
    <span>planets</span><span>,</span>
    <span>cities</span><span>,</span>
    <span>cantinas</span><span>,</span>
    <span>SUM</span><span>(</span><span>scum</span> <span>+</span> <span>villainy</span><span>)</span> <span>as</span> <span>total_scum_and_villainy</span>
<span>FROM</span> <span>star_wars_locations</span>
<span>GROUP</span> <span>BY</span> <span>ALL</span>
<span>-- GROUP BY systems, planets, cities, cantinas</span>
</code></pre></div></div>

<p>Now changes to a query can be made in only one place instead of two! Plus this prevents many mistakes where columns are removed from a <code>SELECT</code> list, but not from the <code>GROUP BY</code>, causing duplication.</p>

<p>Not only does this dramatically simplify many queries, it also makes the above <code>EXCLUDE</code> and <code>REPLACE</code> clauses useful in far more situations. Imagine if we wanted to adjust the above query by no longer considering the level of scum and villainy in each specific cantina:</p>
<div><div><pre><code><span>SELECT</span>
    <span>*</span> <span>EXCLUDE</span> <span>(</span><span>cantinas</span><span>,</span> <span>booths</span><span>,</span> <span>scum</span><span>,</span> <span>villainy</span><span>),</span>
    <span>SUM</span><span>(</span><span>scum</span> <span>+</span> <span>villainy</span><span>)</span> <span>as</span> <span>total_scum_and_villainy</span>
<span>FROM</span> <span>star_wars_locations</span>
<span>GROUP</span> <span>BY</span> <span>ALL</span>
<span>-- GROUP BY systems, planets, cities</span>
</code></pre></div></div>
<p>Now that is some concise and flexible SQL! How many of your <code>GROUP BY</code> clauses could be re-written this way?</p>
      <h3 id="order-by-all">
        
        <a href="#order-by-all">ORDER BY ALL</a>
        
      </h3>
    
<p>Another common cause for repetition in SQL is the <code>ORDER BY</code> clause. DuckDB and other RDBMSs have previously tackled this issue by allowing queries to specify the numbers of columns to <code>ORDER BY</code> (For example, <code>ORDER BY 1, 2, 3</code>). However, frequently the goal is to order by all columns in the query from left to right, and maintaining that numeric list when adding or subtracting columns can be error prone. In DuckDB, simply <code>ORDER BY ALL</code>:</p>
<div><div><pre><code><span>SELECT</span>
    <span>age</span><span>,</span>
    <span>sum</span><span>(</span><span>civility</span><span>)</span> <span>as</span> <span>total_civility</span>
<span>FROM</span> <span>star_wars_universe</span>
<span>ORDER</span> <span>BY</span> <span>ALL</span>
<span>-- ORDER BY age, total_civility</span>
</code></pre></div></div>
<p>This is particularly useful when building summaries, as many other client tools automatically sort results in this manner. DuckDB also supports <code>ORDER BY ALL DESC</code> to sort each column in reverse order, and options to specify <code>NULLS FIRST</code> or <code>NULLS LAST</code>.</p>
      <h3 id="column-aliases-in-where--group-by--having">
        
        <a href="#column-aliases-in-where--group-by--having">Column Aliases in WHERE / GROUP BY / HAVING</a>
        
      </h3>
    
<p>In many SQL dialects, it is not possible to use an alias defined in a <code>SELECT</code> clause anywhere but in the <code>ORDER BY</code> clause of that statement. This commonly leads to verbose CTE’s or subqueries in order to utilize those aliases. In DuckDB, a non-aggregate alias in the <code>SELECT</code> clause can be immediately used in the <code>WHERE</code> and <code>GROUP BY</code> clauses, and aggregate aliases can be used in the <code>HAVING</code> clause, even at the same query depth. No subquery needed!</p>

<div><div><pre><code><span>SELECT</span>
    <span>only_imperial_storm_troopers_are_so_precise</span> <span>as</span> <span>nope</span><span>,</span>
    <span>turns_out_a_parsec_is_a_distance</span> <span>as</span> <span>very_speedy</span><span>,</span>
    <span>SUM</span><span>(</span><span>mistakes</span><span>)</span> <span>as</span> <span>total_oops</span>
<span>FROM</span> <span>oops</span>
<span>WHERE</span>
    <span>nope</span> <span>=</span> <span>1</span>
<span>GROUP</span> <span>BY</span>
    <span>nope</span><span>,</span>
    <span>very_speedy</span>
<span>HAVING</span>
    <span>total_oops</span> <span>&gt;</span> <span>0</span>
</code></pre></div></div>
      <h3 id="case-insensitivity-while-maintaining-case">
        
        <a href="#case-insensitivity-while-maintaining-case">Case Insensitivity While Maintaining Case</a>
        
      </h3>
    
<p>DuckDB allows queries to be case insensitive, while maintaining the specified case as data flows into and out of the system. This simplifies queries within DuckDB while ensuring compatibility with external libraries.</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>mandalorian</span> <span>as</span> <span>SELECT</span> <span>1</span> <span>as</span> <span>&#34;THIS_IS_THE_WAY&#34;</span><span>;</span>
<span>SELECT</span> <span>this_is_the_way</span> <span>FROM</span> <span>mandalorian</span><span>;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>THIS_IS_THE_WAY</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
  </tbody>
</table>
      <h3 id="friendly-error-messages">
        
        <a href="#friendly-error-messages">Friendly Error Messages</a>
        
      </h3>
    
<p>Regardless of expertise, and despite DuckDB’s best efforts to understand our intentions, we all make mistakes in our SQL queries. Many RDBMSs leave you trying to use the force to detect an error. In DuckDB, if you make a typo on a column or table name, you will receive a helpful suggestion about the most similar name. Not only that, you will receive an arrow that points directly to the offending location within your query.</p>

<div><div><pre><code><span>select</span> <span>*</span> <span>from</span> <span>star_trek</span><span>;</span>
<span>Error</span><span>:</span> <span>Catalog</span> <span>Error</span><span>:</span> <span>Table</span> <span>with</span> <span>name</span> <span>star_trek</span> <span>does</span> <span>not</span> <span>exist</span><span>!</span>
<span>Did</span> <span>you</span> <span>mean</span> <span>&#34;star_wars&#34;</span><span>?</span>
<span>LINE</span> <span>1</span><span>:</span> <span>select</span> <span>*</span> <span>from</span> <span>star_trek</span><span>;</span>
                      <span>^</span>
</code></pre></div></div>
<p>(Don’t worry, ducks and duck-themed databases still love some Trek as well).</p>

<p>DuckDB’s suggestions are even context specific. Here, we receive a suggestion to use the most similar column from the table we are querying.</p>

<div><div><pre><code><span>select</span> <span>long_ago</span> <span>from</span> <span>star_wars</span><span>;</span>
<span>Error</span><span>:</span> <span>Binder</span> <span>Error</span><span>:</span> <span>Referenced</span> <span>column</span> <span>&#34;long_ago&#34;</span> <span>not</span> <span>found</span> <span>in</span> <span>FROM</span> <span>clause</span><span>!</span>
<span>Candidate</span> <span>bindings</span><span>:</span> <span>&#34;star_wars.long_long_ago&#34;</span>
<span>LINE</span> <span>1</span><span>:</span> <span>select</span> <span>long_ago</span> <span>from</span> <span>star_wars</span><span>;</span>
               <span>^</span>
</code></pre></div></div>
      <h3 id="string-slicing">
        
        <a href="#string-slicing">String Slicing</a>
        
      </h3>
    
<p>Even as SQL fans, we know that SQL can learn a thing or two from newer languages. Instead of using bulky <code>SUBSTRING</code> functions, you can slice strings in DuckDB using bracket syntax. As a note, SQL is required to be 1-indexed, so that is a slight difference from other languages (although it keeps DuckDB internally consistent and similar to other DBs).</p>

<div><div><pre><code><span>SELECT</span> <span>&#39;I love you! I know&#39;</span><span>[:</span><span>-</span><span>3</span><span>]</span> <span>as</span> <span>nearly_soloed</span><span>;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>nearly_soloed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>I love you! I k</td>
    </tr>
  </tbody>
</table>
      <h3 id="simple-list-and-struct-creation">
        
        <a href="#simple-list-and-struct-creation">Simple List and Struct Creation</a>
        
      </h3>
    
<p>DuckDB provides nested types to allow more flexible data structures than the purely relational model would allow, while retaining high performance. To make them as easy as possible to use, creating a <code>LIST</code> (array) or a <code>STRUCT</code> (object) uses simpler syntax than other SQL systems. Data types are automatically inferred.</p>

<div><div><pre><code><span>SELECT</span>
    <span>[</span><span>&#39;A-Wing&#39;</span><span>,</span> <span>&#39;B-Wing&#39;</span><span>,</span> <span>&#39;X-Wing&#39;</span><span>,</span> <span>&#39;Y-Wing&#39;</span><span>]</span> <span>as</span> <span>starfighter_list</span><span>,</span>
    <span>{</span><span>name</span><span>:</span> <span>&#39;Star Destroyer&#39;</span><span>,</span> <span>common_misconceptions</span><span>:</span> <span>&#39;Can</span><span>&#39;&#39;</span><span>t in fact destroy a star&#39;</span><span>}</span> <span>as</span> <span>star_destroyer_facts</span>
</code></pre></div></div>
      <h3 id="list-slicing">
        
        <a href="#list-slicing">List Slicing</a>
        
      </h3>
    
<p>Bracket syntax may also be used to slice a <code>LIST</code>. Again, note that this is 1-indexed for SQL compatibility.</p>
<div><div><pre><code><span>SELECT</span> 
    <span>starfighter_list</span><span>[</span><span>2</span><span>:</span><span>2</span><span>]</span> <span>as</span> <span>dont_forget_the_b_wing</span> 
<span>FROM</span> <span>(</span><span>SELECT</span> <span>[</span><span>&#39;A-Wing&#39;</span><span>,</span> <span>&#39;B-Wing&#39;</span><span>,</span> <span>&#39;X-Wing&#39;</span><span>,</span> <span>&#39;Y-Wing&#39;</span><span>]</span> <span>as</span> <span>starfighter_list</span><span>);</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>dont_forget_the_b_wing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[B-Wing]</td>
    </tr>
  </tbody>
</table>
      <h3 id="struct-dot-notation">
        
        <a href="#struct-dot-notation">Struct Dot Notation</a>
        
      </h3>
    
<p>Use convenient dot notation to access the value of a specific key in a DuckDB <code>STRUCT</code> column. If keys contain spaces, double quotes can be used.</p>

<div><div><pre><code><span>SELECT</span> 
    <span>planet</span><span>.</span><span>name</span><span>,</span>
    <span>planet</span><span>.</span><span>&#34;Amount of sand&#34;</span> 
<span>FROM</span> <span>(</span><span>SELECT</span> <span>{</span><span>name</span><span>:</span> <span>&#39;Tatooine&#39;</span><span>,</span> <span>&#39;Amount of sand&#39;</span><span>:</span> <span>&#39;High&#39;</span><span>}</span> <span>as</span> <span>planet</span><span>)</span>
</code></pre></div></div>
      <h3 id="trailing-commas">
        
        <a href="#trailing-commas">Trailing Commas</a>
        
      </h3>
    
<p>Have you ever removed your final column from a SQL <code>SELECT</code> and been met with an error, only to find you needed to remove the trailing comma as well!? Never? Ok, Jedi… On a more serious note, this feature is an example of DuckDB’s responsiveness to the community. In under 2 days from seeing this issue in a tweet (not even about DuckDB!), this feature was already built, tested, and merged into the primary branch. You can include trailing commas in many places in your query, and we hope this saves you from the most boring but frustrating of errors!</p>

<div><div><pre><code><span>SELECT</span>
    <span>x_wing</span><span>,</span>
    <span>proton_torpedoes</span><span>,</span>
    <span>--targeting_computer</span>
<span>FROM</span> <span>luke_whats_wrong</span>
<span>GROUP</span> <span>BY</span>
    <span>x_wing</span><span>,</span>
    <span>proton_torpedoes</span><span>,</span>
</code></pre></div></div>
      <h3 id="function-aliases-from-other-databases">
        
        <a href="#function-aliases-from-other-databases">Function Aliases from Other Databases</a>
        
      </h3>
    
<p>For many functions, DuckDB supports multiple names in order to align with other database systems. After all, ducks are pretty versatile - they can fly, swim, and walk! Most commonly, DuckDB supports PostgreSQL function names, but many SQLite names are supported, as well as some from other systems. If you are migrating your workloads to DuckDB and a different function name would be helpful, please reach out - they are very easy to add as long as the behavior is the same! See our <a href="https://duckdb.org/docs/sql/functions/overview">functions documentation</a> for details.</p>

<div><div><pre><code><span>SELECT</span>
    <span>&#39;Use the Force, Luke&#39;</span><span>[:</span><span>13</span><span>]</span> <span>as</span> <span>sliced_quote_1</span><span>,</span>
    <span>substr</span><span>(</span><span>&#39;I am your father&#39;</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>)</span> <span>as</span> <span>sliced_quote_2</span><span>,</span>
    <span>substring</span><span>(</span><span>&#39;Obi-Wan Kenobi, you</span><span>&#39;&#39;</span><span>re my only hope&#39;</span><span>,</span><span>17</span><span>,</span><span>100</span><span>)</span> <span>as</span> <span>sliced_quote_3</span>
</code></pre></div></div>
      <h3 id="auto-increment-duplicate-column-names">
        
        <a href="#auto-increment-duplicate-column-names">Auto-Increment Duplicate Column Names</a>
        
      </h3>
    
<p>As you are building a query that joins similar tables, you’ll often encounter duplicate column names. If the query is the final result, DuckDB will simply return the duplicated column names without modifications. However, if the query is used to create a table, or nested in a subquery or Common Table Expression (where duplicate columns are forbidden by other databases!), DuckDB will automatically assign new names to the repeated columns to make query prototyping easier.</p>

<div><div><pre><code><span>SELECT</span>
    <span>*</span>
<span>FROM</span> <span>(</span>
    <span>SELECT</span>
        <span>s1</span><span>.</span><span>tie_fighter</span><span>,</span>
        <span>s2</span><span>.</span><span>tie_fighter</span>
    <span>FROM</span> <span>squadron_one</span> <span>s1</span>
    <span>JOIN</span> <span>squadron_two</span> <span>s2</span>
        <span>ON</span> <span>1</span><span>=</span><span>1</span>
    <span>)</span> <span>theyre_coming_in_too_fast</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>tie_fighter</th>
      <th>tie_fighter:1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>green_one</td>
      <td>green_two</td>
    </tr>
  </tbody>
</table>
      <h3 id="implicit-type-casts">
        
        <a href="#implicit-type-casts">Implicit Type Casts</a>
        
      </h3>
    
<p>DuckDB believes in using specific data types for performance, but attempts to automatically cast between types whenever necessary. For example, when joining between an integer and a varchar, DuckDB will automatically cast them to be the same type and complete the join successfully. A <code>List</code> or <code>IN</code> expression may also be created with a mixture of types, and they will be automatically cast as well. Also, <code>INT</code> and <code>BIGINT</code> are interchangeable, and thanks to DuckDB’s new storage compression, a <code>BIGINT</code> usually doesn’t even take up any extra space! Now you can store your data as the optimal data type, but use it easily for the best of both!</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>sith_count_int</span> <span>as</span> <span>SELECT</span> <span>2</span><span>::</span><span>INT</span> <span>as</span> <span>sith_count</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>sith_count_varchar</span> <span>as</span> <span>SELECT</span> <span>2</span><span>::</span><span>VARCHAR</span> <span>as</span> <span>sith_count</span><span>;</span>

<span>SELECT</span> 
    <span>*</span> 
<span>FROM</span> <span>sith_count_int</span> <span>s_int</span> 
<span>JOIN</span> <span>sith_count_varchar</span> <span>s_char</span> 
    <span>on</span> <span>s_int</span><span>.</span><span>sith_count</span> <span>=</span> <span>s_char</span><span>.</span><span>sith_count</span><span>;</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>sith_count</th>
      <th>sith_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
      <h3 id="other-friendly-features">
        
        <a href="#other-friendly-features">Other Friendly Features</a>
        
      </h3>
    
<p>There are many other features of DuckDB that make it easier to analyze data with SQL!</p>

<p>DuckDB <a href="https://duckdb.org/2022/01/06/time-zones.html">makes working with time easier in many ways</a>, including by accepting multiple different syntaxes (from other databases) for the <a href="https://duckdb.org/docs/sql/data_types/interval"><code>INTERVAL</code> data type</a> used to specify a length of time.</p>

<p>DuckDB also implements multiple SQL clauses outside of the traditional core clauses including the <a href="https://duckdb.org/docs/sql/query_syntax/sample"><code>SAMPLE</code> clause</a> for quickly selecting a random subset of your data and the <a href="https://duckdb.org/docs/sql/query_syntax/qualify"><code>QUALIFY</code> clause</a> that allows filtering of the results of window functions (much like a <code>HAVING</code> clause does for aggregates).</p>

<p>The <a href="https://duckdb.org/docs/sql/statements/select"><code>DISTINCT ON</code> clause</a> allows DuckDB to select unique combinations of a subset of the columns in a <code>SELECT</code> clause, while returning the first row of data for columns not checked for uniqueness.</p>
      <h3 id="ideas-for-the-future">
        
        <a href="#ideas-for-the-future">Ideas for the Future</a>
        
      </h3>
    
<p>In addition to what has already been implemented, several other improvements have been suggested. Let us know if one would be particularly useful - we are flexible with our roadmap! If you would like to contribute, we are very open to PRs and you are welcome to reach out on <a href="https://github.com/duckdb/duckdb">GitHub</a> or <a href="https://discord.gg/vukK4xp7Rd">Discord</a> ahead of time to talk through a new feature’s design.</p>

<ul>
  <li>Choose columns via regex
    <ul>
      <li>Decide which columns to select with a pattern rather than specifying columns explicitly</li>
      <li>Clickhouse supports this with the <a href="https://clickhouse.com/docs/en/sql-reference/statements/select/#columns-expression"><code>COLUMNS</code> expression</a></li>
    </ul>
  </li>
  <li>Incremental column aliases
    <ul>
      <li>Refer to previously defined aliases in subsequent calculated columns rather than re-specifying the calculations</li>
    </ul>
  </li>
  <li>Dot operators for JSON types
    <ul>
      <li>The JSON extension is brand new (<a href="https://duckdb.org/docs/extensions/json">see our documentation!</a>) and already implements friendly <code>-&gt;</code> and <code>-&gt;&gt;</code> syntax</li>
    </ul>
  </li>
</ul>

<p>Thanks for checking out DuckDB! May the Force be with you…</p>

							<p><a href="https://duckdb.org/news/">back to news archive <span></span></a>
						</p></div>
					
				</div>
			</div>
			
			</div></div></div>
  </body>
</html>
