<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dotat.at/@/2024-10-22-tmp.html">Original</a>
    <h1>Against /tmp</h1>
    
    <div id="readability-page-1" class="page"><article>
  <p>I commented on Lobsters that <a href="https://lobste.rs/s/bzg0kq/how_do_you_deploy_10_seconds#c_ihmo1o"><code>/tmp</code> is usually a bad idea</a>,
which caused some surprise. I suppose <code>/tmp</code> security bugs were common
in the 1990s when I was learning Unix, but they are pretty rare now so
I can see why less grizzled hackers might not be familiar with the
problems.</p>
<p>I guess that’s some kind of success, but sadly the fixes have left
behind a lot of scar tissue because they didn’t address the underlying
problem: <code>/tmp</code> should not exist.</p>
<blockquote>
<p>It’s a bad idea because it’s shared global mutable state that
crosses security boundaries. There’s a ton of complexity at all
levels of unix (filesystems, kernel APIs, libc, shell, admin
scripts) that only exists as a workaround for the dangers caused by
making <code>/tmp</code> shared.</p>
</blockquote>
<h2><a name="sticky-bit" href="#sticky-bit">sticky bit</a></h2>
<p>I think the earliest and lowest-level workaround is the sticky bit.</p>
<p>The sticky bit is mode bit 01000 in <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/chmod.html">unix file permissions</a>. It
is printed as the <code>t</code> instead of <code>x</code> in <code>rwt</code>.</p>
<pre><code>    drwxrwxrwt  5 root  wheel  160 Oct 22 10:22 /tmp/
</code></pre>
<p>Originally in the 1970s the sticky bit was invented to speed up
frequently-used programs such as the shell: the sticky bit indicated
to the kernel that the executable file should stick in core. This
functionality was made obsolete in the 1980s by filesystem page
caches.</p>
<p>The sticky bit was re-used to mean something else on directories, to
fix a security problem with <code>/tmp</code>.</p>
<p>On unix, permission to delete a file depends on write access to the
directory containing the file, independent of the file’s own
permissions.</p>
<p>So if a directory (such as <code>/tmp</code>) is world-writable, anyone can delete
any file in it.</p>
<p>This means <code>/tmp</code> was vulnerable to all sorts of accidental or malicious
trouble caused by users deleting each others’ files.</p>
<p>To fix this, <a href="https://man.freebsd.org/cgi/man.cgi?query=sticky">a file in a sticky directory may only be removed or
renamed by a user if the user has write permission for the directory
and the user is the owner of the file, the owner of the directory, or
the super-user</a>.</p>
<h2><a name="tmp-stupidity-in-c" href="#tmp-stupidity-in-c">tmp stupidity in C</a></h2>
<p>POSIX used to provide 5 (five!) ways to create a temporary file, three
of which (most of them!) you must never use and which have
subsequently been deprecated – except the do-not-use footgun <code>tmpnam</code>
which is still part of the C standard. Two more safe functions have
subsequently been added to support more complicated situations.</p>
<ul>
<li>bad: <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/mktemp.html">mktemp</a>, <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/tempnam.html">tempnam</a>, <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/tmpnam.html">tmpnam</a></li>
<li>ok: <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/mkstemp.html">mkstemp</a>, <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/tmpfile.html">tmpfile</a></li>
<li>new: <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/mkstemp.html">mkdtemp, mkostemp, mkstemp</a></li>
</ul>
<p>There are so many dangerous API design problems in those old functions!
I’m not going to waste time roasting them in detail because I can
cover the important points by discussing …</p>
<h2><a name="mkstemp-and-mkdtemp" href="#mkstemp-and-mkdtemp">mkstemp and mkdtemp</a></h2>
<p>The purpose of all these functions is to create a temporary file (or
directory) that doesn’t collide with other concurrent activity.</p>
<p>When you are creating a file in <code>/tmp</code> the risk is that another
malicious user can make you open a file under their control. To avoid
this vulnerability, you (or rather <code>mkstemp</code>) must:</p>
<ul>
<li>
<p>Generate an <em>unpredictable</em> filename.</p>
<p>It isn’t enough for the filename to be unique, it must contain
sufficient <em>secure</em> randomness that an adversary can’t win a race
and interfere.</p>
</li>
<li>
<p>Open the file with <code>O_CREAT</code> | <code>O_EXCL</code>.</p>
<p>This ensures the file has not already been created by another
friendly or malicious process, without any time-of-check /
time-of-use vulnerabilities. And it ensures that the file isn’t a
symlink pointing somewhere an attacker wants you to accidentally
corrupt.</p>
</li>
<li>
<p>Retry if open fails with <code>EEXIST</code>.</p>
<p>Together with the randomness in the name, this avoids
denial-of-service vulnerabilites.</p>
</li>
</ul>
<p>This is intricate and not entirely obvious, as you can tell from all
the previous failed attempts at functions that didn’t create temporary
files safely.</p>
<h2><a name="mktemp-in-shell" href="#mktemp-in-shell">mktemp in shell</a></h2>
<p>The <a href="https://man.freebsd.org/cgi/man.cgi?query=mktemp">mktemp(1)</a> command is a wrapper around mkstemp(3). (Slightly
confusingly it isn’t a wrapper around mktemp(3) because that would be
unsafe.) It was introduced by OpenBSD and it’s widely supported though
it isn’t yet in POSIX. Its manual page includes a nice rationale:</p>
<blockquote>
<p>The <code>mktemp</code> utility is provided to allow shell scripts to safely use
temporary files. Traditionally, many shell scripts take the name of
the program with the pid as a suffix and use that as a temporary
file name. This kind of naming scheme is predictable and the race
condition it creates is easy for an attacker to win. A safer, though
still inferior, approach is to make a temporary directory using
the same naming scheme. While this does allow one to guarantee that
a temporary file will not be subverted, it still allows a simple
denial of service attack. For these reasons it is suggested that
<code>mktemp</code> be used instead.</p>
</blockquote>
<p>Although shell scripts can’t avoid using the temporary file by name,
mktemp(1) is safe because it creates the file securely and an attacker
can’t interfere with it after that point. It’s OK to re-open a file
that you know is yours.</p>
<h2><a name="tmp-cleanup" href="#tmp-cleanup">tmp cleanup</a></h2>
<p>The last item on my list of regrets is “admin scripts”, an oblique
reference to <code>/tmp</code> cleanup jobs.</p>
<p>By its nature <code>/tmp</code> tends to accumulate junk, so it was common to have
cron jobs that would delete old files. (Less common now that computers
are much bigger.)</p>
<p>These scripts tended to have problems with time-of-check / time-of-use
vulnerabilities, careless handling of symlinks, and pulling the rug
out from under long-running programs that foolishly used <code>/tmp</code>. (Lots
more reasons these scripts are now less common!)</p>
<h2><a name="tmp-remedy" href="#tmp-remedy">tmp remedy</a></h2>
<p>So I’ve spent dozens of paragraphs outlining bugs and complications
related to <code>/tmp</code>. All of them could have been avoided if <code>/tmp</code> did not
exist, and everything would have been simpler as a result.</p>
<p>So where should temporary files go, if not in <code>/tmp</code>?</p>
<p>There should be per-user temporary directories in different per-user
locations. In fact, on some modern systems there <em>are</em> per-user
temporary directories! But this solution came several decades too
late.</p>
<p>If you have per-user <code>$TMPDIR</code> then temporary filenames can safely be
created using the simple mechanisms described in the mktemp(1)
rationale or used by the old deprecated C functions. There’s no need
to defend against an attacker who doesn’t have sufficient access to
mount an attack! There’s no need for sticky directories because there
aren’t any world-writable directories.</p>
<p>There’s a minor wrinkle that setuid programs would have to be more
careful about how they create temporary files, but setuid programs
have to be more careful about everything.</p>
<h2><a name="tmp-rationale" href="#tmp-rationale">tmp rationale</a></h2>
<p>So why wasn’t per-user <code>$TMPDIR</code> a thing back in the day?</p>
<p>Probably the main reason was path-dependence: <code>/tmp</code> was created and in
wide use before its problems became apparent, at which point it was
difficult to deprecate.</p>
<p>There are reasons 1990-ish-you didn’t want <code>$TMPDIR</code> to be in your
home directory:</p>
<ul>
<li>
<p><code>$HOME</code> might be on NFS so a local <code>$TMPDIR</code> might be faster</p>
</li>
<li>
<p><code>$TMPDIR</code> can be a way to get workspace beyond your disk quota</p>
</li>
<li>
<p><code>$HOME</code> might be on a filesystem that doesn’t support named pipes,
so your X11 and SSH agent sockets live in <code>$TMPDIR</code> instead</p>
</li>
</ul>
<p>The fix, way back when, should have been for login(8) to create a
per-user temporary directory in a sensible place before it drops
privilege, and set <code>$TMPDIR</code> so the user’s shell and child processes
can find it.</p>
<h2><a name="more-tmp" href="#more-tmp">more tmp</a></h2>
<p><em>edited to add…</em></p>
<p>Of course, we can’t go back in time to get rid of <code>/tmp</code>, so efforts
continue to make it safer by making things more complicated.</p>
<p>For example, on Linux there are a couple of features that use
filesystem namespaces to hide the global <code>/tmp</code> with a user-owned
<code>/tmp</code> overlay: <a href="https://www.man7.org/linux/man-pages/man8/pam_namespace.8.html">pam_namespace</a> and <a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#PrivateTmp=">systemd <code>PrivateTmp</code></a>.</p>
<h2><a name="less-tmp" href="#less-tmp">less tmp</a></h2>
<p>I don’t think there’s any way to get rid of the complications I’ve
described in this post, as long as a <code>/tmp</code> directory exists – which
will be forever. Unix programs have to assume <code>/tmp</code> is unsafe, so the
security mechanisms in <code>mkstemp()</code> have to stay. We can’t remove
sticky bit support from the kernel as long as there’s a global <code>/tmp</code>,
even if it is sometimes hidden by an overlay.</p>
<p>Personally, when writing software I avoid using <code>/tmp</code>. I create a
working directory somewhere that <em>isn’t</em> world writable and use that
instead.</p>

</article></div>
  </body>
</html>
